[
    
    {
        "description": "Little Sofia is in fourth grade. Today in the geometry lesson she learned about segments and squares. On the way home, she decided to draw $n$ squares in the snow with a side length of $1$. For simplicity, we assume that Sofia lives on a plane and can draw only segments of length $1$, parallel to the coordinate axes, with vertices at integer points.\n\nIn order to draw a segment, Sofia proceeds as follows. If she wants to draw a vertical segment with the coordinates of the ends $(x, y)$ and $(x, y+1)$. Then Sofia looks if there is already a drawn segment with the coordinates of the ends $(x', y)$ and $(x', y+1)$ for some $x'$. If such a segment exists, then Sofia quickly draws a new segment, using the old one as a guideline. If there is no such segment, then Sofia has to take a ruler and measure a new segment for a long time. Same thing happens when Sofia wants to draw a horizontal segment, but only now she checks for the existence of a segment with the same coordinates $x$, $x+1$ and the differing coordinate $y$.\n\nFor example, if Sofia needs to draw one square, she will have to draw two segments using a ruler:  [Image] \n\nAfter that, she can draw the remaining two segments, using the first two as a guide:  [Image] \n\nIf Sofia needs to draw two squares, she will have to draw three segments using a ruler:  [Image] \n\nAfter that, she can draw the remaining four segments, using the first three as a guide:  [Image] \n\nSofia is in a hurry, so she wants to minimize the number of segments that she will have to draw with a ruler without a guide. Help her find this minimum number.\n\n\n-----Input-----\n\nThe only line of input contains a single integer $n$ ($1 \\le n \\le 10^{9}$), the number of squares that Sofia wants to draw.\n\n\n-----Output-----\n\nPrint single integer, the minimum number of segments that Sofia will have to draw with a ruler without a guide in order to draw $n$ squares in the manner described above.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n2\n\nInput\n2\n\nOutput\n3\n\nInput\n4\n\nOutput\n4",
        "task_name": "0290",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "n = int(input())\nprint(2 * (n.bit_length() - 1) + 2)\n",
        "correct": false,
        "task_id": "291",
        "depth": 0,
        "functions": 0
    },
    {
        "description": "Little Sofia is in fourth grade. Today in the geometry lesson she learned about segments and squares. On the way home, she decided to draw $n$ squares in the snow with a side length of $1$. For simplicity, we assume that Sofia lives on a plane and can draw only segments of length $1$, parallel to the coordinate axes, with vertices at integer points.\n\nIn order to draw a segment, Sofia proceeds as follows. If she wants to draw a vertical segment with the coordinates of the ends $(x, y)$ and $(x, y+1)$. Then Sofia looks if there is already a drawn segment with the coordinates of the ends $(x', y)$ and $(x', y+1)$ for some $x'$. If such a segment exists, then Sofia quickly draws a new segment, using the old one as a guideline. If there is no such segment, then Sofia has to take a ruler and measure a new segment for a long time. Same thing happens when Sofia wants to draw a horizontal segment, but only now she checks for the existence of a segment with the same coordinates $x$, $x+1$ and the differing coordinate $y$.\n\nFor example, if Sofia needs to draw one square, she will have to draw two segments using a ruler:  [Image] \n\nAfter that, she can draw the remaining two segments, using the first two as a guide:  [Image] \n\nIf Sofia needs to draw two squares, she will have to draw three segments using a ruler:  [Image] \n\nAfter that, she can draw the remaining four segments, using the first three as a guide:  [Image] \n\nSofia is in a hurry, so she wants to minimize the number of segments that she will have to draw with a ruler without a guide. Help her find this minimum number.\n\n\n-----Input-----\n\nThe only line of input contains a single integer $n$ ($1 \\le n \\le 10^{9}$), the number of squares that Sofia wants to draw.\n\n\n-----Output-----\n\nPrint single integer, the minimum number of segments that Sofia will have to draw with a ruler without a guide in order to draw $n$ squares in the manner described above.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n2\n\nInput\n2\n\nOutput\n3\n\nInput\n4\n\nOutput\n4",
        "task_name": "0290",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "import math\n\ndef min_segments(n):\n    min_segments_needed = float('inf')\n    \n    for a in range(1, int(math.sqrt(n)) + 1):\n        b = (n + a - 1) // a  # This is equivalent to math.ceil(n / a)\n        segments_needed = 2 * (a + b)\n        min_segments_needed = min(min_segments_needed, segments_needed)\n    \n    return min_segments_needed\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(min_segments(n))\n",
        "correct": false,
        "task_id": "291",
        "depth": 1,
        "functions": 1
    },
    {
        "description": "You are given two matrices $A$ and $B$. Each matrix contains exactly $n$ rows and $m$ columns. Each element of $A$ is either $0$ or $1$; each element of $B$ is initially $0$.\n\nYou may perform some operations with matrix $B$. During each operation, you choose any submatrix of $B$ having size $2 \\times 2$, and replace every element in the chosen submatrix with $1$. In other words, you choose two integers $x$ and $y$ such that $1 \\le x < n$ and $1 \\le y < m$, and then set $B_{x, y}$, $B_{x, y + 1}$, $B_{x + 1, y}$ and $B_{x + 1, y + 1}$ to $1$.\n\nYour goal is to make matrix $B$ equal to matrix $A$. Two matrices $A$ and $B$ are equal if and only if every element of matrix $A$ is equal to the corresponding element of matrix $B$.\n\nIs it possible to make these matrices equal? If it is, you have to come up with a sequence of operations that makes $B$ equal to $A$. Note that you don't have to minimize the number of operations.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($2 \\le n, m \\le 50$).\n\nThen $n$ lines follow, each containing $m$ integers. The $j$-th integer in the $i$-th line is $A_{i, j}$. Each integer is either $0$ or $1$.\n\n\n-----Output-----\n\nIf it is impossible to make $B$ equal to $A$, print one integer $-1$.\n\nOtherwise, print any sequence of operations that transforms $B$ into $A$ in the following format: the first line should contain one integer $k$ \u2014 the number of operations, and then $k$ lines should follow, each line containing two integers $x$ and $y$ for the corresponding operation (set $B_{x, y}$, $B_{x, y + 1}$, $B_{x + 1, y}$ and $B_{x + 1, y + 1}$ to $1$). The condition $0 \\le k \\le 2500$ should hold.\n\n\n-----Examples-----\nInput\n3 3\n1 1 1\n1 1 1\n0 1 1\n\nOutput\n3\n1 1\n1 2\n2 2\n\nInput\n3 3\n1 0 1\n1 0 1\n0 0 0\n\nOutput\n-1\n\nInput\n3 2\n0 0\n0 0\n0 0\n\nOutput\n0\n\n\n\n-----Note-----\n\nThe sequence of operations in the first example: $\\begin{matrix} 0 & 0 & 0 & & 1 & 1 & 0 & & 1 & 1 & 1 & & 1 & 1 & 1 \\\\ 0 & 0 & 0 & \\rightarrow & 1 & 1 & 0 & \\rightarrow & 1 & 1 & 1 & \\rightarrow & 1 & 1 & 1 \\\\ 0 & 0 & 0 & & 0 & 0 & 0 & & 0 & 0 & 0 & & 0 & 1 & 1 \\end{matrix}$",
        "task_name": "0114",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "n, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\nops = []\nfor i in range(n-1):\n    for j in range(m-1):\n        if A[i][j] == 1 and A[i+1][j] == 1 and A[i][j+1] == 1 and A[i+1][j+1] == 1:\n            continue\n        if A[i][j] == 1 or A[i+1][j] == 1 or A[i][j+1] == 1 or A[i+1][j+1] == 1:\n            ops.append((i+1, j+1))\n\nif len(ops) > 2500:\n    print(-1)\nelse:\n    print(len(ops))\n    for op in ops:\n        print(op[0], op[1])\n",
        "correct": false,
        "task_id": "115",
        "depth": 2,
        "functions": 0
    },
    {
        "description": "You are given two matrices $A$ and $B$. Each matrix contains exactly $n$ rows and $m$ columns. Each element of $A$ is either $0$ or $1$; each element of $B$ is initially $0$.\n\nYou may perform some operations with matrix $B$. During each operation, you choose any submatrix of $B$ having size $2 \\times 2$, and replace every element in the chosen submatrix with $1$. In other words, you choose two integers $x$ and $y$ such that $1 \\le x < n$ and $1 \\le y < m$, and then set $B_{x, y}$, $B_{x, y + 1}$, $B_{x + 1, y}$ and $B_{x + 1, y + 1}$ to $1$.\n\nYour goal is to make matrix $B$ equal to matrix $A$. Two matrices $A$ and $B$ are equal if and only if every element of matrix $A$ is equal to the corresponding element of matrix $B$.\n\nIs it possible to make these matrices equal? If it is, you have to come up with a sequence of operations that makes $B$ equal to $A$. Note that you don't have to minimize the number of operations.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($2 \\le n, m \\le 50$).\n\nThen $n$ lines follow, each containing $m$ integers. The $j$-th integer in the $i$-th line is $A_{i, j}$. Each integer is either $0$ or $1$.\n\n\n-----Output-----\n\nIf it is impossible to make $B$ equal to $A$, print one integer $-1$.\n\nOtherwise, print any sequence of operations that transforms $B$ into $A$ in the following format: the first line should contain one integer $k$ \u2014 the number of operations, and then $k$ lines should follow, each line containing two integers $x$ and $y$ for the corresponding operation (set $B_{x, y}$, $B_{x, y + 1}$, $B_{x + 1, y}$ and $B_{x + 1, y + 1}$ to $1$). The condition $0 \\le k \\le 2500$ should hold.\n\n\n-----Examples-----\nInput\n3 3\n1 1 1\n1 1 1\n0 1 1\n\nOutput\n3\n1 1\n1 2\n2 2\n\nInput\n3 3\n1 0 1\n1 0 1\n0 0 0\n\nOutput\n-1\n\nInput\n3 2\n0 0\n0 0\n0 0\n\nOutput\n0\n\n\n\n-----Note-----\n\nThe sequence of operations in the first example: $\\begin{matrix} 0 & 0 & 0 & & 1 & 1 & 0 & & 1 & 1 & 1 & & 1 & 1 & 1 \\\\ 0 & 0 & 0 & \\rightarrow & 1 & 1 & 0 & \\rightarrow & 1 & 1 & 1 & \\rightarrow & 1 & 1 & 1 \\\\ 0 & 0 & 0 & & 0 & 0 & 0 & & 0 & 0 & 0 & & 0 & 1 & 1 \\end{matrix}$",
        "task_name": "0114",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n\n    # Try to perform operations to match A\n    for i in range(n - 1):\n        for j in range(m - 1):\n            # Check if a 2x2 submatrix can be transformed\n            if A[i][j] == 1 and A[i][j+1] == 1 and A[i+1][j] == 1 and A[i+1][j+1] == 1:\n                B[i][j] = B[i][j+1] = B[i+1][j] = B[i+1][j+1] = 1\n                operations.append((i + 1, j + 1))\n\n    # Verify if B matches A\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return -1\n    \n    # Output the result\n    print(len(operations))\n    for op in operations:\n        print(op[0], op[1])\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    A = []\n    index = 2\n    for i in range(n):\n        row = []\n        for j in range(m):\n            row.append(int(data[index]))\n            index += 1\n        A.append(row)\n    \n    transform_matrix(n, m, A)\n",
        "correct": false,
        "task_id": "115",
        "depth": 2,
        "functions": 1
    },
    {
        "description": "Bear Limak wants to become the largest of bears, or at least to become larger than his brother Bob.\n\nRight now, Limak and Bob weigh a and b respectively. It's guaranteed that Limak's weight is smaller than or equal to his brother's weight.\n\nLimak eats a lot and his weight is tripled after every year, while Bob's weight is doubled after every year.\n\nAfter how many full years will Limak become strictly larger (strictly heavier) than Bob?\n\n\n-----Input-----\n\nThe only line of the input contains two integers a and b (1 \u2264 a \u2264 b \u2264 10)\u00a0\u2014 the weight of Limak and the weight of Bob respectively.\n\n\n-----Output-----\n\nPrint one integer, denoting the integer number of years after which Limak will become strictly larger than Bob.\n\n\n-----Examples-----\nInput\n4 7\n\nOutput\n2\n\nInput\n4 9\n\nOutput\n3\n\nInput\n1 1\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first sample, Limak weighs 4 and Bob weighs 7 initially. After one year their weights are 4\u00b73 = 12 and 7\u00b72 = 14 respectively (one weight is tripled while the other one is doubled). Limak isn't larger than Bob yet. After the second year weights are 36 and 28, so the first weight is greater than the second one. Limak became larger than Bob after two years so you should print 2.\n\nIn the second sample, Limak's and Bob's weights in next years are: 12 and 18, then 36 and 36, and finally 108 and 72 (after three years). The answer is 3. Remember that Limak wants to be larger than Bob and he won't be satisfied with equal weights.\n\nIn the third sample, Limak becomes larger than Bob after the first year. Their weights will be 3 and 2 then.",
        "task_name": "0291",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "a, b = map(int, input().split())\nyears = 0\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\nprint(years)\n",
        "correct": true,
        "task_id": "292",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "Bear Limak wants to become the largest of bears, or at least to become larger than his brother Bob.\n\nRight now, Limak and Bob weigh a and b respectively. It's guaranteed that Limak's weight is smaller than or equal to his brother's weight.\n\nLimak eats a lot and his weight is tripled after every year, while Bob's weight is doubled after every year.\n\nAfter how many full years will Limak become strictly larger (strictly heavier) than Bob?\n\n\n-----Input-----\n\nThe only line of the input contains two integers a and b (1 \u2264 a \u2264 b \u2264 10)\u00a0\u2014 the weight of Limak and the weight of Bob respectively.\n\n\n-----Output-----\n\nPrint one integer, denoting the integer number of years after which Limak will become strictly larger than Bob.\n\n\n-----Examples-----\nInput\n4 7\n\nOutput\n2\n\nInput\n4 9\n\nOutput\n3\n\nInput\n1 1\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first sample, Limak weighs 4 and Bob weighs 7 initially. After one year their weights are 4\u00b73 = 12 and 7\u00b72 = 14 respectively (one weight is tripled while the other one is doubled). Limak isn't larger than Bob yet. After the second year weights are 36 and 28, so the first weight is greater than the second one. Limak became larger than Bob after two years so you should print 2.\n\nIn the second sample, Limak's and Bob's weights in next years are: 12 and 18, then 36 and 36, and finally 108 and 72 (after three years). The answer is 3. Remember that Limak wants to be larger than Bob and he won't be satisfied with equal weights.\n\nIn the third sample, Limak becomes larger than Bob after the first year. Their weights will be 3 and 2 then.",
        "task_name": "0291",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "a, b = map(int, input().split())\n\nyears = 0\n\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)\n",
        "correct": true,
        "task_id": "292",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "Arpa is researching the Mexican wave.\n\nThere are n spectators in the stadium, labeled from 1 to n. They start the Mexican wave at time 0. \n\n  At time 1, the first spectator stands.  At time 2, the second spectator stands.  ...  At time k, the k-th spectator stands.  At time k + 1, the (k + 1)-th spectator stands and the first spectator sits.  At time k + 2, the (k + 2)-th spectator stands and the second spectator sits.  ...  At time n, the n-th spectator stands and the (n - k)-th spectator sits.  At time n + 1, the (n + 1 - k)-th spectator sits.  ...  At time n + k, the n-th spectator sits. \n\nArpa wants to know how many spectators are standing at time t.\n\n\n-----Input-----\n\nThe first line contains three integers n, k, t (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 n, 1 \u2264 t < n + k).\n\n\n-----Output-----\n\nPrint single integer: how many spectators are standing at time t.\n\n\n-----Examples-----\nInput\n10 5 3\n\nOutput\n3\n\nInput\n10 5 7\n\nOutput\n5\n\nInput\n10 5 12\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the following a sitting spectator is represented as -, a standing spectator is represented as ^.\n\n  At t = 0\u2002 ---------- $\\Rightarrow$ number of standing spectators = 0.  At t = 1\u2002 ^--------- $\\Rightarrow$ number of standing spectators = 1.  At t = 2\u2002 ^^-------- $\\Rightarrow$ number of standing spectators = 2.  At t = 3\u2002 ^^^------- $\\Rightarrow$ number of standing spectators = 3.  At t = 4\u2002 ^^^^------ $\\Rightarrow$ number of standing spectators = 4.  At t = 5\u2002 ^^^^^----- $\\Rightarrow$ number of standing spectators = 5.  At t = 6\u2002 -^^^^^---- $\\Rightarrow$ number of standing spectators = 5.  At t = 7\u2002 --^^^^^--- $\\Rightarrow$ number of standing spectators = 5.  At t = 8\u2002 ---^^^^^-- $\\Rightarrow$ number of standing spectators = 5.  At t = 9\u2002 ----^^^^^- $\\Rightarrow$ number of standing spectators = 5.  At t = 10 -----^^^^^ $\\Rightarrow$ number of standing spectators = 5.  At t = 11 ------^^^^ $\\Rightarrow$ number of standing spectators = 4.  At t = 12 -------^^^ $\\Rightarrow$ number of standing spectators = 3.  At t = 13 --------^^ $\\Rightarrow$ number of standing spectators = 2.  At t = 14 ---------^ $\\Rightarrow$ number of standing spectators = 1.  At t = 15 ---------- $\\Rightarrow$ number of standing spectators = 0.",
        "task_name": "0017",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "n, k, t = map(int, input().split())\nprint(min(t, k) if t <= n else k - (t - n) % k)\n",
        "correct": true,
        "task_id": "18",
        "depth": 0,
        "functions": 0
    },
    {
        "description": "Arpa is researching the Mexican wave.\n\nThere are n spectators in the stadium, labeled from 1 to n. They start the Mexican wave at time 0. \n\n  At time 1, the first spectator stands.  At time 2, the second spectator stands.  ...  At time k, the k-th spectator stands.  At time k + 1, the (k + 1)-th spectator stands and the first spectator sits.  At time k + 2, the (k + 2)-th spectator stands and the second spectator sits.  ...  At time n, the n-th spectator stands and the (n - k)-th spectator sits.  At time n + 1, the (n + 1 - k)-th spectator sits.  ...  At time n + k, the n-th spectator sits. \n\nArpa wants to know how many spectators are standing at time t.\n\n\n-----Input-----\n\nThe first line contains three integers n, k, t (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 n, 1 \u2264 t < n + k).\n\n\n-----Output-----\n\nPrint single integer: how many spectators are standing at time t.\n\n\n-----Examples-----\nInput\n10 5 3\n\nOutput\n3\n\nInput\n10 5 7\n\nOutput\n5\n\nInput\n10 5 12\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the following a sitting spectator is represented as -, a standing spectator is represented as ^.\n\n  At t = 0\u2002 ---------- $\\Rightarrow$ number of standing spectators = 0.  At t = 1\u2002 ^--------- $\\Rightarrow$ number of standing spectators = 1.  At t = 2\u2002 ^^-------- $\\Rightarrow$ number of standing spectators = 2.  At t = 3\u2002 ^^^------- $\\Rightarrow$ number of standing spectators = 3.  At t = 4\u2002 ^^^^------ $\\Rightarrow$ number of standing spectators = 4.  At t = 5\u2002 ^^^^^----- $\\Rightarrow$ number of standing spectators = 5.  At t = 6\u2002 -^^^^^---- $\\Rightarrow$ number of standing spectators = 5.  At t = 7\u2002 --^^^^^--- $\\Rightarrow$ number of standing spectators = 5.  At t = 8\u2002 ---^^^^^-- $\\Rightarrow$ number of standing spectators = 5.  At t = 9\u2002 ----^^^^^- $\\Rightarrow$ number of standing spectators = 5.  At t = 10 -----^^^^^ $\\Rightarrow$ number of standing spectators = 5.  At t = 11 ------^^^^ $\\Rightarrow$ number of standing spectators = 4.  At t = 12 -------^^^ $\\Rightarrow$ number of standing spectators = 3.  At t = 13 --------^^ $\\Rightarrow$ number of standing spectators = 2.  At t = 14 ---------^ $\\Rightarrow$ number of standing spectators = 1.  At t = 15 ---------- $\\Rightarrow$ number of standing spectators = 0.",
        "task_name": "0017",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "n, k, t = map(int, input().split())\n\n# Determine the number of spectators standing at time t\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n",
        "correct": true,
        "task_id": "18",
        "depth": 0,
        "functions": 0
    },
    {
        "description": "Vasya has a pile, that consists of some number of stones. $n$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.\n\nYou are given $n$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.\n\n\n-----Input-----\n\nThe first line contains one positive integer $n$\u00a0\u2014 the number of operations, that have been made by Vasya ($1 \\leq n \\leq 100$).\n\nThe next line contains the string $s$, consisting of $n$ symbols, equal to \"-\" (without quotes) or \"+\" (without quotes). If Vasya took the stone on $i$-th operation, $s_i$ is equal to \"-\" (without quotes), if added, $s_i$ is equal to \"+\" (without quotes).\n\n\n-----Output-----\n\nPrint one integer\u00a0\u2014 the minimal possible number of stones that can be in the pile after these $n$ operations.\n\n\n-----Examples-----\nInput\n3\n---\n\nOutput\n0\nInput\n4\n++++\n\nOutput\n4\nInput\n2\n-+\n\nOutput\n1\nInput\n5\n++-++\n\nOutput\n3\n\n\n-----Note-----\n\nIn the first test, if Vasya had $3$ stones in the pile at the beginning, after making operations the number of stones will be equal to $0$. It is impossible to have less number of piles, so the answer is $0$. Please notice, that the number of stones at the beginning can't be less, than $3$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).\n\nIn the second test, if Vasya had $0$ stones in the pile at the beginning, after making operations the number of stones will be equal to $4$. It is impossible to have less number of piles because after making $4$ operations the number of stones in the pile increases on $4$ stones. So, the answer is $4$.\n\nIn the third test, if Vasya had $1$ stone in the pile at the beginning, after making operations the number of stones will be equal to $1$. It can be proved, that it is impossible to have less number of stones after making the operations.\n\nIn the fourth test, if Vasya had $0$ stones in the pile at the beginning, after making operations the number of stones will be equal to $3$.",
        "task_name": "0168",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "n = int(input())\ns = input()\nminus_count = s.count('-')\nplus_count = s.count('+')\n\nif minus_count > plus_count:\n    print(0)\nelse:\n    print(plus_count - minus_count)\n",
        "correct": false,
        "task_id": "169",
        "depth": 0,
        "functions": 0
    },
    {
        "description": "Vasya has a pile, that consists of some number of stones. $n$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.\n\nYou are given $n$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.\n\n\n-----Input-----\n\nThe first line contains one positive integer $n$\u00a0\u2014 the number of operations, that have been made by Vasya ($1 \\leq n \\leq 100$).\n\nThe next line contains the string $s$, consisting of $n$ symbols, equal to \"-\" (without quotes) or \"+\" (without quotes). If Vasya took the stone on $i$-th operation, $s_i$ is equal to \"-\" (without quotes), if added, $s_i$ is equal to \"+\" (without quotes).\n\n\n-----Output-----\n\nPrint one integer\u00a0\u2014 the minimal possible number of stones that can be in the pile after these $n$ operations.\n\n\n-----Examples-----\nInput\n3\n---\n\nOutput\n0\nInput\n4\n++++\n\nOutput\n4\nInput\n2\n-+\n\nOutput\n1\nInput\n5\n++-++\n\nOutput\n3\n\n\n-----Note-----\n\nIn the first test, if Vasya had $3$ stones in the pile at the beginning, after making operations the number of stones will be equal to $0$. It is impossible to have less number of piles, so the answer is $0$. Please notice, that the number of stones at the beginning can't be less, than $3$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).\n\nIn the second test, if Vasya had $0$ stones in the pile at the beginning, after making operations the number of stones will be equal to $4$. It is impossible to have less number of piles because after making $4$ operations the number of stones in the pile increases on $4$ stones. So, the answer is $4$.\n\nIn the third test, if Vasya had $1$ stone in the pile at the beginning, after making operations the number of stones will be equal to $1$. It can be proved, that it is impossible to have less number of stones after making the operations.\n\nIn the fourth test, if Vasya had $0$ stones in the pile at the beginning, after making operations the number of stones will be equal to $3$.",
        "task_name": "0168",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "n = int(input())\ns = input()\n\n# Initialize the number of stones to the minimum possible, which is zero.\nstones = 0\n\n# Process each operation\nfor operation in s:\n    if operation == '+':\n        stones += 1\n    elif operation == '-':\n        stones = max(0, stones - 1)\n\nprint(stones)\n",
        "correct": true,
        "task_id": "169",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "Pavel cooks barbecue. There are n skewers, they lay on a brazier in a row, each on one of n positions. Pavel wants each skewer to be cooked some time in every of n positions in two directions: in the one it was directed originally and in the reversed direction.\n\nPavel has a plan: a permutation p and a sequence b_1, b_2, ..., b_{n}, consisting of zeros and ones. Each second Pavel move skewer on position i to position p_{i}, and if b_{i} equals 1 then he reverses it. So he hope that every skewer will visit every position in both directions.\n\nUnfortunately, not every pair of permutation p and sequence b suits Pavel. What is the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements? Note that after changing the permutation should remain a permutation as well.\n\nThere is no problem for Pavel, if some skewer visits some of the placements several times before he ends to cook. In other words, a permutation p and a sequence b suit him if there is an integer k (k \u2265 2n), so that after k seconds each skewer visits each of the 2n placements.\n\nIt can be shown that some suitable pair of permutation p and sequence b exists for any n.\n\n\n-----Input-----\n\nThe first line contain the integer n (1 \u2264 n \u2264 2\u00b710^5)\u00a0\u2014 the number of skewers.\n\nThe second line contains a sequence of integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n)\u00a0\u2014 the permutation, according to which Pavel wants to move the skewers.\n\nThe third line contains a sequence b_1, b_2, ..., b_{n} consisting of zeros and ones, according to which Pavel wants to reverse the skewers.\n\n\n-----Output-----\n\nPrint single integer\u00a0\u2014 the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements.\n\n\n-----Examples-----\nInput\n4\n4 3 2 1\n0 1 1 1\n\nOutput\n2\n\nInput\n3\n2 3 1\n0 0 0\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example Pavel can change the permutation to 4, 3, 1, 2.\n\nIn the second example Pavel can change any element of b to 1.",
        "task_name": "0278",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "n = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nans = 0\nfor i in range(n):\n    if p[i] != i + 1:\n        ans += 1\n    if b[i] == 0:\n        ans += 1\n\nprint(ans)\n",
        "correct": false,
        "task_id": "279",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "Pavel cooks barbecue. There are n skewers, they lay on a brazier in a row, each on one of n positions. Pavel wants each skewer to be cooked some time in every of n positions in two directions: in the one it was directed originally and in the reversed direction.\n\nPavel has a plan: a permutation p and a sequence b_1, b_2, ..., b_{n}, consisting of zeros and ones. Each second Pavel move skewer on position i to position p_{i}, and if b_{i} equals 1 then he reverses it. So he hope that every skewer will visit every position in both directions.\n\nUnfortunately, not every pair of permutation p and sequence b suits Pavel. What is the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements? Note that after changing the permutation should remain a permutation as well.\n\nThere is no problem for Pavel, if some skewer visits some of the placements several times before he ends to cook. In other words, a permutation p and a sequence b suit him if there is an integer k (k \u2265 2n), so that after k seconds each skewer visits each of the 2n placements.\n\nIt can be shown that some suitable pair of permutation p and sequence b exists for any n.\n\n\n-----Input-----\n\nThe first line contain the integer n (1 \u2264 n \u2264 2\u00b710^5)\u00a0\u2014 the number of skewers.\n\nThe second line contains a sequence of integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n)\u00a0\u2014 the permutation, according to which Pavel wants to move the skewers.\n\nThe third line contains a sequence b_1, b_2, ..., b_{n} consisting of zeros and ones, according to which Pavel wants to reverse the skewers.\n\n\n-----Output-----\n\nPrint single integer\u00a0\u2014 the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements.\n\n\n-----Examples-----\nInput\n4\n4 3 2 1\n0 1 1 1\n\nOutput\n2\n\nInput\n3\n2 3 1\n0 0 0\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example Pavel can change the permutation to 4, 3, 1, 2.\n\nIn the second example Pavel can change any element of b to 1.",
        "task_name": "0278",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n+1]))\n    b = list(map(int, data[n+1:2*n+1]))\n\n    # Find cycles in the permutation p\n    visited = [False] * n\n    cycles = []\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(x)\n                x = p[x] - 1\n            cycles.append(cycle)\n    \n    # Check number of components with no reversals\n    no_reverse_components = sum(all(b[x] == 0 for x in cycle) for cycle in cycles)\n    \n    # If there is only one component, no change needed\n    if len(cycles) == 1:\n        print(0)\n    else:\n        # Otherwise, we need to ensure at least one reversal in each component\n        print(no_reverse_components if no_reverse_components > 0 else 1)\n\n# Use Standard Input format\nsolve()\n",
        "correct": false,
        "task_id": "279",
        "depth": 2,
        "functions": 1
    },
    {
        "description": "The on-board computer on Polycarp's car measured that the car speed at the beginning of some section of the path equals v_1 meters per second, and in the end it is v_2 meters per second. We know that this section of the route took exactly t seconds to pass.\n\nAssuming that at each of the seconds the speed is constant, and between seconds the speed can change at most by d meters per second in absolute value (i.e., the difference in the speed of any two adjacent seconds does not exceed d in absolute value), find the maximum possible length of the path section in meters.\n\n\n-----Input-----\n\nThe first line contains two integers v_1 and v_2 (1 \u2264 v_1, v_2 \u2264 100) \u2014 the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively.\n\nThe second line contains two integers t (2 \u2264 t \u2264 100) \u2014 the time when the car moves along the segment in seconds, d (0 \u2264 d \u2264 10) \u2014 the maximum value of the speed change between adjacent seconds.\n\nIt is guaranteed that there is a way to complete the segment so that:  the speed in the first second equals v_1,  the speed in the last second equals v_2,  the absolute value of difference of speeds between any two adjacent seconds doesn't exceed d. \n\n\n-----Output-----\n\nPrint the maximum possible length of the path segment in meters. \n\n\n-----Examples-----\nInput\n5 6\n4 2\n\nOutput\n26\nInput\n10 10\n10 0\n\nOutput\n100\n\n\n-----Note-----\n\nIn the first sample the sequence of speeds of Polycarpus' car can look as follows: 5, 7, 8, 6. Thus, the total path is 5 + 7 + 8 + 6 = 26 meters.\n\nIn the second sample, as d = 0, the car covers the whole segment at constant speed v = 10. In t = 10 seconds it covers the distance of 100 meters.",
        "task_name": "0279",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "v1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\nmax_speed = max(v1, v2)\nmin_speed = min(v1, v2)\n\nmax_length = max_speed * t\nmin_length = min_speed * t\n\nfor i in range(t-1, 0, -1):\n    max_speed = max(max_speed - d, min_speed)\n    min_speed = min(min_speed + d, max_speed)\n    max_length += max_speed\n    min_length += min_speed\n\nprint(max_length)\n",
        "correct": false,
        "task_id": "280",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "The on-board computer on Polycarp's car measured that the car speed at the beginning of some section of the path equals v_1 meters per second, and in the end it is v_2 meters per second. We know that this section of the route took exactly t seconds to pass.\n\nAssuming that at each of the seconds the speed is constant, and between seconds the speed can change at most by d meters per second in absolute value (i.e., the difference in the speed of any two adjacent seconds does not exceed d in absolute value), find the maximum possible length of the path section in meters.\n\n\n-----Input-----\n\nThe first line contains two integers v_1 and v_2 (1 \u2264 v_1, v_2 \u2264 100) \u2014 the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively.\n\nThe second line contains two integers t (2 \u2264 t \u2264 100) \u2014 the time when the car moves along the segment in seconds, d (0 \u2264 d \u2264 10) \u2014 the maximum value of the speed change between adjacent seconds.\n\nIt is guaranteed that there is a way to complete the segment so that:  the speed in the first second equals v_1,  the speed in the last second equals v_2,  the absolute value of difference of speeds between any two adjacent seconds doesn't exceed d. \n\n\n-----Output-----\n\nPrint the maximum possible length of the path segment in meters. \n\n\n-----Examples-----\nInput\n5 6\n4 2\n\nOutput\n26\nInput\n10 10\n10 0\n\nOutput\n100\n\n\n-----Note-----\n\nIn the first sample the sequence of speeds of Polycarpus' car can look as follows: 5, 7, 8, 6. Thus, the total path is 5 + 7 + 8 + 6 = 26 meters.\n\nIn the second sample, as d = 0, the car covers the whole segment at constant speed v = 10. In t = 10 seconds it covers the distance of 100 meters.",
        "task_name": "0279",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "# Read input values\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Initialize the list to store the speeds at each second\nspeeds = [0] * t\n\n# Set the speed at the first second\nspeeds[0] = v1\n\n# Set the speed at the last second\nspeeds[-1] = v2\n\n# Calculate maximum possible speeds in between\nfor i in range(1, t):\n    speeds[i] = min(speeds[i-1] + d, v2 + (t - i - 1) * d)\n\n# Calculate total distance traveled\ntotal_distance = sum(speeds)\n\n# Print the result\nprint(total_distance)\n",
        "correct": true,
        "task_id": "280",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "Someone gave Alyona an array containing n positive integers a_1, a_2, ..., a_{n}. In one operation, Alyona can choose any element of the array and decrease it, i.e. replace with any positive integer that is smaller than the current one. Alyona can repeat this operation as many times as she wants. In particular, she may not apply any operation to the array at all.\n\nFormally, after applying some operations Alyona will get an array of n positive integers b_1, b_2, ..., b_{n} such that 1 \u2264 b_{i} \u2264 a_{i} for every 1 \u2264 i \u2264 n. Your task is to determine the maximum possible value of mex of this array.\n\nMex of an array in this problem is the minimum positive integer that doesn't appear in this array. For example, mex of the array containing 1, 3 and 4 is equal to 2, while mex of the array containing 2, 3 and 2 is equal to 1.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000)\u00a0\u2014 the number of elements in the Alyona's array.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 the elements of the array.\n\n\n-----Output-----\n\nPrint one positive integer\u00a0\u2014 the maximum possible value of mex of the array after Alyona applies some (possibly none) operations.\n\n\n-----Examples-----\nInput\n5\n1 3 3 3 6\n\nOutput\n5\n\nInput\n2\n2 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample case if one will decrease the second element value to 2 and the fifth element value to 4 then the mex value of resulting array 1 2 3 3 4 will be equal to 5.\n\nTo reach the answer to the second sample case one must not decrease any of the array elements.",
        "task_name": "0143",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "n = int(input())\narr = list(map(int, input().split()))\narr.sort()\nmex = 1\nfor num in arr:\n    if num == mex:\n        mex += 1\n    elif num > mex:\n        break\nprint(mex)\n",
        "correct": false,
        "task_id": "144",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "Someone gave Alyona an array containing n positive integers a_1, a_2, ..., a_{n}. In one operation, Alyona can choose any element of the array and decrease it, i.e. replace with any positive integer that is smaller than the current one. Alyona can repeat this operation as many times as she wants. In particular, she may not apply any operation to the array at all.\n\nFormally, after applying some operations Alyona will get an array of n positive integers b_1, b_2, ..., b_{n} such that 1 \u2264 b_{i} \u2264 a_{i} for every 1 \u2264 i \u2264 n. Your task is to determine the maximum possible value of mex of this array.\n\nMex of an array in this problem is the minimum positive integer that doesn't appear in this array. For example, mex of the array containing 1, 3 and 4 is equal to 2, while mex of the array containing 2, 3 and 2 is equal to 1.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000)\u00a0\u2014 the number of elements in the Alyona's array.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 the elements of the array.\n\n\n-----Output-----\n\nPrint one positive integer\u00a0\u2014 the maximum possible value of mex of the array after Alyona applies some (possibly none) operations.\n\n\n-----Examples-----\nInput\n5\n1 3 3 3 6\n\nOutput\n5\n\nInput\n2\n2 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample case if one will decrease the second element value to 2 and the fifth element value to 4 then the mex value of resulting array 1 2 3 3 4 will be equal to 5.\n\nTo reach the answer to the second sample case one must not decrease any of the array elements.",
        "task_name": "0143",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\n# Sort the array\na.sort()\n\n# Initialize the target mex value\nmex = 1\n\n# Iterate through the sorted array\nfor num in a:\n    if num >= mex:\n        mex += 1\n\n# Print the maximum possible value of mex\nprint(mex)\n",
        "correct": true,
        "task_id": "144",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "As you know, every birthday party has a cake! This time, Babaei is going to prepare the very special birthday party's cake.\n\nSimple cake is a cylinder of some radius and height. The volume of the simple cake is equal to the volume of corresponding cylinder. Babaei has n simple cakes and he is going to make a special cake placing some cylinders on each other.\n\nHowever, there are some additional culinary restrictions. The cakes are numbered in such a way that the cake number i can be placed only on the table or on some cake number j where j < i. Moreover, in order to impress friends Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j.\n\nBabaei wants to prepare a birthday cake that has a maximum possible total volume. Help him find this value.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000)\u00a0\u2014 the number of simple cakes Babaei has.\n\nEach of the following n lines contains two integers r_{i} and h_{i} (1 \u2264 r_{i}, h_{i} \u2264 10 000), giving the radius and height of the i-th cake.\n\n\n-----Output-----\n\nPrint the maximum volume of the cake that Babaei can make. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\nNamely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if $\\frac{|a - b|}{\\operatorname{max}(1, b)} \\leq 10^{-6}$.\n\n\n-----Examples-----\nInput\n2\n100 30\n40 10\n\nOutput\n942477.796077000\n\nInput\n4\n1 1\n9 7\n1 4\n10 7\n\nOutput\n3983.539484752\n\n\n\n-----Note-----\n\nIn first sample, the optimal way is to choose the cake number 1.\n\nIn second sample, the way to get the maximum volume is to use cakes with indices 1, 2 and 4.",
        "task_name": "0250",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "import math\n\nn = int(input())\ncakes = []\nfor _ in range(n):\n    r, h = map(int, input().split())\n    cakes.append((math.pi * r * r * h, r, h))\n\ncakes.sort(reverse=True)\n\ndp = [0.0] * n\ndp[0] = cakes[0][0]\n\nfor i in range(1, n):\n    dp[i] = cakes[i][0]\n    for j in range(i):\n        if cakes[i][1] < cakes[j][1] and cakes[i][2] < cakes[j][2]:\n            dp[i] = max(dp[i], dp[j] + cakes[i][0])\n\nprint(dp[-1])\n",
        "correct": false,
        "task_id": "251",
        "depth": 2,
        "functions": 0
    },
    {
        "description": "As you know, every birthday party has a cake! This time, Babaei is going to prepare the very special birthday party's cake.\n\nSimple cake is a cylinder of some radius and height. The volume of the simple cake is equal to the volume of corresponding cylinder. Babaei has n simple cakes and he is going to make a special cake placing some cylinders on each other.\n\nHowever, there are some additional culinary restrictions. The cakes are numbered in such a way that the cake number i can be placed only on the table or on some cake number j where j < i. Moreover, in order to impress friends Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j.\n\nBabaei wants to prepare a birthday cake that has a maximum possible total volume. Help him find this value.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000)\u00a0\u2014 the number of simple cakes Babaei has.\n\nEach of the following n lines contains two integers r_{i} and h_{i} (1 \u2264 r_{i}, h_{i} \u2264 10 000), giving the radius and height of the i-th cake.\n\n\n-----Output-----\n\nPrint the maximum volume of the cake that Babaei can make. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\nNamely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if $\\frac{|a - b|}{\\operatorname{max}(1, b)} \\leq 10^{-6}$.\n\n\n-----Examples-----\nInput\n2\n100 30\n40 10\n\nOutput\n942477.796077000\n\nInput\n4\n1 1\n9 7\n1 4\n10 7\n\nOutput\n3983.539484752\n\n\n\n-----Note-----\n\nIn first sample, the optimal way is to choose the cake number 1.\n\nIn second sample, the way to get the maximum volume is to use cakes with indices 1, 2 and 4.",
        "task_name": "0250",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "import sys\nimport math\ninput = sys.stdin.read\n\ndef max_cake_volume(n, cakes):\n    volumes = [(math.pi * r * r * h) for r, h in cakes]\n    dp = [0] * n\n    \n    for i in range(n):\n        dp[i] = volumes[i]\n        for j in range(i):\n            if volumes[j] < volumes[i]:\n                dp[i] = max(dp[i], dp[j] + volumes[i])\n                \n    return max(dp)\n\ndef main():\n    data = input().split()\n    n = int(data[0])\n    cakes = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n)]\n    result = max_cake_volume(n, cakes)\n    print(f\"{result:.6f}\")\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": false,
        "task_id": "251",
        "depth": 2,
        "functions": 2
    },
    {
        "description": "Amr bought a new video game \"Guess Your Way Out!\". The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height h. The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node. \n\nLet's index all the leaf nodes from the left to the right from 1 to 2^{h}. The exit is located at some node n where 1 \u2264 n \u2264 2^{h}, the player doesn't know where the exit is so he has to guess his way out!\n\nAmr follows simple algorithm to choose the path. Let's consider infinite command string \"LRLRLRLRL...\" (consisting of alternating characters 'L' and 'R'). Amr sequentially executes the characters of the string using following rules:  Character 'L' means \"go to the left child of the current node\";  Character 'R' means \"go to the right child of the current node\";  If the destination node is already visited, Amr skips current command, otherwise he moves to the destination node;  If Amr skipped two consecutive commands, he goes back to the parent of the current node before executing next command;  If he reached a leaf node that is not the exit, he returns to the parent of the current node;  If he reaches an exit, the game is finished. \n\nNow Amr wonders, if he follows this algorithm, how many nodes he is going to visit before reaching the exit?\n\n\n-----Input-----\n\nInput consists of two integers h, n (1 \u2264 h \u2264 50, 1 \u2264 n \u2264 2^{h}).\n\n\n-----Output-----\n\nOutput a single integer representing the number of nodes (excluding the exit node) Amr is going to visit before reaching the exit by following this algorithm.\n\n\n-----Examples-----\nInput\n1 2\n\nOutput\n2\nInput\n2 3\n\nOutput\n5\nInput\n3 6\n\nOutput\n10\nInput\n10 1024\n\nOutput\n2046\n\n\n-----Note-----\n\nA perfect binary tree of height h is a binary tree consisting of h + 1 levels. Level 0 consists of a single node called root, level h consists of 2^{h} nodes called leaves. Each node that is not a leaf has exactly two children, left and right one. \n\nFollowing picture illustrates the sample test number 3. Nodes are labeled according to the order of visit.\n\n[Image]",
        "task_name": "0292",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "h, n = map(int, input().split())\nans = 0\nwhile n > 1:\n    if n % 2 == 0:\n        ans += (n // 2) - 1\n    else:\n        ans += n // 2\n    n //= 2\nprint(ans)\n",
        "correct": false,
        "task_id": "293",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "Amr bought a new video game \"Guess Your Way Out!\". The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height h. The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node. \n\nLet's index all the leaf nodes from the left to the right from 1 to 2^{h}. The exit is located at some node n where 1 \u2264 n \u2264 2^{h}, the player doesn't know where the exit is so he has to guess his way out!\n\nAmr follows simple algorithm to choose the path. Let's consider infinite command string \"LRLRLRLRL...\" (consisting of alternating characters 'L' and 'R'). Amr sequentially executes the characters of the string using following rules:  Character 'L' means \"go to the left child of the current node\";  Character 'R' means \"go to the right child of the current node\";  If the destination node is already visited, Amr skips current command, otherwise he moves to the destination node;  If Amr skipped two consecutive commands, he goes back to the parent of the current node before executing next command;  If he reached a leaf node that is not the exit, he returns to the parent of the current node;  If he reaches an exit, the game is finished. \n\nNow Amr wonders, if he follows this algorithm, how many nodes he is going to visit before reaching the exit?\n\n\n-----Input-----\n\nInput consists of two integers h, n (1 \u2264 h \u2264 50, 1 \u2264 n \u2264 2^{h}).\n\n\n-----Output-----\n\nOutput a single integer representing the number of nodes (excluding the exit node) Amr is going to visit before reaching the exit by following this algorithm.\n\n\n-----Examples-----\nInput\n1 2\n\nOutput\n2\nInput\n2 3\n\nOutput\n5\nInput\n3 6\n\nOutput\n10\nInput\n10 1024\n\nOutput\n2046\n\n\n-----Note-----\n\nA perfect binary tree of height h is a binary tree consisting of h + 1 levels. Level 0 consists of a single node called root, level h consists of 2^{h} nodes called leaves. Each node that is not a leaf has exactly two children, left and right one. \n\nFollowing picture illustrates the sample test number 3. Nodes are labeled according to the order of visit.\n\n[Image]",
        "task_name": "0292",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "def main():\n    import sys\n    input = sys.stdin.read\n    h, n = map(int, input().split())\n\n    # Calculate the total number of leaf nodes\n    total_leaves = 2 ** h\n\n    # Track the number of visited nodes\n    visited_count = 0\n\n    # Binary representation of the path to the exit node\n    path = bin(n - 1)[2:].zfill(h)\n\n    current_level = 0\n    current_node = 0  # Represent the root node\n\n    # Simulate the traversal\n    for direction in path:\n        visited_count += 1\n        if direction == '0':\n            current_node = 2 * current_node + 1  # Move to the left child\n        else:\n            current_node = 2 * current_node + 2  # Move to the right child\n\n    # Total nodes visited (excluding the exit node itself)\n    print(visited_count)\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": false,
        "task_id": "293",
        "depth": 1,
        "functions": 1
    },
    {
        "description": "Neko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.\n\nNeko has two integers $a$ and $b$. His goal is to find a non-negative integer $k$ such that the least common multiple of $a+k$ and $b+k$ is the smallest possible. If there are multiple optimal integers $k$, he needs to choose the smallest one.\n\nGiven his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n\n-----Input-----\n\nThe only line contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$).\n\n\n-----Output-----\n\nPrint the smallest non-negative integer $k$ ($k \\ge 0$) such that the lowest common multiple of $a+k$ and $b+k$ is the smallest possible.\n\nIf there are many possible integers $k$ giving the same value of the least common multiple, print the smallest one.\n\n\n-----Examples-----\nInput\n6 10\n\nOutput\n2\nInput\n21 31\n\nOutput\n9\nInput\n5 10\n\nOutput\n0\n\n\n-----Note-----\n\nIn the first test, one should choose $k = 2$, as the least common multiple of $6 + 2$ and $10 + 2$ is $24$, which is the smallest least common multiple possible.",
        "task_name": "0081",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\na, b = map(int, input().split())\n\nk = 0\nmin_lcm = lcm(a, b)\n\nwhile True:\n    if lcm(a + k, b + k) < min_lcm:\n        min_lcm = lcm(a + k, b + k)\n    else:\n        break\n    k += 1\n\nprint(k - 1)\n",
        "correct": false,
        "task_id": "82",
        "depth": 1,
        "functions": 2
    },
    {
        "description": "Neko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.\n\nNeko has two integers $a$ and $b$. His goal is to find a non-negative integer $k$ such that the least common multiple of $a+k$ and $b+k$ is the smallest possible. If there are multiple optimal integers $k$, he needs to choose the smallest one.\n\nGiven his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n\n-----Input-----\n\nThe only line contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$).\n\n\n-----Output-----\n\nPrint the smallest non-negative integer $k$ ($k \\ge 0$) such that the lowest common multiple of $a+k$ and $b+k$ is the smallest possible.\n\nIf there are many possible integers $k$ giving the same value of the least common multiple, print the smallest one.\n\n\n-----Examples-----\nInput\n6 10\n\nOutput\n2\nInput\n21 31\n\nOutput\n9\nInput\n5 10\n\nOutput\n0\n\n\n-----Note-----\n\nIn the first test, one should choose $k = 2$, as the least common multiple of $6 + 2$ and $10 + 2$ is $24$, which is the smallest least common multiple possible.",
        "task_name": "0081",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "import math\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n\n    diff = abs(a - b)\n    min_lcm = float('inf')\n    min_k = 0\n\n    for k in range(1, int(math.sqrt(diff)) + 1):\n        if diff % k == 0:\n            # Check both k and diff // k as possible values for the smallest k\n            for candidate in [k, diff // k]:\n                new_a = (a + candidate - 1) // candidate * candidate\n                new_b = (b + candidate - 1) // candidate * candidate\n                current_lcm = lcm(new_a, new_b)\n                if current_lcm < min_lcm or (current_lcm == min_lcm and candidate < min_k):\n                    min_lcm = current_lcm\n                    min_k = candidate\n\n    return min_k\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    a = int(data[0])\n    b = int(data[1])\n    print(find_min_k(a, b))\n",
        "correct": false,
        "task_id": "82",
        "depth": 2,
        "functions": 3
    }
]