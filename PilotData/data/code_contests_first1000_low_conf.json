[
    {
        "description": "Recenlty Luba got a credit card and started to use it. Let's consider n consecutive days Luba uses the card.\n\nShe starts with 0 money on her account.\n\nIn the evening of i-th day a transaction ai occurs. If ai > 0, then ai bourles are deposited to Luba's account. If ai < 0, then ai bourles are withdrawn. And if ai = 0, then the amount of money on Luba's account is checked.\n\nIn the morning of any of n days Luba can go to the bank and deposit any positive integer amount of burles to her account. But there is a limitation: the amount of money on the account can never exceed d.\n\nIt can happen that the amount of money goes greater than d by some transaction in the evening. In this case answer will be \u00ab-1\u00bb.\n\nLuba must not exceed this limit, and also she wants that every day her account is checked (the days when ai = 0) the amount of money on her account is non-negative. It takes a lot of time to go to the bank, so Luba wants to know the minimum number of days she needs to deposit some money to her account (if it is possible to meet all the requirements). Help her!\n\nInput\n\nThe first line contains two integers n, d (1 \u2264 n \u2264 105, 1 \u2264 d \u2264 109) \u2014the number of days and the money limitation.\n\nThe second line contains n integer numbers a1, a2, ... an ( - 104 \u2264 ai \u2264 104), where ai represents the transaction in i-th day.\n\nOutput\n\nPrint -1 if Luba cannot deposit the money to her account in such a way that the requirements are met. Otherwise print the minimum number of days Luba has to deposit money.\n\nExamples\n\nInput\n\n5 10\n-1 5 0 -5 3\n\n\nOutput\n\n0\n\n\nInput\n\n3 4\n-10 0 20\n\n\nOutput\n\n-1\n\n\nInput\n\n5 10\n-5 0 10 -11 0\n\n\nOutput\n\n2",
        "task_name": "893_D. Credit Card",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "f = lambda: map(int,raw_input().split())\nn, d = f()\nh = s = k = 0\nfor q in f():\n    h, s = h + q, min(d, s + q)\n    if h > d:\n        k = -1\n        break\n    if q == 0:\n        h = max(0, h)\n        if s < 0: s, k = d, k + 1\nprint(k)",
        "correct": true,
        "task_id": "0029",
        "depth": 1
    },
    {
        "description": "At the big break Nastya came to the school dining room. There are n pupils in the school, numbered from 1 to n. Unfortunately, Nastya came pretty late, so that all pupils had already stood in the queue, i.e. Nastya took the last place in the queue. Of course, it's a little bit sad for Nastya, but she is not going to despond because some pupils in the queue can agree to change places with some other pupils.\n\nFormally, there are some pairs u, v such that if the pupil with number u stands directly in front of the pupil with number v, Nastya can ask them and they will change places. \n\nNastya asks you to find the maximal number of places in queue she can move forward. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u2264 3 \u22c5 10^{5}, 0 \u2264 m \u2264 5 \u22c5 10^{5}) \u2014 the number of pupils in the queue and number of pairs of pupils such that the first one agrees to change places with the second one if the first is directly in front of the second.\n\nThe second line contains n integers p_1, p_2, ..., p_n \u2014 the initial arrangement of pupils in the queue, from the queue start to its end (1 \u2264 p_i \u2264 n, p is a permutation of integers from 1 to n). In other words, p_i is the number of the pupil who stands on the i-th position in the queue.\n\nThe i-th of the following m lines contains two integers u_i, v_i (1 \u2264 u_i, v_i \u2264 n, u_i \u2260 v_i), denoting that the pupil with number u_i agrees to change places with the pupil with number v_i if u_i is directly in front of v_i. It is guaranteed that if i \u2260 j, than v_i \u2260 v_j or u_i \u2260 u_j. Note that it is possible that in some pairs both pupils agree to change places with each other.\n\nNastya is the last person in the queue, i.e. the pupil with number p_n.\n\nOutput\n\nPrint a single integer \u2014 the number of places in queue she can move forward.\n\nExamples\n\nInput\n\n2 1\n1 2\n1 2\n\n\nOutput\n\n1\n\nInput\n\n3 3\n3 1 2\n1 2\n3 1\n3 2\n\n\nOutput\n\n2\n\nInput\n\n5 2\n3 1 5 4 2\n5 2\n5 4\n\n\nOutput\n\n1\n\nNote\n\nIn the first example Nastya can just change places with the first pupil in the queue.\n\nOptimal sequence of changes in the second example is \n\n  * change places for pupils with numbers 1 and 3. \n  * change places for pupils with numbers 3 and 2. \n  * change places for pupils with numbers 1 and 2. \n\n\n\nThe queue looks like [3, 1, 2], then [1, 3, 2], then [1, 2, 3], and finally [2, 1, 3] after these operations.",
        "task_name": "1136_D. Nastya Is Buying Lunch",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, m = rints()\na, b = rints(), [rints() for _ in range(m)]\nadj, tem, ans = [set() for _ in range(n + 1)], [], 0\nadj2 = set()\n\nfor u, v in b:\n    adj[u].add(v)\n    if v == a[-1]:\n        adj2.add(u)\n\nfor i in range(n - 2, -1, -1):\n    if a[i] in adj2:\n        if len(adj[a[i]]) >= len(tem):\n            ans += 1\n            for j in tem:\n                if j not in adj[a[i]]:\n                    ans -= 1\n                    break\n    else:\n        tem.append(a[i])\n\nprint(ans)\n",
        "correct": false,
        "task_id": "0048",
        "depth": 2
    },
    {
        "description": "In this problem you will meet the simplified model of game King of Thieves.\n\nIn a new ZeptoLab game called \"King of Thieves\" your aim is to reach a chest with gold by controlling your character, avoiding traps and obstacles on your way.\n\n<image>\n\nAn interesting feature of the game is that you can design your own levels that will be available to other players. Let's consider the following simple design of a level.\n\nA dungeon consists of n segments located at a same vertical level, each segment is either a platform that character can stand on, or a pit with a trap that makes player lose if he falls into it. All segments have the same length, platforms on the scheme of the level are represented as '*' and pits are represented as '.'. \n\nOne of things that affects speedrun characteristics of the level is a possibility to perform a series of consecutive jumps of the same length. More formally, when the character is on the platform number i1, he can make a sequence of jumps through the platforms i1 < i2 < ... < ik, if i2 - i1 = i3 - i2 = ... = ik - ik - 1. Of course, all segments i1, i2, ... ik should be exactly the platforms, not pits. \n\nLet's call a level to be good if you can perform a sequence of four jumps of the same length or in the other words there must be a sequence i1, i2, ..., i5, consisting of five platforms so that the intervals between consecutive platforms are of the same length. Given the scheme of the level, check if it is good.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 100) \u2014 the number of segments on the level.\n\nNext line contains the scheme of the level represented as a string of n characters '*' and '.'.\n\nOutput\n\nIf the level is good, print the word \"yes\" (without the quotes), otherwise print the word \"no\" (without the quotes).\n\nExamples\n\nInput\n\n16\n.**.*..*.***.**.\n\n\nOutput\n\nyes\n\nInput\n\n11\n.*.*...*.*.\n\n\nOutput\n\nno\n\nNote\n\nIn the first sample test you may perform a sequence of jumps through platforms 2, 5, 8, 11, 14.",
        "task_name": "526_A. King of Thieves",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import print_function\n\ndef try_hop(field, i):\n\tfor slice_len in xrange(1, len(field)+1):\n\t\tres = field[i::slice_len]\n\t\t#print(i, slice_len, res)\n\t\tif len(res) == 5 and set(res) == {'*'}:\n\t\t\treturn slice_len\n\treturn 0\n\ndef main():\n\tn = int(raw_input())\n\tfield = raw_input()\n\twin = False\n\tfor i in xrange(n):\n\t\tif field[i] != '.':\n\t\t\tslice_len = try_hop(field, i)\n\t\t\tif slice_len:\n\t\t\t\tj = i+4*slice_len\n\t\t\t\t#print(j)\n\t\t\t\tif j+slice_len >= n or field[j+slice_len] == '*':\n\t\t\t\t\twin = True\n\t\t\t\t\tbreak\n\tif win:\n\t\tprint('yes')\n\telse:\n\t\tprint('no')\n\nif __name__ == '__main__':\n\tmain()\n\n",
        "correct": false,
        "task_id": "0066",
        "depth": 1
    },
    {
        "description": "After playing Neo in the legendary \"Matrix\" trilogy, Keanu Reeves started doubting himself: maybe we really live in virtual reality? To find if this is true, he needs to solve the following problem.\n\nLet's call a string consisting of only zeroes and ones good if it contains different numbers of zeroes and ones. For example, 1, 101, 0000 are good, while 01, 1001, and 111000 are not good.\n\nWe are given a string s of length n consisting of only zeroes and ones. We need to cut s into minimal possible number of substrings s_1, s_2, \u2026, s_k such that all of them are good. More formally, we have to find minimal by number of strings sequence of good strings s_1, s_2, \u2026, s_k such that their concatenation (joining) equals s, i.e. s_1 + s_2 + ... + s_k = s.\n\nFor example, cuttings 110010 into 110 and 010 or into 11 and 0010 are valid, as 110, 010, 11, 0010 are all good, and we can't cut 110010 to the smaller number of substrings as 110010 isn't good itself. At the same time, cutting of 110010 into 1100 and 10 isn't valid as both strings aren't good. Also, cutting of 110010 into 1, 1, 0010 isn't valid, as it isn't minimal, even though all 3 strings are good.\n\nCan you help Keanu? We can show that the solution always exists. If there are multiple optimal answers, print any.\n\nInput\n\nThe first line of the input contains a single integer n (1\u2264 n \u2264 100) \u2014 the length of the string s.\n\nThe second line contains the string s of length n consisting only from zeros and ones.\n\nOutput\n\nIn the first line, output a single integer k (1\u2264 k) \u2014 a minimal number of strings you have cut s into.\n\nIn the second line, output k strings s_1, s_2, \u2026, s_k separated with spaces. The length of each string has to be positive. Their concatenation has to be equal to s and all of them have to be good.\n\nIf there are multiple answers, print any.\n\nExamples\n\nInput\n\n\n1\n1\n\n\nOutput\n\n\n1\n1\n\nInput\n\n\n2\n10\n\n\nOutput\n\n\n2\n1 0\n\nInput\n\n\n6\n100011\n\n\nOutput\n\n\n2\n100 011\n\nNote\n\nIn the first example, the string 1 wasn't cut at all. As it is good, the condition is satisfied.\n\nIn the second example, 1 and 0 both are good. As 10 isn't good, the answer is indeed minimal.\n\nIn the third example, 100 and 011 both are good. As 100011 isn't good, the answer is indeed minimal.",
        "task_name": "1189_A. Keanu Reeves",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"                         \nBeautiful is better than ugly.\n    Explicit is better than implicit.\nSimple is better than complex.\n    Complex is better than complicated.\nFlat is better than nested.\n    Sparse is better than dense.\n                    \n    * Readability counts *\n\n // Author : raj1307 - Raj Singh\n // Date   : 5.07.19\n\n\"\"\"\n\nfrom __future__ import division, print_function\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    _str = str\n    str = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial,pow,pi\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod,MOD=1000000007,998244353\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [i for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p1\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n# For getting input from input.txt file \n#sys.stdin = open('input.txt', 'r')  \n  \n# Printing the Output to output.txt file \n#sys.stdout = open('output.txt', 'w') \n\n    \n\ndef main():\n    \n    \n    \n    #for _ in range(ii()):\n    \n    n=ii()\n    s=si()\n    a=s.count('0')\n    b=s.count('1')\n    \n    if n==1:\n        print(1)\n        print(s)\n        exit()\n    \n    \n    if a!=b:\n        print(1)\n        print(s)\n        exit()\n    \n    \n    if s[0]=='0':\n        a-=1\n    else:\n        b-=1\n    \n    print(2)\n    for i in range(1,n):\n        \n        if a!=b:\n            print(s[:i],s[i:])\n            exit()\n        \n        \n        \n        if s[i]=='0':\n            a-=1\n        else:\n            b-=1\n            \n    \n    if a!=b:\n        print(s[:i],s[i:])\n        exit()\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        if self.buffer.tell():\n            return self.buffer.read()\n        return os.read(self._fd, os.fstat(self._fd).st_size)\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", b\" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", b\"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(b\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n    #dmain()",
        "correct": true,
        "task_id": "0091",
        "depth": 1
    },
    {
        "description": "You want to perform the combo on your opponent in one popular fighting game. The combo is the string s consisting of n lowercase Latin letters. To perform the combo, you have to press all buttons in the order they appear in s. I.e. if s=\"abca\" then you have to press 'a', then 'b', 'c' and 'a' again.\n\nYou know that you will spend m wrong tries to perform the combo and during the i-th try you will make a mistake right after p_i-th button (1 \u2264 p_i < n) (i.e. you will press first p_i buttons right and start performing the combo from the beginning). It is guaranteed that during the m+1-th try you press all buttons right and finally perform the combo.\n\nI.e. if s=\"abca\", m=2 and p = [1, 3] then the sequence of pressed buttons will be 'a' (here you're making a mistake and start performing the combo from the beginning), 'a', 'b', 'c', (here you're making a mistake and start performing the combo from the beginning), 'a' (note that at this point you will not perform the combo because of the mistake), 'b', 'c', 'a'.\n\nYour task is to calculate for each button (letter) the number of times you'll press it.\n\nYou have to answer t independent test cases.\n\nInput\n\nThe first line of the input contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThen t test cases follow.\n\nThe first line of each test case contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the length of s and the number of tries correspondingly.\n\nThe second line of each test case contains the string s consisting of n lowercase Latin letters.\n\nThe third line of each test case contains m integers p_1, p_2, ..., p_m (1 \u2264 p_i < n) \u2014 the number of characters pressed right during the i-th try.\n\nIt is guaranteed that the sum of n and the sum of m both does not exceed 2 \u22c5 10^5 (\u2211 n \u2264 2 \u22c5 10^5, \u2211 m \u2264 2 \u22c5 10^5).\n\nIt is guaranteed that the answer for each letter does not exceed 2 \u22c5 10^9.\n\nOutput\n\nFor each test case, print the answer \u2014 26 integers: the number of times you press the button 'a', the number of times you press the button 'b', ..., the number of times you press the button 'z'.\n\nExample\n\nInput\n\n\n3\n4 2\nabca\n1 3\n10 5\ncodeforces\n2 8 3 2 9\n26 10\nqwertyuioplkjhgfdsazxcvbnm\n20 10 1 2 3 5 10 5 9 4\n\n\nOutput\n\n\n4 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n0 0 9 4 5 3 0 0 0 0 0 0 0 0 9 0 0 3 1 0 0 0 0 0 0 0 \n2 1 1 2 9 2 2 2 5 2 2 2 1 1 5 4 11 8 2 7 5 1 10 1 5 2 \n\nNote\n\nThe first test case is described in the problem statement. Wrong tries are \"a\", \"abc\" and the final try is \"abca\". The number of times you press 'a' is 4, 'b' is 2 and 'c' is 2.\n\nIn the second test case, there are five wrong tries: \"co\", \"codeforc\", \"cod\", \"co\", \"codeforce\" and the final try is \"codeforces\". The number of times you press 'c' is 9, 'd' is 4, 'e' is 5, 'f' is 3, 'o' is 9, 'r' is 3 and 's' is 1.",
        "task_name": "1311_C. Perform the Combo",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n\n# from math import factorial as fac\nfrom collections import defaultdict\n# from copy import deepcopy\nimport sys, math\nf = None\ntry:\n\tf = open('q1.input', 'r')\nexcept IOError:\n\tf = sys.stdin\nif 'xrange' in dir(__builtins__):\n\trange = xrange\n# print(f.readline())\n# sys.setrecursionlimit(10**5)\n\n\t\ndef print_case_iterable(case_num, iterable):\n\tprint(\"Case #{}: {}\".format(case_num,\" \".join(map(str,iterable))))\n\ndef print_case_number(case_num, iterable):\n\tprint(\"Case #{}: {}\".format(case_num,iterable))\n\ndef print_iterable(A):\n\tprint (' '.join(A))\n\ndef read_int():\n\treturn int(f.readline().strip())\ndef read_int_array():\n\treturn [int(x) for x in f.readline().strip().split(\" \")]\ndef rns():\n\ta =  [x for x in f.readline().split(\" \")]\n\treturn int(a[0]), a[1].strip()\ndef read_string():\n\treturn list(f.readline().strip())\ndef bi(x):\n\treturn bin(x)[2:]\n\n\n\n\n\n\n\n\n\n\nfrom copy import deepcopy\ndef solution(s,n,p,m):\n\ts = [0] + s\n\tdp = [[0 for _ in range(26)] for _ in range(n+1)]\n\tp.sort()\n\tfor i in range(1,n+1):\n\t\tfor j in range(26):\n\t\t\tdp[i][j] = dp[i-1][j] + int(j == (ord(s[i])-ord('a')))\n\t#total m+1 tries\n\tres = [x for x in dp[n]]\n\tfor i in range(m):\n\t\tx=p[i]\n\t\tfor j in range(26):\n\t\t\tres[j]+=dp[x][j]\n\treturn ' '.join(map(str,res))\n\n\n\n\n\ndef main():\n\tT = read_int()\n\tfor i in range(T):\n\t\tn,m = read_int_array()\n\t\ts = read_string()\n\t\tp = read_int_array()\n\t\tx = solution(s,n,p,m)\n\n\t\tif 'xrange' not in dir(__builtins__):\n\t\t\tprint(x)\n\t\telse:\n\t\t\tprint >>output,str(x)# \"Case #\"+str(i+1)+':',\n\tif 'xrange' in dir(__builtins__):\n\t\tprint(output.getvalue())\n\t\toutput.close()\n\nif 'xrange' in dir(__builtins__):\n\timport cStringIO\n\toutput = cStringIO.StringIO()\n#example usage:\n#    for l in res:\n#       print >>output, str(len(l)) + ' ' +  ' '.join(l)\n\nif __name__ == '__main__':\n\tmain()\n\n\n\n'''stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* BITS - THINK HOW TO MASK PROPERLY\n\t* PERMUTATIONS - PARITY AND CYCLES\n\t* Think simple, if it becomes over complicated, try to look at it from a different perspective.\n\t* Have fun!!!\n\t* TRY FIXING SOMETHING, and then maybe binary search around it.\n\t* Remember heaps. \n\t* Remember how to add a value to a segment when using prefix sum.\n\t\tsuppose you have an array[1,2,3,4,5] and you want to add 3 to array[1:4]. Then just \n\t\tadd 3 to A[1], and decrease 3 from A[4]. Let's look at what happens:\n\t\toriginal prefixsums is \t\t\t\t\t [1,3,6,10,15]\n\t\tarray -> [1,5,3,4,2] and prefix sums are [1,6,9,13,15] \n\t\tAs you see, exactly +3 in A[1:4]\n\t\t*** The previous method can help checking how many x,y you can choose to get s=x+y from two arrays.\n'''\n'''\nbinary search \n\twhile(r - l > 1) {\n\t\tll mid = l + (r - l) / 2;\n\t\tsolve(mid);\n\t\tll sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum += b[i];\n\t\tif (sum <= k)\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t}\n'''\n",
        "correct": true,
        "task_id": "0096",
        "depth": 2
    },
    {
        "description": "Draw a chessboard which has a height of H cm and a width of W cm. For example, the following figure shows a chessboard which has a height of 6 cm and a width of 10 cm.\n\n\n.#.#.#.#.\n.#.#.#.#.#\n.#.#.#.#.\n.#.#.#.#.#\n.#.#.#.#.\n.#.#.#.#.#\n\n\nNote that the top left corner should be drawn by '#'.\n\nConstraints\n\n* 1 \u2264 H \u2264 300\n* 1 \u2264 W \u2264 300\n\nInput\n\nThe input consists of multiple datasets. Each dataset consists of two integers H and W separated by a single space.\n\nThe input ends with two 0 (when both H and W are zero).\n\nOutput\n\nFor each dataset, print the chessboard made of '#' and '.'.\n\nPrint a blank line after each dataset.\n\nExample\n\nInput\n\n3 4\n5 6\n3 3\n2 2\n1 1\n0 0\n\n\nOutput\n\n#.#.\n.#.#\n#.#.\n\n#.#.#.\n.#.#.#\n#.#.#.\n.#.#.#\n#.#.#.\n\n#.#\n.#.\n#.#\n\n#.\n.#\n\n#",
        "task_name": "p02405 Print a Chessboard",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def draw(h, w):\n    for i in range(h):\n        for j in range(w):\n            print(\"#\" if (i+j)%2 == 0 else \".\")\n        print(\"\")\n\nwhile True:\n    h, w = map(int, raw_input().split())\n    if h == 0 and w == 0:\n        break\n    draw(h, w)",
        "correct": false,
        "task_id": "0126",
        "depth": 2
    },
    {
        "description": "The football season has just ended in Berland. According to the rules of Berland football, each match is played between two teams. The result of each match is either a draw, or a victory of one of the playing teams. If a team wins the match, it gets w points, and the opposing team gets 0 points. If the game results in a draw, both teams get d points.\n\nThe manager of the Berland capital team wants to summarize the results of the season, but, unfortunately, all information about the results of each match is lost. The manager only knows that the team has played n games and got p points for them.\n\nYou have to determine three integers x, y and z \u2014 the number of wins, draws and loses of the team. If there are multiple answers, print any of them. If there is no suitable triple (x, y, z), report about it.\n\nInput\n\nThe first line contains four integers n, p, w and d (1 \u2264 n \u2264 10^{12}, 0 \u2264 p \u2264 10^{17}, 1 \u2264 d < w \u2264 10^{5}) \u2014 the number of games, the number of points the team got, the number of points awarded for winning a match, and the number of points awarded for a draw, respectively. Note that w > d, so the number of points awarded for winning is strictly greater than the number of points awarded for draw.\n\nOutput\n\nIf there is no answer, print -1.\n\nOtherwise print three non-negative integers x, y and z \u2014 the number of wins, draws and losses of the team. If there are multiple possible triples (x, y, z), print any of them. The numbers should meet the following conditions: \n\n  * x \u22c5 w + y \u22c5 d = p, \n  * x + y + z = n. \n\nExamples\n\nInput\n\n\n30 60 3 1\n\n\nOutput\n\n\n17 9 4\n\n\nInput\n\n\n10 51 5 4\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n20 0 15 5\n\n\nOutput\n\n\n0 0 20\n\nNote\n\nOne of the possible answers in the first example \u2014 17 wins, 9 draws and 4 losses. Then the team got 17 \u22c5 3 + 9 \u22c5 1 = 60 points in 17 + 9 + 4 = 30 games.\n\nIn the second example the maximum possible score is 10 \u22c5 5 = 50. Since p = 51, there is no answer.\n\nIn the third example the team got 0 points, so all 20 games were lost.",
        "task_name": "1244_C. The Football Season",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\n[n,p,w,d]=[int(i) for i in sys.stdin.readline().split()]\n\nx=-1\ny=-1\nz=-1\n\ndone=0\n\nfor i in range(w):\n\tif((p-i*d)%w==0):\n\t\tj=(p-i*d)//w\n\t\tif(i+j<=n):\n\t\t\tx,y,z=j,i,n-j-i\n\t\t\tdone=1\n\t\t\tbreak\n\nif(done==1):\n\tprint(str(x)+\" \"+str(y)+\" \"+str(z))\nelse:\n\tprint(-1)",
        "correct": false,
        "task_id": "0130",
        "depth": 1
    },
    {
        "description": "Consider an infinite triangle made up of layers. Let's number the layers, starting from one, from the top of the triangle (from top to bottom). The k-th layer of the triangle contains k points, numbered from left to right. Each point of an infinite triangle is described by a pair of numbers (r, c) (1 \u2264 c \u2264 r), where r is the number of the layer, and c is the number of the point in the layer. From each point (r, c) there are two directed edges to the points (r+1, c) and (r+1, c+1), but only one of the edges is activated. If r + c is even, then the edge to the point (r+1, c) is activated, otherwise the edge to the point (r+1, c+1) is activated. Look at the picture for a better understanding.\n\n<image> Activated edges are colored in black. Non-activated edges are colored in gray.\n\nFrom the point (r_1, c_1) it is possible to reach the point (r_2, c_2), if there is a path between them only from activated edges. For example, in the picture above, there is a path from (1, 1) to (3, 2), but there is no path from (2, 1) to (1, 1).\n\nInitially, you are at the point (1, 1). For each turn, you can: \n\n  * Replace activated edge for point (r, c). That is if the edge to the point (r+1, c) is activated, then instead of it, the edge to the point (r+1, c+1) becomes activated, otherwise if the edge to the point (r+1, c+1), then instead if it, the edge to the point (r+1, c) becomes activated. This action increases the cost of the path by 1; \n  * Move from the current point to another by following the activated edge. This action does not increase the cost of the path. \n\n\n\nYou are given a sequence of n points of an infinite triangle (r_1, c_1), (r_2, c_2), \u2026, (r_n, c_n). Find the minimum cost path from (1, 1), passing through all n points in arbitrary order.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) is the number of test cases. Then t test cases follow.\n\nEach test case begins with a line containing one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) is the number of points to visit.\n\nThe second line contains n numbers r_1, r_2, \u2026, r_n (1 \u2264 r_i \u2264 10^9), where r_i is the number of the layer in which i-th point is located.\n\nThe third line contains n numbers c_1, c_2, \u2026, c_n (1 \u2264 c_i \u2264 r_i), where c_i is the number of the i-th point in the r_i layer.\n\nIt is guaranteed that all n points are distinct.\n\nIt is guaranteed that there is always at least one way to traverse all n points.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output the minimum cost of a path passing through all points in the corresponding test case.\n\nExample\n\nInput\n\n\n4\n3\n1 4 2\n1 3 1\n2\n2 4\n2 3\n2\n1 1000000000\n1 1000000000\n4\n3 10 5 8\n2 5 2 4\n\n\nOutput\n\n\n0\n1\n999999999\n2",
        "task_name": "1506_F. Triangular Paths",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Enter your code here. Read input from STDIN. Print output to STDOUT# ===============================================================================================\n# importing some useful libraries.\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom itertools import *\nimport bisect\nfrom heapq import *\nfrom math import ceil, floor\nfrom copy import *\nfrom collections import deque, defaultdict\nfrom collections import Counter as counter  # Counter(list)  return a dict with {key: count}\nfrom itertools import combinations  # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\nfrom itertools import permutations as permutate\nfrom bisect import bisect_left as bl\nfrom operator import *\n# If the element is already present in the list,\n\n# the left most position where element has to be inserted is returned.\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n# If the element is already present in the list,\n# the right most position where element has to be inserted is returned\n\n# ==============================================================================================\n# fast I/O region\n\nBUFSIZE = 8192\nfrom sys import stderr\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"A\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for A in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(A))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\n\n\ndef iterative(f, stack=[]):\n    def wrapped_func(*args, **kwargs):\n        if stack: return f(*args, **kwargs)\n        to = f(*args, **kwargs)\n        while True:\n            if type(to) is GeneratorType:\n                stack.append(to)\n                to = next(to)\n                continue\n            stack.pop()\n            if not stack: break\n            to = stack[-1].send(to)\n        return to\n\n    return wrapped_func\n\n\n#### END ITERATE RECURSION ####\n###########################\n# Sorted list\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[start:start + _load] for start in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for start in range(len(_fen_tree)):\n            if start | start + 1 < len(_fen_tree):\n                _fen_tree[start | start + 1] += _fen_tree[start]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        A = 0\n        while end:\n            A += _fen_tree[end - 1]\n            end &= end - 1\n        return A\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\n\n# ===============================================================================================\n# some shortcuts\n\nmod = 1000000007\n\n\ndef testcase(t):\n    for p in range(t):\n        solve()\n\n\ndef pow(A, B, p):\n    res = 1  # Initialize result\n    A = A % p  # Update A if it is more , than or equal to p\n    if (A == 0):\n        return 0\n    while (B > 0):\n        if ((B & 1) == 1):  # If B is odd, multiply, A with result\n            res = (res * A) % p\n\n        B = B >> 1  # B = B/2\n        A = (A * A) % p\n    return res\n\n\nfrom functools import reduce\n\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([start, n // start] for start in range(1, int(n ** 0.5) + 1) if n % start == 0)))\n\n\ndef gcd(a, b):\n    if a == b: return a\n    while b > 0: a, b = b, a % b\n    return a\n\n\n# discrete binary search\n# minimise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for start in range(200):\n#         if isvalid(l):\n#             return l\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m - 1):\n#             return m\n#         if isvalid(m):\n#             r = m + 1\n#         else:\n#             l = m\n#     return m\n\n# maximise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for start in range(200):\n#         # print(l,r)\n#         if isvalid(r):\n#             return r\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m + 1):\n#             return m\n#         if isvalid(m):\n#             l = m\n#         else:\n#             r = m - 1\n#     return m\n\n\n##############Find sum of product of subsets of size k in a array\n# ar=[0,1,2,3]\n# k=3\n# n=len(ar)-1\n# dp=[0]*(n+1)\n# dp[0]=1\n# for pos in range(1,n+1):\n#     dp[pos]=0\n#     l=max(1,k+pos-n-1)\n#     for j in range(min(pos,k),l-1,-1):\n#         dp[j]=dp[j]+ar[pos]*dp[j-1]\n# print(dp[k])\n\ndef prefix_sum(ar):  # [1,2,3,4]->[1,3,6,10]\n    return list(accumulate(ar))\n\n\ndef suffix_sum(ar):  # [1,2,3,4]->[10,9,7,4]\n    return list(accumulate(ar[::-1]))[::-1]\n\n\ndef N():\n    return int(inp())\n\n\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\n\ndef YES():\n    print(\"YES\")\n\n\ndef NO():\n    print(\"NO\")\n\n\ndef Yes():\n    print(\"Yes\")\n\n\ndef No():\n    print(\"No\")\n\n\n# =========================================================================================\nfrom collections import defaultdict\n\n\ndef numberOfSetBits(start):\n    start = start - ((start >> 1) & 0x55555555)\n    start = (start & 0x33333333) + ((start >> 2) & 0x33333333)\n    return (((start + (start >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        # self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        # self.lista[a] += self.lista[b]\n        # self.lista[b] = []\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef lcm(a, b):\n    return abs((a // gcd(a, b)) * b)\n\n\n# #\n# to find factorial and ncr\n# tot = 100005\n# mod = 10**9 + 7\n# fac = [1, 1]\n# finv = [1, 1]\n# inv = [0, 1]\n#\n# for start in range(2, tot + 1):\n#     fac.append((fac[-1] * start) % mod)\n#     inv.append(mod - (inv[mod % start] * (mod // start) % mod))\n#     finv.append(finv[-1] * inv[-1] % mod)\n\n\ndef comb(n, r):\n    if n < r:\n        return 0\n    else:\n        return fac[n] * (finv[r] * finv[n - r] % mod) % mod\n\n\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\")  # for fast input\n\n\ndef out(var): sys.stdout.write(str(var))  # for fast output, always take string\n\n\ndef lis(): return list(map(int, inp().split()))\n\n\ndef stringlis(): return list(map(str, inp().split()))\n\n\ndef sep(): return map(int, inp().split())\n\n\ndef strsep(): return map(str, inp().split())\n\n\ndef fsep(): return map(float, inp().split())\n\n\ndef nextline(): out(\"\\n\")  # as stdout.write always print sring.\n\n\ndef arr1d(n, v):\n    return [v] * n\n\n\ndef arr2d(n, m, v):\n    return [[v] * m for _ in range(n)]\n\n\ndef arr3d(n, m, p, v):\n    return [[[v] * p for _ in range(m)] for start in range(n)]\n\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\n\n# co-ordinate compression\n# ma={s:idx for idx,s in enumerate(sorted(set(l+r)))}\n\n# mxn=100005\n# lrg=[0]*mxn\n# for start in range(2,mxn-3):\n#     if (lrg[start]==0):\n#         for j in range(start,mxn-3,start):\n#             lrg[j]=start\n\n\ndef solve():\n    n=N()\n    r=lis()\n    c=lis()\n    points=[]\n    for i in range(n):\n        points.append((r[i],c[i]))\n    points.append((1,1))\n    points.sort()\n    ans=0\n    n+=1\n    for i in range(n-1):\n        x,y=points[i]\n        nx,ny=points[i+1]\n        plus1=ny-y\n        same=nx-x-plus1\n        # print(same,plus1,\"h\")\n        if((x+y) %2 ==1):\n            o=1\n        else:\n            o=0\n        if(plus1==0):\n            if(o):\n                ans+= same//2\n                ans+=same%2\n                continue\n            else:\n                same-=1\n                ans += same // 2\n                ans += same % 2\n                continue\n\n        if(same==0):\n            if(o):\n                ans+=0\n                continue\n            else:\n                ans+=plus1\n                continue\n\n\n        if (o):\n            ans += same // 2\n            ans += same % 2\n            continue\n        else:\n            same-=1\n            ans += same // 2\n            ans += same % 2\n            continue\n    print(ans)\n\n\n\n\n\n\n\n\n# solve()\ntestcase(N())",
        "correct": true,
        "task_id": "0137",
        "depth": 1
    },
    {
        "description": "One day n friends gathered together to play \"Mafia\". During each round of the game some player must be the supervisor and other n - 1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the i-th person wants to play ai rounds. What is the minimum number of rounds of the \"Mafia\" game they need to play to let each person play at least as many rounds as they want?\n\nInput\n\nThe first line contains integer n (3 \u2264 n \u2264 105). The second line contains n space-separated integers a1, a2, ..., an (1 \u2264 ai \u2264 109) \u2014 the i-th number in the list is the number of rounds the i-th person wants to play.\n\nOutput\n\nIn a single line print a single integer \u2014 the minimum number of game rounds the friends need to let the i-th person play at least ai rounds.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nExamples\n\nInput\n\n3\n3 2 2\n\n\nOutput\n\n4\n\n\nInput\n\n4\n2 2 2 2\n\n\nOutput\n\n3\n\nNote\n\nYou don't need to know the rules of \"Mafia\" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).",
        "task_name": "348_A. Mafia",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import math\n\ntry:\n    import psyco\n    psyco.full()\nexcept:\n    pass\n\ndef main():\n    from sys import stdin, stdout\n    \n    \n    n = int(stdin.readline())\n    array = map(int,stdin.readline().split())   \n    \n    sum = 0.0\n    \n    \n    max = array[0]\n    for a in array:\n        sum += a\n        if a > max:\n            max = a\n\n    p = math.ceil(sum / (n - 1))    \n    \n    while p*(n - 1) < sum:\n        p += 1\n    \n    if p < max:\n        p = max\n    \n    stdout.write(str(int(p)) + '\\n')\n\nmain()\n",
        "correct": true,
        "task_id": "0141",
        "depth": 1
    },
    {
        "description": "Snuke is conducting an optical experiment using mirrors and his new invention, the rifle of Mysterious Light.\n\nThree mirrors of length N are set so that they form an equilateral triangle. Let the vertices of the triangle be a, b and c.\n\nInside the triangle, the rifle is placed at the point p on segment ab such that ap = X. (The size of the rifle is negligible.) Now, the rifle is about to fire a ray of Mysterious Light in the direction of bc.\n\nThe ray of Mysterious Light will travel in a straight line, and will be reflected by mirrors, in the same ways as \"ordinary\" light. There is one major difference, though: it will be also reflected by its own trajectory as if it is a mirror! When the ray comes back to the rifle, the ray will be absorbed.\n\nThe following image shows the ray's trajectory where N = 5 and X = 2.\n\nbtriangle.png\n\nIt can be shown that the ray eventually comes back to the rifle and is absorbed, regardless of the values of N and X. Find the total length of the ray's trajectory.\n\nConstraints\n\n* 2\u2266N\u226610^{12}\n* 1\u2266X\u2266N-1\n* N and X are integers.\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN X\n\n\nOutput\n\nPrint the total length of the ray's trajectory.\n\nExample\n\nInput\n\n5 2\n\n\nOutput\n\n12",
        "task_name": "p04048 AtCoder Grand Contest 001 - Mysterious Light",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "L = map(int, raw_input().split())\nn = L[0]\nx = L[1]\nres = n\na = x\nb = n-x\nflag = True\nwhile flag :\n    if a > b:\n        q = a // b\n        a -= q*b\n        res += 2*q*b\n    elif  b > a:\n        q = b // a\n        b -= q*a\n        res += 2*a*q\n    else:\n        res += a\n        flag = False\nprint(res)",
        "correct": false,
        "task_id": "0160",
        "depth": 1
    },
    {
        "description": "Mad scientist Mike has just finished constructing a new device to search for extraterrestrial intelligence! He was in such a hurry to launch it for the first time that he plugged in the power wires without giving it a proper glance and started experimenting right away. After a while Mike observed that the wires ended up entangled and now have to be untangled again.\n\nThe device is powered by two wires \"plus\" and \"minus\". The wires run along the floor from the wall (on the left) to the device (on the right). Both the wall and the device have two contacts in them on the same level, into which the wires are plugged in some order. The wires are considered entangled if there are one or more places where one wire runs above the other one. For example, the picture below has four such places (top view):\n\n<image>\n\nMike knows the sequence in which the wires run above each other. Mike also noticed that on the left side, the \"plus\" wire is always plugged into the top contact (as seen on the picture). He would like to untangle the wires without unplugging them and without moving the device. Determine if it is possible to do that. A wire can be freely moved and stretched on the floor, but cannot be cut.\n\nTo understand the problem better please read the notes to the test samples.\n\nInput\n\nThe single line of the input contains a sequence of characters \"+\" and \"-\" of length n (1 \u2264 n \u2264 100000). The i-th (1 \u2264 i \u2264 n) position of the sequence contains the character \"+\", if on the i-th step from the wall the \"plus\" wire runs above the \"minus\" wire, and the character \"-\" otherwise.\n\nOutput\n\nPrint either \"Yes\" (without the quotes) if the wires can be untangled or \"No\" (without the quotes) if the wires cannot be untangled.\n\nExamples\n\nInput\n\n-++-\n\n\nOutput\n\nYes\n\n\nInput\n\n+-\n\n\nOutput\n\nNo\n\n\nInput\n\n++\n\n\nOutput\n\nYes\n\n\nInput\n\n-\n\n\nOutput\n\nNo\n\nNote\n\nThe first testcase corresponds to the picture in the statement. To untangle the wires, one can first move the \"plus\" wire lower, thus eliminating the two crosses in the middle, and then draw it under the \"minus\" wire, eliminating also the remaining two crosses.\n\nIn the second testcase the \"plus\" wire makes one full revolution around the \"minus\" wire. Thus the wires cannot be untangled: \n\n<image>\n\nIn the third testcase the \"plus\" wire simply runs above the \"minus\" wire twice in sequence. The wires can be untangled by lifting \"plus\" and moving it higher: \n\n<image>\n\nIn the fourth testcase the \"minus\" wire runs above the \"plus\" wire once. The wires cannot be untangled without moving the device itself: \n\n<image>",
        "task_name": "343_B. Alternating Current",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Enter your code here. Read input from STDIN. Print output to STDOUT# ===============================================================================================\n# importing some useful libraries.\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom itertools import *\nimport bisect\nfrom heapq import *\nfrom math import ceil, floor\nfrom copy import *\nfrom collections import deque, defaultdict\nfrom collections import Counter as counter  # Counter(list)  return a dict with {key: count}\nfrom itertools import combinations  # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\nfrom itertools import permutations as permutate\nfrom bisect import bisect_left as bl\nfrom operator import *\n# If the element is already present in the list,\n\n# the left most position where element has to be inserted is returned.\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n# If the element is already present in the list,\n# the right most position where element has to be inserted is returned\n\n# ==============================================================================================\n# fast I/O region\n\nBUFSIZE = 8192\nfrom sys import stderr\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"A\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for A in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(A))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\n\n\ndef iterative(f, stack=[]):\n    def wrapped_func(*args, **kwargs):\n        if stack: return f(*args, **kwargs)\n        to = f(*args, **kwargs)\n        while True:\n            if type(to) is GeneratorType:\n                stack.append(to)\n                to = next(to)\n                continue\n            stack.pop()\n            if not stack: break\n            to = stack[-1].send(to)\n        return to\n\n    return wrapped_func\n\n\n#### END ITERATE RECURSION ####\n###########################\n# Sorted list\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[start:start + _load] for start in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for start in range(len(_fen_tree)):\n            if start | start + 1 < len(_fen_tree):\n                _fen_tree[start | start + 1] += _fen_tree[start]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        A = 0\n        while end:\n            A += _fen_tree[end - 1]\n            end &= end - 1\n        return A\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\n\n# ===============================================================================================\n# some shortcuts\n\nmod = 1000000007\n\n\ndef testcase(t):\n    for p in range(t):\n        solve()\n\n\ndef pow(A, B, p):\n    res = 1  # Initialize result\n    A = A % p  # Update A if it is more , than or equal to p\n    if (A == 0):\n        return 0\n    while (B > 0):\n        if ((B & 1) == 1):  # If B is odd, multiply, A with result\n            res = (res * A) % p\n\n        B = B >> 1  # B = B/2\n        A = (A * A) % p\n    return res\n\n\nfrom functools import reduce\n\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([start, n // start] for start in range(1, int(n ** 0.5) + 1) if n % start == 0)))\n\n\ndef gcd(a, b):\n    if a == b: return a\n    while b > 0: a, b = b, a % b\n    return a\n\n\n# discrete binary search\n# minimise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for start in range(200):\n#         if isvalid(l):\n#             return l\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m - 1):\n#             return m\n#         if isvalid(m):\n#             r = m + 1\n#         else:\n#             l = m\n#     return m\n\n# maximise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for start in range(200):\n#         # print(l,r)\n#         if isvalid(r):\n#             return r\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m + 1):\n#             return m\n#         if isvalid(m):\n#             l = m\n#         else:\n#             r = m - 1\n#     return m\n\n\n##############Find sum of product of subsets of size k in a array\n# ar=[0,1,2,3]\n# k=3\n# n=len(ar)-1\n# dp=[0]*(n+1)\n# dp[0]=1\n# for pos in range(1,n+1):\n#     dp[pos]=0\n#     l=max(1,k+pos-n-1)\n#     for j in range(min(pos,k),l-1,-1):\n#         dp[j]=dp[j]+ar[pos]*dp[j-1]\n# print(dp[k])\n\ndef prefix_sum(ar):  # [1,2,3,4]->[1,3,6,10]\n    return list(accumulate(ar))\n\n\ndef suffix_sum(ar):  # [1,2,3,4]->[10,9,7,4]\n    return list(accumulate(ar[::-1]))[::-1]\n\n\ndef N():\n    return int(inp())\n\n\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\n\ndef YES():\n    print(\"YES\")\n\n\ndef NO():\n    print(\"NO\")\n\n\ndef Yes():\n    print(\"Yes\")\n\n\ndef No():\n    print(\"No\")\n\n\n# =========================================================================================\nfrom collections import defaultdict\n\n\ndef numberOfSetBits(start):\n    start = start - ((start >> 1) & 0x55555555)\n    start = (start & 0x33333333) + ((start >> 2) & 0x33333333)\n    return (((start + (start >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        # self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        # self.lista[a] += self.lista[b]\n        # self.lista[b] = []\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef lcm(a, b):\n    return abs((a // gcd(a, b)) * b)\n\n\n# #\n# to find factorial and ncr\n# tot = 100005\n# mod = 10**9 + 7\n# fac = [1, 1]\n# finv = [1, 1]\n# inv = [0, 1]\n#\n# for start in range(2, tot + 1):\n#     fac.append((fac[-1] * start) % mod)\n#     inv.append(mod - (inv[mod % start] * (mod // start) % mod))\n#     finv.append(finv[-1] * inv[-1] % mod)\n\n\ndef comb(n, r):\n    if n < r:\n        return 0\n    else:\n        return fac[n] * (finv[r] * finv[n - r] % mod) % mod\n\n\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\")  # for fast input\n\n\ndef out(var): sys.stdout.write(str(var))  # for fast output, always take string\n\n\ndef lis(): return list(map(int, inp().split()))\n\n\ndef stringlis(): return list(map(str, inp().split()))\n\n\ndef sep(): return map(int, inp().split())\n\n\ndef strsep(): return map(str, inp().split())\n\n\ndef fsep(): return map(float, inp().split())\n\n\ndef nextline(): out(\"\\n\")  # as stdout.write always print sring.\n\n\ndef arr1d(n, v):\n    return [v] * n\n\n\ndef arr2d(n, m, v):\n    return [[v] * m for _ in range(n)]\n\n\ndef arr3d(n, m, p, v):\n    return [[[v] * p for _ in range(m)] for start in range(n)]\n\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\n\n# co-ordinate compression\n# ma={s:idx for idx,s in enumerate(sorted(set(l+r)))}\n\n# mxn=100005\n# lrg=[0]*mxn\n# for start in range(2,mxn-3):\n#     if (lrg[start]==0):\n#         for j in range(start,mxn-3,start):\n#             lrg[j]=start\n\n\ndef solve():\n    s=inp()\n    ar=[s[0]]\n    n=len(s)\n    for i in range(1,n):\n        if(ar and ar[-1]==s[i]):ar.pop()\n        else:ar.append(s[i])\n    if(len(ar)==0):\n        Yes()\n    else:\n        No()\n\n\n\n\nsolve()\n#testcase(N())",
        "correct": true,
        "task_id": "0184",
        "depth": 1
    },
    {
        "description": "The only difference between easy and hard versions is constraints.\n\nYou are given n segments on the coordinate axis OX. Segments can intersect, lie inside each other and even coincide. The i-th segment is [l_i; r_i] (l_i \u2264 r_i) and it covers all integer points j such that l_i \u2264 j \u2264 r_i.\n\nThe integer point is called bad if it is covered by strictly more than k segments.\n\nYour task is to remove the minimum number of segments so that there are no bad points at all.\n\nInput\n\nThe first line of the input contains two integers n and k (1 \u2264 k \u2264 n \u2264 200) \u2014 the number of segments and the maximum number of segments by which each integer point can be covered.\n\nThe next n lines contain segments. The i-th line contains two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 200) \u2014 the endpoints of the i-th segment.\n\nOutput\n\nIn the first line print one integer m (0 \u2264 m \u2264 n) \u2014 the minimum number of segments you need to remove so that there are no bad points.\n\nIn the second line print m distinct integers p_1, p_2, ..., p_m (1 \u2264 p_i \u2264 n) \u2014 indices of segments you remove in any order. If there are multiple answers, you can print any of them.\n\nExamples\n\nInput\n\n\n7 2\n11 11\n9 11\n7 8\n8 9\n7 8\n9 11\n7 9\n\n\nOutput\n\n\n3\n1 4 7 \n\n\nInput\n\n\n5 1\n29 30\n30 30\n29 29\n28 30\n30 30\n\n\nOutput\n\n\n3\n1 2 4 \n\n\nInput\n\n\n6 1\n2 3\n3 3\n2 3\n2 2\n2 3\n2 3\n\n\nOutput\n\n\n4\n1 3 5 6 ",
        "task_name": "1249_D1. Too Many Segments (easy version)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from heapq import *\ninput = __import__(\"sys\").stdin.readline\nn, k = map(int, input().split())\nseg = []\nevents = []\nremove = __import__(\"collections\").defaultdict(int)\nfor _ in xrange(n):\n\tl, r = map(int, input().split())\n\tseg.append((l, r))\n\tevents.append((l, True, r))\n\tevents.append((r + 1, False, None))\nevents.sort(reverse=True)\ncover = 0\nheap = []  # (-end, start)\nrem = 0\npost = __import__(\"collections\").defaultdict(int)\nwhile events:\n\tind, add, release = events.pop()\n\tif add:\n\t\tcover += 1\n\t\theappush(heap, (-release, ind))\n\telif post[ind]:\n\t\tpost[ind] -= 1\n\telse:\n\t\tcover -= 1\n\twhile events and events[-1][0] == ind:\n\t\tind, add, release = events.pop()\n\t\tif add:\n\t\t\tcover += 1\n\t\t\theappush(heap, (-release, ind))\n\t\telif post[ind]:\n\t\t\tpost[ind] -= 1\n\t\telse:\n\t\t\tcover -= 1\n\twhile cover > k:\n\t\tend, start = heappop(heap)\n\t\tend = -end\n\t\tpost[end + 1] += 1\n\t\tremove[(start, end)] += 1\n\t\trem += 1\n\t\tcover -= 1\nprint(rem)\nfor i in xrange(len(seg)):\n\tif remove[seg[i]]:\n\t\tprint(i + 1),\n\t\tremove[seg[i]] -= 1\nprint",
        "correct": true,
        "task_id": "0219",
        "depth": 2
    },
    {
        "description": "The princess is going to escape the dragon's cave, and she needs to plan it carefully.\n\nThe princess runs at vp miles per hour, and the dragon flies at vd miles per hour. The dragon will discover the escape after t hours and will chase the princess immediately. Looks like there's no chance to success, but the princess noticed that the dragon is very greedy and not too smart. To delay him, the princess decides to borrow a couple of bijous from his treasury. Once the dragon overtakes the princess, she will drop one bijou to distract him. In this case he will stop, pick up the item, return to the cave and spend f hours to straighten the things out in the treasury. Only after this will he resume the chase again from the very beginning.\n\nThe princess is going to run on the straight. The distance between the cave and the king's castle she's aiming for is c miles. How many bijous will she need to take from the treasury to be able to reach the castle? If the dragon overtakes the princess at exactly the same moment she has reached the castle, we assume that she reached the castle before the dragon reached her, and doesn't need an extra bijou to hold him off.\n\nInput\n\nThe input data contains integers vp, vd, t, f and c, one per line (1 \u2264 vp, vd \u2264 100, 1 \u2264 t, f \u2264 10, 1 \u2264 c \u2264 1000).\n\nOutput\n\nOutput the minimal number of bijous required for the escape to succeed.\n\nExamples\n\nInput\n\n1\n2\n1\n1\n10\n\n\nOutput\n\n2\n\n\nInput\n\n1\n2\n1\n1\n8\n\n\nOutput\n\n1\n\nNote\n\nIn the first case one hour after the escape the dragon will discover it, and the princess will be 1 mile away from the cave. In two hours the dragon will overtake the princess 2 miles away from the cave, and she will need to drop the first bijou. Return to the cave and fixing the treasury will take the dragon two more hours; meanwhile the princess will be 4 miles away from the cave. Next time the dragon will overtake the princess 8 miles away from the cave, and she will need the second bijou, but after this she will reach the castle without any further trouble.\n\nThe second case is similar to the first one, but the second time the dragon overtakes the princess when she has reached the castle, and she won't need the second bijou.",
        "task_name": "148_B. Escape",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "vp = int(raw_input())\nvd = int(raw_input())\nt_read = int(raw_input())\nf = int(raw_input())\nc = int(raw_input())\n\n\npl = 0\ndl = 0\nt = 1\ncount = 0\n\n# print(vp, vd, t_read, f, c)\n\n\nwhile (pl + vp <= c):\n    \n    pl += vp\n\n\n    if (t > t_read):\n        dl += vd\n        if (dl >= pl and pl + vp <= c):\n            count += 1\n            dl = pl\n            pl += ((2 * (dl / vd)) + f) * vp\n            # print((str(t), str(count), str(dl), str(pl)))  \n\n            # while (dl > 0 and pl + vp <= c):\n            #     dl = max(dl - vd, 0)\n            #     print((str(t), str(count), str(dl), str(pl)))\n            #     pl += vp\n            # pl += f * vp\n            # if (pl + vp >= c):\n            #     break\n            \n            \n            \n\n\n    \n    t += 1\n\nprint(count)\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# while (pl < c - vp):\n\n#     # if (t == 0):\n#     #     t += 1\n#     #     print((str(t), str(count), str(dl), str(pl), 'BBE'))\n#     #     continue\n\n#     pl += vp\n    \n\n#     if (t > t_read - 1):\n#         dl += vd\n    \n#     lc = 0\n#     if (pl <= dl):\n#         count+=1\n#         lc+=1\n#         t = (t_read) - dl/vd - f\n#         print((str(t), str(count), str(dl), str(pl), 'CC'))\n#         # pl = pl + vp\n#         # if ()\n#         dl = 0\n#         # continue\n#     if (lc == 1):\n#         t_read -=1\n#     # print((str(t), str(count), str(dl), str(pl), 'BB'))\n#     t += 1\n   \n\n# print(count)\n\n# 1\n# 2\n# 1\n# 1\n# 8\n\n\n    ",
        "correct": false,
        "task_id": "0228",
        "depth": 1
    },
    {
        "description": "There are N boxes arranged in a row from left to right. The i-th box from the left contains A_i candies.\n\nYou will take out the candies from some consecutive boxes and distribute them evenly to M children.\n\nSuch being the case, find the number of the pairs (l, r) that satisfy the following:\n\n* l and r are both integers and satisfy 1 \\leq l \\leq r \\leq N.\n* A_l + A_{l+1} + ... + A_r is a multiple of M.\n\nConstraints\n\n* All values in input are integers.\n* 1 \\leq N \\leq 10^5\n* 2 \\leq M \\leq 10^9\n* 1 \\leq A_i \\leq 10^9\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M\nA_1 A_2 ... A_N\n\n\nOutput\n\nPrint the number of the pairs (l, r) that satisfy the conditions.\n\nNote that the number may not fit into a 32-bit integer type.\n\nExamples\n\nInput\n\n3 2\n4 1 5\n\n\nOutput\n\n3\n\n\nInput\n\n13 17\n29 7 5 7 9 51 7 13 8 55 42 9 81\n\n\nOutput\n\n6\n\n\nInput\n\n10 400000000\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n25",
        "task_name": "p03287 AtCoder Beginner Contest 105 - Candy Distribution",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "N, M = map(int, raw_input().split())\nA = map(int, raw_input().split())\n\nAX = [0]\ns = 0\nfor a in A:\n    s += a\n    AX.append(s)\n\nresult = 0\nfor i in range(1, N+1):\n    for j in range(i, N+1):\n        if (AX[j] - AX[i-1]) % M == 0:\n            result += 1\nprint(result)\n",
        "correct": false,
        "task_id": "0251",
        "depth": 2
    },
    {
        "description": "Tonight is brain dinner night and all zombies will gather together to scarf down some delicious brains. The artful Heidi plans to crash the party, incognito, disguised as one of them. Her objective is to get away with at least one brain, so she can analyze the zombies' mindset back home and gain a strategic advantage.\n\nThey will be N guests tonight: N - 1 real zombies and a fake one, our Heidi. The living-dead love hierarchies as much as they love brains: each one has a unique rank in the range 1 to N - 1, and Heidi, who still appears slightly different from the others, is attributed the highest rank, N. Tonight there will be a chest with brains on display and every attendee sees how many there are. These will then be split among the attendees according to the following procedure:\n\nThe zombie of the highest rank makes a suggestion on who gets how many brains (every brain is an indivisible entity). A vote follows. If at least half of the attendees accept the offer, the brains are shared in the suggested way and the feast begins. But if majority is not reached, then the highest-ranked zombie is killed, and the next zombie in hierarchy has to make a suggestion. If he is killed too, then the third highest-ranked makes one, etc. (It's enough to have exactly half of the votes \u2013 in case of a tie, the vote of the highest-ranked alive zombie counts twice, and he will of course vote in favor of his own suggestion in order to stay alive.)\n\nYou should know that zombies are very greedy and sly, and they know this too \u2013 basically all zombie brains are alike. Consequently, a zombie will never accept an offer which is suboptimal for him. That is, if an offer is not strictly better than a potential later offer, he will vote against it. And make no mistake: while zombies may normally seem rather dull, tonight their intellects are perfect. Each zombie's priorities for tonight are, in descending order: \n\n  1. survive the event (they experienced death already once and know it is no fun), \n  2. get as many brains as possible. \n\n\n\nHeidi goes first and must make an offer which at least half of the attendees will accept, and which allocates at least one brain for Heidi herself.\n\nWhat is the smallest number of brains that have to be in the chest for this to be possible?\n\nInput\n\nThe only line of input contains one integer: N, the number of attendees (1 \u2264 N \u2264 109).\n\nOutput\n\nOutput one integer: the smallest number of brains in the chest which allows Heidi to take one brain home.\n\nExamples\n\nInput\n\n1\n\n\nOutput\n\n1\n\n\nInput\n\n4\n\n\nOutput\n\n2\n\nNote",
        "task_name": "690_A1. Collective Mindsets (easy)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import fileinput\nimport math\n\nfor line in fileinput.input():\n    attendees = int(line.strip())\n    min_brains = math.ceil(attendees / 2)\n    min_brains = max(1, min_brains)\n    print(min_brains)\n    ",
        "correct": false,
        "task_id": "0283",
        "depth": 1
    },
    {
        "description": "In Berland each high school student is characterized by academic performance \u2014 integer value between 1 and 5.\n\nIn high school 0xFF there are two groups of pupils: the group A and the group B. Each group consists of exactly n students. An academic performance of each student is known \u2014 integer value between 1 and 5.\n\nThe school director wants to redistribute students between groups so that each of the two groups has the same number of students whose academic performance is equal to 1, the same number of students whose academic performance is 2 and so on. In other words, the purpose of the school director is to change the composition of groups, so that for each value of academic performance the numbers of students in both groups are equal.\n\nTo achieve this, there is a plan to produce a series of exchanges of students between groups. During the single exchange the director selects one student from the class A and one student of class B. After that, they both change their groups.\n\nPrint the least number of exchanges, in order to achieve the desired equal numbers of students for each academic performance.\n\nInput\n\nThe first line of the input contains integer number n (1 \u2264 n \u2264 100) \u2014 number of students in both groups.\n\nThe second line contains sequence of integer numbers a1, a2, ..., an (1 \u2264 ai \u2264 5), where ai is academic performance of the i-th student of the group A.\n\nThe third line contains sequence of integer numbers b1, b2, ..., bn (1 \u2264 bi \u2264 5), where bi is academic performance of the i-th student of the group B.\n\nOutput\n\nPrint the required minimum number of exchanges or -1, if the desired distribution of students can not be obtained.\n\nExamples\n\nInput\n\n4\n5 4 4 4\n5 5 4 5\n\n\nOutput\n\n1\n\n\nInput\n\n6\n1 1 1 1 1 1\n5 5 5 5 5 5\n\n\nOutput\n\n3\n\n\nInput\n\n1\n5\n3\n\n\nOutput\n\n-1\n\n\nInput\n\n9\n3 2 5 5 2 3 3 3 2\n4 1 4 1 1 2 4 4 1\n\n\nOutput\n\n4",
        "task_name": "779_A. Pupils Redistribution",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, a, b, mem = int(input()), rints(), rints(), [[0 for _ in range(6)] for _ in range(2)]\nans = 0\n\nfor i in range(n):\n    mem[0][a[i]] += 1\n    mem[1][b[i]] += 1\n\nfor i in range(1, 6):\n    if (mem[0][i] + mem[1][i]) & 1:\n        ans = -1\n        break\n\n    ans += max((mem[0][i] - mem[1][i]) // 2, 0)\n\nprint(ans)\n",
        "correct": true,
        "task_id": "0285",
        "depth": 1
    },
    {
        "description": "You are given a directed acyclic graph with n vertices and m edges. There are no self-loops or multiple edges between any pair of vertices. Graph can be disconnected.\n\nYou should assign labels to all vertices in such a way that:\n\n  * Labels form a valid permutation of length n \u2014 an integer sequence such that each integer from 1 to n appears exactly once in it. \n  * If there exists an edge from vertex v to vertex u then labelv should be smaller than labelu. \n  * Permutation should be lexicographically smallest among all suitable. \n\n\n\nFind such sequence of labels to satisfy all the conditions.\n\nInput\n\nThe first line contains two integer numbers n, m (2 \u2264 n \u2264 105, 1 \u2264 m \u2264 105).\n\nNext m lines contain two integer numbers v and u (1 \u2264 v, u \u2264 n, v \u2260 u) \u2014 edges of the graph. Edges are directed, graph doesn't contain loops or multiple edges.\n\nOutput\n\nPrint n numbers \u2014 lexicographically smallest correct permutation of labels of vertices.\n\nExamples\n\nInput\n\n3 3\n1 2\n1 3\n3 2\n\n\nOutput\n\n1 3 2 \n\n\nInput\n\n4 5\n3 1\n4 1\n2 3\n3 4\n2 4\n\n\nOutput\n\n4 1 2 3 \n\n\nInput\n\n5 4\n3 1\n2 1\n2 3\n4 5\n\n\nOutput\n\n3 1 2 4 5 ",
        "task_name": "825_E. Minimal Labels",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\nimport sys,heapq\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\n# heap\navail=[]\n\nn,m=map(int,input().split())\nindeg=[0]*n\n\ng=[[] for _ in range(n)]\nfor _ in range(m):\n    u,v=map(int,input().split())\n    indeg[v-1]+=1\n    g[u-1].append(v-1)\n\nfor i in range(n):\n    if indeg[i]==0:\n        heapq.heappush(avail,i)\n\n# label nodes\nans=[0]*n\nlabel=1\n\nwhile avail:\n    u=heapq.heappop(avail)\n    ans[u]=label\n    label+=1\n    for v in g[u]:\n        indeg[v]-=1\n        if indeg[v]==0:\n            heapq.heappush(avail,v)\n\nprint(\" \".join(map(str,ans)))\n",
        "correct": false,
        "task_id": "0286",
        "depth": 2
    },
    {
        "description": "After reaching your destination, you want to build a new colony on the new planet. Since this planet has many mountains and the colony must be built on a flat surface you decided to flatten the mountains using boulders (you are still dreaming so this makes sense to you).\n\n<image>\n\nYou are given an array h_1, h_2, ..., h_n, where h_i is the height of the i-th mountain, and k \u2014 the number of boulders you have.\n\nYou will start throwing boulders from the top of the first mountain one by one and they will roll as follows (let's assume that the height of the current mountain is h_i): \n\n  * if h_i \u2265 h_{i + 1}, the boulder will roll to the next mountain; \n  * if h_i < h_{i + 1}, the boulder will stop rolling and increase the mountain height by 1 (h_i = h_i + 1); \n  * if the boulder reaches the last mountain it will fall to the waste collection system and disappear. \n\n\n\nYou want to find the position of the k-th boulder or determine that it will fall into the waste collection system.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases.\n\nEach test case consists of two lines. The first line in each test case contains two integers n and k (1 \u2264 n \u2264 100; 1 \u2264 k \u2264 10^9) \u2014 the number of mountains and the number of boulders.\n\nThe second line contains n integers h_1, h_2, ..., h_n (1 \u2264 h_i \u2264 100) \u2014 the height of the mountains.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 100.\n\nOutput\n\nFor each test case, print -1 if the k-th boulder will fall into the collection system. Otherwise, print the position of the k-th boulder.\n\nExample\n\nInput\n\n\n4\n4 3\n4 1 2 3\n2 7\n1 8\n4 5\n4 1 2 3\n3 1\n5 3 1\n\n\nOutput\n\n\n2\n1\n-1\n-1\n\nNote\n\nLet's simulate the first case:\n\n  * The first boulder starts at i = 1; since h_1 \u2265 h_2 it rolls to i = 2 and stops there because h_2 < h_3. \n  * The new heights are [4,2,2,3]. \n  * The second boulder starts at i = 1; since h_1 \u2265 h_2 the boulder rolls to i = 2; since h_2 \u2265 h_3 the boulder rolls to i = 3 and stops there because h_3 < h_4. \n  * The new heights are [4,2,3,3]. \n  * The third boulder starts at i = 1; since h_1 \u2265 h_2 it rolls to i = 2 and stops there because h_2 < h_3. \n  * The new heights are [4,3,3,3]. \n\n\n\nThe positions where each boulder stopped are the following: [2,3,2].\n\nIn the second case, all 7 boulders will stop right at the first mountain rising its height from 1 to 8.\n\nThe third case is similar to the first one but now you'll throw 5 boulders. The first three will roll in the same way as in the first test case. After that, mountain heights will be equal to [4, 3, 3, 3], that's why the other two boulders will fall into the collection system.\n\nIn the fourth case, the first and only boulders will fall straight into the collection system.",
        "task_name": "1481_B. New Colony",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\ntesting = len(sys.argv) == 4 and sys.argv[3] == \"myTest\"\nif testing:\n    cmd = sys.stdout\n    from time import time\n    start_time = int(round(time() * 1000)) \n    readAll = open(sys.argv[1], 'r').read\n    sys.stdout = open(sys.argv[2], 'w')\nelse:\n    readAll = sys.stdin.read\n\n# ############ ---- I/O Functions ---- ############\n\nclass InputData:\n    def __init__(self):\n        self.lines = readAll().split('\\n')\n        self.n = len(self.lines)\n        self.ii = -1\n    def input(self):\n        self.ii += 1\n        assert self.ii < self.n\n        return self.lines[self.ii]\ninputData = InputData()\ninput = inputData.input\n\ndef intin():\n    return(int(input()))\ndef intlin():\n    return(list(map(int,input().split())))\ndef chrin():\n    return(list(input()))\ndef strin():\n    return input()\ndef lout(l, sep=\"\\n\"):\n    print(sep.join(l))\n    \n# ############ ---- I/O Functions ---- ############\n\n# from math import ceil\n# from collections import defaultdict as ddict, Counter\n# from heapq import *\n# from Queue import Queue\n\ndef main():\n    n,k = intlin()\n    h = intlin()\n    if n == 1:\n        print(-1)\n        return\n    while k > 0:\n        i = 1\n        while i < n:\n            if h[i-1] >= h[i]:\n                i += 1\n            else:\n                h[i-1] += 1\n                k -= 1\n                break\n        if i == n:\n            print(-1)\n            return\n    print(i)\n\n\n\nfor _ in xrange(intin()):\n    main()\n    # print(\"YES\" if main() else \"NO\")\n# main()\n\nif testing:\n    sys.stdout = cmd\n    print(int(round(time() * 1000))  - start_time)",
        "correct": true,
        "task_id": "0316",
        "depth": 2
    },
    {
        "description": "Karen has just arrived at school, and she has a math test today!\n\n<image>\n\nThe test is about basic addition and subtraction. Unfortunately, the teachers were too busy writing tasks for Codeforces rounds, and had no time to make an actual test. So, they just put one question in the test that is worth all the points.\n\nThere are n integers written on a row. Karen must alternately add and subtract each pair of adjacent integers, and write down the sums or differences on the next row. She must repeat this process on the values on the next row, and so on, until only one integer remains. The first operation should be addition.\n\nNote that, if she ended the previous row by adding the integers, she should start the next row by subtracting, and vice versa.\n\nThe teachers will simply look at the last integer, and then if it is correct, Karen gets a perfect score, otherwise, she gets a zero for the test.\n\nKaren has studied well for this test, but she is scared that she might make a mistake somewhere and it will cause her final answer to be wrong. If the process is followed, what number can she expect to be written on the last row?\n\nSince this number can be quite large, output only the non-negative remainder after dividing it by 109 + 7.\n\nInput\n\nThe first line of input contains a single integer n (1 \u2264 n \u2264 200000), the number of numbers written on the first row.\n\nThe next line contains n integers. Specifically, the i-th one among these is ai (1 \u2264 ai \u2264 109), the i-th number on the first row.\n\nOutput\n\nOutput a single integer on a line by itself, the number on the final row after performing the process above.\n\nSince this number can be quite large, print only the non-negative remainder after dividing it by 109 + 7.\n\nExamples\n\nInput\n\n5\n3 6 9 12 15\n\n\nOutput\n\n36\n\n\nInput\n\n4\n3 7 5 2\n\n\nOutput\n\n1000000006\n\nNote\n\nIn the first test case, the numbers written on the first row are 3, 6, 9, 12 and 15.\n\nKaren performs the operations as follows:\n\n<image>\n\nThe non-negative remainder after dividing the final number by 109 + 7 is still 36, so this is the correct output.\n\nIn the second test case, the numbers written on the first row are 3, 7, 5 and 2.\n\nKaren performs the operations as follows:\n\n<image>\n\nThe non-negative remainder after dividing the final number by 109 + 7 is 109 + 6, so this is the correct output.",
        "task_name": "815_B. Karen and Test",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def binseq(n,p):\n    l = [1]*(n+1)\n    for i in range(n):\n        l[i+1] = (l[i]*(n-i)*pow(i+1,p-2,p)) % p\n    return l\ndef altseq(n,p):\n    l = []\n    if n % 4 == 0:\n        for e in binseq(n//2-1,p):\n            l+=[e,-e]\n        return l\n    if n % 4 == 1:\n        for e in binseq(n//2,p):\n            l+=[e,0]\n        l.pop(-1)\n        return l\n    if n % 4 == 2:\n        for e in binseq(n//2-1,p):\n            l+=[e,e]\n        return l\n    pre_l = []\n    for e in binseq(n//2-1,p):\n        pre_l += [e,e]\n    l.append(pre_l[0])\n    for i in range(1,n-1):\n        l.append(pre_l[i] + pre_l[i-1]*(-1)**(i+1))\n    l.append(pre_l[n-2]*(-1)**n)\n    return l\nif __name__ == '__main__':\n    n = int(raw_input())\n    s = altseq(n,10**9+7)\n    t = 0\n    l = map(lambda x: int(x), raw_input().split(\" \"))\n    for i in range(n):\n        t += s[i]*l[i]\n        t %= 10**9+7\n    print(str(t))\n",
        "correct": true,
        "task_id": "0333",
        "depth": 1
    },
    {
        "description": "Pashmak's homework is a problem about graphs. Although he always tries to do his homework completely, he can't solve this problem. As you know, he's really weak at graph theory; so try to help him in solving the problem.\n\nYou are given a weighted directed graph with n vertices and m edges. You need to find a path (perhaps, non-simple) with maximum number of edges, such that the weights of the edges increase along the path. In other words, each edge of the path must have strictly greater weight than the previous edge in the path.\n\nHelp Pashmak, print the number of edges in the required path.\n\nInput\n\nThe first line contains two integers n, m (2 \u2264 n \u2264 3\u00b7105; 1 \u2264 m \u2264 min(n\u00b7(n - 1), 3\u00b7105)). Then, m lines follows. The i-th line contains three space separated integers: ui, vi, wi (1 \u2264 ui, vi \u2264 n; 1 \u2264 wi \u2264 105) which indicates that there's a directed edge with weight wi from vertex ui to vertex vi.\n\nIt's guaranteed that the graph doesn't contain self-loops and multiple edges.\n\nOutput\n\nPrint a single integer \u2014 the answer to the problem.\n\nExamples\n\nInput\n\n3 3\n1 2 1\n2 3 1\n3 1 1\n\n\nOutput\n\n1\n\n\nInput\n\n3 3\n1 2 1\n2 3 2\n3 1 3\n\n\nOutput\n\n3\n\n\nInput\n\n6 7\n1 2 1\n3 2 5\n2 4 2\n2 5 2\n2 6 9\n5 4 3\n4 3 4\n\n\nOutput\n\n6\n\nNote\n\nIn the first sample the maximum trail can be any of this trails: <image>.\n\nIn the second sample the maximum trail is <image>.\n\nIn the third sample the maximum trail is <image>.",
        "task_name": "459_E. Pashmak and Graph",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrints_2d = lambda n: [rints() for _ in range(n)]\n\nn, m = rints()\nmem, edges, weight = [0] * (n + 1), rints_2d(m), [[] for _ in range(10 ** 5 + 1)]\n\nfor u, v, w in edges:\n    weight[w].append((u, v))\n\nfor i in range(1, 10 ** 5 + 1):\n    all = [(v, mem[u]) for u, v in weight[i]]\n    for v, du in all:\n        mem[v] = max(mem[v], du + 1)\n\nprint(max(mem))\n",
        "correct": true,
        "task_id": "0365",
        "depth": 2
    },
    {
        "description": "Given an array a of length n, find another array, b, of length n such that:\n\n  * for each i (1 \u2264 i \u2264 n) MEX(\\\\{b_1, b_2, \u2026, b_i\\})=a_i. \n\n\n\nThe MEX of a set of integers is the smallest non-negative integer that doesn't belong to this set.\n\nIf such array doesn't exist, determine this.\n\nInput\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the array a.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 i) \u2014 the elements of the array a. It's guaranteed that a_i \u2264 a_{i+1} for 1\u2264 i < n.\n\nOutput\n\nIf there's no such array, print a single line containing -1.\n\nOtherwise, print a single line containing n integers b_1, b_2, \u2026, b_n (0 \u2264 b_i \u2264 10^6)\n\nIf there are multiple answers, print any.\n\nExamples\n\nInput\n\n\n3\n1 2 3\n\n\nOutput\n\n\n0 1 2 \n\nInput\n\n\n4\n0 0 0 2\n\n\nOutput\n\n\n1 3 4 0 \n\nInput\n\n\n3\n1 1 3\n\n\nOutput\n\n\n0 2 1 \n\nNote\n\nIn the second test case, other answers like [1,1,1,0], for example, are valid.",
        "task_name": "1364_C. Ehab and Prefix MEXs",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport math\n \nn = int(sys.stdin.readline().strip())\nl = list(map(int, sys.stdin.readline().strip().split(' ')))\n\npossible = True\nfor i,li in enumerate(l):\n\tif li > i+1:\n\t\tpossible = False\n\nif not possible:\n\tprint(-1)\nelse:\n\tinf = 10**6\n\tres = [inf for i in range(n)]\n\n\ttaken = set(l)\n\n\tfor i in range(n-1):\n\t\tif l[i] != l[i+1]:\n\t\t\tres[i+1] = l[i]\n\n\tcurr = 0\n\twhile curr in taken:\n\t\tcurr += 1\n\tfor i in range(n):\n\t\tif res[i] == inf:\n\t\t\tres[i] = curr\n\t\t\tcurr += 1\n\t\t\twhile curr in taken:\n\t\t\t\tcurr += 1\n\n\tprint(' '.join([str(x) for x in res]))\n\n",
        "correct": true,
        "task_id": "0394",
        "depth": 2
    },
    {
        "description": "After seeing the \"ALL YOUR BASE ARE BELONG TO US\" meme for the first time, numbers X and Y realised that they have different bases, which complicated their relations.\n\nYou're given a number X represented in base bx and a number Y represented in base by. Compare those two numbers.\n\nInput\n\nThe first line of the input contains two space-separated integers n and bx (1 \u2264 n \u2264 10, 2 \u2264 bx \u2264 40), where n is the number of digits in the bx-based representation of X. \n\nThe second line contains n space-separated integers x1, x2, ..., xn (0 \u2264 xi < bx) \u2014 the digits of X. They are given in the order from the most significant digit to the least significant one.\n\nThe following two lines describe Y in the same way: the third line contains two space-separated integers m and by (1 \u2264 m \u2264 10, 2 \u2264 by \u2264 40, bx \u2260 by), where m is the number of digits in the by-based representation of Y, and the fourth line contains m space-separated integers y1, y2, ..., ym (0 \u2264 yi < by) \u2014 the digits of Y.\n\nThere will be no leading zeroes. Both X and Y will be positive. All digits of both numbers are given in the standard decimal numeral system.\n\nOutput\n\nOutput a single character (quotes for clarity): \n\n  * '<' if X < Y\n  * '>' if X > Y\n  * '=' if X = Y\n\nExamples\n\nInput\n\n6 2\n1 0 1 1 1 1\n2 10\n4 7\n\n\nOutput\n\n=\n\n\nInput\n\n3 3\n1 0 2\n2 5\n2 4\n\n\nOutput\n\n&lt;\n\n\nInput\n\n7 16\n15 15 4 0 0 7 10\n7 9\n4 8 0 3 1 5 0\n\n\nOutput\n\n&gt;\n\nNote\n\nIn the first sample, X = 1011112 = 4710 = Y.\n\nIn the second sample, X = 1023 = 215 and Y = 245 = 1123, thus X < Y.\n\nIn the third sample, <image> and Y = 48031509. We may notice that X starts with much larger digits and bx is much larger than by, so X is clearly larger than Y.",
        "task_name": "602_A. Two Bases",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "s = raw_input().split(\" \")\nn = int(s[0])\nbx = int(s[1])\n\nx = 0\nxs = raw_input().split(\" \")\nfor i in range(n-1, -1, -1):\n    a = int(xs[n-1-i])\n    x = x + ((bx**i) * a)\n\ns = raw_input().split(\" \")\nm = int(s[0])\nby = int(s[1])\n\ny = 0\nys = raw_input().split(\" \")\nfor i in range(m-1, -1, -1):\n    a = int(ys[m-1-i])\n    y = y + ((by**i) * a)\n\nif (x == y): ans = \"=\"\nelif (x > y): ans = \">\"\nelse : ans = \"<\"\n\nprint(ans)\n",
        "correct": true,
        "task_id": "0413",
        "depth": 1
    },
    {
        "description": "You are given an undirected connected weighted graph with N vertices and M edges that contains neither self-loops nor double edges.\nThe i-th (1\u2264i\u2264M) edge connects vertex a_i and vertex b_i with a distance of c_i.\nHere, a self-loop is an edge where a_i = b_i (1\u2264i\u2264M), and double edges are two edges where (a_i,b_i)=(a_j,b_j) or (a_i,b_i)=(b_j,a_j) (1\u2264i<j\u2264M).\nA connected graph is a graph where there is a path between every pair of different vertices.\nFind the number of the edges that are not contained in any shortest path between any pair of different vertices.\n\nConstraints\n\n* 2\u2264N\u2264100\n* N-1\u2264M\u2264min(N(N-1)/2,1000)\n* 1\u2264a_i,b_i\u2264N\n* 1\u2264c_i\u22641000\n* c_i is an integer.\n* The given graph contains neither self-loops nor double edges.\n* The given graph is connected.\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN M\na_1 b_1 c_1\na_2 b_2 c_2\n:\na_M b_M c_M\n\n\nOutput\n\nPrint the number of the edges in the graph that are not contained in any shortest path between any pair of different vertices.\n\nExamples\n\nInput\n\n3 3\n1 2 1\n1 3 1\n2 3 3\n\n\nOutput\n\n1\n\n\nInput\n\n3 2\n1 2 1\n2 3 1\n\n\nOutput\n\n0",
        "task_name": "p03837 AtCoder Beginner Contest 051 - Candidates of No Shortest Paths",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Python program for Dijkstra's \n# single source shortest \n# path algorithm. The program \n# is for adjacency matrix \nans=[]\np=[]\n# representation of the graph \n\nfrom collections import defaultdict \npa=[]\n#Class to represent a graph \nclass Graph: \n\n\t# A utility function to find the \n\t# vertex with minimum dist value, from \n\t# the set of vertices still in queue \n\tdef minDistance(self,dist,queue): \n\t\t# Initialize min value and min_index as -1 \n\t\tminimum = float(\"Inf\") \n\t\tmin_index = -1\n\t\t\n\t\t# from the dist array,pick one which \n\t\t# has min value and is till in queue \n\t\tfor i in range(len(dist)): \n\t\t\tif dist[i] < minimum and i in queue: \n\t\t\t\tminimum = dist[i] \n\t\t\t\tmin_index = i \n\t\treturn min_index \n\n\n\t# Function to print shortest path \n\t# from source to j \n\t# using parent array \n\tdef printPath(self, parent, j): \n\t\tglobal p\n\t\tglobal pa \n\t\t#Base Case : If j is source \n\t\tif parent[j] == -1 : \n\t\t#\tprint j, \n\t\t\tp.append(j)\n\t\t\tpa.append(p)\n\t\t\treturn\n\t\tself.printPath(parent , parent[j]) \n\t\t#print j, \n\t\tp.append(j)\n        \n\t# A utility function to print \n\t# the constructed distance \n\t# array \n\tdef printSolution(self, dist, parent): \n\t\tsrc = 0\n\t\tglobal p\n\t#\tprint(\"Vertex \\t\\tDistance from Source\\tPath\") \n\t\tfor i in range(1, len(dist)): \n\t\t#\tprint(\"\\n%d --> %d \\t\\t%d \\t\\t\\t\\t\\t\" % (src, i, dist[i])), \n\t\t\tp=[]\n\t\t\tself.printPath(parent,i) \n\t\t\t#print(p,'fun')\n\t\t#\tpa.append(p)\n\n\t'''Function that implements Dijkstra's single source shortest path \n\talgorithm for a graph represented using adjacency matrix \n\trepresentation'''\n\tdef dijkstra(self, graph, src): \n\n\t\trow = len(graph) \n\t\tcol = len(graph[0]) \n\n\t\t# The output array. dist[i] will hold \n\t\t# the shortest distance from src to i \n\t\t# Initialize all distances as INFINITE \n\t\tdist = [float(\"Inf\")] * row \n\n\t\t#Parent array to store \n\t\t# shortest path tree \n\t\tparent = [-1] * row \n\n\t\t# Distance of source vertex \n\t\t# from itself is always 0 \n\t\tdist[src] = 0\n\t\n\t\t# Add all vertices in queue \n\t\tqueue = [] \n\t\tfor i in range(row): \n\t\t\tqueue.append(i) \n\t\t\t\n\t\t#Find shortest path for all vertices \n\t\twhile queue: \n\n\t\t\t# Pick the minimum dist vertex \n\t\t\t# from the set of vertices \n\t\t\t# still in queue \n\t\t\tu = self.minDistance(dist,queue) \n\n\t\t\t# remove min element\t \n\t\t\tqueue.remove(u) \n\n\t\t\t# Update dist value and parent \n\t\t\t# index of the adjacent vertices of \n\t\t\t# the picked vertex. Consider only \n\t\t\t# those vertices which are still in \n\t\t\t# queue \n\t\t\tfor i in range(col): \n\t\t\t\t'''Update dist[i] only if it is in queue, there is \n\t\t\t\tan edge from u to i, and total weight of path from \n\t\t\t\tsrc to i through u is smaller than current value of \n\t\t\t\tdist[i]'''\n\t\t\t\tif graph[u][i] and i in queue: \n\t\t\t\t\tif dist[u] + graph[u][i] < dist[i]: \n\t\t\t\t\t\tdist[i] = dist[u] + graph[u][i] \n\t\t\t\t\t\tparent[i] = u \n\n\n\t\t# print the constructed distance array \n\t\tself.printSolution(dist,parent) \n\ng= Graph() \nedge=[]\nn,m=map(int,raw_input().split())\ngraph=[[0 for j in range(n)]for i in range(n)]\nfor i in range(m):\n    a,b,c=map(int,raw_input().split())\n    a,b=min(a,b),max(a,b)\n    edge.append([a-1,b-1])\n    graph[a-1][b-1]=c \n    graph[b-1][a-1]=c \n\n\t\t\n\nans={}\nfor i in range(n):\n    p=[]\n    g.dijkstra(graph,i) \n   # print(p)\n    for i in range(len(p)-1):\n        a,b=p[i],p[i+1]\n        a,b=min(a,b),max(a,b)\n        ans[(a,b)]=1 \n#print(ans)\n#print(pa)\n# This code is contributed by Neelam Yadav \ncnt=0 \nfor i in edge: \n    if ans.get((i[0],i[1]),-1)!=-1:\n        cnt+=1 \nprint(m-cnt)",
        "correct": false,
        "task_id": "0429",
        "depth": 2
    },
    {
        "description": "Masha really loves algebra. On the last lesson, her strict teacher Dvastan gave she new exercise.\n\nYou are given geometric progression b defined by two integers b1 and q. Remind that a geometric progression is a sequence of integers b1, b2, b3, ..., where for each i > 1 the respective term satisfies the condition bi = bi - 1\u00b7q, where q is called the common ratio of the progression. Progressions in Uzhlyandia are unusual: both b1 and q can equal 0. Also, Dvastan gave Masha m \"bad\" integers a1, a2, ..., am, and an integer l.\n\nMasha writes all progression terms one by one onto the board (including repetitive) while condition |bi| \u2264 l is satisfied (|x| means absolute value of x). There is an exception: if a term equals one of the \"bad\" integers, Masha skips it (doesn't write onto the board) and moves forward to the next term.\n\nBut the lesson is going to end soon, so Masha has to calculate how many integers will be written on the board. In order not to get into depression, Masha asked you for help: help her calculate how many numbers she will write, or print \"inf\" in case she needs to write infinitely many integers.\n\nInput\n\nThe first line of input contains four integers b1, q, l, m (-109 \u2264 b1, q \u2264 109, 1 \u2264 l \u2264 109, 1 \u2264 m \u2264 105) \u2014 the initial term and the common ratio of progression, absolute value of maximal number that can be written on the board and the number of \"bad\" integers, respectively.\n\nThe second line contains m distinct integers a1, a2, ..., am (-109 \u2264 ai \u2264 109) \u2014 numbers that will never be written on the board.\n\nOutput\n\nPrint the only integer, meaning the number of progression terms that will be written on the board if it is finite, or \"inf\" (without quotes) otherwise.\n\nExamples\n\nInput\n\n3 2 30 4\n6 14 25 48\n\n\nOutput\n\n3\n\nInput\n\n123 1 2143435 4\n123 11 -5453 141245\n\n\nOutput\n\n0\n\nInput\n\n123 1 2143435 4\n54343 -13 6 124\n\n\nOutput\n\ninf\n\nNote\n\nIn the first sample case, Masha will write integers 3, 12, 24. Progression term 6 will be skipped because it is a \"bad\" integer. Terms bigger than 24 won't be written because they exceed l by absolute value.\n\nIn the second case, Masha won't write any number because all terms are equal 123 and this is a \"bad\" integer.\n\nIn the third case, Masha will write infinitely integers 123. ",
        "task_name": "789_B. Masha and geometric depression",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\nfrom collections import *\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nb1, q, l, m = rints()\na, ans, vis = set(rints()), 0, defaultdict(int)\n\nwhile abs(b1) <= l and vis[b1] < 2:\n    if vis[b1] and b1 not in a:\n        print('inf')\n        exit()\n\n    ans += (b1 not in a and not vis[b1])\n    vis[b1] += 1\n    b1 *= q\n\nprint(ans)\n",
        "correct": true,
        "task_id": "0460",
        "depth": 1
    },
    {
        "description": "SmallR is an archer. SmallR is taking a match of archer with Zanoes. They try to shoot in the target in turns, and SmallR shoots first. The probability of shooting the target each time is <image> for SmallR while <image> for Zanoes. The one who shoots in the target first should be the winner.\n\nOutput the probability that SmallR will win the match.\n\nInput\n\nA single line contains four integers <image>.\n\nOutput\n\nPrint a single real number, the probability that SmallR will win the match.\n\nThe answer will be considered correct if the absolute or relative error doesn't exceed 10 - 6.\n\nExamples\n\nInput\n\n1 2 1 2\n\n\nOutput\n\n0.666666666667",
        "task_name": "312_B. Archer",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division;\nfrom bisect import *;\nfrom fractions import Fraction;\nimport sys;\nfrom math import *;\nfrom fractions import *;\nimport io;\nimport re;\n\nINF = 987654321987654321987654321;\n\ndef readint(delimiter=' ') :\n\treturn map(int, raw_input().split(delimiter));\n\ndef readstr(delimiter=' ') :\n\treturn raw_input().split(delimiter);\n\ndef readfloat(delimiter=' ') :\n\treturn map(float, raw_input().split(delimiter));\n\ndef index(a, x):\n\t'Locate the leftmost value exactly equal to x'\n\ti = bisect_left(a, x)\n\tif i != len(a) and a[i] == x:\n\t\treturn i\n\traise ValueError\n\ndef find_lt(a, x):\n\t'Find rightmost value less than x'\n\ti = bisect_left(a, x)\n\tif i:\n\t\treturn a[i-1]\n\traise ValueError\n\ndef find_le(a, x):\n\t'Find rightmost value less than or equal to x'\n\ti = bisect_right(a, x)\n\tif i:\n\t\treturn a[i-1]\n\traise ValueError\n\ndef find_gt(a, x):\n\t'Find leftmost value greater than x'\n\ti = bisect_right(a, x)\n\tif i != len(a):\n\t\treturn a[i]\n\traise ValueError\n\ndef find_ge(a, x):\n\t'Find leftmost item greater than or equal to x'\n\ti = bisect_left(a, x)\n\tif i != len(a):\n\t\treturn a[i]\n\traise ValueError\n\ndef bin_search(a, x, left, right) :\n\n\twhile left<=right :\n\t\tmid = (left + right)//2;\n\t\t\n\t\tif a[mid] == x :\n\t\t\treturn mid;\n\t\telif a[mid] < x :\n\t\t\tleft = mid + 1; \n\t\telif a[mid] > x :\n\t\t\tright = mid - 1;\n\t\t\t\t\t   \n\t\tpass\n\t\n\treturn -1;\n\tpass\n\ndef printf(format, *args):\n\t\"\"\"Format args with the first argument as format string, and write.\n\tReturn the last arg, or format itself if there are no args.\"\"\"\n\tsys.stdout.write(str(format) % args)\n\t\n\nfrom datetime import date;\n\nif __name__ == '__main__':\n\n\ta, b, c, d = readint();\n\n\tprob_a = a/b;\n\tprob_b = c/d;\n\n\tprev = 0;\n\tnow = 0;\n\tnow += prob_a;\n\tacc = (1-prob_a)*(1-prob_b);\n\tii = 0;\n\twhile (now - prev > 0.0000001) :\n\t\tprev = now;\n\t\tii += 1;\n\t\tnow += acc*prob_a;\n\t\tacc *= (1-prob_a)*(1-prob_b);\n\t\tpass\n\n\tprintf('%.6f\\n', now);\n\t\n\tpass",
        "correct": false,
        "task_id": "0491",
        "depth": 1
    },
    {
        "description": "As it's the first of April, Heidi is suspecting that the news she reads today are fake, and she does not want to look silly in front of all the contestants. She knows that a newspiece is fake if it contains heidi as a subsequence. Help Heidi assess whether the given piece is true, but please be discreet about it...\n\nInput\n\nThe first and only line of input contains a single nonempty string s of length at most 1000 composed of lowercase letters (a-z).\n\nOutput\n\nOutput YES if the string s contains heidi as a subsequence and NO otherwise.\n\nExamples\n\nInput\n\nabcheaibcdi\n\n\nOutput\n\nYES\n\nInput\n\nhiedi\n\n\nOutput\n\nNO\n\nNote\n\nA string s contains another string p as a subsequence if it is possible to delete some characters from s and obtain p.",
        "task_name": "802_G. Fake News (easy)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\npattern = 'heidi'\ntext = sys.stdin.readline()\n\nmatch = False\nmax_match = 0\nfor char in text:\n\tif char == pattern[max_match]:\n\t\tmax_match += 1\n\tif max_match == len(pattern):\n\t\tmatch = True\n\t\tbreak\n\nprint('YES' if match else 'NO')",
        "correct": true,
        "task_id": "0503",
        "depth": 1
    },
    {
        "description": "There is a set A = \\\\{ a_1, a_2, \\ldots, a_N \\\\} consisting of N positive integers. Taro and Jiro will play the following game against each other.\n\nInitially, we have a pile consisting of K stones. The two players perform the following operation alternately, starting from Taro:\n\n* Choose an element x in A, and remove exactly x stones from the pile.\n\n\n\nA player loses when he becomes unable to play. Assuming that both players play optimally, determine the winner.\n\nConstraints\n\n* All values in input are integers.\n* 1 \\leq N \\leq 100\n* 1 \\leq K \\leq 10^5\n* 1 \\leq a_1 < a_2 < \\cdots < a_N \\leq K\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN K\na_1 a_2 \\ldots a_N\n\n\nOutput\n\nIf Taro will win, print `First`; if Jiro will win, print `Second`.\n\nExamples\n\nInput\n\n2 4\n2 3\n\n\nOutput\n\nFirst\n\n\nInput\n\n2 5\n2 3\n\n\nOutput\n\nSecond\n\n\nInput\n\n2 7\n2 3\n\n\nOutput\n\nFirst\n\n\nInput\n\n3 20\n1 2 3\n\n\nOutput\n\nSecond\n\n\nInput\n\n3 21\n1 2 3\n\n\nOutput\n\nFirst\n\n\nInput\n\n1 100000\n1\n\n\nOutput\n\nSecond",
        "task_name": "p03170 Educational DP Contest - Stones",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import os\nfrom io import BytesIO\n\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nn, k = map(int, input().split())\na = [int(i) for i in input().split()]\n\ndp = [False] * (k + 1)\n\nfor ai in a:\n    dp[ai] = True\n\nfor i in xrange(max(a) + 1, k + 1):\n    dp[i] = any(not dp[i - ai] for ai in a)\n\nos.write(1, 'First' if dp[k] else 'Second')",
        "correct": false,
        "task_id": "0512",
        "depth": 1
    },
    {
        "description": "n! = n \u00d7 (n \u2212 1) \u00d7 (n \u2212 2) \u00d7 ... \u00d7 3 \u00d7 2 \u00d7 1\n\nIs called the factorial of n. For example, the factorial of 12\n\n12! = 12 x 11 x 10 x 9 x 8 x 7 x 6 x 5 x 4 x 3 x 2 x 1 = 479001600\n\nAnd there are two consecutive 0s at the end.\n\nWrite a program that inputs the integer n and outputs the number of consecutive 0s at the end of n !. However, n is a positive integer less than or equal to 20000.\n\n\n\nInput\n\nMultiple data are given. Each piece of data is given n (n \u2264 20000) on one line. When n is 0, it is the last input.\n\nThe number of data does not exceed 20.\n\nOutput\n\nFor each data, output the number of 0s that are consecutively arranged at the end of n! On one line.\n\nExample\n\nInput\n\n2\n12\n10000\n0\n\n\nOutput\n\n0\n2\n2499",
        "task_name": "p00052 Factorial II",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "while(True):\n    n = input()\n    if(n == 0):\n        break\n    ans = 0\n    a = 5\n    count = 0\n    while(True):\n        count = n / a\n        if(count == 0):\n            break\n        ans += count\n        a *= 5\n    print(ans)",
        "correct": true,
        "task_id": "0518",
        "depth": 2
    },
    {
        "description": "You are given a description of a depot. It is a rectangular checkered field of n \u00d7 m size. Each cell in a field can be empty (\".\") or it can be occupied by a wall (\"*\"). \n\nYou have one bomb. If you lay the bomb at the cell (x, y), then after triggering it will wipe out all walls in the row x and all walls in the column y.\n\nYou are to determine if it is possible to wipe out all walls in the depot by placing and triggering exactly one bomb. The bomb can be laid both in an empty cell or in a cell occupied by a wall.\n\nInput\n\nThe first line contains two positive integers n and m (1 \u2264 n, m \u2264 1000) \u2014 the number of rows and columns in the depot field. \n\nThe next n lines contain m symbols \".\" and \"*\" each \u2014 the description of the field. j-th symbol in i-th of them stands for cell (i, j). If the symbol is equal to \".\", then the corresponding cell is empty, otherwise it equals \"*\" and the corresponding cell is occupied by a wall.\n\nOutput\n\nIf it is impossible to wipe out all walls by placing and triggering exactly one bomb, then print \"NO\" in the first line (without quotes).\n\nOtherwise print \"YES\" (without quotes) in the first line and two integers in the second line \u2014 the coordinates of the cell at which the bomb should be laid. If there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n3 4\n.*..\n....\n.*..\n\n\nOutput\n\nYES\n1 2\n\n\nInput\n\n3 3\n..*\n.*.\n*..\n\n\nOutput\n\nNO\n\n\nInput\n\n6 5\n..*..\n..*..\n*****\n..*..\n..*..\n..*..\n\n\nOutput\n\nYES\n3 3",
        "task_name": "699_B. One Bomb",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, m = map(int, raw_input().split())\ng = [ raw_input().strip() for r in range(n) ]\nrow_count = [ 0 for r in range(n) ]\ncol_count = [ 0 for c in range(m) ]\ntotal = 0\nfor r in range(n):\n  for c in range(m):\n    if g[r][c] == '*':\n      row_count[r] += 1\n      col_count[c] += 1\n      total += 1\nresult = 'NO'\nfor r in range(n):\n  for c in range(m):\n    x = row_count[r] + col_count[c] + (-1 if g[r][c] == '*' else 0)\n    if x == total:\n      print('YES\\n%d %d' % (r + 1, c + 1))\n      import sys; sys.exit()\nprint(result)\n",
        "correct": true,
        "task_id": "0550",
        "depth": 2
    },
    {
        "description": "There is a country with n citizens. The i-th of them initially has a_{i} money. The government strictly controls the wealth of its citizens. Whenever a citizen makes a purchase or earns some money, they must send a receipt to the social services mentioning the amount of money they currently have.\n\nSometimes the government makes payouts to the poor: all citizens who have strictly less money than x are paid accordingly so that after the payout they have exactly x money. In this case the citizens don't send a receipt.\n\nYou know the initial wealth of every citizen and the log of all events: receipts and payouts. Restore the amount of money each citizen has after all events.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^{5}) \u2014 the numer of citizens.\n\nThe next line contains n integers a_1, a_2, ..., a_n (0 \u2264 a_{i} \u2264 10^{9}) \u2014 the initial balances of citizens.\n\nThe next line contains a single integer q (1 \u2264 q \u2264 2 \u22c5 10^{5}) \u2014 the number of events.\n\nEach of the next q lines contains a single event. The events are given in chronological order.\n\nEach event is described as either 1 p x (1 \u2264 p \u2264 n, 0 \u2264 x \u2264 10^{9}), or 2 x (0 \u2264 x \u2264 10^{9}). In the first case we have a receipt that the balance of the p-th person becomes equal to x. In the second case we have a payoff with parameter x.\n\nOutput\n\nPrint n integers \u2014 the balances of all citizens after all events.\n\nExamples\n\nInput\n\n\n4\n1 2 3 4\n3\n2 3\n1 2 2\n2 1\n\n\nOutput\n\n\n3 2 3 4 \n\n\nInput\n\n\n5\n3 50 2 1 10\n3\n1 2 0\n2 8\n1 3 20\n\n\nOutput\n\n\n8 8 20 8 10 \n\nNote\n\nIn the first example the balances change as follows: 1 2 3 4 \u2192 3 3 3 4 \u2192 3 2 3 4 \u2192 3 2 3 4\n\nIn the second example the balances change as follows: 3 50 2 1 10 \u2192 3 0 2 1 10 \u2192 8 8 8 8 10 \u2192 8 8 20 8 10",
        "task_name": "1199_D. Welfare State",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\nimport bisect\nimport math\nimport itertools\nimport sys\nfrom atexit import register\n \nif sys.version_info[0] < 3:\n    from io import BytesIO as stream\nelse:\n    from io import StringIO as stream\n \n \nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n \n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n \n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n \n    input = raw_input\n    range = xrange\n \n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n \n \ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n \n    Args:\n        sync (bool, optional): The new synchronization setting.\n \n    \"\"\"\n    global input, flush\n \n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n \ndef main():\n    n=int(input()) \n    a=list(map(int, input().split()))\n    k=int(input())\n    m=-1\n    ma=0\n    c=[]\n    for i in range(k):\n      b=list(map(int, input().split()))\n      if b[0]==2:\n        if b[1]>=m:\n          m=b[1]\n          ma=i\n      c.append(b)\n    p=0\n    #print(m,ma,c)\n    for i in range(ma):\n      if c[i][0]==1:\n        a[c[i][1]-1]=c[i][2]      \n    for i in range(k-1,ma-1,-1):\n      if c[i][0]==1 and p==0:\n        continue\n      if c[i][0]==2 :\n        x=c[i][1]\n        p=1 \n      if c[i][0]==1 and p==1:\n        c[i][2]=max(x,c[i][2])\n    for i in range(n):\n      if a[i]<m and m!=-1:\n        a[i]=m\n    \n    for i in range(ma,k):\n      if c[i][0]==1:\n        a[c[i][1]-1]=c[i][2]\n    print(*a)\n\n\n \n        \nif __name__ == '__main__':\n    sync_with_stdio(False)\n    main()",
        "correct": false,
        "task_id": "0572",
        "depth": 1
    },
    {
        "description": "Dima, Inna and Seryozha have gathered in a room. That's right, someone's got to go. To cheer Seryozha up and inspire him to have a walk, Inna decided to cook something. \n\nDima and Seryozha have n fruits in the fridge. Each fruit has two parameters: the taste and the number of calories. Inna decided to make a fruit salad, so she wants to take some fruits from the fridge for it. Inna follows a certain principle as she chooses the fruits: the total taste to the total calories ratio of the chosen fruits must equal k. In other words, <image> , where aj is the taste of the j-th chosen fruit and bj is its calories.\n\nInna hasn't chosen the fruits yet, she is thinking: what is the maximum taste of the chosen fruits if she strictly follows her principle? Help Inna solve this culinary problem \u2014 now the happiness of a young couple is in your hands!\n\nInna loves Dima very much so she wants to make the salad from at least one fruit.\n\nInput\n\nThe first line of the input contains two integers n, k (1 \u2264 n \u2264 100, 1 \u2264 k \u2264 10). The second line of the input contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 100) \u2014 the fruits' tastes. The third line of the input contains n integers b1, b2, ..., bn (1 \u2264 bi \u2264 100) \u2014 the fruits' calories. Fruit number i has taste ai and calories bi.\n\nOutput\n\nIf there is no way Inna can choose the fruits for the salad, print in the single line number -1. Otherwise, print a single integer \u2014 the maximum possible sum of the taste values of the chosen fruits.\n\nExamples\n\nInput\n\n3 2\n10 8 1\n2 7 1\n\n\nOutput\n\n18\n\n\nInput\n\n5 3\n4 4 4 4 4\n2 2 2 2 2\n\n\nOutput\n\n-1\n\nNote\n\nIn the first test sample we can get the total taste of the fruits equal to 18 if we choose fruit number 1 and fruit number 2, then the total calories will equal 9. The condition <image> fulfills, that's exactly what Inna wants.\n\nIn the second test sample we cannot choose the fruits so as to follow Inna's principle.",
        "task_name": "366_C. Dima and Salad",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from collections import defaultdict\n\nn, k = map(int, raw_input().split())\nA = map(int, raw_input().split())\nB = map(int, raw_input().split())\ndp1 = defaultdict(lambda: 0, {0 : 0})\npos = 0\nfor a, b in zip(A, B):\n    cur = a - b * k\n    dp2 = dp1.copy()\n    for x, y in dp1.iteritems():\n        dp2[x + cur] = max(dp2[x + cur], y + a)\n    dp1 = dp2\nif dp1[0] > 0:\n    print(dp1[0])\nelse:\n    print(-1)",
        "correct": true,
        "task_id": "0586",
        "depth": 2
    },
    {
        "description": "Tak performed the following action N times: rolling two dice. The result of the i-th roll is D_{i,1} and D_{i,2}.\n\nCheck if doublets occurred at least three times in a row. Specifically, check if there exists at lease one i such that D_{i,1}=D_{i,2}, D_{i+1,1}=D_{i+1,2} and D_{i+2,1}=D_{i+2,2} hold.\n\nConstraints\n\n* 3 \\leq N \\leq 100\n* 1\\leq D_{i,j} \\leq 6\n* All values in input are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nD_{1,1} D_{1,2}\n\\vdots\nD_{N,1} D_{N,2}\n\n\nOutput\n\nPrint `Yes` if doublets occurred at least three times in a row. Print `No` otherwise.\n\nExamples\n\nInput\n\n5\n1 2\n6 6\n4 4\n3 3\n3 2\n\n\nOutput\n\nYes\n\n\nInput\n\n5\n1 1\n2 2\n3 4\n5 5\n6 6\n\n\nOutput\n\nNo\n\n\nInput\n\n6\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n\n\nOutput\n\nYes",
        "task_name": "p02547 AtCoder Beginner Contest 179 - Go to Jail",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nraw_input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nn = int(input())\nok = False\ncont = 0\nfor i in xrange(n):\n    a,b = (int(x) for x in input().split())\n    if a == b:\n        cont += 1\n        if cont == 3:\n            ok = True\n    else:\n        cont = 0\nif ok:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
        "correct": true,
        "task_id": "0601",
        "depth": 1
    },
    {
        "description": "There is a cave.\n\nThe cave has N rooms and M passages. The rooms are numbered 1 to N, and the passages are numbered 1 to M. Passage i connects Room A_i and Room B_i bidirectionally. One can travel between any two rooms by traversing passages. Room 1 is a special room with an entrance from the outside.\n\nIt is dark in the cave, so we have decided to place a signpost in each room except Room 1. The signpost in each room will point to one of the rooms directly connected to that room with a passage.\n\nSince it is dangerous in the cave, our objective is to satisfy the condition below for each room except Room 1.\n\n* If you start in that room and repeatedly move to the room indicated by the signpost in the room you are in, you will reach Room 1 after traversing the minimum number of passages possible.\n\n\n\nDetermine whether there is a way to place signposts satisfying our objective, and print one such way if it exists.\n\nConstraints\n\n* All values in input are integers.\n* 2 \\leq N \\leq 10^5\n* 1 \\leq M \\leq 2 \\times 10^5\n* 1 \\leq A_i, B_i \\leq N\\ (1 \\leq i \\leq M)\n* A_i \\neq B_i\\ (1 \\leq i \\leq M)\n* One can travel between any two rooms by traversing passages.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M\nA_1 B_1\n:\nA_M B_M\n\n\nOutput\n\nIf there is no way to place signposts satisfying the objective, print `No`.\n\nOtherwise, print N lines. The first line should contain `Yes`, and the i-th line (2 \\leq i \\leq N) should contain the integer representing the room indicated by the signpost in Room i.\n\nExamples\n\nInput\n\n4 4\n1 2\n2 3\n3 4\n4 2\n\n\nOutput\n\nYes\n1\n2\n2\n\n\nInput\n\n6 9\n3 4\n6 1\n2 4\n5 3\n4 6\n1 5\n6 2\n4 5\n5 6\n\n\nOutput\n\nYes\n6\n5\n5\n1\n1",
        "task_name": "p02678 AtCoder Beginner Contest 168 - .. (Double Dots)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef bfs(graph, start=0):\n    used = [False] * len(graph)\n    used[start] = True\n    q = [start]\n\n    depth = [-1] * len(graph)\n    post = [-1] * len(graph)\n\n    depth[0] = 0\n\n    for v in q:\n        for w in graph[v]:\n            if depth[w] != -1 and (depth[w] < depth[v] or depth[v] == -1):\n                depth[v] = depth[w] + 1\n                post[v] = w\n\n            if not used[w]:\n                used[w] = True\n                q.append(w)\n\n    return post\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    post = bfs(graph)[1:]\n\n    if -1 in post:\n        print(\"No\")\n        return\n\n    print(\"Yes\")\n    for i in post:\n        print(i + 1)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "0602",
        "depth": 2
    },
    {
        "description": "Extended Euclid Algorithm\n\n\n\n\nGiven positive integers a and b, find the integer solution (x, y) to ax + by = gcd(a, b), where gcd(a, b) is the greatest common divisor of a and b.\n\nConstraints\n\n* 1 \u2264 a, b \u2264 109\n\nInput\n\n\na b\n\n\nTwo positive integers a and b are given separated by a space in a line.\n\nOutput\n\nPrint two integers x and y separated by a space. If there are several pairs of such x and y, print that pair for which |x| + |y| is the minimal (primarily) and x \u2264 y (secondarily).\n\nExamples\n\nInput\n\n4 12\n\n\nOutput\n\n1 0\n\n\nInput\n\n3 8\n\n\nOutput\n\n3 -1",
        "task_name": "p02471 Extended Euclid Algorithm",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\n\n\ndef rec(a, b):\n    \"\"\"a * x + b * y = gcd(a, b) ??\u00a8??????????????? (x, y, gcd) ?????????\"\"\"\n    assert a >= b\n    q, r = divmod(a, b)\n    if r == 0:\n        return 0, 1, b\n    x, y, gcd = rec(b, r)\n    # a = b * q + r\n    # b * x + r * y = gcd\n    # a * y + b * (x - q * y) = gcd\n    return y, x - q * y, gcd\n\n\na, b = [int(_) for _ in raw_input().split()]\n\nif a < b:\n    y0, x0, gcd = rec(b, a)\nelse:\n    x0, y0, gcd = rec(a, b)\n\n# -a/gcd * (x - x0) = b/gcd * (y - y0)\n# x = x0 + (b/gcd) * k, y = y0 + (-a/gcd) * k\ndx = b // gcd\ndy = -a // gcd\nif dx < 0:\n    dx = -dx\n    dy = -dy\nx = x0\ny = y0\nmag = abs(x) + abs(y)\n\nwhile True:\n    x1 = x + dx\n    y1 = y + dy\n    mag1 = abs(x1) + abs(y1)\n    if mag1 >= mag:\n        break\n    mag = mag1\n    x = x1\n    y = y1\n\nwhile True:\n    x1 = x - dx\n    y1 = y - dy\n    mag1 = abs(x1) + abs(y1)\n    if mag1 > mag:\n        break\n    mag = mag1\n    x = x1\n    y = y1\n\nprint(x, y)",
        "correct": true,
        "task_id": "0610",
        "depth": 1
    },
    {
        "description": "You are given a tree consisting of n vertices. A tree is an undirected connected acyclic graph.\n\n<image> Example of a tree.\n\nYou have to paint each vertex into one of three colors. For each vertex, you know the cost of painting it in every color.\n\nYou have to paint the vertices so that any path consisting of exactly three distinct vertices does not contain any vertices with equal colors. In other words, let's consider all triples (x, y, z) such that x \u2260 y, y \u2260 z, x \u2260 z, x is connected by an edge with y, and y is connected by an edge with z. The colours of x, y and z should be pairwise distinct. Let's call a painting which meets this condition good.\n\nYou have to calculate the minimum cost of a good painting and find one of the optimal paintings. If there is no good painting, report about it.\n\nInput\n\nThe first line contains one integer n (3 \u2264 n \u2264 100 000) \u2014 the number of vertices.\n\nThe second line contains a sequence of integers c_{1, 1}, c_{1, 2}, ..., c_{1, n} (1 \u2264 c_{1, i} \u2264 10^{9}), where c_{1, i} is the cost of painting the i-th vertex into the first color.\n\nThe third line contains a sequence of integers c_{2, 1}, c_{2, 2}, ..., c_{2, n} (1 \u2264 c_{2, i} \u2264 10^{9}), where c_{2, i} is the cost of painting the i-th vertex into the second color.\n\nThe fourth line contains a sequence of integers c_{3, 1}, c_{3, 2}, ..., c_{3, n} (1 \u2264 c_{3, i} \u2264 10^{9}), where c_{3, i} is the cost of painting the i-th vertex into the third color.\n\nThen (n - 1) lines follow, each containing two integers u_j and v_j (1 \u2264 u_j, v_j \u2264 n, u_j \u2260 v_j) \u2014 the numbers of vertices connected by the j-th undirected edge. It is guaranteed that these edges denote a tree.\n\nOutput\n\nIf there is no good painting, print -1.\n\nOtherwise, print the minimum cost of a good painting in the first line. In the second line print n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 3), where the i-th integer should denote the color of the i-th vertex. If there are multiple good paintings with minimum cost, print any of them.\n\nExamples\n\nInput\n\n\n3\n3 2 3\n4 3 2\n3 1 3\n1 2\n2 3\n\n\nOutput\n\n\n6\n1 3 2 \n\n\nInput\n\n\n5\n3 4 2 1 2\n4 2 1 5 4\n5 3 2 1 1\n1 2\n3 2\n4 3\n5 3\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\n3 4 2 1 2\n4 2 1 5 4\n5 3 2 1 1\n1 2\n3 2\n4 3\n5 4\n\n\nOutput\n\n\n9\n1 3 2 1 3 \n\nNote\n\nAll vertices should be painted in different colors in the first example. The optimal way to do it is to paint the first vertex into color 1, the second vertex \u2014 into color 3, and the third vertex \u2014 into color 2. The cost of this painting is 3 + 2 + 1 = 6.",
        "task_name": "1244_D. Paint the Tree",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\nfrom collections import defaultdict\nfrom itertools import permutations\n\n\ndef fast2():\n    import os, sys, atexit\n    from cStringIO import StringIO as BytesIO\n    # range = xrange\n    sys.stdout = BytesIO()\n    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))\n    return BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\nclass graph:\n    # initialize graph\n    def __init__(self, gdict=None):\n        if gdict is None:\n            gdict = defaultdict(list)\n        self.gdict, self.edges, self.l = gdict, defaultdict(int), [0] * (n + 1)\n\n    # add edge\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.gdict[node2].append(node1)\n        self.l[node1] += 1\n        self.l[node2] += 1\n\n    def dfsUtil(self, v, per):\n        global ans, out\n        stack, self.visit = [[v, 0]], [0] * (n + 1)\n        self.visit[v], tem = per[0] + 1, color[per[0]][v - 1]\n\n        while (stack):\n            s, c = stack.pop()\n\n            for i in self.gdict[s]:\n                if not self.visit[i]:\n                    val = (c + 1) % 3\n                    stack.append([i, val])\n                    self.visit[i] = per[val] + 1\n                    tem += color[per[val]][i - 1]\n\n        if tem < ans:\n            ans, out = tem, self.visit[1:]\n\n    def dfs(self):\n        v = 0\n\n        for i in range(1, n + 1):\n            if self.l[i] == 1:\n                v = i\n                break\n\n        for per in permutations([0, 1, 2], 3):\n            self.dfsUtil(v, per)\n\n\ninput = fast2()\nrints = lambda: [int(x) for x in input().split()]\nn = int(input())\ncolor = [rints() for _ in range(3)]\ng, ans, out = graph(), float('inf'), []\n\nfor _ in range(n - 1):\n    u, v = rints()\n    g.addEdge(u, v)\n\nif list(filter(lambda x: x > 2, g.l)):\n    print(-1)\nelse:\n    g.dfs()\n    print('%d\\n%s' % (ans, ' '.join(map(str, out))))\n",
        "correct": true,
        "task_id": "0617",
        "depth": 2
    },
    {
        "description": "You are given an array a consisting of n integers numbered from 1 to n.\n\nLet's define the k-amazing number of the array as the minimum number that occurs in all of the subsegments of the array having length k (recall that a subsegment of a of length k is a contiguous part of a containing exactly k elements). If there is no integer occuring in all subsegments of length k for some value of k, then the k-amazing number is -1.\n\nFor each k from 1 to n calculate the k-amazing number of the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\n\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 3 \u22c5 10^5) \u2014 the number of elements in the array. The second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 n) \u2014 the elements of the array. \n\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5.\n\nOutput\n\nFor each test case print n integers, where the i-th integer is equal to the i-amazing number of the array.\n\nExample\n\nInput\n\n\n3\n5\n1 2 3 4 5\n5\n4 4 4 4 2\n6\n1 3 1 5 3 1\n\n\nOutput\n\n\n-1 -1 3 2 1 \n-1 4 4 4 2 \n-1 -1 1 1 1 1 ",
        "task_name": "1416_A. k-Amazing Numbers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n# import threading\n# threading.stack_size(2**27)\nimport sys\nsys.setrecursionlimit(10**4)\n# sys.stdin = open('inpy.txt', 'r')\n# sys.stdout = open('outpy.txt', 'w')\nfrom sys import stdin, stdout\nimport bisect            #c++ upperbound\nimport math\nimport heapq\ni_m=9223372036854775807\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef cin():\n    return map(int,sin().split())\ndef ain():                           #takes array as input\n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input())\nimport math  \ndef GCD(x, y): \n    x=abs(x)\n    y=abs(y)\n    if(min(x,y)==0):\n        return max(x,y)\n    while(y): \n        x, y = y, x % y \n    return x \ndef Divisors(n) : \n    l = []  \n    for i in range(1, int(math.sqrt(n) + 1)) :\n        if (n % i == 0) : \n            if (n // i == i) : \n                l.append(i) \n            else : \n                l.append(i)\n                l.append(n//i)\n    return l\nprime=[]\ndef SieveOfEratosthenes(n): \n    global prime\n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n    f=[]\n    for p in range(2, n): \n        if prime[p]: \n            f.append(p)\n    return f\ndef primeFactors(n): \n    a=[]\n    # Print the number of two's that divide n \n    while n % 2 == 0: \n        a.append(2) \n        n = n // 2\n          \n    # n must be odd at this point \n    # so a skip of 2 ( i = i + 2) can be used \n    for i in range(3,int(math.sqrt(n))+1,2): \n          \n        # while i divides n , print i ad divide n \n        while n % i== 0: \n            a.append(i) \n            n = n // i \n              \n    # Condition if n is a prime \n    # number greater than 2 \n    if n > 2: \n        a.append(n)\n    return a\n\n\"\"\"*******************************************************\"\"\"\ndef main():\n    t=inin()\n    for _ in range(t):\n        n=inin()\n        a=ain()\n        d={}\n        ans=n\n        e={}\n        for i in a:\n            d[i]=-1\n            e[i]=0\n        for i in range(n):\n            e[a[i]]=max(e[a[i]],i-d[a[i]])\n            d[a[i]]=i\n        for i in range(n):\n            e[a[i]]=max(e[a[i]],n-d[a[i]])\n        b=[100000000000]*n\n        for i in e:\n            b[e[i]-1]=min(b[e[i]-1],i)\n        x=100000000000\n        for i in range(n):\n            x=min(x,b[i])\n            b[i]=x\n        for i in range(n):\n            if b[i]==100000000000:\n                b[i]=-1\n        print(b)\n\n######## Python 2 and 3 footer by Pajenegod and c1729\n \n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n \n# So on cf, use PyPy2 for best string performance.\n \npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n \nimport os, sys\nfrom io import IOBase, BytesIO\n \nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'R' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'R' [0]:\n        A.append(sign*numb)\n    return A\n \n# threading.Thread(target=main).start()\nif __name__== \"__main__\":\n  main()",
        "correct": false,
        "task_id": "0623",
        "depth": 2
    },
    {
        "description": "Little Petya likes points a lot. Recently his mom has presented him n points lying on the line OX. Now Petya is wondering in how many ways he can choose three distinct points so that the distance between the two farthest of them doesn't exceed d.\n\nNote that the order of the points inside the group of three chosen points doesn't matter.\n\nInput\n\nThe first line contains two integers: n and d (1 \u2264 n \u2264 105; 1 \u2264 d \u2264 109). The next line contains n integers x1, x2, ..., xn, their absolute value doesn't exceed 109 \u2014 the x-coordinates of the points that Petya has got.\n\nIt is guaranteed that the coordinates of the points in the input strictly increase.\n\nOutput\n\nPrint a single integer \u2014 the number of groups of three points, where the distance between two farthest points doesn't exceed d.\n\nPlease do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nExamples\n\nInput\n\n4 3\n1 2 3 4\n\n\nOutput\n\n4\n\n\nInput\n\n4 2\n-3 -2 -1 0\n\n\nOutput\n\n2\n\n\nInput\n\n5 19\n1 10 20 30 50\n\n\nOutput\n\n1\n\nNote\n\nIn the first sample any group of three points meets our conditions.\n\nIn the seconds sample only 2 groups of three points meet our conditions: {-3, -2, -1} and {-2, -1, 0}.\n\nIn the third sample only one group does: {1, 10, 20}.",
        "task_name": "252_C. Points on Line",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# ------------------------------------------------\n# -- Codeforces #252 - Problem C (Points on Line)\n# -- http://codeforces.com/contest/252/problem/C\n# -- Author: James Lawson <mail@jameslawson.io>\n# ------------------------------------------------\nfrom sys import stdin\nfrom bisect import bisect_left\n\n# -- O(nlgn)\ndef main(xs, d):\n  total = 0\n  start, count = 0, 1\n  for i in range(1, len(xs)):\n    if abs(xs[i] - xs[start]) <= d:\n      # -- xs[i] is less than d distance from \"start\"\n      #    so add it to the set\n      count += 1\n    else:\n      # -- xs[i] is more than d distance from \"start\"\n      #    so break apart the set, removing elements that\n      #    are too far away from xs[i]\n      #    before breaking, we'll add C(count, 3) to the total\n      #    where count is size of the set\n      new_start = bisect_left(xs, xs[i] - d, start, i)\n      overlap = (i - 1) - new_start + 1\n      total += (count * (count - 1) * (count - 2)) / 6\n      if overlap > 0:\n        total -= (overlap * (overlap - 1) * (overlap - 2)) / 6\n      start = new_start\n      count = i - new_start + 1\n  total += (count * (count - 1) * (count - 2)) / 6\n  return total\n\nif __name__ == \"__main__\":\n  n, d = map(int, stdin.readline().strip('\\n').split(' '))\n  xs = map(int, stdin.readline().strip('\\n').split(' '))\n  result = main(xs, d)\n  print(result)\n",
        "correct": true,
        "task_id": "0629",
        "depth": 1
    },
    {
        "description": "This is a simplified version of the task Toy Train. These two versions differ only in the constraints. Hacks for this version are disabled.\n\nAlice received a set of Toy Train\u2122 from Bob. It consists of one train and a connected railway network of n stations, enumerated from 1 through n. The train occupies one station at a time and travels around the network of stations in a circular manner. More precisely, the immediate station that the train will visit after station i is station i+1 if 1 \u2264 i < n or station 1 if i = n. It takes the train 1 second to travel to its next station as described.\n\nBob gave Alice a fun task before he left: to deliver m candies that are initially at some stations to their independent destinations using the train. The candies are enumerated from 1 through m. Candy i (1 \u2264 i \u2264 m), now at station a_i, should be delivered to station b_i (a_i \u2260 b_i).\n\n<image> The blue numbers on the candies correspond to b_i values. The image corresponds to the 1-st example.\n\nThe train has infinite capacity, and it is possible to load off any number of candies at a station. However, only at most one candy can be loaded from a station onto the train before it leaves the station. You can choose any candy at this station. The time it takes to move the candies is negligible.\n\nNow, Alice wonders how much time is needed for the train to deliver all candies. Your task is to find, for each station, the minimum time the train would need to deliver all the candies were it to start from there.\n\nInput\n\nThe first line contains two space-separated integers n and m (2 \u2264 n \u2264 100; 1 \u2264 m \u2264 200) \u2014 the number of stations and the number of candies, respectively.\n\nThe i-th of the following m lines contains two space-separated integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n; a_i \u2260 b_i) \u2014 the station that initially contains candy i and the destination station of the candy, respectively.\n\nOutput\n\nIn the first and only line, print n space-separated integers, the i-th of which is the minimum time, in seconds, the train would need to deliver all the candies were it to start from station i.\n\nExamples\n\nInput\n\n\n5 7\n2 4\n5 1\n2 3\n3 4\n4 1\n5 3\n3 5\n\n\nOutput\n\n\n10 9 10 10 9 \n\n\nInput\n\n\n2 3\n1 2\n1 2\n1 2\n\n\nOutput\n\n\n5 6 \n\nNote\n\nConsider the second sample.\n\nIf the train started at station 1, the optimal strategy is as follows.\n\n  1. Load the first candy onto the train. \n  2. Proceed to station 2. This step takes 1 second. \n  3. Deliver the first candy. \n  4. Proceed to station 1. This step takes 1 second. \n  5. Load the second candy onto the train. \n  6. Proceed to station 2. This step takes 1 second. \n  7. Deliver the second candy. \n  8. Proceed to station 1. This step takes 1 second. \n  9. Load the third candy onto the train. \n  10. Proceed to station 2. This step takes 1 second. \n  11. Deliver the third candy. \n\n\n\nHence, the train needs 5 seconds to complete the tasks.\n\nIf the train were to start at station 2, however, it would need to move to station 1 before it could load the first candy, which would take one additional second. Thus, the answer in this scenario is 5+1 = 6 seconds.",
        "task_name": "1129_A1. Toy Train (Simplified)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python2\n\"\"\"\nThis file is part of https://github.com/cheran-senthil/PyRival\nCopyright 2019 Cheran Senthilkumar <hello@cheran.io>\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport itertools\nimport os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\n\n\nclass dict(dict):\n    \"\"\"dict() -> new empty dictionary\"\"\"\n\n    def items(self):\n        \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n        return dict.iteritems(self)\n\n    def keys(self):\n        \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n        return dict.iterkeys(self)\n\n    def values(self):\n        \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n        return dict.itervalues(self)\n\n\ndef gcd(x, y):\n    \"\"\"greatest common divisor of x and y\"\"\"\n    while y:\n        x, y = y, x % y\n    return x\n\n\nrange = xrange\n\nfilter = itertools.ifilter\nmap = itertools.imap\nzip = itertools.izip\n\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\n\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    station = [[] for _ in range(n)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        station[a - 1].append(b - 1)\n\n    max_candy = [0] * n\n    for i in range(n):\n        try:\n            max_candy[i] = min(station[i], key=lambda x: x + n - i if x < i else x - i)\n        except ValueError:\n            pass\n\n    for i in range(n):\n        res = 0\n\n        for j in range(i, i + n):\n            if len(station[j % n]) == 0:\n                continue\n\n            dist = j - i\n            j %= n\n            dist += (len(station[j]) - 1) * n + (max_candy[j] + n - j if max_candy[j] < j else max_candy[j] - j)\n\n            res = max(res, dist)\n\n        print(res, end=' ')\n\n\nif __name__ == '__main__':\n    main()\n",
        "correct": true,
        "task_id": "0656",
        "depth": 2
    },
    {
        "description": "Vasya has n items lying in a line. The items are consecutively numbered by numbers from 1 to n in such a way that the leftmost item has number 1, the rightmost item has number n. Each item has a weight, the i-th item weights wi kilograms.\n\nVasya needs to collect all these items, however he won't do it by himself. He uses his brand new robot. The robot has two different arms \u2014 the left one and the right one. The robot can consecutively perform the following actions: \n\n  1. Take the leftmost item with the left hand and spend wi \u00b7 l energy units (wi is a weight of the leftmost item, l is some parameter). If the previous action was the same (left-hand), then the robot spends extra Ql energy units; \n  2. Take the rightmost item with the right hand and spend wj \u00b7 r energy units (wj is a weight of the rightmost item, r is some parameter). If the previous action was the same (right-hand), then the robot spends extra Qr energy units; \n\n\n\nNaturally, Vasya wants to program the robot in a way that the robot spends as little energy as possible. He asked you to solve this problem. Your task is to find the minimum number of energy units robot spends to collect all items.\n\nInput\n\nThe first line contains five integers n, l, r, Ql, Qr (1 \u2264 n \u2264 105; 1 \u2264 l, r \u2264 100; 1 \u2264 Ql, Qr \u2264 104).\n\nThe second line contains n integers w1, w2, ..., wn (1 \u2264 wi \u2264 100).\n\nOutput\n\nIn the single line print a single number \u2014 the answer to the problem.\n\nExamples\n\nInput\n\n3 4 4 19 1\n42 3 99\n\n\nOutput\n\n576\n\n\nInput\n\n4 7 2 3 9\n1 2 3 4\n\n\nOutput\n\n34\n\nNote\n\nConsider the first sample. As l = r, we can take an item in turns: first from the left side, then from the right one and last item from the left. In total the robot spends 4\u00b742 + 4\u00b799 + 4\u00b73 = 576 energy units.\n\nThe second sample. The optimal solution is to take one item from the right, then one item from the left and two items from the right. In total the robot spends (2\u00b74) + (7\u00b71) + (2\u00b73) + (2\u00b72 + 9) = 34 energy units.",
        "task_name": "354_A. Vasya and Robot",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\ninp = [map(int, i.split(' ')) for i in sys.stdin.read().splitlines()]\n\nn, L, R, QL, QR = inp[0]\nw = inp[1]\n\ndef test(f):\n    global L, R, QL, QR, w\n    ret = 0\n    l, r = 0, len(w)\n    action = None\n    while l != r:\n        cost_l = w[l  ]*L + (QL if action == 0 else 0)\n        cost_r = w[r-1]*R + (QR if action == 1 else 0)\n        if action is not None:\n            if cost_l < cost_r:\n                action = 0\n            elif cost_l > cost_r:\n                action = 1\n        else:\n            action = f\n        if action == 0:\n            ret += cost_l\n            l += 1\n        else:\n            ret += cost_r\n            r -= 1\n    return ret\n\nres = min(test(0), test(1))\n\nsys.stdout.write(str(res))\n",
        "correct": false,
        "task_id": "0671",
        "depth": 1
    },
    {
        "description": "Dora loves adventures quite a lot. During some journey she encountered an amazing city, which is formed by n streets along the Eastern direction and m streets across the Southern direction. Naturally, this city has nm intersections. At any intersection of i-th Eastern street and j-th Southern street there is a monumental skyscraper. Dora instantly became curious and decided to explore the heights of the city buildings.\n\nWhen Dora passes through the intersection of the i-th Eastern and j-th Southern street she examines those two streets. After Dora learns the heights of all the skyscrapers on those two streets she wonders: how one should reassign heights to the skyscrapers on those two streets, so that the maximum height would be as small as possible and the result of comparing the heights of any two skyscrapers on one street wouldn't change.\n\nFormally, on every of nm intersections Dora solves an independent problem. She sees n + m - 1 skyscrapers and for each of them she knows its real height. Moreover, any two heights can be compared to get a result \"greater\", \"smaller\" or \"equal\". Now Dora wants to select some integer x and assign every skyscraper a height from 1 to x. When assigning heights, Dora wants to preserve the relative order of the skyscrapers in both streets. That is, the result of any comparison of heights of two skyscrapers in the current Eastern street shouldn't change and the result of any comparison of heights of two skyscrapers in current Southern street shouldn't change as well. Note that skyscrapers located on the Southern street are not compared with skyscrapers located on the Eastern street only. However, the skyscraper located at the streets intersection can be compared with both Southern and Eastern skyscrapers. For every intersection Dora wants to independently calculate the minimum possible x.\n\nFor example, if the intersection and the two streets corresponding to it look as follows:\n\n<image>\n\nThen it is optimal to replace the heights of the skyscrapers as follows (note that all comparisons \"less\", \"equal\", \"greater\" inside the Eastern street and inside the Southern street are preserved)\n\n<image>\n\nThe largest used number is 5, hence the answer for this intersection would be 5.\n\nHelp Dora to compute the answers for each intersection.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 1000) \u2014 the number of streets going in the Eastern direction and the number of the streets going in Southern direction.\n\nEach of the following n lines contains m integers a_{i,1}, a_{i,2}, ..., a_{i,m} (1 \u2264 a_{i,j} \u2264 10^9). The integer a_{i,j}, located on j-th position in the i-th line denotes the height of the skyscraper at the intersection of the i-th Eastern street and j-th Southern direction.\n\nOutput\n\nPrint n lines containing m integers each. The integer x_{i,j}, located on j-th position inside the i-th line is an answer for the problem at the intersection of i-th Eastern street and j-th Southern street.\n\nExamples\n\nInput\n\n\n2 3\n1 2 1\n2 1 2\n\n\nOutput\n\n\n2 2 2 \n2 2 2 \n\n\nInput\n\n\n2 2\n1 2\n3 4\n\n\nOutput\n\n\n2 3 \n3 2 \n\nNote\n\nIn the first example, it's not possible to decrease the maximum used height for the problem at any intersection, hence we don't have to change any heights.\n\nIn the second example, the answers are as follows: \n\n  * For the intersection of the first line and the first column <image>\n  * For the intersection of the first line and the second column <image>\n  * For the intersection of the second line and the first column <image>\n  * For the intersection of the second line and the second column <image>",
        "task_name": "1137_A. Skyscrapers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nn,m = map(int, raw_input().split(' '))\nlines = stdin.readlines()\nrows = [None]*n\nfor i in xrange(n):\n\trows[i] = map(int, lines[i].split(' '))\n\ndef equivalently_sorted_list(xs):\n\t'example: [10,20,14,10] -> ([1,3,2,1], 3). returns list of positive integers with equivalent pairwise comparisons (<,=,>) to list.'\n\n\txs = sorted([xs[i]*1000+i for i in xrange(len(xs))])\n\tys = [0]*len(xs)\n\tlast_x = None\n\tj = 0\n\tfor w in xs:\n\t\tx = w/1000\n\t\ti = w%1000\n\t\tif x == last_x:\n\t\t\tys[i] = j\n\t\telse:\n\t\t\tj += 1\n\t\t\tys[i] = j\n\t\tlast_x = x\n\treturn ys, j\n\ncolumns = [[rows[i][j] for i in xrange(n)] for j in xrange(m)]\n\nrows_ordered = [equivalently_sorted_list(row) for row in rows]\ncolumns_ordered = [equivalently_sorted_list(column) for column in columns]\n\ndef answer(i,j):\n\tif rows_ordered[i][0][j] > columns_ordered[j][0][i]:\n\t\tdifference = rows_ordered[i][0][j] - columns_ordered[j][0][i]\n\t\treturn max(rows_ordered[i][1], columns_ordered[j][1] + difference)\n\telse:\n\t\tdifference = columns_ordered[j][0][i] - rows_ordered[i][0][j]\n\t\treturn max(columns_ordered[j][1], rows_ordered[i][1] + difference)\n\nanswer_matrix = [[answer(i,j) for i in xrange(n)] for j in xrange(m)]\n\nstdout.write('\\n'.join([' '.join([str(answer_matrix[j][i]) for j in xrange(m)]) for i in xrange(n)]))",
        "correct": true,
        "task_id": "0697",
        "depth": 1
    },
    {
        "description": "Vasya has been playing Plane of Tanks with his friends the whole year. Now it is time to divide the participants into several categories depending on their results. \n\nA player is given a non-negative integer number of points in each round of the Plane of Tanks. Vasya wrote results for each round of the last year. He has n records in total.\n\nIn order to determine a player's category consider the best result obtained by the player and the best results of other players. The player belongs to category: \n\n  * \"noob\" \u2014 if more than 50% of players have better results; \n  * \"random\" \u2014 if his result is not worse than the result that 50% of players have, but more than 20% of players have better results; \n  * \"average\" \u2014 if his result is not worse than the result that 80% of players have, but more than 10% of players have better results; \n  * \"hardcore\" \u2014 if his result is not worse than the result that 90% of players have, but more than 1% of players have better results; \n  * \"pro\" \u2014 if his result is not worse than the result that 99% of players have. \n\n\n\nWhen the percentage is calculated the player himself is taken into account. That means that if two players played the game and the first one gained 100 points and the second one 1000 points, then the first player's result is not worse than the result that 50% of players have, and the second one is not worse than the result that 100% of players have.\n\nVasya gave you the last year Plane of Tanks results. Help Vasya determine each player's category.\n\nInput\n\nThe first line contains the only integer number n (1 \u2264 n \u2264 1000) \u2014 a number of records with the players' results.\n\nEach of the next n lines contains a player's name and the amount of points, obtained by the player for the round, separated with a space. The name contains not less than 1 and no more than 10 characters. The name consists of lowercase Latin letters only. It is guaranteed that any two different players have different names. The amount of points, obtained by the player for the round, is a non-negative integer number and does not exceed 1000.\n\nOutput\n\nPrint on the first line the number m \u2014 the number of players, who participated in one round at least.\n\nEach one of the next m lines should contain a player name and a category he belongs to, separated with space. Category can be one of the following: \"noob\", \"random\", \"average\", \"hardcore\" or \"pro\" (without quotes). The name of each player should be printed only once. Player names with respective categories can be printed in an arbitrary order.\n\nExamples\n\nInput\n\n5\nvasya 100\nvasya 200\nartem 100\nkolya 200\nigor 250\n\n\nOutput\n\n4\nartem noob\nigor pro\nkolya random\nvasya random\n\n\nInput\n\n3\nvasya 200\nkolya 1000\nvasya 1000\n\n\nOutput\n\n2\nkolya pro\nvasya pro\n\nNote\n\nIn the first example the best result, obtained by artem is not worse than the result that 25% of players have (his own result), so he belongs to category \"noob\". vasya and kolya have best results not worse than the results that 75% players have (both of them and artem), so they belong to category \"random\". igor has best result not worse than the result that 100% of players have (all other players and himself), so he belongs to category \"pro\".\n\nIn the second example both players have the same amount of points, so they have results not worse than 100% players have, so they belong to category \"pro\".",
        "task_name": "175_B. Plane of Tanks: Pro",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\nn = int(input());\nd = {};\nfor i in range (n):\n\t[s, a] = list(sys.stdin.readline().split());\n\tif s in d:\n\t\td[s] = max (d[s], int(a));\n\telse:\n\t\td[s] = int(a);\n\nn = len(d);\nprint (n);\nfor i, iv in d.items():\n\tcnt = 0;\n\tfor j, jv in d.items():\n\t\tif jv <= iv:\n\t\t\tcnt += 1;\n\trt = float (cnt) / n;\n\tif rt >= 0.99:\n\t\tprint (i + ' pro')\n\telif rt >= 0.9:\n\t\tprint (i + ' hardcore')\n\telif rt >= 0.8:\n\t\tprint (i + ' average')\n\telif rt >= 0.5:\n\t\tprint (i + ' random')\n\telif rt < 0.5:\n\t\tprint (i +  ' noob')\n",
        "correct": true,
        "task_id": "0709",
        "depth": 2
    },
    {
        "description": "There are an integer sequence A_1,...,A_N consisting of N terms, and N buttons. When the i-th (1 \u2266 i \u2266 N) button is pressed, the values of the i terms from the first through the i-th are all incremented by 1.\n\nThere is also another integer sequence B_1,...,B_N. Takahashi will push the buttons some number of times so that for every i, A_i will be a multiple of B_i.\n\nFind the minimum number of times Takahashi will press the buttons.\n\nConstraints\n\n* All input values are integers.\n* 1 \u2266 N \u2266 10^5\n* 0 \u2266 A_i \u2266 10^9(1 \u2266 i \u2266 N)\n* 1 \u2266 B_i \u2266 10^9(1 \u2266 i \u2266 N)\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN\nA_1 B_1\n:\nA_N B_N\n\n\nOutput\n\nPrint an integer representing the minimum number of times Takahashi will press the buttons.\n\nExamples\n\nInput\n\n3\n3 5\n2 7\n9 4\n\n\nOutput\n\n7\n\n\nInput\n\n7\n3 1\n4 1\n5 9\n2 6\n5 3\n5 8\n9 7\n\n\nOutput\n\n22",
        "task_name": "p03821 AtCoder Grand Contest 009 - Multiple Array",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n=int(raw_input())\nab=[map(int,raw_input().split()) for _ in xrange(n)]\ncnt=0\nfor i in xrange(n-1,-1,-1):\n    a,b=ab[i][0],ab[i][1]\n    if (a+cnt)%b==0:continue\n    cnt+=b-(a+cnt)%b\nprint(cnt)",
        "correct": true,
        "task_id": "0735",
        "depth": 1
    },
    {
        "description": "You are given two positive integers n (1 \u2264 n \u2264 10^9) and k (1 \u2264 k \u2264 100). Represent the number n as the sum of k positive integers of the same parity (have the same remainder when divided by 2).\n\nIn other words, find a_1, a_2, \u2026, a_k such that all a_i>0, n = a_1 + a_2 + \u2026 + a_k and either all a_i are even or all a_i are odd at the same time.\n\nIf such a representation does not exist, then report it.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases in the input. Next, t test cases are given, one per line.\n\nEach test case is two positive integers n (1 \u2264 n \u2264 10^9) and k (1 \u2264 k \u2264 100).\n\nOutput\n\nFor each test case print:\n\n  * YES and the required values a_i, if the answer exists (if there are several answers, print any of them); \n  * NO if the answer does not exist. \n\n\n\nThe letters in the words YES and NO can be printed in any case.\n\nExample\n\nInput\n\n\n8\n10 3\n100 4\n8 7\n97 2\n8 8\n3 10\n5 3\n1000000000 9\n\n\nOutput\n\n\nYES\n4 2 4\nYES\n55 5 5 35\nNO\nNO\nYES\n1 1 1 1 1 1 1 1\nNO\nYES\n3 1 1\nYES\n111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111120",
        "task_name": "1352_B. Same Parity Summands",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\n\n\ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import log,sqrt,factorial,cos,tan,sin,radians\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *\n#import threading\n#from itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey,reverse=True)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\ndef ncr(n,r): return factorial(n)//(factorial(r)*factorial(max(n-r,1)))\n\ndef ceil(x,y):\n    if x%y==0:\n        return x//y\n    else:\n        return x//y+1\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\ndef lower_bound(l,k):\n    s = 0\n    e = len(l) - 1\n    while(s<e):\n        m = (s+e)//2\n        if(l[m] >= k):\n            e = m\n        else:\n            s = m+1\n    return s\n\ndef upper_bound(l,k):\n    s = 0\n    e = len(l) - 1\n    while(s<e):\n        m = (s+e)//2\n        if(l[m] <= k):\n            s = m+1\n        else:\n            e = m\n    return s\n\ndef bs(l,k):\n    s = 0\n    e = len(l) - 1\n    while(s<=e):\n        m = (s+e)//2\n        if(l[m] == k):\n            return m\n        elif(l[m] > k):\n            e = m-1\n        else:\n            s = m+1\n    return -1\n\n\ndef read():\n    sys.stdin  = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\ndef ii():  return int(input())\ndef si():  return input()\ndef mi():  return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li():  return list(mi())\n\n\n\ndef main():\n    # read()\n    for _ in range(ii()):\n        n,k = mi()\n        if(k>n):\n            print(\"NO\")\n            \n        elif(n==k):\n            print(\"YES\")\n            for i in range(n):\n                print(1,end=\" \")\n            print()\n        else:\n            if(n%2==0 and k%2==0):\n                print(\"YES\")\n                if(k*2 <= n):\n                    for i in range(k-1):\n                        print(2,end=\" \")\n                    print(n-((k-1)*2))\n                else:\n                    for i in range(k-1):\n                        print(1,end=\" \")\n                    print(n-(k-1))\n            elif(n%2==0 and k%2==1):\n                if(k*2 <= n):\n                    print(\"YES\")\n                    for i in range(k-1):\n                        print(2,end=\" \")\n                    print(n-((k-1)*2))\n                else:\n                    print(\"NO\")\n            elif(n%2):\n                if(k%2==0):\n                    print(\"NO\")\n                else:\n                    print(\"YES\")\n                    for i in range(k-1):\n                        print(1,end=\" \")\n                    print(n-(k-1))\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    \n    main()\n    #dmain()\n\n# Comment Read()\n\n\n",
        "correct": true,
        "task_id": "0746",
        "depth": 2
    },
    {
        "description": "There are n benches in the Berland Central park. It is known that a_i people are currently sitting on the i-th bench. Another m people are coming to the park and each of them is going to have a seat on some bench out of n available.\n\nLet k be the maximum number of people sitting on one bench after additional m people came to the park. Calculate the minimum possible k and the maximum possible k.\n\nNobody leaves the taken seat during the whole process.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 100) \u2014 the number of benches in the park.\n\nThe second line contains a single integer m (1 \u2264 m \u2264 10 000) \u2014 the number of people additionally coming to the park.\n\nEach of the next n lines contains a single integer a_i (1 \u2264 a_i \u2264 100) \u2014 the initial number of people on the i-th bench.\n\nOutput\n\nPrint the minimum possible k and the maximum possible k, where k is the maximum number of people sitting on one bench after additional m people came to the park.\n\nExamples\n\nInput\n\n4\n6\n1\n1\n1\n1\n\n\nOutput\n\n3 7\n\n\nInput\n\n1\n10\n5\n\n\nOutput\n\n15 15\n\n\nInput\n\n3\n6\n1\n6\n5\n\n\nOutput\n\n6 12\n\n\nInput\n\n3\n7\n1\n6\n5\n\n\nOutput\n\n7 13\n\nNote\n\nIn the first example, each of four benches is occupied by a single person. The minimum k is 3. For example, it is possible to achieve if two newcomers occupy the first bench, one occupies the second bench, one occupies the third bench, and two remaining \u2014 the fourth bench. The maximum k is 7. That requires all six new people to occupy the same bench.\n\nThe second example has its minimum k equal to 15 and maximum k equal to 15, as there is just a single bench in the park and all 10 people will occupy it.",
        "task_name": "1042_A. Benches",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport math\nn = int(sys.stdin.readline())\nm = int(sys.stdin.readline())\na = [0]*n\nfor i in range(n):\n  a[i] = int(sys.stdin.readline())\n\nasort = sorted(a, reverse=True)\n\nnumspacesremaining = asort[0]*(n-1) - sum(asort[1:])\n\nif m <= numspacesremaining:\n  mink = max(asort)\nelse:\n  mink = max(asort) + max(math.ceil((m - numspacesremaining)/float(n)), 0)\n\nmaxk = max(a) + m\n\nprint(str(int(mink)) + \" \" + str(maxk))\n",
        "correct": true,
        "task_id": "0812",
        "depth": 1
    },
    {
        "description": "You are a coach at your local university. There are n students under your supervision, the programming skill of the i-th student is a_i.\n\nYou have to form k teams for yet another new programming competition. As you know, the more students are involved in competition the more probable the victory of your university is! So you have to form no more than k (and at least one) non-empty teams so that the total number of students in them is maximized. But you also know that each team should be balanced. It means that the programming skill of each pair of students in each team should differ by no more than 5. Teams are independent from one another (it means that the difference between programming skills of two students from two different teams does not matter).\n\nIt is possible that some students not be included in any team at all.\n\nYour task is to report the maximum possible total number of students in no more than k (and at least one) non-empty balanced teams.\n\nIf you are Python programmer, consider using PyPy instead of Python when you submit your code.\n\nInput\n\nThe first line of the input contains two integers n and k (1 \u2264 k \u2264 n \u2264 5000) \u2014 the number of students and the maximum number of teams, correspondingly.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9), where a_i is a programming skill of the i-th student.\n\nOutput\n\nPrint one integer \u2014 the maximum possible total number of students in no more than k (and at least one) non-empty balanced teams.\n\nExamples\n\nInput\n\n\n5 2\n1 2 15 15 15\n\n\nOutput\n\n\n5\n\n\nInput\n\n\n6 1\n36 4 1 25 9 16\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n4 4\n1 10 100 1000\n\n\nOutput\n\n\n4",
        "task_name": "1133_E. K Balanced Teams",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, k = map(int, raw_input().split())\na = map(int, raw_input().split())\n\na.sort()\n\ncnt_from = [0] * n\nfor i in range(n):\n\twhile (i+cnt_from[i] < n) and (a[i+cnt_from[i]] - a[i] <= 5):\n\t\tcnt_from[i] += 1\n\ndp = [[0] * (k+1) for _ in range(n+1)]\nfor i in range(n):\n\tfor j in range(k+1):\n\t\tdp[i+1][j] = max(dp[i+1][j], dp[i][j])\n\t\tif j+1 <= k:\n\t\t\tdp[i+cnt_from[i]][j+1] = max(dp[i+cnt_from[i]][j+1], dp[i][j] + cnt_from[i])\nprint(dp[n][k])",
        "correct": true,
        "task_id": "0814",
        "depth": 2
    },
    {
        "description": "During the last Sereja's Codesecrof round the server crashed many times, so the round was decided to be made unrated for some participants. \n\nLet's assume that n people took part in the contest. Let's assume that the participant who got the first place has rating a1, the second place participant has rating a2, ..., the n-th place participant has rating an. Then changing the rating on the Codesecrof site is calculated by the formula <image>.\n\nAfter the round was over, the Codesecrof management published the participants' results table. They decided that if for a participant di < k, then the round can be considered unrated for him. But imagine the management's surprise when they found out that the participants' rating table is dynamic. In other words, when some participant is removed from the rating, he is removed from the results' table and the rating is recalculated according to the new table. And of course, all applications for exclusion from the rating are considered in view of the current table.\n\nWe know that among all the applications for exclusion from the rating the first application to consider is from the participant with the best rank (the rank with the minimum number), for who di < k. We also know that the applications for exclusion from rating were submitted by all participants.\n\nNow Sereja wonders, what is the number of participants to be excluded from the contest rating, and the numbers of the participants in the original table in the order of their exclusion from the rating. Pay attention to the analysis of the first test case for a better understanding of the statement.\n\nInput\n\nThe first line contains two integers n, k (1 \u2264 n \u2264 2\u00b7105, - 109 \u2264 k \u2264 0). The second line contains n space-separated integers a1, a2, ..., an (1 \u2264 ai \u2264 109) \u2014 ratings of the participants in the initial table.\n\nOutput\n\nPrint the numbers of participants in the order in which they were removed from the table. Print the initial numbers of the participants, that is, the numbers that the participants had in the initial table.\n\nExamples\n\nInput\n\n5 0\n5 3 4 1 2\n\n\nOutput\n\n2\n3\n4\n\n\nInput\n\n10 -10\n5 5 1 7 5 1 2 4 9 2\n\n\nOutput\n\n2\n4\n5\n7\n8\n9\n\nNote\n\nConsider the first test sample. \n\n  1. Initially the sequence of the contest participants' ratings equals [5, 3, 4, 1, 2]. You can use this sequence to calculate the sequence of rating changes: [0, -9, -13, 8, 14]. According to the problem statement, the application of the participant who won the second place will be considered first.\n  2. As soon as the second place winner is out from the ratings, the participants' rating sequence will equal [5, 4, 1, 2]. By this sequence you can count the new sequence of rating changes: [0, -8, 2, 6]. According to the problem statement, the application of the participant who won the second place will be considered. Initially this participant won third place.\n  3. The new rating sequence equals [5, 1, 2], the new sequence of rating changes equals [0, -1, 1]. The second place participant's application is taken into consideration, initially this participant won the fourth place.\n  4. The new rating sequence equals [5, 2], the new sequence of rating changes equals [0, 0]. No more applications will be considered. \n\n\n\nThus, you should print 2, 3, 4.",
        "task_name": "315_C. Sereja and Contest",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, k = rints()\na, ans, s = rints(), [], 0\n\nfor i in range(1, n):\n    if s - (n - i - len(ans) - 1) * a[i] * (i - len(ans)) < k:\n        ans.append(i + 1)\n        n -= 1\n    else:\n        s += a[i] * (i - len(ans))\n\nprint('\\n'.join(map(str, ans)))\n",
        "correct": false,
        "task_id": "0828",
        "depth": 1
    },
    {
        "description": "Gildong owns a bulgogi restaurant. The restaurant has a lot of customers, so many of them like to make a reservation before visiting it.\n\nGildong tries so hard to satisfy the customers that he even memorized all customers' preferred temperature ranges! Looking through the reservation list, he wants to satisfy all customers by controlling the temperature of the restaurant.\n\nThe restaurant has an air conditioner that has 3 states: off, heating, and cooling. When it's off, the restaurant's temperature remains the same. When it's heating, the temperature increases by 1 in one minute. Lastly, when it's cooling, the temperature decreases by 1 in one minute. Gildong can change the state as many times as he wants, at any integer minutes. The air conditioner is off initially.\n\nEach customer is characterized by three values: t_i \u2014 the time (in minutes) when the i-th customer visits the restaurant, l_i \u2014 the lower bound of their preferred temperature range, and h_i \u2014 the upper bound of their preferred temperature range.\n\nA customer is satisfied if the temperature is within the preferred range at the instant they visit the restaurant. Formally, the i-th customer is satisfied if and only if the temperature is between l_i and h_i (inclusive) in the t_i-th minute.\n\nGiven the initial temperature, the list of reserved customers' visit times and their preferred temperature ranges, you're going to help him find if it's possible to satisfy all customers.\n\nInput\n\nEach test contains one or more test cases. The first line contains the number of test cases q (1 \u2264 q \u2264 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 100, -10^9 \u2264 m \u2264 10^9), where n is the number of reserved customers and m is the initial temperature of the restaurant.\n\nNext, n lines follow. The i-th line of them contains three integers t_i, l_i, and h_i (1 \u2264 t_i \u2264 10^9, -10^9 \u2264 l_i \u2264 h_i \u2264 10^9), where t_i is the time when the i-th customer visits, l_i is the lower bound of their preferred temperature range, and h_i is the upper bound of their preferred temperature range. The preferred temperature ranges are inclusive.\n\nThe customers are given in non-decreasing order of their visit time, and the current time is 0.\n\nOutput\n\nFor each test case, print \"YES\" if it is possible to satisfy all customers. Otherwise, print \"NO\".\n\nYou can print each letter in any case (upper or lower).\n\nExample\n\nInput\n\n\n4\n3 0\n5 1 2\n7 3 5\n10 -1 0\n2 12\n5 7 10\n10 16 20\n3 -100\n100 0 0\n100 -50 50\n200 100 100\n1 100\n99 -100 0\n\n\nOutput\n\n\nYES\nNO\nYES\nNO\n\nNote\n\nIn the first case, Gildong can control the air conditioner to satisfy all customers in the following way:\n\n  * At 0-th minute, change the state to heating (the temperature is 0). \n  * At 2-nd minute, change the state to off (the temperature is 2). \n  * At 5-th minute, change the state to heating (the temperature is 2, the 1-st customer is satisfied). \n  * At 6-th minute, change the state to off (the temperature is 3). \n  * At 7-th minute, change the state to cooling (the temperature is 3, the 2-nd customer is satisfied). \n  * At 10-th minute, the temperature will be 0, which satisfies the last customer. \n\n\n\nIn the third case, Gildong can change the state to heating at 0-th minute and leave it be. Then all customers will be satisfied. Note that the 1-st customer's visit time equals the 2-nd customer's visit time.\n\nIn the second and the fourth case, Gildong has to make at least one customer unsatisfied.",
        "task_name": "1304_C. Air Conditioner",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n# Author : raj1307 - Raj Singh\n# Date   : 19.02.2020\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey,reverse=True)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\ndef ncr(n,r):\n\n    return factorial(n)//(factorial(r)*factorial(n-r))\n\n\n\ndef main():\n        \n\n    for _ in range(ii()):\n    \n        n,m=mi()\n        l=[]\n        for i in range(n):\n            l.append(li())\n\n\n        l.sort()\n        f=1\n    \n\n        low=m\n        high=m\n        ini=0\n\n        for i in range(n):\n\n            t=l[i][0]\n            x=l[i][1]\n            y=l[i][2]\n            dif=t-ini\n            ini=t\n            low-=dif\n            high+=dif\n            low=max(low,x)\n            high=min(high,y)\n            if low>high:\n                f=0\n                break\n\n        \n        if f:\n            print('YES')\n        else:\n            print('NO')\n\n            \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": true,
        "task_id": "0858",
        "depth": 2
    },
    {
        "description": "Lee was cleaning his house for the party when he found a messy string under the carpets. Now he'd like to make it clean accurately and in a stylish way...\n\nThe string s he found is a binary string of length n (i. e. string consists only of 0-s and 1-s).\n\nIn one move he can choose two consecutive characters s_i and s_{i+1}, and if s_i is 1 and s_{i + 1} is 0, he can erase exactly one of them (he can choose which one to erase but he can't erase both characters simultaneously). The string shrinks after erasing.\n\nLee can make an arbitrary number of moves (possibly zero) and he'd like to make the string s as clean as possible. He thinks for two different strings x and y, the shorter string is cleaner, and if they are the same length, then the lexicographically smaller string is cleaner.\n\nNow you should answer t test cases: for the i-th test case, print the cleanest possible string that Lee can get by doing some number of moves.\n\nSmall reminder: if we have two strings x and y of the same length then x is lexicographically smaller than y if there is a position i such that x_1 = y_1, x_2 = y_2,..., x_{i - 1} = y_{i - 1} and x_i < y_i.\n\nInput\n\nThe first line contains the integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. \n\nNext 2t lines contain test cases \u2014 one per two lines.\n\nThe first line of each test case contains the integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string s.\n\nThe second line contains the binary string s. The string s is a string of length n which consists only of zeroes and ones.\n\nIt's guaranteed that sum of n over test cases doesn't exceed 10^5.\n\nOutput\n\nPrint t answers \u2014 one per test case.\n\nThe answer to the i-th test case is the cleanest string Lee can get after doing some number of moves (possibly zero).\n\nExample\n\nInput\n\n\n5\n10\n0001111111\n4\n0101\n8\n11001101\n10\n1110000000\n1\n1\n\n\nOutput\n\n\n0001111111\n001\n01\n0\n1\n\nNote\n\nIn the first test case, Lee can't perform any moves.\n\nIn the second test case, Lee should erase s_2.\n\nIn the third test case, Lee can make moves, for example, in the following order: 11001101 \u2192 1100101 \u2192 110101 \u2192 10101 \u2192 1101 \u2192 101 \u2192 01.",
        "task_name": "1369_B. AccurateLee",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Enter your code here. Read input from STDIN. Print output to STDOUT# ===============================================================================================\n# importing some useful libraries.\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom itertools import *\nimport bisect\nfrom heapq import *\nfrom math import ceil, floor\nfrom copy import *\nfrom collections import deque, defaultdict\nfrom collections import Counter as counter  # Counter(list)  return a dict with {key: count}\nfrom itertools import combinations  # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\nfrom itertools import permutations as permutate\nfrom bisect import bisect_left as bl\nfrom operator import *\n# If the element is already present in the list,\n\n# the left most position where element has to be inserted is returned.\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n# If the element is already present in the list,\n# the right most position where element has to be inserted is returned\n\n# ==============================================================================================\n# fast I/O region\n\nBUFSIZE = 8192\nfrom sys import stderr\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\n\n\ndef iterative(f, stack=[]):\n    def wrapped_func(*args, **kwargs):\n        if stack: return f(*args, **kwargs)\n        to = f(*args, **kwargs)\n        while True:\n            if type(to) is GeneratorType:\n                stack.append(to)\n                to = next(to)\n                continue\n            stack.pop()\n            if not stack: break\n            to = stack[-1].send(to)\n        return to\n\n    return wrapped_func\n\n\n#### END ITERATE RECURSION ####\n###########################\n# Sorted list\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\n\n# ===============================================================================================\n# some shortcuts\n\nmod = 1000000007\n\n\ndef testcase(t):\n    for p in range(t):\n        solve()\n\n\ndef pow(x, y, p):\n    res = 1  # Initialize result\n    x = x % p  # Update x if it is more , than or equal to p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):  # If y is odd, multiply, x with result\n            res = (res * x) % p\n\n        y = y >> 1  # y = y/2\n        x = (x * x) % p\n    return res\n\n\nfrom functools import reduce\n\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef gcd(a, b):\n    if a == b: return a\n    while b > 0: a, b = b, a % b\n    return a\n\n\n# discrete binary search\n# minimise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for i in range(200):\n#         if isvalid(l):\n#             return l\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m - 1):\n#             return m\n#         if isvalid(m):\n#             r = m + 1\n#         else:\n#             l = m\n#     return m\n\n# maximise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for i in range(200):\n#         # print(l,r)\n#         if isvalid(r):\n#             return r\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m + 1):\n#             return m\n#         if isvalid(m):\n#             l = m\n#         else:\n#             r = m - 1\n#     return m\n\n\n##############Find sum of product of subsets of size k in a array\n# ar=[0,1,2,3]\n# k=3\n# n=len(ar)-1\n# dp=[0]*(n+1)\n# dp[0]=1\n# for pos in range(1,n+1):\n#     dp[pos]=0\n#     l=max(1,k+pos-n-1)\n#     for j in range(min(pos,k),l-1,-1):\n#         dp[j]=dp[j]+ar[pos]*dp[j-1]\n# print(dp[k])\n\ndef prefix_sum(ar):  # [1,2,3,4]->[1,3,6,10]\n    return list(accumulate(ar))\n\n\ndef suffix_sum(ar):  # [1,2,3,4]->[10,9,7,4]\n    return list(accumulate(ar[::-1]))[::-1]\n\n\ndef N():\n    return int(inp())\n\n\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\n\ndef YES():\n    print(\"YES\")\n\n\ndef NO():\n    print(\"NO\")\n\n\ndef Yes():\n    print(\"Yes\")\n\n\ndef No():\n    print(\"No\")\n\n\n# =========================================================================================\nfrom collections import defaultdict\n\n\ndef numberOfSetBits(i):\n    i = i - ((i >> 1) & 0x55555555)\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        # self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        # self.lista[a] += self.lista[b]\n        # self.lista[b] = []\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef lcm(a, b):\n    return abs((a // gcd(a, b)) * b)\n\n\n# #\n# to find factorial and ncr\n# tot = 100005\n# mod = 10**9 + 7\n# fac = [1, 1]\n# finv = [1, 1]\n# inv = [0, 1]\n#\n# for i in range(2, tot + 1):\n#     fac.append((fac[-1] * i) % mod)\n#     inv.append(mod - (inv[mod % i] * (mod // i) % mod))\n#     finv.append(finv[-1] * inv[-1] % mod)\n\n\ndef comb(n, r):\n    if n < r:\n        return 0\n    else:\n        return fac[n] * (finv[r] * finv[n - r] % mod) % mod\n\n\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\")  # for fast input\n\n\ndef out(var): sys.stdout.write(str(var))  # for fast output, always take string\n\n\ndef lis(): return list(map(int, inp().split()))\n\n\ndef stringlis(): return list(map(str, inp().split()))\n\n\ndef sep(): return map(int, inp().split())\n\n\ndef strsep(): return map(str, inp().split())\n\n\ndef fsep(): return map(float, inp().split())\n\n\ndef nextline(): out(\"\\n\")  # as stdout.write always print sring.\n\n\ndef arr1d(n, v):\n    return [v] * n\n\n\ndef arr2d(n, m, v):\n    return [[v] * m for _ in range(n)]\n\n\ndef arr3d(n, m, p, v):\n    return [[[v] * p for _ in range(m)] for i in range(n)]\n\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\n\n# co-ordinate compression\n# ma={s:idx for idx,s in enumerate(sorted(set(l+r)))}\n\n# mxn=100005\n# lrg=[0]*mxn\n# for i in range(2,mxn-3):\n#     if (lrg[i]==0):\n#         for j in range(i,mxn-3,i):\n#             lrg[j]=i\n\n\ndef solve():\n    n=N()\n    s=inp()\n    ar=[]\n    cur=\"\"\n    curl=0\n    for i in range(n):\n        if s[i]==cur:\n            curl+=1\n        else:\n            if cur!=\"\":\n                ar.append((cur,curl))\n            cur=s[i]\n            curl=1\n    if curl>0:\n        ar.append((cur,curl))\n    # print(ar)\n\n\n\n    if len(ar)==1:\n        print(s)\n        return\n\n    if len(ar)==2:\n        if s[-1]==\"1\":\n            print(s)\n            return\n        else:\n            print(\"0\")\n            return\n    if ar[0][0]==\"1\":\n        notrem=\"\"\n    else:\n        notrem=\"0\"*ar[0][1]\n\n    if ar[-1][0]==\"0\":\n        print(notrem+\"0\")\n        return\n    else:\n        print(notrem+\"0\"+\"1\"*ar[-1][1])\n        return\n\n\n\n\n#solve()\ntestcase(int(inp()))\n\n\n",
        "correct": true,
        "task_id": "0861",
        "depth": 1
    },
    {
        "description": "Iroha has a sequence of N strings S_1, S_2, ..., S_N. The length of each string is L.\n\nShe will concatenate all of the strings in some order, to produce a long string.\n\nAmong all strings that she can produce in this way, find the lexicographically smallest one.\n\nHere, a string s=s_1s_2s_3...s_n is lexicographically smaller than another string t=t_1t_2t_3...t_m if and only if one of the following holds:\n\n* There exists an index i(1\u2266i\u2266min(n,m)), such that s_j = t_j for all indices j(1\u2266j<i), and s_i<t_i.\n* s_i = t_i for all integers i(1\u2266i\u2266min(n,m)), and n<m.\n\nConstraints\n\n* 1 \u2266 N, L \u2266 100\n* For each i, the length of S_i equals L.\n* For each i, S_i consists of lowercase letters.\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN L\nS_1\nS_2\n:\nS_N\n\n\nOutput\n\nPrint the lexicographically smallest string that Iroha can produce.\n\nExample\n\nInput\n\n3 3\ndxx\naxx\ncxx\n\n\nOutput\n\naxxcxxdxx",
        "task_name": "p04044 AtCoder Beginner Contest 042 - Iroha Loves Strings (ABC Edition)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n,l=map(int,raw_input().split())\ns=[raw_input() for _ in xrange(n)]\ns.sort()\nans=\"\"\nfor i in xrange(n):\n    ans+=s[i]\nprint(ans)\n",
        "correct": true,
        "task_id": "0894",
        "depth": 1
    },
    {
        "description": "You survived several months of exam wars and were able to enter ICPC University on a sunny day. On the day of admission, there was an enthusiastic recruitment of circles on the campus of the university, and you received a large number of pamphlets and returned. When you return to your room, you find one of the pamphlets you received that interests you. The pamphlet was given by the university's public relations department.\n\nThe following problems were described in the pamphlet.\n\n> How many combinations of two or more consecutive positive integers have a sum of N? For example, 9 has two combinations, 2 + 3 + 4 and 4 + 5.\n\nIf you were curious about the answer to this question, you decided to write a program to find out the answer. Therefore, your job is to write a program that outputs the answer to the problem for the positive integer N given as the input.\n\n\n\nInput\n\nThe input is a sequence of datasets. Each dataset is a line of one integer N. Where 1 \u2264 N \u2264 1000.\n\nThe end of the input is indicated by a single line of zeros.\n\nOutput\n\nThe output is the order of the input datasets, which is the answer to the question for the positive integers represented by each dataset of the inputs. No other characters should be in the output.\n\nExample\n\nInput\n\n9\n500\n0\n\n\nOutput\n\n2\n3",
        "task_name": "p01314 Sum of Consecutive Integers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/python\nimport sys\nif sys.version_info[0]>=3: raw_input=input\n\ntry:\n\twhile True:\n\t\tn=int(raw_input())\n\t\tif n==0: break\n\t\tr=0\n\t\ti=1\n\t\twhile 1:\n\t\t\tn-=i\n\t\t\tif n<0: break\n\t\t\ti+=1\n\t\t\tif n%i==0: r+=1\n\t\tprint(r)\nexcept EOFError:\n\tpass",
        "correct": false,
        "task_id": "0896",
        "depth": 2
    },
    {
        "description": "Now Serval is a junior high school student in Japari Middle School, and he is still thrilled on math as before. \n\nAs a talented boy in mathematics, he likes to play with numbers. This time, he wants to play with numbers on a rooted tree.\n\nA tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a node v is the last different from v vertex on the path from the root to the vertex v. Children of vertex v are all nodes for which v is the parent. A vertex is a leaf if it has no children.\n\nThe rooted tree Serval owns has n nodes, node 1 is the root. Serval will write some numbers into all nodes of the tree. However, there are some restrictions. Each of the nodes except leaves has an operation max or min written in it, indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons, respectively. \n\nAssume that there are k leaves in the tree. Serval wants to put integers 1, 2, \u2026, k to the k leaves (each number should be used exactly once). He loves large numbers, so he wants to maximize the number in the root. As his best friend, can you help him?\n\nInput\n\nThe first line contains an integer n (2 \u2264 n \u2264 3\u22c5 10^5), the size of the tree.\n\nThe second line contains n integers, the i-th of them represents the operation in the node i. 0 represents min and 1 represents max. If the node is a leaf, there is still a number of 0 or 1, but you can ignore it.\n\nThe third line contains n-1 integers f_2, f_3, \u2026, f_n (1 \u2264 f_i \u2264 i-1), where f_i represents the parent of the node i.\n\nOutput\n\nOutput one integer \u2014 the maximum possible number in the root of the tree.\n\nExamples\n\nInput\n\n\n6\n1 0 1 1 0 1\n1 2 2 2 2\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n1 0 1 0 1\n1 1 1 1\n\n\nOutput\n\n\n4\n\n\nInput\n\n\n8\n1 0 0 1 0 1 1 0\n1 1 2 2 3 3 3\n\n\nOutput\n\n\n4\n\n\nInput\n\n\n9\n1 1 0 0 1 0 1 0 1\n1 1 2 2 3 3 4 4\n\n\nOutput\n\n\n5\n\nNote\n\nPictures below explain the examples. The numbers written in the middle of the nodes are their indices, and the numbers written on the top are the numbers written in the nodes.\n\nIn the first example, no matter how you arrange the numbers, the answer is 1.\n\n<image>\n\nIn the second example, no matter how you arrange the numbers, the answer is 4.\n\n<image>\n\nIn the third example, one of the best solution to achieve 4 is to arrange 4 and 5 to nodes 4 and 5.\n\n<image>\n\nIn the fourth example, the best solution is to arrange 5 to node 5.\n\n<image>",
        "task_name": "1153_D. Serval and Rooted Tree",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Author: Mak Kader\n# Description: Template for pypy or python\n\n\nimport math\nimport sys\nimport heapq\nfrom collections import defaultdict\nfrom collections import deque\nfrom sys import stdin, stdout\nsys.setrecursionlimit(1 << 29)\n# Flush output: sys.stdout.flush()\n\ndef readInts():\n    return [int(x) for x in stdin.readline().split()]\n\ndef readInt():\n    return int(stdin.readline())\n\ndef readLine():\n    return stdin.readline().strip()\n\n# template end\n\n\nN = readInt()\n#assert(N < 10000)\n\nop = [0] + readInts()\npa = [0, 0] + readInts()\n\nG = defaultdict(list)\nfor i in range(2, N + 1):\n    p = pa[i]\n    G[p].append(i)\nnleaf = [0] * (N + 1)\nfor i in range(N, 0, -1):\n    if len(G[i]) == 0:\n        nleaf[i] = 1\n        continue\n    for j in G[i]:\n        nleaf[i] += nleaf[j]  # if len(G[j]) > 0 else 1\n\nmemo = {}\ndef dfs(root):\n    global memo\n    if len(G[root]) == 0:\n        return 1\n    if root in memo:\n        return memo[root]\n    res = 0\n    if op[root] == 0:  # min\n        #nl = nleaf[root]\n\n        for v in G[root]:\n            res = max(res, dfs(v))\n\n    else:\n        # max node\n        nl = nleaf[root]\n\n        for v in G[root]:\n            nlv = nleaf[v]\n            res = max(res, nl - (nlv - dfs(v)))\n    memo[root] = res\n    return memo[root]\n\n\nfor i in range(N, 0, -1):\n    dfs(i)\n\n# print(memo)\nres = dfs(1)\n#print(nleaf[1] - ms, ms)\nprint(res)\n",
        "correct": false,
        "task_id": "0903",
        "depth": 2
    },
    {
        "description": "The end of the school year is near and Ms. Manana, the teacher, will soon have to say goodbye to a yet another class. She decided to prepare a goodbye present for her n students and give each of them a jigsaw puzzle (which, as wikipedia states, is a tiling puzzle that requires the assembly of numerous small, often oddly shaped, interlocking and tessellating pieces).\n\nThe shop assistant told the teacher that there are m puzzles in the shop, but they might differ in difficulty and size. Specifically, the first jigsaw puzzle consists of f1 pieces, the second one consists of f2 pieces and so on.\n\nMs. Manana doesn't want to upset the children, so she decided that the difference between the numbers of pieces in her presents must be as small as possible. Let A be the number of pieces in the largest puzzle that the teacher buys and B be the number of pieces in the smallest such puzzle. She wants to choose such n puzzles that A - B is minimum possible. Help the teacher and find the least possible value of A - B.\n\nInput\n\nThe first line contains space-separated integers n and m (2 \u2264 n \u2264 m \u2264 50). The second line contains m space-separated integers f1, f2, ..., fm (4 \u2264 fi \u2264 1000) \u2014 the quantities of pieces in the puzzles sold in the shop.\n\nOutput\n\nPrint a single integer \u2014 the least possible difference the teacher can obtain.\n\nExamples\n\nInput\n\n4 6\n10 12 10 7 5 22\n\n\nOutput\n\n5\n\nNote\n\nSample 1. The class has 4 students. The shop sells 6 puzzles. If Ms. Manana buys the first four puzzles consisting of 10, 12, 10 and 7 pieces correspondingly, then the difference between the sizes of the largest and the smallest puzzle will be equal to 5. It is impossible to obtain a smaller difference. Note that the teacher can also buy puzzles 1, 3, 4 and 5 to obtain the difference 5.",
        "task_name": "337_A. Puzzles",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "students, num_puzzles = list(map(int, raw_input().split()))\npuzzles = list(map(int, raw_input().split()))\npuzzles.sort()\nbest = 999999\nfor i in range(num_puzzles-students+1):\n    best = min(puzzles[i+students - 1] - puzzles[i], best)\nif (best == 999999):\n    best = puzzles[-1] - puzzles[0]\nprint(best)",
        "correct": true,
        "task_id": "0914",
        "depth": 1
    },
    {
        "description": "Little Artem found a grasshopper. He brought it to his house and constructed a jumping area for him.\n\nThe area looks like a strip of cells 1 \u00d7 n. Each cell contains the direction for the next jump and the length of that jump. Grasshopper starts in the first cell and follows the instructions written on the cells. Grasshopper stops immediately if it jumps out of the strip. Now Artem wants to find out if this will ever happen.\n\nInput\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000) \u2014 length of the strip. \n\nNext line contains a string of length n which consists of characters \"<\" and \">\" only, that provide the direction of the jump from the corresponding cell. Next line contains n integers di (1 \u2264 di \u2264 109) \u2014 the length of the jump from the i-th cell.\n\nOutput\n\nPrint \"INFINITE\" (without quotes) if grasshopper will continue his jumps forever. Otherwise print \"FINITE\" (without quotes).\n\nExamples\n\nInput\n\n2\n&gt;&lt;\n1 2\n\n\nOutput\n\nFINITE\n\n\nInput\n\n3\n&gt;&gt;&lt;\n2 1 1\n\n\nOutput\n\nINFINITE\n\nNote\n\nIn the first sample grasshopper starts from the first cell and jumps to the right on the next cell. When he is in the second cell he needs to jump two cells left so he will jump out of the strip.\n\nSecond sample grasshopper path is 1 - 3 - 2 - 3 - 2 - 3 and so on. The path is infinite.",
        "task_name": "669_B. Little Artem and Grasshopper",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = input()\nfield = raw_input()\npower = map(int, raw_input().split())\n\npos = 0\nwhile 0 <= pos < n and power[pos] != 0:\n    power[pos], pos = 0, pos + (2 * (field[pos] == '>') - 1) * power[pos]\n\nprint (\"INFINITE\" if 0 <= pos < n else \"FINITE\")\n",
        "correct": true,
        "task_id": "0923",
        "depth": 1
    },
    {
        "description": "Given are an integer X and an integer sequence of length N: p_1, \\ldots, p_N.\n\nAmong the integers not contained in the sequence p_1, \\ldots, p_N (not necessarily positive), find the integer nearest to X, that is, find the integer whose absolute difference with X is the minimum. If there are multiple such integers, report the smallest such integer.\n\nConstraints\n\n* 1 \\leq X \\leq 100\n* 0 \\leq N \\leq 100\n* 1 \\leq p_i \\leq 100\n* p_1, \\ldots, p_N are all distinct.\n* All values in input are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nX N\np_1 ... p_N\n\n\nOutput\n\nPrint the answer.\n\nExamples\n\nInput\n\n6 5\n4 7 10 6 5\n\n\nOutput\n\n8\n\n\nInput\n\n10 5\n4 7 10 6 5\n\n\nOutput\n\n9\n\n\nInput\n\n100 0\n\n\nOutput\n\n100",
        "task_name": "p02641 AtCoder Beginner Contest 170 - Forbidden List",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = 10**20\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\n\ndef resolve():\n    X, N = LI()\n    if N == 0:\n        print(X)\n        return\n\n    p = LI()\n\n    p_max = max(p)\n    p_min = min(p)\n\n    if X < p_min or p_max < X:\n        print(X)\n    else:\n        d = [abs(i-X) for i in range(p_min, p_max+1) if i not in p]\n        d_min = min(d)\n        for i in range(p_min, p_max+1):\n            if i not in p:\n                if abs(i-X)==d_min:\n                    print(i)\n                    break\n\nif __name__ == '__main__':\n    resolve()\n",
        "correct": false,
        "task_id": "0933",
        "depth": 1
    },
    {
        "description": "There are n cards numbered 1, \u2026, n. The card i has a red digit r_i and a blue digit b_i written on it.\n\nWe arrange all n cards in random order from left to right, with all permutations of 1, \u2026, n having the same probability. We then read all red digits on the cards from left to right, and obtain an integer R. In the same way, we read all blue digits and obtain an integer B. When reading a number, leading zeros can be ignored. If all digits in a number are zeros, then the number is equal to 0. Below is an illustration of a possible rearrangement of three cards, and how R and B can be found.\n\n<image>\n\nTwo players, Red and Blue, are involved in a bet. Red bets that after the shuffle R > B, and Blue bets that R < B. If in the end R = B, the bet results in a draw, and neither player wins.\n\nDetermine, which of the two players is more likely (has higher probability) to win the bet, or that their chances are equal. Refer to the Note section for a formal discussion of comparing probabilities.\n\nInput\n\nThe first line contains a single integer T (1 \u2264 T \u2264 100) \u2014 the number of test cases.\n\nDescriptions of T test cases follow. Each test case description starts with a line containing a single integer n (1 \u2264 n \u2264 1000) \u2014 the number of cards.\n\nThe following line contains a string of n digits r_1, \u2026, r_n \u2014 red digits on cards 1, \u2026, n respectively.\n\nThe following line contains a string of n digits b_1, \u2026, b_n \u2014 blue digits on cards 1, \u2026, n respectively.\n\nNote that digits in the same line are not separated with any delimiters.\n\nOutput\n\nPrint T answers for the test cases in order, one per line.\n\nIf Red has a strictly higher change to win, print \"RED\".\n\nIf Blue has a strictly higher change to win, print \"BLUE\".\n\nIf both players are equally likely to win, print \"EQUAL\".\n\nNote that all answers are case-sensitive.\n\nExample\n\nInput\n\n\n3\n3\n777\n111\n3\n314\n159\n5\n09281\n09281\n\n\nOutput\n\n\nRED\nBLUE\nEQUAL\n\nNote\n\nFormally, let n_R be the number of permutations of cards 1, \u2026, n such that the resulting numbers R and B satisfy R > B. Similarly, let n_B be the number of permutations such that R < B. If n_R > n_B, you should print \"RED\". If n_R < n_B, you should print \"BLUE\". If n_R = n_B, print \"EQUAL\".\n\nIn the first sample case, R = 777 and B = 111 regardless of the card order, thus Red always wins.\n\nIn the second sample case, there are two card orders when Red wins, and four card orders when Blue wins:\n\n  * order 1, 2, 3: 314 > 159;\n  * order 1, 3, 2: 341 > 195;\n  * order 2, 1, 3: 134 < 519;\n  * order 2, 3, 1: 143 < 591;\n  * order 3, 1, 2: 431 < 915;\n  * order 3, 2, 1: 413 < 951.\n\n\n\nSince R < B is more frequent, the answer is \"BLUE\".\n\nIn the third sample case, R = B regardless of the card order, thus the bet is always a draw, and both Red and Blue have zero chance to win.",
        "task_name": "1459_A. Red-Blue Shuffle",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\nimport sys, math, bisect, itertools\n\ninput = lambda: sys.stdin.readline().rstrip()\ndef lii(): return list(map(int, input().split()))\ndef mii(): return map(int, input().split())\n\ndef solve():\n    a = int(input())\n    b = input(); c = input()\n    first = 0; second = 0\n    for i in range(a):\n        if (int(b[i]) > int(c[i])):\n            first += 1\n        elif (int(b[i]) < int(c[i])):\n            second += 1\n    if (first > second): \n        print(\"RED\")\n    elif (second > first): \n        print(\"BLUE\")\n    else: \n        print(\"EQUAL\")\n\ndef main():\n    for _ in range(int(input())):\n        solve()\n\nif __name__ == '__main__':\n  main()",
        "correct": true,
        "task_id": "0954",
        "depth": 1
    },
    {
        "description": "Oleg the bank client checks share prices every day. There are n share prices he is interested in. Today he observed that each second exactly one of these prices decreases by k rubles (note that each second exactly one price changes, but at different seconds different prices can change). Prices can become negative. Oleg found this process interesting, and he asked Igor the financial analyst, what is the minimum time needed for all n prices to become equal, or it is impossible at all? Igor is busy right now, so he asked you to help Oleg. Can you answer this question?\n\nInput\n\nThe first line contains two integers n and k (1 \u2264 n \u2264 105, 1 \u2264 k \u2264 109) \u2014 the number of share prices, and the amount of rubles some price decreases each second.\n\nThe second line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 109) \u2014 the initial prices.\n\nOutput\n\nPrint the only line containing the minimum number of seconds needed for prices to become equal, of \u00ab-1\u00bb if it is impossible.\n\nExamples\n\nInput\n\n3 3\n12 9 15\n\n\nOutput\n\n3\n\nInput\n\n2 2\n10 9\n\n\nOutput\n\n-1\n\nInput\n\n4 1\n1 1000000000 1000000000 1000000000\n\n\nOutput\n\n2999999997\n\nNote\n\nConsider the first example. \n\nSuppose the third price decreases in the first second and become equal 12 rubles, then the first price decreases and becomes equal 9 rubles, and in the third second the third price decreases again and becomes equal 9 rubles. In this case all prices become equal 9 rubles in 3 seconds.\n\nThere could be other possibilities, but this minimizes the time needed for all prices to become equal. Thus the answer is 3.\n\nIn the second example we can notice that parity of first and second price is different and never changes within described process. Thus prices never can become equal.\n\nIn the third example following scenario can take place: firstly, the second price drops, then the third price, and then fourth price. It happens 999999999 times, and, since in one second only one price can drop, the whole process takes 999999999 * 3 = 2999999997 seconds. We can note that this is the minimum possible time.",
        "task_name": "793_A. Oleg and shares",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n,k = map(int,raw_input().split())\nall = map(int,raw_input().split())\n\nminn = min(all)\nfail = False\namount = 0\nfor i in all:\n    if (i-minn) % k != 0:\n        fail = True\n    else:\n        amount += (i-minn)/k\nif fail:\n    print(-1)\nelse:\n    print(amount)",
        "correct": true,
        "task_id": "1017",
        "depth": 1
    },
    {
        "description": "There are N cities and M roads. The i-th road (1\u2264i\u2264M) connects two cities a_i and b_i (1\u2264a_i,b_i\u2264N) bidirectionally. There may be more than one road that connects the same pair of two cities. For each city, how many roads are connected to the city?\n\nConstraints\n\n* 2\u2264N,M\u226450\n* 1\u2264a_i,b_i\u2264N\n* a_i \u2260 b_i\n* All input values are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M\na_1 b_1\n:\na_M b_M\n\n\nOutput\n\nPrint the answer in N lines. In the i-th line (1\u2264i\u2264N), print the number of roads connected to city i.\n\nExamples\n\nInput\n\n4 3\n1 2\n2 3\n1 4\n\n\nOutput\n\n2\n2\n1\n1\n\n\nInput\n\n2 5\n1 2\n2 1\n1 2\n2 1\n1 2\n\n\nOutput\n\n5\n5\n\n\nInput\n\n8 8\n1 2\n3 4\n1 5\n2 8\n3 7\n5 2\n4 1\n6 8\n\n\nOutput\n\n3\n3\n2\n2\n2\n1\n1\n2",
        "task_name": "p03720 AtCoder Beginner Contest 061 - Counting Roads",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, m = map(int, raw_input().split())\ncount = [0] * n\nfor i in xrange(m):\n    a, b = map(int, raw_input().split())\n    count[a - 1] += 1\n    count[b - 1] += 1\nfor i in xrange(n):\n    print(count[i])\n",
        "correct": true,
        "task_id": "1027",
        "depth": 1
    },
    {
        "description": "You are given two integers x and y. You can perform two types of operations: \n\n  1. Pay a dollars and increase or decrease any of these integers by 1. For example, if x = 0 and y = 7 there are four possible outcomes after this operation: \n    * x = 0, y = 6; \n    * x = 0, y = 8; \n    * x = -1, y = 7; \n    * x = 1, y = 7. \n\n  2. Pay b dollars and increase or decrease both integers by 1. For example, if x = 0 and y = 7 there are two possible outcomes after this operation: \n    * x = -1, y = 6; \n    * x = 1, y = 8. \n\n\n\nYour goal is to make both given integers equal zero simultaneously, i.e. x = y = 0. There are no other requirements. In particular, it is possible to move from x=1, y=0 to x=y=0.\n\nCalculate the minimum amount of dollars you have to spend on it.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of testcases.\n\nThe first line of each test case contains two integers x and y (0 \u2264 x, y \u2264 10^9).\n\nThe second line of each test case contains two integers a and b (1 \u2264 a, b \u2264 10^9).\n\nOutput\n\nFor each test case print one integer \u2014 the minimum amount of dollars you have to spend.\n\nExample\n\nInput\n\n\n2\n1 3\n391 555\n0 0\n9 4\n\n\nOutput\n\n\n1337\n0\n\nNote\n\nIn the first test case you can perform the following sequence of operations: first, second, first. This way you spend 391 + 555 + 391 = 1337 dollars.\n\nIn the second test case both integers are equal to zero initially, so you dont' have to spend money.",
        "task_name": "1342_A. Road To Zero",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\nfrom collections import defaultdict, Counter, deque\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement\nfrom __builtin__ import xrange as range\nfrom math import ceil, factorial\nfrom _continuation import continulet\nfrom cStringIO import StringIO\nfrom io import IOBase\nimport __pypy__\nfrom bisect import bisect, insort, bisect_left, bisect_right\nfrom fractions import Fraction\nfrom functools import reduce\nimport string\nimport sys\nimport os\nimport re\ninf = float('inf')\nmod_ = int(1e9) + 7\nmod = 998244353\n\ndef factors(n):\n    from functools import reduce\n    return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\ndef sieve():\n    n,m=1,10**6\n    primes = {}\n    arr=set([])\n    for i in range(2, round(m ** 0.5) + 1):\n        a = n // i\n        b = m // i\n        for k in range(max(2, a), b + 1):\n            c = i * k\n            primes[c] = 1\n\n    for i in range(max(n, 2), m + 1):\n        if i not in primes:\n            arr.add(i)\n\n    return arr\n\ndef nc2(x):\n    return (x*(x-1))//2\ndef main():    \n    # n=int(input())\n    # arr=list()\n    for _ in range(int(input())):\n        x,y=map(int,input().split())\n        a,b=map(int,input().split())\n        cst1=max(a*(x-1)+a*(y-1)+b,0)\n        cst2=max(0,a*abs(y-x)+b*min(x,y))\n        print(min(cst2,cst1))\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": "1037",
        "depth": 2
    },
    {
        "description": "One day, little Vasya found himself in a maze consisting of (n + 1) rooms, numbered from 1 to (n + 1). Initially, Vasya is at the first room and to get out of the maze, he needs to get to the (n + 1)-th one.\n\nThe maze is organized as follows. Each room of the maze has two one-way portals. Let's consider room number i (1 \u2264 i \u2264 n), someone can use the first portal to move from it to room number (i + 1), also someone can use the second portal to move from it to room number pi, where 1 \u2264 pi \u2264 i.\n\nIn order not to get lost, Vasya decided to act as follows. \n\n  * Each time Vasya enters some room, he paints a cross on its ceiling. Initially, Vasya paints a cross at the ceiling of room 1. \n  * Let's assume that Vasya is in room i and has already painted a cross on its ceiling. Then, if the ceiling now contains an odd number of crosses, Vasya uses the second portal (it leads to room pi), otherwise Vasya uses the first portal. \n\n\n\nHelp Vasya determine the number of times he needs to use portals to get to room (n + 1) in the end.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 103) \u2014 the number of rooms. The second line contains n integers pi (1 \u2264 pi \u2264 i). Each pi denotes the number of the room, that someone can reach, if he will use the second portal in the i-th room.\n\nOutput\n\nPrint a single number \u2014 the number of portal moves the boy needs to go out of the maze. As the number can be rather large, print it modulo 1000000007 (109 + 7).\n\nExamples\n\nInput\n\n2\n1 2\n\n\nOutput\n\n4\n\n\nInput\n\n4\n1 1 2 3\n\n\nOutput\n\n20\n\n\nInput\n\n5\n1 1 1 1 1\n\n\nOutput\n\n62",
        "task_name": "408_D. Long Path",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n# coding: utf-8\n\n# # B. Long Path\n# \n# - time limit per test: 1 second\n# - memory limit per test: 256 megabytes\n# - input: standard input\n# - output: standard output\n# \n# One day, little Vasya found himself in a maze consisting of (n\u2009+\u20091) rooms, numbered from 1 to (n\u2009+\u20091). Initially, Vasya is at the first room and to get out of the maze, he needs to get to the (n\u2009+\u20091)-th one.\n# \n# The maze is organized as follows. Each room of the maze has two one-way portals. Let's consider room number i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), someone can use the first portal to move from it to room number (i\u2009+\u20091), also someone can use the second portal to move from it to room number pi, where 1\u2009\u2264\u2009pi\u2009\u2264\u2009i.\n# \n# In order not to get lost, Vasya decided to act as follows.\n# \n# - Each time Vasya enters some room, he paints a cross on its ceiling. Initially, Vasya paints a cross at the ceiling of room 1.\n# \n# - Let's assume that Vasya is in room i and has already painted a cross on its ceiling. Then, if the ceiling now contains an odd number of crosses, Vasya uses the second portal (it leads to room pi), otherwise Vasya uses the first portal. \n# \n# Help Vasya determine the number of times he needs to use portals to get to room (n\u2009+\u20091) in the end.\n# \n# #### Input\n# \n# The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the number of rooms. The second line contains n integers pi (1\u2009\u2264\u2009pi\u2009\u2264\u2009i). Each pi denotes the number of the room, that someone can reach, if he will use the second portal in the i-th room.\n# \n# #### Output\n# \n# Print a single number \u2014 the number of portal moves the boy needs to go out of the maze. As the number can be rather large, print it modulo 1000000007 (109\u2009+\u20097).\n# \n# #### Examples\n# \n# Input\n# ```\n# 2\n# 1 2\n# ```\n# \n# Output\n# ```\n# 4\n# ```\n# \n# Input\n# ```\n# 4\n# 1 1 2 3\n# ```\n# \n# Output\n# ```\n# 20\n# ```\n# \n# Input\n# ```\n# 5\n# 1 1 1 1 1\n# ```\n# \n# Output\n# ```\n# 62\n# ```\n\n# ### Standard Input Generator\n\n# In[66]:\n\nimport sys\n\n\ndef example_generator(line):\n    \"\"\"Read example from stdin and parse it into the appropriate data structure\n    \n    Use in the following way:\n    \n    example = example_generator(stdin_generator)\n    while True:\n        numbers, target = next(example)\n        .\n        .\n        .\n    \n    \"\"\"\n    while True:\n        n = int(next(line).strip())\n        P = [int(p_i)-1 for p_i in next(line).split()] # convert to zero-indexing\n        \n        yield n, P\n\n\n# ### Workhorse Functions\n\n# In[68]:\n\ndef do_maze(n, p):\n    \"\"\"Print out the number of times Vasya needs to use portals to get to room n+1\n    \n    dp[i] is the number of portal jumps required to start off at room i with an odd\n    number of crosses and get back to room i with an even number of crosses.\n    \n    Hence the recurrence relation is as follows:\n    \n    dp[i] = 1 + [Sum_{j = p(i)}^{i-1} dp[j] + 1]\n    \n    This can be read as \"the number of portal jumps to get from room i with an odd\n    number of crosses to an even number of crosses is equivalent to taking a portal\n    jump to room p(i) into an odd number of crosees (+1), getting back into that\n    state with an even number of crosses (Sum part).\n    \n    \"\"\"\n    dp = [0]*n\n    \n    for i in range(n):\n        \n        portal_jumps = 1 # initial jump from from i to p[i]\n        \n        # This block would read cleaner if it was just a for loop!\n        for j in range(p[i], i):\n            portal_jumps += dp[j] % (1e9+7) # jumps to get you from room j with odd to room j with even\n            portal_jumps += 1 % (1e9+7) # extra jump to get you from j to j+1\n            \n        dp[i] = int(portal_jumps % (1e9+7))\n        \n    total_pjumps = 0    \n    for i in range(n):\n        total_pjumps += dp[i] % (1e9+7)\n        total_pjumps += 1 % (1e9+7)\n        \n    print(total_pjumps)\n\n\nexample = example_generator(sys.stdin)\n\nif __name__ == '__main__':\n    n, P = next(example)\n\n    do_maze(n, P)\n",
        "correct": false,
        "task_id": "1046",
        "depth": 2
    },
    {
        "description": "\n\nInput\n\nThe input contains a single integer a (10 \u2264 a \u2264 999).\n\nOutput\n\nOutput 0 or 1.\n\nExamples\n\nInput\n\n13\n\n\nOutput\n\n1\n\n\nInput\n\n927\n\n\nOutput\n\n1\n\n\nInput\n\n48\n\n\nOutput\n\n0",
        "task_name": "952_A. Quirky Quantifiers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n\n# target Expert  \n\n# Author : raj1307 - Raj Singh\n# Date   : 17.10.19\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \nfrom collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\n\n\n\ndef main():\n    \n\n\n    #for _ in range(ii()):\n\n\n    n=ii()\n    print(n%2)\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": true,
        "task_id": "1052",
        "depth": 1
    },
    {
        "description": "You are given a text of single-space separated words, consisting of small and capital Latin letters.\n\nVolume of the word is number of capital letters in the word. Volume of the text is maximum volume of all words in the text.\n\nCalculate the volume of the given text.\n\nInput\n\nThe first line contains one integer number n (1 \u2264 n \u2264 200) \u2014 length of the text.\n\nThe second line contains text of single-space separated words s1, s2, ..., si, consisting only of small and capital Latin letters.\n\nOutput\n\nPrint one integer number \u2014 volume of text.\n\nExamples\n\nInput\n\n7\nNonZERO\n\n\nOutput\n\n5\n\n\nInput\n\n24\nthis is zero answer text\n\n\nOutput\n\n0\n\n\nInput\n\n24\nHarbour Space University\n\n\nOutput\n\n1\n\nNote\n\nIn the first example there is only one word, there are 5 capital letters in it.\n\nIn the second example all of the words contain 0 capital letters.",
        "task_name": "837_A. Text Volume",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "raw_input()\nl=raw_input().split()\nm=0\nfor i in l :\n    s=0\n    for j in i:\n        if j.isupper() :\n              s+=1\n    m=max(s,m)\n        \nprint(m)\n        \n",
        "correct": true,
        "task_id": "1092",
        "depth": 2
    },
    {
        "description": "You are given a sequence of n digits d_1d_2 ... d_{n}. You need to paint all the digits in two colors so that:\n\n  * each digit is painted either in the color 1 or in the color 2; \n  * if you write in a row from left to right all the digits painted in the color 1, and then after them all the digits painted in the color 2, then the resulting sequence of n digits will be non-decreasing (that is, each next digit will be greater than or equal to the previous digit). \n\n\n\nFor example, for the sequence d=914 the only valid coloring is 211 (paint in the color 1 two last digits, paint in the color 2 the first digit). But 122 is not a valid coloring (9 concatenated with 14 is not a non-decreasing sequence).\n\nIt is allowed that either of the two colors is not used at all. Digits painted in the same color are not required to have consecutive positions.\n\nFind any of the valid ways to paint the given sequence of digits or determine that it is impossible to do.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the input.\n\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 the length of a given sequence of digits.\n\nThe next line contains a sequence of n digits d_1d_2 ... d_{n} (0 \u2264 d_i \u2264 9). The digits are written in a row without spaces or any other separators. The sequence can start with 0.\n\nIt is guaranteed that the sum of the values \u200b\u200bof n for all test cases in the input does not exceed 2\u22c510^5.\n\nOutput\n\nPrint t lines \u2014 the answers to each of the test cases in the input.\n\nIf there is a solution for a test case, the corresponding output line should contain any of the valid colorings written as a string of n digits t_1t_2 ... t_n (1 \u2264 t_i \u2264 2), where t_i is the color the i-th digit is painted in. If there are several feasible solutions, print any of them.\n\nIf there is no solution, then the corresponding output line should contain a single character '-' (the minus sign).\n\nExample\n\nInput\n\n\n5\n12\n040425524644\n1\n0\n9\n123456789\n2\n98\n3\n987\n\n\nOutput\n\n\n121212211211\n1\n222222222\n21\n-\n\nNote\n\nIn the first test case, d=040425524644. The output t=121212211211 is correct because 0022444 (painted in 1) concatenated with 44556 (painted in 2) is 002244444556 which is a sorted sequence of n given digits.",
        "task_name": "1209_C. Paint the Digits",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import print_function # for PyPy2\nfrom collections import Counter, OrderedDict\nfrom itertools import permutations as perm\nfrom collections import deque\nfrom sys import stdin\nfrom bisect import *\nfrom heapq import *\nimport math\n \ng   = lambda : stdin.readline().strip()\ngl  = lambda : g().split()\ngil = lambda : [int(var) for var in gl()]\ngfl = lambda : [float(var) for var in gl()]\ngcl = lambda : list(g())\ngbs = lambda : [int(var) for var in g()]\nmod = int(1e9)+7\ninf = float(\"inf\")\n\nt, = gil()\n\nfor _ in range(t):\n\t# print()\n\tn, = gil()\n\tval = gbs()\n\tidx = list(xrange(n))\n\tidx.sort(key=lambda x : [val[x], x])\n\t# print(idx) \n\tone = []\n\tto = []\n\n\tfor ix in idx:\n\t\tif ix > (one[-1] if one else -1) and val[ix] <= (val[to[0]] if to else inf):\n\t\t\tone.append(ix)\n\t\telif ix > (to[-1] if to else -1):\n\t\t\tto.append(ix)\n\t\telse:\n\t\t\tbreak\n\n\tif len(one) + len(to) == n:\n\t\t# print(one, to)\n\t\tfor ix in one:\n\t\t\tval[ix] = 1\n\t\tfor ix in to:\n\t\t\tval[ix] = 2\n\t\tfor v in val:\n\t\t\tprint(v, end=\"\")\n\t\tprint()\n\telse:\n\t\t# print(one, to)\n\t\tprint(\"-\")",
        "correct": true,
        "task_id": "1110",
        "depth": 2
    },
    {
        "description": "Yura has been walking for some time already and is planning to return home. He needs to get home as fast as possible. To do this, Yura can use the instant-movement locations around the city.\n\nLet's represent the city as an area of n \u00d7 n square blocks. Yura needs to move from the block with coordinates (s_x,s_y) to the block with coordinates (f_x,f_y). In one minute Yura can move to any neighboring by side block; in other words, he can move in four directions. Also, there are m instant-movement locations in the city. Their coordinates are known to you and Yura. Yura can move to an instant-movement location in no time if he is located in a block with the same coordinate x or with the same coordinate y as the location.\n\nHelp Yura to find the smallest time needed to get home.\n\nInput\n\nThe first line contains two integers n and m \u2014 the size of the city and the number of instant-movement locations (1 \u2264 n \u2264 10^9, 0 \u2264 m \u2264 10^5).\n\nThe next line contains four integers s_x s_y f_x f_y \u2014 the coordinates of Yura's initial position and the coordinates of his home ( 1 \u2264 s_x, s_y, f_x, f_y \u2264 n).\n\nEach of the next m lines contains two integers x_i y_i \u2014 coordinates of the i-th instant-movement location (1 \u2264 x_i, y_i \u2264 n).\n\nOutput\n\nIn the only line print the minimum time required to get home.\n\nExamples\n\nInput\n\n\n5 3\n1 1 5 5\n1 2\n4 1\n3 3\n\n\nOutput\n\n\n5\n\n\nInput\n\n\n84 5\n67 59 41 2\n39 56\n7 2\n15 3\n74 18\n22 7\n\n\nOutput\n\n\n42\n\nNote\n\nIn the first example Yura needs to reach (5, 5) from (1, 1). He can do that in 5 minutes by first using the second instant-movement location (because its y coordinate is equal to Yura's y coordinate), and then walking (4, 1) \u2192 (4, 2) \u2192 (4, 3) \u2192 (5, 3) \u2192 (5, 4) \u2192 (5, 5).",
        "task_name": "1422_D. Returning Home",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\nimport bisect\nimport math\nimport heapq\nimport itertools\nimport sys\nfrom collections import deque\nfrom atexit import register\nfrom collections import Counter\nfrom functools import reduce\nif sys.version_info[0] < 3:\n    from io import BytesIO as stream\nelse:\n    from io import StringIO as stream\n \n \nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n \n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n \n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n \n    input = raw_input\n    range = xrange\n \n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n \n \ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n \n    Args:\n        sync (bool, optional): The new synchronization setting.\n \n    \"\"\"\n    global input, flush\n \n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\ndef main():\n    # sys.stdin  = open(\"input.txt\")\n    def dijkstra(n, s, edges):\n        hq = [(0, s)]\n        cost = [float('inf')] * n\n        cost[s] = 0\n        while hq:\n            c, v = heapq.heappop(hq)\n            if c > cost[v]:\n                continue\n            for d, u in edges[v]:\n                tmp = d + cost[v]\n                if tmp < cost[u]:\n                    cost[u] = tmp\n                    heapq.heappush(hq, (tmp, u))\n        return cost[-1]\n\n    n,m=map(int,input().split())\n    sx, sy, fx, fy = map(int, input().split())\n    xy=[None]*m\n    for i in range(m):\n        xy[i]=list(map(int,input().split()))\n        xy[i].append((i+1))\n    adj=[[] for i in range(m+2)]\n    xy.sort()\n    for i in range(m-1):\n        dist=min(abs(xy[i][0]-xy[i+1][0]),abs(xy[i][1]-xy[i+1][1]))\n        adj[xy[i][2]].append([dist,xy[i+1][2]])\n        adj[xy[i+1][2]].append([dist,xy[i][2]])\n    xy.sort(key= lambda x:x[1])\n    for i in range(m-1):\n        dist=min(abs(xy[i][0]-xy[i+1][0]),abs(xy[i][1]-xy[i+1][1]))\n        adj[xy[i][2]].append([dist,xy[i+1][2]])\n        adj[xy[i+1][2]].append([dist,xy[i][2]])\n    for x,y,i in xy:\n        d1= min(abs(x-sx),abs(y-sy))\n        d2=abs(x-sx)+abs(y-sy)\n        adj[0].append([d1,i])\n        adj[i].append([d2,0])\n        d1= min(abs(x-fx),abs(y-fy))\n        d2=abs(x-fx)+abs(y-fy)\n        adj[m+1].append([d1,i])\n        adj[i].append([d2,m+1])\n    d=abs(sx-fx)+abs(sy-fy)\n    adj[0].append([d,m+1])\n    adj[m+1].append([d,0])\n    print(dijkstra(m + 2, 0, adj))\n    \nif __name__ == '__main__':\n    sync_with_stdio(False)\n    main()",
        "correct": true,
        "task_id": "1116",
        "depth": 2
    },
    {
        "description": "There are n cells, numbered 1,2,..., n from left to right. You have to place a robot at any cell initially. The robot must make exactly k moves.\n\nIn one move, the robot must move one cell to the left or right, provided that it doesn't move out of bounds. In other words, if the robot was in the cell i, it must move to either the cell i-1 or the cell i+1, as long as it lies between 1 and n (endpoints inclusive). The cells, in the order they are visited (including the cell the robot is placed), together make a good path.\n\nEach cell i has a value a_i associated with it. Let c_0, c_1, ..., c_k be the sequence of cells in a good path in the order they are visited (c_0 is the cell robot is initially placed, c_1 is the cell where the robot is after its first move, and so on; more formally, c_i is the cell that the robot is at after i moves). Then the value of the path is calculated as a_{c_0} + a_{c_1} + ... + a_{c_k}.\n\nYour task is to calculate the sum of values over all possible good paths. Since this number can be very large, output it modulo 10^9 + 7. Two good paths are considered different if the starting cell differs or there exists an integer i \u2208 [1, k] such that the current cell of the robot after exactly i moves is different in those paths.\n\nYou must process q updates to a and print the updated sum each time. Each update changes the value of exactly one cell. See the input format and the sample input-output for more details.\n\nInput\n\nThe first line of the input contains three space-separated integers n, k and q (2 \u2264 n \u2264 5000; 1 \u2264 k \u2264 5000; 1 \u2264 q \u2264 2 \u22c5 10^5).\n\nThe second line of the input contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nq lines follow. Each line contains two space-separated integers i and x (1 \u2264 i \u2264 n; 1 \u2264 x \u2264 10^9) indicating that you must change the value of a_i to x.\n\nOutput\n\nPrint q integers. The i-th integer should be the sum of values over all good paths after the first i updates are performed. Since the answers may be large, print them modulo 10^9 + 7.\n\nExamples\n\nInput\n\n\n5 1 5\n3 5 1 4 2\n1 9\n2 4\n3 6\n4 6\n5 2\n\n\nOutput\n\n\n62\n58\n78\n86\n86\n\n\nInput\n\n\n5 2 5\n3 5 1 4 2\n1 9\n2 4\n3 6\n4 6\n5 2\n\n\nOutput\n\n\n157\n147\n207\n227\n227\n\n\nInput\n\n\n4 40 6\n92 21 82 46\n3 56\n1 72\n4 28\n1 97\n2 49\n2 88\n\n\nOutput\n\n\n239185261\n666314041\n50729936\n516818968\n766409450\n756910476\n\nNote\n\nIn the first example, the good paths are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), (4, 3), (4, 5), (5, 4).\n\nInitially the values of a are [3, 5, 1, 4, 2]. After the first update, they become [9, 5, 1, 4, 2]. After the second update, they become [9, 4, 1, 4, 2], and so on.",
        "task_name": "1467_D. Sum of Paths",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    pass\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict\n\nmod=10**9+7\nn,k,q=map(int,input().split())\na=list(map(int,input().split()))\ncnt=defaultdict(lambda: 0)\ndp=[[0 for j in range(k+1)] for i in range(n+2)]\nfor i in range(1,n+1):\n    dp[i][0]=1\nfor j in range(1,k+1):\n    for i in range(1,n+1):\n        dp[i][j]=(dp[i-1][j-1]+dp[i+1][j-1])%mod\nfor i in range(1,n+1):\n    for j in range(k+1):\n        cnt[i]+=dp[i][j]*dp[i][k-j]%mod\nans=0\nfor i in range(n):\n    ans+=cnt[i+1]*a[i]%mod\nfor _ in range(q):\n    i,x=map(int,input().split())\n    ans=(ans+(x-a[i-1])*cnt[i])%mod\n    a[i-1]=x\n    print(ans%mod)",
        "correct": true,
        "task_id": "1118",
        "depth": 2
    },
    {
        "description": "Taro has decided to move. Taro has a lot of luggage, so I decided to ask a moving company to carry the luggage. Since there are various weights of luggage, I asked them to arrange them in order from the lightest one for easy understanding, but the mover left the luggage in a different order. So Taro tried to sort the luggage, but the luggage is heavy and requires physical strength to carry. Each piece of luggage can be carried from where it is now to any place you like, such as between other pieces of luggage or at the edge of the piece of luggage, but carrying one piece of luggage uses as much physical strength as the weight of that piece of luggage. Taro doesn't have much physical strength, so I decided to think of a way to arrange the luggage in order from the lightest one without using as much physical strength as possible.\n\nConstraints\n\n> 1 \u2264 n \u2264 105\n> 1 \u2264 xi \u2264 n (1 \u2264 i \u2264 n)\n> xi \u2260 xj (1 \u2264 i, j \u2264 n and i \u2260 j)\n>\n\n* All inputs are given as integers\n\nInput\n\n> n\n> x1 x2 ... xn\n>\n\n* n represents the number of luggage that Taro has\n* x1 to xn represent the weight of each piece of luggage, and are currently arranged in the order of x1, x2, ..., xn.\n\nOutput\n\n> S\n>\n\n* Output the total S of the minimum physical strength required to arrange the luggage in order from the lightest, but output the line break at the end\n\nExamples\n\nInput\n\n4\n1 4 2 3\n\n\nOutput\n\n4\n\n\nInput\n\n5\n1 5 3 2 4\n\n\nOutput\n\n7\n\n\nInput\n\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n0\n\n\nInput\n\n8\n6 2 1 3 8 5 4 7\n\n\nOutput\n\n19",
        "task_name": "p01545 House Moving",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import math\nimport sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass FenwickTree:\n    def __init__(self, a_list, f, default):\n        # 0-indexed\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << (math.ceil(math.log(self.N, 2)))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | (i + 1)] = self.f(self.bit[i | (i + 1)], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        # [0, n]\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & (n + 1)) - 1\n        return ret\n\n\nN = int(input())\nX = [int(x) for x in input().split()]\ndp = FenwickTree([0] * N, lambda x, y: max(x, y), 0)\nfor x, i in sorted((x, i) for i, x in enumerate(X)):\n    dp.update(i, dp.query(i) + x)\nprint(N * (N + 1) // 2 - dp.query(N - 1))",
        "correct": false,
        "task_id": "1149",
        "depth": 1
    },
    {
        "description": "Monocarp has got two strings s and t having equal length. Both strings consist of lowercase Latin letters \"a\" and \"b\". \n\nMonocarp wants to make these two strings s and t equal to each other. He can do the following operation any number of times: choose an index pos_1 in the string s, choose an index pos_2 in the string t, and swap s_{pos_1} with t_{pos_2}.\n\nYou have to determine the minimum number of operations Monocarp has to perform to make s and t equal, and print any optimal sequence of operations \u2014 or say that it is impossible to make these strings equal.\n\nInput\n\nThe first line contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^{5}) \u2014 the length of s and t.\n\nThe second line contains one string s consisting of n characters \"a\" and \"b\". \n\nThe third line contains one string t consisting of n characters \"a\" and \"b\". \n\nOutput\n\nIf it is impossible to make these strings equal, print -1.\n\nOtherwise, in the first line print k \u2014 the minimum number of operations required to make the strings equal. In each of the next k lines print two integers \u2014 the index in the string s and the index in the string t that should be used in the corresponding swap operation. \n\nExamples\n\nInput\n\n\n4\nabab\naabb\n\n\nOutput\n\n\n2\n3 3\n3 2\n\n\nInput\n\n\n1\na\nb\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n8\nbabbaabb\nabababaa\n\n\nOutput\n\n\n3\n2 6\n1 3\n7 8\n\nNote\n\nIn the first example two operations are enough. For example, you can swap the third letter in s with the third letter in t. Then s =  \"abbb\", t =  \"aaab\". Then swap the third letter in s and the second letter in t. Then both s and t are equal to \"abab\".\n\nIn the second example it's impossible to make two strings equal.",
        "task_name": "1215_C. Swap Letters",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n\n# target Expert  \n\n# Author : raj1307 - Raj Singh\n# Date   : 15.09.19\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial,pi\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\n \n \ndef main():\n \n    \n \n    #for _ in range(ii()):\n        \n    \n\n\n    n=ii()\n    s=si()\n    t=si()\n\n    s=list(s)\n    t=list(t)\n\n\n    a=0\n    b=0\n\n    for i in range(n):\n        if s[i]=='a':\n            a+=1\n        else:\n            b+=1\n\n        if t[i]=='a':\n            a+=1\n        else:\n            b+=1\n\n\n\n    if a%2==1 or b%2==1:\n        print(-1)\n        exit()\n\n\n    a=[]\n\n    b=[]\n    for i in range(n):\n\n        if s[i]!=t[i]:\n\n            if s[i]=='a':\n\n                a.append(i)\n\n            else:\n\n                b.append(i)\n\n\n    ans=[]\n    \n\n\n    if len(a)%2==0:\n        nn=len(a)\n    else:\n        nn=len(a)-1\n        ans.append([a[-1]+1,a[-1]+1])\n        s[a[-1]],t[a[-1]]=t[a[-1]],s[a[-1]]\n\n    \n    for i in range(0,nn,2):\n\n        ans.append([a[i]+1,a[i+1]+1])\n        s[a[i]],t[a[i+1]]=t[a[i+1]],s[a[i]]\n\n        #print([a[i]+1,a[i+1]+1])\n\n    b=[]\n    for i in range(n):\n\n        if s[i]!=t[i]:\n\n            if s[i]=='a':\n\n                a.append(i)\n\n            else:\n\n                b.append(i)\n\n\n    for i in range(0,len(b),2):\n        ans.append([b[i]+1,b[i+1]+1])\n\n\n \n    print(len(a))\n    for i in ans:\n        print(*i)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": false,
        "task_id": "1158",
        "depth": 1
    },
    {
        "description": "Shaass has n books. He wants to make a bookshelf for all his books. He wants the bookshelf's dimensions to be as small as possible. The thickness of the i-th book is ti and its pages' width is equal to wi. The thickness of each book is either 1 or 2. All books have the same page heights.\n\n<image>\n\nShaass puts the books on the bookshelf in the following way. First he selects some of the books and put them vertically. Then he puts the rest of the books horizontally above the vertical books. The sum of the widths of the horizontal books must be no more than the total thickness of the vertical books. A sample arrangement of the books is depicted in the figure.\n\n<image>\n\nHelp Shaass to find the minimum total thickness of the vertical books that we can achieve.\n\nInput\n\nThe first line of the input contains an integer n, (1 \u2264 n \u2264 100). Each of the next n lines contains two integers ti and wi denoting the thickness and width of the i-th book correspondingly, (1 \u2264 ti \u2264 2, 1 \u2264 wi \u2264 100).\n\nOutput\n\nOn the only line of the output print the minimum total thickness of the vertical books that we can achieve.\n\nExamples\n\nInput\n\n5\n1 12\n1 3\n2 15\n2 5\n2 1\n\n\nOutput\n\n5\n\n\nInput\n\n3\n1 10\n2 1\n2 4\n\n\nOutput\n\n3",
        "task_name": "294_B. Shaass and Bookshelf",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\n\nmyBooks = []\nW = 0\n\nfor i in range(0,n):\n    t, w = map(int, raw_input().split())\n    W += w\n    myBooks.append([w, t])\n    \nmyBooks.sort()\nmyBooks.reverse()\n\nT = 0\nfor book in myBooks:\n    T += book[1]\n    W -= book[0]\n    if(W<=T):\n        break\n    \nprint(T)\n",
        "correct": false,
        "task_id": "1170",
        "depth": 1
    }
]