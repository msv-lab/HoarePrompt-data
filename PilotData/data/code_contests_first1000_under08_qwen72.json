[
    {
        "description": "Note that this is the first problem of the two similar problems. You can hack this problem only if you solve both problems.\n\nYou are given a tree with n nodes. In the beginning, 0 is written on all edges. In one operation, you can choose any 2 distinct leaves u, v and any real number x and add x to values written on all edges on the simple path between u and v.\n\nFor example, on the picture below you can see the result of applying two operations to the graph: adding 2 on the path from 7 to 6, and then adding -0.5 on the path from 4 to 5. \n\n<image>\n\nIs it true that for any configuration of real numbers written on edges, we can achieve it with a finite number of operations?\n\nLeaf is a node of a tree of degree 1. Simple path is a path that doesn't contain any node twice.\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5) \u2014 the number of nodes.\n\nEach of the next n-1 lines contains two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v), meaning that there is an edge between nodes u and v. It is guaranteed that these edges form a tree.\n\nOutput\n\nIf there is a configuration of real numbers written on edges of the tree that we can't achieve by performing the operations, output \"NO\". \n\nOtherwise, output \"YES\". \n\nYou can print each letter in any case (upper or lower).\n\nExamples\n\nInput\n\n\n2\n1 2\n\n\nOutput\n\n\nYES\n\nInput\n\n\n3\n1 2\n2 3\n\n\nOutput\n\n\nNO\n\nInput\n\n\n5\n1 2\n1 3\n1 4\n2 5\n\n\nOutput\n\n\nNO\n\nInput\n\n\n6\n1 2\n1 3\n1 4\n2 5\n2 6\n\n\nOutput\n\n\nYES\n\nNote\n\nIn the first example, we can add any real x to the value written on the only edge (1, 2).\n\n<image>\n\nIn the second example, one of configurations that we can't reach is 0 written on (1, 2) and 1 written on (2, 3).\n\n<image>\n\nBelow you can see graphs from examples 3, 4:\n\n<image> <image>",
        "task_name": "1189_D1. Add on a Tree",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division\nfrom sys import stdin, stdout\n# from fractions import gcd\n# from math import *\n# from operator import mul\n# from functools import reduce\n# from copy import copy\nfrom collections import deque, defaultdict, Counter\n\nrstr = lambda: stdin.readline().strip()\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\nrint = lambda: int(stdin.readline())\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrstr_2d = lambda n: [rstr() for _ in range(n)]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\nout = []\n\n\nclass graph:\n    # initialize graph\n    def __init__(self, gdict=None):\n        if gdict is None:\n            gdict = defaultdict(list)\n        self.gdict, self.edges, self.l = gdict, defaultdict(int), defaultdict(int)\n\n    # add edge\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.gdict[node2].append(node1)\n        self.l[node1] += 1\n        self.l[node2] += 1\n\n\nn = int(input())\ng = graph()\nfor _ in range(n - 1):\n    u, v = rints()\n    g.addEdge(u, v)\n\nfor i in range(1, n + 1):\n    if g.l[i] != 1 and g.l[i] < 3:\n        print('NO')\n        exit()\n\nprint('YES')\n",
        "correct": true,
        "task_id": "0003",
        "depth": 1
    },
    {
        "description": "An array of integers p_{1},p_{2}, \u2026,p_{n} is called a permutation if it contains each number from 1 to n exactly once. For example, the following arrays are permutations: [3,1,2], [1], [1,2,3,4,5] and [4,3,1,2]. The following arrays are not permutations: [2], [1,1], [2,3,4].\n\nThere is a hidden permutation of length n.\n\nFor each index i, you are given s_{i}, which equals to the sum of all p_{j} such that j < i and p_{j} < p_{i}. In other words, s_i is the sum of elements before the i-th element that are smaller than the i-th element.\n\nYour task is to restore the permutation.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^{5}) \u2014 the size of the permutation.\n\nThe second line contains n integers s_{1}, s_{2}, \u2026, s_{n} (0 \u2264 s_{i} \u2264 (n(n-1))/(2)).\n\nIt is guaranteed that the array s corresponds to a valid permutation of length n.\n\nOutput\n\nPrint n integers p_{1}, p_{2}, \u2026, p_{n} \u2014 the elements of the restored permutation. We can show that the answer is always unique.\n\nExamples\n\nInput\n\n\n3\n0 0 0\n\n\nOutput\n\n\n3 2 1\n\n\nInput\n\n\n2\n0 1\n\n\nOutput\n\n\n1 2\n\n\nInput\n\n\n5\n0 1 1 1 10\n\n\nOutput\n\n\n1 4 3 2 5\n\nNote\n\nIn the first example for each i there is no index j satisfying both conditions, hence s_i are always 0.\n\nIn the second example for i = 2 it happens that j = 1 satisfies the conditions, so s_2 = p_1.\n\nIn the third example for i = 2, 3, 4 only j = 1 satisfies the conditions, so s_2 = s_3 = s_4 = 1. For i = 5 all j = 1, 2, 3, 4 are possible, so s_5 = p_1 + p_2 + p_3 + p_4 = 10.",
        "task_name": "1208_D. Restore Permutation",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nfrom collections import Counter, defaultdict\nfrom itertools import permutations, combinations\nraw_input = stdin.readline\npr = stdout.write\nmod=10**9+7\n\ndef ni():\n    return int(raw_input())\n\n\ndef li():\n    return map(int,raw_input().split())\n\n\ndef pn(n):\n    stdout.write(str(n)+'\\n')\n\n\ndef pa(arr):\n    pr(' '.join(map(str,arr))+'\\n')\n\n# fast read function for total integer input\n\ndef inp():\n    # this function returns whole input of\n    # space/line seperated integers\n    # Use Ctrl+D to flush stdin.\n    return map(int,stdin.read().split())\n\nrange = xrange # not for python 3.0+\n\n#main code\n\nn=ni()\nBITTree=[0]*(n+1)\ndef gs(i): \n    s = 0\n    i = i+1\n    while i > 0:  \n        s += BITTree[i] \n        i -= i & (-i) \n    return s \ndef ub(i ,v): \n    i += 1\n    while i <= n: \n        BITTree[i] += v \n        i += i & (-i) \ndef fun(x):\n    ret=0\n    sm=0\n    for i in range(21,-1,-1):\n        pw=1<<i\n        if ret+pw<=n and sm+BITTree[ret+pw]<=x:\n            ret+=pw\n            sm+=BITTree[ret]\n    return ret\nl=li()\nfor i in range(n):\n    ub(i,i)\nans=[0]*n\nfor i in range(n-1,-1,-1):\n    ans[i]=fun(l[i])\n    ub(ans[i],-ans[i])\npa(ans)\n\n    \n",
        "correct": true,
        "task_id": "0004",
        "depth": 1
    },
    {
        "description": "There are n points on a coordinate axis OX. The i-th point is located at the integer point x_i and has a speed v_i. It is guaranteed that no two points occupy the same coordinate. All n points move with the constant speed, the coordinate of the i-th point at the moment t (t can be non-integer) is calculated as x_i + t \u22c5 v_i.\n\nConsider two points i and j. Let d(i, j) be the minimum possible distance between these two points over any possible moments of time (even non-integer). It means that if two points i and j coincide at some moment, the value d(i, j) will be 0.\n\nYour task is to calculate the value \u2211_{1 \u2264 i < j \u2264 n} d(i, j) (the sum of minimum distances over all pairs of points).\n\nInput\n\nThe first line of the input contains one integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of points.\n\nThe second line of the input contains n integers x_1, x_2, ..., x_n (1 \u2264 x_i \u2264 10^8), where x_i is the initial coordinate of the i-th point. It is guaranteed that all x_i are distinct.\n\nThe third line of the input contains n integers v_1, v_2, ..., v_n (-10^8 \u2264 v_i \u2264 10^8), where v_i is the speed of the i-th point.\n\nOutput\n\nPrint one integer \u2014 the value \u2211_{1 \u2264 i < j \u2264 n} d(i, j) (the sum of minimum distances over all pairs of points).\n\nExamples\n\nInput\n\n\n3\n1 3 2\n-100 2 3\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n5\n2 1 4 3 5\n2 2 2 3 4\n\n\nOutput\n\n\n19\n\n\nInput\n\n\n2\n2 1\n-3 0\n\n\nOutput\n\n\n0",
        "task_name": "1311_F. Moving Points",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\nfrom collections import *\n\n\ndef fast2():\n    import os, sys, atexit\n    from cStringIO import StringIO as BytesIO\n    # range = xrange\n    sys.stdout = BytesIO()\n    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))\n    return BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\nclass order_tree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [[0, 0] for _ in range(self.n * 2)]\n        self.order = defaultdict(int, {arr[i]: i for i in range(self.n)})\n\n    # get interval[l,r)\n    def query(self, l):\n        res, coun = 0, 0\n        l = self.order[l] + self.n\n        r = self.n * 2\n\n        while l < r:\n            if l & 1:\n                res += self.tree[l][0]\n                coun += self.tree[l][1]\n                l += 1\n\n            if r & 1:\n                r -= 1\n                res += self.tree[r][0]\n                coun += self.tree[r][1]\n\n            l >>= 1\n            r >>= 1\n\n        return res, coun\n\n    def update(self, ix, val):\n        ix = self.n + self.order[ix]\n\n        # set new value\n        self.tree[ix][0] += val\n        self.tree[ix][1] += 1\n\n        # move up\n        while ix > 1:\n            self.tree[ix >> 1][0] = self.tree[ix][0] + self.tree[ix ^ 1][0]\n            self.tree[ix >> 1][1] = self.tree[ix][1] + self.tree[ix ^ 1][1]\n            ix >>= 1\n\n\ninput = fast2()\nrints = lambda: [int(x) for x in input().split()]\nn, a = int(input()), sorted(map(lambda x, y: [x, y], rints(), rints()))\ndis = sorted(set([x[1] for x in a]))\ntree, ans = order_tree(dis), 0\n\nfor i in range(n - 1, -1, -1):\n    su, coun = tree.query(a[i][1])\n    ans += su - coun * a[i][0]\n    tree.update(a[i][1], a[i][0])\n\nprint(ans)\n",
        "correct": true,
        "task_id": "0005",
        "depth": 1
    },
    {
        "description": "Easy and hard versions are actually different problems, so read statements of both problems completely and carefully.\n\nSummer vacation has started so Alice and Bob want to play and joy, but... Their mom doesn't think so. She says that they have to read some amount of books before all entertainments. Alice and Bob will read each book together to end this exercise faster.\n\nThere are n books in the family library. The i-th book is described by three integers: t_i \u2014 the amount of time Alice and Bob need to spend to read it, a_i (equals 1 if Alice likes the i-th book and 0 if not), and b_i (equals 1 if Bob likes the i-th book and 0 if not).\n\nSo they need to choose some books from the given n books in such a way that:\n\n  * Alice likes at least k books from the chosen set and Bob likes at least k books from the chosen set; \n  * the total reading time of these books is minimized (they are children and want to play and joy as soon a possible). \n\n\n\nThe set they choose is the same for both Alice an Bob (it's shared between them) and they read all books together, so the total reading time is the sum of t_i over all books that are in the chosen set.\n\nYour task is to help them and find any suitable set of books or determine that it is impossible to find such a set.\n\nInput\n\nThe first line of the input contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe next n lines contain descriptions of books, one description per line: the i-th line contains three integers t_i, a_i and b_i (1 \u2264 t_i \u2264 10^4, 0 \u2264 a_i, b_i \u2264 1), where:\n\n  * t_i \u2014 the amount of time required for reading the i-th book; \n  * a_i equals 1 if Alice likes the i-th book and 0 otherwise; \n  * b_i equals 1 if Bob likes the i-th book and 0 otherwise. \n\nOutput\n\nIf there is no solution, print only one integer -1. Otherwise print one integer T \u2014 the minimum total reading time of the suitable set of books.\n\nExamples\n\nInput\n\n8 4\n7 1 1\n2 1 1\n4 0 1\n8 1 1\n1 0 1\n1 1 1\n1 0 1\n3 0 0\n\n\nOutput\n\n18\n\n\nInput\n\n5 2\n6 0 0\n9 0 0\n1 0 1\n2 1 1\n5 1 0\n\n\nOutput\n\n8\n\n\nInput\n\n5 3\n3 0 0\n2 1 0\n3 1 0\n5 0 1\n3 0 1\n\n\nOutput\n\n-1",
        "task_name": "1374_E1. Reading Books (easy version)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport math\nfrom collections import defaultdict\n\nn,k = list(map(int, sys.stdin.readline().strip().split(' ')))\n\nt = []\na = []\nb = []\nfor _ in range(n):\n\tti,ai,bi = list(map(int, sys.stdin.readline().strip().split(' ')))\n\tt.append(ti)\n\ta.append(ai)\n\tb.append(bi)\n\nalice_only = []\nalice = 0\nbob = 0\nbob_only = []\ntaken = [0 for i in range(n)]\nts = sorted(enumerate(t), key=lambda x: x[1])\nfor i,ti in ts:\n\tif a[i] and b[i]:\n\t\tif alice == k and bob == k:\n\t\t\tif alice_only and bob_only:\n\t\t\t\tif ti < alice_only[-1] + bob_only[-1]:\n\t\t\t\t\ttaken[alice_only.pop()] = 0\n\t\t\t\t\ttaken[bob_only.pop()] = 0\n\t\t\t\t\ttaken[i] = 1\n\t\t\tcontinue\n\t\tif alice == k:\n\t\t\tif alice_only:\n\t\t\t\tj = alice_only.pop()\n\t\t\t\ttaken[j] = 0\n\t\telse:\n\t\t\talice += 1\n\t\tif bob == k:\n\t\t\tif bob_only:\n\t\t\t\tj = bob_only.pop()\n\t\t\t\ttaken[j] = 0\n\t\telse:\n\t\t\tbob += 1\n\t\ttaken[i] = 1\n\t\tcontinue\n\tif a[i] and alice < k:\n\t\talice += 1\n\t\talice_only.append(i)\n\t\ttaken[i] = 1\n\tif b[i] and bob < k:\n\t\tbob += 1\n\t\tbob_only.append(i)\n\t\ttaken[i] = 1\n\nif alice != k or bob != k:\n\tprint(-1)\nelse:\n\tans = 0\n\tfor i,ti in ts:\n\t\tif taken[i]:\n\t\t\tans += ti\n\tprint(ans)\n\n\n\n\n\n",
        "correct": false,
        "task_id": "0007",
        "depth": 1
    },
    {
        "description": "This is the easy version of the problem. The only difference is that in this version q = 1. You can make hacks only if both versions of the problem are solved.\n\nThere is a process that takes place on arrays a and b of length n and length n-1 respectively. \n\nThe process is an infinite sequence of operations. Each operation is as follows: \n\n  * First, choose a random integer i (1 \u2264 i \u2264 n-1). \n  * Then, simultaneously set a_i = min\\left(a_i, \\frac{a_i+a_{i+1}-b_i}{2}\\right) and a_{i+1} = max\\left(a_{i+1}, \\frac{a_i+a_{i+1}+b_i}{2}\\right) without any rounding (so values may become non-integer). \n\nSee notes for an example of an operation.\n\nIt can be proven that array a converges, i. e. for each i there exists a limit a_i converges to. Let function F(a, b) return the value a_1 converges to after a process on a and b.\n\nYou are given array b, but not array a. However, you are given a third array c. Array a is good if it contains only integers and satisfies 0 \u2264 a_i \u2264 c_i for 1 \u2264 i \u2264 n.\n\nYour task is to count the number of good arrays a where F(a, b) \u2265 x for q values of x. Since the number of arrays can be very large, print it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 100).\n\nThe second line contains n integers c_1, c_2 \u2026, c_n (0 \u2264 c_i \u2264 100).\n\nThe third line contains n-1 integers b_1, b_2, \u2026, b_{n-1} (0 \u2264 b_i \u2264 100).\n\nThe fourth line contains a single integer q (q=1).\n\nThe fifth line contains q space separated integers x_1, x_2, \u2026, x_q (-10^5 \u2264 x_i \u2264 10^5).\n\nOutput\n\nOutput q integers, where the i-th integer is the answer to the i-th query, i. e. the number of good arrays a where F(a, b) \u2265 x_i modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n2 3 4\n2 1\n1\n-1\n\n\nOutput\n\n\n56\n\nNote\n\nThe following explanation assumes b = [2, 1] and c=[2, 3, 4] (as in the sample).\n\nExamples of arrays a that are not good: \n\n  * a = [3, 2, 3] is not good because a_1 > c_1; \n  * a = [0, -1, 3] is not good because a_2 < 0. \n\n\n\nOne possible good array a is [0, 2, 4]. We can show that no operation has any effect on this array, so F(a, b) = a_1 = 0.\n\nAnother possible good array a is [0, 1, 4]. In a single operation with i = 1, we set a_1 = min((0+1-2)/(2), 0) and a_2 = max((0+1+2)/(2), 1). So, after a single operation with i = 1, a becomes equal to [-1/2, 3/2, 4]. We can show that no operation has any effect on this array, so F(a, b) = -1/2.",
        "task_name": "1540_C1. Converging Array (Easy Version)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division,print_function\nfrom heapq import*\nimport sys\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\nmo=10**9+7\nif 1:\n    n=int(le.pop())\n    c = list(map(int,le.pop().split()))\n    b = list(map(int,le.pop().split()))\n    le.pop()\n    x=int(le.pop())\n    prefb=[b[0]]\n    for k in b[1:]:\n        prefb.append(k+prefb[-1])\n    prefb.append(0)    #careful when going to C\n    prefbt=[0]\n    for k in range(1,n-1):\n        prefbt.append(k*b[k]+prefbt[-1])\n    prefbt.append(0)\nsc=sum(c)\nd=[[0]*(sc+1) for k in range(n+1)]#fuck a lot of prefix sum in this problem\nds=[[0]*(sc+2) for k in range(n+1)]#prefix array beginning with 0\nds[-1]=list(range(sc+2))\nd[-1]=[1]*(sc+1)\nfor index in range(n-1,-1,-1):\n    #can even go linearly for minpref\n    minpref=0\n    while (minpref-index*prefb[index-1]+prefbt[index-1])/(index+1)<x:\n       minpref+=1\n    for pref in range(sc+1):\n        mi=min(pref+c[index]+1,sc+1)\n        ma=max(minpref,pref)\n        d[index][pref]=0 if mi<ma else ds[index+1][mi]-ds[index+1][ma]\n    for pref in range(1,sc+2):\n        ds[index][pref]=(ds[index][pref-1]+d[index][pref-1])%mo\nprint(d[0][0]%mo)\n",
        "correct": true,
        "task_id": "0014",
        "depth": 2
    },
    {
        "description": "Petya studies positional notations. He has already learned to add and subtract numbers in the systems of notations with different radices and has moved on to a more complicated action \u2014 multiplication. To multiply large numbers one has to learn the multiplication table. Unfortunately, in the second grade students learn only the multiplication table of decimals (and some students even learn it in the first grade). Help Petya make a multiplication table for numbers in the system of notations with the radix k.\n\nInput\n\nThe first line contains a single integer k (2 \u2264 k \u2264 10) \u2014 the radix of the system.\n\nOutput\n\nOutput the multiplication table for the system of notations with the radix k. The table must contain k - 1 rows and k - 1 columns. The element on the crossing of the i-th row and the j-th column is equal to the product of i and j in the system of notations with the radix k. Each line may have any number of spaces between the numbers (the extra spaces in the samples are put for clarity).\n\nExamples\n\nInput\n\n10\n\n\nOutput\n\n1  2  3  4  5  6  7  8  9\n2  4  6  8 10 12 14 16 18\n3  6  9 12 15 18 21 24 27\n4  8 12 16 20 24 28 32 36\n5 10 15 20 25 30 35 40 45\n6 12 18 24 30 36 42 48 54\n7 14 21 28 35 42 49 56 63\n8 16 24 32 40 48 56 64 72\n9 18 27 36 45 54 63 72 81\n\n\nInput\n\n3\n\n\nOutput\n\n1  2\n2 11",
        "task_name": "39_H. Multiplication Table",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\nbase = int(sys.stdin.readline())\n\ndef baseN(num, b, numerals=\"0123456789\"):\n    return ((num == 0) and  \"0\" ) or ( baseN(num // b, b).lstrip(\"0\") + numerals[num % b])\n\nfor i in range(1, base):\n\tfor j in range(1, base):\n\t\tif j != 1:\n\t\t\tsys.stdout.write(\" \")\n\t\tn = (i * j)\n\t\tif base != 10:\n\t\t\tn = int(baseN(n, base))\n\t\tsys.stdout.write(\"%d\" % n)\n\tsys.stdout.write(\"\\n\")\n\n",
        "correct": true,
        "task_id": "0020",
        "depth": 2
    },
    {
        "description": "Adilbek's house is located on a street which can be represented as the OX axis. This street is really dark, so Adilbek wants to install some post lamps to illuminate it. Street has n positions to install lamps, they correspond to the integer numbers from 0 to n - 1 on the OX axis. However, some positions are blocked and no post lamp can be placed there.\n\nThere are post lamps of different types which differ only by their power. When placed in position x, post lamp of power l illuminates the segment [x; x + l]. The power of each post lamp is always a positive integer number.\n\nThe post lamp shop provides an infinite amount of lamps of each type from power 1 to power k. Though each customer is only allowed to order post lamps of exactly one type. Post lamps of power l cost a_l each.\n\nWhat is the minimal total cost of the post lamps of exactly one type Adilbek can buy to illuminate the entire segment [0; n] of the street? If some lamps illuminate any other segment of the street, Adilbek does not care, so, for example, he may place a lamp of power 3 in position n - 1 (even though its illumination zone doesn't completely belong to segment [0; n]).\n\nInput\n\nThe first line contains three integer numbers n, m and k (1 \u2264 k \u2264 n \u2264 10^6, 0 \u2264 m \u2264 n) \u2014 the length of the segment of the street Adilbek wants to illuminate, the number of the blocked positions and the maximum power of the post lamp available.\n\nThe second line contains m integer numbers s_1, s_2, ..., s_m (0 \u2264 s_1 < s_2 < ... s_m < n) \u2014 the blocked positions.\n\nThe third line contains k integer numbers a_1, a_2, ..., a_k (1 \u2264 a_i \u2264 10^6) \u2014 the costs of the post lamps.\n\nOutput\n\nPrint the minimal total cost of the post lamps of exactly one type Adilbek can buy to illuminate the entire segment [0; n] of the street.\n\nIf illumintaing the entire segment [0; n] is impossible, print -1.\n\nExamples\n\nInput\n\n6 2 3\n1 3\n1 2 3\n\n\nOutput\n\n6\n\n\nInput\n\n4 3 4\n1 2 3\n1 10 100 1000\n\n\nOutput\n\n1000\n\n\nInput\n\n5 1 5\n0\n3 3 3 3 3\n\n\nOutput\n\n-1\n\n\nInput\n\n7 4 3\n2 4 5 6\n3 14 15\n\n\nOutput\n\n-1",
        "task_name": "990_E. Post Lamps",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "get = lambda: [int(x) for x in raw_input().split()]\nn, m, k = get()\nblock = get()\na = get()\n     \ncan = [1] * n\nfor x in block:\n    can[x] = 0\nlast_can = [0] * n\nlast = -1\nfor i in range(n):\n    last_can[i] = i if can[i] else last\n    last = last_can[i]\n     \nans = 10**13\nif can[0]:\n    for i in range(k):\n        step = i+1\n        cnt = 1\n        x = 0\n        while x+step < n and last_can[x+step] > x:\n            cnt += 1\n            x = last_can[x+step]\n        if x+step >= n:\n            ans = min(ans, cnt * a[i])\n     \nprint(-1 if ans == 10**13 else ans)\nh=77\n \t\t\t \t  \t \t  \t \t\t\t \t \t\t\t  \t\t\t \t",
        "correct": true,
        "task_id": "0032",
        "depth": 2
    },
    {
        "description": "There is a staircase with N steps. Takahashi is now standing at the foot of the stairs, that is, on the 0-th step. He can climb up one or two steps at a time.\n\nHowever, the treads of the a_1-th, a_2-th, a_3-th, \\ldots, a_M-th steps are broken, so it is dangerous to set foot on those steps.\n\nHow many are there to climb up to the top step, that is, the N-th step, without setting foot on the broken steps? Find the count modulo 1\\ 000\\ 000\\ 007.\n\nConstraints\n\n* 1 \\leq N \\leq 10^5\n* 0 \\leq M \\leq N-1\n* 1 \\leq a_1 < a_2 < ... < a_M \\leq N-1\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M\na_1\na_2\n.\n.\n.\na_M\n\n\nOutput\n\nPrint the number of ways to climb up the stairs under the condition, modulo 1\\ 000\\ 000\\ 007.\n\nExamples\n\nInput\n\n6 1\n3\n\n\nOutput\n\n4\n\n\nInput\n\n10 2\n4\n5\n\n\nOutput\n\n0\n\n\nInput\n\n100 5\n1\n23\n45\n67\n89\n\n\nOutput\n\n608200469",
        "task_name": "p03013 AtCoder Beginner Contest 129 - Typical Stairs",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, m = map(int, raw_input().split(\" \"))\n\ndp = [0 for i in range(0, n + 1)]\ndp[0] = 1\n\nfor i in range(0, m):\n    a = int(raw_input())\n    dp[a] = -1\n\nfor step in range(1, n + 1):\n    if dp[step] < 0:\n        continue\n\n    ans = 0\n    for prev in [1, 2]:\n        if step - prev >= 0 and dp[step - prev] >= 0:\n            ans += dp[step - prev]\n    dp[step] = ans\n\n# for i in range(0, len(dp)):\n#     print(dp[i])\n\nprint(dp[n] % 1000000007)\n",
        "correct": true,
        "task_id": "0036",
        "depth": 2
    },
    {
        "description": "Taro is going to play a card game. However, now he has only n cards, even though there should be 52 cards (he has no Jokers).\n\nThe 52 cards include 13 ranks of each of the four suits: spade, heart, club and diamond.\n\nNote\n\n\u89e3\u8aac\n\n\n\nInput\n\nIn the first line, the number of cards n (n \u2264 52) is given.\n\nIn the following n lines, data of the n cards are given. Each card is given by a pair of a character and an integer which represent its suit and rank respectively. A suit is represented by 'S', 'H', 'C' and 'D' for spades, hearts, clubs and diamonds respectively. A rank is represented by an integer from 1 to 13.\n\nOutput\n\nPrint the missing cards. The same as the input format, each card should be printed with a character and an integer separated by a space character in a line. Arrange the missing cards in the following priorities:\n\n* Print cards of spades, hearts, clubs and diamonds in this order.\n* If the suits are equal, print cards with lower ranks first.\n\nExample\n\nInput\n\n47\nS 10\nS 11\nS 12\nS 13\nH 1\nH 2\nS 6\nS 7\nS 8\nS 9\nH 6\nH 8\nH 9\nH 10\nH 11\nH 4\nH 5\nS 2\nS 3\nS 4\nS 5\nH 12\nH 13\nC 1\nC 2\nD 1\nD 2\nD 3\nD 4\nD 5\nD 6\nD 7\nC 3\nC 4\nC 5\nC 6\nC 7\nC 8\nC 9\nC 10\nC 11\nC 13\nD 9\nD 10\nD 11\nD 12\nD 13\n\n\nOutput\n\nS 1\nH 3\nH 7\nC 12\nD 8",
        "task_name": "p02408 Finding Missing Cards",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = input()\nd = {\"S\":[None]*13, \"H\":[None]*13, \"C\":[None]*13, \"D\":[None]*13}\n\nfor i in range(n):\n\tx, y = raw_input().split()\n\td[x][int(y)-1] = True\n\nfor k in [\"S\",\"H\",\"C\",\"D\"]:\n\tfor i in range(13):\n\t\tif d[k][i]:\n\t\t\tcontinue\n\t\tprint (\"%s %d\"%(k, i+1))",
        "correct": true,
        "task_id": "0045",
        "depth": 2
    },
    {
        "description": "You are given two arrays of integers a_1,\u2026,a_n and b_1,\u2026,b_m.\n\nYour task is to find a non-empty array c_1,\u2026,c_k that is a subsequence of a_1,\u2026,a_n, and also a subsequence of b_1,\u2026,b_m. If there are multiple answers, find one of the smallest possible length. If there are still multiple of the smallest possible length, find any. If there are no such arrays, you should report about it.\n\nA sequence a is a subsequence of a sequence b if a can be obtained from b by deletion of several (possibly, zero) elements. For example, [3,1] is a subsequence of [3,2,1] and [4,3,1], but not a subsequence of [1,3,3,7] and [3,10,4].\n\nInput\n\nThe first line contains a single integer t (1\u2264 t\u2264 1000) \u2014 the number of test cases. Next 3t lines contain descriptions of test cases.\n\nThe first line of each test case contains two integers n and m (1\u2264 n,m\u2264 1000) \u2014 the lengths of the two arrays.\n\nThe second line of each test case contains n integers a_1,\u2026,a_n (1\u2264 a_i\u2264 1000) \u2014 the elements of the first array.\n\nThe third line of each test case contains m integers b_1,\u2026,b_m (1\u2264 b_i\u2264 1000) \u2014 the elements of the second array.\n\nIt is guaranteed that the sum of n and the sum of m across all test cases does not exceed 1000 (\u2211_{i=1}^t n_i, \u2211_{i=1}^t m_i\u2264 1000).\n\nOutput\n\nFor each test case, output \"YES\" if a solution exists, or \"NO\" otherwise.\n\nIf the answer is \"YES\", on the next line output an integer k (1\u2264 k\u2264 1000) \u2014 the length of the array, followed by k integers c_1,\u2026,c_k (1\u2264 c_i\u2264 1000) \u2014 the elements of the array.\n\nIf there are multiple solutions with the smallest possible k, output any.\n\nExample\n\nInput\n\n\n5\n4 5\n10 8 6 4\n1 2 3 4 5\n1 1\n3\n3\n1 1\n3\n2\n5 3\n1000 2 2 2 3\n3 1 5\n5 5\n1 2 3 4 5\n1 2 3 4 5\n\n\nOutput\n\n\nYES\n1 4\nYES\n1 3\nNO\nYES\n1 3\nYES\n1 2\n\nNote\n\nIn the first test case, [4] is a subsequence of [10, 8, 6, 4] and [1, 2, 3, 4, 5]. This array has length 1, it is the smallest possible length of a subsequence of both a and b.\n\nIn the third test case, no non-empty subsequences of both [3] and [2] exist, so the answer is \"NO\".",
        "task_name": "1382_A. Common Subsequence",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\ninput=lambda :stdin.readline().strip()\nfor _ in range(int(input())):\n    n,m=[int(i) for i in input().split()]\n    lst1=[int(i) for i in input().split()]\n    lst2=[int(i) for i in input().split()]\n    nk=0\n    lst1=set(lst1)\n    lst2=set(lst2)\n    for i in lst1:\n        if i in lst2:\n            print('YES')\n            print(1,i)\n            nk=1\n            break\n    if nk==0:\n        print('NO')\n",
        "correct": false,
        "task_id": "0053",
        "depth": 2
    },
    {
        "description": "You can't possibly imagine how cold our friends are this winter in Nvodsk! Two of them play the following game to warm up: initially a piece of paper has an integer q. During a move a player should write any integer number that is a non-trivial divisor of the last written number. Then he should run this number of circles around the hotel. Let us remind you that a number's divisor is called non-trivial if it is different from one and from the divided number itself. \n\nThe first person who can't make a move wins as he continues to lie in his warm bed under three blankets while the other one keeps running. Determine which player wins considering that both players play optimally. If the first player wins, print any winning first move.\n\nInput\n\nThe first line contains the only integer q (1 \u2264 q \u2264 1013).\n\nPlease do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specificator.\n\nOutput\n\nIn the first line print the number of the winning player (1 or 2). If the first player wins then the second line should contain another integer \u2014 his first move (if the first player can't even make the first move, print 0). If there are multiple solutions, print any of them.\n\nExamples\n\nInput\n\n6\n\n\nOutput\n\n2\n\n\nInput\n\n30\n\n\nOutput\n\n1\n6\n\n\nInput\n\n1\n\n\nOutput\n\n1\n0\n\nNote\n\nNumber 6 has only two non-trivial divisors: 2 and 3. It is impossible to make a move after the numbers 2 and 3 are written, so both of them are winning, thus, number 6 is the losing number. A player can make a move and write number 6 after number 30; 6, as we know, is a losing number. Thus, this move will bring us the victory.",
        "task_name": "151_C. Win or Freeze",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python2\n# -*- coding: utf-8 -*-\nimport sys\nifs = sys.stdin\nofs = sys.stdout\n\nfrom math import sqrt\n\n\ndef primes_eratosthene_leq_simple(N):\n    primes = [True]*(N+1)\n    #print 'allocated'\n    primes[0] = False\n    primes[1] = False\n    for i in range(2,int(sqrt(N))+1):\n        if primes[i]:\n            L = (N - i*i) // i  + 1\n            primes[i*i:N+1:i] = [False] * L\n    P = [n for n,prime in enumerate(primes) if prime]\n    return P\n\ndef primes_eratosthene_leq_block(N, block_size):\n    #print\n    #print 'finding primes <=', N, 'with block size', block_size\n    SQRT_N = int(sqrt(N))\n    primes = primes_eratosthene_leq_simple(SQRT_N)\n    #print 'generated primes <=',SQRT_N,'== sqrt(n)' \n    #print 'primes:',primes\n    new_primes = []\n    Nb,r = divmod(N-SQRT_N, block_size)\n    if r>0:\n        Nb += 1\n    #print 'number of blocks:', Nb\n    for ib in range(Nb):\n        # calculation\n        block = [True]*block_size\n        block_beg = SQRT_N + ib*block_size\n        #print 'block_beg:',block_beg\n        for p in primes:\n            beg = block_beg % p\n            if beg > 0:\n                beg = p - beg\n            #print 'checking prime',p,'starting from',beg\n            L = (block_size-1 - beg) // p + 1\n            block[beg:block_size:p] = [False]*L\n        # extraction\n        for k in range(block_size):\n            if block[k]:\n                n = block_beg+k\n                if n <= N:\n                    new_primes.append(n)\n\n    primes.extend(new_primes)\n    return primes\n\ndef primes_eratosthene_leq(N):\n    #return primes_simple_eratosthene_leq(N)\n    block_size = 30 * 10**3\n    if N <= block_size:\n        return primes_eratosthene_leq_simple(N)\n    else:\n        return primes_eratosthene_leq_block(N, block_size)\n\ndef solve(N):\n    NN = N\n    P = primes_eratosthene_leq(int(sqrt(N)))\n    #print P\n    D = []\n    for p in P:\n        d,r = divmod(N,p)\n        if r==0:\n            D.append(p)\n            N = d\n        if len(D) > 2:\n            break\n    if N != NN:\n        D.append(N)\n    #print D\n    \n    if len(D) == 0:\n        # N is prime\n        return (1,0)\n    elif len(D) == 2:\n        # N = p1 * p2, where p1 and p2 are primes\n        return (2,0)\n    else:\n        # N have more than 2 prime factors\n        return (1,D[0]*D[1])\n\n\n#import time\n#beg = time.time()\n\nN = int(ifs.readline())\n\nplayer,move = solve(N)\n\nofs.write('%d\\n' % (player))\nif player == 1:\n    ofs.write('%d\\n' % (move))\n\n#end = time.time()\n#print( '[%s] time = %0.3f ms' % ('Overall',(end-beg)*1000.0) )\n",
        "correct": false,
        "task_id": "0054",
        "depth": 2
    },
    {
        "description": "Manao works on a sports TV. He's spent much time watching the football games of some country. After a while he began to notice different patterns. For example, each team has two sets of uniforms: home uniform and guest uniform. When a team plays a game at home, the players put on the home uniform. When a team plays as a guest on somebody else's stadium, the players put on the guest uniform. The only exception to that rule is: when the home uniform color of the host team matches the guests' uniform, the host team puts on its guest uniform as well. For each team the color of the home and guest uniform is different.\n\nThere are n teams taking part in the national championship. The championship consists of n\u00b7(n - 1) games: each team invites each other team to its stadium. At this point Manao wondered: how many times during the championship is a host team going to put on the guest uniform? Note that the order of the games does not affect this number.\n\nYou know the colors of the home and guest uniform for each team. For simplicity, the colors are numbered by integers in such a way that no two distinct colors have the same number. Help Manao find the answer to his question.\n\nInput\n\nThe first line contains an integer n (2 \u2264 n \u2264 30). Each of the following n lines contains a pair of distinct space-separated integers hi, ai (1 \u2264 hi, ai \u2264 100) \u2014 the colors of the i-th team's home and guest uniforms, respectively.\n\nOutput\n\nIn a single line print the number of games where the host team is going to play in the guest uniform.\n\nExamples\n\nInput\n\n3\n1 2\n2 4\n3 4\n\n\nOutput\n\n1\n\n\nInput\n\n4\n100 42\n42 100\n5 42\n100 5\n\n\nOutput\n\n5\n\n\nInput\n\n2\n1 2\n1 2\n\n\nOutput\n\n0\n\nNote\n\nIn the first test case the championship consists of 6 games. The only game with the event in question is the game between teams 2 and 1 on the stadium of team 2.\n\nIn the second test sample the host team will have to wear guest uniform in the games between teams: 1 and 2, 2 and 1, 2 and 3, 3 and 4, 4 and 2 (the host team is written first).",
        "task_name": "268_A. Games",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import print_function\nfrom collections import Counter\n\nn = input()\ndom, vyezd = Counter(), Counter()\nfor i in range(n):\n    a, b = map(int, raw_input().split())\n    dom[a] += 1\n    vyezd[b] += 1\n    \notv = 0\nfor i in dom:\n    otv += vyezd[i]\n\nprint(otv)\n",
        "correct": false,
        "task_id": "0059",
        "depth": 1
    },
    {
        "description": "The bear decided to store some raspberry for the winter. He cunningly found out the price for a barrel of honey in kilos of raspberry for each of the following n days. According to the bear's data, on the i-th (1 \u2264 i \u2264 n) day, the price for one barrel of honey is going to is xi kilos of raspberry.\n\nUnfortunately, the bear has neither a honey barrel, nor the raspberry. At the same time, the bear's got a friend who is ready to lend him a barrel of honey for exactly one day for c kilograms of raspberry. That's why the bear came up with a smart plan. He wants to choose some day d (1 \u2264 d < n), lent a barrel of honey and immediately (on day d) sell it according to a daily exchange rate. The next day (d + 1) the bear wants to buy a new barrel of honey according to a daily exchange rate (as he's got some raspberry left from selling the previous barrel) and immediately (on day d + 1) give his friend the borrowed barrel of honey as well as c kilograms of raspberry for renting the barrel.\n\nThe bear wants to execute his plan at most once and then hibernate. What maximum number of kilograms of raspberry can he earn? Note that if at some point of the plan the bear runs out of the raspberry, then he won't execute such a plan.\n\nInput\n\nThe first line contains two space-separated integers, n and c (2 \u2264 n \u2264 100, 0 \u2264 c \u2264 100), \u2014 the number of days and the number of kilos of raspberry that the bear should give for borrowing the barrel.\n\nThe second line contains n space-separated integers x1, x2, ..., xn (0 \u2264 xi \u2264 100), the price of a honey barrel on day i.\n\nOutput\n\nPrint a single integer \u2014 the answer to the problem.\n\nExamples\n\nInput\n\n5 1\n5 10 7 3 20\n\n\nOutput\n\n3\n\n\nInput\n\n6 2\n100 1 10 40 10 40\n\n\nOutput\n\n97\n\n\nInput\n\n3 0\n1 2 3\n\n\nOutput\n\n0\n\nNote\n\nIn the first sample the bear will lend a honey barrel at day 3 and then sell it for 7. Then the bear will buy a barrel for 3 and return it to the friend. So, the profit is (7 - 3 - 1) = 3.\n\nIn the second sample bear will lend a honey barrel at day 1 and then sell it for 100. Then the bear buy the barrel for 1 at the day 2. So, the profit is (100 - 1 - 2) = 97.",
        "task_name": "385_A. Bear and Raspberry",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def fun():\n\tstring = raw_input()\n\t(N,C) = string.split(' ')\n\tN = int(N)\n\tC = int(C)\n\tx = raw_input().split(' ')\n\ttem = 0\n\tfor i in range(N):\n\t\tx[i] = int(x[i])\n\tfor i in range(len(x)-1):\n\t\tif(tem<=(x[i]-x[i+1])and(x[i]-x[i+1]-C>0)):\n\t\t\ttem = x[i]-x[i+1]\n\tif tem>0:\n\t\ttem = tem - C\n\treturn tem",
        "correct": false,
        "task_id": "0062",
        "depth": 1
    },
    {
        "description": "Bearland has n cities, numbered 1 through n. Cities are connected via bidirectional roads. Each road connects two distinct cities. No two roads connect the same pair of cities.\n\nBear Limak was once in a city a and he wanted to go to a city b. There was no direct connection so he decided to take a long walk, visiting each city exactly once. Formally: \n\n  * There is no road between a and b. \n  * There exists a sequence (path) of n distinct cities v1, v2, ..., vn that v1 = a, vn = b and there is a road between vi and vi + 1 for <image>. \n\n\n\nOn the other day, the similar thing happened. Limak wanted to travel between a city c and a city d. There is no road between them but there exists a sequence of n distinct cities u1, u2, ..., un that u1 = c, un = d and there is a road between ui and ui + 1 for <image>.\n\nAlso, Limak thinks that there are at most k roads in Bearland. He wonders whether he remembers everything correctly.\n\nGiven n, k and four distinct cities a, b, c, d, can you find possible paths (v1, ..., vn) and (u1, ..., un) to satisfy all the given conditions? Find any solution or print -1 if it's impossible.\n\nInput\n\nThe first line of the input contains two integers n and k (4 \u2264 n \u2264 1000, n - 1 \u2264 k \u2264 2n - 2) \u2014 the number of cities and the maximum allowed number of roads, respectively.\n\nThe second line contains four distinct integers a, b, c and d (1 \u2264 a, b, c, d \u2264 n).\n\nOutput\n\nPrint -1 if it's impossible to satisfy all the given conditions. Otherwise, print two lines with paths descriptions. The first of these two lines should contain n distinct integers v1, v2, ..., vn where v1 = a and vn = b. The second line should contain n distinct integers u1, u2, ..., un where u1 = c and un = d.\n\nTwo paths generate at most 2n - 2 roads: (v1, v2), (v2, v3), ..., (vn - 1, vn), (u1, u2), (u2, u3), ..., (un - 1, un). Your answer will be considered wrong if contains more than k distinct roads or any other condition breaks. Note that (x, y) and (y, x) are the same road.\n\nExamples\n\nInput\n\n7 11\n2 4 7 3\n\n\nOutput\n\n2 7 1 3 6 5 4\n7 1 5 4 6 2 3\n\n\nInput\n\n1000 999\n10 20 30 40\n\n\nOutput\n\n-1\n\nNote\n\nIn the first sample test, there should be 7 cities and at most 11 roads. The provided sample solution generates 10 roads, as in the drawing. You can also see a simple path of length n between 2 and 4, and a path between 7 and 3.\n\n<image>",
        "task_name": "643_B. Bear and Two Paths",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\n\nn,k=map(int,input().split())\na,b,c,d=map(int,input().split())\n\nif n==4:\n    # special case\n    print(\"-1\")\nelif k>=n+1:\n    # i know that having n+1 roads is possible\n    # assume n>=5\n    # get the chain\n    chain=[a,c]\n    for i in range(1,n+1):\n        if i not in [a,b,c,d]:\n            chain.append(i)\n    chain.append(b)\n    chain.append(d)\n    # print first path\n    p1=list(chain)\n    p1[-1],p1[-2]=p1[-2],p1[-1]\n    print(\" \".join(map(str,p1)))\n    # print second path\n    p2=list(chain)\n    p2[0],p2[1]=p2[1],p2[0]\n    print(\" \".join(map(str,p2)))\nelse:\n    print(\"-1\")",
        "correct": true,
        "task_id": "0071",
        "depth": 1
    },
    {
        "description": "Vasya is currently at a car rental service, and he wants to reach cinema. The film he has bought a ticket for starts in t minutes. There is a straight road of length s from the service to the cinema. Let's introduce a coordinate system so that the car rental service is at the point 0, and the cinema is at the point s.\n\nThere are k gas stations along the road, and at each of them you can fill a car with any amount of fuel for free! Consider that this operation doesn't take any time, i.e. is carried out instantly.\n\nThere are n cars in the rental service, i-th of them is characterized with two integers ci and vi \u2014 the price of this car rent and the capacity of its fuel tank in liters. It's not allowed to fuel a car with more fuel than its tank capacity vi. All cars are completely fueled at the car rental service.\n\nEach of the cars can be driven in one of two speed modes: normal or accelerated. In the normal mode a car covers 1 kilometer in 2 minutes, and consumes 1 liter of fuel. In the accelerated mode a car covers 1 kilometer in 1 minutes, but consumes 2 liters of fuel. The driving mode can be changed at any moment and any number of times.\n\nYour task is to choose a car with minimum price such that Vasya can reach the cinema before the show starts, i.e. not later than in t minutes. Assume that all cars are completely fueled initially.\n\nInput\n\nThe first line contains four positive integers n, k, s and t (1 \u2264 n \u2264 2\u00b7105, 1 \u2264 k \u2264 2\u00b7105, 2 \u2264 s \u2264 109, 1 \u2264 t \u2264 2\u00b7109) \u2014 the number of cars at the car rental service, the number of gas stations along the road, the length of the road and the time in which the film starts. \n\nEach of the next n lines contains two positive integers ci and vi (1 \u2264 ci, vi \u2264 109) \u2014 the price of the i-th car and its fuel tank capacity.\n\nThe next line contains k distinct integers g1, g2, ..., gk (1 \u2264 gi \u2264 s - 1) \u2014 the positions of the gas stations on the road in arbitrary order.\n\nOutput\n\nPrint the minimum rent price of an appropriate car, i.e. such car that Vasya will be able to reach the cinema before the film starts (not later than in t minutes). If there is no appropriate car, print -1.\n\nExamples\n\nInput\n\n3 1 8 10\n10 8\n5 7\n11 9\n3\n\n\nOutput\n\n10\n\n\nInput\n\n2 2 10 18\n10 4\n20 6\n5 3\n\n\nOutput\n\n20\n\nNote\n\nIn the first sample, Vasya can reach the cinema in time using the first or the third cars, but it would be cheaper to choose the first one. Its price is equal to 10, and the capacity of its fuel tank is 8. Then Vasya can drive to the first gas station in the accelerated mode in 3 minutes, spending 6 liters of fuel. After that he can full the tank and cover 2 kilometers in the normal mode in 4 minutes, spending 2 liters of fuel. Finally, he drives in the accelerated mode covering the remaining 3 kilometers in 3 minutes and spending 6 liters of fuel. ",
        "task_name": "737_A. Road to Cinema",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\n\ndef fast2():\n    import os, sys, atexit\n    from cStringIO import StringIO as BytesIO\n    # range = xrange\n    sys.stdout = BytesIO()\n    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))\n    return BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ninput = fast2()\nrints = lambda: [int(x) for x in input().split()]\nrints_2d = lambda n: [tuple(rints()) for _ in range(n)]\nn, k, s, t = rints()\na, g = sorted(rints_2d(n), key=lambda x: (x[1], x[0])), sorted(rints()) + [s]\n\nbe, en, ans = 0, n - 1, float('inf')\nwhile be <= en:\n    md = (be + en) >> 1\n    fuel, point, time = a[md][1], 0, 0\n\n    for i in range(k + 1):\n        dist = g[i] - point\n        rem = fuel - dist\n        if rem < 0:\n            time = float('inf')\n            break\n        else:\n            x = min(dist, rem)\n            time += x + (dist - x) * 2\n        point = g[i]\n\n    if time > t:\n        be = md + 1\n    else:\n        en = md - 1\n        ans = min(ans, a[md][0])\n\nprint(-1 if ans == float('inf') else ans)\n",
        "correct": false,
        "task_id": "0074",
        "depth": 2
    },
    {
        "description": "Two-gram is an ordered pair (i.e. string of length two) of capital Latin letters. For example, \"AZ\", \"AA\", \"ZA\" \u2014 three distinct two-grams.\n\nYou are given a string s consisting of n capital Latin letters. Your task is to find any two-gram contained in the given string as a substring (i.e. two consecutive characters of the string) maximal number of times. For example, for string s = \"BBAABBBA\" the answer is two-gram \"BB\", which contained in s three times. In other words, find any most frequent two-gram.\n\nNote that occurrences of the two-gram can overlap with each other.\n\nInput\n\nThe first line of the input contains integer number n (2 \u2264 n \u2264 100) \u2014 the length of string s. The second line of the input contains the string s consisting of n capital Latin letters.\n\nOutput\n\nPrint the only line containing exactly two capital Latin letters \u2014 any two-gram contained in the given string s as a substring (i.e. two consecutive characters of the string) maximal number of times.\n\nExamples\n\nInput\n\n7\nABACABA\n\n\nOutput\n\nAB\n\n\nInput\n\n5\nZZZAA\n\n\nOutput\n\nZZ\n\nNote\n\nIn the first example \"BA\" is also valid answer.\n\nIn the second example the only two-gram \"ZZ\" can be printed because it contained in the string \"ZZZAA\" two times.",
        "task_name": "977_B. Two-gram",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n=input()\ns=raw_input()\nd={}\nfor i in range(1,n):\n\tgram=s[i-1:i+1]\n\tif d.get(gram)==None:\n\t\td[gram]=1\n\telse:\n\t\td[gram]+=1\na = sorted(d.items(), key=lambda x: x[1],reverse=True)\nprint(a[0][0])\n",
        "correct": true,
        "task_id": "0079",
        "depth": 1
    },
    {
        "description": "Snuke has decided to play a game, where the player runs a railway company. There are M+1 stations on Snuke Line, numbered 0 through M. A train on Snuke Line stops at station 0 and every d-th station thereafter, where d is a predetermined constant for each train. For example, if d = 3, the train stops at station 0, 3, 6, 9, and so forth.\n\nThere are N kinds of souvenirs sold in areas around Snuke Line. The i-th kind of souvenirs can be purchased when the train stops at one of the following stations: stations l_i, l_i+1, l_i+2, ..., r_i.\n\nThere are M values of d, the interval between two stops, for trains on Snuke Line: 1, 2, 3, ..., M. For each of these M values, find the number of the kinds of souvenirs that can be purchased if one takes a train with that value of d at station 0. Here, assume that it is not allowed to change trains.\n\nConstraints\n\n* 1 \u2266 N \u2266 3 \u00d7 10^{5}\n* 1 \u2266 M \u2266 10^{5}\n* 1 \u2266 l_i \u2266 r_i \u2266 M\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN M\nl_1 r_1\n:\nl_{N} r_{N}\n\n\nOutput\n\nPrint the answer in M lines. The i-th line should contain the maximum number of the kinds of souvenirs that can be purchased if one takes a train stopping every i-th station.\n\nExamples\n\nInput\n\n3 3\n1 2\n2 3\n3 3\n\n\nOutput\n\n3\n2\n2\n\n\nInput\n\n7 9\n1 7\n5 9\n5 7\n5 9\n1 1\n6 8\n3 4\n\n\nOutput\n\n7\n6\n6\n5\n4\n5\n5\n3\n2",
        "task_name": "p03819 AtCoder Regular Contest 068 - Snuke Line",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "class BIT():\n    def __init__(self,size):\n        self.size=size\n        self.node=[0]*(size+1)\n\n    def sum(self,idx):\n        ret=0\n        while idx>0:\n            ret+=self.node[idx]\n            idx-=idx&(-idx)\n        return ret\n\n    def add(self,idx,x):\n        while idx<=self.size:\n            self.node[idx]+=x\n            idx+=idx&(-idx)\n\nn,m=map(int,raw_input().split())\nL=[[] for _ in xrange(m+1)]\nfor i in xrange(n):\n    l,r=map(int,raw_input().split())\n    r+=1\n    L[r-l].append(l)\nbit=BIT(m+1)\ntotal=0\nfor d in xrange(1,m+1):\n    for l in L[d]:\n        r=l+d\n        bit.add(l,1)\n        bit.add(r,-1)\n    total+=len(L[d])\n    ans=n-total\n    now=0\n    while now<=m:\n        ans+=bit.sum(now)\n        now+=d\n    print(ans)",
        "correct": true,
        "task_id": "0085",
        "depth": 2
    },
    {
        "description": "There is a 120 minute videotape with standard recording. When I set the VCR counter to 00:00:00 with the tape completely rewound and recorded in standard recording mode, I got a certain counter value. Enter this counter value (hours, minutes, seconds), find the length of the remaining tape (recordable time), and create a program that outputs in the format of hours: minutes: seconds.\n\nHowever, the input must be within 2 hours (120 minutes). The remaining amount of tape is calculated in two ways, standard recording mode and triple recording mode, and outputs two digits each for hours, minutes, and seconds as shown in the output example. If the tens digit is 0, such as \"05\", add \"0\".\n\n\n\ninput\n\nGiven multiple datasets. Each dataset is as follows.\n\n\nT H S\n\n\nT, H, and S are integers that represent hours, minutes, and seconds, respectively.\n\nInput ends when T, H, and S are all -1. The number of datasets does not exceed 50.\n\noutput\n\nFor each dataset\nOn the first line, the hours, minutes, and seconds of the recordable time when the rest of the tape is recorded as standard, separated by half-width colons.\nOn the second line, the hours, minutes, and seconds of the recordable time when the rest of the tape is recorded three times are separated by half-width colons.\nPlease output.\n\nExample\n\nInput\n\n1 30 0\n-1 -1 -1\n\n\nOutput\n\n00:30:00\n01:30:00",
        "task_name": "p00074 Videotape",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom __future__ import (division, absolute_import, print_function,\n                        unicode_literals)\nfrom sys import stdin\n\n\ndef print_time_lefts(seconds):\n    h, remain = divmod(7200 - seconds, 3600)\n    m, s = divmod(remain, 60)\n    print('{:02d}:{:02d}:{:02d}'.format(h, m, s))\n\nfor line in stdin:\n    h, m, s = (int(s) for s in line.split())\n    if h == -1 and m == -1 and s == -1:\n        break\n    seconds = h * 3600 + m * 60 + s\n    print_time_lefts(seconds)\n    print_time_lefts(seconds // 3)",
        "correct": false,
        "task_id": "0087",
        "depth": 1
    },
    {
        "description": "Alice received a set of Toy Train\u2122 from Bob. It consists of one train and a connected railway network of n stations, enumerated from 1 through n. The train occupies one station at a time and travels around the network of stations in a circular manner. More precisely, the immediate station that the train will visit after station i is station i+1 if 1 \u2264 i < n or station 1 if i = n. It takes the train 1 second to travel to its next station as described.\n\nBob gave Alice a fun task before he left: to deliver m candies that are initially at some stations to their independent destinations using the train. The candies are enumerated from 1 through m. Candy i (1 \u2264 i \u2264 m), now at station a_i, should be delivered to station b_i (a_i \u2260 b_i).\n\n<image> The blue numbers on the candies correspond to b_i values. The image corresponds to the 1-st example.\n\nThe train has infinite capacity, and it is possible to load off any number of candies at a station. However, only at most one candy can be loaded from a station onto the train before it leaves the station. You can choose any candy at this station. The time it takes to move the candies is negligible.\n\nNow, Alice wonders how much time is needed for the train to deliver all candies. Your task is to find, for each station, the minimum time the train would need to deliver all the candies were it to start from there.\n\nInput\n\nThe first line contains two space-separated integers n and m (2 \u2264 n \u2264 5 000; 1 \u2264 m \u2264 20 000) \u2014 the number of stations and the number of candies, respectively.\n\nThe i-th of the following m lines contains two space-separated integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n; a_i \u2260 b_i) \u2014 the station that initially contains candy i and the destination station of the candy, respectively.\n\nOutput\n\nIn the first and only line, print n space-separated integers, the i-th of which is the minimum time, in seconds, the train would need to deliver all the candies were it to start from station i.\n\nExamples\n\nInput\n\n\n5 7\n2 4\n5 1\n2 3\n3 4\n4 1\n5 3\n3 5\n\n\nOutput\n\n\n10 9 10 10 9 \n\n\nInput\n\n\n2 3\n1 2\n1 2\n1 2\n\n\nOutput\n\n\n5 6 \n\nNote\n\nConsider the second sample.\n\nIf the train started at station 1, the optimal strategy is as follows.\n\n  1. Load the first candy onto the train. \n  2. Proceed to station 2. This step takes 1 second. \n  3. Deliver the first candy. \n  4. Proceed to station 1. This step takes 1 second. \n  5. Load the second candy onto the train. \n  6. Proceed to station 2. This step takes 1 second. \n  7. Deliver the second candy. \n  8. Proceed to station 1. This step takes 1 second. \n  9. Load the third candy onto the train. \n  10. Proceed to station 2. This step takes 1 second. \n  11. Deliver the third candy. \n\n\n\nHence, the train needs 5 seconds to complete the tasks.\n\nIf the train were to start at station 2, however, it would need to move to station 1 before it could load the first candy, which would take one additional second. Thus, the answer in this scenario is 5+1 = 6 seconds.",
        "task_name": "1129_A2. Toy Train",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python2\n\"\"\"\nThis file is part of https://github.com/cheran-senthil/PyRival\nCopyright 2019 Cheran Senthilkumar <hello@cheran.io>\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport itertools\nimport os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\n\n\nclass dict(dict):\n    \"\"\"dict() -> new empty dictionary\"\"\"\n\n    def items(self):\n        \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n        return dict.iteritems(self)\n\n    def keys(self):\n        \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n        return dict.iterkeys(self)\n\n    def values(self):\n        \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n        return dict.itervalues(self)\n\n\ndef gcd(x, y):\n    \"\"\"greatest common divisor of x and y\"\"\"\n    while y:\n        x, y = y, x % y\n    return x\n\n\nrange = xrange\n\nfilter = itertools.ifilter\nmap = itertools.imap\nzip = itertools.izip\n\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\n\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    station = [[] for _ in range(n)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        station[a - 1].append(b - 1)\n\n    max_candy = [0] * n\n    for i in range(n):\n        try:\n            max_candy[i] = min(station[i], key=lambda x: x + n - i if x < i else x - i)\n        except ValueError:\n            pass\n\n    for i in range(n):\n        res = 0\n\n        for j in range(i, i + n):\n            if len(station[j % n]) == 0:\n                continue\n\n            dist = j - i\n            j %= n\n            dist += (len(station[j]) - 1) * n + (max_candy[j] + n - j if max_candy[j] < j else max_candy[j] - j)\n\n            res = max(res, dist)\n\n        print(res, end=' ')\n\n\nif __name__ == '__main__':\n    main()\n",
        "correct": true,
        "task_id": "0090",
        "depth": 2
    },
    {
        "description": "You're given an array a_1, \u2026, a_n of n non-negative integers.\n\nLet's call it sharpened if and only if there exists an integer 1 \u2264 k \u2264 n such that a_1 < a_2 < \u2026 < a_k and a_k > a_{k+1} > \u2026 > a_n. In particular, any strictly increasing or strictly decreasing array is sharpened. For example:\n\n  * The arrays [4], [0, 1], [12, 10, 8] and [3, 11, 15, 9, 7, 4] are sharpened; \n  * The arrays [2, 8, 2, 8, 6, 5], [0, 1, 1, 0] and [2, 5, 6, 9, 8, 8] are not sharpened. \n\n\n\nYou can do the following operation as many times as you want: choose any strictly positive element of the array, and decrease it by one. Formally, you can choose any i (1 \u2264 i \u2264 n) such that a_i>0 and assign a_i := a_i - 1.\n\nTell if it's possible to make the given array sharpened using some number (possibly zero) of these operations.\n\nInput\n\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 15\\ 000) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 3 \u22c5 10^5).\n\nThe second line of each test case contains a sequence of n non-negative integers a_1, \u2026, a_n (0 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single line containing \"Yes\" (without quotes) if it's possible to make the given array sharpened using the described operations, or \"No\" (without quotes) otherwise.\n\nExample\n\nInput\n\n\n10\n1\n248618\n3\n12 10 8\n6\n100 11 15 9 7 8\n4\n0 1 1 0\n2\n0 0\n2\n0 1\n2\n1 0\n2\n1 1\n3\n0 1 0\n3\n1 0 1\n\n\nOutput\n\n\nYes\nYes\nYes\nNo\nNo\nYes\nYes\nYes\nYes\nNo\n\nNote\n\nIn the first and the second test case of the first test, the given array is already sharpened.\n\nIn the third test case of the first test, we can transform the array into [3, 11, 15, 9, 7, 4] (decrease the first element 97 times and decrease the last element 4 times). It is sharpened because 3 < 11 < 15 and 15 > 9 > 7 > 4.\n\nIn the fourth test case of the first test, it's impossible to make the given array sharpened.",
        "task_name": "1291_B. Array Sharpening",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys \ninput=sys.stdin.readline \ndef ok1(curr):\n    n=len(curr)\n    return all(l[i]>l[i-1] for i in range(1,n))\ndef ok2(curr):\n    n=len(curr)\n    return all(l[i]<l[i-1] for i in range(1,n))\nfor _ in range(int(input())):\n    n=int(input())\n    l=[int(i) for i in input().split()]\n    if ok1(l) or ok2(l):\n        print('Yes')\n        continue\n    #increase then decreasee \n    ind=-1 \n    mini=19**10 \n    maxi=0 \n    pr=0 \n    for i in range(n):\n        mini=min(mini,l[i])\n        maxi=max(maxi,l[i])\n        if l[i]<pr:\n            ind=i\n            break \n        pr+=1 \n    f=1 \n    if ind==-1:\n        print('Yes')\n        continue\n    mini=l[ind-1]\n    for i in range(ind,n):\n        l[i]=min(l[i],mini-1)\n        mini=min(mini,l[i])\n        if l[i]<0 or mini<0:\n            f=0 \n    print('Yes' if f else 'No')\n    \n        \n    ",
        "correct": true,
        "task_id": "0095",
        "depth": 2
    },
    {
        "description": "You want to perform the combo on your opponent in one popular fighting game. The combo is the string s consisting of n lowercase Latin letters. To perform the combo, you have to press all buttons in the order they appear in s. I.e. if s=\"abca\" then you have to press 'a', then 'b', 'c' and 'a' again.\n\nYou know that you will spend m wrong tries to perform the combo and during the i-th try you will make a mistake right after p_i-th button (1 \u2264 p_i < n) (i.e. you will press first p_i buttons right and start performing the combo from the beginning). It is guaranteed that during the m+1-th try you press all buttons right and finally perform the combo.\n\nI.e. if s=\"abca\", m=2 and p = [1, 3] then the sequence of pressed buttons will be 'a' (here you're making a mistake and start performing the combo from the beginning), 'a', 'b', 'c', (here you're making a mistake and start performing the combo from the beginning), 'a' (note that at this point you will not perform the combo because of the mistake), 'b', 'c', 'a'.\n\nYour task is to calculate for each button (letter) the number of times you'll press it.\n\nYou have to answer t independent test cases.\n\nInput\n\nThe first line of the input contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThen t test cases follow.\n\nThe first line of each test case contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the length of s and the number of tries correspondingly.\n\nThe second line of each test case contains the string s consisting of n lowercase Latin letters.\n\nThe third line of each test case contains m integers p_1, p_2, ..., p_m (1 \u2264 p_i < n) \u2014 the number of characters pressed right during the i-th try.\n\nIt is guaranteed that the sum of n and the sum of m both does not exceed 2 \u22c5 10^5 (\u2211 n \u2264 2 \u22c5 10^5, \u2211 m \u2264 2 \u22c5 10^5).\n\nIt is guaranteed that the answer for each letter does not exceed 2 \u22c5 10^9.\n\nOutput\n\nFor each test case, print the answer \u2014 26 integers: the number of times you press the button 'a', the number of times you press the button 'b', ..., the number of times you press the button 'z'.\n\nExample\n\nInput\n\n\n3\n4 2\nabca\n1 3\n10 5\ncodeforces\n2 8 3 2 9\n26 10\nqwertyuioplkjhgfdsazxcvbnm\n20 10 1 2 3 5 10 5 9 4\n\n\nOutput\n\n\n4 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n0 0 9 4 5 3 0 0 0 0 0 0 0 0 9 0 0 3 1 0 0 0 0 0 0 0 \n2 1 1 2 9 2 2 2 5 2 2 2 1 1 5 4 11 8 2 7 5 1 10 1 5 2 \n\nNote\n\nThe first test case is described in the problem statement. Wrong tries are \"a\", \"abc\" and the final try is \"abca\". The number of times you press 'a' is 4, 'b' is 2 and 'c' is 2.\n\nIn the second test case, there are five wrong tries: \"co\", \"codeforc\", \"cod\", \"co\", \"codeforce\" and the final try is \"codeforces\". The number of times you press 'c' is 9, 'd' is 4, 'e' is 5, 'f' is 3, 'o' is 9, 'r' is 3 and 's' is 1.",
        "task_name": "1311_C. Perform the Combo",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n\n# from math import factorial as fac\nfrom collections import defaultdict\n# from copy import deepcopy\nimport sys, math\nf = None\ntry:\n\tf = open('q1.input', 'r')\nexcept IOError:\n\tf = sys.stdin\nif 'xrange' in dir(__builtins__):\n\trange = xrange\n# print(f.readline())\n# sys.setrecursionlimit(10**5)\n\n\t\ndef print_case_iterable(case_num, iterable):\n\tprint(\"Case #{}: {}\".format(case_num,\" \".join(map(str,iterable))))\n\ndef print_case_number(case_num, iterable):\n\tprint(\"Case #{}: {}\".format(case_num,iterable))\n\ndef print_iterable(A):\n\tprint (' '.join(A))\n\ndef read_int():\n\treturn int(f.readline().strip())\ndef read_int_array():\n\treturn [int(x) for x in f.readline().strip().split(\" \")]\ndef rns():\n\ta =  [x for x in f.readline().split(\" \")]\n\treturn int(a[0]), a[1].strip()\ndef read_string():\n\treturn list(f.readline().strip())\ndef bi(x):\n\treturn bin(x)[2:]\n\n\n\n\n\n\n\n\n\n\nfrom copy import deepcopy\ndef solution(s,n,p,m):\n\ts = [0] + s\n\tdp = [[0 for _ in range(26)] for _ in range(n+1)]\n\tp.sort()\n\tfor i in range(1,n+1):\n\t\tfor j in range(26):\n\t\t\tdp[i][j] = dp[i-1][j] + int(j == (ord(s[i])-ord('a')))\n\t#total m+1 tries\n\tres = [x for x in dp[n]]\n\tfor i in range(m):\n\t\tx=p[i]\n\t\tfor j in range(26):\n\t\t\tres[j]+=dp[x][j]\n\treturn ' '.join(map(str,res))\n\n\n\n\n\ndef main():\n\tT = read_int()\n\tfor i in range(T):\n\t\tn,m = read_int_array()\n\t\ts = read_string()\n\t\tp = read_int_array()\n\t\tx = solution(s,n,p,m)\n\n\t\tif 'xrange' not in dir(__builtins__):\n\t\t\tprint(x)\n\t\telse:\n\t\t\tprint >>output,str(x)# \"Case #\"+str(i+1)+':',\n\tif 'xrange' in dir(__builtins__):\n\t\tprint(output.getvalue())\n\t\toutput.close()\n\nif 'xrange' in dir(__builtins__):\n\timport cStringIO\n\toutput = cStringIO.StringIO()\n#example usage:\n#    for l in res:\n#       print >>output, str(len(l)) + ' ' +  ' '.join(l)\n\nif __name__ == '__main__':\n\tmain()\n\n\n\n'''stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* BITS - THINK HOW TO MASK PROPERLY\n\t* PERMUTATIONS - PARITY AND CYCLES\n\t* Think simple, if it becomes over complicated, try to look at it from a different perspective.\n\t* Have fun!!!\n\t* TRY FIXING SOMETHING, and then maybe binary search around it.\n\t* Remember heaps. \n\t* Remember how to add a value to a segment when using prefix sum.\n\t\tsuppose you have an array[1,2,3,4,5] and you want to add 3 to array[1:4]. Then just \n\t\tadd 3 to A[1], and decrease 3 from A[4]. Let's look at what happens:\n\t\toriginal prefixsums is \t\t\t\t\t [1,3,6,10,15]\n\t\tarray -> [1,5,3,4,2] and prefix sums are [1,6,9,13,15] \n\t\tAs you see, exactly +3 in A[1:4]\n\t\t*** The previous method can help checking how many x,y you can choose to get s=x+y from two arrays.\n'''\n'''\nbinary search \n\twhile(r - l > 1) {\n\t\tll mid = l + (r - l) / 2;\n\t\tsolve(mid);\n\t\tll sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum += b[i];\n\t\tif (sum <= k)\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t}\n'''\n",
        "correct": true,
        "task_id": "0096",
        "depth": 2
    },
    {
        "description": "The statement of this problem is the same as the statement of problem C1. The only difference is that, in problem C1, n is always even, and in C2, n is always odd.\n\nYou are given a regular polygon with 2 \u22c5 n vertices (it's convex and has equal sides and equal angles) and all its sides have length 1. Let's name it as 2n-gon.\n\nYour task is to find the square of the minimum size such that you can embed 2n-gon in the square. Embedding 2n-gon in the square means that you need to place 2n-gon in the square in such way that each point which lies inside or on a border of 2n-gon should also lie inside or on a border of the square.\n\nYou can rotate 2n-gon and/or the square.\n\nInput\n\nThe first line contains a single integer T (1 \u2264 T \u2264 200) \u2014 the number of test cases.\n\nNext T lines contain descriptions of test cases \u2014 one per line. Each line contains single odd integer n (3 \u2264 n \u2264 199). Don't forget you need to embed 2n-gon, not an n-gon.\n\nOutput\n\nPrint T real numbers \u2014 one per test case. For each test case, print the minimum length of a side of the square 2n-gon can be embedded in. Your answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\n\nExample\n\nInput\n\n\n3\n3\n5\n199\n\n\nOutput\n\n\n1.931851653\n3.196226611\n126.687663595",
        "task_name": "1354_C2. Not So Simple Polygon Embedding",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Educational Code Forces Round 87: C2: Not So Simple Polygon Embedding.\n# Sun. May. 17, 2020, By: arccosh.\n\nimport math\n\ndef solve(n):\n  return math.cos(math.pi / (4 * n)) / math.sin(math.pi / (2 * n))\n\nfor ca in xrange(int(raw_input())):\n  n = int(raw_input())\n  print('%.9f' % solve(n))\n",
        "correct": true,
        "task_id": "0098",
        "depth": 1
    },
    {
        "description": "Ori and Sein have overcome many difficult challenges. They finally lit the Shrouded Lantern and found Gumon Seal, the key to the Forlorn Ruins. When they tried to open the door to the ruins... nothing happened.\n\nOri was very surprised, but Sein gave the explanation quickly: clever Gumon decided to make an additional defence for the door.\n\nThere are n lamps with Spirit Tree's light. Sein knows the time of turning on and off for the i-th lamp \u2014 l_i and r_i respectively. To open the door you have to choose k lamps in such a way that there will be a moment of time when they all will be turned on.\n\nWhile Sein decides which of the k lamps to pick, Ori is interested: how many ways there are to pick such k lamps that the door will open? It may happen that Sein may be wrong and there are no such k lamps. The answer might be large, so print it modulo 998 244 353.\n\nInput\n\nFirst line contains two integers n and k (1 \u2264 n \u2264 3 \u22c5 10^5, 1 \u2264 k \u2264 n) \u2014 total number of lamps and the number of lamps that must be turned on simultaneously.\n\nNext n lines contain two integers l_i ans r_i (1 \u2264 l_i \u2264 r_i \u2264 10^9) \u2014 period of time when i-th lamp is turned on.\n\nOutput\n\nPrint one integer \u2014 the answer to the task modulo 998 244 353.\n\nExamples\n\nInput\n\n\n7 3\n1 7\n3 8\n4 5\n6 7\n1 3\n5 10\n8 9\n\n\nOutput\n\n\n9\n\nInput\n\n\n3 1\n1 1\n2 2\n3 3\n\n\nOutput\n\n\n3\n\nInput\n\n\n3 2\n1 1\n2 2\n3 3\n\n\nOutput\n\n\n0\n\nInput\n\n\n3 3\n1 3\n2 3\n3 3\n\n\nOutput\n\n\n1\n\nInput\n\n\n5 2\n1 3\n2 4\n3 5\n4 6\n5 7\n\n\nOutput\n\n\n7\n\nNote\n\nIn first test case there are nine sets of k lamps: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 2, 6), (1, 3, 6), (1, 4, 6), (2, 3, 6), (2, 4, 6), (2, 6, 7).\n\nIn second test case k=1, so the answer is 3.\n\nIn third test case there are no such pairs of lamps.\n\nIn forth test case all lamps are turned on in a time 3, so the answer is 1.\n\nIn fifth test case there are seven sets of k lamps: (1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (3, 5), (4, 5).",
        "task_name": "1420_D. Rescue Nibel!",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# from sys import stdin\nfrom collections import defaultdict\nfrom bisect import bisect_left\n\n\ndef fact(be, en):\n    res = [1]\n    for i in range(be, en + 1):\n        res.append(mult(res[-1], i))\n    return res\n\n\ndef nCr(n, r):\n    if n < r:\n        return 0\n    return div(facs[n], facs[n - r])\n\n\ndef arr_sum(arr):\n    tem = [0]\n    for i in range(len(arr)):\n        tem.append(tem[i] + arr[i])\n    return tem\n\n\ndef fast2():\n    import os, sys, atexit\n    from cStringIO import StringIO as BytesIO\n    # range = xrange\n    sys.stdout = BytesIO()\n    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))\n    return BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ninput = fast2()\nadd = lambda a, b: (a + b) % mod\nmult = lambda a, b: (a * b) % mod\ndiv = lambda a, b: mult(a, inv(b))\ninv = lambda a: pow(a, mod - 2, mod)\nrints = lambda: [int(x) for x in input().split()]\nmod = 998244353\n\nn, k = rints()\na = [rints() for _ in range(n)]\ndisbe, disen, ans = set(), set(), 0\nfacs = fact(1, 3 * 10 ** 5)\n\nfor l, r in a:\n    disbe.add(l)\n    disbe.add(r)\n\ndisbe = sorted(disbe)\nordbe = defaultdict(int, {disbe[i]: i for i in range(len(disbe))})\ncumbe, cumen = [0] * len(disbe), [0] * len(disbe)\n\nfor l, r in a:\n    cumbe[ordbe[l]] += 1\n    cumen[ordbe[r]] += 1\n\ncumbe, cumen = arr_sum(cumbe), arr_sum(cumen)\n\nfor i in disbe[1:-1]:\n    cur = cumbe[ordbe[i] + 1] - cumbe[ordbe[i]]\n    val = cumbe[-1] - cumbe[ordbe[i] + 1]\n    val += cumen[ordbe[i]]\n    all = n - val\n    ans = add(ans, add(nCr(all, k), -nCr(all - cur, k)))\n\n    # print(val, ans, all, i)\n\nprint(div(ans, facs[k]))\n",
        "correct": false,
        "task_id": "0101",
        "depth": 1
    },
    {
        "description": "As usual, Sereja has array a, its elements are integers: a[1], a[2], ..., a[n]. Let's introduce notation:\n\n<image>\n\nA swap operation is the following sequence of actions:\n\n  * choose two indexes i, j (i \u2260 j); \n  * perform assignments tmp = a[i], a[i] = a[j], a[j] = tmp. \n\n\n\nWhat maximum value of function m(a) can Sereja get if he is allowed to perform at most k swap operations?\n\nInput\n\nThe first line contains two integers n and k (1 \u2264 n \u2264 200; 1 \u2264 k \u2264 10). The next line contains n integers a[1], a[2], ..., a[n] ( - 1000 \u2264 a[i] \u2264 1000).\n\nOutput\n\nIn a single line print the maximum value of m(a) that Sereja can get if he is allowed to perform at most k swap operations.\n\nExamples\n\nInput\n\n10 2\n10 -1 2 2 2 2 2 2 -1 10\n\n\nOutput\n\n32\n\n\nInput\n\n5 10\n-1 -1 -1 -1 -1\n\n\nOutput\n\n-1",
        "task_name": "425_A. Sereja and Swaps",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def solve(a , l , r, k):\n\tout = sorted(a[:l]+a[r:], reverse=True)\n\tinside = sorted(a[l:r])\n\tcur = sum(a[l:r])\n\tfor i in range(min(k , len(inside) , len(out))):\n\t\tif out[i]>inside[i]:\n\t\t\tcur+=out[i]-inside[i]\n\t\telse:\n\t\t\tbreak\n\treturn cur\nn , k = [int(x) for x in raw_input().split()]\na= [int(x) for x in raw_input().split()]\nbest = a[0]\nfor l in range(n):\n\tfor r in range(l+1, n+1):\n\t\tcur = solve(a , l  , r, k)\n\t\tif(cur > best):\n\t\t\tbest= cur\n\nprint(best)",
        "correct": true,
        "task_id": "0108",
        "depth": 2
    },
    {
        "description": "A prime number is a natural number which has exactly two distinct natural number divisors: 1 and itself. For example, the first four prime numbers are: 2, 3, 5 and 7.\n\nWrite a program which reads a list of N integers and prints the number of prime numbers in the list.\n\nConstraints\n\n1 \u2264 N \u2264 10000\n\n2 \u2264 an element of the list \u2264 108\n\nInput\n\nThe first line contains an integer N, the number of elements in the list.\n\nN numbers are given in the following lines.\n\nOutput\n\nPrint the number of prime numbers in the given list.\n\nExamples\n\nInput\n\n5\n2\n3\n4\n5\n6\n\n\nOutput\n\n3\n\n\nInput\n\n11\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nOutput\n\n4",
        "task_name": "p02257 Prime Numbers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def isPrime( x ):\n\tif 2 == x or 3 == x:\n\t\treturn True\n\tif 0 == x%2:\n\t\treturn False \n\t\n\tfor i in range( 3, x ):\n\t\tif x < i*i:\n\t\t\tbreak\n\t\tif 0 == x%i:\n\t\t\treturn False\n\treturn True\n\n\nn = int( raw_input( ) )\ncnt = 0\nfor i in range( n ):\n\tnum = int( raw_input( ) )\n\tif isPrime( num  ):\n\t\tcnt += 1\n\nprint( cnt )",
        "correct": false,
        "task_id": "0125",
        "depth": 1
    },
    {
        "description": "The football season has just ended in Berland. According to the rules of Berland football, each match is played between two teams. The result of each match is either a draw, or a victory of one of the playing teams. If a team wins the match, it gets w points, and the opposing team gets 0 points. If the game results in a draw, both teams get d points.\n\nThe manager of the Berland capital team wants to summarize the results of the season, but, unfortunately, all information about the results of each match is lost. The manager only knows that the team has played n games and got p points for them.\n\nYou have to determine three integers x, y and z \u2014 the number of wins, draws and loses of the team. If there are multiple answers, print any of them. If there is no suitable triple (x, y, z), report about it.\n\nInput\n\nThe first line contains four integers n, p, w and d (1 \u2264 n \u2264 10^{12}, 0 \u2264 p \u2264 10^{17}, 1 \u2264 d < w \u2264 10^{5}) \u2014 the number of games, the number of points the team got, the number of points awarded for winning a match, and the number of points awarded for a draw, respectively. Note that w > d, so the number of points awarded for winning is strictly greater than the number of points awarded for draw.\n\nOutput\n\nIf there is no answer, print -1.\n\nOtherwise print three non-negative integers x, y and z \u2014 the number of wins, draws and losses of the team. If there are multiple possible triples (x, y, z), print any of them. The numbers should meet the following conditions: \n\n  * x \u22c5 w + y \u22c5 d = p, \n  * x + y + z = n. \n\nExamples\n\nInput\n\n\n30 60 3 1\n\n\nOutput\n\n\n17 9 4\n\n\nInput\n\n\n10 51 5 4\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n20 0 15 5\n\n\nOutput\n\n\n0 0 20\n\nNote\n\nOne of the possible answers in the first example \u2014 17 wins, 9 draws and 4 losses. Then the team got 17 \u22c5 3 + 9 \u22c5 1 = 60 points in 17 + 9 + 4 = 30 games.\n\nIn the second example the maximum possible score is 10 \u22c5 5 = 50. Since p = 51, there is no answer.\n\nIn the third example the team got 0 points, so all 20 games were lost.",
        "task_name": "1244_C. The Football Season",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\n[n,p,w,d]=[int(i) for i in sys.stdin.readline().split()]\n\nx=-1\ny=-1\nz=-1\n\ndone=0\n\nfor i in range(w):\n\tif((p-i*d)%w==0):\n\t\tj=(p-i*d)//w\n\t\tif(i+j<=n):\n\t\t\tx,y,z=j,i,n-j-i\n\t\t\tdone=1\n\t\t\tbreak\n\nif(done==1):\n\tprint(str(x)+\" \"+str(y)+\" \"+str(z))\nelse:\n\tprint(-1)",
        "correct": false,
        "task_id": "0130",
        "depth": 1
    },
    {
        "description": "So the Beautiful Regional Contest (BeRC) has come to an end! n students took part in the contest. The final standings are already known: the participant in the i-th place solved p_i problems. Since the participants are primarily sorted by the number of solved problems, then p_1 \u2265 p_2 \u2265 ... \u2265 p_n.\n\nHelp the jury distribute the gold, silver and bronze medals. Let their numbers be g, s and b, respectively. Here is a list of requirements from the rules, which all must be satisfied:\n\n  * for each of the three types of medals, at least one medal must be awarded (that is, g>0, s>0 and b>0); \n  * the number of gold medals must be strictly less than the number of silver and the number of bronze (that is, g<s and g<b, but there are no requirements between s and b); \n  * each gold medalist must solve strictly more problems than any awarded with a silver medal; \n  * each silver medalist must solve strictly more problems than any awarded a bronze medal; \n  * each bronze medalist must solve strictly more problems than any participant not awarded a medal; \n  * the total number of medalists g+s+b should not exceed half of all participants (for example, if n=21, then you can award a maximum of 10 participants, and if n=26, then you can award a maximum of 13 participants). \n\n\n\nThe jury wants to reward with medals the total maximal number participants (i.e. to maximize g+s+b) so that all of the items listed above are fulfilled. Help the jury find such a way to award medals.\n\nInput\n\nThe first line of the input contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the input. Then t test cases follow.\n\nThe first line of a test case contains an integer n (1 \u2264 n \u2264 4\u22c510^5) \u2014 the number of BeRC participants. The second line of a test case contains integers p_1, p_2, ..., p_n (0 \u2264 p_i \u2264 10^6), where p_i is equal to the number of problems solved by the i-th participant from the final standings. The values p_i are sorted in non-increasing order, i.e. p_1 \u2265 p_2 \u2265 ... \u2265 p_n.\n\nThe sum of n over all test cases in the input does not exceed 4\u22c510^5.\n\nOutput\n\nPrint t lines, the j-th line should contain the answer to the j-th test case.\n\nThe answer consists of three non-negative integers g, s, b.\n\n  * Print g=s=b=0 if there is no way to reward participants with medals so that all requirements from the statement are satisfied at the same time. \n  * Otherwise, print three positive numbers g, s, b \u2014 the possible number of gold, silver and bronze medals, respectively. The sum of g+s+b should be the maximum possible. If there are several answers, print any of them. \n\nExample\n\nInput\n\n\n5\n12\n5 4 4 3 2 2 1 1 1 1 1 1\n4\n4 3 2 1\n1\n1000000\n20\n20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\n32\n64 64 63 58 58 58 58 58 37 37 37 37 34 34 28 28 28 28 28 28 24 24 19 17 17 17 17 16 16 16 16 11\n\n\nOutput\n\n\n1 2 3\n0 0 0\n0 0 0\n2 5 3\n2 6 6\n\nNote\n\nIn the first test case, it is possible to reward 1 gold, 2 silver and 3 bronze medals. In this case, the participant solved 5 tasks will be rewarded with the gold medal, participants solved 4 tasks will be rewarded with silver medals, participants solved 2 or 3 tasks will be rewarded with bronze medals. Participants solved exactly 1 task won't be rewarded. It's easy to see, that in this case, all conditions are satisfied and it is possible to reward participants in this way. It is impossible to give more than 6 medals because the number of medals should not exceed half of the number of participants. The answer 1, 3, 2 is also correct in this test case.\n\nIn the second and third test cases, it is impossible to reward medals, because at least one medal of each type should be given, but the number of medals should not exceed half of the number of participants.",
        "task_name": "1264_A. Beautiful Regional Contest",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    t = int(input())\n\n    for _ in range(t):\n        n = int(input())\n\n        g, s, b = 0, 0, 0\n\n        l = 0\n        p = -1\n        for i, j in enumerate(map(int, input().split())):\n            if i > n // 2:\n                break\n\n            if p != j:\n                if g == 0:\n                    g = l\n                elif s <= g:\n                    s += l\n                else:\n                    b += l\n                l = 0\n\n            l += 1\n            p = j\n\n        if g == 0 or s == 0 or b == 0 or g >= s or g >= b:\n            print(0, 0, 0)\n        else:\n            print(g, s, b)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "0131",
        "depth": 2
    },
    {
        "description": "Gildong was hiking a mountain, walking by millions of trees. Inspired by them, he suddenly came up with an interesting idea for trees in data structures: What if we add another edge in a tree?\n\nThen he found that such tree-like graphs are called 1-trees. Since Gildong was bored of solving too many tree problems, he wanted to see if similar techniques in trees can be used in 1-trees as well. Instead of solving it by himself, he's going to test you by providing queries on 1-trees.\n\nFirst, he'll provide you a tree (not 1-tree) with n vertices, then he will ask you q queries. Each query contains 5 integers: x, y, a, b, and k. This means you're asked to determine if there exists a path from vertex a to b that contains exactly k edges after adding a bidirectional edge between vertices x and y. A path can contain the same vertices and same edges multiple times. All queries are independent of each other; i.e. the added edge in a query is removed in the next query.\n\nInput\n\nThe first line contains an integer n (3 \u2264 n \u2264 10^5), the number of vertices of the tree.\n\nNext n-1 lines contain two integers u and v (1 \u2264 u,v \u2264 n, u \u2260 v) each, which means there is an edge between vertex u and v. All edges are bidirectional and distinct.\n\nNext line contains an integer q (1 \u2264 q \u2264 10^5), the number of queries Gildong wants to ask.\n\nNext q lines contain five integers x, y, a, b, and k each (1 \u2264 x,y,a,b \u2264 n, x \u2260 y, 1 \u2264 k \u2264 10^9) \u2013 the integers explained in the description. It is guaranteed that the edge between x and y does not exist in the original tree.\n\nOutput\n\nFor each query, print \"YES\" if there exists a path that contains exactly k edges from vertex a to b after adding an edge between vertices x and y. Otherwise, print \"NO\".\n\nYou can print each letter in any case (upper or lower).\n\nExample\n\nInput\n\n\n5\n1 2\n2 3\n3 4\n4 5\n5\n1 3 1 2 2\n1 4 1 3 2\n1 4 1 3 3\n4 2 3 3 9\n5 2 3 3 9\n\n\nOutput\n\n\nYES\nYES\nNO\nYES\nNO\n\nNote\n\nThe image below describes the tree (circles and solid lines) and the added edges for each query (dotted lines).\n\n<image>\n\nPossible paths for the queries with \"YES\" answers are: \n\n  * 1-st query: 1 \u2013 3 \u2013 2 \n  * 2-nd query: 1 \u2013 2 \u2013 3 \n  * 4-th query: 3 \u2013 4 \u2013 2 \u2013 3 \u2013 4 \u2013 2 \u2013 3 \u2013 4 \u2013 2 \u2013 3 ",
        "task_name": "1304_E. 1-Trees and Queries",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"\nNTC here\n\"\"\"\nimport sys\n# reader = (s.rstrip() for s in sys.stdin)\n# input = reader.__next__\ninp = sys.stdin.readline\n\n\ndef input(): return inp().strip()\n\n\nout = []\n# flush = sys.stdout.flush\n# import threading\n# sys.setrecursionlimit(10**7)\n# threading.stack_size(2**25)\n\n\ndef iin(): return int(input())\n\n\ndef lin(): return list(map(int, input().split()))\n\n\nrange = xrange\ninput = raw_input\n\n\nINF = 10**5+7\nn = iin()\nadj = [[] for i in range(n+1)]\nfor _ in range(n-1):\n    i, j = lin()\n    adj[i].append(j)\n    adj[j].append(i)\n\n# LCA - lowest common ancestor\n\n\ndef dfs(adj, start=1):\n    n = len(adj)\n    visited = [False]*n\n    first = [-1]*n\n    euler = []\n    height = [-1]*n\n    srt = [start]\n    height[start] = 1\n    parent = [-1]*n\n    while srt:\n        v = srt.pop()\n        if visited[v]:\n            euler.append(v)\n            continue\n        \n        first[v] = len(euler)\n        euler.append(v)\n        visited[v] = True\n        if parent[v] != -1:\n            srt.append(parent[v])\n        for u in adj[v]:\n            if not visited[u]:\n                parent[u] = v\n                height[u] = height[v]+1\n                srt.append(u)\n\n    return first, euler, height\n\n\n# segment tree\nfirst, euler, height = dfs(adj)\n# print(first, euler, height)\neuler = [height[i] for i in euler]\n\nclass RangeQuery:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n \n    def query(self, begin, end):\n        end+=1\n        depth = (end - begin).bit_length() - 1\n        return self.func(self._data[depth][begin], self._data[depth][end - (1 << depth)])\n\n\nsa = RangeQuery(euler)\n\n\ndef check(i, j):\n    l, r = first[i], first[j]\n    if l > r:\n        l, r = r, l\n    h = sa.query(l, r)\n    #print(\"CHK\", l, r, h, i, j)\n    return height[i] + height[j] - 2*h\n\n\n# print(euler)\nq = iin()\nwhile q:\n    q -= 1\n    x, y, a, b, k = lin()\n    ans1 = [check(a, b), check(a, x)+1+check(y, b),\n            check(a, y)+1+check(x, b)]\n    for i in ans1:\n        if ((k-i) >= 0 and (k-i) % 2 == 0):\n            out.append('YES')\n            break\n    else:\n        out.append('NO')\n    # print(ans, ans1)\n    # out.append('YES' if True in ans else 'NO')\nprint('\\n'.join(out))\n\n\n# main()\n# threading.Thread(target=main).start()\n",
        "correct": true,
        "task_id": "0133",
        "depth": 2
    },
    {
        "description": "Consider an infinite triangle made up of layers. Let's number the layers, starting from one, from the top of the triangle (from top to bottom). The k-th layer of the triangle contains k points, numbered from left to right. Each point of an infinite triangle is described by a pair of numbers (r, c) (1 \u2264 c \u2264 r), where r is the number of the layer, and c is the number of the point in the layer. From each point (r, c) there are two directed edges to the points (r+1, c) and (r+1, c+1), but only one of the edges is activated. If r + c is even, then the edge to the point (r+1, c) is activated, otherwise the edge to the point (r+1, c+1) is activated. Look at the picture for a better understanding.\n\n<image> Activated edges are colored in black. Non-activated edges are colored in gray.\n\nFrom the point (r_1, c_1) it is possible to reach the point (r_2, c_2), if there is a path between them only from activated edges. For example, in the picture above, there is a path from (1, 1) to (3, 2), but there is no path from (2, 1) to (1, 1).\n\nInitially, you are at the point (1, 1). For each turn, you can: \n\n  * Replace activated edge for point (r, c). That is if the edge to the point (r+1, c) is activated, then instead of it, the edge to the point (r+1, c+1) becomes activated, otherwise if the edge to the point (r+1, c+1), then instead if it, the edge to the point (r+1, c) becomes activated. This action increases the cost of the path by 1; \n  * Move from the current point to another by following the activated edge. This action does not increase the cost of the path. \n\n\n\nYou are given a sequence of n points of an infinite triangle (r_1, c_1), (r_2, c_2), \u2026, (r_n, c_n). Find the minimum cost path from (1, 1), passing through all n points in arbitrary order.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) is the number of test cases. Then t test cases follow.\n\nEach test case begins with a line containing one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) is the number of points to visit.\n\nThe second line contains n numbers r_1, r_2, \u2026, r_n (1 \u2264 r_i \u2264 10^9), where r_i is the number of the layer in which i-th point is located.\n\nThe third line contains n numbers c_1, c_2, \u2026, c_n (1 \u2264 c_i \u2264 r_i), where c_i is the number of the i-th point in the r_i layer.\n\nIt is guaranteed that all n points are distinct.\n\nIt is guaranteed that there is always at least one way to traverse all n points.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output the minimum cost of a path passing through all points in the corresponding test case.\n\nExample\n\nInput\n\n\n4\n3\n1 4 2\n1 3 1\n2\n2 4\n2 3\n2\n1 1000000000\n1 1000000000\n4\n3 10 5 8\n2 5 2 4\n\n\nOutput\n\n\n0\n1\n999999999\n2",
        "task_name": "1506_F. Triangular Paths",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Enter your code here. Read input from STDIN. Print output to STDOUT# ===============================================================================================\n# importing some useful libraries.\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom itertools import *\nimport bisect\nfrom heapq import *\nfrom math import ceil, floor\nfrom copy import *\nfrom collections import deque, defaultdict\nfrom collections import Counter as counter  # Counter(list)  return a dict with {key: count}\nfrom itertools import combinations  # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\nfrom itertools import permutations as permutate\nfrom bisect import bisect_left as bl\nfrom operator import *\n# If the element is already present in the list,\n\n# the left most position where element has to be inserted is returned.\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n# If the element is already present in the list,\n# the right most position where element has to be inserted is returned\n\n# ==============================================================================================\n# fast I/O region\n\nBUFSIZE = 8192\nfrom sys import stderr\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"A\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for A in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(A))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\n\n\ndef iterative(f, stack=[]):\n    def wrapped_func(*args, **kwargs):\n        if stack: return f(*args, **kwargs)\n        to = f(*args, **kwargs)\n        while True:\n            if type(to) is GeneratorType:\n                stack.append(to)\n                to = next(to)\n                continue\n            stack.pop()\n            if not stack: break\n            to = stack[-1].send(to)\n        return to\n\n    return wrapped_func\n\n\n#### END ITERATE RECURSION ####\n###########################\n# Sorted list\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[start:start + _load] for start in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for start in range(len(_fen_tree)):\n            if start | start + 1 < len(_fen_tree):\n                _fen_tree[start | start + 1] += _fen_tree[start]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        A = 0\n        while end:\n            A += _fen_tree[end - 1]\n            end &= end - 1\n        return A\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\n\n# ===============================================================================================\n# some shortcuts\n\nmod = 1000000007\n\n\ndef testcase(t):\n    for p in range(t):\n        solve()\n\n\ndef pow(A, B, p):\n    res = 1  # Initialize result\n    A = A % p  # Update A if it is more , than or equal to p\n    if (A == 0):\n        return 0\n    while (B > 0):\n        if ((B & 1) == 1):  # If B is odd, multiply, A with result\n            res = (res * A) % p\n\n        B = B >> 1  # B = B/2\n        A = (A * A) % p\n    return res\n\n\nfrom functools import reduce\n\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([start, n // start] for start in range(1, int(n ** 0.5) + 1) if n % start == 0)))\n\n\ndef gcd(a, b):\n    if a == b: return a\n    while b > 0: a, b = b, a % b\n    return a\n\n\n# discrete binary search\n# minimise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for start in range(200):\n#         if isvalid(l):\n#             return l\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m - 1):\n#             return m\n#         if isvalid(m):\n#             r = m + 1\n#         else:\n#             l = m\n#     return m\n\n# maximise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for start in range(200):\n#         # print(l,r)\n#         if isvalid(r):\n#             return r\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m + 1):\n#             return m\n#         if isvalid(m):\n#             l = m\n#         else:\n#             r = m - 1\n#     return m\n\n\n##############Find sum of product of subsets of size k in a array\n# ar=[0,1,2,3]\n# k=3\n# n=len(ar)-1\n# dp=[0]*(n+1)\n# dp[0]=1\n# for pos in range(1,n+1):\n#     dp[pos]=0\n#     l=max(1,k+pos-n-1)\n#     for j in range(min(pos,k),l-1,-1):\n#         dp[j]=dp[j]+ar[pos]*dp[j-1]\n# print(dp[k])\n\ndef prefix_sum(ar):  # [1,2,3,4]->[1,3,6,10]\n    return list(accumulate(ar))\n\n\ndef suffix_sum(ar):  # [1,2,3,4]->[10,9,7,4]\n    return list(accumulate(ar[::-1]))[::-1]\n\n\ndef N():\n    return int(inp())\n\n\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\n\ndef YES():\n    print(\"YES\")\n\n\ndef NO():\n    print(\"NO\")\n\n\ndef Yes():\n    print(\"Yes\")\n\n\ndef No():\n    print(\"No\")\n\n\n# =========================================================================================\nfrom collections import defaultdict\n\n\ndef numberOfSetBits(start):\n    start = start - ((start >> 1) & 0x55555555)\n    start = (start & 0x33333333) + ((start >> 2) & 0x33333333)\n    return (((start + (start >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        # self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        # self.lista[a] += self.lista[b]\n        # self.lista[b] = []\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef lcm(a, b):\n    return abs((a // gcd(a, b)) * b)\n\n\n# #\n# to find factorial and ncr\n# tot = 100005\n# mod = 10**9 + 7\n# fac = [1, 1]\n# finv = [1, 1]\n# inv = [0, 1]\n#\n# for start in range(2, tot + 1):\n#     fac.append((fac[-1] * start) % mod)\n#     inv.append(mod - (inv[mod % start] * (mod // start) % mod))\n#     finv.append(finv[-1] * inv[-1] % mod)\n\n\ndef comb(n, r):\n    if n < r:\n        return 0\n    else:\n        return fac[n] * (finv[r] * finv[n - r] % mod) % mod\n\n\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\")  # for fast input\n\n\ndef out(var): sys.stdout.write(str(var))  # for fast output, always take string\n\n\ndef lis(): return list(map(int, inp().split()))\n\n\ndef stringlis(): return list(map(str, inp().split()))\n\n\ndef sep(): return map(int, inp().split())\n\n\ndef strsep(): return map(str, inp().split())\n\n\ndef fsep(): return map(float, inp().split())\n\n\ndef nextline(): out(\"\\n\")  # as stdout.write always print sring.\n\n\ndef arr1d(n, v):\n    return [v] * n\n\n\ndef arr2d(n, m, v):\n    return [[v] * m for _ in range(n)]\n\n\ndef arr3d(n, m, p, v):\n    return [[[v] * p for _ in range(m)] for start in range(n)]\n\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\n\n# co-ordinate compression\n# ma={s:idx for idx,s in enumerate(sorted(set(l+r)))}\n\n# mxn=100005\n# lrg=[0]*mxn\n# for start in range(2,mxn-3):\n#     if (lrg[start]==0):\n#         for j in range(start,mxn-3,start):\n#             lrg[j]=start\n\n\ndef solve():\n    n=N()\n    r=lis()\n    c=lis()\n    points=[]\n    for i in range(n):\n        points.append((r[i],c[i]))\n    points.append((1,1))\n    points.sort()\n    ans=0\n    n+=1\n    for i in range(n-1):\n        x,y=points[i]\n        nx,ny=points[i+1]\n        plus1=ny-y\n        same=nx-x-plus1\n        # print(same,plus1,\"h\")\n        if((x+y) %2 ==1):\n            o=1\n        else:\n            o=0\n        if(plus1==0):\n            if(o):\n                ans+= same//2\n                ans+=same%2\n                continue\n            else:\n                same-=1\n                ans += same // 2\n                ans += same % 2\n                continue\n\n        if(same==0):\n            if(o):\n                ans+=0\n                continue\n            else:\n                ans+=plus1\n                continue\n\n\n        if (o):\n            ans += same // 2\n            ans += same % 2\n            continue\n        else:\n            same-=1\n            ans += same // 2\n            ans += same % 2\n            continue\n    print(ans)\n\n\n\n\n\n\n\n\n# solve()\ntestcase(N())",
        "correct": true,
        "task_id": "0137",
        "depth": 1
    },
    {
        "description": "Everything got unclear to us in a far away constellation Tau Ceti. Specifically, the Taucetians choose names to their children in a very peculiar manner.\n\nTwo young parents abac and bbad think what name to give to their first-born child. They decided that the name will be the permutation of letters of string s. To keep up with the neighbours, they decided to call the baby so that the name was lexicographically strictly larger than the neighbour's son's name t.\n\nOn the other hand, they suspect that a name tax will be introduced shortly. According to it, the Taucetians with lexicographically larger names will pay larger taxes. That's the reason abac and bbad want to call the newborn so that the name was lexicographically strictly larger than name t and lexicographically minimum at that.\n\nThe lexicographical order of strings is the order we are all used to, the \"dictionary\" order. Such comparison is used in all modern programming languages to compare strings. Formally, a string p of length n is lexicographically less than string q of length m, if one of the two statements is correct:\n\n  * n < m, and p is the beginning (prefix) of string q (for example, \"aba\" is less than string \"abaa\"), \n  * p1 = q1, p2 = q2, ..., pk - 1 = qk - 1, pk < qk for some k (1 \u2264 k \u2264 min(n, m)), here characters in strings are numbered starting from 1. \n\n\n\nWrite a program that, given string s and the heighbours' child's name t determines the string that is the result of permutation of letters in s. The string should be lexicographically strictly more than t and also, lexicographically minimum.\n\nInput\n\nThe first line contains a non-empty string s (1 \u2264 |s| \u2264 5000), where |s| is its length. The second line contains a non-empty string t (1 \u2264 |t| \u2264 5000), where |t| is its length. Both strings consist of lowercase Latin letters.\n\nOutput\n\nPrint the sought name or -1 if it doesn't exist.\n\nExamples\n\nInput\n\naad\naac\n\n\nOutput\n\naad\n\n\nInput\n\nabad\nbob\n\n\nOutput\n\ndaab\n\n\nInput\n\nabc\ndefg\n\n\nOutput\n\n-1\n\n\nInput\n\nczaaab\nabcdef\n\n\nOutput\n\nabczaa\n\nNote\n\nIn the first sample the given string s is the sought one, consequently, we do not need to change the letter order there.",
        "task_name": "180_D. Name",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def solve():\n    s = list(raw_input())\n    t = list(raw_input())\n    scount = [0]*26\n    tcount = [0]*26\n    for char in s: scount[ord(char) - ord('a')]+=1\n    for char in t: tcount[ord(char) - ord('a')]+=1\n    allgreater = True\n    for i in range(26): \n        if scount[i] < tcount[i]:\n            allgreater = False\n    if allgreater:\n        if len(s) == len(t): return -1\n        for char in t: scount[ord(char) - ord('a')]-=1\n        for i in range(26): \n            while scount[i] > 0:\n                t.append(chr(i + ord('a')))\n                scount[i] -= 1\n        return ''.join(map(str, t))\n    works = -1\n    scountcopy = list(scount)\n    for i in range(len(s)):\n        cando = False\n        for j in range(ord(t[i]) - ord('a') + 1, 26): \n            if scountcopy[j] > 0:\n                cando = True\n        if cando:\n            works = i\n        if scountcopy[ord(t[i]) - ord('a')] == 0: break\n        scountcopy[ord(t[i]) - ord('a')] -= 1    \n    if works == -1: return -1\n    res = list()\n    for i in range(works):\n        res.append(t[i])\n        scount[ord(t[i]) - ord('a')] -= 1\n#     print(works)\n    for j in range(ord(t[works]) - ord('a') + 1, 26): \n        if scount[j] > 0:\n            res.append(chr(j + ord('a')))\n            scount[j]-=1\n            break\n#     print(res)\n    for i in range(26): \n        while scount[i] > 0:\n            res.append(chr(i + ord('a')))\n            scount[i] -= 1\n    return ''.join(map(str, res))\n        \nprint(solve())",
        "correct": false,
        "task_id": "0138",
        "depth": 2
    },
    {
        "description": "Two little greedy bears have found two pieces of cheese in the forest of weight a and b grams, correspondingly. The bears are so greedy that they are ready to fight for the larger piece. That's where the fox comes in and starts the dialog: \"Little bears, wait a little, I want to make your pieces equal\" \"Come off it fox, how are you going to do that?\", the curious bears asked. \"It's easy\", said the fox. \"If the mass of a certain piece is divisible by two, then I can eat exactly a half of the piece. If the mass of a certain piece is divisible by three, then I can eat exactly two-thirds, and if the mass is divisible by five, then I can eat four-fifths. I'll eat a little here and there and make the pieces equal\". \n\nThe little bears realize that the fox's proposal contains a catch. But at the same time they realize that they can not make the two pieces equal themselves. So they agreed to her proposal, but on one condition: the fox should make the pieces equal as quickly as possible. Find the minimum number of operations the fox needs to make pieces equal.\n\nInput\n\nThe first line contains two space-separated integers a and b (1 \u2264 a, b \u2264 109). \n\nOutput\n\nIf the fox is lying to the little bears and it is impossible to make the pieces equal, print -1. Otherwise, print the required minimum number of operations. If the pieces of the cheese are initially equal, the required number is 0.\n\nExamples\n\nInput\n\n15 20\n\n\nOutput\n\n3\n\n\nInput\n\n14 8\n\n\nOutput\n\n-1\n\n\nInput\n\n6 6\n\n\nOutput\n\n0",
        "task_name": "371_B. Fox Dividing Cheese",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from fractions import gcd\na, b = (int(s) for s in raw_input().split())\ng = gcd(a, b)\na /= g\nb /= g\n\ndef ope(n):\n    res = 0\n    div = [2, 3, 5]\n    for d in div:\n        while n % d == 0:\n            n /= d\n            res += 1\n    return (n, res)\n\na, x = ope(a)\nb, y = ope(b)\nif a != b:\n    print(-1)\nelse:\n    print(x + y)\n",
        "correct": true,
        "task_id": "0142",
        "depth": 2
    },
    {
        "description": "Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings a and b of equal length are called equivalent in one of the two cases: \n\n  1. They are equal. \n  2. If we split string a into two halves of the same size a1 and a2, and string b into two halves of the same size b1 and b2, then one of the following is correct: \n    1. a1 is equivalent to b1, and a2 is equivalent to b2\n    2. a1 is equivalent to b2, and a2 is equivalent to b1\n\n\n\nAs a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.\n\nGerald has already completed this home task. Now it's your turn!\n\nInput\n\nThe first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200 000 and consists of lowercase English letters. The strings have the same length.\n\nOutput\n\nPrint \"YES\" (without the quotes), if these two strings are equivalent, and \"NO\" (without the quotes) otherwise.\n\nExamples\n\nInput\n\naaba\nabaa\n\n\nOutput\n\nYES\n\n\nInput\n\naabb\nabab\n\n\nOutput\n\nNO\n\nNote\n\nIn the first sample you should split the first string into strings \"aa\" and \"ba\", the second one \u2014 into strings \"ab\" and \"aa\". \"aa\" is equivalent to \"aa\"; \"ab\" is equivalent to \"ba\" as \"ab\" = \"a\" + \"b\", \"ba\" = \"b\" + \"a\".\n\nIn the second sample the first string can be splitted into strings \"aa\" and \"bb\", that are equivalent only to themselves. That's why string \"aabb\" is equivalent only to itself and to string \"bbaa\".",
        "task_name": "560_D. Equivalent Strings",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "prime = 2**32 -1\nenglish_base = 30;\n\n\nclass Hasher(object):\n    def __init__(self, word, modulo = prime):\n        self.word = word\n        self.modulo = modulo\n        self.h = self.compute_hashes(self.word)\n        self.powers = self.compute_power(len(self.word))\n\n    def substring_hash(self, i, j):\n        result = self.h[j] - self.h[i] * self.powers[j-i]\n        return result % self.modulo\n\n    \n    def compute_hashes(self, word, base=english_base, modulo=prime):\n        h = [None for _ in range(len(word) + 1)]\n        h[0] = 0\n        for i in range(len(word)):\n            letter_as_number = (ord(word[i]) - ord('a') + 1)\n            h[i + 1] = h[i] * base + letter_as_number\n            h[i + 1] %= modulo\n        return h\n\n\n    def compute_power(self, n, base=english_base, modulo=prime):\n        powers = [None for _ in range(n+1)]\n        powers[0] = 1\n        for i in range(n):\n            powers[i+1] = (powers[i] * base) % modulo\n        return powers\n    \n\ndef splitter(text1, text2, i1, j1, i2, j2, hash1, hash2):\n    mid1 = int((j1+i1)/2)\n    mid2 = int((j2+i2)/2)\n    if (j1-i1)%4 != 0 or (j1-i1)==2:\n        a1 = hash1.substring_hash(i1,mid1)\n        a2 = hash1.substring_hash(mid1,j1)\n        b1 = hash2.substring_hash(i2,mid2)\n        b2 = hash2.substring_hash(mid2,j2)\n        if a1 == b1:\n            return a2 == b2\n        elif a2 == b1:\n            return a1 == b2\n        return False\n    return (splitter(text1, text2, i1, mid1, i2, mid2, hash1, hash2) and splitter(text1, text2, mid1, j1, mid2, j2, hash1, hash2)) or (splitter(text1, text2, i1, mid1, mid2, j2, hash1, hash2) and splitter(text1, text2, mid1, j1, i2, mid2, hash1, hash2))\n\ndef equivalent_substrings(text1, text2):\n    hash1 = Hasher(text1)\n    hash2 = Hasher(text2)\n\n    return splitter(text1, text2, 0, len(text1), 0, len(text2), hash1, hash2)\n\n\ndef main():\n    s1 = raw_input();\n    s2 = raw_input();\n    print(equivalent_substrings(s1,s2))\n\n\nif __name__=='__main__':\n    main()\n",
        "correct": false,
        "task_id": "0145",
        "depth": 1
    },
    {
        "description": "You are given a set of points on a straight line. Each point has a color assigned to it. For point a, its neighbors are the points which don't have any other points between them and a. Each point has at most two neighbors - one from the left and one from the right.\n\nYou perform a sequence of operations on this set of points. In one operation, you delete all points which have a neighbor point of a different color than the point itself. Points are deleted simultaneously, i.e. first you decide which points have to be deleted and then delete them. After that you can perform the next operation etc. If an operation would not delete any points, you can't perform it.\n\nHow many operations will you need to perform until the next operation does not have any points to delete?\n\nInput\n\nInput contains a single string of lowercase English letters 'a'-'z'. The letters give the points' colors in the order in which they are arranged on the line: the first letter gives the color of the leftmost point, the second gives the color of the second point from the left etc.\n\nThe number of the points is between 1 and 106.\n\nOutput\n\nOutput one line containing an integer - the number of operations which can be performed on the given set of points until there are no more points to delete.\n\nExamples\n\nInput\n\naabb\n\n\nOutput\n\n2\n\n\nInput\n\naabcaa\n\n\nOutput\n\n1\n\nNote\n\nIn the first test case, the first operation will delete two middle points and leave points \"ab\", which will be deleted with the second operation. There will be no points left to apply the third operation to.\n\nIn the second test case, the first operation will delete the four points in the middle, leaving points \"aa\". None of them have neighbors of other colors, so the second operation can't be applied.",
        "task_name": "909_D. Colorful Points",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "s=raw_input()\na=[[s[0],1]]\nfor i in s[1:]:\n    if(a[-1][0]==i):\n        a[-1][1]+=1\n    else:\n        a.append([i,1])\nturns=0\nwhile((len(a)>1)):\n    turns+=1\n    temp=[]\n    if(a[0][1]>1):\n        temp.append([a[0][0],a[0][1]-1])\n    for i in a[1:-1]:\n        if(i[1]>2):\n            temp.append([i[0],i[1]-2])\n    if(a[-1][1]>1):\n        temp.append([a[-1][0],a[-1][1]-1])\n    if(len(temp)<2):\n        break\n    a=[temp[0],]\n    for i in temp[1:]:\n        if(i[0]!=a[-1][0]):\n            a.append(i)\n        else:\n            a[-1][1]+=i[1]\nprint(turns)",
        "correct": true,
        "task_id": "0150",
        "depth": 2
    },
    {
        "description": "One day, Taro received a strange email with only the number \"519345213244\" in the text. The email was from my cousin, who was 10 years older than me, so when I called and asked, \"Oh, I sent it with a pocket bell because I was in a hurry. It's convenient. Nice to meet you!\" I got it. You know this cousin, who is always busy and a little bit aggressive, and when you have no choice but to research \"pager hitting\" yourself, you can see that it is a method of input that prevailed in the world about 10 years ago. I understand.\n\nIn \"Pokebell Strike\", enter one character with two numbers, such as 11 for \"A\" and 15 for \"O\" according to the conversion table shown in Fig. 1. For example, to enter the string \"Naruto\", type \"519345\". Therefore, any letter can be entered with two numbers.\n\n<image>\n\nFigure 1\n\nWhen mobile phones weren't widespread, high school students used this method to send messages from payphones to their friends' pagers. Some high school girls were able to pager at a tremendous speed. Recently, my cousin, who has been busy with work, has unknowingly started typing emails with a pager.\n\nTherefore, in order to help Taro who is having a hard time deciphering every time, please write a program that converts the pager message into a character string and outputs it. However, the conversion table shown in Fig. 2 is used for conversion, and only lowercase letters, \".\", \"?\", \"!\", And blanks are targeted. Output NA for messages that contain characters that cannot be converted.\n\n<image>\n\nFigure 2\n\n\n\nInput\n\nMultiple messages are given. One message (up to 200 characters) is given on each line. The total number of messages does not exceed 50.\n\nOutput\n\nFor each message, output the converted message or NA on one line.\n\nExample\n\nInput\n\n341143514535\n314\n143565553551655311343411652235654535651124615163\n551544654451431564\n4\n3411\n6363636363\n153414\n\n\nOutput\n\nnaruto\nNA\ndo you wanna go to aizu?\nyes sure!\nNA\nna\n?????\nend",
        "task_name": "p00127 Pocket Pager Input",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdout\n\ncs = {\n    1: [None] + list(\"abcde\"),\n    2: [None] + list(\"fghij\"),\n    3: [None] + list(\"klmno\"),\n    4: [None] + list(\"pqrst\"),\n    5: [None] + list(\"uvwxy\"),\n    6: [None] + list(\"z.?! \"),\n}\n\nwhile True:\n    try:\n        it = iter(raw_input().strip())\n    except ValueError:\n        break\n\n    try:\n        r = c = None\n        s = []\n        while True:\n            r = int(it.next())\n            c = int(it.next())\n            s += [cs[r][c]]\n            r = c = None\n    except IndexError:\n        stdout.write(\"NA\\n\")\n    except StopIteration:\n        if not r and not c:\n            stdout.write(''.join(s) + \"\\n\")\n        else:\n            stdout.write(\"NA\\n\")\n        continue",
        "correct": false,
        "task_id": "0161",
        "depth": 2
    },
    {
        "description": "Dark is going to attend Motarack's birthday. Dark decided that the gift he is going to give to Motarack is an array a of n non-negative integers.\n\nDark created that array 1000 years ago, so some elements in that array disappeared. Dark knows that Motarack hates to see an array that has two adjacent elements with a high absolute difference between them. He doesn't have much time so he wants to choose an integer k (0 \u2264 k \u2264 10^{9}) and replaces all missing elements in the array a with k.\n\nLet m be the maximum absolute difference between all adjacent elements (i.e. the maximum value of |a_i - a_{i+1}| for all 1 \u2264 i \u2264 n - 1) in the array a after Dark replaces all missing elements with k.\n\nDark should choose an integer k so that m is minimized. Can you help him?\n\nInput\n\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 10^{5}) \u2014 the size of the array a.\n\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (-1 \u2264 a_i \u2264 10 ^ {9}). If a_i = -1, then the i-th integer is missing. It is guaranteed that at least one integer is missing in every test case.\n\nIt is guaranteed, that the sum of n for all test cases does not exceed 4 \u22c5 10 ^ {5}.\n\nOutput\n\nPrint the answers for each test case in the following format:\n\nYou should print two integers, the minimum possible value of m and an integer k (0 \u2264 k \u2264 10^{9}) that makes the maximum absolute difference between adjacent elements in the array a equal to m.\n\nMake sure that after replacing all the missing elements with k, the maximum absolute difference between adjacent elements becomes m.\n\nIf there is more than one possible k, you can print any of them.\n\nExample\n\nInput\n\n\n7\n5\n-1 10 -1 12 -1\n5\n-1 40 35 -1 35\n6\n-1 -1 9 -1 3 -1\n2\n-1 -1\n2\n0 -1\n4\n1 -1 3 -1\n7\n1 -1 7 5 2 -1 5\n\n\nOutput\n\n\n1 11\n5 35\n3 6\n0 42\n0 0\n1 2\n3 4\n\nNote\n\nIn the first test case after replacing all missing elements with 11 the array becomes [11, 10, 11, 12, 11]. The absolute difference between any adjacent elements is 1. It is impossible to choose a value of k, such that the absolute difference between any adjacent element will be \u2264 0. So, the answer is 1.\n\nIn the third test case after replacing all missing elements with 6 the array becomes [6, 6, 9, 6, 3, 6].\n\n  * |a_1 - a_2| = |6 - 6| = 0; \n  * |a_2 - a_3| = |6 - 9| = 3; \n  * |a_3 - a_4| = |9 - 6| = 3; \n  * |a_4 - a_5| = |6 - 3| = 3; \n  * |a_5 - a_6| = |3 - 6| = 3. \n\n\n\nSo, the maximum difference between any adjacent elements is 3.",
        "task_name": "1301_B. Motarack's Birthday",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        l1 = list(map(int, input().split()))\n        temp = 0\n        count = 0\n        mini = -1\n        maxi = -1\n        for i in range(n):\n            flag = 0\n            if l1[i]==-1:\n                continue\n            if i>0 and l1[i-1] == -1:\n                flag = 1\n            if i < n-1 and l1[i+1] == -1:\n                flag = 1\n            if flag==1:\n                if mini==-1:\n                    mini = l1[i]\n                else:\n                    mini = min(mini, l1[i])\n                if maxi==-1:\n                    maxi = l1[i]\n                else:\n                    maxi = max(maxi, l1[i])\n        \n        if mini==-1:\n            k = 0\n        else :\n            k = (maxi+mini)//2\n            \n        m = 0 \n        for i in range(n-1):\n            if l1[i+1]==-1:\n                l1[i+1] = k\n            if l1[i] == -1:\n                l1[i] = k\n            m = max(abs(l1[i+1]-l1[i]), m)\n        print(m, k)\n######## Python 2 and 3 footer by Pajenegod and c1729\n\n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n\n# So on cf, use PyPy2 for best string performance.\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n\n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n\nif __name__== \"__main__\":\n  main()",
        "correct": true,
        "task_id": "0169",
        "depth": 2
    },
    {
        "description": "Hilbert's Hotel is a very unusual hotel since the number of rooms is infinite! In fact, there is exactly one room for every integer, including zero and negative integers. Even stranger, the hotel is currently at full capacity, meaning there is exactly one guest in every room. The hotel's manager, David Hilbert himself, decides he wants to shuffle the guests around because he thinks this will create a vacancy (a room without a guest).\n\nFor any integer k and positive integer n, let kmod n denote the remainder when k is divided by n. More formally, r=kmod n is the smallest non-negative integer such that k-r is divisible by n. It always holds that 0\u2264 kmod n\u2264 n-1. For example, 100mod 12=4 and (-1337)mod 3=1.\n\nThen the shuffling works as follows. There is an array of n integers a_0,a_1,\u2026,a_{n-1}. Then for each integer k, the guest in room k is moved to room number k+a_{kmod n}.\n\nAfter this shuffling process, determine if there is still exactly one guest assigned to each room. That is, there are no vacancies or rooms with multiple guests.\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264 t\u2264 10^4) \u2014 the number of test cases. Next 2t lines contain descriptions of test cases.\n\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 2\u22c5 10^5) \u2014 the length of the array.\n\nThe second line of each test case contains n integers a_0,a_1,\u2026,a_{n-1} (-10^9\u2264 a_i\u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5 10^5.\n\nOutput\n\nFor each test case, output a single line containing \"YES\" if there is exactly one guest assigned to each room after the shuffling process, or \"NO\" otherwise. You can print each letter in any case (upper or lower).\n\nExample\n\nInput\n\n\n6\n1\n14\n2\n1 -1\n4\n5 5 5 1\n3\n3 2 1\n2\n0 1\n5\n-239 -2 -100 -3 -11\n\n\nOutput\n\n\nYES\nYES\nYES\nNO\nNO\nYES\n\nNote\n\nIn the first test case, every guest is shifted by 14 rooms, so the assignment is still unique.\n\nIn the second test case, even guests move to the right by 1 room, and odd guests move to the left by 1 room. We can show that the assignment is still unique.\n\nIn the third test case, every fourth guest moves to the right by 1 room, and the other guests move to the right by 5 rooms. We can show that the assignment is still unique.\n\nIn the fourth test case, guests 0 and 1 are both assigned to room 3.\n\nIn the fifth test case, guests 1 and 2 are both assigned to room 2.",
        "task_name": "1344_A. Hilbert's Hotel",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\ninput = sys.stdin.readline\n\nfor _ in xrange(int(input())):\n    n = int(input())\n    seq = [int(x) for x in input().split()]\n    s = sorted([i+seq[i%n] for i in xrange(2*n)])\n    ans = \"YES\"\n    for i in xrange(1,len(s)):\n        if s[i] == s[i-1]:\n            ans = \"NO\"\n            break\n    print(ans)\n        \n        \n",
        "correct": false,
        "task_id": "0171",
        "depth": 2
    },
    {
        "description": "Polycarp plays a well-known computer game (we won't mention its name). In this game, he can craft tools of two types \u2014 shovels and swords. To craft a shovel, Polycarp spends two sticks and one diamond; to craft a sword, Polycarp spends two diamonds and one stick.\n\nEach tool can be sold for exactly one emerald. How many emeralds can Polycarp earn, if he has a sticks and b diamonds?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe only line of each test case contains two integers a and b (0 \u2264 a, b \u2264 10^9) \u2014 the number of sticks and the number of diamonds, respectively.\n\nOutput\n\nFor each test case print one integer \u2014 the maximum number of emeralds Polycarp can earn.\n\nExample\n\nInput\n\n\n4\n4 4\n1000000000 0\n7 15\n8 7\n\n\nOutput\n\n\n2\n0\n7\n5\n\nNote\n\nIn the first test case Polycarp can earn two emeralds as follows: craft one sword and one shovel.\n\nIn the second test case Polycarp does not have any diamonds, so he cannot craft anything.",
        "task_name": "1366_A. Shovels and Swords",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n\nMOD = 998244353\nmod = 10**9 + 7\n\n# import resource\n# resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n\ndef prepare_factorial():\n    fact = [1]\n    for i in range(1, 20):\n        fact.append((fact[-1] * i) % mod)\n    ifact = [0] * 105\n    ifact[104] = pow(fact[104], mod - 2, mod)\n    for i in range(104, 0, -1):\n        ifact[i - 1] = (i * ifact[i]) % mod\n\n    return fact, ifact\n\n# import threading\n# threading.stack_size(1<<27)\nimport sys\n# sys.setrecursionlimit(10000)\n\nfrom bisect import bisect_left, bisect_right, insort\nfrom math import floor, ceil, sqrt, degrees, atan, pi, log, sin, radians, factorial\nfrom heapq import heappop, heapify, heappush\nfrom collections import Counter, defaultdict, deque\n# from itertools import permutations\n\n\ndef modinv(n, p):\n    return pow(n, p - 2, p)\n\ndef ncr(n, r, fact, ifact):    # for using this uncomment the lines calculating fact and ifact\n    t = (fact[n] * (ifact[r] * ifact[n-r]) % mod) % mod\n    return t\n\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\n\n\"\"\"*****************************************************************************************\"\"\"\n\ndef GCD(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x * y)//(GCD(x, y))\n\ndef get_xor(n):\n    return [n, 1, n+1, 0][n % 4]\n\ndef get_n(P):    # this function returns the maximum n for which Summation(n) <= Sum\n    ans = (-1 + sqrt(1 + 8*P))//2\n    return ans\n\n\"\"\" ********************************************************************************************* \"\"\"\n\ndef main():\n\n    for _ in range(int(input())):\n        l, r = get_ints()\n        print(min(l, r, (l + r) // 3))\n\n\n\"\"\" -------- Python 2 and 3 footer by Pajenegod and c1729 ---------\"\"\"\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill();\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode('ascii'))\n            self.read = lambda: self.buffer.read().decode('ascii')\n            self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\nif __name__ == '__main__':\n    main()\n    # threading.Thread(target=main).start()\n\t  \t \t\t\t \t\t\t   \t\t\t\t \t \t\t\t \t\t\t",
        "correct": true,
        "task_id": "0172",
        "depth": 1
    },
    {
        "description": "To improve the boomerang throwing skills of the animals, Zookeeper has set up an n \u00d7 n grid with some targets, where each row and each column has at most 2 targets each. The rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to n from left to right. \n\nFor each column, Zookeeper will throw a boomerang from the bottom of the column (below the grid) upwards. When the boomerang hits any target, it will bounce off, make a 90 degree turn to the right and fly off in a straight line in its new direction. The boomerang can hit multiple targets and does not stop until it leaves the grid.\n\n<image>\n\nIn the above example, n=6 and the black crosses are the targets. The boomerang in column 1 (blue arrows) bounces 2 times while the boomerang in column 3 (red arrows) bounces 3 times.\n\nThe boomerang in column i hits exactly a_i targets before flying out of the grid. It is known that a_i \u2264 3.\n\nHowever, Zookeeper has lost the original positions of the targets. Thus, he asks you to construct a valid configuration of targets that matches the number of hits for each column, or tell him that no such configuration exists. If multiple valid configurations exist, you may print any of them.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 10^5).\n\nThe next line contains n integers a_1,a_2,\u2026,a_n (0 \u2264 a_i \u2264 3).\n\nOutput\n\nIf no configuration of targets exist, print -1.\n\nOtherwise, on the first line print a single integer t (0 \u2264 t \u2264 2n): the number of targets in your configuration. \n\nThen print t lines with two spaced integers each per line. Each line should contain two integers r and c (1 \u2264 r,c \u2264 n), where r is the target's row and c is the target's column. All targets should be different. \n\nEvery row and every column in your configuration should have at most two targets each.\n\nExamples\n\nInput\n\n\n6\n2 0 3 0 1 1\n\n\nOutput\n\n\n5\n2 1\n2 5\n3 3\n3 6\n5 6\n\n\nInput\n\n\n1\n0\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n6\n3 2 2 2 1 1\n\n\nOutput\n\n\n-1\n\nNote\n\nFor the first test, the answer configuration is the same as in the picture from the statement.\n\nFor the second test, the boomerang is not supposed to hit anything, so we can place 0 targets.\n\nFor the third test, the following configuration of targets matches the number of hits, but is not allowed as row 3 has 4 targets.\n\n<image>\n\nIt can be shown for this test case that no valid configuration of targets will result in the given number of target hits.",
        "task_name": "1428_D. Bouncing Boomerangs",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nfrom collections import deque, defaultdict, Counter\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nout = []\n\nn, a = int(input()), rints()\nmem, cols, rows = defaultdict(deque), n, n\n\nmem2 = [0] * (n + 1)\nfor i in range(n - 1, -1, -1):\n    if a[i] == 1:\n        out.append('%d %d' % (rows, i + 1))\n        if rows < 1:\n            print(-1)\n            exit()\n\n        rows -= 1\n        mem[1].append([rows + 1, i + 1])\n\n    elif a[i] == 2:\n        if mem[1]:\n            out.append('%d %d' % (mem[1][0][0], i + 1))\n        else:\n            print(-1)\n            exit()\n\n        mem[1].popleft()\n        mem[2].append(i + 1)\n\n\n    elif a[i] == 3:\n        if mem[3]:\n            out.append('%d %d' % (rows, i + 1))\n            out.append('%d %d' % (rows, mem[3][0]))\n\n            if rows < 1:\n                print(-1)\n                exit()\n\n            rows -= 1\n            mem[3].popleft()\n\n        elif mem[2]:\n            out.append('%d %d' % (rows, i + 1))\n            out.append('%d %d' % (rows, mem[2][0]))\n\n            if rows < 1:\n                print(-1)\n                exit()\n\n            rows -= 1\n            mem[2].popleft()\n\n        elif mem[1]:\n            out.append('%d %d' % (rows, i + 1))\n            out.append('%d %d' % (rows, mem[1][0][1]))\n\n            if rows < 1:\n                print(-1)\n                exit()\n\n            rows -= 1\n            mem[1].popleft()\n        else:\n            print(-1)\n            exit()\n        mem[3].append(i + 1)\n\nprint('%d\\n%s' % (len(out), '\\n'.join(out)))\n",
        "correct": true,
        "task_id": "0174",
        "depth": 1
    },
    {
        "description": "Utkarsh is forced to play yet another one of Ashish's games. The game progresses turn by turn and as usual, Ashish moves first.\n\nConsider the 2D plane. There is a token which is initially at (0,0). In one move a player must increase either the x coordinate or the y coordinate of the token by exactly k. In doing so, the player must ensure that the token stays within a (Euclidean) distance d from (0,0).\n\nIn other words, if after a move the coordinates of the token are (p,q), then p^2 + q^2 \u2264 d^2 must hold.\n\nThe game ends when a player is unable to make a move. It can be shown that the game will end in a finite number of moves. If both players play optimally, determine who will win.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases.\n\nThe only line of each test case contains two space separated integers d (1 \u2264 d \u2264 10^5) and k (1 \u2264 k \u2264 d).\n\nOutput\n\nFor each test case, if Ashish wins the game, print \"Ashish\", otherwise print \"Utkarsh\" (without the quotes).\n\nExample\n\nInput\n\n\n5\n2 1\n5 2\n10 3\n25 4\n15441 33\n\n\nOutput\n\n\nUtkarsh\nAshish\nUtkarsh\nUtkarsh\nAshish\n\nNote\n\nIn the first test case, one possible sequence of moves can be\n\n(0, 0) \\xrightarrow{Ashish } (0, 1) \\xrightarrow{Utkarsh } (0, 2).\n\nAshish has no moves left, so Utkarsh wins.\n\n<image>",
        "task_name": "1451_D. Circle Game",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division,print_function\nfrom heapq import*\nimport sys\nfrom math import*\n\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\naf = []\nfor i in range(int(le.pop())):\n    d,k=list(map(int,le.pop().split()))\n    a=floor(d/(k*2**0.5))\n    #print(a,d,k)\n    if (a*k)**2+(k*(a+1))**2>d**2:\n        af.append('Utkarsh')\n    else:\n        while (a*k)**2+(k*(a+2))**2>d**2 and a>0:\n            a-=1\n        if ((a+1)*k)**2+(k*(a+2))**2>d**2:\n            #print(\"couc\")\n            af.append('Utkarsh')\n        else:\n            af.append(\"Ashish\")\nprint(\"\\n\".join(map(str,af)))\n",
        "correct": false,
        "task_id": "0175",
        "depth": 2
    },
    {
        "description": "Kevin Sun has just finished competing in Codeforces Round #334! The round was 120 minutes long and featured five problems with maximum point values of 500, 1000, 1500, 2000, and 2500, respectively. Despite the challenging tasks, Kevin was uncowed and bulldozed through all of them, distinguishing himself from the herd as the best cowmputer scientist in all of Bovinia. Kevin knows his submission time for each problem, the number of wrong submissions that he made on each problem, and his total numbers of successful and unsuccessful hacks. Because Codeforces scoring is complicated, Kevin wants you to write a program to compute his final score.\n\nCodeforces scores are computed as follows: If the maximum point value of a problem is x, and Kevin submitted correctly at minute m but made w wrong submissions, then his score on that problem is <image>. His total score is equal to the sum of his scores for each problem. In addition, Kevin's total score gets increased by 100 points for each successful hack, but gets decreased by 50 points for each unsuccessful hack.\n\nAll arithmetic operations are performed with absolute precision and no rounding. It is guaranteed that Kevin's final score is an integer.\n\nInput\n\nThe first line of the input contains five space-separated integers m1, m2, m3, m4, m5, where mi (0 \u2264 mi \u2264 119) is the time of Kevin's last submission for problem i. His last submission is always correct and gets accepted.\n\nThe second line contains five space-separated integers w1, w2, w3, w4, w5, where wi (0 \u2264 wi \u2264 10) is Kevin's number of wrong submissions on problem i.\n\nThe last line contains two space-separated integers hs and hu (0 \u2264 hs, hu \u2264 20), denoting the Kevin's numbers of successful and unsuccessful hacks, respectively.\n\nOutput\n\nPrint a single integer, the value of Kevin's final score.\n\nExamples\n\nInput\n\n20 40 60 80 100\n0 1 2 3 4\n1 0\n\n\nOutput\n\n4900\n\n\nInput\n\n119 119 119 119 119\n0 0 0 0 0\n10 0\n\n\nOutput\n\n4930\n\nNote\n\nIn the second sample, Kevin takes 119 minutes on all of the problems. Therefore, he gets <image> of the points on each problem. So his score from solving problems is <image>. Adding in 10\u00b7100 = 1000 points from hacks, his total score becomes 3930 + 1000 = 4930.",
        "task_name": "604_A. Uncowed Forces",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "m = raw_input().split(\" \")\nw = raw_input().split(\" \")\nh = raw_input().split(\" \")\n\nans = 0\n\nfor i in range(5):\n  x = 500*(i+1)\n  m1 = int(m[i])\n  w1 = int(w[i])\n  pts = max(0.3*x, (1 - (m1/250))*x - 50*w1)\n  ans = ans + pts\n\nans = ans + 100*int(h[0])\nans = ans - 50*int(h[1])\n\nprint(ans)\n\n",
        "correct": false,
        "task_id": "0192",
        "depth": 1
    },
    {
        "description": "Andrew and Jerry are playing a game with Harry as the scorekeeper. The game consists of three rounds. In each round, Andrew and Jerry draw randomly without replacement from a jar containing n balls, each labeled with a distinct positive integer. Without looking, they hand their balls to Harry, who awards the point to the player with the larger number and returns the balls to the jar. The winner of the game is the one who wins at least two of the three rounds.\n\nAndrew wins rounds 1 and 2 while Jerry wins round 3, so Andrew wins the game. However, Jerry is unhappy with this system, claiming that he will often lose the match despite having the higher overall total. What is the probability that the sum of the three balls Jerry drew is strictly higher than the sum of the three balls Andrew drew?\n\nInput\n\nThe first line of input contains a single integer n (2 \u2264 n \u2264 2000) \u2014 the number of balls in the jar.\n\nThe second line contains n integers ai (1 \u2264 ai \u2264 5000) \u2014 the number written on the ith ball. It is guaranteed that no two balls have the same number.\n\nOutput\n\nPrint a single real value \u2014 the probability that Jerry has a higher total, given that Andrew wins the first two rounds and Jerry wins the third. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. \n\nNamely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if <image>.\n\nExamples\n\nInput\n\n2\n1 2\n\n\nOutput\n\n0.0000000000\n\n\nInput\n\n3\n1 2 10\n\n\nOutput\n\n0.0740740741\n\nNote\n\nIn the first case, there are only two balls. In the first two rounds, Andrew must have drawn the 2 and Jerry must have drawn the 1, and vice versa in the final round. Thus, Andrew's sum is 5 and Jerry's sum is 4, so Jerry never has a higher total.\n\nIn the second case, each game could've had three outcomes \u2014 10 - 2, 10 - 1, or 2 - 1. Jerry has a higher total if and only if Andrew won 2 - 1 in both of the first two rounds, and Jerry drew the 10 in the last round. This has probability <image>.",
        "task_name": "626_D. Jerry's Protest",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\na = map(int, raw_input().split())\n\nd = [0] * 5000\nfor i in xrange(n):\n    for j in xrange(i+1, n):\n        d[a[j]-a[i]] += 1\n\nc = [0] * 5000\nfor i in xrange(1, 5000):\n    c[i] = c[i-1] + d[i]\n\nans, m = 0.0, float(sum(d))\nfor i in xrange(4999, 0, -1):\n    if d[i] == 0:\n        continue\n    for j in xrange(i):\n        ans += (d[i] / m) * (d[j] / m) * (c[i-j-1] / m)\n\nprint(\"{0:.10f}\".format(ans))\n",
        "correct": false,
        "task_id": "0193",
        "depth": 2
    },
    {
        "description": "Vasya's telephone contains n photos. Photo number 1 is currently opened on the phone. It is allowed to move left and right to the adjacent photo by swiping finger over the screen. If you swipe left from the first photo, you reach photo n. Similarly, by swiping right from the last photo you reach photo 1. It takes a seconds to swipe from photo to adjacent.\n\nFor each photo it is known which orientation is intended for it \u2014 horizontal or vertical. Phone is in the vertical orientation and can't be rotated. It takes b second to change orientation of the photo.\n\nVasya has T seconds to watch photos. He want to watch as many photos as possible. If Vasya opens the photo for the first time, he spends 1 second to notice all details in it. If photo is in the wrong orientation, he spends b seconds on rotating it before watching it. If Vasya has already opened the photo, he just skips it (so he doesn't spend any time for watching it or for changing its orientation). It is not allowed to skip unseen photos.\n\nHelp Vasya find the maximum number of photos he is able to watch during T seconds.\n\nInput\n\nThe first line of the input contains 4 integers n, a, b, T (1 \u2264 n \u2264 5\u00b7105, 1 \u2264 a, b \u2264 1000, 1 \u2264 T \u2264 109) \u2014 the number of photos, time to move from a photo to adjacent, time to change orientation of a photo and time Vasya can spend for watching photo.\n\nSecond line of the input contains a string of length n containing symbols 'w' and 'h'. \n\nIf the i-th position of a string contains 'w', then the photo i should be seen in the horizontal orientation.\n\nIf the i-th position of a string contains 'h', then the photo i should be seen in vertical orientation.\n\nOutput\n\nOutput the only integer, the maximum number of photos Vasya is able to watch during those T seconds.\n\nExamples\n\nInput\n\n4 2 3 10\nwwhw\n\n\nOutput\n\n2\n\n\nInput\n\n5 2 4 13\nhhwhh\n\n\nOutput\n\n4\n\n\nInput\n\n5 2 4 1000\nhhwhh\n\n\nOutput\n\n5\n\n\nInput\n\n3 1 100 10\nwhw\n\n\nOutput\n\n0\n\nNote\n\nIn the first sample test you can rotate the first photo (3 seconds), watch the first photo (1 seconds), move left (2 second), rotate fourth photo (3 seconds), watch fourth photo (1 second). The whole process takes exactly 10 seconds.\n\nNote that in the last sample test the time is not enough even to watch the first photo, also you can't skip it.",
        "task_name": "650_B. Image Preview",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, a, b, t = map(int, raw_input().split())\ncosts = [ 1 if ch == 'h' else b + 1 for ch in raw_input().strip() ]\nbest = 0\n\nleft_t = -a\nleft_pos = n\nwhile True:\n  left_pos -= 1\n  if left_pos == -1 or left_t + a + costs[left_pos] > t:\n    left_pos += 1\n    break\n  left_t += a + costs[left_pos]\nright_t = -a\nright_pos = -1\nwhile True:\n  right_pos += 1\n  if right_pos == n or right_t + a + costs[right_pos] > t:\n    break\n  right_t += a + costs[right_pos]\n  left_t += a\n  while left_pos != n and right_t + left_t > t:\n    left_t -= a + costs[left_pos]\n    left_pos += 1\n  best = max(best, 1 + right_pos + n - left_pos)\n\nbest = min(n, best)    \nprint(best)\n",
        "correct": false,
        "task_id": "0194",
        "depth": 2
    },
    {
        "description": "Let's denote a function \n\n<image>\n\nYou are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 \u2264 i \u2264 j \u2264 n.\n\nInput\n\nThe first line contains one integer n (1 \u2264 n \u2264 200000) \u2014 the number of elements in a.\n\nThe second line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 109) \u2014 elements of the array. \n\nOutput\n\nPrint one integer \u2014 the sum of d(ai, aj) over all pairs (i, j) such that 1 \u2264 i \u2264 j \u2264 n.\n\nExamples\n\nInput\n\n5\n1 2 3 1 3\n\n\nOutput\n\n4\n\n\nInput\n\n4\n6 6 5 5\n\n\nOutput\n\n0\n\n\nInput\n\n4\n6 6 4 4\n\n\nOutput\n\n-8\n\nNote\n\nIn the first example:\n\n  1. d(a1, a2) = 0; \n  2. d(a1, a3) = 2; \n  3. d(a1, a4) = 0; \n  4. d(a1, a5) = 2; \n  5. d(a2, a3) = 0; \n  6. d(a2, a4) = 0; \n  7. d(a2, a5) = 0; \n  8. d(a3, a4) = - 2; \n  9. d(a3, a5) = 0; \n  10. d(a4, a5) = 2. ",
        "task_name": "903_D. Almost Difference",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\na = list(map(int, raw_input().split()))\nsm = 0\nm = dict()\nans = 0\nfor i in range(n-1, -1, -1):\n    cnt = 0\n    diff = 0\n    if a[i] in m:\n        cnt += m[a[i]]\n        diff += a[i]*m[a[i]]\n    if a[i]+1 in m:\n        cnt += m[a[i]+1]\n        diff += (a[i]+1)*m[a[i]+1]\n    if a[i]-1 in m:\n        cnt += m[a[i]-1]\n        diff += (a[i]-1)*m[a[i]-1]\n    ans += sm-diff-a[i]*(n-i-1-cnt)\n    sm += a[i]\n    if a[i] in m:\n        m[a[i]] += 1\n    else:\n        m[a[i]] = 1\nprint(ans)\n",
        "correct": true,
        "task_id": "0200",
        "depth": 1
    },
    {
        "description": "The nation of Panel holds an annual show called The Number Games, where each district in the nation will be represented by one contestant.\n\nThe nation has n districts numbered from 1 to n, each district has exactly one path connecting it to every other district. The number of fans of a contestant from district i is equal to 2^i.\n\nThis year, the president decided to reduce the costs. He wants to remove k contestants from the games. However, the districts of the removed contestants will be furious and will not allow anyone to cross through their districts. \n\nThe president wants to ensure that all remaining contestants are from districts that can be reached from one another. He also wishes to maximize the total number of fans of the participating contestants.\n\nWhich contestants should the president remove?\n\nInput\n\nThe first line of input contains two integers n and k (1 \u2264 k < n \u2264 10^6) \u2014 the number of districts in Panel, and the number of contestants the president wishes to remove, respectively.\n\nThe next n-1 lines each contains two integers a and b (1 \u2264 a, b \u2264 n, a \u2260 b), that describe a road that connects two different districts a and b in the nation. It is guaranteed that there is exactly one path between every two districts.\n\nOutput\n\nPrint k space-separated integers: the numbers of the districts of which the contestants should be removed, in increasing order of district number.\n\nExamples\n\nInput\n\n6 3\n2 1\n2 6\n4 2\n5 6\n2 3\n\n\nOutput\n\n1 3 4\n\n\nInput\n\n8 4\n2 6\n2 7\n7 8\n1 2\n3 1\n2 4\n7 5\n\n\nOutput\n\n1 3 4 5\n\nNote\n\nIn the first sample, the maximum possible total number of fans is 2^2 + 2^5 + 2^6 = 100. We can achieve it by removing the contestants of the districts 1, 3, and 4.",
        "task_name": "980_E. The Number Games",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n# import time\n\n\ndef calc_result(n, k, edges):\n    # t1 = time.clock()\n\n    storage = [-1] * (4 * n)\n    storage_index = 0\n    lookup = [-1] * (n + 1)\n    for u, v in edges:\n        storage[storage_index] = lookup[u]\n        storage[storage_index + 1] = v\n        lookup[u] = storage_index\n        storage_index += 2\n        storage[storage_index] = lookup[v]\n        storage[storage_index + 1] = u\n        lookup[v] = storage_index\n        storage_index += 2\n\n    # t2 = time.clock()\n\n    nodes = [0] * (2 * (n + 1))\n\n    # t3 = time.clock()\n\n    stack = [n]\n    stack_pop = stack.pop\n    stack_append = stack.append\n    while stack:\n        index = stack_pop()\n        parent_index = nodes[index * 2]\n        t = lookup[index]\n        while t >= 0:\n            v = storage[t + 1]\n            t = storage[t]\n            if v == parent_index:\n                continue\n            nodes[v * 2] = index\n            stack_append(v)\n\n    # t4 = time.clock()\n\n    count = n - k\n    for i in xrange(n, 0, -1):\n        new_nodes = []\n\n        p = i * 2\n        abort = False\n        while True:\n            flag = nodes[p + 1]\n            if flag == -1:\n                abort = True\n                break\n            elif flag == 1:\n                break\n            new_nodes.append(p)\n            index = nodes[p]\n            if index <= 0:\n                break\n            p = index * 2\n        if abort:\n            for p in new_nodes:\n                nodes[p + 1] = -1\n            continue\n\n        c = count - len(new_nodes)\n        if c >= 0:\n            for p in new_nodes:\n                nodes[p + 1] = 1\n            count = c\n            if count == 0:\n                break\n        else:\n            for j in xrange(-c):\n                nodes[new_nodes[j] + 1] = -1\n\n    # t5 = time.clock()\n    #\n    # print('---t5 - t1: %s' % (t5 - t1))\n    # print('---t2 - t1: %s' % (t2 - t1))\n    # print('---t3 - t2: %s' % (t3 - t2))\n    # print('---t4 - t3: %s' % (t4 - t3))\n    # print('---t5 - t4: %s' % (t5 - t4))\n\n    result = [i for i in xrange(1, n + 1) if nodes[i * 2 + 1] != 1]\n\n    print(' '.join(map(str, result)))\n\n\ndef main():\n    sys.setcheckinterval(2147483647)\n\n    n, k = map(int, sys.stdin.readline().split())\n    edges = [map(int, sys.stdin.readline().split()) for _ in xrange(n - 1)]\n\n    # import random\n    # n, k = 1000000, 19\n    # edges = []\n    # rnd = random.Random()\n    # rnd.seed(1)\n    # t = range(1, n + 1)\n    # random.shuffle(t, random=rnd.random)\n    # for i in xrange(2, n + 1):\n    #     j = rnd.randint(1, i - 1)\n    #     edges.append([i, j])\n\n    calc_result(n, k, edges)\n\n\nif __name__ == '__main__':\n    main()\n",
        "correct": true,
        "task_id": "0201",
        "depth": 2
    },
    {
        "description": "Given is a positive integer N. How many tuples (A,B,C) of positive integers satisfy A \\times B + C = N?\n\nConstraints\n\n* 2 \\leq N \\leq 10^6\n* All values in input are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\n\n\nOutput\n\nPrint the answer.\n\nExamples\n\nInput\n\n3\n\n\nOutput\n\n3\n\n\nInput\n\n100\n\n\nOutput\n\n473\n\n\nInput\n\n1000000\n\n\nOutput\n\n13969985",
        "task_name": "p02548 AtCoder Beginner Contest 179 - A x B + C",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\nN = int(input())\n\ncount = 0\nfor i in range(1,N):\n    count += len(make_divisors(N-i))\nprint(count)",
        "correct": false,
        "task_id": "0202",
        "depth": 1
    },
    {
        "description": "Recently, Masha was presented with a chessboard with a height of n and a width of m.\n\nThe rows on the chessboard are numbered from 1 to n from bottom to top. The columns are numbered from 1 to m from left to right. Therefore, each cell can be specified with the coordinates (x,y), where x is the column number, and y is the row number (do not mix up).\n\nLet us call a rectangle with coordinates (a,b,c,d) a rectangle lower left point of which has coordinates (a,b), and the upper right one \u2014 (c,d).\n\nThe chessboard is painted black and white as follows:\n\n<image> An example of a chessboard.\n\nMasha was very happy with the gift and, therefore, invited her friends Maxim and Denis to show off. The guys decided to make her a treat \u2014 they bought her a can of white and a can of black paint, so that if the old board deteriorates, it can be repainted. When they came to Masha, something unpleasant happened: first, Maxim went over the threshold and spilled white paint on the rectangle (x_1,y_1,x_2,y_2). Then after him Denis spilled black paint on the rectangle (x_3,y_3,x_4,y_4).\n\nTo spill paint of color color onto a certain rectangle means that all the cells that belong to the given rectangle become color. The cell dyeing is superimposed on each other (if at first some cell is spilled with white paint and then with black one, then its color will be black).\n\nMasha was shocked! She drove away from the guests and decided to find out how spoiled the gift was. For this, she needs to know the number of cells of white and black color. Help her find these numbers!\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases.\n\nEach of them is described in the following format:\n\nThe first line contains two integers n and m (1 \u2264 n,m \u2264 10^9) \u2014 the size of the board.\n\nThe second line contains four integers x_1, y_1, x_2, y_2 (1 \u2264 x_1 \u2264 x_2 \u2264 m, 1 \u2264 y_1 \u2264 y_2 \u2264 n) \u2014 the coordinates of the rectangle, the white paint was spilled on.\n\nThe third line contains four integers x_3, y_3, x_4, y_4 (1 \u2264 x_3 \u2264 x_4 \u2264 m, 1 \u2264 y_3 \u2264 y_4 \u2264 n) \u2014 the coordinates of the rectangle, the black paint was spilled on.\n\nOutput\n\nOutput t lines, each of which contains two numbers \u2014 the number of white and black cells after spilling paint, respectively.\n\nExample\n\nInput\n\n\n5\n2 2\n1 1 2 2\n1 1 2 2\n3 4\n2 2 3 2\n3 1 4 3\n1 5\n1 1 5 1\n3 1 5 1\n4 4\n1 1 4 2\n1 3 4 4\n3 4\n1 2 4 2\n2 1 3 3\n\n\nOutput\n\n\n0 4\n3 9\n2 3\n8 8\n4 8\n\nNote\n\nExplanation for examples:\n\nThe first picture of each illustration shows how the field looked before the dyes were spilled. The second picture of each illustration shows how the field looked after Maxim spoiled white dye (the rectangle on which the dye was spilled is highlighted with red). The third picture in each illustration shows how the field looked after Denis spoiled black dye (the rectangle on which the dye was spilled is highlighted with red).\n\nIn the first test, the paint on the field changed as follows:\n\n<image>\n\nIn the second test, the paint on the field changed as follows:\n\n<image>\n\nIn the third test, the paint on the field changed as follows:\n\n<image>\n\nIn the fourth test, the paint on the field changed as follows:\n\n<image>\n\nIn the fifth test, the paint on the field changed as follows:\n\n<image>",
        "task_name": "1080_C. Masha and two friends",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\"\"\"\nThis file is part of https://github.com/Cheran-Senthil/PyRival.\n\nCopyright 2018 Cheran Senthilkumar all rights reserved,\nCheran Senthilkumar <hello@cheran.io>\nPermission to use, modify, and distribute this software is given under the\nterms of the MIT License.\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport cmath\nimport itertools\nimport math\nimport operator as op\n# import random\nimport sys\nfrom atexit import register\nfrom bisect import bisect_left, bisect_right\n# from collections import Counter, MutableSequence, defaultdict, deque\n# from copy import deepcopy\n# from decimal import Decimal\n# from difflib import SequenceMatcher\n# from fractions import Fraction\n# from heapq import heappop, heappush\n\nif sys.version_info[0] < 3:\n    # from cPickle import dumps\n    from io import BytesIO as stream\n    # from Queue import PriorityQueue, Queue\nelse:\n    # from functools import reduce\n    from io import StringIO as stream\n    from math import gcd\n    # from pickle import dumps\n    # from queue import PriorityQueue, Queue\n\n\nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n\n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n\n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n\n    def gcd(x, y):\n        \"\"\"gcd(x, y) -> int\n        greatest common divisor of x and y\n        \"\"\"\n        while y:\n            x, y = y, x % y\n        return x\n\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\n\ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n\n    Args:\n        sync (bool, optional): The new synchronization setting.\n\n    \"\"\"\n    global input, flush\n\n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n, m = map(int, input().split(' '))\n        white_sq_0 = (n*m + 1) // 2\n\n        x1, y1, x2, y2 = map(int, input().split(' '))\n        col_cnt_1 = x2 - x1 + 1\n        row_cnt_1 = y2 - y1 + 1\n\n        if x1 % 2 == 0:\n            if y1 % 2 == 0:\n                white_sq_1 = (col_cnt_1*row_cnt_1 + 1) // 2\n            else:\n                white_sq_1 = (col_cnt_1*row_cnt_1) // 2\n        else:\n            if y1 % 2 == 0:\n                white_sq_1 = (col_cnt_1*row_cnt_1) // 2\n            else:\n                white_sq_1 = (col_cnt_1*row_cnt_1 + 1) // 2\n\n        x3, y3, x4, y4 = map(int, input().split(' '))\n        col_cnt_2 = x4 - x3 + 1\n        row_cnt_2 = y4 - y3 + 1\n\n        if x3 % 2 == 0:\n            if y3 % 2 == 0:\n                white_sq_2 = (col_cnt_2*row_cnt_2 + 1) // 2\n            else:\n                white_sq_2 = (col_cnt_2*row_cnt_2) // 2\n        else:\n            if y3 % 2 == 0:\n                white_sq_2 = (col_cnt_2*row_cnt_2) // 2\n            else:\n                white_sq_2 = (col_cnt_2*row_cnt_2 + 1) // 2\n\n        if (x3 > x2) or (y3 > y2) or (x4 < x1) or (y4 < y1):\n            white_cnt = white_sq_0 + (col_cnt_1*row_cnt_1 - white_sq_1) - white_sq_2\n            black_cnt = n*m - white_cnt\n            print(white_cnt, black_cnt)\n        else:\n            x5, x6 = max(x1, x3), min(x2, x4)\n            y5, y6 = max(y1, y3), min(y2, y4)\n\n            col_cnt_3 = x6 - x5 + 1\n            row_cnt_3 = y6 - y5 + 1\n\n            if x5 % 2 == 0:\n                if y5 % 2 == 0:\n                    white_sq_3 = (col_cnt_3*row_cnt_3) // 2\n                else:\n                    white_sq_3 = (col_cnt_3*row_cnt_3 + 1) // 2\n            else:\n                if y5 % 2 == 0:\n                    white_sq_3 = (col_cnt_3*row_cnt_3 + 1) // 2\n                else:\n                    white_sq_3 = (col_cnt_3*row_cnt_3) // 2\n\n            white_cnt = white_sq_0 + (col_cnt_1*row_cnt_1 - white_sq_1) - white_sq_2\n            black_cnt = n*m - white_cnt\n            print(white_cnt - white_sq_3, black_cnt + white_sq_3)\n\n\nif __name__ == '__main__':\n    sync_with_stdio(False)\n    main()\n",
        "correct": true,
        "task_id": "0214",
        "depth": 1
    },
    {
        "description": "You are given a permutation p of integers from 1 to n, where n is an even number. \n\nYour goal is to sort the permutation. To do so, you can perform zero or more operations of the following type: \n\n  * take two indices i and j such that 2 \u22c5 |i - j| \u2265 n and swap p_i and p_j. \n\n\n\nThere is no need to minimize the number of operations, however you should use no more than 5 \u22c5 n operations. One can show that it is always possible to do that.\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 3 \u22c5 10^5, n is even) \u2014 the length of the permutation. \n\nThe second line contains n distinct integers p_1, p_2, \u2026, p_n (1 \u2264 p_i \u2264 n) \u2014 the given permutation.\n\nOutput\n\nOn the first line print m (0 \u2264 m \u2264 5 \u22c5 n) \u2014 the number of swaps to perform.\n\nEach of the following m lines should contain integers a_i, b_i (1 \u2264 a_i, b_i \u2264 n, |a_i - b_i| \u2265 n/2) \u2014 the indices that should be swapped in the corresponding swap.\n\nNote that there is no need to minimize the number of operations. We can show that an answer always exists.\n\nExamples\n\nInput\n\n\n2\n2 1\n\n\nOutput\n\n\n1\n1 2\n\nInput\n\n\n4\n3 4 1 2\n\n\nOutput\n\n\n4\n1 4\n1 4\n1 3\n2 4\n\n\nInput\n\n\n6\n2 5 3 1 4 6\n\n\nOutput\n\n\n3\n1 5\n2 5\n1 4\n\nNote\n\nIn the first example, when one swap elements on positions 1 and 2, the array becomes sorted.\n\nIn the second example, pay attention that there is no need to minimize number of swaps.\n\nIn the third example, after swapping elements on positions 1 and 5 the array becomes: [4, 5, 3, 1, 2, 6]. After swapping elements on positions 2 and 5 the array becomes [4, 2, 3, 1, 5, 6] and finally after swapping elements on positions 1 and 4 the array becomes sorted: [1, 2, 3, 4, 5, 6].",
        "task_name": "1148_C. Crazy Diamond",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"                         \nBeautiful is better than ugly.\n    Explicit is better than implicit.\nSimple is better than complex.\n    Complex is better than complicated.\nFlat is better than nested.\n    Sparse is better than dense.\n                    \n    * Readability counts *\n\n // Author : raj1307 - Raj Singh\n // Date   : 13.06.19\n\n\"\"\"\n\nfrom __future__ import division, print_function\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    _str = str\n    str = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial,pow,pi\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod,MOD=1000000007,998244353\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p1\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n# For getting input from input.txt file \n#sys.stdin = open('input.txt', 'r')  \n  \n# Printing the Output to output.txt file \n#sys.stdout = open('output.txt', 'w') \n\ndef main():\n    \n    \n    \n    n=ii()\n    l=li()\n    \n    d={}\n    \n    for i in range(n):\n        d[l[i]]=i\n    \n    a=l[::]\n    a.sort()\n    \n    ans=[]\n    for i in range(n):\n        \n        if a[i]==l[i]:\n            continue\n        \n        \n        \n        if abs(d[a[i]]-i)>=n//2:\n            \n            x=d[a[i]]\n            y=i\n            \n            l[y],l[x]=l[x],l[y]\n            \n    \n            \n            ans.append([x+1,y+1])\n            \n            #print(d)\n        else:\n            \n            \n            \n                \n            x=d[a[i]]\n            if x<n//2:\n                y=n-1\n            else:\n                y=0\n                \n            \n            l[y],l[x]=l[x],l[y]\n              \n  \n                \n            ans.append([x+1,y+1])\n                \n                \n            if (d[a[i]]-i)<=n//2:\n                x=d[a[i]]\n                if x<n//2:\n                    y=n-1\n                else:\n                    y=0\n                    \n                \n                l[y],l[x]=l[x],l[y]\n                  \n        \n                    \n                ans.append([x+1,y+1])\n                \n                \n                \n                \n                \n            \n            x=d[a[i]]\n            #print(d[a[i]],'i')\n            y=i\n            \n            l[y],l[x]=l[x],l[y]\n            \n            \n            #print('i')\n            ans.append([x+1,y+1])\n            \n    print(len(ans))\n    for i in ans:\n        print(*i)\n            \n            \n            \n            \n            \n    \n    \n    \n    \n        \n    \n            \n        \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        if self.buffer.tell():\n            return self.buffer.read()\n        return os.read(self._fd, os.fstat(self._fd).st_size)\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", b\" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", b\"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(b\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n    #dmain()",
        "correct": false,
        "task_id": "0217",
        "depth": 1
    },
    {
        "description": "You are given an array a of n integers.\n\nYou want to make all elements of a equal to zero by doing the following operation exactly three times:\n\n  * Select a segment, for each number in this segment we can add a multiple of len to it, where len is the length of this segment (added integers can be different). \n\n\n\nIt can be proven that it is always possible to make all elements of a equal to zero.\n\nInput\n\nThe first line contains one integer n (1 \u2264 n \u2264 100 000): the number of elements of the array.\n\nThe second line contains n elements of an array a separated by spaces: a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9).\n\nOutput\n\nThe output should contain six lines representing three operations.\n\nFor each operation, print two lines:\n\n  * The first line contains two integers l, r (1 \u2264 l \u2264 r \u2264 n): the bounds of the selected segment.\n\n  * The second line contains r-l+1 integers b_l, b_{l+1}, ..., b_r (-10^{18} \u2264 b_i \u2264 10^{18}): the numbers to add to a_l, a_{l+1}, \u2026, a_r, respectively; b_i should be divisible by r - l + 1.\n\nExample\n\nInput\n\n\n4\n1 3 2 4\n\n\nOutput\n\n\n1 1 \n-1\n3 4\n4 2\n2 4\n-3 -6 -6",
        "task_name": "1396_A. Multiples of Length",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n\nimport sys\nfrom atexit import register\n\nif sys.version_info[0] < 3:\n    from io import BytesIO as stream\nelse:\n    from io import StringIO as stream\n\n\nsys.stdin = stream(sys.stdin.read())\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nsys.stdout = stream()\nregister(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\ndef egcd(a, b):\n    x,y, u,v = 0,1, 1,0\n    while a != 0:\n        q, r = b//a, b%a\n        m, n = x-u*q, y-v*q\n        b,a, x,y, u,v = a,r, u,v, m,n\n    gcd = b\n    return gcd, x, y\n\n\ndef solve():\n    N = read_int()\n    A = read_ints()\n    if N == 1:\n        print(1, 1)\n        print(-A[0])\n        print(1, 1)\n        print(0)\n        print(1, 1)\n        print(0)\n        return\n    gcd, x, y = egcd(N-1, N)\n    B = []\n    for a in A[:N-1]:\n        B.append(-a*(N-1)*x)\n    B.append(0)\n    print(1, N-1)\n    print(*B[:N-1])\n    A = [a+b for a, b in zip(A, B)]\n    print(N, N)\n    print(N-A[-1])\n    A[-1] = N\n    print(1, N)\n    print(*[-a for a in A])\n\n\nif __name__ == '__main__':\n    solve()\n",
        "correct": true,
        "task_id": "0224",
        "depth": 1
    },
    {
        "description": "In the Main Berland Bank n people stand in a queue at the cashier, everyone knows his/her height hi, and the heights of the other people in the queue. Each of them keeps in mind number ai \u2014 how many people who are taller than him/her and stand in queue in front of him.\n\nAfter a while the cashier has a lunch break and the people in the queue seat on the chairs in the waiting room in a random order.\n\nWhen the lunch break was over, it turned out that nobody can remember the exact order of the people in the queue, but everyone remembers his number ai.\n\nYour task is to restore the order in which the people stood in the queue if it is possible. There may be several acceptable orders, but you need to find any of them. Also, you need to print a possible set of numbers hi \u2014 the heights of people in the queue, so that the numbers ai are correct.\n\nInput\n\nThe first input line contains integer n \u2014 the number of people in the queue (1 \u2264 n \u2264 3000). Then n lines contain descriptions of the people as \"namei ai\" (one description on one line), where namei is a non-empty string consisting of lowercase Latin letters whose length does not exceed 10 characters (the i-th person's name), ai is an integer (0 \u2264 ai \u2264 n - 1), that represents the number of people who are higher and stand in the queue in front of person i. It is guaranteed that all names are different.\n\nOutput\n\nIf there's no acceptable order of the people in the queue, print the single line containing \"-1\" without the quotes. Otherwise, print in n lines the people as \"namei hi\", where hi is the integer from 1 to 109 (inclusive), the possible height of a man whose name is namei. Print the people in the order in which they stand in the queue, starting from the head of the queue and moving to its tail. Numbers hi are not necessarily unique.\n\nExamples\n\nInput\n\n4\na 0\nb 2\nc 0\nd 0\n\n\nOutput\n\na 150\nc 170\nd 180\nb 160\n\n\nInput\n\n4\nvasya 0\npetya 1\nmanya 3\ndunay 3\n\n\nOutput\n\n-1",
        "task_name": "141_C. Queue",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\nn = int(input())\ns, ans = sorted([rstrs() for _ in range(n)], key=lambda x: int(x[1])), []\n\n# print(s)\nfor i in range(n):\n    if int(s[i][1]) > i:\n        print(-1)\n        exit()\n\n    ans.insert(int(s[i][1]), ' '.join([s[i][0], str(n)]))\n    n -= 1\n\nprint('\\n'.join(ans))\n",
        "correct": true,
        "task_id": "0225",
        "depth": 1
    },
    {
        "description": "User ainta loves to play with cards. He has a cards containing letter \"o\" and b cards containing letter \"x\". He arranges the cards in a row, and calculates the score of the deck by the formula below.\n\n  1. At first, the score is 0. \n  2. For each block of contiguous \"o\"s with length x the score increases by x2. \n  3. For each block of contiguous \"x\"s with length y the score decreases by y2. \n\n\n\nFor example, if a = 6, b = 3 and ainta have arranged the cards in the order, that is described by string \"ooxoooxxo\", the score of the deck equals 22 - 12 + 32 - 22 + 12 = 9. That is because the deck has 5 blocks in total: \"oo\", \"x\", \"ooo\", \"xx\", \"o\".\n\nUser ainta likes big numbers, so he wants to maximize the score with the given cards. Help ainta make the score as big as possible. Note, that he has to arrange all his cards.\n\nInput\n\nThe first line contains two space-separated integers a and b (0 \u2264 a, b \u2264 105; a + b \u2265 1) \u2014 the number of \"o\" cards and the number of \"x\" cards.\n\nOutput\n\nIn the first line print a single integer v \u2014 the maximum score that ainta can obtain.\n\nIn the second line print a + b characters describing the deck. If the k-th card of the deck contains \"o\", the k-th character must be \"o\". If the k-th card of the deck contains \"x\", the k-th character must be \"x\". The number of \"o\" characters must be equal to a, and the number of \"x \" characters must be equal to b. If there are many ways to maximize v, print any.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nExamples\n\nInput\n\n2 3\n\n\nOutput\n\n-1\nxoxox\n\n\nInput\n\n4 0\n\n\nOutput\n\n16\noooo\n\nInput\n\n0 4\n\n\nOutput\n\n-16\nxxxx",
        "task_name": "399_C. Cards",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdout\ndef main():\n    a, b = map(int, raw_input().split())\n    if not a or not b:\n        stdout.write(str(a * a - b * b) + '\\n')\n        stdout.write('o' * a + 'x' * b)\n        return\n    ans = -10 ** 17\n    v = 0\n    for i in xrange(1, a+1):\n        x, y = divmod(b, i + 1)\n        t = i - 1 + (a - i + 1) * (a - i + 1) - y * (x + 1) * (x + 1) - (i + 1 - y) * x * x\n        if ans < t:\n            ans = t\n            v = i\n    x, y = divmod(b, v + 1)\n    c = ['o'] * (v - 1) + ['o' * (a - v + 1)]\n    d = ['x' * (x + 1)] * y + ['x' * x] * (a + 1 - y)\n    e = []\n    for j in xrange(v):\n        e.append(d[j])\n        e.append(c[j])\n    e.append(d[-1])       \n    stdout.write(str(ans) + '\\n')\n    stdout.write(''.join(e))\nmain()\n",
        "correct": true,
        "task_id": "0236",
        "depth": 1
    },
    {
        "description": "Peter got a new snow blower as a New Year present. Of course, Peter decided to try it immediately. After reading the instructions he realized that it does not work like regular snow blowing machines. In order to make it work, you need to tie it to some point that it does not cover, and then switch it on. As a result it will go along a circle around this point and will remove all the snow from its path.\n\nFormally, we assume that Peter's machine is a polygon on a plane. Then, after the machine is switched on, it will make a circle around the point to which Peter tied it (this point lies strictly outside the polygon). That is, each of the points lying within or on the border of the polygon will move along the circular trajectory, with the center of the circle at the point to which Peter tied his machine.\n\nPeter decided to tie his car to point P and now he is wondering what is the area of \u200b\u200bthe region that will be cleared from snow. Help him.\n\nInput\n\nThe first line of the input contains three integers \u2014 the number of vertices of the polygon n (<image>), and coordinates of point P.\n\nEach of the next n lines contains two integers \u2014 coordinates of the vertices of the polygon in the clockwise or counterclockwise order. It is guaranteed that no three consecutive vertices lie on a common straight line.\n\nAll the numbers in the input are integers that do not exceed 1 000 000 in their absolute value.\n\nOutput\n\nPrint a single real value number \u2014 the area of the region that will be cleared. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. \n\nNamely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if <image>.\n\nExamples\n\nInput\n\n3 0 0\n0 1\n-1 2\n1 2\n\n\nOutput\n\n12.566370614359172464\n\n\nInput\n\n4 1 -1\n0 0\n1 2\n2 0\n1 1\n\n\nOutput\n\n21.991148575128551812\n\nNote\n\nIn the first sample snow will be removed from that area:\n\n<image>",
        "task_name": "613_A. Peter and Snow Blower",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def main():\n\tfrom sys import stdin,stdout\n\tfrom math import pi\n\tr,w=stdin.readline,stdout.write\n\tn,x,y = map(int,r().split())\n\tpoints = [map(int,r().split()) for i in xrange(n)]\n\tmaxD,minD = 0,10000000\n\tfor i in xrange(n):\n\t\tdistance = ((abs(x-points[i][0]))**2 + (abs(y-points[i][1]))**2)**(1/2.)\n\t\tif distance > maxD:\tmaxD = distance \n\t\tif distance < minD: minD = distance\n\tfor i in xrange(n):\n\t\tp1,p2 = points[i],points[(i+1)%n]\n\t\tpx = p2[0]-p1[0]; py = p2[1]-p1[1]\n\t\tu = ((x-p1[0])*px + (y-p1[1])*py)/((px*1.)**2 + (py*1.)**2)\n\t\tif u > 1: u = 1\n\t\tif u < 0: u = 0\n\t\tx1 = p1[0] + u*px; y1 = p1[1] + u*py\n\t\tdx = x1 - x; dy = y1 - y\n\t\tdistance = (dx*dx + dy*dy)**(0.5)\n\t\tif distance > maxD:\tmaxD = distance \n\t\tif distance < minD: minD = distance\n\tminA = pi*(minD)**2\n\tmaxA = pi*(maxD)**2\n\tw(str(maxA-minA))\nmain()",
        "correct": true,
        "task_id": "0241",
        "depth": 1
    },
    {
        "description": "In one of the games Arkady is fond of the game process happens on a rectangular field. In the game process Arkady can buy extensions for his field, each extension enlarges one of the field sizes in a particular number of times. Formally, there are n extensions, the i-th of them multiplies the width or the length (by Arkady's choice) by ai. Each extension can't be used more than once, the extensions can be used in any order.\n\nNow Arkady's field has size h \u00d7 w. He wants to enlarge it so that it is possible to place a rectangle of size a \u00d7 b on it (along the width or along the length, with sides parallel to the field sides). Find the minimum number of extensions needed to reach Arkady's goal.\n\nInput\n\nThe first line contains five integers a, b, h, w and n (1 \u2264 a, b, h, w, n \u2264 100 000) \u2014 the sizes of the rectangle needed to be placed, the initial sizes of the field and the number of available extensions.\n\nThe second line contains n integers a1, a2, ..., an (2 \u2264 ai \u2264 100 000), where ai equals the integer a side multiplies by when the i-th extension is applied.\n\nOutput\n\nPrint the minimum number of extensions needed to reach Arkady's goal. If it is not possible to place the rectangle on the field with all extensions, print -1. If the rectangle can be placed on the initial field, print 0.\n\nExamples\n\nInput\n\n3 3 2 4 4\n2 5 4 10\n\n\nOutput\n\n1\n\n\nInput\n\n3 3 3 3 5\n2 3 5 4 2\n\n\nOutput\n\n0\n\n\nInput\n\n5 5 1 2 3\n2 2 3\n\n\nOutput\n\n-1\n\n\nInput\n\n3 4 1 1 3\n2 3 2\n\n\nOutput\n\n3\n\nNote\n\nIn the first example it is enough to use any of the extensions available. For example, we can enlarge h in 5 times using the second extension. Then h becomes equal 10 and it is now possible to place the rectangle on the field.",
        "task_name": "799_D. Field expansion",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "f = lambda: map(int, raw_input().split())\na, b, h, w, n = f()\nc = sorted(list(f()), key=lambda x: -x)\nd = {(h, w), (w, h)}\nfor i, q in enumerate([1] + c):\n    for u, v in d.copy():\n        h, w = u, v * q\n        if a <= w and b <= h or a <= h and b <= w:\n            print(i)\n            exit()\n        d.add((h, w))\n        d.add((w, h))\nprint(-1)",
        "correct": true,
        "task_id": "0244",
        "depth": 2
    },
    {
        "description": "Luba has a ticket consisting of 6 digits. In one move she can choose digit in any position and replace it with arbitrary digit. She wants to know the minimum number of digits she needs to replace in order to make the ticket lucky.\n\nThe ticket is considered lucky if the sum of first three digits equals to the sum of last three digits.\n\nInput\n\nYou are given a string consisting of 6 characters (all characters are digits from 0 to 9) \u2014 this string denotes Luba's ticket. The ticket can start with the digit 0.\n\nOutput\n\nPrint one number \u2014 the minimum possible number of digits Luba needs to replace to make the ticket lucky.\n\nExamples\n\nInput\n\n000000\n\n\nOutput\n\n0\n\n\nInput\n\n123456\n\n\nOutput\n\n2\n\n\nInput\n\n111000\n\n\nOutput\n\n1\n\nNote\n\nIn the first example the ticket is already lucky, so the answer is 0.\n\nIn the second example Luba can replace 4 and 5 with zeroes, and the ticket will become lucky. It's easy to see that at least two replacements are required.\n\nIn the third example Luba can replace any zero with 3. It's easy to see that at least one replacement is required.",
        "task_name": "845_B. Luba And The Ticket",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\ns, ans = stdin.readline().strip(), float('inf')\nfor i in range(0, 10 ** 6):\n    cur, tem = i, 0\n    for j in range(5, -1, -1):\n        tem += (cur % 10) != int(s[j])\n        cur //= 10\n\n    if sum([int(x) for x in str(i)[:3]]) == sum([int(y) for y in str(i)[3:]]):\n        ans = min(ans, tem)\nprint(ans)\n",
        "correct": false,
        "task_id": "0245",
        "depth": 2
    },
    {
        "description": "You are given two integer sequences S and T of length N and M, respectively, both consisting of integers between 1 and 10^5 (inclusive).\n\nIn how many pairs of a subsequence of S and a subsequence of T do the two subsequences are the same in content?\n\nHere the subsequence of A is a sequence obtained by removing zero or more elements from A and concatenating the remaining elements without changing the order.\n\nFor both S and T, we distinguish two subsequences if the sets of the indices of the removed elements are different, even if the subsequences are the same in content.\n\nSince the answer can be tremendous, print the number modulo 10^9+7.\n\nConstraints\n\n* 1 \\leq N, M \\leq 2 \\times 10^3\n* The length of S is N.\n* The length of T is M.\n* 1 \\leq S_i, T_i \\leq 10^5\n* All values in input are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M\nS_1 S_2 ... S_{N-1} S_{N}\nT_1 T_2 ... T_{M-1} T_{M}\n\n\nOutput\n\nPrint the number of pairs of a subsequence of S and a subsequence of T such that the subsequences are the same in content, modulo 10^9+7.\n\nExamples\n\nInput\n\n2 2\n1 3\n3 1\n\n\nOutput\n\n3\n\n\nInput\n\n2 2\n1 1\n1 1\n\n\nOutput\n\n6\n\n\nInput\n\n4 4\n3 4 5 6\n3 4 5 6\n\n\nOutput\n\n16\n\n\nInput\n\n10 9\n9 6 5 7 5 9 8 5 6 7\n8 6 8 5 5 7 9 9 7\n\n\nOutput\n\n191\n\n\nInput\n\n20 20\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n\nOutput\n\n846527861",
        "task_name": "p03003 AtCoder Beginner Contest 130 - Common Subsequence",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "source = raw_input()\ninput = source.split(\" \")\nn, m = int(input[0]), int(input[1])\ns = [0] + [int(i) for i in raw_input().split(\" \")]\nt = [0] + [int(i) for i in raw_input().split(\" \")]\nMOD = 10**9 + 7\n\ndp = [[0] * (m + 1) for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n        if s[i] == t[j]:\n            dp[i][j] += dp[i - 1][j - 1] + 1\n        dp[i][j] %= MOD\n\nprint((dp[n][m] + 1) % MOD)",
        "correct": false,
        "task_id": "0250",
        "depth": 2
    },
    {
        "description": "Recently, Tokitsukaze found an interesting game. Tokitsukaze had n items at the beginning of this game. However, she thought there were too many items, so now she wants to discard m (1 \u2264 m \u2264 n) special items of them.\n\nThese n items are marked with indices from 1 to n. In the beginning, the item with index i is placed on the i-th position. Items are divided into several pages orderly, such that each page contains exactly k positions and the last positions on the last page may be left empty.\n\nTokitsukaze would do the following operation: focus on the first special page that contains at least one special item, and at one time, Tokitsukaze would discard all special items on this page. After an item is discarded or moved, its old position would be empty, and then the item below it, if exists, would move up to this empty position. The movement may bring many items forward and even into previous pages, so Tokitsukaze would keep waiting until all the items stop moving, and then do the operation (i.e. check the special page and discard the special items) repeatedly until there is no item need to be discarded.\n\n<image> Consider the first example from the statement: n=10, m=4, k=5, p=[3, 5, 7, 10]. The are two pages. Initially, the first page is special (since it is the first page containing a special item). So Tokitsukaze discards the special items with indices 3 and 5. After, the first page remains to be special. It contains [1, 2, 4, 6, 7], Tokitsukaze discards the special item with index 7. After, the second page is special (since it is the first page containing a special item). It contains [9, 10], Tokitsukaze discards the special item with index 10.\n\nTokitsukaze wants to know the number of operations she would do in total.\n\nInput\n\nThe first line contains three integers n, m and k (1 \u2264 n \u2264 10^{18}, 1 \u2264 m \u2264 10^5, 1 \u2264 m, k \u2264 n) \u2014 the number of items, the number of special items to be discarded and the number of positions in each page.\n\nThe second line contains m distinct integers p_1, p_2, \u2026, p_m (1 \u2264 p_1 < p_2 < \u2026 < p_m \u2264 n) \u2014 the indices of special items which should be discarded.\n\nOutput\n\nPrint a single integer \u2014 the number of operations that Tokitsukaze would do in total.\n\nExamples\n\nInput\n\n\n10 4 5\n3 5 7 10\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n13 4 5\n7 8 9 10\n\n\nOutput\n\n\n1\n\nNote\n\nFor the first example:\n\n  * In the first operation, Tokitsukaze would focus on the first page [1, 2, 3, 4, 5] and discard items with indices 3 and 5; \n  * In the second operation, Tokitsukaze would focus on the first page [1, 2, 4, 6, 7] and discard item with index 7; \n  * In the third operation, Tokitsukaze would focus on the second page [9, 10] and discard item with index 10. \n\n\n\nFor the second example, Tokitsukaze would focus on the second page [6, 7, 8, 9, 10] and discard all special items at once.",
        "task_name": "1191_C. Tokitsukaze and Discard Items",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "data = list(map(int, raw_input().split()))\nn = data[0]\nm = data[1]\nk = data[2]\n\nnums = list(map(int, raw_input().split()))\n\ncurr = 0\noffset = 0\ni = 0\nop = 0\nwhile i < m:\n    if nums[i] <= offset + curr * k + k:\n        while i < m and nums[i] <= offset + curr * k + k:\n            i += 1\n        offset = i\n        op += 1\n    else :\n        curr += (nums[i] - (offset + curr * k) - 1) / k\nprint(op)\n",
        "correct": true,
        "task_id": "0260",
        "depth": 2
    },
    {
        "description": "Today the kindergarten has a new group of n kids who need to be seated at the dinner table. The chairs at the table are numbered from 1 to 4n. Two kids can't sit on the same chair. It is known that two kids who sit on chairs with numbers a and b (a \u2260 b) will indulge if: \n\n  1. gcd(a, b) = 1 or, \n  2. a divides b or b divides a. \n\n\n\ngcd(a, b) \u2014 the maximum number x such that a is divisible by x and b is divisible by x.\n\nFor example, if n=3 and the kids sit on chairs with numbers 2, 3, 4, then they will indulge since 4 is divided by 2 and gcd(2, 3) = 1. If kids sit on chairs with numbers 4, 6, 10, then they will not indulge.\n\nThe teacher really doesn't want the mess at the table, so she wants to seat the kids so there are no 2 of the kid that can indulge. More formally, she wants no pair of chairs a and b that the kids occupy to fulfill the condition above.\n\nSince the teacher is very busy with the entertainment of the kids, she asked you to solve this problem.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\n\nEach test case consists of one line containing an integer n (1 \u2264 n \u2264 100) \u2014 the number of kids.\n\nOutput\n\nOutput t lines, which contain n distinct integers from 1 to 4n \u2014 the numbers of chairs that the kids should occupy in the corresponding test case. If there are multiple answers, print any of them. You can print n numbers in any order.\n\nExample\n\nInput\n\n\n3\n2\n3\n4\n\n\nOutput\n\n\n6 4\n4 6 10\n14 10 12 8",
        "task_name": "1443_A. Kids Seating",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n# Author : raj1307 - Raj Singh\n# Date   : 02.11.2020\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii():  return int(input())\ndef si():  return input()\ndef mi():  return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li():  return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import log,sqrt,factorial,cos,tan,sin,radians\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *\n#import threading\n#from itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey,reverse=True)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\ndef ncr(n,r): return factorial(n)//(factorial(r)*factorial(max(n-r,1)))\n\ndef ceil(x,y):\n    if x%y==0:\n        return x//y\n    else:\n        return x//y+1\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin  = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\n\n\ndef main():\n\n\n\n    #for _ in range(ii()):\n\n    \n    # l=[]\n    # f=[0]*405\n    # for i in range(2,401,2):\n    #     if f[i]==1:\n    #         continue\n    #     if isPrime(i):\n    #         f[i]=1\n    #     else:\n    #         for j in range(i+i,401,i):\n    #             f[j]=1\n    #         l.append(i)\n\n\n    # print(len(l))\n\n    # x=[]\n    # p=0\n    # for i in range(len(l)):\n\n    #     if len(x)>=100:\n    #         break\n\n\n    #     for j in range(i+1,len(l)):\n\n    #         if l[i]*l[j]<=400:\n    #             x.append(l[i]*l[j])\n    #return\n\n    # for i in range(len(l)):\n\n    #     if l[i]*2>400:\n    #         break\n\n    #     x.append(2*l[i])\n\n    # print(len(x))\n\n    #x.sort()\n\n    for _ in range(ii()):\n\n        n=ii()\n\n        cnt=0\n        for i in range(4*n,0,-2):\n            cnt+=1\n            print(i,end=' ')\n            if cnt==n:\n                break\n        print()\n\n\n        #print(*l[:n])\n\n\n\n\n\n\n\n\n\n        \n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": true,
        "task_id": "0266",
        "depth": 2
    },
    {
        "description": "There are n cities and m bidirectional roads in Berland. The i-th road connects the cities x_i and y_i, and has the speed limit s_i. The road network allows everyone to get from any city to any other city. \n\nThe Berland Transport Ministry is planning a road reform.\n\nFirst of all, maintaining all m roads is too costly, so m - (n - 1) roads will be demolished in such a way that the remaining (n - 1) roads still allow to get to any city from any other city. Formally, the remaining roads should represent an undirected tree.\n\nSecondly, the speed limits on the remaining roads might be changed. The changes will be done sequentially, each change is either increasing the speed limit on some road by 1, or decreasing it by 1. Since changing the speed limit requires a lot of work, the Ministry wants to minimize the number of changes.\n\nThe goal of the Ministry is to have a road network of (n - 1) roads with the maximum speed limit over all roads equal to exactly k. They assigned you the task of calculating the minimum number of speed limit changes they have to perform so the road network meets their requirements.\n\nFor example, suppose the initial map of Berland looks like that, and k = 7:\n\n<image>\n\nThen one of the optimal courses of action is to demolish the roads 1\u20134 and 3\u20134, and then decrease the speed limit on the road 2\u20133 by 1, so the resulting road network looks like that:\n\n<image>\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of each test case contains three integers n, m and k (2 \u2264 n \u2264 2 \u22c5 10^5; n - 1 \u2264 m \u2264 min(2 \u22c5 10^5, (n(n-1))/(2)); 1 \u2264 k \u2264 10^9) \u2014 the number of cities, the number of roads and the required maximum speed limit, respectively.\n\nThen m lines follow. The i-th line contains three integers x_i, y_i and s_i (1 \u2264 x_i, y_i \u2264 n; x_i \u2260 y_i; 1 \u2264 s_i \u2264 10^9) \u2014 the cities connected by the i-th road and the speed limit on it, respectively. All roads are bidirectional.\n\nThe road network in each test case is connected (that is, it is possible to reach any city from any other city by traveling along the road), and each pair of cities is connected by at most one road.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5. Similarly, the sum of m over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the minimum number of changes the Ministry has to perform so that the maximum speed limit among the remaining (n - 1) roads is exactly k.\n\nExample\n\nInput\n\n\n4\n4 5 7\n4 1 3\n1 2 5\n2 3 8\n2 4 1\n3 4 4\n4 6 5\n1 2 1\n1 3 1\n1 4 2\n2 4 1\n4 3 1\n3 2 1\n3 2 10\n1 2 8\n1 3 10\n5 5 15\n1 2 17\n3 1 15\n2 3 10\n1 4 14\n2 5 8\n\n\nOutput\n\n\n1\n3\n0\n0\n\nNote\n\nThe explanation for the example test:\n\nThe first test case is described in the problem statement.\n\nIn the second test case, the road network initially looks like that:\n\n<image>\n\nThe Ministry can demolish the roads 1\u20132, 3\u20132 and 3\u20134, and then increase the speed limit on the road 1\u20134 three times.\n\nIn the third test case, the road network already meets all the requirements.\n\nIn the fourth test case, it is enough to demolish the road 1\u20132 so the resulting road network meets the requirements.",
        "task_name": "1468_J. Road Reform",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\n\nclass disjointset:\n    def __init__(self, n):\n        self.rank, self.parent, self.n, self.nsets = [0] * (n + 1), [i for i in range(n + 1)], n, [1] * (n + 1)\n\n    def find(self, x):\n        xcopy = x\n        while x != self.parent[x]:\n            x = self.parent[x]\n\n        while xcopy != x:\n            self.parent[xcopy], xcopy = x, self.parent[xcopy]\n\n        return x\n\n    def union(self, x, y):\n        xpar, ypar = self.find(x), self.find(y)\n\n        # already union\n        if xpar == ypar:\n            return\n        # perform union by rank\n        par, child = xpar, ypar\n        if self.rank[xpar] < self.rank[ypar]:\n            par, child = ypar, xpar\n\n        elif self.rank[xpar] == self.rank[ypar]:\n            self.rank[xpar] += 1\n\n        self.parent[child] = par\n        self.nsets[par] += self.nsets[child]\n        self.n -= 1\n\n    # find min total weight tree\n    def kruskal(self, edges):\n        result, all, rem = 0, [], []\n\n        # loop over v-1\n        for u, v, w in edges:\n            upar, vpar = self.find(u), self.find(v)\n\n            # no cycle\n            if upar != vpar:\n                all.append(w)\n                self.union(upar, vpar)\n                result += max(0, w - k)\n            else:\n                rem.append(w)\n\n        if all and all[-1] < k:\n            try:\n                result += min([abs(i - k) for i in rem])\n            except:\n                result += k - all[-1]\n        print(result)\n\n\nrints = lambda: tuple([int(x) for x in stdin.readline().split()])\nrints_2d = lambda n: [rints() for _ in range(n)]\nout = []\nfor _ in range(int(input())):\n    n, m, k = rints()\n    dis = disjointset(n)\n    a = sorted(rints_2d(m), key=lambda x: x[-1])\n    dis.kruskal(a)\n",
        "correct": false,
        "task_id": "0267",
        "depth": 1
    },
    {
        "description": "The ancient Berlanders believed that the longer the name, the more important its bearer is. Thus, Berland kings were famous for their long names. But long names are somewhat inconvenient, so the Berlanders started to abbreviate the names of their kings. They called every king by the first letters of its name. Thus, the king, whose name was Victorious Vasily Pupkin, was always called by the berlanders VVP.\n\nIn Berland over its long history many dynasties of kings replaced each other, but they were all united by common traditions. Thus, according to one Berland traditions, to maintain stability in the country, the first name of the heir should be the same as the last name his predecessor (hence, the first letter of the abbreviated name of the heir coincides with the last letter of the abbreviated name of the predecessor). Berlanders appreciate stability, so this tradition has never been broken. Also Berlanders like perfection, so another tradition requires that the first name of the first king in the dynasty coincides with the last name of the last king in this dynasty (hence, the first letter of the abbreviated name of the first king coincides with the last letter of the abbreviated name of the last king). This tradition, of course, has also been always observed.\n\nThe name of a dynasty is formed by very simple rules: we take all the short names of the kings in the order in which they ruled, and write them in one line. Thus, a dynasty of kings \"ab\" and \"ba\" is called \"abba\", and the dynasty, which had only the king \"abca\", is called \"abca\".\n\nVasya, a historian, has recently found a list of abbreviated names of all Berland kings and their relatives. Help Vasya to find the maximally long name of the dynasty that could have existed in Berland.\n\nNote that in his list all the names are ordered by the time, that is, if name A is earlier in the list than B, then if A and B were kings, then king A ruled before king B.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 5\u00b7105) \u2014 the number of names in Vasya's list. Next n lines contain n abbreviated names, one per line. An abbreviated name is a non-empty sequence of lowercase Latin letters. Its length does not exceed 10 characters.\n\nOutput\n\nPrint a single number \u2014 length of the sought dynasty's name in letters.\n\nIf Vasya's list is wrong and no dynasty can be found there, print a single number 0.\n\nExamples\n\nInput\n\n3\nabc\nca\ncba\n\n\nOutput\n\n6\n\n\nInput\n\n4\nvvp\nvvp\ndam\nvvp\n\n\nOutput\n\n0\n\n\nInput\n\n3\nab\nc\ndef\n\n\nOutput\n\n1\n\nNote\n\nIn the first sample two dynasties can exist: the one called \"abcca\" (with the first and second kings) and the one called \"abccba\" (with the first and third kings). \n\nIn the second sample there aren't acceptable dynasties.\n\nThe only dynasty in the third sample consists of one king, his name is \"c\".",
        "task_name": "191_A. Dynasty Puzzles",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "__author__ = 'Rikishi'\n\nn = int(raw_input())\ndyn = [[0] * 26 for i in range(26)]\nfor i in range(n):\n    s = raw_input()\n    first = ord(s[0]) - ord('a')\n    last = ord(s[-1]) - ord('a')\n    for j in range(26):\n        if (dyn[j][first] > 0):\n            dyn[j][last] = dyn[j][first] + len(s)\n    dyn[first][last] = max(dyn[first][last], len(s))\n\nans = max([dyn[i][i] for i in range(26)])\n\nprint(ans)",
        "correct": false,
        "task_id": "0271",
        "depth": 2
    },
    {
        "description": "You are given two lists of non-zero digits.\n\nLet's call an integer pretty if its (base 10) representation has at least one digit from the first list and at least one digit from the second list. What is the smallest positive pretty integer?\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 9) \u2014 the lengths of the first and the second lists, respectively.\n\nThe second line contains n distinct digits a1, a2, ..., an (1 \u2264 ai \u2264 9) \u2014 the elements of the first list.\n\nThe third line contains m distinct digits b1, b2, ..., bm (1 \u2264 bi \u2264 9) \u2014 the elements of the second list.\n\nOutput\n\nPrint the smallest pretty integer.\n\nExamples\n\nInput\n\n2 3\n4 2\n5 7 6\n\n\nOutput\n\n25\n\n\nInput\n\n8 8\n1 2 3 4 5 6 7 8\n8 7 6 5 4 3 2 1\n\n\nOutput\n\n1\n\nNote\n\nIn the first example 25, 46, 24567 are pretty, as well as many other integers. The smallest among them is 25. 42 and 24 are not pretty because they don't have digits from the second list.\n\nIn the second example all integers that have at least one digit different from 9 are pretty. It's obvious that the smallest among them is 1, because it's the smallest positive integer.",
        "task_name": "870_A. Search for Pretty Integers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "size1, size2 = map(int, raw_input().split())\n\n\nlista1 = map(int,raw_input().split())\nlista2 = map(int,raw_input().split())\n\ndef intersection(lst1, lst2): \n    lst3 = [value for value in lst1 if value in lst2] \n    return lst3\n\nintersec = intersection(lista1,lista2)\n\nif(len(intersec) > 0):\n    menorInter = intersec[0]\n    for i in range(len(intersec)):\n        if(intersec[i] < menorInter):\n            menorInter = intersec[i]\n    print(menorInter)\nelse:\n    menor1 = lista1[0]\n    for i in range(size1):\n        if(lista1[i] < menor1):\n            menor1 = lista1[i]\n    \n    menor2 = lista2[0]\n    for i in range(size2):\n        if(lista2[i] < menor2):\n            menor2 = lista2[i]\n    if(menor1 == menor2):\n        print(menor1)\n    elif(menor1 < menor2):\n        print(str(menor1) + str(menor2))\n    else:\n        print(str(menor2) + str(menor1))\n\n",
        "correct": true,
        "task_id": "0287",
        "depth": 1
    },
    {
        "description": "We've got no test cases. A big olympiad is coming up. But the problemsetters' number one priority should be adding another problem to the round.\n\nThe diameter of a multiset of points on the line is the largest distance between two points from this set. For example, the diameter of the multiset {1, 3, 2, 1} is 2.\n\nDiameter of multiset consisting of one point is 0.\n\nYou are given n points on the line. What is the minimum number of points you have to remove, so that the diameter of the multiset of the remaining points will not exceed d?\n\nInput\n\nThe first line contains two integers n and d (1 \u2264 n \u2264 100, 0 \u2264 d \u2264 100) \u2014 the amount of points and the maximum allowed diameter respectively.\n\nThe second line contains n space separated integers (1 \u2264 xi \u2264 100) \u2014 the coordinates of the points.\n\nOutput\n\nOutput a single integer \u2014 the minimum number of points you have to remove.\n\nExamples\n\nInput\n\n3 1\n2 1 4\n\n\nOutput\n\n1\n\n\nInput\n\n3 0\n7 7 7\n\n\nOutput\n\n0\n\n\nInput\n\n6 3\n1 3 4 6 9 10\n\n\nOutput\n\n3\n\nNote\n\nIn the first test case the optimal strategy is to remove the point with coordinate 4. The remaining points will have coordinates 1 and 2, so the diameter will be equal to 2 - 1 = 1.\n\nIn the second test case the diameter is equal to 0, so its is unnecessary to remove any points. \n\nIn the third test case the optimal strategy is to remove points with coordinates 1, 9 and 10. The remaining points will have coordinates 3, 4 and 6, so the diameter will be equal to 6 - 3 = 3.",
        "task_name": "940_A. Points on the line",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "R = raw_input()\nQ = R.split()\ng = int(Q[1])\nW = raw_input()\nV = W.split()\nl = len(V)\n\nB = []\nfor i in range(l):\n\tB.append(int(V[i]))\n\nA = sorted(B)\ncount = l\nk = 0\nfor i in range(l):\n\twhile(A[k] - A[i] <= g):\n\t\tk += 1\n\t\tif(k == l):\n\t\t\tbreak\n\tif l-k+i < count:\n\t\tcount = l-k+i\n\t\trm_elem_lower = A[:i]  #elements before index 'i'\n\t\trm_elem_upper = A[k:]  #elements from index 'k'\n\t\trm_elem_total = rm_elem_lower + rm_elem_upper\n\n\tif(k == l):\n\t\tbreak\n\t\t\nprint(count)",
        "correct": true,
        "task_id": "0289",
        "depth": 2
    },
    {
        "description": "We have N switches with \"on\" and \"off\" state, and M bulbs. The switches are numbered 1 to N, and the bulbs are numbered 1 to M.\n\nBulb i is connected to k_i switches: Switch s_{i1}, s_{i2}, ..., and s_{ik_i}. It is lighted when the number of switches that are \"on\" among these switches is congruent to p_i modulo 2.\n\nHow many combinations of \"on\" and \"off\" states of the switches light all the bulbs?\n\nConstraints\n\n* 1 \\leq N, M \\leq 10\n* 1 \\leq k_i \\leq N\n* 1 \\leq s_{ij} \\leq N\n* s_{ia} \\neq s_{ib} (a \\neq b)\n* p_i is 0 or 1.\n* All values in input are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M\nk_1 s_{11} s_{12} ... s_{1k_1}\n:\nk_M s_{M1} s_{M2} ... s_{Mk_M}\np_1 p_2 ... p_M\n\n\nOutput\n\nPrint the number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs.\n\nExamples\n\nInput\n\n2 2\n2 1 2\n1 2\n0 1\n\n\nOutput\n\n1\n\n\nInput\n\n2 3\n2 1 2\n1 1\n1 2\n0 0 1\n\n\nOutput\n\n0\n\n\nInput\n\n5 2\n3 1 2 5\n2 2 3\n1 0\n\n\nOutput\n\n8",
        "task_name": "p03031 AtCoder Beginner Contest 128 - Switches",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def multy(a,b):\n\tc = 0\n\tfor i in range(len(a)):\n\t\tc += a[i]*b[i]\n\treturn c\nN,M = map(int, raw_input().split())\nks = []\nfor i in range(M):\n\tks2 = map(int, raw_input().split())\n\tks.append(ks2)\npm = map(int, raw_input().split())\nplist = []\nfor i in ks:\n\tt = [0]*N\n\tini = 1\n\tfor j in i:\n\t\tif(ini == 1):\n\t\t\tini = 0\n\t\t\tcontinue\n\t\telse:\n\t\t\tt[j-1] = 1\n\tplist.append(t)\nslist = []\nfor i in range(2**N):\n\tt = []\n\tfor j in range(N):\n\t\tt.append(i%2)\n\t\ti = i/2\n\tslist.append(t)\nr = 0\nfor p in plist:\n\ts2 = []\n\tfor s in slist:\n\t\tif(multy(p,s)%2 == pm[r]):\n\t\t\ts2.append(s)\n\tr = r+1\n\tslist = s2\nprint(len(slist))",
        "correct": true,
        "task_id": "0293",
        "depth": 2
    },
    {
        "description": "The Third Doctor Who once correctly said that travel between parallel universes is \"like travelling sideways\". However, he incorrectly thought that there were infinite parallel universes, whereas in fact, as we now all know, there will never be more than 250.\n\nHeidi recently got her hands on a multiverse observation tool. She was able to see all n universes lined up in a row, with non-existent links between them. She also noticed that the Doctor was in the k-th universe.\n\nThe tool also points out that due to restrictions originating from the space-time discontinuum, the number of universes will never exceed m.\n\nObviously, the multiverse is unstable because of free will. Each time a decision is made, one of two events will randomly happen: a new parallel universe is created, or a non-existent link is broken.\n\nMore specifically, \n\n  * When a universe is created, it will manifest itself between any two adjacent universes or at one of the ends. \n  * When a link is broken, it could be cut between any two adjacent universes. After separating the multiverse into two segments, the segment NOT containing the Doctor will cease to exist. \n\n\n\nHeidi wants to perform a simulation of t decisions. Each time a decision is made, Heidi wants to know the length of the multiverse (i.e. the number of universes), and the position of the Doctor.\n\nInput\n\nThe first line contains four integers n, k, m and t (2 \u2264 k \u2264 n \u2264 m \u2264 250, 1 \u2264 t \u2264 1000).\n\nEach of the following t lines is in one of the following formats: \n\n  * \"1 i\" \u2014 meaning that a universe is inserted at the position i (1 \u2264 i \u2264 l + 1), where l denotes the current length of the multiverse. \n  * \"0 i\" \u2014 meaning that the i-th link is broken (1 \u2264 i \u2264 l - 1), where l denotes the current length of the multiverse. \n\nOutput\n\nOutput t lines. Each line should contain l, the current length of the multiverse and k, the current position of the Doctor.\n\nIt is guaranteed that the sequence of the steps will be valid, i.e. the multiverse will have length at most m and when the link breaking is performed, there will be at least one universe in the multiverse.\n\nExample\n\nInput\n\n\n5 2 10 4\n0 1\n1 1\n0 4\n1 2\n\n\nOutput\n\n\n4 1\n5 2\n4 2\n5 3\n\nNote\n\nThe multiverse initially consisted of 5 universes, with the Doctor being in the second.\n\nFirst, link 1 was broken, leaving the multiverse with 4 universes, and the Doctor in the first.\n\nThen, a universe was added to the leftmost end of the multiverse, increasing the multiverse length to 5, and the Doctor was then in the second universe.\n\nThen, the rightmost link was broken.\n\nFinally, a universe was added between the first and the second universe.",
        "task_name": "1184_D1. Parallel Universes (Easy)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"                         \nBeautiful is better than ugly.\n    Explicit is better than implicit.\nSimple is better than complex.\n    Complex is better than complicated.\nFlat is better than nested.\n    Sparse is better than dense.\n                    \n    * Readability counts *\n\n // Author : raj1307 - Raj Singh\n // Date   : 7.07.19\n\n\"\"\"\n\nfrom __future__ import division, print_function\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    _str = str\n    str = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial,pow,pi\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod,MOD=1000000007,998244353\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [i for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p1\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n# For getting input from input.txt file \n#sys.stdin = open('input.txt', 'r')  \n  \n# Printing the Output to output.txt file \n#sys.stdout = open('output.txt', 'w') \n\n    \n\ndef main():\n    \n    \n    n,k,m,t=mi()\n    \n    for i in range(t):\n        \n        a,b=mi()\n        \n        if a==1:\n            n+=1\n            if b<=k:\n                k+=1\n            \n        else:\n            \n            if b<k:\n                n-=b\n                k-=b\n            else:\n                n-=(n-b)\n        \n        print(n,k)\n            \n            \n    \n    \n    \n    \n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        if self.buffer.tell():\n            return self.buffer.read()\n        return os.read(self._fd, os.fstat(self._fd).st_size)\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", b\" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", b\"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(b\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n    #dmain()",
        "correct": true,
        "task_id": "0307",
        "depth": 1
    },
    {
        "description": "You are given n points on a plane. All points are different.\n\nFind the number of different groups of three points (A, B, C) such that point B is the middle of segment AC. \n\nThe groups of three points are considered unordered, that is, if point B is the middle of segment AC, then groups (A, B, C) and (C, B, A) are considered the same.\n\nInput\n\nThe first line contains a single integer n (3 \u2264 n \u2264 3000) \u2014 the number of points. \n\nNext n lines contain the points. The i-th line contains coordinates of the i-th point: two space-separated integers xi, yi ( - 1000 \u2264 xi, yi \u2264 1000).\n\nIt is guaranteed that all given points are different.\n\nOutput\n\nPrint the single number \u2014 the answer to the problem. \n\nExamples\n\nInput\n\n3\n1 1\n2 2\n3 3\n\n\nOutput\n\n1\n\n\nInput\n\n3\n0 0\n-1 0\n0 1\n\n\nOutput\n\n0",
        "task_name": "181_B. Number of Triplets",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "s, n = 0, int(raw_input())\na = [0] * n\nfor i in range(n):\n    x, y = map(int, raw_input().split())\n    a[i] = 10000 * (x + 1000) + y + 1000\na.sort()\nb = set(2 * k for k in a)\nfor i, u in enumerate(a, 2):        \n    for v in a[i: ]:\n        if v + u in b: s += 1 \nprint(s)",
        "correct": true,
        "task_id": "0318",
        "depth": 2
    },
    {
        "description": "Vitaly has an array of n distinct integers. Vitaly wants to divide this array into three non-empty sets so as the following conditions hold: \n\n  1. The product of all numbers in the first set is less than zero ( < 0). \n  2. The product of all numbers in the second set is greater than zero ( > 0). \n  3. The product of all numbers in the third set is equal to zero. \n  4. Each number from the initial array must occur in exactly one set. \n\n\n\nHelp Vitaly. Divide the given array.\n\nInput\n\nThe first line of the input contains integer n (3 \u2264 n \u2264 100). The second line contains n space-separated distinct integers a1, a2, ..., an (|ai| \u2264 103) \u2014 the array elements.\n\nOutput\n\nIn the first line print integer n1 (n1 > 0) \u2014 the number of elements in the first set. Then print n1 numbers \u2014 the elements that got to the first set.\n\nIn the next line print integer n2 (n2 > 0) \u2014 the number of elements in the second set. Then print n2 numbers \u2014 the elements that got to the second set.\n\nIn the next line print integer n3 (n3 > 0) \u2014 the number of elements in the third set. Then print n3 numbers \u2014 the elements that got to the third set.\n\nThe printed sets must meet the described conditions. It is guaranteed that the solution exists. If there are several solutions, you are allowed to print any of them.\n\nExamples\n\nInput\n\n3\n-1 2 0\n\n\nOutput\n\n1 -1\n1 2\n1 0\n\n\nInput\n\n4\n-1 -2 -3 0\n\n\nOutput\n\n1 -1\n2 -3 -2\n1 0",
        "task_name": "300_A. Array",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\na = map(int, raw_input().split())\nzero = [i for i in a if i == 0]\npos = [i for i in a if i > 0]\nneg = [i for i in a if i < 0]\nif len(pos) == 0:\n    pos.append(neg.pop())\n    pos.append(neg.pop())\nif len(neg) % 2 == 0:\n    zero.append(neg.pop())\ns = str(len(neg))\nfor i in neg:\n    s += ' ' + str(i)\nprint(s)\ns = str(len(zero))\nfor i in zero:\n    s += ' ' + str(i)\nprint(s)\ns = str(len(pos))\nfor i in pos:\n    s += ' ' + str(i)\nprint(s)\n",
        "correct": false,
        "task_id": "0320",
        "depth": 1
    },
    {
        "description": "There are n kangaroos with pockets. Each kangaroo has a size (integer number). A kangaroo can go into another kangaroo's pocket if and only if the size of kangaroo who hold the kangaroo is at least twice as large as the size of kangaroo who is held.\n\nEach kangaroo can hold at most one kangaroo, and the kangaroo who is held by another kangaroo cannot hold any kangaroos.\n\nThe kangaroo who is held by another kangaroo cannot be visible from outside. Please, find a plan of holding kangaroos with the minimal number of kangaroos who is visible.\n\nInput\n\nThe first line contains a single integer \u2014 n (1 \u2264 n \u2264 5\u00b7105). Each of the next n lines contains an integer si \u2014 the size of the i-th kangaroo (1 \u2264 si \u2264 105).\n\nOutput\n\nOutput a single integer \u2014 the optimal number of visible kangaroos.\n\nExamples\n\nInput\n\n8\n2\n5\n7\n6\n9\n8\n4\n2\n\n\nOutput\n\n5\n\n\nInput\n\n8\n9\n1\n6\n2\n6\n5\n8\n3\n\n\nOutput\n\n5",
        "task_name": "372_A. Counting Kangaroos is Fun",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\n\ndef main(arr):\n    if len(arr) == 1:\n        return 1\n\n    arr.sort()\n    start = 0\n    move = len(arr) // 2\n    ans = len(arr)\n    while move < len(arr):\n        if arr[start] is None:\n            move += 1\n        elif arr[start] * 2 > arr[move]:\n            # Try to find a match for start.\n            move += 1\n        else:\n            # Can do a grouping.\n            arr[move] = None\n            ans -= 1\n            move += 1\n            start += 1\n    return ans\n\n\nif __name__ == \"__main__\":\n    arr = []\n    for e, line in enumerate(sys.stdin.readlines()):\n        if e == 0:\n            continue\n        arr.append(int(line.strip()))\n    print(main(arr))\n",
        "correct": true,
        "task_id": "0321",
        "depth": 1
    },
    {
        "description": "There are n servers in a laboratory, each of them can perform tasks. Each server has a unique id \u2014 integer from 1 to n.\n\nIt is known that during the day q tasks will come, the i-th of them is characterized with three integers: ti \u2014 the moment in seconds in which the task will come, ki \u2014 the number of servers needed to perform it, and di \u2014 the time needed to perform this task in seconds. All ti are distinct.\n\nTo perform the i-th task you need ki servers which are unoccupied in the second ti. After the servers begin to perform the task, each of them will be busy over the next di seconds. Thus, they will be busy in seconds ti, ti + 1, ..., ti + di - 1. For performing the task, ki servers with the smallest ids will be chosen from all the unoccupied servers. If in the second ti there are not enough unoccupied servers, the task is ignored.\n\nWrite the program that determines which tasks will be performed and which will be ignored.\n\nInput\n\nThe first line contains two positive integers n and q (1 \u2264 n \u2264 100, 1 \u2264 q \u2264 105) \u2014 the number of servers and the number of tasks. \n\nNext q lines contains three integers each, the i-th line contains integers ti, ki and di (1 \u2264 ti \u2264 106, 1 \u2264 ki \u2264 n, 1 \u2264 di \u2264 1000) \u2014 the moment in seconds in which the i-th task will come, the number of servers needed to perform it, and the time needed to perform this task in seconds. The tasks are given in a chronological order and they will come in distinct seconds. \n\nOutput\n\nPrint q lines. If the i-th task will be performed by the servers, print in the i-th line the sum of servers' ids on which this task will be performed. Otherwise, print -1.\n\nExamples\n\nInput\n\n4 3\n1 3 2\n2 2 1\n3 4 3\n\n\nOutput\n\n6\n-1\n10\n\n\nInput\n\n3 2\n3 2 3\n5 1 2\n\n\nOutput\n\n3\n3\n\n\nInput\n\n8 6\n1 3 20\n4 2 1\n6 5 5\n10 1 1\n15 3 6\n21 8 8\n\n\nOutput\n\n6\n9\n30\n-1\n15\n36\n\nNote\n\nIn the first example in the second 1 the first task will come, it will be performed on the servers with ids 1, 2 and 3 (the sum of the ids equals 6) during two seconds. In the second 2 the second task will come, it will be ignored, because only the server 4 will be unoccupied at that second. In the second 3 the third task will come. By this time, servers with the ids 1, 2 and 3 will be unoccupied again, so the third task will be done on all the servers with the ids 1, 2, 3 and 4 (the sum of the ids is 10).\n\nIn the second example in the second 3 the first task will come, it will be performed on the servers with ids 1 and 2 (the sum of the ids is 3) during three seconds. In the second 5 the second task will come, it will be performed on the server 3, because the first two servers will be busy performing the first task.",
        "task_name": "747_C. Servers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nfrom collections import deque\nn, q = map(int, stdin.readline().split())\nqueue = deque()\ncnt = 0\n\n\ndef mergesort(l, r):\n    if r != l:\n        ind = (r + l) // 2\n        mergesort(l, ind)\n        mergesort(ind + 1, r)\n        merge(l, ind, ind + 1, r)\n\n\ndef merge(lf, rf, ls, rs):\n    a = []\n    ind1 = lf\n    ind2 = ls\n    \n    while (ind1 <= rf and ind2 <= rs):\n        if queue[ind1] < queue[ind2]:\n            a.append(queue[ind1])\n            ind1 += 1\n        else:\n            a.append(queue[ind2])\n            ind2 += 1\n    \n    while (ind1 <= rf):\n        a.append(queue[ind1])\n        ind1 += 1\n    \n    while (ind2 <= rs):\n        a.append(queue[ind2])\n        ind2 += 1\n    \n    for i in range(lf, rs + 1):\n        queue[i] = a[i - lf]\n            \n\nused = [0 for i in range(n + 1)]\nlabel = 1\nfor i in range(q):\n    s = set()\n    tc, k, tp = map(int, stdin.readline().split())\n    \n    if queue:\n        mergesort(0, len(queue) - 1)\n    \n    while (queue and tc >= queue[0][0]):\n        s.add(queue[0][2])\n        cnt -= queue[0][1]\n        queue.popleft()\n\n    for i in range(1, n + 1):\n        if used[i] in s:\n            used[i] = 0\n    \n    if cnt + k <= n:\n        ans = 0\n        value = 0\n        for i in range(1, n + 1):\n            if not used[i]:\n                ans += i\n                value += 1\n                used[i] = label\n            if value == k:\n                break\n            \n        stdout.write(str(ans) + '\\n')\n        cnt += k\n        queue.append((tc + tp, k, label))\n        label += 1\n    else:\n        stdout.write('-1\\n')\n        ",
        "correct": true,
        "task_id": "0331",
        "depth": 2
    },
    {
        "description": "Oleg the client and Igor the analyst are good friends. However, sometimes they argue over little things. Recently, they started a new company, but they are having trouble finding a name for the company.\n\nTo settle this problem, they've decided to play a game. The company name will consist of n letters. Oleg and Igor each have a set of n letters (which might contain multiple copies of the same letter, the sets can be different). Initially, the company name is denoted by n question marks. Oleg and Igor takes turns to play the game, Oleg moves first. In each turn, a player can choose one of the letters c in his set and replace any of the question marks with c. Then, a copy of the letter c is removed from his set. The game ends when all the question marks has been replaced by some letter.\n\nFor example, suppose Oleg has the set of letters {i, o, i} and Igor has the set of letters {i, m, o}. One possible game is as follows :\n\nInitially, the company name is ???.\n\nOleg replaces the second question mark with 'i'. The company name becomes ?i?. The set of letters Oleg have now is {i, o}.\n\nIgor replaces the third question mark with 'o'. The company name becomes ?io. The set of letters Igor have now is {i, m}.\n\nFinally, Oleg replaces the first question mark with 'o'. The company name becomes oio. The set of letters Oleg have now is {i}.\n\nIn the end, the company name is oio.\n\nOleg wants the company name to be as lexicographically small as possible while Igor wants the company name to be as lexicographically large as possible. What will be the company name if Oleg and Igor always play optimally?\n\nA string s = s1s2...sm is called lexicographically smaller than a string t = t1t2...tm (where s \u2260 t) if si < ti where i is the smallest index such that si \u2260 ti. (so sj = tj for all j < i)\n\nInput\n\nThe first line of input contains a string s of length n (1 \u2264 n \u2264 3\u00b7105). All characters of the string are lowercase English letters. This string denotes the set of letters Oleg has initially.\n\nThe second line of input contains a string t of length n. All characters of the string are lowercase English letters. This string denotes the set of letters Igor has initially.\n\nOutput\n\nThe output should contain a string of n lowercase English letters, denoting the company name if Oleg and Igor plays optimally.\n\nExamples\n\nInput\n\ntinkoff\nzscoder\n\n\nOutput\n\nfzfsirk\n\n\nInput\n\nxxxxxx\nxxxxxx\n\n\nOutput\n\nxxxxxx\n\n\nInput\n\nioi\nimo\n\n\nOutput\n\nioi\n\nNote\n\nOne way to play optimally in the first sample is as follows :\n\n  * Initially, the company name is ???????.\n  * Oleg replaces the first question mark with 'f'. The company name becomes f??????.\n  * Igor replaces the second question mark with 'z'. The company name becomes fz?????.\n  * Oleg replaces the third question mark with 'f'. The company name becomes fzf????.\n  * Igor replaces the fourth question mark with 's'. The company name becomes fzfs???.\n  * Oleg replaces the fifth question mark with 'i'. The company name becomes fzfsi??.\n  * Igor replaces the sixth question mark with 'r'. The company name becomes fzfsir?.\n  * Oleg replaces the seventh question mark with 'k'. The company name becomes fzfsirk.\n\n\n\nFor the second sample, no matter how they play, the company name will always be xxxxxx.",
        "task_name": "794_C. Naming Company",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division\nfrom sys import stdin\nfrom math import ceil\n\nrstr = lambda: stdin.readline().strip()\ns, t = sorted(rstr()), sorted(rstr(), reverse=True)\nle = len(s)\n\nif le == 1:\n    print(s[0])\nelif le == 2:\n    print(min(s[0] + t[0], t[0] + s[0]))\nelif s[0] <= t[0]:\n    ans = []\n    for i in range(le):\n        ans.append(t[i >> 1] if (i & 1) else s[i >> 1])\n\n    if le & 1 and ans[-1] > ans[-2]:\n        ans[-1], ans[-2] = ans[-2], ans[-1]\n\n    print(''.join(ans))\nelse:\n    mds, mdt, ans = int(ceil(le / 2)) - 1, (le >> 1) - 1, []\n    for i in range(le):\n        if i & 1:\n            ans.append(t[mdt])\n            mdt -= 1\n        else:\n            ans.append(s[mds])\n            mds -= 1\n\n    print(''.join(ans[::-1]))\n",
        "correct": false,
        "task_id": "0332",
        "depth": 1
    },
    {
        "description": "Karen has just arrived at school, and she has a math test today!\n\n<image>\n\nThe test is about basic addition and subtraction. Unfortunately, the teachers were too busy writing tasks for Codeforces rounds, and had no time to make an actual test. So, they just put one question in the test that is worth all the points.\n\nThere are n integers written on a row. Karen must alternately add and subtract each pair of adjacent integers, and write down the sums or differences on the next row. She must repeat this process on the values on the next row, and so on, until only one integer remains. The first operation should be addition.\n\nNote that, if she ended the previous row by adding the integers, she should start the next row by subtracting, and vice versa.\n\nThe teachers will simply look at the last integer, and then if it is correct, Karen gets a perfect score, otherwise, she gets a zero for the test.\n\nKaren has studied well for this test, but she is scared that she might make a mistake somewhere and it will cause her final answer to be wrong. If the process is followed, what number can she expect to be written on the last row?\n\nSince this number can be quite large, output only the non-negative remainder after dividing it by 109 + 7.\n\nInput\n\nThe first line of input contains a single integer n (1 \u2264 n \u2264 200000), the number of numbers written on the first row.\n\nThe next line contains n integers. Specifically, the i-th one among these is ai (1 \u2264 ai \u2264 109), the i-th number on the first row.\n\nOutput\n\nOutput a single integer on a line by itself, the number on the final row after performing the process above.\n\nSince this number can be quite large, print only the non-negative remainder after dividing it by 109 + 7.\n\nExamples\n\nInput\n\n5\n3 6 9 12 15\n\n\nOutput\n\n36\n\n\nInput\n\n4\n3 7 5 2\n\n\nOutput\n\n1000000006\n\nNote\n\nIn the first test case, the numbers written on the first row are 3, 6, 9, 12 and 15.\n\nKaren performs the operations as follows:\n\n<image>\n\nThe non-negative remainder after dividing the final number by 109 + 7 is still 36, so this is the correct output.\n\nIn the second test case, the numbers written on the first row are 3, 7, 5 and 2.\n\nKaren performs the operations as follows:\n\n<image>\n\nThe non-negative remainder after dividing the final number by 109 + 7 is 109 + 6, so this is the correct output.",
        "task_name": "815_B. Karen and Test",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def binseq(n,p):\n    l = [1]*(n+1)\n    for i in range(n):\n        l[i+1] = (l[i]*(n-i)*pow(i+1,p-2,p)) % p\n    return l\ndef altseq(n,p):\n    l = []\n    if n % 4 == 0:\n        for e in binseq(n//2-1,p):\n            l+=[e,-e]\n        return l\n    if n % 4 == 1:\n        for e in binseq(n//2,p):\n            l+=[e,0]\n        l.pop(-1)\n        return l\n    if n % 4 == 2:\n        for e in binseq(n//2-1,p):\n            l+=[e,e]\n        return l\n    pre_l = []\n    for e in binseq(n//2-1,p):\n        pre_l += [e,e]\n    l.append(pre_l[0])\n    for i in range(1,n-1):\n        l.append(pre_l[i] + pre_l[i-1]*(-1)**(i+1))\n    l.append(pre_l[n-2]*(-1)**n)\n    return l\nif __name__ == '__main__':\n    n = int(raw_input())\n    s = altseq(n,10**9+7)\n    t = 0\n    l = map(lambda x: int(x), raw_input().split(\" \"))\n    for i in range(n):\n        t += s[i]*l[i]\n        t %= 10**9+7\n    print(str(t))\n",
        "correct": true,
        "task_id": "0333",
        "depth": 1
    },
    {
        "description": "Mishka received a gift of multicolored pencils for his birthday! Unfortunately he lives in a monochrome world, where everything is of the same color and only saturation differs. This pack can be represented as a sequence a1, a2, ..., an of n integer numbers \u2014 saturation of the color of each pencil. Now Mishka wants to put all the mess in the pack in order. He has an infinite number of empty boxes to do this. He would like to fill some boxes in such a way that:\n\n  * Each pencil belongs to exactly one box; \n  * Each non-empty box has at least k pencils in it; \n  * If pencils i and j belong to the same box, then |ai - aj| \u2264 d, where |x| means absolute value of x. Note that the opposite is optional, there can be pencils i and j such that |ai - aj| \u2264 d and they belong to different boxes. \n\n\n\nHelp Mishka to determine if it's possible to distribute all the pencils into boxes. Print \"YES\" if there exists such a distribution. Otherwise print \"NO\".\n\nInput\n\nThe first line contains three integer numbers n, k and d (1 \u2264 k \u2264 n \u2264 5\u00b7105, 0 \u2264 d \u2264 109) \u2014 the number of pencils, minimal size of any non-empty box and maximal difference in saturation between any pair of pencils in the same box, respectively.\n\nThe second line contains n integer numbers a1, a2, ..., an (1 \u2264 ai \u2264 109) \u2014 saturation of color of each pencil.\n\nOutput\n\nPrint \"YES\" if it's possible to distribute all the pencils into boxes and satisfy all the conditions. Otherwise print \"NO\".\n\nExamples\n\nInput\n\n6 3 10\n7 2 7 7 4 2\n\n\nOutput\n\nYES\n\n\nInput\n\n6 2 3\n4 5 3 13 4 10\n\n\nOutput\n\nYES\n\n\nInput\n\n3 2 5\n10 16 22\n\n\nOutput\n\nNO\n\nNote\n\nIn the first example it is possible to distribute pencils into 2 boxes with 3 pencils in each with any distribution. And you also can put all the pencils into the same box, difference of any pair in it won't exceed 10.\n\nIn the second example you can split pencils of saturations [4, 5, 3, 4] into 2 boxes of size 2 and put the remaining ones into another box.",
        "task_name": "985_E. Pencils and Boxes",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from bisect import bisect\nfrom sys import exit\n\n[n, k, d] = map(int,raw_input().strip().split())\nais = list(map(int,raw_input().strip().split()))\nif k == 1:\n\tprint ('YES')\n\texit()\n\nais.sort()\n\n# can do ais[i:]\ncando = [False for _ in range(n)]\nj = n - 1 \ncount = 0 \nfor i in reversed(range(n)):\n\tif i + k < n and cando[i + k]:\n\t\tcount += 1\n\tif n - i < k:\n\t\tcontinue\n\tif ais[-1] - ais[i] <= d:\n\t\tcando[i] = True\n\t\tcontinue\n\twhile ais[j - 1] > ais[i] + d:\n\t\tif cando[j]:\n\t\t\tcount -= 1\n\t\tj -= 1\n\tcando[i] = (count > 0)\n\t\n\nif cando[0]:\n\tprint ('YES')\nelse:\n\tprint ('NO')",
        "correct": true,
        "task_id": "0336",
        "depth": 2
    },
    {
        "description": "We have N integers. The i-th integer is A_i.\n\nFind \\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N} (A_i \\mbox{ XOR } A_j), modulo (10^9+7).\n\nWhat is \\mbox{ XOR }?\n\nThe XOR of integers A and B, A \\mbox{ XOR } B, is defined as follows:\n\n* When A \\mbox{ XOR } B is written in base two, the digit in the 2^k's place (k \\geq 0) is 1 if either A or B, but not both, has 1 in the 2^k's place, and 0 otherwise.\n\nFor example, 3 \\mbox{ XOR } 5 = 6. (In base two: 011 \\mbox{ XOR } 101 = 110.)\n\nConstraints\n\n* 2 \\leq N \\leq 3 \\times 10^5\n* 0 \\leq A_i < 2^{60}\n* All values in input are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nA_1 A_2 ... A_N\n\n\nOutput\n\nPrint the value \\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N} (A_i \\mbox{ XOR } A_j), modulo (10^9+7).\n\nExamples\n\nInput\n\n3\n1 2 3\n\n\nOutput\n\n6\n\n\nInput\n\n10\n3 1 4 1 5 9 2 6 5 3\n\n\nOutput\n\n237\n\n\nInput\n\n10\n3 14 159 2653 58979 323846 2643383 27950288 419716939 9375105820\n\n\nOutput\n\n103715602",
        "task_name": "p02838 AtCoder Beginner Contest 147 - Xor Sum 4",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\ninput = sys.stdin.readline\n# sys.setrecursionlimit(100000)\n\n\ndef solve(n, arr):\n    sum = 0\n    bitcount = [0]*100\n    for num in arr:\n        b = reversed(bin(num)[2:])\n        for i, s in enumerate(b):\n            if i != \"0\":\n                bitcount[i] += int(s)\n    for i, b in enumerate(bitcount):\n        sum += b * (n-b) * 2**i\n    return sum % (10**9 + 7)\n\n\ndef main():\n    N = int(input())\n    A_l = [int(i) for i in input().split()]\n    print(solve(N, A_l))\n\n\nif __name__ == \"__main__\":\n    main()",
        "correct": true,
        "task_id": "0339",
        "depth": 2
    },
    {
        "description": "You are given n segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.\n\nYour task is the following: for every k \u2208 [1..n], calculate the number of points with integer coordinates such that the number of segments that cover these points equals k. A segment with endpoints l_i and r_i covers point x if and only if l_i \u2264 x \u2264 r_i.\n\nInput\n\nThe first line of the input contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of segments.\n\nThe next n lines contain segments. The i-th line contains a pair of integers l_i, r_i (0 \u2264 l_i \u2264 r_i \u2264 10^{18}) \u2014 the endpoints of the i-th segment.\n\nOutput\n\nPrint n space separated integers cnt_1, cnt_2, ..., cnt_n, where cnt_i is equal to the number of points such that the number of segments that cover these points equals to i.\n\nExamples\n\nInput\n\n3\n0 3\n1 3\n3 8\n\n\nOutput\n\n6 2 1 \n\n\nInput\n\n3\n1 3\n2 4\n5 7\n\n\nOutput\n\n5 2 0 \n\nNote\n\nThe picture describing the first example:\n\n<image>\n\nPoints with coordinates [0, 4, 5, 6, 7, 8] are covered by one segment, points [1, 2] are covered by two segments and point [3] is covered by three segments.\n\nThe picture describing the second example:\n\n<image>\n\nPoints [1, 4, 5, 6, 7] are covered by one segment, points [2, 3] are covered by two segments and there are no points covered by three segments.",
        "task_name": "1000_C. Covered Points Count",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\" \n3\n0 3\n1 3\n3 8\n\"\"\"\n\nimport sys\nimport bisect\nimport heapq\nimport math\n\nsys.setrecursionlimit(10**9+7)\n\ndef fi():\n    return int(sys.stdin.readline())\ndef fi2():\n    return map(int, sys.stdin.readline().split())\ndef fi3():\n    return sys.stdin.readline().rstrip()\ndef fo(*args):\n    for s in args:\n        sys.stdout.write(str(s)+' ')\n    sys.stdout.write('\\n')\n##    sys.stdout.flush()\ndef puts(*args):\n    for s in args:\n        sys.stdout.write(str(s))\n\n##\nOUT = []\ndef bfo(*args):\n    for s in args:\n        OUT.append(str(s)+' ')\n    OUT.append('\\n')\ndef bputs(*args):\n    for s in args:\n        OUT.append(str(s))        \ndef flush():\n    sto = ''.join(OUT)\n    fo(sto)\n##\n\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nnax = 101010\nmod = 10**9+7\ninf = 10**18+5\n\n##\n\n\n##\n#main\n\nn = fi()\nT = []\nM = []\nfor i in range(n):\n    a, b = fi2()\n    T.append((a, b))\n    M.append(a)\n    M.append(b)\n\nM.sort()\n\nf = {}\ninvf = {}\n\nfor x in M:\n    if x not in f:\n        f[x] = len(f)\n        invf[len(f)-1] = x\n\ncomp = len(f)\n\nF = [0 for i in range(comp+5)]\nE = [0 for i in range(comp+5)]\n\nfor t in T:\n    a, b = t\n    a = f[a]\n    b = f[b]\n    E[b] += 1\n    F[a] += 1\n    F[b+1] -= 1\n\nfor i in range(1, len(F)):\n    F[i] = F[i-1]+F[i]\n\nres = [0 for i in range(n+1)]\n\nfor i in range(comp):\n    k = F[i]\n    res[k] += 1\n\nfor i in range(comp-1):\n    k = F[i] - E[i]\n    res[k] += (invf[i+1]-invf[i]-1)\n\nfor i in range(1, n+1):\n    bputs(res[i],' ')\n\nflush()\n",
        "correct": true,
        "task_id": "0345",
        "depth": 1
    },
    {
        "description": "In a very ancient country the following game was popular. Two people play the game. Initially first player writes a string s1, consisting of exactly nine digits and representing a number that does not exceed a. After that second player looks at s1 and writes a string s2, consisting of exactly nine digits and representing a number that does not exceed b. Here a and b are some given constants, s1 and s2 are chosen by the players. The strings are allowed to contain leading zeroes.\n\nIf a number obtained by the concatenation (joining together) of strings s1 and s2 is divisible by mod, then the second player wins. Otherwise the first player wins. You are given numbers a, b, mod. Your task is to determine who wins if both players play in the optimal manner. If the first player wins, you are also required to find the lexicographically minimum winning move.\n\nInput\n\nThe first line contains three integers a, b, mod (0 \u2264 a, b \u2264 109, 1 \u2264 mod \u2264 107).\n\nOutput\n\nIf the first player wins, print \"1\" and the lexicographically minimum string s1 he has to write to win. If the second player wins, print the single number \"2\".\n\nExamples\n\nInput\n\n1 10 7\n\n\nOutput\n\n2\n\n\nInput\n\n4 0 9\n\n\nOutput\n\n1 000000001\n\nNote\n\nThe lexical comparison of strings is performed by the < operator in modern programming languages. String x is lexicographically less than string y if exists such i (1 \u2264 i \u2264 9), that xi < yi, and for any j (1 \u2264 j < i) xj = yj. These strings always have length 9.",
        "task_name": "117_B. Very Interesting Game",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\na,b,m=map(int,raw_input().split())\nfor i in range (1,min(a+1,m+1)):\n    if (m-i*(10**9)%m)%m>b:\n        print(1,'%(x)09d'%{'x':i})\n        sys.exit()\nprint(2)",
        "correct": false,
        "task_id": "0348",
        "depth": 1
    },
    {
        "description": "You are given a sequence a_1, a_2, ..., a_n consisting of n non-zero integers (i.e. a_i \u2260 0). \n\nYou have to calculate two following values:\n\n  1. the number of pairs of indices (l, r) (l \u2264 r) such that a_l \u22c5 a_{l + 1} ... a_{r - 1} \u22c5 a_r is negative; \n  2. the number of pairs of indices (l, r) (l \u2264 r) such that a_l \u22c5 a_{l + 1} ... a_{r - 1} \u22c5 a_r is positive; \n\nInput\n\nThe first line contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^{5}) \u2014 the number of elements in the sequence.\n\nThe second line contains n integers a_1, a_2, ..., a_n (-10^{9} \u2264 a_i \u2264 10^{9}; a_i \u2260 0) \u2014 the elements of the sequence.\n\nOutput\n\nPrint two integers \u2014 the number of subsegments with negative product and the number of subsegments with positive product, respectively.\n\nExamples\n\nInput\n\n\n5\n5 -3 3 -1 1\n\n\nOutput\n\n\n8 7\n\n\nInput\n\n\n10\n4 2 -4 3 1 2 -4 3 2 3\n\n\nOutput\n\n\n28 27\n\n\nInput\n\n\n5\n-1 -2 -3 -4 -5\n\n\nOutput\n\n\n9 6",
        "task_name": "1215_B. The Number of Products",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport collections\nimport bisect\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nimport math\nn = int(raw_input())\nA = map(int, input().split())\nidx, size = 0, len(A)\ntotal = size * (1+size) / 2\np = [0] * size\nq = [0] * size\n\nif A[0] > 0:\n    p[0], q[0] = 1, 0\nelse:\n    q[0], p[0] = 1, 0\n\nfor i in xrange(1, size):\n    if A[i] > 0:\n        p[i] = p[i-1] + 1\n        q[i] = q[i-1]\n    else:\n        p[i] = q[i - 1]\n        q[i] = p[i-1] + 1\nprint('%s %s' % (sum(q), sum(p)))",
        "correct": true,
        "task_id": "0350",
        "depth": 1
    },
    {
        "description": "On the competitive programming platform CodeCook, every person has a rating graph described by an array of integers a of length n. You are now updating the infrastructure, so you've created a program to compress these graphs.\n\nThe program works as follows. Given an integer parameter k, the program takes the minimum of each contiguous subarray of length k in a.\n\nMore formally, for an array a of length n and an integer k, define the k-compression array of a as an array b of length n-k+1, such that $$$b_j =min_{j\u2264 i\u2264 j+k-1}a_i$$$\n\nFor example, the 3-compression array of [1, 3, 4, 5, 2] is [min\\{1, 3, 4\\}, min\\{3, 4, 5\\}, min\\{4, 5, 2\\}]=[1, 3, 2].\n\nA permutation of length m is an array consisting of m distinct integers from 1 to m in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (m=3 but there is 4 in the array).\n\nA k-compression array will make CodeCook users happy if it will be a permutation. Given an array a, determine for all 1\u2264 k\u2264 n if CodeCook users will be happy after a k-compression of this array or not.\n\nInput\n\nThe first line contains a single integer t (1\u2264 t\u2264 10^4) \u2014 the number of test cases.\n\nThe first line of the description of each test case contains a single integer n (1\u2264 n\u2264 3\u22c5 10^5) \u2014 the length of the array.\n\nThe second line of the description of each test case contains n integers a_1,\u2026,a_n (1\u2264 a_i\u2264 n) \u2014 the elements of the array.\n\nIt is guaranteed, that the sum of n for all test cases does not exceed 3\u22c5 10^5.\n\nOutput\n\nFor each test case, print a binary string of length n. \n\nThe k-th character of the string should be 1 if CodeCook users will be happy after a k-compression of the array a, and 0 otherwise. \n\nExample\n\nInput\n\n\n5\n5\n1 5 3 4 2\n4\n1 3 2 1\n5\n1 3 3 3 2\n10\n1 2 3 4 5 6 7 8 9 10\n3\n3 3 2\n\n\nOutput\n\n\n10111\n0001\n00111\n1111111111\n000\n\nNote\n\nIn the first test case, a=[1, 5, 3, 4, 2].\n\n  * The 1-compression of a is [1, 5, 3, 4, 2] and it is a permutation. \n  * The 2-compression of a is [1, 3, 3, 2] and it is not a permutation, since 3 appears twice. \n  * The 3-compression of a is [1, 3, 2] and it is a permutation. \n  * The 4-compression of a is [1, 2] and it is a permutation. \n  * The 5-compression of a is [1] and it is a permutation. ",
        "task_name": "1450_D. Rating Compression",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrint = lambda: int(stdin.readline())\nrints = lambda: [int(x) for x in stdin.readline().split()]\nout = []\nfor _ in range(int(input())):\n    n, a = rint(), rints()\n    ans, mem = ['0'] * n, [0] * (n + 1)\n    ans[0], l, r = '1', 0, n - 1\n\n    for i in range(n):\n        mem[a[i]] += 1\n        if mem[a[i]] == 2:\n            ans[0] = '0'\n\n    for i in range(1, n):\n        if not mem[i]:\n            break\n        ans[n - i] = '1'\n\n        if a[l] != i and a[r] != i or a[l] == a[r] == i:\n            break\n        elif a[l] == i:\n            l += 1\n        else:\n            r -= 1\n\n    out.append(''.join(ans))\n\nprint('\\n'.join(out))\n",
        "correct": false,
        "task_id": "0356",
        "depth": 2
    },
    {
        "description": "Sergey attends lessons of the N-ish language. Each lesson he receives a hometask. This time the task is to translate some sentence to the N-ish language. Sentences of the N-ish language can be represented as strings consisting of lowercase Latin letters without spaces or punctuation marks.\n\nSergey totally forgot about the task until half an hour before the next lesson and hastily scribbled something down. But then he recollected that in the last lesson he learned the grammar of N-ish. The spelling rules state that N-ish contains some \"forbidden\" pairs of letters: such letters can never occur in a sentence next to each other. Also, the order of the letters doesn't matter (for example, if the pair of letters \"ab\" is forbidden, then any occurrences of substrings \"ab\" and \"ba\" are also forbidden). Also, each pair has different letters and each letter occurs in no more than one forbidden pair.\n\nNow Sergey wants to correct his sentence so that it doesn't contain any \"forbidden\" pairs of letters that stand next to each other. However, he is running out of time, so he decided to simply cross out some letters from the sentence. What smallest number of letters will he have to cross out? When a letter is crossed out, it is \"removed\" so that the letters to its left and right (if they existed), become neighboring. For example, if we cross out the first letter from the string \"aba\", we get the string \"ba\", and if we cross out the second letter, we get \"aa\".\n\nInput\n\nThe first line contains a non-empty string s, consisting of lowercase Latin letters \u2014 that's the initial sentence in N-ish, written by Sergey. The length of string s doesn't exceed 105.\n\nThe next line contains integer k (0 \u2264 k \u2264 13) \u2014 the number of forbidden pairs of letters.\n\nNext k lines contain descriptions of forbidden pairs of letters. Each line contains exactly two different lowercase Latin letters without separators that represent the forbidden pairs. It is guaranteed that each letter is included in no more than one pair.\n\nOutput\n\nPrint the single number \u2014 the smallest number of letters that need to be removed to get a string without any forbidden pairs of neighboring letters. Please note that the answer always exists as it is always possible to remove all letters.\n\nExamples\n\nInput\n\nababa\n1\nab\n\n\nOutput\n\n2\n\n\nInput\n\ncodeforces\n2\ndo\ncs\n\n\nOutput\n\n1\n\nNote\n\nIn the first sample you should remove two letters b.\n\nIn the second sample you should remove the second or the third letter. The second restriction doesn't influence the solution.",
        "task_name": "155_C. Hometask",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\n# Created\n#       by zaquest\n#       on 01.03.2012\n\n\nclass Parser(object):\n\n    def __init__(self, string, pairs):\n        self.string = string\n        self.str_len = len(string)\n        self.pairs = pairs\n\n    def min_deletions(self):\n        deletions = 0\n        start = -1\n        for pair in self.pairs:\n            a = pair[0]\n            b = pair[1]\n            a_count = b_count = 0\n            i = 0\n            start = -1\n            stop = -1\n            while i < self.str_len:\n                if a == self.string[i]:\n                    a_count += 1\n                    if start == -1:\n                        start = i\n                elif b == self.string[i]:\n                    b_count += 1\n                    if start == -1:\n                        start = i\n                elif start != -1:\n                    stop = i\n                    if stop != start:\n                        if a_count > b_count:\n                            subs = a * a_count\n                            deletions += b_count\n                            i = start + a_count\n                            self.str_len -= b_count\n                        else:\n                            subs = b * b_count\n                            deletions += a_count\n                            i = start + b_count\n                            self.str_len -= a_count\n                        a_count = b_count = 0\n                        self.string = self.string[:start] + subs + self.string[stop:]\n                    start = -1\n                i += 1\n        if start != -1 and stop == -1:\n            if a_count > b_count:\n                deletions += b_count\n            else:\n                deletions += a_count\n\n        return deletions\n\n\ndef main():\n    string = raw_input()\n    pairs_num = input()\n    pairs = []\n    i = 0\n    while i < pairs_num:\n        pair = raw_input()\n        pairs.append(pair)\n        i += 1\n\n    parser = Parser(string, pairs)\n    print(parser.min_deletions())\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": false,
        "task_id": "0359",
        "depth": 2
    },
    {
        "description": "You've got a list of program warning logs. Each record of a log stream is a string in this format: \n\n\"2012-MM-DD HH:MM:SS:MESSAGE\" (without the quotes). \n\nString \"MESSAGE\" consists of spaces, uppercase and lowercase English letters and characters \"!\", \".\", \",\", \"?\". String \"2012-MM-DD\" determines a correct date in the year of 2012. String \"HH:MM:SS\" determines a correct time in the 24 hour format.\n\nThe described record of a log stream means that at a certain time the record has got some program warning (string \"MESSAGE\" contains the warning's description).\n\nYour task is to print the first moment of time, when the number of warnings for the last n seconds was not less than m.\n\nInput\n\nThe first line of the input contains two space-separated integers n and m (1 \u2264 n, m \u2264 10000).\n\nThe second and the remaining lines of the input represent the log stream. The second line of the input contains the first record of the log stream, the third line contains the second record and so on. Each record of the log stream has the above described format. All records are given in the chronological order, that is, the warning records are given in the order, in which the warnings appeared in the program. \n\nIt is guaranteed that the log has at least one record. It is guaranteed that the total length of all lines of the log stream doesn't exceed 5\u00b7106 (in particular, this means that the length of some line does not exceed 5\u00b7106 characters). It is guaranteed that all given dates and times are correct, and the string 'MESSAGE\" in all records is non-empty.\n\nOutput\n\nIf there is no sought moment of time, print -1. Otherwise print a string in the format \"2012-MM-DD HH:MM:SS\" (without the quotes) \u2014 the first moment of time when the number of warnings for the last n seconds got no less than m.\n\nExamples\n\nInput\n\n60 3\n2012-03-16 16:15:25: Disk size is\n2012-03-16 16:15:25: Network failute\n2012-03-16 16:16:29: Cant write varlog\n2012-03-16 16:16:42: Unable to start process\n2012-03-16 16:16:43: Disk size is too small\n2012-03-16 16:16:53: Timeout detected\n\n\nOutput\n\n2012-03-16 16:16:43\n\n\nInput\n\n1 2\n2012-03-16 23:59:59:Disk size\n2012-03-17 00:00:00: Network\n2012-03-17 00:00:01:Cant write varlog\n\n\nOutput\n\n-1\n\n\nInput\n\n2 2\n2012-03-16 23:59:59:Disk size is too sm\n2012-03-17 00:00:00:Network failute dete\n2012-03-17 00:00:01:Cant write varlogmysq\n\n\nOutput\n\n2012-03-17 00:00:00",
        "task_name": "245_F. Log Stream Analysis",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def Time(mon,day,hour,min,sec):\n    mons =[31,29,31,30,31,30,31,31,30,31,30,31]\n    days = 0\n    for i in range(mon):\n        days+=mons[i]\n    return (days+day)*86400+3600*hour+60*min+sec\nimport sys\nn,m = map(int,raw_input().split())\ntimes = []\na = sys.stdin.readlines()\nfor i in range(len(a)):\n    str1 = a[i]\n    MM = int(str1[5:7])\n    DD = int(str1[8:10])\n    HH = int(str1[11:13])\n    MIN = int(str1[14:16])\n    SEC = int(str1[17:19])\n    times.append(Time(MM,DD,HH,MIN,SEC))\nfor i in range(len(times)):\n    tmp = 0\n    j = i\n    bol = False\n    while j>=0 and times[i]-times[j]<n:\n        j-=1\n        tmp+=1\n    if tmp>=m:\n        print(a[i][:19])\n        exit()\nprint(-1)\n\n\n",
        "correct": false,
        "task_id": "0361",
        "depth": 2
    },
    {
        "description": "Shaass has decided to hunt some birds. There are n horizontal electricity wires aligned parallel to each other. Wires are numbered 1 to n from top to bottom. On each wire there are some oskols sitting next to each other. Oskol is the name of a delicious kind of birds in Shaass's territory. Supposed there are ai oskols sitting on the i-th wire.\n\n<image>\n\nSometimes Shaass shots one of the birds and the bird dies (suppose that this bird sat at the i-th wire). Consequently all the birds on the i-th wire to the left of the dead bird get scared and jump up on the wire number i - 1, if there exists no upper wire they fly away. Also all the birds to the right of the dead bird jump down on wire number i + 1, if there exists no such wire they fly away. \n\nShaass has shot m birds. You're given the initial number of birds on each wire, tell him how many birds are sitting on each wire after the shots.\n\nInput\n\nThe first line of the input contains an integer n, (1 \u2264 n \u2264 100). The next line contains a list of space-separated integers a1, a2, ..., an, (0 \u2264 ai \u2264 100). \n\nThe third line contains an integer m, (0 \u2264 m \u2264 100). Each of the next m lines contains two integers xi and yi. The integers mean that for the i-th time Shaass shoot the yi-th (from left) bird on the xi-th wire, (1 \u2264 xi \u2264 n, 1 \u2264 yi). It's guaranteed there will be at least yi birds on the xi-th wire at that moment.\n\nOutput\n\nOn the i-th line of the output print the number of birds on the i-th wire.\n\nExamples\n\nInput\n\n5\n10 10 10 10 10\n5\n2 5\n3 13\n2 12\n1 13\n4 6\n\n\nOutput\n\n0\n12\n5\n0\n16\n\n\nInput\n\n3\n2 4 1\n1\n2 2\n\n\nOutput\n\n3\n0\n3",
        "task_name": "294_A. Shaass and Oskols",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\nimport bisect\nimport math\nimport heapq\nimport itertools\nimport sys\nfrom collections import deque\nfrom atexit import register\nfrom collections import Counter\nfrom functools import reduce\nsys.setrecursionlimit(100000)\nif sys.version_info[0] < 3:\n    from io import BytesIO as stream\nelse:\n    from io import StringIO as stream\n \n \nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n \n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n \n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n \n    input = raw_input\n    range = xrange\n \n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n \n \ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n \n    Args:\n        sync (bool, optional): The new synchronization setting.\n \n    \"\"\"\n    global input, flush\n \n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\ndef arr():\n    return list(map(int,input().split()))\ndef dd():\n    return map(int,input().split())       \n\n\ndef main():\n    n=int(input())\n    ar=arr()\n    for _ in range(int(input())):\n        a,b=dd()\n        if a-2>=0 and a-2<n:\n            ar[a-2]+=b-1\n        \n        if a>=0 and a<n:\n            ar[a]+=ar[a-1]-b\n        \n        ar[a-1]=0\n    for i in ar:\n        print(i)\n        \n        \n        \n\n\n\nif __name__ == '__main__':\n    sync_with_stdio(False)\n    main()\n",
        "correct": true,
        "task_id": "0363",
        "depth": 1
    },
    {
        "description": "Bear Limak has n colored balls, arranged in one long row. Balls are numbered 1 through n, from left to right. There are n possible colors, also numbered 1 through n. The i-th ball has color ti.\n\nFor a fixed interval (set of consecutive elements) of balls we can define a dominant color. It's a color occurring the biggest number of times in the interval. In case of a tie between some colors, the one with the smallest number (index) is chosen as dominant.\n\nThere are <image> non-empty intervals in total. For each color, your task is to count the number of intervals in which this color is dominant.\n\nInput\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 5000) \u2014 the number of balls.\n\nThe second line contains n integers t1, t2, ..., tn (1 \u2264 ti \u2264 n) where ti is the color of the i-th ball.\n\nOutput\n\nPrint n integers. The i-th of them should be equal to the number of intervals where i is a dominant color.\n\nExamples\n\nInput\n\n4\n1 2 1 2\n\n\nOutput\n\n7 3 0 0 \n\n\nInput\n\n3\n1 1 1\n\n\nOutput\n\n6 0 0 \n\nNote\n\nIn the first sample, color 2 is dominant in three intervals:\n\n  * An interval [2, 2] contains one ball. This ball's color is 2 so it's clearly a dominant color. \n  * An interval [4, 4] contains one ball, with color 2 again. \n  * An interval [2, 4] contains two balls of color 2 and one ball of color 1. \n\n\n\nThere are 7 more intervals and color 1 is dominant in all of them.",
        "task_name": "673_C. Bear and Colors",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\nballs = list(map(int, raw_input().split()))\ndomination = (n + 1) * [ 0 ]\n\nclass Color:\n  def __init__(self, id):\n    self.id = id\n    self.heap_pos = None\n\ncolors = [ Color(color) for color in range(n + 1) ]\n\nfor start in range(n):\n  for color in colors:\n    color.count = 0\n  max_count = 0\n  best_color = colors[1]\n  for i in range(start, n):\n    color = colors[balls[i]]\n    color.count += 1\n    if color.count == max_count:\n      if color.id < best_color.id:\n        best_color = color\n    elif color.count > max_count:\n      max_count = color.count\n      best_color = color\n    domination[best_color.id] += 1\nprint(' '.join(map(str, domination[1:])))\n",
        "correct": true,
        "task_id": "0369",
        "depth": 2
    },
    {
        "description": "Arkady decides to observe a river for n consecutive days. The river's water level on each day is equal to some real value.\n\nArkady goes to the riverside each day and makes a mark on the side of the channel at the height of the water level, but if it coincides with a mark made before, no new mark is created. The water does not wash the marks away. Arkady writes down the number of marks strictly above the water level each day, on the i-th day this value is equal to mi.\n\nDefine di as the number of marks strictly under the water level on the i-th day. You are to find out the minimum possible sum of di over all days. There are no marks on the channel before the first day.\n\nInput\n\nThe first line contains a single positive integer n (1 \u2264 n \u2264 105) \u2014 the number of days.\n\nThe second line contains n space-separated integers m1, m2, ..., mn (0 \u2264 mi < i) \u2014 the number of marks strictly above the water on each day.\n\nOutput\n\nOutput one single integer \u2014 the minimum possible sum of the number of marks strictly below the water level among all days.\n\nExamples\n\nInput\n\n6\n0 1 0 3 0 2\n\n\nOutput\n\n6\n\n\nInput\n\n5\n0 1 2 1 2\n\n\nOutput\n\n1\n\n\nInput\n\n5\n0 1 1 2 2\n\n\nOutput\n\n0\n\nNote\n\nIn the first example, the following figure shows an optimal case.\n\n<image>\n\nNote that on day 3, a new mark should be created because if not, there cannot be 3 marks above water on day 4. The total number of marks underwater is 0 + 0 + 2 + 0 + 3 + 1 = 6.\n\nIn the second example, the following figure shows an optimal case.\n\n<image>",
        "task_name": "924_C. Riverside Curio",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nn, a = int(input()), [int(x) for x in stdin.readline().split()]\ntem, tem2, ans = [], [0] * n, 0\n\nfor i in range(n):\n    if not tem or a[i] > a[tem[-1]]:\n        tem.append(i)\n\ntem.append(n - 1)\nfor i in range(len(tem) - 1, 0, -1):\n    cur = max(a[tem[i]], a[tem[i - 1]])\n\n    for j in range(tem[i], tem[i - 1], -1):\n        tem2[j] = cur\n        cur = max(a[tem[i - 1]], cur - 1)\n\nfor i in range(n):\n    ans += max(tem2[i] - a[i], 0)\n\nprint(ans)",
        "correct": false,
        "task_id": "0374",
        "depth": 2
    },
    {
        "description": "You have a pot and N ingredients. Each ingredient has a real number parameter called value, and the value of the i-th ingredient (1 \\leq i \\leq N) is v_i.\n\nWhen you put two ingredients in the pot, they will vanish and result in the formation of a new ingredient. The value of the new ingredient will be (x + y) / 2 where x and y are the values of the ingredients consumed, and you can put this ingredient again in the pot.\n\nAfter you compose ingredients in this way N-1 times, you will end up with one ingredient. Find the maximum possible value of this ingredient.\n\nConstraints\n\n* 2 \\leq N \\leq 50\n* 1 \\leq v_i \\leq 1000\n* All values in input are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nv_1 v_2 \\ldots v_N\n\n\nOutput\n\nPrint a decimal number (or an integer) representing the maximum possible value of the last ingredient remaining.\n\nYour output will be judged correct when its absolute or relative error from the judge's output is at most 10^{-5}.\n\nExamples\n\nInput\n\n2\n3 4\n\n\nOutput\n\n3.5\n\n\nInput\n\n3\n500 300 200\n\n\nOutput\n\n375\n\n\nInput\n\n5\n138 138 138 138 138\n\n\nOutput\n\n138",
        "task_name": "p02935 AtCoder Beginner Contest 138 - Alchemist",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(input())\nv = [float(x) for x in raw_input().split()]\nv.sort()\n\ndef mean(a, b):\n    return (a+b)/2\n\nresult = v[0]\n\nfor i in range(1, n):\n    result = mean(result, v[i])\n\nprint(result)\n",
        "correct": true,
        "task_id": "0377",
        "depth": 1
    },
    {
        "description": "There are N mountains ranging from east to west, and an ocean to the west.\n\nAt the top of each mountain, there is an inn. You have decided to choose where to stay from these inns.\n\nThe height of the i-th mountain from the west is H_i.\n\nYou can certainly see the ocean from the inn at the top of the westmost mountain.\n\nFor the inn at the top of the i-th mountain from the west (i = 2, 3, ..., N), you can see the ocean if and only if H_1 \\leq H_i, H_2 \\leq H_i, ..., and H_{i-1} \\leq H_i.\n\nFrom how many of these N inns can you see the ocean?\n\nConstraints\n\n* All values in input are integers.\n* 1 \\leq N \\leq 20\n* 1 \\leq H_i \\leq 100\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nH_1 H_2 ... H_N\n\n\nOutput\n\nPrint the number of inns from which you can see the ocean.\n\nExamples\n\nInput\n\n4\n6 5 6 8\n\n\nOutput\n\n3\n\n\nInput\n\n5\n4 5 3 5 4\n\n\nOutput\n\n3\n\n\nInput\n\n5\n9 5 6 8 4\n\n\nOutput\n\n1",
        "task_name": "p03072 AtCoder Beginner Contest 124 - Great Ocean View",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport math \n\nn = int(raw_input().strip())\ninp = map(int, raw_input().strip().split(\" \"))\nmax = 0\nans = 0\n\nfor h in inp:\n    if max <= h:\n        max = h\n        ans += 1\n\nprint(ans)",
        "correct": true,
        "task_id": "0378",
        "depth": 1
    },
    {
        "description": "There are N squares aligned in a row. The i-th square from the left contains an integer a_i.\n\nInitially, all the squares are white. Snuke will perform the following operation some number of times:\n\n* Select K consecutive squares. Then, paint all of them white, or paint all of them black. Here, the colors of the squares are overwritten.\n\n\n\nAfter Snuke finishes performing the operation, the score will be calculated as the sum of the integers contained in the black squares. Find the maximum possible score.\n\nConstraints\n\n* 1\u2264N\u226410^5\n* 1\u2264K\u2264N\n* a_i is an integer.\n* |a_i|\u226410^9\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN K\na_1 a_2 ... a_N\n\n\nOutput\n\nPrint the maximum possible score.\n\nExamples\n\nInput\n\n5 3\n-10 10 -10 10 -10\n\n\nOutput\n\n10\n\n\nInput\n\n4 2\n10 -10 -10 10\n\n\nOutput\n\n20\n\n\nInput\n\n1 1\n-10\n\n\nOutput\n\n0\n\n\nInput\n\n10 5\n5 -4 -5 -8 -4 7 2 -4 0 7\n\n\nOutput\n\n17",
        "task_name": "p03839 AtCoder Grand Contest 008 - Contiguous Repainting",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n,k=map(int,raw_input().split())\na=map(int,raw_input().split())\ntotal=[0]*(n+1)\nasum=[0]*(n+1)\nfor i in xrange(n):\n    asum[i+1]=asum[i]+a[i]\n    if a[i]>0:\n        total[i+1]=total[i]+a[i]\n    else:\n        total[i+1]=total[i]\nans=0\nfor i in xrange(n-k+1):\n    tmp=asum[i+k]-asum[i]\n    ans=max(ans,tmp+total[i]+total[n]-total[i+k],total[i]+total[n]-total[i+k])\n\nprint(ans)\n",
        "correct": true,
        "task_id": "0381",
        "depth": 1
    },
    {
        "description": "Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.\n\nThe valid sizes of T-shirts are either \"M\" or from 0 to 3 \"X\" followed by \"S\" or \"L\". For example, sizes \"M\", \"XXS\", \"L\", \"XXXL\" are valid and \"XM\", \"Z\", \"XXXXL\" are not.\n\nThere are n winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. \n\nOrganizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.\n\nWhat is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?\n\nThe lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.\n\nInput\n\nThe first line contains one integer n (1 \u2264 n \u2264 100) \u2014 the number of T-shirts.\n\nThe i-th of the next n lines contains a_i \u2014 the size of the i-th T-shirt of the list for the previous year.\n\nThe i-th of the next n lines contains b_i \u2014 the size of the i-th T-shirt of the list for the current year.\n\nIt is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list b from the list a.\n\nOutput\n\nPrint the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.\n\nExamples\n\nInput\n\n3\nXS\nXS\nM\nXL\nS\nXS\n\n\nOutput\n\n2\n\n\nInput\n\n2\nXXXL\nXXL\nXXL\nXXXS\n\n\nOutput\n\n1\n\n\nInput\n\n2\nM\nXS\nXS\nM\n\n\nOutput\n\n0\n\nNote\n\nIn the first example Ksenia can replace \"M\" with \"S\" and \"S\" in one of the occurrences of \"XS\" with \"L\".\n\nIn the second example Ksenia should replace \"L\" in \"XXXL\" with \"S\".\n\nIn the third example lists are equal.",
        "task_name": "1000_A. Codehorses T-shirts",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#coding=utf-8\nimport sys\nif __name__ == \"__main__\":\n\tn = int(raw_input())\n\tdic = {}\n\tfor i in xrange(n):\n\t\ts = raw_input()\n\t\tif not dic.has_key(s):\n\t\t\tdic[s] = 1\n\t\telse:\n\t\t\tdic[s] += 1\n\tans = 0\n\tfor i in xrange(n):\n\t\ts = raw_input()\n\t\tif dic.has_key(s) and dic[s] > 0:\n\t\t\tdic[s] -= 1\n\t\telse:\n\t\t\tans += 1\n\tprint(ans)\n",
        "correct": true,
        "task_id": "0384",
        "depth": 1
    },
    {
        "description": "One common way of digitalizing sound is to record sound intensity at particular time moments. For each time moment intensity is recorded as a non-negative integer. Thus we can represent a sound file as an array of n non-negative integers.\n\nIf there are exactly K distinct values in the array, then we need k = \u2308 log_{2} K \u2309 bits to store each value. It then takes nk bits to store the whole file.\n\nTo reduce the memory consumption we need to apply some compression. One common way is to reduce the number of possible intensity values. We choose two integers l \u2264 r, and after that all intensity values are changed in the following way: if the intensity value is within the range [l;r], we don't change it. If it is less than l, we change it to l; if it is greater than r, we change it to r. You can see that we lose some low and some high intensities.\n\nYour task is to apply this compression in such a way that the file fits onto a disk of size I bytes, and the number of changed elements in the array is minimal possible.\n\nWe remind you that 1 byte contains 8 bits.\n\nk = \u2308 log_{2} K \u2309 is the smallest integer such that K \u2264 2^{k}. In particular, if K = 1, then k = 0.\n\nInput\n\nThe first line contains two integers n and I (1 \u2264 n \u2264 4 \u22c5 10^{5}, 1 \u2264 I \u2264 10^{8}) \u2014 the length of the array and the size of the disk in bytes, respectively.\n\nThe next line contains n integers a_{i} (0 \u2264 a_{i} \u2264 10^{9}) \u2014 the array denoting the sound file.\n\nOutput\n\nPrint a single integer \u2014 the minimal possible number of changed elements.\n\nExamples\n\nInput\n\n\n6 1\n2 1 2 3 4 3\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n6 2\n2 1 2 3 4 3\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n6 1\n1 1 2 2 3 3\n\n\nOutput\n\n\n2\n\nNote\n\nIn the first example we can choose l=2, r=3. The array becomes 2 2 2 3 3 3, the number of distinct elements is K=2, and the sound file fits onto the disk. Only two values are changed.\n\nIn the second example the disk is larger, so the initial file fits it and no changes are required.\n\nIn the third example we have to change both 1s or both 3s.",
        "task_name": "1198_A. MP3",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom collections import Counter\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    n, i = map(int, input().split())\n    ca = sorted(Counter(map(int, input().split())).items(), key=lambda x: x[0])\n\n    md = int(2 ** ((8 * i) / n))\n\n    pref = [0]\n    for _, j in ca:\n        pref.append(pref[-1] + j)\n\n    s = n\n    for i in range(len(pref) - md):\n        u = pref[i + md] - pref[i]\n        s = min(s, n - u)\n\n    if len(pref) - md <= 0:\n        s = 0\n\n    print(s)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": false,
        "task_id": "0388",
        "depth": 1
    },
    {
        "description": "There is a river of width n. The left bank of the river is cell 0 and the right bank is cell n + 1 (more formally, the river can be represented as a sequence of n + 2 cells numbered from 0 to n + 1). There are also m wooden platforms on a river, the i-th platform has length c_i (so the i-th platform takes c_i consecutive cells of the river). It is guaranteed that the sum of lengths of platforms does not exceed n.\n\nYou are standing at 0 and want to reach n+1 somehow. If you are standing at the position x, you can jump to any position in the range [x + 1; x + d]. However you don't really like the water so you can jump only to such cells that belong to some wooden platform. For example, if d=1, you can jump only to the next position (if it belongs to the wooden platform). You can assume that cells 0 and n+1 belong to wooden platforms.\n\nYou want to know if it is possible to reach n+1 from 0 if you can move any platform to the left or to the right arbitrary number of times (possibly, zero) as long as they do not intersect each other (but two platforms can touch each other). It also means that you cannot change the relative order of platforms.\n\nNote that you should move platforms until you start jumping (in other words, you first move the platforms and then start jumping).\n\nFor example, if n=7, m=3, d=2 and c = [1, 2, 1], then one of the ways to reach 8 from 0 is follow:\n\n<image> The first example: n=7.\n\nInput\n\nThe first line of the input contains three integers n, m and d (1 \u2264 n, m, d \u2264 1000, m \u2264 n) \u2014 the width of the river, the number of platforms and the maximum distance of your jump, correspondingly.\n\nThe second line of the input contains m integers c_1, c_2, ..., c_m (1 \u2264 c_i \u2264 n, \u2211_{i=1}^{m} c_i \u2264 n), where c_i is the length of the i-th platform.\n\nOutput\n\nIf it is impossible to reach n+1 from 0, print NO in the first line. Otherwise, print YES in the first line and the array a of length n in the second line \u2014 the sequence of river cells (excluding cell 0 and cell n + 1).\n\nIf the cell i does not belong to any platform, a_i should be 0. Otherwise, it should be equal to the index of the platform (1-indexed, platforms are numbered from 1 to m in order of input) to which the cell i belongs.\n\nNote that all a_i equal to 1 should form a contiguous subsegment of the array a of length c_1, all a_i equal to 2 should form a contiguous subsegment of the array a of length c_2, ..., all a_i equal to m should form a contiguous subsegment of the array a of length c_m. The leftmost position of 2 in a should be greater than the rightmost position of 1, the leftmost position of 3 in a should be greater than the rightmost position of 2, ..., the leftmost position of m in a should be greater than the rightmost position of m-1.\n\nSee example outputs for better understanding.\n\nExamples\n\nInput\n\n\n7 3 2\n1 2 1\n\n\nOutput\n\n\nYES\n0 1 0 2 2 0 3 \n\n\nInput\n\n\n10 1 11\n1\n\n\nOutput\n\n\nYES\n0 0 0 0 0 0 0 0 0 1 \n\n\nInput\n\n\n10 1 5\n2\n\n\nOutput\n\n\nYES\n0 0 0 0 1 1 0 0 0 0 \n\nNote\n\nConsider the first example: the answer is [0, 1, 0, 2, 2, 0, 3]. The sequence of jumps you perform is 0 \u2192 2 \u2192 4 \u2192 5 \u2192 7 \u2192 8.\n\nConsider the second example: it does not matter how to place the platform because you always can jump from 0 to 11.\n\nConsider the third example: the answer is [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]. The sequence of jumps you perform is 0 \u2192 5 \u2192 6 \u2192 11.",
        "task_name": "1256_C. Platforms Jumping",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, m, d = rints()\nc, ans = rints(), [0] * n\npos, su = [], 0\n\nfor i in range(m - 1, -1, -1):\n    pos.append(n + 1 - su - c[i])\n    su += c[i]\n\npos.append(0)\npos.reverse()\n\nfor i in range(m):\n    if pos[i + 1] - pos[i] <= d:\n        for j in range(pos[i + 1], pos[i + 1] + c[i]):\n            ans[j - 1] = i + 1\n        continue\n\n    pos[i + 1] = min(pos[i] + d, n)\n\n    for j in range(pos[i + 1], pos[i + 1] + c[i]):\n        ans[j - 1] = i + 1\n\n    pos[i + 1] += c[i] - 1\n\n# print(pos)\nif (n + 1) - (pos[-1] + c[-1] - 1) > d:\n    print('NO')\nelse:\n    print('YES')\n    print(' '.join(map(str, ans)))\n",
        "correct": false,
        "task_id": "0390",
        "depth": 2
    },
    {
        "description": "Bob is about to take a hot bath. \n\nThere are two taps to fill the bath: a hot water tap and a cold water tap. The cold water's temperature is t1, and the hot water's temperature is t2. The cold water tap can transmit any integer number of water units per second from 0 to x1, inclusive. Similarly, the hot water tap can transmit from 0 to x2 water units per second.\n\nIf y1 water units per second flow through the first tap and y2 water units per second flow through the second tap, then the resulting bath water temperature will be:\n\n<image>\n\nBob wants to open both taps so that the bath water temperature was not less than t0. However, the temperature should be as close as possible to this value. If there are several optimal variants, Bob chooses the one that lets fill the bath in the quickest way possible.\n\nDetermine how much each tap should be opened so that Bob was pleased with the result in the end.\n\nInput\n\nYou are given five integers t1, t2, x1, x2 and t0 (1 \u2264 t1 \u2264 t0 \u2264 t2 \u2264 106, 1 \u2264 x1, x2 \u2264 106).\n\nOutput\n\nPrint two space-separated integers y1 and y2 (0 \u2264 y1 \u2264 x1, 0 \u2264 y2 \u2264 x2).\n\nExamples\n\nInput\n\n10 70 100 100 25\n\n\nOutput\n\n99 33\n\nInput\n\n300 500 1000 1000 300\n\n\nOutput\n\n1000 0\n\nInput\n\n143 456 110 117 273\n\n\nOutput\n\n76 54\n\nNote\n\nIn the second sample the hot water tap shouldn't be opened, but the cold water tap should be opened at full capacity in order to fill the bath in the quickest way possible.",
        "task_name": "127_C. Hot Bath",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import fractions\nimport sys\nimport math\n\ndef a( t1, t2, y1max, y2max, t0):\n  dt1 = t0 - t1\n  dt2 = t2 - t0\n\n  if   dt1==0 and dt2==0: return y1max,y2max\n  elif dt1==0: return y1max,0\n  elif dt2==0: return 0,y2max\n\n  calc1max = (y2max * dt2) / dt1\n  if calc1max<y1max: y1max = calc1max\n\n  if y1max < 1: return 0,y2max\n\n  calc2max = (y1max * dt1 + dt2 - 1) / dt2\n  if calc2max<y2max: y2max = calc2max\n\n  if y1max*dt1 == y2max*dt2: return y1max,y2max\n\n  if y1max==0: return 0,y2max\n\n  if dt1<=y2max and dt2<=y1max:\n    n = min( y1max/dt2, y2max/dt1)\n    y1,y2 = n*dt2, n*dt1\n    g = fractions.gcd( y1,y2)\n    fr1,fr2 = y1/g, y2/g\n    n = min( (y1max-y1)/fr1, (y2max-y2)/fr2)\n    return y1+n*fr1, y2+n*fr2\n\n  y1,y2 = y1max,y2max\n\n  if y1<y2: d1,d2 = 1,0\n  else    : d1,d2 = 0,1\n\n  ###sys.stderr.write( str( dict(y1max=y1,y2max=y2,d1=d1,d2=d2,err=(y1*t1+y2*t2)/float(y1+y2)-t0))+'\\n' )\n\n  y1out,y2out = y1,y2\n  errMin = (y1*t1+y2*t2)/float(y1+y2) - t0\n  while y1>1 and y2>1:\n    y1 -= d1\n    y2 -= d2\n    rem = y2*dt2 - y1*dt1\n    if rem==0: return y1,y2\n    if dt1 and rem>=dt2: y2 -= (rem/dt2)\n    elif dt2 and rem<0: y1 -= (dt1-(rem+1))/dt1\n    err = (y1*t1+y2*t2)/float(y1+y2) - t0\n    ###print( (y1,y2,rem,err,errMin,) )\n    if err<errMin: errMin,y1out,y2out = err,y1,y2\n\n  return y1out,y2out\n\n\nif __name__==\"__main__\":\n  toks = sys.stdin.readline().split()\n  t1 = int(toks[0])\n  t2 = int(toks[1])\n  y1max = int(toks[2])\n  y2max = int(toks[3])\n  t0 = int(toks[4])\n\n  print( \"%d %d\" % a(t1,t2,y1max,y2max,t0) )\n",
        "correct": true,
        "task_id": "0391",
        "depth": 1
    },
    {
        "description": "One cold winter evening Alice and her older brother Bob was sitting at home near the fireplace and giving each other interesting problems to solve. When it was Alice's turn, she told the number n to Bob and said:\n\n\u2014Shuffle the digits in this number in order to obtain the smallest possible number without leading zeroes.\n\n\u2014No problem! \u2014 said Bob and immediately gave her an answer.\n\nAlice said a random number, so she doesn't know whether Bob's answer is correct. Help her to find this out, because impatient brother is waiting for the verdict.\n\nInput\n\nThe first line contains one integer n (0 \u2264 n \u2264 109) without leading zeroes. The second lines contains one integer m (0 \u2264 m \u2264 109) \u2014 Bob's answer, possibly with leading zeroes.\n\nOutput\n\nPrint OK if Bob's answer is correct and WRONG_ANSWER otherwise.\n\nExamples\n\nInput\n\n3310\n1033\n\n\nOutput\n\nOK\n\n\nInput\n\n4\n5\n\n\nOutput\n\nWRONG_ANSWER",
        "task_name": "12_B. Correct Solution?",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "I=raw_input\nn=I()\nm=I()\nn=sorted(list(n))\nfor i in range(len(n)):\n    if n[i] != '0':\n        break\nif n[i] != '0':\n    n[0],n[i]=n[i],n[0]\nprint ['OK', 'WRONG_ANSWER'][n != list(m)]",
        "correct": true,
        "task_id": "0392",
        "depth": 1
    },
    {
        "description": "Having stayed home alone, Petya decided to watch forbidden films on the Net in secret. \"What ungentlemanly behavior!\" \u2014 you can say that, of course, but don't be too harsh on the kid. In his country films about the Martians and other extraterrestrial civilizations are forbidden. It was very unfair to Petya as he adored adventure stories that featured lasers and robots. \n\nToday Petya is watching a shocking blockbuster about the Martians called \"R2:D2\". What can \"R2:D2\" possibly mean? It might be the Martian time represented in the Martian numeral system. Petya knows that time on Mars is counted just like on the Earth (that is, there are 24 hours and each hour has 60 minutes). The time is written as \"a:b\", where the string a stands for the number of hours (from 0 to 23 inclusive), and string b stands for the number of minutes (from 0 to 59 inclusive). The only thing Petya doesn't know is in what numeral system the Martian time is written.\n\nYour task is to print the radixes of all numeral system which can contain the time \"a:b\".\n\nInput\n\nThe first line contains a single string as \"a:b\" (without the quotes). There a is a non-empty string, consisting of numbers and uppercase Latin letters. String a shows the number of hours. String b is a non-empty string that consists of numbers and uppercase Latin letters. String b shows the number of minutes. The lengths of strings a and b are from 1 to 5 characters, inclusive. Please note that strings a and b can have leading zeroes that do not influence the result in any way (for example, string \"008:1\" in decimal notation denotes correctly written time).\n\nWe consider characters 0, 1, ..., 9 as denoting the corresponding digits of the number's representation in some numeral system, and characters A, B, ..., Z correspond to numbers 10, 11, ..., 35.\n\nOutput\n\nPrint the radixes of the numeral systems that can represent the time \"a:b\" in the increasing order. Separate the numbers with spaces or line breaks. If there is no numeral system that can represent time \"a:b\", print the single integer 0. If there are infinitely many numeral systems that can represent the time \"a:b\", print the single integer -1.\n\nNote that on Mars any positional numeral systems with positive radix strictly larger than one are possible.\n\nExamples\n\nInput\n\n11:20\n\n\nOutput\n\n3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22\n\nInput\n\n2A:13\n\n\nOutput\n\n0\n\n\nInput\n\n000B:00001\n\n\nOutput\n\n-1\n\nNote\n\nLet's consider the first sample. String \"11:20\" can be perceived, for example, as time 4:6, represented in the ternary numeral system or as time 17:32 in hexadecimal system. \n\nLet's consider the second sample test. String \"2A:13\" can't be perceived as correct time in any notation. For example, let's take the base-11 numeral notation. There the given string represents time 32:14 that isn't a correct time.\n\nLet's consider the third sample. String \"000B:00001\" can be perceived as a correct time in the infinite number of numeral systems. If you need an example, you can take any numeral system with radix no less than 12.",
        "task_name": "149_B. Martian Clock",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import os\nimport sys\nimport traceback\n\ndoprint='DOPRINT' in os.environ\n\nord9 = ord('9')\nord0 = ord('0')\nordA = ord('A')\ndef conv(d):\n  ordd = ord(d)\n  if ordd <= ord9: return ordd - ord0\n  return 10 + ordd - ordA\n\ndef processds( ds):\n  rtn = map( conv, list(ds))\n  while rtn and not rtn[0]:\n    if doprint: print( rtn )\n    rtn.pop(0)\n  return rtn\n\ndef solveone( ds, ub):\n  if doprint: print( (ds,ub) )\n  if len(ds) == 0: return [-1, -1]\n  maxds = max(ds)\n  if maxds > ub: return [0,0]\n  if len(ds) == 1: return [-1,-1]\n  lo = maxds + 1\n  summ = 0\n  for d in ds: summ = summ * lo + d\n  if doprint: print( ('A',lo,summ,ub,summ>ub) )\n  if summ>ub: return [0,0]\n  hi = lo\n  while True:\n    hi += 1\n    summ = 0\n    for d in ds: summ = summ * hi + d\n    if doprint: print( ('B',hi,summ,ub,summ>ub) )\n    if summ>ub: return [lo,hi-1]\n\ndef solve():\n  hs,ms = map( processds, sys.stdin.readline().strip('\\n\\r ').split(':') )\n\n  if doprint: print( (hs,ms) )\n\n  hminmax = solveone( hs, 23 )\n  if hminmax[0]==0: return [0]\n  mminmax = solveone( ms, 59 )\n  if mminmax[0]==0: return [0]\n\n  if hminmax[0]==-1 and mminmax[0]==-1: return [-1]\n  if hminmax[0]==-1: return range(mminmax[0],mminmax[1]+1)\n  if mminmax[0]==-1: return range(hminmax[0],hminmax[1]+1)\n  if hminmax[0] > mminmax[1]: return [0]\n  if mminmax[0] > hminmax[1]: return [0]\n  return range(max([hminmax[0],mminmax[0]]), min([hminmax[1],mminmax[1]])+1 )\n\nif __name__==\"__main__\":\n  pfx=''\n  for i in solve():\n    sys.stdout.write( pfx+str(i) )\n    pfx=' '\n  sys.stdout.write( '\\n' )\n",
        "correct": false,
        "task_id": "0398",
        "depth": 2
    },
    {
        "description": "Iahub recently has learned Bubble Sort, an algorithm that is used to sort a permutation with n elements a1, a2, ..., an in ascending order. He is bored of this so simple algorithm, so he invents his own graph. The graph (let's call it G) initially has n vertices and 0 edges. During Bubble Sort execution, edges appear as described in the following algorithm (pseudocode). \n    \n    \n      \n    procedure bubbleSortGraph()  \n        build a graph G with n vertices and 0 edges  \n        repeat  \n            swapped = false  \n            for i = 1 to n - 1 inclusive do:  \n                if a[i] > a[i + 1] then  \n                    add an undirected edge in G between a[i] and a[i + 1]  \n                    swap( a[i], a[i + 1] )  \n                    swapped = true  \n                end if  \n            end for  \n        until not swapped   \n        /* repeat the algorithm as long as swapped value is true. */   \n    end procedure  \n    \n\nFor a graph, an independent set is a set of vertices in a graph, no two of which are adjacent (so there are no edges between vertices of an independent set). A maximum independent set is an independent set which has maximum cardinality. Given the permutation, find the size of the maximum independent set of graph G, if we use such permutation as the premutation a in procedure bubbleSortGraph.\n\nInput\n\nThe first line of the input contains an integer n (2 \u2264 n \u2264 105). The next line contains n distinct integers a1, a2, ..., an (1 \u2264 ai \u2264 n).\n\nOutput\n\nOutput a single integer \u2014 the answer to the problem. \n\nExamples\n\nInput\n\n3\n3 1 2\n\n\nOutput\n\n2\n\nNote\n\nConsider the first example. Bubble sort swaps elements 3 and 1. We add edge (1, 3). Permutation is now [1, 3, 2]. Then bubble sort swaps elements 3 and 2. We add edge (2, 3). Permutation is now sorted. We have a graph with 3 vertices and 2 edges (1, 3) and (2, 3). Its maximal independent set is [1, 2].",
        "task_name": "341_B. Bubble Sort Graph",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\nfrom bisect import *\n\n\nclass segmenttree:\n    def __init__(self, arr, n):\n        self.tree, self.n = [0] * (2 * n), n\n        # build tree\n        if arr:\n            for i in range(2 * n - 1, 0, -1):\n                if i >= n:\n                    self.tree[i] = arr[i - n]\n                else:\n                    self.tree[i] = max(self.tree[i << 1], self.tree[(i << 1) + 1])\n\n    # get interval[l,r)\n    def query(self, l, r):\n        res = 0\n        l += self.n\n        r += self.n\n        while l < r:\n            if l & 1:\n                res = max(self.tree[l], res)\n                l += 1\n\n            if r & 1:\n                r -= 1\n                res = max(self.tree[r], res)\n\n            l >>= 1\n            r >>= 1\n\n        return res\n\n    def update(self, ix, val):\n        ix += self.n\n\n        # set new value\n        self.tree[ix] = val\n\n        # move up\n        while ix > 1:\n            self.tree[ix >> 1] = max(self.tree[ix], self.tree[ix ^ 1])\n            ix >>= 1\n\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, a, tree = int(input()), rints(), segmenttree([], 10 ** 5 + 1)\n\nfor i in range(n):\n    val = tree.query(0, a[i])\n    tree.update(a[i], val + 1)\n\nprint(tree.query(0, n + 1))\n",
        "correct": true,
        "task_id": "0405",
        "depth": 1
    },
    {
        "description": "Recently Pashmak has been employed in a transportation company. The company has k buses and has a contract with a school which has n students. The school planned to take the students to d different places for d days (each day in one place). Each day the company provides all the buses for the trip. Pashmak has to arrange the students in the buses. He wants to arrange the students in a way that no two students become close friends. In his ridiculous idea, two students will become close friends if and only if they are in the same buses for all d days.\n\nPlease help Pashmak with his weird idea. Assume that each bus has an unlimited capacity.\n\nInput\n\nThe first line of input contains three space-separated integers n, k, d (1 \u2264 n, d \u2264 1000; 1 \u2264 k \u2264 109).\n\nOutput\n\nIf there is no valid arrangement just print -1. Otherwise print d lines, in each of them print n integers. The j-th integer of the i-th line shows which bus the j-th student has to take on the i-th day. You can assume that the buses are numbered from 1 to k.\n\nExamples\n\nInput\n\n3 2 2\n\n\nOutput\n\n1 1 2 \n1 2 1 \n\n\nInput\n\n3 2 1\n\n\nOutput\n\n-1\n\nNote\n\nNote that two students become close friends only if they share a bus each day. But the bus they share can differ from day to day.",
        "task_name": "459_C. Pashmak and Buses",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def incr(a, k):\n    carry = 1\n    for i in range(len(a) - 1, -1, -1):\n        newval = a[i] + carry\n        if newval >= k:\n            if i == 0:\n                return False\n            newval = 0\n            carry = 1\n        else:\n            carry = 0\n        a[i] = newval\n    return True\ndef sol():\n    n, k, d = map(int, raw_input().split())\n    a = [0] * d\n    res = list()\n    nextFine = True\n    for want in xrange(n):\n        if not nextFine:\n            print(-1)\n            return\n        res.append(list(val + 1 for val in a))\n        nextFine = incr(a, k)\n    print('\\n'.join(' '.join(map(str, l)) for l in res))\nsol()",
        "correct": false,
        "task_id": "0408",
        "depth": 1
    },
    {
        "description": "A tree is an undirected connected graph without cycles.\n\nLet's consider a rooted undirected tree with n vertices, numbered 1 through n. There are many ways to represent such a tree. One way is to create an array with n integers p1, p2, ..., pn, where pi denotes a parent of vertex i (here, for convenience a root is considered its own parent).\n\n<image> For this rooted tree the array p is [2, 3, 3, 2].\n\nGiven a sequence p1, p2, ..., pn, one is able to restore a tree:\n\n  1. There must be exactly one index r that pr = r. A vertex r is a root of the tree. \n  2. For all other n - 1 vertices i, there is an edge between vertex i and vertex pi. \n\n\n\nA sequence p1, p2, ..., pn is called valid if the described procedure generates some (any) rooted tree. For example, for n = 3 sequences (1,2,2), (2,3,1) and (2,1,3) are not valid.\n\nYou are given a sequence a1, a2, ..., an, not necessarily valid. Your task is to change the minimum number of elements, in order to get a valid sequence. Print the minimum number of changes and an example of a valid sequence after that number of changes. If there are many valid sequences achievable in the minimum number of changes, print any of them.\n\nInput\n\nThe first line of the input contains an integer n (2 \u2264 n \u2264 200 000) \u2014 the number of vertices in the tree.\n\nThe second line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 n).\n\nOutput\n\nIn the first line print the minimum number of elements to change, in order to get a valid sequence.\n\nIn the second line, print any valid sequence possible to get from (a1, a2, ..., an) in the minimum number of changes. If there are many such sequences, any of them will be accepted.\n\nExamples\n\nInput\n\n4\n2 3 3 4\n\n\nOutput\n\n1\n2 3 4 4 \n\n\nInput\n\n5\n3 2 2 5 3\n\n\nOutput\n\n0\n3 2 2 5 3 \n\n\nInput\n\n8\n2 3 5 4 1 6 6 7\n\n\nOutput\n\n2\n2 3 7 8 1 6 6 7\n\nNote\n\nIn the first sample, it's enough to change one element. In the provided output, a sequence represents a tree rooted in a vertex 4 (because p4 = 4), which you can see on the left drawing below. One of other correct solutions would be a sequence 2 3 3 2, representing a tree rooted in vertex 3 (right drawing below). On both drawings, roots are painted red.\n\n<image>\n\nIn the second sample, the given sequence is already valid.",
        "task_name": "698_B. Fix a Tree",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import itertools\nimport sys\n\n\ndef readline_int(delta=0):\n    return [int(i) + delta for i in raw_input().split()]\n\nclass Solution(object):\n    def find(self, ident, fa):\n        if fa[ident] != ident:\n             fa[ident] = self.find(fa[ident], fa)\n        return fa[ident]\n\n    def merge(self, ident_child, ident_father, fa):\n        fa_child = fa[ident_child]\n        fa_father = fa[ident_father]\n        fa[fa_child] = fa_father\n\n    def solve(self):\n        n = self.n\n        p = self.p\n        issues = []\n        roots = []\n        fa = [i for i in xrange(n)]\n\n        for current in xrange(n):\n            parent = p[current]\n            if parent == current:\n                roots.append(current)\n                continue\n\n            parent_set_id = self.find(parent, fa)\n            if parent_set_id == current:\n                issues.append(current)\n                continue\n\n            self.merge(current, parent, fa)\n\n        root = None\n        changes = 0\n        if len(roots) > 0:\n            root = roots[0]\n            changes = len(roots) + len(issues) - 1\n        elif len(roots) == 0:\n            root = roots[0] if len(roots) > 0 else issues[0]\n            changes = len(roots) + len(issues)\n\n        for ident in itertools.chain(roots, issues):\n            p[ident] = root\n\n        return (changes, p, )\n\n    def read_data(self):\n        self.n = readline_int()[0]\n        self.p = readline_int(delta=-1) # make sure to restore index while printing result\n\n    def print_result(self, result):\n        changes, p = result\n        print(changes)\n        for idx, parent in enumerate(p):\n            sys.stdout.write(str(parent))\n            if idx != len(p) - 1:\n                sys.stdout.write(' ')\n        sys.stdout.write('\\n')\n\n\n    def run(self):\n        self.read_data()\n        result = self.solve()\n        self.print_result(result)\n\nif len(sys.argv) > 1:\n    sys.stdin = open(sys.argv[1], 'r')\n    print('Redirect stdin to {0}'.format(sys.argv[1]))\n\nSolution().run()\n\n",
        "correct": false,
        "task_id": "0415",
        "depth": 1
    },
    {
        "description": "A monster is chasing after Rick and Morty on another planet. They're so frightened that sometimes they scream. More accurately, Rick screams at times b, b + a, b + 2a, b + 3a, ... and Morty screams at times d, d + c, d + 2c, d + 3c, .... \n\n<image>\n\nThe Monster will catch them if at any point they scream at the same time, so it wants to know when it will catch them (the first time they scream at the same time) or that they will never scream at the same time.\n\nInput\n\nThe first line of input contains two integers a and b (1 \u2264 a, b \u2264 100). \n\nThe second line contains two integers c and d (1 \u2264 c, d \u2264 100).\n\nOutput\n\nPrint the first time Rick and Morty will scream at the same time, or  - 1 if they will never scream at the same time.\n\nExamples\n\nInput\n\n20 2\n9 19\n\n\nOutput\n\n82\n\n\nInput\n\n2 1\n16 12\n\n\nOutput\n\n-1\n\nNote\n\nIn the first sample testcase, Rick's 5th scream and Morty's 8th time are at time 82. \n\nIn the second sample testcase, all Rick's screams will be at odd times and Morty's will be at even times, so they will never scream at the same time.",
        "task_name": "787_A. The Monster",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "a , b = map(int, raw_input().split()) \nc, d = map(int, raw_input().split()) \nimport sys \nif (b == d):\n\tprint (b )\n\tsys.exit() \nt = d - b \nfor x in range((a*c+d+b)/a+11): \n\tif (a*x - t)%c == 0: \n\t\tprint(b+ a*x) \n\t\tsys.exit() \nprint(- 1)",
        "correct": false,
        "task_id": "0417",
        "depth": 1
    },
    {
        "description": "After several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.\n\nThis morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.\n\nHelp Petya to determine maximum possible total cost.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u2264 100000, 1 \u2264 m \u2264 300000) \u2014 the number of Petya's souvenirs and total weight that he can carry to the market.\n\nThen n lines follow. ith line contains two integers wi and ci (1 \u2264 wi \u2264 3, 1 \u2264 ci \u2264 109) \u2014 the weight and the cost of ith souvenir.\n\nOutput\n\nPrint one number \u2014 maximum possible total cost of souvenirs that Petya can carry to the market.\n\nExamples\n\nInput\n\n1 1\n2 1\n\n\nOutput\n\n0\n\n\nInput\n\n2 2\n1 3\n2 2\n\n\nOutput\n\n3\n\n\nInput\n\n4 3\n3 10\n2 7\n2 8\n1 1\n\n\nOutput\n\n10",
        "task_name": "808_E. Selling Souvenirs",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n\n\n\n\ndata = [[] for i in range(4)]\n\n\nn,m = map(int,raw_input().split())\n\n\nfor i in range(0,n):\n    w,c = map(int,raw_input().split())\n    data[w].append(c)\n#print(data)\n\nfor i in range(1,4):\n    data[i].sort()\n    data[i].reverse()\n\ndp = []\nfor i in range(0,300010):\n    dp.append((0,0,0))\n\n\n\n\nfor i in range(1,m+1):\n    for j in range(1,3):\n        if(i-j<0 or dp[i-j][j] >= len(data[j])):\n            continue\n\n        val = dp[i-j][0] + data[j][dp[i-j][j]]\n        if(val > dp[i][0]):\n            a0 = val\n            a1 = dp[i-j][1]\n            a2 = dp[i-j][2]\n            if(j == 1):\n                a1 += 1\n            else :\n                a2 += 1\n            dp[i] = (a0,a1,a2)\n        if(dp[i][0] < dp[i-1][0]) :\n            dp[i] = dp[i-1]\n\nans = dp[w][0]\nsum = 0\n\nfor i in range(0,len(data[3])):\n    if (i+1) * 3 > w :\n        break\n    sum += data[3][i]\n    if ans < sum + dp[w - 3 * (i+1)][0] :\n        ans = sum + dp[w-3*(i+1)][0]\n\n\n\n\nprint(ans)\n\n",
        "correct": false,
        "task_id": "0418",
        "depth": 2
    },
    {
        "description": "There is a rectangular grid of n rows of m initially-white cells each.\n\nArkady performed a certain number (possibly zero) of operations on it. In the i-th operation, a non-empty subset of rows Ri and a non-empty subset of columns Ci are chosen. For each row r in Ri and each column c in Ci, the intersection of row r and column c is coloured black.\n\nThere's another constraint: a row or a column can only be chosen at most once among all operations. In other words, it means that no pair of (i, j) (i < j) exists such that <image> or <image>, where <image> denotes intersection of sets, and <image> denotes the empty set.\n\nYou are to determine whether a valid sequence of operations exists that produces a given final grid.\n\nInput\n\nThe first line contains two space-separated integers n and m (1 \u2264 n, m \u2264 50) \u2014 the number of rows and columns of the grid, respectively.\n\nEach of the following n lines contains a string of m characters, each being either '.' (denoting a white cell) or '#' (denoting a black cell), representing the desired setup.\n\nOutput\n\nIf the given grid can be achieved by any valid sequence of operations, output \"Yes\"; otherwise output \"No\" (both without quotes).\n\nYou can print each character in any case (upper or lower).\n\nExamples\n\nInput\n\n5 8\n.#.#..#.\n.....#..\n.#.#..#.\n#.#....#\n.....#..\n\n\nOutput\n\nYes\n\n\nInput\n\n5 5\n..#..\n..#..\n#####\n..#..\n..#..\n\n\nOutput\n\nNo\n\n\nInput\n\n5 9\n........#\n#........\n..##.#...\n.......#.\n....#.#.#\n\n\nOutput\n\nNo\n\nNote\n\nFor the first example, the desired setup can be produced by 3 operations, as is shown below.\n\n<image>\n\nFor the second example, the desired setup cannot be produced, since in order to colour the center row, the third row and all columns must be selected in one operation, but after that no column can be selected again, hence it won't be possible to colour the other cells in the center column.",
        "task_name": "924_A. Mystical Mosaic",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division\nfrom sys import stdin, stdout\n# from fractions import gcd\n# from math import *\n# from operator import mul\n# from functools import reduce\n# from copy import copy\nfrom collections import deque, defaultdict, Counter\n\nrstr = lambda: stdin.readline().strip()\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\nrint = lambda: int(stdin.readline())\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrstr_2d = lambda n: [rstr() for _ in range(n)]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\nout = []\n\nn, m = rints()\ngrid, all, ans = rstr_2d(n), [], 'YES'\n\nfor i in range(m):\n    tem = set()\n    for j in range(n):\n        if grid[j][i] == '#':\n            tem.add(j)\n\n    if tem:\n        for j in all:\n            inter = tem.intersection(j)\n            # print(tem,inter,ans)\n            if inter:\n                if inter != tem:\n                    ans = 'NO'\n                break\n\n        if tem not in all:\n            all.append(tem)\n    # print(all)\n\nprint(ans)\n",
        "correct": false,
        "task_id": "0420",
        "depth": 2
    },
    {
        "description": "There are N stones arranged in a row. Every stone is painted white or black. A string S represents the color of the stones. The i-th stone from the left is white if the i-th character of S is `.`, and the stone is black if the character is `#`.\n\nTakahashi wants to change the colors of some stones to black or white so that there will be no white stone immediately to the right of a black stone. Find the minimum number of stones that needs to be recolored.\n\nConstraints\n\n* 1 \\leq N \\leq 2\\times 10^5\n* S is a string of length N consisting of `.` and `#`.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nS\n\n\nOutput\n\nPrint the minimum number of stones that needs to be recolored.\n\nExamples\n\nInput\n\n3\n#.#\n\n\nOutput\n\n1\n\n\nInput\n\n3\n.#\n\n\nOutput\n\n1\n\n\nInput\n\n5\n.##.\n\n\nOutput\n\n2\n\n\nInput\n\n9\n.........\n\n\nOutput\n\n0",
        "task_name": "p03069 Tenka1 Programmer Beginner Contest 2019 - Stones",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n=int(raw_input())\ns=raw_input()\n\ntemp=s.count(\"#\")\nif temp==0 or temp==n:\n    print(0)\nelse:\n    head=0\n    tail=n-temp\n    ret=tail+head\n    for c in s:\n        if c==\"#\":\n            head+=1\n        else:\n            tail-=1\n        temp2=head+tail\n        if temp2<ret:\n            ret=temp2\n    print(ret)\n",
        "correct": true,
        "task_id": "0426",
        "depth": 1
    },
    {
        "description": "Stick n circular stickers with a radius of 1 on a square origami paper with a side length of 10. The stickers can be stacked. Create a program that reads the coordinates of the position where the stickers are to be attached and outputs the number of stickers at the place where the stickers overlap most on the origami paper (assuming that even one sticker \"overlaps\"). ..\n\nGives the x and y coordinates with the lower left corner of the origami as the origin. Let's put the sticker with these x and y as the center of the circle. The center of the circle never goes out of the origami. Also, multiple stickers will not be attached at the same coordinates.\n\nHint\n\nIt is a figure with a sticker attached as shown in the input example. The circle represents the sticker, and the number represents the number of lines in the input example. At point (2.3, 4.6), the four stickers on the second, third, sixth, and tenth lines of the input example overlap.\n\n<image>\n\nThe distance between the centers of 6 and 9 is 2.01293, so the seals do not overlap. The distance between the centers of 1 and 12 is 1.98231, so the seals overlap.\n\nWhen two circles are in contact (when the distance between the centers is 2), they are assumed to overlap.\n\n\n\nInput\n\nGiven multiple datasets. Each dataset is given in the following format:\n\n\nn\nx1, y1\nx2, y2\n::\nxn, yn\n\n\nThe first line gives the number of stickers n (0 \u2264 100). The next n lines give the center coordinates of each seal. xi and yi represent the x and y coordinates of the center of the i-th sticker. Each value is given as a real number, including up to 6 digits after the decimal point.\n\nWhen n is 0, it is the end of the input. The number of datasets does not exceed 50.\n\nOutput\n\nFor each data set, output the number of stickers (integer) at the place where the stickers overlap most on the origami paper.\n\nExample\n\nInput\n\n15\n3.14979,8.51743\n2.39506,3.84915\n2.68432,5.39095\n5.61904,9.16332\n7.85653,4.75593\n2.84021,5.41511\n1.79500,8.59211\n7.55389,8.17604\n4.70665,4.66125\n1.63470,4.42538\n7.34959,4.61981\n5.09003,8.11122\n5.24373,1.30066\n0.13517,1.83659\n7.57313,1.58150\n0\n\n\nOutput\n\n4",
        "task_name": "p00090 Overlaps of Seals",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"Reference\nhttp://homepage1.nifty.com/gfk/circle-circle.htm\n\"\"\"\nfrom __future__ import (division, absolute_import, print_function,\n                        unicode_literals)\nfrom sys import stdin\nimport math\n\nRADIUS, RADIUS_2 = 1 + 1.0e-12, 2 + 1.0e-12\n\nnum_data = int(stdin.readline())\ndata = []\nfor _ in range(num_data):\n    data.append(tuple(float(s) for s in stdin.readline().split(',')))\n\ncross_points = []\nfor i in range(num_data):\n    x1, y1 = data[i]\n    for j in range(num_data):\n        if i == j:\n            continue\n        x2, y2 = data[j]\n\n        distance = math.hypot(x2-x1, y2-y1)\n        if distance <= RADIUS_2:\n            if x1 == x2 and y1 == y2:\n                cp1 = cp2 = (x1, y1)\n            else:\n                th = math.atan2(y2-y1, x2-x1)\n                al = math.acos(distance**2 / (2.0*distance))\n                cp1 = (x1 + math.cos(th + al), y1 + math.sin(th + al))\n                cp2 = (x1 + math.cos(th - al), y1 + math.sin(th - al))\n\n            if 0.0 <= cp1[0] <= 10.0 and 0.0 <= cp1[1] <= 10.0:\n                cross_points.append(cp1)\n            if 0.0 <= cp2[0] <= 10.0 and 0.0 <= cp2[1] <= 10.0:\n                cross_points.append(cp2)\n\nmax_overlap = 0\nfor cx, cy in cross_points:\n    count = 0\n    for x, y in data:\n        if math.hypot(cx-x, cy-y) <= RADIUS:\n            count += 1\n    if max_overlap < count:\n        max_overlap = count\nprint(max_overlap)",
        "correct": false,
        "task_id": "0430",
        "depth": 2
    },
    {
        "description": "For a given sequence A = {a0, a1, ... , an-1}, find the length of the longest increasing subsequnece (LIS) in A.\n\nAn increasing subsequence of A is defined by a subsequence {ai0, ai1, ... , aik} where 0 \u2264 i0 < i1 < ... < ik < n and ai0 < ai1 < ... < aik.\n\nConstraints\n\n* 1 \u2264 n \u2264 100000\n* 0 \u2264 ai \u2264 109\n\nInput\n\n\nn\na0\na1\n:\nan-1\n\n\n\nIn the first line, an integer n is given. In the next n lines, elements of A are given.\n\nOutput\n\nThe length of the longest increasing subsequence of A.\n\nExamples\n\nInput\n\n5\n5\n1\n3\n2\n4\n\n\nOutput\n\n3\n\n\nInput\n\n3\n1\n1\n1\n\n\nOutput\n\n1",
        "task_name": "p02317 Longest Increasing Subsequence",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import bisect\nn=input()\na=[input() for i in xrange(n)]\ndp=[float('inf') for _ in xrange(n)]\nfor i in xrange(n):\n    dp[bisect.bisect_left(dp,a[i])]=a[i]\nfor i in xrange(n):\n    if dp[i]==float('inf'):\n        print(i)\n        break",
        "correct": false,
        "task_id": "0433",
        "depth": 1
    },
    {
        "description": "Enough is enough. Too many times it happened that Vasya forgot to dispose of garbage and his apartment stank afterwards. Now he wants to create a garbage disposal plan and stick to it.\n\nFor each of next n days Vasya knows a_i \u2014 number of units of garbage he will produce on the i-th day. Each unit of garbage must be disposed of either on the day it was produced or on the next day. Vasya disposes of garbage by putting it inside a bag and dropping the bag into a garbage container. Each bag can contain up to k units of garbage. It is allowed to compose and drop multiple bags into a garbage container in a single day.\n\nBeing economical, Vasya wants to use as few bags as possible. You are to compute the minimum number of bags Vasya needs to dispose of all of his garbage for the given n days. No garbage should be left after the n-th day.\n\nInput\n\nThe first line of the input contains two integers n and k (1 \u2264 n \u2264 2\u22c510^5, 1 \u2264 k \u2264 10^9) \u2014 number of days to consider and bag's capacity. The second line contains n space separated integers a_i (0 \u2264 a_i \u2264 10^9) \u2014 the number of units of garbage produced on the i-th day.\n\nOutput\n\nOutput a single integer \u2014 the minimum number of bags Vasya needs to dispose of all garbage. Each unit of garbage should be disposed on the day it was produced or on the next day. No garbage can be left after the n-th day. In a day it is allowed to compose and drop multiple bags.\n\nExamples\n\nInput\n\n3 2\n3 2 1\n\n\nOutput\n\n3\n\n\nInput\n\n5 1\n1000000000 1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n5000000000\n\n\nInput\n\n3 2\n1 0 1\n\n\nOutput\n\n2\n\n\nInput\n\n4 4\n2 8 4 1\n\n\nOutput\n\n4",
        "task_name": "1070_D. Garbage Disposal",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"\nWhat I cannot create, I do not understand.\n\nhttps://github.com/Cheran-Senthil/PyRival\nCopyright (c) 2018 Cheran Senthilkumar\n\"\"\"\n# IMPORTS---------------------------------------------------------------------#\nfrom __future__ import division, print_function\n\nimport itertools\nimport sys\nfrom atexit import register\nfrom io import BytesIO\n\n# import cmath\nimport math\n# import operator as op\n# import random\n# from bisect import bisect_left as bl, bisect_right as br\n# from collections import Counter, defaultdict, deque\n# from copy import deepcopy\n# from cPickle import dumps\n# from decimal import Decimal, getcontext\n# from difflib import SequenceMatcher\n# from fractions import Fraction, gcd\n# from heapq import heappop, heappush\n# from Queue import PriorityQueue, Queue\n\n\n# PYTHON3---------------------------------------------------------------------#\nclass dict(dict):\n    def items(self):\n        return dict.iteritems(self)\n\n    def keys(self):\n        return dict.iterkeys(self)\n\n    def values(self):\n        return dict.itervalues(self)\n\n\nfilter = itertools.ifilter\nmap = itertools.imap\nzip = itertools.izip\n\ninput = raw_input\nrange = xrange\n\n\n# FASTIO----------------------------------------------------------------------#\n# sys.stdout = BytesIO()\n# register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n# sys.stdin = BytesIO(sys.stdin.read())\n\n# input = lambda: sys.stdin.readline().rstrip()\n# print = lambda *args: sys.stdout.write(' '.join(str(x) for x in args) + '\\n')\n# flush = sys.stdout.flush\n\n\n# SETTINGS--------------------------------------------------------------------#\n# getcontext().prec = 100\n# sys.setrecursionlimit(32768)\n\n\n# CONSTANTS-------------------------------------------------------------------#\nMOD = 1000000007\nINF = float('+inf')\n\nASCII_LOWERCASE = 'abcdefghijklmnopqrstuvwxyz'\nASCII_UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n\n# MAIN------------------------------------------------------------------------#\ndef helper(a, k):\n    bags, carry = 0, 0\n    for i in a:\n        if carry != 0:\n            bags += 1\n            i = max(0, i - carry)\n        bags += i // k\n        carry = i % k\n\n    if carry != 0:\n        bags += 1\n    \n    return bags\n\ndef main():\n    _, k = map(int, input().split(' '))\n    a = list(map(int, input().split(' ')))\n    print(min(helper(a, k), helper(a[::-1], k)))\n\n    \n    \n\n\nif __name__ == '__main__':\n    main()\n",
        "correct": false,
        "task_id": "0435",
        "depth": 1
    },
    {
        "description": "Vasya has a pile, that consists of some number of stones. n times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.\n\nYou are given n operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.\n\nInput\n\nThe first line contains one positive integer n \u2014 the number of operations, that have been made by Vasya (1 \u2264 n \u2264 100).\n\nThe next line contains the string s, consisting of n symbols, equal to \"-\" (without quotes) or \"+\" (without quotes). If Vasya took the stone on i-th operation, s_i is equal to \"-\" (without quotes), if added, s_i is equal to \"+\" (without quotes).\n\nOutput\n\nPrint one integer \u2014 the minimal possible number of stones that can be in the pile after these n operations.\n\nExamples\n\nInput\n\n\n3\n---\n\n\nOutput\n\n\n0\n\nInput\n\n\n4\n++++\n\n\nOutput\n\n\n4\n\nInput\n\n\n2\n-+\n\n\nOutput\n\n\n1\n\nInput\n\n\n5\n++-++\n\n\nOutput\n\n\n3\n\nNote\n\nIn the first test, if Vasya had 3 stones in the pile at the beginning, after making operations the number of stones will be equal to 0. It is impossible to have less number of piles, so the answer is 0. Please notice, that the number of stones at the beginning can't be less, than 3, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).\n\nIn the second test, if Vasya had 0 stones in the pile at the beginning, after making operations the number of stones will be equal to 4. It is impossible to have less number of piles because after making 4 operations the number of stones in the pile increases on 4 stones. So, the answer is 4.\n\nIn the third test, if Vasya had 1 stone in the pile at the beginning, after making operations the number of stones will be equal to 1. It can be proved, that it is impossible to have less number of stones after making the operations.\n\nIn the fourth test, if Vasya had 0 stones in the pile at the beginning, after making operations the number of stones will be equal to 3.",
        "task_name": "1159_A. A pile of stones",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\"\"\"<https://github.com/cheran-senthil/PyRival>\"\"\"\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    _str = str\n    str = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\n\n\ndef main():\n    n = int(input())\n    s = input()\n    cnt = 0\n    for i in range(n):\n        cnt += 1 if s[i] == '+' else -1\n        if cnt < 0:\n            cnt = 0\n    print(cnt)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._buffer = BytesIO()\n        self._fd = file.fileno()\n        self._writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self._buffer.write if self._writable else None\n\n    def read(self):\n        if self._buffer.tell():\n            return self._buffer.read()\n        return os.read(self._fd, os.fstat(self._fd).st_size)\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n    def flush(self):\n        if self._writable:\n            os.write(self._fd, self._buffer.getvalue())\n            self._buffer.truncate(0), self._buffer.seek(0)\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", b\" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", b\"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(b\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "0437",
        "depth": 1
    },
    {
        "description": "A monopole magnet is a magnet that only has one pole, either north or south. They don't actually exist since real magnets have two poles, but this is a programming contest problem, so we don't care.\n\nThere is an n\u00d7 m grid. Initially, you may place some north magnets and some south magnets into the cells. You are allowed to place as many magnets as you like, even multiple in the same cell.\n\nAn operation is performed as follows. Choose a north magnet and a south magnet to activate. If they are in the same row or the same column and they occupy different cells, then the north magnet moves one unit closer to the south magnet. Otherwise, if they occupy the same cell or do not share a row or column, then nothing changes. Note that the south magnets are immovable.\n\nEach cell of the grid is colored black or white. Let's consider ways to place magnets in the cells so that the following conditions are met.\n\n  1. There is at least one south magnet in every row and every column. \n  2. If a cell is colored black, then it is possible for a north magnet to occupy this cell after some sequence of operations from the initial placement. \n  3. If a cell is colored white, then it is impossible for a north magnet to occupy this cell after some sequence of operations from the initial placement. \n\n\n\nDetermine if it is possible to place magnets such that these conditions are met. If it is possible, find the minimum number of north magnets required (there are no requirements on the number of south magnets).\n\nInput\n\nThe first line contains two integers n and m (1\u2264 n,m\u2264 1000) \u2014 the number of rows and the number of columns, respectively.\n\nThe next n lines describe the coloring. The i-th of these lines contains a string of length m, where the j-th character denotes the color of the cell in row i and column j. The characters \"#\" and \".\" represent black and white, respectively. It is guaranteed, that the string will not contain any other characters.\n\nOutput\n\nOutput a single integer, the minimum possible number of north magnets required.\n\nIf there is no placement of magnets that satisfies all conditions, print a single integer -1.\n\nExamples\n\nInput\n\n\n3 3\n.#.\n###\n##.\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n4 2\n##\n.#\n.#\n##\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n4 5\n....#\n####.\n.###.\n.#...\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n2 1\n.\n#\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n3 5\n.....\n.....\n.....\n\n\nOutput\n\n\n0\n\nNote\n\nIn the first test, here is an example placement of magnets:\n\n<image>\n\nIn the second test, we can show that no required placement of magnets exists. Here are three example placements that fail to meet the requirements. The first example violates rule 3 since we can move the north magnet down onto a white square. The second example violates rule 2 since we cannot move the north magnet to the bottom-left black square by any sequence of operations. The third example violates rule 1 since there is no south magnet in the first column.\n\n<image>\n\nIn the third test, here is an example placement of magnets. We can show that there is no required placement of magnets with fewer north magnets.\n\n<image>\n\nIn the fourth test, we can show that no required placement of magnets exists. Here are two example placements that fail to meet the requirements. The first example violates rule 1 since there is no south magnet in the first row. The second example violates rules 1 and 3 since there is no south magnet in the second row and we can move the north magnet up one unit onto a white square.\n\n<image>\n\nIn the fifth test, we can put the south magnet in each cell and no north magnets. Because there are no black cells, it will be a correct placement.",
        "task_name": "1344_B. Monopole Magnets",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n\n    def find(self, a):\n        acopy = a\n        while a != self.parent[a]:\n            a = self.parent[a]\n        while acopy != a:\n            self.parent[acopy], acopy = a, self.parent[acopy]\n        return a\n\n    def union(self, a, b):\n        a, b = self.find(a), self.find(b)\n        if a != b:\n            if self.size[a] < self.size[b]:\n                a, b = b, a\n\n            self.num_sets -= 1\n            self.parent[b] = a\n            self.size[a] += self.size[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    dsu = DisjointSetUnion(n * m)\n\n    f_col = [-1] * n\n    f_row = [-1] * m\n\n    cols = set(range(n))\n    rows = set(range(m))\n\n    exists = True\n    black = False\n\n    white = 0\n    prev_row = '.' * m\n    for i in range(n):\n        row = input()\n        for j in range(m):\n            if row[j] == prev_row[j] == '#':\n                dsu.union((i * m) + j, ((i - 1) * m) + j)\n            if j and row[j] == row[j - 1] == '#':\n                dsu.union((i * m) + j, (i * m) + j - 1)\n\n            if row[j] == '#':\n                black = True\n                f_col[i] = f_col[i] if f_col[i] != -1 else j\n                f_row[j] = f_row[j] if f_row[j] != -1 else i\n                exists &= abs(f_col[i] - j) < 2\n                exists &= abs(f_row[j] - i) < 2\n                f_col[i] = j\n                f_row[j] = i\n                cols.discard(i)\n                rows.discard(j)\n            else:\n                white += 1\n\n        prev_row = row\n\n    if (((not cols) and (not rows)) or (not black)) and exists:\n        print(len(dsu) - white)\n    else:\n        print(-1)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": false,
        "task_id": "0443",
        "depth": 2
    },
    {
        "description": "You are given an array consisting of n integers a_1, a_2, ..., a_n. Initially a_x = 1, all other elements are equal to 0.\n\nYou have to perform m operations. During the i-th operation, you choose two indices c and d such that l_i \u2264 c, d \u2264 r_i, and swap a_c and a_d.\n\nCalculate the number of indices k such that it is possible to choose the operations so that a_k = 1 in the end.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then the description of t testcases follow.\n\nThe first line of each test case contains three integers n, x and m (1 \u2264 n \u2264 10^9; 1 \u2264 m \u2264 100; 1 \u2264 x \u2264 n).\n\nEach of next m lines contains the descriptions of the operations; the i-th line contains two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n).\n\nOutput\n\nFor each test case print one integer \u2014 the number of indices k such that it is possible to choose the operations so that a_k = 1 in the end.\n\nExample\n\nInput\n\n\n3\n6 4 3\n1 6\n2 3\n5 5\n4 1 2\n2 4\n1 2\n3 3 2\n2 3\n1 2\n\n\nOutput\n\n\n6\n2\n3\n\nNote\n\nIn the first test case, it is possible to achieve a_k = 1 for every k. To do so, you may use the following operations:\n\n  1. swap a_k and a_4; \n  2. swap a_2 and a_2; \n  3. swap a_5 and a_5. \n\n\n\nIn the second test case, only k = 1 and k = 2 are possible answers. To achieve a_1 = 1, you have to swap a_1 and a_1 during the second operation. To achieve a_2 = 1, you have to swap a_1 and a_2 during the second operation.",
        "task_name": "1366_B. Shuffle",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "FAST_IO = 1\nif FAST_IO:\n    import io, sys, atexit\n    rr = iter(sys.stdin.read().splitlines()).next\n    sys.stdout = _OUTPUT_BUFFER = io.BytesIO()\n    @atexit.register\n    def write():\n        sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\nelse:\n    rr = raw_input\nrri = lambda: int(rr())\nrrm = lambda: map(int, rr().split())\n                  \ndef solve(arr, n, x, m):\n    ans = 1\n    before = [x,x]\n    for a, b in arr:\n        if a<=before[0] and before[0]<=b<=before[1]:\n            ans+=before[0] -a\n            before = [a, before[1]]\n        elif before[0]<=a<=before[1] and b>=before[1]:\n            ans += b-before[1]\n            before = [before[0], b]\n        elif a<=before[0] and b>=before[1]:\n            ans += before[0]-a\n            ans+= b-before[1]\n            before = [a, b]\n    return ans\nt  = rri()\nfor _ in range(t):\n    n, x, m = rrm()\n    arr = []\n    for _ in range(m):\n        arr.append(rrm())\n    print(solve(arr, n, x, m))\n    ",
        "correct": true,
        "task_id": "0444",
        "depth": 2
    },
    {
        "description": "One day, as Sherlock Holmes was tracking down one very important criminal, he found a wonderful painting on the wall. This wall could be represented as a plane. The painting had several concentric circles that divided the wall into several parts. Some parts were painted red and all the other were painted blue. Besides, any two neighboring parts were painted different colors, that is, the red and the blue color were alternating, i. e. followed one after the other. The outer area of the wall (the area that lied outside all circles) was painted blue. Help Sherlock Holmes determine the total area of red parts of the wall.\n\nLet us remind you that two circles are called concentric if their centers coincide. Several circles are called concentric if any two of them are concentric.\n\nInput\n\nThe first line contains the single integer n (1 \u2264 n \u2264 100). The second line contains n space-separated integers ri (1 \u2264 ri \u2264 1000) \u2014 the circles' radii. It is guaranteed that all circles are different.\n\nOutput\n\nPrint the single real number \u2014 total area of the part of the wall that is painted red. The answer is accepted if absolute or relative error doesn't exceed 10 - 4.\n\nExamples\n\nInput\n\n1\n1\n\n\nOutput\n\n3.1415926536\n\n\nInput\n\n3\n1 4 2\n\n\nOutput\n\n40.8407044967\n\nNote\n\nIn the first sample the picture is just one circle of radius 1. Inner part of the circle is painted red. The area of the red part equals \u03c0 \u00d7 12 = \u03c0.\n\nIn the second sample there are three circles of radii 1, 4 and 2. Outside part of the second circle is painted blue. Part between the second and the third circles is painted red. Part between the first and the third is painted blue. And, finally, the inner part of the first circle is painted red. Overall there are two red parts: the ring between the second and the third circles and the inner part of the first circle. Total area of the red parts is equal (\u03c0 \u00d7 42 - \u03c0 \u00d7 22) + \u03c0 \u00d7 12 = \u03c0 \u00d7 12 + \u03c0 = 13\u03c0",
        "task_name": "157_B. Trace",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport math\n\nnCircles = int(sys.stdin.readline())\n\nif nCircles < 1:\n    sys.stdout.write('0\\n')\n    sys.exit()\n\nareas = []\ninput = sys.stdin.readline()\nfor radius in input.split(' '):\n    areas.append(int(radius)*int(radius))\n\nareas.sort()\n\ntotalArea = 0\nfor index, area in enumerate(areas):\n    if index == 0:\n        totalArea += area\n    elif index % 2 == 0:\n        totalArea += (areas[index] - areas[index-1])\n\ntotalArea *= math.pi\nsys.stdout.write(str(totalArea)+'\\n')\n",
        "correct": false,
        "task_id": "0449",
        "depth": 1
    },
    {
        "description": "For some reason in many American cartoons anvils fall from time to time onto heroes' heads. Of course, safes, wardrobes, cruisers, planes fall sometimes too... But anvils do so most of all.\n\nAnvils come in different sizes and shapes. Quite often they get the hero stuck deep in the ground. But have you ever thought who throws anvils from the sky? From what height? We are sure that such questions have never troubled you!\n\nIt turns out that throwing an anvil properly is not an easy task at all. Let's describe one of the most popular anvil throwing models.\n\nLet the height p of the potential victim vary in the range [0;a] and the direction of the wind q vary in the range [ - b;b]. p and q could be any real (floating) numbers. Then we can assume that the anvil will fit the toon's head perfectly only if the following equation has at least one real root: \n\n<image>\n\nDetermine the probability with which an aim can be successfully hit by an anvil.\n\nYou can assume that the p and q coefficients are chosen equiprobably and independently in their ranges.\n\nInput\n\nThe first line contains integer t (1 \u2264 t \u2264 10000) \u2014 amount of testcases.\n\nEach of the following t lines contain two space-separated integers a and b (0 \u2264 a, b \u2264 106).\n\nPretests contain all the tests with 0 < a < 10, 0 \u2264 b < 10.\n\nOutput\n\nPrint t lines \u2014 the probability of a successful anvil hit for each testcase. The absolute or relative error of the answer should not exceed 10 - 6.\n\nExamples\n\nInput\n\n2\n4 2\n1 2\n\n\nOutput\n\n0.6250000000\n0.5312500000",
        "task_name": "80_D. Falling Anvils",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "t = int(raw_input())\nfor i in range(0, t):\n    a, b = map(int, raw_input().split())\n    if(b == 0):\n        print(1)\n        continue\n    if(a == 0):\n        print(0.5)\n        continue\n    p = a * b + max(a-4*b, 0) * b\n    q = a * 2 * b\n    a = min(a, 4 * b)\n    p = p + a * a / 8.0\n    print(p / (1.0 * q))",
        "correct": true,
        "task_id": "0461",
        "depth": 1
    },
    {
        "description": "Two best friends Serozha and Gena play a game.\n\nInitially there is one pile consisting of n stones on the table. During one move one pile should be taken and divided into an arbitrary number of piles consisting of a1 > a2 > ... > ak > 0 stones. The piles should meet the condition a1 - a2 = a2 - a3 = ... = ak - 1 - ak = 1. Naturally, the number of piles k should be no less than two.\n\nThe friends play in turns. The player who cannot make a move loses. Serozha makes the first move. Who will win if both players play in the optimal way?\n\nInput\n\nThe single line contains a single integer n (1 \u2264 n \u2264 105).\n\nOutput\n\nIf Serozha wins, print k, which represents the minimal number of piles into which he can split the initial one during the first move in order to win the game.\n\nIf Gena wins, print \"-1\" (without the quotes).\n\nExamples\n\nInput\n\n3\n\n\nOutput\n\n2\n\n\nInput\n\n6\n\n\nOutput\n\n-1\n\n\nInput\n\n100\n\n\nOutput\n\n8",
        "task_name": "87_C. Interesting Game",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n\n\nn = input()\n\n\nspg = [0] * (n + 1)\nxor = [0] * (n + 1)\n\nfor i in range(3, n + 1):\n    k = 2\n    movs = set()\n    while k * (k + 1) <= 2 * i:\n        s = 2 * i - k * (k - 1)\n\n        if s % (2 * k) == 0:\n            a = s / 2 / k\n            movs.add(xor[a + k - 1] ^ xor[a - 1])\n        k += 1\n\n    mex = 0\n    while mex in movs:\n        mex += 1\n    spg[i] = mex\n    xor[i] = xor[i - 1] ^ mex\n\nif spg[n]:\n    k = 2\n    while k * (k + 1) <= 2 * i:\n        s = 2 * i - k * (k - 1)\n\n        if s % (2 * k) == 0:\n            a = s / 2 / k\n            if (xor[a + k - 1] ^ xor[a - 1]) == 0:\n                break\n        k += 1\n    print(k)\nelse:\n    print(-1)\n",
        "correct": true,
        "task_id": "0463",
        "depth": 2
    },
    {
        "description": "The average miner Vaganych took refresher courses. As soon as a miner completes the courses, he should take exams. The hardest one is a computer test called \"Testing Pants for Sadness\".\n\nThe test consists of n questions; the questions are to be answered strictly in the order in which they are given, from question 1 to question n. Question i contains ai answer variants, exactly one of them is correct. \n\nA click is regarded as selecting any answer in any question. The goal is to select the correct answer for each of the n questions. If Vaganych selects a wrong answer for some question, then all selected answers become unselected and the test starts from the very beginning, from question 1 again. But Vaganych remembers everything. The order of answers for each question and the order of questions remain unchanged, as well as the question and answers themselves.\n\nVaganych is very smart and his memory is superb, yet he is unbelievably unlucky and knows nothing whatsoever about the test's theme. How many clicks will he have to perform in the worst case?\n\nInput\n\nThe first line contains a positive integer n (1 \u2264 n \u2264 100). It is the number of questions in the test. The second line contains space-separated n positive integers ai (1 \u2264 ai \u2264 109), the number of answer variants to question i.\n\nOutput\n\nPrint a single number \u2014 the minimal number of clicks needed to pass the test it the worst-case scenario. \n\nPlease do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specificator.\n\nExamples\n\nInput\n\n2\n1 1\n\n\nOutput\n\n2\n\nInput\n\n2\n2 2\n\n\nOutput\n\n5\n\nInput\n\n1\n10\n\n\nOutput\n\n10\n\nNote\n\nNote to the second sample. In the worst-case scenario you will need five clicks: \n\n  * the first click selects the first variant to the first question, this answer turns out to be wrong. \n  * the second click selects the second variant to the first question, it proves correct and we move on to the second question; \n  * the third click selects the first variant to the second question, it is wrong and we go back to question 1; \n  * the fourth click selects the second variant to the first question, it proves as correct as it was and we move on to the second question; \n  * the fifth click selects the second variant to the second question, it proves correct, the test is finished. ",
        "task_name": "103_A. Testing Pants for Sadness",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = input()\na = list(map(int, raw_input().split()))\na = [0] + a\nans = 0\nfor i in range(1, n + 1):\n\tans += 1 + (a[i] - 1) * i\nprint(ans)\n",
        "correct": true,
        "task_id": "0471",
        "depth": 1
    },
    {
        "description": "Cowboy Vlad has a birthday today! There are n children who came to the celebration. In order to greet Vlad, the children decided to form a circle around him. Among the children who came, there are both tall and low, so if they stand in a circle arbitrarily, it may turn out, that there is a tall and low child standing next to each other, and it will be difficult for them to hold hands. Therefore, children want to stand in a circle so that the maximum difference between the growth of two neighboring children would be minimal possible.\n\nFormally, let's number children from 1 to n in a circle order, that is, for every i child with number i will stand next to the child with number i+1, also the child with number 1 stands next to the child with number n. Then we will call the discomfort of the circle the maximum absolute difference of heights of the children, who stand next to each other.\n\nPlease help children to find out how they should reorder themselves, so that the resulting discomfort is smallest possible.\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 100) \u2014 the number of the children who came to the cowboy Vlad's birthday.\n\nThe second line contains integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^9) denoting heights of every child.\n\nOutput\n\nPrint exactly n integers \u2014 heights of the children in the order in which they should stand in a circle. You can start printing a circle with any child.\n\nIf there are multiple possible answers, print any of them.\n\nExamples\n\nInput\n\n\n5\n2 1 1 3 2\n\n\nOutput\n\n\n1 2 3 2 1\n\n\nInput\n\n\n3\n30 10 20\n\n\nOutput\n\n\n10 20 30\n\nNote\n\nIn the first example, the discomfort of the circle is equal to 1, since the corresponding absolute differences are 1, 1, 1 and 0. Note, that sequences [2, 3, 2, 1, 1] and [3, 2, 1, 1, 2] form the same circles and differ only by the selection of the starting point.\n\nIn the second example, the discomfort of the circle is equal to 20, since the absolute difference of 10 and 30 is equal to 20.",
        "task_name": "1131_C. Birthday",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport random, math\nfrom collections import defaultdict\n\nn = int(raw_input())\narr = [int(__) for __ in raw_input().split()]\narr.sort(reverse = True)\nnewl = list()\nfl = 0\nfor el in arr:\n    if fl == 0:\n        newl.append(el)\n        fl = 1\n    else:\n        newl = [el] + newl\n        fl = 0\nprint(' '.join([str(x) for x in newl]))",
        "correct": true,
        "task_id": "0474",
        "depth": 1
    },
    {
        "description": "Tokitsukaze is one of the characters in the game \"Kantai Collection\". In this game, every character has a common attribute \u2014 health points, shortened to HP.\n\nIn general, different values of HP are grouped into 4 categories:\n\n  * Category A if HP is in the form of (4 n + 1), that is, when divided by 4, the remainder is 1; \n  * Category B if HP is in the form of (4 n + 3), that is, when divided by 4, the remainder is 3; \n  * Category C if HP is in the form of (4 n + 2), that is, when divided by 4, the remainder is 2; \n  * Category D if HP is in the form of 4 n, that is, when divided by 4, the remainder is 0. \n\n\n\nThe above-mentioned n can be any integer.\n\nThese 4 categories ordered from highest to lowest as A > B > C > D, which means category A is the highest and category D is the lowest.\n\nWhile playing the game, players can increase the HP of the character. Now, Tokitsukaze wants you to increase her HP by at most 2 (that is, either by 0, 1 or 2). How much should she increase her HP so that it has the highest possible category?\n\nInput\n\nThe only line contains a single integer x (30 \u2264 x \u2264 100) \u2014 the value Tokitsukaze's HP currently.\n\nOutput\n\nPrint an integer a (0 \u2264 a \u2264 2) and an uppercase letter b (b \u2208 { A, B, C, D }), representing that the best way is to increase her HP by a, and then the category becomes b.\n\nNote that the output characters are case-sensitive.\n\nExamples\n\nInput\n\n\n33\n\n\nOutput\n\n\n0 A\n\n\nInput\n\n\n98\n\n\nOutput\n\n\n1 B\n\nNote\n\nFor the first example, the category of Tokitsukaze's HP is already A, so you don't need to enhance her ability.\n\nFor the second example:\n\n  * If you don't increase her HP, its value is still 98, which equals to (4 \u00d7 24 + 2), and its category is C. \n  * If you increase her HP by 1, its value becomes 99, which equals to (4 \u00d7 24 + 3), and its category becomes B. \n  * If you increase her HP by 2, its value becomes 100, which equals to (4 \u00d7 25), and its category becomes D. \n\n\n\nTherefore, the best way is to increase her HP by 1 so that the category of her HP becomes B.",
        "task_name": "1191_A. Tokitsukaze and Enhancement",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "input_value = int(input())\n\nvalue_class = [3, 0, 2, 1]\nvalue_label = [\"A\", \"B\", \"C\", \"D\"]\n\ndef value_num(n):\n    return value_class[n % 4]\n\ntop_value = value_num(input_value)\ntop_add = 0\nfor add in [1, 2]:\n    add_val = value_num(input_value + add)\n    if add_val < top_value:\n        top_add = add\n        top_value = add_val\nprint( str(top_add) + \" \" + value_label[top_value] )\n",
        "correct": true,
        "task_id": "0476",
        "depth": 1
    },
    {
        "description": "SmallR is an archer. SmallR is taking a match of archer with Zanoes. They try to shoot in the target in turns, and SmallR shoots first. The probability of shooting the target each time is <image> for SmallR while <image> for Zanoes. The one who shoots in the target first should be the winner.\n\nOutput the probability that SmallR will win the match.\n\nInput\n\nA single line contains four integers <image>.\n\nOutput\n\nPrint a single real number, the probability that SmallR will win the match.\n\nThe answer will be considered correct if the absolute or relative error doesn't exceed 10 - 6.\n\nExamples\n\nInput\n\n1 2 1 2\n\n\nOutput\n\n0.666666666667",
        "task_name": "312_B. Archer",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division;\nfrom bisect import *;\nfrom fractions import Fraction;\nimport sys;\nfrom math import *;\nfrom fractions import *;\nimport io;\nimport re;\n\nINF = 987654321987654321987654321;\n\ndef readint(delimiter=' ') :\n\treturn map(int, raw_input().split(delimiter));\n\ndef readstr(delimiter=' ') :\n\treturn raw_input().split(delimiter);\n\ndef readfloat(delimiter=' ') :\n\treturn map(float, raw_input().split(delimiter));\n\ndef index(a, x):\n\t'Locate the leftmost value exactly equal to x'\n\ti = bisect_left(a, x)\n\tif i != len(a) and a[i] == x:\n\t\treturn i\n\traise ValueError\n\ndef find_lt(a, x):\n\t'Find rightmost value less than x'\n\ti = bisect_left(a, x)\n\tif i:\n\t\treturn a[i-1]\n\traise ValueError\n\ndef find_le(a, x):\n\t'Find rightmost value less than or equal to x'\n\ti = bisect_right(a, x)\n\tif i:\n\t\treturn a[i-1]\n\traise ValueError\n\ndef find_gt(a, x):\n\t'Find leftmost value greater than x'\n\ti = bisect_right(a, x)\n\tif i != len(a):\n\t\treturn a[i]\n\traise ValueError\n\ndef find_ge(a, x):\n\t'Find leftmost item greater than or equal to x'\n\ti = bisect_left(a, x)\n\tif i != len(a):\n\t\treturn a[i]\n\traise ValueError\n\ndef bin_search(a, x, left, right) :\n\n\twhile left<=right :\n\t\tmid = (left + right)//2;\n\t\t\n\t\tif a[mid] == x :\n\t\t\treturn mid;\n\t\telif a[mid] < x :\n\t\t\tleft = mid + 1; \n\t\telif a[mid] > x :\n\t\t\tright = mid - 1;\n\t\t\t\t\t   \n\t\tpass\n\t\n\treturn -1;\n\tpass\n\ndef printf(format, *args):\n\t\"\"\"Format args with the first argument as format string, and write.\n\tReturn the last arg, or format itself if there are no args.\"\"\"\n\tsys.stdout.write(str(format) % args)\n\t\n\nfrom datetime import date;\n\nif __name__ == '__main__':\n\n\ta, b, c, d = readint();\n\n\tprob_a = a/b;\n\tprob_b = c/d;\n\n\tprev = 0;\n\tnow = 0;\n\tnow += prob_a;\n\tacc = (1-prob_a)*(1-prob_b);\n\tii = 0;\n\twhile (now - prev > 0.0000001) :\n\t\tprev = now;\n\t\tii += 1;\n\t\tnow += acc*prob_a;\n\t\tacc *= (1-prob_a)*(1-prob_b);\n\t\tpass\n\n\tprintf('%.6f\\n', now);\n\t\n\tpass",
        "correct": false,
        "task_id": "0491",
        "depth": 1
    },
    {
        "description": "Wilbur is playing with a set of n points on the coordinate plane. All points have non-negative integer coordinates. Moreover, if some point (x, y) belongs to the set, then all points (x', y'), such that 0 \u2264 x' \u2264 x and 0 \u2264 y' \u2264 y also belong to this set.\n\nNow Wilbur wants to number the points in the set he has, that is assign them distinct integer numbers from 1 to n. In order to make the numbering aesthetically pleasing, Wilbur imposes the condition that if some point (x, y) gets number i, then all (x',y') from the set, such that x' \u2265 x and y' \u2265 y must be assigned a number not less than i. For example, for a set of four points (0, 0), (0, 1), (1, 0) and (1, 1), there are two aesthetically pleasing numberings. One is 1, 2, 3, 4 and another one is 1, 3, 2, 4.\n\nWilbur's friend comes along and challenges Wilbur. For any point he defines it's special value as s(x, y) = y - x. Now he gives Wilbur some w1, w2,..., wn, and asks him to find an aesthetically pleasing numbering of the points in the set, such that the point that gets number i has it's special value equal to wi, that is s(xi, yi) = yi - xi = wi.\n\nNow Wilbur asks you to help him with this challenge.\n\nInput\n\nThe first line of the input consists of a single integer n (1 \u2264 n \u2264 100 000) \u2014 the number of points in the set Wilbur is playing with.\n\nNext follow n lines with points descriptions. Each line contains two integers x and y (0 \u2264 x, y \u2264 100 000), that give one point in Wilbur's set. It's guaranteed that all points are distinct. Also, it is guaranteed that if some point (x, y) is present in the input, then all points (x', y'), such that 0 \u2264 x' \u2264 x and 0 \u2264 y' \u2264 y, are also present in the input.\n\nThe last line of the input contains n integers. The i-th of them is wi ( - 100 000 \u2264 wi \u2264 100 000) \u2014 the required special value of the point that gets number i in any aesthetically pleasing numbering.\n\nOutput\n\nIf there exists an aesthetically pleasant numbering of points in the set, such that s(xi, yi) = yi - xi = wi, then print \"YES\" on the first line of the output. Otherwise, print \"NO\".\n\nIf a solution exists, proceed output with n lines. On the i-th of these lines print the point of the set that gets number i. If there are multiple solutions, print any of them.\n\nExamples\n\nInput\n\n5\n2 0\n0 0\n1 0\n1 1\n0 1\n0 -1 -2 1 0\n\n\nOutput\n\nYES\n0 0\n1 0\n2 0\n0 1\n1 1\n\n\nInput\n\n3\n1 0\n0 0\n2 0\n0 1 2\n\n\nOutput\n\nNO\n\nNote\n\nIn the first sample, point (2, 0) gets number 3, point (0, 0) gets number one, point (1, 0) gets number 2, point (1, 1) gets number 5 and point (0, 1) gets number 4. One can easily check that this numbering is aesthetically pleasing and yi - xi = wi.\n\nIn the second sample, the special values of the points in the set are 0,  - 1, and  - 2 while the sequence that the friend gives to Wilbur is 0, 1, 2. Therefore, the answer does not exist.",
        "task_name": "596_C. Wilbur and Points",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\nfrom collections import *\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\n\n\ndef solve():\n    mem, mem2, out = Counter(w), defaultdict(list), []\n    for x, y in a:\n        mem2[y - x].append([x, y])\n\n    for i, j in mem.items():\n        if len(mem2[i]) != j:\n            print('NO')\n            exit()\n        mem2[i].sort(reverse=True)\n\n    for i in range(n):\n        x, y = mem2[w[i]][-1]\n        labels[x][y] = i + 1\n\n        if i and labels[x + 1][y] < labels[x][y] or labels[x][y + 1] < labels[x][y]:\n            print('NO')\n            exit()\n        out.append(' '.join(map(str, mem2[w[i]].pop())))\n\n    print('YES')\n    print('\\n'.join(out))\n\n\nn, labels = int(input()), [[0 for _ in range(1000)] for _ in range(1000)]\na, w = [rints() for _ in range(n)], rints()\nsolve()\n",
        "correct": false,
        "task_id": "0498",
        "depth": 1
    },
    {
        "description": "There is a set A = \\\\{ a_1, a_2, \\ldots, a_N \\\\} consisting of N positive integers. Taro and Jiro will play the following game against each other.\n\nInitially, we have a pile consisting of K stones. The two players perform the following operation alternately, starting from Taro:\n\n* Choose an element x in A, and remove exactly x stones from the pile.\n\n\n\nA player loses when he becomes unable to play. Assuming that both players play optimally, determine the winner.\n\nConstraints\n\n* All values in input are integers.\n* 1 \\leq N \\leq 100\n* 1 \\leq K \\leq 10^5\n* 1 \\leq a_1 < a_2 < \\cdots < a_N \\leq K\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN K\na_1 a_2 \\ldots a_N\n\n\nOutput\n\nIf Taro will win, print `First`; if Jiro will win, print `Second`.\n\nExamples\n\nInput\n\n2 4\n2 3\n\n\nOutput\n\nFirst\n\n\nInput\n\n2 5\n2 3\n\n\nOutput\n\nSecond\n\n\nInput\n\n2 7\n2 3\n\n\nOutput\n\nFirst\n\n\nInput\n\n3 20\n1 2 3\n\n\nOutput\n\nSecond\n\n\nInput\n\n3 21\n1 2 3\n\n\nOutput\n\nFirst\n\n\nInput\n\n1 100000\n1\n\n\nOutput\n\nSecond",
        "task_name": "p03170 Educational DP Contest - Stones",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import os\nfrom io import BytesIO\n\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nn, k = map(int, input().split())\na = [int(i) for i in input().split()]\n\ndp = [False] * (k + 1)\n\nfor ai in a:\n    dp[ai] = True\n\nfor i in xrange(max(a) + 1, k + 1):\n    dp[i] = any(not dp[i - ai] for ai in a)\n\nos.write(1, 'First' if dp[k] else 'Second')",
        "correct": false,
        "task_id": "0512",
        "depth": 1
    },
    {
        "description": "You are going out for a walk, when you suddenly encounter a monster. Fortunately, you have N katana (swords), Katana 1, Katana 2, \u2026, Katana N, and can perform the following two kinds of attacks in any order:\n\n* Wield one of the katana you have. When you wield Katana i (1 \u2264 i \u2264 N), the monster receives a_i points of damage. The same katana can be wielded any number of times.\n* Throw one of the katana you have. When you throw Katana i (1 \u2264 i \u2264 N) at the monster, it receives b_i points of damage, and you lose the katana. That is, you can no longer wield or throw that katana.\n\n\n\nThe monster will vanish when the total damage it has received is H points or more. At least how many attacks do you need in order to vanish it in total?\n\nConstraints\n\n* 1 \u2264 N \u2264 10^5\n* 1 \u2264 H \u2264 10^9\n* 1 \u2264 a_i \u2264 b_i \u2264 10^9\n* All input values are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN H\na_1 b_1\n:\na_N b_N\n\n\nOutput\n\nPrint the minimum total number of attacks required to vanish the monster.\n\nExamples\n\nInput\n\n1 10\n3 5\n\n\nOutput\n\n3\n\n\nInput\n\n2 10\n3 5\n2 6\n\n\nOutput\n\n2\n\n\nInput\n\n4 1000000000\n1 1\n1 10000000\n1 30000000\n1 99999999\n\n\nOutput\n\n860000004\n\n\nInput\n\n5 500\n35 44\n28 83\n46 62\n31 79\n40 43\n\n\nOutput\n\n9",
        "task_name": "p03472 AtCoder Beginner Contest 085 - Katana Thrower",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# -*- coding: utf-8 -*-\n\nimport sys\n\nn, h = [int(e) for e in raw_input().split()]\n\nkl = []\nfor i in range(0, n):\n    a, b = [int(e) for e in raw_input().split()]\n    kl.append((b, 0))\n    kl.append((a, 1))\n\nkl.sort(reverse=True)\n# print kl\n\nn = 0\ni = 0\nwhile h > 0:\n    k = kl[i]\n    if k[1] == 0:\n        h -= k[0]\n        i += 1\n        n += 1\n    else:\n        n = n + ((h + k[0] - 1) / k[0])\n        break\n\nsys.stdout.write('%d\\n' % (n))\nsys.stdout.flush()\n",
        "correct": true,
        "task_id": "0514",
        "depth": 1
    },
    {
        "description": "One day Mr. Takahashi picked up a dictionary containing all of the N! permutations of integers 1 through N. The dictionary has N! pages, and page i (1 \u2264 i \u2264 N!) contains the i-th permutation in the lexicographical order.\n\nMr. Takahashi wanted to look up a certain permutation of length N in this dictionary, but he forgot some part of it.\n\nHis memory of the permutation is described by a sequence P_1, P_2, ..., P_N. If P_i = 0, it means that he forgot the i-th element of the permutation; otherwise, it means that he remembered the i-th element of the permutation and it is P_i.\n\nHe decided to look up all the possible permutations in the dictionary. Compute the sum of the page numbers of the pages he has to check, modulo 10^9 + 7.\n\nConstraints\n\n* 1 \u2264 N \u2264 500000\n* 0 \u2264 P_i \u2264 N\n* P_i \u2260 P_j if i \u2260 j (1 \u2264 i, j \u2264 N), P_i \u2260 0 and P_j \u2260 0.\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN\nP_1 P_2 ... P_N\n\n\nOutput\n\nPrint the sum of the page numbers of the pages he has to check, as modulo 10^9 + 7.\n\nExamples\n\nInput\n\n4\n0 2 3 0\n\n\nOutput\n\n23\n\n\nInput\n\n3\n0 0 0\n\n\nOutput\n\n21\n\n\nInput\n\n5\n1 2 3 5 4\n\n\nOutput\n\n2\n\n\nInput\n\n1\n0\n\n\nOutput\n\n1\n\n\nInput\n\n10\n0 3 0 0 1 0 4 0 0 0\n\n\nOutput\n\n953330050",
        "task_name": "p03961 CODE FESTIVAL 2016 qual C - Encyclopedia of Permutations",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "N = int(raw_input())\na = [int(x)-1 for x in raw_input().split()]\nweight = [1] * N\nM = 10**9+7\ndef factorial(n):\n    acc = 1\n    for i in xrange(1, 1 + n):\n        acc = (acc * i) % M\n    return acc\ndef inv(n):\n    return pow(n, M-2, M)\nfor i in xrange(N-1):\n    weight[N-2-i] = (weight[N-1-i] * (i+1)) % M\nmissing = list(set(xrange(N)) - set(a))\nmissing.sort()\nn_missing = len(missing)\nsum_missing = sum(missing)\navg_missing = sum_missing * inv(n_missing)\nn_present = N - n_missing\nn_rows = factorial(n_missing)\nacc = 0\ni_missing = 0\ni_present = 0\nmissing_lt_tot = 0\nfor i, (w, x) in enumerate(zip(weight, a)):\n    if x == -1:\n        ai = avg_missing\n        bi = i_missing * inv(2) + i_present - missing_lt_tot * inv(n_missing)\n        i_missing += 1\n    else:\n        ai = x\n        bi = 0\n        for j in xrange(i):\n            if a[j] != -1 and a[j] < a[i]:\n                bi += 1\n        missing_lt = 0\n        for j in missing:\n            if j < a[i]:\n                missing_lt += 1\n        missing_lt_tot += missing_lt\n        #print '@', missing_lt, n_missing, i_missing, n_rows\n        bi += missing_lt * inv(n_missing) * i_missing\n        coeff = 1\n        i_present += 1\n    #print (ai * n_rows) % M, (bi * n_rows) % M, w\n    acc = (acc + ((ai - bi) * n_rows) * w) % M\nprint (acc + n_rows) % M\n",
        "correct": false,
        "task_id": "0517",
        "depth": 2
    },
    {
        "description": "Quick sort is based on the Divide-and-conquer approach. In QuickSort(A, p, r), first, a procedure Partition(A, p, r) divides an array A[p..r] into two subarrays A[p..q-1] and A[q+1..r] such that each element of A[p..q-1] is less than or equal to A[q], which is, inturn, less than or equal to each element of A[q+1..r]. It also computes the index q.\n\nIn the conquer processes, the two subarrays A[p..q-1] and A[q+1..r] are sorted by recursive calls of QuickSort(A, p, q-1) and QuickSort(A, q+1, r).\n\nYour task is to read a sequence A and perform the Partition based on the following pseudocode:\n\n\nPartition(A, p, r)\n1 x = A[r]\n2 i = p-1\n3 for j = p to r-1\n4     do if A[j] <= x\n5        then i = i+1\n6            exchange A[i] and A[j]\n7 exchange A[i+1] and A[r]\n8 return i+1\n\n\nNote that, in this algorithm, Partition always selects an element A[r] as a pivot element around which to partition the array A[p..r].\n\nConstraints\n\n* 1 \u2264 n \u2264 100,000\n* 0 \u2264 Ai \u2264 100,000\n\nInput\n\nThe first line of the input includes an integer n, the number of elements in the sequence A.\n\nIn the second line, Ai (i = 1,2,...,n), elements of the sequence are given separated by space characters.\n\nOutput\n\nPrint the sorted sequence. Two contiguous elements of the sequence should be separated by a space character. The element which is selected as the pivot of the partition should be indicated by [  ].\n\nExample\n\nInput\n\n12\n13 19 9 5 12 8 7 4 21 2 6 11\n\n\nOutput\n\n9 5 8 7 4 2 6 [11] 21 13 19 12",
        "task_name": "p02276 Partition",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\nfrom sys import stdin\n\n\ndef patition(a, p, r):\n    x = a[r]\n    i = p-1\n    for j in range(p, r):\n        if a[j] <= x:\n            i += 1\n            a[i], a[j] = a[j], a[i]\n    a[i+1], a[r] = a[r], a[i+1]\n    return i+1\n\n\nn = int(stdin.readline())\ndata = [int(s) for s in stdin.readline().split()]\npat = patition(data, 0, data[-1])\nprint(*data[:pat], end=' ')\nprint('[{}]'.format(data[pat]), *data[pat+1:])",
        "correct": false,
        "task_id": "0519",
        "depth": 1
    },
    {
        "description": "You are given an integer n (n \u2265 0) represented with k digits in base (radix) b. So,\n\n$$$n = a_1 \u22c5 b^{k-1} + a_2 \u22c5 b^{k-2} + \u2026 a_{k-1} \u22c5 b + a_k.$$$\n\nFor example, if b=17, k=3 and a=[11, 15, 7] then n=11\u22c517^2+15\u22c517+7=3179+255+7=3441.\n\nDetermine whether n is even or odd.\n\nInput\n\nThe first line contains two integers b and k (2\u2264 b\u2264 100, 1\u2264 k\u2264 10^5) \u2014 the base of the number and the number of digits.\n\nThe second line contains k integers a_1, a_2, \u2026, a_k (0\u2264 a_i < b) \u2014 the digits of n.\n\nThe representation of n contains no unnecessary leading zero. That is, a_1 can be equal to 0 only if k = 1.\n\nOutput\n\nPrint \"even\" if n is even, otherwise print \"odd\".\n\nYou can print each letter in any case (upper or lower).\n\nExamples\n\nInput\n\n13 3\n3 2 7\n\n\nOutput\n\neven\n\n\nInput\n\n10 9\n1 2 3 4 5 6 7 8 9\n\n\nOutput\n\nodd\n\n\nInput\n\n99 5\n32 92 85 74 4\n\n\nOutput\n\nodd\n\n\nInput\n\n2 2\n1 0\n\n\nOutput\n\neven\n\nNote\n\nIn the first example, n = 3 \u22c5 13^2 + 2 \u22c5 13 + 7 = 540, which is even.\n\nIn the second example, n = 123456789 is odd.\n\nIn the third example, n = 32 \u22c5 99^4 + 92 \u22c5 99^3 + 85 \u22c5 99^2 + 74 \u22c5 99 + 4 = 3164015155 is odd.\n\nIn the fourth example n = 2.",
        "task_name": "1110_A. Parity",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\"\"\"\nThis file is part of https://github.com/Cheran-Senthil/PyRival.\nCopyright 2019 Cheran Senthilkumar <hello@cheran.io>\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport cmath\nimport itertools\nimport math\nimport operator as op\n# import random\nimport sys\nfrom atexit import register\nfrom bisect import bisect_left, bisect_right\n# from collections import Counter, defaultdict, deque\n# from copy import deepcopy\n# from decimal import Decimal\n# from difflib import SequenceMatcher\n# from functools import reduce\n# from heapq import heappop, heappush\nfrom io import BytesIO, FileIO, StringIO\n\n\nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n\n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n\n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\n\nINP_FILE = 0\nOUT_FILE = 1\n\nif sys.version_info[0] < 3:\n    sys.stdin = BytesIO(FileIO(INP_FILE).read())\n    sys.stdout = BytesIO()\n    register(lambda: FileIO(OUT_FILE, 'w').write(sys.stdout.getvalue()))\nelse:\n    sys.stdin = StringIO(FileIO(INP_FILE).read().decode())\n    sys.stdout = StringIO()\n    register(lambda: FileIO(OUT_FILE, 'w').write(sys.stdout.getvalue().encode()))\n\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\ndef main():\n    b, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    n = k % 2\n    m = a[-1] % 2\n    if n == 1:\n        for i in a[:-1]:\n            if i % 2 == 1:\n                m = not m\n\n    print('odd' if m else 'even')\n\n\nif __name__ == '__main__':\n    main()\n",
        "correct": false,
        "task_id": "0522",
        "depth": 1
    },
    {
        "description": "For years, the Day of city N was held in the most rainy day of summer. New mayor decided to break this tradition and select a not-so-rainy day for the celebration. The mayor knows the weather forecast for the n days of summer. On the i-th day, a_i millimeters of rain will fall. All values a_i are distinct.\n\nThe mayor knows that citizens will watch the weather x days before the celebration and y days after. Because of that, he says that a day d is not-so-rainy if a_d is smaller than rain amounts at each of x days before day d and and each of y days after day d. In other words, a_d < a_j should hold for all d - x \u2264 j < d and d < j \u2264 d + y. Citizens only watch the weather during summer, so we only consider such j that 1 \u2264 j \u2264 n.\n\nHelp mayor find the earliest not-so-rainy day of summer.\n\nInput\n\nThe first line contains three integers n, x and y (1 \u2264 n \u2264 100 000, 0 \u2264 x, y \u2264 7) \u2014 the number of days in summer, the number of days citizens watch the weather before the celebration and the number of days they do that after.\n\nThe second line contains n distinct integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9), where a_i denotes the rain amount on the i-th day.\n\nOutput\n\nPrint a single integer \u2014 the index of the earliest not-so-rainy day of summer. We can show that the answer always exists.\n\nExamples\n\nInput\n\n\n10 2 2\n10 9 6 7 8 3 2 1 4 5\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n10 2 3\n10 9 6 7 8 3 2 1 4 5\n\n\nOutput\n\n\n8\n\n\nInput\n\n\n5 5 5\n100000 10000 1000 100 10\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first example days 3 and 8 are not-so-rainy. The 3-rd day is earlier.\n\nIn the second example day 3 is not not-so-rainy, because 3 + y = 6 and a_3 > a_6. Thus, day 8 is the answer. Note that 8 + y = 11, but we don't consider day 11, because it is not summer.",
        "task_name": "1199_A. City Day",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nsys.setrecursionlimit(10 ** 6)\n# pow(3,2,5)==4\n\nn,x,y=map(int,raw_input().split())\ninp2=map(int,raw_input().split())\nfor i in range(n):\n    flag=True\n    val=inp2[i]\n    for bef in range(1,x+1):\n        indis=i-bef\n        if indis<0:\n            break\n        if indis>=n:\n            break\n        if val>inp2[indis]:\n            flag=False\n            break\n    for aft in range(1,y+1):\n        indis=i+aft\n        if indis<0:\n            break\n        if indis>=n:\n            break\n        if val>inp2[indis]:\n            flag=False\n            break\n    if flag:\n        print(i+1)\n        break\n",
        "correct": true,
        "task_id": "0525",
        "depth": 2
    },
    {
        "description": "Petya loves computer games. Finally a game that he's been waiting for so long came out!\n\nThe main character of this game has n different skills, each of which is characterized by an integer ai from 0 to 100. The higher the number ai is, the higher is the i-th skill of the character. The total rating of the character is calculated as the sum of the values \u200b\u200bof <image> for all i from 1 to n. The expression \u230a x\u230b denotes the result of rounding the number x down to the nearest integer.\n\nAt the beginning of the game Petya got k improvement units as a bonus that he can use to increase the skills of his character and his total rating. One improvement unit can increase any skill of Petya's character by exactly one. For example, if a4 = 46, after using one imporvement unit to this skill, it becomes equal to 47. A hero's skill cannot rise higher more than 100. Thus, it is permissible that some of the units will remain unused.\n\nYour task is to determine the optimal way of using the improvement units so as to maximize the overall rating of the character. It is not necessary to use all the improvement units.\n\nInput\n\nThe first line of the input contains two positive integers n and k (1 \u2264 n \u2264 105, 0 \u2264 k \u2264 107) \u2014 the number of skills of the character and the number of units of improvements at Petya's disposal.\n\nThe second line of the input contains a sequence of n integers ai (0 \u2264 ai \u2264 100), where ai characterizes the level of the i-th skill of the character.\n\nOutput\n\nThe first line of the output should contain a single non-negative integer \u2014 the maximum total rating of the character that Petya can get using k or less improvement units.\n\nExamples\n\nInput\n\n2 4\n7 9\n\n\nOutput\n\n2\n\n\nInput\n\n3 8\n17 15 19\n\n\nOutput\n\n5\n\n\nInput\n\n2 2\n99 100\n\n\nOutput\n\n20\n\nNote\n\nIn the first test case the optimal strategy is as follows. Petya has to improve the first skill to 10 by spending 3 improvement units, and the second skill to 10, by spending one improvement unit. Thus, Petya spends all his improvement units and the total rating of the character becomes equal to  lfloor frac{100}{10} rfloor + lfloor frac{100}{10} rfloor = 10 + 10 =  20.\n\nIn the second test the optimal strategy for Petya is to improve the first skill to 20 (by spending 3 improvement units) and to improve the third skill to 20 (in this case by spending 1 improvement units). Thus, Petya is left with 4 improvement units and he will be able to increase the second skill to 19 (which does not change the overall rating, so Petya does not necessarily have to do it). Therefore, the highest possible total rating in this example is <image>.\n\nIn the third test case the optimal strategy for Petya is to increase the first skill to 100 by spending 1 improvement unit. Thereafter, both skills of the character will be equal to 100, so Petya will not be able to spend the remaining improvement unit. So the answer is equal to <image>. ",
        "task_name": "581_C. Developing Skills",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n#\n# http://codeforces.com/problemset/problem/581/C\n\ntry:\n    n, k = raw_input().split()\n    n, k = int(n), int(k)\n    nums = raw_input().split()\n    nums = [int(num) for num in nums]\n\n    nums.sort(cmp = lambda a, b: b%10 - a%10)\n\n    stop = False\n    while not stop:\n        stop = True\n        for i in range(0, n):\n            if k == 0: break\n            if nums[i] == 100: continue\n            delta = 10 - nums[i] % 10\n            if k < delta: break\n            stop = False\n            nums[i] = nums[i] + delta\n            k = k - delta\n\n    print(sum([num / 10 for num in nums]))\nexcept IOError:\n    pass        \n",
        "correct": true,
        "task_id": "0547",
        "depth": 2
    },
    {
        "description": "<image>\n\nIt's the end of July \u2013 the time when a festive evening is held at Jelly Castle! Guests from all over the kingdom gather here to discuss new trends in the world of confectionery. Yet some of the things discussed here are not supposed to be disclosed to the general public: the information can cause discord in the kingdom of Sweetland in case it turns out to reach the wrong hands. So it's a necessity to not let any uninvited guests in.\n\nThere are 26 entrances in Jelly Castle, enumerated with uppercase English letters from A to Z. Because of security measures, each guest is known to be assigned an entrance he should enter the castle through. The door of each entrance is opened right before the first guest's arrival and closed right after the arrival of the last guest that should enter the castle through this entrance. No two guests can enter the castle simultaneously.\n\nFor an entrance to be protected from possible intrusion, a candy guard should be assigned to it. There are k such guards in the castle, so if there are more than k opened doors, one of them is going to be left unguarded! Notice that a guard can't leave his post until the door he is assigned to is closed.\n\nSlastyona had a suspicion that there could be uninvited guests at the evening. She knows the order in which the invited guests entered the castle, and wants you to help her check whether there was a moment when more than k doors were opened.\n\nInput\n\nTwo integers are given in the first string: the number of guests n and the number of guards k (1 \u2264 n \u2264 106, 1 \u2264 k \u2264 26).\n\nIn the second string, n uppercase English letters s1s2... sn are given, where si is the entrance used by the i-th guest.\n\nOutput\n\nOutput \u00abYES\u00bb if at least one door was unguarded during some time, and \u00abNO\u00bb otherwise.\n\nYou can output each letter in arbitrary case (upper or lower).\n\nExamples\n\nInput\n\n5 1\nAABBB\n\n\nOutput\n\nNO\n\n\nInput\n\n5 1\nABABB\n\n\nOutput\n\nYES\n\nNote\n\nIn the first sample case, the door A is opened right before the first guest's arrival and closed when the second guest enters the castle. The door B is opened right before the arrival of the third guest, and closed after the fifth one arrives. One guard can handle both doors, as the first one is closed before the second one is opened.\n\nIn the second sample case, the door B is opened before the second guest's arrival, but the only guard can't leave the door A unattended, as there is still one more guest that should enter the castle through this door. ",
        "task_name": "834_B. The Festive Evening",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\ndef FindIfGuarded(k, n, s):\n\talphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\tcount1 = {}\n\tcount2 = {}\n\tfor ch in alphabet:\n\t\tcount1[ch] = 0\n\t\tcount2[ch] = 0\n\tfor ch in s:\n\t\tcount1[ch] += 1\n\tNumOfOpenGates = 0\n\tfor ch in s:\n\t\tif count2[ch] == 0:\n\t\t\tif NumOfOpenGates == k:\n\t\t\t\treturn 'Yes'\n\t\t\tNumOfOpenGates += 1\n\t\tif count2[ch] == count1[ch]-1:\n\t\t\tNumOfOpenGates -= 1\n\t\tcount2[ch] += 1\n\treturn 'No'\n\t\t \n\t\t\t\n\n\n\n\nn, k = map(int, raw_input().split(' '))\ns = raw_input()\n\nprint (FindIfGuarded(k, n, s))\n",
        "correct": true,
        "task_id": "0552",
        "depth": 1
    },
    {
        "description": "Takahashi has a maze, which is a grid of H \\times W squares with H horizontal rows and W vertical columns.\n\nThe square at the i-th row from the top and the j-th column is a \"wall\" square if S_{ij} is `#`, and a \"road\" square if S_{ij} is `.`.\n\nFrom a road square, you can move to a horizontally or vertically adjacent road square.\n\nYou cannot move out of the maze, move to a wall square, or move diagonally.\n\nTakahashi will choose a starting square and a goal square, which can be any road squares, and give the maze to Aoki.\n\nAoki will then travel from the starting square to the goal square, in the minimum number of moves required.\n\nIn this situation, find the maximum possible number of moves Aoki has to make.\n\nConstraints\n\n* 1 \\leq H,W \\leq 20\n* S_{ij} is `.` or `#`.\n* S contains at least two occurrences of `.`.\n* Any road square can be reached from any road square in zero or more moves.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nH W\nS_{11}...S_{1W}\n:\nS_{H1}...S_{HW}\n\n\nOutput\n\nPrint the maximum possible number of moves Aoki has to make.\n\nExamples\n\nInput\n\n3 3\n...\n...\n...\n\n\nOutput\n\n4\n\n\nInput\n\n3 5\n...#.\n.#.#.\n.#...\n\n\nOutput\n\n10",
        "task_name": "p02803 AtCoder Beginner Contest 151 - Maze Master",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "input = raw_input\n\nh, w = map(int, input().split(\" \"))\n\nmeiro = []\ncoords = []\nfor i in range(h):\n    line = list(input())\n    cur_coords = [(j, i) for j in range(w) if line[j] == \".\"]\n    coords += cur_coords\n    meiro.append(line)\n\ngraphs = []\ngraph = {}\nfor cur_coord in coords:\n    x, y = cur_coord\n    tugi_kouhos = [(x+dx, y) for dx in [-1, 1] if 0 <= x+dx < w]\n    tugi_kouhos += [(x, y+dy) for dy in [-1, 1] if 0 <= y+dy < h]\n    childs = []\n    for tugi_kouho in tugi_kouhos:\n        if tugi_kouho in coords:\n            childs.append(tugi_kouho)\n    graph[cur_coord] = childs\n\n\ndepth_dict_org = {}\nfor coord in coords:\n    depth_dict_org[coord] = None\n\ndef calc_depth(coord1, coord2):\n    depth_dict = depth_dict_org.copy()\n\n    cur_coord = coord1\n    end_coord = coord2\n    cur_depth = 0\n    used_coords = [coord1]\n\n    childs = graph[coord1]\n    while len(childs) != 0:\n        cur_depth += 1\n        next_childs = []\n        used_coords += childs\n        for child in childs:\n            res = get_childs(child, coord2, used_coords)\n            #print(\"child\", child, res)\n            #print(used_coords)\n            if res == \"found\":\n                return cur_depth + 1\n            next_childs += res\n\n        childs = list(set(next_childs))\n        #print(childs)\n\n    return 0\n\ndef get_childs(jibun, target, used_coords):\n    \n    childs = []\n    for child in graph[jibun]:\n        if child == target:\n            return \"found\"\n        if child not in used_coords:\n            childs.append(child)\n    return childs\n       \n\nn_coords = len(coords)\nmax_depth = 0\nfor i in range(n_coords):\n    coord1 = coords[i]\n    for j in range(i+1, n_coords):\n        coord2 = coords[j]\n        cur_depth = calc_depth(coord1, coord2)\n        #print(coord1, coord2, cur_depth)\n        max_depth = max(max_depth, cur_depth)\n\nprint(max_depth)",
        "correct": false,
        "task_id": "0559",
        "depth": 2
    },
    {
        "description": "The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.\n\nMathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:\n\nSuppose we want to analyze the segment of n consecutive days. We have measured the temperatures during these n days; the temperature during i-th day equals a_i.\n\nWe denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day x to day y, we calculate it as \\frac{\u2211 _{i = x}^{y} a_i}{y - x + 1} (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than k consecutive days. For example, if analyzing the measures [3, 4, 1, 2] and k = 3, we are interested in segments [3, 4, 1], [4, 1, 2] and [3, 4, 1, 2] (we want to find the maximum value of average temperature over these segments).\n\nYou have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?\n\nInput\n\nThe first line contains two integers n and k (1 \u2264 k \u2264 n \u2264 5000) \u2014 the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 5000) \u2014 the temperature measures during given n days.\n\nOutput\n\nPrint one real number \u2014 the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than k consecutive days.\n\nYour answer will be considered correct if the following condition holds: |res - res_0| < 10^{-6}, where res is your answer, and res_0 is the answer given by the jury's solution.\n\nExample\n\nInput\n\n4 3\n3 4 1 2\n\n\nOutput\n\n2.666666666666667",
        "task_name": "1003_C. Intense Heat",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n,k = map(int,raw_input().split())\narr = map(int,raw_input().split())\nmax_avg = 0\nfor i in range(k,n+1):\n\tcur = sum(arr[:i])\n\tcur_max = cur\n\tfor j in range(i,n):\n\t\tcur = cur - arr[j-i] + arr[j]\n\t\tif cur>cur_max:\n\t\t\tcur_max = cur\n\tif cur_max/float(i)>max_avg:\n\t\tmax_avg = cur_max/float(i)\nprint(max_avg)",
        "correct": true,
        "task_id": "0567",
        "depth": 2
    },
    {
        "description": "There is a country with n citizens. The i-th of them initially has a_{i} money. The government strictly controls the wealth of its citizens. Whenever a citizen makes a purchase or earns some money, they must send a receipt to the social services mentioning the amount of money they currently have.\n\nSometimes the government makes payouts to the poor: all citizens who have strictly less money than x are paid accordingly so that after the payout they have exactly x money. In this case the citizens don't send a receipt.\n\nYou know the initial wealth of every citizen and the log of all events: receipts and payouts. Restore the amount of money each citizen has after all events.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^{5}) \u2014 the numer of citizens.\n\nThe next line contains n integers a_1, a_2, ..., a_n (0 \u2264 a_{i} \u2264 10^{9}) \u2014 the initial balances of citizens.\n\nThe next line contains a single integer q (1 \u2264 q \u2264 2 \u22c5 10^{5}) \u2014 the number of events.\n\nEach of the next q lines contains a single event. The events are given in chronological order.\n\nEach event is described as either 1 p x (1 \u2264 p \u2264 n, 0 \u2264 x \u2264 10^{9}), or 2 x (0 \u2264 x \u2264 10^{9}). In the first case we have a receipt that the balance of the p-th person becomes equal to x. In the second case we have a payoff with parameter x.\n\nOutput\n\nPrint n integers \u2014 the balances of all citizens after all events.\n\nExamples\n\nInput\n\n\n4\n1 2 3 4\n3\n2 3\n1 2 2\n2 1\n\n\nOutput\n\n\n3 2 3 4 \n\n\nInput\n\n\n5\n3 50 2 1 10\n3\n1 2 0\n2 8\n1 3 20\n\n\nOutput\n\n\n8 8 20 8 10 \n\nNote\n\nIn the first example the balances change as follows: 1 2 3 4 \u2192 3 3 3 4 \u2192 3 2 3 4 \u2192 3 2 3 4\n\nIn the second example the balances change as follows: 3 50 2 1 10 \u2192 3 0 2 1 10 \u2192 8 8 8 8 10 \u2192 8 8 20 8 10",
        "task_name": "1199_D. Welfare State",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\nimport bisect\nimport math\nimport itertools\nimport sys\nfrom atexit import register\n \nif sys.version_info[0] < 3:\n    from io import BytesIO as stream\nelse:\n    from io import StringIO as stream\n \n \nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n \n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n \n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n \n    input = raw_input\n    range = xrange\n \n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n \n \ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n \n    Args:\n        sync (bool, optional): The new synchronization setting.\n \n    \"\"\"\n    global input, flush\n \n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n \ndef main():\n    n=int(input()) \n    a=list(map(int, input().split()))\n    k=int(input())\n    m=-1\n    ma=0\n    c=[]\n    for i in range(k):\n      b=list(map(int, input().split()))\n      if b[0]==2:\n        if b[1]>=m:\n          m=b[1]\n          ma=i\n      c.append(b)\n    p=0\n    #print(m,ma,c)\n    for i in range(ma):\n      if c[i][0]==1:\n        a[c[i][1]-1]=c[i][2]      \n    for i in range(k-1,ma-1,-1):\n      if c[i][0]==1 and p==0:\n        continue\n      if c[i][0]==2 :\n        x=c[i][1]\n        p=1 \n      if c[i][0]==1 and p==1:\n        c[i][2]=max(x,c[i][2])\n    for i in range(n):\n      if a[i]<m and m!=-1:\n        a[i]=m\n    \n    for i in range(ma,k):\n      if c[i][0]==1:\n        a[c[i][1]-1]=c[i][2]\n    print(*a)\n\n\n \n        \nif __name__ == '__main__':\n    sync_with_stdio(False)\n    main()",
        "correct": false,
        "task_id": "0572",
        "depth": 1
    },
    {
        "description": "You are given three strings a, b and c of the same length n. The strings consist of lowercase English letters only. The i-th letter of a is a_i, the i-th letter of b is b_i, the i-th letter of c is c_i.\n\nFor every i (1 \u2264 i \u2264 n) you must swap (i.e. exchange) c_i with either a_i or b_i. So in total you'll perform exactly n swap operations, each of them either c_i \u2194 a_i or c_i \u2194 b_i (i iterates over all integers between 1 and n, inclusive).\n\nFor example, if a is \"code\", b is \"true\", and c is \"help\", you can make c equal to \"crue\" taking the 1-st and the 4-th letters from a and the others from b. In this way a becomes \"hodp\" and b becomes \"tele\".\n\nIs it possible that after these swaps the string a becomes exactly the same as the string b?\n\nInput\n\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a string of lowercase English letters a.\n\nThe second line of each test case contains a string of lowercase English letters b.\n\nThe third line of each test case contains a string of lowercase English letters c.\n\nIt is guaranteed that in each test case these three strings are non-empty and have the same length, which is not exceeding 100.\n\nOutput\n\nPrint t lines with answers for all test cases. For each test case:\n\nIf it is possible to make string a equal to string b print \"YES\" (without quotes), otherwise print \"NO\" (without quotes).\n\nYou can print either lowercase or uppercase letters in the answers.\n\nExample\n\nInput\n\n\n4\naaa\nbbb\nccc\nabc\nbca\nbca\naabb\nbbaa\nbaba\nimi\nmii\niim\n\n\nOutput\n\n\nNO\nYES\nYES\nNO\n\nNote\n\nIn the first test case, it is impossible to do the swaps so that string a becomes exactly the same as string b.\n\nIn the second test case, you should swap c_i with a_i for all possible i. After the swaps a becomes \"bca\", b becomes \"bca\" and c becomes \"abc\". Here the strings a and b are equal.\n\nIn the third test case, you should swap c_1 with a_1, c_2 with b_2, c_3 with b_3 and c_4 with a_4. Then string a becomes \"baba\", string b becomes \"baba\" and string c becomes \"abab\". Here the strings a and b are equal.\n\nIn the fourth test case, it is impossible to do the swaps so that string a becomes exactly the same as string b.",
        "task_name": "1301_A. Three Strings",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import math\nimport heapq\nimport sys\nnum = int(raw_input())\nfor i in range(num):\n    a = raw_input()\n    b = raw_input()\n    c = raw_input()\n    f = 0\n    for j in range(len(a)):\n        if b[j]!=c[j] and a[j]!=c[j]:\n            f = 1\n            break\n    if f==0:\n        print(\"YES\")\n    else:\n        print(\"NO\")",
        "correct": true,
        "task_id": "0575",
        "depth": 2
    },
    {
        "description": "Zookeeper is playing a game. In this game, Zookeeper must use bombs to bomb a string that consists of letters 'A' and 'B'. He can use bombs to bomb a substring which is either \"AB\" or \"BB\". When he bombs such a substring, the substring gets deleted from the string and the remaining parts of the string get concatenated.\n\nFor example, Zookeeper can use two such operations: AABABBA \u2192 AABBA \u2192 AAA.\n\nZookeeper wonders what the shortest string he can make is. Can you help him find the length of the shortest string?\n\nInput\n\nEach test contains multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 20000) \u2014 the number of test cases. The description of the test cases follows.\n\nEach of the next t lines contains a single test case each, consisting of a non-empty string s: the string that Zookeeper needs to bomb. It is guaranteed that all symbols of s are either 'A' or 'B'.\n\nIt is guaranteed that the sum of |s| (length of s) among all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print a single integer: the length of the shortest string that Zookeeper can make.\n\nExample\n\nInput\n\n\n3\nAAA\nBABA\nAABBBABBBB\n\n\nOutput\n\n\n3\n2\n0\n\nNote\n\nFor the first test case, you can't make any moves, so the answer is 3.\n\nFor the second test case, one optimal sequence of moves is BABA \u2192 BA. So, the answer is 2.\n\nFor the third test case, one optimal sequence of moves is AABBBABBBB \u2192 AABBBABB \u2192 AABBBB \u2192 ABBB \u2192 AB \u2192 (empty string). So, the answer is 0.",
        "task_name": "1428_C. ABBB",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\nimport math\nimport os, sys\nfrom sys import maxint\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii():  return int(input())\n\n\ndef si():  return input()\n\n\ndef mi():  return map(int, input().strip().split(\" \"))\n\n\ndef msi(): return map(str, input().strip().split(\" \"))\n\n\ndef li():  return list(mi())\n\n\ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n\n# from collections import deque, Counter, OrderedDict,defaultdict\n# from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n# from math import log,sqrt,factorial,cos,tan,sin,radians\n# from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n# from decimal import *\n# import threading\nfrom itertools import permutations\n\n# Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc = 'abcdefghijklmnopqrstuvwxyz'\nabd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12,\n       'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24,\n       'z': 25}\nmod = 1000000007\n# mod=998244353\ninf = float(\"inf\")\nvow = ['a', 'e', 'i', 'o', 'u']\ndx, dy = [-1, 1, 0, 0], [0, 0, 1, -1]\n\n\ndef getKey(item): return item[1]\n\n\ndef sort2(l): return sorted(l, key=getKey, reverse=True)\n\n\ndef d2(n, m, num): return [[num for x in range(m)] for y in range(n)]\n\n\ndef isPowerOfTwo(x): return (x and (not (x & (x - 1))))\n\n\ndef decimalToBinary(n): return bin(n).replace(\"0b\", \"\")\n\n\ndef ntl(n): return [int(i) for i in str(n)]\n\n\ndef ceil(x, y):\n    if x % y == 0:\n        return x // y\n    else:\n        return x // y + 1\n\n\ndef powerMod(x, y, p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n\ndef isPrime(n):  # Check Prime Number or not\n    if (n <= 1): return False\n    if (n <= 3): return True\n    if (n % 2 == 0 or n % 3 == 0): return False\n    i = 5\n    while (i * i <= n):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n        i = i + 6\n    return True\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\n\ndef main():\n    for _ in range(int(input())):\n        s = raw_input()\n\n        def solve(s):\n            if s.find(\"AB\") == -1 and s.find(\"BB\") == -1:\n                return len(s)\n\n            while s.find(\"AB\") != -1:\n                s = s.replace(\"AB\", \"\")\n\n            while s.find(\"BB\") != -1:\n                s = s.replace(\"BB\", \"\")\n\n            return len(s)\n\n        print(solve(s))\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    # read()\n    main()\n    # dmain()\n\n# Comment Read()\n",
        "correct": false,
        "task_id": "0577",
        "depth": 2
    },
    {
        "description": "Ashish has two strings a and b, each of length n, and an integer k. The strings only contain lowercase English letters.\n\nHe wants to convert string a into string b by performing some (possibly zero) operations on a.\n\nIn one move, he can either \n\n  * choose an index i (1 \u2264 i\u2264 n-1) and swap a_i and a_{i+1}, or \n  * choose an index i (1 \u2264 i \u2264 n-k+1) and if a_i, a_{i+1}, \u2026, a_{i+k-1} are all equal to some character c (c \u2260 'z'), replace each one with the next character (c+1), that is, 'a' is replaced by 'b', 'b' is replaced by 'c' and so on. \n\n\n\nNote that he can perform any number of operations, and the operations can only be performed on string a. \n\nHelp Ashish determine if it is possible to convert string a into b after performing some (possibly zero) operations on it.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^5) \u2014 the number of test cases. The description of each test case is as follows.\n\nThe first line of each test case contains two integers n (2 \u2264 n \u2264 10^6) and k (1 \u2264 k \u2264 n).\n\nThe second line of each test case contains the string a of length n consisting of lowercase English letters.\n\nThe third line of each test case contains the string b of length n consisting of lowercase English letters.\n\nIt is guaranteed that the sum of values n among all test cases does not exceed 10^6.\n\nOutput\n\nFor each test case, print \"Yes\" if Ashish can convert a into b after some moves, else print \"No\".\n\nYou may print the letters of the answer in any case (upper or lower).\n\nExample\n\nInput\n\n\n4\n3 3\nabc\nbcd\n4 2\nabba\nazza\n2 1\nzz\naa\n6 2\naaabba\nddddcc\n\n\nOutput\n\n\nNo\nYes\nNo\nYes\n\nNote\n\nIn the first test case it can be shown that it is impossible to convert a into b.\n\nIn the second test case,\n\n\"abba\" \\xrightarrow{inc} \"acca\" \\xrightarrow{inc} \u2026 \\xrightarrow{inc} \"azza\".\n\nHere \"swap\" denotes an operation of the first type, and \"inc\" denotes an operation of the second type.\n\nIn the fourth test case,\n\n\"aaabba\" \\xrightarrow{swap} \"aaabab\" \\xrightarrow{swap} \"aaaabb\" \\xrightarrow{inc} \u2026 \\xrightarrow{inc} \"ddaabb\" \\xrightarrow{inc} \u2026 \\xrightarrow{inc} \"ddddbb\" \\xrightarrow{inc} \u2026 \\xrightarrow{inc} \"ddddcc\".",
        "task_name": "1451_C. String Equality",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\nfrom collections import defaultdict, Counter, deque\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement\nfrom __builtin__ import xrange as range\nfrom math import ceil, factorial, log, sqrt\nfrom _continuation import continulet\nfrom cStringIO import StringIO\nfrom io import IOBase\nimport __pypy__\nfrom bisect import bisect, insort, bisect_left, bisect_right\nfrom fractions import Fraction\nimport heapq\nfrom functools import reduce\nimport string\nimport sys\nimport os\nimport re\ninf = float('inf')\nmod = int(1e9) + 7\nmod_ = 998244353\n\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n    t = input()\n    freq = Counter(s)\n    groups = [m.group(0) for m in re.finditer(r\"([a-z])\\1*\", t)]\n\n    for group in groups:\n        div = len(group) // k\n        rem = len(group) % k\n        if freq[group[0]] < rem:\n            print('No')\n            return\n        freq[group[0]] -= rem\n        if div == 0:\n            continue\n        for i in range(string.ascii_lowercase.index(group[0]) - 1, -1, -1):\n            if freq[string.ascii_lowercase[i]] >= div:\n                freq[string.ascii_lowercase[i]] -= div\n                break\n        else:\n            print('No')\n            return\n    print('Yes')\n\n\ndef main():\n    for _ in range(int(input())):\n        solve()\n\nBUFSIZE = 8192\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(\n                b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    def bootstrap(cont):\n        call, arg = cont.switch()\n        while True:\n            call, arg = cont.switch(to=continulet(\n                lambda _, f, args: f(*args), call, arg))\n    cont = continulet(bootstrap)\n    cont.switch()\n    main()",
        "correct": false,
        "task_id": "0578",
        "depth": 2
    },
    {
        "description": "Consider a system of n water taps all pouring water into the same container. The i-th water tap can be set to deliver any amount of water from 0 to ai ml per second (this amount may be a real number). The water delivered by i-th tap has temperature ti.\n\nIf for every <image> you set i-th tap to deliver exactly xi ml of water per second, then the resulting temperature of water will be <image> (if <image>, then to avoid division by zero we state that the resulting water temperature is 0).\n\nYou have to set all the water taps in such a way that the resulting temperature is exactly T. What is the maximum amount of water you may get per second if its temperature has to be T?\n\nInput\n\nThe first line contains two integers n and T (1 \u2264 n \u2264 200000, 1 \u2264 T \u2264 106) \u2014 the number of water taps and the desired temperature of water, respectively.\n\nThe second line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 106) where ai is the maximum amount of water i-th tap can deliver per second.\n\nThe third line contains n integers t1, t2, ..., tn (1 \u2264 ti \u2264 106) \u2014 the temperature of water each tap delivers.\n\nOutput\n\nPrint the maximum possible amount of water with temperature exactly T you can get per second (if it is impossible to obtain water with such temperature, then the answer is considered to be 0).\n\nYour answer is considered correct if its absolute or relative error doesn't exceed 10 - 6.\n\nExamples\n\nInput\n\n2 100\n3 10\n50 150\n\n\nOutput\n\n6.000000000000000\n\n\nInput\n\n3 9\n5 5 30\n6 6 10\n\n\nOutput\n\n40.000000000000000\n\n\nInput\n\n2 12\n1 3\n10 15\n\n\nOutput\n\n1.666666666666667",
        "task_name": "954_E. Water Taps",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n,t=map(int,raw_input().strip().split(' '))\nx= list(map(int,raw_input().strip().split(' ')))\n\ntemp= list(map(int,raw_input().strip().split(' ')))\nfor i in xrange(n):\n  temp[i]-=t\npos = []\nneg = []\nans = 0\nnegsum = 0\npossum = 0\nfor i in xrange(n):\n  if(temp[i]<0):\n    negsum+=temp[i]*x[i]\n    neg.append([temp[i],x[i]])\n  elif(temp[i]>0):\n    possum+=temp[i]*x[i]\n    pos.append([temp[i],x[i]])\n  else:\n    ans+=x[i]\nif(abs(negsum)>possum):\n  for i in pos:\n    ans+=i[1]\n  neg.sort()\n  for i in neg:\n    t = i[0]*i[1]\n    if(t+possum<0):\n      ans+= possum*1.0/i[0]\n      break\n    else:\n      ans+=i[1]\n      possum+=t\n  print(ans)\nelif(possum>abs(negsum)):\n  for i in neg:\n    ans+=i[1]\n  pos.sort()\n  for i in pos:\n    t = i[0]*i[1]\n    if(t+negsum>0):\n      ans+= abs(negsum*1.0/i[0])\n      break\n    else:\n      ans+=i[1]\n      negsum+=t\n  print(ans)\nelse:\n  print(sum(x))\n\n\n",
        "correct": false,
        "task_id": "0599",
        "depth": 1
    },
    {
        "description": "A smelt fishing tournament was held at Lake Hibara. It seems that catch and release is recommended this time.\n\nCreate a program that reads the participant number and the number of fish caught or released in order as one event, and outputs the participant number and the number of animals that have acquired the most smelt immediately after each event. please. If there are multiple participants with the highest number of participants (or if all participants are 0), output the one with the lowest participant number.\n\n\n\ninput\n\nThe input is given in the following format.\n\n\nn q\na1 v1\na2 v2\n::\naq vq\n\n\nn (1 \u2264 n \u2264 1000000) represents the number of participants and q (1 \u2264 q \u2264 100000) represents the number of events. ai (1 \u2264 ai \u2264 n) vi (-100 \u2264 vi \u2264 100) indicates that participant ai acquired or released vi at the i-th event. For vi, a positive value indicates acquisition, a negative value indicates release, and 0 is never given.\n\noutput\n\nFor each event, the participant number and the number of participants who have acquired the most smelt at hand are output on one line separated by one blank.\n\nExample\n\nInput\n\n3 5\n1 4\n2 5\n1 3\n3 6\n2 7\n\n\nOutput\n\n1 4\n2 5\n1 7\n1 7\n2 12",
        "task_name": "p00099 Surf Smelt Fishing Contest II",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\nfrom sys import stdin, exit\n\n\ndef main(readline=stdin.readline):\n    n, q = (int(s) for s in readline().split())\n\n    base = [0] * n\n    midway = [0] * (n//100 + 1)\n    last = [0] * (n//10000 + 1)\n\n    for _ in range(q):\n        a, v = (int(s) for s in readline().split())\n\n        a -= 1\n        base[a] += v\n\n        b = a - a % 100\n\n        index = b\n        value = base[b]\n        end = b + 100 if b + 100 < n else n\n        for i in range(b, end):\n            if value < base[i]:\n                value = base[i]\n                index = i\n        midway[b//100] = index\n\n        c = a - a % 10000\n        cc = c // 100\n\n        index = c\n        value = base[c]\n        for i in midway[cc:cc+100]:\n            if value < base[i]:\n                value = base[i]\n                index = i\n        last[c//10000] = index\n\n        index = last[0]\n        value = base[index]\n        for i in last:\n            if value < base[i]:\n                value = base[i]\n                index = i\n\n        print(index+1, value)\n    exit()\n\n\nif __name__ == '__main__':\n    main()",
        "correct": true,
        "task_id": "0607",
        "depth": 2
    },
    {
        "description": "Vitya has just started learning Berlanese language. It is known that Berlanese uses the Latin alphabet. Vowel letters are \"a\", \"o\", \"u\", \"i\", and \"e\". Other letters are consonant.\n\nIn Berlanese, there has to be a vowel after every consonant, but there can be any letter after any vowel. The only exception is a consonant \"n\"; after this letter, there can be any letter (not only a vowel) or there can be no letter at all. For example, the words \"harakiri\", \"yupie\", \"man\", and \"nbo\" are Berlanese while the words \"horse\", \"king\", \"my\", and \"nz\" are not.\n\nHelp Vitya find out if a word s is Berlanese.\n\nInput\n\nThe first line of the input contains the string s consisting of |s| (1\u2264 |s|\u2264 100) lowercase Latin letters.\n\nOutput\n\nPrint \"YES\" (without quotes) if there is a vowel after every consonant except \"n\", otherwise print \"NO\".\n\nYou can print each letter in any case (upper or lower).\n\nExamples\n\nInput\n\nsumimasen\n\n\nOutput\n\nYES\n\n\nInput\n\nninja\n\n\nOutput\n\nYES\n\n\nInput\n\ncodeforces\n\n\nOutput\n\nNO\n\nNote\n\nIn the first and second samples, a vowel goes after each consonant except \"n\", so the word is Berlanese.\n\nIn the third sample, the consonant \"c\" goes after the consonant \"r\", and the consonant \"s\" stands on the end, so the word is not Berlanese.",
        "task_name": "1008_A. Romaji",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "s=raw_input().strip()\nletters = list(map(chr, range(ord('a'),ord('z')+1)))\nvowels = list('aeiou')\nconst = list(set(letters) - set(vowels) - set(['n']))\np = True\nfor i in xrange(len(s)):\n    if s[i] in const and (i+1 == len(s) or s[i+1] not in vowels):\n        p=False\n        break\nprint [\"NO\",\"YES\"][p]\n",
        "correct": true,
        "task_id": "0611",
        "depth": 1
    },
    {
        "description": "A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and a_i < a_j. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).\n\nYou are given a permutation p of size n. However, the numbers on some positions are replaced by -1. Let the valid permutation be such a replacement of -1 in this sequence back to numbers from 1 to n in such a way that the resulting sequence is a permutation of size n.\n\nThe given sequence was turned into a valid permutation randomly with the equal probability of getting each valid permutation.\n\nCalculate the expected total number of inversions in the resulting valid permutation.\n\nIt can be shown that it is in the form of P/Q where P and Q are non-negative integers and Q \u2260 0. Report the value of P \u22c5 Q^{-1} \\pmod {998244353}.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the sequence.\n\nThe second line contains n integers p_1, p_2, ..., p_n (-1 \u2264 p_i \u2264 n, p_i \u2260 0) \u2014 the initial sequence.\n\nIt is guaranteed that all elements not equal to -1 are pairwise distinct.\n\nOutput\n\nPrint a single integer \u2014 the expected total number of inversions in the resulting valid permutation.\n\nIt can be shown that it is in the form of P/Q where P and Q are non-negative integers and Q \u2260 0. Report the value of P \u22c5 Q^{-1} \\pmod {998244353}.\n\nExamples\n\nInput\n\n\n3\n3 -1 -1\n\n\nOutput\n\n\n499122179\n\n\nInput\n\n\n2\n1 2\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n2\n-1 -1\n\n\nOutput\n\n\n499122177\n\nNote\n\nIn the first example two resulting valid permutations are possible:\n\n  * [3, 1, 2] \u2014 2 inversions; \n  * [3, 2, 1] \u2014 3 inversions. \n\n\n\nThe expected value is (2 \u22c5 1 + 3 \u22c5 1)/(2) = 2.5.\n\nIn the second example no -1 are present, thus the only valid permutation is possible \u2014 the given one. It has 0 inversions.\n\nIn the third example there are two resulting valid permutations \u2014 one with 0 inversions and one with 1 inversion.",
        "task_name": "1096_F. Inversion Expectation",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def fenwicktree(arr):\n    fwtree = [0]*(len(arr)+1)\n    for i in range(len(arr)):\n        updatebit(fwtree,i,arr[i])\n    return fwtree\n\ndef updatebit(fwtree,i,val):\n    i += 1\n    while i < len(fwtree):\n        fwtree[i] += val\n        i += i&(-i)\n\n# get sum of [0, i]\ndef getsum(fwtree,i):\n    s = 0\n    i += 1\n    while i > 0:\n        s += fwtree[i]\n        i -= i&(-i)\n    return s\n\nmod = 998244353\nfac = [1]\nfor i in range(1,200010):\n    fac.append((i*fac[-1])%mod)\nfacInv = []\nfor i in fac:\n    facInv.append( pow(i, mod-2, mod) )\n\nn = input()\np = list(map(lambda x: int(x)-1, raw_input().split()))\n\nnumMissing = len([x for x in p if x == -2])\n\nA = [0 for i in range(n)]\nA = fenwicktree(A)\ncnt = 0\n\nfor i in p:\n    if i == -2: continue\n    cnt += getsum(A, n-1) - getsum(A, i)\n    updatebit(A, i, 1)\ncnt *= fac[numMissing]\n\ncntNeg = 0\nfor i in p:\n    if i == -2:\n        cntNeg += 1\n        continue\n    missingGreater = (n-i-1) - (getsum(A, n-1) - getsum(A, i))\n    missingSmaller = i - getsum(A, i-1)\n\n    missingLeftPos = cntNeg\n    missingRightPos = numMissing - cntNeg\n\n    cnt += fac[numMissing - 1] * missingGreater * missingLeftPos + fac[numMissing - 1] * missingSmaller * missingRightPos\n\n\ncnt += fac[numMissing] * numMissing * (numMissing - 1) / 4\ncnt %= mod\n\nprint((cnt * facInv[numMissing])%mod)\n",
        "correct": true,
        "task_id": "0612",
        "depth": 1
    },
    {
        "description": "The Cybermen and the Daleks have long been the Doctor's main enemies. Everyone knows that both these species enjoy destroying everything they encounter. However, a little-known fact about them is that they both also love taking Turing tests!\n\nHeidi designed a series of increasingly difficult tasks for them to spend their time on, which would allow the Doctor enough time to save innocent lives!\n\nThe funny part is that these tasks would be very easy for a human to solve.\n\nThe first task is as follows. There are some points on the plane. All but one of them are on the boundary of an axis-aligned square (its sides are parallel to the axes). Identify that point.\n\nInput\n\nThe first line contains an integer n (2 \u2264 n \u2264 10).\n\nEach of the following 4n + 1 lines contains two integers x_i, y_i (0 \u2264 x_i, y_i \u2264 50), describing the coordinates of the next point.\n\nIt is guaranteed that there are at least n points on each side of the square and all 4n + 1 points are distinct.\n\nOutput\n\nPrint two integers \u2014 the coordinates of the point that is not on the boundary of the square.\n\nExamples\n\nInput\n\n\n2\n0 0\n0 1\n0 2\n1 0\n1 1\n1 2\n2 0\n2 1\n2 2\n\n\nOutput\n\n\n1 1\n\n\nInput\n\n\n2\n0 0\n0 1\n0 2\n0 3\n1 0\n1 2\n2 0\n2 1\n2 2\n\n\nOutput\n\n\n0 3\n\nNote\n\nIn both examples, the square has four sides x=0, x=2, y=0, y=2.",
        "task_name": "1184_C1. Heidi and the Turing Test (Easy)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\nfrom collections import *\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrints_2d = lambda n: [rints() for _ in range(n)]\nget_col = lambda arr, i: [row[i] for row in arr]\n\nn = int(input()) * 4 + 1\na, memx, memy = rints_2d(n), [float('inf'), -1], [float('inf'), -1]\nxs, ys = Counter(get_col(a, 0)), Counter(get_col(a, 1))\n\nfor x, y in a:\n    if xs[x] >= (n - 1) >> 2:\n        memx = [min(memx[0], x), max(memx[1], x)]\n    if ys[y] >= (n - 1) >> 2:\n        memy = [min(memy[0], y), max(memy[1], y)]\n\nfor x, y in a:\n    if not ((memx[0] < x < memx[1] and y in memy) or (x in memx and memy[0] <= y <= memy[1])):\n        print('%d %d' % (x, y))\n        exit()\n",
        "correct": true,
        "task_id": "0615",
        "depth": 1
    },
    {
        "description": "An integer sequence is called beautiful if the difference between any two consecutive numbers is equal to 1. More formally, a sequence s_1, s_2, \u2026, s_{n} is beautiful if |s_i - s_{i+1}| = 1 for all 1 \u2264 i \u2264 n - 1.\n\nTrans has a numbers 0, b numbers 1, c numbers 2 and d numbers 3. He wants to construct a beautiful sequence using all of these a + b + c + d numbers.\n\nHowever, it turns out to be a non-trivial task, and Trans was not able to do it. Could you please help Trans?\n\nInput\n\nThe only input line contains four non-negative integers a, b, c and d (0 < a+b+c+d \u2264 10^5).\n\nOutput\n\nIf it is impossible to construct a beautiful sequence satisfying the above constraints, print \"NO\" (without quotes) in one line.\n\nOtherwise, print \"YES\" (without quotes) in the first line. Then in the second line print a + b + c + d integers, separated by spaces \u2014 a beautiful sequence. There should be a numbers equal to 0, b numbers equal to 1, c numbers equal to 2 and d numbers equal to 3.\n\nIf there are multiple answers, you can print any of them.\n\nExamples\n\nInput\n\n\n2 2 2 1\n\n\nOutput\n\n\nYES\n0 1 0 1 2 3 2\n\n\nInput\n\n\n1 2 3 4\n\n\nOutput\n\n\nNO\n\n\nInput\n\n\n2 2 2 3\n\n\nOutput\n\n\nNO\n\nNote\n\nIn the first test, it is easy to see, that the sequence is beautiful because the difference between any two consecutive numbers is equal to 1. Also, there are exactly two numbers, equal to 0, 1, 2 and exactly one number, equal to 3.\n\nIt can be proved, that it is impossible to construct beautiful sequences in the second and third tests.",
        "task_name": "1264_B. Beautiful Sequence",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n\ndef main():\n    a, b, c, d = input_as_list()\n    s1 = b-a\n    s2 = c-d\n    if s1 == s2:\n        out = [1, 0]*a + [1, 2]*(b-a) + [3, 2]*d\n    elif s1+1 == s2:\n        if a > 0:\n            a -= 1\n            out = [0] + [1, 0]*a + [1, 2]*(b-a) + [3, 2]*d\n        else:\n            c -= 1\n            out = [2] + [1, 0]*a + [1, 2]*(b-a) + [3, 2]*d\n    elif s1 == s2+1:\n        if d > 0:\n            d -= 1\n            out = [1, 0]*a + [1, 2]*(b-a) + [3, 2]*d + [3]\n        else:\n            b -= 1\n            out = [1, 0]*a + [1, 2]*(b-a) + [3, 2]*d + [1]\n    else:\n        print(\"NO\")\n        return\n    print(\"YES\")\n    print(*out)\n\nINF = float('inf')\nMOD = 10 ** 9 + 7\n__interactive = False\n\nimport os, sys\nfrom atexit import register\nfrom io import BytesIO\nimport itertools\nimport __pypy__\n\nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\nmulmod = __pypy__.intop.int_mulmod\n\nif \"LOCAL_\" in os.environ:\n    debug_print = print\nelse:\n    if not __interactive:\n        sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n        sys.stdout = BytesIO()\n        register(lambda: os.write(1, sys.stdout.getvalue()))\n\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n    else:\n        flush = sys.stdout.flush\n    debug_print = lambda *x, **y: None\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef input_as_list():\n    return list(map(int, input().split()))\n\ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\ndef range_with_count(start, step, count):\n    return range(start, start + step * count, step)\n\ndef indices(l, start=0, end=0):\n    return range(start, len(l)+end)\n\ndef ceil_power_of_2(n):\n    return 2 ** ((n - 1).bit_length())\n\ndef ceil_div(x, r):\n    return (x + r - 1) // r\n\nmain()",
        "correct": false,
        "task_id": "0618",
        "depth": 1
    },
    {
        "description": "Today, as a friendship gift, Bakry gave Badawy n integers a_1, a_2, ..., a_n and challenged him to choose an integer X such that the value \\underset{1 \u2264 i \u2264 n}{max} (a_i \u2295 X) is minimum possible, where \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nAs always, Badawy is too lazy, so you decided to help him and find the minimum possible value of \\underset{1 \u2264 i \u2264 n}{max} (a_i \u2295 X).\n\nInput\n\nThe first line contains integer n (1\u2264 n \u2264 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 2^{30}-1).\n\nOutput\n\nPrint one integer \u2014 the minimum possible value of \\underset{1 \u2264 i \u2264 n}{max} (a_i \u2295 X).\n\nExamples\n\nInput\n\n\n3\n1 2 3\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n2\n1 5\n\n\nOutput\n\n\n4\n\nNote\n\nIn the first sample, we can choose X = 3.\n\nIn the second sample, we can choose X = 5.",
        "task_name": "1285_D. Dr. Evil Underscores",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n\nn=int(raw_input())\na=list(map(int,raw_input().split()))\n\ns=[]\n\nfor i in a:\n\tts=bin(i)[2:]\n\tts=ts[::-1]\n\twhile(len(ts)<32):\n\t\tts+=\"0\"\n\n\ts.append(ts)\n\n\nans=\"\"\nbrk=-1\n\nleftp=0\nansl=-1\nansr=-1\n\nfor j in range(31,-1,-1):\n\tc1=0\n\tc0=0\n\n\tfor i in range(n):\n\t\tif(s[i][j]=='0'):\n\t\t\tc0+=1\n\t\telse:\n\t\t\tc1+=1\n\n\n\tif(c1==n):\n\t\tans+=\"1\"\n\telif(c0==n):\n\t\tans+=\"0\"\n\telse:\n\n\t\tmx0=0\n\t\tmx1=0\n\n\t\tans+=\"1\"\n\t\t\n\t\tleftp=int(ans,2)\n\t\tleftp<<=j\n\n\t\tfor i in range(n):\n\t\t\tif(s[i][j]=='0'):\n\t\t\t\tmx0=max(mx0,int((s[i][:j])[::-1],2))\n\t\t\telse:\n\t\t\t\tmx1=max(mx1,int((s[i][:j])[::-1],2))\n\n\n\t\tansl=leftp+mx0\n\t\tansr=leftp+mx1\n\t\tbreak\n\n\nif(ansl==-1):\n\tleftp=int(ans,2)\n\n\ta1=0\n\n\tfor i in a:\n\t\ta1=max(a1,leftp^i)\n\n\tprint(a1)\nelse:\n\n\tm1=0\n\tm0=0\n\n\tfor i in a:\n\t\tm1=max(m1,ansr^i)\n\t\tm0=max(m0,ansl^i)\n\n\tprint(min(m1,m0))\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n",
        "correct": false,
        "task_id": "0619",
        "depth": 2
    },
    {
        "description": "You are given a string s, consisting of lowercase Latin letters. While there is at least one character in the string s that is repeated at least twice, you perform the following operation: \n\n  * you choose the index i (1 \u2264 i \u2264 |s|) such that the character at position i occurs at least two times in the string s, and delete the character at position i, that is, replace s with s_1 s_2 \u2026 s_{i-1} s_{i+1} s_{i+2} \u2026 s_n. \n\n\n\nFor example, if s=\"codeforces\", then you can apply the following sequence of operations: \n\n  * i=6 \u21d2 s=\"codefrces\"; \n  * i=1 \u21d2 s=\"odefrces\"; \n  * i=7 \u21d2 s=\"odefrcs\"; \n\n\n\nGiven a given string s, find the lexicographically maximum string that can be obtained after applying a certain sequence of operations after which all characters in the string become unique.\n\nA string a of length n is lexicographically less than a string b of length m, if: \n\n  * there is an index i (1 \u2264 i \u2264 min(n, m)) such that the first i-1 characters of the strings a and b are the same, and the i-th character of the string a is less than i-th character of string b; \n  * or the first min(n, m) characters in the strings a and b are the same and n < m. \n\n\n\nFor example, the string a=\"aezakmi\" is lexicographically less than the string b=\"aezus\".\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4). Then t test cases follow.\n\nEach test case is characterized by a string s, consisting of lowercase Latin letters (1 \u2264 |s| \u2264 2 \u22c5 10^5).\n\nIt is guaranteed that the sum of the lengths of the strings in all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output the lexicographically maximum string that can be obtained after applying a certain sequence of operations after which all characters in the string become unique.\n\nExample\n\nInput\n\n\n6\ncodeforces\naezakmi\nabacaba\nconvexhull\nswflldjgpaxs\nmyneeocktxpqjpz\n\n\nOutput\n\n\nodfrces\nezakmi\ncba\nconvexhul\nwfldjgpaxs\nmyneocktxqjpz",
        "task_name": "1506_G. Maximize the Remaining String",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Enter your code here. Read input from STDIN. Print output to STDOUT# ===============================================================================================\n# importing some useful libraries.\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom itertools import *\nimport bisect\nfrom heapq import *\nfrom math import ceil, floor\nfrom copy import *\nfrom collections import deque, defaultdict\nfrom collections import Counter as counter  # Counter(list)  return a dict with {key: count}\nfrom itertools import combinations  # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\nfrom itertools import permutations as permutate\nfrom bisect import bisect_left as bl\nfrom operator import *\n# If the element is already present in the list,\n\n# the left most position where element has to be inserted is returned.\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n# If the element is already present in the list,\n# the right most position where element has to be inserted is returned\n\n# ==============================================================================================\n# fast I/O region\n\nBUFSIZE = 8192\nfrom sys import stderr\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"A\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for A in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(A))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\n\n\ndef iterative(f, stack=[]):\n    def wrapped_func(*args, **kwargs):\n        if stack: return f(*args, **kwargs)\n        to = f(*args, **kwargs)\n        while True:\n            if type(to) is GeneratorType:\n                stack.append(to)\n                to = next(to)\n                continue\n            stack.pop()\n            if not stack: break\n            to = stack[-1].send(to)\n        return to\n\n    return wrapped_func\n\n\n#### END ITERATE RECURSION ####\n###########################\n# Sorted list\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[start:start + _load] for start in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for start in range(len(_fen_tree)):\n            if start | start + 1 < len(_fen_tree):\n                _fen_tree[start | start + 1] += _fen_tree[start]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        A = 0\n        while end:\n            A += _fen_tree[end - 1]\n            end &= end - 1\n        return A\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\n\n# ===============================================================================================\n# some shortcuts\n\nmod = 1000000007\n\n\ndef testcase(t):\n    for p in range(t):\n        solve()\n\n\ndef pow(A, B, p):\n    res = 1  # Initialize result\n    A = A % p  # Update A if it is more , than or equal to p\n    if (A == 0):\n        return 0\n    while (B > 0):\n        if ((B & 1) == 1):  # If B is odd, multiply, A with result\n            res = (res * A) % p\n\n        B = B >> 1  # B = B/2\n        A = (A * A) % p\n    return res\n\n\nfrom functools import reduce\n\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([start, n // start] for start in range(1, int(n ** 0.5) + 1) if n % start == 0)))\n\n\ndef gcd(a, b):\n    if a == b: return a\n    while b > 0: a, b = b, a % b\n    return a\n\n\n# discrete binary search\n# minimise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for start in range(200):\n#         if isvalid(l):\n#             return l\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m - 1):\n#             return m\n#         if isvalid(m):\n#             r = m + 1\n#         else:\n#             l = m\n#     return m\n\n# maximise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for start in range(200):\n#         # print(l,r)\n#         if isvalid(r):\n#             return r\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m + 1):\n#             return m\n#         if isvalid(m):\n#             l = m\n#         else:\n#             r = m - 1\n#     return m\n\n\n##############Find sum of product of subsets of size k in a array\n# ar=[0,1,2,3]\n# k=3\n# n=len(ar)-1\n# dp=[0]*(n+1)\n# dp[0]=1\n# for pos in range(1,n+1):\n#     dp[pos]=0\n#     l=max(1,k+pos-n-1)\n#     for j in range(min(pos,k),l-1,-1):\n#         dp[j]=dp[j]+ar[pos]*dp[j-1]\n# print(dp[k])\n\ndef prefix_sum(ar):  # [1,2,3,4]->[1,3,6,10]\n    return list(accumulate(ar))\n\n\ndef suffix_sum(ar):  # [1,2,3,4]->[10,9,7,4]\n    return list(accumulate(ar[::-1]))[::-1]\n\n\ndef N():\n    return int(inp())\n\n\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\n\ndef YES():\n    print(\"YES\")\n\n\ndef NO():\n    print(\"NO\")\n\n\ndef Yes():\n    print(\"Yes\")\n\n\ndef No():\n    print(\"No\")\n\n\n# =========================================================================================\nfrom collections import defaultdict\n\n\ndef numberOfSetBits(start):\n    start = start - ((start >> 1) & 0x55555555)\n    start = (start & 0x33333333) + ((start >> 2) & 0x33333333)\n    return (((start + (start >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        # self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        # self.lista[a] += self.lista[b]\n        # self.lista[b] = []\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef lcm(a, b):\n    return abs((a // gcd(a, b)) * b)\n\n\n# #\n# to find factorial and ncr\n# tot = 100005\n# mod = 10**9 + 7\n# fac = [1, 1]\n# finv = [1, 1]\n# inv = [0, 1]\n#\n# for start in range(2, tot + 1):\n#     fac.append((fac[-1] * start) % mod)\n#     inv.append(mod - (inv[mod % start] * (mod // start) % mod))\n#     finv.append(finv[-1] * inv[-1] % mod)\n\n\ndef comb(n, r):\n    if n < r:\n        return 0\n    else:\n        return fac[n] * (finv[r] * finv[n - r] % mod) % mod\n\n\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\")  # for fast input\n\n\ndef out(var): sys.stdout.write(str(var))  # for fast output, always take string\n\n\ndef lis(): return list(map(int, inp().split()))\n\n\ndef stringlis(): return list(map(str, inp().split()))\n\n\ndef sep(): return map(int, inp().split())\n\n\ndef strsep(): return map(str, inp().split())\n\n\ndef fsep(): return map(float, inp().split())\n\n\ndef nextline(): out(\"\\n\")  # as stdout.write always print sring.\n\n\ndef arr1d(n, v):\n    return [v] * n\n\n\ndef arr2d(n, m, v):\n    return [[v] * m for _ in range(n)]\n\n\ndef arr3d(n, m, p, v):\n    return [[[v] * p for _ in range(m)] for start in range(n)]\n\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\n\n# co-ordinate compression\n# ma={s:idx for idx,s in enumerate(sorted(set(l+r)))}\n\n# mxn=100005\n# lrg=[0]*mxn\n# for start in range(2,mxn-3):\n#     if (lrg[start]==0):\n#         for j in range(start,mxn-3,start):\n#             lrg[j]=start\n\n\ndef solve():\n    s=inp()\n    ans=[]\n    n=len(s)\n    c=counter(s)\n    torem=set()\n    for i in range(n-1):\n        # print(s[i],ans)\n        if(s[i] in torem):\n            c[s[i]]-=1\n            continue\n        if(c[s[i]]==1):\n            if (ans):\n                if (s[i] > ans[-1]):\n                    if (c[ans[-1]] > 0):\n                        if(ans[-1] in torem):\n                            torem.remove(ans[-1])\n                        ans.pop()\n            ans.append(s[i])\n            c[s[i]] -= 1\n            continue\n        if(s[i] < s[i+1]):\n            c[s[i]]-=1\n            continue\n        else:\n            if(ans):\n                if(s[i]>ans[-1]):\n                    if(c[ans[-1]] >0):\n                        ans.pop()\n            ans.append(s[i])\n            torem.add(s[i])\n            c[s[i]] -= 1\n\n            continue\n    if(s[-1] not in torem):\n        ans.append(s[-1])\n    print(\"\".join(ans))\n\n\n\n\n\n\n\n\n# solve()\ntestcase(N())",
        "correct": false,
        "task_id": "0625",
        "depth": 1
    },
    {
        "description": "There are N empty boxes arranged in a row from left to right. The integer i is written on the i-th box from the left (1 \\leq i \\leq N).\n\nFor each of these boxes, Snuke can choose either to put a ball in it or to put nothing in it.\n\nWe say a set of choices to put a ball or not in the boxes is good when the following condition is satisfied:\n\n* For every integer i between 1 and N (inclusive), the total number of balls contained in the boxes with multiples of i written on them is congruent to a_i modulo 2.\n\n\n\nDoes there exist a good set of choices? If the answer is yes, find one good set of choices.\n\nConstraints\n\n* All values in input are integers.\n* 1 \\leq N \\leq 2 \\times 10^5\n* a_i is 0 or 1.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\na_1 a_2 ... a_N\n\n\nOutput\n\nIf a good set of choices does not exist, print `-1`.\n\nIf a good set of choices exists, print one such set of choices in the following format:\n\n\nM\nb_1 b_2 ... b_M\n\n\nwhere M denotes the number of boxes that will contain a ball, and b_1,\\ b_2,\\ ...,\\ b_M are the integers written on these boxes, in any order.\n\nExamples\n\nInput\n\n3\n1 0 0\n\n\nOutput\n\n1\n1\n\n\nInput\n\n5\n0 0 0 0 0\n\n\nOutput\n\n0",
        "task_name": "p02972 AtCoder Beginner Contest 134 - Preparing Boxes",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from collections import *\nimport sys\ninp = raw_input\n\ndef err(s):\n    sys.stderr.write('{}\\n'.format(s))\n\ndef ni():\n    return int(inp())\n\ndef nl():\n    return [int(_) for _ in inp().split()]\n\nN = ni()\nA = nl()\n\nout = [0]*N\nfail = False\nB = []\nfor i in range(N-1, -1, -1):\n    j = i + 1\n    S = 0\n    for k in range(i, N, j):\n        S += out[k]\n    if S%2 != A[i]:\n        out[i] = 1\n        B.append(j)\nprint(len(B))\nif len(B):\n    print(' '.join(map(str, B)))\n\n",
        "correct": true,
        "task_id": "0645",
        "depth": 2
    },
    {
        "description": "On his free time, Chouti likes doing some housework. He has got one new task, paint some bricks in the yard.\n\nThere are n bricks lined in a row on the ground. Chouti has got m paint buckets of different colors at hand, so he painted each brick in one of those m colors.\n\nHaving finished painting all bricks, Chouti was satisfied. He stood back and decided to find something fun with these bricks. After some counting, he found there are k bricks with a color different from the color of the brick on its left (the first brick is not counted, for sure).\n\nSo as usual, he needs your help in counting how many ways could he paint the bricks. Two ways of painting bricks are different if there is at least one brick painted in different colors in these two ways. Because the answer might be quite big, you only need to output the number of ways modulo 998 244 353.\n\nInput\n\nThe first and only line contains three integers n, m and k (1 \u2264 n,m \u2264 2000, 0 \u2264 k \u2264 n-1) \u2014 the number of bricks, the number of colors, and the number of bricks, such that its color differs from the color of brick to the left of it.\n\nOutput\n\nPrint one integer \u2014 the number of ways to color bricks modulo 998 244 353.\n\nExamples\n\nInput\n\n\n3 3 0\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n3 2 1\n\n\nOutput\n\n\n4\n\nNote\n\nIn the first example, since k=0, the color of every brick should be the same, so there will be exactly m=3 ways to color the bricks.\n\nIn the second example, suppose the two colors in the buckets are yellow and lime, the following image shows all 4 possible colorings.\n\n<image>",
        "task_name": "1081_C. Colorful Bricks",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\"\"\"\nThis file is part of https://github.com/Cheran-Senthil/PyRival.\n\nCopyright 2018 Cheran Senthilkumar all rights reserved,\nCheran Senthilkumar <hello@cheran.io>\nPermission to use, modify, and distribute this software is given under the\nterms of the MIT License.\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport cmath\nimport itertools\nimport math\nimport operator as op\n# import random\nimport sys\nfrom atexit import register\nfrom bisect import bisect_left, bisect_right\n# from collections import Counter, MutableSequence, defaultdict, deque\n# from copy import deepcopy\n# from decimal import Decimal\n# from difflib import SequenceMatcher\n# from fractions import Fraction\n# from heapq import heappop, heappush\n\nif sys.version_info[0] < 3:\n    # from cPickle import dumps\n    from io import BytesIO as stream\n    # from Queue import PriorityQueue, Queue\nelse:\n    from functools import reduce\n    from io import StringIO as stream\n    from math import gcd\n    # from pickle import dumps\n    # from queue import PriorityQueue, Queue\n\n\nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n\n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n\n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n\n    def gcd(x, y):\n        \"\"\"gcd(x, y) -> int\n        greatest common divisor of x and y\n        \"\"\"\n        while y:\n            x, y = y, x % y\n        return x\n\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\n\ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n\n    Args:\n        sync (bool, optional): The new synchronization setting.\n\n    \"\"\"\n    global input, flush\n\n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\nMOD = 998244353\n\ndef main():\n    n, m, k = map(int, input().split())\n\n    a = 1\n    for i in range((n - 1) - k + 1, n):\n        a *= i\n        a %= MOD\n    b = 1\n    for i in range(1, k+1):\n        b *= i\n        b %= MOD\n\n    nck = a // b\n\n    print((m * pow((m - 1), k, MOD) * nck) % MOD)\n\nif __name__ == '__main__':\n    sync_with_stdio(False)\n    main()\n",
        "correct": false,
        "task_id": "0654",
        "depth": 1
    },
    {
        "description": "This is a simplified version of the task Toy Train. These two versions differ only in the constraints. Hacks for this version are disabled.\n\nAlice received a set of Toy Train\u2122 from Bob. It consists of one train and a connected railway network of n stations, enumerated from 1 through n. The train occupies one station at a time and travels around the network of stations in a circular manner. More precisely, the immediate station that the train will visit after station i is station i+1 if 1 \u2264 i < n or station 1 if i = n. It takes the train 1 second to travel to its next station as described.\n\nBob gave Alice a fun task before he left: to deliver m candies that are initially at some stations to their independent destinations using the train. The candies are enumerated from 1 through m. Candy i (1 \u2264 i \u2264 m), now at station a_i, should be delivered to station b_i (a_i \u2260 b_i).\n\n<image> The blue numbers on the candies correspond to b_i values. The image corresponds to the 1-st example.\n\nThe train has infinite capacity, and it is possible to load off any number of candies at a station. However, only at most one candy can be loaded from a station onto the train before it leaves the station. You can choose any candy at this station. The time it takes to move the candies is negligible.\n\nNow, Alice wonders how much time is needed for the train to deliver all candies. Your task is to find, for each station, the minimum time the train would need to deliver all the candies were it to start from there.\n\nInput\n\nThe first line contains two space-separated integers n and m (2 \u2264 n \u2264 100; 1 \u2264 m \u2264 200) \u2014 the number of stations and the number of candies, respectively.\n\nThe i-th of the following m lines contains two space-separated integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n; a_i \u2260 b_i) \u2014 the station that initially contains candy i and the destination station of the candy, respectively.\n\nOutput\n\nIn the first and only line, print n space-separated integers, the i-th of which is the minimum time, in seconds, the train would need to deliver all the candies were it to start from station i.\n\nExamples\n\nInput\n\n\n5 7\n2 4\n5 1\n2 3\n3 4\n4 1\n5 3\n3 5\n\n\nOutput\n\n\n10 9 10 10 9 \n\n\nInput\n\n\n2 3\n1 2\n1 2\n1 2\n\n\nOutput\n\n\n5 6 \n\nNote\n\nConsider the second sample.\n\nIf the train started at station 1, the optimal strategy is as follows.\n\n  1. Load the first candy onto the train. \n  2. Proceed to station 2. This step takes 1 second. \n  3. Deliver the first candy. \n  4. Proceed to station 1. This step takes 1 second. \n  5. Load the second candy onto the train. \n  6. Proceed to station 2. This step takes 1 second. \n  7. Deliver the second candy. \n  8. Proceed to station 1. This step takes 1 second. \n  9. Load the third candy onto the train. \n  10. Proceed to station 2. This step takes 1 second. \n  11. Deliver the third candy. \n\n\n\nHence, the train needs 5 seconds to complete the tasks.\n\nIf the train were to start at station 2, however, it would need to move to station 1 before it could load the first candy, which would take one additional second. Thus, the answer in this scenario is 5+1 = 6 seconds.",
        "task_name": "1129_A1. Toy Train (Simplified)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python2\n\"\"\"\nThis file is part of https://github.com/cheran-senthil/PyRival\nCopyright 2019 Cheran Senthilkumar <hello@cheran.io>\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport itertools\nimport os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\n\n\nclass dict(dict):\n    \"\"\"dict() -> new empty dictionary\"\"\"\n\n    def items(self):\n        \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n        return dict.iteritems(self)\n\n    def keys(self):\n        \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n        return dict.iterkeys(self)\n\n    def values(self):\n        \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n        return dict.itervalues(self)\n\n\ndef gcd(x, y):\n    \"\"\"greatest common divisor of x and y\"\"\"\n    while y:\n        x, y = y, x % y\n    return x\n\n\nrange = xrange\n\nfilter = itertools.ifilter\nmap = itertools.imap\nzip = itertools.izip\n\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\n\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    station = [[] for _ in range(n)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        station[a - 1].append(b - 1)\n\n    max_candy = [0] * n\n    for i in range(n):\n        try:\n            max_candy[i] = min(station[i], key=lambda x: x + n - i if x < i else x - i)\n        except ValueError:\n            pass\n\n    for i in range(n):\n        res = 0\n\n        for j in range(i, i + n):\n            if len(station[j % n]) == 0:\n                continue\n\n            dist = j - i\n            j %= n\n            dist += (len(station[j]) - 1) * n + (max_candy[j] + n - j if max_candy[j] < j else max_candy[j] - j)\n\n            res = max(res, dist)\n\n        print(res, end=' ')\n\n\nif __name__ == '__main__':\n    main()\n",
        "correct": true,
        "task_id": "0656",
        "depth": 2
    },
    {
        "description": "Let's call a positive integer composite if it has at least one divisor other than 1 and itself. For example:\n\n  * the following numbers are composite: 1024, 4, 6, 9; \n  * the following numbers are not composite: 13, 1, 2, 3, 37. \n\n\n\nYou are given a positive integer n. Find two composite integers a,b such that a-b=n.\n\nIt can be proven that solution always exists.\n\nInput\n\nThe input contains one integer n (1 \u2264 n \u2264 10^7): the given integer.\n\nOutput\n\nPrint two composite integers a,b (2 \u2264 a, b \u2264 10^9, a-b=n).\n\nIt can be proven, that solution always exists.\n\nIf there are several possible solutions, you can print any. \n\nExamples\n\nInput\n\n\n1\n\n\nOutput\n\n\n9 8\n\n\nInput\n\n\n512\n\n\nOutput\n\n\n4608 4096",
        "task_name": "1269_A. Equation",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Fall 7, Stand 8...\n# !/ankit_SM/bin/env python\n\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\ndef main():\n    tinn=1; #tinn=int(input())\n    for tin in range(tinn):\n        n=int(input())\n        print(9*n,8*n)\n\n\n\n\n\n\n\n# region fastio\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# endregion\nif __name__ == \"__main__\":\n    main()",
        "correct": true,
        "task_id": "0659",
        "depth": 1
    },
    {
        "description": "Let's call a list of positive integers a_0, a_1, ..., a_{n-1} a power sequence if there is a positive integer c, so that for every 0 \u2264 i \u2264 n-1 then a_i = c^i.\n\nGiven a list of n positive integers a_0, a_1, ..., a_{n-1}, you are allowed to:\n\n  * Reorder the list (i.e. pick a permutation p of \\{0,1,...,n - 1\\} and change a_i to a_{p_i}), then \n  * Do the following operation any number of times: pick an index i and change a_i to a_i - 1 or a_i + 1 (i.e. increment or decrement a_i by 1) with a cost of 1. \n\n\n\nFind the minimum cost to transform a_0, a_1, ..., a_{n-1} into a power sequence.\n\nInput\n\nThe first line contains an integer n (3 \u2264 n \u2264 10^5).\n\nThe second line contains n integers a_0, a_1, ..., a_{n-1} (1 \u2264 a_i \u2264 10^9).\n\nOutput\n\nPrint the minimum cost to transform a_0, a_1, ..., a_{n-1} into a power sequence.\n\nExamples\n\nInput\n\n\n3\n1 3 2\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n3\n1000000000 1000000000 1000000000\n\n\nOutput\n\n\n1999982505\n\nNote\n\nIn the first example, we first reorder \\{1, 3, 2\\} into \\{1, 2, 3\\}, then increment a_2 to 4 with cost 1 to get a power sequence \\{1, 2, 4\\}.",
        "task_name": "1397_B. Power Sequence",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# template begins \n##################################### \n  \n# import libraries for input/ output handling \n# on generic level \nimport atexit, io, sys \n  \n# A stream implementation using an in-memory bytes  \n# buffer. It inherits BufferedIOBase. \nbuffer = io.BytesIO() \nsys.stdout = buffer\n  \n# print via here \n@atexit.register \ndef write(): \n    sys.__stdout__.write(buffer.getvalue()) \n  \n##################################### \n# template ends \n \n \nimport math\nn=int(raw_input())\nl=[int(x) for x in raw_input().split()]\nl.sort()\nmx=l[n-1]\nx=math.log(mx,2)\nc=pow(2,(x/(n-1)))\n# print(x)\nfloor_c=int(c)\nif(floor_c<=0):\n    floor_c+=1                                                                                                                                           \nnxt_num=floor_c+1\nans=pow(10,16)\nres=0\nmul=1\nc=floor_c\nfor i in range(0,n):\n    res+=abs(mul-l[i])\n    mul=mul*c\nans=min(ans,res)\nres2=0\nmul=1\nc=nxt_num\nfor i in range(0,n):\n    res2+=abs(mul-l[i])\n    mul=mul*c\nans=min(ans,res2)\nprint(int(ans))",
        "correct": true,
        "task_id": "0665",
        "depth": 1
    },
    {
        "description": "This is the hard version of the problem. The difference between the versions is that the easy version has no swap operations. You can make hacks only if all versions of the problem are solved.\n\nPikachu is a cute and friendly pok\u00e9mon living in the wild pikachu herd.\n\nBut it has become known recently that infamous team R wanted to steal all these pok\u00e9mon! Pok\u00e9mon trainer Andrew decided to help Pikachu to build a pok\u00e9mon army to resist.\n\nFirst, Andrew counted all the pok\u00e9mon \u2014 there were exactly n pikachu. The strength of the i-th pok\u00e9mon is equal to a_i, and all these numbers are distinct.\n\nAs an army, Andrew can choose any non-empty subsequence of pokemons. In other words, Andrew chooses some array b from k indices such that 1 \u2264 b_1 < b_2 < ... < b_k \u2264 n, and his army will consist of pok\u00e9mons with forces a_{b_1}, a_{b_2}, ..., a_{b_k}.\n\nThe strength of the army is equal to the alternating sum of elements of the subsequence; that is, a_{b_1} - a_{b_2} + a_{b_3} - a_{b_4} + ....\n\nAndrew is experimenting with pok\u00e9mon order. He performs q operations. In i-th operation Andrew swaps l_i-th and r_i-th pok\u00e9mon.\n\nAndrew wants to know the maximal stregth of the army he can achieve with the initial pok\u00e9mon placement. He also needs to know the maximal strength after each operation.\n\nHelp Andrew and the pok\u00e9mon, or team R will realize their tricky plan!\n\nInput\n\nEach test contains multiple test cases.\n\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3) denoting the number of test cases. Description of the test cases follows.\n\nThe first line of each test case contains two integers n and q (1 \u2264 n \u2264 3 \u22c5 10^5, 0 \u2264 q \u2264 3 \u22c5 10^5) denoting the number of pok\u00e9mon and number of operations respectively.\n\nThe second line contains n distinct positive integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 n) denoting the strengths of the pok\u00e9mon.\n\ni-th of the last q lines contains two positive integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n) denoting the indices of pok\u00e9mon that were swapped in the i-th operation.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5, and the sum of q over all test cases does not exceed 3 \u22c5 10^5. \n\nOutput\n\nFor each test case, print q+1 integers: the maximal strength of army before the swaps and after each swap.\n\nExample\n\nInput\n\n\n3\n3 1\n1 3 2\n1 2\n2 2\n1 2\n1 2\n1 2\n7 5\n1 2 5 4 3 6 7\n1 2\n6 7\n3 4\n1 2\n2 3\n\n\nOutput\n\n\n3\n4\n2\n2\n2\n9\n10\n10\n10\n9\n11\n\nNote\n\nLet's look at the third test case:\n\nInitially we can build an army in such way: [1 2 5 4 3 6 7], its strength will be 5-3+7=9.\n\nAfter first operation we can build an army in such way: [2 1 5 4 3 6 7], its strength will be 2-1+5-3+7=10.\n\nAfter second operation we can build an army in such way: [2 1 5 4 3 7 6], its strength will be 2-1+5-3+7=10.\n\nAfter third operation we can build an army in such way: [2 1 4 5 3 7 6], its strength will be 2-1+5-3+7=10.\n\nAfter forth operation we can build an army in such way: [1 2 4 5 3 7 6], its strength will be 5-3+7=9.\n\nAfter all operations we can build an army in such way: [1 4 2 5 3 7 6], its strength will be 4-2+5-3+7=11.",
        "task_name": "1420_C2. Pok\u00e9mon Army (hard version)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nfrom itertools import repeat\ndef solve():\n    n, q = map(int, stdin.readline().split())\n    a = [0] + map(int, stdin.readline().split(), repeat(10, n)) + [0]\n    b = [map(int, stdin.readline().split(), (10, 10)) for _ in xrange(q)]\n    s = 0\n    for i in xrange(1, n + 1):\n        if a[i-1] < a[i] > a[i+1]:\n            s += a[i]\n        if a[i-1] > a[i] < a[i+1]:\n            s -= a[i]\n    stdout.write('%d\\n' % s)\n    if not q:\n        return\n    ans = [0] * q\n    d = 0\n    for i, x in enumerate(b):\n        l, r = x\n        if r == l:\n            ans[i] = d\n            continue\n        Ll, L, Lr = a[l-1], a[l], a[l+1]\n        Rl, R, Rr = a[r-1], a[r], a[r+1]\n        if l > 1:\n            if a[l-2] < Ll > L:\n                d -= Ll\n            elif a[l-2] > Ll < L:\n                d += Ll\n        if Ll < L > Lr:\n            d -= L\n        elif Ll > L < Lr:\n            d += L\n        if r - l > 1:\n            if a[l+2] < Lr > L:\n                d -= Lr\n            elif a[l+2] > Lr < L:\n                d += Lr\n        if r - l > 2:\n            if a[r-2] < Rl > R:\n                d -= Rl\n            elif a[r-2] > Rl < R:\n                d += Rl\n        if Rl < R > Rr:\n            d -= R\n        elif Rl > R < Rr:\n            d += R\n        if r < n:\n            if a[r+2] < Rr > R:\n                d -= Rr\n            elif a[r+2] > Rr < R:\n                d += Rr\n        a[l], a[r] = a[r], a[l]\n        Ll, L, Lr = a[l-1], a[l], a[l+1]\n        Rl, R, Rr = a[r-1], a[r], a[r+1]\n        if l > 1:\n            if a[l-2] < Ll > L:\n                d += Ll\n            elif a[l-2] > Ll < L:\n                d -= Ll\n        if Ll < L > Lr:\n            d += L\n        elif Ll > L < Lr:\n            d -= L\n        if r - l > 1:\n            if a[l+2] < Lr > L:\n                d += Lr\n            elif a[l+2] > Lr < L:\n                d -= Lr\n        if r - l > 2:\n            if a[r-2] < Rl > R:\n                d += Rl\n            elif a[r-2] > Rl < R:\n                d -= Rl\n        if Rl < R > Rr:\n            d += R\n        elif Rl > R < Rr:\n            d -= R\n        if r < n:\n            if a[r+2] < Rr > R:\n                d += Rr\n            elif a[r+2] > Rr < R:\n                d -= Rr\n        ans[i] = d\n    stdout.write(''.join('%d\\n' % (s + x) for x in ans))\nT = int(stdin.readline())\nfor _ in xrange(T):\n    solve()\n",
        "correct": true,
        "task_id": "0666",
        "depth": 1
    },
    {
        "description": "Athenaeus has just finished creating his latest musical composition and will present it tomorrow to the people of Athens. Unfortunately, the melody is rather dull and highly likely won't be met with a warm reception. \n\nHis song consists of n notes, which we will treat as positive integers. The diversity of a song is the number of different notes it contains. As a patron of music, Euterpe watches over composers and guides them throughout the process of creating new melodies. She decided to help Athenaeus by changing his song to make it more diverse.\n\nBeing a minor goddess, she cannot arbitrarily change the song. Instead, for each of the n notes in the song, she can either leave it as it is or increase it by 1.\n\nGiven the song as a sequence of integers describing the notes, find out the maximal, achievable diversity.\n\nInput\n\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases. Then t test cases follow, each one is described in two lines.\n\nIn the first line of each test case there is a single integer n (1 \u2264 n \u2264 10^5) denoting the length of the song. The next line contains a sequence of n integers x_1, x_2, \u2026, x_n (1 \u2264 x_1 \u2264 x_2 \u2264 \u2026 \u2264 x_n \u2264 2 \u22c5 n), describing the song.\n\nThe sum of n over all test cases does not exceed 10^5.\n\nOutput\n\nFor each test case, you should output a single line containing precisely one integer, the maximal diversity of the song, i.e. the maximal possible number of different elements in the final sequence.\n\nExample\n\nInput\n\n\n5\n6\n1 2 2 2 5 6\n2\n4 4\n6\n1 1 3 4 4 5\n1\n1\n6\n1 1 1 2 2 2\n\n\nOutput\n\n\n5\n2\n6\n1\n3\n\nNote\n\nIn the first test case, Euterpe can increase the second, fifth and sixth element to obtain the sequence 1, \\underline{3}, 2, 2, \\underline{6}, \\underline{7}, which has 5 different elements (increased elements are underlined).\n\nIn the second test case, Euterpe can increase the first element to obtain the sequence \\underline{5}, 4, which has 2 different elements.\n\nIn the third test case, Euterpe can increase the second, fifth and sixth element to obtain the sequence 1, \\underline{2}, 3, 4, \\underline{5}, \\underline{6}, which has 6 different elements.",
        "task_name": "1466_B. Last minute enhancements",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    t = int(input())\n\n    for _ in range(t):\n        n = int(input())\n        x = [int(xi) for xi in input().split()]\n\n        prev = 0\n        cnt = 0\n        sol = 0\n\n        for i in x:\n            if i != prev and cnt > 1:\n                prev += 1\n                sol += 1\n\n            if i == prev:\n                cnt += 1\n            else:\n                prev = i\n                sol += 1\n                cnt = 1\n\n        if cnt > 1:\n            sol += 1\n\n        print(sol)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "0668",
        "depth": 2
    },
    {
        "description": "Vasya has n items lying in a line. The items are consecutively numbered by numbers from 1 to n in such a way that the leftmost item has number 1, the rightmost item has number n. Each item has a weight, the i-th item weights wi kilograms.\n\nVasya needs to collect all these items, however he won't do it by himself. He uses his brand new robot. The robot has two different arms \u2014 the left one and the right one. The robot can consecutively perform the following actions: \n\n  1. Take the leftmost item with the left hand and spend wi \u00b7 l energy units (wi is a weight of the leftmost item, l is some parameter). If the previous action was the same (left-hand), then the robot spends extra Ql energy units; \n  2. Take the rightmost item with the right hand and spend wj \u00b7 r energy units (wj is a weight of the rightmost item, r is some parameter). If the previous action was the same (right-hand), then the robot spends extra Qr energy units; \n\n\n\nNaturally, Vasya wants to program the robot in a way that the robot spends as little energy as possible. He asked you to solve this problem. Your task is to find the minimum number of energy units robot spends to collect all items.\n\nInput\n\nThe first line contains five integers n, l, r, Ql, Qr (1 \u2264 n \u2264 105; 1 \u2264 l, r \u2264 100; 1 \u2264 Ql, Qr \u2264 104).\n\nThe second line contains n integers w1, w2, ..., wn (1 \u2264 wi \u2264 100).\n\nOutput\n\nIn the single line print a single number \u2014 the answer to the problem.\n\nExamples\n\nInput\n\n3 4 4 19 1\n42 3 99\n\n\nOutput\n\n576\n\n\nInput\n\n4 7 2 3 9\n1 2 3 4\n\n\nOutput\n\n34\n\nNote\n\nConsider the first sample. As l = r, we can take an item in turns: first from the left side, then from the right one and last item from the left. In total the robot spends 4\u00b742 + 4\u00b799 + 4\u00b73 = 576 energy units.\n\nThe second sample. The optimal solution is to take one item from the right, then one item from the left and two items from the right. In total the robot spends (2\u00b74) + (7\u00b71) + (2\u00b73) + (2\u00b72 + 9) = 34 energy units.",
        "task_name": "354_A. Vasya and Robot",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\ninp = [map(int, i.split(' ')) for i in sys.stdin.read().splitlines()]\n\nn, L, R, QL, QR = inp[0]\nw = inp[1]\n\ndef test(f):\n    global L, R, QL, QR, w\n    ret = 0\n    l, r = 0, len(w)\n    action = None\n    while l != r:\n        cost_l = w[l  ]*L + (QL if action == 0 else 0)\n        cost_r = w[r-1]*R + (QR if action == 1 else 0)\n        if action is not None:\n            if cost_l < cost_r:\n                action = 0\n            elif cost_l > cost_r:\n                action = 1\n        else:\n            action = f\n        if action == 0:\n            ret += cost_l\n            l += 1\n        else:\n            ret += cost_r\n            r -= 1\n    return ret\n\nres = min(test(0), test(1))\n\nsys.stdout.write(str(res))\n",
        "correct": false,
        "task_id": "0671",
        "depth": 1
    },
    {
        "description": "It's the year 4527 and the tanks game that we all know and love still exists. There also exists Great Gena's code, written in 2016. The problem this code solves is: given the number of tanks that go into the battle from each country, find their product. If it is turns to be too large, then the servers might have not enough time to assign tanks into teams and the whole game will collapse!\n\nThere are exactly n distinct countries in the world and the i-th country added ai tanks to the game. As the developers of the game are perfectionists, the number of tanks from each country is beautiful. A beautiful number, according to the developers, is such number that its decimal representation consists only of digits '1' and '0', moreover it contains at most one digit '1'. However, due to complaints from players, some number of tanks of one country was removed from the game, hence the number of tanks of this country may not remain beautiful.\n\nYour task is to write the program that solves exactly the same problem in order to verify Gena's code correctness. Just in case.\n\nInput\n\nThe first line of the input contains the number of countries n (1 \u2264 n \u2264 100 000). The second line contains n non-negative integers ai without leading zeroes \u2014 the number of tanks of the i-th country.\n\nIt is guaranteed that the second line contains at least n - 1 beautiful numbers and the total length of all these number's representations doesn't exceed 100 000.\n\nOutput\n\nPrint a single number without leading zeroes \u2014 the product of the number of tanks presented by each country.\n\nExamples\n\nInput\n\n3\n5 10 1\n\n\nOutput\n\n50\n\nInput\n\n4\n1 1 10 11\n\n\nOutput\n\n110\n\nInput\n\n5\n0 3 1 100 1\n\n\nOutput\n\n0\n\nNote\n\nIn sample 1 numbers 10 and 1 are beautiful, number 5 is not not.\n\nIn sample 2 number 11 is not beautiful (contains two '1's), all others are beautiful.\n\nIn sample 3 number 3 is not beautiful, all others are beautiful.",
        "task_name": "614_B. Gena's Code",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n# sys.stdin = open('input.txt')\nn = int(raw_input())\na = raw_input().split()\nif '0' in a:\n    sys.stdout.write('0')\n    exit()\nzc = 0\nhasBad = False\nfor x in a:\n    f = True\n    c = 0\n    c1 = 0\n    for ch in x:\n        if ch == '0':\n            c += 1\n        if ch == '1':\n            c1 += 1\n        if (ch != '1' and ch != '0') or c1 > 1:\n            f = False\n            break\n    if f:\n        zc += c\n    else:\n        hasBad = True\n        sys.stdout.write(x)\nif not hasBad:\n    sys.stdout.write('1')\nsys.stdout.write('0' * zc)\n",
        "correct": true,
        "task_id": "0678",
        "depth": 2
    },
    {
        "description": "Well, the series which Stepan watched for a very long time, ended. In total, the series had n episodes. For each of them, Stepan remembers either that he definitely has watched it, or that he definitely hasn't watched it, or he is unsure, has he watched this episode or not. \n\nStepan's dissatisfaction is the maximum number of consecutive series that Stepan did not watch.\n\nYour task is to determine according to Stepan's memories if his dissatisfaction could be exactly equal to k.\n\nInput\n\nThe first line contains two integers n and k (1 \u2264 n \u2264 100, 0 \u2264 k \u2264 n) \u2014 the number of episodes in the series and the dissatisfaction which should be checked. \n\nThe second line contains the sequence which consists of n symbols \"Y\", \"N\" and \"?\". If the i-th symbol equals \"Y\", Stepan remembers that he has watched the episode number i. If the i-th symbol equals \"N\", Stepan remembers that he hasn't watched the epizode number i. If the i-th symbol equals \"?\", Stepan doesn't exactly remember if he has watched the episode number i or not.\n\nOutput\n\nIf Stepan's dissatisfaction can be exactly equal to k, then print \"YES\" (without qoutes). Otherwise print \"NO\" (without qoutes).\n\nExamples\n\nInput\n\n5 2\nNYNNY\n\n\nOutput\n\nYES\n\n\nInput\n\n6 1\n????NN\n\n\nOutput\n\nNO\n\nNote\n\nIn the first test Stepan remembers about all the episodes whether he has watched them or not. His dissatisfaction is 2, because he hasn't watch two episodes in a row \u2014 the episode number 3 and the episode number 4. The answer is \"YES\", because k = 2.\n\nIn the second test k = 1, Stepan's dissatisfaction is greater than or equal to 2 (because he remembers that he hasn't watch at least two episodes in a row \u2014 number 5 and number 6), even if he has watched the episodes from the first to the fourth, inclusive.",
        "task_name": "774_J. Stepan's Series",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport re\n[n, k] = map(int, sys.stdin.readline().split())\nseq = sys.stdin.readline().split()[0]\n\n#print n, k, seq\n\ndef max_N(s):\n    r = 0\n    max_r = 0\n    for i in range(len(s)):\n        if s[i] == 'N':\n            r += 1\n        else:\n            r = 0\n        if r > max_r:\n            max_r = r\n    return max_r\n\ndef is_possible(s, k):\n    s1 = \"Y\" + s + \"Y\"\n    seq_N = s1.replace(\"?\", \"N\")\n    for i in range(len(seq_N)):\n        if seq_N[i:i + k] == 'N' * k:\n            if (s1[i - 1] in [\"Y\", \"?\"]) and (s1[i + k] in [\"Y\", \"?\"]):\n                return 1\n    return 0\n\nseq_Y = seq.replace(\"?\", \"Y\")\nmax_N_Y = max_N(seq_Y)\n\nif max_N_Y > k:\n    print(\"NO\")\nelif max_N_Y == k:\n    print(\"YES\")\nelse:\n    if is_possible(seq, k):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "correct": true,
        "task_id": "0681",
        "depth": 1
    },
    {
        "description": "The cities of Byteland and Berland are located on the axis Ox. In addition, on this axis there are also disputed cities, which belong to each of the countries in their opinion. Thus, on the line Ox there are three types of cities:\n\n  * the cities of Byteland, \n  * the cities of Berland, \n  * disputed cities. \n\n\n\nRecently, the project BNET has been launched \u2014 a computer network of a new generation. Now the task of the both countries is to connect the cities so that the network of this country is connected.\n\nThe countries agreed to connect the pairs of cities with BNET cables in such a way that:\n\n  * If you look at the only cities of Byteland and the disputed cities, then in the resulting set of cities, any city should be reachable from any other one by one or more cables, \n  * If you look at the only cities of Berland and the disputed cities, then in the resulting set of cities, any city should be reachable from any other one by one or more cables. \n\n\n\nThus, it is necessary to choose a set of pairs of cities to connect by cables in such a way that both conditions are satisfied simultaneously. Cables allow bi-directional data transfer. Each cable connects exactly two distinct cities.\n\nThe cost of laying a cable from one city to another is equal to the distance between them. Find the minimum total cost of laying a set of cables so that two subsets of cities (Byteland and disputed cities, Berland and disputed cities) are connected.\n\nEach city is a point on the line Ox. It is technically possible to connect the cities a and b with a cable so that the city c (a < c < b) is not connected to this cable, where a, b and c are simultaneously coordinates of the cities a, b and c.\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^{5}) \u2014 the number of cities.\n\nThe following n lines contains an integer x_i and the letter c_i (-10^{9} \u2264 x_i \u2264 10^{9}) \u2014 the coordinate of the city and its type. If the city belongs to Byteland, c_i equals to 'B'. If the city belongs to Berland, c_i equals to \u00abR\u00bb. If the city is disputed, c_i equals to 'P'. \n\nAll cities have distinct coordinates. Guaranteed, that the cities are given in the increasing order of their coordinates.\n\nOutput\n\nPrint the minimal total length of such set of cables, that if we delete all Berland cities (c_i='R'), it will be possible to find a way from any remaining city to any other remaining city, moving only by cables. Similarly, if we delete all Byteland cities (c_i='B'), it will be possible to find a way from any remaining city to any other remaining city, moving only by cables.\n\nExamples\n\nInput\n\n4\n-5 R\n0 P\n3 P\n7 B\n\n\nOutput\n\n12\n\n\nInput\n\n5\n10 R\n14 B\n16 B\n21 R\n32 R\n\n\nOutput\n\n24\n\nNote\n\nIn the first example, you should connect the first city with the second, the second with the third, and the third with the fourth. The total length of the cables will be 5 + 3 + 4 = 12.\n\nIn the second example there are no disputed cities, so you need to connect all the neighboring cities of Byteland and all the neighboring cities of Berland. The cities of Berland have coordinates 10, 21, 32, so to connect them you need two cables of length 11 and 11. The cities of Byteland have coordinates 14 and 16, so to connect them you need one cable of length 2. Thus, the total length of all cables is 11 + 11 + 2 = 24.",
        "task_name": "962_E. Byteland, Berland and Disputed Cities",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\ndef solv(p1,p2,a1):\n\n        \n    ans1=0\n    r=[]\n    b=[]\n    for i in a1:\n        if(i[1]=='R'):\n            r.append(i[0])\n        elif(i[1]=='B'):\n            b.append(i[0])\n    ans1=2*(p2-p1)\n\n    ans2=p2-p1\n    if(len(r)):\n        L=[r[0]-p1]\n        R=[p2-r[-1]]\n    \n        for i in range(1,len(r)):\n            L.append(r[i]-r[i-1] + L[-1])\n        for i in range(len(r)-1,0,-1):\n            R.append(r[i]-r[i-1] + R[-1])\n        min1=min(L[-1],R[-1])\n        for i in range(len(r)-1):\n            min1=min(min1,L[i]+R[len(r)-i-2])\n        ans2+=min1\n    #print('ans2 due to r ',ans2,L,R)\n    if(len(b)):\n        L=[b[0]-p1]\n        R=[p2-b[-1]]\n    \n        for i in range(1,len(b)):\n            L.append(b[i]-b[i-1] + L[-1])\n        for i in range(len(b)-1,0,-1):\n            R.append(b[i]-b[i-1] + R[-1])\n        min1=min(L[-1],R[-1])\n        for i in range(len(b)-1):\n            min1=min(min1,L[i]+R[len(b)-i-2])\n        ans2+=min1\n    #print('ans2 due to r ',ans2,L,R)\n    #print('in solv ',ans1,ans2,p1,p2)\n    return min(ans1,ans2)\n\n\nn=int(raw_input())\n\na=[]\n        \nfor i in range(n):\n    x,y=raw_input().split()\n    x=int(x)\n    a.append([x,y])\nfirst=-1\nlast=-1\nans=0\nfor i in range(n):\n    if(a[i][1]=='P'):\n        if(first==-1):\n            first=i\n        else:\n            ans+=solv(a[last][0],a[i][0],a[last+1:i])\n        last=i\n    ans1=0\nr=[]\nb=[]\n#print(ans)\nif(first!=-1):\n    for i in a[:first]:\n        if(i[1]=='R'):\n            r.append(i[0])\n        elif(i[1]=='B'):\n            b.append(i[0])\n    for i in range(len(r)-1):\n        ans+=r[i+1]-r[i]\n    for i in range(len(b)-1):\n        ans+=b[i+1]-b[i]\n    if(len(r)):\n        ans+=a[first][0]-r[-1]\n    if(len(b)):\n        ans+=a[first][0]-b[-1]\n    r=[]\n    b=[]\n#    print(ans,r,b,first,a[:1])\n    for i in a[last:]:\n        if(i[1]=='R'):\n            r.append(i[0])\n        elif(i[1]=='B'):\n            b.append(i[0])\n    for i in range(len(r)-1):\n        ans+=r[i+1]-r[i]\n    for i in range(len(b)-1):\n        ans+=b[i+1]-b[i]\n    if(len(r)):\n        ans+=r[0]-a[last][0]\n    if(len(b)):\n        ans+=b[0]-a[last][0]\nelse:\n    r=[]\n    b=[]\n    \n    for i in a:\n        if(i[1]=='R'):\n            r.append(i[0])\n        elif(i[1]=='B'):\n            b.append(i[0])\n    for i in range(len(r)-1):\n        ans+=r[i+1]-r[i]\n    for i in range(len(b)-1):\n        ans+=b[i+1]-b[i]\nprint(ans)\n\n\n\n\n",
        "correct": true,
        "task_id": "0685",
        "depth": 1
    },
    {
        "description": "We have a 2 \\times N grid. We will denote the square at the i-th row and j-th column (1 \\leq i \\leq 2, 1 \\leq j \\leq N) as (i, j).\n\nYou are initially in the top-left square, (1, 1). You will travel to the bottom-right square, (2, N), by repeatedly moving right or down.\n\nThe square (i, j) contains A_{i, j} candies. You will collect all the candies you visit during the travel. The top-left and bottom-right squares also contain candies, and you will also collect them.\n\nAt most how many candies can you collect when you choose the best way to travel?\n\nConstraints\n\n* 1 \\leq N \\leq 100\n* 1 \\leq A_{i, j} \\leq 100 (1 \\leq i \\leq 2, 1 \\leq j \\leq N)\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nA_{1, 1} A_{1, 2} ... A_{1, N}\nA_{2, 1} A_{2, 2} ... A_{2, N}\n\n\nOutput\n\nPrint the maximum number of candies that can be collected.\n\nExamples\n\nInput\n\n5\n3 2 2 4 1\n1 2 2 2 1\n\n\nOutput\n\n14\n\n\nInput\n\n4\n1 1 1 1\n1 1 1 1\n\n\nOutput\n\n5\n\n\nInput\n\n7\n3 3 4 5 4 5 3\n5 3 4 4 2 3 2\n\n\nOutput\n\n29\n\n\nInput\n\n1\n2\n3\n\n\nOutput\n\n5",
        "task_name": "p03449 AtCoder Beginner Contest 087 - Candies",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "N=int(raw_input())\nA=raw_input().split(\" \")\nB=raw_input().split(\" \")\n\nA = map(int, A)\nB = map(int, B)\n\nmaxim=0\nfor i in xrange(1,N+1):\n\ttemp=sum(A[0:i]) + sum(B[i-1:N])\n\tprint(sum(A[0:i]),sum(B[i-1:N]))\n\tif maxim < temp:\n\t\tmaxim = temp\nprint(maxim)",
        "correct": false,
        "task_id": "0690",
        "depth": 1
    },
    {
        "description": "Dora loves adventures quite a lot. During some journey she encountered an amazing city, which is formed by n streets along the Eastern direction and m streets across the Southern direction. Naturally, this city has nm intersections. At any intersection of i-th Eastern street and j-th Southern street there is a monumental skyscraper. Dora instantly became curious and decided to explore the heights of the city buildings.\n\nWhen Dora passes through the intersection of the i-th Eastern and j-th Southern street she examines those two streets. After Dora learns the heights of all the skyscrapers on those two streets she wonders: how one should reassign heights to the skyscrapers on those two streets, so that the maximum height would be as small as possible and the result of comparing the heights of any two skyscrapers on one street wouldn't change.\n\nFormally, on every of nm intersections Dora solves an independent problem. She sees n + m - 1 skyscrapers and for each of them she knows its real height. Moreover, any two heights can be compared to get a result \"greater\", \"smaller\" or \"equal\". Now Dora wants to select some integer x and assign every skyscraper a height from 1 to x. When assigning heights, Dora wants to preserve the relative order of the skyscrapers in both streets. That is, the result of any comparison of heights of two skyscrapers in the current Eastern street shouldn't change and the result of any comparison of heights of two skyscrapers in current Southern street shouldn't change as well. Note that skyscrapers located on the Southern street are not compared with skyscrapers located on the Eastern street only. However, the skyscraper located at the streets intersection can be compared with both Southern and Eastern skyscrapers. For every intersection Dora wants to independently calculate the minimum possible x.\n\nFor example, if the intersection and the two streets corresponding to it look as follows:\n\n<image>\n\nThen it is optimal to replace the heights of the skyscrapers as follows (note that all comparisons \"less\", \"equal\", \"greater\" inside the Eastern street and inside the Southern street are preserved)\n\n<image>\n\nThe largest used number is 5, hence the answer for this intersection would be 5.\n\nHelp Dora to compute the answers for each intersection.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 1000) \u2014 the number of streets going in the Eastern direction and the number of the streets going in Southern direction.\n\nEach of the following n lines contains m integers a_{i,1}, a_{i,2}, ..., a_{i,m} (1 \u2264 a_{i,j} \u2264 10^9). The integer a_{i,j}, located on j-th position in the i-th line denotes the height of the skyscraper at the intersection of the i-th Eastern street and j-th Southern direction.\n\nOutput\n\nPrint n lines containing m integers each. The integer x_{i,j}, located on j-th position inside the i-th line is an answer for the problem at the intersection of i-th Eastern street and j-th Southern street.\n\nExamples\n\nInput\n\n\n2 3\n1 2 1\n2 1 2\n\n\nOutput\n\n\n2 2 2 \n2 2 2 \n\n\nInput\n\n\n2 2\n1 2\n3 4\n\n\nOutput\n\n\n2 3 \n3 2 \n\nNote\n\nIn the first example, it's not possible to decrease the maximum used height for the problem at any intersection, hence we don't have to change any heights.\n\nIn the second example, the answers are as follows: \n\n  * For the intersection of the first line and the first column <image>\n  * For the intersection of the first line and the second column <image>\n  * For the intersection of the second line and the first column <image>\n  * For the intersection of the second line and the second column <image>",
        "task_name": "1137_A. Skyscrapers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nn,m = map(int, raw_input().split(' '))\nlines = stdin.readlines()\nrows = [None]*n\nfor i in xrange(n):\n\trows[i] = map(int, lines[i].split(' '))\n\ndef equivalently_sorted_list(xs):\n\t'example: [10,20,14,10] -> ([1,3,2,1], 3). returns list of positive integers with equivalent pairwise comparisons (<,=,>) to list.'\n\n\txs = sorted([xs[i]*1000+i for i in xrange(len(xs))])\n\tys = [0]*len(xs)\n\tlast_x = None\n\tj = 0\n\tfor w in xs:\n\t\tx = w/1000\n\t\ti = w%1000\n\t\tif x == last_x:\n\t\t\tys[i] = j\n\t\telse:\n\t\t\tj += 1\n\t\t\tys[i] = j\n\t\tlast_x = x\n\treturn ys, j\n\ncolumns = [[rows[i][j] for i in xrange(n)] for j in xrange(m)]\n\nrows_ordered = [equivalently_sorted_list(row) for row in rows]\ncolumns_ordered = [equivalently_sorted_list(column) for column in columns]\n\ndef answer(i,j):\n\tif rows_ordered[i][0][j] > columns_ordered[j][0][i]:\n\t\tdifference = rows_ordered[i][0][j] - columns_ordered[j][0][i]\n\t\treturn max(rows_ordered[i][1], columns_ordered[j][1] + difference)\n\telse:\n\t\tdifference = columns_ordered[j][0][i] - rows_ordered[i][0][j]\n\t\treturn max(columns_ordered[j][1], rows_ordered[i][1] + difference)\n\nanswer_matrix = [[answer(i,j) for i in xrange(n)] for j in xrange(m)]\n\nstdout.write('\\n'.join([' '.join([str(answer_matrix[j][i]) for j in xrange(m)]) for i in xrange(n)]))",
        "correct": true,
        "task_id": "0697",
        "depth": 1
    },
    {
        "description": "Polycarp analyzes the prices of the new berPhone. At his disposal are the prices for n last days: a_1, a_2, ..., a_n, where a_i is the price of berPhone on the day i.\n\nPolycarp considers the price on the day i to be bad if later (that is, a day with a greater number) berPhone was sold at a lower price. For example, if n=6 and a=[3, 9, 4, 6, 7, 5], then the number of days with a bad price is 3 \u2014 these are days 2 (a_2=9), 4 (a_4=6) and 5 (a_5=7).\n\nPrint the number of days with a bad price.\n\nYou have to answer t independent data sets.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of sets of input data in the test. Input data sets must be processed independently, one after another.\n\nEach input data set consists of two lines. The first line contains an integer n (1 \u2264 n \u2264 150000) \u2014 the number of days. The second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^6), where a_i is the price on the i-th day.\n\nIt is guaranteed that the sum of n over all data sets in the test does not exceed 150000.\n\nOutput\n\nPrint t integers, the j-th of which should be equal to the number of days with a bad price in the j-th input data set.\n\nExample\n\nInput\n\n\n5\n6\n3 9 4 6 7 5\n1\n1000000\n2\n2 1\n10\n31 41 59 26 53 58 97 93 23 84\n7\n3 2 1 2 3 4 5\n\n\nOutput\n\n\n3\n0\n1\n8\n2",
        "task_name": "1213_B. Bad Prices",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "for i in range(input()):\n\tn=input()\n\tl=[int(j) for j in raw_input().split(' ')]\n\tminAr = l[-1]\n\tsm =0\n\tfor j in range(len(l)-2,-1,-1):\n\t\tif l[j] < minAr:\n\t\t\tminAr = l[j]\n\t\telif l[j] > minAr:\n\t\t\tsm+=1\n\tprint(sm)\n",
        "correct": true,
        "task_id": "0700",
        "depth": 2
    },
    {
        "description": "In order to do some research, n^2 labs are built on different heights of a mountain. Let's enumerate them with integers from 1 to n^2, such that the lab with the number 1 is at the lowest place, the lab with the number 2 is at the second-lowest place, \u2026, the lab with the number n^2 is at the highest place.\n\nTo transport water between the labs, pipes are built between every pair of labs. A pipe can transport at most one unit of water at a time from the lab with the number u to the lab with the number v if u > v.\n\nNow the labs need to be divided into n groups, each group should contain exactly n labs. The labs from different groups can transport water to each other. The sum of units of water that can be sent from a group A to a group B is equal to the number of pairs of labs (u, v) such that the lab with the number u is from the group A, the lab with the number v is from the group B and u > v. Let's denote this value as f(A,B) (i.e. f(A,B) is the sum of units of water that can be sent from a group A to a group B).\n\nFor example, if n=3 and there are 3 groups X, Y and Z: X = \\{1, 5, 6\\}, Y = \\{2, 4, 9\\} and Z = \\{3, 7, 8\\}. In this case, the values of f are equal to:\n\n  * f(X,Y)=4 because of 5 \u2192 2, 5 \u2192 4, 6 \u2192 2, 6 \u2192 4, \n  * f(X,Z)=2 because of 5 \u2192 3, 6 \u2192 3, \n  * f(Y,X)=5 because of 2 \u2192 1, 4 \u2192 1, 9 \u2192 1, 9 \u2192 5, 9 \u2192 6, \n  * f(Y,Z)=4 because of 4 \u2192 3, 9 \u2192 3, 9 \u2192 7, 9 \u2192 8, \n  * f(Z,X)=7 because of 3 \u2192 1, 7 \u2192 1, 7 \u2192 5, 7 \u2192 6, 8 \u2192 1, 8 \u2192 5, 8 \u2192 6, \n  * f(Z,Y)=5 because of 3 \u2192 2, 7 \u2192 2, 7 \u2192 4, 8 \u2192 2, 8 \u2192 4. \n\n\n\nPlease, divide labs into n groups with size n, such that the value min f(A,B) over all possible pairs of groups A and B (A \u2260 B) is maximal.\n\nIn other words, divide labs into n groups with size n, such that minimum number of the sum of units of water that can be transported from a group A to a group B for every pair of different groups A and B (A \u2260 B) as big as possible.\n\nNote, that the example above doesn't demonstrate an optimal division, but it demonstrates how to calculate the values f for some division.\n\nIf there are many optimal divisions, you can find any.\n\nInput\n\nThe only line contains one number n (2 \u2264 n \u2264 300).\n\nOutput\n\nOutput n lines:\n\nIn the i-th line print n numbers, the numbers of labs of the i-th group, in any order you want.\n\nIf there are multiple answers, that maximize the minimum number of the sum of units of water that can be transported from one group the another, you can print any.\n\nExample\n\nInput\n\n\n3\n\n\nOutput\n\n\n2 8 5\n9 3 4\n7 6 1\n\nNote\n\nIn the first test we can divide 9 labs into groups \\{2, 8, 5\\}, \\{9, 3, 4\\}, \\{7, 6, 1\\}.\n\nFrom the first group to the second group we can transport 4 units of water (8 \u2192 3, 8 \u2192 4, 5 \u2192 3, 5 \u2192 4).\n\nFrom the first group to the third group we can transport 5 units of water (2 \u2192 1, 8 \u2192 7, 8 \u2192 6, 8 \u2192 1, 5 \u2192 1).\n\nFrom the second group to the first group we can transport 5 units of water (9 \u2192 2, 9 \u2192 8, 9 \u2192 5, 3 \u2192 2, 4 \u2192 2).\n\nFrom the second group to the third group we can transport 5 units of water (9 \u2192 7, 9 \u2192 6, 9 \u2192 1, 3 \u2192 1, 4 \u2192 1).\n\nFrom the third group to the first group we can transport 4 units of water (7 \u2192 2, 7 \u2192 5, 6 \u2192 2, 6 \u2192 5).\n\nFrom the third group to the second group we can transport 4 units of water (7 \u2192 3, 7 \u2192 4, 6 \u2192 3, 6 \u2192 4).\n\nThe minimal number of the sum of units of water, that can be transported from one group to another is equal to 4. It can be proved, that it is impossible to make a better division.",
        "task_name": "1236_C. Labs",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys,math,fractions,bisect\ndef fi():\n    return int(sys.stdin.readline())\n\ndef fi2():\n    return map(int, sys.stdin.readline().split())\n\ndef fi3():\n    return sys.stdin.readline()\n\ndef fo(*args):\n    for s in args:\n        sys.stdout.write(str(s)+' ')\n    sys.stdout.write('\\n')\nINF=2000000000\nMOD=10**9+7\nsys.setrecursionlimit(INF)\n\n#main\nn=fi()\nans=[[] for i in range(n)]\n\nx=1\nstart=0\nwhile x<=n**2:\n    for i in range(start,start+n):\n        ans[i%n].append(x)\n        x+=1\n    start+=1\nfor i in range(n):\n    for j in range(n):\n        ans[i][j]=str(ans[i][j])\nfor i in range(n):\n    fo(\" \".join(ans[i]))\n        \n        \n    \n    \n           \n\n                           \n                \n\n            \n        \n\n        \n        \n        \n    \n    \n    \n            \n\n\n\n\n    \n            \n\n\n    \n\n        \n    \n    \n        \n        \n        \n    \n    \n    \n            \n            \n            \n            \n    \n                \n    \n        \n    \n\n        \n        \n    \n\n\n    \n    \n            \n                \n            \n            \n        \n    \n    \n        \n    \n    \n    \n            \n\n    \n    \n\n\n\n    \n        \n            \n    \n        \n",
        "correct": false,
        "task_id": "0701",
        "depth": 2
    },
    {
        "description": "Tanya wants to go on a journey across the cities of Berland. There are n cities situated along the main railroad line of Berland, and these cities are numbered from 1 to n. \n\nTanya plans her journey as follows. First of all, she will choose some city c_1 to start her journey. She will visit it, and after that go to some other city c_2 > c_1, then to some other city c_3 > c_2, and so on, until she chooses to end her journey in some city c_k > c_{k - 1}. So, the sequence of visited cities [c_1, c_2, ..., c_k] should be strictly increasing.\n\nThere are some additional constraints on the sequence of cities Tanya visits. Each city i has a beauty value b_i associated with it. If there is only one city in Tanya's journey, these beauty values imply no additional constraints. But if there are multiple cities in the sequence, then for any pair of adjacent cities c_i and c_{i + 1}, the condition c_{i + 1} - c_i = b_{c_{i + 1}} - b_{c_i} must hold.\n\nFor example, if n = 8 and b = [3, 4, 4, 6, 6, 7, 8, 9], there are several three possible ways to plan a journey:\n\n  * c = [1, 2, 4]; \n  * c = [3, 5, 6, 8]; \n  * c = [7] (a journey consisting of one city is also valid). \n\n\n\nThere are some additional ways to plan a journey that are not listed above.\n\nTanya wants her journey to be as beautiful as possible. The beauty value of the whole journey is the sum of beauty values over all visited cities. Can you help her to choose the optimal plan, that is, to maximize the beauty value of the journey?\n\nInput\n\nThe first line contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of cities in Berland.\n\nThe second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 4 \u22c5 10^5), where b_i is the beauty value of the i-th city.\n\nOutput\n\nPrint one integer \u2014 the maximum beauty of a journey Tanya can choose.\n\nExamples\n\nInput\n\n\n6\n10 7 1 9 10 15\n\n\nOutput\n\n\n26\n\n\nInput\n\n\n1\n400000\n\n\nOutput\n\n\n400000\n\n\nInput\n\n\n7\n8 9 26 11 12 29 14\n\n\nOutput\n\n\n55\n\nNote\n\nThe optimal journey plan in the first example is c = [2, 4, 5].\n\nThe optimal journey plan in the second example is c = [1].\n\nThe optimal journey plan in the third example is c = [3, 6].",
        "task_name": "1321_B. Journey Planning",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nseq = sorted(((int(x)-i,int(x)) for i,x in enumerate(input().split())), key=lambda x:x[0])\nd = dict()\nans = 0\nansb = 0\nfor g,val in seq:\n    try:\n        d[abs(g)] += val\n    except:\n        d[abs(g)] = val\n    ans = max(ans, d[abs(g)])\n    ansb = max(val, ansb)\nif ans == 0:\n    ans = ansb\nprint(ans)\n",
        "correct": false,
        "task_id": "0703",
        "depth": 1
    },
    {
        "description": "Recently, the bear started studying data structures and faced the following problem.\n\nYou are given a sequence of integers x1, x2, ..., xn of length n and m queries, each of them is characterized by two integers li, ri. Let's introduce f(p) to represent the number of such indexes k, that xk is divisible by p. The answer to the query li, ri is the sum: <image>, where S(li, ri) is a set of prime numbers from segment [li, ri] (both borders are included in the segment).\n\nHelp the bear cope with the problem.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 106). The second line contains n integers x1, x2, ..., xn (2 \u2264 xi \u2264 107). The numbers are not necessarily distinct.\n\nThe third line contains integer m (1 \u2264 m \u2264 50000). Each of the following m lines contains a pair of space-separated integers, li and ri (2 \u2264 li \u2264 ri \u2264 2\u00b7109) \u2014 the numbers that characterize the current query.\n\nOutput\n\nPrint m integers \u2014 the answers to the queries on the order the queries appear in the input.\n\nExamples\n\nInput\n\n6\n5 5 7 10 14 15\n3\n2 11\n3 12\n4 4\n\n\nOutput\n\n9\n7\n0\n\n\nInput\n\n7\n2 3 5 7 11 4 8\n2\n8 10\n2 123\n\n\nOutput\n\n0\n7\n\nNote\n\nConsider the first sample. Overall, the first sample has 3 queries.\n\n  1. The first query l = 2, r = 11 comes. You need to count f(2) + f(3) + f(5) + f(7) + f(11) = 2 + 1 + 4 + 2 + 0 = 9. \n  2. The second query comes l = 3, r = 12. You need to count f(3) + f(5) + f(7) + f(11) = 1 + 4 + 2 + 0 = 7. \n  3. The third query comes l = 4, r = 4. As this interval has no prime numbers, then the sum equals 0. ",
        "task_name": "385_C. Bear and Prime Numbers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n# Author : raj1307 - Raj Singh\n# Date   : 13.03.2020\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\nfrom math import ceil,floor,log,sqrt,factorial\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey,reverse=True)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\ndef ncr(n,r): return factorial(n)//(factorial(r)*factorial(n-r))\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\nprime = [True for i in range(10000010)] \ndef SieveOfEratosthenes(n): \n      \n    p = 2\n    prime[1]=False\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n      \n\n\n\n\ndef main():\n        \n\n    #for _ in range(ii()):\n    \n    n=ii()\n    a=li()\n    p=[0]*(10000005)\n    SieveOfEratosthenes(10000005)\n    #print(prime[:10 ])\n    for i in range(n):\n\n        for j in range(1,int(sqrt(a[i]))+1):\n\n            if prime[j]==True: \n                if a[i]%j==0:\n                    p[j]+=1\n            if a[i]%j==0:\n                if prime[a[i]//j]==False: continue\n            \n                p[a[i]//j]+=1\n    #print(p[:20])\n    for i in range(1,10000005):\n        p[i]+=p[i-1]\n\n    q=ii()\n\n    for i in range(q):\n        l,r=mi()\n        print(p[r]-p[l-1])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": false,
        "task_id": "0714",
        "depth": 2
    },
    {
        "description": "Ryouko is an extremely forgetful girl, she could even forget something that has just happened. So in order to remember, she takes a notebook with her, called Ryouko's Memory Note. She writes what she sees and what she hears on the notebook, and the notebook became her memory.\n\nThough Ryouko is forgetful, she is also born with superb analyzing abilities. However, analyzing depends greatly on gathered information, in other words, memory. So she has to shuffle through her notebook whenever she needs to analyze, which is tough work.\n\nRyouko's notebook consists of n pages, numbered from 1 to n. To make life (and this problem) easier, we consider that to turn from page x to page y, |x - y| pages should be turned. During analyzing, Ryouko needs m pieces of information, the i-th piece of information is on page ai. Information must be read from the notebook in order, so the total number of pages that Ryouko needs to turn is <image>.\n\nRyouko wants to decrease the number of pages that need to be turned. In order to achieve this, she can merge two pages of her notebook. If Ryouko merges page x to page y, she would copy all the information on page x to y (1 \u2264 x, y \u2264 n), and consequently, all elements in sequence a that was x would become y. Note that x can be equal to y, in which case no changes take place.\n\nPlease tell Ryouko the minimum number of pages that she needs to turn. Note she can apply the described operation at most once before the reading. Note that the answer can exceed 32-bit integers.\n\nInput\n\nThe first line of input contains two integers n and m (1 \u2264 n, m \u2264 105).\n\nThe next line contains m integers separated by spaces: a1, a2, ..., am (1 \u2264 ai \u2264 n).\n\nOutput\n\nPrint a single integer \u2014 the minimum number of pages Ryouko needs to turn.\n\nExamples\n\nInput\n\n4 6\n1 2 3 4 3 2\n\n\nOutput\n\n3\n\n\nInput\n\n10 5\n9 4 3 8 8\n\n\nOutput\n\n6\n\nNote\n\nIn the first sample, the optimal solution is to merge page 4 to 3, after merging sequence a becomes {1, 2, 3, 3, 3, 2}, so the number of pages Ryouko needs to turn is |1 - 2| + |2 - 3| + |3 - 3| + |3 - 3| + |3 - 2| = 3.\n\nIn the second sample, optimal solution is achieved by merging page 9 to 4.",
        "task_name": "433_C. Ryouko's Memory Note",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Enter your code here. Read input from STDIN. Print output to STDOUT# ===============================================================================================\n# importing some useful libraries.\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom itertools import *\nimport bisect\nfrom heapq import *\nfrom math import ceil, floor\nfrom copy import *\nfrom collections import deque, defaultdict\nfrom collections import Counter as counter  # Counter(list)  return a dict with {key: count}\nfrom itertools import combinations  # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\nfrom itertools import permutations as permutate\nfrom bisect import bisect_left as bl\nfrom operator import *\n# If the element is already present in the list,\n\n# the left most position where element has to be inserted is returned.\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n# If the element is already present in the list,\n# the right most position where element has to be inserted is returned\n\n# ==============================================================================================\n# fast I/O region\n\nBUFSIZE = 8192\nfrom sys import stderr\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\n\n\ndef iterative(f, stack=[]):\n    def wrapped_func(*args, **kwargs):\n        if stack: return f(*args, **kwargs)\n        to = f(*args, **kwargs)\n        while True:\n            if type(to) is GeneratorType:\n                stack.append(to)\n                to = next(to)\n                continue\n            stack.pop()\n            if not stack: break\n            to = stack[-1].send(to)\n        return to\n\n    return wrapped_func\n\n\n#### END ITERATE RECURSION ####\n###########################\n# Sorted list\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\n\n# ===============================================================================================\n# some shortcuts\n\nmod = 1000000007\n\n\ndef testcase(t):\n    for p in range(t):\n        solve()\n\n\ndef pow(x, y, p):\n    res = 1  # Initialize result\n    x = x % p  # Update x if it is more , than or equal to p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):  # If y is odd, multiply, x with result\n            res = (res * x) % p\n\n        y = y >> 1  # y = y/2\n        x = (x * x) % p\n    return res\n\n\nfrom functools import reduce\n\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef gcd(a, b):\n    if a == b: return a\n    while b > 0: a, b = b, a % b\n    return a\n\n\n# discrete binary search\n# minimise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for i in range(200):\n#         if isvalid(l):\n#             return l\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m - 1):\n#             return m\n#         if isvalid(m):\n#             r = m + 1\n#         else:\n#             l = m\n#     return m\n\n# maximise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for i in range(200):\n#         # print(l,r)\n#         if isvalid(r):\n#             return r\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m + 1):\n#             return m\n#         if isvalid(m):\n#             l = m\n#         else:\n#             r = m - 1\n#     return m\n\n\n##############Find sum of product of subsets of size k in a array\n# ar=[0,1,2,3]\n# k=3\n# n=len(ar)-1\n# dp=[0]*(n+1)\n# dp[0]=1\n# for pos in range(1,n+1):\n#     dp[pos]=0\n#     l=max(1,k+pos-n-1)\n#     for j in range(min(pos,k),l-1,-1):\n#         dp[j]=dp[j]+ar[pos]*dp[j-1]\n# print(dp[k])\n\ndef prefix_sum(ar):  # [1,2,3,4]->[1,3,6,10]\n    return list(accumulate(ar))\n\n\ndef suffix_sum(ar):  # [1,2,3,4]->[10,9,7,4]\n    return list(accumulate(ar[::-1]))[::-1]\n\n\ndef N():\n    return int(inp())\n\n\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\n\ndef YES():\n    print(\"YES\")\n\n\ndef NO():\n    print(\"NO\")\n\n\ndef Yes():\n    print(\"Yes\")\n\n\ndef No():\n    print(\"No\")\n\n\n# =========================================================================================\nfrom collections import defaultdict\n\n\ndef numberOfSetBits(i):\n    i = i - ((i >> 1) & 0x55555555)\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        # self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        # self.lista[a] += self.lista[b]\n        # self.lista[b] = []\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef lcm(a, b):\n    return abs((a // gcd(a, b)) * b)\n\n\n# #\n# to find factorial and ncr\n# tot = 100005\n# mod = 10**9 + 7\n# fac = [1, 1]\n# finv = [1, 1]\n# inv = [0, 1]\n#\n# for i in range(2, tot + 1):\n#     fac.append((fac[-1] * i) % mod)\n#     inv.append(mod - (inv[mod % i] * (mod // i) % mod))\n#     finv.append(finv[-1] * inv[-1] % mod)\n\n\ndef comb(n, r):\n    if n < r:\n        return 0\n    else:\n        return fac[n] * (finv[r] * finv[n - r] % mod) % mod\n\n\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\")  # for fast input\n\n\ndef out(var): sys.stdout.write(str(var))  # for fast output, always take string\n\n\ndef lis(): return list(map(int, inp().split()))\n\n\ndef stringlis(): return list(map(str, inp().split()))\n\n\ndef sep(): return map(int, inp().split())\n\n\ndef strsep(): return map(str, inp().split())\n\n\ndef fsep(): return map(float, inp().split())\n\n\ndef nextline(): out(\"\\n\")  # as stdout.write always print sring.\n\n\ndef arr1d(n, v):\n    return [v] * n\n\n\ndef arr2d(n, m, v):\n    return [[v] * m for _ in range(n)]\n\n\ndef arr3d(n, m, p, v):\n    return [[[v] * p for _ in range(m)] for i in range(n)]\n\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\n\n# co-ordinate compression\n# ma={s:idx for idx,s in enumerate(sorted(set(l+r)))}\n\n# mxn=100005\n# lrg=[0]*mxn\n# for i in range(2,mxn-3):\n#     if (lrg[i]==0):\n#         for j in range(i,mxn-3,i):\n#             lrg[j]=i\n\n\ndef solve():\n    n,m=sep()\n    ar=lis()\n    adj=[[] for _ in range(n+1)]\n    for i in range(m):\n        if(i-1>=0):\n            if(ar[i]!=ar[i-1]):\n                adj[ar[i]].append(ar[i-1])\n        if (i + 1 < m):\n            if (ar[i] != ar[i + 1]):\n                adj[ar[i]].append(ar[i + 1])\n    totscore=0\n    for i in range(1,m):\n        totscore+=abs(ar[i]-ar[i-1])\n    redscore=0\n    for i in range(1,n+1):\n        adj[i].sort()\n        curscore=0\n        l=(len(adj[i]))\n        if l==0:continue\n\n        med=adj[i][(l)//2]\n        besscore=0\n        for j in adj[i]:\n            curscore+=abs(i-j)\n            besscore+=abs(med-j)\n        redscore=max(redscore,curscore-besscore)\n\n    print(min(totscore-redscore,totscore))\n\n\n\n\n\n\nsolve()\n# testcase(int(inp()))\n",
        "correct": true,
        "task_id": "0716",
        "depth": 2
    },
    {
        "description": "A sweet little monster Om Nom loves candies very much. One day he found himself in a rather tricky situation that required him to think a bit in order to enjoy candies the most. Would you succeed with the same task if you were on his place?\n\n<image>\n\nOne day, when he came to his friend Evan, Om Nom didn't find him at home but he found two bags with candies. The first was full of blue candies and the second bag was full of red candies. Om Nom knows that each red candy weighs Wr grams and each blue candy weighs Wb grams. Eating a single red candy gives Om Nom Hr joy units and eating a single blue candy gives Om Nom Hb joy units.\n\nCandies are the most important thing in the world, but on the other hand overeating is not good. Om Nom knows if he eats more than C grams of candies, he will get sick. Om Nom thinks that it isn't proper to leave candy leftovers, so he can only eat a whole candy. Om Nom is a great mathematician and he quickly determined how many candies of what type he should eat in order to get the maximum number of joy units. Can you repeat his achievement? You can assume that each bag contains more candies that Om Nom can eat.\n\nInput\n\nThe single line contains five integers C, Hr, Hb, Wr, Wb (1 \u2264 C, Hr, Hb, Wr, Wb \u2264 109).\n\nOutput\n\nPrint a single integer \u2014 the maximum number of joy units that Om Nom can get.\n\nExamples\n\nInput\n\n10 3 5 2 3\n\n\nOutput\n\n16\n\nNote\n\nIn the sample test Om Nom can eat two candies of each type and thus get 16 joy units.",
        "task_name": "526_C. Om Nom and Candies",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nfrom fractions import gcd\n\nc, h1, h2, w1, w2 = (int (t) for t in sys.stdin.readline().split())\ng = gcd (w1, w2)\nc /= g\nw1 /= g\nw2 /= g\n\nres = 0\nif c <= 10 ** 5 * w1:\n  for i in range (c/w1 + 1):\n    if res < i * h1 + (c - i*w1) / w2 * h2:\n      res = i * h1 + (c - i*w1) / w2 * h2\nelif c <= 10 ** 5 * w2:\n  for i in range (c/w2 + 1):\n    if res < i * h2 + (c - i*w2) / w1 * h1:\n      res = i * h2 + (c - i*w2) / w1 * h1\nelse:\n  if h1 * w2 < h2 * w1:\n    h1, h2 = h2, h1\n    w1, w2 = w2, w1\n  for i in range (10 ** 5):\n    if res < i * h2 + (c - i*w2) / w1 * h1:\n      res = i * h2 + (c - i*w2) / w1 * h1\n\nprint (res)\n\n    ",
        "correct": true,
        "task_id": "0718",
        "depth": 1
    },
    {
        "description": "We have a rectangular grid of squares with H horizontal rows and W vertical columns. Let (i,j) denote the square at the i-th row from the top and the j-th column from the left. On this grid, there is a piece, which is initially placed at square (s_r,s_c).\n\nTakahashi and Aoki will play a game, where each player has a string of length N. Takahashi's string is S, and Aoki's string is T. S and T both consist of four kinds of letters: `L`, `R`, `U` and `D`.\n\nThe game consists of N steps. The i-th step proceeds as follows:\n\n* First, Takahashi performs a move. He either moves the piece in the direction of S_i, or does not move the piece.\n* Second, Aoki performs a move. He either moves the piece in the direction of T_i, or does not move the piece.\n\n\n\nHere, to move the piece in the direction of `L`, `R`, `U` and `D`, is to move the piece from square (r,c) to square (r,c-1), (r,c+1), (r-1,c) and (r+1,c), respectively. If the destination square does not exist, the piece is removed from the grid, and the game ends, even if less than N steps are done.\n\nTakahashi wants to remove the piece from the grid in one of the N steps. Aoki, on the other hand, wants to finish the N steps with the piece remaining on the grid. Determine if the piece will remain on the grid at the end of the game when both players play optimally.\n\nConstraints\n\n* 2 \\leq H,W \\leq 2 \\times 10^5\n* 2 \\leq N \\leq 2 \\times 10^5\n* 1 \\leq s_r \\leq H\n* 1 \\leq s_c \\leq W\n* |S|=|T|=N\n* S and T consists of the four kinds of letters `L`, `R`, `U` and `D`.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nH W N\ns_r s_c\nS\nT\n\n\nOutput\n\nIf the piece will remain on the grid at the end of the game, print `YES`; otherwise, print `NO`.\n\nExamples\n\nInput\n\n2 3 3\n2 2\nRRL\nLUD\n\n\nOutput\n\nYES\n\n\nInput\n\n4 3 5\n2 2\nUDRRR\nLLDUD\n\n\nOutput\n\nNO\n\n\nInput\n\n5 6 11\n2 1\nRLDRRUDDLRL\nURRDRLLDLRD\n\n\nOutput\n\nNO",
        "task_name": "p03054 AtCoder Grand Contest 033 - LRUD Game",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "H,W,N = map(int, raw_input().split())\nsr,sc = map(int, raw_input().split())\nS = raw_input()\nT = raw_input()\nAO = [1,W,1,H]\nflag = 0\nfor i in reversed(range(N)):\n\tif(i != N-1):\n\t\tif(T[i] == 'L'):\n\t\t\tAO[1] = min(W,AO[1]+1)\n\t\telif(T[i] == 'R'):\n\t\t\tAO[0] = max(1,AO[0]-1)\n\t\telif(T[i] == 'U'):\n\t\t\tAO[3] = min(H,AO[3]+1)\n\t\telif(T[i] == 'D'):\n\t\t\tAO[2] = max(1,AO[2]-1)\n\tif(S[i] == 'L'):\n\t\tAO[0] += 1\n\telif(S[i] == 'R'):\n\t\tAO[1] -= 1\n\telif(S[i] == 'U'):\n\t\tAO[2] += 1\n\telif(S[i] == 'D'):\n\t\tAO[3] -= 1\n\tif(AO[0] > AO[1] or AO[2] > AO[3]):\n\t\tflag = 1\n\t\tbreak\nif(AO[0] > sc or AO[1] < sc or AO[2] > sr or AO[3] < sr):\n\tflag = 1\nif(flag == 0):\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")",
        "correct": true,
        "task_id": "0731",
        "depth": 1
    },
    {
        "description": "There are N squares in a row. The leftmost square contains the integer A, and the rightmost contains the integer B. The other squares are empty.\n\nAohashi would like to fill the empty squares with integers so that the following condition is satisfied:\n\n* For any two adjacent squares, the (absolute) difference of the two integers in those squares is between C and D (inclusive).\n\n\n\nAs long as the condition is satisfied, it is allowed to use arbitrarily large or small integers to fill the squares. Determine whether it is possible to fill the squares under the condition.\n\nConstraints\n\n* 3 \\leq N \\leq 500000\n* 0 \\leq A \\leq 10^9\n* 0 \\leq B \\leq 10^9\n* 0 \\leq C \\leq D \\leq 10^9\n* All input values are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN A B C D\n\n\nOutput\n\nPrint `YES` if it is possible to fill the squares under the condition; print `NO` otherwise.\n\nExamples\n\nInput\n\n5 1 5 2 4\n\n\nOutput\n\nYES\n\n\nInput\n\n4 7 6 4 5\n\n\nOutput\n\nNO\n\n\nInput\n\n48792 105960835 681218449 90629745 90632170\n\n\nOutput\n\nNO\n\n\nInput\n\n491995 412925347 825318103 59999126 59999339\n\n\nOutput\n\nYES",
        "task_name": "p03666 AtCoder Grand Contest 017 - Moderate Differences",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, a, b, c, d = map(int, raw_input().split())\ndd = b - a\nif dd < 0:\n  dd = -dd\n\ndef get(n, c, d):\n  l = -1\n  r = n\n  while l + 1 < r:\n    mid = (l + r) / 2\n    if mid * c - (n - mid) * d >= 0:\n      r = mid\n    else:\n      l = mid\n  return r\n\nl = get(n, c, d)\n\nok = False\nfor i in range(l, n + 1):\n  ll = i * c - (n - i) * d\n  rr = i * d - (n - i) * c\n  if ll <= dd and rr >= dd:\n    ok = True\n  if ll > dd:\n    break\n\nif ok:\n  print('YES')\nelse:\n  print('NO')\n",
        "correct": false,
        "task_id": "0734",
        "depth": 1
    },
    {
        "description": "Aoki loves numerical sequences and trees.\n\nOne day, Takahashi gave him an integer sequence of length N, a_1, a_2, ..., a_N, which made him want to construct a tree.\n\nAoki wants to construct a tree with N vertices numbered 1 through N, such that for each i = 1,2,...,N, the distance between vertex i and the farthest vertex from it is a_i, assuming that the length of each edge is 1.\n\nDetermine whether such a tree exists.\n\nConstraints\n\n* 2 \u2266 N \u2266 100\n* 1 \u2266 a_i \u2266 N-1\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN\na_1 a_2 ... a_N\n\n\nOutput\n\nIf there exists a tree that satisfies the condition, print `Possible`. Otherwise, print `Impossible`.\n\nExamples\n\nInput\n\n5\n3 2 2 3 3\n\n\nOutput\n\nPossible\n\n\nInput\n\n3\n1 1 2\n\n\nOutput\n\nImpossible\n\n\nInput\n\n10\n1 2 2 2 2 2 2 2 2 2\n\n\nOutput\n\nPossible\n\n\nInput\n\n10\n1 1 2 2 2 2 2 2 2 2\n\n\nOutput\n\nImpossible\n\n\nInput\n\n6\n1 1 1 1 1 5\n\n\nOutput\n\nImpossible\n\n\nInput\n\n5\n4 3 2 3 4\n\n\nOutput\n\nPossible",
        "task_name": "p03988 AtCoder Grand Contest 005 - Tree Restoring",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n=int(raw_input())\na=map(int,raw_input().split())\nmaxa=max(a)\ncmaxa=a.count(maxa)\nca=[0]*(maxa+1)\nfor i in xrange(n):\n    ca[a[i]]+=1\nif maxa%2==1:\n    l=maxa/2+1\n    if a.count(l)==2:\n        for i in xrange(n):\n            if a[i]<l:\n                print(\"Impossible\")\n                exit()\n        for i in xrange(l+1,maxa+1):\n            if ca[i]<2:\n                print(\"Impossible\")\n                exit()\n        print(\"Possible\")\n    else:\n        print(\"Impossible\")\nelse:\n    l=maxa/2\n    if a.count(l)==1:\n        for i in xrange(n):\n            if a[i]<l:\n                print(\"Impossible\")\n                exit()\n        for i in xrange(l+1,maxa+1):\n            if ca[i]<2:\n                print(\"Impossible\")\n                exit()\n        print(\"Possible\")\n    else:\n        print(\"Impossible\")",
        "correct": true,
        "task_id": "0736",
        "depth": 1
    },
    {
        "description": "Alice and Bob are playing a game on a line with n cells. There are n cells labeled from 1 through n. For each i from 1 to n-1, cells i and i+1 are adjacent.\n\nAlice initially has a token on some cell on the line, and Bob tries to guess where it is. \n\nBob guesses a sequence of line cell numbers x_1, x_2, \u2026, x_k in order. In the i-th question, Bob asks Alice if her token is currently on cell x_i. That is, Alice can answer either \"YES\" or \"NO\" to each Bob's question.\n\nAt most one time in this process, before or after answering a question, Alice is allowed to move her token from her current cell to some adjacent cell. Alice acted in such a way that she was able to answer \"NO\" to all of Bob's questions.\n\nNote that Alice can even move her token before answering the first question or after answering the last question. Alice can also choose to not move at all.\n\nYou are given n and Bob's questions x_1, \u2026, x_k. You would like to count the number of scenarios that let Alice answer \"NO\" to all of Bob's questions. \n\nLet (a,b) denote a scenario where Alice starts at cell a and ends at cell b. Two scenarios (a_i, b_i) and (a_j, b_j) are different if a_i \u2260 a_j or b_i \u2260 b_j.\n\nInput\n\nThe first line contains two integers n and k (1 \u2264 n,k \u2264 10^5) \u2014 the number of cells and the number of questions Bob asked.\n\nThe second line contains k integers x_1, x_2, \u2026, x_k (1 \u2264 x_i \u2264 n) \u2014 Bob's questions.\n\nOutput\n\nPrint a single integer, the number of scenarios that let Alice answer \"NO\" to all of Bob's questions.\n\nExamples\n\nInput\n\n\n5 3\n5 1 4\n\n\nOutput\n\n\n9\n\n\nInput\n\n\n4 8\n1 2 3 4 4 3 2 1\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n100000 1\n42\n\n\nOutput\n\n\n299997\n\nNote\n\nThe notation (i,j) denotes a scenario where Alice starts at cell i and ends at cell j.\n\nIn the first example, the valid scenarios are (1, 2), (2, 1), (2, 2), (2, 3), (3, 2), (3, 3), (3, 4), (4, 3), (4, 5). For example, (3,4) is valid since Alice can start at cell 3, stay there for the first three questions, then move to cell 4 after the last question. \n\n(4,5) is valid since Alice can start at cell 4, stay there for the first question, the move to cell 5 for the next two questions. Note that (4,5) is only counted once, even though there are different questions that Alice can choose to do the move, but remember, we only count each pair of starting and ending positions once.\n\nIn the second example, Alice has no valid scenarios.\n\nIn the last example, all (i,j) where |i-j| \u2264 1 except for (42, 42) are valid scenarios.",
        "task_name": "1147_A. Hide and Seek",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\"\"\"<https://github.com/cheran-senthil/PyRival>\"\"\"\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    _str = str\n    str = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\n\n\ndef main():\n    n, k = readlist()\n    x = readlist()\n\n    counter = [(-1, -1)] * (n + 1)\n    for i, xi in enumerate(x):\n        if counter[xi][0] == -1:\n            counter[xi] = (i, -1)\n        else:\n            counter[xi] = (counter[xi][0], i)\n\n    res = 0\n    for i in range(1, n + 1):\n        if counter[i][0] == -1:\n            res += 1\n\n    for i in range(1, n):\n        if counter[i][0] != -1:\n            if counter[i][1] != -1:\n                if counter[i + 1][0] == -1 or counter[i + 1][0] > counter[i][1]:\n                    res += 1\n            else:\n                if counter[i + 1][0] == -1 or counter[i + 1][0] > counter[i][0]:\n                    res += 1\n        else:\n            res += 1\n\n    for i in range(1, n):\n        if counter[i + 1][0] != -1:\n            if counter[i + 1][1] != -1:\n                if counter[i][0] == -1 or counter[i][0] > counter[i + 1][1]:\n                    res += 1\n            else:\n                if counter[i][0] == -1 or counter[i][0] > counter[i + 1][0]:\n                    res += 1\n        else:\n            res += 1\n\n    print(res)\n\n\n# region template\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._buffer = BytesIO()\n        self._fd = file.fileno()\n        self._writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self._buffer.write if self._writable else None\n\n    def read(self):\n        if self._buffer.tell():\n            return self._buffer.read()\n        return os.read(self._fd, os.fstat(self._fd).st_size)\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n    def flush(self):\n        if self._writable:\n            os.write(self._fd, self._buffer.getvalue())\n            self._buffer.truncate(0), self._buffer.seek(0)\n\n\nclass ostream:\n    def __lshift__(self, a):\n        if a is endl:\n            sys.stdout.write(b\"\\n\")\n            sys.stdout.flush()\n        else:\n            sys.stdout.write(str(a))\n        return self\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", b\" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", b\"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\ncout, endl = ostream(), object()\n\nreadline = sys.stdin.readline\nreadlist = lambda var=int: [var(n) for n in readline().split()]\ninput = lambda: readline().rstrip(b\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "0740",
        "depth": 1
    },
    {
        "description": "    per nextum in unam tum XI conscribementis fac sic  \n        vestibulo perlegementum da varo.  \n        morde varo.  \n        seqis cumula varum.  \n    cis  \n      \n    per nextum in unam tum XI conscribementis fac sic  \n        seqis decumulamenta da varo.  \n        varum privamentum fodementum da aresulto.  \n        varum tum III elevamentum tum V multiplicamentum da bresulto.  \n        aresultum tum bresultum addementum da resulto.  \n      \n        si CD tum resultum non praestantiam fac sic  \n            dictum sic f(%d) = %.2f cis tum varum tum resultum egresso describe.  \n            novumversum egresso scribe.  \n        cis  \n        si CD tum resultum praestantiam fac sic  \n            dictum sic f(%d) = MAGNA NIMIS! cis tum varum egresso describe.  \n            novumversum egresso scribe.          \n        cis  \n    cis  \n    \n\nInput\n\nThe input consists of several integers, one per line. Each integer is between -50 and 50, inclusive.\n\nOutput\n\nAs described in the problem statement.\n\nExample\n\nInput\n\n\n0\n1\n-2\n-3\n-4\n-5\n-6\n-7\n-8\n-9\n10\n\n\nOutput\n\n\nf(10) = MAGNA NIMIS!\nf(-9) = -3642.00\nf(-8) = -2557.17\nf(-7) = -1712.35\nf(-6) = -1077.55\nf(-5) = -622.76\nf(-4) = -318.00\nf(-3) = -133.27\nf(-2) = -38.59\nf(1) = 6.00\nf(0) = 0.00",
        "task_name": "1331_G. Lingua Romana",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "f = []\nfor i in range(11):\n    f.append(int(raw_input()))\n\nfrom math import *\n\nf.reverse()\nfor x in f:\n    y = abs(x)\n    z = sqrt(y) + x ** 3 * 5\n    if (z < 400):\n        print(\"f(%d) = %.2f\" % (x, z))\n    else:\n        print(\"f(%d) = MAGNA NIMIS!\" % (x))",
        "correct": true,
        "task_id": "0745",
        "depth": 1
    },
    {
        "description": "Bob has a string s consisting of lowercase English letters. He defines s' to be the string after removing all \"a\" characters from s (keeping all other characters in the same order). He then generates a new string t by concatenating s and s'. In other words, t=s+s' (look at notes for an example).\n\nYou are given a string t. Your task is to find some s that Bob could have used to generate t. It can be shown that if an answer exists, it will be unique.\n\nInput\n\nThe first line of input contains a string t (1 \u2264 |t| \u2264 10^5) consisting of lowercase English letters.\n\nOutput\n\nPrint a string s that could have generated t. It can be shown if an answer exists, it is unique. If no string exists, print \":(\" (without double quotes, there is no space between the characters).\n\nExamples\n\nInput\n\n\naaaaa\n\n\nOutput\n\n\naaaaa\n\n\nInput\n\n\naacaababc\n\n\nOutput\n\n\n:(\n\n\nInput\n\n\nababacacbbcc\n\n\nOutput\n\n\nababacac\n\n\nInput\n\n\nbaba\n\n\nOutput\n\n\n:(\n\nNote\n\nIn the first example, we have s =  \"aaaaa\", and s' =  \"\".\n\nIn the second example, no such s can work that will generate the given t.\n\nIn the third example, we have s =  \"ababacac\", and s' =  \"bbcc\", and t = s + s' =  \"ababacacbbcc\".",
        "task_name": "1146_B. Hate \"A\"",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"\nAuthor    : raj1307 - Raj Singh\nInstitute : Jalpaiguri Government Engineering College\nDate      : 20.04.19\n\"\"\"\nfrom __future__ import division, print_function\nimport itertools,os,sys\nfrom collections import deque, Counter, OrderedDict, defaultdict\n#from heapq import nsmallest, nlargest, heapify, #heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial,pow,pi\n#from bisect import bisect_left,bisect_right\n#from decimal import *\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    from builtins import str as __str__\n    str = lambda x=b'': x if type(x) is bytes else __str__(x).encode()\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._buffer = BytesIO()\n        self._fd = file.fileno()\n        self._writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self._buffer.write if self._writable else None\n\n    def read(self):\n        return self._buffer.read() if self._buffer.tell() else os.read(self._fd, os.fstat(self._fd).st_size)\n\n    def readline(self):\n        while self.newlines == 0:\n            b, ptr = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)), self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n            self.newlines += b.count(b'\\n') + (not b)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n    def flush(self):\n        if self._writable:\n            os.write(self._fd, self._buffer.getvalue())\n            self._buffer.truncate(0), self._buffer.seek(0)\n\n\nsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(b'\\r\\n')\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop('end', b'\\n'))\n    if kwargs.pop('flush', False):\n        file.flush()\n\n\n\n\n\ndef ii(): return int(input())\ndef si(): return str(input())\ndef mi():return map(int,input().strip().split(\" \"))\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef ntl(n):return [int(i) for i in str(n)]\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p1\n    return res\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# For getting input from input.txt file \n#sys.stdin = open('input.txt', 'r')  \n  \n# Printing the Output to output.txt file \n#sys.stdout = open('output.txt', 'w') \n\n\ndef main():\n   \n    s=si()\n    s=list(s)\n    l=[]\n    n=len(s)\n    flag=0\n    a,x=0,0\n    if s.count('a')==n:\n        print(''.join(s))\n        exit()\n    \n    for i in range(len(s)):\n        if s[i]!='a':\n            x+=1\n            l.append(s[i])\n            if x+i+1==n:\n               if s[:i+1]+l==s:\n                   print(''.join(s[:i+1]))\n                   flag=1\n                   exit()\n               \n                \n        else:\n            a+=1\n            \n    \n    print(':(')            \n            \n                \n        \n        \n    \n\n   \n   \n   \n   \n   \n\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": "0772",
        "depth": 1
    },
    {
        "description": "Slime has a sequence of positive integers a_1, a_2, \u2026, a_n.\n\nIn one operation Orac can choose an arbitrary subsegment [l \u2026 r] of this sequence and replace all values a_l, a_{l + 1}, \u2026, a_r to the value of median of \\\\{a_l, a_{l + 1}, \u2026, a_r\\}.\n\nIn this problem, for the integer multiset s, the median of s is equal to the \u230a (|s|+1)/(2)\u230b-th smallest number in it. For example, the median of \\{1,4,4,6,5\\} is 4, and the median of \\{1,7,5,8\\} is 5.\n\nSlime wants Orac to make a_1 = a_2 = \u2026 = a_n = k using these operations.\n\nOrac thinks that it is impossible, and he does not want to waste his time, so he decided to ask you if it is possible to satisfy the Slime's requirement, he may ask you these questions several times.\n\nInput\n\nThe first line of the input is a single integer t: the number of queries.\n\nThe first line of each query contains two integers n\\ (1\u2264 n\u2264 100 000) and k\\ (1\u2264 k\u2264 10^9), the second line contains n positive integers a_1,a_2,...,a_n\\ (1\u2264 a_i\u2264 10^9)\n\nThe total sum of n is at most 100 000.\n\nOutput\n\nThe output should contain t lines. The i-th line should be equal to 'yes' if it is possible to make all integers k in some number of operations or 'no', otherwise. You can print each letter in lowercase or uppercase.\n\nExample\n\nInput\n\n\n5\n5 3\n1 5 2 6 1\n1 6\n6\n3 2\n1 2 3\n4 3\n3 1 2 3\n10 3\n1 2 3 4 5 6 7 8 9 10\n\n\nOutput\n\n\nno\nyes\nyes\nno\nyes\n\nNote\n\nIn the first query, Orac can't turn all elements into 3.\n\nIn the second query, a_1=6 is already satisfied.\n\nIn the third query, Orac can select the complete array and turn all elements into 2.\n\nIn the fourth query, Orac can't turn all elements into 3.\n\nIn the fifth query, Orac can select [1,6] at first and then select [2,10].",
        "task_name": "1350_D. Orac and Medians",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"Template for Python Competitive Programmers prepared by pa.n.ik, kabeer seth and Mayank Chaudhary \"\"\"\n\n# to use the print and division function of Python3\nfrom __future__ import division, print_function\n\n\"\"\"value of mod\"\"\"\nMOD = 998244353\nmod = 10**9 + 7\n\n\"\"\"use resource\"\"\"\n# import resource\n# resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n\n\"\"\"for factorial\"\"\"\n\ndef prepare_factorial():\n    fact = [1]\n    for i in range(1, 5005):\n        fact.append((fact[-1] * i) % mod)\n    ifact = [0] * 5005\n    ifact[5004] = pow(fact[5004], mod - 2, mod)\n    for i in range(5004, 0, -1):\n        ifact[i - 1] = (i * ifact[i]) % mod\n\n    return fact, ifact\n\n\"\"\"uncomment next 4 lines while doing recursion based question\"\"\"\n# import threading\n# threading.stack_size(1<<27)\nimport sys\n# sys.setrecursionlimit(10000)\n\n\n\"\"\"uncomment modules according to your need\"\"\"\nfrom bisect import bisect_left, bisect_right, insort\n# from itertools import repeat\nfrom math import floor, ceil, sqrt, degrees, atan, pi, log, sin, radians\nfrom heapq import heappop, heapify, heappush\n# from random import randint as rn\n# from Queue import Queue as Q\nfrom collections import Counter, defaultdict, deque\n# from copy import deepcopy\n# from decimal import *\n\n\ndef modinv(n, p):\n    return pow(n, p - 2, p)\n\ndef ncr(n, r,  fact, ifact):    # for using this uncomment the lines calculating fact and ifact\n    t = (fact[n] * (ifact[r]*ifact[n-r]) % mod)% mod\n    return t\n\n\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\n\n\"\"\"*****************************************************************************************\"\"\"\n\ndef GCD(x, y):\n    while (y):\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x*y)//(GCD(x, y))\n\ndef get_xor(n):\n    return [n,1,n+1,0][n%4]\n\ndef bin_pow(a, b):\n    res = 1\n    while b:\n        if b&1:\n            res = (res * a)\n            b -= 1\n        else:\n            a = (a* a)\n            b>>=1\n    return res\n\n\"\"\" ********************************************************************************************* \"\"\"\n\ndef main():\n\n    t = int(input())\n    while t:\n        n, k = get_ints()\n        Arr = get_array() + [0, 0, 0]\n        flag1 = flag2 = 0\n\n        if n == 1:\n            if Arr[0] == k:\n                print('yes')\n            else:\n                print('no')\n            t -= 1\n            continue\n\n        for i in range(n):\n            if Arr[i] == k:\n                flag1 = 1\n            if Arr[i] >= k:\n                if Arr[i+1] >=k or Arr[i+2] >= k:\n                    flag2 = 1\n\n        if flag1 and flag2:\n            print('yes')\n        else:\n            print('no')\n\n        t -= 1\n\n\"\"\" -------- Python 2 and 3 footer by Pajenegod and c1729 ---------\"\"\"\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill();\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode('ascii'))\n            self.read = lambda: self.buffer.read().decode('ascii')\n            self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\n\"\"\" main function\"\"\"\n\nif __name__ == '__main__':\n    main()\n    # threading.Thread(target=main).start()",
        "correct": true,
        "task_id": "0780",
        "depth": 2
    },
    {
        "description": "Pinkie Pie has bought a bag of patty-cakes with different fillings! But it appeared that not all patty-cakes differ from one another with filling. In other words, the bag contains some patty-cakes with the same filling.\n\nPinkie Pie eats the patty-cakes one-by-one. She likes having fun so she decided not to simply eat the patty-cakes but to try not to eat the patty-cakes with the same filling way too often. To achieve this she wants the minimum distance between the eaten with the same filling to be the largest possible. Herein Pinkie Pie called the distance between two patty-cakes the number of eaten patty-cakes strictly between them.\n\nPinkie Pie can eat the patty-cakes in any order. She is impatient about eating all the patty-cakes up so she asks you to help her to count the greatest minimum distance between the eaten patty-cakes with the same filling amongst all possible orders of eating!\n\nPinkie Pie is going to buy more bags of patty-cakes so she asks you to solve this problem for several bags!\n\nInput\n\nThe first line contains a single integer T (1 \u2264 T \u2264 100): the number of bags for which you need to solve the problem.\n\nThe first line of each bag description contains a single integer n (2 \u2264 n \u2264 10^5): the number of patty-cakes in it. The second line of the bag description contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n): the information of patty-cakes' fillings: same fillings are defined as same integers, different fillings are defined as different integers. It is guaranteed that each bag contains at least two patty-cakes with the same filling. \n\nIt is guaranteed that the sum of n over all bags does not exceed 10^5.\n\nOutput\n\nFor each bag print in separate line one single integer: the largest minimum distance between the eaten patty-cakes with the same filling amongst all possible orders of eating for that bag.\n\nExample\n\nInput\n\n\n4\n7\n1 7 1 6 4 4 6\n8\n1 1 4 6 4 6 4 7\n3\n3 3 3\n6\n2 5 2 3 1 4\n\n\nOutput\n\n\n3\n2\n0\n4\n\nNote\n\nFor the first bag Pinkie Pie can eat the patty-cakes in the following order (by fillings): 1, 6, 4, 7, 1, 6, 4 (in this way, the minimum distance is equal to 3).\n\nFor the second bag Pinkie Pie can eat the patty-cakes in the following order (by fillings): 1, 4, 6, 7, 4, 1, 6, 4 (in this way, the minimum distance is equal to 2).",
        "task_name": "1393_C. Pinkie Pie Eats Patty-cakes",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"\n// Author : snape_here - Susanta Mukherjee\n     \n \"\"\"\n \nfrom __future__ import division, print_function\n \nimport os,sys\nfrom io import BytesIO, IOBase\n \nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n \ndef ii(): return int(input())\ndef fi(): return float(input())\ndef si(): return input()\ndef msi(): return map(str,input().split())\ndef mi(): return map(int,input().split())\ndef li(): return list(mi())\n \n \ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n \ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x*y)//(gcd(x,y))\n\nmod=1000000007 \n\ndef modInverse(b,m): \n    g = gcd(b, m)  \n    if (g != 1):         \n        return -1\n    else:          \n        return pow(b, m - 2, m) \n\ndef modu(a,b,m): \n\n    a = a % m \n    inv = modInverse(b,m) \n    if(inv == -1): \n        return -999999999\n    else: \n        return (inv*a)%m\n\nfrom math import log,sqrt,factorial,cos,tan,sin,radians,ceil,floor\n\nimport bisect\n\nfrom decimal import *\n\ngetcontext().prec = 25\n\nabc=\"abcdefghijklmnopqrstuvwxyz\"\n\npi=3.141592653589793238\n\ndef main():\n\n    for _ in range(ii()):\n        n=ii()\n        a=li()\n        a.sort(reverse=True)\n        f=[0]*100005\n        for i in range(n):\n            f[a[i]]+=1 \n        s=0\n        s=max(f)\n\n        if s==n:\n            print(0)\n            continue\n\n        if f.count(1)==n-s:\n            if s==2:\n                ans=n-s\n            else:\n                ans=(n-1)//(s+1)\n                ans+=1\n            print(ans)\n            continue\n\n        ans=(n-1)//(s+1)\n        ans+=1 \n        print(ans)\n\n\n\n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \n \nif __name__ == \"__main__\":\n    #read()\n    main()",
        "correct": false,
        "task_id": "0781",
        "depth": 2
    },
    {
        "description": "Eugeny has array a = a1, a2, ..., an, consisting of n integers. Each integer ai equals to -1, or to 1. Also, he has m queries:\n\n  * Query number i is given as a pair of integers li, ri (1 \u2264 li \u2264 ri \u2264 n). \n  * The response to the query will be integer 1, if the elements of array a can be rearranged so as the sum ali + ali + 1 + ... + ari = 0, otherwise the response to the query will be integer 0. \n\n\n\nHelp Eugeny, answer all his queries.\n\nInput\n\nThe first line contains integers n and m (1 \u2264 n, m \u2264 2\u00b7105). The second line contains n integers a1, a2, ..., an (ai = -1, 1). Next m lines contain Eugene's queries. The i-th line contains integers li, ri (1 \u2264 li \u2264 ri \u2264 n).\n\nOutput\n\nPrint m integers \u2014 the responses to Eugene's queries in the order they occur in the input.\n\nExamples\n\nInput\n\n2 3\n1 -1\n1 1\n1 2\n2 2\n\n\nOutput\n\n0\n1\n0\n\n\nInput\n\n5 5\n-1 1 1 1 -1\n1 1\n2 3\n3 5\n2 5\n1 5\n\n\nOutput\n\n0\n1\n0\n1\n0",
        "task_name": "302_A. Eugeny and Array",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\nimport sys\n\nline = raw_input()\nn,m = line.split()\nn = int(n)\nm = int(m)\n\nline = raw_input()\nnr_minus = line.count('-')\nminimum = min(nr_minus, n-nr_minus)\n\nfor i in xrange(m):  \n  line = raw_input()\n  l,r = line.split()\n  l = int(l)\n  r = int(r)\n \n  length = r - l + 1;\n    \n  if ((length % 2) == 0):\n    length = length / 2;\n    if (length <= minimum):\n      print(1)\n    else:\n      print(0)\n  else:\n    print(0)\n           \n",
        "correct": true,
        "task_id": "0787",
        "depth": 1
    },
    {
        "description": "Thor is getting used to the Earth. As a gift Loki gave him a smartphone. There are n applications on this phone. Thor is fascinated by this phone. He has only one minor issue: he can't count the number of unread notifications generated by those applications (maybe Loki put a curse on it so he can't).\n\nq events are about to happen (in chronological order). They are of three types:\n\n  1. Application x generates a notification (this new notification is unread). \n  2. Thor reads all notifications generated so far by application x (he may re-read some notifications). \n  3. Thor reads the first t notifications generated by phone applications (notifications generated in first t events of the first type). It's guaranteed that there were at least t events of the first type before this event. Please note that he doesn't read first t unread notifications, he just reads the very first t notifications generated on his phone and he may re-read some of them in this operation. \n\n\n\nPlease help Thor and tell him the number of unread notifications after each event. You may assume that initially there are no notifications in the phone.\n\nInput\n\nThe first line of input contains two integers n and q (1 \u2264 n, q \u2264 300 000) \u2014 the number of applications and the number of events to happen.\n\nThe next q lines contain the events. The i-th of these lines starts with an integer typei \u2014 type of the i-th event. If typei = 1 or typei = 2 then it is followed by an integer xi. Otherwise it is followed by an integer ti (1 \u2264 typei \u2264 3, 1 \u2264 xi \u2264 n, 1 \u2264 ti \u2264 q).\n\nOutput\n\nPrint the number of unread notifications after each event.\n\nExamples\n\nInput\n\n3 4\n1 3\n1 1\n1 2\n2 3\n\n\nOutput\n\n1\n2\n3\n2\n\n\nInput\n\n4 6\n1 2\n1 4\n1 2\n3 3\n1 3\n1 3\n\n\nOutput\n\n1\n2\n3\n0\n1\n2\n\nNote\n\nIn the first sample:\n\n  1. Application 3 generates a notification (there is 1 unread notification). \n  2. Application 1 generates a notification (there are 2 unread notifications). \n  3. Application 2 generates a notification (there are 3 unread notifications). \n  4. Thor reads the notification generated by application 3, there are 2 unread notifications left. \n\n\n\nIn the second sample test:\n\n  1. Application 2 generates a notification (there is 1 unread notification). \n  2. Application 4 generates a notification (there are 2 unread notifications). \n  3. Application 2 generates a notification (there are 3 unread notifications). \n  4. Thor reads first three notifications and since there are only three of them so far, there will be no unread notification left. \n  5. Application 3 generates a notification (there is 1 unread notification). \n  6. Application 3 generates a notification (there are 2 unread notifications). ",
        "task_name": "705_C. Thor",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport math\nimport bisect\n\nn,q = list(map(int, sys.stdin.readline().strip().split(' ')))\n\nnotifications = []\nunread = [0 for i in range(n+1)]\nlast_unread = 0\nans = 0\nfor q0 in range(q):\n    i,x = list(map(int, sys.stdin.readline().strip().split(' ')))\n    if i == 1:\n        unread[x] += 1\n        ans += 1\n        notifications.append(x)\n    elif i == 2:\n        ans -= unread[x]\n        unread[x] = 0\n    else:\n        for j in range(last_unread,x):\n            unread[notifications[j]] -= 1\n            ans -= 1\n        last_unread = x\n    print(ans)",
        "correct": false,
        "task_id": "0797",
        "depth": 2
    },
    {
        "description": "There are N monsters, numbered 1, 2, ..., N.\n\nInitially, the health of Monster i is A_i.\n\nBelow, a monster with at least 1 health is called alive.\n\nUntil there is only one alive monster, the following is repeated:\n\n* A random alive monster attacks another random alive monster.\n* As a result, the health of the monster attacked is reduced by the amount equal to the current health of the monster attacking.\n\n\n\nFind the minimum possible final health of the last monster alive.\n\nConstraints\n\n* All values in input are integers.\n* 2 \\leq N \\leq 10^5\n* 1 \\leq A_i \\leq 10^9\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nA_1 A_2 ... A_N\n\n\nOutput\n\nPrint the minimum possible final health of the last monster alive.\n\nExamples\n\nInput\n\n4\n2 10 8 40\n\n\nOutput\n\n2\n\n\nInput\n\n4\n5 13 8 1000000000\n\n\nOutput\n\n1\n\n\nInput\n\n3\n1000000000 1000000000 1000000000\n\n\nOutput\n\n1000000000",
        "task_name": "p03127 AtCoder Beginner Contest 118 - Monsters Battle Royale",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#coding:utf-8\n\nn=input()\nA=map(int, raw_input().split(\" \"))\nA.sort()\nans=A[0]\nfor a in A[1:]:\n    m=a%ans\n    if m!=0:\n        ans=min(m,ans)\nprint(ans)",
        "correct": false,
        "task_id": "0806",
        "depth": 1
    },
    {
        "description": "Write a program which reads an integer n and prints the number of prime numbers which are less than or equal to n. A prime number is a natural number which has exactly two distinct natural number divisors: 1 and itself. For example, the first four prime numbers are: 2, 3, 5 and 7.\n\n\n\nInput\n\nInput consists of several datasets. Each dataset has an integer n (1 \u2264 n \u2264 999,999) in a line.\n\nThe number of datasets is less than or equal to 30.\n\nOutput\n\nFor each dataset, prints the number of prime numbers.\n\nExample\n\nInput\n\n10\n3\n11\n\n\nOutput\n\n4\n2\n5",
        "task_name": "p00009 Prime Number",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\na = [True] * 1000000\n\nfor i in range(2,1000000):\n\tif(a[i-1]):\n\t\tfor j in range(i**2-1, 1000000, i):\n\t\t\ta[j] = False\n\nfor s in sys.stdin:\n\tprint(a[1:int(s)].count(True))",
        "correct": true,
        "task_id": "0808",
        "depth": 2
    },
    {
        "description": "There are n benches in the Berland Central park. It is known that a_i people are currently sitting on the i-th bench. Another m people are coming to the park and each of them is going to have a seat on some bench out of n available.\n\nLet k be the maximum number of people sitting on one bench after additional m people came to the park. Calculate the minimum possible k and the maximum possible k.\n\nNobody leaves the taken seat during the whole process.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 100) \u2014 the number of benches in the park.\n\nThe second line contains a single integer m (1 \u2264 m \u2264 10 000) \u2014 the number of people additionally coming to the park.\n\nEach of the next n lines contains a single integer a_i (1 \u2264 a_i \u2264 100) \u2014 the initial number of people on the i-th bench.\n\nOutput\n\nPrint the minimum possible k and the maximum possible k, where k is the maximum number of people sitting on one bench after additional m people came to the park.\n\nExamples\n\nInput\n\n4\n6\n1\n1\n1\n1\n\n\nOutput\n\n3 7\n\n\nInput\n\n1\n10\n5\n\n\nOutput\n\n15 15\n\n\nInput\n\n3\n6\n1\n6\n5\n\n\nOutput\n\n6 12\n\n\nInput\n\n3\n7\n1\n6\n5\n\n\nOutput\n\n7 13\n\nNote\n\nIn the first example, each of four benches is occupied by a single person. The minimum k is 3. For example, it is possible to achieve if two newcomers occupy the first bench, one occupies the second bench, one occupies the third bench, and two remaining \u2014 the fourth bench. The maximum k is 7. That requires all six new people to occupy the same bench.\n\nThe second example has its minimum k equal to 15 and maximum k equal to 15, as there is just a single bench in the park and all 10 people will occupy it.",
        "task_name": "1042_A. Benches",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport math\nn = int(sys.stdin.readline())\nm = int(sys.stdin.readline())\na = [0]*n\nfor i in range(n):\n  a[i] = int(sys.stdin.readline())\n\nasort = sorted(a, reverse=True)\n\nnumspacesremaining = asort[0]*(n-1) - sum(asort[1:])\n\nif m <= numspacesremaining:\n  mink = max(asort)\nelse:\n  mink = max(asort) + max(math.ceil((m - numspacesremaining)/float(n)), 0)\n\nmaxk = max(a) + m\n\nprint(str(int(mink)) + \" \" + str(maxk))\n",
        "correct": true,
        "task_id": "0812",
        "depth": 1
    },
    {
        "description": "This is the easy version of the problem. The difference between the versions is the constraint on n and the required number of operations. You can make hacks only if all versions of the problem are solved.\n\nThere are two binary strings a and b of length n (a binary string is a string consisting of symbols 0 and 1). In an operation, you select a prefix of a, and simultaneously invert the bits in the prefix (0 changes to 1 and 1 changes to 0) and reverse the order of the bits in the prefix.\n\nFor example, if a=001011 and you select the prefix of length 3, it becomes 011011. Then if you select the entire string, it becomes 001001.\n\nYour task is to transform the string a into b in at most 3n operations. It can be proved that it is always possible.\n\nInput\n\nThe first line contains a single integer t (1\u2264 t\u2264 1000) \u2014 the number of test cases. Next 3t lines contain descriptions of test cases.\n\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 1000) \u2014 the length of the binary strings.\n\nThe next two lines contain two binary strings a and b of length n.\n\nIt is guaranteed that the sum of n across all test cases does not exceed 1000.\n\nOutput\n\nFor each test case, output an integer k (0\u2264 k\u2264 3n), followed by k integers p_1,\u2026,p_k (1\u2264 p_i\u2264 n). Here k is the number of operations you use and p_i is the length of the prefix you flip in the i-th operation.\n\nExample\n\nInput\n\n\n5\n2\n01\n10\n5\n01011\n11100\n2\n01\n01\n10\n0110011011\n1000110100\n1\n0\n1\n\n\nOutput\n\n\n3 1 2 1\n6 5 2 5 3 1 2\n0\n9 4 1 2 10 4 1 2 1 5\n1 1\n\nNote\n\nIn the first test case, we have 01\u2192 11\u2192 00\u2192 10.\n\nIn the second test case, we have 01011\u2192 00101\u2192 11101\u2192 01000\u2192 10100\u2192 00100\u2192 11100.\n\nIn the third test case, the strings are already the same. Another solution is to flip the prefix of length 2, which will leave a unchanged.",
        "task_name": "1381_A1. Prefix Flip (Easy Version)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from collections import *\nimport sys\ntry: inp = raw_input\nexcept: inp = input\ndef err(s):\n    sys.stderr.write('{}\\n'.format(s))\n\ndef ni():\n    return int(inp())\n\ndef nl():\n    return [int(_) for _ in inp().split()]\n\nT = ni()\ndef swap(ch):\n    return '1' if ch == '0' else '0'\n\ndef get_a_l(a, flips):\n    if flips%2 == 0:\n        return a[0]\n    else:\n        return swap(a[-1])\n\ndef get_a_r(a, flips):\n    if flips%2 == 0:\n        return a[-1]\n    else:\n        return swap(a[0])\n\ndef solve(a, b):\n    a = deque(a)\n    out = []\n    flips = 0\n    for i in range(len(a) - 1, -1, -1):\n        if (get_a_r(a, flips) == b[i]):\n            if flips%2 == 0:\n                a.pop()\n            else:\n                a.popleft()\n            continue\n        if (get_a_l(a, flips) != b[i]):\n            out.append(i+1)\n        else:\n            out.append(1)\n            out.append(i+1)\n        flips += 1\n        if flips%2 == 0:\n            a.pop()\n        else:\n            a.popleft()\n    return out\n\nfor _ in range(T):\n    N = ni()\n    a = list(inp())\n    b = list(inp())\n    out = solve(a, b)\n    print(' '.join(map(str, [len(out)] + out)))\n    \n    \n",
        "correct": true,
        "task_id": "0820",
        "depth": 1
    },
    {
        "description": "You are given an array a of length 2n. Consider a partition of array a into two subsequences p and q of length n each (each element of array a should be in exactly one subsequence: either in p or in q).\n\nLet's sort p in non-decreasing order, and q in non-increasing order, we can denote the sorted versions by x and y, respectively. Then the cost of a partition is defined as f(p, q) = \u2211_{i = 1}^n |x_i - y_i|.\n\nFind the sum of f(p, q) over all correct partitions of array a. Since the answer might be too big, print its remainder modulo 998244353.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 150 000).\n\nThe second line contains 2n integers a_1, a_2, \u2026, a_{2n} (1 \u2264 a_i \u2264 10^9) \u2014 elements of array a.\n\nOutput\n\nPrint one integer \u2014 the answer to the problem, modulo 998244353.\n\nExamples\n\nInput\n\n\n1\n1 4\n\n\nOutput\n\n\n6\n\nInput\n\n\n2\n2 1 2 1\n\n\nOutput\n\n\n12\n\nInput\n\n\n3\n2 2 2 2 2 2\n\n\nOutput\n\n\n0\n\nInput\n\n\n5\n13 8 35 94 9284 34 54 69 123 846\n\n\nOutput\n\n\n2588544\n\nNote\n\nTwo partitions of an array are considered different if the sets of indices of elements included in the subsequence p are different.\n\nIn the first example, there are two correct partitions of the array a:\n\n  1. p = [1], q = [4], then x = [1], y = [4], f(p, q) = |1 - 4| = 3; \n  2. p = [4], q = [1], then x = [4], y = [1], f(p, q) = |4 - 1| = 3. \n\n\n\nIn the second example, there are six valid partitions of the array a: \n\n  1. p = [2, 1], q = [2, 1] (elements with indices 1 and 2 in the original array are selected in the subsequence p); \n  2. p = [2, 2], q = [1, 1]; \n  3. p = [2, 1], q = [1, 2] (elements with indices 1 and 4 are selected in the subsequence p); \n  4. p = [1, 2], q = [2, 1]; \n  5. p = [1, 1], q = [2, 2]; \n  6. p = [2, 1], q = [2, 1] (elements with indices 3 and 4 are selected in the subsequence p). ",
        "task_name": "1445_D. Divide and Sum",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n=input()\na=map(int,raw_input().split())\nmod=998244353\na.sort()\nfirsum=0\nsecsum=0\nfor i in range(len(a)):\n    if i<n:\n        firsum+=a[i]\n    else:\n        secsum+=a[i]\nk=abs(secsum-firsum)%mod\nfac=[1,1]\nfor i in range(2,2*n+1):\n    fac.append((fac[-1]*i)%mod)\nrr=(fac[n]**2)%mod\ng=pow(rr,mod-2,mod)\nprint ((k*((fac[2*n]*g)%mod))%mod)",
        "correct": true,
        "task_id": "0822",
        "depth": 1
    },
    {
        "description": "During the last Sereja's Codesecrof round the server crashed many times, so the round was decided to be made unrated for some participants. \n\nLet's assume that n people took part in the contest. Let's assume that the participant who got the first place has rating a1, the second place participant has rating a2, ..., the n-th place participant has rating an. Then changing the rating on the Codesecrof site is calculated by the formula <image>.\n\nAfter the round was over, the Codesecrof management published the participants' results table. They decided that if for a participant di < k, then the round can be considered unrated for him. But imagine the management's surprise when they found out that the participants' rating table is dynamic. In other words, when some participant is removed from the rating, he is removed from the results' table and the rating is recalculated according to the new table. And of course, all applications for exclusion from the rating are considered in view of the current table.\n\nWe know that among all the applications for exclusion from the rating the first application to consider is from the participant with the best rank (the rank with the minimum number), for who di < k. We also know that the applications for exclusion from rating were submitted by all participants.\n\nNow Sereja wonders, what is the number of participants to be excluded from the contest rating, and the numbers of the participants in the original table in the order of their exclusion from the rating. Pay attention to the analysis of the first test case for a better understanding of the statement.\n\nInput\n\nThe first line contains two integers n, k (1 \u2264 n \u2264 2\u00b7105, - 109 \u2264 k \u2264 0). The second line contains n space-separated integers a1, a2, ..., an (1 \u2264 ai \u2264 109) \u2014 ratings of the participants in the initial table.\n\nOutput\n\nPrint the numbers of participants in the order in which they were removed from the table. Print the initial numbers of the participants, that is, the numbers that the participants had in the initial table.\n\nExamples\n\nInput\n\n5 0\n5 3 4 1 2\n\n\nOutput\n\n2\n3\n4\n\n\nInput\n\n10 -10\n5 5 1 7 5 1 2 4 9 2\n\n\nOutput\n\n2\n4\n5\n7\n8\n9\n\nNote\n\nConsider the first test sample. \n\n  1. Initially the sequence of the contest participants' ratings equals [5, 3, 4, 1, 2]. You can use this sequence to calculate the sequence of rating changes: [0, -9, -13, 8, 14]. According to the problem statement, the application of the participant who won the second place will be considered first.\n  2. As soon as the second place winner is out from the ratings, the participants' rating sequence will equal [5, 4, 1, 2]. By this sequence you can count the new sequence of rating changes: [0, -8, 2, 6]. According to the problem statement, the application of the participant who won the second place will be considered. Initially this participant won third place.\n  3. The new rating sequence equals [5, 1, 2], the new sequence of rating changes equals [0, -1, 1]. The second place participant's application is taken into consideration, initially this participant won the fourth place.\n  4. The new rating sequence equals [5, 2], the new sequence of rating changes equals [0, 0]. No more applications will be considered. \n\n\n\nThus, you should print 2, 3, 4.",
        "task_name": "315_C. Sereja and Contest",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, k = rints()\na, ans, s = rints(), [], 0\n\nfor i in range(1, n):\n    if s - (n - i - len(ans) - 1) * a[i] * (i - len(ans)) < k:\n        ans.append(i + 1)\n        n -= 1\n    else:\n        s += a[i] * (i - len(ans))\n\nprint('\\n'.join(map(str, ans)))\n",
        "correct": false,
        "task_id": "0828",
        "depth": 1
    },
    {
        "description": "Game \"Minesweeper 1D\" is played on a line of squares, the line's height is 1 square, the line's width is n squares. Some of the squares contain bombs. If a square doesn't contain a bomb, then it contains a number from 0 to 2 \u2014 the total number of bombs in adjacent squares.\n\nFor example, the correct field to play looks like that: 001*2***101*. The cells that are marked with \"*\" contain bombs. Note that on the correct field the numbers represent the number of bombs in adjacent cells. For example, field 2* is not correct, because cell with value 2 must have two adjacent cells with bombs.\n\nValera wants to make a correct field to play \"Minesweeper 1D\". He has already painted a squared field with width of n cells, put several bombs on the field and wrote numbers into some cells. Now he wonders how many ways to fill the remaining cells with bombs and numbers are there if we should get a correct field in the end.\n\nInput\n\nThe first line contains sequence of characters without spaces s1s2... sn (1 \u2264 n \u2264 106), containing only characters \"*\", \"?\" and digits \"0\", \"1\" or \"2\". If character si equals \"*\", then the i-th cell of the field contains a bomb. If character si equals \"?\", then Valera hasn't yet decided what to put in the i-th cell. Character si, that is equal to a digit, represents the digit written in the i-th square.\n\nOutput\n\nPrint a single integer \u2014 the number of ways Valera can fill the empty cells and get a correct field.\n\nAs the answer can be rather large, print it modulo 1000000007 (109 + 7).\n\nExamples\n\nInput\n\n?01???\n\n\nOutput\n\n4\n\n\nInput\n\n?\n\n\nOutput\n\n2\n\n\nInput\n\n**12\n\n\nOutput\n\n0\n\n\nInput\n\n1\n\n\nOutput\n\n0\n\nNote\n\nIn the first test sample you can get the following correct fields: 001**1, 001***, 001*2*, 001*10.",
        "task_name": "404_D. Minesweeper 1D",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# zero, one_used, one_unused, two, mine\nt = None\n\nline = raw_input()\n\nbig_prime = 1000000007\n\nfor c in line:\n    if t is None:\n        zero = 1\n        one_used = 0\n        one_unused = 1\n        two = 0\n        mine = 1\n    else:\n        zero = (t[0] + t[1]) % big_prime\n        one_used = t[4]\n        one_unused = (t[0] + t[1]) % big_prime\n        two = t[4]\n        mine = (t[2] + t[3] + t[4]) % big_prime\n\n    if c == '0':\n        t = (zero, 0, 0, 0, 0)\n    if c == '1':\n        t = (0, one_used, one_unused, 0, 0)\n    if c == '2':\n        t = (0, 0, 0, two, 0)\n    if c == '*':\n        t = (0, 0, 0, 0, mine)\n    if c == '?':\n        t = (zero, one_used, one_unused, two, mine)\n    # print t\n\nprint (t[0] + t[1] + t[4]) % big_prime\n\n",
        "correct": true,
        "task_id": "0829",
        "depth": 1
    },
    {
        "description": "In the Kingdom of AtCoder, only banknotes are used as currency. There are 10^{100}+1 kinds of banknotes, with the values of 1, 10, 10^2, 10^3, \\dots, 10^{(10^{100})}. You have come shopping at a mall and are now buying a takoyaki machine with a value of N. (Takoyaki is the name of a Japanese snack.)\n\nTo make the payment, you will choose some amount of money which is at least N and give it to the clerk. Then, the clerk gives you back the change, which is the amount of money you give minus N.\n\nWhat will be the minimum possible number of total banknotes used by you and the clerk, when both choose the combination of banknotes to minimize this count?\n\nAssume that you have sufficient numbers of banknotes, and so does the clerk.\n\nConstraints\n\n* N is an integer between 1 and 10^{1,000,000} (inclusive).\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\n\n\nOutput\n\nPrint the minimum possible number of total banknotes used by you and the clerk.\n\nExamples\n\nInput\n\n36\n\n\nOutput\n\n8\n\n\nInput\n\n91\n\n\nOutput\n\n3\n\n\nInput\n\n314159265358979323846264338327950288419716939937551058209749445923078164062862089986280348253421170\n\n\nOutput\n\n243",
        "task_name": "p02775 AtCoder Beginner Contest 155 - Payment",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    n = [int(i) for i in input()][::-1]\n\n    s = c = 0\n\n    for i in range(len(n)):\n        d = n[i] + c\n        c = 0\n\n        if (d > 5) or (d == 5 and i + 1 < len(n) and n[i + 1] + 1 > 5):\n            s += 10 - d\n            c = 1\n        else:\n            s += d\n\n    print(s + c)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "0841",
        "depth": 1
    },
    {
        "description": "There are N cards placed face down in a row. On each card, an integer 1 or 2 is written.\n\nLet A_i be the integer written on the i-th card.\n\nYour objective is to guess A_1, A_2, ..., A_N correctly.\n\nYou know the following facts:\n\n* For each i = 1, 2, ..., M, the value A_{X_i} + A_{Y_i} + Z_i is an even number.\n\n\n\nYou are a magician and can use the following magic any number of times:\n\nMagic: Choose one card and know the integer A_i written on it. The cost of using this magic is 1.\n\nWhat is the minimum cost required to determine all of A_1, A_2, ..., A_N?\n\nIt is guaranteed that there is no contradiction in given input.\n\nConstraints\n\n* All values in input are integers.\n* 2 \\leq N \\leq 10^5\n* 1 \\leq M \\leq 10^5\n* 1 \\leq X_i < Y_i \\leq N\n* 1 \\leq Z_i \\leq 100\n* The pairs (X_i, Y_i) are distinct.\n* There is no contradiction in input. (That is, there exist integers A_1, A_2, ..., A_N that satisfy the conditions.)\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M\nX_1 Y_1 Z_1\nX_2 Y_2 Z_2\n\\vdots\nX_M Y_M Z_M\n\n\nOutput\n\nPrint the minimum total cost required to determine all of A_1, A_2, ..., A_N.\n\nExamples\n\nInput\n\n3 1\n1 2 1\n\n\nOutput\n\n2\n\n\nInput\n\n6 5\n1 2 1\n2 3 2\n1 3 3\n4 5 4\n5 6 5\n\n\nOutput\n\n2\n\n\nInput\n\n100000 1\n1 100000 100\n\n\nOutput\n\n99999",
        "task_name": "p03045 AtCoder Beginner Contest 126 - 1 or 2",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#coding:utf-8\n# https://reiyw.com/post/union-find-tree-in-python/\nimport collections\nimport itertools\nimport operator\nclass UnionFind:\n    def __init__(self, elems=None):\n        class KeyDict(dict):\n            def __missing__(self, key):\n                self[key] = key\n                return key\n\n        self.parent = KeyDict()\n        self.rank = collections.defaultdict(int)\n\n        if elems is not None:\n            for elem in elems:\n                _, _ = self.parent[elem], self.rank[elem]\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n        else:\n            self.parent[y] = x\n        if self.rank[x] == self.rank[y]:\n            self.rank[x] += 1\n\n    def are_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def grouper(self):\n        roots = [(x, self.find(x_par)) for x, x_par in self.parent.items()]\n        root = operator.itemgetter(1)\n        for _, group in itertools.groupby(sorted(roots, key=root), root):\n            yield [x for x, _ in group]\n\nN,M=map(int,raw_input().split())\nuf=UnionFind(range(1,N+1))\nfor i in range(M):\n    x,y,z=map(int,raw_input().split())\n    uf.unite(x,y)\n\nfrom collections import defaultdict\nF=set()\nfor i in range(1,N+1):\n    F.add(uf.find(i))\nprint(len(F))    ",
        "correct": true,
        "task_id": "0843",
        "depth": 1
    },
    {
        "description": "You've got two rectangular tables with sizes na \u00d7 ma and nb \u00d7 mb cells. The tables consist of zeroes and ones. We will consider the rows and columns of both tables indexed starting from 1. Then we will define the element of the first table, located at the intersection of the i-th row and the j-th column, as ai, j; we will define the element of the second table, located at the intersection of the i-th row and the j-th column, as bi, j. \n\nWe will call the pair of integers (x, y) a shift of the second table relative to the first one. We'll call the overlap factor of the shift (x, y) value:\n\n<image>\n\nwhere the variables i, j take only such values, in which the expression ai, j\u00b7bi + x, j + y makes sense. More formally, inequalities 1 \u2264 i \u2264 na, 1 \u2264 j \u2264 ma, 1 \u2264 i + x \u2264 nb, 1 \u2264 j + y \u2264 mb must hold. If there are no values of variables i, j, that satisfy the given inequalities, the value of the sum is considered equal to 0. \n\nYour task is to find the shift with the maximum overlap factor among all possible shifts.\n\nInput\n\nThe first line contains two space-separated integers na, ma (1 \u2264 na, ma \u2264 50) \u2014 the number of rows and columns in the first table. Then na lines contain ma characters each \u2014 the elements of the first table. Each character is either a \"0\", or a \"1\".\n\nThe next line contains two space-separated integers nb, mb (1 \u2264 nb, mb \u2264 50) \u2014 the number of rows and columns in the second table. Then follow the elements of the second table in the format, similar to the first table.\n\nIt is guaranteed that the first table has at least one number \"1\". It is guaranteed that the second table has at least one number \"1\".\n\nOutput\n\nPrint two space-separated integers x, y (|x|, |y| \u2264 109) \u2014 a shift with maximum overlap factor. If there are multiple solutions, print any of them.\n\nExamples\n\nInput\n\n3 2\n01\n10\n00\n2 3\n001\n111\n\n\nOutput\n\n0 1\n\n\nInput\n\n3 3\n000\n010\n000\n1 1\n1\n\n\nOutput\n\n-1 -1",
        "task_name": "228_B. Two Tables",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\n(na, ma) = [int(buf) for buf in stdin.readline().strip().split()]\na = [int(stdin.readline().strip()[::-1], 2) for i in range(0, na)]\n\n(nb, mb) = [int(buf) for buf in stdin.readline().strip().split()]\nb = [int(stdin.readline().strip()[::-1], 2) for i in range(0, nb)]\n\ndef count1(x):\n    x = (x & 0x55555555555555555555555555555555) + ((x>>0x01) & 0x55555555555555555555555555555555)\n    x = (x & 0x33333333333333333333333333333333) + ((x>>0x02) & 0x33333333333333333333333333333333)\n    x = (x & 0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F) + ((x>>0x04) & 0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F)\n    x = (x & 0x00FF00FF00FF00FF00FF00FF00FF00FF) + ((x>>0x08) & 0x00FF00FF00FF00FF00FF00FF00FF00FF)\n    x = (x & 0x0000FFFF0000FFFF0000FFFF0000FFFF) + ((x>>0x0F) & 0x0000FFFF0000FFFF0000FFFF0000FFFF)\n    x = (x & 0x00000000FFFFFFFF00000000FFFFFFFF) + ((x>>0x10) & 0x00000000FFFFFFFF00000000FFFFFFFF)\n    x = (x & 0x0000000000000000FFFFFFFFFFFFFFFF) + ((x>>0x20) & 0x0000000000000000FFFFFFFFFFFFFFFF)\n    return x\n\ndef getval(x, y):\n    cnt = 0\n    for i in range(0, na):\n        if i+x in range(0, nb):\n            if y > 0:\n                cnt += count1((a[i]<<y) & b[i+x])\n            else:\n                cnt += count1(a[i] & (b[i+x]<<-y))\n    return cnt\n\n(ans, xx, yy) = (0, 0, 0)\nfor x in range(1-na, nb):\n    for y in range(1-ma, mb):\n        val = getval(x, y)\n        if ans  < val:\n            (ans, xx, yy) = (val, x, y)\n\nprint('%d %d' % (xx, yy))\n                \n",
        "correct": false,
        "task_id": "0867",
        "depth": 2
    },
    {
        "description": "One day Bob got a letter in an envelope. Bob knows that when Berland's post officers send a letter directly from city \u00abA\u00bb to city \u00abB\u00bb, they stamp it with \u00abA B\u00bb, or \u00abB A\u00bb. Unfortunately, often it is impossible to send a letter directly from the city of the sender to the city of the receiver, that's why the letter is sent via some intermediate cities. Post officers never send a letter in such a way that the route of this letter contains some city more than once. Bob is sure that the post officers stamp the letters accurately.\n\nThere are n stamps on the envelope of Bob's letter. He understands that the possible routes of this letter are only two. But the stamps are numerous, and Bob can't determine himself none of these routes. That's why he asks you to help him. Find one of the possible routes of the letter.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 105) \u2014 amount of mail stamps on the envelope. Then there follow n lines with two integers each \u2014 description of the stamps. Each stamp is described with indexes of the cities between which a letter is sent. The indexes of cities are integers from 1 to 109. Indexes of all the cities are different. Every time the letter is sent from one city to another, exactly one stamp is put on the envelope. It is guaranteed that the given stamps correspond to some valid route from some city to some other city. \n\nOutput\n\nOutput n + 1 numbers \u2014 indexes of cities in one of the two possible routes of the letter.\n\nExamples\n\nInput\n\n2\n1 100\n100 2\n\n\nOutput\n\n2 100 1 \n\nInput\n\n3\n3 1\n100 2\n3 2\n\n\nOutput\n\n100 2 3 1 ",
        "task_name": "29_C. Mail Stamps",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from math import *\nfrom Queue import *\n\n\nn = int(raw_input())\nnbr = dict()\ncand = set()\nfor i in range(n):\n    l = raw_input().split()\n    if l[0] not in nbr:\n        nbr[l[0]] = [l[1]]\n        cand.add(l[0])\n    else:\n        nbr[l[0]].append(l[1])\n        cand.remove(l[0])\n    if l[1] not in nbr:\n        nbr[l[1]] = [l[0]]\n        cand.add(l[1])\n    else:\n        nbr[l[1]].append(l[0])\n        cand.remove(l[1])\nfor v in cand:\n    break\nmarked = set()\nmarked.add(v)\nres = [v]\nQ = [v]\nwhile len(Q) > 0:\n    v = Q.pop()\n    for i in nbr[v]:\n        if i not in marked:\n            marked.add(i)\n            res.append(i)\n            Q.append(i)\nprint(\" \".join(res))\n    \n",
        "correct": true,
        "task_id": "0869",
        "depth": 2
    },
    {
        "description": "Karafs is some kind of vegetable in shape of an 1 \u00d7 h rectangle. Tavaspolis people love Karafs and they use Karafs in almost any kind of food. Tavas, himself, is crazy about Karafs.\n\n<image>\n\nEach Karafs has a positive integer height. Tavas has an infinite 1-based sequence of Karafses. The height of the i-th Karafs is si = A + (i - 1) \u00d7 B.\n\nFor a given m, let's define an m-bite operation as decreasing the height of at most m distinct not eaten Karafses by 1. Karafs is considered as eaten when its height becomes zero.\n\nNow SaDDas asks you n queries. In each query he gives you numbers l, t and m and you should find the largest number r such that l \u2264 r and sequence sl, sl + 1, ..., sr can be eaten by performing m-bite no more than t times or print -1 if there is no such number r.\n\nInput\n\nThe first line of input contains three integers A, B and n (1 \u2264 A, B \u2264 106, 1 \u2264 n \u2264 105).\n\nNext n lines contain information about queries. i-th line contains integers l, t, m (1 \u2264 l, t, m \u2264 106) for i-th query.\n\nOutput\n\nFor each query, print its answer in a single line.\n\nExamples\n\nInput\n\n2 1 4\n1 5 3\n3 3 10\n7 10 2\n6 4 8\n\n\nOutput\n\n4\n-1\n8\n-1\n\n\nInput\n\n1 5 2\n1 5 10\n2 7 4\n\n\nOutput\n\n1\n2",
        "task_name": "536_A. Tavas and Karafs",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\n\ndef bs():\n    be, en, ans = l, 10 ** 7, -1\n    while be <= en:\n        md = (be + en) >> 1\n        all = a * (md - l + 1) + b * (sum_n(md - 1) - sum_n(max(l - 2, 0)))\n        val = max(ceil1(all, m), a + (md - 1) * b)\n\n        if val <= t:\n            be = md + 1\n            ans = md\n        else:\n            en = md - 1\n\n    return ans\n\n\nceil1 = lambda a, b: (a + b - 1) // b\nsum_n = lambda n: (n * (n + 1)) // 2\nrints = lambda: [int(x) for x in stdin.readline().split()]\n\na, b, n = rints()\nqur, out = [rints() for _ in range(n)], []\n\nfor l, t, m in qur:\n    out.append(bs())\n\nprint('\\n'.join(map(str, out)))\n",
        "correct": true,
        "task_id": "0874",
        "depth": 1
    },
    {
        "description": "Innokentiy likes tea very much and today he wants to drink exactly n cups of tea. He would be happy to drink more but he had exactly n tea bags, a of them are green and b are black.\n\nInnokentiy doesn't like to drink the same tea (green or black) more than k times in a row. Your task is to determine the order of brewing tea bags so that Innokentiy will be able to drink n cups of tea, without drinking the same tea more than k times in a row, or to inform that it is impossible. Each tea bag has to be used exactly once.\n\nInput\n\nThe first line contains four integers n, k, a and b (1 \u2264 k \u2264 n \u2264 105, 0 \u2264 a, b \u2264 n) \u2014 the number of cups of tea Innokentiy wants to drink, the maximum number of cups of same tea he can drink in a row, the number of tea bags of green and black tea. It is guaranteed that a + b = n.\n\nOutput\n\nIf it is impossible to drink n cups of tea, print \"NO\" (without quotes).\n\nOtherwise, print the string of the length n, which consists of characters 'G' and 'B'. If some character equals 'G', then the corresponding cup of tea should be green. If some character equals 'B', then the corresponding cup of tea should be black.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n5 1 3 2\n\n\nOutput\n\nGBGBG\n\n\nInput\n\n7 2 2 5\n\n\nOutput\n\nBBGBGBB\n\nInput\n\n4 3 4 0\n\n\nOutput\n\nNO",
        "task_name": "746_D. Green and Black Tea",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "vals=[int(x) for x in raw_input().split()]\nn=vals[0]\nk=vals[1]\na=vals[2]\nb=vals[3]\n\nc=0\nd=True\nif b>a: d=False\ns=''\n\nfor i in range(n):\n    if c==k:\n        d = not d\n        c=0\n    if d:\n        s+='G'\n        a-=1\n        c+=1\n        if a < b:\n            d=not d\n            c=0\n    else:\n        s+='B'\n        b-=1\n        c+=1\n        if b<a:\n            d=not d\n            c=0\n    if a<0 or b<0:\n        print('NO')\n        quit()\n\nprint(s)\n",
        "correct": true,
        "task_id": "0881",
        "depth": 1
    },
    {
        "description": "Consider the following game for two players. There is one white token and some number of black tokens. Each token is placed on a plane in a point with integer coordinates x and y.\n\nThe players take turn making moves, white starts. On each turn, a player moves all tokens of their color by 1 to up, down, left or right. Black player can choose directions for each token independently.\n\nAfter a turn of the white player the white token can not be in a point where a black token is located. There are no other constraints on locations of the tokens: positions of black tokens can coincide, after a turn of the black player and initially the white token can be in the same point with some black point. If at some moment the white player can't make a move, he loses. If the white player makes 10100500 moves, he wins.\n\nYou are to solve the following problem. You are given initial positions of all black tokens. It is guaranteed that initially all these positions are distinct. In how many places can the white token be located initially so that if both players play optimally, the black player wins?\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 105) \u2014 the number of black points.\n\nThe (i + 1)-th line contains two integers xi, yi ( - 105 \u2264 xi, yi, \u2264 105) \u2014 the coordinates of the point where the i-th black token is initially located.\n\nIt is guaranteed that initial positions of black tokens are distinct.\n\nOutput\n\nPrint the number of points where the white token can be located initially, such that if both players play optimally, the black player wins.\n\nExamples\n\nInput\n\n4\n-2 -1\n0 1\n0 -3\n2 -1\n\n\nOutput\n\n4\n\n\nInput\n\n4\n-2 0\n-1 1\n0 -2\n1 -1\n\n\nOutput\n\n2\n\n\nInput\n\n16\n2 1\n1 2\n-1 1\n0 1\n0 0\n1 1\n2 -1\n2 0\n1 0\n-1 -1\n1 -1\n2 2\n0 -1\n-1 0\n0 2\n-1 2\n\n\nOutput\n\n4\n\nNote\n\nIn the first and second examples initial positions of black tokens are shown with black points, possible positions of the white token (such that the black player wins) are shown with white points.\n\nThe first example: <image>\n\nThe second example: <image>\n\nIn the third example the white tokens should be located in the inner square 2 \u00d7 2, to make the black player win. <image>",
        "task_name": "930_D. Game with Tokens",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import*\nfrom itertools import*\ndef solve(a):\n    inf = 1001001001\n    C = 400010\n    lmn = [inf] * 400010\n    lmx = [-inf] * 400010\n    for x, y in a:\n        x = (x - 1) / 2 + 100005\n        if lmn[x] > y:\n            lmn[x] = y\n        if lmx[x] < y:\n            lmx[x] = y\n    rmn = lmn[:]\n    rmx = lmx[:]\n    for i in xrange(200009):\n        if lmn[i+1] > lmn[i]:\n            lmn[i+1] = lmn[i]\n    for i in xrange(200009):\n        if lmx[i+1] < lmx[i]:\n            lmx[i+1] = lmx[i]\n    for i in xrange(200009, 0, -1):\n        if rmn[i-1] > rmn[i]:\n            rmn[i-1] = rmn[i]\n    for i in xrange(200009, 0, -1):\n        if rmx[i-1] < rmx[i]:\n            rmx[i-1] = rmx[i]\n    for i in xrange(200010):\n        if lmn[i] < rmn[i]:\n            lmn[i] = rmn[i]\n    for i in xrange(200010):\n        if lmx[i] > rmx[i]:\n            lmx[i] = rmx[i]\n    ans = 0\n    for i in xrange(200009):\n        if lmn[i] < lmn[i+1]:\n            lmn[i] = lmn[i+1]\n    for i in xrange(200009):\n        if lmx[i] > lmx[i+1]:\n            lmx[i] = lmx[i+1]\n    for i in xrange(200009):\n        if lmn[i] < lmx[i]:\n            ans += (lmx[i] - lmn[i]) / 2\n    return ans\n    \ndef main():\n    n = int(stdin.readline())\n    dat = map(int, stdin.read().split(), repeat(10, 2 * n))\n    s = [[], []]\n    for i in xrange(n):\n        x, y = dat[i*2:i*2+2]\n        s[(x+y)&1].append((-x+y, x+y))\n    print(solve(s[0]) + solve(s[1]))\nmain()",
        "correct": true,
        "task_id": "0887",
        "depth": 1
    },
    {
        "description": "Hiasat registered a new account in NeckoForces and when his friends found out about that, each one of them asked to use his name as Hiasat's handle.\n\nLuckily for Hiasat, he can change his handle in some points in time. Also he knows the exact moments friends will visit his profile page. Formally, you are given a sequence of events of two types:\n\n  * 1 \u2014 Hiasat can change his handle. \n  * 2 s \u2014 friend s visits Hiasat's profile. \n\n\n\nThe friend s will be happy, if each time he visits Hiasat's profile his handle would be s.\n\nHiasat asks you to help him, find the maximum possible number of happy friends he can get.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u2264 10^5, 1 \u2264 m \u2264 40) \u2014 the number of events and the number of friends.\n\nThen n lines follow, each denoting an event of one of two types: \n\n  * 1 \u2014 Hiasat can change his handle. \n  * 2 s \u2014 friend s (1 \u2264 |s| \u2264 40) visits Hiasat's profile. \n\n\n\nIt's guaranteed, that each friend's name consists only of lowercase Latin letters.\n\nIt's guaranteed, that the first event is always of the first type and each friend will visit Hiasat's profile at least once.\n\nOutput\n\nPrint a single integer \u2014 the maximum number of happy friends.\n\nExamples\n\nInput\n\n\n5 3\n1\n2 motarack\n2 mike\n1\n2 light\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n4 3\n1\n2 alice\n2 bob\n2 tanyaromanova\n\n\nOutput\n\n\n1\n\nNote\n\nIn the first example, the best way is to change the handle to the \"motarack\" in the first event and to the \"light\" in the fourth event. This way, \"motarack\" and \"light\" will be happy, but \"mike\" will not.\n\nIn the second example, you can choose either \"alice\", \"bob\" or \"tanyaromanova\" and only that friend will be happy.",
        "task_name": "1105_E. Helping Hiasat ",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, m = [int(x) for x in raw_input().split()] \n# arr = list(raw_input())\n\n\nstart_counting = 'NO'\ncounter = {}\nfinal_cnt = 0\nfor i in range(0,n):\n    tmp_str = raw_input().split()\n    # print tmp_str\n    state = int(tmp_str[0])\n    if state == 1:\n        if start_counting=='YES':\n            if len(counter):\n                final_cnt += max(counter.values())\n            counter = {}\n        start_counting = 'YES'\n    else:\n        frnd = tmp_str[1]\n        if frnd in counter:\n            counter[frnd] += 1\n        else:\n            counter[frnd] = 1\n\nif start_counting=='YES':\n    if len(counter):\n        final_cnt += max(counter.values())\n\nprint(final_cnt)",
        "correct": false,
        "task_id": "0901",
        "depth": 1
    },
    {
        "description": "Now Serval is a junior high school student in Japari Middle School, and he is still thrilled on math as before. \n\nAs a talented boy in mathematics, he likes to play with numbers. This time, he wants to play with numbers on a rooted tree.\n\nA tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a node v is the last different from v vertex on the path from the root to the vertex v. Children of vertex v are all nodes for which v is the parent. A vertex is a leaf if it has no children.\n\nThe rooted tree Serval owns has n nodes, node 1 is the root. Serval will write some numbers into all nodes of the tree. However, there are some restrictions. Each of the nodes except leaves has an operation max or min written in it, indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons, respectively. \n\nAssume that there are k leaves in the tree. Serval wants to put integers 1, 2, \u2026, k to the k leaves (each number should be used exactly once). He loves large numbers, so he wants to maximize the number in the root. As his best friend, can you help him?\n\nInput\n\nThe first line contains an integer n (2 \u2264 n \u2264 3\u22c5 10^5), the size of the tree.\n\nThe second line contains n integers, the i-th of them represents the operation in the node i. 0 represents min and 1 represents max. If the node is a leaf, there is still a number of 0 or 1, but you can ignore it.\n\nThe third line contains n-1 integers f_2, f_3, \u2026, f_n (1 \u2264 f_i \u2264 i-1), where f_i represents the parent of the node i.\n\nOutput\n\nOutput one integer \u2014 the maximum possible number in the root of the tree.\n\nExamples\n\nInput\n\n\n6\n1 0 1 1 0 1\n1 2 2 2 2\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n1 0 1 0 1\n1 1 1 1\n\n\nOutput\n\n\n4\n\n\nInput\n\n\n8\n1 0 0 1 0 1 1 0\n1 1 2 2 3 3 3\n\n\nOutput\n\n\n4\n\n\nInput\n\n\n9\n1 1 0 0 1 0 1 0 1\n1 1 2 2 3 3 4 4\n\n\nOutput\n\n\n5\n\nNote\n\nPictures below explain the examples. The numbers written in the middle of the nodes are their indices, and the numbers written on the top are the numbers written in the nodes.\n\nIn the first example, no matter how you arrange the numbers, the answer is 1.\n\n<image>\n\nIn the second example, no matter how you arrange the numbers, the answer is 4.\n\n<image>\n\nIn the third example, one of the best solution to achieve 4 is to arrange 4 and 5 to nodes 4 and 5.\n\n<image>\n\nIn the fourth example, the best solution is to arrange 5 to node 5.\n\n<image>",
        "task_name": "1153_D. Serval and Rooted Tree",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Author: Mak Kader\n# Description: Template for pypy or python\n\n\nimport math\nimport sys\nimport heapq\nfrom collections import defaultdict\nfrom collections import deque\nfrom sys import stdin, stdout\nsys.setrecursionlimit(1 << 29)\n# Flush output: sys.stdout.flush()\n\ndef readInts():\n    return [int(x) for x in stdin.readline().split()]\n\ndef readInt():\n    return int(stdin.readline())\n\ndef readLine():\n    return stdin.readline().strip()\n\n# template end\n\n\nN = readInt()\n#assert(N < 10000)\n\nop = [0] + readInts()\npa = [0, 0] + readInts()\n\nG = defaultdict(list)\nfor i in range(2, N + 1):\n    p = pa[i]\n    G[p].append(i)\nnleaf = [0] * (N + 1)\nfor i in range(N, 0, -1):\n    if len(G[i]) == 0:\n        nleaf[i] = 1\n        continue\n    for j in G[i]:\n        nleaf[i] += nleaf[j]  # if len(G[j]) > 0 else 1\n\nmemo = {}\ndef dfs(root):\n    global memo\n    if len(G[root]) == 0:\n        return 1\n    if root in memo:\n        return memo[root]\n    res = 0\n    if op[root] == 0:  # min\n        #nl = nleaf[root]\n\n        for v in G[root]:\n            res = max(res, dfs(v))\n\n    else:\n        # max node\n        nl = nleaf[root]\n\n        for v in G[root]:\n            nlv = nleaf[v]\n            res = max(res, nl - (nlv - dfs(v)))\n    memo[root] = res\n    return memo[root]\n\n\nfor i in range(N, 0, -1):\n    dfs(i)\n\n# print(memo)\nres = dfs(1)\n#print(nleaf[1] - ms, ms)\nprint(res)\n",
        "correct": false,
        "task_id": "0903",
        "depth": 2
    },
    {
        "description": "Mishka wants to buy some food in the nearby shop. Initially, he has s burles on his card. \n\nMishka can perform the following operation any number of times (possibly, zero): choose some positive integer number 1 \u2264 x \u2264 s, buy food that costs exactly x burles and obtain \u230ax/10\u230b burles as a cashback (in other words, Mishka spends x burles and obtains \u230ax/10\u230b back). The operation \u230aa/b\u230b means a divided by b rounded down.\n\nIt is guaranteed that you can always buy some food that costs x for any possible value of x.\n\nYour task is to say the maximum number of burles Mishka can spend if he buys food optimally.\n\nFor example, if Mishka has s=19 burles then the maximum number of burles he can spend is 21. Firstly, he can spend x=10 burles, obtain 1 burle as a cashback. Now he has s=10 burles, so can spend x=10 burles, obtain 1 burle as a cashback and spend it too.\n\nYou have to answer t independent test cases.\n\nInput\n\nThe first line of the input contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next t lines describe test cases. Each test case is given on a separate line and consists of one integer s (1 \u2264 s \u2264 10^9) \u2014 the number of burles Mishka initially has.\n\nOutput\n\nFor each test case print the answer on it \u2014 the maximum number of burles Mishka can spend if he buys food optimally.\n\nExample\n\nInput\n\n\n6\n1\n10\n19\n9876\n12345\n1000000000\n\n\nOutput\n\n\n1\n11\n21\n10973\n13716\n1111111111",
        "task_name": "1296_B. Food Buying",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "t = int(input())\nfor i in range(t):\n  s = int(input())\n  total = 0\n  while s > 0:\n    ss = str(s)\n    spend = int(ss[0]) * (10 ** (len(ss)-1))\n    back = spend // 10\n    total += spend\n    s = s - spend + back\n  print(total)\n",
        "correct": true,
        "task_id": "0906",
        "depth": 2
    },
    {
        "description": "There are n warriors in a row. The power of the i-th warrior is a_i. All powers are pairwise distinct.\n\nYou have two types of spells which you may cast: \n\n  1. Fireball: you spend x mana and destroy exactly k consecutive warriors; \n  2. Berserk: you spend y mana, choose two consecutive warriors, and the warrior with greater power destroys the warrior with smaller power. \n\n\n\nFor example, let the powers of warriors be [2, 3, 7, 8, 11, 5, 4], and k = 3. If you cast Berserk on warriors with powers 8 and 11, the resulting sequence of powers becomes [2, 3, 7, 11, 5, 4]. Then, for example, if you cast Fireball on consecutive warriors with powers [7, 11, 5], the resulting sequence of powers becomes [2, 3, 4].\n\nYou want to turn the current sequence of warriors powers a_1, a_2, ..., a_n into b_1, b_2, ..., b_m. Calculate the minimum amount of mana you need to spend on it.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the length of sequence a and the length of sequence b respectively.\n\nThe second line contains three integers x, k, y (1 \u2264 x, y, \u2264 10^9; 1 \u2264 k \u2264 n) \u2014 the cost of fireball, the range of fireball and the cost of berserk respectively.\n\nThe third line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 n). It is guaranteed that all integers a_i are pairwise distinct.\n\nThe fourth line contains m integers b_1, b_2, ..., b_m (1 \u2264 b_i \u2264 n). It is guaranteed that all integers b_i are pairwise distinct.\n\nOutput\n\nPrint the minimum amount of mana for turning the sequnce a_1, a_2, ..., a_n into b_1, b_2, ..., b_m, or -1 if it is impossible.\n\nExamples\n\nInput\n\n\n5 2\n5 2 3\n3 1 4 5 2\n3 5\n\n\nOutput\n\n\n8\n\n\nInput\n\n\n4 4\n5 1 4\n4 3 1 2\n2 4 3 1\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n4 4\n2 1 11\n1 3 2 4\n1 3 2 4\n\n\nOutput\n\n\n0",
        "task_name": "1380_D. Berserk And Fireball",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#   Author: yumtam\n#   Created at: 2020-09-10 23:03\n\nfrom __future__ import division, print_function\n_interactive = False\n\ndef main():\n    n, m = input_as_list()\n    x, k, y = input_as_list()\n    a = input_as_list()\n    b = input_as_list()\n\n    j = 0\n    for i, ax in enumerate(a):\n        if j < m and ax == b[j]:\n            j += 1\n\n    if j < m:\n        print(-1)\n        return\n\n    sa = set(a)\n    sb = set(b)\n    if sa == sb:\n        print(0)\n        return\n\n    mx = max(sa-sb)\n\n    gaps = []\n    j = 0\n    gl = 0\n    special = False\n    for i, ax in enumerate(a):\n        if j < m and ax == b[j]:\n            j += 1\n            if special:\n                specialgap = gl\n            gaps.append(gl)\n            gl = 0\n            special = False\n        else:\n            if ax == mx:\n                special = True\n            gl += 1\n    if special:\n        specialgap = gl\n    gaps.append(gl)\n\n    debug_print(gaps)\n\n    if specialgap < k:\n        print(-1)\n        return\n\n    ans = 0\n    if x < y*k:\n        for g in gaps:\n            ans += x*(g//k) + y*(g%k)\n    else:\n        for g in gaps:\n            ans += y*g\n\n    print(ans)\n\n\n# Constants\nINF = float('inf')\nMOD = 10**9+7\n\n# Python3 equivalent names\nimport os, sys, itertools\nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\n# print-flush in interactive problems\nif _interactive:\n    flush = sys.stdout.flush\n    def printf(*args, **kwargs):\n        print(*args, **kwargs)\n        flush()\n\n# Debug print, only works on local machine\nLOCAL = \"LOCAL_\" in os.environ\ndebug_print = (print) if LOCAL else (lambda *x, **y: None)\n\n# Fast IO\nif (not LOCAL) and (not _interactive):\n    from io import BytesIO\n    from atexit import register\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n    sys.stdout = BytesIO()\n    register(lambda: os.write(1, sys.stdout.getvalue()))\n    input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Some utility functions(Input, N-dimensional lists, ...)\ndef input_as_list():\n    return [int(x) for x in input().split()]\n\ndef input_with_offset(o):\n    return [int(x)+o for x in input().split()]\n\ndef input_as_matrix(n, m):\n    return [input_as_list() for _ in range(n)]\n\ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\n# Start of external code templates...\n# End of external code templates.\n\nmain()\n",
        "correct": false,
        "task_id": "0909",
        "depth": 1
    },
    {
        "description": "Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.\n\nWe assume that Bajtek can only heap up snow drifts at integer coordinates.\n\nInput\n\nThe first line of input contains a single integer n (1 \u2264 n \u2264 100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1 \u2264 xi, yi \u2264 1000) \u2014 the coordinates of the i-th snow drift.\n\nNote that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.\n\nOutput\n\nOutput the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.\n\nExamples\n\nInput\n\n2\n2 1\n1 2\n\n\nOutput\n\n1\n\n\nInput\n\n2\n2 1\n4 1\n\n\nOutput\n\n0",
        "task_name": "217_A. Ice Skating",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"Template for Python Competitive Programmers prepared by Mayank Chaudhary \"\"\"\n\n# to use the print and division function of Python3\nfrom __future__ import division, print_function\n\n\"\"\"value of mod\"\"\"\nMOD = 998244353\nmod = 10**9 + 7\n\n\"\"\"use resource\"\"\"\n# import resource\n# resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n\n\"\"\"for factorial\"\"\"\n\n# def prepare_factorial():\n#     fact = [1]\n#     for i in range(1, 100005):\n#         fact.append((fact[-1] * i) % mod)\n#     ifact = [0] * 100005\n#     ifact[100004] = pow(fact[100004], mod - 2, mod)\n#     for i in range(100004, 0, -1):\n#         ifact[i - 1] = (i * ifact[i]) % mod\n#\n#     return fact, ifact\n\n\"\"\"uncomment next 4 lines while doing recursion based question\"\"\"\nimport threading\nthreading.stack_size(2**27)\nimport sys\nsys.setrecursionlimit(10000)\n\n\n\"\"\"uncomment modules according to your need\"\"\"\n# from bisect import bisect_left, bisect_right, insort\n# import itertools\nfrom math import floor, ceil, sqrt\n# import heapq\n# from random import randint as rn\n# from Queue import Queue as Q\n# from collections import Counter, defaultdict\n\n'''\ndef modinv(n, p):\n    return pow(n, p - 2, p)\n'''\n\n\n# def ncr(n, r,  fact, ifact):  # for using this uncomment the lines calculating fact and ifact\n#     t = ((fact[n]) * (ifact[r] % mod)) % mod\n#     return t\n\n\n\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\n\n\n# def GCD(x, y):\n#     while (y):\n#         x, y = y, x % y\n#     return x\n#\n# def lcm(x, y):\n#     return (x*y)//(GCD(x, y))\n#\n# def get_xor(n):\n#     return [n,1,n+1,0][n%4]\n\n\n\"\"\"*******************************************************\"\"\"\n\ndef main():\n\n    def dfs(i):\n        if i not in visited:\n            visited.add(i)\n            for child in mydict_x[i[0]]:\n                if (i[0], child) not in visited:\n                    dfs((i[0], child))\n            for child in mydict_y[i[1]]:\n                if (child, i[1]) not in visited:\n                    dfs((child, i[1]))\n\n\n    n = int(input())\n    lst = []\n    count_of_components = 0\n    mydict_x = {i:[] for i in range(1, 1001)}\n    mydict_y = {i:[] for i in range(1, 1001)}\n    for i in range(n):\n        x,y = get_ints()\n        lst.append((x, y))\n        mydict_x[x].append(y)\n        mydict_y[y].append(x)\n\n    visited = set()\n\n    for i in lst:\n        if i not in visited:\n            dfs(i)\n            count_of_components += 1\n\n    print(count_of_components - 1)\n\n\n\n\n\n\n\n\"\"\" -------- Python 2 and 3 footer by Pajenegod and c1729 ---------\"\"\"\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\n\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill();\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode('ascii'))\n            self.read = lambda: self.buffer.read().decode('ascii')\n            self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\"\"\" main function\"\"\"\n\nif __name__ == '__main__':\n    # main()\n    threading.Thread(target=main).start()",
        "correct": true,
        "task_id": "0912",
        "depth": 1
    },
    {
        "description": "Quite recently, a very smart student named Jury decided that lectures are boring, so he downloaded a game called \"Black Square\" on his super cool touchscreen phone.\n\nIn this game, the phone's screen is divided into four vertical strips. Each second, a black square appears on some of the strips. According to the rules of the game, Jury must use this second to touch the corresponding strip to make the square go away. As Jury is both smart and lazy, he counted that he wastes exactly ai calories on touching the i-th strip.\n\nYou've got a string s, describing the process of the game and numbers a1, a2, a3, a4. Calculate how many calories Jury needs to destroy all the squares?\n\nInput\n\nThe first line contains four space-separated integers a1, a2, a3, a4 (0 \u2264 a1, a2, a3, a4 \u2264 104).\n\nThe second line contains string s (1 \u2264 |s| \u2264 105), where the \u0456-th character of the string equals \"1\", if on the i-th second of the game the square appears on the first strip, \"2\", if it appears on the second strip, \"3\", if it appears on the third strip, \"4\", if it appears on the fourth strip.\n\nOutput\n\nPrint a single integer \u2014 the total number of calories that Jury wastes.\n\nExamples\n\nInput\n\n1 2 3 4\n123214\n\n\nOutput\n\n13\n\n\nInput\n\n1 5 3 2\n11221\n\n\nOutput\n\n13",
        "task_name": "431_A. Black Square",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def main():\n    c = [0]*5\n    for i in range(1,5):\n        c[i] = int(input())\n    s = input()\n    res = 0\n    for ch in s:\n        res += c[int(ch)]\n    print(res)\n    return\n",
        "correct": false,
        "task_id": "0915",
        "depth": 1
    },
    {
        "description": "Little Artem found a grasshopper. He brought it to his house and constructed a jumping area for him.\n\nThe area looks like a strip of cells 1 \u00d7 n. Each cell contains the direction for the next jump and the length of that jump. Grasshopper starts in the first cell and follows the instructions written on the cells. Grasshopper stops immediately if it jumps out of the strip. Now Artem wants to find out if this will ever happen.\n\nInput\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000) \u2014 length of the strip. \n\nNext line contains a string of length n which consists of characters \"<\" and \">\" only, that provide the direction of the jump from the corresponding cell. Next line contains n integers di (1 \u2264 di \u2264 109) \u2014 the length of the jump from the i-th cell.\n\nOutput\n\nPrint \"INFINITE\" (without quotes) if grasshopper will continue his jumps forever. Otherwise print \"FINITE\" (without quotes).\n\nExamples\n\nInput\n\n2\n&gt;&lt;\n1 2\n\n\nOutput\n\nFINITE\n\n\nInput\n\n3\n&gt;&gt;&lt;\n2 1 1\n\n\nOutput\n\nINFINITE\n\nNote\n\nIn the first sample grasshopper starts from the first cell and jumps to the right on the next cell. When he is in the second cell he needs to jump two cells left so he will jump out of the strip.\n\nSecond sample grasshopper path is 1 - 3 - 2 - 3 - 2 - 3 and so on. The path is infinite.",
        "task_name": "669_B. Little Artem and Grasshopper",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = input()\nfield = raw_input()\npower = map(int, raw_input().split())\n\npos = 0\nwhile 0 <= pos < n and power[pos] != 0:\n    power[pos], pos = 0, pos + (2 * (field[pos] == '>') - 1) * power[pos]\n\nprint (\"INFINITE\" if 0 <= pos < n else \"FINITE\")\n",
        "correct": true,
        "task_id": "0923",
        "depth": 1
    },
    {
        "description": "Perhaps many have heard that the World Biathlon Championship has finished. Although our hero Valera was not present at this spectacular event himself and only watched it on TV, it excited him so much that he decided to enroll in a biathlon section.\n\nOf course, biathlon as any sport, proved very difficult in practice. It takes much time and effort. Workouts, workouts, and workouts, \u2014 that's what awaited Valera on his way to great achievements in biathlon.\n\nAs for the workouts, you all probably know that every professional biathlete should ski fast and shoot precisely at the shooting range. Only in this case you can hope to be successful, because running and shooting are the two main components of biathlon. Valera has been diligent in his ski trainings, which is why he runs really fast, however, his shooting accuracy is nothing to write home about.\n\nOn a biathlon base where Valera is preparing for the competition, there is a huge rifle range with n targets. Each target have shape of a circle, and the center of each circle is located on the Ox axis. At the last training session Valera made the total of m shots. To make monitoring of his own results easier for him, one rather well-known programmer (of course it is you) was commissioned to write a program that would reveal how many and which targets Valera hit. More specifically, for each target the program must print the number of the first successful shot (in the target), or \"-1\" if this was not hit. The target is considered hit if the shot is inside the circle or on its boundary. Valera is counting on you and perhaps, thanks to you he will one day win international competitions.\n\nInput\n\nThe first line of the input file contains the integer n (1 \u2264 n \u2264 104), which is the number of targets. The next n lines contain descriptions of the targets. Each target is a circle whose center is located on the Ox axis. Each circle is given by its coordinate of the center x ( - 2\u00b7104 \u2264 x \u2264 2\u00b7104) and its radius r (1 \u2264 r \u2264 1000). It is guaranteed that no two targets coincide, intersect or are nested into each other, but they can touch each other.\n\nThe next line contains integer m (1 \u2264 m \u2264 2\u00b7105), which is the number of shots. Next m lines contain descriptions of the shots, which are points on the plane, given by their coordinates x and y ( - 2\u00b7104 \u2264 x, y \u2264 2\u00b7104).\n\nAll the numbers in the input are integers. \n\nTargets and shots are numbered starting from one in the order of the input.\n\nOutput\n\nPrint on the first line a single number, the number of targets hit by Valera. Print on the second line for each of the targets the number of its first hit or \"-1\" (without quotes) if this number does not exist. Separate numbers with spaces.\n\nExamples\n\nInput\n\n3\n2 1\n5 2\n10 1\n5\n0 1\n1 3\n3 0\n4 0\n4 0\n\n\nOutput\n\n2\n3 3 -1 \n\n\nInput\n\n3\n3 2\n7 1\n11 2\n4\n2 1\n6 0\n6 4\n11 2\n\n\nOutput\n\n3\n1 2 4 ",
        "task_name": "84_C. Biathlon",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from bisect import bisect_left as p\nz=lambda: map(int, raw_input().split())\nn=input()\na=[z()+[i] for i in range(n)]\nb=[-1]*n\nw=0\na.sort()\nfor i in range(input()):\n    x,y=z()\n    h=p(a,[x])\n    for u in (h-1,h):\n        if 0<=u<n and (x-a[u][0])**2+y**2<=a[u][1]**2:\n            d=a[u][2]\n            if b[d]==-1:\n                b[d]=i+1\n                w+=1\nprint(w)\nprint(' '.join(map(str,b)))\n",
        "correct": true,
        "task_id": "0929",
        "depth": 2
    },
    {
        "description": "Given are an integer X and an integer sequence of length N: p_1, \\ldots, p_N.\n\nAmong the integers not contained in the sequence p_1, \\ldots, p_N (not necessarily positive), find the integer nearest to X, that is, find the integer whose absolute difference with X is the minimum. If there are multiple such integers, report the smallest such integer.\n\nConstraints\n\n* 1 \\leq X \\leq 100\n* 0 \\leq N \\leq 100\n* 1 \\leq p_i \\leq 100\n* p_1, \\ldots, p_N are all distinct.\n* All values in input are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nX N\np_1 ... p_N\n\n\nOutput\n\nPrint the answer.\n\nExamples\n\nInput\n\n6 5\n4 7 10 6 5\n\n\nOutput\n\n8\n\n\nInput\n\n10 5\n4 7 10 6 5\n\n\nOutput\n\n9\n\n\nInput\n\n100 0\n\n\nOutput\n\n100",
        "task_name": "p02641 AtCoder Beginner Contest 170 - Forbidden List",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = 10**20\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\n\ndef resolve():\n    X, N = LI()\n    if N == 0:\n        print(X)\n        return\n\n    p = LI()\n\n    p_max = max(p)\n    p_min = min(p)\n\n    if X < p_min or p_max < X:\n        print(X)\n    else:\n        d = [abs(i-X) for i in range(p_min, p_max+1) if i not in p]\n        d_min = min(d)\n        for i in range(p_min, p_max+1):\n            if i not in p:\n                if abs(i-X)==d_min:\n                    print(i)\n                    break\n\nif __name__ == '__main__':\n    resolve()\n",
        "correct": false,
        "task_id": "0933",
        "depth": 1
    },
    {
        "description": "There is a box containing N balls. The i-th ball has the integer A_i written on it. Snuke can perform the following operation any number of times:\n\n* Take out two balls from the box. Then, return them to the box along with a new ball, on which the absolute difference of the integers written on the two balls is written.\n\n\n\nDetermine whether it is possible for Snuke to reach the state where the box contains a ball on which the integer K is written.\n\nConstraints\n\n* 1 \\leq N \\leq 10^5\n* 1 \\leq A_i \\leq 10^9\n* 1 \\leq K \\leq 10^9\n* All input values are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN K\nA_1 A_2 ... A_N\n\n\nOutput\n\nIf it is possible for Snuke to reach the state where the box contains a ball on which the integer K is written, print `POSSIBLE`; if it is not possible, print `IMPOSSIBLE`.\n\nExamples\n\nInput\n\n3 7\n9 3 4\n\n\nOutput\n\nPOSSIBLE\n\n\nInput\n\n3 5\n6 9 3\n\n\nOutput\n\nIMPOSSIBLE\n\n\nInput\n\n4 11\n11 3 7 15\n\n\nOutput\n\nPOSSIBLE\n\n\nInput\n\n5 12\n10 2 8 6 4\n\n\nOutput\n\nIMPOSSIBLE",
        "task_name": "p03651 AtCoder Grand Contest 018 - Getting Difference",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\nfrom fractions import gcd\n\n\nN, K = map(int, raw_input().split())\nA = sorted(list(map(int, raw_input().split())))\n\n\nif K > A[-1]:\n    print('IMPOSSIBLE')\nelse:\n    flag = True\n    tmp = reduce(gcd, A)\n    if tmp != 1:\n        flag = False\n    for a in A:\n        if a == K or (K - a) % tmp == 0:\n            flag = True\n            break\n    if flag:\n        print(\"POSSIBLE\")\n    else:\n        print('IMPOSSIBLE')\n",
        "correct": true,
        "task_id": "0938",
        "depth": 1
    },
    {
        "description": "There are N integers written on a blackboard. The i-th integer is A_i.\n\nTakahashi will repeatedly perform the following operation on these numbers:\n\n* Select a pair of integers, A_i and A_j, that have the same parity (that is, both are even or both are odd) and erase them.\n* Then, write a new integer on the blackboard that is equal to the sum of those integers, A_i+A_j.\n\n\n\nDetermine whether it is possible to have only one integer on the blackboard.\n\nConstraints\n\n* 2 \u2266 N \u2266 10^5\n* 1 \u2266 A_i \u2266 10^9\n* A_i is an integer.\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN\nA_1 A_2 \u2026 A_N\n\n\nOutput\n\nIf it is possible to have only one integer on the blackboard, print `YES`. Otherwise, print `NO`.\n\nExamples\n\nInput\n\n3\n1 2 3\n\n\nOutput\n\nYES\n\n\nInput\n\n5\n1 2 3 4 5\n\n\nOutput\n\nNO",
        "task_name": "p03807 AtCoder Grand Contest 010 - Addition",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "N = int(raw_input())\nA = list(map(int, raw_input().split(' ')))\n\ncnt = 0\nfor a in A:\n    cnt += 1 if a & 1 == 1 else 0\n\nprint('YES' if cnt % 2 == 0 else 'NO')",
        "correct": true,
        "task_id": "0939",
        "depth": 1
    },
    {
        "description": "A binary heap which satisfies max-heap property is called max-heap. In a max-heap, for every node $i$ other than the root, $A[i] \\leq A[parent(i)]$, that is, the value of a node is at most the value of its parent. The largest element in a max-heap is stored at the root, and the subtree rooted at a node contains values no larger than that contained at the node itself.\n\nHere is an example of a max-heap.\n\n<image>\n\n\nWrite a program which reads an array and constructs a max-heap from the array based on the following pseudo code.\n\n$maxHeapify(A, i)$ move the value of $A[i]$ down to leaves to make a sub-tree of node $i$ a max-heap. Here, $H$ is the size of the heap.\n\n\n1  maxHeapify(A, i)\n2      l = left(i)\n3      r = right(i)\n4      // select the node which has the maximum value\n5      if l \u2264 H and A[l] > A[i]\n6          largest = l\n7      else\n8          largest = i\n9      if r \u2264 H and A[r] > A[largest]\n10         largest = r\n11\n12     if largest \u2260 i\u3000// value of children is larger than that of i\n13         swap A[i] and A[largest]\n14         maxHeapify(A, largest) // call recursively\n\n\nThe following procedure buildMaxHeap(A) makes $A$ a max-heap by performing maxHeapify in a bottom-up manner.\n\n\n1 buildMaxHeap(A)\n2    for i = H/2 downto 1\n3        maxHeapify(A, i)\n\n\n\n\nInput\n\nIn the first line, an integer $H$ is given. In the second line, $H$ integers which represent elements in the binary heap are given in order of node id (from $1$ to $H$).\n\nOutput\n\nPrint values of nodes in the max-heap in order of their id (from $1$ to $H$). Print a single space character before each value.\n\nExample\n\nInput\n\n10\n4 1 3 2 16 9 10 14 8 7\n\n\nOutput\n\n16 14 10 8 7 9 3 2 4 1",
        "task_name": "p02288 Maximum Heap",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\ndef get_left(i):\n    return 2 * i + 1\n\ndef get_right(i):\n    return 2 * i + 2\n\ndef get_parent(i):\n    return int((i-1)/2)\n\ndef make_heap_tree(array, i, item_num):\n    left = get_left(i)\n    right = get_right(i)\n    largest = i\n    if (left < item_num) and (array[left] > array[largest]):\n        largest = left\n    if (right < item_num) and (array[right] > array[largest]):\n        largest = right\n    if largest != i:\n        tmp = array[i]\n        array[i] = array[largest]\n        array[largest] = tmp\n        make_heap_tree(array, largest, item_num)\n\ndef main():\n    size = int(sys.stdin.readline().strip())\n    array = map(lambda x: int(x), sys.stdin.readline().strip().split(\" \"))\n    for i in reversed(range(0, get_parent(size))):\n        make_heap_tree(array, i, size)\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": "0943",
        "depth": 1
    },
    {
        "description": "Let's call an undirected graph G = (V, E) relatively prime if and only if for each edge (v, u) \u2208 E GCD(v, u) = 1 (the greatest common divisor of v and u is 1). If there is no edge between some pair of vertices v and u then the value of GCD(v, u) doesn't matter. The vertices are numbered from 1 to |V|.\n\nConstruct a relatively prime graph with n vertices and m edges such that it is connected and it contains neither self-loops nor multiple edges.\n\nIf there exists no valid graph with the given number of vertices and edges then output \"Impossible\".\n\nIf there are multiple answers then print any of them.\n\nInput\n\nThe only line contains two integers n and m (1 \u2264 n, m \u2264 10^5) \u2014 the number of vertices and the number of edges.\n\nOutput\n\nIf there exists no valid graph with the given number of vertices and edges then output \"Impossible\".\n\nOtherwise print the answer in the following format:\n\nThe first line should contain the word \"Possible\".\n\nThe i-th of the next m lines should contain the i-th edge (v_i, u_i) of the resulting graph (1 \u2264 v_i, u_i \u2264 n, v_i \u2260 u_i). For each pair (v, u) there can be no more pairs (v, u) or (u, v). The vertices are numbered from 1 to n.\n\nIf there are multiple answers then print any of them.\n\nExamples\n\nInput\n\n5 6\n\n\nOutput\n\nPossible\n2 5\n3 2\n5 1\n3 4\n4 1\n5 4\n\n\nInput\n\n6 12\n\n\nOutput\n\nImpossible\n\nNote\n\nHere is the representation of the graph from the first example: <image>",
        "task_name": "1009_D. Relatively Prime Graph",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\nfrom fractions import gcd\n\nn, m = map(int, stdin.readline().split())\nedges, cur = [], 0\n\nfor i in range(1, n):\n    for j in range(i + 1, n + 1):\n        if not m:\n            break\n\n        if gcd(i, j) == 1:\n            m -= 1\n            edges.append('%d %d' % (i, j))\n            cur = max(cur, j)\n\nif m or cur != n:\n    print('Impossible')\nelse:\n    print('%s\\n%s' % ('Possible', '\\n'.join(edges)))\n",
        "correct": true,
        "task_id": "0944",
        "depth": 2
    },
    {
        "description": "There are n boxers, the weight of the i-th boxer is a_i. Each of them can change the weight by no more than 1 before the competition (the weight cannot become equal to zero, that is, it must remain positive). Weight is always an integer number.\n\nIt is necessary to choose the largest boxing team in terms of the number of people, that all the boxers' weights in the team are different (i.e. unique).\n\nWrite a program that for given current values \u200ba_i will find the maximum possible number of boxers in a team.\n\nIt is possible that after some change the weight of some boxer is 150001 (but no more).\n\nInput\n\nThe first line contains an integer n (1 \u2264 n \u2264 150000) \u2014 the number of boxers. The next line contains n integers a_1, a_2, ..., a_n, where a_i (1 \u2264 a_i \u2264 150000) is the weight of the i-th boxer.\n\nOutput\n\nPrint a single integer \u2014 the maximum possible number of people in a team.\n\nExamples\n\nInput\n\n4\n3 2 4 1\n\n\nOutput\n\n4\n\n\nInput\n\n6\n1 1 1 4 4 4\n\n\nOutput\n\n5\n\nNote\n\nIn the first example, boxers should not change their weights \u2014 you can just make a team out of all of them.\n\nIn the second example, one boxer with a weight of 1 can be increased by one (get the weight of 2), one boxer with a weight of 4 can be reduced by one, and the other can be increased by one (resulting the boxers with a weight of 3 and 5, respectively). Thus, you can get a team consisting of boxers with weights of 5, 4, 3, 2, 1.",
        "task_name": "1203_E. Boxers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from itertools import chain\n\nn = int(raw_input())\na = list(sorted(map(int,raw_input().split())))\n\nteam = set()\n\nfor boxer in a :\n    if boxer - 1 > 0 and boxer - 1 <= 150001 and boxer - 1 not in team :\n    \tteam.add(boxer - 1)\n    elif boxer > 0 and boxer <= 150001 and boxer not in team :\n    \tteam.add(boxer)\n    elif boxer + 1 > 0 and boxer + 1 <= 150001 and boxer + 1 not in team :\n    \tteam.add(boxer + 1)\n\nprint(len(team),team)\n\n#print(min(\n#\tn, len(\n#\t\tset(\n#\t\t\tlist(\n#\t\t\t\tfilter(lambda x : 0<x<=150001,\n#\t\t\t\t\tchain.from_iterable([[i-1,i,i+1] for i in a])\n#\t\t\t\t\t)\n#\t\t\t\t)\n#\t\t\t)\n#\t\t)\n#\t)\n#)\n",
        "correct": false,
        "task_id": "0949",
        "depth": 1
    },
    {
        "description": "There are n cards numbered 1, \u2026, n. The card i has a red digit r_i and a blue digit b_i written on it.\n\nWe arrange all n cards in random order from left to right, with all permutations of 1, \u2026, n having the same probability. We then read all red digits on the cards from left to right, and obtain an integer R. In the same way, we read all blue digits and obtain an integer B. When reading a number, leading zeros can be ignored. If all digits in a number are zeros, then the number is equal to 0. Below is an illustration of a possible rearrangement of three cards, and how R and B can be found.\n\n<image>\n\nTwo players, Red and Blue, are involved in a bet. Red bets that after the shuffle R > B, and Blue bets that R < B. If in the end R = B, the bet results in a draw, and neither player wins.\n\nDetermine, which of the two players is more likely (has higher probability) to win the bet, or that their chances are equal. Refer to the Note section for a formal discussion of comparing probabilities.\n\nInput\n\nThe first line contains a single integer T (1 \u2264 T \u2264 100) \u2014 the number of test cases.\n\nDescriptions of T test cases follow. Each test case description starts with a line containing a single integer n (1 \u2264 n \u2264 1000) \u2014 the number of cards.\n\nThe following line contains a string of n digits r_1, \u2026, r_n \u2014 red digits on cards 1, \u2026, n respectively.\n\nThe following line contains a string of n digits b_1, \u2026, b_n \u2014 blue digits on cards 1, \u2026, n respectively.\n\nNote that digits in the same line are not separated with any delimiters.\n\nOutput\n\nPrint T answers for the test cases in order, one per line.\n\nIf Red has a strictly higher change to win, print \"RED\".\n\nIf Blue has a strictly higher change to win, print \"BLUE\".\n\nIf both players are equally likely to win, print \"EQUAL\".\n\nNote that all answers are case-sensitive.\n\nExample\n\nInput\n\n\n3\n3\n777\n111\n3\n314\n159\n5\n09281\n09281\n\n\nOutput\n\n\nRED\nBLUE\nEQUAL\n\nNote\n\nFormally, let n_R be the number of permutations of cards 1, \u2026, n such that the resulting numbers R and B satisfy R > B. Similarly, let n_B be the number of permutations such that R < B. If n_R > n_B, you should print \"RED\". If n_R < n_B, you should print \"BLUE\". If n_R = n_B, print \"EQUAL\".\n\nIn the first sample case, R = 777 and B = 111 regardless of the card order, thus Red always wins.\n\nIn the second sample case, there are two card orders when Red wins, and four card orders when Blue wins:\n\n  * order 1, 2, 3: 314 > 159;\n  * order 1, 3, 2: 341 > 195;\n  * order 2, 1, 3: 134 < 519;\n  * order 2, 3, 1: 143 < 591;\n  * order 3, 1, 2: 431 < 915;\n  * order 3, 2, 1: 413 < 951.\n\n\n\nSince R < B is more frequent, the answer is \"BLUE\".\n\nIn the third sample case, R = B regardless of the card order, thus the bet is always a draw, and both Red and Blue have zero chance to win.",
        "task_name": "1459_A. Red-Blue Shuffle",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\nimport sys, math, bisect, itertools\n\ninput = lambda: sys.stdin.readline().rstrip()\ndef lii(): return list(map(int, input().split()))\ndef mii(): return map(int, input().split())\n\ndef solve():\n    a = int(input())\n    b = input(); c = input()\n    first = 0; second = 0\n    for i in range(a):\n        if (int(b[i]) > int(c[i])):\n            first += 1\n        elif (int(b[i]) < int(c[i])):\n            second += 1\n    if (first > second): \n        print(\"RED\")\n    elif (second > first): \n        print(\"BLUE\")\n    else: \n        print(\"EQUAL\")\n\ndef main():\n    for _ in range(int(input())):\n        solve()\n\nif __name__ == '__main__':\n  main()",
        "correct": true,
        "task_id": "0954",
        "depth": 1
    },
    {
        "description": "Bob got a job as a system administrator in X corporation. His first task was to connect n servers with the help of m two-way direct connection so that it becomes possible to transmit data from one server to any other server via these connections. Each direct connection has to link two different servers, each pair of servers should have at most one direct connection. Y corporation, a business rival of X corporation, made Bob an offer that he couldn't refuse: Bob was asked to connect the servers in such a way, that when server with index v fails, the transmission of data between some other two servers becomes impossible, i.e. the system stops being connected. Help Bob connect the servers.\n\nInput\n\nThe first input line contains 3 space-separated integer numbers n, m, v (3 \u2264 n \u2264 105, 0 \u2264 m \u2264 105, 1 \u2264 v \u2264 n), n \u2014 amount of servers, m \u2014 amount of direct connections, v \u2014 index of the server that fails and leads to the failure of the whole system.\n\nOutput\n\nIf it is impossible to connect the servers in the required way, output -1. Otherwise output m lines with 2 numbers each \u2014 description of all the direct connections in the system. Each direct connection is described by two numbers \u2014 indexes of two servers, linked by this direct connection. The servers are numbered from 1. If the answer is not unique, output any.\n\nExamples\n\nInput\n\n5 6 3\n\n\nOutput\n\n1 2\n2 3\n3 4\n4 5\n1 3\n3 5\n\n\nInput\n\n6 100 1\n\n\nOutput\n\n-1",
        "task_name": "22_C. System Administrator",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\n(n,m,v) = map(int, raw_input().split())\n\nif (m < (n-1)):\n  print(-1)\n  exit()\n\n# Were going to make node 0 lose connection with the rest of the network,\n# when node 1 fails. Put all nodes > 1 on the other side of 1 results in\n# the largest possible network.\n\n# Make a line\nedges = [(i, i+1) for i in xrange(n-1)]\n\n# Keep adding edges until the requested amount is reached (if possible)\nm = m - len(edges)\nnode1_nr = 1\nwhile ((m > 0) and (node1_nr < n)):\n  node2_nr = node1_nr + 2 # Edge from node1_nr to node1_nr+1 already exists\n  while ((m > 0) and (node2_nr < n)):\n    edges.append((node1_nr, node2_nr))\n    m -= 1\n    node2_nr += 1\n  node1_nr += 1\n\nif (m > 0):\n  # Unable to make the requested amount of edges\n  print(-1)\n  exit()\n\n# Make a translation table\ntranslate = [i+1 for i in xrange(n)]\ntranslate[v-1],translate[1] = translate[1],translate[v-1] # Swap v and 1\n\n# Construct output\noutput = [(\"%d %d\" % (translate[n1], translate[n2])) for (n1, n2) in edges]\nprint(\"\\n\".join(output))\n",
        "correct": true,
        "task_id": "0960",
        "depth": 2
    },
    {
        "description": "Yaroslav has an array, consisting of (2\u00b7n - 1) integers. In a single operation Yaroslav can change the sign of exactly n elements in the array. In other words, in one operation Yaroslav can select exactly n array elements, and multiply each of them by -1.\n\nYaroslav is now wondering: what maximum sum of array elements can be obtained if it is allowed to perform any number of described operations?\n\nHelp Yaroslav.\n\nInput\n\nThe first line contains an integer n (2 \u2264 n \u2264 100). The second line contains (2\u00b7n - 1) integers \u2014 the array elements. The array elements do not exceed 1000 in their absolute value.\n\nOutput\n\nIn a single line print the answer to the problem \u2014 the maximum sum that Yaroslav can get.\n\nExamples\n\nInput\n\n2\n50 50 50\n\n\nOutput\n\n150\n\n\nInput\n\n2\n-1 -100 -1\n\n\nOutput\n\n100\n\nNote\n\nIn the first sample you do not need to change anything. The sum of elements equals 150.\n\nIn the second sample you need to change the sign of the first two elements. Then we get the sum of the elements equal to 100.",
        "task_name": "301_A. Yaroslav and Sequence",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "INT_MIN = -1000000007\n\nif __name__ == '__main__':\n\tn = int(raw_input())\n\ta = sorted([int(x) for x in raw_input().split()])\n\tres = INT_MIN\n\tfor i in range(0, 2 * n, 2 - n % 2):\n\t\tres = max(res, sum([-x for x in a[:i]] + a[i:]))\n\tprint(res)\n",
        "correct": true,
        "task_id": "0963",
        "depth": 1
    },
    {
        "description": "Vasily has a number a, which he wants to turn into a number b. For this purpose, he can do two types of operations:\n\n  * multiply the current number by 2 (that is, replace the number x by 2\u00b7x); \n  * append the digit 1 to the right of current number (that is, replace the number x by 10\u00b7x + 1). \n\n\n\nYou need to help Vasily to transform the number a into the number b using only the operations described above, or find that it is impossible.\n\nNote that in this task you are not required to minimize the number of operations. It suffices to find any way to transform a into b.\n\nInput\n\nThe first line contains two positive integers a and b (1 \u2264 a < b \u2264 109) \u2014 the number which Vasily has and the number he wants to have.\n\nOutput\n\nIf there is no way to get b from a, print \"NO\" (without quotes).\n\nOtherwise print three lines. On the first line print \"YES\" (without quotes). The second line should contain single integer k \u2014 the length of the transformation sequence. On the third line print the sequence of transformations x1, x2, ..., xk, where:\n\n  * x1 should be equal to a, \n  * xk should be equal to b, \n  * xi should be obtained from xi - 1 using any of two described operations (1 < i \u2264 k). \n\n\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n2 162\n\n\nOutput\n\nYES\n5\n2 4 8 81 162 \n\n\nInput\n\n4 42\n\n\nOutput\n\nNO\n\n\nInput\n\n100 40021\n\n\nOutput\n\nYES\n5\n100 200 2001 4002 40021 ",
        "task_name": "727_A. Transformation: from A to B",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\nn, big = map(int, raw_input().split())\n\ntotal = [str(big)]\ntemp = big\nwhile big > n:\n\n    if big % 2 == 0:\n        big = big / 2\n        total.append(str(big))\n\n    else:\n        temp = (big - 1) // 10\n        if temp * 10  + 1 == big:\n            total.append(str(temp))\n            big = temp\n        else:\n            break\n            \n\nif total[-1] == str(n):\n    sys.stdout.write('YES\\n%d\\n' %len(total) + ' '.join(total[::-1]) +'\\n')\nelse:\n    sys.stdout.write('NO\\n')\n",
        "correct": true,
        "task_id": "0973",
        "depth": 1
    },
    {
        "description": "Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).\n\nThere are n members, numbered 1 through n. m pairs of members are friends. Of course, a member can't be a friend with themselves.\n\nLet A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.\n\nFor example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.\n\nCan you help Limak and check if the network is reasonable? Print \"YES\" or \"NO\" accordingly, without the quotes.\n\nInput\n\nThe first line of the input contain two integers n and m (3 \u2264 n \u2264 150 000, <image>) \u2014 the number of members and the number of pairs of members that are friends.\n\nThe i-th of the next m lines contains two distinct integers ai and bi (1 \u2264 ai, bi \u2264 n, ai \u2260 bi). Members ai and bi are friends with each other. No pair of members will appear more than once in the input.\n\nOutput\n\nIf the given network is reasonable, print \"YES\" in a single line (without the quotes). Otherwise, print \"NO\" in a single line (without the quotes).\n\nExamples\n\nInput\n\n4 3\n1 3\n3 4\n1 4\n\n\nOutput\n\nYES\n\n\nInput\n\n4 4\n3 1\n2 3\n3 4\n1 2\n\n\nOutput\n\nNO\n\n\nInput\n\n10 4\n4 3\n5 10\n8 9\n1 2\n\n\nOutput\n\nYES\n\n\nInput\n\n3 2\n1 2\n2 3\n\n\nOutput\n\nNO\n\nNote\n\nThe drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is \"NO\" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.\n\n<image>",
        "task_name": "771_A. Bear and Friendship Condition",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nn, m = map(int, stdin.readline().rstrip().split())\n#n, m = 4,3\ngraph = {}\nfor i in range(n):\n    graph[i+1] = []\nfor i in range(m):\n    edge = map(int, stdin.readline().rstrip().split())\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n#graph = {1:[3,4], 2:[], 3:[1,4], 4:[1,3]}\n\nleftToCheck = set([i+1 for i in range(n)])\nisGood = True\nwhile len(leftToCheck) > 0:\n    checkMe = leftToCheck.pop()\n    neighbors = graph[checkMe]\n    cliqueSize = len(neighbors)\n    for neighbor in neighbors:\n        if len(graph[neighbor]) != cliqueSize:\n            isGood = False\n            leftToCheck = set([])\n            break\n    leftToCheck.discard(set(neighbors))\n\nif isGood:\n    print('YES')\nelse:\n    print('NO')\n\n\n",
        "correct": false,
        "task_id": "0975",
        "depth": 2
    },
    {
        "description": "We have a string S of length N consisting of `R`, `G`, and `B`.\n\nFind the number of triples (i,~j,~k)~(1 \\leq i < j < k \\leq N) that satisfy both of the following conditions:\n\n* S_i \\neq S_j, S_i \\neq S_k, and S_j \\neq S_k.\n* j - i \\neq k - j.\n\nConstraints\n\n* 1 \\leq N \\leq 4000\n* S is a string of length N consisting of `R`, `G`, and `B`.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nS\n\n\nOutput\n\nPrint the number of triplets in question.\n\nExamples\n\nInput\n\n4\nRRGB\n\n\nOutput\n\n1\n\n\nInput\n\n39\nRBRBGRBGGBBRRGBBRRRBGGBRBGBRBGBRBBBGBBB\n\n\nOutput\n\n1800",
        "task_name": "p02714 AtCoder Beginner Contest 162 - RGB Triplets",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import bisect\nn = int(raw_input())\ns = raw_input()\nd = {}\nfor i in s:\n\td[i] = []\nfor i in range(len(s)):\n\td[s[i]].append(i)\np = d['R']\nq = d['G']\nr = d['B']\np1 = len(p)\nq1 = len(q)\nr1 = len(r)\nz = 0\nfor i in range(len(p)):\n\tfor j in range(len(q)):\n\t\tl = sorted([p[i],q[j]])\n\t\tto = bisect.bisect_left(r,l[1])\n\t\tisTrue = bisect.bisect_left(r[to:],2*l[1]-l[0])\n\t\ttry:\n\t\t\tif (r[to:])[isTrue] == 2*l[1]-l[0]:\n\t\t\t\tz+=r1-to-1\n\t\t\telse:\n\t\t\t\tz+=r1-to\n\t\texcept:\n\t\t\tz+=r1-to\nfor i in range(len(q)):\n\tfor j in range(len(r)):\n\t\tl = sorted([q[i],r[j]])\n\t\tto = bisect.bisect_left(p,l[1])\n\t\tisTrue = bisect.bisect_left(p[to:],2*l[1]-l[0])\n\t\ttry:\n\t\t\tif (p[to:])[isTrue] == 2*l[1]-l[0]:\n\t\t\t\tz+=p1-to-1\n\t\t\telse:\n\t\t\t\tz+=p1-to\n\t\texcept:\n\t\t\tz+=p1-to\n\t\t\nfor i in range(len(p)):\n\tfor j in range(len(r)):\n\t\tl = sorted([p[i],r[j]])\n\t\tto = bisect.bisect_left(q,l[1])\n\t\tisTrue = bisect.bisect_left(q[to:],2*l[1]-l[0])\n\t\ttry:\n\t\t\tif (q[to:])[isTrue] == 2*l[1]-l[0]:\n\t\t\t\tz+=q1-to-1\n\t\t\telse:\n\t\t\t\tz+=q1-to\n\t\texcept:\n\t\t\tz+=q1-to\n\nprint(z)\n",
        "correct": false,
        "task_id": "0984",
        "depth": 2
    },
    {
        "description": "There is a grid of square cells with H horizontal rows and W vertical columns. The cell at the i-th row and the j-th column will be denoted as Cell (i, j).\n\nIn Cell (i, j), a_{ij} coins are placed.\n\nYou can perform the following operation any number of times:\n\nOperation: Choose a cell that was not chosen before and contains one or more coins, then move one of those coins to a vertically or horizontally adjacent cell.\n\nMaximize the number of cells containing an even number of coins.\n\nConstraints\n\n* All values in input are integers.\n* 1 \\leq H, W \\leq 500\n* 0 \\leq a_{ij} \\leq 9\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nH W\na_{11} a_{12} ... a_{1W}\na_{21} a_{22} ... a_{2W}\n:\na_{H1} a_{H2} ... a_{HW}\n\n\nOutput\n\nPrint a sequence of operations that maximizes the number of cells containing an even number of coins, in the following format:\n\n\nN\ny_1 x_1 y_1' x_1'\ny_2 x_2 y_2' x_2'\n:\ny_N x_N y_N' x_N'\n\n\nThat is, in the first line, print an integer N between 0 and H \\times W (inclusive), representing the number of operations.\n\nIn the (i+1)-th line (1 \\leq i \\leq N), print four integers y_i, x_i, y_i' and x_i' (1 \\leq y_i, y_i' \\leq H and 1 \\leq x_i, x_i' \\leq W), representing the i-th operation. These four integers represents the operation of moving one of the coins placed in Cell (y_i, x_i) to a vertically or horizontally adjacent cell, (y_i', x_i').\n\nNote that if the specified operation violates the specification in the problem statement or the output format is invalid, it will result in Wrong Answer.\n\nExamples\n\nInput\n\n2 3\n1 2 3\n0 1 1\n\n\nOutput\n\n3\n2 2 2 3\n1 1 1 2\n1 3 1 2\n\n\nInput\n\n3 2\n1 0\n2 1\n1 0\n\n\nOutput\n\n3\n1 1 1 2\n1 2 2 2\n3 1 3 2\n\n\nInput\n\n1 5\n9 9 9 9 9\n\n\nOutput\n\n2\n1 1 1 2\n1 3 1 4",
        "task_name": "p03263 AtCoder Beginner Contest 109 - Make Them Even",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def main():\n    H, W = map(int, raw_input().split())\n    a = []\n    result = []\n    for i in range(H):\n        a.append(map(int, raw_input().split()))\n    # print a\n    for i in range(H):\n        for j in range(W):\n            if a[i][j] %2 == 0:\n                continue\n            else:\n                # if you can move a coin to the right, do so\n                if j + 1 < W:\n                    result.append([i+1,j+1,i+1,j+2])\n                    a[i][j] = a[i][j]-1\n                    a[i][j+1] = a[i][j+1]+1\n                # if you are the right edge and you can move a coin to the bottom, do so\n                elif j+1 == W and i+1 < H:\n                    result.append([i+1,j+1,i+2,j+1])\n                    a[i][j] = a[i][j]-1\n                    a[i+1][j] = a[i+1][j]+1\n                # else:\n                    # print('mo')\n                    # print(i+1)\n                    # print(j+1)\n    print(len(result))\n    for i in range(len(result)):\n        for j in range(len(result[i])):\n            if j == len(result[i]) - 1:\n                print(result[i][j])\n            else:\n                print(result[i][j]),\n\nif __name__ == '__main__':\n    main()\n",
        "correct": true,
        "task_id": "0985",
        "depth": 2
    },
    {
        "description": "Rng has a connected undirected graph with N vertices. Currently, there are M edges in the graph, and the i-th edge connects Vertices A_i and B_i.\n\nRng will add new edges to the graph by repeating the following operation:\n\n* Operation: Choose u and v (u \\neq v) such that Vertex v can be reached by traversing exactly three edges from Vertex u, and add an edge connecting Vertices u and v. It is not allowed to add an edge if there is already an edge connecting Vertices u and v.\n\n\n\nFind the maximum possible number of edges that can be added.\n\nConstraints\n\n* 2 \\leq N \\leq 10^5\n* 1 \\leq M \\leq 10^5\n* 1 \\leq A_i,B_i \\leq N\n* The graph has no self-loops or multiple edges.\n* The graph is connected.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M\nA_1 B_1\nA_2 B_2\n:\nA_M B_M\n\n\nOutput\n\nFind the maximum possible number of edges that can be added.\n\nExamples\n\nInput\n\n6 5\n1 2\n2 3\n3 4\n4 5\n5 6\n\n\nOutput\n\n4\n\n\nInput\n\n5 5\n1 2\n2 3\n3 1\n5 4\n5 1\n\n\nOutput\n\n5",
        "task_name": "p03579 CODE FESTIVAL 2017 qual B - 3 Steps",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "N,M = map(int,raw_input().split())\nes = [[] for i in range(N)]\nfor i in range(M):\n  a,b = map(int,raw_input().split())\n  a,b = a-1,b-1\n  es[a].append(b)\n  es[b].append(a)\n\ncolors = [0 for i in range(N)]\n\ndef dfs(v,color):\n  colors[v] = color\n  for to in es[v]:\n    if colors[to] == color:\n      return False\n    if colors[to] == 0 and not dfs(to, -color):\n      return False\n  return True\n\ndef is_bipartite():\n  return dfs(0,1)\n\nif is_bipartite():\n  b = (sum(colors) + N) // 2\n  w = N-b\n  print(b*w - M)\nelse:\n  all = N*(N-1) // 2\n  print(all - M)",
        "correct": false,
        "task_id": "0986",
        "depth": 1
    },
    {
        "description": "You are given array a_1, a_2, ..., a_n. Find the subsegment a_l, a_{l+1}, ..., a_r (1 \u2264 l \u2264 r \u2264 n) with maximum arithmetic mean (1)/(r - l + 1)\u2211_{i=l}^{r}{a_i} (in floating-point numbers, i.e. without any rounding).\n\nIf there are many such subsegments find the longest one.\n\nInput\n\nThe first line contains single integer n (1 \u2264 n \u2264 10^5) \u2014 length of the array a.\n\nThe second line contains n integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^9) \u2014 the array a.\n\nOutput\n\nPrint the single integer \u2014 the length of the longest subsegment with maximum possible arithmetic mean.\n\nExample\n\nInput\n\n\n5\n6 1 6 6 0\n\n\nOutput\n\n\n2\n\nNote\n\nThe subsegment [3, 4] is the longest among all subsegments with maximum arithmetic mean.",
        "task_name": "1117_A. Best Subsegment",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input()) \na = [int(x) for x in raw_input().split()] \n\n\n\"\"\"\nmax_avg = 0\nmax_len = 0\nfor i in range(0, n):\n    for j in range(i, n):\n        tmp = sum(a[i:j+1])/float(j-i+1)\n        if tmp > max_avg:\n            max_avg = tmp\n            max_len = (j-i+1)\n        elif tmp == max_avg:\n            if (j-i+1) > max_len:\n                max_len = (j-i+1)\n\"\"\"\n\nmax_a = max(a)\n#print (max_a)\nmax_len = 0\ntmp = 0\nfor i in range(0,n):\n    if a[i]!=max_a:\n        if tmp > max_len:\n            max_len = tmp\n        tmp = 0\n    elif a[i]==max_a:\n        tmp += 1\nif tmp > max_len:\n    max_len = tmp\n\n\nprint (max_len)\n\n\n\n",
        "correct": true,
        "task_id": "0990",
        "depth": 1
    },
    {
        "description": "Polycarp found a rectangular table consisting of n rows and m columns. He noticed that each cell of the table has its number, obtained by the following algorithm \"by columns\": \n\n  * cells are numbered starting from one; \n  * cells are numbered from left to right by columns, and inside each column from top to bottom; \n  * number of each cell is an integer one greater than in the previous cell. \n\n\n\nFor example, if n = 3 and m = 5, the table will be numbered as follows:\n\n$$$ \\begin{matrix} 1 & 4 & 7 & 10 & 13 \\\\\\ 2 & 5 & 8 & 11 & 14 \\\\\\ 3 & 6 & 9 & 12 & 15 \\\\\\ \\end{matrix} $$$\n\nHowever, Polycarp considers such numbering inconvenient. He likes the numbering \"by rows\": \n\n  * cells are numbered starting from one; \n  * cells are numbered from top to bottom by rows, and inside each row from left to right; \n  * number of each cell is an integer one greater than the number of the previous cell. \n\n\n\nFor example, if n = 3 and m = 5, then Polycarp likes the following table numbering: $$$ \\begin{matrix} 1 & 2 & 3 & 4 & 5 \\\\\\ 6 & 7 & 8 & 9 & 10 \\\\\\ 11 & 12 & 13 & 14 & 15 \\\\\\ \\end{matrix} $$$\n\nPolycarp doesn't have much time, so he asks you to find out what would be the cell number in the numbering \"by rows\", if in the numbering \"by columns\" the cell has the number x?\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4). Then t test cases follow.\n\nEach test case consists of a single line containing three integers n, m, x (1 \u2264 n, m \u2264 10^6, 1 \u2264 x \u2264 n \u22c5 m), where n and m are the number of rows and columns in the table, and x is the cell number.\n\nNote that the numbers in some test cases do not fit into the 32-bit integer type, so you must use at least the 64-bit integer type of your programming language.\n\nOutput\n\nFor each test case, output the cell number in the numbering \"by rows\".\n\nExample\n\nInput\n\n\n5\n1 1 1\n2 2 3\n3 5 11\n100 100 7312\n1000000 1000000 1000000000000\n\n\nOutput\n\n\n1\n2\n9\n1174\n1000000000000",
        "task_name": "1506_A. Strange Table",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Enter your code here. Read input from STDIN. Print output to STDOUT# ===============================================================================================\n# importing some useful libraries.\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom itertools import *\nimport bisect\nfrom heapq import *\nfrom math import ceil, floor\nfrom copy import *\nfrom collections import deque, defaultdict\nfrom collections import Counter as counter  # Counter(list)  return a dict with {key: count}\nfrom itertools import combinations  # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\nfrom itertools import permutations as permutate\nfrom bisect import bisect_left as bl\nfrom operator import *\n# If the element is already present in the list,\n\n# the left most position where element has to be inserted is returned.\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n# If the element is already present in the list,\n# the right most position where element has to be inserted is returned\n\n# ==============================================================================================\n# fast I/O region\n\nBUFSIZE = 8192\nfrom sys import stderr\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"A\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for A in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(A))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\n\n\ndef iterative(f, stack=[]):\n    def wrapped_func(*args, **kwargs):\n        if stack: return f(*args, **kwargs)\n        to = f(*args, **kwargs)\n        while True:\n            if type(to) is GeneratorType:\n                stack.append(to)\n                to = next(to)\n                continue\n            stack.pop()\n            if not stack: break\n            to = stack[-1].send(to)\n        return to\n\n    return wrapped_func\n\n\n#### END ITERATE RECURSION ####\n###########################\n# Sorted list\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[start:start + _load] for start in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for start in range(len(_fen_tree)):\n            if start | start + 1 < len(_fen_tree):\n                _fen_tree[start | start + 1] += _fen_tree[start]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        A = 0\n        while end:\n            A += _fen_tree[end - 1]\n            end &= end - 1\n        return A\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\n\n# ===============================================================================================\n# some shortcuts\n\nmod = 1000000007\n\ntest_count=1\ndef testcase(t):\n    global test_count\n    for p in range(t):\n        solve()\n        test_count+=1\n\n\n\ndef pow(A, B, p):\n    res = 1  # Initialize result\n    A = A % p  # Update A if it is more , than or equal to p\n    if (A == 0):\n        return 0\n    while (B > 0):\n        if ((B & 1) == 1):  # If B is odd, multiply, A with result\n            res = (res * A) % p\n\n        B = B >> 1  # B = B/2\n        A = (A * A) % p\n    return res\n\n\nfrom functools import reduce\n\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([start, n // start] for start in range(1, int(n ** 0.5) + 1) if n % start == 0)))\n\n\ndef gcd(a, b):\n    if a == b: return a\n    while b > 0: a, b = b, a % b\n    return a\n\n\n# discrete binary search\n# minimise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for start in range(200):\n#         if isvalid(l):\n#             return l\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m - 1):\n#             return m\n#         if isvalid(m):\n#             r = m + 1\n#         else:\n#             l = m\n#     return m\n\n# maximise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for start in range(200):\n#         # print(l,r)\n#         if isvalid(r):\n#             return r\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m + 1):\n#             return m\n#         if isvalid(m):\n#             l = m\n#         else:\n#             r = m - 1\n#     return m\n\n\n##############Find sum of product of subsets of size k in a array\n# ar=[0,1,2,3]\n# k=3\n# n=len(ar)-1\n# dp=[0]*(n+1)\n# dp[0]=1\n# for pos in range(1,n+1):\n#     dp[pos]=0\n#     l=max(1,k+pos-n-1)\n#     for j in range(min(pos,k),l-1,-1):\n#         dp[j]=dp[j]+ar[pos]*dp[j-1]\n# print(dp[k])\n\ndef prefix_sum(ar):  # [1,2,3,4]->[1,3,6,10]\n    return list(accumulate(ar))\n\n\ndef suffix_sum(ar):  # [1,2,3,4]->[10,9,7,4]\n    return list(accumulate(ar[::-1]))[::-1]\n\n\ndef N():\n    return int(inp())\n\n\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\n\ndef YES():\n    print(\"YES\")\n\n\ndef NO():\n    print(\"NO\")\n\n\ndef Yes():\n    print(\"Yes\")\n\n\ndef No():\n    print(\"No\")\n\n\n# =========================================================================================\nfrom collections import defaultdict\n\n\ndef numberOfSetBits(start):\n    start = start - ((start >> 1) & 0x55555555)\n    start = (start & 0x33333333) + ((start >> 2) & 0x33333333)\n    return (((start + (start >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        # self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        # self.lista[a] += self.lista[b]\n        # self.lista[b] = []\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef lcm(a, b):\n    return abs((a // gcd(a, b)) * b)\n\n\n# #\n# to find factorial and ncr\n# tot = 100005\n# mod = 10**9 + 7\n# fac = [1, 1]\n# finv = [1, 1]\n# inv = [0, 1]\n#\n# for start in range(2, tot + 1):\n#     fac.append((fac[-1] * start) % mod)\n#     inv.append(mod - (inv[mod % start] * (mod // start) % mod))\n#     finv.append(finv[-1] * inv[-1] % mod)\n\n\ndef comb(n, r):\n    if n < r:\n        return 0\n    else:\n        return fac[n] * (finv[r] * finv[n - r] % mod) % mod\n\n\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\")  # for fast input\n\n\ndef out(var): sys.stdout.write(str(var))  # for fast output, always take string\n\n\ndef lis(): return list(map(int, inp().split()))\n\n\ndef stringlis(): return list(map(str, inp().split()))\n\n\ndef sep(): return map(int, inp().split())\n\n\ndef strsep(): return map(str, inp().split())\n\n\ndef fsep(): return map(float, inp().split())\n\n\ndef nextline(): out(\"\\n\")  # as stdout.write always print sring.\n\n\ndef arr1d(n, v):\n    return [v] * n\n\n\ndef arr2d(n, m, v):\n    return [[v] * m for _ in range(n)]\n\n\ndef arr3d(n, m, p, v):\n    return [[[v] * p for _ in range(m)] for start in range(n)]\n\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\n\n# co-ordinate compression\n# ma={s:idx for idx,s in enumerate(sorted(set(l+r)))}\n\n# mxn=100005\n# lrg=[0]*mxn\n# for start in range(2,mxn-3):\n#     if (lrg[start]==0):\n#         for j in range(start,mxn-3,start):\n#             lrg[j]=start\n\ndef printer(s):\n    print(\"Case #{}: {}\".format(test_count,s))\n\ndef solve():\n    n,m,x=sep()\n    x-=1\n    ans= (x%n)*m + x//n\n    print(ans+1)\n\n\n\n# solve()\ntestcase(N())",
        "correct": true,
        "task_id": "1000",
        "depth": 1
    },
    {
        "description": "Each of you probably has your personal experience of riding public transportation and buying tickets. After a person buys a ticket (which traditionally has an even number of digits), he usually checks whether the ticket is lucky. Let us remind you that a ticket is lucky if the sum of digits in its first half matches the sum of digits in its second half.\n\nBut of course, not every ticket can be lucky. Far from it! Moreover, sometimes one look at a ticket can be enough to say right away that the ticket is not lucky. So, let's consider the following unluckiness criterion that can definitely determine an unlucky ticket. We'll say that a ticket is definitely unlucky if each digit from the first half corresponds to some digit from the second half so that each digit from the first half is strictly less than the corresponding digit from the second one or each digit from the first half is strictly more than the corresponding digit from the second one. Each digit should be used exactly once in the comparisons. In other words, there is such bijective correspondence between the digits of the first and the second half of the ticket, that either each digit of the first half turns out strictly less than the corresponding digit of the second half or each digit of the first half turns out strictly more than the corresponding digit from the second half.\n\nFor example, ticket 2421 meets the following unluckiness criterion and will not be considered lucky (the sought correspondence is 2 > 1 and 4 > 2), ticket 0135 also meets the criterion (the sought correspondence is 0 < 3 and 1 < 5), and ticket 3754 does not meet the criterion. \n\nYou have a ticket in your hands, it contains 2n digits. Your task is to check whether it meets the unluckiness criterion.\n\nInput\n\nThe first line contains an integer n (1 \u2264 n \u2264 100). The second line contains a string that consists of 2n digits and defines your ticket.\n\nOutput\n\nIn the first line print \"YES\" if the ticket meets the unluckiness criterion. Otherwise, print \"NO\" (without the quotes).\n\nExamples\n\nInput\n\n2\n2421\n\n\nOutput\n\nYES\n\n\nInput\n\n2\n0135\n\n\nOutput\n\nYES\n\n\nInput\n\n2\n3754\n\n\nOutput\n\nNO",
        "task_name": "160_B. Unlucky Ticket",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport traceback\n  \ndef solve():\n    n = map( int, sys.stdin.readline().strip('\\n\\r ').split())[0]\n    s = map( int, list(sys.stdin.readline()[:2*n]) )\n    sb = s[:n]\n    se = s[n:]\n    sb.sort()\n    se.sort()\n    lucky = 0\n    unlucky = 0\n    \n    while sb:\n      b = sb.pop()\n      e = se.pop()\n      if b>e: lucky+=1\n      elif b<e: unlucky+=1\n    if lucky==n or unlucky==n: return \"YES\"\n    return \"NO\"\n\nif __name__==\"__main__\":\n  print( solve() )\n",
        "correct": true,
        "task_id": "1002",
        "depth": 1
    },
    {
        "description": "Valera has got a rectangle table consisting of n rows and m columns. Valera numbered the table rows starting from one, from top to bottom and the columns \u2013 starting from one, from left to right. We will represent cell that is on the intersection of row x and column y by a pair of integers (x, y).\n\nValera wants to place exactly k tubes on his rectangle table. A tube is such sequence of table cells (x1, y1), (x2, y2), ..., (xr, yr), that: \n\n  * r \u2265 2; \n  * for any integer i (1 \u2264 i \u2264 r - 1) the following equation |xi - xi + 1| + |yi - yi + 1| = 1 holds; \n  * each table cell, which belongs to the tube, must occur exactly once in the sequence. \n\n\n\nValera thinks that the tubes are arranged in a fancy manner if the following conditions are fulfilled: \n\n  * no pair of tubes has common cells; \n  * each cell of the table belongs to some tube. \n\n\n\nHelp Valera to arrange k tubes on his rectangle table in a fancy manner.\n\nInput\n\nThe first line contains three space-separated integers n, m, k (2 \u2264 n, m \u2264 300; 2 \u2264 2k \u2264 n\u00b7m) \u2014 the number of rows, the number of columns and the number of tubes, correspondingly. \n\nOutput\n\nPrint k lines. In the i-th line print the description of the i-th tube: first print integer ri (the number of tube cells), then print 2ri integers xi1, yi1, xi2, yi2, ..., xiri, yiri (the sequence of table cells).\n\nIf there are multiple solutions, you can print any of them. It is guaranteed that at least one solution exists. \n\nExamples\n\nInput\n\n3 3 3\n\n\nOutput\n\n3 1 1 1 2 1 3\n3 2 1 2 2 2 3\n3 3 1 3 2 3 3\n\n\nInput\n\n2 3 1\n\n\nOutput\n\n6 1 1 1 2 1 3 2 3 2 2 2 1\n\nNote\n\nPicture for the first sample: \n\n<image>\n\nPicture for the second sample: \n\n<image>",
        "task_name": "441_C. Valera and Tubes ",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"Template for Python Competitive Programmers prepared by Mayank Chaudhary \"\"\"\n\n# to use the print and division function of Python3\nfrom __future__ import division, print_function\n\n\"\"\"value of mod\"\"\"\nMOD = 998244353\nmod = 10**9 + 7\n\n\"\"\"use resource\"\"\"\n# import resource\n# resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n\n\"\"\"for factorial\"\"\"\n\n# def prepare_factorial():\n#     fact = [1]\n#     for i in range(1, 1000005):\n#         fact.append((fact[-1] * i) % mod)\n#     ifact = [0] * 1000005\n#     ifact[1000004] = pow(fact[1000004], mod - 2, mod)\n#     for i in range(1000004, 0, -1):\n#         ifact[i - 1] = (i * ifact[i]) % mod\n#\n#     return fact, ifact\n\n\"\"\"uncomment next 4 lines while doing recursion based question\"\"\"\n# import threading\n# threading.stack_size(2**27)\nimport sys\n# sys.setrecursionlimit(30000)\n\n\n\"\"\"uncomment modules according to your need\"\"\"\n# from bisect import bisect_left, bisect_right, insort\n# import itertools\n# from math import floor, ceil, sqrt, degrees, atan, pi\n# from heapq import heappop, heapify, heappush\n# from random import randint as rn\n# from Queue import Queue as Q\n# from collections import Counter, defaultdict, deque\nfrom copy import deepcopy\n'''\ndef modinv(n, p):\n    return pow(n, p - 2, p)\n'''\n\n\n# def ncr(n, r,  fact, ifact):  # for using this uncomment the lines calculating fact and ifact\n#     t = (fact[n] * (ifact[r]*ifact[n-r]) % mod)% mod\n#     return t\n\n\n\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\n\n\ndef GCD(x, y):\n    while (y):\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x*y)//(GCD(x, y))\n\n# def get_xor(n):\n#     return [n,1,n+1,0][n%4]\n\n# def binary_expo(a, b):\n#\n#     result = 1\n#     while b:\n#         if b&1:\n#             result *= a\n#             b-=1\n#         else:\n#             a *= a\n#             b >>= 1\n#     return result\n\n\n\n\"\"\"*******************************************************\"\"\"\n\n\ndef main():\n\n    rows, cols, k = get_ints()\n\n    curr_x = curr_y = 0\n    turn = 0\n    store = []\n    for i in range(rows):\n        if not turn:\n            for j in range(cols):\n                store.append([i+1, j+1])\n        else:\n            for j in range(cols-1, -1, -1):\n                store.append([i+1, j+1])\n        turn ^= 1\n\n    i = 0\n    count = 0\n    while count<(k-1):\n        print(2, end = ' ')\n        print(*store[i], end = ' ')\n        print(*store[i+1])\n        i += 2\n        count += 1\n    print(rows*cols - 2*(k-1), end = ' ')\n    while i<(rows*cols):\n        if i==(rows*cols - 1):\n            print(*store[i])\n        else:\n            print(*store[i], end = ' ')\n        i += 1\n\n\n\n\n\n\n\n\"\"\" -------- Python 2 and 3 footer by Pajenegod and c1729 ---------\"\"\"\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\n\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill();\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode('ascii'))\n            self.read = lambda: self.buffer.read().decode('ascii')\n            self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\"\"\" main function\"\"\"\n\nif __name__ == '__main__':\n    main()\n    # threading.Thread(target=main).start()",
        "correct": true,
        "task_id": "1008",
        "depth": 2
    },
    {
        "description": "Fox Ciel is playing a mobile puzzle game called \"Two Dots\". The basic levels are played on a board of size n \u00d7 m cells, like this:\n\n<image>\n\nEach cell contains a dot that has some color. We will use different uppercase Latin characters to express different colors.\n\nThe key of this game is to find a cycle that contain dots of same color. Consider 4 blue dots on the picture forming a circle as an example. Formally, we call a sequence of dots d1, d2, ..., dk a cycle if and only if it meets the following condition:\n\n  1. These k dots are different: if i \u2260 j then di is different from dj. \n  2. k is at least 4. \n  3. All dots belong to the same color. \n  4. For all 1 \u2264 i \u2264 k - 1: di and di + 1 are adjacent. Also, dk and d1 should also be adjacent. Cells x and y are called adjacent if they share an edge. \n\n\n\nDetermine if there exists a cycle on the field.\n\nInput\n\nThe first line contains two integers n and m (2 \u2264 n, m \u2264 50): the number of rows and columns of the board.\n\nThen n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter.\n\nOutput\n\nOutput \"Yes\" if there exists a cycle, and \"No\" otherwise.\n\nExamples\n\nInput\n\n3 4\nAAAA\nABCA\nAAAA\n\n\nOutput\n\nYes\n\n\nInput\n\n3 4\nAAAA\nABCA\nAADA\n\n\nOutput\n\nNo\n\n\nInput\n\n4 4\nYYYR\nBYBY\nBBBY\nBBBY\n\n\nOutput\n\nYes\n\n\nInput\n\n7 6\nAAAAAB\nABBBAB\nABAAAB\nABABBB\nABAAAB\nABBBAB\nAAAAAB\n\n\nOutput\n\nYes\n\n\nInput\n\n2 13\nABCDEFGHIJKLM\nNOPQRSTUVWXYZ\n\n\nOutput\n\nNo\n\nNote\n\nIn first sample test all 'A' form a cycle.\n\nIn second sample there is no such cycle.\n\nThe third sample is displayed on the picture above ('Y' = Yellow, 'B' = Blue, 'R' = Red).",
        "task_name": "510_B. Fox And Two Dots",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def func(first, let, l, x, y, n, m, xInit, yInit, xAnt, yAnt, conj):\n  if(not (x >= 0 and x < n and y >= 0 and y < m) or (x, y) in conj):\n    return False\n  \n  if(x == xInit and y == yInit and len(conj) > 3):\n    return True\n\n  if(l[x][y] == let):\n    if(not first):\n      conj.add((x, y))\n\n    cima = False\n    if(y-1 != yAnt):\n      cima = func(False, let, l, x, y-1, n, m, xInit, yInit, x, y, conj)\n\n    direita = False\n    if(x+1 != xAnt):\n      direita = func(False, let, l, x+1, y, n, m, xInit, yInit, x, y, conj)\n\n    baixo = False\n    if(y+1 != yAnt):\n      baixo = func(False, let, l, x, y+1, n, m, xInit, yInit, x, y, conj)\n\n    esquerda = False\n    if(x-1 != xAnt):\n      esquerda = func(False, let, l, x-1, y, n, m, xInit, yInit, x, y, conj)\n\n    return cima or baixo or direita or esquerda\n  else:\n    return False\n  \n\nn, m = map(int, raw_input().split())\n\nl = [raw_input() for i in xrange(n)]\n\nres = False\nrow = 0\nwhile(row < n and not res):\n  for column in xrange(m):\n    conj = set()\n    tmp = func(True, l[row][column], l, row, column, n, m, row, column, row, column, conj)\n\n    if(tmp):\n      res = True\n      break\n  \n  row += 1\n\nif(res):\n  print(\"Yes\")\nelse:\n  print(\"No\")",
        "correct": false,
        "task_id": "1010",
        "depth": 2
    },
    {
        "description": "There are famous Russian nesting dolls named matryoshkas sold in one of the souvenir stores nearby, and you'd like to buy several of them. The store has n different matryoshkas. Any matryoshka is a figure of volume out_i with an empty space inside of volume in_i (of course, out_i > in_i).\n\nYou don't have much free space inside your bag, but, fortunately, you know that matryoshkas can be nested one inside another. Formally, let's call a set of matryoshkas nested if we can rearrange dolls in such a way, that the first doll can be nested inside the second one, the second doll \u2014 inside the third one and so on. Matryoshka i can be nested inside matryoshka j if out_i \u2264 in_j. So only the last doll will take space inside your bag.\n\nLet's call extra space of a nested set of dolls as a total volume of empty space inside this structure. Obviously, it's equal to in_{i_1} + (in_{i_2} - out_{i_1}) + (in_{i_3} - out_{i_2}) + ... + (in_{i_k} - out_{i_{k-1}}), where i_1, i_2, ..., i_k are the indices of the chosen dolls in the order they are nested in each other.\n\nFinally, let's call a nested subset of the given sequence as big enough if there isn't any doll from the sequence that can be added to the nested subset without breaking its nested property.\n\nYou want to buy many matryoshkas, so you should choose a big enough nested subset to buy it. But you will be disappointed if too much space in your bag will be wasted, so you want to choose a big enough subset so that its extra space is minimum possible among all big enough subsets. Now you wonder, how many different nested subsets meet these conditions (they are big enough, and there is no big enough subset such that its extra space is less than the extra space of the chosen subset). Two subsets are considered different if there exists at least one index i such that one of the subsets contains the i-th doll, and another subset doesn't.\n\nSince the answer can be large, print it modulo 10^9 + 7.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of matryoshkas.\n\nThe next n lines contain a description of each doll: two integers out_i and in_i (1 \u2264 in_i < out_i \u2264 10^9) \u2014 the outer and inners volumes of the i-th matryoshka.\n\nOutput\n\nPrint one integer \u2014 the number of big enough nested subsets such that extra space of each of these subsets is minimum possible. Since the answer can be large, print it modulo 10^9 + 7.\n\nExample\n\nInput\n\n\n7\n4 1\n4 2\n4 2\n2 1\n5 4\n6 4\n3 2\n\n\nOutput\n\n\n6\n\nNote\n\nThere are 6 big enough nested subsets with minimum possible extra space in the example: \n\n  * \\{1, 5\\}: we can't add any other matryoshka and keep it nested; it's extra space is 1; \n  * \\{1, 6\\}; \n  * \\{2, 4, 5\\}; \n  * \\{2, 4, 6\\}; \n  * \\{3, 4, 5\\}; \n  * \\{3, 4, 6\\}. \n\n\n\nThere are no more \"good\" subsets because, for example, subset \\{6, 7\\} is not big enough (we can add the 4-th matryoshka to it) or subset \\{4, 6, 7\\} has extra space equal to 2.",
        "task_name": "1197_E. Culture Code",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n\nDEBUG = 0\n\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nimport os, sys\nfrom atexit import register\nfrom io import BytesIO\nimport itertools\n\nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\nif DEBUG:\n    debug_print = print\nelse:\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n    sys.stdout = BytesIO()\n    register(lambda: os.write(1, sys.stdout.getvalue()))\n\n    input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n    debug_print = lambda *x, **y: None\n\n\ndef input_as_list():\n    return list(map(int, input().split()))\n\n\ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\n\ndef main():\n    from bisect import bisect_right\n\n    def update(o, n):\n        if n[0] < o[0]:\n            return n\n        elif n[0] == o[0]:\n            return o[0], (o[1] + n[1]) % MOD\n        else:\n            return o\n\n    def update2(o, n):\n        if n[0] > o[0]:\n            return n\n        elif n[0] == o[0]:\n            return o[0], (o[1] + n[1]) % MOD\n        else:\n            return o\n\n    n = int(input())\n    a = [input_as_list() for _ in range(n)]\n    a.sort()\n\n    eps = []\n    best = []\n    d = dict()\n    er = []\n\n    for ep, sp in a:\n        if not eps or eps[-1] != ep:\n            eps.append(ep)\n\n        if not er or er[-1][0] != ep:\n            er.append([ep, sp])\n        else:\n            er[-1][1] = sp\n\n        i = bisect_right(eps, sp) - 1\n        if i == -1:\n            g, c = sp, 1\n        else:\n            g, c = sp - best[i][0], best[i][1]\n\n        try:\n            gap, count = d[ep]\n        except KeyError:\n            gap, count = ep, 0\n\n        gap, count = update((gap, count), (g, c))\n        d[ep] = (gap, count)\n\n        try:\n            best[len(eps)-1] = update2(best[len(eps)-1], (ep-g, c))\n        except IndexError:\n            if len(eps) == 1:\n                best.append((ep - g, c))\n            else:\n                best.append(update2(best[len(eps)-2], (ep-g, c)))\n\n    debug_print(eps)\n    debug_print(d)\n    debug_print(best)\n    debug_print(er)\n\n    e, sb = er.pop()\n    ans = (e, 0)\n    while sb < e:\n        ans = update(ans, d[e])\n        if er:\n            e, s = er.pop()\n            sb = max(sb, s)\n        else:\n            break\n\n    print(ans[1])\n\n\nmain()",
        "correct": true,
        "task_id": "1033",
        "depth": 1
    },
    {
        "description": "You have a coins of value n and b coins of value 1. You always pay in exact change, so you want to know if there exist such x and y that if you take x (0 \u2264 x \u2264 a) coins of value n and y (0 \u2264 y \u2264 b) coins of value 1, then the total value of taken coins will be S.\n\nYou have to answer q independent test cases.\n\nInput\n\nThe first line of the input contains one integer q (1 \u2264 q \u2264 10^4) \u2014 the number of test cases. Then q test cases follow.\n\nThe only line of the test case contains four integers a, b, n and S (1 \u2264 a, b, n, S \u2264 10^9) \u2014 the number of coins of value n, the number of coins of value 1, the value n and the required total value.\n\nOutput\n\nFor the i-th test case print the answer on it \u2014 YES (without quotes) if there exist such x and y that if you take x coins of value n and y coins of value 1, then the total value of taken coins will be S, and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\n\nExample\n\nInput\n\n\n4\n1 2 3 4\n1 2 3 6\n5 2 6 27\n3 3 5 18\n\n\nOutput\n\n\nYES\nNO\nNO\nYES",
        "task_name": "1256_A. Payment Without Change",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout  \n  \ndef main(): \n\tn = stdin.readline() \n\tres = ''\n\tfor x in range(int(n)):\n\t\ta , b, n, S = [int(x) for x in stdin.readline().split()] \n\t\tprod = n*a\n\t\t#if prod == S or b == S:\n\t\t#\tres += 'YES \\n'\n\t\tif n*a < S:\n\t\t\tif S - prod <= b:\n\t\t\t\tres += 'YES\\n'\n\t\t\telse:\t\t\t\n\t\t\t\tres += 'NO\\n'\n\t\telse:\n\t\t\tif S % n <= b:\n\t\t\t\tres += 'YES\\n'\n\t\t\telse:\n\t\t\t\tres += 'NO\\n'\n\tstdout.write(res)\nif __name__ == \"__main__\": \n\tmain()",
        "correct": true,
        "task_id": "1034",
        "depth": 1
    },
    {
        "description": "You are given an array a of length n and array b of length m both consisting of only integers 0 and 1. Consider a matrix c of size n \u00d7 m formed by following rule: c_{i, j} = a_i \u22c5 b_j (i.e. a_i multiplied by b_j). It's easy to see that c consists of only zeroes and ones too.\n\nHow many subrectangles of size (area) k consisting only of ones are there in c?\n\nA subrectangle is an intersection of a consecutive (subsequent) segment of rows and a consecutive (subsequent) segment of columns. I.e. consider four integers x_1, x_2, y_1, y_2 (1 \u2264 x_1 \u2264 x_2 \u2264 n, 1 \u2264 y_1 \u2264 y_2 \u2264 m) a subrectangle c[x_1 ... x_2][y_1 ... y_2] is an intersection of the rows x_1, x_1+1, x_1+2, ..., x_2 and the columns y_1, y_1+1, y_1+2, ..., y_2.\n\nThe size (area) of a subrectangle is the total number of cells in it.\n\nInput\n\nThe first line contains three integers n, m and k (1 \u2264 n, m \u2264 40 000, 1 \u2264 k \u2264 n \u22c5 m), length of array a, length of array b and required size of subrectangles.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1), elements of a.\n\nThe third line contains m integers b_1, b_2, \u2026, b_m (0 \u2264 b_i \u2264 1), elements of b.\n\nOutput\n\nOutput single integer \u2014 the number of subrectangles of c with size (area) k consisting only of ones.\n\nExamples\n\nInput\n\n\n3 3 2\n1 0 1\n1 1 1\n\n\nOutput\n\n\n4\n\n\nInput\n\n\n3 5 4\n1 1 1\n1 1 1 1 1\n\n\nOutput\n\n\n14\n\nNote\n\nIn first example matrix c is:\n\n<image>\n\nThere are 4 subrectangles of size 2 consisting of only ones in it:\n\n<image>\n\nIn second example matrix c is:\n\n<image>",
        "task_name": "1323_B. Count Subrectangles",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n# Author : raj1307 - Raj Singh\n# Date   : 07.03.2020\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey,reverse=True)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\ndef ncr(n,r): return factorial(n)//(factorial(r)*factorial(n-r))\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\ndef main():\n        \n\n    #for _ in range(ii()):\n    if True:\n\n        n,m,k=mi()\n        a=li()\n        b=li()\n\n        x=[0]*(n+5)\n        y=[0]*(m+5)\n        x[0]=a[0]\n        #fx=[0]*40005\n\n        fx={}\n\n        p=[]\n        q=[]\n\n        if x[0]==1:\n            #fx[1]+=1\n            #fx[2]-=1\n            fx[1]=1\n            p.append(1)\n        for i in range(1,n):\n            if a[i]!=0:\n                x[i]+=x[i-1]+a[i]\n                #fx[1]+=1\n                #fx[x[i]+1]-=1\n                if fx.get(x[i],0)==0:\n                    fx[x[i]]=1\n                else:\n                    fx[x[i]]+=1\n                p.append(x[i])\n\n            else:\n                x[i]=0\n\n        y[0]=b[0]\n        #fy=[0]*40005\n        fy={}\n        if y[0]==1:\n            #fy[1]+=1\n            #fy[2]-=1\n            fy[1]=1\n            q.append(1)\n\n        for i in range(1,m):\n            if b[i]!=0:\n\n                y[i]+=y[i-1]+b[i]\n                #fy[1]+=1\n                #fy[y[i]+1]-=1\n                if fy.get(y[i],0)==0:\n                    fy[y[i]]=1\n                else:\n                    fy[y[i]]+=1\n                q.append(y[i])\n            else:\n                y[i]=0\n\n        # for i in range(1,40005):\n        #     fx[i]+=fx[i-1]\n        #     fy[i]+=fy[i-1]\n        p=list(set(p))\n        q=list(set(q))\n\n        cnt=0\n        for i in range(len(p)-1,-1,-1):\n            fx[p[i]]=fx[p[i]]+cnt\n            cnt=fx[p[i]]\n\n        cnt=0\n        for i in range(len(q)-1,-1,-1):\n            fy[q[i]]=fy[q[i]]+cnt\n            cnt=fy[q[i]]\n\n\n\n\n\n        ans=0\n        for i in p:\n            if k&i!=0:\n                continue\n\n            if fx.get(i,0)==0 or fy.get(k//i,0)==0:\n                continue\n\n            if k%i==0:\n                ans+=(fx[i]*fy[k//i])\n\n        print(ans)\n\n\n\n\n\n\n\n       \n    \n        \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": false,
        "task_id": "1036",
        "depth": 1
    },
    {
        "description": "The only difference between easy and hard versions is on constraints. In this version constraints are higher. You can make hacks only if all versions of the problem are solved.\n\nKoa the Koala is at the beach!\n\nThe beach consists (from left to right) of a shore, n+1 meters of sea and an island at n+1 meters from the shore.\n\nShe measured the depth of the sea at 1, 2, ..., n meters from the shore and saved them in array d. d_i denotes the depth of the sea at i meters from the shore for 1 \u2264 i \u2264 n.\n\nLike any beach this one has tide, the intensity of the tide is measured by parameter k and affects all depths from the beginning at time t=0 in the following way:\n\n  * For a total of k seconds, each second, tide increases all depths by 1.\n\n  * Then, for a total of k seconds, each second, tide decreases all depths by 1.\n\n  * This process repeats again and again (ie. depths increase for k seconds then decrease for k seconds and so on ...).\n\nFormally, let's define 0-indexed array p = [0, 1, 2, \u2026, k - 2, k - 1, k, k - 1, k - 2, \u2026, 2, 1] of length 2k. At time t (0 \u2264 t) depth at i meters from the shore equals d_i + p[t mod 2k] (t mod 2k denotes the remainder of the division of t by 2k). Note that the changes occur instantaneously after each second, see the notes for better understanding. \n\n\n\n\nAt time t=0 Koa is standing at the shore and wants to get to the island. Suppose that at some time t (0 \u2264 t) she is at x (0 \u2264 x \u2264 n) meters from the shore:\n\n  * In one second Koa can swim 1 meter further from the shore (x changes to x+1) or not swim at all (x stays the same), in both cases t changes to t+1.\n\n  * As Koa is a bad swimmer, the depth of the sea at the point where she is can't exceed l at integer points of time (or she will drown). More formally, if Koa is at x (1 \u2264 x \u2264 n) meters from the shore at the moment t (for some integer t\u2265 0), the depth of the sea at this point \u2014 d_x + p[t mod 2k] \u2014 can't exceed l. In other words, d_x + p[t mod 2k] \u2264 l must hold always.\n\n  * Once Koa reaches the island at n+1 meters from the shore, she stops and can rest.\n\nNote that while Koa swims tide doesn't have effect on her (ie. she can't drown while swimming). Note that Koa can choose to stay on the shore for as long as she needs and neither the shore or the island are affected by the tide (they are solid ground and she won't drown there). \n\n\n\n\nKoa wants to know whether she can go from the shore to the island. Help her!\n\nInput\n\nThe first line of the input contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\n\nThe first line of each test case contains three integers n, k and l (1 \u2264 n \u2264 3 \u22c5 10^5; 1 \u2264 k \u2264 10^9; 1 \u2264 l \u2264 10^9) \u2014 the number of meters of sea Koa measured and parameters k and l.\n\nThe second line of each test case contains n integers d_1, d_2, \u2026, d_n (0 \u2264 d_i \u2264 10^9) \u2014 the depths of each meter of sea Koa measured.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5.\n\nOutput\n\nFor each test case:\n\nPrint Yes if Koa can get from the shore to the island, and No otherwise.\n\nYou may print each letter in any case (upper or lower).\n\nExample\n\nInput\n\n\n7\n2 1 1\n1 0\n5 2 3\n1 2 3 2 2\n4 3 4\n0 2 4 3\n2 3 5\n3 0\n7 2 3\n3 0 2 1 3 0 1\n7 1 4\n4 4 3 0 2 4 2\n5 2 3\n1 2 3 2 2\n\n\nOutput\n\n\nYes\nNo\nYes\nYes\nYes\nNo\nNo\n\nNote\n\nIn the following s denotes the shore, i denotes the island, x denotes distance from Koa to the shore, the underline denotes the position of Koa, and values in the array below denote current depths, affected by tide, at 1, 2, ..., n meters from the shore.\n\nIn test case 1 we have n = 2, k = 1, l = 1, p = [ 0, 1 ].\n\nKoa wants to go from shore (at x = 0) to the island (at x = 3). Let's describe a possible solution:\n\n  * Initially at t = 0 the beach looks like this: [\\underline{s}, 1, 0, i]. \n  * At t = 0 if Koa would decide to swim to x = 1, beach would look like: [s, \\underline{2}, 1, i] at t = 1, since 2 > 1 she would drown. So Koa waits 1 second instead and beach looks like [\\underline{s}, 2, 1, i] at t = 1. \n  * At t = 1 Koa swims to x = 1, beach looks like [s, \\underline{1}, 0, i] at t = 2. Koa doesn't drown because 1 \u2264 1. \n  * At t = 2 Koa swims to x = 2, beach looks like [s, 2, \\underline{1}, i] at t = 3. Koa doesn't drown because 1 \u2264 1. \n  * At t = 3 Koa swims to x = 3, beach looks like [s, 1, 0, \\underline{i}] at t = 4. \n  * At t = 4 Koa is at x = 3 and she made it! \n\n\n\nWe can show that in test case 2 Koa can't get to the island.",
        "task_name": "1384_B2. Koa and the Beach (Hard Version)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#   Author: yumtam\n#   Created at: 2020-09-10 18:30\n\nfrom __future__ import division, print_function\n_interactive = False\n\ndef main():\n    for _ in range(int(input())):\n        n, k, L = input_as_list()\n        ar = input_as_list()\n\n        pos = None\n        for x in ar:\n            if x > L:\n                print(\"No\")\n                break\n            if x + k <= L:\n                pos = None\n            else:\n                if pos is not None:\n                    limit = L-x\n                    pos = max(pos+1, -(L-x))\n                    if pos > limit:\n                        print(\"No\")\n                        break\n                else:\n                    pos = -(L-x)\n        else:\n            print(\"Yes\")\n\n\n# Constants\nINF = float('inf')\nMOD = 10**9+7\n\n# Python3 equivalent names\nimport os, sys, itertools\nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\n# print-flush in interactive problems\nif _interactive:\n    flush = sys.stdout.flush\n    def printf(*args, **kwargs):\n        print(*args, **kwargs)\n        flush()\n\n# Debug print, only works on local machine\nLOCAL = \"LOCAL_\" in os.environ\ndebug_print = (print) if LOCAL else (lambda *x, **y: None)\n\n# Fast IO\nif (not LOCAL) and (not _interactive):\n    from io import BytesIO\n    from atexit import register\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n    sys.stdout = BytesIO()\n    register(lambda: os.write(1, sys.stdout.getvalue()))\n    input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Some utility functions(Input, N-dimensional lists, ...)\ndef input_as_list():\n    return [int(x) for x in input().split()]\n\ndef input_with_offset(o):\n    return [int(x)+o for x in input().split()]\n\ndef input_as_matrix(n, m):\n    return [input_as_list() for _ in range(n)]\n\ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\n# Start of external code templates...\n# End of external code templates.\n\nmain()\n",
        "correct": true,
        "task_id": "1039",
        "depth": 2
    },
    {
        "description": "The Smart Beaver from ABBYY decided to have a day off. But doing nothing the whole day turned out to be too boring, and he decided to play a game with pebbles. Initially, the Beaver has n pebbles. He arranges them in a equal rows, each row has b pebbles (a > 1). Note that the Beaver must use all the pebbles he has, i. e. n = a\u00b7b.\n\n<image> 10 pebbles are arranged in two rows, each row has 5 pebbles \n\nOnce the Smart Beaver has arranged the pebbles, he takes back any of the resulting rows (that is, b pebbles) and discards all other pebbles. Then he arranges all his pebbles again (possibly choosing other values of a and b) and takes back one row, and so on. The game continues until at some point the Beaver ends up with exactly one pebble. \n\nThe game process can be represented as a finite sequence of integers c1, ..., ck, where: \n\n  * c1 = n\n  * ci + 1 is the number of pebbles that the Beaver ends up with after the i-th move, that is, the number of pebbles in a row after some arrangement of ci pebbles (1 \u2264 i < k). Note that ci > ci + 1. \n  * ck = 1\n\n\n\nThe result of the game is the sum of numbers ci. You are given n. Find the maximum possible result of the game.\n\nInput\n\nThe single line of the input contains a single integer n \u2014 the initial number of pebbles the Smart Beaver has.\n\nThe input limitations for getting 30 points are: \n\n  * 2 \u2264 n \u2264 50\n\n\n\nThe input limitations for getting 100 points are: \n\n  * 2 \u2264 n \u2264 109\n\nOutput\n\nPrint a single number \u2014 the maximum possible result of the game.\n\nExamples\n\nInput\n\n10\n\n\nOutput\n\n16\n\n\nInput\n\n8\n\n\nOutput\n\n15\n\nNote\n\nConsider the first example (c1 = 10). The possible options for the game development are:\n\n  * Arrange the pebbles in 10 rows, one pebble per row. Then c2 = 1, and the game ends after the first move with the result of 11. \n  * Arrange the pebbles in 5 rows, two pebbles per row. Then c2 = 2, and the game continues. During the second move we have two pebbles which can be arranged in a unique way (remember that you are not allowed to put all the pebbles in the same row!) \u2014 2 rows, one pebble per row. c3 = 1, and the game ends with the result of 13. \n  * Finally, arrange the pebbles in two rows, five pebbles per row. The same logic leads us to c2 = 5, c3 = 1, and the game ends with the result of 16 \u2014 the maximum possible result. ",
        "task_name": "177_B1. Rectangular Game",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n=int(raw_input())\n\ncount=n\n\nwhile n!=1:\n    i=2\n    while divmod(n,i)[1]!=0:\n        i+=1\n    b=divmod(n,i)[0]\n    count+=b\n    n=b\n\nprint(count)",
        "correct": true,
        "task_id": "1042",
        "depth": 2
    },
    {
        "description": "Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.\n\nThe current state of the wall can be respresented by a sequence a of n integers, with a_i being the height of the i-th part of the wall.\n\nVova can only use 2 \u00d7 1 bricks to put in the wall (he has infinite supply of them, however).\n\nVova can put bricks only horizontally on the neighbouring parts of the wall of equal height. It means that if for some i the current height of part i is the same as for part i + 1, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part 1 of the wall or to the right of part n of it).\n\nNote that Vova can't put bricks vertically.\n\nVova is a perfectionist, so he considers the wall completed when:\n\n  * all parts of the wall has the same height; \n  * the wall has no empty spaces inside it. \n\n\n\nCan Vova complete the wall using any amount of bricks (possibly zero)?\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of parts in the wall.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9) \u2014 the initial heights of the parts of the wall.\n\nOutput\n\nPrint \"YES\" if Vova can complete the wall using any amount of bricks (possibly zero).\n\nPrint \"NO\" otherwise.\n\nExamples\n\nInput\n\n\n5\n2 1 1 2 5\n\n\nOutput\n\n\nYES\n\n\nInput\n\n\n3\n4 5 3\n\n\nOutput\n\n\nNO\n\n\nInput\n\n\n2\n10 10\n\n\nOutput\n\n\nYES\n\nNote\n\nIn the first example Vova can put a brick on parts 2 and 3 to make the wall [2, 2, 2, 2, 5] and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it [5, 5, 5, 5, 5].\n\nIn the second example Vova can put no bricks in the wall.\n\nIn the third example the wall is already complete.",
        "task_name": "1092_D2. Great Vova Wall (Version 2)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys,math\nfrom collections import defaultdict\nfrom io import BytesIO\n\nsys.stdin = BytesIO(sys.stdin.read())\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nn = int(input())\narr = [int(x) for x in input().split(' ')]\n#n,k = map(int, input().split(' '))\n#print(arr)\n\n#print(arr)\nh = max(arr)\nres = list()\nfor el in arr:\n    if len(res) == 0 or res[-1] != el:\n        if len(res) > 0:\n            if res[-1] < el:\n                print('NO')\n                exit()\n        res.append(el)\n    else:\n        res.pop()\nif len(res) > 1:\n    print('NO')\nelif len(res) == 0:\n    print('YES')\nelse:\n    print('NO' if res[-1] < h else 'YES')\n",
        "correct": true,
        "task_id": "1065",
        "depth": 1
    },
    {
        "description": "Thanos wants to destroy the avengers base, but he needs to destroy the avengers along with their base.\n\nLet we represent their base with an array, where each position can be occupied by many avengers, but one avenger can occupy only one position. Length of their base is a perfect power of 2. Thanos wants to destroy the base using minimum power. He starts with the whole base and in one step he can do either of following: \n\n  * if the current length is at least 2, divide the base into 2 equal halves and destroy them separately, or \n  * burn the current base. If it contains no avenger in it, it takes A amount of power, otherwise it takes his B \u22c5 n_a \u22c5 l amount of power, where n_a is the number of avengers and l is the length of the current base.\n\nOutput the minimum power needed by Thanos to destroy the avengers' base.\n\nInput\n\nThe first line contains four integers n, k, A and B (1 \u2264 n \u2264 30, 1 \u2264 k \u2264 10^5, 1 \u2264 A,B \u2264 10^4), where 2^n is the length of the base, k is the number of avengers and A and B are the constants explained in the question.\n\nThe second line contains k integers a_{1}, a_{2}, a_{3}, \u2026, a_{k} (1 \u2264 a_{i} \u2264 2^n), where a_{i} represents the position of avenger in the base.\n\nOutput\n\nOutput one integer \u2014 the minimum power needed to destroy the avengers base.\n\nExamples\n\nInput\n\n\n2 2 1 2\n1 3\n\n\nOutput\n\n\n6\n\n\nInput\n\n\n3 2 1 2\n1 7\n\n\nOutput\n\n\n8\n\nNote\n\nConsider the first example.\n\nOne option for Thanos is to burn the whole base 1-4 with power 2 \u22c5 2 \u22c5 4 = 16.\n\nOtherwise he can divide the base into two parts 1-2 and 3-4.\n\nFor base 1-2, he can either burn it with power 2 \u22c5 1 \u22c5 2 = 4 or divide it into 2 parts 1-1 and 2-2.\n\nFor base 1-1, he can burn it with power 2 \u22c5 1 \u22c5 1 = 2. For 2-2, he can destroy it with power 1, as there are no avengers. So, the total power for destroying 1-2 is 2 + 1 = 3, which is less than 4. \n\nSimilarly, he needs 3 power to destroy 3-4. The total minimum power needed is 6.",
        "task_name": "1111_C. Creative Snap",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n,k,a,b=map(int,raw_input().split())#attendu:12\ndef f(pos,amp,debut,fins):\n    global a,b\n    #print(pos,amp,debut,fins)\n    if debut==fins:\n        return a\n    if amp==1:\n        return b*(fins-debut)\n    else:\n        borne=pos+amp//2\n        deb=debut-1#\u00e0 l'issue de la dicho, deb doit indiquer le dernier avanger de la premi\u00e8re moiti\u00e9 ou avant,j'ai gal\u00e9r\u00e9 pourc omprendre qu'il fallaaitmettre d\u00e9but-1\n        fin=fins\n        while fin-deb>1:\n            m=(fin+deb)//2\n            if antman[m]>=borne:\n                fin=m\n            else:\n                deb=m\n            #if amp==4:\n                #print(m,antman[m],borne,deb,fin)\n        r=min(f(pos,amp//2,debut,fin)+f(borne,amp//2,fin,fins),b*amp*(fins-debut))\n        #print(r,pos,amp,debut,fins,deb,fin)\n        return r\nantman=sorted(map(int,raw_input().split()))\nprint(f(1,2**n,0,k))#pointeur au d\u00e9but et pointeur en dehors\n",
        "correct": true,
        "task_id": "1066",
        "depth": 1
    },
    {
        "description": "Johnny has a younger sister Anne, who is very clever and smart. As she came home from the kindergarten, she told his brother about the task that her kindergartener asked her to solve. The task was just to construct a triangle out of four sticks of different colours. Naturally, one of the sticks is extra. It is not allowed to break the sticks or use their partial length. Anne has perfectly solved this task, now she is asking Johnny to do the same.\n\nThe boy answered that he would cope with it without any difficulty. However, after a while he found out that different tricky things can occur. It can happen that it is impossible to construct a triangle of a positive area, but it is possible to construct a degenerate triangle. It can be so, that it is impossible to construct a degenerate triangle even. As Johnny is very lazy, he does not want to consider such a big amount of cases, he asks you to help him.\n\nInput\n\nThe first line of the input contains four space-separated positive integer numbers not exceeding 100 \u2014 lengthes of the sticks.\n\nOutput\n\nOutput TRIANGLE if it is possible to construct a non-degenerate triangle. Output SEGMENT if the first case cannot take place and it is possible to construct a degenerate triangle. Output IMPOSSIBLE if it is impossible to construct any triangle. Remember that you are to use three sticks. It is not allowed to break the sticks or use their partial length.\n\nExamples\n\nInput\n\n4 2 1 3\n\n\nOutput\n\nTRIANGLE\n\n\nInput\n\n7 2 2 4\n\n\nOutput\n\nSEGMENT\n\n\nInput\n\n3 5 9 1\n\n\nOutput\n\nIMPOSSIBLE",
        "task_name": "6_A. Triangle",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python2\n# -*- coding: utf-8 -*-\nimport sys\ninput = sys.stdin\noutput = sys.stdout\n\nfrom itertools import combinations\n\ndef compose_geom(t):\n    a,b,c = t\n    D2 = [a+b,a+c,b+c]\n    for d2 in D2:\n        for d in t:\n            if d2 == d:\n                return 'SEGMENT'\n            elif d2 < d:\n                return None\n    return 'TRIANGLE'\n\ndef solve(D):\n    for t in combinations(D,3):\n        r = compose_geom(t)\n        if r is not None:\n            return r\n    return 'IMPOSSIBLE'\n\ndef numbers_from_line(d=' '):\n    return [int(s) for s in input.readline().strip().split(d) if len(s.strip())>0]\n\nD = numbers_from_line()\n\na = solve(D)\noutput.write('%s\\n' % a)\n",
        "correct": false,
        "task_id": "1087",
        "depth": 2
    },
    {
        "description": "Vladik is a competitive programmer. This year he is going to win the International Olympiad in Informatics. But it is not as easy as it sounds: the question Vladik face now is to find the cheapest way to get to the olympiad.\n\nVladik knows n airports. All the airports are located on a straight line. Each airport has unique id from 1 to n, Vladik's house is situated next to the airport with id a, and the place of the olympiad is situated next to the airport with id b. It is possible that Vladik's house and the place of the olympiad are located near the same airport. \n\nTo get to the olympiad, Vladik can fly between any pair of airports any number of times, but he has to start his route at the airport a and finish it at the airport b.\n\nEach airport belongs to one of two companies. The cost of flight from the airport i to the airport j is zero if both airports belong to the same company, and |i - j| if they belong to different companies.\n\nPrint the minimum cost Vladik has to pay to get to the olympiad.\n\nInput\n\nThe first line contains three integers n, a, and b (1 \u2264 n \u2264 105, 1 \u2264 a, b \u2264 n) \u2014 the number of airports, the id of the airport from which Vladik starts his route and the id of the airport which he has to reach. \n\nThe second line contains a string with length n, which consists only of characters 0 and 1. If the i-th character in this string is 0, then i-th airport belongs to first company, otherwise it belongs to the second.\n\nOutput\n\nPrint single integer \u2014 the minimum cost Vladik has to pay to get to the olympiad.\n\nExamples\n\nInput\n\n4 1 4\n1010\n\n\nOutput\n\n1\n\nInput\n\n5 5 2\n10110\n\n\nOutput\n\n0\n\nNote\n\nIn the first example Vladik can fly to the airport 2 at first and pay |1 - 2| = 1 (because the airports belong to different companies), and then fly from the airport 2 to the airport 4 for free (because the airports belong to the same company). So the cost of the whole flight is equal to 1. It's impossible to get to the olympiad for free, so the answer is equal to 1. \n\nIn the second example Vladik can fly directly from the airport 5 to the airport 2, because they belong to the same company.",
        "task_name": "743_A. Vladik and flights",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nn, s, f = map(int, stdin.readline().split())\nnumbers = list(map(int, list(stdin.readline().strip())))\ncnt = [0 for i in range(n)]\ns -= 1\nf -= 1\n\ns, f = min(s, f), max(s, f)\n\nif numbers[0] == numbers[s]:\n    cnt[0] = 1\n    \nfor i in range(1, n):\n    if numbers[i] == numbers[s]:\n        cnt[i] = cnt[i - 1] + 1\n    else:\n        cnt[i] = cnt[i - 1]\n\nans = f - s\nif numbers[s] != numbers[f]:\n    l = -1\n    r = n\n    while (r > l + 1):\n        m = (r + l) // 2\n        if cnt[m] > cnt[f]:\n            r = m\n        else:\n            l = m\n       \n    \n    l = -1  \n    r = n\n    while (r > l + 1):\n        m = (r + l) // 2\n        if cnt[m] >= cnt[f]:\n            r = m\n        else:\n            l = m\n            \n    if r != n:\n        ans = min(ans, f - r)\nelse:\n    ans = 0\n    \nstdout.write(str(ans))",
        "correct": false,
        "task_id": "1089",
        "depth": 1
    },
    {
        "description": "There are N blocks arranged in a row. Let us paint these blocks.\n\nWe will consider two ways to paint the blocks different if and only if there is a block painted in different colors in those two ways.\n\nFind the number of ways to paint the blocks under the following conditions:\n\n* For each block, use one of the M colors, Color 1 through Color M, to paint it. It is not mandatory to use all the colors.\n* There may be at most K pairs of adjacent blocks that are painted in the same color.\n\n\n\nSince the count may be enormous, print it modulo 998244353.\n\nConstraints\n\n* All values in input are integers.\n* 1 \\leq N, M \\leq 2 \\times 10^5\n* 0 \\leq K \\leq N - 1\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M K\n\n\nOutput\n\nPrint the answer.\n\nExamples\n\nInput\n\n3 2 1\n\n\nOutput\n\n6\n\n\nInput\n\n100 100 0\n\n\nOutput\n\n73074801\n\n\nInput\n\n60522 114575 7559\n\n\nOutput\n\n479519525",
        "task_name": "p02685 AtCoder Beginner Contest 167 - Colorful Blocks",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout, setrecursionlimit\nfrom functools import lru_cache\n\nrl = lambda: stdin.readline()\nrll = lambda: stdin.readline().split()\nrli = lambda: map(int, stdin.readline().split())\n\nINF, NINF = float('inf'), float('-inf')\n\ndef binom_tables(n, q):\n\tfact = [1 for _ in range(n + 1)]\n\tinv = [1 for _ in range(n + 1)]\n\tfor i in range(1, n+1):\n\t\tfact[i] = (fact[i-1] * i) % q\n\t\tinv[i] = pow(fact[i], q-2, q)\n\treturn fact, inv\n\ndef binom(n, k, q, F, I):\n\treturn (F[n]*((I[k]*I[n-k])%q))%q\n\ndef main():\n\tMOD = 998244353\n\tn, m, k = rli()\n\tF, I = binom_tables(n, MOD)\n\tans = 0\n\tfor i in range(n-k, n+1):\n\t\tans += (binom(n-1, i-1, MOD, F, I)*m*pow(m-1, i-1, MOD))%MOD\n\tprint(ans % MOD)\n\nif __name__ == \"__main__\":\n\tmain()",
        "correct": false,
        "task_id": "1095",
        "depth": 1
    },
    {
        "description": "Given are a prime number p and a sequence of p integers a_0, \\ldots, a_{p-1} consisting of zeros and ones.\n\nFind a polynomial of degree at most p-1, f(x) = b_{p-1} x^{p-1} + b_{p-2} x^{p-2} + \\ldots + b_0, satisfying the following conditions:\n\n* For each i (0 \\leq i \\leq p-1), b_i is an integer such that 0 \\leq b_i \\leq p-1.\n* For each i (0 \\leq i \\leq p-1), f(i) \\equiv a_i \\pmod p.\n\nConstraints\n\n* 2 \\leq p \\leq 2999\n* p is a prime number.\n* 0 \\leq a_i \\leq 1\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\np\na_0 a_1 \\ldots a_{p-1}\n\n\nOutput\n\nPrint b_0, b_1, \\ldots, b_{p-1} of a polynomial f(x) satisfying the conditions, in this order, with spaces in between.\n\nIt can be proved that a solution always exists. If multiple solutions exist, any of them will be accepted.\n\nExamples\n\nInput\n\n2\n1 0\n\n\nOutput\n\n1 1\n\n\nInput\n\n3\n0 0 0\n\n\nOutput\n\n0 0 0\n\n\nInput\n\n5\n0 1 0 1 0\n\n\nOutput\n\n0 2 0 1 3",
        "task_name": "p02950 AtCoder Beginner Contest 137 - Polynomial Construction",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom __builtin__ import xrange as range\nfrom cStringIO import StringIO\nfrom io import IOBase\n\nimport __pypy__\n\n\ndef mcrt(A, b, p):\n    \"\"\"returns x s.t. Ax = b mod p\"\"\"\n    x = [0] * len(A)\n\n    m = 1\n    for i, Ai in enumerate(A):\n        tot = sum(Ai[k] * x[k] for k in range(len(A)))\n        tmp = (pow(Ai[-1], p - 2, p) * (b[i] - tot)) % p\n        x[i] += tmp\n        m *= p\n\n    return [xi % p for xi in x]\n\n\ndef main():\n    p = int(input())\n    b = [int(x) for x in input().split()]\n    A = [[0] * (p - 1) for _ in range(p - 1)]\n    for i, Ai in enumerate(A):\n        i += 1\n        x = i\n        for j in range(p - 1):\n            Ai[j] = x\n            x *= i\n            x %= p\n\n    print(*([b[0]] + mcrt(A, [b[i] - b[0] for i in range(1, p)], p)))\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0,\n                              2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": false,
        "task_id": "1097",
        "depth": 2
    },
    {
        "description": "You are given a sequence of n digits d_1d_2 ... d_{n}. You need to paint all the digits in two colors so that:\n\n  * each digit is painted either in the color 1 or in the color 2; \n  * if you write in a row from left to right all the digits painted in the color 1, and then after them all the digits painted in the color 2, then the resulting sequence of n digits will be non-decreasing (that is, each next digit will be greater than or equal to the previous digit). \n\n\n\nFor example, for the sequence d=914 the only valid coloring is 211 (paint in the color 1 two last digits, paint in the color 2 the first digit). But 122 is not a valid coloring (9 concatenated with 14 is not a non-decreasing sequence).\n\nIt is allowed that either of the two colors is not used at all. Digits painted in the same color are not required to have consecutive positions.\n\nFind any of the valid ways to paint the given sequence of digits or determine that it is impossible to do.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the input.\n\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 the length of a given sequence of digits.\n\nThe next line contains a sequence of n digits d_1d_2 ... d_{n} (0 \u2264 d_i \u2264 9). The digits are written in a row without spaces or any other separators. The sequence can start with 0.\n\nIt is guaranteed that the sum of the values \u200b\u200bof n for all test cases in the input does not exceed 2\u22c510^5.\n\nOutput\n\nPrint t lines \u2014 the answers to each of the test cases in the input.\n\nIf there is a solution for a test case, the corresponding output line should contain any of the valid colorings written as a string of n digits t_1t_2 ... t_n (1 \u2264 t_i \u2264 2), where t_i is the color the i-th digit is painted in. If there are several feasible solutions, print any of them.\n\nIf there is no solution, then the corresponding output line should contain a single character '-' (the minus sign).\n\nExample\n\nInput\n\n\n5\n12\n040425524644\n1\n0\n9\n123456789\n2\n98\n3\n987\n\n\nOutput\n\n\n121212211211\n1\n222222222\n21\n-\n\nNote\n\nIn the first test case, d=040425524644. The output t=121212211211 is correct because 0022444 (painted in 1) concatenated with 44556 (painted in 2) is 002244444556 which is a sorted sequence of n given digits.",
        "task_name": "1209_C. Paint the Digits",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import print_function # for PyPy2\nfrom collections import Counter, OrderedDict\nfrom itertools import permutations as perm\nfrom collections import deque\nfrom sys import stdin\nfrom bisect import *\nfrom heapq import *\nimport math\n \ng   = lambda : stdin.readline().strip()\ngl  = lambda : g().split()\ngil = lambda : [int(var) for var in gl()]\ngfl = lambda : [float(var) for var in gl()]\ngcl = lambda : list(g())\ngbs = lambda : [int(var) for var in g()]\nmod = int(1e9)+7\ninf = float(\"inf\")\n\nt, = gil()\n\nfor _ in range(t):\n\t# print()\n\tn, = gil()\n\tval = gbs()\n\tidx = list(xrange(n))\n\tidx.sort(key=lambda x : [val[x], x])\n\t# print(idx) \n\tone = []\n\tto = []\n\n\tfor ix in idx:\n\t\tif ix > (one[-1] if one else -1) and val[ix] <= (val[to[0]] if to else inf):\n\t\t\tone.append(ix)\n\t\telif ix > (to[-1] if to else -1):\n\t\t\tto.append(ix)\n\t\telse:\n\t\t\tbreak\n\n\tif len(one) + len(to) == n:\n\t\t# print(one, to)\n\t\tfor ix in one:\n\t\t\tval[ix] = 1\n\t\tfor ix in to:\n\t\t\tval[ix] = 2\n\t\tfor v in val:\n\t\t\tprint(v, end=\"\")\n\t\tprint()\n\telse:\n\t\t# print(one, to)\n\t\tprint(\"-\")",
        "correct": true,
        "task_id": "1110",
        "depth": 2
    },
    {
        "description": "Madeline has an array a of n integers. A pair (u, v) of integers forms an inversion in a if:\n\n  * 1 \u2264 u < v \u2264 n. \n  * a_u > a_v. \n\n\n\nMadeline recently found a magical paper, which allows her to write two indices u and v and swap the values a_u and a_v. Being bored, she decided to write a list of pairs (u_i, v_i) with the following conditions:\n\n  * all the pairs in the list are distinct and form an inversion in a. \n  * all the pairs that form an inversion in a are in the list. \n  * Starting from the given array, if you swap the values at indices u_1 and v_1, then the values at indices u_2 and v_2 and so on, then after all pairs are processed, the array a will be sorted in non-decreasing order. \n\n\n\nConstruct such a list or determine that no such list exists. If there are multiple possible answers, you may find any of them.\n\nInput\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 1000) \u2014 the length of the array.\n\nNext line contains n integers a_1,a_2,...,a_n (1 \u2264 a_i \u2264 10^9) \u2014 elements of the array.\n\nOutput\n\nPrint -1 if no such list exists. Otherwise in the first line you should print a single integer m (0 \u2264 m \u2264 (n(n-1))/(2)) \u2014 number of pairs in the list.\n\nThe i-th of the following m lines should contain two integers u_i, v_i (1 \u2264 u_i < v_i\u2264 n).\n\nIf there are multiple possible answers, you may find any of them.\n\nExamples\n\nInput\n\n\n3\n3 1 2\n\n\nOutput\n\n\n2\n1 3\n1 2\n\n\nInput\n\n\n4\n1 8 1 6\n\n\nOutput\n\n\n2\n2 4\n2 3\n\n\nInput\n\n\n5\n1 1 1 2 2\n\n\nOutput\n\n\n0\n\nNote\n\nIn the first sample test case the array will change in this order [3,1,2] \u2192 [2,1,3] \u2192 [1,2,3].\n\nIn the second sample test case it will be [1,8,1,6] \u2192 [1,6,1,8] \u2192 [1,1,6,8].\n\nIn the third sample test case the array is already sorted.",
        "task_name": "1375_E. Inversion SwapSort",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdout\ndef main():\n    n = int(raw_input())\n    a = map(int, raw_input().split())\n    d = [[] for _ in xrange(n)]\n    for i in xrange(n):\n        for j in xrange(i + 1, n):\n            if a[i] > a[j]:\n                d[i].append(j)\n    ans = []\n    for i in xrange(n):\n        d[i].sort(key=lambda x: (-a[x], -x))\n        for j in d[i]:\n            ans.append((i + 1, j + 1))\n            a[i], a[j] = a[j], a[i]\n    stdout.write(str(len(ans)) + '\\n')\n    stdout.write(''.join(\"%d %d\\n\" % (x, y) for x, y in ans))\nmain()\n",
        "correct": false,
        "task_id": "1114",
        "depth": 2
    },
    {
        "description": "Little Vasya has received a young builder\u2019s kit. The kit consists of several wooden bars, the lengths of all of them are known. The bars can be put one on the top of the other if their lengths are the same.\n\nVasya wants to construct the minimal number of towers from the bars. Help Vasya to use the bars in the best way possible.\n\nInput\n\nThe first line contains an integer N (1 \u2264 N \u2264 1000) \u2014 the number of bars at Vasya\u2019s disposal. The second line contains N space-separated integers li \u2014 the lengths of the bars. All the lengths are natural numbers not exceeding 1000.\n\nOutput\n\nIn one line output two numbers \u2014 the height of the largest tower and their total number. Remember that Vasya should use all the bars.\n\nExamples\n\nInput\n\n3\n1 2 3\n\n\nOutput\n\n1 3\n\n\nInput\n\n4\n6 5 6 7\n\n\nOutput\n\n2 3",
        "task_name": "37_A. Towers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\ninput = sys.stdin\noutput = sys.stdout\n'''\ninput = open('input.txt','r')\noutput = open('output.txt','w')\n'''\n\ninput.readline()\nwoods = map(lambda x: int(x), input.readline().strip().split(' '))\n\nd = {}\nfor w in woods:\n  d[w] = d.setdefault(w,0) + 1\n  \noutput.write('%d %d'%(max(d.values()), len(d)))\noutput.close()\n\n",
        "correct": true,
        "task_id": "1126",
        "depth": 1
    },
    {
        "description": "International Abbreviation Olympiad takes place annually starting from 1989. Each year the competition receives an abbreviation of form IAO'y, where y stands for some number of consequent last digits of the current year. Organizers always pick an abbreviation with non-empty string y that has never been used before. Among all such valid abbreviations they choose the shortest one and announce it to be the abbreviation of this year's competition.\n\nFor example, the first three Olympiads (years 1989, 1990 and 1991, respectively) received the abbreviations IAO'9, IAO'0 and IAO'1, while the competition in 2015 received an abbreviation IAO'15, as IAO'5 has been already used in 1995.\n\nYou are given a list of abbreviations. For each of them determine the year it stands for.\n\nInput\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 1000) \u2014 the number of abbreviations to process. \n\nThen n lines follow, each containing a single abbreviation. It's guaranteed that each abbreviation contains at most nine digits.\n\nOutput\n\nFor each abbreviation given in the input, find the year of the corresponding Olympiad.\n\nExamples\n\nInput\n\n5\nIAO'15\nIAO'2015\nIAO'1\nIAO'9\nIAO'0\n\n\nOutput\n\n2015\n12015\n1991\n1989\n1990\n\n\nInput\n\n4\nIAO'9\nIAO'99\nIAO'999\nIAO'9999\n\n\nOutput\n\n1989\n1999\n2999\n9999",
        "task_name": "664_C. International Olympiad",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = input()\n\nbase = 1989\nm = 9\npower_of_10 = [10**i for i in range(1, 1+m)]\ncut_off = [0] + power_of_10\nfor i in range(1,m):\n    cut_off[i] += cut_off[i-1]\n\ncut_off = [ base + cut for cut in cut_off]\ncut_off_str = [str(cut_off[i])[:-(i+1)] for i in range(1+m)]\n\ndef find_year(code_str):\n    code_len = len(code_str)\n    tmp = int(cut_off_str[code_len - 1] + code_str)\n    if tmp < cut_off[code_len - 1]:\n        tmp += power_of_10[code_len - 1]\n    return tmp\n\nfor _ in range(n):\n    print(find_year(raw_input().split(\"'\")[1]))",
        "correct": true,
        "task_id": "1133",
        "depth": 1
    },
    {
        "description": "Taro has decided to move. Taro has a lot of luggage, so I decided to ask a moving company to carry the luggage. Since there are various weights of luggage, I asked them to arrange them in order from the lightest one for easy understanding, but the mover left the luggage in a different order. So Taro tried to sort the luggage, but the luggage is heavy and requires physical strength to carry. Each piece of luggage can be carried from where it is now to any place you like, such as between other pieces of luggage or at the edge of the piece of luggage, but carrying one piece of luggage uses as much physical strength as the weight of that piece of luggage. Taro doesn't have much physical strength, so I decided to think of a way to arrange the luggage in order from the lightest one without using as much physical strength as possible.\n\nConstraints\n\n> 1 \u2264 n \u2264 105\n> 1 \u2264 xi \u2264 n (1 \u2264 i \u2264 n)\n> xi \u2260 xj (1 \u2264 i, j \u2264 n and i \u2260 j)\n>\n\n* All inputs are given as integers\n\nInput\n\n> n\n> x1 x2 ... xn\n>\n\n* n represents the number of luggage that Taro has\n* x1 to xn represent the weight of each piece of luggage, and are currently arranged in the order of x1, x2, ..., xn.\n\nOutput\n\n> S\n>\n\n* Output the total S of the minimum physical strength required to arrange the luggage in order from the lightest, but output the line break at the end\n\nExamples\n\nInput\n\n4\n1 4 2 3\n\n\nOutput\n\n4\n\n\nInput\n\n5\n1 5 3 2 4\n\n\nOutput\n\n7\n\n\nInput\n\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n0\n\n\nInput\n\n8\n6 2 1 3 8 5 4 7\n\n\nOutput\n\n19",
        "task_name": "p01545 House Moving",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import math\nimport sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass FenwickTree:\n    def __init__(self, a_list, f, default):\n        # 0-indexed\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << (math.ceil(math.log(self.N, 2)))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | (i + 1)] = self.f(self.bit[i | (i + 1)], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        # [0, n]\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & (n + 1)) - 1\n        return ret\n\n\nN = int(input())\nX = [int(x) for x in input().split()]\ndp = FenwickTree([0] * N, lambda x, y: max(x, y), 0)\nfor x, i in sorted((x, i) for i, x in enumerate(X)):\n    dp.update(i, dp.query(i) + x)\nprint(N * (N + 1) // 2 - dp.query(N - 1))",
        "correct": false,
        "task_id": "1149",
        "depth": 1
    },
    {
        "description": "The sequence of integers a_1, a_2, ..., a_k is called a good array if a_1 = k - 1 and a_1 > 0. For example, the sequences [3, -1, 44, 0], [1, -99] are good arrays, and the sequences [3, 7, 8], [2, 5, 4, 1], [0] \u2014 are not.\n\nA sequence of integers is called good if it can be divided into a positive number of good arrays. Each good array should be a subsegment of sequence and each element of the sequence should belong to exactly one array. For example, the sequences [2, -3, 0, 1, 4], [1, 2, 3, -3, -9, 4] are good, and the sequences [2, -3, 0, 1], [1, 2, 3, -3 -9, 4, 1] \u2014 are not.\n\nFor a given sequence of numbers, count the number of its subsequences that are good sequences, and print the number of such subsequences modulo 998244353.\n\nInput\n\nThe first line contains the number n~(1 \u2264 n \u2264 10^3) \u2014 the length of the initial sequence. The following line contains n integers a_1, a_2, ..., a_n~(-10^9 \u2264 a_i \u2264 10^9) \u2014 the sequence itself.\n\nOutput\n\nIn the single line output one integer \u2014 the number of subsequences of the original sequence that are good sequences, taken modulo 998244353.\n\nExamples\n\nInput\n\n3\n2 1 1\n\n\nOutput\n\n2\n\n\nInput\n\n4\n1 1 1 1\n\n\nOutput\n\n7\n\nNote\n\nIn the first test case, two good subsequences \u2014 [a_1, a_2, a_3] and [a_2, a_3].\n\nIn the second test case, seven good subsequences \u2014 [a_1, a_2, a_3, a_4], [a_1, a_2], [a_1, a_3], [a_1, a_4], [a_2, a_3], [a_2, a_4] and [a_3, a_4].",
        "task_name": "1000_D. Yet Another Problem On a Subsequence",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "mod=998244353\n\nc=[[0]*2000 for i in range(2000)]\nc[0][0]=1\nfor i in range(1,1005):\n    c[i][0] = 1\n    c[i][i] = 1\n    for j in range(1, i):\n        c[i][j] = c[i-1][j] + c[i-1][j-1]\n        c[i][j]%=mod\n\ndef getc(n, k):\n    if k>n:\n        return 0\n    return c[n][k]\n\nn = int(raw_input())\nsrc=map(int, raw_input().split())\n# n=3\n# src=[2,1,1]\n# n=4\n# src=[1,1,1,1]\n\ndp=[0]*(n+1)\ndp[n] = 1\n\nfor i in range(n-1, -1, -1):\n    if src[i] < 1:\n        continue\n    for j in range(i+1, n+1):\n        dp[i] += dp[j] * getc(j-i-1, src[i])\n        dp[i]%=mod\n\nprint (sum(dp)-1)%mod\n",
        "correct": true,
        "task_id": "1152",
        "depth": 2
    },
    {
        "description": "Monocarp has got two strings s and t having equal length. Both strings consist of lowercase Latin letters \"a\" and \"b\". \n\nMonocarp wants to make these two strings s and t equal to each other. He can do the following operation any number of times: choose an index pos_1 in the string s, choose an index pos_2 in the string t, and swap s_{pos_1} with t_{pos_2}.\n\nYou have to determine the minimum number of operations Monocarp has to perform to make s and t equal, and print any optimal sequence of operations \u2014 or say that it is impossible to make these strings equal.\n\nInput\n\nThe first line contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^{5}) \u2014 the length of s and t.\n\nThe second line contains one string s consisting of n characters \"a\" and \"b\". \n\nThe third line contains one string t consisting of n characters \"a\" and \"b\". \n\nOutput\n\nIf it is impossible to make these strings equal, print -1.\n\nOtherwise, in the first line print k \u2014 the minimum number of operations required to make the strings equal. In each of the next k lines print two integers \u2014 the index in the string s and the index in the string t that should be used in the corresponding swap operation. \n\nExamples\n\nInput\n\n\n4\nabab\naabb\n\n\nOutput\n\n\n2\n3 3\n3 2\n\n\nInput\n\n\n1\na\nb\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n8\nbabbaabb\nabababaa\n\n\nOutput\n\n\n3\n2 6\n1 3\n7 8\n\nNote\n\nIn the first example two operations are enough. For example, you can swap the third letter in s with the third letter in t. Then s =  \"abbb\", t =  \"aaab\". Then swap the third letter in s and the second letter in t. Then both s and t are equal to \"abab\".\n\nIn the second example it's impossible to make two strings equal.",
        "task_name": "1215_C. Swap Letters",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n\n# target Expert  \n\n# Author : raj1307 - Raj Singh\n# Date   : 15.09.19\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial,pi\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\n \n \ndef main():\n \n    \n \n    #for _ in range(ii()):\n        \n    \n\n\n    n=ii()\n    s=si()\n    t=si()\n\n    s=list(s)\n    t=list(t)\n\n\n    a=0\n    b=0\n\n    for i in range(n):\n        if s[i]=='a':\n            a+=1\n        else:\n            b+=1\n\n        if t[i]=='a':\n            a+=1\n        else:\n            b+=1\n\n\n\n    if a%2==1 or b%2==1:\n        print(-1)\n        exit()\n\n\n    a=[]\n\n    b=[]\n    for i in range(n):\n\n        if s[i]!=t[i]:\n\n            if s[i]=='a':\n\n                a.append(i)\n\n            else:\n\n                b.append(i)\n\n\n    ans=[]\n    \n\n\n    if len(a)%2==0:\n        nn=len(a)\n    else:\n        nn=len(a)-1\n        ans.append([a[-1]+1,a[-1]+1])\n        s[a[-1]],t[a[-1]]=t[a[-1]],s[a[-1]]\n\n    \n    for i in range(0,nn,2):\n\n        ans.append([a[i]+1,a[i+1]+1])\n        s[a[i]],t[a[i+1]]=t[a[i+1]],s[a[i]]\n\n        #print([a[i]+1,a[i+1]+1])\n\n    b=[]\n    for i in range(n):\n\n        if s[i]!=t[i]:\n\n            if s[i]=='a':\n\n                a.append(i)\n\n            else:\n\n                b.append(i)\n\n\n    for i in range(0,len(b),2):\n        ans.append([b[i]+1,b[i+1]+1])\n\n\n \n    print(len(a))\n    for i in ans:\n        print(*i)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": false,
        "task_id": "1158",
        "depth": 1
    },
    {
        "description": "One day shooshuns found a sequence of n integers, written on a blackboard. The shooshuns can perform one operation with it, the operation consists of two steps:\n\n  1. Find the number that goes k-th in the current sequence and add the same number to the end of the sequence; \n  2. Delete the first number of the current sequence. \n\n\n\nThe shooshuns wonder after how many operations all numbers on the board will be the same and whether all numbers will ever be the same.\n\nInput\n\nThe first line contains two space-separated integers n and k (1 \u2264 k \u2264 n \u2264 105).\n\nThe second line contains n space-separated integers: a1, a2, ..., an (1 \u2264 ai \u2264 105) \u2014 the sequence that the shooshuns found.\n\nOutput\n\nPrint the minimum number of operations, required for all numbers on the blackboard to become the same. If it is impossible to achieve, print -1.\n\nExamples\n\nInput\n\n3 2\n3 1 1\n\n\nOutput\n\n1\n\n\nInput\n\n3 1\n3 1 1\n\n\nOutput\n\n-1\n\nNote\n\nIn the first test case after the first operation the blackboard will have sequence [1, 1, 1]. So, one operation is enough to make all numbers the same. Thus, the answer equals one.\n\nIn the second test case the sequence will never consist of the same numbers. It will always contain at least two distinct numbers 3 and 1. Thus, the answer equals -1.",
        "task_name": "222_A. Shooshuns and Sequence ",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n,k = map(int,raw_input().split())\n\nls = map(int,raw_input().split())\ntmp = ls[k-1]\ncheck = True\nfor i in range(k,n):\n    if ls[i]!=tmp:\n        check = False\n\nif check:\n    print(k-1)\nelse:\n    print(-1)",
        "correct": false,
        "task_id": "1169",
        "depth": 1
    },
    {
        "description": "Shaass has n books. He wants to make a bookshelf for all his books. He wants the bookshelf's dimensions to be as small as possible. The thickness of the i-th book is ti and its pages' width is equal to wi. The thickness of each book is either 1 or 2. All books have the same page heights.\n\n<image>\n\nShaass puts the books on the bookshelf in the following way. First he selects some of the books and put them vertically. Then he puts the rest of the books horizontally above the vertical books. The sum of the widths of the horizontal books must be no more than the total thickness of the vertical books. A sample arrangement of the books is depicted in the figure.\n\n<image>\n\nHelp Shaass to find the minimum total thickness of the vertical books that we can achieve.\n\nInput\n\nThe first line of the input contains an integer n, (1 \u2264 n \u2264 100). Each of the next n lines contains two integers ti and wi denoting the thickness and width of the i-th book correspondingly, (1 \u2264 ti \u2264 2, 1 \u2264 wi \u2264 100).\n\nOutput\n\nOn the only line of the output print the minimum total thickness of the vertical books that we can achieve.\n\nExamples\n\nInput\n\n5\n1 12\n1 3\n2 15\n2 5\n2 1\n\n\nOutput\n\n5\n\n\nInput\n\n3\n1 10\n2 1\n2 4\n\n\nOutput\n\n3",
        "task_name": "294_B. Shaass and Bookshelf",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\n\nmyBooks = []\nW = 0\n\nfor i in range(0,n):\n    t, w = map(int, raw_input().split())\n    W += w\n    myBooks.append([w, t])\n    \nmyBooks.sort()\nmyBooks.reverse()\n\nT = 0\nfor book in myBooks:\n    T += book[1]\n    W -= book[0]\n    if(W<=T):\n        break\n    \nprint(T)\n",
        "correct": false,
        "task_id": "1170",
        "depth": 1
    },
    {
        "description": "Fox Ciel is playing a game with numbers now. \n\nCiel has n positive integers: x1, x2, ..., xn. She can do the following operation as many times as needed: select two different indexes i and j such that xi > xj hold, and then apply assignment xi = xi - xj. The goal is to make the sum of all numbers as small as possible.\n\nPlease help Ciel to find this minimal sum.\n\nInput\n\nThe first line contains an integer n (2 \u2264 n \u2264 100). Then the second line contains n integers: x1, x2, ..., xn (1 \u2264 xi \u2264 100).\n\nOutput\n\nOutput a single integer \u2014 the required minimal sum.\n\nExamples\n\nInput\n\n2\n1 2\n\n\nOutput\n\n2\n\n\nInput\n\n3\n2 4 6\n\n\nOutput\n\n6\n\n\nInput\n\n2\n12 18\n\n\nOutput\n\n12\n\n\nInput\n\n5\n45 12 27 30 18\n\n\nOutput\n\n15\n\nNote\n\nIn the first example the optimal way is to do the assignment: x2 = x2 - x1.\n\nIn the second example the optimal sequence of operations is: x3 = x3 - x2, x2 = x2 - x1.",
        "task_name": "389_A. Fox and Number Game",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n=int(raw_input())\nx=raw_input().split(\" \")\nfor i in xrange(len(x)):\n\tx[i]=int(x[i])\nx.sort()\nsolved=False\nwhile True:\n\t#print x\n\tx.sort()\n\tfor j in xrange(n-1):\n\t\tif x[j+1] > x[j]:\n\t\t\tx[j+1]=x[j+1]-x[j]\n\tsolved=True\n\tfor j in xrange(n-1):\n\t\tif x[j+1]!=x[j]:\n\t\t\tsolved=False\n\t\t\tbreak\n\tif solved: break\n\t#print x\nprint (x[0]*n)\n",
        "correct": true,
        "task_id": "1172",
        "depth": 2
    },
    {
        "description": "Bearland has n cities, numbered 1 through n. Cities are connected via bidirectional roads. Each road connects two distinct cities. No two roads connect the same pair of cities.\n\nBear Limak was once in a city a and he wanted to go to a city b. There was no direct connection so he decided to take a long walk, visiting each city exactly once. Formally: \n\n  * There is no road between a and b. \n  * There exists a sequence (path) of n distinct cities v1, v2, ..., vn that v1 = a, vn = b and there is a road between vi and vi + 1 for <image>. \n\n\n\nOn the other day, the similar thing happened. Limak wanted to travel between a city c and a city d. There is no road between them but there exists a sequence of n distinct cities u1, u2, ..., un that u1 = c, un = d and there is a road between ui and ui + 1 for <image>.\n\nAlso, Limak thinks that there are at most k roads in Bearland. He wonders whether he remembers everything correctly.\n\nGiven n, k and four distinct cities a, b, c, d, can you find possible paths (v1, ..., vn) and (u1, ..., un) to satisfy all the given conditions? Find any solution or print -1 if it's impossible.\n\nInput\n\nThe first line of the input contains two integers n and k (4 \u2264 n \u2264 1000, n - 1 \u2264 k \u2264 2n - 2) \u2014 the number of cities and the maximum allowed number of roads, respectively.\n\nThe second line contains four distinct integers a, b, c and d (1 \u2264 a, b, c, d \u2264 n).\n\nOutput\n\nPrint -1 if it's impossible to satisfy all the given conditions. Otherwise, print two lines with paths descriptions. The first of these two lines should contain n distinct integers v1, v2, ..., vn where v1 = a and vn = b. The second line should contain n distinct integers u1, u2, ..., un where u1 = c and un = d.\n\nTwo paths generate at most 2n - 2 roads: (v1, v2), (v2, v3), ..., (vn - 1, vn), (u1, u2), (u2, u3), ..., (un - 1, un). Your answer will be considered wrong if contains more than k distinct roads or any other condition breaks. Note that (x, y) and (y, x) are the same road.\n\nExamples\n\nInput\n\n7 11\n2 4 7 3\n\n\nOutput\n\n2 7 1 3 6 5 4\n7 1 5 4 6 2 3\n\n\nInput\n\n1000 999\n10 20 30 40\n\n\nOutput\n\n-1\n\nNote\n\nIn the first sample test, there should be 7 cities and at most 11 roads. The provided sample solution generates 10 roads, as in the drawing. You can also see a simple path of length n between 2 and 4, and a path between 7 and 3.\n\n<image>",
        "task_name": "673_D. Bear and Two Paths",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\n\nn,k=map(int,input().split())\na,b,c,d=map(int,input().split())\n\nif n==4:\n    # special case\n    print(\"-1\")\nelif k>=n+1:\n    # i know that having n+1 roads is possible\n    # assume n>=5\n    # get the chain\n    chain=[a,c]\n    for i in range(1,n+1):\n        if i not in [a,b,c,d]:\n            chain.append(i)\n    chain.append(b)\n    chain.append(d)\n    # print first path\n    p1=list(chain)\n    p1[-1],p1[-2]=p1[-2],p1[-1]\n    print(\" \".join(map(str,p1)))\n    # print second path\n    p2=list(chain)\n    p2[0],p2[1]=p2[1],p2[0]\n    print(\" \".join(map(str,p2)))\nelse:\n    print(\"-1\")",
        "correct": true,
        "task_id": "1177",
        "depth": 1
    },
    {
        "description": "Sometimes some words like \"localization\" or \"internationalization\" are so long that writing them many times in one text is quite tiresome.\n\nLet's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.\n\nThis abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.\n\nThus, \"localization\" will be spelt as \"l10n\", and \"internationalization\u00bb will be spelt as \"i18n\".\n\nYou are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.\n\nInput\n\nThe first line contains an integer n (1 \u2264 n \u2264 100). Each of the following n lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.\n\nOutput\n\nPrint n lines. The i-th line should contain the result of replacing of the i-th word from the input data.\n\nExamples\n\nInput\n\n4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n\n\nOutput\n\nword\nl10n\ni18n\np43s",
        "task_name": "71_A. Way Too Long Words",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\ndef getArgs():\n  args = []\n  for line in sys.stdin:\n    args.append(line)\n  return args\n\ndef shortenWord(word):\n  n = len(word) - 2\n  return word[0] + str(n) + word[n+1]\n\nargLines = getArgs()\n\nn = int(argLines[0])\nargLines.pop(0)\nfor word in argLines:\n  w = word.replace('\\n', '')\n  if(len(w) > 10):\n    print(shortenWord(w))\n  else:\n    print(w)\n",
        "correct": true,
        "task_id": "1178",
        "depth": 1
    },
    {
        "description": "Young Timofey has a birthday today! He got kit of n cubes as a birthday present from his parents. Every cube has a number ai, which is written on it. Timofey put all the cubes in a row and went to unpack other presents.\n\nIn this time, Timofey's elder brother, Dima reordered the cubes using the following rule. Suppose the cubes are numbered from 1 to n in their order. Dima performs several steps, on step i he reverses the segment of cubes from i-th to (n - i + 1)-th. He does this while i \u2264 n - i + 1.\n\nAfter performing the operations Dima went away, being very proud of himself. When Timofey returned to his cubes, he understood that their order was changed. Help Timofey as fast as you can and save the holiday \u2014 restore the initial order of the cubes using information of their current location.\n\nInput\n\nThe first line contains single integer n (1 \u2264 n \u2264 2\u00b7105) \u2014 the number of cubes.\n\nThe second line contains n integers a1, a2, ..., an ( - 109 \u2264 ai \u2264 109), where ai is the number written on the i-th cube after Dima has changed their order.\n\nOutput\n\nPrint n integers, separated by spaces \u2014 the numbers written on the cubes in their initial order.\n\nIt can be shown that the answer is unique.\n\nExamples\n\nInput\n\n7\n4 3 7 6 9 1 2\n\n\nOutput\n\n2 3 9 6 7 1 4\n\nInput\n\n8\n6 1 4 2 5 6 9 2\n\n\nOutput\n\n2 1 6 2 5 4 9 6\n\nNote\n\nConsider the first sample.\n\n  1. At the begining row was [2, 3, 9, 6, 7, 1, 4]. \n  2. After first operation row was [4, 1, 7, 6, 9, 3, 2]. \n  3. After second operation row was [4, 3, 9, 6, 7, 1, 2]. \n  4. After third operation row was [4, 3, 7, 6, 9, 1, 2]. \n  5. At fourth operation we reverse just middle element, so nothing has changed. The final row is [4, 3, 7, 6, 9, 1, 2]. So the answer for this case is row [2, 3, 9, 6, 7, 1, 4]. ",
        "task_name": "764_B. Timofey and cubes",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\nvalues = raw_input().split()\nfor i in range(0, n//2, 2):\n    j = n-1-i\n    values[i], values[j] = values[j], values[i]\nprint(' '.join(values))\n",
        "correct": true,
        "task_id": "1180",
        "depth": 1
    },
    {
        "description": "N tiles are arranged in a row from left to right. The initial color of each tile is represented by a string S of length N.\n\nThe i-th tile from the left is painted black if the i-th character of S is `0`, and painted white if that character is `1`.\n\nYou want to repaint some of the tiles black or white, so that any two adjacent tiles have different colors.\n\nAt least how many tiles need to be repainted to satisfy the condition?\n\nConstraints\n\n* 1 \\leq |S| \\leq 10^5\n* S_i is `0` or `1`.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nS\n\n\nOutput\n\nPrint the minimum number of tiles that need to be repainted to satisfy the condition.\n\nExamples\n\nInput\n\n000\n\n\nOutput\n\n1\n\n\nInput\n\n10010010\n\n\nOutput\n\n3\n\n\nInput\n\n0\n\n\nOutput\n\n0",
        "task_name": "p03073 AtCoder Beginner Contest 124 - Coloring Colorfully",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "s = input()\nc = 0\nfor i, a in enumerate(s):\n    if i % 2 == 0 and a == '0':\n        c += 1\n    if i % 2 == 1 and a == '1':\n        c += 1\nprint(min(c, len(s)-c))",
        "correct": false,
        "task_id": "1186",
        "depth": 1
    },
    {
        "description": "The only difference between easy and hard versions is the constraints.\n\nVova likes pictures with kittens. The news feed in the social network he uses can be represented as an array of n consecutive pictures (with kittens, of course). Vova likes all these pictures, but some are more beautiful than the others: the i-th picture has beauty a_i.\n\nVova wants to repost exactly x pictures in such a way that: \n\n  * each segment of the news feed of at least k consecutive pictures has at least one picture reposted by Vova; \n  * the sum of beauty values of reposted pictures is maximum possible. \n\n\n\nFor example, if k=1 then Vova has to repost all the pictures in the news feed. If k=2 then Vova can skip some pictures, but between every pair of consecutive pictures Vova has to repost at least one of them.\n\nYour task is to calculate the maximum possible sum of values of reposted pictures if Vova follows conditions described above, or say that there is no way to satisfy all conditions.\n\nInput\n\nThe first line of the input contains three integers n, k and x (1 \u2264 k, x \u2264 n \u2264 200) \u2014 the number of pictures in the news feed, the minimum length of segment with at least one repost in it and the number of pictures Vova is ready to repost.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9), where a_i is the beauty of the i-th picture.\n\nOutput\n\nPrint -1 if there is no way to repost some pictures to satisfy all the conditions in the problem statement.\n\nOtherwise print one integer \u2014 the maximum sum of values of reposted pictures if Vova follows conditions described in the problem statement.\n\nExamples\n\nInput\n\n\n5 2 3\n5 1 3 10 1\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n6 1 5\n10 30 30 70 10 10\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n4 3 1\n1 100 1 1\n\n\nOutput\n\n\n100",
        "task_name": "1077_F1. Pictures with Kittens (easy version)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys,math\nfrom fractions import gcd\nfrom bisect import bisect_left, bisect\nfrom collections import defaultdict\nfrom io import BytesIO\nsys.stdin = BytesIO(sys.stdin.read())\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n#n = int(input())\n#s = input()\nn,k,x = [int(_) for _ in input().split()]\n\narr = [int(_) for _ in input().split()]\nif k > 1:\n    rpr = {(x,1):0,(x-1,0):arr[0]}\nelse:\n    rpr = {(x-1,0):arr[0]}\ni = 1\nwhile i < n and len(rpr):\n    #print(i,rpr)\n    pr = defaultdict(int)\n    for ost,lag in rpr:\n        if lag + 1 == k:\n            if ost > 0:\n                pr[(ost-1,0)] = max(pr[(ost-1,0)],rpr[(ost,lag)] + arr[i])\n            else:\n                continue\n        else:\n            pr[(ost,lag+1)] = max(pr[(ost,lag+1)], rpr[(ost,lag)])\n            if ost > 0:\n                pr[(ost-1,0)] = max(pr[(ost-1,0)],rpr[(ost,lag)] + arr[i])\n    rpr = dict()\n    for ke in pr:\n        rpr[ke] = pr[ke]\n    i += 1\nif len(rpr):\n    m = 0\n    for k in rpr:\n        m = max(m,rpr[k])\n    print(m)\nelse:\n    print(-1)",
        "correct": true,
        "task_id": "1191",
        "depth": 2
    },
    {
        "description": "Let a be a matrix of size r \u00d7 c containing positive integers, not necessarily distinct. Rows of the matrix are numbered from 1 to r, columns are numbered from 1 to c. We can construct an array b consisting of r + c integers as follows: for each i \u2208 [1, r], let b_i be the greatest common divisor of integers in the i-th row, and for each j \u2208 [1, c] let b_{r+j} be the greatest common divisor of integers in the j-th column. \n\nWe call the matrix diverse if all r + c numbers b_k (k \u2208 [1, r + c]) are pairwise distinct. \n\nThe magnitude of a matrix equals to the maximum of b_k.\n\nFor example, suppose we have the following matrix:\n\n\\begin{pmatrix} 2 & 9 & 7\\\\\\ 4 & 144 & 84 \\end{pmatrix} \n\nWe construct the array b:\n\n  1. b_1 is the greatest common divisor of 2, 9, and 7, that is 1; \n  2. b_2 is the greatest common divisor of 4, 144, and 84, that is 4; \n  3. b_3 is the greatest common divisor of 2 and 4, that is 2; \n  4. b_4 is the greatest common divisor of 9 and 144, that is 9; \n  5. b_5 is the greatest common divisor of 7 and 84, that is 7. \n\n\n\nSo b = [1, 4, 2, 9, 7]. All values in this array are distinct, so the matrix is diverse. The magnitude is equal to 9.\n\nFor a given r and c, find a diverse matrix that minimises the magnitude. If there are multiple solutions, you may output any of them. If there are no solutions, output a single integer 0. \n\nInput\n\nThe only line in the input contains two space separated integers r and c (1 \u2264 r,c \u2264 500) \u2014 the number of rows and the number of columns of the matrix to be found.\n\nOutput\n\nIf there is no solution, output a single integer 0.\n\nOtherwise, output r rows. The i-th of them should contain c space-separated integers, the j-th of which is a_{i,j} \u2014 the positive integer in the i-th row and j-th column of a diverse matrix minimizing the magnitude.\n\nFurthermore, it must hold that 1 \u2264 a_{i,j} \u2264 10^9. It can be shown that if a solution exists, there is also a solution with this additional constraint (still having minimum possible magnitude).\n\nExamples\n\nInput\n\n\n2 2\n\n\nOutput\n\n\n4 12\n2 9\n\nInput\n\n\n1 1\n\n\nOutput\n\n\n0\n\nNote\n\nIn the first example, the GCDs of rows are b_1 = 4 and b_2 = 1, and the GCDs of columns are b_3 = 2 and b_4 = 3. All GCDs are pairwise distinct and the maximum of them is 4. Since the GCDs have to be distinct and at least 1, it is clear that there are no diverse matrices of size 2 \u00d7 2 with magnitude smaller than 4.\n\nIn the second example, no matter what a_{1,1} is, b_1 = b_2 will always hold, so there are no diverse matrices.",
        "task_name": "1266_C. Diverse Matrix",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "(r,c)=map(int,raw_input().split())\n\nif r==1 and c==1:\n\tprint(0)\n\t\nelse:\n\n\tflag=False\n\tif c==1:\n\t\tflag=True\n\t\t(r,c)=(c,r)\n\n\tl=[[1 for _ in range(c)] for _ in range(r)]\n\tb=[i+1 for i in range(r+c)]\n\n\tfor i in range(r):\n\t\tfor j in range(c):\n\t\t\tl[i][j]*=b[i]*b[r+j]\n\n\tif flag==False:\n\t\tfor i in range(r):\n\t\t\ts=\"\"\n\t\t\tfor j in range(c):\n\t\t\t\ts+=str(l[i][j])+\" \"\n\n\t\t\tprint(s)\n\n\telse:\n\t\tfor j in range(c):\t\n\t\t\ts=\"\"\n\t\t\tfor i in range(r):\n\t\t\t\ts+=str(l[i][j])+\" \"\n\n\t\t\tprint(s)\n",
        "correct": true,
        "task_id": "1196",
        "depth": 2
    },
    {
        "description": "Carousel Boutique is busy again! Rarity has decided to visit the pony ball and she surely needs a new dress, because going out in the same dress several times is a sign of bad manners. First of all, she needs a dress pattern, which she is going to cut out from the rectangular piece of the multicolored fabric.\n\nThe piece of the multicolored fabric consists of n \u00d7 m separate square scraps. Since Rarity likes dresses in style, a dress pattern must only include scraps sharing the same color. A dress pattern must be the square, and since Rarity is fond of rhombuses, the sides of a pattern must form a 45^{\\circ} angle with sides of a piece of fabric (that way it will be resembling the traditional picture of a rhombus).\n\nExamples of proper dress patterns: <image> Examples of improper dress patterns: <image> The first one consists of multi-colored scraps, the second one goes beyond the bounds of the piece of fabric, the third one is not a square with sides forming a 45^{\\circ} angle with sides of the piece of fabric.\n\nRarity wonders how many ways to cut out a dress pattern that satisfies all the conditions that do exist. Please help her and satisfy her curiosity so she can continue working on her new masterpiece!\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 2000). Each of the next n lines contains m characters: lowercase English letters, the j-th of which corresponds to scrap in the current line and in the j-th column. Scraps having the same letter share the same color, scraps having different letters have different colors.\n\nOutput\n\nPrint a single integer: the number of ways to cut out a dress pattern to satisfy all of Rarity's conditions.\n\nExamples\n\nInput\n\n\n3 3\naaa\naaa\naaa\n\n\nOutput\n\n\n10\n\n\nInput\n\n\n3 4\nabab\nbaba\nabab\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n5 5\nzbacg\nbaaac\naaaaa\neaaad\nweadd\n\n\nOutput\n\n\n31\n\nNote\n\nIn the first example, all the dress patterns of size 1 and one of size 2 are satisfactory.\n\nIn the second example, only the dress patterns of size 1 are satisfactory.",
        "task_name": "1393_D. Rarity and New Dress",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n\nimport sys\nfrom atexit import register\n\nif sys.version_info[0] < 3:\n    from io import BytesIO as stream\nelse:\n    from io import StringIO as stream\n\n\nsys.stdin = stream(sys.stdin.read())\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nsys.stdout = stream()\nregister(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\ndef solve():\n    n, m = read_ints()\n    table = []\n    for _ in range(n):\n        table.append(input())\n\n    def create_table():\n        return [[1 for _ in range(m)] for _ in range(n)]\n\n    top_left = create_table()\n    top_right = create_table()\n    bottom_left = create_table()\n    bottom_right = create_table()\n\n    for i in range(n):\n        for j in range(m):\n            if i > 0 and j > 0 and table[i-1][j] == table[i][j-1] == table[i][j]:\n                top_left[i][j] = min(top_left[i-1][j], top_left[i][j-1])+1\n\n    for i in range(n):\n        for j in range(m-1, -1, -1):\n            if i > 0 and j < m-1 and table[i-1][j] == table[i][j+1] == table[i][j]:\n                top_right[i][j] = min(top_right[i-1][j], top_right[i][j+1])+1\n\n    for i in range(n-1, -1, -1):\n        for j in range(m):\n            if i < n-1 and j > 0 and table[i+1][j] == table[i][j-1] == table[i][j]:\n                bottom_left[i][j] = min(bottom_left[i+1][j], bottom_left[i][j-1])+1\n\n    for i in range(n-1, -1, -1):\n        for j in range(m-1, -1, -1):\n            if i < n-1 and j < m-1 and table[i+1][j] == table[i][j+1] == table[i][j]:\n                bottom_right[i][j] = min(bottom_right[i+1][j], bottom_right[i][j+1])+1\n\n    answer = 0\n    for i in range(n):\n        for j in range(m):\n            answer += min(top_left[i][j], top_right[i][j], bottom_left[i][j], bottom_right[i][j])\n    return answer\n\nif __name__ == '__main__':\n    print(solve())\n",
        "correct": true,
        "task_id": "1198",
        "depth": 2
    },
    {
        "description": "You and your friend are playing the game Mortal Kombat XI. You are trying to pass a challenge tower. There are n bosses in this tower, numbered from 1 to n. The type of the i-th boss is a_i. If the i-th boss is easy then its type is a_i = 0, otherwise this boss is hard and its type is a_i = 1.\n\nDuring one session, either you or your friend can kill one or two bosses (neither you nor your friend can skip the session, so the minimum number of bosses killed during one session is at least one). After your friend session, your session begins, then again your friend session begins, your session begins, and so on. The first session is your friend's session.\n\nYour friend needs to get good because he can't actually kill hard bosses. To kill them, he uses skip points. One skip point can be used to kill one hard boss.\n\nYour task is to find the minimum number of skip points your friend needs to use so you and your friend kill all n bosses in the given order.\n\nFor example: suppose n = 8, a = [1, 0, 1, 1, 0, 1, 1, 1]. Then the best course of action is the following:\n\n  * your friend kills two first bosses, using one skip point for the first boss; \n  * you kill the third and the fourth bosses; \n  * your friend kills the fifth boss; \n  * you kill the sixth and the seventh bosses; \n  * your friend kills the last boss, using one skip point, so the tower is completed using two skip points. \n\n\n\nYou have to answer t independent test cases.\n\nInput\n\nThe first line of the input contains one integer t (1 \u2264 t \u2264 2 \u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\n\nThe first line of the test case contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of bosses. The second line of the test case contains n integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 1), where a_i is the type of the i-th boss.\n\nIt is guaranteed that the sum of n does not exceed 2 \u22c5 10^5 (\u2211 n \u2264 2 \u22c5 10^5).\n\nOutput\n\nFor each test case, print the answer: the minimum number of skip points your friend needs to use so you and your friend kill all n bosses in the given order.\n\nExample\n\nInput\n\n\n6\n8\n1 0 1 1 0 1 1 1\n5\n1 1 1 1 0\n7\n1 1 1 1 0 0 1\n6\n1 1 1 1 1 1\n1\n1\n1\n0\n\n\nOutput\n\n\n2\n2\n2\n2\n1\n0",
        "task_name": "1418_C. Mortal Kombat Tower",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "t=int(raw_input())\nfor _ in range(t):\n    n=int(raw_input())\n    A=map(int,raw_input().split())\n    A.reverse()\n    F=[0]*n\n    M=[0]*n\n    F[0]=A[0]\n    if n==1:\n        print(F[0])\n        continue\n    F[1]=A[1]\n    for i in range(2,n):\n        M[i]=min(F[i-1],F[i-2])\n        F[i]=min(A[i]+M[i-1],A[i]+A[i-1]+M[i-2])\n    print(F[-1])",
        "correct": true,
        "task_id": "1199",
        "depth": 2
    },
    {
        "description": "Ilya is very fond of graphs, especially trees. During his last trip to the forest Ilya found a very interesting tree rooted at vertex 1. There is an integer number written on each vertex of the tree; the number written on vertex i is equal to ai.\n\nIlya believes that the beauty of the vertex x is the greatest common divisor of all numbers written on the vertices on the path from the root to x, including this vertex itself. In addition, Ilya can change the number in one arbitrary vertex to 0 or leave all vertices unchanged. Now for each vertex Ilya wants to know the maximum possible beauty it can have.\n\nFor each vertex the answer must be considered independently.\n\nThe beauty of the root equals to number written on it.\n\nInput\n\nFirst line contains one integer number n \u2014 the number of vertices in tree (1 \u2264 n \u2264 2\u00b7105).\n\nNext line contains n integer numbers ai (1 \u2264 i \u2264 n, 1 \u2264 ai \u2264 2\u00b7105).\n\nEach of next n - 1 lines contains two integer numbers x and y (1 \u2264 x, y \u2264 n, x \u2260 y), which means that there is an edge (x, y) in the tree.\n\nOutput\n\nOutput n numbers separated by spaces, where i-th number equals to maximum possible beauty of vertex i.\n\nExamples\n\nInput\n\n2\n6 2\n1 2\n\n\nOutput\n\n6 6 \n\n\nInput\n\n3\n6 2 3\n1 2\n1 3\n\n\nOutput\n\n6 6 6 \n\n\nInput\n\n1\n10\n\n\nOutput\n\n10 ",
        "task_name": "842_C. Ilya And The Tree",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\na = map(int, raw_input().split())\n\ngraph = [[] for _ in range(n)]\n\nfor i in xrange(n - 1):\n    x, y = map(int, raw_input().split())\n    x -= 1; y -= 1\n#    print(x, y)\n    graph[x].append(y)\n    graph[y].append(x)\n#    graph\n#    a[i] = int(raw_input())\n    \n#n, k = map(int, raw_input().split())\n#s = str(raw_input())\n\n#a = map(int, raw_input().split())\n#b = [(y,x) for x,y in enumerate(map(int,raw_input().split()))]\n\nclass Info:\n    def __init__(self):\n        self.gcd = 0\n        self.tor1 = 0\n        self.ifr1 = 0\n        self.tor2 = 0\n        self.ifr2 = 0\n\n    def get(self):\n        r = self.gcd\n        if self.ifr1 > r:\n            r = self.ifr1\n        if self.ifr2 > r:\n            r = self.ifr2\n        return r\n\nvisited = [False] * n\n\ngcdinfo = [Info() for _ in xrange(n)]\n\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\ndef dfs(n, parent):\n    if visited[n]:\n        return\n    visited[n] = True\n    if parent != -1:\n        newgcd = gcd(gcdinfo[parent].gcd, a[n])\n#        print(\"newgcd=\", newgcd)\n        gcdinfo[n].gcd = newgcd\n        if newgcd < gcdinfo[parent].gcd:\n            # try removing self\n            gcdinfo[n].tor1 = a[n]\n            gcdinfo[n].ifr1 = gcdinfo[parent].gcd\n            if gcdinfo[parent].ifr1 == 0:\n                # alternative option\n                gcdinfo[n].tor2 = gcdinfo[parent].gcd\n                gcdinfo[n].ifr2 = a[n]\n        else:\n            # self if good, keep one of the other candidates\n            if gcdinfo[parent].ifr1:\n                newgcd1 = gcd(gcdinfo[parent].ifr1, a[n])\n            else:\n                newgcd1 = 1\n            if gcdinfo[parent].ifr2:\n                newgcd2 = gcd(gcdinfo[parent].ifr2, a[n])\n            else:\n                newgcd2 = 1\n            if newgcd1 > newgcd2:\n                gcdinfo[n].tor1 = gcdinfo[parent].tor1\n                gcdinfo[n].ifr1 = gcdinfo[parent].ifr1\n            elif newgcd2 > newgcd1:\n                gcdinfo[n].tor1 = gcdinfo[parent].tor2\n                gcdinfo[n].ifr1 = gcdinfo[parent].ifr2               \n\n    for neigh in graph[n]:\n        dfs(neigh, n)\n\ngcdinfo[0].gcd = a[0]\ngcdinfo[0].tor1 = a[0]\ngcdinfo[0].ifr1 = 0\ndfs(0, -1)\n\ns = \"\"\nfor i in xrange(n):\n    s += str(gcdinfo[i].get()) + \" \"\nprint(s)\n    \n",
        "correct": false,
        "task_id": "1217",
        "depth": 1
    },
    {
        "description": "Ilya is working for the company that constructs robots. Ilya writes programs for entertainment robots, and his current project is \"Bob\", a new-generation game robot. Ilya's boss wants to know his progress so far. Especially he is interested if Bob is better at playing different games than the previous model, \"Alice\". \n\nSo now Ilya wants to compare his robots' performance in a simple game called \"1-2-3\". This game is similar to the \"Rock-Paper-Scissors\" game: both robots secretly choose a number from the set {1, 2, 3} and say it at the same moment. If both robots choose the same number, then it's a draw and noone gets any points. But if chosen numbers are different, then one of the robots gets a point: 3 beats 2, 2 beats 1 and 1 beats 3. \n\nBoth robots' programs make them choose their numbers in such a way that their choice in (i + 1)-th game depends only on the numbers chosen by them in i-th game. \n\nIlya knows that the robots will play k games, Alice will choose number a in the first game, and Bob will choose b in the first game. He also knows both robots' programs and can tell what each robot will choose depending on their choices in previous game. Ilya doesn't want to wait until robots play all k games, so he asks you to predict the number of points they will have after the final game. \n\nInput\n\nThe first line contains three numbers k, a, b (1 \u2264 k \u2264 1018, 1 \u2264 a, b \u2264 3). \n\nThen 3 lines follow, i-th of them containing 3 numbers Ai, 1, Ai, 2, Ai, 3, where Ai, j represents Alice's choice in the game if Alice chose i in previous game and Bob chose j (1 \u2264 Ai, j \u2264 3). \n\nThen 3 lines follow, i-th of them containing 3 numbers Bi, 1, Bi, 2, Bi, 3, where Bi, j represents Bob's choice in the game if Alice chose i in previous game and Bob chose j (1 \u2264 Bi, j \u2264 3). \n\nOutput\n\nPrint two numbers. First of them has to be equal to the number of points Alice will have, and second of them must be Bob's score after k games.\n\nExamples\n\nInput\n\n10 2 1\n1 1 1\n1 1 1\n1 1 1\n2 2 2\n2 2 2\n2 2 2\n\n\nOutput\n\n1 9\n\n\nInput\n\n8 1 1\n2 2 1\n3 3 1\n3 1 3\n1 1 1\n2 1 1\n1 2 3\n\n\nOutput\n\n5 2\n\n\nInput\n\n5 1 1\n1 2 2\n2 2 2\n2 2 2\n1 2 2\n2 2 2\n2 2 2\n\n\nOutput\n\n0 0\n\nNote\n\nIn the second example game goes like this:\n\n<image>\n\nThe fourth and the seventh game are won by Bob, the first game is draw and the rest are won by Alice.",
        "task_name": "863_C. 1-2-3",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "f = lambda: list(map(int,raw_input().split()))\ng = lambda: [[0] * 4] + [[0] + f() for i in range(3)]\nh = lambda x, y: x - 1 == y % 3\nt = lambda a, b, u, v: (A[a][b], B[a][b], u + h(a, b), v + h(b, a))\nk, a, b = f()\np = 2520\ns, d = divmod(k, p)\nA, B = g(), g()\nu = v = x = y = 0\nfor j in range(d): a, b, u, v = t(a, b, u, v)\nfor i in range(p): a, b, x, y = t(a, b, x, y)\nprint(u + x * s, v + y * s)",
        "correct": false,
        "task_id": "1218",
        "depth": 1
    },
    {
        "description": "Ziota found a video game called \"Monster Invaders\".\n\nSimilar to every other shooting RPG game, \"Monster Invaders\" involves killing monsters and bosses with guns.\n\nFor the sake of simplicity, we only consider two different types of monsters and three different types of guns.\n\nNamely, the two types of monsters are: \n\n  * a normal monster with 1 hp. \n  * a boss with 2 hp. \n\n\n\nAnd the three types of guns are: \n\n  * Pistol, deals 1 hp in damage to one monster, r_1 reloading time \n  * Laser gun, deals 1 hp in damage to all the monsters in the current level (including the boss), r_2 reloading time \n  * AWP, instantly kills any monster, r_3 reloading time \n\n\n\nThe guns are initially not loaded, and the Ziota can only reload 1 gun at a time.\n\nThe levels of the game can be considered as an array a_1, a_2, \u2026, a_n, in which the i-th stage has a_i normal monsters and 1 boss. Due to the nature of the game, Ziota cannot use the Pistol (the first type of gun) or AWP (the third type of gun) to shoot the boss before killing all of the a_i normal monsters.\n\nIf Ziota damages the boss but does not kill it immediately, he is forced to move out of the current level to an arbitrary adjacent level (adjacent levels of level i (1 < i < n) are levels i - 1 and i + 1, the only adjacent level of level 1 is level 2, the only adjacent level of level n is level n - 1). Ziota can also choose to move to an adjacent level at any time. Each move between adjacent levels are managed by portals with d teleportation time.\n\nIn order not to disrupt the space-time continuum within the game, it is strictly forbidden to reload or shoot monsters during teleportation. \n\nZiota starts the game at level 1. The objective of the game is rather simple, to kill all the bosses in all the levels. He is curious about the minimum time to finish the game (assuming it takes no time to shoot the monsters with a loaded gun and Ziota has infinite ammo on all the three guns). Please help him find this value.\n\nInput\n\nThe first line of the input contains five integers separated by single spaces: n (2 \u2264 n \u2264 10^6) \u2014 the number of stages, r_1, r_2, r_3 (1 \u2264 r_1 \u2264 r_2 \u2264 r_3 \u2264 10^9) \u2014 the reload time of the three guns respectively, d (1 \u2264 d \u2264 10^9) \u2014 the time of moving between adjacent levels.\n\nThe second line of the input contains n integers separated by single spaces a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^6, 1 \u2264 i \u2264 n).\n\nOutput\n\nPrint one integer, the minimum time to finish the game.\n\nExamples\n\nInput\n\n\n4 1 3 4 3\n3 2 5 1\n\n\nOutput\n\n\n34\n\nInput\n\n\n4 2 4 4 1\n4 5 1 2\n\n\nOutput\n\n\n31\n\nNote\n\nIn the first test case, the optimal strategy is:\n\n  * Use the pistol to kill three normal monsters and AWP to kill the boss (Total time 1\u22c53+4=7) \n  * Move to stage two (Total time 7+3=10) \n  * Use the pistol twice and AWP to kill the boss (Total time 10+1\u22c52+4=16) \n  * Move to stage three (Total time 16+3=19) \n  * Use the laser gun and forced to move to either stage four or two, here we move to stage four (Total time 19+3+3=25) \n  * Use the pistol once, use AWP to kill the boss (Total time 25+1\u22c51+4=30) \n  * Move back to stage three (Total time 30+3=33) \n  * Kill the boss at stage three with the pistol (Total time 33+1=34) \n\n\n\nNote that here, we do not finish at level n, but when all the bosses are killed.",
        "task_name": "1397_E. Monster Invaders",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport math\n\nif sys.subversion[0] == \"PyPy\":\n    import io, atexit\n\n    sys.stdout = io.BytesIO()\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\n    sys.stdin = io.BytesIO(sys.stdin.read())\n    input = lambda: sys.stdin.readline().rstrip()\n\n#t = int(raw_input())\n\n# python codesforces210710.py < input.txt\n#for zz in range(t):\n\nstr1 = raw_input().split(' ')\nn, r1, r2, r3, d = map(int, str1)\nstr2 = raw_input().split(' ')\na = map(int, str2)\nfs = 0\nc1 = 0\nc2 = 2 * d\n\nfor i in range(n):\n    #print(aii)\n    indcost = r3 + a[i] * r1\n    aoecost = min(r2 + r1, r1 * (a[i] + 2))\n    mincost = min(indcost, aoecost)\n    mincost2l = min(indcost - d, aoecost)\n    oto = indcost\n    ott = mincost + 2 * d\n    ttt = mincost + 2 * d\n    tto = mincost\n    #print(oto, ott, ttt, tto)\n    if i < n - 1:\n        c3 = min(c1 + oto, c2 + tto) + d\n        c4 = min(c1 + ott, c2 + ttt) + d\n    else:\n        c3 = min(c1 + oto, c2 + mincost2l) + d\n        c4 = min(c1 + ott, c2 + ttt) + d\n    c1 = c3\n    c2 = c4\n    #print(c1, c2)\nans = min(c1, c2) - d\nprint(ans)\n",
        "correct": true,
        "task_id": "1238",
        "depth": 1
    },
    {
        "description": "Petya wrote a programme on C++ that calculated a very interesting function f(n). Petya ran the program with a certain value of n and went to the kitchen to have some tea. The history has no records concerning how long the program had been working. By the time Petya returned, it had completed the calculations and had the result. However while Petya was drinking tea, a sly virus managed to destroy the input file so that Petya can't figure out for which value of n the program was run. Help Petya, carry out the inverse function!\n\nMostly, the program consists of a function in C++ with the following simplified syntax:\n\n  * function ::= int f(int n) {operatorSequence}\n  * operatorSequence ::= operator | operator operatorSequence\n  * operator ::= return arithmExpr; | if (logicalExpr) return arithmExpr;\n  * logicalExpr ::= arithmExpr > arithmExpr | arithmExpr < arithmExpr | arithmExpr == arithmExpr\n  * arithmExpr ::= sum\n  * sum ::= product | sum + product | sum - product\n  * product ::= multiplier | product * multiplier | product / multiplier\n  * multiplier ::= n | number | f(arithmExpr)\n  * number ::= 0|1|2|... |32767\n\n\n\nThe whitespaces in a operatorSequence are optional.\n\nThus, we have a function, in which body there are two kinds of operators. There is the operator \"return arithmExpr;\" that returns the value of the expression as the value of the function, and there is the conditional operator \"if (logicalExpr) return arithmExpr;\" that returns the value of the arithmetical expression when and only when the logical expression is true. Guaranteed that no other constructions of C++ language \u2014 cycles, assignment operators, nested conditional operators etc, and other variables except the n parameter are used in the function. All the constants are integers in the interval [0..32767].\n\nThe operators are performed sequentially. After the function has returned a value other operators in the sequence are not performed. Arithmetical expressions are performed taking into consideration the standard priority of the operations. It means that first all the products that are part of the sum are calculated. During the calculation of the products the operations of multiplying and division are performed from the left to the right. Then the summands are summed, and the addition and the subtraction are also performed from the left to the right. Operations \">\" (more), \"<\" (less) and \"==\" (equals) also have standard meanings.\n\nNow you've got to pay close attention! The program is compiled with the help of 15-bit Berland C++ compiler invented by a Berland company BerSoft, that's why arithmetical operations are performed in a non-standard way. Addition, subtraction and multiplication are performed modulo 32768 (if the result of subtraction is negative, then 32768 is added to it until the number belongs to the interval [0..32767]). Division \"/\" is a usual integer division where the remainder is omitted.\n\nExamples of arithmetical operations: \n\n<image>\n\nGuaranteed that for all values of n from 0 to 32767 the given function is performed correctly. That means that:\n\n1. Division by 0 never occures.\n\n2. When performing a function for the value n = N recursive calls of the function f may occur only for the parameter value of 0, 1, ..., N - 1. Consequently, the program never has an infinite recursion.\n\n3. As the result of the sequence of the operators, the function always returns a value.\n\nWe have to mention that due to all the limitations the value returned by the function f is independent from either global variables or the order of performing the calculations of arithmetical expressions as part of the logical one, or from anything else except the value of n parameter. That's why the f function can be regarded as a function in its mathematical sense, i.e. as a unique correspondence between any value of n from the interval [0..32767] and a value of f(n) from the same interval.\n\nGiven the value of f(n), and you should find n. If the suitable n value is not unique, you should find the maximal one (from the interval [0..32767]).\n\nInput\n\nThe first line has an integer f(n) from the interval [0..32767]. The next lines have the description of the function f. In the description can be found extra spaces and line breaks (see the examples) which, of course, can\u2019t break key words int, if, return and numbers. The size of input data can\u2019t exceed 100 bytes.\n\nOutput\n\nOutput a single number \u2014 the answer to the problem. If there\u2019s no answer, output \"-1\" (without quotes).\n\nExamples\n\nInput\n\n17\nint f(int n)\n{\nif (n &lt; 100) return 17;\nif (n &gt; 99) return 27;\n}\n\n\nOutput\n\n99\n\n\nInput\n\n13\nint f(int n)\n{\nif (n == 0) return 0;\nreturn f(n - 1) + 1;\n}\n\n\nOutput\n\n13\n\nInput\n\n144\nint f(int n)\n{\nif (n == 0) return 0;\nif (n == 1) return n;\nreturn f(n - 1) + f(n - 2);\n}\n\nOutput\n\n24588",
        "task_name": "39_G. Inverse Function",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\nimport re\n\nimport sys\n\nimport operator as op\n\n \n\nfin, fout = sys.stdin, sys.stdout\n\n \n\nMOD = 2 ** 15\n\nmake_op = lambda op: lambda s, o: Num(op(s.x, o.x) % MOD)\n\nmake_cmp = lambda op: lambda s, o: op(s.x, o.x)\n\n \n\nclass Num:\n\n    def __init__(self, obj):\n\n        self.x = obj.x if isinstance(obj, Num) else int(obj)\n\n    __add__ = make_op(op.add)\n\n    __sub__ = make_op(op.sub)\n\n    __div__ = make_op(op.div)\n\n    __mul__ = make_op(op.mul)\n\n    __eq__ = make_cmp(op.eq)\n\n    __lt__ = make_cmp(op.lt)\n\n    __gt__ = make_cmp(op.gt)\n\n \n\ndef val(num):\n\n    return num.x if isinstance(num, Num) else num\n\n \n\nn = int(fin.readline())\n\n \n\ntext = \"\".join(fin.readlines())\n\nfor pat, repl in [\n\n    (r\"\\s\", r\"\"),\n\n    (r\"return\", \"return \"),\n\n    (r\".*{(.*)}.*\", r\"\\1\"),\n\n    (r\"(\\d+)\", r\"Num(\\1)\"),\n\n    (r\"(if.*?)(return)\", r\"\\1:\\2\"),\n\n    (r\";\", \"\\n\\t\"),\n\n    ]:\n\n    text = re.sub(pat, repl, text)\n\ntext = \"def F(n):\\n\\tn = Num(n)\\n\\t\" + text\n\n \n\nexec(compile(text.strip(), \"f**k\", 'exec'))\n\n \n\ncache = {}\n\nf = lambda n: Num(cache[val(n)])\n\nans = -1\n\nfor i in range(0, MOD):\n\n    t = cache[i] = Num(F(i))\n\n    if val(t) == n:\n\n      ans = i\n\n     \n\nprint(ans) \n",
        "correct": true,
        "task_id": "1246",
        "depth": 1
    },
    {
        "description": "A famous Berland's painter Kalevitch likes to shock the public. One of his last obsessions is chess. For more than a thousand years people have been playing this old game on uninteresting, monotonous boards. Kalevitch decided to put an end to this tradition and to introduce a new attitude to chessboards.\n\nAs before, the chessboard is a square-checkered board with the squares arranged in a 8 \u00d7 8 grid, each square is painted black or white. Kalevitch suggests that chessboards should be painted in the following manner: there should be chosen a horizontal or a vertical line of 8 squares (i.e. a row or a column), and painted black. Initially the whole chessboard is white, and it can be painted in the above described way one or more times. It is allowed to paint a square many times, but after the first time it does not change its colour any more and remains black. Kalevitch paints chessboards neatly, and it is impossible to judge by an individual square if it was painted with a vertical or a horizontal stroke.\n\nKalevitch hopes that such chessboards will gain popularity, and he will be commissioned to paint chessboards, which will help him ensure a comfortable old age. The clients will inform him what chessboard they want to have, and the painter will paint a white chessboard meeting the client's requirements.\n\nIt goes without saying that in such business one should economize on everything \u2014 for each commission he wants to know the minimum amount of strokes that he has to paint to fulfill the client's needs. You are asked to help Kalevitch with this task.\n\nInput\n\nThe input file contains 8 lines, each of the lines contains 8 characters. The given matrix describes the client's requirements, W character stands for a white square, and B character \u2014 for a square painted black.\n\nIt is guaranteed that client's requirments can be fulfilled with a sequence of allowed strokes (vertical/column or horizontal/row).\n\nOutput\n\nOutput the only number \u2014 the minimum amount of rows and columns that Kalevitch has to paint on the white chessboard to meet the client's requirements.\n\nExamples\n\nInput\n\nWWWBWWBW\nBBBBBBBB\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\n\n\nOutput\n\n3\n\n\nInput\n\nWWWWWWWW\nBBBBBBBB\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\n\n\nOutput\n\n1",
        "task_name": "7_A. Kalevitch and Chess",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nsys.setrecursionlimit(2 ** 15)\n\nboard = []\npainted_rows = [False] * 8\npainted_cols = [False] * 8\n\n\ndef should_paint_column(col_num):\n    painted_by_rows = True\n    for row_num, x in enumerate(board):\n        if x[col_num] != True:\n            return False\n        painted_by_rows = painted_by_rows and painted_rows[row_num]\n    return True and not painted_by_rows\n\ndef main():\n    for y in xrange(8):\n        board.append([True if x == 'B' else False for x in raw_input()])# True is black, False is white\n    strokes = 0\n    for row_num, row in enumerate(board):\n        if all(row): #Entire row should be black\n            strokes += 1\n            painted_rows[row_num] = True\n    \n    for col_num in xrange(8):\n        if should_paint_column(col_num):\n            strokes += 1\n            painted_cols[col_num] = True\n    \n    print(strokes)\n    \n\nmain()\n",
        "correct": true,
        "task_id": "1254",
        "depth": 1
    },
    {
        "description": "One day Sasha visited the farmer 2D and his famous magnetic farm. On this farm, the crop grows due to the influence of a special magnetic field. Maintaining of the magnetic field is provided by n machines, and the power of the i-th machine is a_i. \n\nThis year 2D decided to cultivate a new culture, but what exactly he didn't say. For the successful growth of the new culture, it is necessary to slightly change the powers of the machines. 2D can at most once choose an arbitrary integer x, then choose one machine and reduce the power of its machine by x times, and at the same time increase the power of one another machine by x times (powers of all the machines must stay positive integers). Note that he may not do that if he wants. More formally, 2D can choose two such indices i and j, and one integer x such that x is a divisor of a_i, and change powers as following: a_i = (a_i)/(x), a_j = a_j \u22c5 x\n\nSasha is very curious, that's why he wants to calculate the minimum total power the farmer can reach. There are too many machines, and Sasha can't cope with computations, help him!\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 5 \u22c5 10^4) \u2014 the number of machines.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 100) \u2014 the powers of the machines.\n\nOutput\n\nPrint one integer \u2014 minimum total power.\n\nExamples\n\nInput\n\n\n5\n1 2 3 4 5\n\n\nOutput\n\n\n14\n\n\nInput\n\n\n4\n4 2 4 4\n\n\nOutput\n\n\n14\n\n\nInput\n\n\n5\n2 4 2 3 7\n\n\nOutput\n\n\n18\n\nNote\n\nIn the first example, the farmer can reduce the power of the 4-th machine by 2 times, and increase the power of the 1-st machine by 2 times, then the powers will be: [2, 2, 3, 2, 5].\n\nIn the second example, the farmer can reduce the power of the 3-rd machine by 2 times, and increase the power of the 2-nd machine by 2 times. At the same time, the farmer can leave is be as it is and the total power won't change.\n\nIn the third example, it is optimal to leave it be as it is.",
        "task_name": "1113_B. Sasha and Magnetic Machines",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\"\"\"\nThis file is part of https://github.com/cheran-senthil/PyRival\nCopyright 2019 Cheran Senthilkumar <hello@cheran.io>\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport cmath\nimport itertools\nimport math\nimport operator as op\n# import random\nimport sys\nfrom atexit import register\nfrom bisect import bisect_left, bisect_right\n# from collections import Counter, defaultdict, deque\n# from copy import deepcopy\n# from decimal import Decimal\n# from difflib import SequenceMatcher\n# from functools import reduce\n# from heapq import heappop, heappush\nfrom io import BytesIO, FileIO, StringIO\n\nif sys.version_info[0] < 3:\n\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n\n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n\n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\n\ndef gcd(x, y):\n    \"\"\"greatest common divisor of x and y\"\"\"\n    while y:\n        x, y = y, x % y\n    return x\n\n\nINP_FILE = 0\nOUT_FILE = 1\n\nif sys.version_info[0] < 3:\n    sys.stdin = BytesIO(FileIO(INP_FILE).read())\n    sys.stdout = BytesIO()\n    register(lambda: FileIO(OUT_FILE, 'w').write(sys.stdout.getvalue()))\nelse:\n    sys.stdin = StringIO(FileIO(INP_FILE).read().decode())\n    sys.stdout = StringIO()\n    register(lambda: FileIO(OUT_FILE, 'w').write(sys.stdout.getvalue().encode()))\n\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\ndef memodict(f):\n    \"\"\" Memoization decorator for a function taking a single argument. \"\"\"\n\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n\n    return memodict().__getitem__\n\n\n@memodict\ndef all_factors(n):\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    sa = sum(a)\n    ma = min(a)\n\n    res = sa\n    for i in range(n):\n        if a[i] == ma:\n            continue\n        for fi in all_factors(a[i]):\n            res = min(res, sa - ma - a[i] + (ma * fi) + (a[i] // fi))\n\n    print(res)\n\n\nif __name__ == '__main__':\n    main()\n",
        "correct": true,
        "task_id": "1271",
        "depth": 2
    },
    {
        "description": "A superhero fights with a monster. The battle consists of rounds, each of which lasts exactly n minutes. After a round ends, the next round starts immediately. This is repeated over and over again.\n\nEach round has the same scenario. It is described by a sequence of n numbers: d_1, d_2, ..., d_n (-10^6 \u2264 d_i \u2264 10^6). The i-th element means that monster's hp (hit points) changes by the value d_i during the i-th minute of each round. Formally, if before the i-th minute of a round the monster's hp is h, then after the i-th minute it changes to h := h + d_i.\n\nThe monster's initial hp is H. It means that before the battle the monster has H hit points. Print the first minute after which the monster dies. The monster dies if its hp is less than or equal to 0. Print -1 if the battle continues infinitely.\n\nInput\n\nThe first line contains two integers H and n (1 \u2264 H \u2264 10^{12}, 1 \u2264 n \u2264 2\u22c510^5). The second line contains the sequence of integers d_1, d_2, ..., d_n (-10^6 \u2264 d_i \u2264 10^6), where d_i is the value to change monster's hp in the i-th minute of a round.\n\nOutput\n\nPrint -1 if the superhero can't kill the monster and the battle will last infinitely. Otherwise, print the positive integer k such that k is the first minute after which the monster is dead.\n\nExamples\n\nInput\n\n\n1000 6\n-100 -200 -300 125 77 -4\n\n\nOutput\n\n\n9\n\n\nInput\n\n\n1000000000000 5\n-1 0 0 0 0\n\n\nOutput\n\n\n4999999999996\n\n\nInput\n\n\n10 4\n-3 -6 5 4\n\n\nOutput\n\n\n-1",
        "task_name": "1141_E. Superhero Battle",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "h, n  = map(int, raw_input().split())\nl = map(int, raw_input().split())\n\nmneg = 0\nsom = 0\nneg = 0\n\nfor i in xrange(n):\n    if(l[i] < 0):\n        neg += l[i]\n    else:\n        if(neg < mneg):\n            mneg = neg\n        neg = 0\n    som += l[i]\n\nif(neg < mneg):\n    mneg = neg\n\nif(mneg*-1 > h):\n    li = h\n    for i in xrange(n):\n        li += l[i]\n        if(li <= 0):\n            break\n    print(i+1)\nelif(som < 0):\n    li = h - (h/(som*-1)-1)*(som*-1)\n    for i in xrange(n):\n        li += l[i]\n        if(li <= 0):\n            break\n    print((h/(som*-1)-1)*n+i+1)\nelse:\n    print(\"-1\")",
        "correct": false,
        "task_id": "1272",
        "depth": 1
    },
    {
        "description": "We are committed to the well being of all participants. Therefore, instead of the problem, we suggest you enjoy a piece of cake.\n\nUh oh. Somebody cut the cake. We told them to wait for you, but they did it anyway. There is still some left, though, if you hurry back. Of course, before you taste the cake, you thought about how the cake was cut.\n\nIt is known that the cake was originally a regular n-sided polygon, each vertex of which had a unique number from 1 to n. The vertices were numbered in random order.\n\nEach piece of the cake is a triangle. The cake was cut into n - 2 pieces as follows: each time one cut was made with a knife (from one vertex to another) such that exactly one triangular piece was separated from the current cake, and the rest continued to be a convex polygon. In other words, each time three consecutive vertices of the polygon were selected and the corresponding triangle was cut off.\n\nA possible process of cutting the cake is presented in the picture below.\n\n<image> Example of 6-sided cake slicing.\n\nYou are given a set of n-2 triangular pieces in random order. The vertices of each piece are given in random order \u2014 clockwise or counterclockwise. Each piece is defined by three numbers \u2014 the numbers of the corresponding n-sided cake vertices.\n\nFor example, for the situation in the picture above, you could be given a set of pieces: [3, 6, 5], [5, 2, 4], [5, 4, 6], [6, 3, 1].\n\nYou are interested in two questions.\n\n  * What was the enumeration of the n-sided cake vertices? \n  * In what order were the pieces cut? \n\n\n\nFormally, you have to find two permutations p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) and q_1, q_2, ..., q_{n - 2} (1 \u2264 q_i \u2264 n - 2) such that if the cake vertices are numbered with the numbers p_1, p_2, ..., p_n in order clockwise or counterclockwise, then when cutting pieces of the cake in the order q_1, q_2, ..., q_{n - 2} always cuts off a triangular piece so that the remaining part forms one convex polygon.\n\nFor example, in the picture above the answer permutations could be: p=[2, 4, 6, 1, 3, 5] (or any of its cyclic shifts, or its reversal and after that any cyclic shift) and q=[2, 4, 1, 3].\n\nWrite a program that, based on the given triangular pieces, finds any suitable permutations p and q.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then there are t independent sets of input data.\n\nThe first line of each set consists of a single integer n (3 \u2264 n \u2264 10^5) \u2014 the number of vertices in the cake.\n\nThe following n - 2 lines describe the numbers of the pieces vertices: each line consists of three different integers a, b, c (1 \u2264 a, b, c \u2264 n) \u2014 the numbers of the pieces vertices of cake given in random order. The pieces are given in random order.\n\nIt is guaranteed that the answer to each of the tests exists. It is also guaranteed that the sum of n for all test cases does not exceed 10^5.\n\nOutput\n\nPrint 2t lines \u2014 answers to given t test cases in the order in which they are written in the input. Each answer should consist of 2 lines.\n\nIn the first line of an answer on a test case print n distinct numbers p_1, p_2, ..., p_n(1 \u2264 p_i \u2264 n) \u2014 the numbers of the cake vertices in clockwise or counterclockwise order.\n\nIn the second line of an answer on a test case print n - 2 distinct numbers q_1, q_2, ..., q_{n - 2}(1 \u2264 q_i \u2264 n - 2) \u2014 the order of cutting pieces of the cake. The number of a piece of the cake corresponds to its number in the input.\n\nIf there are several answers, print any. It is guaranteed that the answer to each of the tests exists.\n\nExample\n\nInput\n\n\n3\n6\n3 6 5\n5 2 4\n5 4 6\n6 3 1\n6\n2 5 6\n2 5 1\n4 1 2\n1 3 5\n3\n1 2 3\n\n\nOutput\n\n\n1 6 4 2 5 3 \n4 2 3 1 \n1 4 2 6 5 3 \n3 4 2 1 \n1 3 2 \n1 ",
        "task_name": "1282_E. The Cake Is a Lie",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nfrom collections import defaultdict\nfrom itertools import repeat\ndef solve():\n    n = int(stdin.readline())\n    a = [map(int, stdin.readline().split()) for _ in xrange(n - 2)]\n    s = defaultdict(set)\n    for i, t in enumerate(a):\n        x, y, z = t\n        if x < y:\n            s[x,y].add(i)\n        else:\n            s[y,x].add(i)\n        if y < z:\n            s[y,z].add(i)\n        else:\n            s[z,y].add(i)\n        if x < z:\n            s[x,z].add(i)\n        else:\n            s[z,x].add(i)\n    con = [[] for _ in xrange(n + 1)]\n    c = [3] * (n - 2)\n    st = []\n    po = st.pop\n    pu = st.append\n    for k, v in s.viewitems():\n        if len(v) == 1:\n            i = v.pop()\n            c[i] -= 1\n            if c[i] == 1:\n                pu(i)\n            x, y = k\n            con[y].append(x)\n            con[x].append(y)\n    q = []\n    while st:\n        i = po()\n        if c[i] == 1:\n            x, y, z = a[i]\n            if x < y and i in s[x,y]:\n                k = x, y\n                q.append(z)\n            elif x > y and i in s[y,x]:\n                k = y, x\n                q.append(z)\n            elif y < z and i in s[y,z]:\n                k = y, z\n                q.append(x)\n            elif y > z and i in s[z,y]:\n                k = z, y\n                q.append(x)\n            elif x < z and i in s[x,z]:\n                k = x, z\n                q.append(y)\n            else:\n                k = z, x\n                q.append(y)\n            c[i] -= 1\n            s[k].remove(i)\n            j = s[k].pop()\n            c[j] -= 1\n            if c[j] == 1:\n                pu(j)\n        else:\n            x, y, z = a[i]\n            if x not in q:\n                q.append(x)\n            elif y not in q:\n                q.append(y)\n            else:\n                q.append(z)\n    p = []\n    x = 1\n    d = [0] * (n + 1)\n    for i in xrange(n):\n        d[x] = 1\n        p.append(x)\n        for y in con[x]:\n            if not d[y]:\n                x = y\n                break\n    stdout.write(' '.join(map(str, p)))\n    stdout.write('\\n')\n    stdout.write(' '.join(map(str, q)))\n    stdout.write('\\n')\n\nT = int(stdin.readline())\nfor _ in xrange(T):\n    solve()\n",
        "correct": false,
        "task_id": "1275",
        "depth": 2
    },
    {
        "description": "You are given four integers a, b, x and y. Initially, a \u2265 x and b \u2265 y. You can do the following operation no more than n times:\n\n  * Choose either a or b and decrease it by one. However, as a result of this operation, value of a cannot become less than x, and value of b cannot become less than y. \n\n\n\nYour task is to find the minimum possible product of a and b (a \u22c5 b) you can achieve by applying the given operation no more than n times.\n\nYou have to answer t independent test cases.\n\nInput\n\nThe first line of the input contains one integer t (1 \u2264 t \u2264 2 \u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\n\nThe only line of the test case contains five integers a, b, x, y and n (1 \u2264 a, b, x, y, n \u2264 10^9). Additional constraint on the input: a \u2265 x and b \u2265 y always holds.\n\nOutput\n\nFor each test case, print one integer: the minimum possible product of a and b (a \u22c5 b) you can achieve by applying the given operation no more than n times.\n\nExample\n\nInput\n\n\n7\n10 10 8 5 3\n12 8 8 7 2\n12343 43 4543 39 123212\n1000000000 1000000000 1 1 1\n1000000000 1000000000 1 1 1000000000\n10 11 2 1 5\n10 11 9 1 10\n\n\nOutput\n\n\n70\n77\n177177\n999999999000000000\n999999999\n55\n10\n\nNote\n\nIn the first test case of the example, you need to decrease b three times and obtain 10 \u22c5 7 = 70.\n\nIn the second test case of the example, you need to decrease a one time, b one time and obtain 11 \u22c5 7 = 77.\n\nIn the sixth test case of the example, you need to decrease a five times and obtain 5 \u22c5 11 = 55.\n\nIn the seventh test case of the example, you need to decrease b ten times and obtain 10 \u22c5 1 = 10.",
        "task_name": "1409_B. Minimum Product",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# cook your dish here\n\n# Name: Rhythem Jain\n# Date: 01.09.2020\n\n\nfrom __future__ import division, print_function\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii():  return int(input())\ndef si():  return input()\ndef mi():  return map(int,input().strip().split())\ndef msi(): return map(str,input().strip().split())\ndef li():  return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import log,sqrt,factorial,cos,tan,sin,radians\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *\n#import threading\n#from itertools import permutations\n# Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\nvow=['a','e','i','o','u','A','E','I','O','U']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey,reverse=True)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\ndef ncr(n,r): return factorial(n)//(factorial(r)*factorial(max(n-r,1)))\n\ndef ceil(x,y):\n    if x%y==0:\n        return x//y\n    else:\n        return x//y+1\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\ndef read():\n    sys.stdin  = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\ndef main():\n    for _ in range(ii()):\n        a,b,x,y,n=mi()\n        if (a-x)+(b-y)<=n:\n            print(int(x*y))\n        else:\n            a1=a-x\n            b1=b-y\n            if min(a1,b1)>=n:\n                # print(\"HOO\")\n                if a<b:\n                    print((a-n)*b)\n                else:\n                    print((b-n)*a)\n            elif max(a1,b1)==n:\n                if a1>b1:\n                    print(x*b)\n                else:\n                    print(y*a)\n            elif max(a1,b1)>n:\n                if a1<b1:\n                    a2=x*(b-(n-a1))\n                    b2=a*(b-n)\n                    print(min(a2,b2))\n                else:\n                    a2=y*(a-(n-b1))\n                    b2=b*(a-n)\n                    print(min(a2,b2))\n            else:\n                if a1<b1:\n                    a2=x*(b-(n-a1))\n                    b2=a*(b-n)\n                    print(max(a2,b2))\n                else:\n                    a2=x*(a-(n-b1))\n                    b2=b*(a-n)\n                    print(max(a2,b2))\n\n\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": false,
        "task_id": "1278",
        "depth": 1
    },
    {
        "description": "Gildong has an interesting machine that has an array a with n integers. The machine supports two kinds of operations:\n\n  1. Increase all elements of a suffix of the array by 1. \n  2. Decrease all elements of a suffix of the array by 1. \n\n\n\nA suffix is a subsegment (contiguous elements) of the array that contains a_n. In other words, for all i where a_i is included in the subsegment, all a_j's where i < j \u2264 n must also be included in the subsegment.\n\nGildong wants to make all elements of a equal \u2014 he will always do so using the minimum number of operations necessary. To make his life even easier, before Gildong starts using the machine, you have the option of changing one of the integers in the array to any other integer. You are allowed to leave the array unchanged. You want to minimize the number of operations Gildong performs. With your help, what is the minimum number of operations Gildong will perform?\n\nNote that even if you change one of the integers in the array, you should not count that as one of the operations because Gildong did not perform it.\n\nInput\n\nEach test contains one or more test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\n\nEach test case contains two lines. The first line of each test case consists of an integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements of the array a.\n\nThe second line of each test case contains n integers. The i-th integer is a_i (-5 \u22c5 10^8 \u2264 a_i \u2264 5 \u22c5 10^8).\n\nIt is guaranteed that the sum of n in all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the minimum number of operations Gildong has to perform in order to make all elements of the array equal.\n\nExample\n\nInput\n\n\n7\n2\n1 1\n3\n-1 0 2\n4\n99 96 97 95\n4\n-3 -5 -2 1\n6\n1 4 3 2 4 1\n5\n5 0 0 0 5\n9\n-367741579 319422997 -415264583 -125558838 -300860379 420848004 294512916 -383235489 425814447\n\n\nOutput\n\n\n0\n1\n3\n4\n6\n5\n2847372102\n\nNote\n\nIn the first case, all elements of the array are already equal. Therefore, we do not change any integer and Gildong will perform zero operations.\n\nIn the second case, we can set a_3 to be 0, so that the array becomes [-1,0,0]. Now Gildong can use the 2-nd operation once on the suffix starting at a_2, which means a_2 and a_3 are decreased by 1, making all elements of the array -1.\n\nIn the third case, we can set a_1 to 96, so that the array becomes [96,96,97,95]. Now Gildong needs to: \n\n  * Use the 2-nd operation on the suffix starting at a_3 once, making the array [96,96,96,94]. \n  * Use the 1-st operation on the suffix starting at a_4 2 times, making the array [96,96,96,96]. \n\n\n\nIn the fourth case, we can change the array into [-3,-3,-2,1]. Now Gildong needs to: \n\n  * Use the 2-nd operation on the suffix starting at a_4 3 times, making the array [-3,-3,-2,-2]. \n  * Use the 2-nd operation on the suffix starting at a_3 once, making the array [-3,-3,-3,-3]. ",
        "task_name": "1453_B. Suffix Operations",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\nfrom collections import defaultdict, Counter, deque\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement,product\nfrom __builtin__ import xrange as range\nfrom math import ceil, factorial, log,tan,pi,cos,sin,radians\nfrom _continuation import continulet\nfrom cStringIO import StringIO\nfrom io import IOBase\nimport __pypy__\nfrom bisect import bisect, insort, bisect_left, bisect_right\nfrom fractions import Fraction\nfrom functools import reduce\nfrom decimal import *\nimport copy\nimport string\nimport sys\nimport os\nimport re\ninf = float('inf')\nmod = int(1e9) + 7\nmod_ = 998244353\n\ndef factors(n):\n    from functools import reduce\n    return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\ndef sieve(n):\n    arr=[True]*n\n    for i in range(2,int(n**0.5)+1):\n        if arr[i]:\n            for j in range(i*i,n,i):\n                arr[j]=False\n    primes=[]\n    for i in range(n):\n        if arr[i]:\n            primes.append(i)\n\n    return primes\n\n\n\ndef main():\n    def cost(arr):\n        cst=0\n        for i in range(len(arr)-1,0,-1):\n            cst+=abs(arr[i]-arr[i-1])\n        return cst\n    for _ in range(int(input())):\n        n=int(input())\n        arr=list(map(int,input().split()))\n        temp=list(arr)\n        temp[0]=temp[1]\n        cost1=cost(temp)\n        temp=list(arr)\n        temp[1]=temp[0]\n        cost1=min(cost1,cost(temp))\n        temp=list(arr)\n        temp[-2]=temp[-1]\n        cost1=min(cost1,cost(temp))\n        temp=list(arr)\n        temp[-1]=temp[-2]\n        cost1=min(cost1,cost(temp))\n        print(cost1)\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": "1279",
        "depth": 2
    },
    {
        "description": "Polycarpus has a hobby \u2014 he develops an unusual social network. His work is almost completed, and there is only one more module to implement \u2014 the module which determines friends. Oh yes, in this social network one won't have to add friends manually! Pairs of friends are deduced in the following way. Let's assume that user A sent user B a message at time t1, and user B sent user A a message at time t2. If 0 < t2 - t1 \u2264 d, then user B's message was an answer to user A's one. Users A and B are considered to be friends if A answered at least one B's message or B answered at least one A's message.\n\nYou are given the log of messages in chronological order and a number d. Find all pairs of users who will be considered to be friends.\n\nInput\n\nThe first line of the input contains two integers n and d (1 \u2264 n, d \u2264 1000). The next n lines contain the messages log. The i-th line contains one line of the log formatted as \"Ai Bi ti\" (without the quotes), which means that user Ai sent a message to user Bi at time ti (1 \u2264 i \u2264 n). Ai and Bi are non-empty strings at most 20 characters long, consisting of lowercase letters ('a' ... 'z'), and ti is an integer (0 \u2264 ti \u2264 10000). It is guaranteed that the lines are given in non-decreasing order of ti's and that no user sent a message to himself. The elements in the lines are separated by single spaces.\n\nOutput\n\nIn the first line print integer k \u2014 the number of pairs of friends. In the next k lines print pairs of friends as \"Ai Bi\" (without the quotes). You can print users in pairs and the pairs themselves in any order. Each pair must be printed exactly once.\n\nExamples\n\nInput\n\n4 1\nvasya petya 1\npetya vasya 2\nanya ivan 2\nivan anya 4\n\n\nOutput\n\n1\npetya vasya\n\n\nInput\n\n1 1000\na b 0\n\n\nOutput\n\n0\n\nNote\n\nIn the first sample test case Vasya and Petya are friends because their messages' sending times are one second apart. Anya and Ivan are not, because their messages' sending times differ by more than one second.",
        "task_name": "159_A. Friends or Not",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, d = map(int, raw_input().split())\nres = set()\ndata = [[]] * n\nfor i in range(0, n):\n\tdata[i] = raw_input().split()\n\tdata[i][2] = int(data[i][2])\nfor i in range(0, n):\n\tfor j in range(i + 1, n):\n\t\tif (data[i][0] == data[j][1] and data[i][1] == data[j][0]\n\t\t\tand 0 < abs(data[i][2] - data[j][2]) <= d):\n\t\t\tres |= {data[i][0] + \" \" + data[i][1]}\nprint(len(res))\nfor l in res:\n\tprint(l)\n\n\t\n\t",
        "correct": false,
        "task_id": "1281",
        "depth": 2
    },
    {
        "description": "You've got an n \u00d7 m pixel picture. Each pixel can be white or black. Your task is to change the colors of as few pixels as possible to obtain a barcode picture.\n\nA picture is a barcode if the following conditions are fulfilled: \n\n  * All pixels in each column are of the same color. \n  * The width of each monochrome vertical line is at least x and at most y pixels. In other words, if we group all neighbouring columns of the pixels with equal color, the size of each group can not be less than x or greater than y. \n\nInput\n\nThe first line contains four space-separated integers n, m, x and y (1 \u2264 n, m, x, y \u2264 1000; x \u2264 y).\n\nThen follow n lines, describing the original image. Each of these lines contains exactly m characters. Character \".\" represents a white pixel and \"#\" represents a black pixel. The picture description doesn't have any other characters besides \".\" and \"#\".\n\nOutput\n\nIn the first line print the minimum number of pixels to repaint. It is guaranteed that the answer exists. \n\nExamples\n\nInput\n\n6 5 1 2\n##.#.\n.###.\n###..\n#...#\n.##.#\n###..\n\n\nOutput\n\n11\n\n\nInput\n\n2 5 1 1\n#####\n.....\n\n\nOutput\n\n5\n\nNote\n\nIn the first test sample the picture after changing some colors can looks as follows: \n    \n    \n      \n    .##..  \n    .##..  \n    .##..  \n    .##..  \n    .##..  \n    .##..  \n    \n\nIn the second test sample the picture after changing some colors can looks as follows: \n    \n    \n      \n    .#.#.  \n    .#.#.  \n    ",
        "task_name": "225_C. Barcode",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "'''input\n10 5 3 7\n.####\n###..\n##.##\n#..#.\n.#...\n#.##.\n.##..\n.#.##\n#.#..\n.#..#\n'''\n# connected components\nfrom sys import stdin\nfrom collections import defaultdict\nimport sys\nimport time\n\nsys.setrecursionlimit(15000)\n\ndef calculate_cost(matrix, n, m):\n\twhite_cost = []\n\tblack_cost = []\n\tfor i in range(m):\n\t\tbcount = 0; wcount = 0\n\t\tfor j in range(n):\n\t\t\tif matrix[j][i] == '.':\n\t\t\t\tbcount += 1\n\t\t\telse:\n\t\t\t\twcount += 1\n\t\twhite_cost.append(wcount)\n\t\tblack_cost.append(bcount)\n\treturn black_cost, white_cost\n\n\ndef brute(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index, w, b):\n\t#print(index, w, b)\n\tif index >= m:\n\t\tif w != 0 and w >= x:\n\t\t\treturn 0\n\t\tif b != 0 and b >= x:\n\t\t\treturn 0\n\t\treturn float('inf')\n\telse:\n\t\tif dp1[w][index] != -1 and dp2[b][index] != -1:\n\t\t\treturn min(dp1[w][index], dp2[b][index])\n\n\t\tc1 = float('inf'); c2 = float('inf'); c3 = float('inf'); c4 = float('inf')\n\t\tif w < x:\n\t\t\tc1 = 0\n\t\t\tcw = w\n\t\t\ti = index\n\t\t\twhile cw < x:\n\t\t\t\tif i == m:\n\t\t\t\t\tbreak\n\t\t\t\tc1 += white_cost[i]\t\n\t\t\t\ti +=  1; cw += 1\n\t\t\tc1 += brute(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)\n\t\t\n\t\tif b < x:\n\t\t\tc2 = 0\n\t\t\tcb = b\n\t\t\ti = index\n\t\t\twhile cb < x:\n\t\t\t\tif i == m:\n\t\t\t\t\tc2 = float('inf')\n\t\t\t\t\tbreak\n\t\t\t\tc2 += black_cost[i]\n\t\t\t\ti += 1; cb += 1\n\t\t\tc2 += brute(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)\n\t\t\n\t\tif w >= x and w + 1 <= y:\n\t\t\tc3 = white_cost[index] + brute(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)\n\t\t\n\t\tif b >= x and b + 1 <= y:\n\t\t\tc4 = black_cost[index] + brute(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, 0, b + 1)\n\t\t\n\t\t\n\t\tdp1[w][index] = min(c1, c3)\n\t\tdp2[b][index] = min(c2, c4)\n\t\treturn min(c1, c2, c3, c4)\n\t\t\n\n# main starts\nn, m, x, y = list(map(int, stdin.readline().split()))\nmatrix = []\nfor _ in range(n):\n\tmatrix.append(list(stdin.readline().strip()))\nblack_cost, white_cost = calculate_cost(matrix, n, m)\n#print(black_cost, white_cost)\ndp1 = [[-1 for j in range(m)] for k in range(y + 1)]\ndp2 = [[-1 for j in range(m)] for k in range(y + 1)]\n\nprint(brute(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, 0, 0, 0))\n",
        "correct": true,
        "task_id": "1283",
        "depth": 2
    },
    {
        "description": "Sereja has two sequences a and b and number p. Sequence a consists of n integers a1, a2, ..., an. Similarly, sequence b consists of m integers b1, b2, ..., bm. As usual, Sereja studies the sequences he has. Today he wants to find the number of positions q (q + (m - 1)\u00b7p \u2264 n; q \u2265 1), such that sequence b can be obtained from sequence aq, aq + p, aq + 2p, ..., aq + (m - 1)p by rearranging elements.\n\nSereja needs to rush to the gym, so he asked to find all the described positions of q.\n\nInput\n\nThe first line contains three integers n, m and p (1 \u2264 n, m \u2264 2\u00b7105, 1 \u2264 p \u2264 2\u00b7105). The next line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 109). The next line contains m integers b1, b2, ..., bm (1 \u2264 bi \u2264 109).\n\nOutput\n\nIn the first line print the number of valid qs. In the second line, print the valid values in the increasing order.\n\nExamples\n\nInput\n\n5 3 1\n1 2 3 2 1\n1 2 3\n\n\nOutput\n\n2\n1 3\n\n\nInput\n\n6 3 2\n1 3 2 2 3 1\n1 2 3\n\n\nOutput\n\n2\n1 2",
        "task_name": "368_D. Sereja ans Anagrams",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division\nfrom sys import stdin\nfrom collections import Counter\nfrom math import ceil\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, m, q = rints()\na, b, ans = rints(), Counter(rints()), []\nall = len(b)\n\nfor i in range(q):\n    dis, mem = set(), Counter()\n    if int(ceil((n - i) / q)) < m:\n        break\n\n    for j in range(i, i + (m - 1) * q, q):\n        mem[a[j]] += 1\n\n    for k, j in mem.items():\n        if j == b[k]:\n            dis.add(k)\n\n    be = i\n    for j in range(i + (m - 1) * q, n, q):\n        mem[a[j]] += 1\n        if mem[a[j]] == b[a[j]]:\n            dis.add(a[j])\n        else:\n            dis.discard(a[j])\n\n        if len(dis) == all:\n            ans.append(be + 1)\n\n        mem[a[be]] -= 1\n        if b[a[be]] and mem[a[be]] == b[a[be]]:\n            dis.add(a[be])\n        else:\n            dis.discard(a[be])\n\n        be += q\n\nprint('%d\\n%s' % (len(ans), ' '.join(map(str, sorted(ans)))))\n",
        "correct": true,
        "task_id": "1287",
        "depth": 2
    },
    {
        "description": "Many computer strategy games require building cities, recruiting army, conquering tribes, collecting resources. Sometimes it leads to interesting problems. \n\nLet's suppose that your task is to build a square city. The world map uses the Cartesian coordinates. The sides of the city should be parallel to coordinate axes. The map contains mines with valuable resources, located at some points with integer coordinates. The sizes of mines are relatively small, i.e. they can be treated as points. The city should be built in such a way that all the mines are inside or on the border of the city square. \n\nBuilding a city takes large amount of money depending on the size of the city, so you have to build the city with the minimum area. Given the positions of the mines find the minimum possible area of the city.\n\nInput\n\nThe first line of the input contains number n \u2014 the number of mines on the map (2 \u2264 n \u2264 1000). Each of the next n lines contains a pair of integers xi and yi \u2014 the coordinates of the corresponding mine ( - 109 \u2264 xi, yi \u2264 109). All points are pairwise distinct.\n\nOutput\n\nPrint the minimum area of the city that can cover all the mines with valuable resources.\n\nExamples\n\nInput\n\n2\n0 0\n2 2\n\n\nOutput\n\n4\n\n\nInput\n\n2\n0 0\n0 3\n\n\nOutput\n\n9",
        "task_name": "485_B. Valuable Resources",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "t=int(raw_input())\nmaxx,maxy=-10**18,-10**18\nminx=10**18\nminy=10**18\nfor z in xrange(t):\n    a,b=map(int,raw_input().split())\n    maxx=max(maxx,a)\n    minx=min(minx,a)\n    maxy=max(maxy,b)\n    miny=min(miny,b)\nprint (max(maxx-minx,maxy-miny))**2\n",
        "correct": true,
        "task_id": "1289",
        "depth": 1
    },
    {
        "description": "There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.\n\nThe library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.\n\nInput\n\nThe first line of the input data contains two integer numbers separated by a space n (1 \u2264 n \u2264 105) and k (0 \u2264 k \u2264 106) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1 \u2264 hi \u2264 106) is the height of the i-th book in millimeters.\n\nOutput\n\nIn the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters.\n\nIn each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.\n\nExamples\n\nInput\n\n3 3\n14 12 10\n\n\nOutput\n\n2 2\n1 2\n2 3\n\n\nInput\n\n2 0\n10 10\n\n\nOutput\n\n2 1\n1 2\n\n\nInput\n\n4 5\n8 19 10 13\n\n\nOutput\n\n2 1\n3 4",
        "task_name": "6_E. Exposition",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import heapq\n\nn, k = [int(x) for x in raw_input().split()]\nhLst = [int(x) for x in raw_input().split()]\na = i = j = 0\nr = []\nm = M = hLst[0]\nmI = MI = 0\nq1 = []\nq2 = []\nwhile j < n:\n\tw = hLst[j]\n\tif w <= m:\n\t\tm = w\n\t\tmI = j\n\tif w >= M:\n\t\tM = w\n\t\tMI = j\n\theapq.heappush(q1, (w, j))\n\theapq.heappush(q2, (-w, j))\n\tprevJ = j\n\tif M-m > k:\n\t\tbreak\n\tj += 1\nwhile j < n:\n\tif j-i > a:\n\t\ta = j-i\n\t\tr = [(i+1, j)]\n\telif j-i == a:\n\t\tr.append((i+1, j))\n\tif j-i == 1:\n\t\tm = M = hLst[j]\n\t\tmI = MI = j\n\t\ti += 1\n\telif mI < MI:\n\t\ti = mI+1\n\t\tw, t = heapq.heappop(q1)\n\t\twhile t < i:\n\t\t\tw, t = heapq.heappop(q1)\n\t\theapq.heappush(q1, (w, t))\n\t\tm = w\n\t\tmI = t\n\t\tw, t = heapq.heappop(q2)\n\t\twhile t < i:\n\t\t\tw, t = heapq.heappop(q2)\n\t\theapq.heappush(q2, (w, t))\n\telse:\n\t\ti = MI+1\n\t\tw, t = heapq.heappop(q2)\n\t\twhile t < i:\n\t\t\tw, t = heapq.heappop(q2)\n\t\theapq.heappush(q2, (w, t))\n\t\tM = -w\n\t\tMI = t\n\t\tw, t = heapq.heappop(q1)\n\t\twhile t < i:\n\t\t\tw, t = heapq.heappop(q1)\n\t\theapq.heappush(q1, (w, t))\n\twhile j < n:\n\t\tw = hLst[j]\n\t\tif w <= m:\n\t\t\tm = w\n\t\t\tmI = j\n\t\tif w >= M:\n\t\t\tM = w\n\t\t\tMI = j\n\t\tif prevJ != j:\n\t\t\theapq.heappush(q1, (w, j))\n\t\t\theapq.heappush(q2, (-w, j))\n\t\t\tprevJ = j\n\t\tif M-m > k:\n\t\t\tbreak\n\t\tj += 1\nif j-i > a:\n\ta = j-i\n\tr = [(i+1, j)]\nelif j-i == a:\n\tr.append((i+1, j))\n\t\nprint(str(a)+' '+str(len(r)))\nfor x in r:\n\tprint(str(x[0])+' '+str(x[1]))",
        "correct": true,
        "task_id": "1296",
        "depth": 2
    }
]