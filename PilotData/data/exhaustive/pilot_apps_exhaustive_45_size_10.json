[
    {
        "task_id": "0081",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Neko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.\n\nNeko has two integers $a$ and $b$. His goal is to find a non-negative integer $k$ such that the least common multiple of $a+k$ and $b+k$ is the smallest possible. If there are multiple optimal integers $k$, he needs to choose the smallest one.\n\nGiven his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n\n-----Input-----\n\nThe only line contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$).\n\n\n-----Output-----\n\nPrint the smallest non-negative integer $k$ ($k \\ge 0$) such that the lowest common multiple of $a+k$ and $b+k$ is the smallest possible.\n\nIf there are many possible integers $k$ giving the same value of the least common multiple, print the smallest one.\n\n\n-----Examples-----\nInput\n6 10\n\nOutput\n2\nInput\n21 31\n\nOutput\n9\nInput\n5 10\n\nOutput\n0\n\n\n-----Note-----\n\nIn the first test, one should choose $k = 2$, as the least common multiple of $6 + 2$ and $10 + 2$ is $24$, which is the smallest least common multiple possible.",
        "generated_code": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\na, b = map(int, input().split())\n\nk = 0\nmin_lcm = lcm(a, b)\n\nwhile True:\n    if lcm(a + k, b + k) < min_lcm:\n        min_lcm = lcm(a + k, b + k)\n    else:\n        break\n    k += 1\n\nprint(k - 1)\n",
        "counter_example": {
            "input": "6 10\n",
            "expected": "2",
            "got": "-1"
        }
    },
    {
        "task_id": "0081",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Neko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.\n\nNeko has two integers $a$ and $b$. His goal is to find a non-negative integer $k$ such that the least common multiple of $a+k$ and $b+k$ is the smallest possible. If there are multiple optimal integers $k$, he needs to choose the smallest one.\n\nGiven his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n\n-----Input-----\n\nThe only line contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$).\n\n\n-----Output-----\n\nPrint the smallest non-negative integer $k$ ($k \\ge 0$) such that the lowest common multiple of $a+k$ and $b+k$ is the smallest possible.\n\nIf there are many possible integers $k$ giving the same value of the least common multiple, print the smallest one.\n\n\n-----Examples-----\nInput\n6 10\n\nOutput\n2\nInput\n21 31\n\nOutput\n9\nInput\n5 10\n\nOutput\n0\n\n\n-----Note-----\n\nIn the first test, one should choose $k = 2$, as the least common multiple of $6 + 2$ and $10 + 2$ is $24$, which is the smallest least common multiple possible.",
        "generated_code": "import math\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n\n    diff = abs(a - b)\n    min_lcm = float('inf')\n    min_k = 0\n\n    for k in range(1, int(math.sqrt(diff)) + 1):\n        if diff % k == 0:\n            # Check both k and diff // k as possible values for the smallest k\n            for candidate in [k, diff // k]:\n                new_a = (a + candidate - 1) // candidate * candidate\n                new_b = (b + candidate - 1) // candidate * candidate\n                current_lcm = lcm(new_a, new_b)\n                if current_lcm < min_lcm or (current_lcm == min_lcm and candidate < min_k):\n                    min_lcm = current_lcm\n                    min_k = candidate\n\n    return min_k\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    a = int(data[0])\n    b = int(data[1])\n    print(find_min_k(a, b))\n",
        "counter_example": {
            "input": "6 10\n",
            "expected": "2",
            "got": "4"
        }
    },
    {
        "task_id": "0290",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Little Sofia is in fourth grade. Today in the geometry lesson she learned about segments and squares. On the way home, she decided to draw $n$ squares in the snow with a side length of $1$. For simplicity, we assume that Sofia lives on a plane and can draw only segments of length $1$, parallel to the coordinate axes, with vertices at integer points.\n\nIn order to draw a segment, Sofia proceeds as follows. If she wants to draw a vertical segment with the coordinates of the ends $(x, y)$ and $(x, y+1)$. Then Sofia looks if there is already a drawn segment with the coordinates of the ends $(x', y)$ and $(x', y+1)$ for some $x'$. If such a segment exists, then Sofia quickly draws a new segment, using the old one as a guideline. If there is no such segment, then Sofia has to take a ruler and measure a new segment for a long time. Same thing happens when Sofia wants to draw a horizontal segment, but only now she checks for the existence of a segment with the same coordinates $x$, $x+1$ and the differing coordinate $y$.\n\nFor example, if Sofia needs to draw one square, she will have to draw two segments using a ruler:  [Image] \n\nAfter that, she can draw the remaining two segments, using the first two as a guide:  [Image] \n\nIf Sofia needs to draw two squares, she will have to draw three segments using a ruler:  [Image] \n\nAfter that, she can draw the remaining four segments, using the first three as a guide:  [Image] \n\nSofia is in a hurry, so she wants to minimize the number of segments that she will have to draw with a ruler without a guide. Help her find this minimum number.\n\n\n-----Input-----\n\nThe only line of input contains a single integer $n$ ($1 \\le n \\le 10^{9}$), the number of squares that Sofia wants to draw.\n\n\n-----Output-----\n\nPrint single integer, the minimum number of segments that Sofia will have to draw with a ruler without a guide in order to draw $n$ squares in the manner described above.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n2\n\nInput\n2\n\nOutput\n3\n\nInput\n4\n\nOutput\n4",
        "generated_code": "n = int(input())\nprint(2 * (n.bit_length() - 1) + 2)\n",
        "counter_example": {
            "input": "2\n",
            "expected": "3\n",
            "got": "4"
        }
    },
    {
        "task_id": "0290",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Little Sofia is in fourth grade. Today in the geometry lesson she learned about segments and squares. On the way home, she decided to draw $n$ squares in the snow with a side length of $1$. For simplicity, we assume that Sofia lives on a plane and can draw only segments of length $1$, parallel to the coordinate axes, with vertices at integer points.\n\nIn order to draw a segment, Sofia proceeds as follows. If she wants to draw a vertical segment with the coordinates of the ends $(x, y)$ and $(x, y+1)$. Then Sofia looks if there is already a drawn segment with the coordinates of the ends $(x', y)$ and $(x', y+1)$ for some $x'$. If such a segment exists, then Sofia quickly draws a new segment, using the old one as a guideline. If there is no such segment, then Sofia has to take a ruler and measure a new segment for a long time. Same thing happens when Sofia wants to draw a horizontal segment, but only now she checks for the existence of a segment with the same coordinates $x$, $x+1$ and the differing coordinate $y$.\n\nFor example, if Sofia needs to draw one square, she will have to draw two segments using a ruler:  [Image] \n\nAfter that, she can draw the remaining two segments, using the first two as a guide:  [Image] \n\nIf Sofia needs to draw two squares, she will have to draw three segments using a ruler:  [Image] \n\nAfter that, she can draw the remaining four segments, using the first three as a guide:  [Image] \n\nSofia is in a hurry, so she wants to minimize the number of segments that she will have to draw with a ruler without a guide. Help her find this minimum number.\n\n\n-----Input-----\n\nThe only line of input contains a single integer $n$ ($1 \\le n \\le 10^{9}$), the number of squares that Sofia wants to draw.\n\n\n-----Output-----\n\nPrint single integer, the minimum number of segments that Sofia will have to draw with a ruler without a guide in order to draw $n$ squares in the manner described above.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n2\n\nInput\n2\n\nOutput\n3\n\nInput\n4\n\nOutput\n4",
        "generated_code": "import math\n\ndef min_segments(n):\n    min_segments_needed = float('inf')\n    \n    for a in range(1, int(math.sqrt(n)) + 1):\n        b = (n + a - 1) // a  # This is equivalent to math.ceil(n / a)\n        segments_needed = 2 * (a + b)\n        min_segments_needed = min(min_segments_needed, segments_needed)\n    \n    return min_segments_needed\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(min_segments(n))\n",
        "counter_example": {
            "input": "1\n",
            "expected": "2\n",
            "got": "4"
        }
    },
    {
        "task_id": "0149",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Unlucky year in Berland is such a year that its number n can be represented as n = x^{a} + y^{b}, where a and b are non-negative integer numbers. \n\nFor example, if x = 2 and y = 3 then the years 4 and 17 are unlucky (4 = 2^0 + 3^1, 17 = 2^3 + 3^2 = 2^4 + 3^0) and year 18 isn't unlucky as there is no such representation for it.\n\nSuch interval of years that there are no unlucky years in it is called The Golden Age.\n\nYou should write a program which will find maximum length of The Golden Age which starts no earlier than the year l and ends no later than the year r. If all years in the interval [l, r] are unlucky then the answer is 0.\n\n\n-----Input-----\n\nThe first line contains four integer numbers x, y, l and r (2 ≤ x, y ≤ 10^18, 1 ≤ l ≤ r ≤ 10^18).\n\n\n-----Output-----\n\nPrint the maximum length of The Golden Age within the interval [l, r].\n\nIf all years in the interval [l, r] are unlucky then print 0.\n\n\n-----Examples-----\nInput\n2 3 1 10\n\nOutput\n1\n\nInput\n3 5 10 22\n\nOutput\n8\n\nInput\n2 3 3 5\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example the unlucky years are 2, 3, 4, 5, 7, 9 and 10. So maximum length of The Golden Age is achived in the intervals [1, 1], [6, 6] and [8, 8].\n\nIn the second example the longest Golden Age is the interval [15, 22].",
        "generated_code": "def is_unlucky(x, y, n):\n    for a in range(61):\n        for b in range(61):\n            if x**a + y**b == n:\n                return True\n    return False\n\nx, y, l, r = map(int, input().split())\nmax_golden_age = 0\nstart = l\nwhile start <= r:\n    if not is_unlucky(x, y, start):\n        end = start\n        while end <= r and not is_unlucky(x, y, end):\n            end += 1\n        max_golden_age = max(max_golden_age, end - start)\n        start = end\n    else:\n        start += 1\nprint(max_golden_age)\n",
        "counter_example": {
            "input": "2 2 1 1000000\n",
            "expected": "213568\n",
            "got": "TimeoutError: Execution exceeded time limit"
        }
    },
    {
        "task_id": "0149",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Unlucky year in Berland is such a year that its number n can be represented as n = x^{a} + y^{b}, where a and b are non-negative integer numbers. \n\nFor example, if x = 2 and y = 3 then the years 4 and 17 are unlucky (4 = 2^0 + 3^1, 17 = 2^3 + 3^2 = 2^4 + 3^0) and year 18 isn't unlucky as there is no such representation for it.\n\nSuch interval of years that there are no unlucky years in it is called The Golden Age.\n\nYou should write a program which will find maximum length of The Golden Age which starts no earlier than the year l and ends no later than the year r. If all years in the interval [l, r] are unlucky then the answer is 0.\n\n\n-----Input-----\n\nThe first line contains four integer numbers x, y, l and r (2 ≤ x, y ≤ 10^18, 1 ≤ l ≤ r ≤ 10^18).\n\n\n-----Output-----\n\nPrint the maximum length of The Golden Age within the interval [l, r].\n\nIf all years in the interval [l, r] are unlucky then print 0.\n\n\n-----Examples-----\nInput\n2 3 1 10\n\nOutput\n1\n\nInput\n3 5 10 22\n\nOutput\n8\n\nInput\n2 3 3 5\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example the unlucky years are 2, 3, 4, 5, 7, 9 and 10. So maximum length of The Golden Age is achived in the intervals [1, 1], [6, 6] and [8, 8].\n\nIn the second example the longest Golden Age is the interval [15, 22].",
        "generated_code": "def generate_unlucky_years(x, y, l, r):\n    # Generate all unlucky years within a certain reasonable bound.\n    unlucky_years = set()\n    a, b = 0, 0\n    max_value = r + 1\n    power_x = 1\n    while power_x < max_value:\n        power_y = 1\n        b = 0\n        while power_x + power_y < max_value:\n            year = power_x + power_y\n            if l <= year <= r:\n                unlucky_years.add(year)\n            power_y *= y\n            b += 1\n            if power_y > r:\n                break\n        power_x *= x\n        a += 1\n        if power_x > r:\n            break\n    return unlucky_years\n\ndef max_golden_age(x, y, l, r):\n    unlucky_years = generate_unlucky_years(x, y, l, r)\n    unlucky_years = sorted(list(unlucky_years))\n    \n    max_length = 0\n    previous_end = l - 1\n    \n    for year in unlucky_years:\n        if year > previous_end + 1:\n            max_length = max(max_length, year - previous_end - 1)\n        previous_end = year\n    \n    if previous_end < r:\n        max_length = max(max_length, r - previous_end)\n    \n    return max_length\n\n# Read input values\nx, y, l, r = map(int, input().split())\n\n# Calculate and print the maximum length of the golden age\nprint(max_golden_age(x, y, l, r))\n",
        "counter_example": null
    },
    {
        "task_id": "0116",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": true,
        "description": "Today an outstanding event is going to happen in the forest — hedgehog Filya will come to his old fried Sonya!\n\nSonya is an owl and she sleeps during the day and stay awake from minute l_1 to minute r_1 inclusive. Also, during the minute k she prinks and is unavailable for Filya.\n\nFilya works a lot and he plans to visit Sonya from minute l_2 to minute r_2 inclusive.\n\nCalculate the number of minutes they will be able to spend together.\n\n\n-----Input-----\n\nThe only line of the input contains integers l_1, r_1, l_2, r_2 and k (1 ≤ l_1, r_1, l_2, r_2, k ≤ 10^18, l_1 ≤ r_1, l_2 ≤ r_2), providing the segments of time for Sonya and Filya and the moment of time when Sonya prinks.\n\n\n-----Output-----\n\nPrint one integer — the number of minutes Sonya and Filya will be able to spend together.\n\n\n-----Examples-----\nInput\n1 10 9 20 1\n\nOutput\n2\n\nInput\n1 100 50 200 75\n\nOutput\n50\n\n\n\n-----Note-----\n\nIn the first sample, they will be together during minutes 9 and 10.\n\nIn the second sample, they will be together from minute 50 to minute 74 and from minute 76 to minute 100.",
        "generated_code": "l1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate the intersection of Sonya's and Filya's time segments\nstart = max(l1, l2)\nend = min(r1, r2)\n\n# If Sonya prinks during their common time, subtract 1 minute\nif start <= k <= end:\n    end -= 1\n\n# Calculate the number of minutes they can spend together\nminutes_together = max(0, end - start + 1)\n\nprint(minutes_together)\n",
        "counter_example": null
    },
    {
        "task_id": "0116",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Today an outstanding event is going to happen in the forest — hedgehog Filya will come to his old fried Sonya!\n\nSonya is an owl and she sleeps during the day and stay awake from minute l_1 to minute r_1 inclusive. Also, during the minute k she prinks and is unavailable for Filya.\n\nFilya works a lot and he plans to visit Sonya from minute l_2 to minute r_2 inclusive.\n\nCalculate the number of minutes they will be able to spend together.\n\n\n-----Input-----\n\nThe only line of the input contains integers l_1, r_1, l_2, r_2 and k (1 ≤ l_1, r_1, l_2, r_2, k ≤ 10^18, l_1 ≤ r_1, l_2 ≤ r_2), providing the segments of time for Sonya and Filya and the moment of time when Sonya prinks.\n\n\n-----Output-----\n\nPrint one integer — the number of minutes Sonya and Filya will be able to spend together.\n\n\n-----Examples-----\nInput\n1 10 9 20 1\n\nOutput\n2\n\nInput\n1 100 50 200 75\n\nOutput\n50\n\n\n\n-----Note-----\n\nIn the first sample, they will be together during minutes 9 and 10.\n\nIn the second sample, they will be together from minute 50 to minute 74 and from minute 76 to minute 100.",
        "generated_code": "# Read the input values\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate the overlapping interval\nstart = max(l1, l2)\nend = min(r1, r2)\n\n# Determine the number of minutes they can spend together\nif start > end:\n    print(0)\nelse:\n    overlap = end - start + 1\n    if start <= k <= end:\n        overlap -= 1\n    print(overlap)\n",
        "counter_example": null
    },
    {
        "task_id": "0040",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Is it rated?\n\nHere it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.\n\nAnother Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.\n\nIt's known that if at least one participant's rating has changed, then the round was rated for sure.\n\nIt's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.\n\nIn this problem, you should not make any other assumptions about the rating system.\n\nDetermine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.\n\n\n-----Input-----\n\nThe first line contains a single integer n (2 ≤ n ≤ 1000) — the number of round participants.\n\nEach of the next n lines contains two integers a_{i} and b_{i} (1 ≤ a_{i}, b_{i} ≤ 4126) — the rating of the i-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.\n\n\n-----Output-----\n\nIf the round is rated for sure, print \"rated\". If the round is unrated for sure, print \"unrated\". If it's impossible to determine whether the round is rated or not, print \"maybe\".\n\n\n-----Examples-----\nInput\n6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n\nOutput\nrated\n\nInput\n4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n\nOutput\nunrated\n\nInput\n5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n\nOutput\nmaybe\n\n\n\n-----Note-----\n\nIn the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.\n\nIn the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.\n\nIn the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.",
        "generated_code": "n = int(input())\nratings_before = []\nratings_after = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    ratings_before.append(a)\n    ratings_after.append(b)\n\nrated = False\nunrated = True\nmaybe = True\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if ratings_before[i] < ratings_before[j] and ratings_after[i] > ratings_after[j]:\n            unrated = False\n            break\n    if not unrated:\n        break\n\nfor i in range(n):\n    if ratings_before[i] != ratings_after[i]:\n        rated = True\n        break\n\nif rated:\n    print(\"rated\")\nelif unrated:\n    print(\"unrated\")\nelse:\n    print(\"maybe\")\n",
        "counter_example": {
            "input": "5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n",
            "expected": "maybe\n",
            "got": "unrated"
        }
    },
    {
        "task_id": "0040",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Is it rated?\n\nHere it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.\n\nAnother Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.\n\nIt's known that if at least one participant's rating has changed, then the round was rated for sure.\n\nIt's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.\n\nIn this problem, you should not make any other assumptions about the rating system.\n\nDetermine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.\n\n\n-----Input-----\n\nThe first line contains a single integer n (2 ≤ n ≤ 1000) — the number of round participants.\n\nEach of the next n lines contains two integers a_{i} and b_{i} (1 ≤ a_{i}, b_{i} ≤ 4126) — the rating of the i-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.\n\n\n-----Output-----\n\nIf the round is rated for sure, print \"rated\". If the round is unrated for sure, print \"unrated\". If it's impossible to determine whether the round is rated or not, print \"maybe\".\n\n\n-----Examples-----\nInput\n6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n\nOutput\nrated\n\nInput\n4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n\nOutput\nunrated\n\nInput\n5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n\nOutput\nmaybe\n\n\n\n-----Note-----\n\nIn the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.\n\nIn the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.\n\nIn the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.",
        "generated_code": "# Read the number of participants\nn = int(input())\n\n# Initialize a list to store the ratings before and after the round\nratings = []\n\n# Flag to determine if the round is rated\nis_rated = False\n\n# Flag to determine if the round is unrated\nis_unrated = False\n\n# Read the ratings before and after the round for each participant\nfor _ in range(n):\n    a, b = map(int, input().split())\n    ratings.append((a, b))\n    if a != b:\n        is_rated = True\n\n# If the round is not rated, check for unrated condition\nif not is_rated:\n    for i in range(1, n):\n        if ratings[i-1][0] < ratings[i][0]:\n            is_unrated = True\n            break\n\n# Determine the output based on the flags\nif is_rated:\n    print(\"rated\")\nelif is_unrated:\n    print(\"unrated\")\nelse:\n    print(\"maybe\")\n",
        "counter_example": null
    }
]