[
    {
        "task_id": "0242",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Mr. Santa asks all the great programmers of the world to solve a trivial problem. He gives them an integer m and asks for the number of positive integers n, such that the factorial of n ends with exactly m zeroes. Are you among those great programmers who can solve this problem?\n\n\n-----Input-----\n\nThe only line of input contains an integer m (1 ≤ m ≤ 100 000) — the required number of trailing zeroes in factorial.\n\n\n-----Output-----\n\nFirst print k — the number of values of n such that the factorial of n ends with m zeroes. Then print these k integers in increasing order.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n5\n5 6 7 8 9 \nInput\n5\n\nOutput\n0\n\n\n-----Note-----\n\nThe factorial of n is equal to the product of all integers from 1 to n inclusive, that is n! = 1·2·3·...·n.\n\nIn the first sample, 5! = 120, 6! = 720, 7! = 5040, 8! = 40320 and 9! = 362880.",
        "generated_code": "m = int(input())\ncount = 0\nn = 1\nwhile True:\n    if n // 5 ** count >= m:\n        break\n    count += 1\nn = 1\nans = []\nwhile True:\n    if n // 5 ** count < m:\n        break\n    ans.append(n)\n    n += 1\nprint(len(ans))\nprint(' '.join(map(str, ans)))\n",
        "counter_example": {
            "input": "1\n",
            "expected": "5\n5 6 7 8 9 ",
            "got": "TimeoutError: Execution exceeded time limit"
        }
    },
    {
        "task_id": "0242",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Mr. Santa asks all the great programmers of the world to solve a trivial problem. He gives them an integer m and asks for the number of positive integers n, such that the factorial of n ends with exactly m zeroes. Are you among those great programmers who can solve this problem?\n\n\n-----Input-----\n\nThe only line of input contains an integer m (1 ≤ m ≤ 100 000) — the required number of trailing zeroes in factorial.\n\n\n-----Output-----\n\nFirst print k — the number of values of n such that the factorial of n ends with m zeroes. Then print these k integers in increasing order.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n5\n5 6 7 8 9 \nInput\n5\n\nOutput\n0\n\n\n-----Note-----\n\nThe factorial of n is equal to the product of all integers from 1 to n inclusive, that is n! = 1·2·3·...·n.\n\nIn the first sample, 5! = 120, 6! = 720, 7! = 5040, 8! = 40320 and 9! = 362880.",
        "generated_code": "def count_trailing_zeroes(n):\n    \"\"\" Return the number of trailing zeroes in n! \"\"\"\n    count = 0\n    power_of_5 = 5\n    while n >= power_of_5:\n        count += n // power_of_5\n        power_of_5 *= 5\n    return count\n\ndef find_numbers_with_trailing_zeroes(m):\n    \"\"\" Find all numbers n such that n! ends with exactly m trailing zeroes \"\"\"\n    low, high = 0, 5 * (m + 1)\n    result = []\n\n    while low <= high:\n        mid = (low + high) // 2\n        zeroes = count_trailing_zeroes(mid)\n        if zeroes < m:\n            low = mid + 1\n        elif zeroes > m:\n            high = mid - 1\n        else:\n            result = []\n            left = mid\n            while count_trailing_zeroes(left) == m:\n                left -= 1\n            right = mid + 1\n            while count_trailing_zeroes(right) == m:\n                right += 1\n            result = list(range(left + 1, right))\n            break\n\n    return result\n\n# Read input\nm = int(input())\n\n# Find result\nresult = find_numbers_with_trailing_zeroes(m)\n\n# Output result\nif result:\n    print(len(result))\n    print(' '.join(map(str, result)))\nelse:\n    print(0)\n",
        "counter_example": null
    },
    {
        "task_id": "0163",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "On the way to Rio de Janeiro Ostap kills time playing with a grasshopper he took with him in a special box. Ostap builds a line of length n such that some cells of this line are empty and some contain obstacles. Then, he places his grasshopper to one of the empty cells and a small insect in another empty cell. The grasshopper wants to eat the insect.\n\nOstap knows that grasshopper is able to jump to any empty cell that is exactly k cells away from the current (to the left or to the right). Note that it doesn't matter whether intermediate cells are empty or not as the grasshopper makes a jump over them. For example, if k = 1 the grasshopper can jump to a neighboring cell only, and if k = 2 the grasshopper can jump over a single cell.\n\nYour goal is to determine whether there is a sequence of jumps such that grasshopper will get from his initial position to the cell with an insect.\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and k (2 ≤ n ≤ 100, 1 ≤ k ≤ n - 1) — the number of cells in the line and the length of one grasshopper's jump.\n\nThe second line contains a string of length n consisting of characters '.', '#', 'G' and 'T'. Character '.' means that the corresponding cell is empty, character '#' means that the corresponding cell contains an obstacle and grasshopper can't jump there. Character 'G' means that the grasshopper starts at this position and, finally, 'T' means that the target insect is located at this cell. It's guaranteed that characters 'G' and 'T' appear in this line exactly once.\n\n\n-----Output-----\n\nIf there exists a sequence of jumps (each jump of length k), such that the grasshopper can get from his initial position to the cell with the insect, print \"YES\" (without quotes) in the only line of the input. Otherwise, print \"NO\" (without quotes).\n\n\n-----Examples-----\nInput\n5 2\n#G#T#\n\nOutput\nYES\n\nInput\n6 1\nT....G\n\nOutput\nYES\n\nInput\n7 3\nT..#..G\n\nOutput\nNO\n\nInput\n6 2\n..GT..\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first sample, the grasshopper can make one jump to the right in order to get from cell 2 to cell 4.\n\nIn the second sample, the grasshopper is only able to jump to neighboring cells but the way to the insect is free — he can get there by jumping left 5 times.\n\nIn the third sample, the grasshopper can't make a single jump.\n\nIn the fourth sample, the grasshopper can only jump to the cells with odd indices, thus he won't be able to reach the insect.",
        "generated_code": "n, k = map(int, input().split())\ns = input()\ng, t = -1, -1\nfor i in range(n):\n    if s[i] == 'G':\n        g = i\n    elif s[i] == 'T':\n        t = i\nif g == -1 or t == -1:\n    print(\"NO\")\nelse:\n    if abs(t - g) % k == 0 and all(s[(g + i * k) % n] != '#' for i in range(abs(t - g) // k + 1)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "counter_example": {
            "input": "7 3\nT..#..G\n",
            "expected": "NO\n",
            "got": "YES"
        }
    },
    {
        "task_id": "0163",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "On the way to Rio de Janeiro Ostap kills time playing with a grasshopper he took with him in a special box. Ostap builds a line of length n such that some cells of this line are empty and some contain obstacles. Then, he places his grasshopper to one of the empty cells and a small insect in another empty cell. The grasshopper wants to eat the insect.\n\nOstap knows that grasshopper is able to jump to any empty cell that is exactly k cells away from the current (to the left or to the right). Note that it doesn't matter whether intermediate cells are empty or not as the grasshopper makes a jump over them. For example, if k = 1 the grasshopper can jump to a neighboring cell only, and if k = 2 the grasshopper can jump over a single cell.\n\nYour goal is to determine whether there is a sequence of jumps such that grasshopper will get from his initial position to the cell with an insect.\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and k (2 ≤ n ≤ 100, 1 ≤ k ≤ n - 1) — the number of cells in the line and the length of one grasshopper's jump.\n\nThe second line contains a string of length n consisting of characters '.', '#', 'G' and 'T'. Character '.' means that the corresponding cell is empty, character '#' means that the corresponding cell contains an obstacle and grasshopper can't jump there. Character 'G' means that the grasshopper starts at this position and, finally, 'T' means that the target insect is located at this cell. It's guaranteed that characters 'G' and 'T' appear in this line exactly once.\n\n\n-----Output-----\n\nIf there exists a sequence of jumps (each jump of length k), such that the grasshopper can get from his initial position to the cell with the insect, print \"YES\" (without quotes) in the only line of the input. Otherwise, print \"NO\" (without quotes).\n\n\n-----Examples-----\nInput\n5 2\n#G#T#\n\nOutput\nYES\n\nInput\n6 1\nT....G\n\nOutput\nYES\n\nInput\n7 3\nT..#..G\n\nOutput\nNO\n\nInput\n6 2\n..GT..\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first sample, the grasshopper can make one jump to the right in order to get from cell 2 to cell 4.\n\nIn the second sample, the grasshopper is only able to jump to neighboring cells but the way to the insect is free — he can get there by jumping left 5 times.\n\nIn the third sample, the grasshopper can't make a single jump.\n\nIn the fourth sample, the grasshopper can only jump to the cells with odd indices, thus he won't be able to reach the insect.",
        "generated_code": "# Read input values\nn, k = map(int, input().split())\nline = input()\n\n# Find positions of 'G' and 'T'\nG_pos = line.index('G')\nT_pos = line.index('T')\n\n# Ensure G_pos is less than T_pos for consistency\nif G_pos > T_pos:\n    G_pos, T_pos = T_pos, G_pos\n\n# Check every k-th position from G_pos to T_pos\nreachable = False\nfor pos in range(G_pos, T_pos + 1, k):\n    if line[pos] == '#':\n        break\n    if pos == T_pos:\n        reachable = True\n        break\n\n# Output the result\nif reachable:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "counter_example": null
    },
    {
        "task_id": "0201",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "A sweet little monster Om Nom loves candies very much. One day he found himself in a rather tricky situation that required him to think a bit in order to enjoy candies the most. Would you succeed with the same task if you were on his place? [Image] \n\nOne day, when he came to his friend Evan, Om Nom didn't find him at home but he found two bags with candies. The first was full of blue candies and the second bag was full of red candies. Om Nom knows that each red candy weighs W_{r} grams and each blue candy weighs W_{b} grams. Eating a single red candy gives Om Nom H_{r} joy units and eating a single blue candy gives Om Nom H_{b} joy units.\n\nCandies are the most important thing in the world, but on the other hand overeating is not good. Om Nom knows if he eats more than C grams of candies, he will get sick. Om Nom thinks that it isn't proper to leave candy leftovers, so he can only eat a whole candy. Om Nom is a great mathematician and he quickly determined how many candies of what type he should eat in order to get the maximum number of joy units. Can you repeat his achievement? You can assume that each bag contains more candies that Om Nom can eat.\n\n\n-----Input-----\n\nThe single line contains five integers C, H_{r}, H_{b}, W_{r}, W_{b} (1 ≤ C, H_{r}, H_{b}, W_{r}, W_{b} ≤ 10^9).\n\n\n-----Output-----\n\nPrint a single integer — the maximum number of joy units that Om Nom can get.\n\n\n-----Examples-----\nInput\n10 3 5 2 3\n\nOutput\n16\n\n\n\n-----Note-----\n\nIn the sample test Om Nom can eat two candies of each type and thus get 16 joy units.",
        "generated_code": "C, Hr, Hb, Wr, Wb = map(int, input().split())\n\nmax_joy = 0\nfor r in range(C // Wr + 1):\n    b = (C - r * Wr) // Wb\n    joy = r * Hr + b * Hb\n    max_joy = max(max_joy, joy)\n\nprint(max_joy)\n",
        "counter_example": {
            "input": "902303498 609628987 152407246 8 2\n",
            "expected": "68758795931537065\n",
            "got": "TimeoutError: Execution exceeded time limit"
        }
    },
    {
        "task_id": "0201",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "A sweet little monster Om Nom loves candies very much. One day he found himself in a rather tricky situation that required him to think a bit in order to enjoy candies the most. Would you succeed with the same task if you were on his place? [Image] \n\nOne day, when he came to his friend Evan, Om Nom didn't find him at home but he found two bags with candies. The first was full of blue candies and the second bag was full of red candies. Om Nom knows that each red candy weighs W_{r} grams and each blue candy weighs W_{b} grams. Eating a single red candy gives Om Nom H_{r} joy units and eating a single blue candy gives Om Nom H_{b} joy units.\n\nCandies are the most important thing in the world, but on the other hand overeating is not good. Om Nom knows if he eats more than C grams of candies, he will get sick. Om Nom thinks that it isn't proper to leave candy leftovers, so he can only eat a whole candy. Om Nom is a great mathematician and he quickly determined how many candies of what type he should eat in order to get the maximum number of joy units. Can you repeat his achievement? You can assume that each bag contains more candies that Om Nom can eat.\n\n\n-----Input-----\n\nThe single line contains five integers C, H_{r}, H_{b}, W_{r}, W_{b} (1 ≤ C, H_{r}, H_{b}, W_{r}, W_{b} ≤ 10^9).\n\n\n-----Output-----\n\nPrint a single integer — the maximum number of joy units that Om Nom can get.\n\n\n-----Examples-----\nInput\n10 3 5 2 3\n\nOutput\n16\n\n\n\n-----Note-----\n\nIn the sample test Om Nom can eat two candies of each type and thus get 16 joy units.",
        "generated_code": "def max_joy(C, H_r, H_b, W_r, W_b):\n    max_joy_units = 0\n\n    # Try to maximize joy by iterating over number of red candies\n    for red_candies in range(0, C // W_r + 1):\n        remaining_capacity = C - red_candies * W_r\n        blue_candies = remaining_capacity // W_b\n        joy_units = red_candies * H_r + blue_candies * H_b\n        max_joy_units = max(max_joy_units, joy_units)\n\n    return max_joy_units\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\nC, H_r, H_b, W_r, W_b = map(int, data)\n\n# Print the maximum number of joy units\nprint(max_joy(C, H_r, H_b, W_r, W_b))\n",
        "counter_example": {
            "input": "902303498 609628987 152407246 8 2\n",
            "expected": "68758795931537065\n",
            "got": "TimeoutError: Execution exceeded time limit"
        }
    },
    {
        "task_id": "0269",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Nothing is eternal in the world, Kostya understood it on the 7-th of January when he saw partially dead four-color garland.\n\nNow he has a goal to replace dead light bulbs, however he doesn't know how many light bulbs for each color are required. It is guaranteed that for each of four colors at least one light is working.\n\nIt is known that the garland contains light bulbs of four colors: red, blue, yellow and green. The garland is made as follows: if you take any four consecutive light bulbs then there will not be light bulbs with the same color among them. For example, the garland can look like \"RYBGRYBGRY\", \"YBGRYBGRYBG\", \"BGRYB\", but can not look like \"BGRYG\", \"YBGRYBYGR\" or \"BGYBGY\". Letters denote colors: 'R' — red, 'B' — blue, 'Y' — yellow, 'G' — green.\n\nUsing the information that for each color at least one light bulb still works count the number of dead light bulbs of each four colors.\n\n\n-----Input-----\n\nThe first and the only line contains the string s (4 ≤ |s| ≤ 100), which describes the garland, the i-th symbol of which describes the color of the i-th light bulb in the order from the beginning of garland:   'R' — the light bulb is red,  'B' — the light bulb is blue,  'Y' — the light bulb is yellow,  'G' — the light bulb is green,  '!' — the light bulb is dead. \n\nThe string s can not contain other symbols except those five which were described. \n\nIt is guaranteed that in the given string at least once there is each of four letters 'R', 'B', 'Y' and 'G'. \n\nIt is guaranteed that the string s is correct garland with some blown light bulbs, it means that for example the line \"GRBY!!!B\" can not be in the input data. \n\n\n-----Output-----\n\nIn the only line print four integers k_{r}, k_{b}, k_{y}, k_{g} — the number of dead light bulbs of red, blue, yellow and green colors accordingly.\n\n\n-----Examples-----\nInput\nRYBGRYBGR\n\nOutput\n0 0 0 0\nInput\n!RGYB\n\nOutput\n0 1 0 0\nInput\n!!!!YGRB\n\nOutput\n1 1 1 1\nInput\n!GB!RG!Y!\n\nOutput\n2 1 1 0\n\n\n-----Note-----\n\nIn the first example there are no dead light bulbs.\n\nIn the second example it is obvious that one blue bulb is blown, because it could not be light bulbs of other colors on its place according to the statements.",
        "generated_code": "s = input()\nr, b, y, g = 0, 0, 0, 0\nfor c in s:\n    if c == '!':\n        if s[s.index(c)-1] == 'R':\n            r += 1\n        elif s[s.index(c)-1] == 'B':\n            b += 1\n        elif s[s.index(c)-1] == 'Y':\n            y += 1\n        elif s[s.index(c)-1] == 'G':\n            g += 1\nprint(r, b, y, g)\n",
        "counter_example": {
            "input": "!!!!YGRB\n",
            "expected": "1 1 1 1",
            "got": "0 4 0 0"
        }
    },
    {
        "task_id": "0269",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Nothing is eternal in the world, Kostya understood it on the 7-th of January when he saw partially dead four-color garland.\n\nNow he has a goal to replace dead light bulbs, however he doesn't know how many light bulbs for each color are required. It is guaranteed that for each of four colors at least one light is working.\n\nIt is known that the garland contains light bulbs of four colors: red, blue, yellow and green. The garland is made as follows: if you take any four consecutive light bulbs then there will not be light bulbs with the same color among them. For example, the garland can look like \"RYBGRYBGRY\", \"YBGRYBGRYBG\", \"BGRYB\", but can not look like \"BGRYG\", \"YBGRYBYGR\" or \"BGYBGY\". Letters denote colors: 'R' — red, 'B' — blue, 'Y' — yellow, 'G' — green.\n\nUsing the information that for each color at least one light bulb still works count the number of dead light bulbs of each four colors.\n\n\n-----Input-----\n\nThe first and the only line contains the string s (4 ≤ |s| ≤ 100), which describes the garland, the i-th symbol of which describes the color of the i-th light bulb in the order from the beginning of garland:   'R' — the light bulb is red,  'B' — the light bulb is blue,  'Y' — the light bulb is yellow,  'G' — the light bulb is green,  '!' — the light bulb is dead. \n\nThe string s can not contain other symbols except those five which were described. \n\nIt is guaranteed that in the given string at least once there is each of four letters 'R', 'B', 'Y' and 'G'. \n\nIt is guaranteed that the string s is correct garland with some blown light bulbs, it means that for example the line \"GRBY!!!B\" can not be in the input data. \n\n\n-----Output-----\n\nIn the only line print four integers k_{r}, k_{b}, k_{y}, k_{g} — the number of dead light bulbs of red, blue, yellow and green colors accordingly.\n\n\n-----Examples-----\nInput\nRYBGRYBGR\n\nOutput\n0 0 0 0\nInput\n!RGYB\n\nOutput\n0 1 0 0\nInput\n!!!!YGRB\n\nOutput\n1 1 1 1\nInput\n!GB!RG!Y!\n\nOutput\n2 1 1 0\n\n\n-----Note-----\n\nIn the first example there are no dead light bulbs.\n\nIn the second example it is obvious that one blue bulb is blown, because it could not be light bulbs of other colors on its place according to the statements.",
        "generated_code": "s = input().strip()\n\n# Initialize counters for each color\ndead_bulbs = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n\n# Determine the positions (modulo 4) for each color\npositions = {}\nfor i, char in enumerate(s):\n    if char in 'RBYG':\n        positions[char] = i % 4\n\n# Count the number of dead bulbs for each color\nfor i, char in enumerate(s):\n    if char == '!':\n        for color, pos in positions.items():\n            if i % 4 == pos:\n                dead_bulbs[color] += 1\n\n# Output the result\nprint(dead_bulbs['R'], dead_bulbs['B'], dead_bulbs['Y'], dead_bulbs['G'])\n",
        "counter_example": null
    },
    {
        "task_id": "0185",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Finished her homework, Nastya decided to play computer games. Passing levels one by one, Nastya eventually faced a problem. Her mission is to leave a room, where a lot of monsters live, as quickly as possible.\n\nThere are $n$ manholes in the room which are situated on one line, but, unfortunately, all the manholes are closed, and there is one stone on every manhole. There is exactly one coin under every manhole, and to win the game Nastya should pick all the coins. Initially Nastya stands near the $k$-th manhole from the left. She is thinking what to do.\n\nIn one turn, Nastya can do one of the following:   if there is at least one stone on the manhole Nastya stands near, throw exactly one stone from it onto any other manhole (yes, Nastya is strong).  go to a neighboring manhole;  if there are no stones on the manhole Nastya stays near, she can open it and pick the coin from it. After it she must close the manhole immediately (it doesn't require additional moves). \n\n [Image] The figure shows the intermediate state of the game. At the current position Nastya can throw the stone to any other manhole or move left or right to the neighboring manholes. If she were near the leftmost manhole, she could open it (since there are no stones on it). \n\nNastya can leave the room when she picks all the coins. Monsters are everywhere, so you need to compute the minimum number of moves Nastya has to make to pick all the coins.\n\nNote one time more that Nastya can open a manhole only when there are no stones onto it.\n\n\n-----Input-----\n\nThe first and only line contains two integers $n$ and $k$, separated by space ($2 \\leq n \\leq 5000$, $1 \\leq k \\leq n$) — the number of manholes and the index of manhole from the left, near which Nastya stays initially. Initially there is exactly one stone near each of the $n$ manholes. \n\n\n-----Output-----\n\nPrint a single integer — minimum number of moves which lead Nastya to pick all the coins.\n\n\n-----Examples-----\nInput\n2 2\n\nOutput\n6\n\nInput\n4 2\n\nOutput\n13\n\nInput\n5 1\n\nOutput\n15\n\n\n\n-----Note-----\n\nLet's consider the example where $n = 2$, $k = 2$. Nastya should play as follows:\n\n  At first she throws the stone from the second manhole to the first. Now there are two stones on the first manhole.  Then she opens the second manhole and pick the coin from it.  Then she goes to the first manhole, throws two stones by two moves to the second manhole and then opens the manhole and picks the coin from it. \n\nSo, $6$ moves are required to win.",
        "generated_code": "n, k = map(int, input().split())\nans = 0\nfor i in range(1, n + 1):\n    if i != k:\n        ans += 2 * abs(i - k) + 2\n    else:\n        ans += 2\nprint(ans)\n",
        "counter_example": {
            "input": "4 2\n",
            "expected": "13\n",
            "got": "16"
        }
    },
    {
        "task_id": "0185",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Finished her homework, Nastya decided to play computer games. Passing levels one by one, Nastya eventually faced a problem. Her mission is to leave a room, where a lot of monsters live, as quickly as possible.\n\nThere are $n$ manholes in the room which are situated on one line, but, unfortunately, all the manholes are closed, and there is one stone on every manhole. There is exactly one coin under every manhole, and to win the game Nastya should pick all the coins. Initially Nastya stands near the $k$-th manhole from the left. She is thinking what to do.\n\nIn one turn, Nastya can do one of the following:   if there is at least one stone on the manhole Nastya stands near, throw exactly one stone from it onto any other manhole (yes, Nastya is strong).  go to a neighboring manhole;  if there are no stones on the manhole Nastya stays near, she can open it and pick the coin from it. After it she must close the manhole immediately (it doesn't require additional moves). \n\n [Image] The figure shows the intermediate state of the game. At the current position Nastya can throw the stone to any other manhole or move left or right to the neighboring manholes. If she were near the leftmost manhole, she could open it (since there are no stones on it). \n\nNastya can leave the room when she picks all the coins. Monsters are everywhere, so you need to compute the minimum number of moves Nastya has to make to pick all the coins.\n\nNote one time more that Nastya can open a manhole only when there are no stones onto it.\n\n\n-----Input-----\n\nThe first and only line contains two integers $n$ and $k$, separated by space ($2 \\leq n \\leq 5000$, $1 \\leq k \\leq n$) — the number of manholes and the index of manhole from the left, near which Nastya stays initially. Initially there is exactly one stone near each of the $n$ manholes. \n\n\n-----Output-----\n\nPrint a single integer — minimum number of moves which lead Nastya to pick all the coins.\n\n\n-----Examples-----\nInput\n2 2\n\nOutput\n6\n\nInput\n4 2\n\nOutput\n13\n\nInput\n5 1\n\nOutput\n15\n\n\n\n-----Note-----\n\nLet's consider the example where $n = 2$, $k = 2$. Nastya should play as follows:\n\n  At first she throws the stone from the second manhole to the first. Now there are two stones on the first manhole.  Then she opens the second manhole and pick the coin from it.  Then she goes to the first manhole, throws two stones by two moves to the second manhole and then opens the manhole and picks the coin from it. \n\nSo, $6$ moves are required to win.",
        "generated_code": "n, k = map(int, input().split())\n\n# Calculate the minimum number of moves required\n# The general formula derived from the explanation is:\n# (number_of_moves_to_throw_stones * (n-1)) + (number_of_moves_to_pick_coins)\n# where n-1 is the number of manholes to be processed (excluding the starting manhole)\n\ntotal_moves = 3 * n - 3 + min(k - 1, n - k)\nprint(total_moves)\n",
        "counter_example": {
            "input": "2 2\n",
            "expected": "6\n",
            "got": "3"
        }
    }
]