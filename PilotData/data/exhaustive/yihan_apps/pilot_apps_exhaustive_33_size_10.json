[
    {
        "task_id": "0064",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": true,
        "description": "One day Kefa found n baloons. For convenience, we denote color of i-th baloon as s_{i} — lowercase letter of the Latin alphabet. Also Kefa has k friends. Friend will be upset, If he get two baloons of the same color. Kefa want to give out all baloons to his friends. Help Kefa to find out, can he give out all his baloons, such that no one of his friens will be upset — print «YES», if he can, and «NO», otherwise. Note, that Kefa's friend will not upset, if he doesn't get baloons at all.\n\n\n-----Input-----\n\nThe first line contains two integers n and k (1 ≤ n, k ≤ 100) — the number of baloons and friends.\n\nNext line contains string s — colors of baloons.\n\n\n-----Output-----\n\nAnswer to the task — «YES» or «NO» in a single line.\n\nYou can choose the case (lower or upper) for each letter arbitrary.\n\n\n-----Examples-----\nInput\n4 2\naabb\n\nOutput\nYES\n\nInput\n6 3\naacaab\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first sample Kefa can give 1-st and 3-rd baloon to the first friend, and 2-nd and 4-th to the second.\n\nIn the second sample Kefa needs to give to all his friends baloons of color a, but one baloon will stay, thats why answer is «NO».",
        "generated_code": "n, k = map(int, input().split())\ns = input()\n\ncolor_count = {}\nfor c in s:\n    if c in color_count:\n        color_count[c] += 1\n    else:\n        color_count[c] = 1\n\nmax_color_count = max(color_count.values())\nif max_color_count <= k:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "counter_example": null
    },
    {
        "task_id": "0064",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "One day Kefa found n baloons. For convenience, we denote color of i-th baloon as s_{i} — lowercase letter of the Latin alphabet. Also Kefa has k friends. Friend will be upset, If he get two baloons of the same color. Kefa want to give out all baloons to his friends. Help Kefa to find out, can he give out all his baloons, such that no one of his friens will be upset — print «YES», if he can, and «NO», otherwise. Note, that Kefa's friend will not upset, if he doesn't get baloons at all.\n\n\n-----Input-----\n\nThe first line contains two integers n and k (1 ≤ n, k ≤ 100) — the number of baloons and friends.\n\nNext line contains string s — colors of baloons.\n\n\n-----Output-----\n\nAnswer to the task — «YES» or «NO» in a single line.\n\nYou can choose the case (lower or upper) for each letter arbitrary.\n\n\n-----Examples-----\nInput\n4 2\naabb\n\nOutput\nYES\n\nInput\n6 3\naacaab\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first sample Kefa can give 1-st and 3-rd baloon to the first friend, and 2-nd and 4-th to the second.\n\nIn the second sample Kefa needs to give to all his friends baloons of color a, but one baloon will stay, thats why answer is «NO».",
        "generated_code": "# Read input values\nn, k = map(int, input().split())\ns = input()\n\n# Count the occurrences of each balloon color\ncolor_count = {}\nfor color in s:\n    if color in color_count:\n        color_count[color] += 1\n    else:\n        color_count[color] = 1\n\n# Check if any color count exceeds the number of friends\ncan_distribute = True\nfor count in color_count.values():\n    if count > k:\n        can_distribute = False\n        break\n\n# Print the result\nif can_distribute:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "counter_example": null
    },
    {
        "task_id": "0131",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "There is a beautiful garden of stones in Innopolis.\n\nIts most beautiful place is the $n$ piles with stones numbered from $1$ to $n$.\n\nEJOI participants have visited this place twice. \n\nWhen they first visited it, the number of stones in piles was $x_1, x_2, \\ldots, x_n$, correspondingly. One of the participants wrote down this sequence in a notebook. \n\nThey visited it again the following day, and the number of stones in piles was equal to $y_1, y_2, \\ldots, y_n$. One of the participants also wrote it down in a notebook.\n\nIt is well known that every member of the EJOI jury during the night either sits in the room $108$ or comes to the place with stones. Each jury member who comes there either takes one stone for himself or moves one stone from one pile to another. We can assume that there is an unlimited number of jury members. No one except the jury goes to the place with stones at night.\n\nParticipants want to know whether their notes can be correct or they are sure to have made a mistake.\n\n\n-----Input-----\n\nThe first line of the input file contains a single integer $n$, the number of piles with stones in the garden ($1 \\leq n \\leq 50$).\n\nThe second line contains $n$ integers separated by spaces $x_1, x_2, \\ldots, x_n$, the number of stones in piles recorded in the notebook when the participants came to the place with stones for the first time ($0 \\leq x_i \\leq 1000$).\n\nThe third line contains $n$ integers separated by spaces $y_1, y_2, \\ldots, y_n$, the number of stones in piles recorded in the notebook when the participants came to the place with stones for the second time ($0 \\leq y_i \\leq 1000$).\n\n\n-----Output-----\n\nIf the records can be consistent output \"Yes\", otherwise output \"No\" (quotes for clarity).\n\n\n-----Examples-----\nInput\n5\n1 2 3 4 5\n2 1 4 3 5\n\nOutput\nYes\n\nInput\n5\n1 1 1 1 1\n1 0 1 0 1\n\nOutput\nYes\n\nInput\n3\n2 3 9\n1 7 9\n\nOutput\nNo\n\n\n\n-----Note-----\n\nIn the first example, the following could have happened during the night: one of the jury members moved one stone from the second pile to the first pile, and the other jury member moved one stone from the fourth pile to the third pile.\n\nIn the second example, the jury took stones from the second and fourth piles.\n\nIt can be proved that it is impossible for the jury members to move and took stones to convert the first array into the second array.",
        "generated_code": "n = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nif sum(x) != sum(y):\n    print(\"No\")\nelse:\n    x.sort()\n    y.sort()\n    if x == y:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "counter_example": {
            "input": "5\n1 1 1 1 1\n1 0 1 0 1\n",
            "expected": "Yes\n",
            "got": "No"
        }
    },
    {
        "task_id": "0131",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "There is a beautiful garden of stones in Innopolis.\n\nIts most beautiful place is the $n$ piles with stones numbered from $1$ to $n$.\n\nEJOI participants have visited this place twice. \n\nWhen they first visited it, the number of stones in piles was $x_1, x_2, \\ldots, x_n$, correspondingly. One of the participants wrote down this sequence in a notebook. \n\nThey visited it again the following day, and the number of stones in piles was equal to $y_1, y_2, \\ldots, y_n$. One of the participants also wrote it down in a notebook.\n\nIt is well known that every member of the EJOI jury during the night either sits in the room $108$ or comes to the place with stones. Each jury member who comes there either takes one stone for himself or moves one stone from one pile to another. We can assume that there is an unlimited number of jury members. No one except the jury goes to the place with stones at night.\n\nParticipants want to know whether their notes can be correct or they are sure to have made a mistake.\n\n\n-----Input-----\n\nThe first line of the input file contains a single integer $n$, the number of piles with stones in the garden ($1 \\leq n \\leq 50$).\n\nThe second line contains $n$ integers separated by spaces $x_1, x_2, \\ldots, x_n$, the number of stones in piles recorded in the notebook when the participants came to the place with stones for the first time ($0 \\leq x_i \\leq 1000$).\n\nThe third line contains $n$ integers separated by spaces $y_1, y_2, \\ldots, y_n$, the number of stones in piles recorded in the notebook when the participants came to the place with stones for the second time ($0 \\leq y_i \\leq 1000$).\n\n\n-----Output-----\n\nIf the records can be consistent output \"Yes\", otherwise output \"No\" (quotes for clarity).\n\n\n-----Examples-----\nInput\n5\n1 2 3 4 5\n2 1 4 3 5\n\nOutput\nYes\n\nInput\n5\n1 1 1 1 1\n1 0 1 0 1\n\nOutput\nYes\n\nInput\n3\n2 3 9\n1 7 9\n\nOutput\nNo\n\n\n\n-----Note-----\n\nIn the first example, the following could have happened during the night: one of the jury members moved one stone from the second pile to the first pile, and the other jury member moved one stone from the fourth pile to the third pile.\n\nIn the second example, the jury took stones from the second and fourth piles.\n\nIt can be proved that it is impossible for the jury members to move and took stones to convert the first array into the second array.",
        "generated_code": "n = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\ntotal_x = sum(x)\ntotal_y = sum(y)\n\n# Check if the total number of stones has decreased or remained the same\nif total_y > total_x:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n",
        "counter_example": null
    },
    {
        "task_id": "0112",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Absent-minded Masha got set of n cubes for her birthday.\n\nAt each of 6 faces of each cube, there is exactly one digit from 0 to 9. Masha became interested what is the largest natural x such she can make using her new cubes all integers from 1 to x.\n\nTo make a number Masha can rotate her cubes and put them in a row. After that, she looks at upper faces of cubes from left to right and reads the number.\n\nThe number can't contain leading zeros. It's not required to use all cubes to build a number.\n\nPay attention: Masha can't make digit 6 from digit 9 and vice-versa using cube rotations.\n\n\n-----Input-----\n\nIn first line integer n is given (1 ≤ n ≤ 3) — the number of cubes, Masha got for her birthday.\n\nEach of next n lines contains 6 integers a_{i}_{j} (0 ≤ a_{i}_{j} ≤ 9) — number on j-th face of i-th cube.\n\n\n-----Output-----\n\nPrint single integer — maximum number x such Masha can make any integers from 1 to x using her cubes or 0 if Masha can't make even 1.\n\n\n-----Examples-----\nInput\n3\n0 1 2 3 4 5\n6 7 8 9 0 1\n2 3 4 5 6 7\n\nOutput\n87\nInput\n3\n0 1 3 5 6 8\n1 2 4 5 7 8\n2 3 4 6 7 9\n\nOutput\n98\n\n\n-----Note-----\n\nIn the first test case, Masha can build all numbers from 1 to 87, but she can't make 88 because there are no two cubes with digit 8.",
        "generated_code": "n = int(input())\ncubes = [list(map(int, input().split())) for _ in range(n)]\n\ndigits = set()\nfor cube in cubes:\n    digits.update(str(digit) for digit in cube)\n\nif '0' in digits:\n    digits.remove('0')\n\nmax_num = int(''.join(sorted(digits, reverse=True)))\nprint(max_num)\n",
        "counter_example": {
            "input": "3\n0 1 2 3 4 5\n6 7 8 9 0 1\n2 3 4 5 6 7\n",
            "expected": "87",
            "got": "987654321"
        }
    },
    {
        "task_id": "0112",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Absent-minded Masha got set of n cubes for her birthday.\n\nAt each of 6 faces of each cube, there is exactly one digit from 0 to 9. Masha became interested what is the largest natural x such she can make using her new cubes all integers from 1 to x.\n\nTo make a number Masha can rotate her cubes and put them in a row. After that, she looks at upper faces of cubes from left to right and reads the number.\n\nThe number can't contain leading zeros. It's not required to use all cubes to build a number.\n\nPay attention: Masha can't make digit 6 from digit 9 and vice-versa using cube rotations.\n\n\n-----Input-----\n\nIn first line integer n is given (1 ≤ n ≤ 3) — the number of cubes, Masha got for her birthday.\n\nEach of next n lines contains 6 integers a_{i}_{j} (0 ≤ a_{i}_{j} ≤ 9) — number on j-th face of i-th cube.\n\n\n-----Output-----\n\nPrint single integer — maximum number x such Masha can make any integers from 1 to x using her cubes or 0 if Masha can't make even 1.\n\n\n-----Examples-----\nInput\n3\n0 1 2 3 4 5\n6 7 8 9 0 1\n2 3 4 5 6 7\n\nOutput\n87\nInput\n3\n0 1 3 5 6 8\n1 2 4 5 7 8\n2 3 4 6 7 9\n\nOutput\n98\n\n\n-----Note-----\n\nIn the first test case, Masha can build all numbers from 1 to 87, but she can't make 88 because there are no two cubes with digit 8.",
        "generated_code": "def find_max_x(n, cubes):\n    from itertools import product\n\n    # Create a set for each cube's faces\n    cube_faces = [set(cube) for cube in cubes]\n\n    def can_form_number(num):\n        digits = list(str(num))\n        used_cubes = [False] * n\n\n        for digit in digits:\n            found = False\n            for i in range(n):\n                if not used_cubes[i] and digit in cube_faces[i]:\n                    used_cubes[i] = True\n                    found = True\n                    break\n            if not found:\n                return False\n        return True\n\n    x = 0\n    while can_form_number(x + 1):\n        x += 1\n\n    return x\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    cubes = []\n    index = 1\n    \n    for i in range(n):\n        cubes.append(data[index:index + 6])\n        index += 6\n\n    print(find_max_x(n, cubes))\n",
        "counter_example": {
            "input": "3\n0 1 2 3 4 5\n6 7 8 9 0 1\n2 3 4 5 6 7\n",
            "expected": "87",
            "got": "67"
        }
    },
    {
        "task_id": "0115",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "The Bad Luck Island is inhabited by three kinds of species: r rocks, s scissors and p papers. At some moments of time two random individuals meet (all pairs of individuals can meet equiprobably), and if they belong to different species, then one individual kills the other one: a rock kills scissors, scissors kill paper, and paper kills a rock. Your task is to determine for each species what is the probability that this species will be the only one to inhabit this island after a long enough period of time.\n\n\n-----Input-----\n\nThe single line contains three integers r, s and p (1 ≤ r, s, p ≤ 100) — the original number of individuals in the species of rock, scissors and paper, respectively.\n\n\n-----Output-----\n\nPrint three space-separated real numbers: the probabilities, at which the rocks, the scissors and the paper will be the only surviving species, respectively. The answer will be considered correct if the relative or absolute error of each number doesn't exceed 10^{ - 9}.\n\n\n-----Examples-----\nInput\n2 2 2\n\nOutput\n0.333333333333 0.333333333333 0.333333333333\n\nInput\n2 1 2\n\nOutput\n0.150000000000 0.300000000000 0.550000000000\n\nInput\n1 1 3\n\nOutput\n0.057142857143 0.657142857143 0.285714285714",
        "generated_code": "r, s, p = map(int, input().split())\ntotal = r + s + p\n\n# Calculate the probability of each species to be the only one surviving\nrock_prob = 0\nscissor_prob = 0\npaper_prob = 0\n\nif r > s and r > p:\n    rock_prob = 1\nelif s > r and s > p:\n    scissor_prob = 1\nelif p > r and p > s:\n    paper_prob = 1\nelse:\n    # Calculate the probability when no species has a clear advantage\n    rock_prob = (r * (r - 1) + r * s + r * p) / (total * (total - 1))\n    scissor_prob = (s * (s - 1) + s * p + s * r) / (total * (total - 1))\n    paper_prob = (p * (p - 1) + p * r + p * s) / (total * (total - 1))\n\nprint(\"{:.9f} {:.9f} {:.9f}\".format(rock_prob, scissor_prob, paper_prob))\n",
        "counter_example": {
            "input": "2 2 2\n",
            "expected": "0.333333333333 0.333333333333 0.333333333333\n",
            "got": "0.333333333 0.333333333 0.333333333"
        }
    },
    {
        "task_id": "0115",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "The Bad Luck Island is inhabited by three kinds of species: r rocks, s scissors and p papers. At some moments of time two random individuals meet (all pairs of individuals can meet equiprobably), and if they belong to different species, then one individual kills the other one: a rock kills scissors, scissors kill paper, and paper kills a rock. Your task is to determine for each species what is the probability that this species will be the only one to inhabit this island after a long enough period of time.\n\n\n-----Input-----\n\nThe single line contains three integers r, s and p (1 ≤ r, s, p ≤ 100) — the original number of individuals in the species of rock, scissors and paper, respectively.\n\n\n-----Output-----\n\nPrint three space-separated real numbers: the probabilities, at which the rocks, the scissors and the paper will be the only surviving species, respectively. The answer will be considered correct if the relative or absolute error of each number doesn't exceed 10^{ - 9}.\n\n\n-----Examples-----\nInput\n2 2 2\n\nOutput\n0.333333333333 0.333333333333 0.333333333333\n\nInput\n2 1 2\n\nOutput\n0.150000000000 0.300000000000 0.550000000000\n\nInput\n1 1 3\n\nOutput\n0.057142857143 0.657142857143 0.285714285714",
        "generated_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip()\n    r, s, p = map(int, data.split())\n    \n    dp = [[[0.0 for _ in range(p+1)] for _ in range(s+1)] for _ in range(r+1)]\n    \n    dp[r][s][p] = 1.0\n    \n    for i in range(r, -1, -1):\n        for j in range(s, -1, -1):\n            for k in range(p, -1, -1):\n                sum_ = i*j + j*k + k*i\n                if i > 0 and j > 0:\n                    dp[i-1][j][k] += dp[i][j][k] * (i * j) / sum_\n                if j > 0 and k > 0:\n                    dp[i][j-1][k] += dp[i][j][k] * (j * k) / sum_\n                if k > 0 and i > 0:\n                    dp[i][j][k-1] += dp[i][j][k] * (k * i) / sum_\n    \n    prob_rock = sum(dp[i][0][0] for i in range(r+1))\n    prob_scissor = sum(dp[0][j][0] for j in range(s+1))\n    prob_paper = sum(dp[0][0][k] for k in range(p+1))\n    \n    print(f\"{prob_rock:.12f} {prob_scissor:.12f} {prob_paper:.12f}\")\n\nif __name__ == \"__main__\":\n    main()\n",
        "counter_example": {
            "input": "2 1 2\n",
            "expected": "0.150000000000 0.300000000000 0.550000000000\n",
            "got": "0.550000000000 0.300000000000 0.150000000000"
        }
    },
    {
        "task_id": "0280",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "There are N camels numbered 1 through N.\nThe weight of Camel i is w_i.\nYou will arrange the camels in a line and make them cross a bridge consisting of M parts.\nBefore they cross the bridge, you can choose their order in the line - it does not have to be Camel 1, 2, \\ldots, N from front to back - and specify the distance between each adjacent pair of camels to be any non-negative real number.\nThe camels will keep the specified distances between them while crossing the bridge.\nThe i-th part of the bridge has length l_i and weight capacity v_i.\nIf the sum of the weights of camels inside a part (excluding the endpoints) exceeds v_i, the bridge will collapse.\nDetermine whether it is possible to make the camels cross the bridge without it collapsing. If it is possible, find the minimum possible distance between the first and last camels in the line in such a case.\nIt can be proved that the answer is always an integer, so print an integer.\n\n-----Constraints-----\n - All values in input are integers.\n - 2 \\leq N \\leq 8\n - 1 \\leq M \\leq 10^5\n - 1 \\leq w_i,l_i,v_i \\leq 10^8\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nw_1 w_2 \\cdots w_N\nl_1 v_1\n\\vdots\nl_M v_M\n\n-----Output-----\nIf the bridge will unavoidably collapse when the camels cross the bridge, print -1.\nOtherwise, print the minimum possible distance between the first and last camels in the line when the camels cross the bridge without it collapsing.\n\n-----Sample Input-----\n3 2\n1 4 2\n10 4\n2 6\n\n-----Sample Output-----\n10\n\n - It is possible to make the camels cross the bridge without it collapsing by, for example, arranging them in the order 1, 3, 2 from front to back, and setting the distances between them to be 0, 10.\n - For Part 1 of the bridge, there are moments when only Camel 1 and 3 are inside the part and moments when only Camel 2 is inside the part. In both cases, the sum of the weights of camels does not exceed 4 - the weight capacity of Part 1 - so there is no collapse.\n - For Part 2 of the bridge, there are moments when only Camel 1 and 3 are inside the part and moments when only Camel 2 is inside the part. In both cases, the sum of the weights of camels does not exceed 6 - the weight capacity of Part 2 - so there is no collapse.\n - Note that the distance between two camels may be 0 and that camels on endpoints of a part are not considered to be inside the part.",
        "generated_code": "def can_cross_bridge(N, M, weights, bridge):\n    dp = [[False] * (M + 1) for _ in range(N + 1)]\n    dp[0][0] = True\n    for i in range(N):\n        for j in range(M):\n            if dp[i][j]:\n                if j < M and weights[i] <= bridge[j][1]:\n                    dp[i + 1][j + 1] = True\n                dp[i + 1][j] = True\n    return dp[N][M]\n\ndef main():\n    N, M = map(int, input().split())\n    weights = list(map(int, input().split()))\n    bridge = [list(map(int, input().split())) for _ in range(M)]\n    weights.sort()\n    bridge.sort(key=lambda x: x[0])\n    l, r = 0, 10**18\n    while l < r:\n        mid = (l + r) // 2\n        if can_cross_bridge(N, M, weights, [(l, v) for l, v in bridge]):\n            r = mid\n        else:\n            l = mid + 1\n    if l == 10**18:\n        print(-1)\n    else:\n        print(l)\n\nif __name__ == \"__main__\":\n    main()\n",
        "counter_example": {
            "input": "3 2\n1 4 2\n10 4\n2 6\n",
            "expected": "10\n",
            "got": "0"
        }
    },
    {
        "task_id": "0280",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "There are N camels numbered 1 through N.\nThe weight of Camel i is w_i.\nYou will arrange the camels in a line and make them cross a bridge consisting of M parts.\nBefore they cross the bridge, you can choose their order in the line - it does not have to be Camel 1, 2, \\ldots, N from front to back - and specify the distance between each adjacent pair of camels to be any non-negative real number.\nThe camels will keep the specified distances between them while crossing the bridge.\nThe i-th part of the bridge has length l_i and weight capacity v_i.\nIf the sum of the weights of camels inside a part (excluding the endpoints) exceeds v_i, the bridge will collapse.\nDetermine whether it is possible to make the camels cross the bridge without it collapsing. If it is possible, find the minimum possible distance between the first and last camels in the line in such a case.\nIt can be proved that the answer is always an integer, so print an integer.\n\n-----Constraints-----\n - All values in input are integers.\n - 2 \\leq N \\leq 8\n - 1 \\leq M \\leq 10^5\n - 1 \\leq w_i,l_i,v_i \\leq 10^8\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nw_1 w_2 \\cdots w_N\nl_1 v_1\n\\vdots\nl_M v_M\n\n-----Output-----\nIf the bridge will unavoidably collapse when the camels cross the bridge, print -1.\nOtherwise, print the minimum possible distance between the first and last camels in the line when the camels cross the bridge without it collapsing.\n\n-----Sample Input-----\n3 2\n1 4 2\n10 4\n2 6\n\n-----Sample Output-----\n10\n\n - It is possible to make the camels cross the bridge without it collapsing by, for example, arranging them in the order 1, 3, 2 from front to back, and setting the distances between them to be 0, 10.\n - For Part 1 of the bridge, there are moments when only Camel 1 and 3 are inside the part and moments when only Camel 2 is inside the part. In both cases, the sum of the weights of camels does not exceed 4 - the weight capacity of Part 1 - so there is no collapse.\n - For Part 2 of the bridge, there are moments when only Camel 1 and 3 are inside the part and moments when only Camel 2 is inside the part. In both cases, the sum of the weights of camels does not exceed 6 - the weight capacity of Part 2 - so there is no collapse.\n - Note that the distance between two camels may be 0 and that camels on endpoints of a part are not considered to be inside the part.",
        "generated_code": "import itertools\n\ndef can_cross(bridge_parts, camels, N):\n    for part_length, part_capacity in bridge_parts:\n        max_weight = 0\n        for start in range(N):\n            total_weight = 0\n            for end in range(start, N):\n                total_weight += camels[end]\n                if total_weight > part_capacity:\n                    break\n                max_weight = max(max_weight, total_weight)\n        if max_weight > part_capacity:\n            return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    camels = []\n    for i in range(N):\n        camels.append(int(data[index]))\n        index += 1\n    \n    bridge_parts = []\n    for i in range(M):\n        l = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        bridge_parts.append((l, v))\n    \n    min_distance = float('inf')\n    possible = False\n    \n    for perm in itertools.permutations(camels):\n        if can_cross(bridge_parts, perm, N):\n            possible = True\n            min_distance = min(min_distance, sum(bridge_parts[i][0] for i in range(N - 1)))\n    \n    if possible:\n        print(min_distance)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()\n",
        "counter_example": {
            "input": "3 2\n1 4 2\n10 4\n2 6\n",
            "expected": "10\n",
            "got": "12"
        }
    }
]