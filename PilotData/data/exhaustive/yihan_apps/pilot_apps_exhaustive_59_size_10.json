[
    {
        "task_id": "0021",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Nicholas has an array a that contains n distinct integers from 1 to n. In other words, Nicholas has a permutation of size n.\n\nNicholas want the minimum element (integer 1) and the maximum element (integer n) to be as far as possible from each other. He wants to perform exactly one swap in order to maximize the distance between the minimum and the maximum elements. The distance between two elements is considered to be equal to the absolute difference between their positions.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (2 ≤ n ≤ 100) — the size of the permutation.\n\nThe second line of the input contains n distinct integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ n), where a_{i} is equal to the element at the i-th position.\n\n\n-----Output-----\n\nPrint a single integer — the maximum possible distance between the minimum and the maximum elements Nicholas can achieve by performing exactly one swap.\n\n\n-----Examples-----\nInput\n5\n4 5 1 3 2\n\nOutput\n3\n\nInput\n7\n1 6 5 3 4 7 2\n\nOutput\n6\n\nInput\n6\n6 5 4 3 2 1\n\nOutput\n5\n\n\n\n-----Note-----\n\nIn the first sample, one may obtain the optimal answer by swapping elements 1 and 2.\n\nIn the second sample, the minimum and the maximum elements will be located in the opposite ends of the array if we swap 7 and 2.\n\nIn the third sample, the distance between the minimum and the maximum elements is already maximum possible, so we just perform some unnecessary swap, for example, one can swap 5 and 2.",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\npos1 = a.index(1)\nposn = a.index(n)\n\nmax_dist = max(abs(pos1 - posn) - 1, n - 2)\nmin_dist = min(abs(pos1 - posn) - 1, n - 2)\n\nprint(max(max_dist, n - 1 - min_dist))\n",
        "counter_example": {
            "input": "5\n4 5 1 3 2\n",
            "expected": "3\n",
            "got": "4"
        }
    },
    {
        "task_id": "0021",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Nicholas has an array a that contains n distinct integers from 1 to n. In other words, Nicholas has a permutation of size n.\n\nNicholas want the minimum element (integer 1) and the maximum element (integer n) to be as far as possible from each other. He wants to perform exactly one swap in order to maximize the distance between the minimum and the maximum elements. The distance between two elements is considered to be equal to the absolute difference between their positions.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (2 ≤ n ≤ 100) — the size of the permutation.\n\nThe second line of the input contains n distinct integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ n), where a_{i} is equal to the element at the i-th position.\n\n\n-----Output-----\n\nPrint a single integer — the maximum possible distance between the minimum and the maximum elements Nicholas can achieve by performing exactly one swap.\n\n\n-----Examples-----\nInput\n5\n4 5 1 3 2\n\nOutput\n3\n\nInput\n7\n1 6 5 3 4 7 2\n\nOutput\n6\n\nInput\n6\n6 5 4 3 2 1\n\nOutput\n5\n\n\n\n-----Note-----\n\nIn the first sample, one may obtain the optimal answer by swapping elements 1 and 2.\n\nIn the second sample, the minimum and the maximum elements will be located in the opposite ends of the array if we swap 7 and 2.\n\nIn the third sample, the distance between the minimum and the maximum elements is already maximum possible, so we just perform some unnecessary swap, for example, one can swap 5 and 2.",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\n# Find the initial positions of the minimum and maximum elements\nmin_pos = a.index(1)\nmax_pos = a.index(n)\n\n# Calculate possible new distances after performing one swap\n# Option 1: Swap the minimum element with the element at the start\ndist1 = abs(0 - max_pos)\n# Option 2: Swap the minimum element with the element at the end\ndist2 = abs((n-1) - max_pos)\n# Option 3: Swap the maximum element with the element at the start\ndist3 = abs(0 - min_pos)\n# Option 4: Swap the maximum element with the element at the end\ndist4 = abs((n-1) - min_pos)\n\n# The maximum possible distance after one swap\nmax_distance = max(dist1, dist2, dist3, dist4)\nprint(max_distance)\n",
        "counter_example": null
    },
    {
        "task_id": "0196",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).\n\nUnfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. \n\nNastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.\n\nNastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 10^9 + 7, because it is easy to see that it is always integer.\n\n\n-----Input-----\n\nThe only line contains two integers x and k (0 ≤ x, k ≤ 10^18), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.\n\n\n-----Output-----\n\nIn the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 10^9 + 7.\n\n\n-----Examples-----\nInput\n2 0\n\nOutput\n4\n\nInput\n2 1\n\nOutput\n7\n\nInput\n3 2\n\nOutput\n21\n\n\n\n-----Note-----\n\nIn the first example a year consists on only one month, so the wardrobe does not eat dresses at all.\n\nIn the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.",
        "generated_code": "MOD = 10**9 + 7\nx, k = map(int, input().split())\nans = x\nfor _ in range(k):\n    ans = (ans * 2) % MOD\n    ans = (ans + ans) // 2 % MOD\nprint(ans)\n",
        "counter_example": {
            "input": "2 0\n",
            "expected": "4\n",
            "got": "2"
        }
    },
    {
        "task_id": "0196",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).\n\nUnfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. \n\nNastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.\n\nNastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 10^9 + 7, because it is easy to see that it is always integer.\n\n\n-----Input-----\n\nThe only line contains two integers x and k (0 ≤ x, k ≤ 10^18), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.\n\n\n-----Output-----\n\nIn the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 10^9 + 7.\n\n\n-----Examples-----\nInput\n2 0\n\nOutput\n4\n\nInput\n2 1\n\nOutput\n7\n\nInput\n3 2\n\nOutput\n21\n\n\n\n-----Note-----\n\nIn the first example a year consists on only one month, so the wardrobe does not eat dresses at all.\n\nIn the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.",
        "generated_code": "MOD = 10**9 + 7\n\ndef power_mod(base, exponent, mod):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exponent //= 2\n    return result\n\ndef expected_dresses(x, k):\n    if x == 0:\n        return 0\n    # Calculate (2^(k+1) - 1) % MOD\n    power = power_mod(2, k + 1, MOD)\n    result = (x * (power - 1) % MOD) % MOD\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\nx, k = map(int, input().split())\n\n# Print the result\nprint(expected_dresses(x, k))\n",
        "counter_example": {
            "input": "2 0\n",
            "expected": "4\n",
            "got": "2"
        }
    },
    {
        "task_id": "0118",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Ted has a pineapple. This pineapple is able to bark like a bulldog! At time t (in seconds) it barks for the first time. Then every s seconds after it, it barks twice with 1 second interval. Thus it barks at times t, t + s, t + s + 1, t + 2s, t + 2s + 1, etc.\n\n [Image] \n\nBarney woke up in the morning and wants to eat the pineapple, but he can't eat it when it's barking. Barney plans to eat it at time x (in seconds), so he asked you to tell him if it's gonna bark at that time.\n\n\n-----Input-----\n\nThe first and only line of input contains three integers t, s and x (0 ≤ t, x ≤ 10^9, 2 ≤ s ≤ 10^9) — the time the pineapple barks for the first time, the pineapple barking interval, and the time Barney wants to eat the pineapple respectively.\n\n\n-----Output-----\n\nPrint a single \"YES\" (without quotes) if the pineapple will bark at time x or a single \"NO\" (without quotes) otherwise in the only line of output.\n\n\n-----Examples-----\nInput\n3 10 4\n\nOutput\nNO\n\nInput\n3 10 3\n\nOutput\nYES\n\nInput\n3 8 51\n\nOutput\nYES\n\nInput\n3 8 52\n\nOutput\nYES\n\n\n\n-----Note-----\n\nIn the first and the second sample cases pineapple will bark at moments 3, 13, 14, ..., so it won't bark at the moment 4 and will bark at the moment 3.\n\nIn the third and fourth sample cases pineapple will bark at moments 3, 11, 12, 19, 20, 27, 28, 35, 36, 43, 44, 51, 52, 59, ..., so it will bark at both moments 51 and 52.",
        "generated_code": "t, s, x = map(int, input().split())\nif (x - t) % s == 0 or (x - t) % s == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "counter_example": {
            "input": "3 10 4\n",
            "expected": "NO\n",
            "got": "YES"
        }
    },
    {
        "task_id": "0118",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Ted has a pineapple. This pineapple is able to bark like a bulldog! At time t (in seconds) it barks for the first time. Then every s seconds after it, it barks twice with 1 second interval. Thus it barks at times t, t + s, t + s + 1, t + 2s, t + 2s + 1, etc.\n\n [Image] \n\nBarney woke up in the morning and wants to eat the pineapple, but he can't eat it when it's barking. Barney plans to eat it at time x (in seconds), so he asked you to tell him if it's gonna bark at that time.\n\n\n-----Input-----\n\nThe first and only line of input contains three integers t, s and x (0 ≤ t, x ≤ 10^9, 2 ≤ s ≤ 10^9) — the time the pineapple barks for the first time, the pineapple barking interval, and the time Barney wants to eat the pineapple respectively.\n\n\n-----Output-----\n\nPrint a single \"YES\" (without quotes) if the pineapple will bark at time x or a single \"NO\" (without quotes) otherwise in the only line of output.\n\n\n-----Examples-----\nInput\n3 10 4\n\nOutput\nNO\n\nInput\n3 10 3\n\nOutput\nYES\n\nInput\n3 8 51\n\nOutput\nYES\n\nInput\n3 8 52\n\nOutput\nYES\n\n\n\n-----Note-----\n\nIn the first and the second sample cases pineapple will bark at moments 3, 13, 14, ..., so it won't bark at the moment 4 and will bark at the moment 3.\n\nIn the third and fourth sample cases pineapple will bark at moments 3, 11, 12, 19, 20, 27, 28, 35, 36, 43, 44, 51, 52, 59, ..., so it will bark at both moments 51 and 52.",
        "generated_code": "t, s, x = map(int, input().split())\n\nif x == t:\n    print(\"YES\")\nelif x > t:\n    if (x - t) % s == 0:\n        print(\"YES\")\n    elif (x - t - 1) % s == 0 and x != t + 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    print(\"NO\")\n",
        "counter_example": null
    },
    {
        "task_id": "0137",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Kuro has recently won the \"Most intelligent cat ever\" contest. The three friends then decided to go to Katie's home to celebrate Kuro's winning. After a big meal, they took a small break then started playing games.\n\nKuro challenged Katie to create a game with only a white paper, a pencil, a pair of scissors and a lot of arrows (you can assume that the number of arrows is infinite). Immediately, Katie came up with the game called Topological Parity.\n\nThe paper is divided into $n$ pieces enumerated from $1$ to $n$. Shiro has painted some pieces with some color. Specifically, the $i$-th piece has color $c_{i}$ where $c_{i} = 0$ defines black color, $c_{i} = 1$ defines white color and $c_{i} = -1$ means that the piece hasn't been colored yet.\n\nThe rules of the game is simple. Players must put some arrows between some pairs of different pieces in such a way that for each arrow, the number in the piece it starts from is less than the number of the piece it ends at. Also, two different pieces can only be connected by at most one arrow. After that the players must choose the color ($0$ or $1$) for each of the unpainted pieces. The score of a valid way of putting the arrows and coloring pieces is defined as the number of paths of pieces of alternating colors. For example, $[1 \\to 0 \\to 1 \\to 0]$, $[0 \\to 1 \\to 0 \\to 1]$, $[1]$, $[0]$ are valid paths and will be counted. You can only travel from piece $x$ to piece $y$ if and only if there is an arrow from $x$ to $y$.\n\nBut Kuro is not fun yet. He loves parity. Let's call his favorite parity $p$ where $p = 0$ stands for \"even\" and $p = 1$ stands for \"odd\". He wants to put the arrows and choose colors in such a way that the score has the parity of $p$.\n\nIt seems like there will be so many ways which satisfy Kuro. He wants to count the number of them but this could be a very large number. Let's help him with his problem, but print it modulo $10^{9} + 7$.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $p$ ($1 \\leq n \\leq 50$, $0 \\leq p \\leq 1$) — the number of pieces and Kuro's wanted parity.\n\nThe second line contains $n$ integers $c_{1}, c_{2}, ..., c_{n}$ ($-1 \\leq c_{i} \\leq 1$) — the colors of the pieces.\n\n\n-----Output-----\n\nPrint a single integer — the number of ways to put the arrows and choose colors so the number of valid paths of alternating colors has the parity of $p$.\n\n\n-----Examples-----\nInput\n3 1\n-1 0 1\n\nOutput\n6\nInput\n2 1\n1 0\n\nOutput\n1\nInput\n1 1\n-1\n\nOutput\n2\n\n\n-----Note-----\n\nIn the first example, there are $6$ ways to color the pieces and add the arrows, as are shown in the figure below. The scores are $3, 3, 5$ for the first row and $5, 3, 3$ for the second row, both from left to right.\n\n [Image]",
        "generated_code": "def count_ways(n, p, colors):\n    MOD = 10**9 + 7\n    dp = [[[0]*(p+1) for _ in range(2)] for _ in range(n+1)]\n    dp[0][0][p] = 1\n    for i in range(n):\n        for j in range(2):\n            for k in range(p+1):\n                if colors[i] == -1:\n                    dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k]) % MOD\n                    dp[i+1][1-j][k] = (dp[i+1][1-j][k] + dp[i][j][k]) % MOD\n                elif colors[i] == j:\n                    dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k]) % MOD\n                else:\n                    dp[i+1][1-j][k] = (dp[i+1][1-j][k] + dp[i][j][1-k]) % MOD\n    return dp[n][0][p]\n\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\nprint(count_ways(n, p, colors))\n",
        "counter_example": {
            "input": "3 1\n-1 0 1\n",
            "expected": "6",
            "got": "0"
        }
    },
    {
        "task_id": "0137",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Kuro has recently won the \"Most intelligent cat ever\" contest. The three friends then decided to go to Katie's home to celebrate Kuro's winning. After a big meal, they took a small break then started playing games.\n\nKuro challenged Katie to create a game with only a white paper, a pencil, a pair of scissors and a lot of arrows (you can assume that the number of arrows is infinite). Immediately, Katie came up with the game called Topological Parity.\n\nThe paper is divided into $n$ pieces enumerated from $1$ to $n$. Shiro has painted some pieces with some color. Specifically, the $i$-th piece has color $c_{i}$ where $c_{i} = 0$ defines black color, $c_{i} = 1$ defines white color and $c_{i} = -1$ means that the piece hasn't been colored yet.\n\nThe rules of the game is simple. Players must put some arrows between some pairs of different pieces in such a way that for each arrow, the number in the piece it starts from is less than the number of the piece it ends at. Also, two different pieces can only be connected by at most one arrow. After that the players must choose the color ($0$ or $1$) for each of the unpainted pieces. The score of a valid way of putting the arrows and coloring pieces is defined as the number of paths of pieces of alternating colors. For example, $[1 \\to 0 \\to 1 \\to 0]$, $[0 \\to 1 \\to 0 \\to 1]$, $[1]$, $[0]$ are valid paths and will be counted. You can only travel from piece $x$ to piece $y$ if and only if there is an arrow from $x$ to $y$.\n\nBut Kuro is not fun yet. He loves parity. Let's call his favorite parity $p$ where $p = 0$ stands for \"even\" and $p = 1$ stands for \"odd\". He wants to put the arrows and choose colors in such a way that the score has the parity of $p$.\n\nIt seems like there will be so many ways which satisfy Kuro. He wants to count the number of them but this could be a very large number. Let's help him with his problem, but print it modulo $10^{9} + 7$.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $p$ ($1 \\leq n \\leq 50$, $0 \\leq p \\leq 1$) — the number of pieces and Kuro's wanted parity.\n\nThe second line contains $n$ integers $c_{1}, c_{2}, ..., c_{n}$ ($-1 \\leq c_{i} \\leq 1$) — the colors of the pieces.\n\n\n-----Output-----\n\nPrint a single integer — the number of ways to put the arrows and choose colors so the number of valid paths of alternating colors has the parity of $p$.\n\n\n-----Examples-----\nInput\n3 1\n-1 0 1\n\nOutput\n6\nInput\n2 1\n1 0\n\nOutput\n1\nInput\n1 1\n-1\n\nOutput\n2\n\n\n-----Note-----\n\nIn the first example, there are $6$ ways to color the pieces and add the arrows, as are shown in the figure below. The scores are $3, 3, 5$ for the first row and $5, 3, 3$ for the second row, both from left to right.\n\n [Image]",
        "generated_code": "MOD = 10**9 + 7\n\ndef count_ways(n, p, colors):\n    # Number of ways to color uncolored pieces\n    uncolored_count = colors.count(-1)\n    total_colorings = 2 ** uncolored_count\n    \n    # To store the number of ways to get even and odd valid paths\n    dp = [0, 0]\n    \n    # Calculate the parity of the number of valid paths\n    for mask in range(total_colorings):\n        new_colors = colors[:]\n        uncolored_index = 0\n        for i in range(n):\n            if new_colors[i] == -1:\n                new_colors[i] = (mask >> uncolored_index) & 1\n                uncolored_index += 1\n        \n        # Count valid paths\n        valid_paths = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if new_colors[i] != new_colors[j]:\n                    valid_paths += 1\n        \n        parity = valid_paths % 2\n        dp[parity] += 1\n    \n    return dp[p] % MOD\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = int(data[1])\ncolors = list(map(int, data[2:]))\n\n# Output result\nprint(count_ways(n, p, colors))\n",
        "counter_example": {
            "input": "3 1\n-1 0 1\n",
            "expected": "6",
            "got": "0"
        }
    },
    {
        "task_id": "0102",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Today Tavas got his test result as an integer score and he wants to share it with his girlfriend, Nafas.\n\nHis phone operating system is Tavdroid, and its keyboard doesn't have any digits! He wants to share his score with Nafas via text, so he has no choice but to send this number using words. [Image] \n\nHe ate coffee mix without water again, so right now he's really messed up and can't think.\n\nYour task is to help him by telling him what to type.\n\n\n-----Input-----\n\nThe first and only line of input contains an integer s (0 ≤ s ≤ 99), Tavas's score. \n\n\n-----Output-----\n\nIn the first and only line of output, print a single string consisting only from English lowercase letters and hyphens ('-'). Do not use spaces.\n\n\n-----Examples-----\nInput\n6\n\nOutput\nsix\n\nInput\n99\n\nOutput\nninety-nine\n\nInput\n20\n\nOutput\ntwenty\n\n\n\n-----Note-----\n\nYou can find all you need to know about English numerals in http://en.wikipedia.org/wiki/English_numerals .",
        "generated_code": "ones = ['', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\nteens = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']\ntens = ['', '', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']\n\ns = int(input())\nif s < 10:\n    print(ones[s])\nelif s < 20:\n    print(teens[s-10])\nelse:\n    print(tens[s//10] + ('' if s%10==0 else '-' + ones[s%10]))\n",
        "counter_example": {
            "input": "0\n",
            "expected": "zero\n",
            "got": ""
        }
    },
    {
        "task_id": "0102",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Today Tavas got his test result as an integer score and he wants to share it with his girlfriend, Nafas.\n\nHis phone operating system is Tavdroid, and its keyboard doesn't have any digits! He wants to share his score with Nafas via text, so he has no choice but to send this number using words. [Image] \n\nHe ate coffee mix without water again, so right now he's really messed up and can't think.\n\nYour task is to help him by telling him what to type.\n\n\n-----Input-----\n\nThe first and only line of input contains an integer s (0 ≤ s ≤ 99), Tavas's score. \n\n\n-----Output-----\n\nIn the first and only line of output, print a single string consisting only from English lowercase letters and hyphens ('-'). Do not use spaces.\n\n\n-----Examples-----\nInput\n6\n\nOutput\nsix\n\nInput\n99\n\nOutput\nninety-nine\n\nInput\n20\n\nOutput\ntwenty\n\n\n\n-----Note-----\n\nYou can find all you need to know about English numerals in http://en.wikipedia.org/wiki/English_numerals .",
        "generated_code": "def number_to_words(n):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= n <= 9:\n        return ones[n]\n    elif 11 <= n <= 19:\n        return teens[n - 10]\n    elif 10 <= n <= 99:\n        if n % 10 == 0:\n            return tens[n // 10]\n        else:\n            return tens[n // 10] + \"-\" + ones[n % 10]\n\nif __name__ == \"__main__\":\n    s = int(input())\n    print(number_to_words(s))\n",
        "counter_example": null
    }
]