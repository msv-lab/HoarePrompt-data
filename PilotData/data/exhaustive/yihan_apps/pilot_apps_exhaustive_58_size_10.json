[
    {
        "task_id": "0067",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Nauuo is a girl who loves writing comments.\n\nOne day, she posted a comment on Codeforces, wondering whether she would get upvotes or downvotes.\n\nIt's known that there were $x$ persons who would upvote, $y$ persons who would downvote, and there were also another $z$ persons who would vote, but you don't know whether they would upvote or downvote. Note that each of the $x+y+z$ people would vote exactly one time.\n\nThere are three different results: if there are more people upvote than downvote, the result will be \"+\"; if there are more people downvote than upvote, the result will be \"-\"; otherwise the result will be \"0\".\n\nBecause of the $z$ unknown persons, the result may be uncertain (i.e. there are more than one possible results). More formally, the result is uncertain if and only if there exist two different situations of how the $z$ persons vote, that the results are different in the two situations.\n\nTell Nauuo the result or report that the result is uncertain.\n\n\n-----Input-----\n\nThe only line contains three integers $x$, $y$, $z$ ($0\\le x,y,z\\le100$), corresponding to the number of persons who would upvote, downvote or unknown.\n\n\n-----Output-----\n\nIf there is only one possible result, print the result : \"+\", \"-\" or \"0\".\n\nOtherwise, print \"?\" to report that the result is uncertain.\n\n\n-----Examples-----\nInput\n3 7 0\n\nOutput\n-\nInput\n2 0 1\n\nOutput\n+\nInput\n1 1 0\n\nOutput\n0\nInput\n0 0 1\n\nOutput\n?\n\n\n-----Note-----\n\nIn the first example, Nauuo would definitely get three upvotes and seven downvotes, so the only possible result is \"-\".\n\nIn the second example, no matter the person unknown downvotes or upvotes, Nauuo would get more upvotes than downvotes. So the only possible result is \"+\".\n\nIn the third example, Nauuo would definitely get one upvote and one downvote, so the only possible result is \"0\".\n\nIn the fourth example, if the only one person upvoted, the result would be \"+\", otherwise, the result would be \"-\". There are two possible results, so the result is uncertain.",
        "generated_code": "x, y, z = map(int, input().split())\nif x > y + z:\n    print(\"+\")\nelif x < y:\n    print(\"-\")\nelif x == y:\n    if z == 0:\n        print(\"0\")\n    else:\n        print(\"?\")\nelse:\n    print(\"?\")\n",
        "counter_example": {
            "input": "22 99 77\n",
            "expected": "?",
            "got": "-"
        }
    },
    {
        "task_id": "0067",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Nauuo is a girl who loves writing comments.\n\nOne day, she posted a comment on Codeforces, wondering whether she would get upvotes or downvotes.\n\nIt's known that there were $x$ persons who would upvote, $y$ persons who would downvote, and there were also another $z$ persons who would vote, but you don't know whether they would upvote or downvote. Note that each of the $x+y+z$ people would vote exactly one time.\n\nThere are three different results: if there are more people upvote than downvote, the result will be \"+\"; if there are more people downvote than upvote, the result will be \"-\"; otherwise the result will be \"0\".\n\nBecause of the $z$ unknown persons, the result may be uncertain (i.e. there are more than one possible results). More formally, the result is uncertain if and only if there exist two different situations of how the $z$ persons vote, that the results are different in the two situations.\n\nTell Nauuo the result or report that the result is uncertain.\n\n\n-----Input-----\n\nThe only line contains three integers $x$, $y$, $z$ ($0\\le x,y,z\\le100$), corresponding to the number of persons who would upvote, downvote or unknown.\n\n\n-----Output-----\n\nIf there is only one possible result, print the result : \"+\", \"-\" or \"0\".\n\nOtherwise, print \"?\" to report that the result is uncertain.\n\n\n-----Examples-----\nInput\n3 7 0\n\nOutput\n-\nInput\n2 0 1\n\nOutput\n+\nInput\n1 1 0\n\nOutput\n0\nInput\n0 0 1\n\nOutput\n?\n\n\n-----Note-----\n\nIn the first example, Nauuo would definitely get three upvotes and seven downvotes, so the only possible result is \"-\".\n\nIn the second example, no matter the person unknown downvotes or upvotes, Nauuo would get more upvotes than downvotes. So the only possible result is \"+\".\n\nIn the third example, Nauuo would definitely get one upvote and one downvote, so the only possible result is \"0\".\n\nIn the fourth example, if the only one person upvoted, the result would be \"+\", otherwise, the result would be \"-\". There are two possible results, so the result is uncertain.",
        "generated_code": "x, y, z = map(int, input().split())\n\n# Calculate the minimum and maximum possible upvotes\nmin_upvotes = x\nmax_upvotes = x + z\n\n# Calculate the minimum and maximum possible downvotes\nmin_downvotes = y\nmax_downvotes = y + z\n\nif max_upvotes < min_downvotes:\n    print(\"-\")\nelif max_downvotes < min_upvotes:\n    print(\"+\")\nelse:\n    print(\"?\")\n",
        "counter_example": {
            "input": "1 1 0\n",
            "expected": "0",
            "got": "?"
        }
    },
    {
        "task_id": "0234",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": true,
        "description": "One day Alex decided to remember childhood when computers were not too powerful and lots of people played only default games. Alex enjoyed playing Minesweeper that time. He imagined that he saved world from bombs planted by terrorists, but he rarely won.\n\nAlex has grown up since then, so he easily wins the most difficult levels. This quickly bored him, and he thought: what if the computer gave him invalid fields in the childhood and Alex could not win because of it?\n\nHe needs your help to check it.\n\nA Minesweeper field is a rectangle $n \\times m$, where each cell is either empty, or contains a digit from $1$ to $8$, or a bomb. The field is valid if for each cell:   if there is a digit $k$ in the cell, then exactly $k$ neighboring cells have bombs.  if the cell is empty, then all neighboring cells have no bombs. \n\nTwo cells are neighbors if they have a common side or a corner (i. e. a cell has at most $8$ neighboring cells).\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 100$) — the sizes of the field.\n\nThe next $n$ lines contain the description of the field. Each line contains $m$ characters, each of them is \".\" (if this cell is empty), \"*\" (if there is bomb in this cell), or a digit from $1$ to $8$, inclusive.\n\n\n-----Output-----\n\nPrint \"YES\", if the field is valid and \"NO\" otherwise.\n\nYou can choose the case (lower or upper) for each letter arbitrarily.\n\n\n-----Examples-----\nInput\n3 3\n111\n1*1\n111\n\nOutput\nYES\nInput\n2 4\n*.*.\n1211\n\nOutput\nNO\n\n\n-----Note-----\n\nIn the second example the answer is \"NO\" because, if the positions of the bombs are preserved, the first line of the field should be *2*1.\n\nYou can read more about Minesweeper in Wikipedia's article.",
        "generated_code": "n, m = map(int, input().split())\nfield = [list(input()) for _ in range(n)]\n\ndef count_bombs(i, j):\n    bombs = 0\n    for x in range(max(0, i-1), min(n, i+2)):\n        for y in range(max(0, j-1), min(m, j+2)):\n            if (x, y) != (i, j) and field[x][y] == '*':\n                bombs += 1\n    return bombs\n\nfor i in range(n):\n    for j in range(m):\n        if field[i][j].isdigit():\n            if int(field[i][j]) != count_bombs(i, j):\n                print(\"NO\")\n                exit()\n        elif field[i][j] == '.':\n            if count_bombs(i, j) > 0:\n                print(\"NO\")\n                exit()\n\nprint(\"YES\")\n",
        "counter_example": null
    },
    {
        "task_id": "0234",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "One day Alex decided to remember childhood when computers were not too powerful and lots of people played only default games. Alex enjoyed playing Minesweeper that time. He imagined that he saved world from bombs planted by terrorists, but he rarely won.\n\nAlex has grown up since then, so he easily wins the most difficult levels. This quickly bored him, and he thought: what if the computer gave him invalid fields in the childhood and Alex could not win because of it?\n\nHe needs your help to check it.\n\nA Minesweeper field is a rectangle $n \\times m$, where each cell is either empty, or contains a digit from $1$ to $8$, or a bomb. The field is valid if for each cell:   if there is a digit $k$ in the cell, then exactly $k$ neighboring cells have bombs.  if the cell is empty, then all neighboring cells have no bombs. \n\nTwo cells are neighbors if they have a common side or a corner (i. e. a cell has at most $8$ neighboring cells).\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 100$) — the sizes of the field.\n\nThe next $n$ lines contain the description of the field. Each line contains $m$ characters, each of them is \".\" (if this cell is empty), \"*\" (if there is bomb in this cell), or a digit from $1$ to $8$, inclusive.\n\n\n-----Output-----\n\nPrint \"YES\", if the field is valid and \"NO\" otherwise.\n\nYou can choose the case (lower or upper) for each letter arbitrarily.\n\n\n-----Examples-----\nInput\n3 3\n111\n1*1\n111\n\nOutput\nYES\nInput\n2 4\n*.*.\n1211\n\nOutput\nNO\n\n\n-----Note-----\n\nIn the second example the answer is \"NO\" because, if the positions of the bombs are preserved, the first line of the field should be *2*1.\n\nYou can read more about Minesweeper in Wikipedia's article.",
        "generated_code": "def is_valid_minesweeper_field(n, m, field):\n    def count_bombs_around(x, y):\n        bomb_count = 0\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                if dx == 0 and dy == 0:\n                    continue\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == '*':\n                    bomb_count += 1\n        return bomb_count\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '.':\n                if count_bombs_around(i, j) != 0:\n                    return \"NO\"\n            elif field[i][j] == '*':\n                continue\n            else:\n                expected_bombs = int(field[i][j])\n                actual_bombs = count_bombs_around(i, j)\n                if expected_bombs != actual_bombs:\n                    return \"NO\"\n    return \"YES\"\n\n# Reading input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Checking the validity of the Minesweeper field\nresult = is_valid_minesweeper_field(n, m, field)\nprint(result)\n",
        "counter_example": null
    },
    {
        "task_id": "0257",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Takahashi wants to grill N pieces of meat on a grilling net, which can be seen as a two-dimensional plane. The coordinates of the i-th piece of meat are \\left(x_i, y_i\\right), and its hardness is c_i.\nTakahashi can use one heat source to grill the meat. If he puts the heat source at coordinates \\left(X, Y\\right), where X and Y are real numbers, the i-th piece of meat will be ready to eat in c_i \\times \\sqrt{\\left(X - x_i\\right)^2 + \\left(Y-y_i\\right)^2} seconds.\nTakahashi wants to eat K pieces of meat. Find the time required to have K or more pieces of meat ready if he put the heat source to minimize this time.\n\n-----Constraints-----\n - All values in input are integers.\n - 1 \\leq N \\leq 60\n - 1 \\leq K \\leq N\n - -1000 \\leq x_i , y_i \\leq 1000\n - \\left(x_i, y_i\\right) \\neq \\left(x_j, y_j\\right) \\left(i \\neq j \\right)\n - 1 \\leq c_i \\leq 100\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN K\nx_1 y_1 c_1\n\\vdots\nx_N y_N c_N\n\n-----Output-----\nPrint the answer.\nIt will be considered correct if its absolute or relative error from our answer is at most 10^{-6}.\n\n-----Sample Input-----\n4 3\n-1 0 3\n0 0 3\n1 0 2\n1 1 40\n\n-----Sample Output-----\n2.4\n\nIf we put the heat source at \\left(-0.2, 0\\right), the 1-st, 2-nd, and 3-rd pieces of meat will be ready to eat within 2.4 seconds. This is the optimal place to put the heat source.",
        "generated_code": "import math\n\nN, K = map(int, input().split())\nmeats = []\nfor _ in range(N):\n    x, y, c = map(int, input().split())\n    meats.append((x, y, c))\n\ndef distance(x, y, X, Y):\n    return math.sqrt((X - x) ** 2 + (Y - y) ** 2)\n\ndef time_to_ready(x, y, X, Y):\n    return [c * distance(x, y, X, Y) for x, y, c in meats]\n\ndef solve():\n    ans = float('inf')\n    for x in range(-1000, 1001):\n        for y in range(-1000, 1001):\n            times = time_to_ready(x, y, x, y)\n            times.sort()\n            ans = min(ans, times[K - 1])\n    return ans\n\nprint(solve())\n",
        "counter_example": {
            "input": "4 3\n-1 0 3\n0 0 3\n1 0 2\n1 1 40\n",
            "expected": "2.4\n",
            "got": "TimeoutError: Execution exceeded time limit"
        }
    },
    {
        "task_id": "0257",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Takahashi wants to grill N pieces of meat on a grilling net, which can be seen as a two-dimensional plane. The coordinates of the i-th piece of meat are \\left(x_i, y_i\\right), and its hardness is c_i.\nTakahashi can use one heat source to grill the meat. If he puts the heat source at coordinates \\left(X, Y\\right), where X and Y are real numbers, the i-th piece of meat will be ready to eat in c_i \\times \\sqrt{\\left(X - x_i\\right)^2 + \\left(Y-y_i\\right)^2} seconds.\nTakahashi wants to eat K pieces of meat. Find the time required to have K or more pieces of meat ready if he put the heat source to minimize this time.\n\n-----Constraints-----\n - All values in input are integers.\n - 1 \\leq N \\leq 60\n - 1 \\leq K \\leq N\n - -1000 \\leq x_i , y_i \\leq 1000\n - \\left(x_i, y_i\\right) \\neq \\left(x_j, y_j\\right) \\left(i \\neq j \\right)\n - 1 \\leq c_i \\leq 100\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN K\nx_1 y_1 c_1\n\\vdots\nx_N y_N c_N\n\n-----Output-----\nPrint the answer.\nIt will be considered correct if its absolute or relative error from our answer is at most 10^{-6}.\n\n-----Sample Input-----\n4 3\n-1 0 3\n0 0 3\n1 0 2\n1 1 40\n\n-----Sample Output-----\n2.4\n\nIf we put the heat source at \\left(-0.2, 0\\right), the 1-st, 2-nd, and 3-rd pieces of meat will be ready to eat within 2.4 seconds. This is the optimal place to put the heat source.",
        "generated_code": "import math\nimport sys\ninput = sys.stdin.read\n\ndef is_feasible(meats, K, T):\n    N = len(meats)\n    for i in range(N):\n        for j in range(i + 1, N):\n            x1, y1, c1 = meats[i]\n            x2, y2, c2 = meats[j]\n            if c1 * T < c2 * T:\n                x1, y1, c1, x2, y2, c2 = x2, y2, c2, x1, y1, c1\n            d = c1 * T - c2 * T\n            if d < 0:\n                continue\n            d /= c1 * c2\n            cx = (x1 + x2) / 2\n            cy = (y1 + y2) / 2\n            dx = (x1 - x2) / 2\n            dy = (y1 - y2) / 2\n            d2 = dx * dx + dy * dy\n            if d * d2 > d2:\n                continue\n            mx = cx + dy * math.sqrt(d2 * d - d * d) / d2\n            my = cy - dx * math.sqrt(d2 * d - d * d) / d2\n            count = sum(c * math.sqrt((mx - x) ** 2 + (my - y) ** 2) <= T for x, y, c in meats)\n            if count >= K:\n                return True\n    return False\n\ndef min_time_to_grill(N, K, meats):\n    low, high = 0, 1e9\n    while high - low > 1e-7:\n        mid = (low + high) / 2\n        if is_feasible(meats, K, mid):\n            high = mid\n        else:\n            low = mid\n    return high\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    meats = []\n    index = 2\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        c = int(data[index + 2])\n        meats.append((x, y, c))\n        index += 3\n    result = min_time_to_grill(N, K, meats)\n    print(f\"{result:.6f}\")\n\nif __name__ == \"__main__\":\n    main()\n",
        "counter_example": {
            "input": "4 3\n-1 0 3\n0 0 3\n1 0 2\n1 1 40\n",
            "expected": "2.4\n",
            "got": "Traceback (most recent call last):\n  File \"<string>\", line 57, in <module>\n  File \"<string>\", line 53, in main\n  File \"<string>\", line 35, in min_time_to_grill\n  File \"<string>\", line 24, in is_feasible\nValueError: math domain error"
        }
    },
    {
        "task_id": "0024",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Alice and Bob play 5-in-a-row game. They have a playing field of size 10 × 10. In turns they put either crosses or noughts, one at a time. Alice puts crosses and Bob puts noughts.\n\nIn current match they have made some turns and now it's Alice's turn. She wonders if she can put cross in such empty cell that she wins immediately.\n\nAlice wins if some crosses in the field form line of length not smaller than 5. This line can be horizontal, vertical and diagonal.\n\n\n-----Input-----\n\nYou are given matrix 10 × 10 (10 lines of 10 characters each) with capital Latin letters 'X' being a cross, letters 'O' being a nought and '.' being an empty cell. The number of 'X' cells is equal to the number of 'O' cells and there is at least one of each type. There is at least one empty cell.\n\nIt is guaranteed that in the current arrangement nobody has still won.\n\n\n-----Output-----\n\nPrint 'YES' if it's possible for Alice to win in one turn by putting cross in some empty cell. Otherwise print 'NO'.\n\n\n-----Examples-----\nInput\nXX.XX.....\n.....OOOO.\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n\nOutput\nYES\n\nInput\nXXOXX.....\nOO.O......\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n\nOutput\nNO",
        "generated_code": "def can_win(matrix):\n    # Check horizontal lines\n    for i in range(10):\n        count = 0\n        for j in range(10):\n            if matrix[i][j] == 'X':\n                count += 1\n            elif matrix[i][j] == '.':\n                if count >= 4:\n                    return True\n                count = 0\n            else:\n                count = 0\n        if count >= 4:\n            return True\n\n    # Check vertical lines\n    for j in range(10):\n        count = 0\n        for i in range(10):\n            if matrix[i][j] == 'X':\n                count += 1\n            elif matrix[i][j] == '.':\n                if count >= 4:\n                    return True\n                count = 0\n            else:\n                count = 0\n        if count >= 4:\n            return True\n\n    # Check diagonal lines (top-left to bottom-right)\n    for k in range(-9, 10):\n        count = 0\n        for i in range(10):\n            j = i + k\n            if j >= 0 and j < 10:\n                if matrix[i][j] == 'X':\n                    count += 1\n                elif matrix[i][j] == '.':\n                    if count >= 4:\n                        return True\n                    count = 0\n                else:\n                    count = 0\n        if count >= 4:\n            return True\n\n    # Check diagonal lines (bottom-left to top-right)\n    for k in range(-9, 10):\n        count = 0\n        for i in range(10):\n            j = 9 - i + k\n            if j >= 0 and j < 10:\n                if matrix[i][j] == 'X':\n                    count += 1\n                elif matrix[i][j] == '.':\n                    if count >= 4:\n                        return True\n                    count = 0\n                else:\n                    count = 0\n        if count >= 4:\n            return True\n\n    return False\n\nmatrix = [input() for _ in range(10)]\nprint('YES' if can_win(matrix) else 'NO')\n",
        "counter_example": {
            "input": "XX.XX.....\n.....OOOO.\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n",
            "expected": "YES\n",
            "got": "NO"
        }
    },
    {
        "task_id": "0024",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Alice and Bob play 5-in-a-row game. They have a playing field of size 10 × 10. In turns they put either crosses or noughts, one at a time. Alice puts crosses and Bob puts noughts.\n\nIn current match they have made some turns and now it's Alice's turn. She wonders if she can put cross in such empty cell that she wins immediately.\n\nAlice wins if some crosses in the field form line of length not smaller than 5. This line can be horizontal, vertical and diagonal.\n\n\n-----Input-----\n\nYou are given matrix 10 × 10 (10 lines of 10 characters each) with capital Latin letters 'X' being a cross, letters 'O' being a nought and '.' being an empty cell. The number of 'X' cells is equal to the number of 'O' cells and there is at least one of each type. There is at least one empty cell.\n\nIt is guaranteed that in the current arrangement nobody has still won.\n\n\n-----Output-----\n\nPrint 'YES' if it's possible for Alice to win in one turn by putting cross in some empty cell. Otherwise print 'NO'.\n\n\n-----Examples-----\nInput\nXX.XX.....\n.....OOOO.\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n\nOutput\nYES\n\nInput\nXXOXX.....\nOO.O......\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n\nOutput\nNO",
        "generated_code": "def check_win(board, x, y):\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (1, 1), (-1, 1), (1, -1)]\n    \n    for dx, dy in directions:\n        count = 1  # Start with the placement at (x, y)\n        for step in range(1, 5):\n            nx, ny = x + step * dx, y + step * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        \n        for step in range(1, 5):\n            nx, ny = x - step * dx, y - step * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        \n        if count >= 5:\n            return True\n    \n    return False\n\ndef can_alice_win(board):\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                if check_win(board, i, j):\n                    return \"YES\"\n    return \"NO\"\n\n# Reading input\nboard = []\nfor _ in range(10):\n    board.append(input().strip())\n\n# Checking if Alice can win\nprint(can_alice_win(board))\n",
        "counter_example": null
    },
    {
        "task_id": "0215",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Polycarp loves lowercase letters and dislikes uppercase ones. Once he got a string s consisting only of lowercase and uppercase Latin letters.\n\nLet A be a set of positions in the string. Let's call it pretty if following conditions are met:  letters on positions from A in the string are all distinct and lowercase;  there are no uppercase letters in the string which are situated between positions from A (i.e. there is no such j that s[j] is an uppercase letter, and a_1 < j < a_2 for some a_1 and a_2 from A). \n\nWrite a program that will determine the maximum number of elements in a pretty set of positions.\n\n\n-----Input-----\n\nThe first line contains a single integer n (1 ≤ n ≤ 200) — length of string s.\n\nThe second line contains a string s consisting of lowercase and uppercase Latin letters.\n\n\n-----Output-----\n\nPrint maximum number of elements in pretty set of positions for string s.\n\n\n-----Examples-----\nInput\n11\naaaaBaabAbA\n\nOutput\n2\n\nInput\n12\nzACaAbbaazzC\n\nOutput\n3\n\nInput\n3\nABC\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example the desired positions might be 6 and 8 or 7 and 8. Positions 6 and 7 contain letters 'a', position 8 contains letter 'b'. The pair of positions 1 and 8 is not suitable because there is an uppercase letter 'B' between these position.\n\nIn the second example desired positions can be 7, 8 and 11. There are other ways to choose pretty set consisting of three elements.\n\nIn the third example the given string s does not contain any lowercase letters, so the answer is 0.",
        "generated_code": "n = int(input())\ns = input()\nlowercase = [i for i, c in enumerate(s) if c.islower()]\nprint(len(lowercase))\n",
        "counter_example": {
            "input": "11\naaaaBaabAbA\n",
            "expected": "2\n",
            "got": "8"
        }
    },
    {
        "task_id": "0215",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Polycarp loves lowercase letters and dislikes uppercase ones. Once he got a string s consisting only of lowercase and uppercase Latin letters.\n\nLet A be a set of positions in the string. Let's call it pretty if following conditions are met:  letters on positions from A in the string are all distinct and lowercase;  there are no uppercase letters in the string which are situated between positions from A (i.e. there is no such j that s[j] is an uppercase letter, and a_1 < j < a_2 for some a_1 and a_2 from A). \n\nWrite a program that will determine the maximum number of elements in a pretty set of positions.\n\n\n-----Input-----\n\nThe first line contains a single integer n (1 ≤ n ≤ 200) — length of string s.\n\nThe second line contains a string s consisting of lowercase and uppercase Latin letters.\n\n\n-----Output-----\n\nPrint maximum number of elements in pretty set of positions for string s.\n\n\n-----Examples-----\nInput\n11\naaaaBaabAbA\n\nOutput\n2\n\nInput\n12\nzACaAbbaazzC\n\nOutput\n3\n\nInput\n3\nABC\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example the desired positions might be 6 and 8 or 7 and 8. Positions 6 and 7 contain letters 'a', position 8 contains letter 'b'. The pair of positions 1 and 8 is not suitable because there is an uppercase letter 'B' between these position.\n\nIn the second example desired positions can be 7, 8 and 11. There are other ways to choose pretty set consisting of three elements.\n\nIn the third example the given string s does not contain any lowercase letters, so the answer is 0.",
        "generated_code": "n = int(input())\ns = input()\n\nmax_count = 0\ncurrent_set = set()\ncurrent_count = 0\n\nfor char in s:\n    if char.islower():\n        if char not in current_set:\n            current_set.add(char)\n            current_count += 1\n    else:\n        max_count = max(max_count, current_count)\n        current_set.clear()\n        current_count = 0\n\n# Check the count after the last segment\nmax_count = max(max_count, current_count)\n\nprint(max_count)\n",
        "counter_example": null
    }
]