[
    {
        "task_id": "0022",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Let's call a string \"s-palindrome\" if it is symmetric about the middle of the string. For example, the string \"oHo\" is \"s-palindrome\", but the string \"aa\" is not. The string \"aa\" is not \"s-palindrome\", because the second half of it is not a mirror reflection of the first half.\n\n [Image] English alphabet \n\nYou are given a string s. Check if the string is \"s-palindrome\".\n\n\n-----Input-----\n\nThe only line contains the string s (1 ≤ |s| ≤ 1000) which consists of only English letters.\n\n\n-----Output-----\n\nPrint \"TAK\" if the string s is \"s-palindrome\" and \"NIE\" otherwise.\n\n\n-----Examples-----\nInput\noXoxoXo\n\nOutput\nTAK\n\nInput\nbod\n\nOutput\nTAK\n\nInput\nER\n\nOutput\nNIE",
        "generated_code": "s = input()\nn = len(s)\nis_spalindrome = True\nfor i in range(n // 2):\n    if s[i] != s[n - i - 1]:\n        is_spalindrome = False\n        break\nprint(\"TAK\" if is_spalindrome else \"NIE\")\n",
        "counter_example": {
            "input": "bod\n",
            "expected": "TAK\n",
            "got": "NIE"
        }
    },
    {
        "task_id": "0022",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Let's call a string \"s-palindrome\" if it is symmetric about the middle of the string. For example, the string \"oHo\" is \"s-palindrome\", but the string \"aa\" is not. The string \"aa\" is not \"s-palindrome\", because the second half of it is not a mirror reflection of the first half.\n\n [Image] English alphabet \n\nYou are given a string s. Check if the string is \"s-palindrome\".\n\n\n-----Input-----\n\nThe only line contains the string s (1 ≤ |s| ≤ 1000) which consists of only English letters.\n\n\n-----Output-----\n\nPrint \"TAK\" if the string s is \"s-palindrome\" and \"NIE\" otherwise.\n\n\n-----Examples-----\nInput\noXoxoXo\n\nOutput\nTAK\n\nInput\nbod\n\nOutput\nTAK\n\nInput\nER\n\nOutput\nNIE",
        "generated_code": "def is_s_palindrome(s):\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            return False\n    return True\n\n# Read input\ns = input().strip()\n\n# Check if the string is \"s-palindrome\"\nif is_s_palindrome(s):\n    print(\"TAK\")\nelse:\n    print(\"NIE\")\n",
        "counter_example": {
            "input": "bod\n",
            "expected": "TAK\n",
            "got": "NIE"
        }
    },
    {
        "task_id": "0072",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "After the big birthday party, Katie still wanted Shiro to have some more fun. Later, she came up with a game called treasure hunt. Of course, she invited her best friends Kuro and Shiro to play with her.\n\nThe three friends are very smart so they passed all the challenges very quickly and finally reached the destination. But the treasure can only belong to one cat so they started to think of something which can determine who is worthy of the treasure. Instantly, Kuro came up with some ribbons.\n\nA random colorful ribbon is given to each of the cats. Each color of the ribbon can be represented as an uppercase or lowercase Latin letter. Let's call a consecutive subsequence of colors that appears in the ribbon a subribbon. The beauty of a ribbon is defined as the maximum number of times one of its subribbon appears in the ribbon. The more the subribbon appears, the more beautiful is the ribbon. For example, the ribbon aaaaaaa has the beauty of $7$ because its subribbon a appears $7$ times, and the ribbon abcdabc has the beauty of $2$ because its subribbon abc appears twice.\n\nThe rules are simple. The game will have $n$ turns. Every turn, each of the cats must change strictly one color (at one position) in his/her ribbon to an arbitrary color which is different from the unchanged one. For example, a ribbon aaab can be changed into acab in one turn. The one having the most beautiful ribbon after $n$ turns wins the treasure.\n\nCould you find out who is going to be the winner if they all play optimally?\n\n\n-----Input-----\n\nThe first line contains an integer $n$ ($0 \\leq n \\leq 10^{9}$) — the number of turns.\n\nNext 3 lines contain 3 ribbons of Kuro, Shiro and Katie one per line, respectively. Each ribbon is a string which contains no more than $10^{5}$ uppercase and lowercase Latin letters and is not empty. It is guaranteed that the length of all ribbons are equal for the purpose of fairness. Note that uppercase and lowercase letters are considered different colors.\n\n\n-----Output-----\n\nPrint the name of the winner (\"Kuro\", \"Shiro\" or \"Katie\"). If there are at least two cats that share the maximum beauty, print \"Draw\".\n\n\n-----Examples-----\nInput\n3\nKuroo\nShiro\nKatie\n\nOutput\nKuro\n\nInput\n7\ntreasurehunt\nthreefriends\nhiCodeforces\n\nOutput\nShiro\n\nInput\n1\nabcabc\ncbabac\nababca\n\nOutput\nKatie\n\nInput\n15\nfoPaErcvJ\nmZaxowpbt\nmkuOlaHRE\n\nOutput\nDraw\n\n\n\n-----Note-----\n\nIn the first example, after $3$ turns, Kuro can change his ribbon into ooooo, which has the beauty of $5$, while reaching such beauty for Shiro and Katie is impossible (both Shiro and Katie can reach the beauty of at most $4$, for example by changing Shiro's ribbon into SSiSS and changing Katie's ribbon into Kaaaa). Therefore, the winner is Kuro.\n\nIn the fourth example, since the length of each of the string is $9$ and the number of turn is $15$, everyone can change their ribbons in some way to reach the maximal beauty of $9$ by changing their strings into zzzzzzzzz after 9 turns, and repeatedly change their strings into azzzzzzzz and then into zzzzzzzzz thrice. Therefore, the game ends in a draw.",
        "generated_code": "n = int(input())\nkuro = input()\nshiro = input()\nkatie = input()\n\ndef max_beauty(s, n):\n    max_len = len(s)\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            sub = s[i:j]\n            beauty = s.count(sub)\n            if beauty > max_len:\n                max_len = beauty\n    return max_len\n\nkuro_beauty = max_beauty(kuro, n)\nshiro_beauty = max_beauty(shiro, n)\nkatie_beauty = max_beauty(katie, n)\n\nmax_beauty = max(kuro_beauty, shiro_beauty, katie_beauty)\n\nif kuro_beauty == max_beauty and shiro_beauty != max_beauty and katie_beauty != max_beauty:\n    print(\"Kuro\")\nelif shiro_beauty == max_beauty and kuro_beauty != max_beauty and katie_beauty != max_beauty:\n    print(\"Shiro\")\nelif katie_beauty == max_beauty and kuro_beauty != max_beauty and shiro_beauty != max_beauty:\n    print(\"Katie\")\nelse:\n    print(\"Draw\")\n",
        "counter_example": {
            "input": "3\nKuroo\nShiro\nKatie\n",
            "expected": "Kuro\n",
            "got": "Draw"
        }
    },
    {
        "task_id": "0072",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "After the big birthday party, Katie still wanted Shiro to have some more fun. Later, she came up with a game called treasure hunt. Of course, she invited her best friends Kuro and Shiro to play with her.\n\nThe three friends are very smart so they passed all the challenges very quickly and finally reached the destination. But the treasure can only belong to one cat so they started to think of something which can determine who is worthy of the treasure. Instantly, Kuro came up with some ribbons.\n\nA random colorful ribbon is given to each of the cats. Each color of the ribbon can be represented as an uppercase or lowercase Latin letter. Let's call a consecutive subsequence of colors that appears in the ribbon a subribbon. The beauty of a ribbon is defined as the maximum number of times one of its subribbon appears in the ribbon. The more the subribbon appears, the more beautiful is the ribbon. For example, the ribbon aaaaaaa has the beauty of $7$ because its subribbon a appears $7$ times, and the ribbon abcdabc has the beauty of $2$ because its subribbon abc appears twice.\n\nThe rules are simple. The game will have $n$ turns. Every turn, each of the cats must change strictly one color (at one position) in his/her ribbon to an arbitrary color which is different from the unchanged one. For example, a ribbon aaab can be changed into acab in one turn. The one having the most beautiful ribbon after $n$ turns wins the treasure.\n\nCould you find out who is going to be the winner if they all play optimally?\n\n\n-----Input-----\n\nThe first line contains an integer $n$ ($0 \\leq n \\leq 10^{9}$) — the number of turns.\n\nNext 3 lines contain 3 ribbons of Kuro, Shiro and Katie one per line, respectively. Each ribbon is a string which contains no more than $10^{5}$ uppercase and lowercase Latin letters and is not empty. It is guaranteed that the length of all ribbons are equal for the purpose of fairness. Note that uppercase and lowercase letters are considered different colors.\n\n\n-----Output-----\n\nPrint the name of the winner (\"Kuro\", \"Shiro\" or \"Katie\"). If there are at least two cats that share the maximum beauty, print \"Draw\".\n\n\n-----Examples-----\nInput\n3\nKuroo\nShiro\nKatie\n\nOutput\nKuro\n\nInput\n7\ntreasurehunt\nthreefriends\nhiCodeforces\n\nOutput\nShiro\n\nInput\n1\nabcabc\ncbabac\nababca\n\nOutput\nKatie\n\nInput\n15\nfoPaErcvJ\nmZaxowpbt\nmkuOlaHRE\n\nOutput\nDraw\n\n\n\n-----Note-----\n\nIn the first example, after $3$ turns, Kuro can change his ribbon into ooooo, which has the beauty of $5$, while reaching such beauty for Shiro and Katie is impossible (both Shiro and Katie can reach the beauty of at most $4$, for example by changing Shiro's ribbon into SSiSS and changing Katie's ribbon into Kaaaa). Therefore, the winner is Kuro.\n\nIn the fourth example, since the length of each of the string is $9$ and the number of turn is $15$, everyone can change their ribbons in some way to reach the maximal beauty of $9$ by changing their strings into zzzzzzzzz after 9 turns, and repeatedly change their strings into azzzzzzzz and then into zzzzzzzzz thrice. Therefore, the game ends in a draw.",
        "generated_code": "def calculate_max_beauty(ribbon, n):\n    from collections import Counter\n\n    # Count the frequency of each character in the ribbon\n    freq = Counter(ribbon)\n    \n    # Find the maximum frequency of any character in the ribbon\n    max_freq = max(freq.values())\n    \n    # If the length of the ribbon is more than the maximum frequency plus n changes,\n    # we can make all characters the same\n    if len(ribbon) == max_freq and n == 1:\n        return max_freq - 1\n    else:\n        return min(len(ribbon), max_freq + n)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    ribbons = data[1:]\n    \n    kuro_ribbon = ribbons[0]\n    shiro_ribbon = ribbons[1]\n    katie_ribbon = ribbons[2]\n    \n    # Calculate the maximum beauty for each ribbon\n    kuro_beauty = calculate_max_beauty(kuro_ribbon, n)\n    shiro_beauty = calculate_max_beauty(shiro_ribbon, n)\n    katie_beauty = calculate_max_beauty(katie_ribbon, n)\n    \n    # Determine the winner\n    beauties = [kuro_beauty, shiro_beauty, katie_beauty]\n    max_beauty = max(beauties)\n    \n    if beauties.count(max_beauty) > 1:\n        print(\"Draw\")\n    else:\n        if max_beauty == kuro_beauty:\n            print(\"Kuro\")\n        elif max_beauty == shiro_beauty:\n            print(\"Shiro\")\n        else:\n            print(\"Katie\")\n\nif __name__ == \"__main__\":\n    main()\n",
        "counter_example": null
    },
    {
        "task_id": "0151",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Beroffice text editor has a wide range of features that help working with text. One of the features is an automatic search for typos and suggestions of how to fix them.\n\nBeroffice works only with small English letters (i.e. with 26 letters from a to z). Beroffice thinks that a word is typed with a typo if there are three or more consonants in a row in the word. The only exception is that if the block of consonants has all letters the same, then this block (even if its length is greater than three) is not considered a typo. Formally, a word is typed with a typo if there is a block of not less that three consonants in a row, and there are at least two different letters in this block.\n\nFor example:\n\n  the following words have typos: \"hellno\", \"hackcerrs\" and \"backtothefutttture\";  the following words don't have typos: \"helllllooooo\", \"tobeornottobe\" and \"oooooo\". \n\nWhen Beroffice editor finds a word with a typo, it inserts as little as possible number of spaces in this word (dividing it into several words) in such a way that each of the resulting words is typed without any typos.\n\nImplement this feature of Beroffice editor. Consider the following letters as the only vowels: 'a', 'e', 'i', 'o' and 'u'. All the other letters are consonants in this problem.\n\n\n-----Input-----\n\nThe only line contains a non-empty word consisting of small English letters. The length of the word is between 1 and 3000 letters.\n\n\n-----Output-----\n\nPrint the given word without any changes if there are no typos.\n\nIf there is at least one typo in the word, insert the minimum number of spaces into the word so that each of the resulting words doesn't have any typos. If there are multiple solutions, print any of them.\n\n\n-----Examples-----\nInput\nhellno\n\nOutput\nhell no \n\nInput\nabacaba\n\nOutput\nabacaba \n\nInput\nasdfasdf\n\nOutput\nasd fasd f",
        "generated_code": "s = input()\nvowels = set('aeiou')\nans = []\ntmp = []\nfor c in s:\n    if c in vowels or (tmp and tmp[-1] == c):\n        tmp.append(c)\n    else:\n        if len(tmp) >= 3 and len(set(tmp)) > 1:\n            ans.append(' '.join(tmp[:-3]))\n            tmp = tmp[-3:]\n        else:\n            ans.append(''.join(tmp))\n            tmp = [c]\nans.append(''.join(tmp))\nprint(' '.join(ans))\n",
        "counter_example": {
            "input": "hellno\n",
            "expected": "hell no \n",
            "got": "he ll no"
        }
    },
    {
        "task_id": "0151",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Beroffice text editor has a wide range of features that help working with text. One of the features is an automatic search for typos and suggestions of how to fix them.\n\nBeroffice works only with small English letters (i.e. with 26 letters from a to z). Beroffice thinks that a word is typed with a typo if there are three or more consonants in a row in the word. The only exception is that if the block of consonants has all letters the same, then this block (even if its length is greater than three) is not considered a typo. Formally, a word is typed with a typo if there is a block of not less that three consonants in a row, and there are at least two different letters in this block.\n\nFor example:\n\n  the following words have typos: \"hellno\", \"hackcerrs\" and \"backtothefutttture\";  the following words don't have typos: \"helllllooooo\", \"tobeornottobe\" and \"oooooo\". \n\nWhen Beroffice editor finds a word with a typo, it inserts as little as possible number of spaces in this word (dividing it into several words) in such a way that each of the resulting words is typed without any typos.\n\nImplement this feature of Beroffice editor. Consider the following letters as the only vowels: 'a', 'e', 'i', 'o' and 'u'. All the other letters are consonants in this problem.\n\n\n-----Input-----\n\nThe only line contains a non-empty word consisting of small English letters. The length of the word is between 1 and 3000 letters.\n\n\n-----Output-----\n\nPrint the given word without any changes if there are no typos.\n\nIf there is at least one typo in the word, insert the minimum number of spaces into the word so that each of the resulting words doesn't have any typos. If there are multiple solutions, print any of them.\n\n\n-----Examples-----\nInput\nhellno\n\nOutput\nhell no \n\nInput\nabacaba\n\nOutput\nabacaba \n\nInput\nasdfasdf\n\nOutput\nasd fasd f",
        "generated_code": "def is_vowel(c):\n    return c in 'aeiou'\n\ndef has_typo(block):\n    if len(block) < 3:\n        return False\n    first_consonant = block[0]\n    for c in block:\n        if c != first_consonant:\n            return True\n    return False\n\ndef correct_typo(word):\n    n = len(word)\n    result = []\n    i = 0\n\n    while i < n:\n        start = i\n        while i < n and not is_vowel(word[i]):\n            i += 1\n        if i - start >= 3 and has_typo(word[start:i]):\n            result.append(word[start:start+2])\n            start += 2\n            while start < i:\n                result.append(word[start:start+1])\n                start += 1\n        else:\n            result.append(word[start:i])\n        while i < n and is_vowel(word[i]):\n            i += 1\n        result.append(word[start:i])\n        \n    return ' '.join(result)\n\nif __name__ == \"__main__\":\n    word = input().strip()\n    print(correct_typo(word))\n",
        "counter_example": {
            "input": "hellno\n",
            "expected": "hell no \n",
            "got": "h he ll n o"
        }
    },
    {
        "task_id": "0173",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Imagine a city with n horizontal streets crossing m vertical streets, forming an (n - 1) × (m - 1) grid. In order to increase the traffic flow, mayor of the city has decided to make each street one way. This means in each horizontal street, the traffic moves only from west to east or only from east to west. Also, traffic moves only from north to south or only from south to north in each vertical street. It is possible to enter a horizontal street from a vertical street, or vice versa, at their intersection.\n\n [Image] \n\nThe mayor has received some street direction patterns. Your task is to check whether it is possible to reach any junction from any other junction in the proposed street direction pattern.\n\n\n-----Input-----\n\nThe first line of input contains two integers n and m, (2 ≤ n, m ≤ 20), denoting the number of horizontal streets and the number of vertical streets.\n\nThe second line contains a string of length n, made of characters '<' and '>', denoting direction of each horizontal street. If the i-th character is equal to '<', the street is directed from east to west otherwise, the street is directed from west to east. Streets are listed in order from north to south.\n\nThe third line contains a string of length m, made of characters '^' and 'v', denoting direction of each vertical street. If the i-th character is equal to '^', the street is directed from south to north, otherwise the street is directed from north to south. Streets are listed in order from west to east.\n\n\n-----Output-----\n\nIf the given pattern meets the mayor's criteria, print a single line containing \"YES\", otherwise print a single line containing \"NO\".\n\n\n-----Examples-----\nInput\n3 3\n><>\nv^v\n\nOutput\nNO\n\nInput\n4 6\n<><>\nv^v^v^\n\nOutput\nYES\n\n\n\n-----Note-----\n\nThe figure above shows street directions in the second sample test case.",
        "generated_code": "n, m = map(int, input().split())\nh_streets = input()\nv_streets = input()\n\nh_west_to_east = [i for i, c in enumerate(h_streets) if c == '>']\nh_east_to_west = [i for i, c in enumerate(h_streets) if c == '<']\nv_north_to_south = [i for i, c in enumerate(v_streets) if c == 'v']\nv_south_to_north = [i for i, c in enumerate(v_streets) if c == '^']\n\ncan_reach = True\n\nfor i in range(n-1):\n    if not (h_west_to_east and h_east_to_west):\n        can_reach = False\n        break\n    if i not in h_west_to_east and i not in h_east_to_west:\n        can_reach = False\n        break\n\nfor i in range(m-1):\n    if not (v_north_to_south and v_south_to_north):\n        can_reach = False\n        break\n    if i not in v_north_to_south and i not in v_south_to_north:\n        can_reach = False\n        break\n\nprint(\"YES\" if can_reach else \"NO\")\n",
        "counter_example": {
            "input": "3 3\n><>\nv^v\n",
            "expected": "NO\n",
            "got": "YES"
        }
    },
    {
        "task_id": "0173",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Imagine a city with n horizontal streets crossing m vertical streets, forming an (n - 1) × (m - 1) grid. In order to increase the traffic flow, mayor of the city has decided to make each street one way. This means in each horizontal street, the traffic moves only from west to east or only from east to west. Also, traffic moves only from north to south or only from south to north in each vertical street. It is possible to enter a horizontal street from a vertical street, or vice versa, at their intersection.\n\n [Image] \n\nThe mayor has received some street direction patterns. Your task is to check whether it is possible to reach any junction from any other junction in the proposed street direction pattern.\n\n\n-----Input-----\n\nThe first line of input contains two integers n and m, (2 ≤ n, m ≤ 20), denoting the number of horizontal streets and the number of vertical streets.\n\nThe second line contains a string of length n, made of characters '<' and '>', denoting direction of each horizontal street. If the i-th character is equal to '<', the street is directed from east to west otherwise, the street is directed from west to east. Streets are listed in order from north to south.\n\nThe third line contains a string of length m, made of characters '^' and 'v', denoting direction of each vertical street. If the i-th character is equal to '^', the street is directed from south to north, otherwise the street is directed from north to south. Streets are listed in order from west to east.\n\n\n-----Output-----\n\nIf the given pattern meets the mayor's criteria, print a single line containing \"YES\", otherwise print a single line containing \"NO\".\n\n\n-----Examples-----\nInput\n3 3\n><>\nv^v\n\nOutput\nNO\n\nInput\n4 6\n<><>\nv^v^v^\n\nOutput\nYES\n\n\n\n-----Note-----\n\nThe figure above shows street directions in the second sample test case.",
        "generated_code": "def can_reach_all_junctions(n, m, horizontal, vertical):\n    if (horizontal[0] == '>' and horizontal[-1] == '>' and vertical[0] == 'v' and vertical[-1] == 'v') or \\\n       (horizontal[0] == '<' and horizontal[-1] == '<' and vertical[0] == '^' and vertical[-1] == '^'):\n        return \"YES\"\n    else:\n        return \"NO\"\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    horizontal = data[2]\n    vertical = data[3]\n    \n    print(can_reach_all_junctions(n, m, horizontal, vertical))\n",
        "counter_example": {
            "input": "3 3\n><>\nv^v\n",
            "expected": "NO\n",
            "got": "YES"
        }
    },
    {
        "task_id": "0284",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": true,
        "description": "Kolya is developing an economy simulator game. His most favourite part of the development process is in-game testing. Once he was entertained by the testing so much, that he found out his game-coin score become equal to 0.\n\nKolya remembers that at the beginning of the game his game-coin score was equal to n and that he have bought only some houses (for 1 234 567 game-coins each), cars (for 123 456 game-coins each) and computers (for 1 234 game-coins each).\n\nKolya is now interested, whether he could have spent all of his initial n game-coins buying only houses, cars and computers or there is a bug in the game. Formally, is there a triple of non-negative integers a, b and c such that a × 1 234 567 + b × 123 456 + c × 1 234 = n?\n\nPlease help Kolya answer this question.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 ≤ n ≤ 10^9) — Kolya's initial game-coin score.\n\n\n-----Output-----\n\nPrint \"YES\" (without quotes) if it's possible that Kolya spent all of his initial n coins buying only houses, cars and computers. Otherwise print \"NO\" (without quotes).\n\n\n-----Examples-----\nInput\n1359257\n\nOutput\nYES\nInput\n17851817\n\nOutput\nNO\n\n\n-----Note-----\n\nIn the first sample, one of the possible solutions is to buy one house, one car and one computer, spending 1 234 567 + 123 456 + 1234 = 1 359 257 game-coins in total.",
        "generated_code": "n = int(input())\nfor a in range(n // 1234567 + 1):\n    for b in range((n - a * 1234567) // 123456 + 1):\n        c = (n - a * 1234567 - b * 123456) // 1234\n        if a * 1234567 + b * 123456 + c * 1234 == n:\n            print(\"YES\")\n            exit()\nprint(\"NO\")\n",
        "counter_example": null
    },
    {
        "task_id": "0284",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Kolya is developing an economy simulator game. His most favourite part of the development process is in-game testing. Once he was entertained by the testing so much, that he found out his game-coin score become equal to 0.\n\nKolya remembers that at the beginning of the game his game-coin score was equal to n and that he have bought only some houses (for 1 234 567 game-coins each), cars (for 123 456 game-coins each) and computers (for 1 234 game-coins each).\n\nKolya is now interested, whether he could have spent all of his initial n game-coins buying only houses, cars and computers or there is a bug in the game. Formally, is there a triple of non-negative integers a, b and c such that a × 1 234 567 + b × 123 456 + c × 1 234 = n?\n\nPlease help Kolya answer this question.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 ≤ n ≤ 10^9) — Kolya's initial game-coin score.\n\n\n-----Output-----\n\nPrint \"YES\" (without quotes) if it's possible that Kolya spent all of his initial n coins buying only houses, cars and computers. Otherwise print \"NO\" (without quotes).\n\n\n-----Examples-----\nInput\n1359257\n\nOutput\nYES\nInput\n17851817\n\nOutput\nNO\n\n\n-----Note-----\n\nIn the first sample, one of the possible solutions is to buy one house, one car and one computer, spending 1 234 567 + 123 456 + 1234 = 1 359 257 game-coins in total.",
        "generated_code": "def can_spend_all_coins(n):\n    # Define the cost of houses, cars, and computers\n    house_cost = 1234567\n    car_cost = 123456\n    computer_cost = 1234\n    \n    # Iterate over the possible number of houses\n    for a in range(n // house_cost + 1):\n        remaining_after_houses = n - a * house_cost\n        # Iterate over the possible number of cars\n        for b in range(remaining_after_houses // car_cost + 1):\n            remaining_after_cars = remaining_after_houses - b * car_cost\n            # Check if the remaining coins can be exactly spent on computers\n            if remaining_after_cars % computer_cost == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input().strip())\n\n# Get the result\nresult = can_spend_all_coins(n)\n\n# Print the result\nprint(result)\n",
        "counter_example": null
    }
]