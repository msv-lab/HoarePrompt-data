[
    {
        "task_id": "0189",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Salem gave you $n$ sticks with integer positive lengths $a_1, a_2, \\ldots, a_n$.\n\nFor every stick, you can change its length to any other positive integer length (that is, either shrink or stretch it). The cost of changing the stick's length from $a$ to $b$ is $|a - b|$, where $|x|$ means the absolute value of $x$.\n\nA stick length $a_i$ is called almost good for some integer $t$ if $|a_i - t| \\le 1$.\n\nSalem asks you to change the lengths of some sticks (possibly all or none), such that all sticks' lengths are almost good for some positive integer $t$ and the total cost of changing is minimum possible. The value of $t$ is not fixed in advance and you can choose it as any positive integer. \n\nAs an answer, print the value of $t$ and the minimum cost. If there are multiple optimal choices for $t$, print any of them.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 1000$) — the number of sticks.\n\nThe second line contains $n$ integers $a_i$ ($1 \\le a_i \\le 100$) — the lengths of the sticks.\n\n\n-----Output-----\n\nPrint the value of $t$ and the minimum possible cost. If there are multiple optimal choices for $t$, print any of them.\n\n\n-----Examples-----\nInput\n3\n10 1 4\n\nOutput\n3 7\n\nInput\n5\n1 1 2 2 3\n\nOutput\n2 0\n\n\n\n-----Note-----\n\nIn the first example, we can change $1$ into $2$ and $10$ into $4$ with cost $|1 - 2| + |10 - 4| = 1 + 6 = 7$ and the resulting lengths $[2, 4, 4]$ are almost good for $t = 3$.\n\nIn the second example, the sticks lengths are already almost good for $t = 2$, so we don't have to do anything.",
        "generated_code": "n = int(input())\nsticks = list(map(int, input().split()))\n\nsticks.sort()\n\nmid = sticks[n // 2]\n\ncost = sum(abs(x - mid) for x in sticks)\nt = mid\n\nmin_cost = cost\nmin_t = t\n\nfor i in range(mid - 1, 0, -1):\n    cost = sum(min(abs(x - i), abs(x - (i + 1))) for x in sticks)\n    if cost < min_cost:\n        min_cost = cost\n        min_t = i\n\nfor i in range(mid + 1, 101):\n    cost = sum(min(abs(x - i), abs(x - (i - 1))) for x in sticks)\n    if cost < min_cost:\n        min_cost = cost\n        min_t = i\n\nprint(min_t, min_cost)\n",
        "counter_example": {
            "input": "3\n10 1 4\n",
            "expected": "3 7\n",
            "got": "3 8"
        }
    },
    {
        "task_id": "0189",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Salem gave you $n$ sticks with integer positive lengths $a_1, a_2, \\ldots, a_n$.\n\nFor every stick, you can change its length to any other positive integer length (that is, either shrink or stretch it). The cost of changing the stick's length from $a$ to $b$ is $|a - b|$, where $|x|$ means the absolute value of $x$.\n\nA stick length $a_i$ is called almost good for some integer $t$ if $|a_i - t| \\le 1$.\n\nSalem asks you to change the lengths of some sticks (possibly all or none), such that all sticks' lengths are almost good for some positive integer $t$ and the total cost of changing is minimum possible. The value of $t$ is not fixed in advance and you can choose it as any positive integer. \n\nAs an answer, print the value of $t$ and the minimum cost. If there are multiple optimal choices for $t$, print any of them.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 1000$) — the number of sticks.\n\nThe second line contains $n$ integers $a_i$ ($1 \\le a_i \\le 100$) — the lengths of the sticks.\n\n\n-----Output-----\n\nPrint the value of $t$ and the minimum possible cost. If there are multiple optimal choices for $t$, print any of them.\n\n\n-----Examples-----\nInput\n3\n10 1 4\n\nOutput\n3 7\n\nInput\n5\n1 1 2 2 3\n\nOutput\n2 0\n\n\n\n-----Note-----\n\nIn the first example, we can change $1$ into $2$ and $10$ into $4$ with cost $|1 - 2| + |10 - 4| = 1 + 6 = 7$ and the resulting lengths $[2, 4, 4]$ are almost good for $t = 3$.\n\nIn the second example, the sticks lengths are already almost good for $t = 2$, so we don't have to do anything.",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\nmin_cost = float('inf')\nbest_t = -1\n\n# Try every possible t from 1 to 100\nfor t in range(1, 101):\n    current_cost = 0\n    for length in a:\n        if length < t - 1:\n            current_cost += (t - 1) - length\n        elif length > t + 1:\n            current_cost += length - (t + 1)\n    \n    if current_cost < min_cost:\n        min_cost = current_cost\n        best_t = t\n\nprint(best_t, min_cost)\n",
        "counter_example": null
    },
    {
        "task_id": "0238",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "You are given an array $a_1, a_2, \\dots , a_n$ and two integers $m$ and $k$.\n\nYou can choose some subarray $a_l, a_{l+1}, \\dots, a_{r-1}, a_r$. \n\nThe cost of subarray $a_l, a_{l+1}, \\dots, a_{r-1}, a_r$ is equal to $\\sum\\limits_{i=l}^{r} a_i - k \\lceil \\frac{r - l + 1}{m} \\rceil$, where $\\lceil x \\rceil$ is the least integer greater than or equal to $x$. \n\nThe cost of empty subarray is equal to zero.\n\nFor example, if $m = 3$, $k = 10$ and $a = [2, -4, 15, -3, 4, 8, 3]$, then the cost of some subarrays are:  $a_3 \\dots a_3: 15 - k \\lceil \\frac{1}{3} \\rceil = 15 - 10 = 5$;  $a_3 \\dots a_4: (15 - 3) - k \\lceil \\frac{2}{3} \\rceil = 12 - 10 = 2$;  $a_3 \\dots a_5: (15 - 3 + 4) - k \\lceil \\frac{3}{3} \\rceil = 16 - 10 = 6$;  $a_3 \\dots a_6: (15 - 3 + 4 + 8) - k \\lceil \\frac{4}{3} \\rceil = 24 - 20 = 4$;  $a_3 \\dots a_7: (15 - 3 + 4 + 8 + 3) - k \\lceil \\frac{5}{3} \\rceil = 27 - 20 = 7$. \n\nYour task is to find the maximum cost of some subarray (possibly empty) of array $a$.\n\n\n-----Input-----\n\nThe first line contains three integers $n$, $m$, and $k$ ($1 \\le n \\le 3 \\cdot 10^5, 1 \\le m \\le 10, 1 \\le k \\le 10^9$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-10^9 \\le a_i \\le 10^9$).\n\n\n-----Output-----\n\nPrint the maximum cost of some subarray of array $a$.\n\n\n-----Examples-----\nInput\n7 3 10\n2 -4 15 -3 4 8 3\n\nOutput\n7\n\nInput\n5 2 1000\n-13 -4 -9 -20 -11\n\nOutput\n0",
        "generated_code": "n, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [0] * (n + 1)\nmx = 0\n\nfor i in range(1, n + 1):\n    dp[i] = max(dp[i - 1], sum(a[:i]) - k * ((i + m - 1) // m))\n    mx = max(mx, dp[i])\n\nprint(mx)\n",
        "counter_example": {
            "input": "7 3 10\n2 -4 15 -3 4 8 3\n",
            "expected": "7\n",
            "got": "3"
        }
    },
    {
        "task_id": "0238",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "You are given an array $a_1, a_2, \\dots , a_n$ and two integers $m$ and $k$.\n\nYou can choose some subarray $a_l, a_{l+1}, \\dots, a_{r-1}, a_r$. \n\nThe cost of subarray $a_l, a_{l+1}, \\dots, a_{r-1}, a_r$ is equal to $\\sum\\limits_{i=l}^{r} a_i - k \\lceil \\frac{r - l + 1}{m} \\rceil$, where $\\lceil x \\rceil$ is the least integer greater than or equal to $x$. \n\nThe cost of empty subarray is equal to zero.\n\nFor example, if $m = 3$, $k = 10$ and $a = [2, -4, 15, -3, 4, 8, 3]$, then the cost of some subarrays are:  $a_3 \\dots a_3: 15 - k \\lceil \\frac{1}{3} \\rceil = 15 - 10 = 5$;  $a_3 \\dots a_4: (15 - 3) - k \\lceil \\frac{2}{3} \\rceil = 12 - 10 = 2$;  $a_3 \\dots a_5: (15 - 3 + 4) - k \\lceil \\frac{3}{3} \\rceil = 16 - 10 = 6$;  $a_3 \\dots a_6: (15 - 3 + 4 + 8) - k \\lceil \\frac{4}{3} \\rceil = 24 - 20 = 4$;  $a_3 \\dots a_7: (15 - 3 + 4 + 8 + 3) - k \\lceil \\frac{5}{3} \\rceil = 27 - 20 = 7$. \n\nYour task is to find the maximum cost of some subarray (possibly empty) of array $a$.\n\n\n-----Input-----\n\nThe first line contains three integers $n$, $m$, and $k$ ($1 \\le n \\le 3 \\cdot 10^5, 1 \\le m \\le 10, 1 \\le k \\le 10^9$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-10^9 \\le a_i \\le 10^9$).\n\n\n-----Output-----\n\nPrint the maximum cost of some subarray of array $a$.\n\n\n-----Examples-----\nInput\n7 3 10\n2 -4 15 -3 4 8 3\n\nOutput\n7\n\nInput\n5 2 1000\n-13 -4 -9 -20 -11\n\nOutput\n0",
        "generated_code": "import sys\nimport math\n\ndef max_subarray_cost(n, m, k, a):\n    # Initialize variables\n    max_cost = 0\n    current_sum = 0\n    min_prefix = 0\n    \n    # Iterate over the array\n    for i in range(n):\n        current_sum += a[i]\n        if i + 1 >= m:\n            current_cost = current_sum - k * math.ceil((i + 1) / m)\n            max_cost = max(max_cost, current_cost - min_prefix)\n            min_prefix = min(min_prefix, current_cost)\n    \n    return max_cost\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn, m, k = int(data[0]), int(data[1]), int(data[2])\na = list(map(int, data[3:]))\n\n# Calculate and print the result\nprint(max_subarray_cost(n, m, k, a))\n",
        "counter_example": {
            "input": "7 3 10\n2 -4 15 -3 4 8 3\n",
            "expected": "7\n",
            "got": "12"
        }
    },
    {
        "task_id": "0085",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Polycarpus likes giving presents to Paraskevi. He has bought two chocolate bars, each of them has the shape of a segmented rectangle. The first bar is a_1 × b_1 segments large and the second one is a_2 × b_2 segments large.\n\nPolycarpus wants to give Paraskevi one of the bars at the lunch break and eat the other one himself. Besides, he wants to show that Polycarpus's mind and Paraskevi's beauty are equally matched, so the two bars must have the same number of squares.\n\nTo make the bars have the same number of squares, Polycarpus eats a little piece of chocolate each minute. Each minute he does the following:  he either breaks one bar exactly in half (vertically or horizontally) and eats exactly a half of the bar,  or he chips of exactly one third of a bar (vertically or horizontally) and eats exactly a third of the bar. \n\nIn the first case he is left with a half, of the bar and in the second case he is left with two thirds of the bar.\n\nBoth variants aren't always possible, and sometimes Polycarpus cannot chip off a half nor a third. For example, if the bar is 16 × 23, then Polycarpus can chip off a half, but not a third. If the bar is 20 × 18, then Polycarpus can chip off both a half and a third. If the bar is 5 × 7, then Polycarpus cannot chip off a half nor a third.\n\nWhat is the minimum number of minutes Polycarpus needs to make two bars consist of the same number of squares? Find not only the required minimum number of minutes, but also the possible sizes of the bars after the process.\n\n\n-----Input-----\n\nThe first line of the input contains integers a_1, b_1 (1 ≤ a_1, b_1 ≤ 10^9) — the initial sizes of the first chocolate bar. The second line of the input contains integers a_2, b_2 (1 ≤ a_2, b_2 ≤ 10^9) — the initial sizes of the second bar.\n\nYou can use the data of type int64 (in Pascal), long long (in С++), long (in Java) to process large integers (exceeding 2^31 - 1).\n\n\n-----Output-----\n\nIn the first line print m — the sought minimum number of minutes. In the second and third line print the possible sizes of the bars after they are leveled in m minutes. Print the sizes using the format identical to the input format. Print the sizes (the numbers in the printed pairs) in any order. The second line must correspond to the first bar and the third line must correspond to the second bar. If there are multiple solutions, print any of them.\n\nIf there is no solution, print a single line with integer -1.\n\n\n-----Examples-----\nInput\n2 6\n2 3\n\nOutput\n1\n1 6\n2 3\n\nInput\n36 5\n10 16\n\nOutput\n3\n16 5\n5 16\n\nInput\n3 5\n2 1\n\nOutput\n-1",
        "generated_code": "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\narea1 = a1 * b1\narea2 = a2 * b2\n\nif area1 != area2:\n    print(-1)\nelse:\n    g = gcd(a1, b1)\n    a1 //= g\n    b1 //= g\n    g = gcd(a2, b2)\n    a2 //= b2\n    b2 //= g\n\n    minutes = 0\n    while a1 != a2 or b1 != b2:\n        if a1 > a2:\n            if a1 % 2 == 0:\n                a1 //= 2\n            elif a1 % 3 == 0:\n                a1 //= 3\n            else:\n                break\n            minutes += 1\n        elif a1 < a2:\n            if a2 % 2 == 0:\n                a2 //= 2\n            elif a2 % 3 == 0:\n                a2 //= 3\n            else:\n                break\n            minutes += 1\n        if b1 > b2:\n            if b1 % 2 == 0:\n                b1 //= 2\n            elif b1 % 3 == 0:\n                b1 //= 3\n            else:\n                break\n            minutes += 1\n        elif b1 < b2:\n            if b2 % 2 == 0:\n                b2 //= 2\n            elif b2 % 3 == 0:\n                b2 //= 3\n            else:\n                break\n            minutes += 1\n    if a1 == a2 and b1 == b2:\n        print(minutes)\n        print(a1, b1)\n        print(a2, b2)\n    else:\n        print(-1)\n",
        "counter_example": {
            "input": "2 6\n2 3\n",
            "expected": "1\n1 6\n2 3\n",
            "got": "-1"
        }
    },
    {
        "task_id": "0085",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Polycarpus likes giving presents to Paraskevi. He has bought two chocolate bars, each of them has the shape of a segmented rectangle. The first bar is a_1 × b_1 segments large and the second one is a_2 × b_2 segments large.\n\nPolycarpus wants to give Paraskevi one of the bars at the lunch break and eat the other one himself. Besides, he wants to show that Polycarpus's mind and Paraskevi's beauty are equally matched, so the two bars must have the same number of squares.\n\nTo make the bars have the same number of squares, Polycarpus eats a little piece of chocolate each minute. Each minute he does the following:  he either breaks one bar exactly in half (vertically or horizontally) and eats exactly a half of the bar,  or he chips of exactly one third of a bar (vertically or horizontally) and eats exactly a third of the bar. \n\nIn the first case he is left with a half, of the bar and in the second case he is left with two thirds of the bar.\n\nBoth variants aren't always possible, and sometimes Polycarpus cannot chip off a half nor a third. For example, if the bar is 16 × 23, then Polycarpus can chip off a half, but not a third. If the bar is 20 × 18, then Polycarpus can chip off both a half and a third. If the bar is 5 × 7, then Polycarpus cannot chip off a half nor a third.\n\nWhat is the minimum number of minutes Polycarpus needs to make two bars consist of the same number of squares? Find not only the required minimum number of minutes, but also the possible sizes of the bars after the process.\n\n\n-----Input-----\n\nThe first line of the input contains integers a_1, b_1 (1 ≤ a_1, b_1 ≤ 10^9) — the initial sizes of the first chocolate bar. The second line of the input contains integers a_2, b_2 (1 ≤ a_2, b_2 ≤ 10^9) — the initial sizes of the second bar.\n\nYou can use the data of type int64 (in Pascal), long long (in С++), long (in Java) to process large integers (exceeding 2^31 - 1).\n\n\n-----Output-----\n\nIn the first line print m — the sought minimum number of minutes. In the second and third line print the possible sizes of the bars after they are leveled in m minutes. Print the sizes using the format identical to the input format. Print the sizes (the numbers in the printed pairs) in any order. The second line must correspond to the first bar and the third line must correspond to the second bar. If there are multiple solutions, print any of them.\n\nIf there is no solution, print a single line with integer -1.\n\n\n-----Examples-----\nInput\n2 6\n2 3\n\nOutput\n1\n1 6\n2 3\n\nInput\n36 5\n10 16\n\nOutput\n3\n16 5\n5 16\n\nInput\n3 5\n2 1\n\nOutput\n-1",
        "generated_code": "def min_minutes_to_equal_areas(a1, b1, a2, b2):\n    from math import gcd\n    \n    def reduce_area(area):\n        operations = 0\n        while area % 2 == 0:\n            area //= 2\n            operations += 1\n        while area % 3 == 0:\n            area //= 3\n            operations += 1\n        return area, operations\n    \n    area1 = a1 * b1\n    area2 = a2 * b2\n    \n    reduced_area1, ops1 = reduce_area(area1)\n    reduced_area2, ops2 = reduce_area(area2)\n    \n    if reduced_area1 != reduced_area2:\n        print(-1)\n        return\n    \n    print(abs(ops1 - ops2) + min(ops1, ops2))\n    print(a1, b1)\n    print(a2, b2)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    a1, b1 = int(data[0]), int(data[1])\n    a2, b2 = int(data[2]), int(data[3])\n    min_minutes_to_equal_areas(a1, b1, a2, b2)\n",
        "counter_example": {
            "input": "2 6\n2 3\n",
            "expected": "1\n1 6\n2 3\n",
            "got": "3\n2 6\n2 3"
        }
    },
    {
        "task_id": "0141",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "You have a set of items, each having some integer weight not greater than $8$. You denote that a subset of items is good if total weight of items in the subset does not exceed $W$.\n\nYou want to calculate the maximum possible weight of a good subset of items. Note that you have to consider the empty set and the original set when calculating the answer.\n\n\n-----Input-----\n\nThe first line contains one integer $W$ ($0 \\le W \\le 10^{18}$) — the maximum total weight of a good subset.\n\nThe second line denotes the set of items you have. It contains $8$ integers $cnt_1$, $cnt_2$, ..., $cnt_8$ ($0 \\le cnt_i \\le 10^{16}$), where $cnt_i$ is the number of items having weight $i$ in the set.\n\n\n-----Output-----\n\nPrint one integer — the maximum possible weight of a good subset of items.\n\n\n-----Examples-----\nInput\n10\n1 2 3 4 5 6 7 8\n\nOutput\n10\n\nInput\n0\n0 0 0 0 0 0 0 0\n\nOutput\n0\n\nInput\n3\n0 4 1 0 0 9 8 3\n\nOutput\n3",
        "generated_code": "W = int(input())\ncnt = list(map(int, input().split()))\ndp = [0] * (W + 1)\nfor i in range(1, 9):\n    for j in range(W, i - 1, -1):\n        dp[j] = max(dp[j], dp[j - i] + i * cnt[i - 1])\nprint(dp[W])\n",
        "counter_example": {
            "input": "10\n1 2 3 4 5 6 7 8\n",
            "expected": "10\n",
            "got": "68"
        }
    },
    {
        "task_id": "0141",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "You have a set of items, each having some integer weight not greater than $8$. You denote that a subset of items is good if total weight of items in the subset does not exceed $W$.\n\nYou want to calculate the maximum possible weight of a good subset of items. Note that you have to consider the empty set and the original set when calculating the answer.\n\n\n-----Input-----\n\nThe first line contains one integer $W$ ($0 \\le W \\le 10^{18}$) — the maximum total weight of a good subset.\n\nThe second line denotes the set of items you have. It contains $8$ integers $cnt_1$, $cnt_2$, ..., $cnt_8$ ($0 \\le cnt_i \\le 10^{16}$), where $cnt_i$ is the number of items having weight $i$ in the set.\n\n\n-----Output-----\n\nPrint one integer — the maximum possible weight of a good subset of items.\n\n\n-----Examples-----\nInput\n10\n1 2 3 4 5 6 7 8\n\nOutput\n10\n\nInput\n0\n0 0 0 0 0 0 0 0\n\nOutput\n0\n\nInput\n3\n0 4 1 0 0 9 8 3\n\nOutput\n3",
        "generated_code": "W = int(input())\ncnt = list(map(int, input().split()))\n\n# weights from 1 to 8\nweights = [i for i in range(1, 9)]\n\n# Initialize the max weight achievable to 0\nmax_weight = 0\n\n# Iterate through each weight from 8 to 1\nfor i in range(7, -1, -1):\n    if W >= weights[i]:\n        # Calculate the maximum number of items of this weight we can use\n        num_items = min(W // weights[i], cnt[i])\n        # Update the total weight\n        max_weight += num_items * weights[i]\n        # Decrease the weight limit\n        W -= num_items * weights[i]\n\nprint(max_weight)\n",
        "counter_example": {
            "input": "25\n0 0 0 0 2 0 6 0\n",
            "expected": "24\n",
            "got": "21"
        }
    },
    {
        "task_id": "0028",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "The All-Berland National Olympiad in Informatics has just ended! Now Vladimir wants to upload the contest from the Olympiad as a gym to a popular Codehorses website.\n\nUnfortunately, the archive with Olympiad's data is a mess. For example, the files with tests are named arbitrary without any logic.\n\nVladimir wants to rename the files with tests so that their names are distinct integers starting from 1 without any gaps, namely, \"1\", \"2\", ..., \"n', where n is the total number of tests.\n\nSome of the files contain tests from statements (examples), while others contain regular tests. It is possible that there are no examples, and it is possible that all tests are examples. Vladimir wants to rename the files so that the examples are the first several tests, all all the next files contain regular tests only.\n\nThe only operation Vladimir can perform is the \"move\" command. Vladimir wants to write a script file, each of the lines in which is \"move file_1 file_2\", that means that the file \"file_1\" is to be renamed to \"file_2\". If there is a file \"file_2\" at the moment of this line being run, then this file is to be rewritten. After the line \"move file_1 file_2\" the file \"file_1\" doesn't exist, but there is a file \"file_2\" with content equal to the content of \"file_1\" before the \"move\" command.\n\nHelp Vladimir to write the script file with the minimum possible number of lines so that after this script is run:  all examples are the first several tests having filenames \"1\", \"2\", ..., \"e\", where e is the total number of examples;  all other files contain regular tests with filenames \"e + 1\", \"e + 2\", ..., \"n\", where n is the total number of all tests. \n\n\n-----Input-----\n\nThe first line contains single integer n (1 ≤ n ≤ 10^5) — the number of files with tests.\n\nn lines follow, each describing a file with test. Each line has a form of \"name_i type_i\", where \"name_i\" is the filename, and \"type_i\" equals \"1\", if the i-th file contains an example test, and \"0\" if it contains a regular test. Filenames of each file are strings of digits and small English letters with length from 1 to 6 characters. The filenames are guaranteed to be distinct.\n\n\n-----Output-----\n\nIn the first line print the minimum number of lines in Vladimir's script file.\n\nAfter that print the script file, each line should be \"move file_1 file_2\", where \"file_1\" is an existing at the moment of this line being run filename, and \"file_2\" — is a string of digits and small English letters with length from 1 to 6.\n\n\n-----Examples-----\nInput\n5\n01 0\n2 1\n2extra 0\n3 1\n99 0\n\nOutput\n4\nmove 3 1\nmove 01 5\nmove 2extra 4\nmove 99 3\n\nInput\n2\n1 0\n2 1\n\nOutput\n3\nmove 1 3\nmove 2 1\nmove 3 2\nInput\n5\n1 0\n11 1\n111 0\n1111 1\n11111 0\n\nOutput\n5\nmove 1 5\nmove 11 1\nmove 1111 2\nmove 111 4\nmove 11111 3",
        "generated_code": "n = int(input())\nfiles = []\nfor _ in range(n):\n    name, type_ = input().split()\n    files.append((name, int(type_)))\n\nfiles.sort(key=lambda x: x[1], reverse=True)\nexamples = [file[0] for file in files if file[1] == 1]\nregular = [file[0] for file in files if file[1] == 0]\n\nscript = []\nfor i, file in enumerate(examples, start=1):\n    script.append(f\"move {file} {i}\")\nfor i, file in enumerate(regular, start=len(examples) + 1):\n    script.append(f\"move {file} {i}\")\n\nprint(len(script))\nfor line in script:\n    print(line)\n",
        "counter_example": {
            "input": "5\n01 0\n2 1\n2extra 0\n3 1\n99 0\n",
            "expected": "4\nmove 3 1\nmove 01 5\nmove 2extra 4\nmove 99 3\n",
            "got": "5\nmove 2 1\nmove 3 2\nmove 01 3\nmove 2extra 4\nmove 99 5"
        }
    },
    {
        "task_id": "0028",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "The All-Berland National Olympiad in Informatics has just ended! Now Vladimir wants to upload the contest from the Olympiad as a gym to a popular Codehorses website.\n\nUnfortunately, the archive with Olympiad's data is a mess. For example, the files with tests are named arbitrary without any logic.\n\nVladimir wants to rename the files with tests so that their names are distinct integers starting from 1 without any gaps, namely, \"1\", \"2\", ..., \"n', where n is the total number of tests.\n\nSome of the files contain tests from statements (examples), while others contain regular tests. It is possible that there are no examples, and it is possible that all tests are examples. Vladimir wants to rename the files so that the examples are the first several tests, all all the next files contain regular tests only.\n\nThe only operation Vladimir can perform is the \"move\" command. Vladimir wants to write a script file, each of the lines in which is \"move file_1 file_2\", that means that the file \"file_1\" is to be renamed to \"file_2\". If there is a file \"file_2\" at the moment of this line being run, then this file is to be rewritten. After the line \"move file_1 file_2\" the file \"file_1\" doesn't exist, but there is a file \"file_2\" with content equal to the content of \"file_1\" before the \"move\" command.\n\nHelp Vladimir to write the script file with the minimum possible number of lines so that after this script is run:  all examples are the first several tests having filenames \"1\", \"2\", ..., \"e\", where e is the total number of examples;  all other files contain regular tests with filenames \"e + 1\", \"e + 2\", ..., \"n\", where n is the total number of all tests. \n\n\n-----Input-----\n\nThe first line contains single integer n (1 ≤ n ≤ 10^5) — the number of files with tests.\n\nn lines follow, each describing a file with test. Each line has a form of \"name_i type_i\", where \"name_i\" is the filename, and \"type_i\" equals \"1\", if the i-th file contains an example test, and \"0\" if it contains a regular test. Filenames of each file are strings of digits and small English letters with length from 1 to 6 characters. The filenames are guaranteed to be distinct.\n\n\n-----Output-----\n\nIn the first line print the minimum number of lines in Vladimir's script file.\n\nAfter that print the script file, each line should be \"move file_1 file_2\", where \"file_1\" is an existing at the moment of this line being run filename, and \"file_2\" — is a string of digits and small English letters with length from 1 to 6.\n\n\n-----Examples-----\nInput\n5\n01 0\n2 1\n2extra 0\n3 1\n99 0\n\nOutput\n4\nmove 3 1\nmove 01 5\nmove 2extra 4\nmove 99 3\n\nInput\n2\n1 0\n2 1\n\nOutput\n3\nmove 1 3\nmove 2 1\nmove 3 2\nInput\n5\n1 0\n11 1\n111 0\n1111 1\n11111 0\n\nOutput\n5\nmove 1 5\nmove 11 1\nmove 1111 2\nmove 111 4\nmove 11111 3",
        "generated_code": "def rename_files(n, files):\n    examples = []\n    regulars = []\n    \n    for file in files:\n        name, type_ = file.split()\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n    \n    moves = []\n    temp_counter = n + 1\n\n    # Move examples to the beginning\n    for i in range(len(examples)):\n        if examples[i] != str(i + 1):\n            while temp_counter <= 2 * n and str(temp_counter) in files_set:\n                temp_counter += 1\n            moves.append(f\"move {examples[i]} {temp_counter}\")\n            examples[i] = str(temp_counter)\n            temp_counter += 1\n            \n        if examples[i] != str(i + 1):\n            moves.append(f\"move {examples[i]} {i + 1}\")\n    \n    # Move regulars to the correct positions\n    for i in range(len(regulars)):\n        target = len(examples) + i + 1\n        if regulars[i] != str(target):\n            while temp_counter <= 2 * n and str(temp_counter) in files_set:\n                temp_counter += 1\n            moves.append(f\"move {regulars[i]} {temp_counter}\")\n            regulars[i] = str(temp_counter)\n            temp_counter += 1\n            \n        if regulars[i] != str(target):\n            moves.append(f\"move {regulars[i]} {target}\")\n    \n    return moves\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split('\\n')\n\nn = int(data[0])\nfiles = data[1:n+1]\n\nfiles_set = set(file.split()[0] for file in files)\n\nmoves = rename_files(n, files)\nprint(len(moves))\nfor move in moves:\n    print(move)\n",
        "counter_example": {
            "input": "5\n01 0\n2 1\n2extra 0\n3 1\n99 0\n",
            "expected": "4\nmove 3 1\nmove 01 5\nmove 2extra 4\nmove 99 3\n",
            "got": "10\nmove 2 6\nmove 6 1\nmove 3 7\nmove 7 2\nmove 01 8\nmove 8 3\nmove 2extra 9\nmove 9 4\nmove 99 10\nmove 10 5"
        }
    }
]