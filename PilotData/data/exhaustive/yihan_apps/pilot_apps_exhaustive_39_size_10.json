[
    {
        "task_id": "0251",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "There is a toy building consisting of $n$ towers. Each tower consists of several cubes standing on each other. The $i$-th tower consists of $h_i$ cubes, so it has height $h_i$.\n\nLet's define operation slice on some height $H$ as following: for each tower $i$, if its height is greater than $H$, then remove some top cubes to make tower's height equal to $H$. Cost of one \"slice\" equals to the total number of removed cubes from all towers.\n\nLet's name slice as good one if its cost is lower or equal to $k$ ($k \\ge n$).\n\n [Image] \n\nCalculate the minimum number of good slices you have to do to make all towers have the same height. Of course, it is always possible to make it so.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($1 \\le n \\le 2 \\cdot 10^5$, $n \\le k \\le 10^9$) — the number of towers and the restriction on slices, respectively.\n\nThe second line contains $n$ space separated integers $h_1, h_2, \\dots, h_n$ ($1 \\le h_i \\le 2 \\cdot 10^5$) — the initial heights of towers.\n\n\n-----Output-----\n\nPrint one integer — the minimum number of good slices you have to do to make all towers have the same heigth.\n\n\n-----Examples-----\nInput\n5 5\n3 1 2 2 4\n\nOutput\n2\n\nInput\n4 5\n2 3 4 5\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first example it's optimal to make $2$ slices. The first slice is on height $2$ (its cost is $3$), and the second one is on height $1$ (its cost is $4$).",
        "generated_code": "n, k = map(int, input().split())\nh = list(map(int, input().split()))\n\nh.sort()\nres = float('inf')\nl, r = 1, max(h)\n\nwhile l <= r:\n    mid = (l + r) // 2\n    cnt = sum(max(0, hi - mid) for hi in h)\n    if cnt <= k:\n        res = min(res, len(h) - h.index(mid) - (h.count(mid) - 1))\n        r = mid - 1\n    else:\n        l = mid + 1\n\nprint(res)\n",
        "counter_example": {
            "input": "5 5\n3 1 2 2 4\n",
            "expected": "2\n",
            "got": "3"
        }
    },
    {
        "task_id": "0251",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "There is a toy building consisting of $n$ towers. Each tower consists of several cubes standing on each other. The $i$-th tower consists of $h_i$ cubes, so it has height $h_i$.\n\nLet's define operation slice on some height $H$ as following: for each tower $i$, if its height is greater than $H$, then remove some top cubes to make tower's height equal to $H$. Cost of one \"slice\" equals to the total number of removed cubes from all towers.\n\nLet's name slice as good one if its cost is lower or equal to $k$ ($k \\ge n$).\n\n [Image] \n\nCalculate the minimum number of good slices you have to do to make all towers have the same height. Of course, it is always possible to make it so.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($1 \\le n \\le 2 \\cdot 10^5$, $n \\le k \\le 10^9$) — the number of towers and the restriction on slices, respectively.\n\nThe second line contains $n$ space separated integers $h_1, h_2, \\dots, h_n$ ($1 \\le h_i \\le 2 \\cdot 10^5$) — the initial heights of towers.\n\n\n-----Output-----\n\nPrint one integer — the minimum number of good slices you have to do to make all towers have the same heigth.\n\n\n-----Examples-----\nInput\n5 5\n3 1 2 2 4\n\nOutput\n2\n\nInput\n4 5\n2 3 4 5\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first example it's optimal to make $2$ slices. The first slice is on height $2$ (its cost is $3$), and the second one is on height $1$ (its cost is $4$).",
        "generated_code": "def min_slices_to_uniform_height(n, k, heights):\n    heights.sort(reverse=True)\n    slices = 0\n    current_total_removed = 0\n    current_height = heights[0]\n    \n    for i in range(n):\n        if i > 0 and heights[i] != current_height:\n            current_height = heights[i - 1]\n            removed_per_tower = current_height - heights[i]\n            total_removed = removed_per_tower * i\n            \n            if current_total_removed + total_removed > k:\n                slices += 1\n                current_total_removed = 0\n            current_total_removed += total_removed\n        \n        current_height = heights[i]\n    \n    if current_total_removed > 0:\n        slices += 1\n    \n    return slices\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nheights = list(map(int, data[2:]))\n\n# Get result and print it\nresult = min_slices_to_uniform_height(n, k, heights)\nprint(result)\n",
        "counter_example": {
            "input": "2 2\n1 9\n",
            "expected": "4\n",
            "got": "2"
        }
    },
    {
        "task_id": "0204",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Monocarp has decided to buy a new TV set and hang it on the wall in his flat. The wall has enough free space so Monocarp can buy a TV set with screen width not greater than $a$ and screen height not greater than $b$. Monocarp is also used to TV sets with a certain aspect ratio: formally, if the width of the screen is $w$, and the height of the screen is $h$, then the following condition should be met: $\\frac{w}{h} = \\frac{x}{y}$.\n\nThere are many different TV sets in the shop. Monocarp is sure that for any pair of positive integers $w$ and $h$ there is a TV set with screen width $w$ and height $h$ in the shop.\n\nMonocarp isn't ready to choose the exact TV set he is going to buy. Firstly he wants to determine the optimal screen resolution. He has decided to try all possible variants of screen size. But he must count the number of pairs of positive integers $w$ and $h$, beforehand, such that $(w \\le a)$, $(h \\le b)$ and $(\\frac{w}{h} = \\frac{x}{y})$.\n\nIn other words, Monocarp wants to determine the number of TV sets having aspect ratio $\\frac{x}{y}$, screen width not exceeding $a$, and screen height not exceeding $b$. Two TV sets are considered different if they have different screen width or different screen height.\n\n\n-----Input-----\n\nThe first line contains four integers $a$, $b$, $x$, $y$ ($1 \\le a, b, x, y \\le 10^{18}$) — the constraints on the screen width and height, and on the aspect ratio.\n\n\n-----Output-----\n\nPrint one integer — the number of different variants to choose TV screen width and screen height so that they meet the aforementioned constraints.\n\n\n-----Examples-----\nInput\n17 15 5 3\n\nOutput\n3\n\nInput\n14 16 7 22\n\nOutput\n0\n\nInput\n4 2 6 4\n\nOutput\n1\n\nInput\n1000000000000000000 1000000000000000000 999999866000004473 999999822000007597\n\nOutput\n1000000063\n\n\n\n-----Note-----\n\nIn the first example, there are $3$ possible variants: $(5, 3)$, $(10, 6)$, $(15, 9)$.\n\nIn the second example, there is no TV set meeting the constraints.\n\nIn the third example, there is only one variant: $(3, 2)$.",
        "generated_code": "a, b, x, y = map(int, input().split())\nans = 0\nfor w in range(x, a + 1, x):\n    h = w * y // x\n    if h <= b:\n        ans += 1\nprint(ans)\n",
        "counter_example": {
            "input": "4 2 6 4\n",
            "expected": "1\n",
            "got": "0"
        }
    },
    {
        "task_id": "0204",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Monocarp has decided to buy a new TV set and hang it on the wall in his flat. The wall has enough free space so Monocarp can buy a TV set with screen width not greater than $a$ and screen height not greater than $b$. Monocarp is also used to TV sets with a certain aspect ratio: formally, if the width of the screen is $w$, and the height of the screen is $h$, then the following condition should be met: $\\frac{w}{h} = \\frac{x}{y}$.\n\nThere are many different TV sets in the shop. Monocarp is sure that for any pair of positive integers $w$ and $h$ there is a TV set with screen width $w$ and height $h$ in the shop.\n\nMonocarp isn't ready to choose the exact TV set he is going to buy. Firstly he wants to determine the optimal screen resolution. He has decided to try all possible variants of screen size. But he must count the number of pairs of positive integers $w$ and $h$, beforehand, such that $(w \\le a)$, $(h \\le b)$ and $(\\frac{w}{h} = \\frac{x}{y})$.\n\nIn other words, Monocarp wants to determine the number of TV sets having aspect ratio $\\frac{x}{y}$, screen width not exceeding $a$, and screen height not exceeding $b$. Two TV sets are considered different if they have different screen width or different screen height.\n\n\n-----Input-----\n\nThe first line contains four integers $a$, $b$, $x$, $y$ ($1 \\le a, b, x, y \\le 10^{18}$) — the constraints on the screen width and height, and on the aspect ratio.\n\n\n-----Output-----\n\nPrint one integer — the number of different variants to choose TV screen width and screen height so that they meet the aforementioned constraints.\n\n\n-----Examples-----\nInput\n17 15 5 3\n\nOutput\n3\n\nInput\n14 16 7 22\n\nOutput\n0\n\nInput\n4 2 6 4\n\nOutput\n1\n\nInput\n1000000000000000000 1000000000000000000 999999866000004473 999999822000007597\n\nOutput\n1000000063\n\n\n\n-----Note-----\n\nIn the first example, there are $3$ possible variants: $(5, 3)$, $(10, 6)$, $(15, 9)$.\n\nIn the second example, there is no TV set meeting the constraints.\n\nIn the third example, there is only one variant: $(3, 2)$.",
        "generated_code": "import math\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Reduce the ratio x/y to its irreducible form\ng = math.gcd(x, y)\nx = x // g\ny = y // g\n\n# Calculate the maximum k that satisfies the conditions\nmax_k = min(a // x, b // y)\n\n# Print the result\nprint(max_k)\n",
        "counter_example": null
    },
    {
        "task_id": "0106",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Есть n-подъездный дом, в каждом подъезде по m этажей, и на каждом этаже каждого подъезда ровно k квартир. Таким образом, в доме всего n·m·k квартир. Они пронумерованы естественным образом от 1 до n·m·k, то есть первая квартира на первом этаже в первом подъезде имеет номер 1, первая квартира на втором этаже первого подъезда имеет номер k + 1 и так далее. Особенность этого дома состоит в том, что он круглый. То есть если обходить его по часовой стрелке, то после подъезда номер 1 следует подъезд номер 2, затем подъезд номер 3 и так далее до подъезда номер n. После подъезда номер n снова идёт подъезд номер 1.\n\nЭдвард живёт в квартире номер a, а Наташа — в квартире номер b. Переход на 1 этаж вверх или вниз по лестнице занимает 5 секунд, переход от двери подъезда к двери соседнего подъезда — 15 секунд, а переход в пределах одного этажа одного подъезда происходит мгновенно. Также в каждом подъезде дома есть лифт. Он устроен следующим образом: он всегда приезжает ровно через 10 секунд после вызова, а чтобы переместить пассажира на один этаж вверх или вниз, лифт тратит ровно 1 секунду. Посадка и высадка происходят мгновенно.\n\nПомогите Эдварду найти минимальное время, за которое он сможет добраться до квартиры Наташи. Считайте, что Эдвард может выйти из подъезда только с первого этажа соответствующего подъезда (это происходит мгновенно). Если Эдвард стоит перед дверью какого-то подъезда, он может зайти в него и сразу окажется на первом этаже этого подъезда (это также происходит мгновенно). Эдвард может выбирать, в каком направлении идти вокруг дома.\n\n\n-----Входные данные-----\n\nВ первой строке входных данных следуют три числа n, m, k (1 ≤ n, m, k ≤ 1000) — количество подъездов в доме, количество этажей в каждом подъезде и количество квартир на каждом этаже каждого подъезда соответственно.\n\nВо второй строке входных данных записаны два числа a и b (1 ≤ a, b ≤ n·m·k) — номера квартир, в которых живут Эдвард и Наташа, соответственно. Гарантируется, что эти номера различны. \n\n\n-----Выходные данные-----\n\nВыведите единственное целое число — минимальное время (в секундах), за которое Эдвард сможет добраться от своей квартиры до квартиры Наташи.\n\n\n-----Примеры-----\nВходные данные\n4 10 5\n200 6\n\nВыходные данные\n39\n\nВходные данные\n3 1 5\n7 2\n\nВыходные данные\n15\n\n\n\n-----Примечание-----\n\nВ первом тестовом примере Эдвард находится в 4 подъезде на 10 этаже, а Наташа находится в 1 подъезде на 2 этаже. Поэтому Эдварду выгодно сначала спуститься на лифте на первый этаж (на это он потратит 19 секунд, из которых 10 — на ожидание и 9 — на поездку на лифте), затем обойти дом против часовой стрелки до подъезда номер 1 (на это он потратит 15 секунд), и наконец подняться по лестнице на этаж номер 2 (на это он потратит 5 секунд). Таким образом, ответ равен 19 + 15 + 5 = 39.\n\nВо втором тестовом примере Эдвард живёт в подъезде 2 на этаже 1, а Наташа находится в подъезде 1 на этаже 1. Поэтому Эдварду выгодно просто обойти дом по часовой стрелке до подъезда 1, на это он потратит 15 секунд.",
        "generated_code": "n, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate the floor and block number of Edward and Natasha\na_floor = (a - 1) % m + 1\na_block = (a - 1) // (m * k) + 1\nb_floor = (b - 1) % m + 1\nb_block = (b - 1) // (m * k) + 1\n\n# Calculate the minimum time to reach Natasha's block\nmin_block_time = min(abs(a_block - b_block), n - abs(a_block - b_block)) * 15\n\n# Calculate the minimum time to reach Natasha's floor\nif a_floor > b_floor:\n    min_floor_time = (a_floor - b_floor) * 5 + 10\nelse:\n    min_floor_time = (b_floor - a_floor) * 5 + 10\n\nprint(min_block_time + min_floor_time)\n",
        "counter_example": {
            "input": "4 10 5\n200 6\n",
            "expected": "39\n",
            "got": "45"
        }
    },
    {
        "task_id": "0106",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Есть n-подъездный дом, в каждом подъезде по m этажей, и на каждом этаже каждого подъезда ровно k квартир. Таким образом, в доме всего n·m·k квартир. Они пронумерованы естественным образом от 1 до n·m·k, то есть первая квартира на первом этаже в первом подъезде имеет номер 1, первая квартира на втором этаже первого подъезда имеет номер k + 1 и так далее. Особенность этого дома состоит в том, что он круглый. То есть если обходить его по часовой стрелке, то после подъезда номер 1 следует подъезд номер 2, затем подъезд номер 3 и так далее до подъезда номер n. После подъезда номер n снова идёт подъезд номер 1.\n\nЭдвард живёт в квартире номер a, а Наташа — в квартире номер b. Переход на 1 этаж вверх или вниз по лестнице занимает 5 секунд, переход от двери подъезда к двери соседнего подъезда — 15 секунд, а переход в пределах одного этажа одного подъезда происходит мгновенно. Также в каждом подъезде дома есть лифт. Он устроен следующим образом: он всегда приезжает ровно через 10 секунд после вызова, а чтобы переместить пассажира на один этаж вверх или вниз, лифт тратит ровно 1 секунду. Посадка и высадка происходят мгновенно.\n\nПомогите Эдварду найти минимальное время, за которое он сможет добраться до квартиры Наташи. Считайте, что Эдвард может выйти из подъезда только с первого этажа соответствующего подъезда (это происходит мгновенно). Если Эдвард стоит перед дверью какого-то подъезда, он может зайти в него и сразу окажется на первом этаже этого подъезда (это также происходит мгновенно). Эдвард может выбирать, в каком направлении идти вокруг дома.\n\n\n-----Входные данные-----\n\nВ первой строке входных данных следуют три числа n, m, k (1 ≤ n, m, k ≤ 1000) — количество подъездов в доме, количество этажей в каждом подъезде и количество квартир на каждом этаже каждого подъезда соответственно.\n\nВо второй строке входных данных записаны два числа a и b (1 ≤ a, b ≤ n·m·k) — номера квартир, в которых живут Эдвард и Наташа, соответственно. Гарантируется, что эти номера различны. \n\n\n-----Выходные данные-----\n\nВыведите единственное целое число — минимальное время (в секундах), за которое Эдвард сможет добраться от своей квартиры до квартиры Наташи.\n\n\n-----Примеры-----\nВходные данные\n4 10 5\n200 6\n\nВыходные данные\n39\n\nВходные данные\n3 1 5\n7 2\n\nВыходные данные\n15\n\n\n\n-----Примечание-----\n\nВ первом тестовом примере Эдвард находится в 4 подъезде на 10 этаже, а Наташа находится в 1 подъезде на 2 этаже. Поэтому Эдварду выгодно сначала спуститься на лифте на первый этаж (на это он потратит 19 секунд, из которых 10 — на ожидание и 9 — на поездку на лифте), затем обойти дом против часовой стрелки до подъезда номер 1 (на это он потратит 15 секунд), и наконец подняться по лестнице на этаж номер 2 (на это он потратит 5 секунд). Таким образом, ответ равен 19 + 15 + 5 = 39.\n\nВо втором тестовом примере Эдвард живёт в подъезде 2 на этаже 1, а Наташа находится в подъезде 1 на этаже 1. Поэтому Эдварду выгодно просто обойти дом по часовой стрелке до подъезда 1, на это он потратит 15 секунд.",
        "generated_code": "# Function to calculate minimum time for Edward to reach Natasha's apartment\ndef min_time_to_reach(n, m, k, a, b):\n    # Calculating block, floor, and apartment within floor for both apartments\n    def get_location(apartment):\n        block = (apartment - 1) // (m * k) + 1\n        floor_within_block = (apartment - 1) % (m * k)\n        floor = floor_within_block // k + 1\n        return block, floor\n\n    block_a, floor_a = get_location(a)\n    block_b, floor_b = get_location(b)\n    \n    # Time to get from floor_a to floor 1 using the elevator\n    if floor_a == 1:\n        time_to_exit = 0\n    else:\n        time_to_exit = 10 + (floor_a - 1)\n    \n    # Time to walk between the blocks\n    direct_walk_time = (abs(block_a - block_b) % n) * 15\n    reverse_walk_time = (n - abs(block_a - block_b)) % n * 15\n    min_walk_time = min(direct_walk_time, reverse_walk_time)\n\n    # Time to go from floor 1 in block_b to floor_b\n    time_to_target_floor = (floor_b - 1) * 5\n    \n    # Total time\n    total_time = time_to_exit + min_walk_time + time_to_target_floor\n    return total_time\n\n# Reading input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Computing the result\nresult = min_time_to_reach(n, m, k, a, b)\n\n# Printing the result\nprint(result)\n",
        "counter_example": {
            "input": "100 100 100\n1 1000000\n",
            "expected": "124\n",
            "got": "510"
        }
    },
    {
        "task_id": "0273",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": true,
        "description": "The preferred way to generate user login in Polygon is to concatenate a prefix of the user's first name and a prefix of their last name, in that order. Each prefix must be non-empty, and any of the prefixes can be the full name. Typically there are multiple possible logins for each person.\n\nYou are given the first and the last name of a user. Return the alphabetically earliest login they can get (regardless of other potential Polygon users).\n\nAs a reminder, a prefix of a string s is its substring which occurs at the beginning of s: \"a\", \"ab\", \"abc\" etc. are prefixes of string \"{abcdef}\" but \"b\" and 'bc\" are not. A string a is alphabetically earlier than a string b, if a is a prefix of b, or a and b coincide up to some position, and then a has a letter that is alphabetically earlier than the corresponding letter in b: \"a\" and \"ab\" are alphabetically earlier than \"ac\" but \"b\" and \"ba\" are alphabetically later than \"ac\".\n\n\n-----Input-----\n\nThe input consists of a single line containing two space-separated strings: the first and the last names. Each character of each string is a lowercase English letter. The length of each string is between 1 and 10, inclusive. \n\n\n-----Output-----\n\nOutput a single string — alphabetically earliest possible login formed from these names. The output should be given in lowercase as well.\n\n\n-----Examples-----\nInput\nharry potter\n\nOutput\nhap\n\nInput\ntom riddle\n\nOutput\ntomr",
        "generated_code": "first_name, last_name = input().split()\nlogin = ''\nfor i in range(1, len(first_name) + 1):\n    for j in range(1, len(last_name) + 1):\n        login = min(login, first_name[:i] + last_name[:j]) if login else first_name[:i] + last_name[:j]\nprint(login)\n",
        "counter_example": null
    },
    {
        "task_id": "0273",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "The preferred way to generate user login in Polygon is to concatenate a prefix of the user's first name and a prefix of their last name, in that order. Each prefix must be non-empty, and any of the prefixes can be the full name. Typically there are multiple possible logins for each person.\n\nYou are given the first and the last name of a user. Return the alphabetically earliest login they can get (regardless of other potential Polygon users).\n\nAs a reminder, a prefix of a string s is its substring which occurs at the beginning of s: \"a\", \"ab\", \"abc\" etc. are prefixes of string \"{abcdef}\" but \"b\" and 'bc\" are not. A string a is alphabetically earlier than a string b, if a is a prefix of b, or a and b coincide up to some position, and then a has a letter that is alphabetically earlier than the corresponding letter in b: \"a\" and \"ab\" are alphabetically earlier than \"ac\" but \"b\" and \"ba\" are alphabetically later than \"ac\".\n\n\n-----Input-----\n\nThe input consists of a single line containing two space-separated strings: the first and the last names. Each character of each string is a lowercase English letter. The length of each string is between 1 and 10, inclusive. \n\n\n-----Output-----\n\nOutput a single string — alphabetically earliest possible login formed from these names. The output should be given in lowercase as well.\n\n\n-----Examples-----\nInput\nharry potter\n\nOutput\nhap\n\nInput\ntom riddle\n\nOutput\ntomr",
        "generated_code": "# Read input\nfirst_name, last_name = input().split()\n\n# Initialize the earliest_login with a combination of the whole first name and one character of the last name\nearliest_login = first_name + last_name[0]\n\n# Iterate through each possible prefix of the first name\nfor i in range(1, len(first_name) + 1):\n    # Iterate through each possible prefix of the last name\n    for j in range(1, len(last_name) + 1):\n        # Form the login by concatenating the prefixes\n        login = first_name[:i] + last_name[:j]\n        \n        # Update the earliest_login if the current one is alphabetically earlier\n        if login < earliest_login:\n            earliest_login = login\n\n# Print the result\nprint(earliest_login)\n",
        "counter_example": null
    },
    {
        "task_id": "0041",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": true,
        "description": "You are given the array of integer numbers a_0, a_1, ..., a_{n} - 1. For each element find the distance to the nearest zero (to the element which equals to zero). There is at least one zero element in the given array.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 2·10^5) — length of the array a. The second line contains integer elements of the array separated by single spaces ( - 10^9 ≤ a_{i} ≤ 10^9).\n\n\n-----Output-----\n\nPrint the sequence d_0, d_1, ..., d_{n} - 1, where d_{i} is the difference of indices between i and nearest j such that a_{j} = 0. It is possible that i = j.\n\n\n-----Examples-----\nInput\n9\n2 1 0 3 0 0 3 2 4\n\nOutput\n2 1 0 1 0 0 1 2 3 \nInput\n5\n0 1 2 3 4\n\nOutput\n0 1 2 3 4 \nInput\n7\n5 6 0 1 -2 3 4\n\nOutput\n2 1 0 1 2 3 4",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\nd = [0] * n\nleft = float('inf')\nfor i in range(n):\n    if a[i] == 0:\n        left = 0\n    else:\n        left += 1\n    d[i] = left\nright = float('inf')\nfor i in range(n-1, -1, -1):\n    if a[i] == 0:\n        right = 0\n    else:\n        right += 1\n    d[i] = min(d[i], right)\nprint(' '.join(map(str, d)))\n",
        "counter_example": null
    },
    {
        "task_id": "0041",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "You are given the array of integer numbers a_0, a_1, ..., a_{n} - 1. For each element find the distance to the nearest zero (to the element which equals to zero). There is at least one zero element in the given array.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 2·10^5) — length of the array a. The second line contains integer elements of the array separated by single spaces ( - 10^9 ≤ a_{i} ≤ 10^9).\n\n\n-----Output-----\n\nPrint the sequence d_0, d_1, ..., d_{n} - 1, where d_{i} is the difference of indices between i and nearest j such that a_{j} = 0. It is possible that i = j.\n\n\n-----Examples-----\nInput\n9\n2 1 0 3 0 0 3 2 4\n\nOutput\n2 1 0 1 0 0 1 2 3 \nInput\n5\n0 1 2 3 4\n\nOutput\n0 1 2 3 4 \nInput\n7\n5 6 0 1 -2 3 4\n\nOutput\n2 1 0 1 2 3 4",
        "generated_code": "# Read the input values\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the output array with a large value\nd = [float('inf')] * n\n\n# First pass: from left to right\nlast_zero = -1\nfor i in range(n):\n    if a[i] == 0:\n        last_zero = i\n    if last_zero != -1:\n        d[i] = i - last_zero\n\n# Second pass: from right to left\nlast_zero = -1\nfor i in range(n-1, -1, -1):\n    if a[i] == 0:\n        last_zero = i\n    if last_zero != -1:\n        d[i] = min(d[i], last_zero - i)\n\n# Print the result\nprint(' '.join(map(str, d)))\n",
        "counter_example": null
    }
]