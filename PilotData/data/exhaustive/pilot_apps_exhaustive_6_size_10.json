[
    {
        "task_id": "0019",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.\n\nAll levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by $1$. If he manages to finish the level successfully then the number of clears increases by $1$ as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).\n\nPolycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.\n\nSo he peeked at the stats $n$ times and wrote down $n$ pairs of integers — $(p_1, c_1), (p_2, c_2), \\dots, (p_n, c_n)$, where $p_i$ is the number of plays at the $i$-th moment of time and $c_i$ is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).\n\nBetween two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.\n\nFinally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.\n\nHelp him to check the correctness of his records.\n\nFor your convenience you have to answer multiple independent test cases.\n\n\n-----Input-----\n\nThe first line contains a single integer $T$ $(1 \\le T \\le 500)$ — the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$) — the number of moments of time Polycarp peeked at the stats.\n\nEach of the next $n$ lines contains two integers $p_i$ and $c_i$ ($0 \\le p_i, c_i \\le 1000$) — the number of plays and the number of clears of the level at the $i$-th moment of time.\n\nNote that the stats are given in chronological order.\n\n\n-----Output-----\n\nFor each test case print a single line.\n\nIf there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print \"YES\".\n\nOtherwise, print \"NO\".\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Example-----\nInput\n6\n3\n0 0\n1 1\n1 2\n2\n1 0\n1000 3\n4\n10 1\n15 2\n10 2\n15 2\n1\n765 432\n2\n4 4\n4 3\n5\n0 0\n1 0\n1 0\n1 0\n1 0\n\nOutput\nNO\nYES\nNO\nYES\nNO\nYES\n\n\n\n-----Note-----\n\nIn the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.\n\nThe second test case is a nice example of a Super Expert level.\n\nIn the third test case the number of plays decreased, which is impossible.\n\nThe fourth test case is probably an auto level with a single jump over the spike.\n\nIn the fifth test case the number of clears decreased, which is also impossible.\n\nNobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.",
        "generated_code": "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    plays = []\n    clears = []\n    for _ in range(n):\n        p, c = map(int, input().split())\n        plays.append(p)\n        clears.append(c)\n    ok = True\n    for i in range(1, n):\n        if plays[i] < plays[i-1] or clears[i] < clears[i-1]:\n            ok = False\n            break\n        if clears[i] > plays[i]:\n            ok = False\n            break\n    print(\"YES\" if ok else \"NO\")\n",
        "counter_example": {
            "input": "1\n2\n10 1\n11 3\n",
            "expected": "NO\n",
            "got": "YES"
        }
    },
    {
        "task_id": "0019",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.\n\nAll levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by $1$. If he manages to finish the level successfully then the number of clears increases by $1$ as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).\n\nPolycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.\n\nSo he peeked at the stats $n$ times and wrote down $n$ pairs of integers — $(p_1, c_1), (p_2, c_2), \\dots, (p_n, c_n)$, where $p_i$ is the number of plays at the $i$-th moment of time and $c_i$ is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).\n\nBetween two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.\n\nFinally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.\n\nHelp him to check the correctness of his records.\n\nFor your convenience you have to answer multiple independent test cases.\n\n\n-----Input-----\n\nThe first line contains a single integer $T$ $(1 \\le T \\le 500)$ — the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$) — the number of moments of time Polycarp peeked at the stats.\n\nEach of the next $n$ lines contains two integers $p_i$ and $c_i$ ($0 \\le p_i, c_i \\le 1000$) — the number of plays and the number of clears of the level at the $i$-th moment of time.\n\nNote that the stats are given in chronological order.\n\n\n-----Output-----\n\nFor each test case print a single line.\n\nIf there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print \"YES\".\n\nOtherwise, print \"NO\".\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Example-----\nInput\n6\n3\n0 0\n1 1\n1 2\n2\n1 0\n1000 3\n4\n10 1\n15 2\n10 2\n15 2\n1\n765 432\n2\n4 4\n4 3\n5\n0 0\n1 0\n1 0\n1 0\n1 0\n\nOutput\nNO\nYES\nNO\nYES\nNO\nYES\n\n\n\n-----Note-----\n\nIn the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.\n\nThe second test case is a nice example of a Super Expert level.\n\nIn the third test case the number of plays decreased, which is impossible.\n\nThe fourth test case is probably an auto level with a single jump over the spike.\n\nIn the fifth test case the number of clears decreased, which is also impossible.\n\nNobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.",
        "generated_code": "T = int(input())\n\nfor _ in range(T):\n    n = int(input())\n    records = []\n    for _ in range(n):\n        p, c = map(int, input().split())\n        records.append((p, c))\n    \n    valid = True\n    \n    for i in range(n):\n        p, c = records[i]\n        if c > p:\n            valid = False\n            break\n        if i > 0:\n            p_prev, c_prev = records[i-1]\n            if p < p_prev or c < c_prev or (p - p_prev) < (c - c_prev):\n                valid = False\n                break\n    \n    if valid:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "counter_example": null
    },
    {
        "task_id": "0101",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": true,
        "description": "Vasya has n burles. One bottle of Ber-Cola costs a burles and one Bars bar costs b burles. He can buy any non-negative integer number of bottles of Ber-Cola and any non-negative integer number of Bars bars.\n\nFind out if it's possible to buy some amount of bottles of Ber-Cola and Bars bars and spend exactly n burles.\n\nIn other words, you should find two non-negative integers x and y such that Vasya can buy x bottles of Ber-Cola and y Bars bars and x·a + y·b = n or tell that it's impossible.\n\n\n-----Input-----\n\nFirst line contains single integer n (1 ≤ n ≤ 10 000 000) — amount of money, that Vasya has.\n\nSecond line contains single integer a (1 ≤ a ≤ 10 000 000) — cost of one bottle of Ber-Cola.\n\nThird line contains single integer b (1 ≤ b ≤ 10 000 000) — cost of one Bars bar.\n\n\n-----Output-----\n\nIf Vasya can't buy Bars and Ber-Cola in such a way to spend exactly n burles print «NO» (without quotes).\n\nOtherwise in first line print «YES» (without quotes). In second line print two non-negative integers x and y — number of bottles of Ber-Cola and number of Bars bars Vasya should buy in order to spend exactly n burles, i.e. x·a + y·b = n. If there are multiple answers print any of them.\n\nAny of numbers x and y can be equal 0.\n\n\n-----Examples-----\nInput\n7\n2\n3\n\nOutput\nYES\n2 1\n\nInput\n100\n25\n10\n\nOutput\nYES\n0 10\n\nInput\n15\n4\n8\n\nOutput\nNO\n\nInput\n9960594\n2551\n2557\n\nOutput\nYES\n1951 1949\n\n\n\n-----Note-----\n\nIn first example Vasya can buy two bottles of Ber-Cola and one Bars bar. He will spend exactly 2·2 + 1·3 = 7 burles.\n\nIn second example Vasya can spend exactly n burles multiple ways:   buy two bottles of Ber-Cola and five Bars bars;  buy four bottles of Ber-Cola and don't buy Bars bars;  don't buy Ber-Cola and buy 10 Bars bars. \n\nIn third example it's impossible to but Ber-Cola and Bars bars in order to spend exactly n burles.",
        "generated_code": "n = int(input())\na = int(input())\nb = int(input())\n\nfor x in range(n // a + 1):\n    y = (n - x * a) // b\n    if x * a + y * b == n:\n        print('YES')\n        print(x, y)\n        exit()\n\nprint('NO')\n",
        "counter_example": null
    },
    {
        "task_id": "0101",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Vasya has n burles. One bottle of Ber-Cola costs a burles and one Bars bar costs b burles. He can buy any non-negative integer number of bottles of Ber-Cola and any non-negative integer number of Bars bars.\n\nFind out if it's possible to buy some amount of bottles of Ber-Cola and Bars bars and spend exactly n burles.\n\nIn other words, you should find two non-negative integers x and y such that Vasya can buy x bottles of Ber-Cola and y Bars bars and x·a + y·b = n or tell that it's impossible.\n\n\n-----Input-----\n\nFirst line contains single integer n (1 ≤ n ≤ 10 000 000) — amount of money, that Vasya has.\n\nSecond line contains single integer a (1 ≤ a ≤ 10 000 000) — cost of one bottle of Ber-Cola.\n\nThird line contains single integer b (1 ≤ b ≤ 10 000 000) — cost of one Bars bar.\n\n\n-----Output-----\n\nIf Vasya can't buy Bars and Ber-Cola in such a way to spend exactly n burles print «NO» (without quotes).\n\nOtherwise in first line print «YES» (without quotes). In second line print two non-negative integers x and y — number of bottles of Ber-Cola and number of Bars bars Vasya should buy in order to spend exactly n burles, i.e. x·a + y·b = n. If there are multiple answers print any of them.\n\nAny of numbers x and y can be equal 0.\n\n\n-----Examples-----\nInput\n7\n2\n3\n\nOutput\nYES\n2 1\n\nInput\n100\n25\n10\n\nOutput\nYES\n0 10\n\nInput\n15\n4\n8\n\nOutput\nNO\n\nInput\n9960594\n2551\n2557\n\nOutput\nYES\n1951 1949\n\n\n\n-----Note-----\n\nIn first example Vasya can buy two bottles of Ber-Cola and one Bars bar. He will spend exactly 2·2 + 1·3 = 7 burles.\n\nIn second example Vasya can spend exactly n burles multiple ways:   buy two bottles of Ber-Cola and five Bars bars;  buy four bottles of Ber-Cola and don't buy Bars bars;  don't buy Ber-Cola and buy 10 Bars bars. \n\nIn third example it's impossible to but Ber-Cola and Bars bars in order to spend exactly n burles.",
        "generated_code": "def main():\n    # Read input\n    n = int(input())\n    a = int(input())\n    b = int(input())\n\n    # Iterate over possible values of x from 0 to n//a\n    for x in range(n // a + 1):\n        # Check if the remaining amount can be exactly divided by b\n        if (n - x * a) % b == 0:\n            y = (n - x * a) // b\n            # Print YES and the values of x and y\n            print(\"YES\")\n            print(x, y)\n            return\n    \n    # If no valid (x, y) pair is found, print NO\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n",
        "counter_example": null
    },
    {
        "task_id": "0086",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Polycarp and Vasiliy love simple logical games. Today they play a game with infinite chessboard and one pawn for each player. Polycarp and Vasiliy move in turns, Polycarp starts. In each turn Polycarp can move his pawn from cell (x, y) to (x - 1, y) or (x, y - 1). Vasiliy can move his pawn from (x, y) to one of cells: (x - 1, y), (x - 1, y - 1) and (x, y - 1). Both players are also allowed to skip move. \n\nThere are some additional restrictions — a player is forbidden to move his pawn to a cell with negative x-coordinate or y-coordinate or to the cell containing opponent's pawn The winner is the first person to reach cell (0, 0). \n\nYou are given the starting coordinates of both pawns. Determine who will win if both of them play optimally well.\n\n\n-----Input-----\n\nThe first line contains four integers: x_{p}, y_{p}, x_{v}, y_{v} (0 ≤ x_{p}, y_{p}, x_{v}, y_{v} ≤ 10^5) — Polycarp's and Vasiliy's starting coordinates.\n\nIt is guaranteed that in the beginning the pawns are in different cells and none of them is in the cell (0, 0).\n\n\n-----Output-----\n\nOutput the name of the winner: \"Polycarp\" or \"Vasiliy\".\n\n\n-----Examples-----\nInput\n2 1 2 2\n\nOutput\nPolycarp\n\nInput\n4 7 7 4\n\nOutput\nVasiliy\n\n\n\n-----Note-----\n\nIn the first sample test Polycarp starts in (2, 1) and will move to (1, 1) in the first turn. No matter what his opponent is doing, in the second turn Polycarp can move to (1, 0) and finally to (0, 0) in the third turn.",
        "generated_code": "x_p, y_p, x_v, y_v = map(int, input().split())\n\nif x_p <= x_v and y_p <= y_v:\n    print(\"Polycarp\")\nelse:\n    print(\"Vasiliy\")\n",
        "counter_example": {
            "input": "20 0 7 22\n",
            "expected": "Polycarp\n",
            "got": "Vasiliy"
        }
    },
    {
        "task_id": "0086",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Polycarp and Vasiliy love simple logical games. Today they play a game with infinite chessboard and one pawn for each player. Polycarp and Vasiliy move in turns, Polycarp starts. In each turn Polycarp can move his pawn from cell (x, y) to (x - 1, y) or (x, y - 1). Vasiliy can move his pawn from (x, y) to one of cells: (x - 1, y), (x - 1, y - 1) and (x, y - 1). Both players are also allowed to skip move. \n\nThere are some additional restrictions — a player is forbidden to move his pawn to a cell with negative x-coordinate or y-coordinate or to the cell containing opponent's pawn The winner is the first person to reach cell (0, 0). \n\nYou are given the starting coordinates of both pawns. Determine who will win if both of them play optimally well.\n\n\n-----Input-----\n\nThe first line contains four integers: x_{p}, y_{p}, x_{v}, y_{v} (0 ≤ x_{p}, y_{p}, x_{v}, y_{v} ≤ 10^5) — Polycarp's and Vasiliy's starting coordinates.\n\nIt is guaranteed that in the beginning the pawns are in different cells and none of them is in the cell (0, 0).\n\n\n-----Output-----\n\nOutput the name of the winner: \"Polycarp\" or \"Vasiliy\".\n\n\n-----Examples-----\nInput\n2 1 2 2\n\nOutput\nPolycarp\n\nInput\n4 7 7 4\n\nOutput\nVasiliy\n\n\n\n-----Note-----\n\nIn the first sample test Polycarp starts in (2, 1) and will move to (1, 1) in the first turn. No matter what his opponent is doing, in the second turn Polycarp can move to (1, 0) and finally to (0, 0) in the third turn.",
        "generated_code": "# Read input from standard input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Calculate the maximum distances to (0, 0) for both players\npolycarp_distance = max(x_p, y_p)\nvasiliy_distance = max(x_v, y_v)\n\n# Determine the winner based on the distances\nif polycarp_distance <= vasiliy_distance:\n    print(\"Polycarp\")\nelse:\n    print(\"Vasiliy\")\n",
        "counter_example": {
            "input": "4 7 7 4\n",
            "expected": "Vasiliy\n",
            "got": "Polycarp"
        }
    },
    {
        "task_id": "0108",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "You are given a string s consisting of |s| small english letters.\n\nIn one move you can replace any character of this string to the next character in alphabetical order (a will be replaced with b, s will be replaced with t, etc.). You cannot replace letter z with any other letter.\n\nYour target is to make some number of moves (not necessary minimal) to get string abcdefghijklmnopqrstuvwxyz (english alphabet) as a subsequence. Subsequence of the string is the string that is obtained by deleting characters at some positions. You need to print the string that will be obtained from the given string and will be contain english alphabet as a subsequence or say that it is impossible.\n\n\n-----Input-----\n\nThe only one line of the input consisting of the string s consisting of |s| (1 ≤ |s| ≤ 10^5) small english letters.\n\n\n-----Output-----\n\nIf you can get a string that can be obtained from the given string and will contain english alphabet as a subsequence, print it. Otherwise print «-1» (without quotes).\n\n\n-----Examples-----\nInput\naacceeggiikkmmooqqssuuwwyy\n\nOutput\nabcdefghijklmnopqrstuvwxyz\n\nInput\nthereisnoanswer\n\nOutput\n-1",
        "generated_code": "s = input()\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nres = ''\nfor char in alphabet:\n    while char in s:\n        res += char\n        s = s.replace(char, chr(ord(char) + 1), 1)\nif len(res) == 26:\n    print(res)\nelse:\n    print(-1)\n",
        "counter_example": {
            "input": "aacceeggiikkmmooqqssuuwwyy\n",
            "expected": "abcdefghijklmnopqrstuvwxyz\n",
            "got": "-1"
        }
    },
    {
        "task_id": "0108",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "You are given a string s consisting of |s| small english letters.\n\nIn one move you can replace any character of this string to the next character in alphabetical order (a will be replaced with b, s will be replaced with t, etc.). You cannot replace letter z with any other letter.\n\nYour target is to make some number of moves (not necessary minimal) to get string abcdefghijklmnopqrstuvwxyz (english alphabet) as a subsequence. Subsequence of the string is the string that is obtained by deleting characters at some positions. You need to print the string that will be obtained from the given string and will be contain english alphabet as a subsequence or say that it is impossible.\n\n\n-----Input-----\n\nThe only one line of the input consisting of the string s consisting of |s| (1 ≤ |s| ≤ 10^5) small english letters.\n\n\n-----Output-----\n\nIf you can get a string that can be obtained from the given string and will contain english alphabet as a subsequence, print it. Otherwise print «-1» (without quotes).\n\n\n-----Examples-----\nInput\naacceeggiikkmmooqqssuuwwyy\n\nOutput\nabcdefghijklmnopqrstuvwxyz\n\nInput\nthereisnoanswer\n\nOutput\n-1",
        "generated_code": "s = input()\n\n# Target alphabet sequence\ntarget = \"abcdefghijklmnopqrstuvwxyz\"\ntarget_len = len(target)\ni, j = 0, 0\n\n# Iterate over the input string and try to match the target sequence\nwhile i < len(s) and j < target_len:\n    if s[i] == target[j]:\n        j += 1\n    i += 1\n\n# If we have matched the entire target sequence, print the target\nif j == target_len:\n    print(target)\nelse:\n    print(-1)\n",
        "counter_example": {
            "input": "aacceeggiikkmmooqqssuuwwyy\n",
            "expected": "abcdefghijklmnopqrstuvwxyz\n",
            "got": "-1"
        }
    },
    {
        "task_id": "0288",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Famous Brazil city Rio de Janeiro holds a tennis tournament and Ostap Bender doesn't want to miss this event. There will be n players participating, and the tournament will follow knockout rules from the very first game. That means, that if someone loses a game he leaves the tournament immediately.\n\nOrganizers are still arranging tournament grid (i.e. the order games will happen and who is going to play with whom) but they have already fixed one rule: two players can play against each other only if the number of games one of them has already played differs by no more than one from the number of games the other one has already played. Of course, both players had to win all their games in order to continue participating in the tournament.\n\nTournament hasn't started yet so the audience is a bit bored. Ostap decided to find out what is the maximum number of games the winner of the tournament can take part in (assuming the rule above is used). However, it is unlikely he can deal with this problem without your help.\n\n\n-----Input-----\n\nThe only line of the input contains a single integer n (2 ≤ n ≤ 10^18) — the number of players to participate in the tournament.\n\n\n-----Output-----\n\nPrint the maximum number of games in which the winner of the tournament can take part.\n\n\n-----Examples-----\nInput\n2\n\nOutput\n1\n\nInput\n3\n\nOutput\n2\n\nInput\n4\n\nOutput\n2\n\nInput\n10\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn all samples we consider that player number 1 is the winner.\n\nIn the first sample, there would be only one game so the answer is 1.\n\nIn the second sample, player 1 can consequently beat players 2 and 3. \n\nIn the third sample, player 1 can't play with each other player as after he plays with players 2 and 3 he can't play against player 4, as he has 0 games played, while player 1 already played 2. Thus, the answer is 2 and to achieve we make pairs (1, 2) and (3, 4) and then clash the winners.",
        "generated_code": "n = int(input())\nprint(n.bit_length() - 1)\n",
        "counter_example": {
            "input": "3\n",
            "expected": "2\n",
            "got": "1"
        }
    },
    {
        "task_id": "0288",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Famous Brazil city Rio de Janeiro holds a tennis tournament and Ostap Bender doesn't want to miss this event. There will be n players participating, and the tournament will follow knockout rules from the very first game. That means, that if someone loses a game he leaves the tournament immediately.\n\nOrganizers are still arranging tournament grid (i.e. the order games will happen and who is going to play with whom) but they have already fixed one rule: two players can play against each other only if the number of games one of them has already played differs by no more than one from the number of games the other one has already played. Of course, both players had to win all their games in order to continue participating in the tournament.\n\nTournament hasn't started yet so the audience is a bit bored. Ostap decided to find out what is the maximum number of games the winner of the tournament can take part in (assuming the rule above is used). However, it is unlikely he can deal with this problem without your help.\n\n\n-----Input-----\n\nThe only line of the input contains a single integer n (2 ≤ n ≤ 10^18) — the number of players to participate in the tournament.\n\n\n-----Output-----\n\nPrint the maximum number of games in which the winner of the tournament can take part.\n\n\n-----Examples-----\nInput\n2\n\nOutput\n1\n\nInput\n3\n\nOutput\n2\n\nInput\n4\n\nOutput\n2\n\nInput\n10\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn all samples we consider that player number 1 is the winner.\n\nIn the first sample, there would be only one game so the answer is 1.\n\nIn the second sample, player 1 can consequently beat players 2 and 3. \n\nIn the third sample, player 1 can't play with each other player as after he plays with players 2 and 3 he can't play against player 4, as he has 0 games played, while player 1 already played 2. Thus, the answer is 2 and to achieve we make pairs (1, 2) and (3, 4) and then clash the winners.",
        "generated_code": "n = int(input())\n\n# The maximum number of games the winner can play is essentially the maximum number of times\n# we can divide the number of players by 2 (which is equivalent to finding the highest power\n# of 2 less than or equal to n).\nmax_games = n.bit_length() - 1\n\nprint(max_games)\n",
        "counter_example": {
            "input": "3\n",
            "expected": "2\n",
            "got": "1"
        }
    }
]