[
    {
        "task_id": "0159",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": true,
        "description": "You are given an array of n elements, you must make it a co-prime array in as few moves as possible.\n\nIn each move you can insert any positive integral number you want not greater than 10^9 in any place in the array.\n\nAn array is co-prime if any two adjacent numbers of it are co-prime.\n\nIn the number theory, two integers a and b are said to be co-prime if the only positive integer that divides both of them is 1.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 1000) — the number of elements in the given array.\n\nThe second line contains n integers a_{i} (1 ≤ a_{i} ≤ 10^9) — the elements of the array a.\n\n\n-----Output-----\n\nPrint integer k on the first line — the least number of elements needed to add to the array a to make it co-prime.\n\nThe second line should contain n + k integers a_{j} — the elements of the array a after adding k elements to it. Note that the new array should be co-prime, so any two adjacent values should be co-prime. Also the new array should be got from the original array a by adding k elements to it.\n\nIf there are multiple answers you can print any one of them.\n\n\n-----Example-----\nInput\n3\n2 7 28\n\nOutput\n1\n2 7 9 28",
        "generated_code": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn = int(input())\narr = list(map(int, input().split()))\n\nk = 0\nans = [arr[0]]\nfor i in range(1, n):\n    if gcd(arr[i-1], arr[i]) != 1:\n        k += 1\n        for j in range(1, 10**9 + 1):\n            if gcd(arr[i-1], j) == 1 and gcd(j, arr[i]) == 1:\n                ans.append(j)\n                break\n    ans.append(arr[i])\n\nprint(k)\nprint(' '.join(map(str, ans)))\n",
        "counter_example": null
    },
    {
        "task_id": "0159",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "You are given an array of n elements, you must make it a co-prime array in as few moves as possible.\n\nIn each move you can insert any positive integral number you want not greater than 10^9 in any place in the array.\n\nAn array is co-prime if any two adjacent numbers of it are co-prime.\n\nIn the number theory, two integers a and b are said to be co-prime if the only positive integer that divides both of them is 1.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 1000) — the number of elements in the given array.\n\nThe second line contains n integers a_{i} (1 ≤ a_{i} ≤ 10^9) — the elements of the array a.\n\n\n-----Output-----\n\nPrint integer k on the first line — the least number of elements needed to add to the array a to make it co-prime.\n\nThe second line should contain n + k integers a_{j} — the elements of the array a after adding k elements to it. Note that the new array should be co-prime, so any two adjacent values should be co-prime. Also the new array should be got from the original array a by adding k elements to it.\n\nIf there are multiple answers you can print any one of them.\n\n\n-----Example-----\nInput\n3\n2 7 28\n\nOutput\n1\n2 7 9 28",
        "generated_code": "import math\n\ndef is_coprime(a, b):\n    return math.gcd(a, b) == 1\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize result array and the count of added elements\nresult = [a[0]]\ncount = 0\n\n# Iterate through the array to check adjacent pairs\nfor i in range(1, n):\n    if not is_coprime(result[-1], a[i]):\n        # Insert a number to make the pair co-prime\n        # We can always insert 1 because 1 is co-prime with any number\n        result.append(1)\n        count += 1\n    result.append(a[i])\n\n# Print the results\nprint(count)\nprint(\" \".join(map(str, result)))\n",
        "counter_example": null
    },
    {
        "task_id": "0208",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Pashmak has fallen in love with an attractive girl called Parmida since one year ago...\n\nToday, Pashmak set up a meeting with his partner in a romantic garden. Unfortunately, Pashmak has forgotten where the garden is. But he remembers that the garden looks like a square with sides parallel to the coordinate axes. He also remembers that there is exactly one tree on each vertex of the square. Now, Pashmak knows the position of only two of the trees. Help him to find the position of two remaining ones.\n\n\n-----Input-----\n\nThe first line contains four space-separated x_1, y_1, x_2, y_2 ( - 100 ≤ x_1, y_1, x_2, y_2 ≤ 100) integers, where x_1 and y_1 are coordinates of the first tree and x_2 and y_2 are coordinates of the second tree. It's guaranteed that the given points are distinct.\n\n\n-----Output-----\n\nIf there is no solution to the problem, print -1. Otherwise print four space-separated integers x_3, y_3, x_4, y_4 that correspond to the coordinates of the two other trees. If there are several solutions you can output any of them. \n\nNote that x_3, y_3, x_4, y_4 must be in the range ( - 1000 ≤ x_3, y_3, x_4, y_4 ≤ 1000).\n\n\n-----Examples-----\nInput\n0 0 0 1\n\nOutput\n1 0 1 1\n\nInput\n0 0 1 1\n\nOutput\n0 1 1 0\n\nInput\n0 0 1 2\n\nOutput\n-1",
        "generated_code": "x1, y1, x2, y2 = map(int, input().split())\n\nif x1 == x2:\n    x3, x4 = x1 + abs(y1 - y2), x1 - abs(y1 - y2)\n    y3, y4 = y1, y2\nelse:\n    y3, y4 = y1 + abs(x1 - x2), y1 - abs(x1 - x2)\n    x3, x4 = x1, x2\n\nif -1000 <= x3 <= 1000 and -1000 <= x4 <= 1000 and -1000 <= y3 <= 1000 and -1000 <= y4 <= 1000:\n    print(x3, y3, x4, y4)\nelse:\n    print(-1)\n",
        "counter_example": {
            "input": "0 0 0 1\n",
            "expected": "1 0 1 1\n",
            "got": "1 0 -1 1"
        }
    },
    {
        "task_id": "0208",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Pashmak has fallen in love with an attractive girl called Parmida since one year ago...\n\nToday, Pashmak set up a meeting with his partner in a romantic garden. Unfortunately, Pashmak has forgotten where the garden is. But he remembers that the garden looks like a square with sides parallel to the coordinate axes. He also remembers that there is exactly one tree on each vertex of the square. Now, Pashmak knows the position of only two of the trees. Help him to find the position of two remaining ones.\n\n\n-----Input-----\n\nThe first line contains four space-separated x_1, y_1, x_2, y_2 ( - 100 ≤ x_1, y_1, x_2, y_2 ≤ 100) integers, where x_1 and y_1 are coordinates of the first tree and x_2 and y_2 are coordinates of the second tree. It's guaranteed that the given points are distinct.\n\n\n-----Output-----\n\nIf there is no solution to the problem, print -1. Otherwise print four space-separated integers x_3, y_3, x_4, y_4 that correspond to the coordinates of the two other trees. If there are several solutions you can output any of them. \n\nNote that x_3, y_3, x_4, y_4 must be in the range ( - 1000 ≤ x_3, y_3, x_4, y_4 ≤ 1000).\n\n\n-----Examples-----\nInput\n0 0 0 1\n\nOutput\n1 0 1 1\n\nInput\n0 0 1 1\n\nOutput\n0 1 1 0\n\nInput\n0 0 1 2\n\nOutput\n-1",
        "generated_code": "# Read input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Check if the given points form a vertical or horizontal line\nif x1 == x2:\n    side_length = abs(y2 - y1)\n    x3, y3 = x1 + side_length, y1\n    x4, y4 = x2 + side_length, y2\n    print(x3, y3, x4, y4)\nelif y1 == y2:\n    side_length = abs(x2 - x1)\n    x3, y3 = x1, y1 + side_length\n    x4, y4 = x2, y2 + side_length\n    print(x3, y3, x4, y4)\n# Check if the given points are diagonally opposite on a square\nelif abs(x2 - x1) == abs(y2 - y1):\n    x3, y3 = x1, y2\n    x4, y4 = x2, y1\n    print(x3, y3, x4, y4)\nelse:\n    print(-1)\n",
        "counter_example": null
    },
    {
        "task_id": "0009",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Yet another round on DecoForces is coming! Grandpa Maks wanted to participate in it but someone has stolen his precious sofa! And how can one perform well with such a major loss?\n\nFortunately, the thief had left a note for Grandpa Maks. This note got Maks to the sofa storehouse. Still he had no idea which sofa belongs to him as they all looked the same!\n\nThe storehouse is represented as matrix n × m. Every sofa takes two neighbouring by some side cells. No cell is covered by more than one sofa. There can be empty cells.\n\nSofa A is standing to the left of sofa B if there exist two such cells a and b that x_{a} < x_{b}, a is covered by A and b is covered by B. Sofa A is standing to the top of sofa B if there exist two such cells a and b that y_{a} < y_{b}, a is covered by A and b is covered by B. Right and bottom conditions are declared the same way. \n\nNote that in all conditions A ≠ B. Also some sofa A can be both to the top of another sofa B and to the bottom of it. The same is for left and right conditions.\n\nThe note also stated that there are cnt_{l} sofas to the left of Grandpa Maks's sofa, cnt_{r} — to the right, cnt_{t} — to the top and cnt_{b} — to the bottom.\n\nGrandpa Maks asks you to help him to identify his sofa. It is guaranteed that there is no more than one sofa of given conditions.\n\nOutput the number of Grandpa Maks's sofa. If there is no such sofa that all the conditions are met for it then output -1.\n\n\n-----Input-----\n\nThe first line contains one integer number d (1 ≤ d ≤ 10^5) — the number of sofas in the storehouse.\n\nThe second line contains two integer numbers n, m (1 ≤ n, m ≤ 10^5) — the size of the storehouse.\n\nNext d lines contains four integer numbers x_1, y_1, x_2, y_2 (1 ≤ x_1, x_2 ≤ n, 1 ≤ y_1, y_2 ≤ m) — coordinates of the i-th sofa. It is guaranteed that cells (x_1, y_1) and (x_2, y_2) have common side, (x_1, y_1)  ≠  (x_2, y_2) and no cell is covered by more than one sofa.\n\nThe last line contains four integer numbers cnt_{l}, cnt_{r}, cnt_{t}, cnt_{b} (0 ≤ cnt_{l}, cnt_{r}, cnt_{t}, cnt_{b} ≤ d - 1).\n\n\n-----Output-----\n\nPrint the number of the sofa for which all the conditions are met. Sofas are numbered 1 through d as given in input. If there is no such sofa then print -1.\n\n\n-----Examples-----\nInput\n2\n3 2\n3 1 3 2\n1 2 2 2\n1 0 0 1\n\nOutput\n1\n\nInput\n3\n10 10\n1 2 1 1\n5 5 6 5\n6 4 5 4\n2 1 2 0\n\nOutput\n2\n\nInput\n2\n2 2\n2 1 1 1\n1 2 2 2\n1 0 0 0\n\nOutput\n-1\n\n\n\n-----Note-----\n\nLet's consider the second example.   The first sofa has 0 to its left, 2 sofas to its right ((1, 1) is to the left of both (5, 5) and (5, 4)), 0 to its top and 2 to its bottom (both 2nd and 3rd sofas are below).  The second sofa has cnt_{l} = 2, cnt_{r} = 1, cnt_{t} = 2 and cnt_{b} = 0.  The third sofa has cnt_{l} = 2, cnt_{r} = 1, cnt_{t} = 1 and cnt_{b} = 1. \n\nSo the second one corresponds to the given conditions.\n\nIn the third example   The first sofa has cnt_{l} = 1, cnt_{r} = 1, cnt_{t} = 0 and cnt_{b} = 1.  The second sofa has cnt_{l} = 1, cnt_{r} = 1, cnt_{t} = 1 and cnt_{b} = 0. \n\nAnd there is no sofa with the set (1, 0, 0, 0) so the answer is -1.",
        "generated_code": "d = int(input())\nn, m = map(int, input().split())\nsofas = []\nfor _ in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append(((x1, y1), (x2, y2)))\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_sofas(sofa, sofas):\n    left, right, top, bottom = 0, 0, 0, 0\n    for s in sofas:\n        if s != sofa:\n            if sofa[0][0] < s[0][0] and sofa[0][1] == s[0][1]:\n                left += 1\n            if sofa[0][0] > s[0][0] and sofa[0][1] == s[0][1]:\n                right += 1\n            if sofa[0][1] < s[0][1] and sofa[0][0] == s[0][0]:\n                top += 1\n            if sofa[0][1] > s[0][1] and sofa[0][0] == s[0][0]:\n                bottom += 1\n    return left, right, top, bottom\n\nfor i, sofa in enumerate(sofas):\n    left, right, top, bottom = count_sofas(sofa, sofas)\n    if (left, right, top, bottom) == (cnt_l, cnt_r, cnt_t, cnt_b):\n        print(i + 1)\n        break\nelse:\n    print(-1)\n",
        "counter_example": {
            "input": "2\n3 2\n3 1 3 2\n1 2 2 2\n1 0 0 1\n",
            "expected": "1\n",
            "got": "-1"
        }
    },
    {
        "task_id": "0009",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Yet another round on DecoForces is coming! Grandpa Maks wanted to participate in it but someone has stolen his precious sofa! And how can one perform well with such a major loss?\n\nFortunately, the thief had left a note for Grandpa Maks. This note got Maks to the sofa storehouse. Still he had no idea which sofa belongs to him as they all looked the same!\n\nThe storehouse is represented as matrix n × m. Every sofa takes two neighbouring by some side cells. No cell is covered by more than one sofa. There can be empty cells.\n\nSofa A is standing to the left of sofa B if there exist two such cells a and b that x_{a} < x_{b}, a is covered by A and b is covered by B. Sofa A is standing to the top of sofa B if there exist two such cells a and b that y_{a} < y_{b}, a is covered by A and b is covered by B. Right and bottom conditions are declared the same way. \n\nNote that in all conditions A ≠ B. Also some sofa A can be both to the top of another sofa B and to the bottom of it. The same is for left and right conditions.\n\nThe note also stated that there are cnt_{l} sofas to the left of Grandpa Maks's sofa, cnt_{r} — to the right, cnt_{t} — to the top and cnt_{b} — to the bottom.\n\nGrandpa Maks asks you to help him to identify his sofa. It is guaranteed that there is no more than one sofa of given conditions.\n\nOutput the number of Grandpa Maks's sofa. If there is no such sofa that all the conditions are met for it then output -1.\n\n\n-----Input-----\n\nThe first line contains one integer number d (1 ≤ d ≤ 10^5) — the number of sofas in the storehouse.\n\nThe second line contains two integer numbers n, m (1 ≤ n, m ≤ 10^5) — the size of the storehouse.\n\nNext d lines contains four integer numbers x_1, y_1, x_2, y_2 (1 ≤ x_1, x_2 ≤ n, 1 ≤ y_1, y_2 ≤ m) — coordinates of the i-th sofa. It is guaranteed that cells (x_1, y_1) and (x_2, y_2) have common side, (x_1, y_1)  ≠  (x_2, y_2) and no cell is covered by more than one sofa.\n\nThe last line contains four integer numbers cnt_{l}, cnt_{r}, cnt_{t}, cnt_{b} (0 ≤ cnt_{l}, cnt_{r}, cnt_{t}, cnt_{b} ≤ d - 1).\n\n\n-----Output-----\n\nPrint the number of the sofa for which all the conditions are met. Sofas are numbered 1 through d as given in input. If there is no such sofa then print -1.\n\n\n-----Examples-----\nInput\n2\n3 2\n3 1 3 2\n1 2 2 2\n1 0 0 1\n\nOutput\n1\n\nInput\n3\n10 10\n1 2 1 1\n5 5 6 5\n6 4 5 4\n2 1 2 0\n\nOutput\n2\n\nInput\n2\n2 2\n2 1 1 1\n1 2 2 2\n1 0 0 0\n\nOutput\n-1\n\n\n\n-----Note-----\n\nLet's consider the second example.   The first sofa has 0 to its left, 2 sofas to its right ((1, 1) is to the left of both (5, 5) and (5, 4)), 0 to its top and 2 to its bottom (both 2nd and 3rd sofas are below).  The second sofa has cnt_{l} = 2, cnt_{r} = 1, cnt_{t} = 2 and cnt_{b} = 0.  The third sofa has cnt_{l} = 2, cnt_{r} = 1, cnt_{t} = 1 and cnt_{b} = 1. \n\nSo the second one corresponds to the given conditions.\n\nIn the third example   The first sofa has cnt_{l} = 1, cnt_{r} = 1, cnt_{t} = 0 and cnt_{b} = 1.  The second sofa has cnt_{l} = 1, cnt_{r} = 1, cnt_{t} = 1 and cnt_{b} = 0. \n\nAnd there is no sofa with the set (1, 0, 0, 0) so the answer is -1.",
        "generated_code": "# Read the number of sofas\nd = int(input().strip())\n\n# Read the dimensions of the storehouse\nn, m = map(int, input().strip().split())\n\n# Initialize lists to store the coordinates of the sofas\nsofas = []\n\n# Read the coordinates of each sofa\nfor _ in range(d):\n    x1, y1, x2, y2 = map(int, input().strip().split())\n    sofas.append((x1, y1, x2, y2))\n\n# Read the conditions for the target sofa\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().strip().split())\n\n# Initialize counters for each sofa\nleft_count = [0] * d\nright_count = [0] * d\ntop_count = [0] * d\nbottom_count = [0] * d\n\n# Calculate the necessary counts for each sofa\nfor i in range(d):\n    x1, y1, x2, y2 = sofas[i]\n    for j in range(d):\n        if i == j:\n            continue\n        x1_j, y1_j, x2_j, y2_j = sofas[j]\n        if x1 < x1_j and x2 < x1_j:\n            right_count[i] += 1\n        if x1 > x2_j and x2 > x2_j:\n            left_count[i] += 1\n        if y1 < y1_j and y2 < y1_j:\n            bottom_count[i] += 1\n        if y1 > y2_j and y2 > y2_j:\n            top_count[i] += 1\n\n# Find the sofa that matches the given conditions\ntarget_sofa = -1\nfor i in range(d):\n    if (left_count[i] == cnt_l and right_count[i] == cnt_r and\n        top_count[i] == cnt_t and bottom_count[i] == cnt_b):\n        target_sofa = i + 1\n        break\n\n# Print the result\nprint(target_sofa)\n",
        "counter_example": {
            "input": "2\n3 2\n3 1 3 2\n1 2 2 2\n1 0 0 1\n",
            "expected": "1\n",
            "got": "-1"
        }
    },
    {
        "task_id": "0177",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Let's write all the positive integer numbers one after another from $1$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...\n\nYour task is to print the $k$-th digit of this sequence.\n\n\n-----Input-----\n\nThe first and only line contains integer $k$ ($1 \\le k \\le 10000$) — the position to process ($1$-based index).\n\n\n-----Output-----\n\nPrint the $k$-th digit of the resulting infinite sequence.\n\n\n-----Examples-----\nInput\n7\n\nOutput\n7\n\nInput\n21\n\nOutput\n5",
        "generated_code": "k = int(input())\nn, digits = 1, 1\nwhile True:\n    if k <= n * digits:\n        num = (k - 1) // digits + 10**(digits-1)\n        digit = (k - 1) % digits\n        print(int(str(num)[digit]))\n        break\n    n *= 10\n    k -= n * digits\n    digits += 1\n",
        "counter_example": {
            "input": "7\n",
            "expected": "7\n",
            "got": "8"
        }
    },
    {
        "task_id": "0177",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Let's write all the positive integer numbers one after another from $1$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...\n\nYour task is to print the $k$-th digit of this sequence.\n\n\n-----Input-----\n\nThe first and only line contains integer $k$ ($1 \\le k \\le 10000$) — the position to process ($1$-based index).\n\n\n-----Output-----\n\nPrint the $k$-th digit of the resulting infinite sequence.\n\n\n-----Examples-----\nInput\n7\n\nOutput\n7\n\nInput\n21\n\nOutput\n5",
        "generated_code": "k = int(input())\n\n# Determine the length of numbers we are currently considering\nlength = 1\ncount = 9\nstart = 1\n\n# Find the range in which the k-th digit lies\nwhile k > length * count:\n    k -= length * count\n    length += 1\n    count *= 10\n    start *= 10\n\n# Find the exact number where the k-th digit is located\nstart += (k - 1) // length\ns = str(start)\nresult = s[(k - 1) % length]\n\nprint(result)\n",
        "counter_example": null
    },
    {
        "task_id": "0008",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $1$ to $9$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $\\ldots$, 9m, 1p, 2p, $\\ldots$, 9p, 1s, 2s, $\\ldots$, 9s.\n\nIn order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.\n\nDo you know the minimum number of extra suited tiles she needs to draw so that she can win?\n\nHere are some useful definitions in this game:  A mentsu, also known as meld, is formed by a koutsu or a shuntsu;  A koutsu, also known as triplet, is made of three identical tiles, such as [1m, 1m, 1m], however, [1m, 1p, 1s] or [1m, 4m, 7m] is NOT a koutsu;  A shuntsu, also known as sequence, is made of three sequential numbered tiles in the same suit, such as [1m, 2m, 3m] and [5s, 7s, 6s], however, [9m, 1m, 2m] or [1m, 2p, 3s] is NOT a shuntsu. \n\nSome examples:   [2m, 3p, 2s, 4m, 1s, 2s, 4s] — it contains no koutsu or shuntsu, so it includes no mentsu;  [4s, 3m, 3p, 4s, 5p, 4s, 5p] — it contains a koutsu, [4s, 4s, 4s], but no shuntsu, so it includes a mentsu;  [5p, 5s, 9m, 4p, 1s, 7p, 7m, 6p] — it contains no koutsu but a shuntsu, [5p, 4p, 6p] or [5p, 7p, 6p], so it includes a mentsu. \n\nNote that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.\n\n\n-----Input-----\n\nThe only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $1$ to $9$ and the second character is m, p or s.\n\n\n-----Output-----\n\nPrint a single integer — the minimum number of extra suited tiles she needs to draw.\n\n\n-----Examples-----\nInput\n1s 2s 3s\n\nOutput\n0\n\nInput\n9m 9m 9m\n\nOutput\n0\n\nInput\n3p 9m 2p\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example, Tokitsukaze already has a shuntsu.\n\nIn the second example, Tokitsukaze already has a koutsu.\n\nIn the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].",
        "generated_code": "def count_tiles(tiles):\n    tile_count = {}\n    for tile in tiles:\n        num, suit = tile[0], tile[1]\n        if suit not in tile_count:\n            tile_count[suit] = {}\n        if num not in tile_count[suit]:\n            tile_count[suit][num] = 0\n        tile_count[suit][num] += 1\n    return tile_count\n\ndef has_koutsu(tile_count):\n    for suit in tile_count:\n        for num in tile_count[suit]:\n            if tile_count[suit][num] >= 3:\n                return True\n    return False\n\ndef has_shuntsu(tile_count):\n    for suit in tile_count:\n        nums = sorted([int(num) for num in tile_count[suit]])\n        for i in range(len(nums) - 2):\n            if nums[i] + 1 == nums[i+1] and nums[i+1] + 1 == nums[i+2]:\n                return True\n    return False\n\ntiles = input().split()\ntile_count = count_tiles(tiles)\nif has_koutsu(tile_count) or has_shuntsu(tile_count):\n    print(0)\nelse:\n    print(1)\n",
        "counter_example": {
            "input": "8p 2s 9m\n",
            "expected": "2\n",
            "got": "1"
        }
    },
    {
        "task_id": "0008",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $1$ to $9$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $\\ldots$, 9m, 1p, 2p, $\\ldots$, 9p, 1s, 2s, $\\ldots$, 9s.\n\nIn order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.\n\nDo you know the minimum number of extra suited tiles she needs to draw so that she can win?\n\nHere are some useful definitions in this game:  A mentsu, also known as meld, is formed by a koutsu or a shuntsu;  A koutsu, also known as triplet, is made of three identical tiles, such as [1m, 1m, 1m], however, [1m, 1p, 1s] or [1m, 4m, 7m] is NOT a koutsu;  A shuntsu, also known as sequence, is made of three sequential numbered tiles in the same suit, such as [1m, 2m, 3m] and [5s, 7s, 6s], however, [9m, 1m, 2m] or [1m, 2p, 3s] is NOT a shuntsu. \n\nSome examples:   [2m, 3p, 2s, 4m, 1s, 2s, 4s] — it contains no koutsu or shuntsu, so it includes no mentsu;  [4s, 3m, 3p, 4s, 5p, 4s, 5p] — it contains a koutsu, [4s, 4s, 4s], but no shuntsu, so it includes a mentsu;  [5p, 5s, 9m, 4p, 1s, 7p, 7m, 6p] — it contains no koutsu but a shuntsu, [5p, 4p, 6p] or [5p, 7p, 6p], so it includes a mentsu. \n\nNote that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.\n\n\n-----Input-----\n\nThe only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $1$ to $9$ and the second character is m, p or s.\n\n\n-----Output-----\n\nPrint a single integer — the minimum number of extra suited tiles she needs to draw.\n\n\n-----Examples-----\nInput\n1s 2s 3s\n\nOutput\n0\n\nInput\n9m 9m 9m\n\nOutput\n0\n\nInput\n3p 9m 2p\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example, Tokitsukaze already has a shuntsu.\n\nIn the second example, Tokitsukaze already has a koutsu.\n\nIn the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].",
        "generated_code": "def min_tiles_to_win(tiles):\n    # Parse the input tiles\n    t1, t2, t3 = tiles.split()\n    \n    # Utility function to check if three tiles form a koutsu or shuntsu\n    def is_koutsu_or_shuntsu(t1, t2, t3):\n        if t1 == t2 == t3:\n            return True\n        n1, s1 = int(t1[0]), t1[1]\n        n2, s2 = int(t2[0]), t2[1]\n        n3, s3 = int(t3[0]), t3[1]\n        if s1 == s2 == s3 and sorted([n1, n2, n3]) in ([n1, n2, n3] for n1 in range(1, 8)):\n            return True\n        return False\n    \n    # Check if already a koutsu or shuntsu\n    if is_koutsu_or_shuntsu(t1, t2, t3):\n        return 0\n    \n    # Group tiles by suit\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in [t1, t2, t3]:\n        suits[tile[1]].append(int(tile[0]))\n    \n    # Check how many tiles are needed to form koutsu or shuntsu\n    def tiles_needed_to_complete_group(tiles):\n        tiles.sort()\n        if len(tiles) == 1:\n            return 2\n        if len(tiles) == 2:\n            if tiles[0] == tiles[1]:\n                return 1\n            if tiles[1] - tiles[0] <= 2:\n                return 1\n            return 2\n        return 2\n\n    min_additional_tiles = 2\n    for suit, numbers in suits.items():\n        min_additional_tiles = min(min_additional_tiles, tiles_needed_to_complete_group(numbers))\n    \n    return min_additional_tiles\n\n# Read input\nimport sys\ninput = sys.stdin.read\ntiles = input().strip()\nprint(min_tiles_to_win(tiles))\n",
        "counter_example": {
            "input": "4p 7p 2p\n",
            "expected": "1\n",
            "got": "2"
        }
    }
]