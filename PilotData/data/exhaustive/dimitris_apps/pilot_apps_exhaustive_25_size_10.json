[
    {
        "task_id": "0170",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Two bored soldiers are playing card war. Their card deck consists of exactly n cards, numbered from 1 to n, all values are different. They divide cards between them in some manner, it's possible that they have different number of cards. Then they play a \"war\"-like card game. \n\nThe rules are following. On each turn a fight happens. Each of them picks card from the top of his stack and puts on the table. The one whose card value is bigger wins this fight and takes both cards from the table to the bottom of his stack. More precisely, he first takes his opponent's card and puts to the bottom of his stack, and then he puts his card to the bottom of his stack. If after some turn one of the player's stack becomes empty, he loses and the other one wins. \n\nYou have to calculate how many fights will happen and who will win the game, or state that game won't end.\n\n\n-----Input-----\n\nFirst line contains a single integer n (2 ≤ n ≤ 10), the number of cards.\n\nSecond line contains integer k_1 (1 ≤ k_1 ≤ n - 1), the number of the first soldier's cards. Then follow k_1 integers that are the values on the first soldier's cards, from top to bottom of his stack.\n\nThird line contains integer k_2 (k_1 + k_2 = n), the number of the second soldier's cards. Then follow k_2 integers that are the values on the second soldier's cards, from top to bottom of his stack.\n\nAll card values are different.\n\n\n-----Output-----\n\nIf somebody wins in this game, print 2 integers where the first one stands for the number of fights before end of game and the second one is 1 or 2 showing which player has won.\n\nIf the game won't end and will continue forever output  - 1.\n\n\n-----Examples-----\nInput\n4\n2 1 3\n2 4 2\n\nOutput\n6 2\nInput\n3\n1 2\n2 1 3\n\nOutput\n-1\n\n\n-----Note-----\n\nFirst sample:  [Image] \n\nSecond sample:  [Image]",
        "generated_code": "n = int(input())\nk1 = int(input())\ndeck1 = list(map(int, input().split()))\nk2 = int(input())\ndeck2 = list(map(int, input().split()))\n\ndef game(deck1, deck2):\n    seen = set()\n    while deck1 and deck2:\n        state = (tuple(deck1), tuple(deck2))\n        if state in seen:\n            return -1\n        seen.add(state)\n        card1 = deck1.pop(0)\n        card2 = deck2.pop(0)\n        if card1 > card2:\n            deck1.extend([card1, card2])\n        else:\n            deck2.extend([card2, card1])\n    return (len(seen), 1) if deck1 else (len(seen), 2)\n\nprint(*game(deck1, deck2))\n",
        "counter_example": {
            "input": "4\n2 1 3\n2 4 2\n",
            "expected": "6 2",
            "got": "Traceback (most recent call last):\n  File \"<string>\", line 2, in <module>\nValueError: invalid literal for int() with base 10: '2 1 3'"
        }
    },
    {
        "task_id": "0170",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Two bored soldiers are playing card war. Their card deck consists of exactly n cards, numbered from 1 to n, all values are different. They divide cards between them in some manner, it's possible that they have different number of cards. Then they play a \"war\"-like card game. \n\nThe rules are following. On each turn a fight happens. Each of them picks card from the top of his stack and puts on the table. The one whose card value is bigger wins this fight and takes both cards from the table to the bottom of his stack. More precisely, he first takes his opponent's card and puts to the bottom of his stack, and then he puts his card to the bottom of his stack. If after some turn one of the player's stack becomes empty, he loses and the other one wins. \n\nYou have to calculate how many fights will happen and who will win the game, or state that game won't end.\n\n\n-----Input-----\n\nFirst line contains a single integer n (2 ≤ n ≤ 10), the number of cards.\n\nSecond line contains integer k_1 (1 ≤ k_1 ≤ n - 1), the number of the first soldier's cards. Then follow k_1 integers that are the values on the first soldier's cards, from top to bottom of his stack.\n\nThird line contains integer k_2 (k_1 + k_2 = n), the number of the second soldier's cards. Then follow k_2 integers that are the values on the second soldier's cards, from top to bottom of his stack.\n\nAll card values are different.\n\n\n-----Output-----\n\nIf somebody wins in this game, print 2 integers where the first one stands for the number of fights before end of game and the second one is 1 or 2 showing which player has won.\n\nIf the game won't end and will continue forever output  - 1.\n\n\n-----Examples-----\nInput\n4\n2 1 3\n2 4 2\n\nOutput\n6 2\nInput\n3\n1 2\n2 1 3\n\nOutput\n-1\n\n\n-----Note-----\n\nFirst sample:  [Image] \n\nSecond sample:  [Image]",
        "generated_code": "from collections import deque\n\ndef card_game(n, k1, cards1, k2, cards2):\n    player1 = deque(cards1)\n    player2 = deque(cards2)\n    seen_states = set()\n    rounds = 0\n    \n    while player1 and player2:\n        state = (tuple(player1), tuple(player2))\n        if state in seen_states:\n            return -1\n        seen_states.add(state)\n        \n        card1 = player1.popleft()\n        card2 = player2.popleft()\n        \n        if card1 > card2:\n            player1.append(card2)\n            player1.append(card1)\n        else:\n            player2.append(card1)\n            player2.append(card2)\n        \n        rounds += 1\n    \n    winner = 1 if player1 else 2\n    return rounds, winner\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k1 = int(data[1])\n    cards1 = list(map(int, data[2:2+k1]))\n    k2 = int(data[2+k1])\n    cards2 = list(map(int, data[3+k1:3+k1+k2]))\n    \n    result = card_game(n, k1, cards1, k2, cards2)\n    if result == -1:\n        print(result)\n    else:\n        print(result[0], result[1])\n",
        "counter_example": null
    },
    {
        "task_id": "0289",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Tonio has a keyboard with only two letters, \"V\" and \"K\".\n\nOne day, he has typed out a string s with only these two letters. He really likes it when the string \"VK\" appears, so he wishes to change at most one letter in the string (or do no changes) to maximize the number of occurrences of that string. Compute the maximum number of times \"VK\" can appear as a substring (i. e. a letter \"K\" right after a letter \"V\") in the resulting string.\n\n\n-----Input-----\n\nThe first line will contain a string s consisting only of uppercase English letters \"V\" and \"K\" with length not less than 1 and not greater than 100.\n\n\n-----Output-----\n\nOutput a single integer, the maximum number of times \"VK\" can appear as a substring of the given string after changing at most one character.\n\n\n-----Examples-----\nInput\nVK\n\nOutput\n1\n\nInput\nVV\n\nOutput\n1\n\nInput\nV\n\nOutput\n0\n\nInput\nVKKKKKKKKKVVVVVVVVVK\n\nOutput\n3\n\nInput\nKVKV\n\nOutput\n1\n\n\n\n-----Note-----\n\nFor the first case, we do not change any letters. \"VK\" appears once, which is the maximum number of times it could appear.\n\nFor the second case, we can change the second character from a \"V\" to a \"K\". This will give us the string \"VK\". This has one occurrence of the string \"VK\" as a substring.\n\nFor the fourth case, we can change the fourth character from a \"K\" to a \"V\". This will give us the string \"VKKVKKKKKKVVVVVVVVVK\". This has three occurrences of the string \"VK\" as a substring. We can check no other moves can give us strictly more occurrences.",
        "generated_code": "s = input()\ncount_vk = 0\ncount_v = 0\ncount_k = 0\nfor char in s:\n    if char == 'V':\n        count_v += 1\n    elif char == 'K':\n        count_k += 1\n        if count_v > 0:\n            count_vk += 1\n            count_v -= 1\nprint(count_vk + min(count_v, count_k))\n",
        "counter_example": {
            "input": "VV\n",
            "expected": "1\n",
            "got": "0"
        }
    },
    {
        "task_id": "0289",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Tonio has a keyboard with only two letters, \"V\" and \"K\".\n\nOne day, he has typed out a string s with only these two letters. He really likes it when the string \"VK\" appears, so he wishes to change at most one letter in the string (or do no changes) to maximize the number of occurrences of that string. Compute the maximum number of times \"VK\" can appear as a substring (i. e. a letter \"K\" right after a letter \"V\") in the resulting string.\n\n\n-----Input-----\n\nThe first line will contain a string s consisting only of uppercase English letters \"V\" and \"K\" with length not less than 1 and not greater than 100.\n\n\n-----Output-----\n\nOutput a single integer, the maximum number of times \"VK\" can appear as a substring of the given string after changing at most one character.\n\n\n-----Examples-----\nInput\nVK\n\nOutput\n1\n\nInput\nVV\n\nOutput\n1\n\nInput\nV\n\nOutput\n0\n\nInput\nVKKKKKKKKKVVVVVVVVVK\n\nOutput\n3\n\nInput\nKVKV\n\nOutput\n1\n\n\n\n-----Note-----\n\nFor the first case, we do not change any letters. \"VK\" appears once, which is the maximum number of times it could appear.\n\nFor the second case, we can change the second character from a \"V\" to a \"K\". This will give us the string \"VK\". This has one occurrence of the string \"VK\" as a substring.\n\nFor the fourth case, we can change the fourth character from a \"K\" to a \"V\". This will give us the string \"VKKVKKKKKKVVVVVVVVVK\". This has three occurrences of the string \"VK\" as a substring. We can check no other moves can give us strictly more occurrences.",
        "generated_code": "s = input()\n\n# Initialize the count of VK substrings\ncount_vk = 0\n\n# Count initial VK substrings\nfor i in range(len(s) - 1):\n    if s[i] == 'V' and s[i + 1] == 'K':\n        count_vk += 1\n\n# Try changing each character and see if it increases VK substrings\nmax_vk = count_vk\nfor i in range(len(s)):\n    if s[i] == 'V':\n        s_new = s[:i] + 'K' + s[i+1:]\n    elif s[i] == 'K':\n        s_new = s[:i] + 'V' + s[i+1:]\n    else:\n        continue\n    \n    new_count_vk = 0\n    for j in range(len(s_new) - 1):\n        if s_new[j] == 'V' and s_new[j + 1] == 'K':\n            new_count_vk += 1\n    \n    max_vk = max(max_vk, new_count_vk)\n\nprint(max_vk)\n",
        "counter_example": null
    },
    {
        "task_id": "0233",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": true,
        "description": "Mishka is a little polar bear. As known, little bears loves spending their free time playing dice for chocolates. Once in a wonderful sunny morning, walking around blocks of ice, Mishka met her friend Chris, and they started playing the game.\n\nRules of the game are very simple: at first number of rounds n is defined. In every round each of the players throws a cubical dice with distinct numbers from 1 to 6 written on its faces. Player, whose value after throwing the dice is greater, wins the round. In case if player dice values are equal, no one of them is a winner.\n\nIn average, player, who won most of the rounds, is the winner of the game. In case if two players won the same number of rounds, the result of the game is draw.\n\nMishka is still very little and can't count wins and losses, so she asked you to watch their game and determine its result. Please help her!\n\n\n-----Input-----\n\nThe first line of the input contains single integer n n (1 ≤ n ≤ 100) — the number of game rounds.\n\nThe next n lines contains rounds description. i-th of them contains pair of integers m_{i} and c_{i} (1 ≤ m_{i},  c_{i} ≤ 6) — values on dice upper face after Mishka's and Chris' throws in i-th round respectively.\n\n\n-----Output-----\n\nIf Mishka is the winner of the game, print \"Mishka\" (without quotes) in the only line.\n\nIf Chris is the winner of the game, print \"Chris\" (without quotes) in the only line.\n\nIf the result of the game is draw, print \"Friendship is magic!^^\" (without quotes) in the only line.\n\n\n-----Examples-----\nInput\n3\n3 5\n2 1\n4 2\n\nOutput\nMishka\nInput\n2\n6 1\n1 6\n\nOutput\nFriendship is magic!^^\nInput\n3\n1 5\n3 3\n2 2\n\nOutput\nChris\n\n\n-----Note-----\n\nIn the first sample case Mishka loses the first round, but wins second and third rounds and thus she is the winner of the game.\n\nIn the second sample case Mishka wins the first round, Chris wins the second round, and the game ends with draw with score 1:1.\n\nIn the third sample case Chris wins the first round, but there is no winner of the next two rounds. The winner of the game is Chris.",
        "generated_code": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\nfor _ in range(n):\n    m, c = map(int, input().split())\n    if m > c:\n        mishka_wins += 1\n    elif c > m:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")\n",
        "counter_example": null
    },
    {
        "task_id": "0233",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Mishka is a little polar bear. As known, little bears loves spending their free time playing dice for chocolates. Once in a wonderful sunny morning, walking around blocks of ice, Mishka met her friend Chris, and they started playing the game.\n\nRules of the game are very simple: at first number of rounds n is defined. In every round each of the players throws a cubical dice with distinct numbers from 1 to 6 written on its faces. Player, whose value after throwing the dice is greater, wins the round. In case if player dice values are equal, no one of them is a winner.\n\nIn average, player, who won most of the rounds, is the winner of the game. In case if two players won the same number of rounds, the result of the game is draw.\n\nMishka is still very little and can't count wins and losses, so she asked you to watch their game and determine its result. Please help her!\n\n\n-----Input-----\n\nThe first line of the input contains single integer n n (1 ≤ n ≤ 100) — the number of game rounds.\n\nThe next n lines contains rounds description. i-th of them contains pair of integers m_{i} and c_{i} (1 ≤ m_{i},  c_{i} ≤ 6) — values on dice upper face after Mishka's and Chris' throws in i-th round respectively.\n\n\n-----Output-----\n\nIf Mishka is the winner of the game, print \"Mishka\" (without quotes) in the only line.\n\nIf Chris is the winner of the game, print \"Chris\" (without quotes) in the only line.\n\nIf the result of the game is draw, print \"Friendship is magic!^^\" (without quotes) in the only line.\n\n\n-----Examples-----\nInput\n3\n3 5\n2 1\n4 2\n\nOutput\nMishka\nInput\n2\n6 1\n1 6\n\nOutput\nFriendship is magic!^^\nInput\n3\n1 5\n3 3\n2 2\n\nOutput\nChris\n\n\n-----Note-----\n\nIn the first sample case Mishka loses the first round, but wins second and third rounds and thus she is the winner of the game.\n\nIn the second sample case Mishka wins the first round, Chris wins the second round, and the game ends with draw with score 1:1.\n\nIn the third sample case Chris wins the first round, but there is no winner of the next two rounds. The winner of the game is Chris.",
        "generated_code": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    m, c = map(int, input().split())\n    if m > c:\n        mishka_wins += 1\n    elif c > m:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")\n",
        "counter_example": null
    },
    {
        "task_id": "0124",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "The Duck song\n\nFor simplicity, we'll assume that there are only three types of grapes: green grapes, purple grapes and black grapes.\n\nAndrew, Dmitry and Michal are all grapes' lovers, however their preferences of grapes are different. To make all of them happy, the following should happen: Andrew, Dmitry and Michal should eat at least $x$, $y$ and $z$ grapes, respectively. Andrew has an extreme affinity for green grapes, thus he will eat green grapes and green grapes only. On the other hand, Dmitry is not a fan of black grapes — any types of grapes except black would do for him. In other words, Dmitry can eat green and purple grapes. Michal has a common taste — he enjoys grapes in general and will be pleased with any types of grapes, as long as the quantity is sufficient.\n\nKnowing that his friends are so fond of grapes, Aki decided to host a grape party with them. He has prepared a box with $a$ green grapes, $b$ purple grapes and $c$ black grapes.\n\nHowever, Aki isn't sure if the box he prepared contains enough grapes to make everyone happy. Can you please find out whether it's possible to distribute grapes so that everyone is happy or Aki has to buy some more grapes?\n\nIt is not required to distribute all the grapes, so it's possible that some of them will remain unused.\n\n\n-----Input-----\n\nThe first line contains three integers $x$, $y$ and $z$ ($1 \\le x, y, z \\le 10^5$) — the number of grapes Andrew, Dmitry and Michal want to eat.\n\nThe second line contains three integers $a$, $b$, $c$ ($1 \\le a, b, c \\le 10^5$) — the number of green, purple and black grapes in the box.\n\n\n-----Output-----\n\nIf there is a grape distribution that allows everyone to be happy, print \"YES\", otherwise print \"NO\".\n\n\n-----Examples-----\nInput\n1 6 2\n4 3 3\n\nOutput\nYES\n\nInput\n5 1 1\n4 3 2\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first example, there is only one possible distribution:\n\nAndrew should take $1$ green grape, Dmitry should take $3$ remaining green grapes and $3$ purple grapes, and Michal will take $2$ out of $3$ available black grapes.\n\nIn the second test, there is no possible distribution, since Andrew is not be able to eat enough green grapes. :(",
        "generated_code": "x, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\nif x > a:\n    print(\"NO\")\nelif y > a + b:\n    print(\"NO\")\nelif z > a + b + c:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n",
        "counter_example": {
            "input": "1 1 100000\n4 2 99995\n",
            "expected": "NO\n",
            "got": "YES"
        }
    },
    {
        "task_id": "0124",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "The Duck song\n\nFor simplicity, we'll assume that there are only three types of grapes: green grapes, purple grapes and black grapes.\n\nAndrew, Dmitry and Michal are all grapes' lovers, however their preferences of grapes are different. To make all of them happy, the following should happen: Andrew, Dmitry and Michal should eat at least $x$, $y$ and $z$ grapes, respectively. Andrew has an extreme affinity for green grapes, thus he will eat green grapes and green grapes only. On the other hand, Dmitry is not a fan of black grapes — any types of grapes except black would do for him. In other words, Dmitry can eat green and purple grapes. Michal has a common taste — he enjoys grapes in general and will be pleased with any types of grapes, as long as the quantity is sufficient.\n\nKnowing that his friends are so fond of grapes, Aki decided to host a grape party with them. He has prepared a box with $a$ green grapes, $b$ purple grapes and $c$ black grapes.\n\nHowever, Aki isn't sure if the box he prepared contains enough grapes to make everyone happy. Can you please find out whether it's possible to distribute grapes so that everyone is happy or Aki has to buy some more grapes?\n\nIt is not required to distribute all the grapes, so it's possible that some of them will remain unused.\n\n\n-----Input-----\n\nThe first line contains three integers $x$, $y$ and $z$ ($1 \\le x, y, z \\le 10^5$) — the number of grapes Andrew, Dmitry and Michal want to eat.\n\nThe second line contains three integers $a$, $b$, $c$ ($1 \\le a, b, c \\le 10^5$) — the number of green, purple and black grapes in the box.\n\n\n-----Output-----\n\nIf there is a grape distribution that allows everyone to be happy, print \"YES\", otherwise print \"NO\".\n\n\n-----Examples-----\nInput\n1 6 2\n4 3 3\n\nOutput\nYES\n\nInput\n5 1 1\n4 3 2\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first example, there is only one possible distribution:\n\nAndrew should take $1$ green grape, Dmitry should take $3$ remaining green grapes and $3$ purple grapes, and Michal will take $2$ out of $3$ available black grapes.\n\nIn the second test, there is no possible distribution, since Andrew is not be able to eat enough green grapes. :(",
        "generated_code": "# Read input values\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Check if there are enough green grapes for Andrew\nif a < x:\n    print(\"NO\")\nelse:\n    # Deduct the green grapes taken by Andrew\n    a -= x\n\n    # Check if there are enough green and purple grapes for Dmitry\n    if a + b < y:\n        print(\"NO\")\n    else:\n        # Deduct the required grapes for Dmitry\n        if a >= y:\n            a -= y\n        else:\n            y -= a\n            a = 0\n            b -= y\n\n        # Check if the remaining grapes (any color) are enough for Michal\n        if a + b + c < z:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n",
        "counter_example": null
    },
    {
        "task_id": "0166",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "There is a matrix A of size x × y filled with integers. For every $i \\in [ 1 . . x ]$, $j \\in [ 1 . . y ]$ A_{i}, j = y(i - 1) + j. Obviously, every integer from [1..xy] occurs exactly once in this matrix. \n\nYou have traversed some path in this matrix. Your path can be described as a sequence of visited cells a_1, a_2, ..., a_{n} denoting that you started in the cell containing the number a_1, then moved to the cell with the number a_2, and so on.\n\nFrom the cell located in i-th line and j-th column (we denote this cell as (i, j)) you can move into one of the following cells: (i + 1, j) — only if i < x;  (i, j + 1) — only if j < y;  (i - 1, j) — only if i > 1;  (i, j - 1) — only if j > 1.\n\nNotice that making a move requires you to go to an adjacent cell. It is not allowed to stay in the same cell. You don't know x and y exactly, but you have to find any possible values for these numbers such that you could start in the cell containing the integer a_1, then move to the cell containing a_2 (in one step), then move to the cell containing a_3 (also in one step) and so on. Can you choose x and y so that they don't contradict with your sequence of moves?\n\n\n-----Input-----\n\nThe first line contains one integer number n (1 ≤ n ≤ 200000) — the number of cells you visited on your path (if some cell is visited twice, then it's listed twice).\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9) — the integers in the cells on your path.\n\n\n-----Output-----\n\nIf all possible values of x and y such that 1 ≤ x, y ≤ 10^9 contradict with the information about your path, print NO.\n\nOtherwise, print YES in the first line, and in the second line print the values x and y such that your path was possible with such number of lines and columns in the matrix. Remember that they must be positive integers not exceeding 10^9.\n\n\n-----Examples-----\nInput\n8\n1 2 3 6 9 8 5 2\n\nOutput\nYES\n3 3\n\nInput\n6\n1 2 1 2 5 3\n\nOutput\nNO\n\nInput\n2\n1 10\n\nOutput\nYES\n4 9\n\n\n\n-----Note-----\n\nThe matrix and the path on it in the first test looks like this: [Image] \n\nAlso there exist multiple correct answers for both the first and the third examples.",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\n\ndef check(x, y):\n    px, py = 0, 0\n    for v in a:\n        nx, ny = (v - 1) // y, (v - 1) % y\n        if abs(nx - px) + abs(ny - py) != 1:\n            return False\n        px, py = nx, ny\n    return True\n\nfor x in range(1, 1000001):\n    for y in range(1, 1000001):\n        if x * y > max(a):\n            break\n        if all(1 <= v <= x * y for v in a) and check(x, y):\n            print(\"YES\")\n            print(x, y)\n            exit()\nprint(\"NO\")\n",
        "counter_example": {
            "input": "8\n1 2 3 6 9 8 5 2\n",
            "expected": "YES\n1000000000 3\n",
            "got": "NO"
        }
    },
    {
        "task_id": "0166",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "There is a matrix A of size x × y filled with integers. For every $i \\in [ 1 . . x ]$, $j \\in [ 1 . . y ]$ A_{i}, j = y(i - 1) + j. Obviously, every integer from [1..xy] occurs exactly once in this matrix. \n\nYou have traversed some path in this matrix. Your path can be described as a sequence of visited cells a_1, a_2, ..., a_{n} denoting that you started in the cell containing the number a_1, then moved to the cell with the number a_2, and so on.\n\nFrom the cell located in i-th line and j-th column (we denote this cell as (i, j)) you can move into one of the following cells: (i + 1, j) — only if i < x;  (i, j + 1) — only if j < y;  (i - 1, j) — only if i > 1;  (i, j - 1) — only if j > 1.\n\nNotice that making a move requires you to go to an adjacent cell. It is not allowed to stay in the same cell. You don't know x and y exactly, but you have to find any possible values for these numbers such that you could start in the cell containing the integer a_1, then move to the cell containing a_2 (in one step), then move to the cell containing a_3 (also in one step) and so on. Can you choose x and y so that they don't contradict with your sequence of moves?\n\n\n-----Input-----\n\nThe first line contains one integer number n (1 ≤ n ≤ 200000) — the number of cells you visited on your path (if some cell is visited twice, then it's listed twice).\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9) — the integers in the cells on your path.\n\n\n-----Output-----\n\nIf all possible values of x and y such that 1 ≤ x, y ≤ 10^9 contradict with the information about your path, print NO.\n\nOtherwise, print YES in the first line, and in the second line print the values x and y such that your path was possible with such number of lines and columns in the matrix. Remember that they must be positive integers not exceeding 10^9.\n\n\n-----Examples-----\nInput\n8\n1 2 3 6 9 8 5 2\n\nOutput\nYES\n3 3\n\nInput\n6\n1 2 1 2 5 3\n\nOutput\nNO\n\nInput\n2\n1 10\n\nOutput\nYES\n4 9\n\n\n\n-----Note-----\n\nThe matrix and the path on it in the first test looks like this: [Image] \n\nAlso there exist multiple correct answers for both the first and the third examples.",
        "generated_code": "   1 2 3\n   4 5 6\n   7 8 9\n   ",
        "counter_example": {
            "input": "8\n1 2 3 6 9 8 5 2\n",
            "expected": "YES\n1000000000 3\n",
            "got": "File \"<string>\", line 1\n    1 2 3\nIndentationError: unexpected indent"
        }
    }
]