[
    {
        "task_id": "0220",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Two positive integers a and b have a sum of s and a bitwise XOR of x. How many possible values are there for the ordered pair (a, b)?\n\n\n-----Input-----\n\nThe first line of the input contains two integers s and x (2 ≤ s ≤ 10^12, 0 ≤ x ≤ 10^12), the sum and bitwise xor of the pair of positive integers, respectively.\n\n\n-----Output-----\n\nPrint a single integer, the number of solutions to the given conditions. If no solutions exist, print 0.\n\n\n-----Examples-----\nInput\n9 5\n\nOutput\n4\n\nInput\n3 3\n\nOutput\n2\n\nInput\n5 2\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first sample, we have the following solutions: (2, 7), (3, 6), (6, 3), (7, 2).\n\nIn the second sample, the only solutions are (1, 2) and (2, 1).",
        "generated_code": "s, x = map(int, input().split())\ncount = 0\nfor a in range(1, s):\n    b = s - a\n    if a ^ b == x:\n        count += 1\nprint(count)\n",
        "counter_example": {
            "input": "549755813887 549755813887\n",
            "expected": "549755813886\n",
            "got": "TimeoutError: Execution exceeded time limit"
        }
    },
    {
        "task_id": "0220",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Two positive integers a and b have a sum of s and a bitwise XOR of x. How many possible values are there for the ordered pair (a, b)?\n\n\n-----Input-----\n\nThe first line of the input contains two integers s and x (2 ≤ s ≤ 10^12, 0 ≤ x ≤ 10^12), the sum and bitwise xor of the pair of positive integers, respectively.\n\n\n-----Output-----\n\nPrint a single integer, the number of solutions to the given conditions. If no solutions exist, print 0.\n\n\n-----Examples-----\nInput\n9 5\n\nOutput\n4\n\nInput\n3 3\n\nOutput\n2\n\nInput\n5 2\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first sample, we have the following solutions: (2, 7), (3, 6), (6, 3), (7, 2).\n\nIn the second sample, the only solutions are (1, 2) and (2, 1).",
        "generated_code": "a = b ^ x\nb = a ^ x\n",
        "counter_example": {
            "input": "9 5\n",
            "expected": "4\n",
            "got": "Traceback (most recent call last):\n  File \"<string>\", line 1, in <module>\nNameError: name 'b' is not defined"
        }
    },
    {
        "task_id": "0205",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "The number \"zero\" is called \"love\" (or \"l'oeuf\" to be precise, literally means \"egg\" in French), for example when denoting the zero score in a game of tennis. \n\nAki is fond of numbers, especially those with trailing zeros. For example, the number $9200$ has two trailing zeros. Aki thinks the more trailing zero digits a number has, the prettier it is.\n\nHowever, Aki believes, that the number of trailing zeros of a number is not static, but depends on the base (radix) it is represented in. Thus, he considers a few scenarios with some numbers and bases. And now, since the numbers he used become quite bizarre, he asks you to help him to calculate the beauty of these numbers.\n\nGiven two integers $n$ and $b$ (in decimal notation), your task is to calculate the number of trailing zero digits in the $b$-ary (in the base/radix of $b$) representation of $n\\,!$ (factorial of $n$). \n\n\n-----Input-----\n\nThe only line of the input contains two integers $n$ and $b$ ($1 \\le n \\le 10^{18}$, $2 \\le b \\le 10^{12}$).\n\n\n-----Output-----\n\nPrint an only integer — the number of trailing zero digits in the $b$-ary representation of $n!$\n\n\n-----Examples-----\nInput\n6 9\n\nOutput\n1\n\nInput\n38 11\n\nOutput\n3\n\nInput\n5 2\n\nOutput\n3\n\nInput\n5 10\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example, $6!_{(10)} = 720_{(10)} = 880_{(9)}$.\n\nIn the third and fourth example, $5!_{(10)} = 120_{(10)} = 1111000_{(2)}$.\n\nThe representation of the number $x$ in the $b$-ary base is $d_1, d_2, \\ldots, d_k$ if $x = d_1 b^{k - 1} + d_2 b^{k - 2} + \\ldots + d_k b^0$, where $d_i$ are integers and $0 \\le d_i \\le b - 1$. For example, the number $720$ from the first example is represented as $880_{(9)}$ since $720 = 8 \\cdot 9^2 + 8 \\cdot 9 + 0 \\cdot 1$.\n\nYou can read more about bases here.",
        "generated_code": "def count_zeros(n, b):\n    count = 0\n    i = b\n    while i <= n:\n        count += n // i\n        i *= b\n    return count\n\nn, b = map(int, input().split())\nprint(count_zeros(n, b))\n",
        "counter_example": {
            "input": "6 9\n",
            "expected": "1\n",
            "got": "0"
        }
    },
    {
        "task_id": "0205",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "The number \"zero\" is called \"love\" (or \"l'oeuf\" to be precise, literally means \"egg\" in French), for example when denoting the zero score in a game of tennis. \n\nAki is fond of numbers, especially those with trailing zeros. For example, the number $9200$ has two trailing zeros. Aki thinks the more trailing zero digits a number has, the prettier it is.\n\nHowever, Aki believes, that the number of trailing zeros of a number is not static, but depends on the base (radix) it is represented in. Thus, he considers a few scenarios with some numbers and bases. And now, since the numbers he used become quite bizarre, he asks you to help him to calculate the beauty of these numbers.\n\nGiven two integers $n$ and $b$ (in decimal notation), your task is to calculate the number of trailing zero digits in the $b$-ary (in the base/radix of $b$) representation of $n\\,!$ (factorial of $n$). \n\n\n-----Input-----\n\nThe only line of the input contains two integers $n$ and $b$ ($1 \\le n \\le 10^{18}$, $2 \\le b \\le 10^{12}$).\n\n\n-----Output-----\n\nPrint an only integer — the number of trailing zero digits in the $b$-ary representation of $n!$\n\n\n-----Examples-----\nInput\n6 9\n\nOutput\n1\n\nInput\n38 11\n\nOutput\n3\n\nInput\n5 2\n\nOutput\n3\n\nInput\n5 10\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example, $6!_{(10)} = 720_{(10)} = 880_{(9)}$.\n\nIn the third and fourth example, $5!_{(10)} = 120_{(10)} = 1111000_{(2)}$.\n\nThe representation of the number $x$ in the $b$-ary base is $d_1, d_2, \\ldots, d_k$ if $x = d_1 b^{k - 1} + d_2 b^{k - 2} + \\ldots + d_k b^0$, where $d_i$ are integers and $0 \\le d_i \\le b - 1$. For example, the number $720$ from the first example is represented as $880_{(9)}$ since $720 = 8 \\cdot 9^2 + 8 \\cdot 9 + 0 \\cdot 1$.\n\nYou can read more about bases here.",
        "generated_code": "def prime_factors(b):\n    \"\"\" Return the prime factors of b as a dictionary where keys are the prime factors and values are their powers \"\"\"\n    factors = {}\n    d = 2\n    while b > 1:\n        while (b % d) == 0:\n            if d in factors:\n                factors[d] += 1\n            else:\n                factors[d] = 1\n            b //= d\n        d += 1\n        if d * d > b:\n            if b > 1:\n                if b in factors:\n                    factors[b] += 1\n                else:\n                    factors[b] = 1\n            break\n    return factors\n\ndef count_factors(n, p):\n    \"\"\" Return the number of times prime p is a factor in n! \"\"\"\n    count = 0\n    power = p\n    while power <= n:\n        count += n // power\n        power *= p\n    return count\n\ndef trailing_zeros_in_base_factorial(n, b):\n    \"\"\" Calculate the number of trailing zero digits in the b-ary representation of n! \"\"\"\n    factors = prime_factors(b)\n    min_zeros = float('inf')\n    \n    for prime, power in factors.items():\n        count = count_factors(n, prime) // power\n        if count < min_zeros:\n            min_zeros = count\n    \n    return min_zeros\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\nn = int(data[0])\nb = int(data[1])\n\n# Calculating the result\nresult = trailing_zeros_in_base_factorial(n, b)\n\n# Printing the result\nprint(result)\n",
        "counter_example": null
    },
    {
        "task_id": "0077",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "You are given sequence a_1, a_2, ..., a_{n} of integer numbers of length n. Your task is to find such subsequence that its sum is odd and maximum among all such subsequences. It's guaranteed that given sequence contains subsequence with odd sum.\n\nSubsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.\n\nYou should write a program which finds sum of the best subsequence.\n\n\n-----Input-----\n\nThe first line contains integer number n (1 ≤ n ≤ 10^5).\n\nThe second line contains n integer numbers a_1, a_2, ..., a_{n} ( - 10^4 ≤ a_{i} ≤ 10^4). The sequence contains at least one subsequence with odd sum.\n\n\n-----Output-----\n\nPrint sum of resulting subseqeuence.\n\n\n-----Examples-----\nInput\n4\n-2 2 -3 1\n\nOutput\n3\n\nInput\n3\n2 -5 -3\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first example sum of the second and the fourth elements is 3.",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\na.sort(reverse=True)\n\nans = 0\nfor i in a:\n    if ans % 2 == 0 and i % 2 != 0:\n        ans += i\n    elif ans % 2 != 0 and i % 2 == 0:\n        ans += i\n    elif ans % 2 == 0 and i % 2 == 0:\n        ans += i\nprint(ans)\n",
        "counter_example": {
            "input": "4\n-2 2 -3 1\n",
            "expected": "3\n",
            "got": "1"
        }
    },
    {
        "task_id": "0077",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "You are given sequence a_1, a_2, ..., a_{n} of integer numbers of length n. Your task is to find such subsequence that its sum is odd and maximum among all such subsequences. It's guaranteed that given sequence contains subsequence with odd sum.\n\nSubsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.\n\nYou should write a program which finds sum of the best subsequence.\n\n\n-----Input-----\n\nThe first line contains integer number n (1 ≤ n ≤ 10^5).\n\nThe second line contains n integer numbers a_1, a_2, ..., a_{n} ( - 10^4 ≤ a_{i} ≤ 10^4). The sequence contains at least one subsequence with odd sum.\n\n\n-----Output-----\n\nPrint sum of resulting subseqeuence.\n\n\n-----Examples-----\nInput\n4\n-2 2 -3 1\n\nOutput\n3\n\nInput\n3\n2 -5 -3\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first example sum of the second and the fourth elements is 3.",
        "generated_code": "# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize sums\ntotal_sum = sum(a)\nmin_positive_odd = float('inf')\nmax_negative_odd = float('-inf')\n\n# Check if the total sum is odd\nif total_sum % 2 != 0:\n    print(total_sum)\nelse:\n    for num in a:\n        if num % 2 != 0:\n            if num > 0:\n                min_positive_odd = min(min_positive_odd, num)\n            else:\n                max_negative_odd = max(max_negative_odd, num)\n    \n    # Calculate possible results by adjusting the total sum to make it odd\n    result1 = total_sum - min_positive_odd if min_positive_odd != float('inf') else float('-inf')\n    result2 = total_sum - max_negative_odd if max_negative_odd != float('-inf') else float('-inf')\n\n    # Print the maximum valid result\n    print(max(result1, result2))\n",
        "counter_example": {
            "input": "4\n-2 2 -3 1\n",
            "expected": "3\n",
            "got": "1"
        }
    },
    {
        "task_id": "0252",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Alice and Bob are playing yet another card game. This time the rules are the following. There are $n$ cards lying in a row in front of them. The $i$-th card has value $a_i$. \n\nFirst, Alice chooses a non-empty consecutive segment of cards $[l; r]$ ($l \\le r$). After that Bob removes a single card $j$ from that segment $(l \\le j \\le r)$. The score of the game is the total value of the remaining cards on the segment $(a_l + a_{l + 1} + \\dots + a_{j - 1} + a_{j + 1} + \\dots + a_{r - 1} + a_r)$. In particular, if Alice chooses a segment with just one element, then the score after Bob removes the only card is $0$.\n\nAlice wants to make the score as big as possible. Bob takes such a card that the score is as small as possible.\n\nWhat segment should Alice choose so that the score is maximum possible? Output the maximum score.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^5$) — the number of cards.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-30 \\le a_i \\le 30$) — the values on the cards.\n\n\n-----Output-----\n\nPrint a single integer — the final score of the game.\n\n\n-----Examples-----\nInput\n5\n5 -2 10 -1 4\n\nOutput\n6\n\nInput\n8\n5 2 5 3 -30 -30 6 9\n\nOutput\n10\n\nInput\n3\n-10 6 -15\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example Alice chooses a segment $[1;5]$ — the entire row of cards. Bob removes card $3$ with the value $10$ from the segment. Thus, the final score is $5 + (-2) + (-1) + 4 = 6$.\n\nIn the second example Alice chooses a segment $[1;4]$, so that Bob removes either card $1$ or $3$ with the value $5$, making the answer $5 + 2 + 3 = 10$.\n\nIn the third example Alice can choose any of the segments of length $1$: $[1;1]$, $[2;2]$ or $[3;3]$. Bob removes the only card, so the score is $0$. If Alice chooses some other segment then the answer will be less than $0$.",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\nprefix_sum = [0] * (n + 1)\nfor i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\nmax_score = 0\nfor i in range(n):\n    for j in range(i, n):\n        total = prefix_sum[j + 1] - prefix_sum[i]\n        if j - i > 0:\n            total -= min(a[i:j + 1])\n        max_score = max(max_score, total)\n\nprint(max_score)\n",
        "counter_example": {
            "input": "5\n5 -2 10 -1 4\n",
            "expected": "6\n",
            "got": "18"
        }
    },
    {
        "task_id": "0252",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Alice and Bob are playing yet another card game. This time the rules are the following. There are $n$ cards lying in a row in front of them. The $i$-th card has value $a_i$. \n\nFirst, Alice chooses a non-empty consecutive segment of cards $[l; r]$ ($l \\le r$). After that Bob removes a single card $j$ from that segment $(l \\le j \\le r)$. The score of the game is the total value of the remaining cards on the segment $(a_l + a_{l + 1} + \\dots + a_{j - 1} + a_{j + 1} + \\dots + a_{r - 1} + a_r)$. In particular, if Alice chooses a segment with just one element, then the score after Bob removes the only card is $0$.\n\nAlice wants to make the score as big as possible. Bob takes such a card that the score is as small as possible.\n\nWhat segment should Alice choose so that the score is maximum possible? Output the maximum score.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^5$) — the number of cards.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-30 \\le a_i \\le 30$) — the values on the cards.\n\n\n-----Output-----\n\nPrint a single integer — the final score of the game.\n\n\n-----Examples-----\nInput\n5\n5 -2 10 -1 4\n\nOutput\n6\n\nInput\n8\n5 2 5 3 -30 -30 6 9\n\nOutput\n10\n\nInput\n3\n-10 6 -15\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example Alice chooses a segment $[1;5]$ — the entire row of cards. Bob removes card $3$ with the value $10$ from the segment. Thus, the final score is $5 + (-2) + (-1) + 4 = 6$.\n\nIn the second example Alice chooses a segment $[1;4]$, so that Bob removes either card $1$ or $3$ with the value $5$, making the answer $5 + 2 + 3 = 10$.\n\nIn the third example Alice can choose any of the segments of length $1$: $[1;1]$, $[2;2]$ or $[3;3]$. Bob removes the only card, so the score is $0$. If Alice chooses some other segment then the answer will be less than $0$.",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\n# Function to find the maximum sum of a subarray\ndef max_subarray_sum(nums):\n    max_so_far = float('-inf')\n    current_max = 0\n    \n    for num in nums:\n        current_max += num\n        if max_so_far < current_max:\n            max_so_far = current_max\n        if current_max < 0:\n            current_max = 0\n    return max_so_far\n\n# We need to find the segment where removing the smallest single card results in the maximum sum\nmax_score = float('-inf')\n\nfor i in range(n):\n    left_sum = sum(a[:i])\n    right_sum = sum(a[i+1:])\n    current_score = left_sum + right_sum\n    \n    if current_score > max_score:\n        max_score = current_score\n\n# If all possible segments result in removing all cards, the score is 0\nif max_score < 0:\n    max_score = 0\n\nprint(max_score)\n",
        "counter_example": {
            "input": "5\n5 -2 10 -1 4\n",
            "expected": "6\n",
            "got": "18"
        }
    },
    {
        "task_id": "0055",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Jamie is preparing a Codeforces round. He has got an idea for a problem, but does not know how to solve it. Help him write a solution to the following problem:\n\nFind k integers such that the sum of two to the power of each number equals to the number n and the largest integer in the answer is as small as possible. As there may be multiple answers, you are asked to output the lexicographically largest one. \n\nTo be more clear, consider all integer sequence with length k (a_1, a_2, ..., a_{k}) with $\\sum_{i = 1}^{k} 2^{a_{i}} = n$. Give a value $y = \\operatorname{max}_{1 \\leq i \\leq k} a_{i}$ to each sequence. Among all sequence(s) that have the minimum y value, output the one that is the lexicographically largest.\n\nFor definitions of powers and lexicographical order see notes.\n\n\n-----Input-----\n\nThe first line consists of two integers n and k (1 ≤ n ≤ 10^18, 1 ≤ k ≤ 10^5) — the required sum and the length of the sequence.\n\n\n-----Output-----\n\nOutput \"No\" (without quotes) in a single line if there does not exist such sequence. Otherwise, output \"Yes\" (without quotes) in the first line, and k numbers separated by space in the second line — the required sequence.\n\nIt is guaranteed that the integers in the answer sequence fit the range [ - 10^18, 10^18].\n\n\n-----Examples-----\nInput\n23 5\n\nOutput\nYes\n3 3 2 1 0 \n\nInput\n13 2\n\nOutput\nNo\n\nInput\n1 2\n\nOutput\nYes\n-1 -1 \n\n\n\n-----Note-----\n\nSample 1:\n\n2^3 + 2^3 + 2^2 + 2^1 + 2^0 = 8 + 8 + 4 + 2 + 1 = 23\n\nAnswers like (3, 3, 2, 0, 1) or (0, 1, 2, 3, 3) are not lexicographically largest.\n\nAnswers like (4, 1, 1, 1, 0) do not have the minimum y value.\n\nSample 2:\n\nIt can be shown there does not exist a sequence with length 2.\n\nSample 3:\n\n$2^{-1} + 2^{-1} = \\frac{1}{2} + \\frac{1}{2} = 1$\n\nPowers of 2:\n\nIf x > 0, then 2^{x} = 2·2·2·...·2 (x times).\n\nIf x = 0, then 2^{x} = 1.\n\nIf x < 0, then $2^{x} = \\frac{1}{2^{-x}}$.\n\nLexicographical order:\n\nGiven two different sequences of the same length, (a_1, a_2, ... , a_{k}) and (b_1, b_2, ... , b_{k}), the first one is smaller than the second one for the lexicographical order, if and only if a_{i} < b_{i}, for the first i where a_{i} and b_{i} differ.",
        "generated_code": "n, k = map(int, input().split())\nif n < k:\n    print(\"No\")\nelse:\n    a = []\n    i = 0\n    while n > 0:\n        x = n.bit_length() - 1\n        if x <= i:\n            break\n        a.append(x)\n        n -= 2 ** x\n        i += 1\n    if len(a) < k:\n        print(\"No\")\n    else:\n        a = a[:k]\n        a.sort(reverse=True)\n        print(\"Yes\")\n        print(' '.join(map(str, a)))\n",
        "counter_example": {
            "input": "23 5\n",
            "expected": "Yes\n3 3 2 1 0 \n",
            "got": "No"
        }
    },
    {
        "task_id": "0055",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Jamie is preparing a Codeforces round. He has got an idea for a problem, but does not know how to solve it. Help him write a solution to the following problem:\n\nFind k integers such that the sum of two to the power of each number equals to the number n and the largest integer in the answer is as small as possible. As there may be multiple answers, you are asked to output the lexicographically largest one. \n\nTo be more clear, consider all integer sequence with length k (a_1, a_2, ..., a_{k}) with $\\sum_{i = 1}^{k} 2^{a_{i}} = n$. Give a value $y = \\operatorname{max}_{1 \\leq i \\leq k} a_{i}$ to each sequence. Among all sequence(s) that have the minimum y value, output the one that is the lexicographically largest.\n\nFor definitions of powers and lexicographical order see notes.\n\n\n-----Input-----\n\nThe first line consists of two integers n and k (1 ≤ n ≤ 10^18, 1 ≤ k ≤ 10^5) — the required sum and the length of the sequence.\n\n\n-----Output-----\n\nOutput \"No\" (without quotes) in a single line if there does not exist such sequence. Otherwise, output \"Yes\" (without quotes) in the first line, and k numbers separated by space in the second line — the required sequence.\n\nIt is guaranteed that the integers in the answer sequence fit the range [ - 10^18, 10^18].\n\n\n-----Examples-----\nInput\n23 5\n\nOutput\nYes\n3 3 2 1 0 \n\nInput\n13 2\n\nOutput\nNo\n\nInput\n1 2\n\nOutput\nYes\n-1 -1 \n\n\n\n-----Note-----\n\nSample 1:\n\n2^3 + 2^3 + 2^2 + 2^1 + 2^0 = 8 + 8 + 4 + 2 + 1 = 23\n\nAnswers like (3, 3, 2, 0, 1) or (0, 1, 2, 3, 3) are not lexicographically largest.\n\nAnswers like (4, 1, 1, 1, 0) do not have the minimum y value.\n\nSample 2:\n\nIt can be shown there does not exist a sequence with length 2.\n\nSample 3:\n\n$2^{-1} + 2^{-1} = \\frac{1}{2} + \\frac{1}{2} = 1$\n\nPowers of 2:\n\nIf x > 0, then 2^{x} = 2·2·2·...·2 (x times).\n\nIf x = 0, then 2^{x} = 1.\n\nIf x < 0, then $2^{x} = \\frac{1}{2^{-x}}$.\n\nLexicographical order:\n\nGiven two different sequences of the same length, (a_1, a_2, ... , a_{k}) and (b_1, b_2, ... , b_{k}), the first one is smaller than the second one for the lexicographical order, if and only if a_{i} < b_{i}, for the first i where a_{i} and b_{i} differ.",
        "generated_code": "def find_sequence(n, k):\n    # Check if it is possible to express n as a sum of k powers of 2\n    if k > n:\n        return \"No\"\n    \n    # Start by representing n in binary and counting the number of 1s\n    bits = []\n    for i in range(60, -1, -1):\n        if (n >> i) & 1:\n            bits.append(i)\n\n    # If the number of bits is more than k, it's impossible\n    if len(bits) > k:\n        return \"No\"\n    \n    # We need to distribute the bits to get exactly k parts\n    while len(bits) < k:\n        smallest = bits.pop()\n        bits.append(smallest - 1)\n        bits.append(smallest - 1)\n    \n    # Sort to ensure that the sequence is lexicographically largest\n    bits.sort(reverse=True)\n    \n    return \"Yes\\n\" + \" \".join(map(str, bits))\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\nn = int(data[0])\nk = int(data[1])\n\n# Finding and printing the sequence\nprint(find_sequence(n, k))\n",
        "counter_example": {
            "input": "23 5\n",
            "expected": "Yes\n3 3 2 1 0 \n",
            "got": "Yes\n4 2 1 -1 -1"
        }
    }
]