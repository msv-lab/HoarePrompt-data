[
    {
        "task_id": "0130",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Polycarp has a checkered sheet of paper of size n × m. Polycarp painted some of cells with black, the others remained white. Inspired by Malevich's \"Black Square\", Polycarp wants to paint minimum possible number of white cells with black so that all black cells form a square.\n\nYou are to determine the minimum possible number of cells needed to be painted black so that the black cells form a black square with sides parallel to the painting's sides. All the cells that do not belong to the square should be white. The square's side should have positive length.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (1 ≤ n, m ≤ 100) — the sizes of the sheet.\n\nThe next n lines contain m letters 'B' or 'W' each — the description of initial cells' colors. If a letter is 'B', then the corresponding cell is painted black, otherwise it is painted white.\n\n\n-----Output-----\n\nPrint the minimum number of cells needed to be painted black so that the black cells form a black square with sides parallel to the painting's sides. All the cells that do not belong to the square should be white. If it is impossible, print -1.\n\n\n-----Examples-----\nInput\n5 4\nWWWW\nWWWB\nWWWB\nWWBB\nWWWW\n\nOutput\n5\n\nInput\n1 2\nBB\n\nOutput\n-1\n\nInput\n3 3\nWWW\nWWW\nWWW\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example it is needed to paint 5 cells — (2, 2), (2, 3), (3, 2), (3, 3) and (4, 2). Then there will be a square with side equal to three, and the upper left corner in (2, 2).\n\nIn the second example all the cells are painted black and form a rectangle, so it's impossible to get a square.\n\nIn the third example all cells are colored white, so it's sufficient to color any cell black.",
        "generated_code": "n, m = map(int, input().split())\npaper = [list(input()) for _ in range(n)]\n\nblack_cells = [(i, j) for i in range(n) for j in range(m) if paper[i][j] == 'B']\n\nif not black_cells:\n    print(1)\nelse:\n    min_x, min_y, max_x, max_y = float('inf'), float('inf'), float('-inf'), float('-inf')\n    for x, y in black_cells:\n        min_x, min_y = min(min_x, x), min(min_y, y)\n        max_x, max_y = max(max_x, x), max(max_y, y)\n\n    side = max_x - min_x + 1\n    if side != max_y - min_y + 1:\n        print(-1)\n    else:\n        print(side * side - len(black_cells))\n",
        "counter_example": {
            "input": "5 4\nWWWW\nWWWB\nWWWB\nWWBB\nWWWW\n",
            "expected": "5\n",
            "got": "-1"
        }
    },
    {
        "task_id": "0130",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Polycarp has a checkered sheet of paper of size n × m. Polycarp painted some of cells with black, the others remained white. Inspired by Malevich's \"Black Square\", Polycarp wants to paint minimum possible number of white cells with black so that all black cells form a square.\n\nYou are to determine the minimum possible number of cells needed to be painted black so that the black cells form a black square with sides parallel to the painting's sides. All the cells that do not belong to the square should be white. The square's side should have positive length.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (1 ≤ n, m ≤ 100) — the sizes of the sheet.\n\nThe next n lines contain m letters 'B' or 'W' each — the description of initial cells' colors. If a letter is 'B', then the corresponding cell is painted black, otherwise it is painted white.\n\n\n-----Output-----\n\nPrint the minimum number of cells needed to be painted black so that the black cells form a black square with sides parallel to the painting's sides. All the cells that do not belong to the square should be white. If it is impossible, print -1.\n\n\n-----Examples-----\nInput\n5 4\nWWWW\nWWWB\nWWWB\nWWBB\nWWWW\n\nOutput\n5\n\nInput\n1 2\nBB\n\nOutput\n-1\n\nInput\n3 3\nWWW\nWWW\nWWW\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example it is needed to paint 5 cells — (2, 2), (2, 3), (3, 2), (3, 3) and (4, 2). Then there will be a square with side equal to three, and the upper left corner in (2, 2).\n\nIn the second example all the cells are painted black and form a rectangle, so it's impossible to get a square.\n\nIn the third example all cells are colored white, so it's sufficient to color any cell black.",
        "generated_code": "# Read input values\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Initialize variables to track the bounding box of the black cells ('B')\ntop, bottom, left, right = n, -1, m, -1\n\n# Find the bounding box of the black cells\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 'B':\n            top = min(top, i)\n            bottom = max(bottom, i)\n            left = min(left, j)\n            right = max(right, j)\n\n# If no black cells were found, paint one cell black\nif top > bottom or left > right:\n    print(1)\nelse:\n    # Calculate the size of the bounding box\n    height = bottom - top + 1\n    width = right - left + 1\n    \n    # The side length of the square should be the maximum of height and width\n    side_length = max(height, width)\n    \n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        print(-1)\n    else:\n        # Calculate the number of white cells that need to be painted black\n        total_cells = side_length * side_length\n        existing_black_cells = 0\n        \n        for i in range(top, bottom + 1):\n            for j in range(left, right + 1):\n                if grid[i][j] == 'B':\n                    existing_black_cells += 1\n                    \n        print(total_cells - existing_black_cells)\n",
        "counter_example": null
    },
    {
        "task_id": "0039",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": true,
        "description": "A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings \"kek\", \"abacaba\", \"r\" and \"papicipap\" are palindromes, while the strings \"abb\" and \"iq\" are not.\n\nA substring $s[l \\ldots r]$ ($1 \\leq l \\leq r \\leq |s|$) of a string $s = s_{1}s_{2} \\ldots s_{|s|}$ is the string $s_{l}s_{l + 1} \\ldots s_{r}$.\n\nAnna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $s$ is changed into its longest substring that is not a palindrome. If all the substrings of $s$ are palindromes, she skips the word at all.\n\nSome time ago Ann read the word $s$. What is the word she changed it into?\n\n\n-----Input-----\n\nThe first line contains a non-empty string $s$ with length at most $50$ characters, containing lowercase English letters only.\n\n\n-----Output-----\n\nIf there is such a substring in $s$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $0$.\n\nNote that there can be multiple longest substrings that are not palindromes, but their length is unique.\n\n\n-----Examples-----\nInput\nmew\n\nOutput\n3\n\nInput\nwuffuw\n\nOutput\n5\n\nInput\nqqqqqqqq\n\nOutput\n0\n\n\n\n-----Note-----\n\n\"mew\" is not a palindrome, so the longest substring of it that is not a palindrome, is the string \"mew\" itself. Thus, the answer for the first example is $3$.\n\nThe string \"uffuw\" is one of the longest non-palindrome substrings (of length $5$) of the string \"wuffuw\", so the answer for the second example is $5$.\n\nAll substrings of the string \"qqqqqqqq\" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $0$.",
        "generated_code": "s = input()\nn = len(s)\nmax_len = 0\nfor i in range(n):\n    for j in range(i + 1, n + 1):\n        substr = s[i:j]\n        if substr != substr[::-1]:\n            max_len = max(max_len, len(substr))\nprint(max_len if max_len > 0 else 0)\n",
        "counter_example": null
    },
    {
        "task_id": "0039",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings \"kek\", \"abacaba\", \"r\" and \"papicipap\" are palindromes, while the strings \"abb\" and \"iq\" are not.\n\nA substring $s[l \\ldots r]$ ($1 \\leq l \\leq r \\leq |s|$) of a string $s = s_{1}s_{2} \\ldots s_{|s|}$ is the string $s_{l}s_{l + 1} \\ldots s_{r}$.\n\nAnna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $s$ is changed into its longest substring that is not a palindrome. If all the substrings of $s$ are palindromes, she skips the word at all.\n\nSome time ago Ann read the word $s$. What is the word she changed it into?\n\n\n-----Input-----\n\nThe first line contains a non-empty string $s$ with length at most $50$ characters, containing lowercase English letters only.\n\n\n-----Output-----\n\nIf there is such a substring in $s$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $0$.\n\nNote that there can be multiple longest substrings that are not palindromes, but their length is unique.\n\n\n-----Examples-----\nInput\nmew\n\nOutput\n3\n\nInput\nwuffuw\n\nOutput\n5\n\nInput\nqqqqqqqq\n\nOutput\n0\n\n\n\n-----Note-----\n\n\"mew\" is not a palindrome, so the longest substring of it that is not a palindrome, is the string \"mew\" itself. Thus, the answer for the first example is $3$.\n\nThe string \"uffuw\" is one of the longest non-palindrome substrings (of length $5$) of the string \"wuffuw\", so the answer for the second example is $5$.\n\nAll substrings of the string \"qqqqqqqq\" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $0$.",
        "generated_code": "def is_palindrome(s):\n    return s == s[::-1]\n\ns = input().strip()\n\nif len(s) <= 1:\n    print(0)\nelse:\n    if not is_palindrome(s):\n        print(len(s))\n    else:\n        if not is_palindrome(s[1:]):\n            print(len(s) - 1)\n        elif not is_palindrome(s[:-1]):\n            print(len(s) - 1)\n        else:\n            print(0)\n",
        "counter_example": null
    },
    {
        "task_id": "0071",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "On the Literature lesson Sergei noticed an awful injustice, it seems that some students are asked more often than others.\n\nSeating in the class looks like a rectangle, where n rows with m pupils in each. \n\nThe teacher asks pupils in the following order: at first, she asks all pupils from the first row in the order of their seating, then she continues to ask pupils from the next row. If the teacher asked the last row, then the direction of the poll changes, it means that she asks the previous row. The order of asking the rows looks as follows: the 1-st row, the 2-nd row, ..., the n - 1-st row, the n-th row, the n - 1-st row, ..., the 2-nd row, the 1-st row, the 2-nd row, ...\n\nThe order of asking of pupils on the same row is always the same: the 1-st pupil, the 2-nd pupil, ..., the m-th pupil.\n\nDuring the lesson the teacher managed to ask exactly k questions from pupils in order described above. Sergei seats on the x-th row, on the y-th place in the row. Sergei decided to prove to the teacher that pupils are asked irregularly, help him count three values:  the maximum number of questions a particular pupil is asked,  the minimum number of questions a particular pupil is asked,  how many times the teacher asked Sergei. \n\nIf there is only one row in the class, then the teacher always asks children from this row.\n\n\n-----Input-----\n\nThe first and the only line contains five integers n, m, k, x and y (1 ≤ n, m ≤ 100, 1 ≤ k ≤ 10^18, 1 ≤ x ≤ n, 1 ≤ y ≤ m).\n\n\n-----Output-----\n\nPrint three integers:  the maximum number of questions a particular pupil is asked,  the minimum number of questions a particular pupil is asked,  how many times the teacher asked Sergei. \n\n\n-----Examples-----\nInput\n1 3 8 1 1\n\nOutput\n3 2 3\nInput\n4 2 9 4 2\n\nOutput\n2 1 1\nInput\n5 5 25 4 3\n\nOutput\n1 1 1\nInput\n100 100 1000000000000000000 100 100\n\nOutput\n101010101010101 50505050505051 50505050505051\n\n\n-----Note-----\n\nThe order of asking pupils in the first test:   the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table;  the pupil from the first row who seats at the third table;  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table;  the pupil from the first row who seats at the third table;  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table; \n\nThe order of asking pupils in the second test:   the pupil from the first row who seats at the first table;  the pupil from the first row who seats at the second table;  the pupil from the second row who seats at the first table;  the pupil from the second row who seats at the second table;  the pupil from the third row who seats at the first table;  the pupil from the third row who seats at the second table;  the pupil from the fourth row who seats at the first table;  the pupil from the fourth row who seats at the second table, it means it is Sergei;  the pupil from the third row who seats at the first table;",
        "generated_code": "n, m, k, x, y = map(int, input().split())\n\nmax_asked = (k + (n - 1)) // (2 * n)\nmin_asked = max(1, max_asked - (n - 1))\nsergei_asked = (k + x - 1) // (2 * n) + ((k + x - 1) % (2 * n) >= n - x + 1)\n\nprint(max_asked, min_asked, sergei_asked)\n",
        "counter_example": {
            "input": "1 3 8 1 1\n",
            "expected": "3 2 3",
            "got": "4 4 4"
        }
    },
    {
        "task_id": "0071",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "On the Literature lesson Sergei noticed an awful injustice, it seems that some students are asked more often than others.\n\nSeating in the class looks like a rectangle, where n rows with m pupils in each. \n\nThe teacher asks pupils in the following order: at first, she asks all pupils from the first row in the order of their seating, then she continues to ask pupils from the next row. If the teacher asked the last row, then the direction of the poll changes, it means that she asks the previous row. The order of asking the rows looks as follows: the 1-st row, the 2-nd row, ..., the n - 1-st row, the n-th row, the n - 1-st row, ..., the 2-nd row, the 1-st row, the 2-nd row, ...\n\nThe order of asking of pupils on the same row is always the same: the 1-st pupil, the 2-nd pupil, ..., the m-th pupil.\n\nDuring the lesson the teacher managed to ask exactly k questions from pupils in order described above. Sergei seats on the x-th row, on the y-th place in the row. Sergei decided to prove to the teacher that pupils are asked irregularly, help him count three values:  the maximum number of questions a particular pupil is asked,  the minimum number of questions a particular pupil is asked,  how many times the teacher asked Sergei. \n\nIf there is only one row in the class, then the teacher always asks children from this row.\n\n\n-----Input-----\n\nThe first and the only line contains five integers n, m, k, x and y (1 ≤ n, m ≤ 100, 1 ≤ k ≤ 10^18, 1 ≤ x ≤ n, 1 ≤ y ≤ m).\n\n\n-----Output-----\n\nPrint three integers:  the maximum number of questions a particular pupil is asked,  the minimum number of questions a particular pupil is asked,  how many times the teacher asked Sergei. \n\n\n-----Examples-----\nInput\n1 3 8 1 1\n\nOutput\n3 2 3\nInput\n4 2 9 4 2\n\nOutput\n2 1 1\nInput\n5 5 25 4 3\n\nOutput\n1 1 1\nInput\n100 100 1000000000000000000 100 100\n\nOutput\n101010101010101 50505050505051 50505050505051\n\n\n-----Note-----\n\nThe order of asking pupils in the first test:   the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table;  the pupil from the first row who seats at the third table;  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table;  the pupil from the first row who seats at the third table;  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table; \n\nThe order of asking pupils in the second test:   the pupil from the first row who seats at the first table;  the pupil from the first row who seats at the second table;  the pupil from the second row who seats at the first table;  the pupil from the second row who seats at the second table;  the pupil from the third row who seats at the first table;  the pupil from the third row who seats at the second table;  the pupil from the fourth row who seats at the first table;  the pupil from the fourth row who seats at the second table, it means it is Sergei;  the pupil from the third row who seats at the first table;",
        "generated_code": "n, m, k, x, y = map(int, input().split())\n\n# Convert 1-based indices to 0-based for easier calculations\nx -= 1\ny -= 1\n\n# Calculate the number of complete cycles (from 1st row to nth row and back to 1st)\nfull_cycle_length = (2 * n - 2) * m if n > 1 else m\n\n# Calculate the number of complete cycles that fit into k questions\nfull_cycles = k // full_cycle_length\n\n# Calculate the remaining questions after the full cycles\nremaining_questions = k % full_cycle_length\n\n# Initialize the counts for each pupil\nmin_questions = full_cycles\nmax_questions = full_cycles\n\n# Handle special cases for first row and last row\nif n > 1:\n    min_questions = full_cycles // (2 * n - 2)\n    max_questions = (full_cycles + n - 1) // (2 * n - 2)\n\n# Calculate the number of times Sergei is asked\nsergei_questions = min_questions\nif x == 0 or x == n - 1:  # First or last row\n    sergei_questions = full_cycles // (2 * n - 2) + (full_cycles % (2 * n - 2) >= 1)\nelse:\n    sergei_questions = (full_cycles + x - 1) // (2 * n - 2) + (full_cycles % (2 * n - 2) >= x)\n\n# Process the remaining questions\nrow = 0\ndirection = 1\nfor _ in range(remaining_questions):\n    for col in range(m):\n        if row == x and col == y:\n            sergei_questions += 1\n        if direction == 1:\n            max_questions += 1\n            row += direction\n            if row == n:\n                direction = -1\n                row -= 2\n        else:\n            max_questions -= 1\n            row += direction\n            if row == -1:\n                direction = 1\n                row += 2\n\nprint(max_questions, min_questions, sergei_questions)\n",
        "counter_example": {
            "input": "1 3 8 1 1\n",
            "expected": "3 2 3",
            "got": "Traceback (most recent call last):\n  File \"<string>\", line 28, in <module>\nZeroDivisionError: integer division or modulo by zero"
        }
    },
    {
        "task_id": "0260",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "One day, after a difficult lecture a diligent student Sasha saw a graffitied desk in the classroom. She came closer and read: \"Find such positive integer n, that among numbers n + 1, n + 2, ..., 2·n there are exactly m numbers which binary representation contains exactly k digits one\".\n\nThe girl got interested in the task and she asked you to help her solve it. Sasha knows that you are afraid of large numbers, so she guaranteed that there is an answer that doesn't exceed 10^18.\n\n\n-----Input-----\n\nThe first line contains two space-separated integers, m and k (0 ≤ m ≤ 10^18; 1 ≤ k ≤ 64).\n\n\n-----Output-----\n\nPrint the required number n (1 ≤ n ≤ 10^18). If there are multiple answers, print any of them.\n\n\n-----Examples-----\nInput\n1 1\n\nOutput\n1\n\nInput\n3 2\n\nOutput\n5",
        "generated_code": "m, k = map(int, input().split())\n\ndef count_ones(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef find_n(m, k):\n    n = 1\n    while True:\n        count = sum(1 for i in range(n + 1, 2 * n + 1) if count_ones(i) == k)\n        if count == m:\n            return n\n        n += 1\n\nprint(find_n(m, k))\n",
        "counter_example": {
            "input": "4 20\n",
            "expected": "983040\n",
            "got": "TimeoutError: Execution exceeded time limit"
        }
    },
    {
        "task_id": "0260",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "One day, after a difficult lecture a diligent student Sasha saw a graffitied desk in the classroom. She came closer and read: \"Find such positive integer n, that among numbers n + 1, n + 2, ..., 2·n there are exactly m numbers which binary representation contains exactly k digits one\".\n\nThe girl got interested in the task and she asked you to help her solve it. Sasha knows that you are afraid of large numbers, so she guaranteed that there is an answer that doesn't exceed 10^18.\n\n\n-----Input-----\n\nThe first line contains two space-separated integers, m and k (0 ≤ m ≤ 10^18; 1 ≤ k ≤ 64).\n\n\n-----Output-----\n\nPrint the required number n (1 ≤ n ≤ 10^18). If there are multiple answers, print any of them.\n\n\n-----Examples-----\nInput\n1 1\n\nOutput\n1\n\nInput\n3 2\n\nOutput\n5",
        "generated_code": "def count_set_bits(x):\n    return bin(x).count('1')\n\ndef find_n_for_m_k(m, k):\n    n = 1\n    while True:\n        count = 0\n        for i in range(n + 1, 2 * n + 1):\n            if count_set_bits(i) == k:\n                count += 1\n        if count == m:\n            print(n)\n            return\n        n += 1\n\n# Read input values for m and k\nm, k = map(int, input().split())\n\n# Find and print the required number n\nfind_n_for_m_k(m, k)\n",
        "counter_example": {
            "input": "4 20\n",
            "expected": "983040\n",
            "got": "TimeoutError: Execution exceeded time limit"
        }
    },
    {
        "task_id": "0113",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "For a given positive integer n denote its k-rounding as the minimum positive integer x, such that x ends with k or more zeros in base 10 and is divisible by n.\n\nFor example, 4-rounding of 375 is 375·80 = 30000. 30000 is the minimum integer such that it ends with 4 or more zeros and is divisible by 375.\n\nWrite a program that will perform the k-rounding of n.\n\n\n-----Input-----\n\nThe only line contains two integers n and k (1 ≤ n ≤ 10^9, 0 ≤ k ≤ 8).\n\n\n-----Output-----\n\nPrint the k-rounding of n.\n\n\n-----Examples-----\nInput\n375 4\n\nOutput\n30000\n\nInput\n10000 1\n\nOutput\n10000\n\nInput\n38101 0\n\nOutput\n38101\n\nInput\n123456789 8\n\nOutput\n12345678900000000",
        "generated_code": "n, k = map(int, input().split())\nx = 10 ** k\nwhile n % x != 0:\n    n += 1\nprint(n)\n",
        "counter_example": {
            "input": "375 4\n",
            "expected": "30000\n",
            "got": "10000"
        }
    },
    {
        "task_id": "0113",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "For a given positive integer n denote its k-rounding as the minimum positive integer x, such that x ends with k or more zeros in base 10 and is divisible by n.\n\nFor example, 4-rounding of 375 is 375·80 = 30000. 30000 is the minimum integer such that it ends with 4 or more zeros and is divisible by 375.\n\nWrite a program that will perform the k-rounding of n.\n\n\n-----Input-----\n\nThe only line contains two integers n and k (1 ≤ n ≤ 10^9, 0 ≤ k ≤ 8).\n\n\n-----Output-----\n\nPrint the k-rounding of n.\n\n\n-----Examples-----\nInput\n375 4\n\nOutput\n30000\n\nInput\n10000 1\n\nOutput\n10000\n\nInput\n38101 0\n\nOutput\n38101\n\nInput\n123456789 8\n\nOutput\n12345678900000000",
        "generated_code": "import math\n\ndef k_rounding(n, k):\n    # Calculate the minimum number that ends with at least k zeros\n    multiplier = 10**k\n    # Find the smallest number x that is a multiple of n and also ends with k zeros\n    x = (n * (multiplier // math.gcd(n, multiplier)))\n    return x\n\n# Read input\nn, k = map(int, input().split())\n# Print the k-rounding of n\nprint(k_rounding(n, k))\n",
        "counter_example": null
    }
]