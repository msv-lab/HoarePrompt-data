[
    {
        "task_id": "0187",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Petya and Vasya decided to play a game. They have n cards (n is an even number). A single integer is written on each card.\n\nBefore the game Petya will choose an integer and after that Vasya will choose another integer (different from the number that Petya chose). During the game each player takes all the cards with number he chose. For example, if Petya chose number 5 before the game he will take all cards on which 5 is written and if Vasya chose number 10 before the game he will take all cards on which 10 is written.\n\nThe game is considered fair if Petya and Vasya can take all n cards, and the number of cards each player gets is the same.\n\nDetermine whether Petya and Vasya can choose integer numbers before the game so that the game is fair. \n\n\n-----Input-----\n\nThe first line contains a single integer n (2 ≤ n ≤ 100) — number of cards. It is guaranteed that n is an even number.\n\nThe following n lines contain a sequence of integers a_1, a_2, ..., a_{n} (one integer per line, 1 ≤ a_{i} ≤ 100) — numbers written on the n cards.\n\n\n-----Output-----\n\nIf it is impossible for Petya and Vasya to choose numbers in such a way that the game will be fair, print \"NO\" (without quotes) in the first line. In this case you should not print anything more.\n\nIn the other case print \"YES\" (without quotes) in the first line. In the second line print two distinct integers — number that Petya should choose and the number that Vasya should choose to make the game fair. If there are several solutions, print any of them.\n\n\n-----Examples-----\nInput\n4\n11\n27\n27\n11\n\nOutput\nYES\n11 27\n\nInput\n2\n6\n6\n\nOutput\nNO\n\nInput\n6\n10\n20\n30\n20\n10\n20\n\nOutput\nNO\n\nInput\n6\n1\n1\n2\n2\n3\n3\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first example the game will be fair if, for example, Petya chooses number 11, and Vasya chooses number 27. Then the will take all cards — Petya will take cards 1 and 4, and Vasya will take cards 2 and 3. Thus, each of them will take exactly two cards.\n\nIn the second example fair game is impossible because the numbers written on the cards are equal, but the numbers that Petya and Vasya should choose should be distinct.\n\nIn the third example it is impossible to take all cards. Petya and Vasya can take at most five cards — for example, Petya can choose number 10 and Vasya can choose number 20. But for the game to be fair it is necessary to take 6 cards.",
        "generated_code": "n = int(input())\ncards = {}\nfor _ in range(n):\n    num = int(input())\n    if num in cards:\n        cards[num] += 1\n    else:\n        cards[num] = 1\n\nfor key, value in cards.items():\n    if value % 2 != 0:\n        print(\"NO\")\n        exit()\n\nif len(cards) == 1:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for key in cards.keys():\n        print(key, end=\" \")\n        break\n    for key in list(cards.keys())[1:]:\n        print(key)\n        break\n",
        "counter_example": {
            "input": "6\n1\n1\n2\n2\n3\n3\n",
            "expected": "NO\n",
            "got": "YES\n1 2"
        }
    },
    {
        "task_id": "0187",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Petya and Vasya decided to play a game. They have n cards (n is an even number). A single integer is written on each card.\n\nBefore the game Petya will choose an integer and after that Vasya will choose another integer (different from the number that Petya chose). During the game each player takes all the cards with number he chose. For example, if Petya chose number 5 before the game he will take all cards on which 5 is written and if Vasya chose number 10 before the game he will take all cards on which 10 is written.\n\nThe game is considered fair if Petya and Vasya can take all n cards, and the number of cards each player gets is the same.\n\nDetermine whether Petya and Vasya can choose integer numbers before the game so that the game is fair. \n\n\n-----Input-----\n\nThe first line contains a single integer n (2 ≤ n ≤ 100) — number of cards. It is guaranteed that n is an even number.\n\nThe following n lines contain a sequence of integers a_1, a_2, ..., a_{n} (one integer per line, 1 ≤ a_{i} ≤ 100) — numbers written on the n cards.\n\n\n-----Output-----\n\nIf it is impossible for Petya and Vasya to choose numbers in such a way that the game will be fair, print \"NO\" (without quotes) in the first line. In this case you should not print anything more.\n\nIn the other case print \"YES\" (without quotes) in the first line. In the second line print two distinct integers — number that Petya should choose and the number that Vasya should choose to make the game fair. If there are several solutions, print any of them.\n\n\n-----Examples-----\nInput\n4\n11\n27\n27\n11\n\nOutput\nYES\n11 27\n\nInput\n2\n6\n6\n\nOutput\nNO\n\nInput\n6\n10\n20\n30\n20\n10\n20\n\nOutput\nNO\n\nInput\n6\n1\n1\n2\n2\n3\n3\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first example the game will be fair if, for example, Petya chooses number 11, and Vasya chooses number 27. Then the will take all cards — Petya will take cards 1 and 4, and Vasya will take cards 2 and 3. Thus, each of them will take exactly two cards.\n\nIn the second example fair game is impossible because the numbers written on the cards are equal, but the numbers that Petya and Vasya should choose should be distinct.\n\nIn the third example it is impossible to take all cards. Petya and Vasya can take at most five cards — for example, Petya can choose number 10 and Vasya can choose number 20. But for the game to be fair it is necessary to take 6 cards.",
        "generated_code": "n = int(input())\ncards = [int(input()) for _ in range(n)]\n\nfrom collections import Counter\n\ncard_count = Counter(cards)\nmost_common = card_count.most_common()\n\nif len(most_common) < 2:\n    print(\"NO\")\nelse:\n    first_count = most_common[0][1]\n    second_count = most_common[1][1]\n    if first_count + second_count == n and first_count == second_count:\n        print(\"YES\")\n        print(most_common[0][0], most_common[1][0])\n    else:\n        print(\"NO\")\n",
        "counter_example": {
            "input": "20\n34\n34\n34\n34\n34\n34\n34\n34\n34\n34\n11\n11\n11\n11\n11\n11\n11\n11\n11\n11\n",
            "expected": "YES\n11 34\n",
            "got": "YES\n34 11"
        }
    },
    {
        "task_id": "0095",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Array of integers is unimodal, if:\n\n  it is strictly increasing in the beginning;  after that it is constant;  after that it is strictly decreasing. \n\nThe first block (increasing) and the last block (decreasing) may be absent. It is allowed that both of this blocks are absent.\n\nFor example, the following three arrays are unimodal: [5, 7, 11, 11, 2, 1], [4, 4, 2], [7], but the following three are not unimodal: [5, 5, 6, 6, 1], [1, 2, 1, 2], [4, 5, 5, 6].\n\nWrite a program that checks if an array is unimodal.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 100) — the number of elements in the array.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 1 000) — the elements of the array.\n\n\n-----Output-----\n\nPrint \"YES\" if the given array is unimodal. Otherwise, print \"NO\".\n\nYou can output each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n6\n1 5 5 5 4 2\n\nOutput\nYES\n\nInput\n5\n10 20 30 20 10\n\nOutput\nYES\n\nInput\n4\n1 2 1 2\n\nOutput\nNO\n\nInput\n7\n3 3 3 3 3 3 3\n\nOutput\nYES\n\n\n\n-----Note-----\n\nIn the first example the array is unimodal, because it is strictly increasing in the beginning (from position 1 to position 2, inclusively), that it is constant (from position 2 to position 4, inclusively) and then it is strictly decreasing (from position 4 to position 6, inclusively).",
        "generated_code": "n = int(input())\narr = list(map(int, input().split()))\n\nincreasing = False\nconstant = False\ndecreasing = False\n\nfor i in range(1, n):\n    if arr[i] > arr[i-1]:\n        if decreasing:\n            print(\"NO\")\n            exit()\n        increasing = True\n    elif arr[i] == arr[i-1]:\n        if increasing:\n            increasing = False\n            constant = True\n    else:\n        if increasing:\n            increasing = False\n        decreasing = True\n\nprint(\"YES\")\n",
        "counter_example": {
            "input": "5\n5 5 6 6 1\n",
            "expected": "NO\n",
            "got": "YES"
        }
    },
    {
        "task_id": "0095",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Array of integers is unimodal, if:\n\n  it is strictly increasing in the beginning;  after that it is constant;  after that it is strictly decreasing. \n\nThe first block (increasing) and the last block (decreasing) may be absent. It is allowed that both of this blocks are absent.\n\nFor example, the following three arrays are unimodal: [5, 7, 11, 11, 2, 1], [4, 4, 2], [7], but the following three are not unimodal: [5, 5, 6, 6, 1], [1, 2, 1, 2], [4, 5, 5, 6].\n\nWrite a program that checks if an array is unimodal.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 100) — the number of elements in the array.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 1 000) — the elements of the array.\n\n\n-----Output-----\n\nPrint \"YES\" if the given array is unimodal. Otherwise, print \"NO\".\n\nYou can output each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n6\n1 5 5 5 4 2\n\nOutput\nYES\n\nInput\n5\n10 20 30 20 10\n\nOutput\nYES\n\nInput\n4\n1 2 1 2\n\nOutput\nNO\n\nInput\n7\n3 3 3 3 3 3 3\n\nOutput\nYES\n\n\n\n-----Note-----\n\nIn the first example the array is unimodal, because it is strictly increasing in the beginning (from position 1 to position 2, inclusively), that it is constant (from position 2 to position 4, inclusively) and then it is strictly decreasing (from position 4 to position 6, inclusively).",
        "generated_code": "# Use Standard Input format\n\nn = int(input())\na = list(map(int, input().split()))\n\ndef is_unimodal(arr):\n    i = 0\n    n = len(arr)\n    \n    # Increasing phase\n    while i + 1 < n and arr[i] < arr[i + 1]:\n        i += 1\n    \n    # Constant phase\n    while i + 1 < n and arr[i] == arr[i + 1]:\n        i += 1\n    \n    # Decreasing phase\n    while i + 1 < n and arr[i] > arr[i + 1]:\n        i += 1\n    \n    # If we have traversed the entire array, it's unimodal\n    return i == n - 1\n\nif is_unimodal(a):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "counter_example": null
    },
    {
        "task_id": "0161",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Cat Furrier Transform is a popular algorithm among cat programmers to create longcats. As one of the greatest cat programmers ever exist, Neko wants to utilize this algorithm to create the perfect longcat.\n\nAssume that we have a cat with a number $x$. A perfect longcat is a cat with a number equal $2^m - 1$ for some non-negative integer $m$. For example, the numbers $0$, $1$, $3$, $7$, $15$ and so on are suitable for the perfect longcats.\n\nIn the Cat Furrier Transform, the following operations can be performed on $x$:  (Operation A): you select any non-negative integer $n$ and replace $x$ with $x \\oplus (2^n - 1)$, with $\\oplus$ being a bitwise XOR operator. (Operation B): replace $x$ with $x + 1$. \n\nThe first applied operation must be of type A, the second of type B, the third of type A again, and so on. Formally, if we number operations from one in the order they are executed, then odd-numbered operations must be of type A and the even-numbered operations must be of type B.\n\nNeko wants to produce perfect longcats at industrial scale, thus for each cat Neko only wants to perform at most $40$ operations. Can you help Neko writing a transformation plan?\n\nNote that it is not required to minimize the number of operations. You just need to use no more than $40$ operations.\n\n\n-----Input-----\n\nThe only line contains a single integer $x$ ($1 \\le x \\le 10^6$).\n\n\n-----Output-----\n\nThe first line should contain a single integer $t$ ($0 \\le t \\le 40$) — the number of operations to apply.\n\nThen for each odd-numbered operation print the corresponding number $n_i$ in it. That is, print $\\lceil \\frac{t}{2} \\rceil$ integers $n_i$ ($0 \\le n_i \\le 30$), denoting the replacement $x$ with $x \\oplus (2^{n_i} - 1)$ in the corresponding step.\n\nIf there are multiple possible answers, you can print any of them. It is possible to show, that there is at least one answer in the constraints of this problem.\n\n\n-----Examples-----\nInput\n39\n\nOutput\n4\n5 3 \nInput\n1\n\nOutput\n0\n\nInput\n7\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first test, one of the transforms might be as follows: $39 \\to 56 \\to 57 \\to 62 \\to 63$. Or more precisely: Pick $n = 5$. $x$ is transformed into $39 \\oplus 31$, or $56$.  Increase $x$ by $1$, changing its value to $57$.  Pick $n = 3$. $x$ is transformed into $57 \\oplus 7$, or $62$.  Increase $x$ by $1$, changing its value to $63 = 2^6 - 1$. \n\nIn the second and third test, the number already satisfies the goal requirement.",
        "generated_code": "x = int(input())\nm = 0\nwhile (1 << m) - 1 < x:\n    m += 1\nt = 0\noperations = []\nwhile x != (1 << m) - 1:\n    n = m\n    while (x ^ ((1 << n) - 1)) != (1 << m) - 1:\n        n -= 1\n    x ^= (1 << n) - 1\n    operations.append(n)\n    x += 1\n    t += 2\nprint(t)\nfor i in range(0, t, 2):\n    print(operations[i])\n",
        "counter_example": {
            "input": "39\n",
            "expected": "4\n5 3 ",
            "got": "Traceback (most recent call last):\n  File \"<string>\", line 9, in <module>\nValueError: negative shift count"
        }
    },
    {
        "task_id": "0161",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Cat Furrier Transform is a popular algorithm among cat programmers to create longcats. As one of the greatest cat programmers ever exist, Neko wants to utilize this algorithm to create the perfect longcat.\n\nAssume that we have a cat with a number $x$. A perfect longcat is a cat with a number equal $2^m - 1$ for some non-negative integer $m$. For example, the numbers $0$, $1$, $3$, $7$, $15$ and so on are suitable for the perfect longcats.\n\nIn the Cat Furrier Transform, the following operations can be performed on $x$:  (Operation A): you select any non-negative integer $n$ and replace $x$ with $x \\oplus (2^n - 1)$, with $\\oplus$ being a bitwise XOR operator. (Operation B): replace $x$ with $x + 1$. \n\nThe first applied operation must be of type A, the second of type B, the third of type A again, and so on. Formally, if we number operations from one in the order they are executed, then odd-numbered operations must be of type A and the even-numbered operations must be of type B.\n\nNeko wants to produce perfect longcats at industrial scale, thus for each cat Neko only wants to perform at most $40$ operations. Can you help Neko writing a transformation plan?\n\nNote that it is not required to minimize the number of operations. You just need to use no more than $40$ operations.\n\n\n-----Input-----\n\nThe only line contains a single integer $x$ ($1 \\le x \\le 10^6$).\n\n\n-----Output-----\n\nThe first line should contain a single integer $t$ ($0 \\le t \\le 40$) — the number of operations to apply.\n\nThen for each odd-numbered operation print the corresponding number $n_i$ in it. That is, print $\\lceil \\frac{t}{2} \\rceil$ integers $n_i$ ($0 \\le n_i \\le 30$), denoting the replacement $x$ with $x \\oplus (2^{n_i} - 1)$ in the corresponding step.\n\nIf there are multiple possible answers, you can print any of them. It is possible to show, that there is at least one answer in the constraints of this problem.\n\n\n-----Examples-----\nInput\n39\n\nOutput\n4\n5 3 \nInput\n1\n\nOutput\n0\n\nInput\n7\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first test, one of the transforms might be as follows: $39 \\to 56 \\to 57 \\to 62 \\to 63$. Or more precisely: Pick $n = 5$. $x$ is transformed into $39 \\oplus 31$, or $56$.  Increase $x$ by $1$, changing its value to $57$.  Pick $n = 3$. $x$ is transformed into $57 \\oplus 7$, or $62$.  Increase $x$ by $1$, changing its value to $63 = 2^6 - 1$. \n\nIn the second and third test, the number already satisfies the goal requirement.",
        "generated_code": "def is_perfect_longcat(x):\n    # Check if x is of the form 2^m - 1\n    return (x & (x + 1)) == 0\n\ndef find_transform(x):\n    operations = []\n    count = 0\n    while not is_perfect_longcat(x) and count < 40:\n        if count % 2 == 0:\n            # Operation A\n            n = 0\n            while (1 << n) - 1 <= x:\n                n += 1\n            # Find the highest bit position with 0\n            while n > 0 and ((x >> (n - 1)) & 1) == 1:\n                n -= 1\n            if n == 0:\n                break\n            operations.append(n)\n            x ^= (1 << n) - 1\n        else:\n            # Operation B\n            x += 1\n        count += 1\n    \n    return count, operations\n\n# Read input\nx = int(input())\n\nt, ops = find_transform(x)\n\nprint(t)\nfor i in range(0, len(ops), 2):\n    print(ops[i], end=' ')\n",
        "counter_example": {
            "input": "39\n",
            "expected": "4\n5 3 ",
            "got": "4\n5"
        }
    },
    {
        "task_id": "0202",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": true,
        "description": "Professor GukiZ makes a new robot. The robot are in the point with coordinates (x_1, y_1) and should go to the point (x_2, y_2). In a single step the robot can change any of its coordinates (maybe both of them) by one (decrease or increase). So the robot can move in one of the 8 directions. Find the minimal number of steps the robot should make to get the finish position.\n\n\n-----Input-----\n\nThe first line contains two integers x_1, y_1 ( - 10^9 ≤ x_1, y_1 ≤ 10^9) — the start position of the robot.\n\nThe second line contains two integers x_2, y_2 ( - 10^9 ≤ x_2, y_2 ≤ 10^9) — the finish position of the robot.\n\n\n-----Output-----\n\nPrint the only integer d — the minimal number of steps to get the finish position.\n\n\n-----Examples-----\nInput\n0 0\n4 5\n\nOutput\n5\n\nInput\n3 4\n6 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first example robot should increase both of its coordinates by one four times, so it will be in position (4, 4). After that robot should simply increase its y coordinate and get the finish position.\n\nIn the second example robot should simultaneously increase x coordinate and decrease y coordinate by one three times.",
        "generated_code": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\ndx = abs(x1 - x2)\ndy = abs(y1 - y2)\n\nprint(max(dx, dy))\n",
        "counter_example": null
    },
    {
        "task_id": "0202",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Professor GukiZ makes a new robot. The robot are in the point with coordinates (x_1, y_1) and should go to the point (x_2, y_2). In a single step the robot can change any of its coordinates (maybe both of them) by one (decrease or increase). So the robot can move in one of the 8 directions. Find the minimal number of steps the robot should make to get the finish position.\n\n\n-----Input-----\n\nThe first line contains two integers x_1, y_1 ( - 10^9 ≤ x_1, y_1 ≤ 10^9) — the start position of the robot.\n\nThe second line contains two integers x_2, y_2 ( - 10^9 ≤ x_2, y_2 ≤ 10^9) — the finish position of the robot.\n\n\n-----Output-----\n\nPrint the only integer d — the minimal number of steps to get the finish position.\n\n\n-----Examples-----\nInput\n0 0\n4 5\n\nOutput\n5\n\nInput\n3 4\n6 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first example robot should increase both of its coordinates by one four times, so it will be in position (4, 4). After that robot should simply increase its y coordinate and get the finish position.\n\nIn the second example robot should simultaneously increase x coordinate and decrease y coordinate by one three times.",
        "generated_code": "# Read the input values\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Calculate the minimal number of steps\nsteps = max(abs(x2 - x1), abs(y2 - y1))\n\n# Print the result\nprint(steps)\n",
        "counter_example": null
    },
    {
        "task_id": "0275",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Piegirl got bored with binary, decimal and other integer based counting systems. Recently she discovered some interesting properties about number $q = \\frac{\\sqrt{5} + 1}{2}$, in particular that q^2 = q + 1, and she thinks it would make a good base for her new unique system. She called it \"golden system\". In golden system the number is a non-empty string containing 0's and 1's as digits. The decimal value of expression a_0a_1...a_{n} equals to $\\sum_{i = 0}^{n} a_{i} \\cdot q^{n - i}$.\n\nSoon Piegirl found out that this system doesn't have same properties that integer base systems do and some operations can not be performed on it. She wasn't able to come up with a fast way of comparing two numbers. She is asking for your help.\n\nGiven two numbers written in golden system notation, determine which of them has larger decimal value.\n\n\n-----Input-----\n\nInput consists of two lines — one for each number. Each line contains non-empty string consisting of '0' and '1' characters. The length of each string does not exceed 100000.\n\n\n-----Output-----\n\nPrint \">\" if the first number is larger, \"<\" if it is smaller and \"=\" if they are equal.\n\n\n-----Examples-----\nInput\n1000\n111\n\nOutput\n<\n\nInput\n00100\n11\n\nOutput\n=\n\nInput\n110\n101\n\nOutput\n>\n\n\n\n-----Note-----\n\nIn the first example first number equals to $((\\sqrt{5} + 1) / 2)^{3} \\approx 1.618033988^{3} \\approx 4.236$, while second number is approximately 1.618033988^2 + 1.618033988 + 1 ≈ 5.236, which is clearly a bigger number.\n\nIn the second example numbers are equal. Each of them is  ≈ 2.618.",
        "generated_code": "import math\n\ndef golden_to_decimal(s):\n    q = (math.sqrt(5) + 1) / 2\n    decimal = 0\n    for i, c in enumerate(reversed(s)):\n        decimal += int(c) * (q ** i)\n    return decimal\n\na = input()\nb = input()\n\ndecimal_a = golden_to_decimal(a)\ndecimal_b = golden_to_decimal(b)\n\nif decimal_a > decimal_b:\n    print('>')\nelif decimal_a < decimal_b:\n    print('<')\nelse:\n    print('=')\n",
        "counter_example": {
            "input": "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\n",
            "expected": "<\n",
            "got": ">"
        }
    },
    {
        "task_id": "0275",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Piegirl got bored with binary, decimal and other integer based counting systems. Recently she discovered some interesting properties about number $q = \\frac{\\sqrt{5} + 1}{2}$, in particular that q^2 = q + 1, and she thinks it would make a good base for her new unique system. She called it \"golden system\". In golden system the number is a non-empty string containing 0's and 1's as digits. The decimal value of expression a_0a_1...a_{n} equals to $\\sum_{i = 0}^{n} a_{i} \\cdot q^{n - i}$.\n\nSoon Piegirl found out that this system doesn't have same properties that integer base systems do and some operations can not be performed on it. She wasn't able to come up with a fast way of comparing two numbers. She is asking for your help.\n\nGiven two numbers written in golden system notation, determine which of them has larger decimal value.\n\n\n-----Input-----\n\nInput consists of two lines — one for each number. Each line contains non-empty string consisting of '0' and '1' characters. The length of each string does not exceed 100000.\n\n\n-----Output-----\n\nPrint \">\" if the first number is larger, \"<\" if it is smaller and \"=\" if they are equal.\n\n\n-----Examples-----\nInput\n1000\n111\n\nOutput\n<\n\nInput\n00100\n11\n\nOutput\n=\n\nInput\n110\n101\n\nOutput\n>\n\n\n\n-----Note-----\n\nIn the first example first number equals to $((\\sqrt{5} + 1) / 2)^{3} \\approx 1.618033988^{3} \\approx 4.236$, while second number is approximately 1.618033988^2 + 1.618033988 + 1 ≈ 5.236, which is clearly a bigger number.\n\nIn the second example numbers are equal. Each of them is  ≈ 2.618.",
        "generated_code": "def golden_system_value(s):\n    q = (5 ** 0.5 + 1) / 2\n    value = 0\n    n = len(s)\n    for i in range(n):\n        if s[i] == '1':\n            value += q ** (n - i - 1)\n    return value\n\ns1 = input().strip()\ns2 = input().strip()\n\nvalue1 = golden_system_value(s1)\nvalue2 = golden_system_value(s2)\n\nif value1 > value2:\n    print(\">\")\nelif value1 < value2:\n    print(\"<\")\nelse:\n    print(\"=\")\n",
        "counter_example": {
            "input": "010000100010100000100010001000001100100010110000101010000010010011001111101101001\n001011100001110101111001100110001011011100000000100111011010010011010100101011111\n",
            "expected": "=\n",
            "got": ">"
        }
    }
]