[
    {
        "task_id": "0277",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "The last stage of Football World Cup is played using the play-off system.\n\nThere are n teams left in this stage, they are enumerated from 1 to n. Several rounds are held, in each round the remaining teams are sorted in the order of their ids, then the first in this order plays with the second, the third — with the fourth, the fifth — with the sixth, and so on. It is guaranteed that in each round there is even number of teams. The winner of each game advances to the next round, the loser is eliminated from the tournament, there are no draws. In the last round there is the only game with two remaining teams: the round is called the Final, the winner is called the champion, and the tournament is over.\n\nArkady wants his two favorite teams to play in the Final. Unfortunately, the team ids are already determined, and it may happen that it is impossible for teams to meet in the Final, because they are to meet in some earlier stage, if they are strong enough. Determine, in which round the teams with ids a and b can meet.\n\n\n-----Input-----\n\nThe only line contains three integers n, a and b (2 ≤ n ≤ 256, 1 ≤ a, b ≤ n) — the total number of teams, and the ids of the teams that Arkady is interested in. \n\nIt is guaranteed that n is such that in each round an even number of team advance, and that a and b are not equal.\n\n\n-----Output-----\n\nIn the only line print \"Final!\" (without quotes), if teams a and b can meet in the Final.\n\nOtherwise, print a single integer — the number of the round in which teams a and b can meet. The round are enumerated from 1.\n\n\n-----Examples-----\nInput\n4 1 2\n\nOutput\n1\n\nInput\n8 2 6\n\nOutput\nFinal!\n\nInput\n8 7 5\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first example teams 1 and 2 meet in the first round.\n\nIn the second example teams 2 and 6 can only meet in the third round, which is the Final, if they win all their opponents in earlier rounds.\n\nIn the third example the teams with ids 7 and 5 can meet in the second round, if they win their opponents in the first round.",
        "generated_code": "n, a, b = map(int, input().split())\nif (a + b - 1) & (a + b - 2):\n    print(\"Final!\")\nelse:\n    print(((a ^ b).bit_length() - 1))\n",
        "counter_example": {
            "input": "8 7 5\n",
            "expected": "2\n",
            "got": "Final!"
        }
    },
    {
        "task_id": "0277",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "The last stage of Football World Cup is played using the play-off system.\n\nThere are n teams left in this stage, they are enumerated from 1 to n. Several rounds are held, in each round the remaining teams are sorted in the order of their ids, then the first in this order plays with the second, the third — with the fourth, the fifth — with the sixth, and so on. It is guaranteed that in each round there is even number of teams. The winner of each game advances to the next round, the loser is eliminated from the tournament, there are no draws. In the last round there is the only game with two remaining teams: the round is called the Final, the winner is called the champion, and the tournament is over.\n\nArkady wants his two favorite teams to play in the Final. Unfortunately, the team ids are already determined, and it may happen that it is impossible for teams to meet in the Final, because they are to meet in some earlier stage, if they are strong enough. Determine, in which round the teams with ids a and b can meet.\n\n\n-----Input-----\n\nThe only line contains three integers n, a and b (2 ≤ n ≤ 256, 1 ≤ a, b ≤ n) — the total number of teams, and the ids of the teams that Arkady is interested in. \n\nIt is guaranteed that n is such that in each round an even number of team advance, and that a and b are not equal.\n\n\n-----Output-----\n\nIn the only line print \"Final!\" (without quotes), if teams a and b can meet in the Final.\n\nOtherwise, print a single integer — the number of the round in which teams a and b can meet. The round are enumerated from 1.\n\n\n-----Examples-----\nInput\n4 1 2\n\nOutput\n1\n\nInput\n8 2 6\n\nOutput\nFinal!\n\nInput\n8 7 5\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first example teams 1 and 2 meet in the first round.\n\nIn the second example teams 2 and 6 can only meet in the third round, which is the Final, if they win all their opponents in earlier rounds.\n\nIn the third example the teams with ids 7 and 5 can meet in the second round, if they win their opponents in the first round.",
        "generated_code": "n, a, b = map(int, input().split())\n\n# Function to determine the round in which two teams will meet\ndef find_round(n, a, b):\n    round_num = 0\n    while n > 1:\n        round_num += 1\n        # Move to the next round\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        # Check if they meet in this round\n        if a == b:\n            return round_num\n        # Halve the number of teams for the next round\n        n //= 2\n    return round_num\n\n# Calculate the round they meet\nround_met = find_round(n, a, b)\n\n# Print the result\nif (1 << (round_met - 1)) == 2:\n    print(\"Final!\")\nelse:\n    print(round_met)\n",
        "counter_example": {
            "input": "8 2 6\n",
            "expected": "Final!\n",
            "got": "3"
        }
    },
    {
        "task_id": "0148",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "The circle line of the Roflanpolis subway has $n$ stations.\n\nThere are two parallel routes in the subway. The first one visits stations in order $1 \\to 2 \\to \\ldots \\to n \\to 1 \\to 2 \\to \\ldots$ (so the next stop after station $x$ is equal to $(x+1)$ if $x < n$ and $1$ otherwise). The second route visits stations in order $n \\to (n-1) \\to \\ldots \\to 1 \\to n \\to (n-1) \\to \\ldots$ (so the next stop after station $x$ is equal to $(x-1)$ if $x>1$ and $n$ otherwise). All trains depart their stations simultaneously, and it takes exactly $1$ minute to arrive at the next station.\n\nTwo toads live in this city, their names are Daniel and Vlad.\n\nDaniel is currently in a train of the first route at station $a$ and will exit the subway when his train reaches station $x$.\n\nCoincidentally, Vlad is currently in a train of the second route at station $b$ and he will exit the subway when his train reaches station $y$.\n\nSurprisingly, all numbers $a,x,b,y$ are distinct.\n\nToad Ilya asks you to check if Daniel and Vlad will ever be at the same station at the same time during their journey. In other words, check if there is a moment when their trains stop at the same station. Note that this includes the moments when Daniel or Vlad enter or leave the subway.\n\n\n-----Input-----\n\nThe first line contains five space-separated integers $n$, $a$, $x$, $b$, $y$ ($4 \\leq n \\leq 100$, $1 \\leq a, x, b, y \\leq n$, all numbers among $a$, $x$, $b$, $y$ are distinct) — the number of stations in Roflanpolis, Daniel's start station, Daniel's finish station, Vlad's start station and Vlad's finish station, respectively.\n\n\n-----Output-----\n\nOutput \"YES\" if there is a time moment when Vlad and Daniel are at the same station, and \"NO\" otherwise. You can print each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n5 1 4 3 2\n\nOutput\nYES\n\nInput\n10 2 1 9 10\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first example, Daniel and Vlad start at the stations $(1, 3)$. One minute later they are at stations $(2, 2)$. They are at the same station at this moment. Note that Vlad leaves the subway right after that.\n\nConsider the second example, let's look at the stations Vlad and Daniel are at. They are:   initially $(2, 9)$,  after $1$ minute $(3, 8)$,  after $2$ minutes $(4, 7)$,  after $3$ minutes $(5, 6)$,  after $4$ minutes $(6, 5)$,  after $5$ minutes $(7, 4)$,  after $6$ minutes $(8, 3)$,  after $7$ minutes $(9, 2)$,  after $8$ minutes $(10, 1)$,  after $9$ minutes $(1, 10)$. \n\nAfter that, they both leave the subway because they are at their finish stations, so there is no moment when they both are at the same station.",
        "generated_code": "n, a, x, b, y = map(int, input().split())\nif (x - a) % (n - 1) == (y - b) % (n - 1):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "counter_example": {
            "input": "100 2 97 84 89\n",
            "expected": "YES\n",
            "got": "NO"
        }
    },
    {
        "task_id": "0148",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "The circle line of the Roflanpolis subway has $n$ stations.\n\nThere are two parallel routes in the subway. The first one visits stations in order $1 \\to 2 \\to \\ldots \\to n \\to 1 \\to 2 \\to \\ldots$ (so the next stop after station $x$ is equal to $(x+1)$ if $x < n$ and $1$ otherwise). The second route visits stations in order $n \\to (n-1) \\to \\ldots \\to 1 \\to n \\to (n-1) \\to \\ldots$ (so the next stop after station $x$ is equal to $(x-1)$ if $x>1$ and $n$ otherwise). All trains depart their stations simultaneously, and it takes exactly $1$ minute to arrive at the next station.\n\nTwo toads live in this city, their names are Daniel and Vlad.\n\nDaniel is currently in a train of the first route at station $a$ and will exit the subway when his train reaches station $x$.\n\nCoincidentally, Vlad is currently in a train of the second route at station $b$ and he will exit the subway when his train reaches station $y$.\n\nSurprisingly, all numbers $a,x,b,y$ are distinct.\n\nToad Ilya asks you to check if Daniel and Vlad will ever be at the same station at the same time during their journey. In other words, check if there is a moment when their trains stop at the same station. Note that this includes the moments when Daniel or Vlad enter or leave the subway.\n\n\n-----Input-----\n\nThe first line contains five space-separated integers $n$, $a$, $x$, $b$, $y$ ($4 \\leq n \\leq 100$, $1 \\leq a, x, b, y \\leq n$, all numbers among $a$, $x$, $b$, $y$ are distinct) — the number of stations in Roflanpolis, Daniel's start station, Daniel's finish station, Vlad's start station and Vlad's finish station, respectively.\n\n\n-----Output-----\n\nOutput \"YES\" if there is a time moment when Vlad and Daniel are at the same station, and \"NO\" otherwise. You can print each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n5 1 4 3 2\n\nOutput\nYES\n\nInput\n10 2 1 9 10\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first example, Daniel and Vlad start at the stations $(1, 3)$. One minute later they are at stations $(2, 2)$. They are at the same station at this moment. Note that Vlad leaves the subway right after that.\n\nConsider the second example, let's look at the stations Vlad and Daniel are at. They are:   initially $(2, 9)$,  after $1$ minute $(3, 8)$,  after $2$ minutes $(4, 7)$,  after $3$ minutes $(5, 6)$,  after $4$ minutes $(6, 5)$,  after $5$ minutes $(7, 4)$,  after $6$ minutes $(8, 3)$,  after $7$ minutes $(9, 2)$,  after $8$ minutes $(10, 1)$,  after $9$ minutes $(1, 10)$. \n\nAfter that, they both leave the subway because they are at their finish stations, so there is no moment when they both are at the same station.",
        "generated_code": "# Read input\nn, a, x, b, y = map(int, input().split())\n\n# Simulate the movement of Daniel and Vlad\nwhile True:\n    if a == b:  # If Daniel and Vlad meet at the same station\n        print(\"YES\")\n        break\n    if a == x or b == y:  # If either of them reaches their destination\n        print(\"NO\")\n        break\n    # Move Daniel to the next station in clockwise direction\n    a = a + 1 if a < n else 1\n    # Move Vlad to the next station in counterclockwise direction\n    b = b - 1 if b > 1 else n\n",
        "counter_example": null
    },
    {
        "task_id": "0169",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Kolya Gerasimov loves kefir very much. He lives in year 1984 and knows all the details of buying this delicious drink. One day, as you probably know, he found himself in year 2084, and buying kefir there is much more complicated.\n\nKolya is hungry, so he went to the nearest milk shop. In 2084 you may buy kefir in a plastic liter bottle, that costs a rubles, or in glass liter bottle, that costs b rubles. Also, you may return empty glass bottle and get c (c < b) rubles back, but you cannot return plastic bottles.\n\nKolya has n rubles and he is really hungry, so he wants to drink as much kefir as possible. There were no plastic bottles in his 1984, so Kolya doesn't know how to act optimally and asks for your help.\n\n\n-----Input-----\n\nFirst line of the input contains a single integer n (1 ≤ n ≤ 10^18) — the number of rubles Kolya has at the beginning.\n\nThen follow three lines containing integers a, b and c (1 ≤ a ≤ 10^18, 1 ≤ c < b ≤ 10^18) — the cost of one plastic liter bottle, the cost of one glass liter bottle and the money one can get back by returning an empty glass bottle, respectively.\n\n\n-----Output-----\n\nPrint the only integer — maximum number of liters of kefir, that Kolya can drink.\n\n\n-----Examples-----\nInput\n10\n11\n9\n8\n\nOutput\n2\n\nInput\n10\n5\n6\n1\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first sample, Kolya can buy one glass bottle, then return it and buy one more glass bottle. Thus he will drink 2 liters of kefir.\n\nIn the second sample, Kolya can buy two plastic bottle and get two liters of kefir, or he can buy one liter glass bottle, then return it and buy one plastic bottle. In both cases he will drink two liters of kefir.",
        "generated_code": "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nglass = n // b\nremain = n % b\nkefir = glass\n\nwhile remain >= c:\n    new_glass = remain // c\n    kefir += new_glass\n    remain = new_glass + remain % c\n\nplastic = n // a\nkefir = max(kefir, plastic)\n\nprint(kefir)\n",
        "counter_example": {
            "input": "10\n11\n9\n8\n",
            "expected": "2\n",
            "got": "1"
        }
    },
    {
        "task_id": "0169",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Kolya Gerasimov loves kefir very much. He lives in year 1984 and knows all the details of buying this delicious drink. One day, as you probably know, he found himself in year 2084, and buying kefir there is much more complicated.\n\nKolya is hungry, so he went to the nearest milk shop. In 2084 you may buy kefir in a plastic liter bottle, that costs a rubles, or in glass liter bottle, that costs b rubles. Also, you may return empty glass bottle and get c (c < b) rubles back, but you cannot return plastic bottles.\n\nKolya has n rubles and he is really hungry, so he wants to drink as much kefir as possible. There were no plastic bottles in his 1984, so Kolya doesn't know how to act optimally and asks for your help.\n\n\n-----Input-----\n\nFirst line of the input contains a single integer n (1 ≤ n ≤ 10^18) — the number of rubles Kolya has at the beginning.\n\nThen follow three lines containing integers a, b and c (1 ≤ a ≤ 10^18, 1 ≤ c < b ≤ 10^18) — the cost of one plastic liter bottle, the cost of one glass liter bottle and the money one can get back by returning an empty glass bottle, respectively.\n\n\n-----Output-----\n\nPrint the only integer — maximum number of liters of kefir, that Kolya can drink.\n\n\n-----Examples-----\nInput\n10\n11\n9\n8\n\nOutput\n2\n\nInput\n10\n5\n6\n1\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first sample, Kolya can buy one glass bottle, then return it and buy one more glass bottle. Thus he will drink 2 liters of kefir.\n\nIn the second sample, Kolya can buy two plastic bottle and get two liters of kefir, or he can buy one liter glass bottle, then return it and buy one plastic bottle. In both cases he will drink two liters of kefir.",
        "generated_code": "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nif a <= b - c:\n    # If plastic bottle is cheaper or same as effective cost of glass bottle\n    print(n // a)\nelse:\n    # Use as many rubles as possible to buy and return glass bottles\n    k = (n - b) // (b - c) + 1  # Max number of glass bottles that can be bought and returned\n    remaining_rubles = n - k * (b - c)\n    \n    if remaining_rubles < b:\n        # If remaining rubles are less than cost of one glass bottle, buy plastic bottles\n        print(k + remaining_rubles // a)\n    else:\n        # Otherwise, buy one more glass bottle\n        print(k + 1)\n",
        "counter_example": {
            "input": "1\n100\n5\n4\n",
            "expected": "0\n",
            "got": "-3"
        }
    },
    {
        "task_id": "0179",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Andrey thinks he is truly a successful developer, but in reality he didn't know about the binary search algorithm until recently. After reading some literature Andrey understood that this algorithm allows to quickly find a certain number $x$ in an array. For an array $a$ indexed from zero, and an integer $x$ the pseudocode of the algorithm is as follows:\n\nBinarySearch(a, x)\n  left = 0\n  right = a.size()\n  while left < right\n    middle = (left + right) / 2\n    if a[middle] <= x then\n      left = middle + 1\n    else\n      right = middle\n  \n  if left > 0 and a[left - 1] == x then\n    return true\n  else\n    return false\n\nNote that the elements of the array are indexed from zero, and the division is done in integers (rounding down).\n\nAndrey read that the algorithm only works if the array is sorted. However, he found this statement untrue, because there certainly exist unsorted arrays for which the algorithm find $x$!\n\nAndrey wants to write a letter to the book authors, but before doing that he must consider the permutations of size $n$ such that the algorithm finds $x$ in them. A permutation of size $n$ is an array consisting of $n$ distinct integers between $1$ and $n$ in arbitrary order.\n\nHelp Andrey and find the number of permutations of size $n$ which contain $x$ at position $pos$ and for which the given implementation of the binary search algorithm finds $x$ (returns true). As the result may be extremely large, print the remainder of its division by $10^9+7$.\n\n\n-----Input-----\n\nThe only line of input contains integers $n$, $x$ and $pos$ ($1 \\le x \\le n \\le 1000$, $0 \\le pos \\le n - 1$) — the required length of the permutation, the number to search, and the required position of that number, respectively.\n\n\n-----Output-----\n\nPrint a single number — the remainder of the division of the number of valid permutations by $10^9+7$.\n\n\n-----Examples-----\nInput\n4 1 2\n\nOutput\n6\n\nInput\n123 42 24\n\nOutput\n824071958\n\n\n\n-----Note-----\n\nAll possible permutations in the first test case: $(2, 3, 1, 4)$, $(2, 4, 1, 3)$, $(3, 2, 1, 4)$, $(3, 4, 1, 2)$, $(4, 2, 1, 3)$, $(4, 3, 1, 2)$.",
        "generated_code": "n, x, pos = map(int, input().split())\nMOD = 10**9 + 7\n\ndef comb(n, k):\n    if k > n - k: k = n - k\n    res = 1\n    for i in range(1, k + 1):\n        res = res * (n - i + 1) // i\n    return res % MOD\n\nres = comb(pos, x - 1) * comb(n - pos - 1, x)\nprint(res % MOD)\n",
        "counter_example": {
            "input": "4 1 2\n",
            "expected": "6\n",
            "got": "1"
        }
    },
    {
        "task_id": "0179",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Andrey thinks he is truly a successful developer, but in reality he didn't know about the binary search algorithm until recently. After reading some literature Andrey understood that this algorithm allows to quickly find a certain number $x$ in an array. For an array $a$ indexed from zero, and an integer $x$ the pseudocode of the algorithm is as follows:\n\nBinarySearch(a, x)\n  left = 0\n  right = a.size()\n  while left < right\n    middle = (left + right) / 2\n    if a[middle] <= x then\n      left = middle + 1\n    else\n      right = middle\n  \n  if left > 0 and a[left - 1] == x then\n    return true\n  else\n    return false\n\nNote that the elements of the array are indexed from zero, and the division is done in integers (rounding down).\n\nAndrey read that the algorithm only works if the array is sorted. However, he found this statement untrue, because there certainly exist unsorted arrays for which the algorithm find $x$!\n\nAndrey wants to write a letter to the book authors, but before doing that he must consider the permutations of size $n$ such that the algorithm finds $x$ in them. A permutation of size $n$ is an array consisting of $n$ distinct integers between $1$ and $n$ in arbitrary order.\n\nHelp Andrey and find the number of permutations of size $n$ which contain $x$ at position $pos$ and for which the given implementation of the binary search algorithm finds $x$ (returns true). As the result may be extremely large, print the remainder of its division by $10^9+7$.\n\n\n-----Input-----\n\nThe only line of input contains integers $n$, $x$ and $pos$ ($1 \\le x \\le n \\le 1000$, $0 \\le pos \\le n - 1$) — the required length of the permutation, the number to search, and the required position of that number, respectively.\n\n\n-----Output-----\n\nPrint a single number — the remainder of the division of the number of valid permutations by $10^9+7$.\n\n\n-----Examples-----\nInput\n4 1 2\n\nOutput\n6\n\nInput\n123 42 24\n\nOutput\n824071958\n\n\n\n-----Note-----\n\nAll possible permutations in the first test case: $(2, 3, 1, 4)$, $(2, 4, 1, 3)$, $(3, 2, 1, 4)$, $(3, 4, 1, 2)$, $(4, 2, 1, 3)$, $(4, 3, 1, 2)$.",
        "generated_code": "MOD = 10**9 + 7\n\ndef factorial(n):\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef count_permutations(n, x, pos):\n    less_than_x = x - 1\n    greater_than_x = n - x\n    \n    left_size = pos\n    right_size = n - pos - 1\n    \n    if left_size > less_than_x or right_size > greater_than_x:\n        return 0\n    \n    less_pos = factorial(less_than_x) // factorial(less_than_x - left_size)\n    greater_pos = factorial(greater_than_x) // factorial(greater_than_x - right_size)\n    \n    remaining = n - 1 - left_size - right_size\n    remaining_factorial = factorial(remaining)\n    \n    result = (less_pos * greater_pos) % MOD\n    result = (result * remaining_factorial) % MOD\n    \n    return result\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    n, x, pos = map(int, input().split())\n    print(count_permutations(n, x, pos))\n",
        "counter_example": {
            "input": "4 1 2\n",
            "expected": "6\n",
            "got": "0"
        }
    },
    {
        "task_id": "0209",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Jzzhu has invented a kind of sequences, they meet the following property:$f_{1} = x ; f_{2} = y ; \\forall i(i \\geq 2), f_{i} = f_{i - 1} + f_{i + 1}$\n\nYou are given x and y, please calculate f_{n} modulo 1000000007 (10^9 + 7).\n\n\n-----Input-----\n\nThe first line contains two integers x and y (|x|, |y| ≤ 10^9). The second line contains a single integer n (1 ≤ n ≤ 2·10^9).\n\n\n-----Output-----\n\nOutput a single integer representing f_{n} modulo 1000000007 (10^9 + 7).\n\n\n-----Examples-----\nInput\n2 3\n3\n\nOutput\n1\n\nInput\n0 -1\n2\n\nOutput\n1000000006\n\n\n\n-----Note-----\n\nIn the first sample, f_2 = f_1 + f_3, 3 = 2 + f_3, f_3 = 1.\n\nIn the second sample, f_2 =  - 1;  - 1 modulo (10^9 + 7) equals (10^9 + 6).",
        "generated_code": "x, y = map(int, input().split())\nn = int(input())\n\nMOD = 10**9 + 7\n\nif n == 1:\n    print(x % MOD)\nelif n == 2:\n    print(y % MOD)\nelse:\n    a, b = x, y\n    for _ in range(3, n + 1):\n        a, b = b, (b * 2 - a) % MOD\n    print(b)\n",
        "counter_example": {
            "input": "2 3\n3\n",
            "expected": "1\n",
            "got": "4"
        }
    },
    {
        "task_id": "0209",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "Jzzhu has invented a kind of sequences, they meet the following property:$f_{1} = x ; f_{2} = y ; \\forall i(i \\geq 2), f_{i} = f_{i - 1} + f_{i + 1}$\n\nYou are given x and y, please calculate f_{n} modulo 1000000007 (10^9 + 7).\n\n\n-----Input-----\n\nThe first line contains two integers x and y (|x|, |y| ≤ 10^9). The second line contains a single integer n (1 ≤ n ≤ 2·10^9).\n\n\n-----Output-----\n\nOutput a single integer representing f_{n} modulo 1000000007 (10^9 + 7).\n\n\n-----Examples-----\nInput\n2 3\n3\n\nOutput\n1\n\nInput\n0 -1\n2\n\nOutput\n1000000006\n\n\n\n-----Note-----\n\nIn the first sample, f_2 = f_1 + f_3, 3 = 2 + f_3, f_3 = 1.\n\nIn the second sample, f_2 =  - 1;  - 1 modulo (10^9 + 7) equals (10^9 + 6).",
        "generated_code": "MOD = 1000000007\n\n# Read inputs\nx, y = map(int, input().split())\nn = int(input())\n\n# Calculating the term based on the periodicity of 6\nterms = [x, y, y - x, -x, -y, x - y]\nresult = terms[(n - 1) % 6] % MOD\n\n# Adjusting for negative results to ensure positive modulo results\nif result < 0:\n    result += MOD\n\nprint(result)\n",
        "counter_example": null
    }
]