[
    {
        "task_id": "0172",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "In Berland each high school student is characterized by academic performance — integer value between 1 and 5.\n\nIn high school 0xFF there are two groups of pupils: the group A and the group B. Each group consists of exactly n students. An academic performance of each student is known — integer value between 1 and 5.\n\nThe school director wants to redistribute students between groups so that each of the two groups has the same number of students whose academic performance is equal to 1, the same number of students whose academic performance is 2 and so on. In other words, the purpose of the school director is to change the composition of groups, so that for each value of academic performance the numbers of students in both groups are equal.\n\nTo achieve this, there is a plan to produce a series of exchanges of students between groups. During the single exchange the director selects one student from the class A and one student of class B. After that, they both change their groups.\n\nPrint the least number of exchanges, in order to achieve the desired equal numbers of students for each academic performance.\n\n\n-----Input-----\n\nThe first line of the input contains integer number n (1 ≤ n ≤ 100) — number of students in both groups.\n\nThe second line contains sequence of integer numbers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 5), where a_{i} is academic performance of the i-th student of the group A.\n\nThe third line contains sequence of integer numbers b_1, b_2, ..., b_{n} (1 ≤ b_{i} ≤ 5), where b_{i} is academic performance of the i-th student of the group B.\n\n\n-----Output-----\n\nPrint the required minimum number of exchanges or -1, if the desired distribution of students can not be obtained.\n\n\n-----Examples-----\nInput\n4\n5 4 4 4\n5 5 4 5\n\nOutput\n1\n\nInput\n6\n1 1 1 1 1 1\n5 5 5 5 5 5\n\nOutput\n3\n\nInput\n1\n5\n3\n\nOutput\n-1\n\nInput\n9\n3 2 5 5 2 3 3 3 2\n4 1 4 1 1 2 4 4 1\n\nOutput\n4",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ncount_a = [0] * 6\ncount_b = [0] * 6\n\nfor i in a:\n    count_a[i] += 1\nfor i in b:\n    count_b[i] += 1\n\nans = 0\nfor i in range(1, 6):\n    ans += abs(count_a[i] - count_b[i])\n\nprint(ans // 2)\n",
        "counter_example": {
            "input": "4\n5 4 4 4\n5 5 4 5\n",
            "expected": "1\n",
            "got": "2"
        }
    },
    {
        "task_id": "0172",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "In Berland each high school student is characterized by academic performance — integer value between 1 and 5.\n\nIn high school 0xFF there are two groups of pupils: the group A and the group B. Each group consists of exactly n students. An academic performance of each student is known — integer value between 1 and 5.\n\nThe school director wants to redistribute students between groups so that each of the two groups has the same number of students whose academic performance is equal to 1, the same number of students whose academic performance is 2 and so on. In other words, the purpose of the school director is to change the composition of groups, so that for each value of academic performance the numbers of students in both groups are equal.\n\nTo achieve this, there is a plan to produce a series of exchanges of students between groups. During the single exchange the director selects one student from the class A and one student of class B. After that, they both change their groups.\n\nPrint the least number of exchanges, in order to achieve the desired equal numbers of students for each academic performance.\n\n\n-----Input-----\n\nThe first line of the input contains integer number n (1 ≤ n ≤ 100) — number of students in both groups.\n\nThe second line contains sequence of integer numbers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 5), where a_{i} is academic performance of the i-th student of the group A.\n\nThe third line contains sequence of integer numbers b_1, b_2, ..., b_{n} (1 ≤ b_{i} ≤ 5), where b_{i} is academic performance of the i-th student of the group B.\n\n\n-----Output-----\n\nPrint the required minimum number of exchanges or -1, if the desired distribution of students can not be obtained.\n\n\n-----Examples-----\nInput\n4\n5 4 4 4\n5 5 4 5\n\nOutput\n1\n\nInput\n6\n1 1 1 1 1 1\n5 5 5 5 5 5\n\nOutput\n3\n\nInput\n1\n5\n3\n\nOutput\n-1\n\nInput\n9\n3 2 5 5 2 3 3 3 2\n4 1 4 1 1 2 4 4 1\n\nOutput\n4",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Initialize counters for academic performances in both groups\ncount_a = [0] * 6\ncount_b = [0] * 6\n\n# Count the number of students with each academic performance in both groups\nfor performance in a:\n    count_a[performance] += 1\nfor performance in b:\n    count_b[performance] += 1\n\n# Check if it's possible to achieve the desired distribution\nfor i in range(1, 6):\n    if (count_a[i] + count_b[i]) % 2 != 0:\n        print(-1)\n        exit()\n\n# Calculate the minimum number of exchanges\nexchanges_needed = 0\nfor i in range(1, 6):\n    # Calculate the difference for each academic performance\n    diff = abs(count_a[i] - count_b[i]) // 2\n    exchanges_needed += diff\n\n# Since each exchange corrects the count for two students, we need to divide by 2\nprint(exchanges_needed // 2)\n",
        "counter_example": null
    },
    {
        "task_id": "0295",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "You are given a positive integer $n$.\n\nFind a sequence of fractions $\\frac{a_i}{b_i}$, $i = 1 \\ldots k$ (where $a_i$ and $b_i$ are positive integers) for some $k$ such that:\n\n$$ \\begin{cases} \\text{$b_i$ divides $n$, $1 < b_i < n$ for $i = 1 \\ldots k$} \\\\ \\text{$1 \\le a_i < b_i$ for $i = 1 \\ldots k$} \\\\ \\text{$\\sum\\limits_{i=1}^k \\frac{a_i}{b_i} = 1 - \\frac{1}{n}$} \\end{cases} $$\n\n\n-----Input-----\n\nThe input consists of a single integer $n$ ($2 \\le n \\le 10^9$).\n\n\n-----Output-----\n\nIn the first line print \"YES\" if there exists such a sequence of fractions or \"NO\" otherwise.\n\nIf there exists such a sequence, next lines should contain a description of the sequence in the following format.\n\nThe second line should contain integer $k$ ($1 \\le k \\le 100\\,000$) — the number of elements in the sequence. It is guaranteed that if such a sequence exists, then there exists a sequence of length at most $100\\,000$.\n\nNext $k$ lines should contain fractions of the sequence with two integers $a_i$ and $b_i$ on each line.\n\n\n-----Examples-----\nInput\n2\n\nOutput\nNO\n\nInput\n6\n\nOutput\nYES\n2\n1 2\n1 3\n\n\n\n-----Note-----\n\nIn the second example there is a sequence $\\frac{1}{2}, \\frac{1}{3}$ such that $\\frac{1}{2} + \\frac{1}{3} = 1 - \\frac{1}{6}$.",
        "generated_code": "n = int(input())\nif n == 2:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    k = 2\n    print(k)\n    print(\"1\", n // 2)\n    print(\"1\", n)\n",
        "counter_example": {
            "input": "6\n",
            "expected": "YES\n2\n1 2\n1 3\n",
            "got": "YES\n2\n1 3\n1 6"
        }
    },
    {
        "task_id": "0295",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "You are given a positive integer $n$.\n\nFind a sequence of fractions $\\frac{a_i}{b_i}$, $i = 1 \\ldots k$ (where $a_i$ and $b_i$ are positive integers) for some $k$ such that:\n\n$$ \\begin{cases} \\text{$b_i$ divides $n$, $1 < b_i < n$ for $i = 1 \\ldots k$} \\\\ \\text{$1 \\le a_i < b_i$ for $i = 1 \\ldots k$} \\\\ \\text{$\\sum\\limits_{i=1}^k \\frac{a_i}{b_i} = 1 - \\frac{1}{n}$} \\end{cases} $$\n\n\n-----Input-----\n\nThe input consists of a single integer $n$ ($2 \\le n \\le 10^9$).\n\n\n-----Output-----\n\nIn the first line print \"YES\" if there exists such a sequence of fractions or \"NO\" otherwise.\n\nIf there exists such a sequence, next lines should contain a description of the sequence in the following format.\n\nThe second line should contain integer $k$ ($1 \\le k \\le 100\\,000$) — the number of elements in the sequence. It is guaranteed that if such a sequence exists, then there exists a sequence of length at most $100\\,000$.\n\nNext $k$ lines should contain fractions of the sequence with two integers $a_i$ and $b_i$ on each line.\n\n\n-----Examples-----\nInput\n2\n\nOutput\nNO\n\nInput\n6\n\nOutput\nYES\n2\n1 2\n1 3\n\n\n\n-----Note-----\n\nIn the second example there is a sequence $\\frac{1}{2}, \\frac{1}{3}$ such that $\\frac{1}{2} + \\frac{1}{3} = 1 - \\frac{1}{6}$.",
        "generated_code": "import math\n\ndef find_sequence(n):\n    if n <= 2:\n        return \"NO\"\n    \n    divisors = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    \n    if not divisors:\n        return \"NO\"\n    \n    k = len(divisors)\n    fractions = [(1, d) for d in divisors]\n    \n    return f\"YES\\n{k}\\n\" + \"\\n\".join(f\"{a} {b}\" for a, b in fractions)\n\n# Reading input\nn = int(input().strip())\nresult = find_sequence(n)\nprint(result)\n",
        "counter_example": {
            "input": "4\n",
            "expected": "NO\n",
            "got": "YES\n1\n1 2"
        }
    },
    {
        "task_id": "0218",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "You are given the string s of length n and the numbers p, q. Split the string s to pieces of length p and q.\n\nFor example, the string \"Hello\" for p = 2, q = 3 can be split to the two strings \"Hel\" and \"lo\" or to the two strings \"He\" and \"llo\".\n\nNote it is allowed to split the string s to the strings only of length p or to the strings only of length q (see the second sample test).\n\n\n-----Input-----\n\nThe first line contains three positive integers n, p, q (1 ≤ p, q ≤ n ≤ 100).\n\nThe second line contains the string s consists of lowercase and uppercase latin letters and digits.\n\n\n-----Output-----\n\nIf it's impossible to split the string s to the strings of length p and q print the only number \"-1\".\n\nOtherwise in the first line print integer k — the number of strings in partition of s.\n\nEach of the next k lines should contain the strings in partition. Each string should be of the length p or q. The string should be in order of their appearing in string s — from left to right.\n\nIf there are several solutions print any of them.\n\n\n-----Examples-----\nInput\n5 2 3\nHello\n\nOutput\n2\nHe\nllo\n\nInput\n10 9 5\nCodeforces\n\nOutput\n2\nCodef\norces\n\nInput\n6 4 5\nPrivet\n\nOutput\n-1\n\nInput\n8 1 1\nabacabac\n\nOutput\n8\na\nb\na\nc\na\nb\na\nc",
        "generated_code": "n, p, q = map(int, input().split())\ns = input()\n\nk = 0\npieces = []\nwhile len(s) > 0:\n    if len(s) >= p:\n        pieces.append(s[:p])\n        s = s[p:]\n        k += 1\n    elif len(s) >= q:\n        pieces.append(s[:q])\n        s = s[q:]\n        k += 1\n    else:\n        break\n\nif len(s) > 0:\n    print(-1)\nelse:\n    print(k)\n    for piece in pieces:\n        print(piece)\n",
        "counter_example": {
            "input": "5 2 3\nHello\n",
            "expected": "2\nHe\nllo\n",
            "got": "-1"
        }
    },
    {
        "task_id": "0218",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "You are given the string s of length n and the numbers p, q. Split the string s to pieces of length p and q.\n\nFor example, the string \"Hello\" for p = 2, q = 3 can be split to the two strings \"Hel\" and \"lo\" or to the two strings \"He\" and \"llo\".\n\nNote it is allowed to split the string s to the strings only of length p or to the strings only of length q (see the second sample test).\n\n\n-----Input-----\n\nThe first line contains three positive integers n, p, q (1 ≤ p, q ≤ n ≤ 100).\n\nThe second line contains the string s consists of lowercase and uppercase latin letters and digits.\n\n\n-----Output-----\n\nIf it's impossible to split the string s to the strings of length p and q print the only number \"-1\".\n\nOtherwise in the first line print integer k — the number of strings in partition of s.\n\nEach of the next k lines should contain the strings in partition. Each string should be of the length p or q. The string should be in order of their appearing in string s — from left to right.\n\nIf there are several solutions print any of them.\n\n\n-----Examples-----\nInput\n5 2 3\nHello\n\nOutput\n2\nHe\nllo\n\nInput\n10 9 5\nCodeforces\n\nOutput\n2\nCodef\norces\n\nInput\n6 4 5\nPrivet\n\nOutput\n-1\n\nInput\n8 1 1\nabacabac\n\nOutput\n8\na\nb\na\nc\na\nb\na\nc",
        "generated_code": "n, p, q = map(int, input().split())\ns = input()\n\ndef split_string(n, p, q, s):\n    for i in range(n // p + 1):\n        if (n - i * p) % q == 0:\n            k = i + (n - i * p) // q\n            print(k)\n            for j in range(i):\n                print(s[j * p: (j + 1) * p])\n            for j in range((n - i * p) // q):\n                print(s[i * p + j * q: i * p + (j + 1) * q])\n            return\n    print(-1)\n\nsplit_string(n, p, q, s)\n",
        "counter_example": null
    },
    {
        "task_id": "0099",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Masha really loves algebra. On the last lesson, her strict teacher Dvastan gave she new exercise.\n\nYou are given geometric progression b defined by two integers b_1 and q. Remind that a geometric progression is a sequence of integers b_1, b_2, b_3, ..., where for each i > 1 the respective term satisfies the condition b_{i} = b_{i} - 1·q, where q is called the common ratio of the progression. Progressions in Uzhlyandia are unusual: both b_1 and q can equal 0. Also, Dvastan gave Masha m \"bad\" integers a_1, a_2, ..., a_{m}, and an integer l.\n\nMasha writes all progression terms one by one onto the board (including repetitive) while condition |b_{i}| ≤ l is satisfied (|x| means absolute value of x). There is an exception: if a term equals one of the \"bad\" integers, Masha skips it (doesn't write onto the board) and moves forward to the next term.\n\nBut the lesson is going to end soon, so Masha has to calculate how many integers will be written on the board. In order not to get into depression, Masha asked you for help: help her calculate how many numbers she will write, or print \"inf\" in case she needs to write infinitely many integers.\n\n\n-----Input-----\n\nThe first line of input contains four integers b_1, q, l, m (-10^9 ≤ b_1, q ≤ 10^9, 1 ≤ l ≤ 10^9, 1 ≤ m ≤ 10^5) — the initial term and the common ratio of progression, absolute value of maximal number that can be written on the board and the number of \"bad\" integers, respectively.\n\nThe second line contains m distinct integers a_1, a_2, ..., a_{m} (-10^9 ≤ a_{i} ≤ 10^9) — numbers that will never be written on the board.\n\n\n-----Output-----\n\nPrint the only integer, meaning the number of progression terms that will be written on the board if it is finite, or \"inf\" (without quotes) otherwise.\n\n\n-----Examples-----\nInput\n3 2 30 4\n6 14 25 48\n\nOutput\n3\nInput\n123 1 2143435 4\n123 11 -5453 141245\n\nOutput\n0\nInput\n123 1 2143435 4\n54343 -13 6 124\n\nOutput\ninf\n\n\n-----Note-----\n\nIn the first sample case, Masha will write integers 3, 12, 24. Progression term 6 will be skipped because it is a \"bad\" integer. Terms bigger than 24 won't be written because they exceed l by absolute value.\n\nIn the second case, Masha won't write any number because all terms are equal 123 and this is a \"bad\" integer.\n\nIn the third case, Masha will write infinitely integers 123.",
        "generated_code": "b1, q, l, m = map(int, input().split())\nbad = set(map(int, input().split()))\n\ncount = 0\nwhile True:\n    if abs(b1) > l:\n        break\n    if b1 not in bad:\n        count += 1\n    if q == 0:\n        break\n    b1 *= q\n\nif q == 0 and abs(b1) <= l and b1 not in bad:\n    print(1)\nelif q == 1 and b1 in bad:\n    print(0)\nelse:\n    print(\"inf\" if q == 1 or abs(q) == 1 else count)\n",
        "counter_example": {
            "input": "123 1 2143435 4\n123 11 -5453 141245\n",
            "expected": "0",
            "got": "TimeoutError: Execution exceeded time limit"
        }
    },
    {
        "task_id": "0099",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Masha really loves algebra. On the last lesson, her strict teacher Dvastan gave she new exercise.\n\nYou are given geometric progression b defined by two integers b_1 and q. Remind that a geometric progression is a sequence of integers b_1, b_2, b_3, ..., where for each i > 1 the respective term satisfies the condition b_{i} = b_{i} - 1·q, where q is called the common ratio of the progression. Progressions in Uzhlyandia are unusual: both b_1 and q can equal 0. Also, Dvastan gave Masha m \"bad\" integers a_1, a_2, ..., a_{m}, and an integer l.\n\nMasha writes all progression terms one by one onto the board (including repetitive) while condition |b_{i}| ≤ l is satisfied (|x| means absolute value of x). There is an exception: if a term equals one of the \"bad\" integers, Masha skips it (doesn't write onto the board) and moves forward to the next term.\n\nBut the lesson is going to end soon, so Masha has to calculate how many integers will be written on the board. In order not to get into depression, Masha asked you for help: help her calculate how many numbers she will write, or print \"inf\" in case she needs to write infinitely many integers.\n\n\n-----Input-----\n\nThe first line of input contains four integers b_1, q, l, m (-10^9 ≤ b_1, q ≤ 10^9, 1 ≤ l ≤ 10^9, 1 ≤ m ≤ 10^5) — the initial term and the common ratio of progression, absolute value of maximal number that can be written on the board and the number of \"bad\" integers, respectively.\n\nThe second line contains m distinct integers a_1, a_2, ..., a_{m} (-10^9 ≤ a_{i} ≤ 10^9) — numbers that will never be written on the board.\n\n\n-----Output-----\n\nPrint the only integer, meaning the number of progression terms that will be written on the board if it is finite, or \"inf\" (without quotes) otherwise.\n\n\n-----Examples-----\nInput\n3 2 30 4\n6 14 25 48\n\nOutput\n3\nInput\n123 1 2143435 4\n123 11 -5453 141245\n\nOutput\n0\nInput\n123 1 2143435 4\n54343 -13 6 124\n\nOutput\ninf\n\n\n-----Note-----\n\nIn the first sample case, Masha will write integers 3, 12, 24. Progression term 6 will be skipped because it is a \"bad\" integer. Terms bigger than 24 won't be written because they exceed l by absolute value.\n\nIn the second case, Masha won't write any number because all terms are equal 123 and this is a \"bad\" integer.\n\nIn the third case, Masha will write infinitely integers 123.",
        "generated_code": "def count_valid_terms(b1, q, l, m, bad_numbers):\n    bad_set = set(bad_numbers)\n    count = 0\n\n    if abs(b1) > l:\n        return 0\n\n    if b1 == 0:\n        if 0 in bad_set:\n            return 0\n        else:\n            return float('inf')\n\n    if q == 0:\n        if b1 in bad_set:\n            return 0\n        if 0 in bad_set:\n            return 1\n        return float('inf')\n\n    if q == 1:\n        if b1 in bad_set:\n            return 0\n        return float('inf')\n\n    if q == -1:\n        if b1 in bad_set and -b1 in bad_set:\n            return 0\n        return float('inf')\n\n    current = b1\n    while abs(current) <= l:\n        if current not in bad_set:\n            count += 1\n        current *= q\n\n        if q == 1 or q == -1 or q == 0:\n            break\n\n    return count\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    b1 = int(data[0])\n    q = int(data[1])\n    l = int(data[2])\n    m = int(data[3])\n    bad_numbers = list(map(int, data[4:4 + m]))\n\n    result = count_valid_terms(b1, q, l, m, bad_numbers)\n    if result == float('inf'):\n        print(\"inf\")\n    else:\n        print(result)\n",
        "counter_example": {
            "input": "2 0 2 1\n2\n",
            "expected": "inf",
            "got": "0"
        }
    },
    {
        "task_id": "0046",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "After finishing eating her bun, Alyona came up with two integers n and m. She decided to write down two columns of integers — the first column containing integers from 1 to n and the second containing integers from 1 to m. Now the girl wants to count how many pairs of integers she can choose, one from the first column and the other from the second column, such that their sum is divisible by 5.\n\nFormally, Alyona wants to count the number of pairs of integers (x, y) such that 1 ≤ x ≤ n, 1 ≤ y ≤ m and $(x + y) \\operatorname{mod} 5$ equals 0.\n\nAs usual, Alyona has some troubles and asks you to help.\n\n\n-----Input-----\n\nThe only line of the input contains two integers n and m (1 ≤ n, m ≤ 1 000 000).\n\n\n-----Output-----\n\nPrint the only integer — the number of pairs of integers (x, y) such that 1 ≤ x ≤ n, 1 ≤ y ≤ m and (x + y) is divisible by 5.\n\n\n-----Examples-----\nInput\n6 12\n\nOutput\n14\n\nInput\n11 14\n\nOutput\n31\n\nInput\n1 5\n\nOutput\n1\n\nInput\n3 8\n\nOutput\n5\n\nInput\n5 7\n\nOutput\n7\n\nInput\n21 21\n\nOutput\n88\n\n\n\n-----Note-----\n\nFollowing pairs are suitable in the first sample case:   for x = 1 fits y equal to 4 or 9;  for x = 2 fits y equal to 3 or 8;  for x = 3 fits y equal to 2, 7 or 12;  for x = 4 fits y equal to 1, 6 or 11;  for x = 5 fits y equal to 5 or 10;  for x = 6 fits y equal to 4 or 9. \n\nOnly the pair (1, 4) is suitable in the third sample case.",
        "generated_code": "n, m = map(int, input().split())\ncount = 0\nfor x in range(1, n + 1):\n    for y in range(1, m + 1):\n        if (x + y) % 5 == 0:\n            count += 1\nprint(count)\n",
        "counter_example": {
            "input": "1000000 1000000\n",
            "expected": "200000000000\n",
            "got": "TimeoutError: Execution exceeded time limit"
        }
    },
    {
        "task_id": "0046",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "After finishing eating her bun, Alyona came up with two integers n and m. She decided to write down two columns of integers — the first column containing integers from 1 to n and the second containing integers from 1 to m. Now the girl wants to count how many pairs of integers she can choose, one from the first column and the other from the second column, such that their sum is divisible by 5.\n\nFormally, Alyona wants to count the number of pairs of integers (x, y) such that 1 ≤ x ≤ n, 1 ≤ y ≤ m and $(x + y) \\operatorname{mod} 5$ equals 0.\n\nAs usual, Alyona has some troubles and asks you to help.\n\n\n-----Input-----\n\nThe only line of the input contains two integers n and m (1 ≤ n, m ≤ 1 000 000).\n\n\n-----Output-----\n\nPrint the only integer — the number of pairs of integers (x, y) such that 1 ≤ x ≤ n, 1 ≤ y ≤ m and (x + y) is divisible by 5.\n\n\n-----Examples-----\nInput\n6 12\n\nOutput\n14\n\nInput\n11 14\n\nOutput\n31\n\nInput\n1 5\n\nOutput\n1\n\nInput\n3 8\n\nOutput\n5\n\nInput\n5 7\n\nOutput\n7\n\nInput\n21 21\n\nOutput\n88\n\n\n\n-----Note-----\n\nFollowing pairs are suitable in the first sample case:   for x = 1 fits y equal to 4 or 9;  for x = 2 fits y equal to 3 or 8;  for x = 3 fits y equal to 2, 7 or 12;  for x = 4 fits y equal to 1, 6 or 11;  for x = 5 fits y equal to 5 or 10;  for x = 6 fits y equal to 4 or 9. \n\nOnly the pair (1, 4) is suitable in the third sample case.",
        "generated_code": "n, m = map(int, input().split())\n\n# Count group sizes based on remainder when divided by 5\ngroup_n = [0] * 5\ngroup_m = [0] * 5\n\nfor i in range(1, n + 1):\n    group_n[i % 5] += 1\n\nfor i in range(1, m + 1):\n    group_m[i % 5] += 1\n\n# Calculate the number of valid pairs\nresult = (group_n[0] * group_m[0] +\n          group_n[1] * group_m[4] +\n          group_n[2] * group_m[3] +\n          group_n[3] * group_m[2] +\n          group_n[4] * group_m[1])\n\nprint(result)\n",
        "counter_example": null
    }
]