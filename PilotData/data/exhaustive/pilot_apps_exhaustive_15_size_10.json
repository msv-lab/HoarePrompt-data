[
    {
        "task_id": "0142",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "A New Year party is not a New Year party without lemonade! As usual, you are expecting a lot of guests, and buying lemonade has already become a pleasant necessity.\n\nYour favorite store sells lemonade in bottles of n different volumes at different costs. A single bottle of type i has volume 2^{i} - 1 liters and costs c_{i} roubles. The number of bottles of each type in the store can be considered infinite.\n\nYou want to buy at least L liters of lemonade. How many roubles do you have to spend?\n\n\n-----Input-----\n\nThe first line contains two integers n and L (1 ≤ n ≤ 30; 1 ≤ L ≤ 10^9) — the number of types of bottles in the store and the required amount of lemonade in liters, respectively.\n\nThe second line contains n integers c_1, c_2, ..., c_{n} (1 ≤ c_{i} ≤ 10^9) — the costs of bottles of different types.\n\n\n-----Output-----\n\nOutput a single integer — the smallest number of roubles you have to pay in order to buy at least L liters of lemonade.\n\n\n-----Examples-----\nInput\n4 12\n20 30 70 90\n\nOutput\n150\n\nInput\n4 3\n10000 1000 100 10\n\nOutput\n10\n\nInput\n4 3\n10 100 1000 10000\n\nOutput\n30\n\nInput\n5 787787787\n123456789 234567890 345678901 456789012 987654321\n\nOutput\n44981600785557577\n\n\n\n-----Note-----\n\nIn the first example you should buy one 8-liter bottle for 90 roubles and two 2-liter bottles for 30 roubles each. In total you'll get 12 liters of lemonade for just 150 roubles.\n\nIn the second example, even though you need only 3 liters, it's cheaper to buy a single 8-liter bottle for 10 roubles.\n\nIn the third example it's best to buy three 1-liter bottles for 10 roubles each, getting three liters for 30 roubles.",
        "generated_code": "n, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\ndp = [float('inf')] * (L + 1)\ndp[0] = 0\n\nfor i in range(1, L + 1):\n    for j in range(n):\n        vol = 2 ** j - 1\n        if vol <= i:\n            dp[i] = min(dp[i], dp[i - vol] + costs[j])\n\nprint(dp[L] if dp[L] != float('inf') else -1)\n",
        "counter_example": {
            "input": "4 12\n20 30 70 90\n",
            "expected": "150\n",
            "got": "220"
        }
    },
    {
        "task_id": "0142",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "A New Year party is not a New Year party without lemonade! As usual, you are expecting a lot of guests, and buying lemonade has already become a pleasant necessity.\n\nYour favorite store sells lemonade in bottles of n different volumes at different costs. A single bottle of type i has volume 2^{i} - 1 liters and costs c_{i} roubles. The number of bottles of each type in the store can be considered infinite.\n\nYou want to buy at least L liters of lemonade. How many roubles do you have to spend?\n\n\n-----Input-----\n\nThe first line contains two integers n and L (1 ≤ n ≤ 30; 1 ≤ L ≤ 10^9) — the number of types of bottles in the store and the required amount of lemonade in liters, respectively.\n\nThe second line contains n integers c_1, c_2, ..., c_{n} (1 ≤ c_{i} ≤ 10^9) — the costs of bottles of different types.\n\n\n-----Output-----\n\nOutput a single integer — the smallest number of roubles you have to pay in order to buy at least L liters of lemonade.\n\n\n-----Examples-----\nInput\n4 12\n20 30 70 90\n\nOutput\n150\n\nInput\n4 3\n10000 1000 100 10\n\nOutput\n10\n\nInput\n4 3\n10 100 1000 10000\n\nOutput\n30\n\nInput\n5 787787787\n123456789 234567890 345678901 456789012 987654321\n\nOutput\n44981600785557577\n\n\n\n-----Note-----\n\nIn the first example you should buy one 8-liter bottle for 90 roubles and two 2-liter bottles for 30 roubles each. In total you'll get 12 liters of lemonade for just 150 roubles.\n\nIn the second example, even though you need only 3 liters, it's cheaper to buy a single 8-liter bottle for 10 roubles.\n\nIn the third example it's best to buy three 1-liter bottles for 10 roubles each, getting three liters for 30 roubles.",
        "generated_code": "def min_cost_to_buy_lemonade(n, L, costs):\n    max_cost = 10**18  # A large number to initialize our dp array\n    dp = [max_cost] * 31\n    c = costs + [max_cost] * (31 - len(costs))\n    \n    for i in range(n):\n        dp[i] = min(dp[i], c[i])\n    \n    for i in range(1, 31):\n        dp[i] = min(dp[i], dp[i-1] * 2)\n    \n    answer = max_cost\n    current_cost = 0\n    \n    for i in range(30, -1, -1):\n        if L >= (1 << i):\n            current_cost += dp[i]\n            L -= (1 << i)\n        answer = min(answer, current_cost + (L > 0) * dp[i])\n    \n    return answer\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    L = int(data[1])\n    costs = list(map(int, data[2:2 + n]))\n    \n    print(min_cost_to_buy_lemonade(n, L, costs))\n",
        "counter_example": null
    },
    {
        "task_id": "0232",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "There is unrest in the Galactic Senate. Several thousand solar systems have declared their intentions to leave the Republic. Master Heidi needs to select the Jedi Knights who will go on peacekeeping missions throughout the galaxy. It is well-known that the success of any peacekeeping mission depends on the colors of the lightsabers of the Jedi who will go on that mission. \n\nHeidi has n Jedi Knights standing in front of her, each one with a lightsaber of one of m possible colors. She knows that for the mission to be the most effective, she needs to select some contiguous interval of knights such that there are exactly k_1 knights with lightsabers of the first color, k_2 knights with lightsabers of the second color, ..., k_{m} knights with lightsabers of the m-th color. Help her find out if this is possible.\n\n\n-----Input-----\n\nThe first line of the input contains n (1 ≤ n ≤ 100) and m (1 ≤ m ≤ n). The second line contains n integers in the range {1, 2, ..., m} representing colors of the lightsabers of the subsequent Jedi Knights. The third line contains m integers k_1, k_2, ..., k_{m} (with $1 \\leq \\sum_{i = 1}^{m} k_{i} \\leq n$) – the desired counts of lightsabers of each color from 1 to m.\n\n\n-----Output-----\n\nOutput YES if an interval with prescribed color counts exists, or output NO if there is none.\n\n\n-----Example-----\nInput\n5 2\n1 1 2 2 1\n1 2\n\nOutput\nYES",
        "generated_code": "n, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ncounts = list(map(int, input().split()))\n\ncolor_counts = {}\nfor color in colors:\n    if color not in color_counts:\n        color_counts[color] = 0\n    color_counts[color] += 1\n\nfound = False\nfor i in range(n):\n    window_counts = {}\n    for j in range(i, n):\n        color = colors[j]\n        if color not in window_counts:\n            window_counts[color] = 0\n        window_counts[color] += 1\n        if all(count == target for count, target in zip(sorted(window_counts.values()), counts)):\n            found = True\n            break\n    if found:\n        break\n\nprint(\"YES\" if found else \"NO\")\n",
        "counter_example": {
            "input": "4 4\n2 3 3 2\n0 0 1 0\n",
            "expected": "YES\n",
            "got": "NO"
        }
    },
    {
        "task_id": "0232",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "There is unrest in the Galactic Senate. Several thousand solar systems have declared their intentions to leave the Republic. Master Heidi needs to select the Jedi Knights who will go on peacekeeping missions throughout the galaxy. It is well-known that the success of any peacekeeping mission depends on the colors of the lightsabers of the Jedi who will go on that mission. \n\nHeidi has n Jedi Knights standing in front of her, each one with a lightsaber of one of m possible colors. She knows that for the mission to be the most effective, she needs to select some contiguous interval of knights such that there are exactly k_1 knights with lightsabers of the first color, k_2 knights with lightsabers of the second color, ..., k_{m} knights with lightsabers of the m-th color. Help her find out if this is possible.\n\n\n-----Input-----\n\nThe first line of the input contains n (1 ≤ n ≤ 100) and m (1 ≤ m ≤ n). The second line contains n integers in the range {1, 2, ..., m} representing colors of the lightsabers of the subsequent Jedi Knights. The third line contains m integers k_1, k_2, ..., k_{m} (with $1 \\leq \\sum_{i = 1}^{m} k_{i} \\leq n$) – the desired counts of lightsabers of each color from 1 to m.\n\n\n-----Output-----\n\nOutput YES if an interval with prescribed color counts exists, or output NO if there is none.\n\n\n-----Example-----\nInput\n5 2\n1 1 2 2 1\n1 2\n\nOutput\nYES",
        "generated_code": "def can_find_interval(n, m, colors, k):\n    # We will create a sliding window to find the interval\n    from collections import defaultdict\n    \n    # Desired counts for each color\n    desired_counts = dict(zip(range(1, m+1), k))\n    \n    # Current counts in the sliding window\n    current_counts = defaultdict(int)\n    \n    # Initialize two pointers for the sliding window\n    left = 0\n    \n    for right in range(n):\n        current_counts[colors[right]] += 1\n        \n        # Check if current window meets the condition\n        while all(current_counts[color] >= desired_counts[color] for color in desired_counts):\n            if all(current_counts[color] == desired_counts[color] for color in desired_counts):\n                return \"YES\"\n            current_counts[colors[left]] -= 1\n            left += 1\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\n# Output the result\nprint(can_find_interval(n, m, colors, k))\n",
        "counter_example": null
    },
    {
        "task_id": "0222",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "You are given a positive integer $n$, written without leading zeroes (for example, the number 04 is incorrect). \n\nIn one operation you can delete any digit of the given integer so that the result remains a positive integer without leading zeros.\n\nDetermine the minimum number of operations that you need to consistently apply to the given integer $n$ to make from it the square of some positive integer or report that it is impossible.\n\nAn integer $x$ is the square of some positive integer if and only if $x=y^2$ for some positive integer $y$.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^{9}$). The number is given without leading zeroes.\n\n\n-----Output-----\n\nIf it is impossible to make the square of some positive integer from $n$, print -1. In the other case, print the minimal number of operations required to do it.\n\n\n-----Examples-----\nInput\n8314\n\nOutput\n2\n\nInput\n625\n\nOutput\n0\n\nInput\n333\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first example we should delete from $8314$ the digits $3$ and $4$. After that $8314$ become equals to $81$, which is the square of the integer $9$.\n\nIn the second example the given $625$ is the square of the integer $25$, so you should not delete anything. \n\nIn the third example it is impossible to make the square from $333$, so the answer is -1.",
        "generated_code": "import math\n\nn = int(input())\norig_n = n\nmin_ops = float('inf')\n\nfor i in range(len(str(n)), -1, -1):\n    for j in range(i, len(str(n))+1):\n        num_str = str(n)[:i] + str(n)[j:]\n        if num_str and num_str[0] != '0':\n            num = int(num_str)\n            root = math.sqrt(num)\n            if root == int(root):\n                min_ops = min(min_ops, len(str(orig_n)) - len(num_str))\n\nif min_ops == float('inf'):\n    print(-1)\nelse:\n    print(min_ops)\n",
        "counter_example": {
            "input": "8314\n",
            "expected": "2\n",
            "got": "3"
        }
    },
    {
        "task_id": "0222",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "You are given a positive integer $n$, written without leading zeroes (for example, the number 04 is incorrect). \n\nIn one operation you can delete any digit of the given integer so that the result remains a positive integer without leading zeros.\n\nDetermine the minimum number of operations that you need to consistently apply to the given integer $n$ to make from it the square of some positive integer or report that it is impossible.\n\nAn integer $x$ is the square of some positive integer if and only if $x=y^2$ for some positive integer $y$.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^{9}$). The number is given without leading zeroes.\n\n\n-----Output-----\n\nIf it is impossible to make the square of some positive integer from $n$, print -1. In the other case, print the minimal number of operations required to do it.\n\n\n-----Examples-----\nInput\n8314\n\nOutput\n2\n\nInput\n625\n\nOutput\n0\n\nInput\n333\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first example we should delete from $8314$ the digits $3$ and $4$. After that $8314$ become equals to $81$, which is the square of the integer $9$.\n\nIn the second example the given $625$ is the square of the integer $25$, so you should not delete anything. \n\nIn the third example it is impossible to make the square from $333$, so the answer is -1.",
        "generated_code": "import math\n\ndef is_square(x):\n    root = int(math.isqrt(x))\n    return root * root == x\n\ndef min_operations_to_square(n):\n    n_str = str(n)\n    length = len(n_str)\n    min_operations = float('inf')\n\n    # Generate all subsequences of n_str\n    for i in range(1, 1 << length):\n        subsequence = ''.join(n_str[j] for j in range(length) if (i & (1 << j)))\n        if subsequence and is_square(int(subsequence)):\n            min_operations = min(min_operations, length - len(subsequence))\n\n    return -1 if min_operations == float('inf') else min_operations\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(min_operations_to_square(n))\n",
        "counter_example": {
            "input": "101\n",
            "expected": "2\n",
            "got": "1"
        }
    },
    {
        "task_id": "0013",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Now you can take online courses in the Berland State University! Polycarp needs to pass k main online courses of his specialty to get a diploma. In total n courses are availiable for the passage.\n\nThe situation is complicated by the dependence of online courses, for each course there is a list of those that must be passed before starting this online course (the list can be empty, it means that there is no limitation).\n\nHelp Polycarp to pass the least number of courses in total to get the specialty (it means to pass all main and necessary courses). Write a program which prints the order of courses. \n\nPolycarp passes courses consistently, he starts the next course when he finishes the previous one. Each course can't be passed more than once. \n\n\n-----Input-----\n\nThe first line contains n and k (1 ≤ k ≤ n ≤ 10^5) — the number of online-courses and the number of main courses of Polycarp's specialty. \n\nThe second line contains k distinct integers from 1 to n — numbers of main online-courses of Polycarp's specialty. \n\nThen n lines follow, each of them describes the next course: the i-th of them corresponds to the course i. Each line starts from the integer t_{i} (0 ≤ t_{i} ≤ n - 1) — the number of courses on which the i-th depends. Then there follows the sequence of t_{i} distinct integers from 1 to n — numbers of courses in random order, on which the i-th depends. It is guaranteed that no course can depend on itself. \n\nIt is guaranteed that the sum of all values t_{i} doesn't exceed 10^5. \n\n\n-----Output-----\n\nPrint -1, if there is no the way to get a specialty. \n\nOtherwise, in the first line print the integer m — the minimum number of online-courses which it is necessary to pass to get a specialty. In the second line print m distinct integers — numbers of courses which it is necessary to pass in the chronological order of their passage. If there are several answers it is allowed to print any of them.\n\n\n-----Examples-----\nInput\n6 2\n5 3\n0\n0\n0\n2 2 1\n1 4\n1 5\n\nOutput\n5\n1 2 3 4 5 \n\nInput\n9 3\n3 9 5\n0\n0\n3 9 4 5\n0\n0\n1 8\n1 6\n1 2\n2 1 2\n\nOutput\n6\n1 2 9 4 5 3 \n\nInput\n3 3\n1 2 3\n1 2\n1 3\n1 1\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first test firstly you can take courses number 1 and 2, after that you can take the course number 4, then you can take the course number 5, which is the main. After that you have to take only the course number 3, which is the last not passed main course.",
        "generated_code": "from collections import defaultdict, deque\n\nn, k = map(int, input().split())\nmain_courses = set(map(int, input().split()))\ngraph = defaultdict(list)\nin_degree = [0] * (n + 1)\nfor i in range(1, n + 1):\n    t = int(input())\n    in_degree[i] = t\n    for j in range(t):\n        u = int(input())\n        graph[u].append(i)\n\nqueue = deque([i for i in range(1, n + 1) if in_degree[i] == 0])\npassed_courses = 0\norder = []\nwhile queue:\n    u = queue.popleft()\n    order.append(u)\n    passed_courses += 1\n    for v in graph[u]:\n        in_degree[v] -= 1\n        if in_degree[v] == 0:\n            queue.append(v)\n\nif len(order) != n:\n    print(-1)\nelse:\n    print(passed_courses)\n    print(' '.join(map(str, order)))\n",
        "counter_example": {
            "input": "6 2\n5 3\n0\n0\n0\n2 2 1\n1 4\n1 5\n",
            "expected": "5\n1 2 3 4 5 \n",
            "got": "Traceback (most recent call last):\n  File \"<string>\", line 8, in <module>\nValueError: invalid literal for int() with base 10: '2 2 1'"
        }
    },
    {
        "task_id": "0013",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Now you can take online courses in the Berland State University! Polycarp needs to pass k main online courses of his specialty to get a diploma. In total n courses are availiable for the passage.\n\nThe situation is complicated by the dependence of online courses, for each course there is a list of those that must be passed before starting this online course (the list can be empty, it means that there is no limitation).\n\nHelp Polycarp to pass the least number of courses in total to get the specialty (it means to pass all main and necessary courses). Write a program which prints the order of courses. \n\nPolycarp passes courses consistently, he starts the next course when he finishes the previous one. Each course can't be passed more than once. \n\n\n-----Input-----\n\nThe first line contains n and k (1 ≤ k ≤ n ≤ 10^5) — the number of online-courses and the number of main courses of Polycarp's specialty. \n\nThe second line contains k distinct integers from 1 to n — numbers of main online-courses of Polycarp's specialty. \n\nThen n lines follow, each of them describes the next course: the i-th of them corresponds to the course i. Each line starts from the integer t_{i} (0 ≤ t_{i} ≤ n - 1) — the number of courses on which the i-th depends. Then there follows the sequence of t_{i} distinct integers from 1 to n — numbers of courses in random order, on which the i-th depends. It is guaranteed that no course can depend on itself. \n\nIt is guaranteed that the sum of all values t_{i} doesn't exceed 10^5. \n\n\n-----Output-----\n\nPrint -1, if there is no the way to get a specialty. \n\nOtherwise, in the first line print the integer m — the minimum number of online-courses which it is necessary to pass to get a specialty. In the second line print m distinct integers — numbers of courses which it is necessary to pass in the chronological order of their passage. If there are several answers it is allowed to print any of them.\n\n\n-----Examples-----\nInput\n6 2\n5 3\n0\n0\n0\n2 2 1\n1 4\n1 5\n\nOutput\n5\n1 2 3 4 5 \n\nInput\n9 3\n3 9 5\n0\n0\n3 9 4 5\n0\n0\n1 8\n1 6\n1 2\n2 1 2\n\nOutput\n6\n1 2 9 4 5 3 \n\nInput\n3 3\n1 2 3\n1 2\n1 3\n1 1\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first test firstly you can take courses number 1 and 2, after that you can take the course number 4, then you can take the course number 5, which is the main. After that you have to take only the course number 3, which is the last not passed main course.",
        "generated_code": "from collections import deque, defaultdict\n\ndef find_course_order(n, k, main_courses, course_details):\n    # Build graph and in-degrees\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        details = course_details[i - 1]\n        t_i = details[0]\n        for j in range(1, t_i + 1):\n            prerequisite = details[j]\n            graph[prerequisite].append(i)\n            in_degree[i] += 1\n    \n    # Initialize queue with courses that have no prerequisites\n    queue = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    order = []\n    visited = set()\n    \n    while queue:\n        course = queue.popleft()\n        if course in visited:\n            continue\n        visited.add(course)\n        order.append(course)\n        \n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n    \n    # Check if all main courses are covered\n    main_courses_set = set(main_courses)\n    if not main_courses_set.issubset(visited):\n        return -1, []\n    \n    # Filter the order to only include necessary courses\n    necessary_courses = set()\n    for course in main_courses:\n        stack = [course]\n        while stack:\n            c = stack.pop()\n            if c not in necessary_courses:\n                necessary_courses.add(c)\n                for prerequisite in course_details[c - 1][1:]:\n                    stack.append(prerequisite)\n    \n    filtered_order = [course for course in order if course in necessary_courses]\n    \n    return len(filtered_order), filtered_order\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    n = int(data[index])\n    k = int(data[index + 1])\n    index += 2\n    \n    main_courses = []\n    for i in range(k):\n        main_courses.append(int(data[index + i]))\n    index += k\n    \n    course_details = []\n    for i in range(n):\n        t_i = int(data[index])\n        course_info = [t_i]\n        for j in range(t_i):\n            course_info.append(int(data[index + j + 1]))\n        course_details.append(course_info)\n        index += t_i + 1\n    \n    m, order = find_course_order(n, k, main_courses, course_details)\n    \n    if m == -1:\n        print(-1)\n    else:\n        print(m)\n        print(\" \".join(map(str, order)))\n",
        "counter_example": {
            "input": "9 3\n3 9 5\n0\n0\n3 9 4 5\n0\n0\n1 8\n1 6\n1 2\n2 1 2\n",
            "expected": "6\n1 2 9 4 5 3 \n",
            "got": "6\n1 2 4 5 9 3"
        }
    },
    {
        "task_id": "0198",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Pasha has a wooden stick of some positive integer length n. He wants to perform exactly three cuts to get four parts of the stick. Each part must have some positive integer length and the sum of these lengths will obviously be n. \n\nPasha likes rectangles but hates squares, so he wonders, how many ways are there to split a stick into four parts so that it's possible to form a rectangle using these parts, but is impossible to form a square.\n\nYour task is to help Pasha and count the number of such ways. Two ways to cut the stick are considered distinct if there exists some integer x, such that the number of parts of length x in the first way differ from the number of parts of length x in the second way.\n\n\n-----Input-----\n\nThe first line of the input contains a positive integer n (1 ≤ n ≤ 2·10^9) — the length of Pasha's stick.\n\n\n-----Output-----\n\nThe output should contain a single integer — the number of ways to split Pasha's stick into four parts of positive integer length so that it's possible to make a rectangle by connecting the ends of these parts, but is impossible to form a square. \n\n\n-----Examples-----\nInput\n6\n\nOutput\n1\n\nInput\n20\n\nOutput\n4\n\n\n\n-----Note-----\n\nThere is only one way to divide the stick in the first sample {1, 1, 2, 2}.\n\nFour ways to divide the stick in the second sample are {1, 1, 9, 9}, {2, 2, 8, 8}, {3, 3, 7, 7} and {4, 4, 6, 6}. Note that {5, 5, 5, 5} doesn't work.",
        "generated_code": "def count_ways(n):\n    ways = 0\n    for a in range(1, n // 2 + 1):\n        for b in range(a, (n - a) // 2 + 1):\n            if a != b and 2 * (a + b) == n:\n                ways += 1\n    return ways\n\nn = int(input())\nprint(count_ways(n))\n",
        "counter_example": {
            "input": "2000000000\n",
            "expected": "499999999\n",
            "got": "TimeoutError: Execution exceeded time limit"
        }
    },
    {
        "task_id": "0198",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Pasha has a wooden stick of some positive integer length n. He wants to perform exactly three cuts to get four parts of the stick. Each part must have some positive integer length and the sum of these lengths will obviously be n. \n\nPasha likes rectangles but hates squares, so he wonders, how many ways are there to split a stick into four parts so that it's possible to form a rectangle using these parts, but is impossible to form a square.\n\nYour task is to help Pasha and count the number of such ways. Two ways to cut the stick are considered distinct if there exists some integer x, such that the number of parts of length x in the first way differ from the number of parts of length x in the second way.\n\n\n-----Input-----\n\nThe first line of the input contains a positive integer n (1 ≤ n ≤ 2·10^9) — the length of Pasha's stick.\n\n\n-----Output-----\n\nThe output should contain a single integer — the number of ways to split Pasha's stick into four parts of positive integer length so that it's possible to make a rectangle by connecting the ends of these parts, but is impossible to form a square. \n\n\n-----Examples-----\nInput\n6\n\nOutput\n1\n\nInput\n20\n\nOutput\n4\n\n\n\n-----Note-----\n\nThere is only one way to divide the stick in the first sample {1, 1, 2, 2}.\n\nFour ways to divide the stick in the second sample are {1, 1, 9, 9}, {2, 2, 8, 8}, {3, 3, 7, 7} and {4, 4, 6, 6}. Note that {5, 5, 5, 5} doesn't work.",
        "generated_code": "n = int(input())\n\n# Number of ways to split the stick into four parts such that it's possible to form a rectangle but not a square\ndef count_ways(n):\n    if n < 6:\n        return 0\n    count = 0\n    for a in range(1, n // 4 + 1):\n        b = a\n        rem = n - 2 * (a + b)\n        if rem > 0 and rem % 2 == 0:\n            if a != rem // 2:\n                count += 1\n    return count\n\nprint(count_ways(n))\n",
        "counter_example": {
            "input": "6\n",
            "expected": "1\n",
            "got": "0"
        }
    }
]