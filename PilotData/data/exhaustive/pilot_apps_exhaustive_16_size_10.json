[
    {
        "task_id": "0231",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "The main street of Berland is a straight line with n houses built along it (n is an even number). The houses are located at both sides of the street. The houses with odd numbers are at one side of the street and are numbered from 1 to n - 1 in the order from the beginning of the street to the end (in the picture: from left to right). The houses with even numbers are at the other side of the street and are numbered from 2 to n in the order from the end of the street to its beginning (in the picture: from right to left). The corresponding houses with even and odd numbers are strictly opposite each other, that is, house 1 is opposite house n, house 3 is opposite house n - 2, house 5 is opposite house n - 4 and so on. [Image] \n\nVasya needs to get to house number a as quickly as possible. He starts driving from the beginning of the street and drives his car to house a. To get from the beginning of the street to houses number 1 and n, he spends exactly 1 second. He also spends exactly one second to drive the distance between two neighbouring houses. Vasya can park at any side of the road, so the distance between the beginning of the street at the houses that stand opposite one another should be considered the same.\n\nYour task is: find the minimum time Vasya needs to reach house a.\n\n\n-----Input-----\n\nThe first line of the input contains two integers, n and a (1 ≤ a ≤ n ≤ 100 000) — the number of houses on the street and the number of the house that Vasya needs to reach, correspondingly. It is guaranteed that number n is even.\n\n\n-----Output-----\n\nPrint a single integer — the minimum time Vasya needs to get from the beginning of the street to house a.\n\n\n-----Examples-----\nInput\n4 2\n\nOutput\n2\n\nInput\n8 5\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample there are only four houses on the street, two houses at each side. House 2 will be the last at Vasya's right.\n\nThe second sample corresponds to picture with n = 8. House 5 is the one before last at Vasya's left.",
        "generated_code": "n, a = map(int, input().split())\nif a <= n // 2:\n    print(a // 2 + a % 2)\nelse:\n    print((n - a + 1) // 2 + (n - a + 1) % 2)\n",
        "counter_example": {
            "input": "4 2\n",
            "expected": "2\n",
            "got": "1"
        }
    },
    {
        "task_id": "0231",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": true,
        "description": "The main street of Berland is a straight line with n houses built along it (n is an even number). The houses are located at both sides of the street. The houses with odd numbers are at one side of the street and are numbered from 1 to n - 1 in the order from the beginning of the street to the end (in the picture: from left to right). The houses with even numbers are at the other side of the street and are numbered from 2 to n in the order from the end of the street to its beginning (in the picture: from right to left). The corresponding houses with even and odd numbers are strictly opposite each other, that is, house 1 is opposite house n, house 3 is opposite house n - 2, house 5 is opposite house n - 4 and so on. [Image] \n\nVasya needs to get to house number a as quickly as possible. He starts driving from the beginning of the street and drives his car to house a. To get from the beginning of the street to houses number 1 and n, he spends exactly 1 second. He also spends exactly one second to drive the distance between two neighbouring houses. Vasya can park at any side of the road, so the distance between the beginning of the street at the houses that stand opposite one another should be considered the same.\n\nYour task is: find the minimum time Vasya needs to reach house a.\n\n\n-----Input-----\n\nThe first line of the input contains two integers, n and a (1 ≤ a ≤ n ≤ 100 000) — the number of houses on the street and the number of the house that Vasya needs to reach, correspondingly. It is guaranteed that number n is even.\n\n\n-----Output-----\n\nPrint a single integer — the minimum time Vasya needs to get from the beginning of the street to house a.\n\n\n-----Examples-----\nInput\n4 2\n\nOutput\n2\n\nInput\n8 5\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample there are only four houses on the street, two houses at each side. House 2 will be the last at Vasya's right.\n\nThe second sample corresponds to picture with n = 8. House 5 is the one before last at Vasya's left.",
        "generated_code": "# Read input\nn, a = map(int, input().split())\n\n# Calculate the minimum time to reach house a\nif a % 2 == 1:\n    # If a is odd, just return (a+1) // 2\n    print((a + 1) // 2)\nelse:\n    # If a is even, return (n - a + 2) // 2\n    print((n - a + 2) // 2)\n",
        "counter_example": null
    },
    {
        "task_id": "0060",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "A new airplane SuperPuperJet has an infinite number of rows, numbered with positive integers starting with 1 from cockpit to tail. There are six seats in each row, denoted with letters from 'a' to 'f'. Seats 'a', 'b' and 'c' are located to the left of an aisle (if one looks in the direction of the cockpit), while seats 'd', 'e' and 'f' are located to the right. Seats 'a' and 'f' are located near the windows, while seats 'c' and 'd' are located near the aisle.  [Image] \n\n \n\nIt's lunch time and two flight attendants have just started to serve food. They move from the first rows to the tail, always maintaining a distance of two rows from each other because of the food trolley. Thus, at the beginning the first attendant serves row 1 while the second attendant serves row 3. When both rows are done they move one row forward: the first attendant serves row 2 while the second attendant serves row 4. Then they move three rows forward and the first attendant serves row 5 while the second attendant serves row 7. Then they move one row forward again and so on.\n\nFlight attendants work with the same speed: it takes exactly 1 second to serve one passenger and 1 second to move one row forward. Each attendant first serves the passengers on the seats to the right of the aisle and then serves passengers on the seats to the left of the aisle (if one looks in the direction of the cockpit). Moreover, they always serve passengers in order from the window to the aisle. Thus, the first passenger to receive food in each row is located in seat 'f', and the last one — in seat 'c'. Assume that all seats are occupied.\n\nVasya has seat s in row n and wants to know how many seconds will pass before he gets his lunch.\n\n\n-----Input-----\n\nThe only line of input contains a description of Vasya's seat in the format ns, where n (1 ≤ n ≤ 10^18) is the index of the row and s is the seat in this row, denoted as letter from 'a' to 'f'. The index of the row and the seat are not separated by a space.\n\n\n-----Output-----\n\nPrint one integer — the number of seconds Vasya has to wait until he gets his lunch.\n\n\n-----Examples-----\nInput\n1f\n\nOutput\n1\n\nInput\n2d\n\nOutput\n10\n\nInput\n4a\n\nOutput\n11\n\nInput\n5e\n\nOutput\n18\n\n\n\n-----Note-----\n\nIn the first sample, the first flight attendant serves Vasya first, so Vasya gets his lunch after 1 second.\n\nIn the second sample, the flight attendants will spend 6 seconds to serve everyone in the rows 1 and 3, then they will move one row forward in 1 second. As they first serve seats located to the right of the aisle in order from window to aisle, Vasya has to wait 3 more seconds. The total is 6 + 1 + 3 = 10.",
        "generated_code": "n, s = input()\nn = int(n)\npos = 'abcdef'.index(s) + 1\n\nt = (n - 1) // 2\nt *= 6\nt += (n - 1) % 2\nt += 3 - pos\n\nprint(t + 1)\n",
        "counter_example": {
            "input": "1f\n",
            "expected": "1\n",
            "got": "-2"
        }
    },
    {
        "task_id": "0060",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "A new airplane SuperPuperJet has an infinite number of rows, numbered with positive integers starting with 1 from cockpit to tail. There are six seats in each row, denoted with letters from 'a' to 'f'. Seats 'a', 'b' and 'c' are located to the left of an aisle (if one looks in the direction of the cockpit), while seats 'd', 'e' and 'f' are located to the right. Seats 'a' and 'f' are located near the windows, while seats 'c' and 'd' are located near the aisle.  [Image] \n\n \n\nIt's lunch time and two flight attendants have just started to serve food. They move from the first rows to the tail, always maintaining a distance of two rows from each other because of the food trolley. Thus, at the beginning the first attendant serves row 1 while the second attendant serves row 3. When both rows are done they move one row forward: the first attendant serves row 2 while the second attendant serves row 4. Then they move three rows forward and the first attendant serves row 5 while the second attendant serves row 7. Then they move one row forward again and so on.\n\nFlight attendants work with the same speed: it takes exactly 1 second to serve one passenger and 1 second to move one row forward. Each attendant first serves the passengers on the seats to the right of the aisle and then serves passengers on the seats to the left of the aisle (if one looks in the direction of the cockpit). Moreover, they always serve passengers in order from the window to the aisle. Thus, the first passenger to receive food in each row is located in seat 'f', and the last one — in seat 'c'. Assume that all seats are occupied.\n\nVasya has seat s in row n and wants to know how many seconds will pass before he gets his lunch.\n\n\n-----Input-----\n\nThe only line of input contains a description of Vasya's seat in the format ns, where n (1 ≤ n ≤ 10^18) is the index of the row and s is the seat in this row, denoted as letter from 'a' to 'f'. The index of the row and the seat are not separated by a space.\n\n\n-----Output-----\n\nPrint one integer — the number of seconds Vasya has to wait until he gets his lunch.\n\n\n-----Examples-----\nInput\n1f\n\nOutput\n1\n\nInput\n2d\n\nOutput\n10\n\nInput\n4a\n\nOutput\n11\n\nInput\n5e\n\nOutput\n18\n\n\n\n-----Note-----\n\nIn the first sample, the first flight attendant serves Vasya first, so Vasya gets his lunch after 1 second.\n\nIn the second sample, the flight attendants will spend 6 seconds to serve everyone in the rows 1 and 3, then they will move one row forward in 1 second. As they first serve seats located to the right of the aisle in order from window to aisle, Vasya has to wait 3 more seconds. The total is 6 + 1 + 3 = 10.",
        "generated_code": "s = input().strip()\nn = int(s[:-1])\nseat = s[-1]\n\n# Determine the base time for the row\ngroup = (n - 1) // 4\nbase_time = group * 8 * 3  # Each group of 4 rows takes 24 seconds (8 per row)\n\n# Determine the extra time within the group\nrow_position_in_group = (n - 1) % 4\nif row_position_in_group == 0 or row_position_in_group == 2:\n    base_time += 0  # for rows 1 and 3 in their respective 4-row groups\nelif row_position_in_group == 1 or row_position_in_group == 3:\n    base_time += 7  # for rows 2 and 4 in their respective 4-row groups\n\n# Determine the time based on the seat position\nseat_time = {\n    'f': 0,\n    'e': 1,\n    'd': 2,\n    'c': 3,\n    'b': 4,\n    'a': 5\n}[seat]\n\n# Total time is base time plus seat time plus 1 second to start serving\ntotal_time = base_time + seat_time + 1\n\nprint(total_time)\n",
        "counter_example": {
            "input": "4a\n",
            "expected": "11\n",
            "got": "13"
        }
    },
    {
        "task_id": "0097",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "Consider a billiard table of rectangular size $n \\times m$ with four pockets. Let's introduce a coordinate system with the origin at the lower left corner (see the picture).  [Image] \n\nThere is one ball at the point $(x, y)$ currently. Max comes to the table and strikes the ball. The ball starts moving along a line that is parallel to one of the axes or that makes a $45^{\\circ}$ angle with them. We will assume that:   the angles between the directions of the ball before and after a collision with a side are equal,  the ball moves indefinitely long, it only stops when it falls into a pocket,  the ball can be considered as a point, it falls into a pocket if and only if its coordinates coincide with one of the pockets,  initially the ball is not in a pocket. \n\nNote that the ball can move along some side, in this case the ball will just fall into the pocket at the end of the side.\n\nYour task is to determine whether the ball will fall into a pocket eventually, and if yes, which of the four pockets it will be.\n\n\n-----Input-----\n\nThe only line contains $6$ integers $n$, $m$, $x$, $y$, $v_x$, $v_y$ ($1 \\leq n, m \\leq 10^9$, $0 \\leq x \\leq n$; $0 \\leq y \\leq m$; $-1 \\leq v_x, v_y \\leq 1$; $(v_x, v_y) \\neq (0, 0)$) — the width of the table, the length of the table, the $x$-coordinate of the initial position of the ball, the $y$-coordinate of the initial position of the ball, the $x$-component of its initial speed and the $y$-component of its initial speed, respectively. It is guaranteed that the ball is not initially in a pocket.\n\n\n-----Output-----\n\nPrint the coordinates of the pocket the ball will fall into, or $-1$ if the ball will move indefinitely.\n\n\n-----Examples-----\nInput\n4 3 2 2 -1 1\n\nOutput\n0 0\nInput\n4 4 2 0 1 1\n\nOutput\n-1\nInput\n10 10 10 1 -1 0\n\nOutput\n-1\n\n\n-----Note-----\n\nThe first sample:  [Image] \n\nThe second sample:  [Image] \n\nIn the third sample the ball will never change its $y$ coordinate, so the ball will never fall into a pocket.",
        "generated_code": "n, m, x, y, vx, vy = map(int, input().split())\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nif vx == 0:\n    if vy == 0:\n        print(-1)\n    elif vy > 0:\n        print(m, y + (m - y) // abs(vy) * vy)\n    else:\n        print(0, y - y // abs(vy) * vy)\nelif vy == 0:\n    if vx > 0:\n        print(x + (n - x) // abs(vx) * vx, 0)\n    else:\n        print(0, x - x // abs(vx) * vx)\nelse:\n    g = gcd(abs(vx), abs(vy))\n    vx //= g\n    vy //= g\n    if vx > 0:\n        dx = (n - x) // vx\n    else:\n        dx = -x // -vx\n    if vy > 0:\n        dy = (m - y) // vy\n    else:\n        dy = -y // -vy\n    if dx == dy:\n        print(n, m)\n    elif dx < dy:\n        print(n, y + dx * vy)\n    else:\n        print(x + dy * vx, m)\n",
        "counter_example": {
            "input": "4 3 2 2 -1 1\n",
            "expected": "0 0",
            "got": "4 0"
        }
    },
    {
        "task_id": "0097",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "Consider a billiard table of rectangular size $n \\times m$ with four pockets. Let's introduce a coordinate system with the origin at the lower left corner (see the picture).  [Image] \n\nThere is one ball at the point $(x, y)$ currently. Max comes to the table and strikes the ball. The ball starts moving along a line that is parallel to one of the axes or that makes a $45^{\\circ}$ angle with them. We will assume that:   the angles between the directions of the ball before and after a collision with a side are equal,  the ball moves indefinitely long, it only stops when it falls into a pocket,  the ball can be considered as a point, it falls into a pocket if and only if its coordinates coincide with one of the pockets,  initially the ball is not in a pocket. \n\nNote that the ball can move along some side, in this case the ball will just fall into the pocket at the end of the side.\n\nYour task is to determine whether the ball will fall into a pocket eventually, and if yes, which of the four pockets it will be.\n\n\n-----Input-----\n\nThe only line contains $6$ integers $n$, $m$, $x$, $y$, $v_x$, $v_y$ ($1 \\leq n, m \\leq 10^9$, $0 \\leq x \\leq n$; $0 \\leq y \\leq m$; $-1 \\leq v_x, v_y \\leq 1$; $(v_x, v_y) \\neq (0, 0)$) — the width of the table, the length of the table, the $x$-coordinate of the initial position of the ball, the $y$-coordinate of the initial position of the ball, the $x$-component of its initial speed and the $y$-component of its initial speed, respectively. It is guaranteed that the ball is not initially in a pocket.\n\n\n-----Output-----\n\nPrint the coordinates of the pocket the ball will fall into, or $-1$ if the ball will move indefinitely.\n\n\n-----Examples-----\nInput\n4 3 2 2 -1 1\n\nOutput\n0 0\nInput\n4 4 2 0 1 1\n\nOutput\n-1\nInput\n10 10 10 1 -1 0\n\nOutput\n-1\n\n\n-----Note-----\n\nThe first sample:  [Image] \n\nThe second sample:  [Image] \n\nIn the third sample the ball will never change its $y$ coordinate, so the ball will never fall into a pocket.",
        "generated_code": "n, m, x, y, v_x, v_y = map(int, input().split())\n\ndef reflect_coordinate(coord, max_val, velocity):\n    if velocity == 0:\n        return coord\n\n    reflections = (coord + max_val) // max_val\n    if reflections % 2 == 0:\n        return coord % max_val\n    else:\n        return max_val - (coord % max_val)\n\nfinal_x = reflect_coordinate(x, n, v_x)\nfinal_y = reflect_coordinate(y, m, v_y)\n\nif (final_x == 0 or final_x == n) and (final_y == 0 or final_y == m):\n    print(final_x, final_y)\nelse:\n    print(-1)\n",
        "counter_example": {
            "input": "4 3 2 2 -1 1\n",
            "expected": "0 0",
            "got": "-1"
        }
    },
    {
        "task_id": "0197",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "An online contest will soon be held on ForceCoders, a large competitive programming platform. The authors have prepared $n$ problems; and since the platform is very popular, $998244351$ coder from all over the world is going to solve them.\n\nFor each problem, the authors estimated the number of people who would solve it: for the $i$-th problem, the number of accepted solutions will be between $l_i$ and $r_i$, inclusive.\n\nThe creator of ForceCoders uses different criteria to determine if the contest is good or bad. One of these criteria is the number of inversions in the problem order. An inversion is a pair of problems $(x, y)$ such that $x$ is located earlier in the contest ($x < y$), but the number of accepted solutions for $y$ is strictly greater.\n\nObviously, both the creator of ForceCoders and the authors of the contest want the contest to be good. Now they want to calculate the probability that there will be no inversions in the problem order, assuming that for each problem $i$, any integral number of accepted solutions for it (between $l_i$ and $r_i$) is equally probable, and all these numbers are independent.\n\n\n-----Input-----\n\nThe first line contains one integer $n$ ($2 \\le n \\le 50$) — the number of problems in the contest.\n\nThen $n$ lines follow, the $i$-th line contains two integers $l_i$ and $r_i$ ($0 \\le l_i \\le r_i \\le 998244351$) — the minimum and maximum number of accepted solutions for the $i$-th problem, respectively.\n\n\n-----Output-----\n\nThe probability that there will be no inversions in the contest can be expressed as an irreducible fraction $\\frac{x}{y}$, where $y$ is coprime with $998244353$. Print one integer — the value of $xy^{-1}$, taken modulo $998244353$, where $y^{-1}$ is an integer such that $yy^{-1} \\equiv 1$ $(mod$ $998244353)$.\n\n\n-----Examples-----\nInput\n3\n1 2\n1 2\n1 2\n\nOutput\n499122177\n\nInput\n2\n42 1337\n13 420\n\nOutput\n578894053\n\nInput\n2\n1 1\n0 0\n\nOutput\n1\n\nInput\n2\n1 1\n1 1\n\nOutput\n1\n\n\n\n-----Note-----\n\nThe real answer in the first test is $\\frac{1}{2}$.",
        "generated_code": "import math\n\nMOD = 998244353\n\ndef mul(a, b):\n    return (a * b) % MOD\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = mul(res, a)\n        a = mul(a, a)\n        b >>= 1\n    return res\n\ndef inv(a):\n    return power(a, MOD - 2)\n\nn = int(input())\na = [list(map(int, input().split())) for _ in range(n)]\n\nres = 1\nfor i in range(n):\n    cnt = 1\n    for j in range(i + 1, n):\n        if a[i][0] <= a[j][1]:\n            cnt = mul(cnt, a[j][1] - a[i][0] + 1)\n    res = mul(res, cnt)\n\nfor i in range(n):\n    res = mul(res, inv(a[i][1] - a[i][0] + 1))\n\nprint(res)\n",
        "counter_example": {
            "input": "3\n1 2\n1 2\n1 2\n",
            "expected": "499122177\n",
            "got": "1"
        }
    },
    {
        "task_id": "0197",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "An online contest will soon be held on ForceCoders, a large competitive programming platform. The authors have prepared $n$ problems; and since the platform is very popular, $998244351$ coder from all over the world is going to solve them.\n\nFor each problem, the authors estimated the number of people who would solve it: for the $i$-th problem, the number of accepted solutions will be between $l_i$ and $r_i$, inclusive.\n\nThe creator of ForceCoders uses different criteria to determine if the contest is good or bad. One of these criteria is the number of inversions in the problem order. An inversion is a pair of problems $(x, y)$ such that $x$ is located earlier in the contest ($x < y$), but the number of accepted solutions for $y$ is strictly greater.\n\nObviously, both the creator of ForceCoders and the authors of the contest want the contest to be good. Now they want to calculate the probability that there will be no inversions in the problem order, assuming that for each problem $i$, any integral number of accepted solutions for it (between $l_i$ and $r_i$) is equally probable, and all these numbers are independent.\n\n\n-----Input-----\n\nThe first line contains one integer $n$ ($2 \\le n \\le 50$) — the number of problems in the contest.\n\nThen $n$ lines follow, the $i$-th line contains two integers $l_i$ and $r_i$ ($0 \\le l_i \\le r_i \\le 998244351$) — the minimum and maximum number of accepted solutions for the $i$-th problem, respectively.\n\n\n-----Output-----\n\nThe probability that there will be no inversions in the contest can be expressed as an irreducible fraction $\\frac{x}{y}$, where $y$ is coprime with $998244353$. Print one integer — the value of $xy^{-1}$, taken modulo $998244353$, where $y^{-1}$ is an integer such that $yy^{-1} \\equiv 1$ $(mod$ $998244353)$.\n\n\n-----Examples-----\nInput\n3\n1 2\n1 2\n1 2\n\nOutput\n499122177\n\nInput\n2\n42 1337\n13 420\n\nOutput\n578894053\n\nInput\n2\n1 1\n0 0\n\nOutput\n1\n\nInput\n2\n1 1\n1 1\n\nOutput\n1\n\n\n\n-----Note-----\n\nThe real answer in the first test is $\\frac{1}{2}$.",
        "generated_code": "import sys\ninput = sys.stdin.read\nfrom functools import lru_cache\n\nMOD = 998244353\n\ndef mod_inv(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef calculate_probability(n, ranges):\n    total_probability = 1\n    for i in range(n):\n        li, ri = ranges[i]\n        for j in range(i+1, n):\n            lj, rj = ranges[j]\n            # Calculate the probability that there is no inversion between i and j\n            prob_no_inversion = 0\n            count_i = ri - li + 1\n            count_j = rj - lj + 1\n            total_count = count_i * count_j\n\n            for x in range(li, ri + 1):\n                if x > rj:\n                    prob_no_inversion += count_j\n                elif x >= lj:\n                    prob_no_inversion += rj - x + 1\n\n            prob_no_inversion %= MOD\n            total_count %= MOD\n\n            prob_no_inversion = prob_no_inversion * mod_inv(total_count, MOD) % MOD\n            total_probability = total_probability * prob_no_inversion % MOD\n\n    return total_probability\n\ndef main():\n    data = input().strip().split()\n    n = int(data[0])\n    ranges = []\n    index = 1\n    for _ in range(n):\n        l = int(data[index])\n        r = int(data[index + 1])\n        ranges.append((l, r))\n        index += 2\n    \n    result = calculate_probability(n, ranges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
        "counter_example": {
            "input": "3\n1 2\n1 2\n1 2\n",
            "expected": "499122177\n",
            "got": "577110017"
        }
    },
    {
        "task_id": "0274",
        "dataset": "apps",
        "model": "llama3-70b-8192",
        "correct": false,
        "description": "A sequence of square brackets is regular if by inserting symbols \"+\" and \"1\" into it, you can get a regular mathematical expression from it. For example, sequences \"[[]][]\", \"[]\" and \"[[][[]]]\" — are regular, at the same time \"][\", \"[[]\" and \"[[]]][\" — are irregular. \n\nDraw the given sequence using a minimalistic pseudographics in the strip of the lowest possible height — use symbols '+', '-' and '|'. For example, the sequence \"[[][]][]\" should be represented as: \n\n+-        -++- -+    \n\n|+- -++- -+||   |\n\n||   ||   |||   |\n\n|+- -++- -+||   |\n\n+-        -++- -+\n\n\n\nEach bracket should be represented with the hepl of one or more symbols '|' (the vertical part) and symbols '+' and '-' as on the example which is given above.\n\nBrackets should be drawn without spaces one by one, only dividing pairs of consecutive pairwise brackets with a single-space bar (so that the two brackets do not visually merge into one symbol). The image should have the minimum possible height. \n\nThe enclosed bracket is always smaller than the surrounding bracket, but each bracket separately strives to maximize the height of the image. So the pair of final brackets in the example above occupies the entire height of the image.\n\nStudy carefully the examples below, they adequately explain the condition of the problem. Pay attention that in this problem the answer (the image) is unique. \n\n\n-----Input-----\n\nThe first line contains an even integer n (2 ≤ n ≤ 100) — the length of the sequence of brackets.\n\nThe second line contains the sequence of brackets — these are n symbols \"[\" and \"]\". It is guaranteed that the given sequence of brackets is regular. \n\n\n-----Output-----\n\nPrint the drawn bracket sequence in the format which is given in the condition. Don't print extra (unnecessary) spaces. \n\n\n-----Examples-----\nInput\n8\n[[][]][]\n\nOutput\n+-        -++- -+\n|+- -++- -+||   |\n||   ||   |||   |\n|+- -++- -+||   |\n+-        -++- -+\n\nInput\n6\n[[[]]]\n\nOutput\n+-     -+\n|+-   -+|\n||+- -+||\n|||   |||\n||+- -+||\n|+-   -+|\n+-     -+\n\nInput\n6\n[[][]]\n\nOutput\n+-        -+\n|+- -++- -+|\n||   ||   ||\n|+- -++- -+|\n+-        -+\n\nInput\n2\n[]\n\nOutput\n+- -+\n|   |\n+- -+\n\nInput\n4\n[][]\n\nOutput\n+- -++- -+\n|   ||   |\n+- -++- -+",
        "generated_code": "n = int(input())\ns = input()\nstack = []\nres = []\nfor c in s:\n    if c == '[':\n        stack.append(c)\n    else:\n        stack.pop()\n        if stack:\n            res.append(stack[-1] + c)\n        else:\n            res.append(c)\nheight = len(stack) + 1\nfor i in range(height):\n    line = ''\n    for r in res:\n        if i == 0 or i == height - 1:\n            line += '+-' if r == '[' else '-+'\n        else:\n            line += '| ' if r == '[' else ' |'\n        if i == len(stack):\n            line += ' '\n    print(line)\n",
        "counter_example": {
            "input": "8\n[[][]][]\n",
            "expected": "+-        -++- -+\n|+- -++- -+||   |\n||   ||   |||   |\n|+- -++- -+||   |\n+-        -++- -+\n",
            "got": "-+ -+ -+ -+"
        }
    },
    {
        "task_id": "0274",
        "dataset": "apps",
        "model": "gpt-4o-2024-05-13",
        "correct": false,
        "description": "A sequence of square brackets is regular if by inserting symbols \"+\" and \"1\" into it, you can get a regular mathematical expression from it. For example, sequences \"[[]][]\", \"[]\" and \"[[][[]]]\" — are regular, at the same time \"][\", \"[[]\" and \"[[]]][\" — are irregular. \n\nDraw the given sequence using a minimalistic pseudographics in the strip of the lowest possible height — use symbols '+', '-' and '|'. For example, the sequence \"[[][]][]\" should be represented as: \n\n+-        -++- -+    \n\n|+- -++- -+||   |\n\n||   ||   |||   |\n\n|+- -++- -+||   |\n\n+-        -++- -+\n\n\n\nEach bracket should be represented with the hepl of one or more symbols '|' (the vertical part) and symbols '+' and '-' as on the example which is given above.\n\nBrackets should be drawn without spaces one by one, only dividing pairs of consecutive pairwise brackets with a single-space bar (so that the two brackets do not visually merge into one symbol). The image should have the minimum possible height. \n\nThe enclosed bracket is always smaller than the surrounding bracket, but each bracket separately strives to maximize the height of the image. So the pair of final brackets in the example above occupies the entire height of the image.\n\nStudy carefully the examples below, they adequately explain the condition of the problem. Pay attention that in this problem the answer (the image) is unique. \n\n\n-----Input-----\n\nThe first line contains an even integer n (2 ≤ n ≤ 100) — the length of the sequence of brackets.\n\nThe second line contains the sequence of brackets — these are n symbols \"[\" and \"]\". It is guaranteed that the given sequence of brackets is regular. \n\n\n-----Output-----\n\nPrint the drawn bracket sequence in the format which is given in the condition. Don't print extra (unnecessary) spaces. \n\n\n-----Examples-----\nInput\n8\n[[][]][]\n\nOutput\n+-        -++- -+\n|+- -++- -+||   |\n||   ||   |||   |\n|+- -++- -+||   |\n+-        -++- -+\n\nInput\n6\n[[[]]]\n\nOutput\n+-     -+\n|+-   -+|\n||+- -+||\n|||   |||\n||+- -+||\n|+-   -+|\n+-     -+\n\nInput\n6\n[[][]]\n\nOutput\n+-        -+\n|+- -++- -+|\n||   ||   ||\n|+- -++- -+|\n+-        -+\n\nInput\n2\n[]\n\nOutput\n+- -+\n|   |\n+- -+\n\nInput\n4\n[][]\n\nOutput\n+- -++- -+\n|   ||   |\n+- -++- -+",
        "generated_code": "def draw_bracket_sequence(n, sequence):\n    levels = []\n    current_level = 0\n    for char in sequence:\n        if char == '[':\n            current_level += 1\n            while len(levels) < current_level:\n                levels.append(0)\n            levels[current_level - 1] += 1\n        else:\n            levels[current_level - 1] -= 1\n            if levels[current_level - 1] == 0:\n                levels.pop()\n            current_level -= 1\n\n    max_level = len(levels)\n    drawing = [[' ' for _ in range(2 * n)] for _ in range(2 * max_level + 1)]\n\n    current_level = 0\n    pos = 0\n    for char in sequence:\n        if char == '[':\n            drawing[current_level][pos] = '+'\n            drawing[2 * max_level - current_level][pos] = '+'\n            drawing[current_level][pos + 1] = '-'\n            drawing[2 * max_level - current_level][pos + 1] = '-'\n            drawing[current_level + 1][pos] = '|'\n            drawing[2 * max_level - current_level - 1][pos] = '|'\n            current_level += 1\n            pos += 1\n        else:\n            current_level -= 1\n            drawing[current_level][pos] = '-'\n            drawing[2 * max_level - current_level][pos] = '-'\n            drawing[current_level][pos - 1] = '+'\n            drawing[2 * max_level - current_level][pos - 1] = '+'\n            drawing[current_level + 1][pos - 1] = '|'\n            drawing[2 * max_level - current_level - 1][pos - 1] = '|'\n            pos += 1\n            while pos < 2 * n and sequence[pos] == ']':\n                pos += 1\n            pos -= 1\n\n    for row in drawing:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    n = int(input())\n    sequence = input().strip()\n    draw_bracket_sequence(n, sequence)\n",
        "counter_example": {
            "input": "8\n[[][]][]\n",
            "expected": "+-        -++- -+\n|+- -++- -+||   |\n||   ||   |||   |\n|+- -++- -+||   |\n+-        -++- -+\n",
            "got": "Traceback (most recent call last):\n  File \"<string>\", line 50, in <module>\n  File \"<string>\", line 27, in draw_bracket_sequence\nIndexError: list index out of range"
        }
    }
]