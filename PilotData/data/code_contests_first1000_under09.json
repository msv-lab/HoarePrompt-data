[
    {
        "description": "Note that this is the first problem of the two similar problems. You can hack this problem only if you solve both problems.\n\nYou are given a tree with n nodes. In the beginning, 0 is written on all edges. In one operation, you can choose any 2 distinct leaves u, v and any real number x and add x to values written on all edges on the simple path between u and v.\n\nFor example, on the picture below you can see the result of applying two operations to the graph: adding 2 on the path from 7 to 6, and then adding -0.5 on the path from 4 to 5. \n\n<image>\n\nIs it true that for any configuration of real numbers written on edges, we can achieve it with a finite number of operations?\n\nLeaf is a node of a tree of degree 1. Simple path is a path that doesn't contain any node twice.\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5) \u2014 the number of nodes.\n\nEach of the next n-1 lines contains two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v), meaning that there is an edge between nodes u and v. It is guaranteed that these edges form a tree.\n\nOutput\n\nIf there is a configuration of real numbers written on edges of the tree that we can't achieve by performing the operations, output \"NO\". \n\nOtherwise, output \"YES\". \n\nYou can print each letter in any case (upper or lower).\n\nExamples\n\nInput\n\n\n2\n1 2\n\n\nOutput\n\n\nYES\n\nInput\n\n\n3\n1 2\n2 3\n\n\nOutput\n\n\nNO\n\nInput\n\n\n5\n1 2\n1 3\n1 4\n2 5\n\n\nOutput\n\n\nNO\n\nInput\n\n\n6\n1 2\n1 3\n1 4\n2 5\n2 6\n\n\nOutput\n\n\nYES\n\nNote\n\nIn the first example, we can add any real x to the value written on the only edge (1, 2).\n\n<image>\n\nIn the second example, one of configurations that we can't reach is 0 written on (1, 2) and 1 written on (2, 3).\n\n<image>\n\nBelow you can see graphs from examples 3, 4:\n\n<image> <image>",
        "task_name": "1189_D1. Add on a Tree",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division\nfrom sys import stdin, stdout\n# from fractions import gcd\n# from math import *\n# from operator import mul\n# from functools import reduce\n# from copy import copy\nfrom collections import deque, defaultdict, Counter\n\nrstr = lambda: stdin.readline().strip()\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\nrint = lambda: int(stdin.readline())\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrstr_2d = lambda n: [rstr() for _ in range(n)]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\nout = []\n\n\nclass graph:\n    # initialize graph\n    def __init__(self, gdict=None):\n        if gdict is None:\n            gdict = defaultdict(list)\n        self.gdict, self.edges, self.l = gdict, defaultdict(int), defaultdict(int)\n\n    # add edge\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.gdict[node2].append(node1)\n        self.l[node1] += 1\n        self.l[node2] += 1\n\n\nn = int(input())\ng = graph()\nfor _ in range(n - 1):\n    u, v = rints()\n    g.addEdge(u, v)\n\nfor i in range(1, n + 1):\n    if g.l[i] != 1 and g.l[i] < 3:\n        print('NO')\n        exit()\n\nprint('YES')\n",
        "correct": true,
        "task_id": "0003",
        "depth": 1
    },
    {
        "description": "An array of integers p_{1},p_{2}, \u2026,p_{n} is called a permutation if it contains each number from 1 to n exactly once. For example, the following arrays are permutations: [3,1,2], [1], [1,2,3,4,5] and [4,3,1,2]. The following arrays are not permutations: [2], [1,1], [2,3,4].\n\nThere is a hidden permutation of length n.\n\nFor each index i, you are given s_{i}, which equals to the sum of all p_{j} such that j < i and p_{j} < p_{i}. In other words, s_i is the sum of elements before the i-th element that are smaller than the i-th element.\n\nYour task is to restore the permutation.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^{5}) \u2014 the size of the permutation.\n\nThe second line contains n integers s_{1}, s_{2}, \u2026, s_{n} (0 \u2264 s_{i} \u2264 (n(n-1))/(2)).\n\nIt is guaranteed that the array s corresponds to a valid permutation of length n.\n\nOutput\n\nPrint n integers p_{1}, p_{2}, \u2026, p_{n} \u2014 the elements of the restored permutation. We can show that the answer is always unique.\n\nExamples\n\nInput\n\n\n3\n0 0 0\n\n\nOutput\n\n\n3 2 1\n\n\nInput\n\n\n2\n0 1\n\n\nOutput\n\n\n1 2\n\n\nInput\n\n\n5\n0 1 1 1 10\n\n\nOutput\n\n\n1 4 3 2 5\n\nNote\n\nIn the first example for each i there is no index j satisfying both conditions, hence s_i are always 0.\n\nIn the second example for i = 2 it happens that j = 1 satisfies the conditions, so s_2 = p_1.\n\nIn the third example for i = 2, 3, 4 only j = 1 satisfies the conditions, so s_2 = s_3 = s_4 = 1. For i = 5 all j = 1, 2, 3, 4 are possible, so s_5 = p_1 + p_2 + p_3 + p_4 = 10.",
        "task_name": "1208_D. Restore Permutation",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nfrom collections import Counter, defaultdict\nfrom itertools import permutations, combinations\nraw_input = stdin.readline\npr = stdout.write\nmod=10**9+7\n\ndef ni():\n    return int(raw_input())\n\n\ndef li():\n    return map(int,raw_input().split())\n\n\ndef pn(n):\n    stdout.write(str(n)+'\\n')\n\n\ndef pa(arr):\n    pr(' '.join(map(str,arr))+'\\n')\n\n# fast read function for total integer input\n\ndef inp():\n    # this function returns whole input of\n    # space/line seperated integers\n    # Use Ctrl+D to flush stdin.\n    return map(int,stdin.read().split())\n\nrange = xrange # not for python 3.0+\n\n#main code\n\nn=ni()\nBITTree=[0]*(n+1)\ndef gs(i): \n    s = 0\n    i = i+1\n    while i > 0:  \n        s += BITTree[i] \n        i -= i & (-i) \n    return s \ndef ub(i ,v): \n    i += 1\n    while i <= n: \n        BITTree[i] += v \n        i += i & (-i) \ndef fun(x):\n    ret=0\n    sm=0\n    for i in range(21,-1,-1):\n        pw=1<<i\n        if ret+pw<=n and sm+BITTree[ret+pw]<=x:\n            ret+=pw\n            sm+=BITTree[ret]\n    return ret\nl=li()\nfor i in range(n):\n    ub(i,i)\nans=[0]*n\nfor i in range(n-1,-1,-1):\n    ans[i]=fun(l[i])\n    ub(ans[i],-ans[i])\npa(ans)\n\n    \n",
        "correct": true,
        "task_id": "0004",
        "depth": 1
    },
    {
        "description": "There are n points on a coordinate axis OX. The i-th point is located at the integer point x_i and has a speed v_i. It is guaranteed that no two points occupy the same coordinate. All n points move with the constant speed, the coordinate of the i-th point at the moment t (t can be non-integer) is calculated as x_i + t \u22c5 v_i.\n\nConsider two points i and j. Let d(i, j) be the minimum possible distance between these two points over any possible moments of time (even non-integer). It means that if two points i and j coincide at some moment, the value d(i, j) will be 0.\n\nYour task is to calculate the value \u2211_{1 \u2264 i < j \u2264 n} d(i, j) (the sum of minimum distances over all pairs of points).\n\nInput\n\nThe first line of the input contains one integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of points.\n\nThe second line of the input contains n integers x_1, x_2, ..., x_n (1 \u2264 x_i \u2264 10^8), where x_i is the initial coordinate of the i-th point. It is guaranteed that all x_i are distinct.\n\nThe third line of the input contains n integers v_1, v_2, ..., v_n (-10^8 \u2264 v_i \u2264 10^8), where v_i is the speed of the i-th point.\n\nOutput\n\nPrint one integer \u2014 the value \u2211_{1 \u2264 i < j \u2264 n} d(i, j) (the sum of minimum distances over all pairs of points).\n\nExamples\n\nInput\n\n\n3\n1 3 2\n-100 2 3\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n5\n2 1 4 3 5\n2 2 2 3 4\n\n\nOutput\n\n\n19\n\n\nInput\n\n\n2\n2 1\n-3 0\n\n\nOutput\n\n\n0",
        "task_name": "1311_F. Moving Points",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\nfrom collections import *\n\n\ndef fast2():\n    import os, sys, atexit\n    from cStringIO import StringIO as BytesIO\n    # range = xrange\n    sys.stdout = BytesIO()\n    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))\n    return BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\nclass order_tree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [[0, 0] for _ in range(self.n * 2)]\n        self.order = defaultdict(int, {arr[i]: i for i in range(self.n)})\n\n    # get interval[l,r)\n    def query(self, l):\n        res, coun = 0, 0\n        l = self.order[l] + self.n\n        r = self.n * 2\n\n        while l < r:\n            if l & 1:\n                res += self.tree[l][0]\n                coun += self.tree[l][1]\n                l += 1\n\n            if r & 1:\n                r -= 1\n                res += self.tree[r][0]\n                coun += self.tree[r][1]\n\n            l >>= 1\n            r >>= 1\n\n        return res, coun\n\n    def update(self, ix, val):\n        ix = self.n + self.order[ix]\n\n        # set new value\n        self.tree[ix][0] += val\n        self.tree[ix][1] += 1\n\n        # move up\n        while ix > 1:\n            self.tree[ix >> 1][0] = self.tree[ix][0] + self.tree[ix ^ 1][0]\n            self.tree[ix >> 1][1] = self.tree[ix][1] + self.tree[ix ^ 1][1]\n            ix >>= 1\n\n\ninput = fast2()\nrints = lambda: [int(x) for x in input().split()]\nn, a = int(input()), sorted(map(lambda x, y: [x, y], rints(), rints()))\ndis = sorted(set([x[1] for x in a]))\ntree, ans = order_tree(dis), 0\n\nfor i in range(n - 1, -1, -1):\n    su, coun = tree.query(a[i][1])\n    ans += su - coun * a[i][0]\n    tree.update(a[i][1], a[i][0])\n\nprint(ans)\n",
        "correct": true,
        "task_id": "0005",
        "depth": 1
    },
    {
        "description": "Takahashi is participating in a programming contest called AXC002, and he has just submitted his code to Problem A.\n\nThe problem has N test cases.\n\nFor each test case i (1\\leq i \\leq N), you are given a string S_i representing the verdict for that test case. Find the numbers of test cases for which the verdict is `AC`, `WA`, `TLE`, and `RE`, respectively.\n\nSee the Output section for the output format.\n\nConstraints\n\n* 1 \\leq N \\leq 10^5\n* S_i is `AC`, `WA`, `TLE`, or `RE`.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nS_1\n\\vdots\nS_N\n\n\nOutput\n\nLet C_0, C_1, C_2, and C_3 be the numbers of test cases for which the verdict is `AC`, `WA`, `TLE`, and `RE`, respectively. Print the following:\n\n\nAC x C_0\nWA x C_1\nTLE x C_2\nRE x C_3\n\nOutput\n\nLet C_0, C_1, C_2, and C_3 be the numbers of test cases for which the verdict is `AC`, `WA`, `TLE`, and `RE`, respectively. Print the following:\n\n\nAC x C_0\nWA x C_1\nTLE x C_2\nRE x C_3\n\nExamples\n\nInput\n\n6\nAC\nTLE\nAC\nAC\nWA\nTLE\n\n\nOutput\n\nAC x 3\nWA x 1\nTLE x 2\nRE x 0\n\n\nInput\n\n10\nAC\nAC\nAC\nAC\nAC\nAC\nAC\nAC\nAC\nAC\n\n\nOutput\n\nAC x 10\nWA x 0\nTLE x 0\nRE x 0",
        "task_name": "p02613 AtCoder Beginner Contest 173 - Judge Status Summary",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    n = int(input())\n    s = [input() for _ in range(n)]\n\n    ac = 0\n    wa = 0\n    tle = 0\n    re = 0\n\n    for i in s:\n        if i == \"AC\":\n            ac += 1\n        elif i == \"WA\":\n            wa += 1\n        elif i == \"TLE\":\n            tle += 1\n        elif i == \"RE\":\n            re += 1\n\n    print(\"AC x\", ac)\n    print(\"WA x\", wa)\n    print(\"TLE x\", tle)\n    print(\"RE x\", re)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "0033",
        "depth": 1
    },
    {
        "description": "There is a staircase with N steps. Takahashi is now standing at the foot of the stairs, that is, on the 0-th step. He can climb up one or two steps at a time.\n\nHowever, the treads of the a_1-th, a_2-th, a_3-th, \\ldots, a_M-th steps are broken, so it is dangerous to set foot on those steps.\n\nHow many are there to climb up to the top step, that is, the N-th step, without setting foot on the broken steps? Find the count modulo 1\\ 000\\ 000\\ 007.\n\nConstraints\n\n* 1 \\leq N \\leq 10^5\n* 0 \\leq M \\leq N-1\n* 1 \\leq a_1 < a_2 < ... < a_M \\leq N-1\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M\na_1\na_2\n.\n.\n.\na_M\n\n\nOutput\n\nPrint the number of ways to climb up the stairs under the condition, modulo 1\\ 000\\ 000\\ 007.\n\nExamples\n\nInput\n\n6 1\n3\n\n\nOutput\n\n4\n\n\nInput\n\n10 2\n4\n5\n\n\nOutput\n\n0\n\n\nInput\n\n100 5\n1\n23\n45\n67\n89\n\n\nOutput\n\n608200469",
        "task_name": "p03013 AtCoder Beginner Contest 129 - Typical Stairs",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, m = map(int, raw_input().split(\" \"))\n\ndp = [0 for i in range(0, n + 1)]\ndp[0] = 1\n\nfor i in range(0, m):\n    a = int(raw_input())\n    dp[a] = -1\n\nfor step in range(1, n + 1):\n    if dp[step] < 0:\n        continue\n\n    ans = 0\n    for prev in [1, 2]:\n        if step - prev >= 0 and dp[step - prev] >= 0:\n            ans += dp[step - prev]\n    dp[step] = ans\n\n# for i in range(0, len(dp)):\n#     print(dp[i])\n\nprint(dp[n] % 1000000007)\n",
        "correct": true,
        "task_id": "0036",
        "depth": 2
    },
    {
        "description": "There are N cities in Republic of AtCoder. The size of the i-th city is A_{i}. Takahashi would like to build N-1 bidirectional roads connecting two cities so that any city can be reached from any other city by using these roads.\n\nAssume that the cost of building a road connecting the i-th city and the j-th city is |i-j| \\times D + A_{i} + A_{j}. For Takahashi, find the minimum possible total cost to achieve the objective.\n\nConstraints\n\n* 1 \\leq N \\leq 2 \\times 10^5\n* 1 \\leq D \\leq 10^9\n* 1 \\leq A_{i} \\leq 10^9\n* A_{i} and D are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN D\nA_1 A_2 ... A_N\n\n\nOutput\n\nPrint the minimum possible total cost.\n\nExamples\n\nInput\n\n3 1\n1 100 1\n\n\nOutput\n\n106\n\n\nInput\n\n3 1000\n1 100 1\n\n\nOutput\n\n2202\n\n\nInput\n\n6 14\n25 171 7 1 17 162\n\n\nOutput\n\n497\n\n\nInput\n\n12 5\n43 94 27 3 69 99 56 25 8 15 46 8\n\n\nOutput\n\n658",
        "task_name": "p03153 KEYENCE Programming Contest 2019 - Connecting Cities",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def main():\n    import sys\n    from collections import defaultdict\n    input = sys.stdin.readline\n\n    class UnionFind():\n        def __init__(self, n):\n            self.n = n\n            self.root = [-1] * (n + 1)\n            self.rnk = [0] * (n + 1)\n\n        def find_root(self, x):\n            if self.root[x] < 0:\n                return x\n            else:\n                self.root[x] = self.find_root(self.root[x])\n                return self.root[x]\n\n        def unite(self, x, y):\n            x = self.find_root(x)\n            y = self.find_root(y)\n            if x == y:\n                return\n            elif self.rnk[x] > self.rnk[y]:\n                self.root[x] += self.root[y]\n                self.root[y] = x\n            else:\n                self.root[y] += self.root[x]\n                self.root[x] = y\n                if self.rnk[x] == self.rnk[y]:\n                    self.rnk[y] += 1\n\n        def isSameGroup(self, x, y):\n            return self.find_root(x) == self.find_root(y)\n\n        def size(self, x):\n            return -self.root[self.find_root(x)]\n\n    class Bit:\n        def __init__(self, n):\n            self.size = n\n            self.inf = 10 ** 15\n            self.tree = [self.inf] * (n + 1)\n\n        def query(self, i):\n            s = self.inf\n            while i > 0:\n                s = min(self.tree[i], s)\n                i -= i & -i\n            return s\n\n        def update(self, i, x):\n            while i <= self.size:\n                self.tree[i] = min(self.tree[i], x)\n                i += i & -i\n\n    N, D = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    tmp = [(a, i+1) for i, a in enumerate(A)]\n    tmp.sort(key=lambda x: x[0])\n    segtree_plus = Bit(N+5)\n    segtree_minus = Bit(N+5)\n    edge = []\n    val2idx_plus = defaultdict(int)\n    val2idx_minus = defaultdict(lambda: N+3)\n    edge_append = edge.append\n    inf = 10**15\n    for a, i in tmp:\n        val_plus = a+D*i\n        val_minus = a-D*i\n        segtree_plus.update(N+1-i, val_plus)\n        segtree_minus.update(i, val_minus)\n        i_ori = val2idx_plus[val_plus]\n        if i > i_ori:\n            val2idx_plus[val_plus] = i\n        i_ori = val2idx_minus[val_minus]\n        if i < i_ori:\n            val2idx_minus[val_minus] = i\n        plus_min = segtree_plus.query(N-i)\n        if plus_min < inf:\n            j_plus = val2idx_plus[plus_min]\n            edge_append((i, j_plus, A[i-1] + A[j_plus-1] + D*(j_plus - i)))\n        minus_min = segtree_minus.query(i-1)\n        if minus_min < inf:\n            j_minus = val2idx_minus[minus_min]\n            edge_append((i, j_minus, A[i-1] + A[j_minus-1] + D * (i - j_minus)))\n\n    edge.sort(key=lambda x: x[2])\n    UF = UnionFind(N + 1)\n    ans = 0\n    for u, v, cost in edge:\n        if UF.isSameGroup(u, v):\n            continue\n        ans += cost\n        UF.unite(u, v)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n",
        "correct": true,
        "task_id": "0037",
        "depth": 1
    },
    {
        "description": "You are given two arrays of integers a_1,\u2026,a_n and b_1,\u2026,b_m.\n\nYour task is to find a non-empty array c_1,\u2026,c_k that is a subsequence of a_1,\u2026,a_n, and also a subsequence of b_1,\u2026,b_m. If there are multiple answers, find one of the smallest possible length. If there are still multiple of the smallest possible length, find any. If there are no such arrays, you should report about it.\n\nA sequence a is a subsequence of a sequence b if a can be obtained from b by deletion of several (possibly, zero) elements. For example, [3,1] is a subsequence of [3,2,1] and [4,3,1], but not a subsequence of [1,3,3,7] and [3,10,4].\n\nInput\n\nThe first line contains a single integer t (1\u2264 t\u2264 1000) \u2014 the number of test cases. Next 3t lines contain descriptions of test cases.\n\nThe first line of each test case contains two integers n and m (1\u2264 n,m\u2264 1000) \u2014 the lengths of the two arrays.\n\nThe second line of each test case contains n integers a_1,\u2026,a_n (1\u2264 a_i\u2264 1000) \u2014 the elements of the first array.\n\nThe third line of each test case contains m integers b_1,\u2026,b_m (1\u2264 b_i\u2264 1000) \u2014 the elements of the second array.\n\nIt is guaranteed that the sum of n and the sum of m across all test cases does not exceed 1000 (\u2211_{i=1}^t n_i, \u2211_{i=1}^t m_i\u2264 1000).\n\nOutput\n\nFor each test case, output \"YES\" if a solution exists, or \"NO\" otherwise.\n\nIf the answer is \"YES\", on the next line output an integer k (1\u2264 k\u2264 1000) \u2014 the length of the array, followed by k integers c_1,\u2026,c_k (1\u2264 c_i\u2264 1000) \u2014 the elements of the array.\n\nIf there are multiple solutions with the smallest possible k, output any.\n\nExample\n\nInput\n\n\n5\n4 5\n10 8 6 4\n1 2 3 4 5\n1 1\n3\n3\n1 1\n3\n2\n5 3\n1000 2 2 2 3\n3 1 5\n5 5\n1 2 3 4 5\n1 2 3 4 5\n\n\nOutput\n\n\nYES\n1 4\nYES\n1 3\nNO\nYES\n1 3\nYES\n1 2\n\nNote\n\nIn the first test case, [4] is a subsequence of [10, 8, 6, 4] and [1, 2, 3, 4, 5]. This array has length 1, it is the smallest possible length of a subsequence of both a and b.\n\nIn the third test case, no non-empty subsequences of both [3] and [2] exist, so the answer is \"NO\".",
        "task_name": "1382_A. Common Subsequence",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\ninput=lambda :stdin.readline().strip()\nfor _ in range(int(input())):\n    n,m=[int(i) for i in input().split()]\n    lst1=[int(i) for i in input().split()]\n    lst2=[int(i) for i in input().split()]\n    nk=0\n    lst1=set(lst1)\n    lst2=set(lst2)\n    for i in lst1:\n        if i in lst2:\n            print('YES')\n            print(1,i)\n            nk=1\n            break\n    if nk==0:\n        print('NO')\n",
        "correct": false,
        "task_id": "0053",
        "depth": 2
    },
    {
        "description": "Monocarp and Polycarp are learning new programming techniques. Now they decided to try pair programming.\n\nIt's known that they have worked together on the same file for n + m minutes. Every minute exactly one of them made one change to the file. Before they started, there were already k lines written in the file.\n\nEvery minute exactly one of them does one of two actions: adds a new line to the end of the file or changes one of its lines.\n\nMonocarp worked in total for n minutes and performed the sequence of actions [a_1, a_2, ..., a_n]. If a_i = 0, then he adds a new line to the end of the file. If a_i > 0, then he changes the line with the number a_i. Monocarp performed actions strictly in this order: a_1, then a_2, ..., a_n.\n\nPolycarp worked in total for m minutes and performed the sequence of actions [b_1, b_2, ..., b_m]. If b_j = 0, then he adds a new line to the end of the file. If b_j > 0, then he changes the line with the number b_j. Polycarp performed actions strictly in this order: b_1, then b_2, ..., b_m.\n\nRestore their common sequence of actions of length n + m such that all actions would be correct \u2014 there should be no changes to lines that do not yet exist. Keep in mind that in the common sequence Monocarp's actions should form the subsequence [a_1, a_2, ..., a_n] and Polycarp's \u2014 subsequence [b_1, b_2, ..., b_m]. They can replace each other at the computer any number of times.\n\nLet's look at an example. Suppose k = 3. Monocarp first changed the line with the number 2 and then added a new line (thus, n = 2, \\: a = [2, 0]). Polycarp first added a new line and then changed the line with the number 5 (thus, m = 2, \\: b = [0, 5]).\n\nSince the initial length of the file was 3, in order for Polycarp to change line number 5 two new lines must be added beforehand. Examples of correct sequences of changes, in this case, would be [0, 2, 0, 5] and [2, 0, 0, 5]. Changes [0, 0, 5, 2] (wrong order of actions) and [0, 5, 2, 0] (line 5 cannot be edited yet) are not correct.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000). Then t test cases follow. Before each test case, there is an empty line.\n\nEach test case contains three lines. The first line contains three integers k, n, m (0 \u2264 k \u2264 100, 1 \u2264 n, m \u2264 100) \u2014 the initial number of lines in file and lengths of Monocarp's and Polycarp's sequences of changes respectively.\n\nThe second line contains n integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 300).\n\nThe third line contains m integers b_1, b_2, ..., b_m (0 \u2264 b_j \u2264 300).\n\nOutput\n\nFor each test case print any correct common sequence of Monocarp's and Polycarp's actions of length n + m or -1 if such sequence doesn't exist.\n\nExample\n\nInput\n\n\n5\n\n3 2 2\n2 0\n0 5\n\n4 3 2\n2 0 5\n0 6\n\n0 2 2\n1 0\n2 3\n\n5 4 4\n6 0 8 0\n0 7 0 9\n\n5 4 1\n8 7 8 0\n0\n\n\nOutput\n\n\n2 0 0 5 \n0 2 0 6 5 \n-1\n0 6 0 7 0 8 0 9\n-1",
        "task_name": "1547_C. Pair Programming",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\n\ndef main():\n    pass\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n\n\nt = int(input().rstrip())\nfor _ in range(t):\n    str1 = input()\n    k, n, m = list(map(int, input().rstrip().split()))\n    list1 = list(map(int, input().rstrip().split()))\n    list2 = list(map(int, input().rstrip().split()))\n    list3 = []\n    result = True\n    t1 = 0\n    t2 = 0\n    while True:\n        if t1 == n and t2 == m:\n            break\n        if t1 < n:\n            if list1[t1] == 0:\n                k += 1\n                t1 += 1\n                list3.append(0)\n            else:\n                if list1[t1] <= k:\n                    list3.append(list1[t1])\n                    t1 += 1\n                else:\n                    if t2 == m:\n                        result = False\n                        break\n                    elif list2[t2] > k:\n                        result = False\n                        break\n        if t2 < m:\n            if list2[t2] == 0:\n                k += 1\n                t2 += 1\n                list3.append(0)\n            else:\n                if list2[t2] <= k:\n                    list3.append(list2[t2])\n                    t2 += 1\n                else:\n                    if t1 == n:\n                        result = False\n                        break\n                    elif list1[t1] > k:\n                        result = False\n                        break\n    if result is False:\n        print(-1)\n    else:\n        print(*list3)",
        "correct": true,
        "task_id": "0055",
        "depth": 2
    },
    {
        "description": "In this problem you will meet the simplified model of game King of Thieves.\n\nIn a new ZeptoLab game called \"King of Thieves\" your aim is to reach a chest with gold by controlling your character, avoiding traps and obstacles on your way.\n\n<image>\n\nAn interesting feature of the game is that you can design your own levels that will be available to other players. Let's consider the following simple design of a level.\n\nA dungeon consists of n segments located at a same vertical level, each segment is either a platform that character can stand on, or a pit with a trap that makes player lose if he falls into it. All segments have the same length, platforms on the scheme of the level are represented as '*' and pits are represented as '.'. \n\nOne of things that affects speedrun characteristics of the level is a possibility to perform a series of consecutive jumps of the same length. More formally, when the character is on the platform number i1, he can make a sequence of jumps through the platforms i1 < i2 < ... < ik, if i2 - i1 = i3 - i2 = ... = ik - ik - 1. Of course, all segments i1, i2, ... ik should be exactly the platforms, not pits. \n\nLet's call a level to be good if you can perform a sequence of four jumps of the same length or in the other words there must be a sequence i1, i2, ..., i5, consisting of five platforms so that the intervals between consecutive platforms are of the same length. Given the scheme of the level, check if it is good.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 100) \u2014 the number of segments on the level.\n\nNext line contains the scheme of the level represented as a string of n characters '*' and '.'.\n\nOutput\n\nIf the level is good, print the word \"yes\" (without the quotes), otherwise print the word \"no\" (without the quotes).\n\nExamples\n\nInput\n\n16\n.**.*..*.***.**.\n\n\nOutput\n\nyes\n\nInput\n\n11\n.*.*...*.*.\n\n\nOutput\n\nno\n\nNote\n\nIn the first sample test you may perform a sequence of jumps through platforms 2, 5, 8, 11, 14.",
        "task_name": "526_A. King of Thieves",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import print_function\n\ndef try_hop(field, i):\n\tfor slice_len in xrange(1, len(field)+1):\n\t\tres = field[i::slice_len]\n\t\t#print(i, slice_len, res)\n\t\tif len(res) == 5 and set(res) == {'*'}:\n\t\t\treturn slice_len\n\treturn 0\n\ndef main():\n\tn = int(raw_input())\n\tfield = raw_input()\n\twin = False\n\tfor i in xrange(n):\n\t\tif field[i] != '.':\n\t\t\tslice_len = try_hop(field, i)\n\t\t\tif slice_len:\n\t\t\t\tj = i+4*slice_len\n\t\t\t\t#print(j)\n\t\t\t\tif j+slice_len >= n or field[j+slice_len] == '*':\n\t\t\t\t\twin = True\n\t\t\t\t\tbreak\n\tif win:\n\t\tprint('yes')\n\telse:\n\t\tprint('no')\n\nif __name__ == '__main__':\n\tmain()\n\n",
        "correct": false,
        "task_id": "0066",
        "depth": 1
    },
    {
        "description": "Professor GukiZ doesn't accept string as they are. He likes to swap some letters in string to obtain a new one.\n\nGukiZ has strings a, b, and c. He wants to obtain string k by swapping some letters in a, so that k should contain as many non-overlapping substrings equal either to b or c as possible. Substring of string x is a string formed by consecutive segment of characters from x. Two substrings of string x overlap if there is position i in string x occupied by both of them.\n\nGukiZ was disappointed because none of his students managed to solve the problem. Can you help them and find one of possible strings k?\n\nInput\n\nThe first line contains string a, the second line contains string b, and the third line contains string c (1 \u2264 |a|, |b|, |c| \u2264 105, where |s| denotes the length of string s).\n\nAll three strings consist only of lowercase English letters. \n\nIt is possible that b and c coincide.\n\nOutput\n\nFind one of possible strings k, as described in the problem statement. If there are multiple possible answers, print any of them.\n\nExamples\n\nInput\n\naaa\na\nb\n\n\nOutput\n\naaa\n\nInput\n\npozdravstaklenidodiri\nniste\ndobri\n\n\nOutput\n\nnisteaadddiiklooprrvz\n\nInput\n\nabbbaaccca\nab\naca\n\n\nOutput\n\nababacabcc\n\nNote\n\nIn the third sample, this optimal solutions has three non-overlaping substrings equal to either b or c on positions 1 \u2013 2 (ab), 3 \u2013 4 (ab), 5 \u2013 7 (aca). In this sample, there exist many other optimal solutions, one of them would be acaababbcc.",
        "task_name": "551_B. ZgukistringZ",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from collections import defaultdict\nimport sys\n\na = raw_input()\nb = raw_input()\nc = raw_input()\n\ndef table(word):\n    table = defaultdict(int)\n    for char in word:\n        table[char] += 1\n    return table\n\nta = table(a)\ntb = table(b)\ntc = table(c)\n\nmaxb = min([ta[char] / tb[char] for char in tb])\nans = maxb\nbocc = maxb\nfor i in range(1, maxb + 1):\n    maxc = min([(ta[char] - tb[char] * i) / tc[char] for char in tc])\n    if maxc + i > ans:\n        ans = maxc + i\n        bocc = i\n\nfor i in range(bocc):\n    sys.stdout.write(b)\n\nfor i in range(ans - bocc):\n    sys.stdout.write(c)\n\nfor char in ta:\n    rem = ta[char] - bocc * tb[char] - (ans - bocc) * tb[char]\n    for i in range(rem):\n        sys.stdout.write(char)\n\n\n",
        "correct": false,
        "task_id": "0067",
        "depth": 2
    },
    {
        "description": "You are given a sequence of n integers a1, a2, ..., an. \n\nDetermine a real number x such that the weakness of the sequence a1 - x, a2 - x, ..., an - x is as small as possible.\n\nThe weakness of a sequence is defined as the maximum value of the poorness over all segments (contiguous subsequences) of a sequence.\n\nThe poorness of a segment is defined as the absolute value of sum of the elements of segment.\n\nInput\n\nThe first line contains one integer n (1 \u2264 n \u2264 200 000), the length of a sequence.\n\nThe second line contains n integers a1, a2, ..., an (|ai| \u2264 10 000).\n\nOutput\n\nOutput a real number denoting the minimum possible weakness of a1 - x, a2 - x, ..., an - x. Your answer will be considered correct if its relative or absolute error doesn't exceed 10 - 6.\n\nExamples\n\nInput\n\n3\n1 2 3\n\n\nOutput\n\n1.000000000000000\n\n\nInput\n\n4\n1 2 3 4\n\n\nOutput\n\n2.000000000000000\n\n\nInput\n\n10\n1 10 2 9 3 8 4 7 5 6\n\n\nOutput\n\n4.500000000000000\n\nNote\n\nFor the first case, the optimal value of x is 2 so the sequence becomes  - 1, 0, 1 and the max poorness occurs at the segment \"-1\" or segment \"1\". The poorness value (answer) equals to 1 in this case. \n\nFor the second sample the optimal value of x is 2.5 so the sequence becomes  - 1.5, - 0.5, 0.5, 1.5 and the max poorness occurs on segment \"-1.5 -0.5\" or \"0.5 1.5\". The poorness value (answer) equals to 2 in this case.",
        "task_name": "578_C. Weakness and Poorness",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\nfrom itertools import permutations \nimport threading,bisect,math,heapq,sys\nfrom collections import deque\n# threading.stack_size(2**27)\n# sys.setrecursionlimit(10**4)\nfrom sys import stdin, stdout\ni_m=9223372036854775807    \ndef cin():\n    return map(int,sin().split())\ndef ain():                           #takes array as input\n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input()) \nprime=[]\ndef dfs(n,d,v):\n    v[n]=1\n    x=d[n]\n    for i in x:\n        if i not in v:\n            dfs(i,d,v)\n    return p \n\"\"\"**************************MAIN*****************************\"\"\"\ndef main():\n    def f(x,a):\n        b=0\n        mx=0\n        mi=0\n        for i in range(len(a)):\n            b+=a[i]-x\n            mx=max(b,mx)\n            mi=min(b,mi)\n        ans=mx-mi\n        return ans\n    n=inin()\n    a=ain()\n    l=-100005\n    r=100005\n    h=101\n    ans=i_m\n    while(h>0):\n        h-=1\n        m1=l+(r-l)/3\n        m2=r-(r-l)/3\n        p=f(m1,a)\n        q=f(m2,a)\n        ans=min(p,q,ans)\n        if p<=q:\n            r=m2\n        else:\n            l=m1\n    print(ans)\n\n\"\"\"***********************************************\"\"\"\ndef block(x): \n      \n    v = []  \n    while (x > 0): \n        v.append(int(x % 2)) \n        x = int(x / 2) \n    ans=[]\n    for i in range(0, len(v)): \n        if (v[i] == 1): \n            ans.append(2**i)  \n    return ans \ndef intersection(l,r,ll,rr):\n    # print(l,r,ll,rr)\n    if (ll > r or rr < l): \n            return -1  \n    else: \n        l = max(l, ll) \n        r = min(r, rr)\n    return max(0,r-l) \n######## Python 2 and 3 footer by Pajenegod and c1729\nfac=[]\ndef fact(n,mod):\n    global fac\n    fac.append(1)\n    for i in range(1,n+1):\n        fac.append((fac[i-1]*i)%mod)\n    f=fac[:]\n    return f\ndef nCr(n,r,mod):\n    global fac\n    x=fac[n]\n    y=fac[n-r]\n    z=fac[r]\n    x=moddiv(x,y,mod)\n    return moddiv(x,z,mod)\ndef moddiv(m,n,p):\n    x=pow(n,p-2,p)\n    return (m*x)%p\ndef GCD(x, y): \n    x=abs(x)\n    y=abs(y)\n    if(min(x,y)==0):\n        return max(x,y)\n    while(y): \n        x, y = y, x % y \n    return x \ndef Divisors(n) : \n    l = []  \n    ll=[]\n    for i in range(1, int(math.sqrt(n) + 1)) :\n        if (n % i == 0) : \n            if (n // i == i) : \n                l.append(i) \n            else : \n                l.append(i)\n                ll.append(n//i)\n    l.extend(ll[::-1])\n    return l\ndef SieveOfEratosthenes(n): \n    global prime\n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n    f=[]\n    for p in range(2, n): \n        if prime[p]: \n            f.append(p)\n    return f\ndef primeFactors(n): \n    a=[]\n    while n % 2 == 0: \n        a.append(2) \n        n = n // 2 \n    for i in range(3,int(math.sqrt(n))+1,2):  \n        while n % i== 0: \n            a.append(i) \n            n = n // i  \n    if n > 2: \n        a.append(n)\n    return a\n\"\"\"*******************************************************\"\"\"\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\nimport os\nfrom io import IOBase, BytesIO\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n') \n# Cout implemented in Python\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'R' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'R' [0]:\n        A.append(sign*numb)\n    return A\n \n# threading.Thread(target=main).start()\nif __name__== \"__main__\":\n  main()",
        "correct": true,
        "task_id": "0068",
        "depth": 2
    },
    {
        "description": "Wet Shark asked Rat Kwesh to generate three positive real numbers x, y and z, from 0.1 to 200.0, inclusive. Wet Krash wants to impress Wet Shark, so all generated numbers will have exactly one digit after the decimal point.\n\nWet Shark knows Rat Kwesh will want a lot of cheese. So he will give the Rat an opportunity to earn a lot of cheese. He will hand the three numbers x, y and z to Rat Kwesh, and Rat Kwesh will pick one of the these twelve options:\n\n  1. a1 = xyz; \n  2. a2 = xzy; \n  3. a3 = (xy)z; \n  4. a4 = (xz)y; \n  5. a5 = yxz; \n  6. a6 = yzx; \n  7. a7 = (yx)z; \n  8. a8 = (yz)x; \n  9. a9 = zxy; \n  10. a10 = zyx; \n  11. a11 = (zx)y; \n  12. a12 = (zy)x. \n\n\n\nLet m be the maximum of all the ai, and c be the smallest index (from 1 to 12) such that ac = m. Rat's goal is to find that c, and he asks you to help him. Rat Kwesh wants to see how much cheese he gets, so he you will have to print the expression corresponding to that ac.\n\nInput\n\nThe only line of the input contains three space-separated real numbers x, y and z (0.1 \u2264 x, y, z \u2264 200.0). Each of x, y and z is given with exactly one digit after the decimal point.\n\nOutput\n\nFind the maximum value of expression among xyz, xzy, (xy)z, (xz)y, yxz, yzx, (yx)z, (yz)x, zxy, zyx, (zx)y, (zy)x and print the corresponding expression. If there are many maximums, print the one that comes first in the list. \n\nxyz should be outputted as x^y^z (without brackets), and (xy)z should be outputted as (x^y)^z (quotes for clarity). \n\nExamples\n\nInput\n\n1.1 3.4 2.5\n\n\nOutput\n\nz^y^x\n\n\nInput\n\n2.0 2.0 2.0\n\n\nOutput\n\nx^y^z\n\n\nInput\n\n1.9 1.8 1.7\n\n\nOutput\n\n(x^y)^z",
        "task_name": "621_D. Rat Kwesh and Cheese",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from math import log\n\ndef calculateExp(x, y, z, k):\n\tif(k == 1):\n\t\treturn x**(y**z), \"x^y^z\"\n\telif(k == 2):\n\t\treturn x**(z**y), \"x^z^y\"\n\telif(k == 3 or k == 4):\n\t\treturn x**(z*y), \"(x^y)^z\"\n\telif(k == 5):\n\t\treturn y**(x**z), \"y^x^z\"\n\telif(k == 6):\n\t\treturn y**(z**x), \"y^z^x\"\n\telif(k == 7 or k == 8):\n\t\treturn y**(x*z), \"(y^x)^z\"\n\telif(k == 9):\n\t\treturn z**(x**y), \"z^x^y\"\n\telif(k == 10):\n\t\treturn z**(y**x), \"z^y^x\"\n\telif(k == 11 or k == 12):\n\t\treturn z**(x*y), \"(z^x)^y\"\n\ndef calculateLogLog(x, y, z, k):\n\tif(x > 1):\n\t\tif(k == 1):\n\t\t\treturn z * log(y) + log(log(x)), \"x^y^z\"\n\t\telif(k == 2):\n\t\t\treturn y * log(z) + log(log(x)), \"x^z^y\"\n\t\telif(k == 3 or k == 4):\n\t\t\treturn log(y) + log(z) + log(log(x)), \"(x^y)^z\"\n\n\tif(y > 1):\n\t\tif(k == 5):\n\t\t\treturn z * log(x) + log(log(y)), \"y^x^z\"\n\t\telif(k == 6):\n\t\t\treturn x * log(z) + log(log(y)), \"y^z^x\"\n\t\telif(k == 7 or k == 8):\n\t\t\treturn log(x) + log(z) + log(log(y)), \"(y^x)^z\"\n\n\tif(z > 1):\n\t\tif(k == 9):\n\t\t\treturn y * log(x) + log(log(z)), \"z^x^y\"\n\t\telif(k == 10):\n\t\t\treturn x * log(y) + log(log(z)), \"z^y^x\"\n\t\telif(k == 11 or k == 12):\n\t\t\treturn log(x) + log(y) + log(log(z)), \"(z^x)^y\"\n\n\treturn False, \"\"\ndef getAns(x, y, z):\n\tif(max(x,y,z) < 1):\n\t\tmaxNum, ans = 0, \"\"\n\t\tfor i in index:\n\t\t\tt = calculateExp(x, y, z, i)\n\t\t\tif(t[0] > maxNum):\n\t\t\t\tans = t[1]\n\t\t\t\tmaxNum = t[0]\n\t\treturn ans\n\telif(max(x, y, z) == 1):\n\t\tif(x == 1):\n\t\t\treturn \"x^y^z\"\n\t\telif(y == 1):\n\t\t\treturn \"y^x^z\"\n\t\telse:\n\t\t\treturn \"z^x^y\"\n\telse:\n\t\tmaxNum, ans = None, \"\"\n\t\tfor i in index:\n\t\t\tt = calculateLogLog(x, y, z, i)\n\t\t\tif(t[0] != False):\n\t\t\t\tif(maxNum == None or t[0] > maxNum):\n\t\t\t\t\tans = t[1]\n\t\t\t\t\tmaxNum = t[0]\n\t\t\t# print(t, ans)\n\n\t\treturn ans\n\nindex = [1, 2, 3, 5, 6, 7, 9, 10, 11]\nif(__name__ == \"__main__\"):\n\tx, y, z = [float(t) for t in raw_input().split(' ')]\n\t\n\tprint(getAns(x, y, z))",
        "correct": true,
        "task_id": "0070",
        "depth": 1
    },
    {
        "description": "Programmers' kids solve this riddle in 5-10 minutes. How fast can you do it?\n\nInput\n\nThe input contains a single integer n (0 \u2264 n \u2264 2000000000).\n\nOutput\n\nOutput a single integer.\n\nExamples\n\nInput\n\n11\n\n\nOutput\n\n2\n\n\nInput\n\n14\n\n\nOutput\n\n0\n\n\nInput\n\n61441\n\n\nOutput\n\n2\n\n\nInput\n\n571576\n\n\nOutput\n\n10\n\n\nInput\n\n2128506\n\n\nOutput\n\n3",
        "task_name": "784_B. Kids' Riddle",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "a=int(input())\nb=[1,0,0,0,1,0,1,0,2,1,1,2,0,1,0,0]\nres=0\nif a==0:\n\tres+=b[0]\nwhile a>0:\n\tres+=b[a%16]\n\ta/=16\nprint(res)\n",
        "correct": true,
        "task_id": "0075",
        "depth": 1
    },
    {
        "description": "You're given an array a_1, \u2026, a_n of n non-negative integers.\n\nLet's call it sharpened if and only if there exists an integer 1 \u2264 k \u2264 n such that a_1 < a_2 < \u2026 < a_k and a_k > a_{k+1} > \u2026 > a_n. In particular, any strictly increasing or strictly decreasing array is sharpened. For example:\n\n  * The arrays [4], [0, 1], [12, 10, 8] and [3, 11, 15, 9, 7, 4] are sharpened; \n  * The arrays [2, 8, 2, 8, 6, 5], [0, 1, 1, 0] and [2, 5, 6, 9, 8, 8] are not sharpened. \n\n\n\nYou can do the following operation as many times as you want: choose any strictly positive element of the array, and decrease it by one. Formally, you can choose any i (1 \u2264 i \u2264 n) such that a_i>0 and assign a_i := a_i - 1.\n\nTell if it's possible to make the given array sharpened using some number (possibly zero) of these operations.\n\nInput\n\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 15\\ 000) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 3 \u22c5 10^5).\n\nThe second line of each test case contains a sequence of n non-negative integers a_1, \u2026, a_n (0 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single line containing \"Yes\" (without quotes) if it's possible to make the given array sharpened using the described operations, or \"No\" (without quotes) otherwise.\n\nExample\n\nInput\n\n\n10\n1\n248618\n3\n12 10 8\n6\n100 11 15 9 7 8\n4\n0 1 1 0\n2\n0 0\n2\n0 1\n2\n1 0\n2\n1 1\n3\n0 1 0\n3\n1 0 1\n\n\nOutput\n\n\nYes\nYes\nYes\nNo\nNo\nYes\nYes\nYes\nYes\nNo\n\nNote\n\nIn the first and the second test case of the first test, the given array is already sharpened.\n\nIn the third test case of the first test, we can transform the array into [3, 11, 15, 9, 7, 4] (decrease the first element 97 times and decrease the last element 4 times). It is sharpened because 3 < 11 < 15 and 15 > 9 > 7 > 4.\n\nIn the fourth test case of the first test, it's impossible to make the given array sharpened.",
        "task_name": "1291_B. Array Sharpening",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys \ninput=sys.stdin.readline \ndef ok1(curr):\n    n=len(curr)\n    return all(l[i]>l[i-1] for i in range(1,n))\ndef ok2(curr):\n    n=len(curr)\n    return all(l[i]<l[i-1] for i in range(1,n))\nfor _ in range(int(input())):\n    n=int(input())\n    l=[int(i) for i in input().split()]\n    if ok1(l) or ok2(l):\n        print('Yes')\n        continue\n    #increase then decreasee \n    ind=-1 \n    mini=19**10 \n    maxi=0 \n    pr=0 \n    for i in range(n):\n        mini=min(mini,l[i])\n        maxi=max(maxi,l[i])\n        if l[i]<pr:\n            ind=i\n            break \n        pr+=1 \n    f=1 \n    if ind==-1:\n        print('Yes')\n        continue\n    mini=l[ind-1]\n    for i in range(ind,n):\n        l[i]=min(l[i],mini-1)\n        mini=min(mini,l[i])\n        if l[i]<0 or mini<0:\n            f=0 \n    print('Yes' if f else 'No')\n    \n        \n    ",
        "correct": true,
        "task_id": "0095",
        "depth": 2
    },
    {
        "description": "Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.\n\nAll levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by 1. If he manages to finish the level successfully then the number of clears increases by 1 as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).\n\nPolycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.\n\nSo he peeked at the stats n times and wrote down n pairs of integers \u2014 (p_1, c_1), (p_2, c_2), ..., (p_n, c_n), where p_i is the number of plays at the i-th moment of time and c_i is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).\n\nBetween two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.\n\nFinally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.\n\nHelp him to check the correctness of his records.\n\nFor your convenience you have to answer multiple independent test cases.\n\nInput\n\nThe first line contains a single integer T (1 \u2264 T \u2264 500) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 the number of moments of time Polycarp peeked at the stats.\n\nEach of the next n lines contains two integers p_i and c_i (0 \u2264 p_i, c_i \u2264 1000) \u2014 the number of plays and the number of clears of the level at the i-th moment of time.\n\nNote that the stats are given in chronological order.\n\nOutput\n\nFor each test case print a single line.\n\nIf there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print \"YES\".\n\nOtherwise, print \"NO\".\n\nYou can print each letter in any case (upper or lower).\n\nExample\n\nInput\n\n\n6\n3\n0 0\n1 1\n1 2\n2\n1 0\n1000 3\n4\n10 1\n15 2\n10 2\n15 2\n1\n765 432\n2\n4 4\n4 3\n5\n0 0\n1 0\n1 0\n1 0\n1 0\n\n\nOutput\n\n\nNO\nYES\nNO\nYES\nNO\nYES\n\nNote\n\nIn the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.\n\nThe second test case is a nice example of a Super Expert level.\n\nIn the third test case the number of plays decreased, which is impossible.\n\nThe fourth test case is probably an auto level with a single jump over the spike.\n\nIn the fifth test case the number of clears decreased, which is also impossible.\n\nNobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.",
        "task_name": "1334_A. Level Statistics",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n\n\ndef main():\n    # Template 1.0\n    import sys, re, math\n    from collections import deque, defaultdict, Counter, OrderedDict\n    from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, floor\n    from heapq import heappush, heappop, heapify, nlargest, nsmallest\n    def STR(): return list(input())\n\n    def INT(): return int(input())\n\n    def MAP(): return map(int, input().split())\n\n    def LIST(): return list(map(int, input().split()))\n\n    def list2d(a, b, c): return [[c] * b for i in range(a)]\n\n    def sortListWithIndex(listOfTuples, idx):   return (sorted(listOfTuples, key=lambda x: x[idx]))\n\n    def sortDictWithVal(passedDic):\n        temp = sorted(passedDic.items(), key=lambda kv: (kv[1], kv[0]))\n        toret = {}\n        for tup in temp:\n            toret[tup[0]] = tup[1]\n        return toret\n\n    def sortDictWithKey(passedDic):\n        return dict(OrderedDict(sorted(passedDic.items())))\n\n    INF = float('inf')\n    mod = 10 ** 9 + 7\n\n\n    t = INT()\n\n    while(t!=0):\n\n        n = INT()\n\n        zz = []\n\n        for _ in range(n):\n            zz.append(LIST())\n\n        prevplay = 0\n        prevClr = 0\n        flag = 0\n        for i in range(n):\n            if(zz[i][0]<prevplay or zz[i][1]<prevClr or zz[i][0]<zz[i][1]):\n                flag=1\n                break\n            if (zz[i][1] > prevClr):\n                temp = zz[i][1] - prevClr\n                temp1 = zz[i][0] - prevplay\n\n                if (temp > temp1):\n                    flag = 1\n                    break\n\n            prevplay = zz[i][0]\n            prevClr = zz[i][1]\n\n        if(flag==1):\n            print(\"NO\")\n        else:\n            print(\"YES\")\n\n        t-=1\n\n\n######## Python 2 and 3 footer by Pajenegod and c1729\n\n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n\n# So on cf, use PyPy2 for best string performance.\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\n\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill();\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode('ascii'))\n            self.read = lambda: self.buffer.read().decode('ascii')\n            self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Cout implemented in Python\nimport sys\n\n\nclass ostream:\n    def __lshift__(self, a):\n        sys.stdout.write(str(a))\n        return self\n\n\ncout = ostream()\nendl = '\\n'\n\n\n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero=0):\n    conv = ord if py2 else lambda x: x\n    A = [];\n    numb = zero;\n    sign = 1;\n    i = 0;\n    s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0'[0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-'[0]:\n                sign = -1\n            elif s[i] != b'\\r'[0]:\n                A.append(sign * numb)\n                numb = zero;\n                sign = 1\n            i += 1\n    except:\n        pass\n    if s and s[-1] >= b'0'[0]:\n        A.append(sign * numb)\n    return A\n\n\nif __name__ == \"__main__\":\n    main()",
        "correct": true,
        "task_id": "0097",
        "depth": 2
    },
    {
        "description": "The statement of this problem is the same as the statement of problem C1. The only difference is that, in problem C1, n is always even, and in C2, n is always odd.\n\nYou are given a regular polygon with 2 \u22c5 n vertices (it's convex and has equal sides and equal angles) and all its sides have length 1. Let's name it as 2n-gon.\n\nYour task is to find the square of the minimum size such that you can embed 2n-gon in the square. Embedding 2n-gon in the square means that you need to place 2n-gon in the square in such way that each point which lies inside or on a border of 2n-gon should also lie inside or on a border of the square.\n\nYou can rotate 2n-gon and/or the square.\n\nInput\n\nThe first line contains a single integer T (1 \u2264 T \u2264 200) \u2014 the number of test cases.\n\nNext T lines contain descriptions of test cases \u2014 one per line. Each line contains single odd integer n (3 \u2264 n \u2264 199). Don't forget you need to embed 2n-gon, not an n-gon.\n\nOutput\n\nPrint T real numbers \u2014 one per test case. For each test case, print the minimum length of a side of the square 2n-gon can be embedded in. Your answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\n\nExample\n\nInput\n\n\n3\n3\n5\n199\n\n\nOutput\n\n\n1.931851653\n3.196226611\n126.687663595",
        "task_name": "1354_C2. Not So Simple Polygon Embedding",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Educational Code Forces Round 87: C2: Not So Simple Polygon Embedding.\n# Sun. May. 17, 2020, By: arccosh.\n\nimport math\n\ndef solve(n):\n  return math.cos(math.pi / (4 * n)) / math.sin(math.pi / (2 * n))\n\nfor ca in xrange(int(raw_input())):\n  n = int(raw_input())\n  print('%.9f' % solve(n))\n",
        "correct": true,
        "task_id": "0098",
        "depth": 1
    },
    {
        "description": "You are given an array a of n integers.\n\nYou want to make all elements of a equal to zero by doing the following operation exactly three times:\n\n  * Select a segment, for each number in this segment we can add a multiple of len to it, where len is the length of this segment (added integers can be different). \n\n\n\nIt can be proven that it is always possible to make all elements of a equal to zero.\n\nInput\n\nThe first line contains one integer n (1 \u2264 n \u2264 100 000): the number of elements of the array.\n\nThe second line contains n elements of an array a separated by spaces: a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9).\n\nOutput\n\nThe output should contain six lines representing three operations.\n\nFor each operation, print two lines:\n\n  * The first line contains two integers l, r (1 \u2264 l \u2264 r \u2264 n): the bounds of the selected segment.\n\n  * The second line contains r-l+1 integers b_l, b_{l+1}, ..., b_r (-10^{18} \u2264 b_i \u2264 10^{18}): the numbers to add to a_l, a_{l+1}, \u2026, a_r, respectively; b_i should be divisible by r - l + 1.\n\nExample\n\nInput\n\n\n4\n1 3 2 4\n\n\nOutput\n\n\n1 1 \n-1\n3 4\n4 2\n2 4\n-3 -6 -6",
        "task_name": "1397_C. Multiples of Length",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\nfrom itertools import permutations \nimport threading,bisect,math,heapq,sys\n# threading.stack_size(2**27)\n# sys.setrecursionlimit(10**4)\nfrom sys import stdin, stdout\ni_m=9223372036854775807    \ndef cin():\n    return map(int,sin().split())\ndef ain():                           #takes array as input\n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input()) \nprime=[]\ndef dfs(n,d,v,a,c):\n    v[n]=1\n    if n in d:\n        x=d[n]\n    else:\n        a[n]+=c\n        x=[]\n    p=a[n]\n    for i in x:\n        if i not in v:\n            dfs(i,d,v,a,c)\n            p+=a[i]\n    a[n]=p\n    return p \n \n\"\"\"**************************MAIN*****************************\"\"\"\ndef main():\n    n=inin()\n    a=ain()\n    print(1,1)\n    x=a[0]%n\n    print(n-x)\n    a[0]+=n-x\n    if n>1:\n        print(2,n)\n        b=[]\n        for i in range(1,n):\n            b.append((a[i]%n)*(n-1))\n            a[i]+=b[i-1]\n        print(*b)\n    if n==1:\n        print(1,1)\n        print(0)\n    print(1,n)\n    for i in range(n):\n        a[i]=-a[i]\n    print(*a)\n\n    \n\"\"\"*******************************************************\"\"\"\n\n######## Python 2 and 3 footer by Pajenegod and c1729\nfac=[]\ndef fact(n,mod):\n    global fac\n    fac.append(1)\n    for i in range(1,n+1):\n        fac.append((fac[i-1]*i)%mod)\n    f=fac[:]\n    return f\ndef nCr(n,r,mod):\n    global fac\n    x=fac[n]\n    y=fac[n-r]\n    z=fac[r]\n    x=moddiv(x,y,mod)\n    return moddiv(x,z,mod)\ndef moddiv(m,n,p):\n    x=pow(n,p-2,p)\n    return (m*x)%p\ndef GCD(x, y): \n    x=abs(x)\n    y=abs(y)\n    if(min(x,y)==0):\n        return max(x,y)\n    while(y): \n        x, y = y, x % y \n    return x \ndef Divisors(n) : \n    l = []  \n    ll=[]\n    for i in range(1, int(math.sqrt(n) + 1)) :\n        if (n % i == 0) : \n            if (n // i == i) : \n                l.append(i) \n            else : \n                l.append(i)\n                ll.append(n//i)\n    l.extend(ll[::-1])\n    return l\ndef SieveOfEratosthenes(n): \n    global prime\n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n    f=[]\n    for p in range(2, n): \n        if prime[p]: \n            f.append(p)\n    return f\ndef primeFactors(n): \n    a=[]\n    while n % 2 == 0: \n        a.append(2) \n        n = n // 2 \n    for i in range(3,int(math.sqrt(n))+1,2):  \n        while n % i== 0: \n            a.append(i) \n            n = n // i  \n    if n > 2: \n        a.append(n)\n    return a\n\"\"\"*******************************************************\"\"\"\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\nimport os\nfrom io import IOBase, BytesIO\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n') \n# Cout implemented in Python\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'R' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'R' [0]:\n        A.append(sign*numb)\n    return A\n \n# threading.Thread(target=main).start()\nif __name__== \"__main__\":\n  main()",
        "correct": true,
        "task_id": "0100",
        "depth": 2
    },
    {
        "description": "Draw a chessboard which has a height of H cm and a width of W cm. For example, the following figure shows a chessboard which has a height of 6 cm and a width of 10 cm.\n\n\n.#.#.#.#.\n.#.#.#.#.#\n.#.#.#.#.\n.#.#.#.#.#\n.#.#.#.#.\n.#.#.#.#.#\n\n\nNote that the top left corner should be drawn by '#'.\n\nConstraints\n\n* 1 \u2264 H \u2264 300\n* 1 \u2264 W \u2264 300\n\nInput\n\nThe input consists of multiple datasets. Each dataset consists of two integers H and W separated by a single space.\n\nThe input ends with two 0 (when both H and W are zero).\n\nOutput\n\nFor each dataset, print the chessboard made of '#' and '.'.\n\nPrint a blank line after each dataset.\n\nExample\n\nInput\n\n3 4\n5 6\n3 3\n2 2\n1 1\n0 0\n\n\nOutput\n\n#.#.\n.#.#\n#.#.\n\n#.#.#.\n.#.#.#\n#.#.#.\n.#.#.#\n#.#.#.\n\n#.#\n.#.\n#.#\n\n#.\n.#\n\n#",
        "task_name": "p02405 Print a Chessboard",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def draw(h, w):\n    for i in range(h):\n        for j in range(w):\n            print(\"#\" if (i+j)%2 == 0 else \".\")\n        print(\"\")\n\nwhile True:\n    h, w = map(int, raw_input().split())\n    if h == 0 and w == 0:\n        break\n    draw(h, w)",
        "correct": false,
        "task_id": "0126",
        "depth": 2
    },
    {
        "description": "Everything got unclear to us in a far away constellation Tau Ceti. Specifically, the Taucetians choose names to their children in a very peculiar manner.\n\nTwo young parents abac and bbad think what name to give to their first-born child. They decided that the name will be the permutation of letters of string s. To keep up with the neighbours, they decided to call the baby so that the name was lexicographically strictly larger than the neighbour's son's name t.\n\nOn the other hand, they suspect that a name tax will be introduced shortly. According to it, the Taucetians with lexicographically larger names will pay larger taxes. That's the reason abac and bbad want to call the newborn so that the name was lexicographically strictly larger than name t and lexicographically minimum at that.\n\nThe lexicographical order of strings is the order we are all used to, the \"dictionary\" order. Such comparison is used in all modern programming languages to compare strings. Formally, a string p of length n is lexicographically less than string q of length m, if one of the two statements is correct:\n\n  * n < m, and p is the beginning (prefix) of string q (for example, \"aba\" is less than string \"abaa\"), \n  * p1 = q1, p2 = q2, ..., pk - 1 = qk - 1, pk < qk for some k (1 \u2264 k \u2264 min(n, m)), here characters in strings are numbered starting from 1. \n\n\n\nWrite a program that, given string s and the heighbours' child's name t determines the string that is the result of permutation of letters in s. The string should be lexicographically strictly more than t and also, lexicographically minimum.\n\nInput\n\nThe first line contains a non-empty string s (1 \u2264 |s| \u2264 5000), where |s| is its length. The second line contains a non-empty string t (1 \u2264 |t| \u2264 5000), where |t| is its length. Both strings consist of lowercase Latin letters.\n\nOutput\n\nPrint the sought name or -1 if it doesn't exist.\n\nExamples\n\nInput\n\naad\naac\n\n\nOutput\n\naad\n\n\nInput\n\nabad\nbob\n\n\nOutput\n\ndaab\n\n\nInput\n\nabc\ndefg\n\n\nOutput\n\n-1\n\n\nInput\n\nczaaab\nabcdef\n\n\nOutput\n\nabczaa\n\nNote\n\nIn the first sample the given string s is the sought one, consequently, we do not need to change the letter order there.",
        "task_name": "180_D. Name",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def solve():\n    s = list(raw_input())\n    t = list(raw_input())\n    scount = [0]*26\n    tcount = [0]*26\n    for char in s: scount[ord(char) - ord('a')]+=1\n    for char in t: tcount[ord(char) - ord('a')]+=1\n    allgreater = True\n    for i in range(26): \n        if scount[i] < tcount[i]:\n            allgreater = False\n    if allgreater:\n        if len(s) == len(t): return -1\n        for char in t: scount[ord(char) - ord('a')]-=1\n        for i in range(26): \n            while scount[i] > 0:\n                t.append(chr(i + ord('a')))\n                scount[i] -= 1\n        return ''.join(map(str, t))\n    works = -1\n    scountcopy = list(scount)\n    for i in range(len(s)):\n        cando = False\n        for j in range(ord(t[i]) - ord('a') + 1, 26): \n            if scountcopy[j] > 0:\n                cando = True\n        if cando:\n            works = i\n        if scountcopy[ord(t[i]) - ord('a')] == 0: break\n        scountcopy[ord(t[i]) - ord('a')] -= 1    \n    if works == -1: return -1\n    res = list()\n    for i in range(works):\n        res.append(t[i])\n        scount[ord(t[i]) - ord('a')] -= 1\n#     print(works)\n    for j in range(ord(t[works]) - ord('a') + 1, 26): \n        if scount[j] > 0:\n            res.append(chr(j + ord('a')))\n            scount[j]-=1\n            break\n#     print(res)\n    for i in range(26): \n        while scount[i] > 0:\n            res.append(chr(i + ord('a')))\n            scount[i] -= 1\n    return ''.join(map(str, res))\n        \nprint(solve())",
        "correct": false,
        "task_id": "0138",
        "depth": 2
    },
    {
        "description": "Little Petya likes arrays of integers a lot. Recently his mother has presented him one such array consisting of n elements. Petya is now wondering whether he can swap any two distinct integers in the array so that the array got unsorted. Please note that Petya can not swap equal integers even if they are in distinct positions in the array. Also note that Petya must swap some two integers even if the original array meets all requirements.\n\nArray a (the array elements are indexed from 1) consisting of n elements is called sorted if it meets at least one of the following two conditions:\n\n  1. a1 \u2264 a2 \u2264 ... \u2264 an; \n  2. a1 \u2265 a2 \u2265 ... \u2265 an. \n\n\n\nHelp Petya find the two required positions to swap or else say that they do not exist.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 105). The second line contains n non-negative space-separated integers a1, a2, ..., an \u2014 the elements of the array that Petya's mother presented him. All integers in the input do not exceed 109.\n\nOutput\n\nIf there is a pair of positions that make the array unsorted if swapped, then print the numbers of these positions separated by a space. If there are several pairs of positions, print any of them. If such pair does not exist, print -1. The positions in the array are numbered with integers from 1 to n.\n\nExamples\n\nInput\n\n1\n1\n\n\nOutput\n\n-1\n\n\nInput\n\n2\n1 2\n\n\nOutput\n\n-1\n\n\nInput\n\n4\n1 2 3 4\n\n\nOutput\n\n1 2\n\n\nInput\n\n3\n1 1 1\n\n\nOutput\n\n-1\n\nNote\n\nIn the first two samples the required pairs obviously don't exist.\n\nIn the third sample you can swap the first two elements. After that the array will look like this: 2 1 3 4. This array is unsorted.",
        "task_name": "252_B. Unsorting Array",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "####################################################\n# -*- coding: utf-8 -*-\nimport sys\n\nw = sys.stdout.write\nread = sys.stdin.readline\nreads = sys.stdin.read\n\ndef r(f=None):\n    if f:\n        return map(f, read().split())\n    else:\n        return read().split()\n\ndef rs(t,f=None):\n    result = []\n    result_append = result.append\n    for i in xrange(t):\n        if f:\n            result_append(tuple(map(f, read().split())))\n        else:\n            result_append(list(read().split()))\n    return result\n\n\n####################################################\nimport math\nsqrt = math.sqrt\nfrom collections import deque\n\n\n[n] = r(int)\nxs = r(int)\nxss = set(xs)\n\nif n <= 2:\n    w(\"-1\")\n    sys.exit()\n\nif len(xss) == 1:\n    w(\"-1\")\n    sys.exit()\n\nif len(xs) == 3 and xs[0] == xs[2]:\n    w(\"-1\")\n    sys.exit()\n\n\ndef check(xs, k):\n    k2 = 0 # malej\u0105co\n    k1 = 0\n    for i in xrange(0, n-1, 1):\n        if xs[i] < xs[i+1]:\n            k2 += 1\n        if xs[i] > xs[i+1]:\n            k1 += 1\n\n    if k2 >= 2:\n        for i in xrange(0, n-1, 1):\n            if xs[i] < xs[i+1]:\n                w(\"%s %s\" % (abs(i+1+k), abs(i+2+k)))\n                sys.exit()\n\n    if k2 == 1 and k1 >= 1 and len(xss) < n:\n        for i in xrange(0, n-1, 1):\n            if xs[i] > xs[i+1]:\n                w(\"%s %s\" % (abs(i+1+k), abs(i+2+k)))\n                sys.exit()\n            if xs[i] < xs[i+1]:\n                w(\"%s %s\" % (abs(i+1+k), abs(i+2+k)))\n                sys.exit()\n\n    if k2 == 1 and k1 == 0 and len(xs) >= 3:\n        for i in xrange(0, n-1, 1):\n            if xs[i] < xs[i+1]:\n                w(\"%s %s\" % (abs(i+1+k), abs(i+2+k)))\n                sys.exit()\n\n    if k2 == 0:\n        for i in xrange(0, n-1, 1):\n            if xs[0] != xs[i]:\n                w(\"%s %s\" % (abs(1+k), abs(i+1+k)))\n                sys.exit()\n\ncheck(xs, 0)\nxs.reverse()\ncheck(xs, -1*n)\n\n\nw(\"-1\")\n    \n\n\n\n\n\n\n",
        "correct": false,
        "task_id": "0140",
        "depth": 1
    },
    {
        "description": "Snuke is conducting an optical experiment using mirrors and his new invention, the rifle of Mysterious Light.\n\nThree mirrors of length N are set so that they form an equilateral triangle. Let the vertices of the triangle be a, b and c.\n\nInside the triangle, the rifle is placed at the point p on segment ab such that ap = X. (The size of the rifle is negligible.) Now, the rifle is about to fire a ray of Mysterious Light in the direction of bc.\n\nThe ray of Mysterious Light will travel in a straight line, and will be reflected by mirrors, in the same ways as \"ordinary\" light. There is one major difference, though: it will be also reflected by its own trajectory as if it is a mirror! When the ray comes back to the rifle, the ray will be absorbed.\n\nThe following image shows the ray's trajectory where N = 5 and X = 2.\n\nbtriangle.png\n\nIt can be shown that the ray eventually comes back to the rifle and is absorbed, regardless of the values of N and X. Find the total length of the ray's trajectory.\n\nConstraints\n\n* 2\u2266N\u226610^{12}\n* 1\u2266X\u2266N-1\n* N and X are integers.\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN X\n\n\nOutput\n\nPrint the total length of the ray's trajectory.\n\nExample\n\nInput\n\n5 2\n\n\nOutput\n\n12",
        "task_name": "p04048 AtCoder Grand Contest 001 - Mysterious Light",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "L = map(int, raw_input().split())\nn = L[0]\nx = L[1]\nres = n\na = x\nb = n-x\nflag = True\nwhile flag :\n    if a > b:\n        q = a // b\n        a -= q*b\n        res += 2*q*b\n    elif  b > a:\n        q = b // a\n        b -= q*a\n        res += 2*a*q\n    else:\n        res += a\n        flag = False\nprint(res)",
        "correct": false,
        "task_id": "0160",
        "depth": 1
    },
    {
        "description": "Sherlock Holmes and Dr. Watson played some game on a checkered board n \u00d7 n in size. During the game they put numbers on the board's squares by some tricky rules we don't know. However, the game is now over and each square of the board contains exactly one number. To understand who has won, they need to count the number of winning squares. To determine if the particular square is winning you should do the following. Calculate the sum of all numbers on the squares that share this column (including the given square) and separately calculate the sum of all numbers on the squares that share this row (including the given square). A square is considered winning if the sum of the column numbers is strictly greater than the sum of the row numbers.\n\n<image>\n\nFor instance, lets game was ended like is shown in the picture. Then the purple cell is winning, because the sum of its column numbers equals 8 + 3 + 6 + 7 = 24, sum of its row numbers equals 9 + 5 + 3 + 2 = 19, and 24 > 19.\n\nInput\n\nThe first line contains an integer n (1 \u2264 n \u2264 30). Each of the following n lines contain n space-separated integers. The j-th number on the i-th line represents the number on the square that belongs to the j-th column and the i-th row on the board. All number on the board are integers from 1 to 100.\n\nOutput\n\nPrint the single number \u2014 the number of the winning squares.\n\nExamples\n\nInput\n\n1\n1\n\n\nOutput\n\n0\n\n\nInput\n\n2\n1 2\n3 4\n\n\nOutput\n\n2\n\n\nInput\n\n4\n5 7 8 4\n9 5 3 2\n1 6 6 4\n9 5 7 3\n\n\nOutput\n\n6\n\nNote\n\nIn the first example two upper squares are winning.\n\nIn the third example three left squares in the both middle rows are winning:\n    \n    \n    5 7 8 4  \n    9 5 3 2  \n    1 6 6 4  \n    9 5 7 3  \n    ",
        "task_name": "157_A. Game Outcome",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(input())\nT = [[0 for loop in range(n)]for i in range(n)]\nfor loop in range(n):\n    T[loop]= list(map(int,raw_input().split(\" \")))\n\nlig = [0 for loop in range(n)]\nfor i in range(n):\n    for j in range(n):\n        lig[i]+= T[i][j]\n\ncol = [0 for loop in range(n)]\nfor i in range(n):\n    for j in range(n):\n        col[i] += T[j][i]\ncompt = 0\nfor i in range(n):\n    for j in range(n):\n        if col[i]>lig[j]:\n            compt += 1\nprint(compt)",
        "correct": true,
        "task_id": "0178",
        "depth": 2
    },
    {
        "description": "The nation of Panel holds an annual show called The Number Games, where each district in the nation will be represented by one contestant.\n\nThe nation has n districts numbered from 1 to n, each district has exactly one path connecting it to every other district. The number of fans of a contestant from district i is equal to 2^i.\n\nThis year, the president decided to reduce the costs. He wants to remove k contestants from the games. However, the districts of the removed contestants will be furious and will not allow anyone to cross through their districts. \n\nThe president wants to ensure that all remaining contestants are from districts that can be reached from one another. He also wishes to maximize the total number of fans of the participating contestants.\n\nWhich contestants should the president remove?\n\nInput\n\nThe first line of input contains two integers n and k (1 \u2264 k < n \u2264 10^6) \u2014 the number of districts in Panel, and the number of contestants the president wishes to remove, respectively.\n\nThe next n-1 lines each contains two integers a and b (1 \u2264 a, b \u2264 n, a \u2260 b), that describe a road that connects two different districts a and b in the nation. It is guaranteed that there is exactly one path between every two districts.\n\nOutput\n\nPrint k space-separated integers: the numbers of the districts of which the contestants should be removed, in increasing order of district number.\n\nExamples\n\nInput\n\n6 3\n2 1\n2 6\n4 2\n5 6\n2 3\n\n\nOutput\n\n1 3 4\n\n\nInput\n\n8 4\n2 6\n2 7\n7 8\n1 2\n3 1\n2 4\n7 5\n\n\nOutput\n\n1 3 4 5\n\nNote\n\nIn the first sample, the maximum possible total number of fans is 2^2 + 2^5 + 2^6 = 100. We can achieve it by removing the contestants of the districts 1, 3, and 4.",
        "task_name": "980_E. The Number Games",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n# import time\n\n\ndef calc_result(n, k, edges):\n    # t1 = time.clock()\n\n    storage = [-1] * (4 * n)\n    storage_index = 0\n    lookup = [-1] * (n + 1)\n    for u, v in edges:\n        storage[storage_index] = lookup[u]\n        storage[storage_index + 1] = v\n        lookup[u] = storage_index\n        storage_index += 2\n        storage[storage_index] = lookup[v]\n        storage[storage_index + 1] = u\n        lookup[v] = storage_index\n        storage_index += 2\n\n    # t2 = time.clock()\n\n    nodes = [0] * (2 * (n + 1))\n\n    # t3 = time.clock()\n\n    stack = [n]\n    stack_pop = stack.pop\n    stack_append = stack.append\n    while stack:\n        index = stack_pop()\n        parent_index = nodes[index * 2]\n        t = lookup[index]\n        while t >= 0:\n            v = storage[t + 1]\n            t = storage[t]\n            if v == parent_index:\n                continue\n            nodes[v * 2] = index\n            stack_append(v)\n\n    # t4 = time.clock()\n\n    count = n - k\n    for i in xrange(n, 0, -1):\n        new_nodes = []\n\n        p = i * 2\n        abort = False\n        while True:\n            flag = nodes[p + 1]\n            if flag == -1:\n                abort = True\n                break\n            elif flag == 1:\n                break\n            new_nodes.append(p)\n            index = nodes[p]\n            if index <= 0:\n                break\n            p = index * 2\n        if abort:\n            for p in new_nodes:\n                nodes[p + 1] = -1\n            continue\n\n        c = count - len(new_nodes)\n        if c >= 0:\n            for p in new_nodes:\n                nodes[p + 1] = 1\n            count = c\n            if count == 0:\n                break\n        else:\n            for j in xrange(-c):\n                nodes[new_nodes[j] + 1] = -1\n\n    # t5 = time.clock()\n    #\n    # print('---t5 - t1: %s' % (t5 - t1))\n    # print('---t2 - t1: %s' % (t2 - t1))\n    # print('---t3 - t2: %s' % (t3 - t2))\n    # print('---t4 - t3: %s' % (t4 - t3))\n    # print('---t5 - t4: %s' % (t5 - t4))\n\n    result = [i for i in xrange(1, n + 1) if nodes[i * 2 + 1] != 1]\n\n    print(' '.join(map(str, result)))\n\n\ndef main():\n    sys.setcheckinterval(2147483647)\n\n    n, k = map(int, sys.stdin.readline().split())\n    edges = [map(int, sys.stdin.readline().split()) for _ in xrange(n - 1)]\n\n    # import random\n    # n, k = 1000000, 19\n    # edges = []\n    # rnd = random.Random()\n    # rnd.seed(1)\n    # t = range(1, n + 1)\n    # random.shuffle(t, random=rnd.random)\n    # for i in xrange(2, n + 1):\n    #     j = rnd.randint(1, i - 1)\n    #     edges.append([i, j])\n\n    calc_result(n, k, edges)\n\n\nif __name__ == '__main__':\n    main()\n",
        "correct": true,
        "task_id": "0201",
        "depth": 2
    },
    {
        "description": "We have caught N sardines. The deliciousness and fragrantness of the i-th sardine is A_i and B_i, respectively.\n\nWe will choose one or more of these sardines and put them into a cooler. However, two sardines on bad terms cannot be chosen at the same time.\n\nThe i-th and j-th sardines (i \\neq j) are on bad terms if and only if A_i \\cdot A_j + B_i \\cdot B_j = 0.\n\nIn how many ways can we choose the set of sardines to put into the cooler? Since the count can be enormous, print it modulo 1000000007.\n\nConstraints\n\n* All values in input are integers.\n* 1 \\leq N \\leq 2 \\times 10^5\n* -10^{18} \\leq A_i, B_i \\leq 10^{18}\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nA_1 B_1\n:\nA_N B_N\n\n\nOutput\n\nPrint the count modulo 1000000007.\n\nExamples\n\nInput\n\n3\n1 2\n-1 1\n2 -1\n\n\nOutput\n\n5\n\n\nInput\n\n10\n3 2\n3 2\n-1 1\n2 -1\n-3 -9\n-8 12\n7 7\n8 1\n8 2\n8 4\n\n\nOutput\n\n479",
        "task_name": "p02679 AtCoder Beginner Contest 168 - \u2219 (Bullet)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from collections import defaultdict\n\nMOD = (10 ** 9) + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    return gcd(b, a % b)\n\nn = int(raw_input())\n\nns = []\nd = defaultdict(int)\n\nfor i in xrange(n):\n    a, b = map(int, raw_input().split())\n    ns.append((a, b))\n    if a and b:\n        s = 1 if a * b >= 0 else -1\n        g = gcd(abs(a), abs(b))\n        m1 = (s * abs(a) / g, abs(b) / g)\n        m2 = (-s * abs(b) / g, abs(a) / g)\n    elif a == 0 and b == 0:\n        continue\n    elif a == 0:\n        m1 = (1, 0)\n        m2 = (0, 1)\n    elif b == 0:\n        m1 = (0, 1)\n        m2 = (1, 0)\n\n    d[m1] += 1\n    d[m2] += 0\n\npre = 1\nfor k in d.keys():\n    if k[0] < 0:\n        assert (k[1], -k[0]) in d\n        continue\n    elif k[0] == 0:\n        pre = pre * d[k] % MOD\n    else:\n        k1 = k\n        k2 = (-k[1], k[0])\n\n        tot = pow(2, d[k1], MOD) + pow(2, d[k2], MOD) - 1\n        pre = pre * tot % MOD\nprint (pre - 1 + MOD) % MOD\n",
        "correct": false,
        "task_id": "0203",
        "depth": 1
    },
    {
        "description": "You are given an array [a_1, a_2, ..., a_n] such that 1 \u2264 a_i \u2264 10^9. Let S be the sum of all elements of the array a.\n\nLet's call an array b of n integers beautiful if:\n\n  * 1 \u2264 b_i \u2264 10^9 for each i from 1 to n; \n  * for every pair of adjacent integers from the array (b_i, b_{i + 1}), either b_i divides b_{i + 1}, or b_{i + 1} divides b_i (or both); \n  * 2 \u2211 _{i = 1}^{n} |a_i - b_i| \u2264 S. \n\n\n\nYour task is to find any beautiful array. It can be shown that at least one beautiful array always exists.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of two lines. The first line contains one integer n (2 \u2264 n \u2264 50).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nOutput\n\nFor each test case, print the beautiful array b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^9) on a separate line. It can be shown that at least one beautiful array exists under these circumstances. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n5\n1 2 3 4 5\n2\n4 6\n2\n1 1000000000\n6\n3 4 8 1 2 3\n\n\nOutput\n\n\n3 3 3 3 3\n3 6\n1 1000000000\n4 4 8 1 3 3",
        "task_name": "1463_B. Find The Array",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\nimport bisect\nimport math\nimport heapq\nimport itertools\nimport sys\nfrom collections import deque\nfrom atexit import register\nfrom collections import Counter\nfrom functools import reduce\nsys.setrecursionlimit(100000)\nif sys.version_info[0] < 3:\n    from io import BytesIO as stream\nelse:\n    from io import StringIO as stream\n \n \nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n \n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n \n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n \n    input = raw_input\n    range = xrange\n \n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n \n \ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n \n    Args:\n        sync (bool, optional): The new synchronization setting.\n \n    \"\"\"\n    global input, flush\n \n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\ndef dd():\n    return map(int,input().split())    \ndef arr():\n    return list(map(int,input().split()))\ndef twinSort(X,Y):\n    #sorting X wrt Y\n    return [x for _,x in sorted(zip(Y,X))]\n\ndef solve():\n    n=int(input())\n    ar=arr()\n    ans=[]\n\n    for i in range(n-1):\n        if ar[i]%ar[i+1]==0 or ar[i+1]%ar[i]==0:\n            ans.append(ar[i])\n        else:\n            if ar[i]<ar[i+1]:\n                ans.append(ar[i])\n                ar[i+1]-=(ar[i+1]%ar[i])\n            else:\n                ans.append(ar[i])\n                ar[i+1]+=(ar[i+1]%ar[i])\n\n        \n    ans.append(ar[i+1])\n    for i in ans:\n        print(i,end=' ')\n    print()\n\n\n        \n    # print(sum(ans)*2,sum(ar))\n\ndef main():\n    testCase=1\n    if testCase:\n        for _ in range(int(input())):\n            solve()\n    else:\n        solve()\n    \nif __name__ == '__main__':\n    sync_with_stdio(False)\n    main()",
        "correct": false,
        "task_id": "0227",
        "depth": 1
    },
    {
        "description": "The princess is going to escape the dragon's cave, and she needs to plan it carefully.\n\nThe princess runs at vp miles per hour, and the dragon flies at vd miles per hour. The dragon will discover the escape after t hours and will chase the princess immediately. Looks like there's no chance to success, but the princess noticed that the dragon is very greedy and not too smart. To delay him, the princess decides to borrow a couple of bijous from his treasury. Once the dragon overtakes the princess, she will drop one bijou to distract him. In this case he will stop, pick up the item, return to the cave and spend f hours to straighten the things out in the treasury. Only after this will he resume the chase again from the very beginning.\n\nThe princess is going to run on the straight. The distance between the cave and the king's castle she's aiming for is c miles. How many bijous will she need to take from the treasury to be able to reach the castle? If the dragon overtakes the princess at exactly the same moment she has reached the castle, we assume that she reached the castle before the dragon reached her, and doesn't need an extra bijou to hold him off.\n\nInput\n\nThe input data contains integers vp, vd, t, f and c, one per line (1 \u2264 vp, vd \u2264 100, 1 \u2264 t, f \u2264 10, 1 \u2264 c \u2264 1000).\n\nOutput\n\nOutput the minimal number of bijous required for the escape to succeed.\n\nExamples\n\nInput\n\n1\n2\n1\n1\n10\n\n\nOutput\n\n2\n\n\nInput\n\n1\n2\n1\n1\n8\n\n\nOutput\n\n1\n\nNote\n\nIn the first case one hour after the escape the dragon will discover it, and the princess will be 1 mile away from the cave. In two hours the dragon will overtake the princess 2 miles away from the cave, and she will need to drop the first bijou. Return to the cave and fixing the treasury will take the dragon two more hours; meanwhile the princess will be 4 miles away from the cave. Next time the dragon will overtake the princess 8 miles away from the cave, and she will need the second bijou, but after this she will reach the castle without any further trouble.\n\nThe second case is similar to the first one, but the second time the dragon overtakes the princess when she has reached the castle, and she won't need the second bijou.",
        "task_name": "148_B. Escape",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "vp = int(raw_input())\nvd = int(raw_input())\nt_read = int(raw_input())\nf = int(raw_input())\nc = int(raw_input())\n\n\npl = 0\ndl = 0\nt = 1\ncount = 0\n\n# print(vp, vd, t_read, f, c)\n\n\nwhile (pl + vp <= c):\n    \n    pl += vp\n\n\n    if (t > t_read):\n        dl += vd\n        if (dl >= pl and pl + vp <= c):\n            count += 1\n            dl = pl\n            pl += ((2 * (dl / vd)) + f) * vp\n            # print((str(t), str(count), str(dl), str(pl)))  \n\n            # while (dl > 0 and pl + vp <= c):\n            #     dl = max(dl - vd, 0)\n            #     print((str(t), str(count), str(dl), str(pl)))\n            #     pl += vp\n            # pl += f * vp\n            # if (pl + vp >= c):\n            #     break\n            \n            \n            \n\n\n    \n    t += 1\n\nprint(count)\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# while (pl < c - vp):\n\n#     # if (t == 0):\n#     #     t += 1\n#     #     print((str(t), str(count), str(dl), str(pl), 'BBE'))\n#     #     continue\n\n#     pl += vp\n    \n\n#     if (t > t_read - 1):\n#         dl += vd\n    \n#     lc = 0\n#     if (pl <= dl):\n#         count+=1\n#         lc+=1\n#         t = (t_read) - dl/vd - f\n#         print((str(t), str(count), str(dl), str(pl), 'CC'))\n#         # pl = pl + vp\n#         # if ()\n#         dl = 0\n#         # continue\n#     if (lc == 1):\n#         t_read -=1\n#     # print((str(t), str(count), str(dl), str(pl), 'BB'))\n#     t += 1\n   \n\n# print(count)\n\n# 1\n# 2\n# 1\n# 1\n# 8\n\n\n    ",
        "correct": false,
        "task_id": "0228",
        "depth": 1
    },
    {
        "description": "Vasya is interested in arranging dominoes. He is fed up with common dominoes and he uses the dominoes of different heights. He put n dominoes on the table along one axis, going from left to right. Every domino stands perpendicular to that axis so that the axis passes through the center of its base. The i-th domino has the coordinate xi and the height hi. Now Vasya wants to learn for every domino, how many dominoes will fall if he pushes it to the right. Help him do that. \n\nConsider that a domino falls if it is touched strictly above the base. In other words, the fall of the domino with the initial coordinate x and height h leads to the fall of all dominoes on the segment [x + 1, x + h - 1].\n\n<image>\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 105) which is the number of dominoes. Then follow n lines containing two integers xi and hi ( - 108 \u2264 xi \u2264 108, 2 \u2264 hi \u2264 108) each, which are the coordinate and height of every domino. No two dominoes stand on one point.\n\nOutput\n\nPrint n space-separated numbers zi \u2014 the number of dominoes that will fall if Vasya pushes the i-th domino to the right (including the domino itself).\n\nExamples\n\nInput\n\n4\n16 5\n20 5\n10 10\n18 2\n\n\nOutput\n\n3 1 4 1 \n\nInput\n\n4\n0 10\n1 5\n9 10\n15 10\n\n\nOutput\n\n4 1 2 1 ",
        "task_name": "56_E. Domino Principle",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\nimport sys\n\ndef get():\n    return sys.stdin.readline().split()\n\ndom = []\nn = int (get()[0])\nfor i in range (n):\n    dom.append (get())\n    dom[i].append (i)\n    for j in range (len (dom[i])):\n        dom[i][j] = int (dom[i][j])\ndom.sort()\n\nseg = 4 * n * [0]\nres = n * [0]\ninf = 1000 * 1000 * 100 + 10\n\ndef update (i, val, s, e, x):\n    seg[x] = max (seg[x], val)\n    if e - s < 2:\n        return;\n    m = (e + s) / 2\n    if i < m:\n        update (i, val, s, m, 2 * x)\n    else:\n        update (i, val, m, e, 2 * x + 1)\n\ndef find (x, s, e, l, r):\n    print (\"infind %d %d-%d %d-%d\" % (x, s, e, l, r))\n    if s >= r or e <= l:\n        return 0\n    print (\"passed\")\n    if (s == l and e == r) or e - s < 2:\n        print (\"wtf? %d\" % (seg[x]))\n        return seg[x]\n    m = (e + s) / 2\n    return max (find (2 * x, s, m, l, min (r, m)), find (2 * x + 1, m, e, max (m, l), r))\n\ndef query (i):\n    [x, h] = dom[i][0:2]\n    s = i; e = n\n    while e - s > 1:\n        m = int ((e + s) / 2)\n        print (\"bs %d\" % m)\n        if dom[m][0] < x + h:\n            s = m\n        else:\n            e = m\n\n    print (\"find %d %d - %d %d\" % (i, e, x, h))\n    return find (1, 0, n, i, e)\n\nindx = n\nwhile indx > 0:\n    indx -= 1\n    res[indx] = [dom[indx][2], max (indx + 1, query(indx)), indx]\n    print (\"res %d: %d\" % (indx, res[indx][1]))\n    update (indx, res[indx][1], 0, n, 1)\n    log = ''\n    for x in seg:\n        log += str (x) + ' '\n    print (log)\n\nprint (res)\n\nres.sort()\n\nout = ''\nfor i in range (n):\n    out += str (res[i][1] - res[i][2]) + ' '\nprint (out)",
        "correct": false,
        "task_id": "0239",
        "depth": 2
    },
    {
        "description": "You are given a positive integer n greater or equal to 2. For every pair of integers a and b (2 \u2264 |a|, |b| \u2264 n), you can transform a into b if and only if there exists an integer x such that 1 < |x| and (a \u22c5 x = b or b \u22c5 x = a), where |x| denotes the absolute value of x.\n\nAfter such a transformation, your score increases by |x| points and you are not allowed to transform a into b nor b into a anymore.\n\nInitially, you have a score of 0. You can start at any integer and transform it as many times as you like. What is the maximum score you can achieve?\n\nInput\n\nA single line contains a single integer n (2 \u2264 n \u2264 100 000) \u2014 the given integer described above.\n\nOutput\n\nPrint an only integer \u2014 the maximum score that can be achieved with the transformations. If it is not possible to perform even a single transformation for all possible starting integers, print 0.\n\nExamples\n\nInput\n\n4\n\n\nOutput\n\n8\n\nInput\n\n6\n\n\nOutput\n\n28\n\nInput\n\n2\n\n\nOutput\n\n0\n\nNote\n\nIn the first example, the transformations are 2 \u2192 4 \u2192 (-2) \u2192 (-4) \u2192 2.\n\nIn the third example, it is impossible to perform even a single transformation.",
        "task_name": "1062_D. Fun with Integers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division\nfrom sys import stdin, stdout\n# from fractions import gcd\n# from math import *\n# from operator import mul\n# from functools import reduce\n# from copy import copy\nfrom collections import deque, defaultdict, Counter\n\nrstr = lambda: stdin.readline().strip()\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\nrint = lambda: int(stdin.readline())\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrstr_2d = lambda n: [rstr() for _ in range(n)]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\nout = []\nn, ans = int(input()), 0\nfor i in range(2, n + 1):\n    cur = 2\n\n    while i * cur <= n:\n        ans += 4 * cur\n        cur += 1\n\nprint(ans)",
        "correct": true,
        "task_id": "0257",
        "depth": 2
    },
    {
        "description": "Recently, Tokitsukaze found an interesting game. Tokitsukaze had n items at the beginning of this game. However, she thought there were too many items, so now she wants to discard m (1 \u2264 m \u2264 n) special items of them.\n\nThese n items are marked with indices from 1 to n. In the beginning, the item with index i is placed on the i-th position. Items are divided into several pages orderly, such that each page contains exactly k positions and the last positions on the last page may be left empty.\n\nTokitsukaze would do the following operation: focus on the first special page that contains at least one special item, and at one time, Tokitsukaze would discard all special items on this page. After an item is discarded or moved, its old position would be empty, and then the item below it, if exists, would move up to this empty position. The movement may bring many items forward and even into previous pages, so Tokitsukaze would keep waiting until all the items stop moving, and then do the operation (i.e. check the special page and discard the special items) repeatedly until there is no item need to be discarded.\n\n<image> Consider the first example from the statement: n=10, m=4, k=5, p=[3, 5, 7, 10]. The are two pages. Initially, the first page is special (since it is the first page containing a special item). So Tokitsukaze discards the special items with indices 3 and 5. After, the first page remains to be special. It contains [1, 2, 4, 6, 7], Tokitsukaze discards the special item with index 7. After, the second page is special (since it is the first page containing a special item). It contains [9, 10], Tokitsukaze discards the special item with index 10.\n\nTokitsukaze wants to know the number of operations she would do in total.\n\nInput\n\nThe first line contains three integers n, m and k (1 \u2264 n \u2264 10^{18}, 1 \u2264 m \u2264 10^5, 1 \u2264 m, k \u2264 n) \u2014 the number of items, the number of special items to be discarded and the number of positions in each page.\n\nThe second line contains m distinct integers p_1, p_2, \u2026, p_m (1 \u2264 p_1 < p_2 < \u2026 < p_m \u2264 n) \u2014 the indices of special items which should be discarded.\n\nOutput\n\nPrint a single integer \u2014 the number of operations that Tokitsukaze would do in total.\n\nExamples\n\nInput\n\n\n10 4 5\n3 5 7 10\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n13 4 5\n7 8 9 10\n\n\nOutput\n\n\n1\n\nNote\n\nFor the first example:\n\n  * In the first operation, Tokitsukaze would focus on the first page [1, 2, 3, 4, 5] and discard items with indices 3 and 5; \n  * In the second operation, Tokitsukaze would focus on the first page [1, 2, 4, 6, 7] and discard item with index 7; \n  * In the third operation, Tokitsukaze would focus on the second page [9, 10] and discard item with index 10. \n\n\n\nFor the second example, Tokitsukaze would focus on the second page [6, 7, 8, 9, 10] and discard all special items at once.",
        "task_name": "1191_C. Tokitsukaze and Discard Items",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "data = list(map(int, raw_input().split()))\nn = data[0]\nm = data[1]\nk = data[2]\n\nnums = list(map(int, raw_input().split()))\n\ncurr = 0\noffset = 0\ni = 0\nop = 0\nwhile i < m:\n    if nums[i] <= offset + curr * k + k:\n        while i < m and nums[i] <= offset + curr * k + k:\n            i += 1\n        offset = i\n        op += 1\n    else :\n        curr += (nums[i] - (offset + curr * k) - 1) / k\nprint(op)\n",
        "correct": true,
        "task_id": "0260",
        "depth": 2
    },
    {
        "description": "Andrey's favourite number is n. Andrey's friends gave him two identical numbers n as a New Year present. He hung them on a wall and watched them adoringly.\n\nThen Andrey got bored from looking at the same number and he started to swap digits first in one, then in the other number, then again in the first number and so on (arbitrary number of changes could be made in each number). At some point it turned out that if we sum the resulting numbers, then the number of zeroes with which the sum will end would be maximum among the possible variants of digit permutations in those numbers.\n\nGiven number n, can you find the two digit permutations that have this property?\n\nInput\n\nThe first line contains a positive integer n \u2014 the original number. The number of digits in this number does not exceed 105. The number is written without any leading zeroes.\n\nOutput\n\nPrint two permutations of digits of number n, such that the sum of these numbers ends with the maximum number of zeroes. The permutations can have leading zeroes (if they are present, they all should be printed). The permutations do not have to be different. If there are several answers, print any of them.\n\nExamples\n\nInput\n\n198\n\n\nOutput\n\n981\n819\n\n\nInput\n\n500\n\n\nOutput\n\n500\n500",
        "task_name": "139_D. Digits Permutations",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\n\ndef d( digits ):\n  pair9s = {}\n  for i in range(10): pair9s[i] = 9 - i\n  baseCounts = [0]*10\n\n  for digit in digits: baseCounts[int(digit)] += 1\n\n\n  iTen = -1\n  mxZeros = 0\n  for i in range(1,6):\n\n    countsa = baseCounts[:]\n    countsb = baseCounts[:]\n    zeros=0\n    i10 = 10 - i\n    mn9s = [0]*10\n    mni10 = min(1,countsa[i],countsb[i10])\n\n    print( dict(i=i,countsa=countsa,countsb=countsb,mxZeros=mxZeros,mni10=mni10) )\n\n    if mni10>0:\n      countsa[i] -= 1\n      countsb[i10] -= 1\n      zeros = 1\n      for j in range(10):\n        j9 = pair9s[j]\n        mn = min( countsa[j],countsb[j9])\n        if mn>0:\n          countsa[j] -= mn\n          countsb[j9] -= mn\n          zeros += mn\n          mn9s[j] = mn\n\n    mn0 = min(countsa[0],countsb[0])\n    \n    countsa[0] -= mn0\n    countsb[0] -= mn0\n    zeros += mn0\n\n    if mxZeros < zeros:\n      mxZeros = zeros\n      mxZString = ['']*2\n      for j in range(10):\n         mxZString[0] += str(j) * countsa[j]\n         mxZString[1] += str(j) * countsb[j]\n      for j in range(10):\n         mxZString[0] += str(j)*mn9s[j]\n         mxZString[1] += str(9-j)*mn9s[j]\n      mxZString[0] += str(i)*mni10 + '0' * mn0 \n      mxZString[1] += str(i10)*mni10 + '0' * mn0 \n      print( dict(v=2,mxZString=mxZString) )\n\n  if mxZeros==0: return (digits,digits)\n\n  return tuple(mxZString)\n\nif __name__==\"__main__\":\n\n  digits = sys.stdin.readline().strip('\\n\\r ')\n\n  print( \"%s\\n%s\" % d(digits) )\n",
        "correct": false,
        "task_id": "0265",
        "depth": 2
    },
    {
        "description": "Seryozha has a very changeable character. This time he refused to leave the room to Dima and his girlfriend (her hame is Inna, by the way). However, the two lovebirds can always find a way to communicate. Today they are writing text messages to each other.\n\nDima and Inna are using a secret code in their text messages. When Dima wants to send Inna some sentence, he writes out all words, inserting a heart before each word and after the last word. A heart is a sequence of two characters: the \"less\" characters (<) and the digit three (3). After applying the code, a test message looks like that: <3word1<3word2<3 ... wordn<3.\n\nEncoding doesn't end here. Then Dima inserts a random number of small English characters, digits, signs \"more\" and \"less\" into any places of the message.\n\nInna knows Dima perfectly well, so she knows what phrase Dima is going to send her beforehand. Inna has just got a text message. Help her find out if Dima encoded the message correctly. In other words, find out if a text message could have been received by encoding in the manner that is described above.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 105) \u2014 the number of words in Dima's message. Next n lines contain non-empty words, one word per line. The words only consist of small English letters. The total length of all words doesn't exceed 105. \n\nThe last line contains non-empty text message that Inna has got. The number of characters in the text message doesn't exceed 105. A text message can contain only small English letters, digits and signs more and less.\n\nOutput\n\nIn a single line, print \"yes\" (without the quotes), if Dima decoded the text message correctly, and \"no\" (without the quotes) otherwise.\n\nExamples\n\nInput\n\n3\ni\nlove\nyou\n&lt;3i&lt;3love&lt;23you&lt;3\n\n\nOutput\n\nyes\n\n\nInput\n\n7\ni\nam\nnot\nmain\nin\nthe\nfamily\n&lt;3i&lt;&gt;3am&lt;3the&lt;3&lt;main&lt;3in&lt;3the&lt;3&gt;&lt;3family&lt;3\n\n\nOutput\n\nno\n\nNote\n\nPlease note that Dima got a good old kick in the pants for the second sample from the statement.",
        "task_name": "358_B. Dima and Text Messages",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\ndef normalize(string):\n    return ''.join(filter(lambda x: x.isalpha(), string))\n\ndef is_valid_encoding(encoding, word_list):\n    encoding_toks = encoding.split('<3')\n    message_str = ''.join(word_list)\n    encoding_str = ''\n    for enc in encoding_toks[1:-1]:\n        enc = normalize(enc)\n        if not enc:\n            return \"no\"\n        encoding_str += enc \n    if encoding_str == message_str:\n        return \"yes\"\n    else:\n        return \"no\"\n\nif __name__ == '__main__':\n    n = int(raw_input())\n    word_list = []\n    for i in range(n):\n        word_list.append(raw_input())\n    encoding = raw_input()\n",
        "correct": false,
        "task_id": "0276",
        "depth": 1
    },
    {
        "description": "We have N switches with \"on\" and \"off\" state, and M bulbs. The switches are numbered 1 to N, and the bulbs are numbered 1 to M.\n\nBulb i is connected to k_i switches: Switch s_{i1}, s_{i2}, ..., and s_{ik_i}. It is lighted when the number of switches that are \"on\" among these switches is congruent to p_i modulo 2.\n\nHow many combinations of \"on\" and \"off\" states of the switches light all the bulbs?\n\nConstraints\n\n* 1 \\leq N, M \\leq 10\n* 1 \\leq k_i \\leq N\n* 1 \\leq s_{ij} \\leq N\n* s_{ia} \\neq s_{ib} (a \\neq b)\n* p_i is 0 or 1.\n* All values in input are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M\nk_1 s_{11} s_{12} ... s_{1k_1}\n:\nk_M s_{M1} s_{M2} ... s_{Mk_M}\np_1 p_2 ... p_M\n\n\nOutput\n\nPrint the number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs.\n\nExamples\n\nInput\n\n2 2\n2 1 2\n1 2\n0 1\n\n\nOutput\n\n1\n\n\nInput\n\n2 3\n2 1 2\n1 1\n1 2\n0 0 1\n\n\nOutput\n\n0\n\n\nInput\n\n5 2\n3 1 2 5\n2 2 3\n1 0\n\n\nOutput\n\n8",
        "task_name": "p03031 AtCoder Beginner Contest 128 - Switches",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def multy(a,b):\n\tc = 0\n\tfor i in range(len(a)):\n\t\tc += a[i]*b[i]\n\treturn c\nN,M = map(int, raw_input().split())\nks = []\nfor i in range(M):\n\tks2 = map(int, raw_input().split())\n\tks.append(ks2)\npm = map(int, raw_input().split())\nplist = []\nfor i in ks:\n\tt = [0]*N\n\tini = 1\n\tfor j in i:\n\t\tif(ini == 1):\n\t\t\tini = 0\n\t\t\tcontinue\n\t\telse:\n\t\t\tt[j-1] = 1\n\tplist.append(t)\nslist = []\nfor i in range(2**N):\n\tt = []\n\tfor j in range(N):\n\t\tt.append(i%2)\n\t\ti = i/2\n\tslist.append(t)\nr = 0\nfor p in plist:\n\ts2 = []\n\tfor s in slist:\n\t\tif(multy(p,s)%2 == pm[r]):\n\t\t\ts2.append(s)\n\tr = r+1\n\tslist = s2\nprint(len(slist))",
        "correct": true,
        "task_id": "0293",
        "depth": 2
    },
    {
        "description": "Little Petya very much likes computers. Recently he has received a new \"Ternatron IV\" as a gift from his mother. Unlike other modern computers, \"Ternatron IV\" operates with ternary and not binary logic. Petya immediately wondered how the xor operation is performed on this computer (and whether there is anything like it).\n\nIt turned out that the operation does exist (however, it is called tor) and it works like this. Suppose that we need to calculate the value of the expression a tor b. Both numbers a and b are written in the ternary notation one under the other one (b under a). If they have a different number of digits, then leading zeroes are added to the shorter number until the lengths are the same. Then the numbers are summed together digit by digit. The result of summing each two digits is calculated modulo 3. Note that there is no carry between digits (i. e. during this operation the digits aren't transferred). For example: 1410 tor 5010 = 01123 tor 12123 = 10213 = 3410.\n\nPetya wrote numbers a and c on a piece of paper. Help him find such number b, that a tor b = c. If there are several such numbers, print the smallest one.\n\nInput\n\nThe first line contains two integers a and c (0 \u2264 a, c \u2264 109). Both numbers are written in decimal notation.\n\nOutput\n\nPrint the single integer b, such that a tor b = c. If there are several possible numbers b, print the smallest one. You should print the number in decimal notation.\n\nExamples\n\nInput\n\n14 34\n\n\nOutput\n\n50\n\n\nInput\n\n50 34\n\n\nOutput\n\n14\n\n\nInput\n\n387420489 225159023\n\n\nOutput\n\n1000000001\n\n\nInput\n\n5 5\n\n\nOutput\n\n0",
        "task_name": "136_B. Ternary Logic",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\nans = 0\n\n(a, b) = [int(x) for x in sys.stdin.readline().strip().split()]\n\nwhile a > 0 and b > 0:\n    ans *= 3\n    ans += (3 - a % 3 + b % 3) % 3\n    a //= 3\n    b //= 3\n\nprint(ans)",
        "correct": false,
        "task_id": "0313",
        "depth": 1
    },
    {
        "description": "There are n piranhas with sizes a_1, a_2, \u2026, a_n in the aquarium. Piranhas are numbered from left to right in order they live in the aquarium.\n\nScientists of the Berland State University want to find if there is dominant piranha in the aquarium. The piranha is called dominant if it can eat all the other piranhas in the aquarium (except itself, of course). Other piranhas will do nothing while the dominant piranha will eat them.\n\nBecause the aquarium is pretty narrow and long, the piranha can eat only one of the adjacent piranhas during one move. Piranha can do as many moves as it needs (or as it can). More precisely: \n\n  * The piranha i can eat the piranha i-1 if the piranha i-1 exists and a_{i - 1} < a_i. \n  * The piranha i can eat the piranha i+1 if the piranha i+1 exists and a_{i + 1} < a_i. \n\n\n\nWhen the piranha i eats some piranha, its size increases by one (a_i becomes a_i + 1).\n\nYour task is to find any dominant piranha in the aquarium or determine if there are no such piranhas.\n\nNote that you have to find any (exactly one) dominant piranha, you don't have to find all of them.\n\nFor example, if a = [5, 3, 4, 4, 5], then the third piranha can be dominant. Consider the sequence of its moves: \n\n  * The piranha eats the second piranha and a becomes [5, \\underline{5}, 4, 5] (the underlined piranha is our candidate). \n  * The piranha eats the third piranha and a becomes [5, \\underline{6}, 5]. \n  * The piranha eats the first piranha and a becomes [\\underline{7}, 5]. \n  * The piranha eats the second piranha and a becomes [\\underline{8}]. \n\n\n\nYou have to answer t independent test cases.\n\nInput\n\nThe first line of the input contains one integer t (1 \u2264 t \u2264 2 \u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\n\nThe first line of the test case contains one integer n (2 \u2264 n \u2264 3 \u22c5 10^5) \u2014 the number of piranhas in the aquarium. The second line of the test case contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^9), where a_i is the size of the i-th piranha.\n\nIt is guaranteed that the sum of n does not exceed 3 \u22c5 10^5 (\u2211 n \u2264 3 \u22c5 10^5).\n\nOutput\n\nFor each test case, print the answer: -1 if there are no dominant piranhas in the aquarium or index of any dominant piranha otherwise. If there are several answers, you can print any.\n\nExample\n\nInput\n\n\n6\n5\n5 3 4 4 5\n3\n1 1 1\n5\n4 4 3 4 4\n5\n5 5 4 3 2\n3\n1 1 2\n5\n5 4 3 5 5\n\n\nOutput\n\n\n3\n-1\n4\n3\n3\n1\n\nNote\n\nThe first test case of the example is described in the problem statement.\n\nIn the second test case of the example, there are no dominant piranhas in the aquarium.\n\nIn the third test case of the example, the fourth piranha can firstly eat the piranha to the left and the aquarium becomes [4, 4, 5, 4], then it can eat any other piranha in the aquarium.",
        "task_name": "1433_C. Dominant Piranha",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\nimport math\n\n\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    t=int(input())\n    for _ in range(t):\n        n=int(input())\n        a=list(map(int,input().split()))\n        m=(max(a))\n        f=0\n        for i in range(n):\n            if(a[i]==m):\n                if( (i-1>=0 and a[i]>a[i-1]) or (i+1<n and a[i]>a[i+1])):\n                    print(i+1)\n                    f=1\n                    break\n        if(f==0):\n            print(-1)\n\n\n\n\n\n            \n\n\n\n\n\n        \n        \n        \n\n    # region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# zz=not __debug__\n# if not zz:\n#     sys.stdin=open('input.txt', 'r')\n#     sys.stdout=open('output.txt','w')\n# # endregion\n\nif __name__ == \"__main__\":\n    main()",
        "correct": true,
        "task_id": "0315",
        "depth": 2
    },
    {
        "description": "Limak is a little polar bear. He loves connecting with other bears via social networks. He has n friends and his relation with the i-th of them is described by a unique integer ti. The bigger this value is, the better the friendship is. No two friends have the same value ti.\n\nSpring is starting and the Winter sleep is over for bears. Limak has just woken up and logged in. All his friends still sleep and thus none of them is online. Some (maybe all) of them will appear online in the next hours, one at a time.\n\nThe system displays friends who are online. On the screen there is space to display at most k friends. If there are more than k friends online then the system displays only k best of them \u2014 those with biggest ti.\n\nYour task is to handle queries of two types:\n\n  * \"1 id\" \u2014 Friend id becomes online. It's guaranteed that he wasn't online before. \n  * \"2 id\" \u2014 Check whether friend id is displayed by the system. Print \"YES\" or \"NO\" in a separate line. \n\n\n\nAre you able to help Limak and answer all queries of the second type?\n\nInput\n\nThe first line contains three integers n, k and q (1 \u2264 n, q \u2264 150 000, 1 \u2264 k \u2264 min(6, n)) \u2014 the number of friends, the maximum number of displayed online friends and the number of queries, respectively.\n\nThe second line contains n integers t1, t2, ..., tn (1 \u2264 ti \u2264 109) where ti describes how good is Limak's relation with the i-th friend.\n\nThe i-th of the following q lines contains two integers typei and idi (1 \u2264 typei \u2264 2, 1 \u2264 idi \u2264 n) \u2014 the i-th query. If typei = 1 then a friend idi becomes online. If typei = 2 then you should check whether a friend idi is displayed.\n\nIt's guaranteed that no two queries of the first type will have the same idi becuase one friend can't become online twice. Also, it's guaranteed that at least one query will be of the second type (typei = 2) so the output won't be empty.\n\nOutput\n\nFor each query of the second type print one line with the answer \u2014 \"YES\" (without quotes) if the given friend is displayed and \"NO\" (without quotes) otherwise.\n\nExamples\n\nInput\n\n4 2 8\n300 950 500 200\n1 3\n2 4\n2 3\n1 1\n1 2\n2 1\n2 2\n2 3\n\n\nOutput\n\nNO\nYES\nNO\nYES\nYES\n\n\nInput\n\n6 3 9\n50 20 51 17 99 24\n1 3\n1 4\n1 5\n1 2\n2 4\n2 2\n1 1\n2 4\n2 3\n\n\nOutput\n\nNO\nYES\nNO\nYES\n\nNote\n\nIn the first sample, Limak has 4 friends who all sleep initially. At first, the system displays nobody because nobody is online. There are the following 8 queries:\n\n  1. \"1 3\" \u2014 Friend 3 becomes online. \n  2. \"2 4\" \u2014 We should check if friend 4 is displayed. He isn't even online and thus we print \"NO\". \n  3. \"2 3\" \u2014 We should check if friend 3 is displayed. Right now he is the only friend online and the system displays him. We should print \"YES\". \n  4. \"1 1\" \u2014 Friend 1 becomes online. The system now displays both friend 1 and friend 3. \n  5. \"1 2\" \u2014 Friend 2 becomes online. There are 3 friends online now but we were given k = 2 so only two friends can be displayed. Limak has worse relation with friend 1 than with other two online friends (t1 < t2, t3) so friend 1 won't be displayed \n  6. \"2 1\" \u2014 Print \"NO\". \n  7. \"2 2\" \u2014 Print \"YES\". \n  8. \"2 3\" \u2014 Print \"YES\". ",
        "task_name": "658_B. Bear and Displayed Friends",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\n\ndef siftup(ind):\n    global tree\n    while (ind != 1) and (frendly[tree[ind]] < frendly[tree[ind // 2]]):\n        tree[ind], tree[ind // 2] = tree[ind // 2], tree[ind]\n        ind //= 2\n    \n\ndef siftdown(ind):\n    global tree\n    while (ind * 2 + 1 <= len(tree) - 1) and (frendly[tree[ind]] > frendly[tree[ind * 2]] or frendly[tree[ind]] > frendly[tree[ind * 2 + 1]]):\n        if frendly[tree[ind * 2]] > frendly[tree[ind * 2 + 1]]:\n            tree[ind], tree[ind * 2 + 1] = tree[ind * 2 + 1], tree[ind]\n            ind = ind * 2 + 1\n        else:\n            tree[ind], tree[ind * 2] = tree[ind * 2], tree[ind]\n            ind *= 2\n    if (ind * 2 <= len(tree) - 1) and (frendly[tree[ind]] > frendly[tree[ind * 2]]):\n        tree[ind], tree[ind * 2] = tree[ind * 2], tree[ind]\n        ind *= 2\n        \n    \nn, k, q = map(int, sys.stdin.readline().split())\nfrendly = [0] + list(map(int, sys.stdin.readline().split()))\nbearsout = set([i for i in range(1, n + 1)])\ntree = [0]\nfor i in range(q):\n    lab, b = map(int, sys.stdin.readline().split())\n    if lab == 1:\n        if len(tree) > k:\n            if frendly[b] > frendly[tree[1]]:\n                bearsout.discard(b)\n                bearsout.add(tree[1])\n                tree[1] = b\n                siftdown(1)\n        else:\n            tree.append(b)\n            bearsout.discard(b)\n            siftup(len(tree) - 1)\n    else:\n        if b in bearsout:\n            sys.stdout.write('NO' + '\\n')\n        else:\n            sys.stdout.write('YES' + '\\n')\n            #",
        "correct": true,
        "task_id": "0328",
        "depth": 1
    },
    {
        "description": "An African crossword is a rectangular table n \u00d7 m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.\n\nTo solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.\n\nWhen all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.\n\nYou are suggested to solve an African crossword and print the word encrypted there.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.\n\nOutput\n\nPrint the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.\n\nExamples\n\nInput\n\n3 3\ncba\nbcd\ncbc\n\n\nOutput\n\nabcd\n\nInput\n\n5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf\n\n\nOutput\n\ncodeforces",
        "task_name": "90_B. African Crossword",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def main():\n\tn, m = list(map(int, raw_input(\"\").split()))\n\n\tmatrix = []\n\tselected_words = \"\"\n\n\tfor i in range(n):\n\t\tletters = raw_input(\"\")\n\t\trow = []\n\t\tfor letter in letters:\n\t\t\trow.append(letter)\n\t\tmatrix.append(row)\n\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif not(word_not_repeated(matrix, i, j)):\n\t\t\t\tselected_words += matrix[i][j]\n\tprint(selected_words)\n\ndef word_not_repeated(matrix, i, j):\n\tletter = matrix[i][j]\n\tmatrix[i][j] = '_'\n\tresult = letter in matrix[i] or letter in zip(*matrix)[j]\n\tmatrix[i][j] = letter\n\treturn result\n\n\nif __name__ == '__main__':\n\tmain()\n\t    \t\t \t  \t\t\t\t\t\t \t \t\t \t\t\t\t",
        "correct": true,
        "task_id": "0335",
        "depth": 2
    },
    {
        "description": "You are given a sequence a_1, a_2, ..., a_n consisting of n non-zero integers (i.e. a_i \u2260 0). \n\nYou have to calculate two following values:\n\n  1. the number of pairs of indices (l, r) (l \u2264 r) such that a_l \u22c5 a_{l + 1} ... a_{r - 1} \u22c5 a_r is negative; \n  2. the number of pairs of indices (l, r) (l \u2264 r) such that a_l \u22c5 a_{l + 1} ... a_{r - 1} \u22c5 a_r is positive; \n\nInput\n\nThe first line contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^{5}) \u2014 the number of elements in the sequence.\n\nThe second line contains n integers a_1, a_2, ..., a_n (-10^{9} \u2264 a_i \u2264 10^{9}; a_i \u2260 0) \u2014 the elements of the sequence.\n\nOutput\n\nPrint two integers \u2014 the number of subsegments with negative product and the number of subsegments with positive product, respectively.\n\nExamples\n\nInput\n\n\n5\n5 -3 3 -1 1\n\n\nOutput\n\n\n8 7\n\n\nInput\n\n\n10\n4 2 -4 3 1 2 -4 3 2 3\n\n\nOutput\n\n\n28 27\n\n\nInput\n\n\n5\n-1 -2 -3 -4 -5\n\n\nOutput\n\n\n9 6",
        "task_name": "1215_B. The Number of Products",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport collections\nimport bisect\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nimport math\nn = int(raw_input())\nA = map(int, input().split())\nidx, size = 0, len(A)\ntotal = size * (1+size) / 2\np = [0] * size\nq = [0] * size\n\nif A[0] > 0:\n    p[0], q[0] = 1, 0\nelse:\n    q[0], p[0] = 1, 0\n\nfor i in xrange(1, size):\n    if A[i] > 0:\n        p[i] = p[i-1] + 1\n        q[i] = q[i-1]\n    else:\n        p[i] = q[i - 1]\n        q[i] = p[i-1] + 1\nprint('%s %s' % (sum(q), sum(p)))",
        "correct": true,
        "task_id": "0350",
        "depth": 1
    },
    {
        "description": "Positive integer x is called divisor of positive integer y, if y is divisible by x without remainder. For example, 1 is a divisor of 7 and 3 is not divisor of 8.\n\nWe gave you an integer d and asked you to find the smallest positive integer a, such that \n\n  * a has at least 4 divisors; \n  * difference between any two divisors of a is at least d.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 3000) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer d (1 \u2264 d \u2264 10000).\n\nOutput\n\nFor each test case print one integer a \u2014 the answer for this test case.\n\nExample\n\nInput\n\n\n2\n1\n2\n\n\nOutput\n\n\n6\n15\n\nNote\n\nIn the first test case, integer 6 have following divisors: [1, 2, 3, 6]. There are 4 of them and the difference between any two of them is at least 1. There is no smaller integer with at least 4 divisors.\n\nIn the second test case, integer 15 have following divisors: [1, 3, 5, 15]. There are 4 of them and the difference between any two of them is at least 2.\n\nThe answer 12 is INVALID because divisors are [1, 2, 3, 4, 6, 12]. And the difference between, for example, divisors 2 and 3 is less than d=2.",
        "task_name": "1474_B. Different Divisors",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\ntesting = len(sys.argv) == 4 and sys.argv[3] == \"myTest\"\nif testing:\n    cmd = sys.stdout\n    from time import time\n    start_time = int(round(time() * 1000)) \n    input = open(sys.argv[1], 'r').readline\n    readAll = open(sys.argv[1], 'r').read\n    sys.stdout = open(sys.argv[2], 'w')\nelse:\n    input = sys.stdin.readline\n    readAll = sys.stdin.read\n\n# ############ ---- I/O Functions ---- ############\n\n# class InputData:\n#     def __init__(self):\n#         self.lines = readAll().split('\\n')\n#         self.n = len(self.lines)\n#         self.ii = -1\n#     def input(self):\n#         self.ii += 1\n#         assert self.ii < self.n\n#         return self.lines[self.ii]\n# inputData = InputData()\n# input = inputData.input\n\ndef intin():\n    return(int(input()))\ndef intlin():\n    return(list(map(int,input().split())))\ndef chrin():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef strin():\n    s = input()\n    return s[:len(s) - 1]\ndef intlout(l, sep=\" \"):\n    print(sep.join(map(str, l)))\n    \n# ############ ---- I/O Functions ---- ############\n\n# from math import ceil\n# from collections import defaultdict as dd\n# from heapq import *\n# from Queue import Queue\n\ndef getDiv(n):\n    i = 1\n    sq_n = n**0.5\n    divs = []\n    while i <= sq_n:\n        if n%i==0:\n            divs.append(i)\n            if n / i != i:\n                divs.append(n/i)\n        i = i + 1\n    return sorted(divs)     # unsorted\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n%2==0 or n%3==0:\n        return False\n    i = 5\n    while i*i <= n:\n        if n%i==0 or n%(i+2)==0:\n            return False\n        i += 6\n    return True\n\ndef BS(arr, x, low, high):\n    if high >= low:\n        mid = (high + low) // 2\n        if arr[mid] == x:\n            return mid, mid\n        elif arr[mid] > x:\n            return BS(arr, x, low, mid - 1)\n        else:\n            return BS(arr, x, mid + 1, high)\n    else:\n        return high, low\n\np = [False]*21001\nfor i in xrange(1,21001):\n    p[i] = isPrime(i)\nprimes = [i for i,x in enumerate(p) if x]\n# print(primes)\ndef main():\n    d = intin()\n    i = BS(primes, d+1, 0, len(primes)-1)[1]\n    j = i+1\n    while primes[j] - primes[i] < d:\n        j += 1\n    print(primes[i]*primes[j])\n    \n\n\nif __name__ == \"__main__\":\n    for _ in xrange(intin()):\n        main()\n    # for i in xrange(1,11001):\n    #     a = getDiv(i)\n    #     if len(a) >= 4:\n    #         print(i, a)\n        # print(\"YES\" if main() else \"NO\")\n    # main()\n\n    if testing:\n        sys.stdout = cmd\n        print(int(round(time() * 1000))  - start_time)",
        "correct": true,
        "task_id": "0357",
        "depth": 1
    },
    {
        "description": "Pashmak's homework is a problem about graphs. Although he always tries to do his homework completely, he can't solve this problem. As you know, he's really weak at graph theory; so try to help him in solving the problem.\n\nYou are given a weighted directed graph with n vertices and m edges. You need to find a path (perhaps, non-simple) with maximum number of edges, such that the weights of the edges increase along the path. In other words, each edge of the path must have strictly greater weight than the previous edge in the path.\n\nHelp Pashmak, print the number of edges in the required path.\n\nInput\n\nThe first line contains two integers n, m (2 \u2264 n \u2264 3\u00b7105; 1 \u2264 m \u2264 min(n\u00b7(n - 1), 3\u00b7105)). Then, m lines follows. The i-th line contains three space separated integers: ui, vi, wi (1 \u2264 ui, vi \u2264 n; 1 \u2264 wi \u2264 105) which indicates that there's a directed edge with weight wi from vertex ui to vertex vi.\n\nIt's guaranteed that the graph doesn't contain self-loops and multiple edges.\n\nOutput\n\nPrint a single integer \u2014 the answer to the problem.\n\nExamples\n\nInput\n\n3 3\n1 2 1\n2 3 1\n3 1 1\n\n\nOutput\n\n1\n\n\nInput\n\n3 3\n1 2 1\n2 3 2\n3 1 3\n\n\nOutput\n\n3\n\n\nInput\n\n6 7\n1 2 1\n3 2 5\n2 4 2\n2 5 2\n2 6 9\n5 4 3\n4 3 4\n\n\nOutput\n\n6\n\nNote\n\nIn the first sample the maximum trail can be any of this trails: <image>.\n\nIn the second sample the maximum trail is <image>.\n\nIn the third sample the maximum trail is <image>.",
        "task_name": "459_E. Pashmak and Graph",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrints_2d = lambda n: [rints() for _ in range(n)]\n\nn, m = rints()\nmem, edges, weight = [0] * (n + 1), rints_2d(m), [[] for _ in range(10 ** 5 + 1)]\n\nfor u, v, w in edges:\n    weight[w].append((u, v))\n\nfor i in range(1, 10 ** 5 + 1):\n    all = [(v, mem[u]) for u, v in weight[i]]\n    for v, du in all:\n        mem[v] = max(mem[v], du + 1)\n\nprint(max(mem))\n",
        "correct": true,
        "task_id": "0365",
        "depth": 2
    },
    {
        "description": "There are many anime that are about \"love triangles\": Alice loves Bob, and Charlie loves Bob as well, but Alice hates Charlie. You are thinking about an anime which has n characters. The characters are labeled from 1 to n. Every pair of two characters can either mutually love each other or mutually hate each other (there is no neutral state).\n\nYou hate love triangles (A-B are in love and B-C are in love, but A-C hate each other), and you also hate it when nobody is in love. So, considering any three characters, you will be happy if exactly one pair is in love (A and B love each other, and C hates both A and B), or if all three pairs are in love (A loves B, B loves C, C loves A).\n\nYou are given a list of m known relationships in the anime. You know for sure that certain pairs love each other, and certain pairs hate each other. You're wondering how many ways you can fill in the remaining relationships so you are happy with every triangle. Two ways are considered different if two characters are in love in one way but hate each other in the other. Print this count modulo 1 000 000 007.\n\nInput\n\nThe first line of input will contain two integers n, m (3 \u2264 n \u2264 100 000, 0 \u2264 m \u2264 100 000).\n\nThe next m lines will contain the description of the known relationships. The i-th line will contain three integers ai, bi, ci. If ci is 1, then ai and bi are in love, otherwise, they hate each other (1 \u2264 ai, bi \u2264 n, ai \u2260 bi, <image>).\n\nEach pair of people will be described no more than once.\n\nOutput\n\nPrint a single integer equal to the number of ways to fill in the remaining pairs so that you are happy with every triangle modulo 1 000 000 007. \n\nExamples\n\nInput\n\n3 0\n\n\nOutput\n\n4\n\n\nInput\n\n4 4\n1 2 1\n2 3 1\n3 4 0\n4 1 0\n\n\nOutput\n\n1\n\n\nInput\n\n4 4\n1 2 1\n2 3 1\n3 4 0\n4 1 1\n\n\nOutput\n\n0\n\nNote\n\nIn the first sample, the four ways are to: \n\n  * Make everyone love each other \n  * Make 1 and 2 love each other, and 3 hate 1 and 2 (symmetrically, we get 3 ways from this). \n\n\n\nIn the second sample, the only possible solution is to make 1 and 3 love each other and 2 and 4 hate each other.",
        "task_name": "554_E. Love Triangles",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "maxn = 100005\nmod = 1000000007\ne = [[] for i in range(maxn)]\nvis = [False for i in range(maxn)]\ndef dfs(u):\n    sz = len(e[u])\n    ok = True\n    for i in range(sz):\n        v = e[u][i][0]\n        c = e[u][i][1]\n        if(vis[v] == False):\n            if(c == True):\n                vis[v] = vis[u]\n            else:\n                vis[v] = -vis[u]\n            ok = dfs(v)\n        if(c == 1 and vis[v] != vis[u]):\n            return False\n        if(c == 0 and vis[v] != -vis[u]):\n            return False\n    return ok\ndef main():\n    n,m = map(int,raw_input().split())\n    for i in range(m):\n        u,v,c = map(int,raw_input().split())\n        u -= 1\n        v -= 1\n        e[u].append([v,c])\n        e[v].append([u,c])\n    cnt = 0\n    for i in range(n):\n        if(vis[i] == False):\n            vis[i] = True\n            cnt += 1\n            if(dfs(i) == False):\n                cnt = 0\n                break\n    ans = 1\n    if(cnt == 0):\n        ans = 0\n    for i in (1,cnt):\n        ans *= 2\n        ans %= mod\n    print(ans)\nmain()",
        "correct": false,
        "task_id": "0366",
        "depth": 1
    },
    {
        "description": "In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network \u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.\n\nA train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.\n\nYou've been asked to plan out routes for the vehicles; each route can use any road/railway multiple times. One of the most important aspects to consider is safety \u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.\n\nUnder these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.\n\nInput\n\nThe first line of the input contains two integers n and m (2 \u2264 n \u2264 400, 0 \u2264 m \u2264 n(n - 1) / 2) \u2014 the number of towns and the number of railways respectively.\n\nEach of the next m lines contains two integers u and v, denoting a railway between towns u and v (1 \u2264 u, v \u2264 n, u \u2260 v).\n\nYou may assume that there is at most one railway connecting any two towns.\n\nOutput\n\nOutput one integer \u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output  - 1.\n\nExamples\n\nInput\n\n4 2\n1 3\n3 4\n\n\nOutput\n\n2\n\n\nInput\n\n4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n\n\nOutput\n\n-1\n\n\nInput\n\n5 5\n4 2\n3 5\n4 5\n5 1\n1 2\n\n\nOutput\n\n3\n\nNote\n\nIn the first sample, the train can take the route <image> and the bus can take the route <image>. Note that they can arrive at town 4 at the same time.\n\nIn the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.",
        "task_name": "602_C. The Two Routes",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\nfrom collections import *\n\n\nclass graph:\n    def __init__(self):\n        self.gdict, self.edges = defaultdict(list), set()\n\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.gdict[node2].append(node1)\n        self.edges.add(tuple(sorted([node1, node2])))\n\n    def bfs_util(self, i):\n        self.visit = [0] * (n + 1)\n        queue, self.visit[i] = deque([[i, 0]]), 1\n\n        while queue:\n            # dequeue parent vertix\n            s, lev = queue.popleft()\n            if s == n:\n                ans.append(lev)\n                break\n\n            # enqueue child vertices\n            for i1 in self.gdict[s]:\n                if self.visit[i1] == 0:\n                    queue.append([i1, lev + 1])\n                    self.visit[i1] = 1\n\n\nrint = lambda: int(stdin.readline())\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\n\nn, m = rints()\ng, g1, ans = graph(), graph(), []\nfor _ in range(m):\n    u, v = rints()\n    g.addEdge(u, v)\n\nfor i in range(1, n):\n    for j in range(i + 1, n + 1):\n        if (i, j) not in g.edges:\n            g1.addEdge(i, j)\n\ng.bfs_util(1)\ng1.bfs_util(1)\n# print(ans)\nprint(-1 if len(ans) < 2 else max(ans))\n",
        "correct": true,
        "task_id": "0367",
        "depth": 2
    },
    {
        "description": "Petya is a big fan of mathematics, especially its part related to fractions. Recently he learned that a fraction <image> is called proper iff its numerator is smaller than its denominator (a < b) and that the fraction is called irreducible if its numerator and its denominator are coprime (they do not have positive common divisors except 1).\n\nDuring his free time, Petya thinks about proper irreducible fractions and converts them to decimals using the calculator. One day he mistakenly pressed addition button ( + ) instead of division button (\u00f7) and got sum of numerator and denominator that was equal to n instead of the expected decimal notation. \n\nPetya wanted to restore the original fraction, but soon he realized that it might not be done uniquely. That's why he decided to determine maximum possible proper irreducible fraction <image> such that sum of its numerator and denominator equals n. Help Petya deal with this problem.\n\nInput\n\nIn the only line of input there is an integer n (3 \u2264 n \u2264 1000), the sum of numerator and denominator of the fraction.\n\nOutput\n\nOutput two space-separated positive integers a and b, numerator and denominator of the maximum possible proper irreducible fraction satisfying the given sum.\n\nExamples\n\nInput\n\n3\n\n\nOutput\n\n1 2\n\n\nInput\n\n4\n\n\nOutput\n\n1 3\n\n\nInput\n\n12\n\n\nOutput\n\n5 7",
        "task_name": "854_A. Fraction",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from fractions import gcd\nn=int(raw_input())\nfor i in range(n/2):\n    if(gcd(n-i,i)==1):\n        print (str(i)+\" \"+str(n-i))",
        "correct": false,
        "task_id": "0372",
        "depth": 1
    },
    {
        "description": "One common way of digitalizing sound is to record sound intensity at particular time moments. For each time moment intensity is recorded as a non-negative integer. Thus we can represent a sound file as an array of n non-negative integers.\n\nIf there are exactly K distinct values in the array, then we need k = \u2308 log_{2} K \u2309 bits to store each value. It then takes nk bits to store the whole file.\n\nTo reduce the memory consumption we need to apply some compression. One common way is to reduce the number of possible intensity values. We choose two integers l \u2264 r, and after that all intensity values are changed in the following way: if the intensity value is within the range [l;r], we don't change it. If it is less than l, we change it to l; if it is greater than r, we change it to r. You can see that we lose some low and some high intensities.\n\nYour task is to apply this compression in such a way that the file fits onto a disk of size I bytes, and the number of changed elements in the array is minimal possible.\n\nWe remind you that 1 byte contains 8 bits.\n\nk = \u2308 log_{2} K \u2309 is the smallest integer such that K \u2264 2^{k}. In particular, if K = 1, then k = 0.\n\nInput\n\nThe first line contains two integers n and I (1 \u2264 n \u2264 4 \u22c5 10^{5}, 1 \u2264 I \u2264 10^{8}) \u2014 the length of the array and the size of the disk in bytes, respectively.\n\nThe next line contains n integers a_{i} (0 \u2264 a_{i} \u2264 10^{9}) \u2014 the array denoting the sound file.\n\nOutput\n\nPrint a single integer \u2014 the minimal possible number of changed elements.\n\nExamples\n\nInput\n\n\n6 1\n2 1 2 3 4 3\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n6 2\n2 1 2 3 4 3\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n6 1\n1 1 2 2 3 3\n\n\nOutput\n\n\n2\n\nNote\n\nIn the first example we can choose l=2, r=3. The array becomes 2 2 2 3 3 3, the number of distinct elements is K=2, and the sound file fits onto the disk. Only two values are changed.\n\nIn the second example the disk is larger, so the initial file fits it and no changes are required.\n\nIn the third example we have to change both 1s or both 3s.",
        "task_name": "1198_A. MP3",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom collections import Counter\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    n, i = map(int, input().split())\n    ca = sorted(Counter(map(int, input().split())).items(), key=lambda x: x[0])\n\n    md = int(2 ** ((8 * i) / n))\n\n    pref = [0]\n    for _, j in ca:\n        pref.append(pref[-1] + j)\n\n    s = n\n    for i in range(len(pref) - md):\n        u = pref[i + md] - pref[i]\n        s = min(s, n - u)\n\n    if len(pref) - md <= 0:\n        s = 0\n\n    print(s)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": false,
        "task_id": "0388",
        "depth": 1
    },
    {
        "description": "There is a river of width n. The left bank of the river is cell 0 and the right bank is cell n + 1 (more formally, the river can be represented as a sequence of n + 2 cells numbered from 0 to n + 1). There are also m wooden platforms on a river, the i-th platform has length c_i (so the i-th platform takes c_i consecutive cells of the river). It is guaranteed that the sum of lengths of platforms does not exceed n.\n\nYou are standing at 0 and want to reach n+1 somehow. If you are standing at the position x, you can jump to any position in the range [x + 1; x + d]. However you don't really like the water so you can jump only to such cells that belong to some wooden platform. For example, if d=1, you can jump only to the next position (if it belongs to the wooden platform). You can assume that cells 0 and n+1 belong to wooden platforms.\n\nYou want to know if it is possible to reach n+1 from 0 if you can move any platform to the left or to the right arbitrary number of times (possibly, zero) as long as they do not intersect each other (but two platforms can touch each other). It also means that you cannot change the relative order of platforms.\n\nNote that you should move platforms until you start jumping (in other words, you first move the platforms and then start jumping).\n\nFor example, if n=7, m=3, d=2 and c = [1, 2, 1], then one of the ways to reach 8 from 0 is follow:\n\n<image> The first example: n=7.\n\nInput\n\nThe first line of the input contains three integers n, m and d (1 \u2264 n, m, d \u2264 1000, m \u2264 n) \u2014 the width of the river, the number of platforms and the maximum distance of your jump, correspondingly.\n\nThe second line of the input contains m integers c_1, c_2, ..., c_m (1 \u2264 c_i \u2264 n, \u2211_{i=1}^{m} c_i \u2264 n), where c_i is the length of the i-th platform.\n\nOutput\n\nIf it is impossible to reach n+1 from 0, print NO in the first line. Otherwise, print YES in the first line and the array a of length n in the second line \u2014 the sequence of river cells (excluding cell 0 and cell n + 1).\n\nIf the cell i does not belong to any platform, a_i should be 0. Otherwise, it should be equal to the index of the platform (1-indexed, platforms are numbered from 1 to m in order of input) to which the cell i belongs.\n\nNote that all a_i equal to 1 should form a contiguous subsegment of the array a of length c_1, all a_i equal to 2 should form a contiguous subsegment of the array a of length c_2, ..., all a_i equal to m should form a contiguous subsegment of the array a of length c_m. The leftmost position of 2 in a should be greater than the rightmost position of 1, the leftmost position of 3 in a should be greater than the rightmost position of 2, ..., the leftmost position of m in a should be greater than the rightmost position of m-1.\n\nSee example outputs for better understanding.\n\nExamples\n\nInput\n\n\n7 3 2\n1 2 1\n\n\nOutput\n\n\nYES\n0 1 0 2 2 0 3 \n\n\nInput\n\n\n10 1 11\n1\n\n\nOutput\n\n\nYES\n0 0 0 0 0 0 0 0 0 1 \n\n\nInput\n\n\n10 1 5\n2\n\n\nOutput\n\n\nYES\n0 0 0 0 1 1 0 0 0 0 \n\nNote\n\nConsider the first example: the answer is [0, 1, 0, 2, 2, 0, 3]. The sequence of jumps you perform is 0 \u2192 2 \u2192 4 \u2192 5 \u2192 7 \u2192 8.\n\nConsider the second example: it does not matter how to place the platform because you always can jump from 0 to 11.\n\nConsider the third example: the answer is [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]. The sequence of jumps you perform is 0 \u2192 5 \u2192 6 \u2192 11.",
        "task_name": "1256_C. Platforms Jumping",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, m, d = rints()\nc, ans = rints(), [0] * n\npos, su = [], 0\n\nfor i in range(m - 1, -1, -1):\n    pos.append(n + 1 - su - c[i])\n    su += c[i]\n\npos.append(0)\npos.reverse()\n\nfor i in range(m):\n    if pos[i + 1] - pos[i] <= d:\n        for j in range(pos[i + 1], pos[i + 1] + c[i]):\n            ans[j - 1] = i + 1\n        continue\n\n    pos[i + 1] = min(pos[i] + d, n)\n\n    for j in range(pos[i + 1], pos[i + 1] + c[i]):\n        ans[j - 1] = i + 1\n\n    pos[i + 1] += c[i] - 1\n\n# print(pos)\nif (n + 1) - (pos[-1] + c[-1] - 1) > d:\n    print('NO')\nelse:\n    print('YES')\n    print(' '.join(map(str, ans)))\n",
        "correct": false,
        "task_id": "0390",
        "depth": 2
    },
    {
        "description": "Valery is a PE teacher at a school in Berland. Soon the students are going to take a test in long jumps, and Valery has lost his favorite ruler! \n\nHowever, there is no reason for disappointment, as Valery has found another ruler, its length is l centimeters. The ruler already has n marks, with which he can make measurements. We assume that the marks are numbered from 1 to n in the order they appear from the beginning of the ruler to its end. The first point coincides with the beginning of the ruler and represents the origin. The last mark coincides with the end of the ruler, at distance l from the origin. This ruler can be repesented by an increasing sequence a1, a2, ..., an, where ai denotes the distance of the i-th mark from the origin (a1 = 0, an = l).\n\nValery believes that with a ruler he can measure the distance of d centimeters, if there is a pair of integers i and j (1 \u2264 i \u2264 j \u2264 n), such that the distance between the i-th and the j-th mark is exactly equal to d (in other words, aj - ai = d). \n\nUnder the rules, the girls should be able to jump at least x centimeters, and the boys should be able to jump at least y (x < y) centimeters. To test the children's abilities, Valery needs a ruler to measure each of the distances x and y. \n\nYour task is to determine what is the minimum number of additional marks you need to add on the ruler so that they can be used to measure the distances x and y. Valery can add the marks at any integer non-negative distance from the origin not exceeding the length of the ruler.\n\nInput\n\nThe first line contains four positive space-separated integers n, l, x, y (2 \u2264 n \u2264 105, 2 \u2264 l \u2264 109, 1 \u2264 x < y \u2264 l) \u2014 the number of marks, the length of the ruler and the jump norms for girls and boys, correspondingly.\n\nThe second line contains a sequence of n integers a1, a2, ..., an (0 = a1 < a2 < ... < an = l), where ai shows the distance from the i-th mark to the origin.\n\nOutput\n\nIn the first line print a single non-negative integer v \u2014 the minimum number of marks that you need to add on the ruler.\n\nIn the second line print v space-separated integers p1, p2, ..., pv (0 \u2264 pi \u2264 l). Number pi means that the i-th mark should be at the distance of pi centimeters from the origin. Print the marks in any order. If there are multiple solutions, print any of them.\n\nExamples\n\nInput\n\n3 250 185 230\n0 185 250\n\n\nOutput\n\n1\n230\n\n\nInput\n\n4 250 185 230\n0 20 185 250\n\n\nOutput\n\n0\n\n\nInput\n\n2 300 185 230\n0 300\n\n\nOutput\n\n2\n185 230\n\nNote\n\nIn the first sample it is impossible to initially measure the distance of 230 centimeters. For that it is enough to add a 20 centimeter mark or a 230 centimeter mark.\n\nIn the second sample you already can use the ruler to measure the distances of 185 and 230 centimeters, so you don't have to add new marks.\n\nIn the third sample the ruler only contains the initial and the final marks. We will need to add two marks to be able to test the children's skills.",
        "task_name": "480_B. Long Jumps",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport bisect\n\nimport numpy as np\n\n\nn, l, x, y = map(int, sys.stdin.next().split())\nmarks = map(int, sys.stdin.next().split())\n\nx_solved = False\ny_solved = False\n\nmagic_tick = None\n\nfor i, mark in enumerate(marks):\n\n    if mark + x > l:\n        break\n\n    res_y = bisect.bisect_left(marks, mark + y, lo=i)\n    res_x = bisect.bisect_left(marks, mark + x, lo=i, hi=min(res_y + 1, n))\n\n    res_x = min(max(0, res_x), n - 1)\n    res_y = min(max(0, res_y), n - 1)\n\n    if (marks[res_x] == mark + x):\n        x_solved = True\n    if (marks[res_y] == mark + y):\n        y_solved = True\n\nif x_solved and y_solved:\n    print(0)\nelif x_solved and not(y_solved):\n    print(1)\n    print(y)\nelif not(x_solved) and x_solved:\n    print(1)\n    print(x)\nelse:\n\n    for shift_x, shift_y in [(x, y), (-x, y), (x, -y), (x, y)]:\n        i, j = 0, 0\n        while True:\n            if (i >= n) or (j >= n):\n                break\n\n            if marks[i] + shift_x > marks[j] + shift_y:\n                j += 1\n            elif marks[i] + shift_x < marks[j] + shift_y:\n                i += 1\n            else:\n                if 0 <= marks[i] + shift_x <= l:\n                    magic_tick = marks[i] + shift_x\n                    break\n                else:\n                    i += 1\n                    j += 1\n\n    if magic_tick:\n        print(1)\n        print(magic_tick)\n    else:\n        print(2)\n        print(\"%i %i\" % (x, y))\n",
        "correct": false,
        "task_id": "0409",
        "depth": 2
    },
    {
        "description": "Kefa wants to celebrate his first big salary by going to restaurant. However, he needs company. \n\nKefa has n friends, each friend will agree to go to the restaurant if Kefa asks. Each friend is characterized by the amount of money he has and the friendship factor in respect to Kefa. The parrot doesn't want any friend to feel poor compared to somebody else in the company (Kefa doesn't count). A friend feels poor if in the company there is someone who has at least d units of money more than he does. Also, Kefa wants the total friendship factor of the members of the company to be maximum. Help him invite an optimal company!\n\nInput\n\nThe first line of the input contains two space-separated integers, n and d (1 \u2264 n \u2264 105, <image>) \u2014 the number of Kefa's friends and the minimum difference between the amount of money in order to feel poor, respectively.\n\nNext n lines contain the descriptions of Kefa's friends, the (i + 1)-th line contains the description of the i-th friend of type mi, si (0 \u2264 mi, si \u2264 109) \u2014 the amount of money and the friendship factor, respectively. \n\nOutput\n\nPrint the maximum total friendship factir that can be reached.\n\nExamples\n\nInput\n\n4 5\n75 5\n0 100\n150 20\n75 1\n\n\nOutput\n\n100\n\n\nInput\n\n5 100\n0 7\n11 32\n99 10\n46 8\n87 54\n\n\nOutput\n\n111\n\nNote\n\nIn the first sample test the most profitable strategy is to form a company from only the second friend. At all other variants the total degree of friendship will be worse.\n\nIn the second sample test we can take all the friends.",
        "task_name": "580_B. Kefa and Company",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#encoding: utf-8\nread_input = map(int, raw_input().split())\n\nn = read_input[0]\nd = read_input[1]\n\ninput_list = []\n\nfor i in range(n):\n    user_input = map(int, raw_input().split())\n    input_list.append((user_input[0], user_input[1]))\n\ninput_list.sort()\n\nmax_factor = input_list[0][1]\npartial_sum = input_list[0][1]\n\nj = 0\nfor i in range(1, n):\n    while((input_list[i][0] - input_list[j][0]) >= d):\n        partial_sum -= input_list[j][1]\n        j += 1\n\n    partial_sum += input_list[i][1]\n    max_factor = max(max_factor, partial_sum)\n\nprint(max_factor)",
        "correct": true,
        "task_id": "0412",
        "depth": 2
    },
    {
        "description": "After seeing the \"ALL YOUR BASE ARE BELONG TO US\" meme for the first time, numbers X and Y realised that they have different bases, which complicated their relations.\n\nYou're given a number X represented in base bx and a number Y represented in base by. Compare those two numbers.\n\nInput\n\nThe first line of the input contains two space-separated integers n and bx (1 \u2264 n \u2264 10, 2 \u2264 bx \u2264 40), where n is the number of digits in the bx-based representation of X. \n\nThe second line contains n space-separated integers x1, x2, ..., xn (0 \u2264 xi < bx) \u2014 the digits of X. They are given in the order from the most significant digit to the least significant one.\n\nThe following two lines describe Y in the same way: the third line contains two space-separated integers m and by (1 \u2264 m \u2264 10, 2 \u2264 by \u2264 40, bx \u2260 by), where m is the number of digits in the by-based representation of Y, and the fourth line contains m space-separated integers y1, y2, ..., ym (0 \u2264 yi < by) \u2014 the digits of Y.\n\nThere will be no leading zeroes. Both X and Y will be positive. All digits of both numbers are given in the standard decimal numeral system.\n\nOutput\n\nOutput a single character (quotes for clarity): \n\n  * '<' if X < Y\n  * '>' if X > Y\n  * '=' if X = Y\n\nExamples\n\nInput\n\n6 2\n1 0 1 1 1 1\n2 10\n4 7\n\n\nOutput\n\n=\n\n\nInput\n\n3 3\n1 0 2\n2 5\n2 4\n\n\nOutput\n\n&lt;\n\n\nInput\n\n7 16\n15 15 4 0 0 7 10\n7 9\n4 8 0 3 1 5 0\n\n\nOutput\n\n&gt;\n\nNote\n\nIn the first sample, X = 1011112 = 4710 = Y.\n\nIn the second sample, X = 1023 = 215 and Y = 245 = 1123, thus X < Y.\n\nIn the third sample, <image> and Y = 48031509. We may notice that X starts with much larger digits and bx is much larger than by, so X is clearly larger than Y.",
        "task_name": "602_A. Two Bases",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "s = raw_input().split(\" \")\nn = int(s[0])\nbx = int(s[1])\n\nx = 0\nxs = raw_input().split(\" \")\nfor i in range(n-1, -1, -1):\n    a = int(xs[n-1-i])\n    x = x + ((bx**i) * a)\n\ns = raw_input().split(\" \")\nm = int(s[0])\nby = int(s[1])\n\ny = 0\nys = raw_input().split(\" \")\nfor i in range(m-1, -1, -1):\n    a = int(ys[m-1-i])\n    y = y + ((by**i) * a)\n\nif (x == y): ans = \"=\"\nelif (x > y): ans = \">\"\nelse : ans = \"<\"\n\nprint(ans)\n",
        "correct": true,
        "task_id": "0413",
        "depth": 1
    },
    {
        "description": "A tree is an undirected connected graph without cycles.\n\nLet's consider a rooted undirected tree with n vertices, numbered 1 through n. There are many ways to represent such a tree. One way is to create an array with n integers p1, p2, ..., pn, where pi denotes a parent of vertex i (here, for convenience a root is considered its own parent).\n\n<image> For this rooted tree the array p is [2, 3, 3, 2].\n\nGiven a sequence p1, p2, ..., pn, one is able to restore a tree:\n\n  1. There must be exactly one index r that pr = r. A vertex r is a root of the tree. \n  2. For all other n - 1 vertices i, there is an edge between vertex i and vertex pi. \n\n\n\nA sequence p1, p2, ..., pn is called valid if the described procedure generates some (any) rooted tree. For example, for n = 3 sequences (1,2,2), (2,3,1) and (2,1,3) are not valid.\n\nYou are given a sequence a1, a2, ..., an, not necessarily valid. Your task is to change the minimum number of elements, in order to get a valid sequence. Print the minimum number of changes and an example of a valid sequence after that number of changes. If there are many valid sequences achievable in the minimum number of changes, print any of them.\n\nInput\n\nThe first line of the input contains an integer n (2 \u2264 n \u2264 200 000) \u2014 the number of vertices in the tree.\n\nThe second line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 n).\n\nOutput\n\nIn the first line print the minimum number of elements to change, in order to get a valid sequence.\n\nIn the second line, print any valid sequence possible to get from (a1, a2, ..., an) in the minimum number of changes. If there are many such sequences, any of them will be accepted.\n\nExamples\n\nInput\n\n4\n2 3 3 4\n\n\nOutput\n\n1\n2 3 4 4 \n\n\nInput\n\n5\n3 2 2 5 3\n\n\nOutput\n\n0\n3 2 2 5 3 \n\n\nInput\n\n8\n2 3 5 4 1 6 6 7\n\n\nOutput\n\n2\n2 3 7 8 1 6 6 7\n\nNote\n\nIn the first sample, it's enough to change one element. In the provided output, a sequence represents a tree rooted in a vertex 4 (because p4 = 4), which you can see on the left drawing below. One of other correct solutions would be a sequence 2 3 3 2, representing a tree rooted in vertex 3 (right drawing below). On both drawings, roots are painted red.\n\n<image>\n\nIn the second sample, the given sequence is already valid.",
        "task_name": "698_B. Fix a Tree",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import itertools\nimport sys\n\n\ndef readline_int(delta=0):\n    return [int(i) + delta for i in raw_input().split()]\n\nclass Solution(object):\n    def find(self, ident, fa):\n        if fa[ident] != ident:\n             fa[ident] = self.find(fa[ident], fa)\n        return fa[ident]\n\n    def merge(self, ident_child, ident_father, fa):\n        fa_child = fa[ident_child]\n        fa_father = fa[ident_father]\n        fa[fa_child] = fa_father\n\n    def solve(self):\n        n = self.n\n        p = self.p\n        issues = []\n        roots = []\n        fa = [i for i in xrange(n)]\n\n        for current in xrange(n):\n            parent = p[current]\n            if parent == current:\n                roots.append(current)\n                continue\n\n            parent_set_id = self.find(parent, fa)\n            if parent_set_id == current:\n                issues.append(current)\n                continue\n\n            self.merge(current, parent, fa)\n\n        root = None\n        changes = 0\n        if len(roots) > 0:\n            root = roots[0]\n            changes = len(roots) + len(issues) - 1\n        elif len(roots) == 0:\n            root = roots[0] if len(roots) > 0 else issues[0]\n            changes = len(roots) + len(issues)\n\n        for ident in itertools.chain(roots, issues):\n            p[ident] = root\n\n        return (changes, p, )\n\n    def read_data(self):\n        self.n = readline_int()[0]\n        self.p = readline_int(delta=-1) # make sure to restore index while printing result\n\n    def print_result(self, result):\n        changes, p = result\n        print(changes)\n        for idx, parent in enumerate(p):\n            sys.stdout.write(str(parent))\n            if idx != len(p) - 1:\n                sys.stdout.write(' ')\n        sys.stdout.write('\\n')\n\n\n    def run(self):\n        self.read_data()\n        result = self.solve()\n        self.print_result(result)\n\nif len(sys.argv) > 1:\n    sys.stdin = open(sys.argv[1], 'r')\n    print('Redirect stdin to {0}'.format(sys.argv[1]))\n\nSolution().run()\n\n",
        "correct": false,
        "task_id": "0415",
        "depth": 1
    },
    {
        "description": "Anatoly lives in the university dorm as many other students do. As you know, cockroaches are also living there together with students. Cockroaches might be of two colors: black and red. There are n cockroaches living in Anatoly's room.\n\nAnatoly just made all his cockroaches to form a single line. As he is a perfectionist, he would like the colors of cockroaches in the line to alternate. He has a can of black paint and a can of red paint. In one turn he can either swap any two cockroaches, or take any single cockroach and change it's color.\n\nHelp Anatoly find out the minimum number of turns he needs to make the colors of cockroaches in the line alternate.\n\nInput\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000) \u2014 the number of cockroaches.\n\nThe second line contains a string of length n, consisting of characters 'b' and 'r' that denote black cockroach and red cockroach respectively.\n\nOutput\n\nPrint one integer \u2014 the minimum number of moves Anatoly has to perform in order to make the colors of cockroaches in the line to alternate.\n\nExamples\n\nInput\n\n5\nrbbrr\n\n\nOutput\n\n1\n\n\nInput\n\n5\nbbbbb\n\n\nOutput\n\n2\n\n\nInput\n\n3\nrbr\n\n\nOutput\n\n0\n\nNote\n\nIn the first sample, Anatoly has to swap third and fourth cockroaches. He needs 1 turn to do this.\n\nIn the second sample, the optimum answer is to paint the second and the fourth cockroaches red. This requires 2 turns.\n\nIn the third sample, the colors of cockroaches in the line are alternating already, thus the answer is 0.",
        "task_name": "719_B. Anatoly and Cockroaches",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\nline = raw_input()\n\nchange_red = 0\nchange_black = 0\nfor idx,val in enumerate(line):\n\tif idx%2 == 0 and val == 'b':\n\t\tchange_black += 1\n\tif idx%2 == 1 and val == 'r':\n\t\tchange_red += 1\nswaps = min(change_red, change_black)\ncolor = max(change_red, change_black) - swaps\n\ntotal = swaps + color\n\nchange_red2 = 0\nchange_black2 = 0\nfor idx,val in enumerate(line):\n\tif idx%2 == 1 and val == 'b':\n\t\tchange_black2 += 1\n\tif idx%2 == 0 and val == 'r':\n\t\tchange_red2 += 1\n\n\nswaps2 = min(change_red2, change_black2)\ncolor2 = max(change_red2, change_black2) - swaps2\n\ntotal2 = swaps2 + color2\n\nprint(min(total, total2))\n\n\n\n",
        "correct": true,
        "task_id": "0416",
        "depth": 1
    },
    {
        "description": "You are given a sequence A_1, A_2, ..., A_N and an integer K.\n\nPrint the maximum possible length of a sequence B that satisfies the following conditions:\n\n* B is a (not necessarily continuous) subsequence of A.\n* For each pair of adjacents elements of B, the absolute difference of the elements is at most K.\n\nConstraints\n\n* 1 \\leq N \\leq 300,000\n* 0 \\leq A_i \\leq 300,000\n* 0 \\leq K \\leq 300,000\n* All values in input are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN K\nA_1\nA_2\n:\nA_N\n\n\nOutput\n\nPrint the answer.\n\nExample\n\nInput\n\n10 3\n1\n5\n4\n3\n8\n6\n9\n7\n2\n4\n\n\nOutput\n\n7",
        "task_name": "p02537 ACL Beginner Contest - Flat Subsequence",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\n\nn, k = map(int, input().split(\" \"))\n\nnums = [int(input()) for i in range(n)]\ngraph = [[] for i in range(n)]\n\nfor node1 in range(n-1):\n    num1 = nums[node1]\n    for node2 in range(node1+1, n):\n        num2 = nums[node2]\n        if abs(num1-num2) <= k:\n            graph[node2].append(node1)\n\nlens = []\nmax_ = 0\nfor node in range(n):\n    if len(graph[node]) == 0:\n        len_ = 1\n    else:\n        len_ = max([lens[kid] for kid in graph[node]]) + 1\n    lens.append(len_)\n    max_ = max(len_, max_)\n\nprint(max_)",
        "correct": false,
        "task_id": "0423",
        "depth": 2
    },
    {
        "description": "You are given an undirected connected weighted graph with N vertices and M edges that contains neither self-loops nor double edges.\nThe i-th (1\u2264i\u2264M) edge connects vertex a_i and vertex b_i with a distance of c_i.\nHere, a self-loop is an edge where a_i = b_i (1\u2264i\u2264M), and double edges are two edges where (a_i,b_i)=(a_j,b_j) or (a_i,b_i)=(b_j,a_j) (1\u2264i<j\u2264M).\nA connected graph is a graph where there is a path between every pair of different vertices.\nFind the number of the edges that are not contained in any shortest path between any pair of different vertices.\n\nConstraints\n\n* 2\u2264N\u2264100\n* N-1\u2264M\u2264min(N(N-1)/2,1000)\n* 1\u2264a_i,b_i\u2264N\n* 1\u2264c_i\u22641000\n* c_i is an integer.\n* The given graph contains neither self-loops nor double edges.\n* The given graph is connected.\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN M\na_1 b_1 c_1\na_2 b_2 c_2\n:\na_M b_M c_M\n\n\nOutput\n\nPrint the number of the edges in the graph that are not contained in any shortest path between any pair of different vertices.\n\nExamples\n\nInput\n\n3 3\n1 2 1\n1 3 1\n2 3 3\n\n\nOutput\n\n1\n\n\nInput\n\n3 2\n1 2 1\n2 3 1\n\n\nOutput\n\n0",
        "task_name": "p03837 AtCoder Beginner Contest 051 - Candidates of No Shortest Paths",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# Python program for Dijkstra's \n# single source shortest \n# path algorithm. The program \n# is for adjacency matrix \nans=[]\np=[]\n# representation of the graph \n\nfrom collections import defaultdict \npa=[]\n#Class to represent a graph \nclass Graph: \n\n\t# A utility function to find the \n\t# vertex with minimum dist value, from \n\t# the set of vertices still in queue \n\tdef minDistance(self,dist,queue): \n\t\t# Initialize min value and min_index as -1 \n\t\tminimum = float(\"Inf\") \n\t\tmin_index = -1\n\t\t\n\t\t# from the dist array,pick one which \n\t\t# has min value and is till in queue \n\t\tfor i in range(len(dist)): \n\t\t\tif dist[i] < minimum and i in queue: \n\t\t\t\tminimum = dist[i] \n\t\t\t\tmin_index = i \n\t\treturn min_index \n\n\n\t# Function to print shortest path \n\t# from source to j \n\t# using parent array \n\tdef printPath(self, parent, j): \n\t\tglobal p\n\t\tglobal pa \n\t\t#Base Case : If j is source \n\t\tif parent[j] == -1 : \n\t\t#\tprint j, \n\t\t\tp.append(j)\n\t\t\tpa.append(p)\n\t\t\treturn\n\t\tself.printPath(parent , parent[j]) \n\t\t#print j, \n\t\tp.append(j)\n        \n\t# A utility function to print \n\t# the constructed distance \n\t# array \n\tdef printSolution(self, dist, parent): \n\t\tsrc = 0\n\t\tglobal p\n\t#\tprint(\"Vertex \\t\\tDistance from Source\\tPath\") \n\t\tfor i in range(1, len(dist)): \n\t\t#\tprint(\"\\n%d --> %d \\t\\t%d \\t\\t\\t\\t\\t\" % (src, i, dist[i])), \n\t\t\tp=[]\n\t\t\tself.printPath(parent,i) \n\t\t\t#print(p,'fun')\n\t\t#\tpa.append(p)\n\n\t'''Function that implements Dijkstra's single source shortest path \n\talgorithm for a graph represented using adjacency matrix \n\trepresentation'''\n\tdef dijkstra(self, graph, src): \n\n\t\trow = len(graph) \n\t\tcol = len(graph[0]) \n\n\t\t# The output array. dist[i] will hold \n\t\t# the shortest distance from src to i \n\t\t# Initialize all distances as INFINITE \n\t\tdist = [float(\"Inf\")] * row \n\n\t\t#Parent array to store \n\t\t# shortest path tree \n\t\tparent = [-1] * row \n\n\t\t# Distance of source vertex \n\t\t# from itself is always 0 \n\t\tdist[src] = 0\n\t\n\t\t# Add all vertices in queue \n\t\tqueue = [] \n\t\tfor i in range(row): \n\t\t\tqueue.append(i) \n\t\t\t\n\t\t#Find shortest path for all vertices \n\t\twhile queue: \n\n\t\t\t# Pick the minimum dist vertex \n\t\t\t# from the set of vertices \n\t\t\t# still in queue \n\t\t\tu = self.minDistance(dist,queue) \n\n\t\t\t# remove min element\t \n\t\t\tqueue.remove(u) \n\n\t\t\t# Update dist value and parent \n\t\t\t# index of the adjacent vertices of \n\t\t\t# the picked vertex. Consider only \n\t\t\t# those vertices which are still in \n\t\t\t# queue \n\t\t\tfor i in range(col): \n\t\t\t\t'''Update dist[i] only if it is in queue, there is \n\t\t\t\tan edge from u to i, and total weight of path from \n\t\t\t\tsrc to i through u is smaller than current value of \n\t\t\t\tdist[i]'''\n\t\t\t\tif graph[u][i] and i in queue: \n\t\t\t\t\tif dist[u] + graph[u][i] < dist[i]: \n\t\t\t\t\t\tdist[i] = dist[u] + graph[u][i] \n\t\t\t\t\t\tparent[i] = u \n\n\n\t\t# print the constructed distance array \n\t\tself.printSolution(dist,parent) \n\ng= Graph() \nedge=[]\nn,m=map(int,raw_input().split())\ngraph=[[0 for j in range(n)]for i in range(n)]\nfor i in range(m):\n    a,b,c=map(int,raw_input().split())\n    a,b=min(a,b),max(a,b)\n    edge.append([a-1,b-1])\n    graph[a-1][b-1]=c \n    graph[b-1][a-1]=c \n\n\t\t\n\nans={}\nfor i in range(n):\n    p=[]\n    g.dijkstra(graph,i) \n   # print(p)\n    for i in range(len(p)-1):\n        a,b=p[i],p[i+1]\n        a,b=min(a,b),max(a,b)\n        ans[(a,b)]=1 \n#print(ans)\n#print(pa)\n# This code is contributed by Neelam Yadav \ncnt=0 \nfor i in edge: \n    if ans.get((i[0],i[1]),-1)!=-1:\n        cnt+=1 \nprint(m-cnt)",
        "correct": false,
        "task_id": "0429",
        "depth": 2
    },
    {
        "description": "Stick n circular stickers with a radius of 1 on a square origami paper with a side length of 10. The stickers can be stacked. Create a program that reads the coordinates of the position where the stickers are to be attached and outputs the number of stickers at the place where the stickers overlap most on the origami paper (assuming that even one sticker \"overlaps\"). ..\n\nGives the x and y coordinates with the lower left corner of the origami as the origin. Let's put the sticker with these x and y as the center of the circle. The center of the circle never goes out of the origami. Also, multiple stickers will not be attached at the same coordinates.\n\nHint\n\nIt is a figure with a sticker attached as shown in the input example. The circle represents the sticker, and the number represents the number of lines in the input example. At point (2.3, 4.6), the four stickers on the second, third, sixth, and tenth lines of the input example overlap.\n\n<image>\n\nThe distance between the centers of 6 and 9 is 2.01293, so the seals do not overlap. The distance between the centers of 1 and 12 is 1.98231, so the seals overlap.\n\nWhen two circles are in contact (when the distance between the centers is 2), they are assumed to overlap.\n\n\n\nInput\n\nGiven multiple datasets. Each dataset is given in the following format:\n\n\nn\nx1, y1\nx2, y2\n::\nxn, yn\n\n\nThe first line gives the number of stickers n (0 \u2264 100). The next n lines give the center coordinates of each seal. xi and yi represent the x and y coordinates of the center of the i-th sticker. Each value is given as a real number, including up to 6 digits after the decimal point.\n\nWhen n is 0, it is the end of the input. The number of datasets does not exceed 50.\n\nOutput\n\nFor each data set, output the number of stickers (integer) at the place where the stickers overlap most on the origami paper.\n\nExample\n\nInput\n\n15\n3.14979,8.51743\n2.39506,3.84915\n2.68432,5.39095\n5.61904,9.16332\n7.85653,4.75593\n2.84021,5.41511\n1.79500,8.59211\n7.55389,8.17604\n4.70665,4.66125\n1.63470,4.42538\n7.34959,4.61981\n5.09003,8.11122\n5.24373,1.30066\n0.13517,1.83659\n7.57313,1.58150\n0\n\n\nOutput\n\n4",
        "task_name": "p00090 Overlaps of Seals",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"Reference\nhttp://homepage1.nifty.com/gfk/circle-circle.htm\n\"\"\"\nfrom __future__ import (division, absolute_import, print_function,\n                        unicode_literals)\nfrom sys import stdin\nimport math\n\nRADIUS, RADIUS_2 = 1 + 1.0e-12, 2 + 1.0e-12\n\nnum_data = int(stdin.readline())\ndata = []\nfor _ in range(num_data):\n    data.append(tuple(float(s) for s in stdin.readline().split(',')))\n\ncross_points = []\nfor i in range(num_data):\n    x1, y1 = data[i]\n    for j in range(num_data):\n        if i == j:\n            continue\n        x2, y2 = data[j]\n\n        distance = math.hypot(x2-x1, y2-y1)\n        if distance <= RADIUS_2:\n            if x1 == x2 and y1 == y2:\n                cp1 = cp2 = (x1, y1)\n            else:\n                th = math.atan2(y2-y1, x2-x1)\n                al = math.acos(distance**2 / (2.0*distance))\n                cp1 = (x1 + math.cos(th + al), y1 + math.sin(th + al))\n                cp2 = (x1 + math.cos(th - al), y1 + math.sin(th - al))\n\n            if 0.0 <= cp1[0] <= 10.0 and 0.0 <= cp1[1] <= 10.0:\n                cross_points.append(cp1)\n            if 0.0 <= cp2[0] <= 10.0 and 0.0 <= cp2[1] <= 10.0:\n                cross_points.append(cp2)\n\nmax_overlap = 0\nfor cx, cy in cross_points:\n    count = 0\n    for x, y in data:\n        if math.hypot(cx-x, cy-y) <= RADIUS:\n            count += 1\n    if max_overlap < count:\n        max_overlap = count\nprint(max_overlap)",
        "correct": false,
        "task_id": "0430",
        "depth": 2
    },
    {
        "description": "For a given sequence A = {a0, a1, ... , an-1}, find the length of the longest increasing subsequnece (LIS) in A.\n\nAn increasing subsequence of A is defined by a subsequence {ai0, ai1, ... , aik} where 0 \u2264 i0 < i1 < ... < ik < n and ai0 < ai1 < ... < aik.\n\nConstraints\n\n* 1 \u2264 n \u2264 100000\n* 0 \u2264 ai \u2264 109\n\nInput\n\n\nn\na0\na1\n:\nan-1\n\n\n\nIn the first line, an integer n is given. In the next n lines, elements of A are given.\n\nOutput\n\nThe length of the longest increasing subsequence of A.\n\nExamples\n\nInput\n\n5\n5\n1\n3\n2\n4\n\n\nOutput\n\n3\n\n\nInput\n\n3\n1\n1\n1\n\n\nOutput\n\n1",
        "task_name": "p02317 Longest Increasing Subsequence",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import bisect\nn=input()\na=[input() for i in xrange(n)]\ndp=[float('inf') for _ in xrange(n)]\nfor i in xrange(n):\n    dp[bisect.bisect_left(dp,a[i])]=a[i]\nfor i in xrange(n):\n    if dp[i]==float('inf'):\n        print(i)\n        break",
        "correct": false,
        "task_id": "0433",
        "depth": 1
    },
    {
        "description": "Vasya has a pile, that consists of some number of stones. n times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.\n\nYou are given n operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.\n\nInput\n\nThe first line contains one positive integer n \u2014 the number of operations, that have been made by Vasya (1 \u2264 n \u2264 100).\n\nThe next line contains the string s, consisting of n symbols, equal to \"-\" (without quotes) or \"+\" (without quotes). If Vasya took the stone on i-th operation, s_i is equal to \"-\" (without quotes), if added, s_i is equal to \"+\" (without quotes).\n\nOutput\n\nPrint one integer \u2014 the minimal possible number of stones that can be in the pile after these n operations.\n\nExamples\n\nInput\n\n\n3\n---\n\n\nOutput\n\n\n0\n\nInput\n\n\n4\n++++\n\n\nOutput\n\n\n4\n\nInput\n\n\n2\n-+\n\n\nOutput\n\n\n1\n\nInput\n\n\n5\n++-++\n\n\nOutput\n\n\n3\n\nNote\n\nIn the first test, if Vasya had 3 stones in the pile at the beginning, after making operations the number of stones will be equal to 0. It is impossible to have less number of piles, so the answer is 0. Please notice, that the number of stones at the beginning can't be less, than 3, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).\n\nIn the second test, if Vasya had 0 stones in the pile at the beginning, after making operations the number of stones will be equal to 4. It is impossible to have less number of piles because after making 4 operations the number of stones in the pile increases on 4 stones. So, the answer is 4.\n\nIn the third test, if Vasya had 1 stone in the pile at the beginning, after making operations the number of stones will be equal to 1. It can be proved, that it is impossible to have less number of stones after making the operations.\n\nIn the fourth test, if Vasya had 0 stones in the pile at the beginning, after making operations the number of stones will be equal to 3.",
        "task_name": "1159_A. A pile of stones",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\"\"\"<https://github.com/cheran-senthil/PyRival>\"\"\"\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    _str = str\n    str = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\n\n\ndef main():\n    n = int(input())\n    s = input()\n    cnt = 0\n    for i in range(n):\n        cnt += 1 if s[i] == '+' else -1\n        if cnt < 0:\n            cnt = 0\n    print(cnt)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._buffer = BytesIO()\n        self._fd = file.fileno()\n        self._writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self._buffer.write if self._writable else None\n\n    def read(self):\n        if self._buffer.tell():\n            return self._buffer.read()\n        return os.read(self._fd, os.fstat(self._fd).st_size)\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n    def flush(self):\n        if self._writable:\n            os.write(self._fd, self._buffer.getvalue())\n            self._buffer.truncate(0), self._buffer.seek(0)\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", b\" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", b\"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(b\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "0437",
        "depth": 1
    },
    {
        "description": "One day, as Sherlock Holmes was tracking down one very important criminal, he found a wonderful painting on the wall. This wall could be represented as a plane. The painting had several concentric circles that divided the wall into several parts. Some parts were painted red and all the other were painted blue. Besides, any two neighboring parts were painted different colors, that is, the red and the blue color were alternating, i. e. followed one after the other. The outer area of the wall (the area that lied outside all circles) was painted blue. Help Sherlock Holmes determine the total area of red parts of the wall.\n\nLet us remind you that two circles are called concentric if their centers coincide. Several circles are called concentric if any two of them are concentric.\n\nInput\n\nThe first line contains the single integer n (1 \u2264 n \u2264 100). The second line contains n space-separated integers ri (1 \u2264 ri \u2264 1000) \u2014 the circles' radii. It is guaranteed that all circles are different.\n\nOutput\n\nPrint the single real number \u2014 total area of the part of the wall that is painted red. The answer is accepted if absolute or relative error doesn't exceed 10 - 4.\n\nExamples\n\nInput\n\n1\n1\n\n\nOutput\n\n3.1415926536\n\n\nInput\n\n3\n1 4 2\n\n\nOutput\n\n40.8407044967\n\nNote\n\nIn the first sample the picture is just one circle of radius 1. Inner part of the circle is painted red. The area of the red part equals \u03c0 \u00d7 12 = \u03c0.\n\nIn the second sample there are three circles of radii 1, 4 and 2. Outside part of the second circle is painted blue. Part between the second and the third circles is painted red. Part between the first and the third is painted blue. And, finally, the inner part of the first circle is painted red. Overall there are two red parts: the ring between the second and the third circles and the inner part of the first circle. Total area of the red parts is equal (\u03c0 \u00d7 42 - \u03c0 \u00d7 22) + \u03c0 \u00d7 12 = \u03c0 \u00d7 12 + \u03c0 = 13\u03c0",
        "task_name": "157_B. Trace",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport math\n\nnCircles = int(sys.stdin.readline())\n\nif nCircles < 1:\n    sys.stdout.write('0\\n')\n    sys.exit()\n\nareas = []\ninput = sys.stdin.readline()\nfor radius in input.split(' '):\n    areas.append(int(radius)*int(radius))\n\nareas.sort()\n\ntotalArea = 0\nfor index, area in enumerate(areas):\n    if index == 0:\n        totalArea += area\n    elif index % 2 == 0:\n        totalArea += (areas[index] - areas[index-1])\n\ntotalArea *= math.pi\nsys.stdout.write(str(totalArea)+'\\n')\n",
        "correct": false,
        "task_id": "0449",
        "depth": 1
    },
    {
        "description": "You are given a huge integer a consisting of n digits (n is between 1 and 3 \u22c5 10^5, inclusive). It may contain leading zeros.\n\nYou can swap two digits on adjacent (neighboring) positions if the swapping digits are of different parity (that is, they have different remainders when divided by 2). \n\nFor example, if a = 032867235 you can get the following integers in a single operation: \n\n  * 302867235 if you swap the first and the second digits; \n  * 023867235 if you swap the second and the third digits; \n  * 032876235 if you swap the fifth and the sixth digits; \n  * 032862735 if you swap the sixth and the seventh digits; \n  * 032867325 if you swap the seventh and the eighth digits. \n\n\n\nNote, that you can't swap digits on positions 2 and 4 because the positions are not adjacent. Also, you can't swap digits on positions 3 and 4 because the digits have the same parity.\n\nYou can perform any number (possibly, zero) of such operations.\n\nFind the minimum integer you can obtain.\n\nNote that the resulting integer also may contain leading zeros.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases in the input.\n\nThe only line of each test case contains the integer a, its length n is between 1 and 3 \u22c5 10^5, inclusive.\n\nIt is guaranteed that the sum of all values n does not exceed 3 \u22c5 10^5.\n\nOutput\n\nFor each test case print line \u2014 the minimum integer you can obtain.\n\nExample\n\nInput\n\n\n3\n0709\n1337\n246432\n\n\nOutput\n\n\n0079\n1337\n234642\n\nNote\n\nIn the first test case, you can perform the following sequence of operations (the pair of swapped digits is highlighted): 0 \\underline{70} 9 \u2192 0079.\n\nIn the second test case, the initial integer is optimal. \n\nIn the third test case you can perform the following sequence of operations: 246 \\underline{43} 2 \u2192 24 \\underline{63}42 \u2192 2 \\underline{43} 642 \u2192 234642.",
        "task_name": "1251_C. Minimize The Integer",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# <editor-fold desc=\"Fast IO\">\n# !/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport itertools\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\nBUFFER_SIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFFER_SIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFFER_SIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop('end', '\\n'))\n    if kwargs.pop('flush', False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# </editor-fold>\n\nimport collections\n\n\ndef solve(num):\n    num = [ord(x) - ord('0') for x in num]\n\n    even_digits, odd_digits = collections.deque(), collections.deque()\n\n    for digit in num:\n        if digit & 1 == 0:\n            even_digits.append(digit)\n        else:\n            odd_digits.append(digit)\n\n    ret = []\n\n    for _ in range(len(num)):\n        if not odd_digits or (even_digits and even_digits[0] < odd_digits[0]):\n            ret.append(even_digits.popleft())\n        else:\n            ret.append(odd_digits.popleft())\n\n    return ''.join(map(str, ret))\n\n\n# xx\n\n\nDEBUG = False\n\nif not DEBUG:\n    t = int(input())\n\n    while t > 0:\n        t -= 1\n        s = input()\n        print(solve(s))\n\nelse:\n    print(solve('246432'))\n    print(solve('2464321'))\n    print(solve('264721'))\n    #\n    print(solve('999999992222222'))\n    print(solve('7772648'))\n    print(solve('737572464282'))\n\n    print(solve('12'))\n    print(solve('21'))\n    print(solve('221'))\n    print(solve('221'))\n",
        "correct": true,
        "task_id": "0478",
        "depth": 1
    },
    {
        "description": "You are given two integers n and k. You are asked to choose maximum number of distinct integers from 1 to n so that there is no subset of chosen numbers with sum equal to k.\n\nA subset of a set is a set that can be obtained from initial one by removing some (possibly all or none) elements of it.\n\nInput\n\nThe first line contains the number of test cases T (1 \u2264 T \u2264 100).\n\nEach of the next T lines contains two integers n and k (1 \u2264 k \u2264 n \u2264 1000) \u2014 the description of test cases.\n\nOutput\n\nFor each test case output two lines. In the first line output a single integer m \u2014 the number of chosen integers.\n\nIn the second line output m distinct integers from 1 to n \u2014 the chosen numbers.\n\nIf there are multiple answers, print any. You can print the numbers in any order.\n\nExample\n\nInput\n\n\n3\n3 2\n5 3\n1 1\n\n\nOutput\n\n\n2\n3 1 \n3\n4 5 2 \n0",
        "task_name": "1493_A. Anti-knapsack",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nfor _ in range(int(input())):\n    n, k = map(int, stdin.readline().split())\n    ans = [x for x in range(1, k // 2 + 1)] + [x for x in range(k + 1, n + 1)]\n    print('%d\\n%s' % (len(ans), ' '.join(map(str, ans))))\n",
        "correct": false,
        "task_id": "0484",
        "depth": 1
    },
    {
        "description": "Wilbur is playing with a set of n points on the coordinate plane. All points have non-negative integer coordinates. Moreover, if some point (x, y) belongs to the set, then all points (x', y'), such that 0 \u2264 x' \u2264 x and 0 \u2264 y' \u2264 y also belong to this set.\n\nNow Wilbur wants to number the points in the set he has, that is assign them distinct integer numbers from 1 to n. In order to make the numbering aesthetically pleasing, Wilbur imposes the condition that if some point (x, y) gets number i, then all (x',y') from the set, such that x' \u2265 x and y' \u2265 y must be assigned a number not less than i. For example, for a set of four points (0, 0), (0, 1), (1, 0) and (1, 1), there are two aesthetically pleasing numberings. One is 1, 2, 3, 4 and another one is 1, 3, 2, 4.\n\nWilbur's friend comes along and challenges Wilbur. For any point he defines it's special value as s(x, y) = y - x. Now he gives Wilbur some w1, w2,..., wn, and asks him to find an aesthetically pleasing numbering of the points in the set, such that the point that gets number i has it's special value equal to wi, that is s(xi, yi) = yi - xi = wi.\n\nNow Wilbur asks you to help him with this challenge.\n\nInput\n\nThe first line of the input consists of a single integer n (1 \u2264 n \u2264 100 000) \u2014 the number of points in the set Wilbur is playing with.\n\nNext follow n lines with points descriptions. Each line contains two integers x and y (0 \u2264 x, y \u2264 100 000), that give one point in Wilbur's set. It's guaranteed that all points are distinct. Also, it is guaranteed that if some point (x, y) is present in the input, then all points (x', y'), such that 0 \u2264 x' \u2264 x and 0 \u2264 y' \u2264 y, are also present in the input.\n\nThe last line of the input contains n integers. The i-th of them is wi ( - 100 000 \u2264 wi \u2264 100 000) \u2014 the required special value of the point that gets number i in any aesthetically pleasing numbering.\n\nOutput\n\nIf there exists an aesthetically pleasant numbering of points in the set, such that s(xi, yi) = yi - xi = wi, then print \"YES\" on the first line of the output. Otherwise, print \"NO\".\n\nIf a solution exists, proceed output with n lines. On the i-th of these lines print the point of the set that gets number i. If there are multiple solutions, print any of them.\n\nExamples\n\nInput\n\n5\n2 0\n0 0\n1 0\n1 1\n0 1\n0 -1 -2 1 0\n\n\nOutput\n\nYES\n0 0\n1 0\n2 0\n0 1\n1 1\n\n\nInput\n\n3\n1 0\n0 0\n2 0\n0 1 2\n\n\nOutput\n\nNO\n\nNote\n\nIn the first sample, point (2, 0) gets number 3, point (0, 0) gets number one, point (1, 0) gets number 2, point (1, 1) gets number 5 and point (0, 1) gets number 4. One can easily check that this numbering is aesthetically pleasing and yi - xi = wi.\n\nIn the second sample, the special values of the points in the set are 0,  - 1, and  - 2 while the sequence that the friend gives to Wilbur is 0, 1, 2. Therefore, the answer does not exist.",
        "task_name": "596_C. Wilbur and Points",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\nfrom collections import *\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\n\n\ndef solve():\n    mem, mem2, out = Counter(w), defaultdict(list), []\n    for x, y in a:\n        mem2[y - x].append([x, y])\n\n    for i, j in mem.items():\n        if len(mem2[i]) != j:\n            print('NO')\n            exit()\n        mem2[i].sort(reverse=True)\n\n    for i in range(n):\n        x, y = mem2[w[i]][-1]\n        labels[x][y] = i + 1\n\n        if i and labels[x + 1][y] < labels[x][y] or labels[x][y + 1] < labels[x][y]:\n            print('NO')\n            exit()\n        out.append(' '.join(map(str, mem2[w[i]].pop())))\n\n    print('YES')\n    print('\\n'.join(out))\n\n\nn, labels = int(input()), [[0 for _ in range(1000)] for _ in range(1000)]\na, w = [rints() for _ in range(n)], rints()\nsolve()\n",
        "correct": false,
        "task_id": "0498",
        "depth": 1
    },
    {
        "description": "Two participants are each given a pair of distinct numbers from 1 to 9 such that there's exactly one number that is present in both pairs. They want to figure out the number that matches by using a communication channel you have access to without revealing it to you.\n\nBoth participants communicated to each other a set of pairs of numbers, that includes the pair given to them. Each pair in the communicated sets comprises two different numbers.\n\nDetermine if you can with certainty deduce the common number, or if you can determine with certainty that both participants know the number but you do not.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 12) \u2014 the number of pairs the first participant communicated to the second and vice versa.\n\nThe second line contains n pairs of integers, each between 1 and 9, \u2014 pairs of numbers communicated from first participant to the second.\n\nThe third line contains m pairs of integers, each between 1 and 9, \u2014 pairs of numbers communicated from the second participant to the first.\n\nAll pairs within each set are distinct (in particular, if there is a pair (1,2), there will be no pair (2,1) within the same set), and no pair contains the same number twice.\n\nIt is guaranteed that the two sets do not contradict the statements, in other words, there is pair from the first set and a pair from the second set that share exactly one number.\n\nOutput\n\nIf you can deduce the shared number with certainty, print that number.\n\nIf you can with certainty deduce that both participants know the shared number, but you do not know it, print 0.\n\nOtherwise print -1.\n\nExamples\n\nInput\n\n2 2\n1 2 3 4\n1 5 3 4\n\n\nOutput\n\n1\n\n\nInput\n\n2 2\n1 2 3 4\n1 5 6 4\n\n\nOutput\n\n0\n\n\nInput\n\n2 3\n1 2 4 5\n1 2 1 3 2 3\n\n\nOutput\n\n-1\n\nNote\n\nIn the first example the first participant communicated pairs (1,2) and (3,4), and the second communicated (1,5), (3,4). Since we know that the actual pairs they received share exactly one number, it can't be that they both have (3,4). Thus, the first participant has (1,2) and the second has (1,5), and at this point you already know the shared number is 1.\n\nIn the second example either the first participant has (1,2) and the second has (1,5), or the first has (3,4) and the second has (6,4). In the first case both of them know the shared number is 1, in the second case both of them know the shared number is 4. You don't have enough information to tell 1 and 4 apart.\n\nIn the third case if the first participant was given (1,2), they don't know what the shared number is, since from their perspective the second participant might have been given either (1,3), in which case the shared number is 1, or (2,3), in which case the shared number is 2. While the second participant does know the number with certainty, neither you nor the first participant do, so the output is -1.",
        "task_name": "993_B. Open Communication",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, m = map(int, raw_input().split())\np1 = list(map(int,raw_input().split()))\np2 = list(map(int,raw_input().split()))\ncand = set()\ncc = [set() for i in range(n)]\ndd = [set() for i in range(m)]\nfor i in range(n):\n    for j in range(m):\n        a, b = p1[2 * i], p1[2 * i + 1]\n        c, d = p2[2 * j], p2[2 * j + 1]\n        if a not in (c, d) and b not in (c, d):\n            continue\n        if a in (c, d) and b in (c, d):\n            continue\n        if a in (c, d):\n            kandidat = a\n        else:\n            kandidat = b\n        cand.add(kandidat)\n        cc[i].add(kandidat)\n        dd[j].add(kandidat)\nif len(cand) == 1:\n    print(cand.pop())\nelif max(len(cc[i]) for i in range(n)) <= 1 and\\\n        max(len(dd[i]) for i in range(m)) <= 1:\n    print(0)\nelse:\n    print(-1)",
        "correct": true,
        "task_id": "0508",
        "depth": 2
    },
    {
        "description": "There is a set A = \\\\{ a_1, a_2, \\ldots, a_N \\\\} consisting of N positive integers. Taro and Jiro will play the following game against each other.\n\nInitially, we have a pile consisting of K stones. The two players perform the following operation alternately, starting from Taro:\n\n* Choose an element x in A, and remove exactly x stones from the pile.\n\n\n\nA player loses when he becomes unable to play. Assuming that both players play optimally, determine the winner.\n\nConstraints\n\n* All values in input are integers.\n* 1 \\leq N \\leq 100\n* 1 \\leq K \\leq 10^5\n* 1 \\leq a_1 < a_2 < \\cdots < a_N \\leq K\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN K\na_1 a_2 \\ldots a_N\n\n\nOutput\n\nIf Taro will win, print `First`; if Jiro will win, print `Second`.\n\nExamples\n\nInput\n\n2 4\n2 3\n\n\nOutput\n\nFirst\n\n\nInput\n\n2 5\n2 3\n\n\nOutput\n\nSecond\n\n\nInput\n\n2 7\n2 3\n\n\nOutput\n\nFirst\n\n\nInput\n\n3 20\n1 2 3\n\n\nOutput\n\nSecond\n\n\nInput\n\n3 21\n1 2 3\n\n\nOutput\n\nFirst\n\n\nInput\n\n1 100000\n1\n\n\nOutput\n\nSecond",
        "task_name": "p03170 Educational DP Contest - Stones",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import os\nfrom io import BytesIO\n\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nn, k = map(int, input().split())\na = [int(i) for i in input().split()]\n\ndp = [False] * (k + 1)\n\nfor ai in a:\n    dp[ai] = True\n\nfor i in xrange(max(a) + 1, k + 1):\n    dp[i] = any(not dp[i - ai] for ai in a)\n\nos.write(1, 'First' if dp[k] else 'Second')",
        "correct": false,
        "task_id": "0512",
        "depth": 1
    },
    {
        "description": "While playing with geometric figures Alex has accidentally invented a concept of a n-th order rhombus in a cell grid.\n\nA 1-st order rhombus is just a square 1 \u00d7 1 (i.e just a cell).\n\nA n-th order rhombus for all n \u2265 2 one obtains from a n-1-th order rhombus adding all cells which have a common side with it to it (look at the picture to understand it better).\n\n<image>\n\nAlex asks you to compute the number of cells in a n-th order rhombus.\n\nInput\n\nThe first and only input line contains integer n (1 \u2264 n \u2264 100) \u2014 order of a rhombus whose numbers of cells should be computed.\n\nOutput\n\nPrint exactly one integer \u2014 the number of cells in a n-th order rhombus.\n\nExamples\n\nInput\n\n\n1\n\n\nOutput\n\n\n1\n\nInput\n\n\n2\n\n\nOutput\n\n\n5\n\nInput\n\n\n3\n\n\nOutput\n\n\n13\n\nNote\n\nImages of rhombus corresponding to the examples are given in the statement.",
        "task_name": "1180_A. Alex and a Rhombus",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"                         \nBeautiful is better than ugly.\n    Explicit is better than implicit.\nSimple is better than complex.\n    Complex is better than complicated.\nFlat is better than nested.\n    Sparse is better than dense.\n                    \n    * Readability counts *\n\n // Author : raj1307 - Raj Singh\n // Date   : 21.06.19\n\n\"\"\"\n\nfrom __future__ import division, print_function\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    _str = str\n    str = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial,pow,pi\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod,MOD=1000000007,998244353\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p1\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n# For getting input from input.txt file \n#sys.stdin = open('input.txt', 'r')  \n  \n# Printing the Output to output.txt file \n#sys.stdout = open('output.txt', 'w') \n\ndef main():\n    \n    \n    #for _ in range(ii()):\n    \n    n=ii()\n    \n    if n==1: \n        print(1)\n    else:\n        \n        r=1\n        ans=1\n        for i in range(2,n+1):\n            \n            m=(r*r)%ans\n            r+=2\n            ans+=4+m\n            \n        print(ans)    \n        \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        if self.buffer.tell():\n            return self.buffer.read()\n        return os.read(self._fd, os.fstat(self._fd).st_size)\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", b\" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", b\"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(b\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n    #dmain()",
        "correct": false,
        "task_id": "0524",
        "depth": 1
    },
    {
        "description": "Petya loves computer games. Finally a game that he's been waiting for so long came out!\n\nThe main character of this game has n different skills, each of which is characterized by an integer ai from 0 to 100. The higher the number ai is, the higher is the i-th skill of the character. The total rating of the character is calculated as the sum of the values \u200b\u200bof <image> for all i from 1 to n. The expression \u230a x\u230b denotes the result of rounding the number x down to the nearest integer.\n\nAt the beginning of the game Petya got k improvement units as a bonus that he can use to increase the skills of his character and his total rating. One improvement unit can increase any skill of Petya's character by exactly one. For example, if a4 = 46, after using one imporvement unit to this skill, it becomes equal to 47. A hero's skill cannot rise higher more than 100. Thus, it is permissible that some of the units will remain unused.\n\nYour task is to determine the optimal way of using the improvement units so as to maximize the overall rating of the character. It is not necessary to use all the improvement units.\n\nInput\n\nThe first line of the input contains two positive integers n and k (1 \u2264 n \u2264 105, 0 \u2264 k \u2264 107) \u2014 the number of skills of the character and the number of units of improvements at Petya's disposal.\n\nThe second line of the input contains a sequence of n integers ai (0 \u2264 ai \u2264 100), where ai characterizes the level of the i-th skill of the character.\n\nOutput\n\nThe first line of the output should contain a single non-negative integer \u2014 the maximum total rating of the character that Petya can get using k or less improvement units.\n\nExamples\n\nInput\n\n2 4\n7 9\n\n\nOutput\n\n2\n\n\nInput\n\n3 8\n17 15 19\n\n\nOutput\n\n5\n\n\nInput\n\n2 2\n99 100\n\n\nOutput\n\n20\n\nNote\n\nIn the first test case the optimal strategy is as follows. Petya has to improve the first skill to 10 by spending 3 improvement units, and the second skill to 10, by spending one improvement unit. Thus, Petya spends all his improvement units and the total rating of the character becomes equal to  lfloor frac{100}{10} rfloor + lfloor frac{100}{10} rfloor = 10 + 10 =  20.\n\nIn the second test the optimal strategy for Petya is to improve the first skill to 20 (by spending 3 improvement units) and to improve the third skill to 20 (in this case by spending 1 improvement units). Thus, Petya is left with 4 improvement units and he will be able to increase the second skill to 19 (which does not change the overall rating, so Petya does not necessarily have to do it). Therefore, the highest possible total rating in this example is <image>.\n\nIn the third test case the optimal strategy for Petya is to increase the first skill to 100 by spending 1 improvement unit. Thereafter, both skills of the character will be equal to 100, so Petya will not be able to spend the remaining improvement unit. So the answer is equal to <image>. ",
        "task_name": "581_C. Developing Skills",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n#\n# http://codeforces.com/problemset/problem/581/C\n\ntry:\n    n, k = raw_input().split()\n    n, k = int(n), int(k)\n    nums = raw_input().split()\n    nums = [int(num) for num in nums]\n\n    nums.sort(cmp = lambda a, b: b%10 - a%10)\n\n    stop = False\n    while not stop:\n        stop = True\n        for i in range(0, n):\n            if k == 0: break\n            if nums[i] == 100: continue\n            delta = 10 - nums[i] % 10\n            if k < delta: break\n            stop = False\n            nums[i] = nums[i] + delta\n            k = k - delta\n\n    print(sum([num / 10 for num in nums]))\nexcept IOError:\n    pass        \n",
        "correct": true,
        "task_id": "0547",
        "depth": 2
    },
    {
        "description": "Takahashi has a maze, which is a grid of H \\times W squares with H horizontal rows and W vertical columns.\n\nThe square at the i-th row from the top and the j-th column is a \"wall\" square if S_{ij} is `#`, and a \"road\" square if S_{ij} is `.`.\n\nFrom a road square, you can move to a horizontally or vertically adjacent road square.\n\nYou cannot move out of the maze, move to a wall square, or move diagonally.\n\nTakahashi will choose a starting square and a goal square, which can be any road squares, and give the maze to Aoki.\n\nAoki will then travel from the starting square to the goal square, in the minimum number of moves required.\n\nIn this situation, find the maximum possible number of moves Aoki has to make.\n\nConstraints\n\n* 1 \\leq H,W \\leq 20\n* S_{ij} is `.` or `#`.\n* S contains at least two occurrences of `.`.\n* Any road square can be reached from any road square in zero or more moves.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nH W\nS_{11}...S_{1W}\n:\nS_{H1}...S_{HW}\n\n\nOutput\n\nPrint the maximum possible number of moves Aoki has to make.\n\nExamples\n\nInput\n\n3 3\n...\n...\n...\n\n\nOutput\n\n4\n\n\nInput\n\n3 5\n...#.\n.#.#.\n.#...\n\n\nOutput\n\n10",
        "task_name": "p02803 AtCoder Beginner Contest 151 - Maze Master",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "input = raw_input\n\nh, w = map(int, input().split(\" \"))\n\nmeiro = []\ncoords = []\nfor i in range(h):\n    line = list(input())\n    cur_coords = [(j, i) for j in range(w) if line[j] == \".\"]\n    coords += cur_coords\n    meiro.append(line)\n\ngraphs = []\ngraph = {}\nfor cur_coord in coords:\n    x, y = cur_coord\n    tugi_kouhos = [(x+dx, y) for dx in [-1, 1] if 0 <= x+dx < w]\n    tugi_kouhos += [(x, y+dy) for dy in [-1, 1] if 0 <= y+dy < h]\n    childs = []\n    for tugi_kouho in tugi_kouhos:\n        if tugi_kouho in coords:\n            childs.append(tugi_kouho)\n    graph[cur_coord] = childs\n\n\ndepth_dict_org = {}\nfor coord in coords:\n    depth_dict_org[coord] = None\n\ndef calc_depth(coord1, coord2):\n    depth_dict = depth_dict_org.copy()\n\n    cur_coord = coord1\n    end_coord = coord2\n    cur_depth = 0\n    used_coords = [coord1]\n\n    childs = graph[coord1]\n    while len(childs) != 0:\n        cur_depth += 1\n        next_childs = []\n        used_coords += childs\n        for child in childs:\n            res = get_childs(child, coord2, used_coords)\n            #print(\"child\", child, res)\n            #print(used_coords)\n            if res == \"found\":\n                return cur_depth + 1\n            next_childs += res\n\n        childs = list(set(next_childs))\n        #print(childs)\n\n    return 0\n\ndef get_childs(jibun, target, used_coords):\n    \n    childs = []\n    for child in graph[jibun]:\n        if child == target:\n            return \"found\"\n        if child not in used_coords:\n            childs.append(child)\n    return childs\n       \n\nn_coords = len(coords)\nmax_depth = 0\nfor i in range(n_coords):\n    coord1 = coords[i]\n    for j in range(i+1, n_coords):\n        coord2 = coords[j]\n        cur_depth = calc_depth(coord1, coord2)\n        #print(coord1, coord2, cur_depth)\n        max_depth = max(max_depth, cur_depth)\n\nprint(max_depth)",
        "correct": false,
        "task_id": "0559",
        "depth": 2
    },
    {
        "description": "There is a white sheet of paper lying on a rectangle table. The sheet is a rectangle with its sides parallel to the sides of the table. If you will take a look from above and assume that the bottom left corner of the table has coordinates (0, 0), and coordinate axes are left and bottom sides of the table, then the bottom left corner of the white sheet has coordinates (x_1, y_1), and the top right \u2014 (x_2, y_2).\n\nAfter that two black sheets of paper are placed on the table. Sides of both black sheets are also parallel to the sides of the table. Coordinates of the bottom left corner of the first black sheet are (x_3, y_3), and the top right \u2014 (x_4, y_4). Coordinates of the bottom left corner of the second black sheet are (x_5, y_5), and the top right \u2014 (x_6, y_6). \n\n<image> Example of three rectangles.\n\nDetermine if some part of the white sheet can be seen from the above after the two black sheets are placed. The part of the white sheet can be seen if there is at least one point lying not strictly inside the white sheet and strictly outside of both black sheets.\n\nInput\n\nThe first line of the input contains four integers x_1, y_1, x_2, y_2 (0 \u2264 x_1 < x_2 \u2264 10^{6}, 0 \u2264 y_1 < y_2 \u2264 10^{6}) \u2014 coordinates of the bottom left and the top right corners of the white sheet.\n\nThe second line of the input contains four integers x_3, y_3, x_4, y_4 (0 \u2264 x_3 < x_4 \u2264 10^{6}, 0 \u2264 y_3 < y_4 \u2264 10^{6}) \u2014 coordinates of the bottom left and the top right corners of the first black sheet.\n\nThe third line of the input contains four integers x_5, y_5, x_6, y_6 (0 \u2264 x_5 < x_6 \u2264 10^{6}, 0 \u2264 y_5 < y_6 \u2264 10^{6}) \u2014 coordinates of the bottom left and the top right corners of the second black sheet.\n\nThe sides of each sheet of paper are parallel (perpendicular) to the coordinate axes.\n\nOutput\n\nIf some part of the white sheet can be seen from the above after the two black sheets are placed, print \"YES\" (without quotes). Otherwise print \"NO\".\n\nExamples\n\nInput\n\n\n2 2 4 4\n1 1 3 5\n3 1 5 5\n\n\nOutput\n\n\nNO\n\n\nInput\n\n\n3 3 7 5\n0 0 4 6\n0 0 7 4\n\n\nOutput\n\n\nYES\n\n\nInput\n\n\n5 2 10 5\n3 1 7 6\n8 1 11 7\n\n\nOutput\n\n\nYES\n\n\nInput\n\n\n0 0 1000000 1000000\n0 0 499999 1000000\n500000 0 1000000 1000000\n\n\nOutput\n\n\nYES\n\nNote\n\nIn the first example the white sheet is fully covered by black sheets.\n\nIn the second example the part of the white sheet can be seen after two black sheets are placed. For example, the point (6.5, 4.5) lies not strictly inside the white sheet and lies strictly outside of both black sheets.",
        "task_name": "1216_C. White Sheet",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n\n# target Expert  \n\n# Author : raj1307 - Raj Singh\n# Date   : 21.09.19\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\ndef yes():\n    print('YES')\n\ndef no():\n    print('NO')\n\n\ndef main():\n\n    \n\n\n    #for _ in range(ii()):\n\n\n\n    x1,y1,x2,y2=mi()\n    x3,y3,x4,y4=mi()\n    x5,y5,x6,y6=mi()\n\n    one=two=True\n    \n    if x5>x2 or y6<y1 or x6<x1 or y5>y2:\n        one=False\n\n    if y3>y2 or y4<y1 or x3>x2 or x4<x1:\n        two=False\n\n\n    if  (not one) and (not two):\n        yes()\n        exit()\n\n    if True:\n\n        y4=min(y4,y2)\n        y3=max(y3,y1)\n\n        y6=min(y6,y2)\n        y5=max(y5,y1)\n\n        x4=min(x4,x2)\n        x3=max(x3,x1)\n\n        x6=min(x6,x2)\n        x5=max(x5,x1)\n\n\n        if two and one:\n\n            area=abs(x1-x2)*abs(y1-y2)\n\n            a1=abs(x3-x4)*abs(y3-y4)\n\n            a2=abs(x5-x6)*abs(y5-y6)\n\n            if a1+a2<area:\n                yes()\n            else:\n                no()\n\n        elif one==True:\n\n            a2=abs(x5-x6)*abs(y5-y6)\n\n            if a2<area:\n                yes()\n            else:\n                no()\n\n\n        elif two:\n\n            a1=abs(x3-x4)*abs(y3-y4)\n\n            if a1<area:\n                yes()\n            else:\n                no()\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": false,
        "task_id": "0573",
        "depth": 1
    },
    {
        "description": "Zookeeper is playing a game. In this game, Zookeeper must use bombs to bomb a string that consists of letters 'A' and 'B'. He can use bombs to bomb a substring which is either \"AB\" or \"BB\". When he bombs such a substring, the substring gets deleted from the string and the remaining parts of the string get concatenated.\n\nFor example, Zookeeper can use two such operations: AABABBA \u2192 AABBA \u2192 AAA.\n\nZookeeper wonders what the shortest string he can make is. Can you help him find the length of the shortest string?\n\nInput\n\nEach test contains multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 20000) \u2014 the number of test cases. The description of the test cases follows.\n\nEach of the next t lines contains a single test case each, consisting of a non-empty string s: the string that Zookeeper needs to bomb. It is guaranteed that all symbols of s are either 'A' or 'B'.\n\nIt is guaranteed that the sum of |s| (length of s) among all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print a single integer: the length of the shortest string that Zookeeper can make.\n\nExample\n\nInput\n\n\n3\nAAA\nBABA\nAABBBABBBB\n\n\nOutput\n\n\n3\n2\n0\n\nNote\n\nFor the first test case, you can't make any moves, so the answer is 3.\n\nFor the second test case, one optimal sequence of moves is BABA \u2192 BA. So, the answer is 2.\n\nFor the third test case, one optimal sequence of moves is AABBBABBBB \u2192 AABBBABB \u2192 AABBBB \u2192 ABBB \u2192 AB \u2192 (empty string). So, the answer is 0.",
        "task_name": "1428_C. ABBB",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\nimport math\nimport os, sys\nfrom sys import maxint\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii():  return int(input())\n\n\ndef si():  return input()\n\n\ndef mi():  return map(int, input().strip().split(\" \"))\n\n\ndef msi(): return map(str, input().strip().split(\" \"))\n\n\ndef li():  return list(mi())\n\n\ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n\n# from collections import deque, Counter, OrderedDict,defaultdict\n# from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n# from math import log,sqrt,factorial,cos,tan,sin,radians\n# from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n# from decimal import *\n# import threading\nfrom itertools import permutations\n\n# Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc = 'abcdefghijklmnopqrstuvwxyz'\nabd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12,\n       'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24,\n       'z': 25}\nmod = 1000000007\n# mod=998244353\ninf = float(\"inf\")\nvow = ['a', 'e', 'i', 'o', 'u']\ndx, dy = [-1, 1, 0, 0], [0, 0, 1, -1]\n\n\ndef getKey(item): return item[1]\n\n\ndef sort2(l): return sorted(l, key=getKey, reverse=True)\n\n\ndef d2(n, m, num): return [[num for x in range(m)] for y in range(n)]\n\n\ndef isPowerOfTwo(x): return (x and (not (x & (x - 1))))\n\n\ndef decimalToBinary(n): return bin(n).replace(\"0b\", \"\")\n\n\ndef ntl(n): return [int(i) for i in str(n)]\n\n\ndef ceil(x, y):\n    if x % y == 0:\n        return x // y\n    else:\n        return x // y + 1\n\n\ndef powerMod(x, y, p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n\ndef isPrime(n):  # Check Prime Number or not\n    if (n <= 1): return False\n    if (n <= 3): return True\n    if (n % 2 == 0 or n % 3 == 0): return False\n    i = 5\n    while (i * i <= n):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n        i = i + 6\n    return True\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\n\ndef main():\n    for _ in range(int(input())):\n        s = raw_input()\n\n        def solve(s):\n            if s.find(\"AB\") == -1 and s.find(\"BB\") == -1:\n                return len(s)\n\n            while s.find(\"AB\") != -1:\n                s = s.replace(\"AB\", \"\")\n\n            while s.find(\"BB\") != -1:\n                s = s.replace(\"BB\", \"\")\n\n            return len(s)\n\n        print(solve(s))\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    # read()\n    main()\n    # dmain()\n\n# Comment Read()\n",
        "correct": false,
        "task_id": "0577",
        "depth": 2
    },
    {
        "description": "Ashish has two strings a and b, each of length n, and an integer k. The strings only contain lowercase English letters.\n\nHe wants to convert string a into string b by performing some (possibly zero) operations on a.\n\nIn one move, he can either \n\n  * choose an index i (1 \u2264 i\u2264 n-1) and swap a_i and a_{i+1}, or \n  * choose an index i (1 \u2264 i \u2264 n-k+1) and if a_i, a_{i+1}, \u2026, a_{i+k-1} are all equal to some character c (c \u2260 'z'), replace each one with the next character (c+1), that is, 'a' is replaced by 'b', 'b' is replaced by 'c' and so on. \n\n\n\nNote that he can perform any number of operations, and the operations can only be performed on string a. \n\nHelp Ashish determine if it is possible to convert string a into b after performing some (possibly zero) operations on it.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^5) \u2014 the number of test cases. The description of each test case is as follows.\n\nThe first line of each test case contains two integers n (2 \u2264 n \u2264 10^6) and k (1 \u2264 k \u2264 n).\n\nThe second line of each test case contains the string a of length n consisting of lowercase English letters.\n\nThe third line of each test case contains the string b of length n consisting of lowercase English letters.\n\nIt is guaranteed that the sum of values n among all test cases does not exceed 10^6.\n\nOutput\n\nFor each test case, print \"Yes\" if Ashish can convert a into b after some moves, else print \"No\".\n\nYou may print the letters of the answer in any case (upper or lower).\n\nExample\n\nInput\n\n\n4\n3 3\nabc\nbcd\n4 2\nabba\nazza\n2 1\nzz\naa\n6 2\naaabba\nddddcc\n\n\nOutput\n\n\nNo\nYes\nNo\nYes\n\nNote\n\nIn the first test case it can be shown that it is impossible to convert a into b.\n\nIn the second test case,\n\n\"abba\" \\xrightarrow{inc} \"acca\" \\xrightarrow{inc} \u2026 \\xrightarrow{inc} \"azza\".\n\nHere \"swap\" denotes an operation of the first type, and \"inc\" denotes an operation of the second type.\n\nIn the fourth test case,\n\n\"aaabba\" \\xrightarrow{swap} \"aaabab\" \\xrightarrow{swap} \"aaaabb\" \\xrightarrow{inc} \u2026 \\xrightarrow{inc} \"ddaabb\" \\xrightarrow{inc} \u2026 \\xrightarrow{inc} \"ddddbb\" \\xrightarrow{inc} \u2026 \\xrightarrow{inc} \"ddddcc\".",
        "task_name": "1451_C. String Equality",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\nfrom collections import defaultdict, Counter, deque\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement\nfrom __builtin__ import xrange as range\nfrom math import ceil, factorial, log, sqrt\nfrom _continuation import continulet\nfrom cStringIO import StringIO\nfrom io import IOBase\nimport __pypy__\nfrom bisect import bisect, insort, bisect_left, bisect_right\nfrom fractions import Fraction\nimport heapq\nfrom functools import reduce\nimport string\nimport sys\nimport os\nimport re\ninf = float('inf')\nmod = int(1e9) + 7\nmod_ = 998244353\n\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n    t = input()\n    freq = Counter(s)\n    groups = [m.group(0) for m in re.finditer(r\"([a-z])\\1*\", t)]\n\n    for group in groups:\n        div = len(group) // k\n        rem = len(group) % k\n        if freq[group[0]] < rem:\n            print('No')\n            return\n        freq[group[0]] -= rem\n        if div == 0:\n            continue\n        for i in range(string.ascii_lowercase.index(group[0]) - 1, -1, -1):\n            if freq[string.ascii_lowercase[i]] >= div:\n                freq[string.ascii_lowercase[i]] -= div\n                break\n        else:\n            print('No')\n            return\n    print('Yes')\n\n\ndef main():\n    for _ in range(int(input())):\n        solve()\n\nBUFSIZE = 8192\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(\n                b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    def bootstrap(cont):\n        call, arg = cont.switch()\n        while True:\n            call, arg = cont.switch(to=continulet(\n                lambda _, f, args: f(*args), call, arg))\n    cont = continulet(bootstrap)\n    cont.switch()\n    main()",
        "correct": false,
        "task_id": "0578",
        "depth": 2
    },
    {
        "description": "At the school where Vasya is studying, preparations are underway for the graduation ceremony. One of the planned performances is a ball, which will be attended by pairs of boys and girls.\n\nEach class must present two couples to the ball. In Vasya's class, a boys and b girls wish to participate. But not all boys and not all girls are ready to dance in pairs.\n\nFormally, you know k possible one-boy-one-girl pairs. You need to choose two of these pairs so that no person is in more than one pair.\n\nFor example, if a=3, b=4, k=4 and the couples (1, 2), (1, 3), (2, 2), (3, 4) are ready to dance together (in each pair, the boy's number comes first, then the girl's number), then the following combinations of two pairs are possible (not all possible options are listed below): \n\n  * (1, 3) and (2, 2); \n  * (3, 4) and (1, 3); \n\n\n\nBut the following combinations are not possible: \n\n  * (1, 3) and (1, 2) \u2014 the first boy enters two pairs; \n  * (1, 2) and (2, 2) \u2014 the second girl enters two pairs; \n\n\n\nFind the number of ways to select two pairs that match the condition above. Two ways are considered different if they consist of different pairs.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\n\nThe first line of each test case contains three integers a, b and k (1 \u2264 a, b, k \u2264 2 \u22c5 10^5) \u2014 the number of boys and girls in the class and the number of couples ready to dance together.\n\nThe second line of each test case contains k integers a_1, a_2, \u2026 a_k. (1 \u2264 a_i \u2264 a), where a_i is the number of the boy in the pair with the number i.\n\nThe third line of each test case contains k integers b_1, b_2, \u2026 b_k. (1 \u2264 b_i \u2264 b), where b_i is the number of the girl in the pair with the number i.\n\nIt is guaranteed that the sums of a, b, and k over all test cases do not exceed 2 \u22c5 10^5.\n\nIt is guaranteed that each pair is specified at most once in one test case.\n\nOutput\n\nFor each test case, on a separate line print one integer \u2014 the number of ways to choose two pairs that match the condition above.\n\nExample\n\nInput\n\n\n3\n3 4 4\n1 1 2 3\n2 3 2 4\n1 1 1\n1\n1\n2 2 4\n1 1 2 2\n1 2 1 2\n\n\nOutput\n\n\n4\n0\n2\n\nNote\n\nIn the first test case, the following combinations of pairs fit: \n\n  * (1, 2) and (3, 4); \n  * (1, 3) and (2, 2); \n  * (1, 3) and (3, 4); \n  * (2, 2) and (3, 4). \n\n\n\nThere is only one pair in the second test case.\n\nIn the third test case, the following combinations of pairs fit: \n\n  * (1, 1) and (2, 2); \n  * (1, 2) and (2, 1). ",
        "task_name": "1475_C. Ball in Berland",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\ntesting = len(sys.argv) == 4 and sys.argv[3] == \"myTest\"\nif testing:\n    cmd = sys.stdout\n    from time import time\n    start_time = int(round(time() * 1000)) \n    input = open(sys.argv[1], 'r').readline\n    readAll = open(sys.argv[1], 'r').read\n    sys.stdout = open(sys.argv[2], 'w')\nelse:\n    input = sys.stdin.readline\n    readAll = sys.stdin.read\n\n# ############ ---- I/O Functions ---- ############\n\nclass InputData:\n    def __init__(self):\n        self.lines = readAll().split('\\n')\n        self.n = len(self.lines)\n        self.ii = -1\n    def input(self):\n        self.ii += 1\n        assert self.ii < self.n\n        return self.lines[self.ii]\ninputData = InputData()\ninput = inputData.input\n\ndef intin():\n    return(int(input()))\ndef intlin():\n    return(list(map(int,input().split())))\ndef chrin():\n    return(list(input()))\ndef strin():\n    return input()\ndef lout(l, sep=\"\\n\"):\n    print(sep.join(l))\n    \n# ############ ---- I/O Functions ---- ############\n\n# from math import ceil\nfrom collections import defaultdict as ddict, Counter\n# from heapq import *\n# from Queue import Queue\n\ndef main():\n    n,m,k = intlin()\n    a = intlin()\n    b = intlin()\n    cntA = Counter(a)\n    cntB = Counter(b)\n    ans = 0\n    for i in xrange(k):\n        ans += k-cntA[a[i]]-cntB[b[i]]+1\n    print(ans/2)\n\n\nfor _ in xrange(intin()):\n    main()\n    # print(\"YES\" if main() else \"NO\")\n# main()\n\nif testing:\n    sys.stdout = cmd\n    print(int(round(time() * 1000))  - start_time)",
        "correct": true,
        "task_id": "0579",
        "depth": 1
    },
    {
        "description": "Polycarpus got hold of a family tree. The found tree describes the family relations of n people, numbered from 1 to n. Every person in this tree has at most one direct ancestor. Also, each person in the tree has a name, the names are not necessarily unique.\n\nWe call the man with a number a a 1-ancestor of the man with a number b, if the man with a number a is a direct ancestor of the man with a number b.\n\nWe call the man with a number a a k-ancestor (k > 1) of the man with a number b, if the man with a number b has a 1-ancestor, and the man with a number a is a (k - 1)-ancestor of the 1-ancestor of the man with a number b.\n\nIn the tree the family ties do not form cycles. In other words there isn't a person who is his own direct or indirect ancestor (that is, who is an x-ancestor of himself, for some x, x > 0).\n\nWe call a man with a number a the k-son of the man with a number b, if the man with a number b is a k-ancestor of the man with a number a.\n\nPolycarpus is very much interested in how many sons and which sons each person has. He took a piece of paper and wrote m pairs of numbers vi, ki. Help him to learn for each pair vi, ki the number of distinct names among all names of the ki-sons of the man with number vi.\n\nInput\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 105) \u2014 the number of people in the tree. Next n lines contain the description of people in the tree. The i-th line contains space-separated string si and integer ri (0 \u2264 ri \u2264 n), where si is the name of the man with a number i, and ri is either the number of the direct ancestor of the man with a number i or 0, if the man with a number i has no direct ancestor. \n\nThe next line contains a single integer m (1 \u2264 m \u2264 105) \u2014 the number of Polycarpus's records. Next m lines contain space-separated pairs of integers. The i-th line contains integers vi, ki (1 \u2264 vi, ki \u2264 n).\n\nIt is guaranteed that the family relationships do not form cycles. The names of all people are non-empty strings, consisting of no more than 20 lowercase English letters.\n\nOutput\n\nPrint m whitespace-separated integers \u2014 the answers to Polycarpus's records. Print the answers to the records in the order, in which the records occur in the input.\n\nExamples\n\nInput\n\n6\npasha 0\ngerald 1\ngerald 1\nvalera 2\nigor 3\nolesya 1\n5\n1 1\n1 2\n1 3\n3 1\n6 1\n\n\nOutput\n\n2\n2\n0\n1\n0\n\n\nInput\n\n6\nvalera 0\nvalera 1\nvalera 1\ngerald 0\nvalera 4\nkolya 4\n7\n1 1\n1 2\n2 1\n2 2\n4 1\n5 1\n6 1\n\n\nOutput\n\n1\n0\n0\n0\n2\n0\n0",
        "task_name": "246_E. Blood Cousins Return",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\nchild = [set({}) for i in range(0, n + 1)]\nquery = [list({}) for i in range(0, n + 1)]\nans = [dict(set({})) for i in range(0, n + 1)]\nss = [0 for i in range(0, n + 1)]\nfa = [0 for i in range(0, n + 1)]\nhash_string = dict()\nnowstrings = 0\nfor i in range(1, n + 1):\n    s = raw_input().split()\n    child[int(s[1])] |= {i}\n    fa[i] = int(s[1])\n    if s[0] not in hash_string:\n        nowstrings += 1\n        hash_string[s[0]] = nowstrings\n    ss[i] = hash_string[s[0]]\nfa[0] = -1\nChild = [list(child[i]) for i in range(0, n+1)]\nlenChild = [len(Child[i]) for i in range(0, n+1)]\nnowChild = [0 for i in range(0, n+1)]\nm = int(raw_input())\nanswer = [0 for i in range(0, m)]\nfor i in range(0, m):\n    s = raw_input().split()\n    query[int(s[0])] += {int(s[1])}\n    query[int(s[0])] += {i}\ndef dfs(x, dep):\n    while x != -1:\n        if nowChild[x] == lenChild[x]:\n            if x != 0:\n                ans[x][dep] = {ss[x]}\n                for nowlistindex in range(0, len(query[x]), 2):\n                    i = query[x][nowlistindex]\n                    j = query[x][nowlistindex+1]\n                    if dep + i not in ans[x]:\n                        answer[j] = 0\n                    else:\n                        answer[j] = len(ans[x][dep + i])\n                \"\"\"count ans\"\"\"\n                if len(ans[x]) < len(ans[fa[x]]):\n                    for j in ans[x]:\n                        if j not in ans[fa[x]]:\n                            ans[fa[x]][j] = ans[x][j]\n                        elif len(ans[x][j]) < len(ans[fa[x]][j]):\n                            ans[fa[x]][j] |= ans[x][j]\n                            ans[x][j].clear()\n                        else:\n                            ans[x][j] |= ans[fa[x]][j]\n                            ans[fa[x]][j].clear()\n                            ans[fa[x]][j] = ans[x][j]\n                    ans[x].clear()\n                else:\n                    for j in ans[fa[x]]:\n                        if j not in ans[x]:\n                            ans[x][j] = ans[fa[x]][j]\n                        elif len(ans[x][j]) > len(ans[fa[x]][j]):\n                            ans[x][j] |= ans[fa[x]][j]\n                            ans[fa[x]][j].clear()\n                        else:\n                            ans[fa[x]][j] |= ans[x][j]\n                            ans[x][j].clear()\n                            ans[x][j] = ans[fa[x]][j]\n                    ans[fa[x]].clear()\n                    ans[fa[x]] = ans[x]\n            x = fa[x]\n            nowChild[x] += 1\n            dep -= 1\n        else:\n            x = Child[x][nowChild[x]]\n            dep += 1\ndfs(0, 0)\nfor i in range(0, m):\n    print(answer[i])\n",
        "correct": true,
        "task_id": "0582",
        "depth": 2
    },
    {
        "description": "Dima and his friends have been playing hide and seek at Dima's place all night. As a result, Dima's place got messy. In the morning they decided that they need to clean the place.\n\nTo decide who exactly would clean the apartment, the friends want to play a counting-out game. First, all the guys stand in a circle, and then each of them shows some number of fingers on one hand (one to five), and then the boys count in a circle, starting from Dima, the number of people, respective to the total number of fingers shown. The person on who the countdown stops will clean the apartment.\n\nFor example, if Dima and one of his friends played hide and seek, and 7 fingers were shown during the counting-out, then Dima would clean the place. If there were 2 or say, 8 fingers shown, then his friend would clean the place.\n\nDima knows how many fingers each of his friends will show during the counting-out. Now he is interested in the number of ways to show some number of fingers on one hand (one to five), so that he did not have to clean the place. Help Dima.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 100) \u2014 the number of Dima's friends. Dima himself isn't considered to be his own friend. The second line contains n positive integers, not exceeding 5, representing, how many fingers the Dima's friends will show. \n\nThe numbers in the lines are separated by a single space.\n\nOutput\n\nIn a single line print the answer to the problem.\n\nExamples\n\nInput\n\n1\n1\n\n\nOutput\n\n3\n\n\nInput\n\n1\n2\n\n\nOutput\n\n2\n\n\nInput\n\n2\n3 5\n\n\nOutput\n\n3\n\nNote\n\nIn the first sample Dima can show 1, 3 or 5 fingers. If Dima shows 3 fingers, then the counting-out will go like that: Dima, his friend, Dima, his friend.\n\nIn the second sample Dima can show 2 or 4 fingers.",
        "task_name": "272_A. Dima and Friends",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = input()\n\ns = sum(map(int,raw_input().split()))\n\nk = n+1\ntemp=0\nfor i in range(5):\n    if (s+i)%k==0:\n        temp += 1\n\nprint(5-temp)",
        "correct": true,
        "task_id": "0583",
        "depth": 1
    },
    {
        "description": "Dima, Inna and Seryozha have gathered in a room. That's right, someone's got to go. To cheer Seryozha up and inspire him to have a walk, Inna decided to cook something. \n\nDima and Seryozha have n fruits in the fridge. Each fruit has two parameters: the taste and the number of calories. Inna decided to make a fruit salad, so she wants to take some fruits from the fridge for it. Inna follows a certain principle as she chooses the fruits: the total taste to the total calories ratio of the chosen fruits must equal k. In other words, <image> , where aj is the taste of the j-th chosen fruit and bj is its calories.\n\nInna hasn't chosen the fruits yet, she is thinking: what is the maximum taste of the chosen fruits if she strictly follows her principle? Help Inna solve this culinary problem \u2014 now the happiness of a young couple is in your hands!\n\nInna loves Dima very much so she wants to make the salad from at least one fruit.\n\nInput\n\nThe first line of the input contains two integers n, k (1 \u2264 n \u2264 100, 1 \u2264 k \u2264 10). The second line of the input contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 100) \u2014 the fruits' tastes. The third line of the input contains n integers b1, b2, ..., bn (1 \u2264 bi \u2264 100) \u2014 the fruits' calories. Fruit number i has taste ai and calories bi.\n\nOutput\n\nIf there is no way Inna can choose the fruits for the salad, print in the single line number -1. Otherwise, print a single integer \u2014 the maximum possible sum of the taste values of the chosen fruits.\n\nExamples\n\nInput\n\n3 2\n10 8 1\n2 7 1\n\n\nOutput\n\n18\n\n\nInput\n\n5 3\n4 4 4 4 4\n2 2 2 2 2\n\n\nOutput\n\n-1\n\nNote\n\nIn the first test sample we can get the total taste of the fruits equal to 18 if we choose fruit number 1 and fruit number 2, then the total calories will equal 9. The condition <image> fulfills, that's exactly what Inna wants.\n\nIn the second test sample we cannot choose the fruits so as to follow Inna's principle.",
        "task_name": "366_C. Dima and Salad",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from collections import defaultdict\n\nn, k = map(int, raw_input().split())\nA = map(int, raw_input().split())\nB = map(int, raw_input().split())\ndp1 = defaultdict(lambda: 0, {0 : 0})\npos = 0\nfor a, b in zip(A, B):\n    cur = a - b * k\n    dp2 = dp1.copy()\n    for x, y in dp1.iteritems():\n        dp2[x + cur] = max(dp2[x + cur], y + a)\n    dp1 = dp2\nif dp1[0] > 0:\n    print(dp1[0])\nelse:\n    print(-1)",
        "correct": true,
        "task_id": "0586",
        "depth": 2
    },
    {
        "description": "Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. \n\nYour friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. \n\nYou want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l \u2264 a < b < c \u2264 r. \n\nMore specifically, you need to find three numbers (a, b, c), such that l \u2264 a < b < c \u2264 r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.\n\nInput\n\nThe single line contains two positive space-separated integers l, r (1 \u2264 l \u2264 r \u2264 1018; r - l \u2264 50).\n\nOutput\n\nPrint three positive space-separated integers a, b, c \u2014 three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. \n\nIf the counterexample does not exist, print the single number -1.\n\nExamples\n\nInput\n\n2 4\n\n\nOutput\n\n2 3 4\n\n\nInput\n\n10 11\n\n\nOutput\n\n-1\n\n\nInput\n\n900000000000000009 900000000000000029\n\n\nOutput\n\n900000000000000009 900000000000000010 900000000000000021\n\nNote\n\nIn the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. \n\nIn the second sample you cannot form a group of three distinct integers, so the answer is -1. \n\nIn the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three. ",
        "task_name": "483_A. Counterexample ",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\n\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\n\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# ref. https://codeforces.com/blog/entry/71884\n# 1) inp(), For taking integer inputs.\n# 2) inlt(), For taking List inputs.\n# 3) insr(), For taking string inputs. \n#           Actually it returns a List of Characters, \n#           instead of a string, which is easier to use in Python, \n#           because in Python, Strings are Immutable.\n# 4) invr(), For taking space seperated integer variable inputs.\n\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s[:len(s)]))\ndef invr():\n    return(map(int,input().split()))\n\ndef gcd(a, b):\n    while a % b > 0:\n        c = a % b\n        a = b\n        b = c\n    \n    return b\n\ndef findC(l, r):\n    for a in range(l, r + 1):\n        for b in range(a + 1, r + 1):\n            # print(a, b, r, gcd(b, a), gcd(r, b))\n            if gcd(r, b) == 1 and gcd(b, a) != 1:\n                return (a, b, r)\n\n    return (-1, -1, -1)\n\nl, r = inlt()\n\nif gcd(r, l) == 1:\n    a, b, c = findC(l, r)\n    if a == -1:\n        sys.stdout.write('-1\\n')\n    sys.stdout.write(str(a) + ' ' + str(b)+ ' ' + str(c) + '\\n')\nelse:\n    sys.stdout.write(str(l) + ' ' + str(l + 1)+ ' ' + str(r) + '\\n')\n",
        "correct": false,
        "task_id": "0589",
        "depth": 2
    },
    {
        "description": "Students in a class are making towers of blocks. Each student makes a (non-zero) tower by stacking pieces lengthwise on top of each other. n of the students use pieces made of two blocks and m of the students use pieces made of three blocks.\n\nThe students don\u2019t want to use too many blocks, but they also want to be unique, so no two students\u2019 towers may contain the same number of blocks. Find the minimum height necessary for the tallest of the students' towers.\n\nInput\n\nThe first line of the input contains two space-separated integers n and m (0 \u2264 n, m \u2264 1 000 000, n + m > 0) \u2014 the number of students using two-block pieces and the number of students using three-block pieces, respectively.\n\nOutput\n\nPrint a single integer, denoting the minimum possible height of the tallest tower.\n\nExamples\n\nInput\n\n1 3\n\n\nOutput\n\n9\n\n\nInput\n\n3 2\n\n\nOutput\n\n8\n\n\nInput\n\n5 0\n\n\nOutput\n\n10\n\nNote\n\nIn the first case, the student using two-block pieces can make a tower of height 4, and the students using three-block pieces can make towers of height 3, 6, and 9 blocks. The tallest tower has a height of 9 blocks.\n\nIn the second case, the students can make towers of heights 2, 4, and 8 with two-block pieces and towers of heights 3 and 6 with three-block pieces, for a maximum height of 8 blocks.",
        "task_name": "626_C. Block Towers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n# Author : raj1307 - Raj Singh\n# Date   : 30.04.2020\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import log,sqrt,factorial\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey,reverse=True)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\ndef ncr(n,r): return factorial(n)//(factorial(r)*factorial(n-r))\n\ndef ceil(x,y):\n    if x%y==0:\n        return x//y\n    else:\n        return x//y+1\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\n\n\ndef main():\n        \n\n    #for _ in range(ii()):\n    \n    \n    n,m=mi()\n\n\n    for i in range(1,1000001):\n\n        if n<=i//2 and m<=i//3 and n+m<=i//2+i//2-i//6:\n            print(i)\n            break\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n       \n\n\n\n    \n\n\n\n\n\n\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": false,
        "task_id": "0592",
        "depth": 1
    },
    {
        "description": "Vasya the programmer lives in the middle of the Programming subway branch. He has two girlfriends: Dasha and Masha, who live at the different ends of the branch, each one is unaware of the other one's existence.\n\nWhen Vasya has some free time, he goes to one of his girlfriends. He descends into the subway at some time, waits the first train to come and rides on it to the end of the branch to the corresponding girl. However, the trains run with different frequencies: a train goes to Dasha's direction every a minutes, but a train goes to Masha's direction every b minutes. If two trains approach at the same time, Vasya goes toward the direction with the lower frequency of going trains, that is, to the girl, to whose directions the trains go less frequently (see the note to the third sample).\n\nWe know that the trains begin to go simultaneously before Vasya appears. That is the train schedule is such that there exists a moment of time when the two trains arrive simultaneously.\n\nHelp Vasya count to which girlfriend he will go more often.\n\nInput\n\nThe first line contains two integers a and b (a \u2260 b, 1 \u2264 a, b \u2264 106).\n\nOutput\n\nPrint \"Dasha\" if Vasya will go to Dasha more frequently, \"Masha\" if he will go to Masha more frequently, or \"Equal\" if he will go to both girlfriends with the same frequency.\n\nExamples\n\nInput\n\n3 7\n\n\nOutput\n\nDasha\n\n\nInput\n\n5 3\n\n\nOutput\n\nMasha\n\n\nInput\n\n2 3\n\n\nOutput\n\nEqual\n\nNote\n\nLet's take a look at the third sample. Let the trains start to go at the zero moment of time. It is clear that the moments of the trains' arrival will be periodic with period 6. That's why it is enough to show that if Vasya descends to the subway at a moment of time inside the interval (0, 6], he will go to both girls equally often. \n\nIf he descends to the subway at a moment of time from 0 to 2, he leaves for Dasha on the train that arrives by the second minute.\n\nIf he descends to the subway at a moment of time from 2 to 3, he leaves for Masha on the train that arrives by the third minute.\n\nIf he descends to the subway at a moment of time from 3 to 4, he leaves for Dasha on the train that arrives by the fourth minute.\n\nIf he descends to the subway at a moment of time from 4 to 6, he waits for both trains to arrive by the sixth minute and goes to Masha as trains go less often in Masha's direction.\n\nIn sum Masha and Dasha get equal time \u2014 three minutes for each one, thus, Vasya will go to both girlfriends equally often.",
        "task_name": "87_A. Trains",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python2\n# -*- coding: utf-8 -*-\nimport sys\ninput = sys.stdin\noutput = sys.stdout\n\nMAX = 10**6\n\nDa = 'Dasha'\nMa = 'Masha'\n\ndef gcd(a,b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a,b):\n    assert (a*b)/gcd(a,b) == (a/gcd(a,b))*b \n    #return (a*b)/gcd(a,b)\n    return (a/gcd(a,b))*b\n\ndef GCD(numbers):\n    return reduce(lambda a,b: gcd(a,b), numbers)\n\ndef LCM(numbers):\n    return reduce(lambda a,b: lcm(a,b), numbers)\n\n\ndef f1(n):\n    return n*(n+1)/2\n\ndef solve(a,b):\n    G = gcd(a,b)\n    L = lcm(a,b)\n    if a<b:\n        M = (L/b - 1)*G\n        D = L - M\n        if D>M:\n            return Ma\n        else:\n            return Da\n    else:\n        M = (L/a - 1)*G\n        D = L - M\n        if D>M:\n            return Ma\n        else:\n            return Da\n\nS = input.readline().split(' ')\na = int(S[0])\nb = int(S[1])\nassert 1<=a and a<=MAX \nassert 1<=b and b<=MAX\nassert a != b \n\nanswer = solve(a,b)\n    \noutput.write('%s\\n' % (answer))\n",
        "correct": false,
        "task_id": "0597",
        "depth": 1
    },
    {
        "description": "There is a cave.\n\nThe cave has N rooms and M passages. The rooms are numbered 1 to N, and the passages are numbered 1 to M. Passage i connects Room A_i and Room B_i bidirectionally. One can travel between any two rooms by traversing passages. Room 1 is a special room with an entrance from the outside.\n\nIt is dark in the cave, so we have decided to place a signpost in each room except Room 1. The signpost in each room will point to one of the rooms directly connected to that room with a passage.\n\nSince it is dangerous in the cave, our objective is to satisfy the condition below for each room except Room 1.\n\n* If you start in that room and repeatedly move to the room indicated by the signpost in the room you are in, you will reach Room 1 after traversing the minimum number of passages possible.\n\n\n\nDetermine whether there is a way to place signposts satisfying our objective, and print one such way if it exists.\n\nConstraints\n\n* All values in input are integers.\n* 2 \\leq N \\leq 10^5\n* 1 \\leq M \\leq 2 \\times 10^5\n* 1 \\leq A_i, B_i \\leq N\\ (1 \\leq i \\leq M)\n* A_i \\neq B_i\\ (1 \\leq i \\leq M)\n* One can travel between any two rooms by traversing passages.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M\nA_1 B_1\n:\nA_M B_M\n\n\nOutput\n\nIf there is no way to place signposts satisfying the objective, print `No`.\n\nOtherwise, print N lines. The first line should contain `Yes`, and the i-th line (2 \\leq i \\leq N) should contain the integer representing the room indicated by the signpost in Room i.\n\nExamples\n\nInput\n\n4 4\n1 2\n2 3\n3 4\n4 2\n\n\nOutput\n\nYes\n1\n2\n2\n\n\nInput\n\n6 9\n3 4\n6 1\n2 4\n5 3\n4 6\n1 5\n6 2\n4 5\n5 6\n\n\nOutput\n\nYes\n6\n5\n5\n1\n1",
        "task_name": "p02678 AtCoder Beginner Contest 168 - .. (Double Dots)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef bfs(graph, start=0):\n    used = [False] * len(graph)\n    used[start] = True\n    q = [start]\n\n    depth = [-1] * len(graph)\n    post = [-1] * len(graph)\n\n    depth[0] = 0\n\n    for v in q:\n        for w in graph[v]:\n            if depth[w] != -1 and (depth[w] < depth[v] or depth[v] == -1):\n                depth[v] = depth[w] + 1\n                post[v] = w\n\n            if not used[w]:\n                used[w] = True\n                q.append(w)\n\n    return post\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    post = bfs(graph)[1:]\n\n    if -1 in post:\n        print(\"No\")\n        return\n\n    print(\"Yes\")\n    for i in post:\n        print(i + 1)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "0602",
        "depth": 2
    },
    {
        "description": "An integer sequence is called beautiful if the difference between any two consecutive numbers is equal to 1. More formally, a sequence s_1, s_2, \u2026, s_{n} is beautiful if |s_i - s_{i+1}| = 1 for all 1 \u2264 i \u2264 n - 1.\n\nTrans has a numbers 0, b numbers 1, c numbers 2 and d numbers 3. He wants to construct a beautiful sequence using all of these a + b + c + d numbers.\n\nHowever, it turns out to be a non-trivial task, and Trans was not able to do it. Could you please help Trans?\n\nInput\n\nThe only input line contains four non-negative integers a, b, c and d (0 < a+b+c+d \u2264 10^5).\n\nOutput\n\nIf it is impossible to construct a beautiful sequence satisfying the above constraints, print \"NO\" (without quotes) in one line.\n\nOtherwise, print \"YES\" (without quotes) in the first line. Then in the second line print a + b + c + d integers, separated by spaces \u2014 a beautiful sequence. There should be a numbers equal to 0, b numbers equal to 1, c numbers equal to 2 and d numbers equal to 3.\n\nIf there are multiple answers, you can print any of them.\n\nExamples\n\nInput\n\n\n2 2 2 1\n\n\nOutput\n\n\nYES\n0 1 0 1 2 3 2\n\n\nInput\n\n\n1 2 3 4\n\n\nOutput\n\n\nNO\n\n\nInput\n\n\n2 2 2 3\n\n\nOutput\n\n\nNO\n\nNote\n\nIn the first test, it is easy to see, that the sequence is beautiful because the difference between any two consecutive numbers is equal to 1. Also, there are exactly two numbers, equal to 0, 1, 2 and exactly one number, equal to 3.\n\nIt can be proved, that it is impossible to construct beautiful sequences in the second and third tests.",
        "task_name": "1264_B. Beautiful Sequence",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n\ndef main():\n    a, b, c, d = input_as_list()\n    s1 = b-a\n    s2 = c-d\n    if s1 == s2:\n        out = [1, 0]*a + [1, 2]*(b-a) + [3, 2]*d\n    elif s1+1 == s2:\n        if a > 0:\n            a -= 1\n            out = [0] + [1, 0]*a + [1, 2]*(b-a) + [3, 2]*d\n        else:\n            c -= 1\n            out = [2] + [1, 0]*a + [1, 2]*(b-a) + [3, 2]*d\n    elif s1 == s2+1:\n        if d > 0:\n            d -= 1\n            out = [1, 0]*a + [1, 2]*(b-a) + [3, 2]*d + [3]\n        else:\n            b -= 1\n            out = [1, 0]*a + [1, 2]*(b-a) + [3, 2]*d + [1]\n    else:\n        print(\"NO\")\n        return\n    print(\"YES\")\n    print(*out)\n\nINF = float('inf')\nMOD = 10 ** 9 + 7\n__interactive = False\n\nimport os, sys\nfrom atexit import register\nfrom io import BytesIO\nimport itertools\nimport __pypy__\n\nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\nmulmod = __pypy__.intop.int_mulmod\n\nif \"LOCAL_\" in os.environ:\n    debug_print = print\nelse:\n    if not __interactive:\n        sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n        sys.stdout = BytesIO()\n        register(lambda: os.write(1, sys.stdout.getvalue()))\n\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n    else:\n        flush = sys.stdout.flush\n    debug_print = lambda *x, **y: None\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef input_as_list():\n    return list(map(int, input().split()))\n\ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\ndef range_with_count(start, step, count):\n    return range(start, start + step * count, step)\n\ndef indices(l, start=0, end=0):\n    return range(start, len(l)+end)\n\ndef ceil_power_of_2(n):\n    return 2 ** ((n - 1).bit_length())\n\ndef ceil_div(x, r):\n    return (x + r - 1) // r\n\nmain()",
        "correct": false,
        "task_id": "0618",
        "depth": 1
    },
    {
        "description": "Today, as a friendship gift, Bakry gave Badawy n integers a_1, a_2, ..., a_n and challenged him to choose an integer X such that the value \\underset{1 \u2264 i \u2264 n}{max} (a_i \u2295 X) is minimum possible, where \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nAs always, Badawy is too lazy, so you decided to help him and find the minimum possible value of \\underset{1 \u2264 i \u2264 n}{max} (a_i \u2295 X).\n\nInput\n\nThe first line contains integer n (1\u2264 n \u2264 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 2^{30}-1).\n\nOutput\n\nPrint one integer \u2014 the minimum possible value of \\underset{1 \u2264 i \u2264 n}{max} (a_i \u2295 X).\n\nExamples\n\nInput\n\n\n3\n1 2 3\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n2\n1 5\n\n\nOutput\n\n\n4\n\nNote\n\nIn the first sample, we can choose X = 3.\n\nIn the second sample, we can choose X = 5.",
        "task_name": "1285_D. Dr. Evil Underscores",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n\nn=int(raw_input())\na=list(map(int,raw_input().split()))\n\ns=[]\n\nfor i in a:\n\tts=bin(i)[2:]\n\tts=ts[::-1]\n\twhile(len(ts)<32):\n\t\tts+=\"0\"\n\n\ts.append(ts)\n\n\nans=\"\"\nbrk=-1\n\nleftp=0\nansl=-1\nansr=-1\n\nfor j in range(31,-1,-1):\n\tc1=0\n\tc0=0\n\n\tfor i in range(n):\n\t\tif(s[i][j]=='0'):\n\t\t\tc0+=1\n\t\telse:\n\t\t\tc1+=1\n\n\n\tif(c1==n):\n\t\tans+=\"1\"\n\telif(c0==n):\n\t\tans+=\"0\"\n\telse:\n\n\t\tmx0=0\n\t\tmx1=0\n\n\t\tans+=\"1\"\n\t\t\n\t\tleftp=int(ans,2)\n\t\tleftp<<=j\n\n\t\tfor i in range(n):\n\t\t\tif(s[i][j]=='0'):\n\t\t\t\tmx0=max(mx0,int((s[i][:j])[::-1],2))\n\t\t\telse:\n\t\t\t\tmx1=max(mx1,int((s[i][:j])[::-1],2))\n\n\n\t\tansl=leftp+mx0\n\t\tansr=leftp+mx1\n\t\tbreak\n\n\nif(ansl==-1):\n\tleftp=int(ans,2)\n\n\ta1=0\n\n\tfor i in a:\n\t\ta1=max(a1,leftp^i)\n\n\tprint(a1)\nelse:\n\n\tm1=0\n\tm0=0\n\n\tfor i in a:\n\t\tm1=max(m1,ansr^i)\n\t\tm0=max(m0,ansl^i)\n\n\tprint(min(m1,m0))\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n",
        "correct": false,
        "task_id": "0619",
        "depth": 2
    },
    {
        "description": "The Little Elephant very much loves sums on intervals.\n\nThis time he has a pair of integers l and r (l \u2264 r). The Little Elephant has to find the number of such integers x (l \u2264 x \u2264 r), that the first digit of integer x equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.\n\nHelp him and count the number of described numbers x for a given pair l and r.\n\nInput\n\nThe single line contains a pair of integers l and r (1 \u2264 l \u2264 r \u2264 1018) \u2014 the boundaries of the interval.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nOutput\n\nOn a single line print a single integer \u2014 the answer to the problem.\n\nExamples\n\nInput\n\n2 47\n\n\nOutput\n\n12\n\n\nInput\n\n47 1024\n\n\nOutput\n\n98\n\nNote\n\nIn the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44. ",
        "task_name": "204_A. Little Elephant and Interval",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def sol():\n    lower, upper = map(int, raw_input().split())\n    res = 0\n    for val in range(1, 10):\n        if lower <= val <= upper: res+=1 \n    for length in range(2, 19):\n        for startend in range(1, 10):\n            alreadyval = startend * pow(10, length - 1) + (0 if length == 1 else startend)\n            smallestpos = max(0, (lower - alreadyval + 9) / 10)\n            largestpos = min(pow(10, length - 2) - 1, (upper - alreadyval) / 10)\n            res += max(0, largestpos - smallestpos + 1)\n    print(res)\nsol()",
        "correct": true,
        "task_id": "0628",
        "depth": 2
    },
    {
        "description": "The winner of the card game popular in Berland \"Berlogging\" is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line \"name score\", where name is a player's name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to m) at the end of the game, than wins the one of them who scored at least m points first. Initially each player has 0 points. It's guaranteed that at the end of the game at least one player has a positive number of points.\n\nInput\n\nThe first line contains an integer number n (1 \u2264 n \u2264 1000), n is the number of rounds played. Then follow n lines, containing the information about the rounds in \"name score\" format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive.\n\nOutput\n\nPrint the name of the winner.\n\nExamples\n\nInput\n\n3\nmike 3\nandrew 5\nmike 2\n\n\nOutput\n\nandrew\n\n\nInput\n\n3\nandrew 3\nandrew 2\nmike 5\n\n\nOutput\n\nandrew",
        "task_name": "2_A. Winner",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport io\nimport os\nimport sys\nfrom collections import defaultdict\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from cStringIO import StringIO\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    from io import BytesIO as StringIO\n\nsys.stdout, stream = io.IOBase(), StringIO()\nsys.stdout.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\nsys.stdout.write = stream.write if sys.version_info[0] < 3 else lambda s: stream.write(s.encode())\n\ninput, flush = sys.stdin.readline, sys.stdout.flush\ninput = StringIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ndef main():\n    n = int(input())\n    rounds = [input().split() for _ in range(n)]\n    rounds = [(name, int(score)) for name, score in rounds]\n\n    final_scores = defaultdict(int)\n    for name, score in rounds:\n        final_scores[name] += score\n\n    m = max(final_scores.values())\n    winner_candidates = {player for player, score in final_scores.items() if score == m}\n\n    curr_scores = defaultdict(int)\n    for name, score in rounds:\n        curr_scores[name] += score\n        if (curr_scores[name] >= m) and (name in winner_candidates):\n            print(name)\n            break\n\n\nif __name__ == '__main__':\n    main()\n",
        "correct": true,
        "task_id": "0630",
        "depth": 1
    },
    {
        "description": "There are N empty boxes arranged in a row from left to right. The integer i is written on the i-th box from the left (1 \\leq i \\leq N).\n\nFor each of these boxes, Snuke can choose either to put a ball in it or to put nothing in it.\n\nWe say a set of choices to put a ball or not in the boxes is good when the following condition is satisfied:\n\n* For every integer i between 1 and N (inclusive), the total number of balls contained in the boxes with multiples of i written on them is congruent to a_i modulo 2.\n\n\n\nDoes there exist a good set of choices? If the answer is yes, find one good set of choices.\n\nConstraints\n\n* All values in input are integers.\n* 1 \\leq N \\leq 2 \\times 10^5\n* a_i is 0 or 1.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\na_1 a_2 ... a_N\n\n\nOutput\n\nIf a good set of choices does not exist, print `-1`.\n\nIf a good set of choices exists, print one such set of choices in the following format:\n\n\nM\nb_1 b_2 ... b_M\n\n\nwhere M denotes the number of boxes that will contain a ball, and b_1,\\ b_2,\\ ...,\\ b_M are the integers written on these boxes, in any order.\n\nExamples\n\nInput\n\n3\n1 0 0\n\n\nOutput\n\n1\n1\n\n\nInput\n\n5\n0 0 0 0 0\n\n\nOutput\n\n0",
        "task_name": "p02972 AtCoder Beginner Contest 134 - Preparing Boxes",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from collections import *\nimport sys\ninp = raw_input\n\ndef err(s):\n    sys.stderr.write('{}\\n'.format(s))\n\ndef ni():\n    return int(inp())\n\ndef nl():\n    return [int(_) for _ in inp().split()]\n\nN = ni()\nA = nl()\n\nout = [0]*N\nfail = False\nB = []\nfor i in range(N-1, -1, -1):\n    j = i + 1\n    S = 0\n    for k in range(i, N, j):\n        S += out[k]\n    if S%2 != A[i]:\n        out[i] = 1\n        B.append(j)\nprint(len(B))\nif len(B):\n    print(' '.join(map(str, B)))\n\n",
        "correct": true,
        "task_id": "0645",
        "depth": 2
    },
    {
        "description": "On his free time, Chouti likes doing some housework. He has got one new task, paint some bricks in the yard.\n\nThere are n bricks lined in a row on the ground. Chouti has got m paint buckets of different colors at hand, so he painted each brick in one of those m colors.\n\nHaving finished painting all bricks, Chouti was satisfied. He stood back and decided to find something fun with these bricks. After some counting, he found there are k bricks with a color different from the color of the brick on its left (the first brick is not counted, for sure).\n\nSo as usual, he needs your help in counting how many ways could he paint the bricks. Two ways of painting bricks are different if there is at least one brick painted in different colors in these two ways. Because the answer might be quite big, you only need to output the number of ways modulo 998 244 353.\n\nInput\n\nThe first and only line contains three integers n, m and k (1 \u2264 n,m \u2264 2000, 0 \u2264 k \u2264 n-1) \u2014 the number of bricks, the number of colors, and the number of bricks, such that its color differs from the color of brick to the left of it.\n\nOutput\n\nPrint one integer \u2014 the number of ways to color bricks modulo 998 244 353.\n\nExamples\n\nInput\n\n\n3 3 0\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n3 2 1\n\n\nOutput\n\n\n4\n\nNote\n\nIn the first example, since k=0, the color of every brick should be the same, so there will be exactly m=3 ways to color the bricks.\n\nIn the second example, suppose the two colors in the buckets are yellow and lime, the following image shows all 4 possible colorings.\n\n<image>",
        "task_name": "1081_C. Colorful Bricks",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\"\"\"\nThis file is part of https://github.com/Cheran-Senthil/PyRival.\n\nCopyright 2018 Cheran Senthilkumar all rights reserved,\nCheran Senthilkumar <hello@cheran.io>\nPermission to use, modify, and distribute this software is given under the\nterms of the MIT License.\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport cmath\nimport itertools\nimport math\nimport operator as op\n# import random\nimport sys\nfrom atexit import register\nfrom bisect import bisect_left, bisect_right\n# from collections import Counter, MutableSequence, defaultdict, deque\n# from copy import deepcopy\n# from decimal import Decimal\n# from difflib import SequenceMatcher\n# from fractions import Fraction\n# from heapq import heappop, heappush\n\nif sys.version_info[0] < 3:\n    # from cPickle import dumps\n    from io import BytesIO as stream\n    # from Queue import PriorityQueue, Queue\nelse:\n    from functools import reduce\n    from io import StringIO as stream\n    from math import gcd\n    # from pickle import dumps\n    # from queue import PriorityQueue, Queue\n\n\nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n\n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n\n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n\n    def gcd(x, y):\n        \"\"\"gcd(x, y) -> int\n        greatest common divisor of x and y\n        \"\"\"\n        while y:\n            x, y = y, x % y\n        return x\n\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\n\ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n\n    Args:\n        sync (bool, optional): The new synchronization setting.\n\n    \"\"\"\n    global input, flush\n\n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\nMOD = 998244353\n\ndef main():\n    n, m, k = map(int, input().split())\n\n    a = 1\n    for i in range((n - 1) - k + 1, n):\n        a *= i\n        a %= MOD\n    b = 1\n    for i in range(1, k+1):\n        b *= i\n        b %= MOD\n\n    nck = a // b\n\n    print((m * pow((m - 1), k, MOD) * nck) % MOD)\n\nif __name__ == '__main__':\n    sync_with_stdio(False)\n    main()\n",
        "correct": false,
        "task_id": "0654",
        "depth": 1
    },
    {
        "description": "We're giving away nice huge bags containing number tiles! A bag we want to present to you contains n tiles. Each of them has a single number written on it \u2014 either 1 or 2.\n\nHowever, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get.\n\nCan you win the prize? Hurry up, the bags are waiting!\n\nInput\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 200 000) \u2014 the number of number tiles in the bag. The following line contains n space-separated integers a_1, a_2, ..., a_n (a_i \u2208 \\{1, 2\\}) \u2014 the values written on the tiles.\n\nOutput\n\nOutput a permutation b_1, b_2, ..., b_n of the input sequence (a_1, a_2, ..., a_n) maximizing the number of the prefix sums being prime numbers. If there are multiple optimal permutations, output any.\n\nExamples\n\nInput\n\n\n5\n1 2 1 2 1\n\n\nOutput\n\n\n1 1 1 2 2\n\n\nInput\n\n\n9\n1 1 2 1 1 1 2 1 1\n\n\nOutput\n\n\n1 1 1 2 1 1 1 2 1\n\nNote\n\nThe first solution produces the prefix sums 1, \\mathbf{\\color{blue}{2}}, \\mathbf{\\color{blue}{3}}, \\mathbf{\\color{blue}{5}}, \\mathbf{\\color{blue}{7}} (four primes constructed), while the prefix sums in the second solution are 1, \\mathbf{\\color{blue}{2}}, \\mathbf{\\color{blue}{3}}, \\mathbf{\\color{blue}{5}}, 6, \\mathbf{\\color{blue}{7}}, 8, 10, \\mathbf{\\color{blue}{11}} (five primes). Primes are marked bold and blue. In each of these cases, the number of produced primes is maximum possible.",
        "task_name": "1149_A. Prefix Sum Primes",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"\nAuthor    : raj1307 - Raj Singh\nInstitute : Jalpaiguri Government Engineering College\nDate      : 29.04.19\n\"\"\"\nfrom __future__ import division, print_function\nimport itertools,os,sys\n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify, #heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial,pow,pi\n#from bisect import bisect_left,bisect_right\n#from decimal import *,threading\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    from builtins import str as __str__\n    str = lambda x=b'': x if type(x) is bytes else __str__(x).encode()\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._buffer = BytesIO()\n        self._fd = file.fileno()\n        self._writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self._buffer.write if self._writable else None\n\n    def read(self):\n        return self._buffer.read() if self._buffer.tell() else os.read(self._fd, os.fstat(self._fd).st_size)\n\n    def readline(self):\n        while self.newlines == 0:\n            b, ptr = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)), self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n            self.newlines += b.count(b'\\n') + (not b)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n    def flush(self):\n        if self._writable:\n            os.write(self._fd, self._buffer.getvalue())\n            self._buffer.truncate(0), self._buffer.seek(0)\n\n\nsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(b'\\r\\n')\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop('end', b'\\n'))\n    if kwargs.pop('flush', False):\n        file.flush()\n\n\n\n\n\ndef ii(): return int(input())\ndef si(): return str(input())\ndef mi():return map(int,input().strip().split(\" \"))\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p1\n    return res\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# For getting input from input.txt file \n#sys.stdin = open('input.txt', 'r')  \n  \n# Printing the Output to output.txt file \n#sys.stdout = open('output.txt', 'w') \n\ndef main():\n   \n    n=ii()\n    l=li()\n    a=[1,1,1,2]*50000\n    s=[]\n    one=l.count(1)\n    two=l.count(2)\n    \n    \"\"\"if two==one:\n        for i in range(n):\n            if i%2==0:\n                s.append(2)\n            else:\n                s.append(1)\n        print(*s)\n        exit()\n        \n    \n    for i in range(n):\n        if a[i]==1:\n            if one !=0:\n                s.append(1)\n                one-=1\n            else:\n                s.append(2)\n                two-=1\n        else:\n            if two!=0:\n                s.append(2)\n                two-=1\n            else:\n                s.append(1)\n                one-=1\n    print(*s)   \"\"\"\n    \n    s=[2]\n    p=[2]\n    two-=1\n    for i in range(1,n):\n        if p[-1]%2==0:\n            if one!=0:\n                s.append(1)\n                p.append(p[-1]+1)\n                one-=1\n            else:\n                s.append(2)\n                p.append(p[-1]+2)\n                two-=1\n        else:\n            if two!=0:\n                s.append(2)\n                p.append(p[-1]+2)\n                two-=1\n            else:\n                s.append(1)\n                p.append(p[-1]+1)\n                one-=1\n                \n   \n    print(*s)\n   \n   \n   \n   \n   \n   \n   \n   \n   \n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": false,
        "task_id": "0657",
        "depth": 1
    },
    {
        "description": "The statement of this problem is the same as the statement of problem C2. The only difference is that, in problem C1, n is always even, and in C2, n is always odd.\n\nYou are given a regular polygon with 2 \u22c5 n vertices (it's convex and has equal sides and equal angles) and all its sides have length 1. Let's name it as 2n-gon.\n\nYour task is to find the square of the minimum size such that you can embed 2n-gon in the square. Embedding 2n-gon in the square means that you need to place 2n-gon in the square in such way that each point which lies inside or on a border of 2n-gon should also lie inside or on a border of the square.\n\nYou can rotate 2n-gon and/or the square.\n\nInput\n\nThe first line contains a single integer T (1 \u2264 T \u2264 200) \u2014 the number of test cases.\n\nNext T lines contain descriptions of test cases \u2014 one per line. Each line contains single even integer n (2 \u2264 n \u2264 200). Don't forget you need to embed 2n-gon, not an n-gon.\n\nOutput\n\nPrint T real numbers \u2014 one per test case. For each test case, print the minimum length of a side of the square 2n-gon can be embedded in. Your answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\n\nExample\n\nInput\n\n\n3\n2\n4\n200\n\n\nOutput\n\n\n1.000000000\n2.414213562\n127.321336469",
        "task_name": "1354_C1. Simple Polygon Embedding",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from math import sin,pi,sqrt\nfor _ in range(input()):\n    n=input()\n    print (sin(pi/4+pi/(2*n))/sin(pi/(2*n)))*sqrt(2)",
        "correct": false,
        "task_id": "0663",
        "depth": 1
    },
    {
        "description": "Two semifinals have just been in the running tournament. Each semifinal had n participants. There are n participants advancing to the finals, they are chosen as follows: from each semifinal, we choose k people (0 \u2264 2k \u2264 n) who showed the best result in their semifinals and all other places in the finals go to the people who haven't ranked in the top k in their semifinal but got to the n - 2k of the best among the others.\n\nThe tournament organizers hasn't yet determined the k value, so the participants want to know who else has any chance to get to the finals and who can go home.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 105) \u2014 the number of participants in each semifinal.\n\nEach of the next n lines contains two integers ai and bi (1 \u2264 ai, bi \u2264 109) \u2014 the results of the i-th participant (the number of milliseconds he needs to cover the semifinals distance) of the first and second semifinals, correspondingly. All results are distinct. Sequences a1, a2, ..., an and b1, b2, ..., bn are sorted in ascending order, i.e. in the order the participants finished in the corresponding semifinal.\n\nOutput\n\nPrint two strings consisting of n characters, each equals either \"0\" or \"1\". The first line should correspond to the participants of the first semifinal, the second line should correspond to the participants of the second semifinal. The i-th character in the j-th line should equal \"1\" if the i-th participant of the j-th semifinal has any chances to advance to the finals, otherwise it should equal a \"0\".\n\nExamples\n\nInput\n\n4\n9840 9920\n9860 9980\n9930 10020\n10040 10090\n\n\nOutput\n\n1110\n1100\n\n\nInput\n\n4\n9900 9850\n9940 9930\n10000 10020\n10060 10110\n\n\nOutput\n\n1100\n1100\n\nNote\n\nConsider the first sample. Each semifinal has 4 participants. The results of the first semifinal are 9840, 9860, 9930, 10040. The results of the second semifinal are 9920, 9980, 10020, 10090.\n\n  * If k = 0, the finalists are determined by the time only, so players 9840, 9860, 9920 and 9930 advance to the finals. \n  * If k = 1, the winners from both semifinals move to the finals (with results 9840 and 9920), and the other places are determined by the time (these places go to the sportsmen who run the distance in 9860 and 9930 milliseconds). \n  * If k = 2, then first and second places advance from each seminfial, these are participants with results 9840, 9860, 9920 and 9980 milliseconds. ",
        "task_name": "378_B. Semifinals",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nn=int(sys.stdin.readline())\nA=[]\nB=[]\nT=[]\nfor i in range(n):\n    a,b=map(int,sys.stdin.readline().split())\n    A.append(a)\n    B.append(b)\n    T.append((a,i,0))\n    T.append((b,i,1))\nT.sort()\na=[0]*n\nb=[0]*n\nfor i in range(n//2):\n    a[i]=1\n    b[i]=1\nfor i in range(n):\n    if(T[i][-1]==0):\n        a[T[i][1]]=1\n    else:\n        b[T[i][1]]=1\nAns=\"\"\nfor i in range(n):\n    Ans+=str(a[i])\nAns+=\"\\n\"\nfor i in range(n):\n    Ans+=str(b[i])\nsys.stdout.write(Ans)",
        "correct": true,
        "task_id": "0672",
        "depth": 1
    },
    {
        "description": "Ari the monster is not an ordinary monster. She is the hidden identity of Super M, the Byteforces\u2019 superhero. Byteforces is a country that consists of n cities, connected by n - 1 bidirectional roads. Every road connects exactly two distinct cities, and the whole road system is designed in a way that one is able to go from any city to any other city using only the given roads. There are m cities being attacked by humans. So Ari... we meant Super M have to immediately go to each of the cities being attacked to scare those bad humans. Super M can pass from one city to another only using the given roads. Moreover, passing through one road takes her exactly one kron - the time unit used in Byteforces. \n\n<image>\n\nHowever, Super M is not on Byteforces now - she is attending a training camp located in a nearby country Codeforces. Fortunately, there is a special device in Codeforces that allows her to instantly teleport from Codeforces to any city of Byteforces. The way back is too long, so for the purpose of this problem teleportation is used exactly once.\n\nYou are to help Super M, by calculating the city in which she should teleport at the beginning in order to end her job in the minimum time (measured in krons). Also, provide her with this time so she can plan her way back to Codeforces.\n\nInput\n\nThe first line of the input contains two integers n and m (1 \u2264 m \u2264 n \u2264 123456) - the number of cities in Byteforces, and the number of cities being attacked respectively.\n\nThen follow n - 1 lines, describing the road system. Each line contains two city numbers ui and vi (1 \u2264 ui, vi \u2264 n) - the ends of the road i.\n\nThe last line contains m distinct integers - numbers of cities being attacked. These numbers are given in no particular order.\n\nOutput\n\nFirst print the number of the city Super M should teleport to. If there are many possible optimal answers, print the one with the lowest city number.\n\nThen print the minimum possible time needed to scare all humans in cities being attacked, measured in Krons.\n\nNote that the correct answer is always unique.\n\nExamples\n\nInput\n\n7 2\n1 2\n1 3\n1 4\n3 5\n3 6\n3 7\n2 7\n\n\nOutput\n\n2\n3\n\n\nInput\n\n6 4\n1 2\n2 3\n2 4\n4 5\n4 6\n2 4 5 6\n\n\nOutput\n\n2\n4\n\nNote\n\nIn the first sample, there are two possibilities to finish the Super M's job in 3 krons. They are:\n\n<image> and <image>.\n\nHowever, you should choose the first one as it starts in the city with the lower number.",
        "task_name": "592_D. Super M",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from collections import deque\nfrom sys import stdin\n\n#parser\ndef parser():\n    return map(int, stdin.readline().split())\n\ndef DFS_Discriminiting():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    intrudoction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                if attacked_city[u]:\n                    count_attacked_cities_subtree[u]+=1\n                stack.append(u)\n                intrudoction_order.append(u)    \n    for v in intrudoction_order[::-1]:\n        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]\n        if count_attacked_cities_subtree[v]==0:\n            important_cities[v]=False\n\ndef DFS_Heigths():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    intrudoction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                stack.append(u)\n                intrudoction_order.append(u)\n    for v in intrudoction_order[::-1]:\n        if heights1[pi[v]] < heights1[v]+1:\n            heights2[pi[v]]=heights1[pi[v]]\n            heights1[pi[v]]=heights1[v]+1\n        elif heights2[pi[v]]<heights1[v]+1:\n            heights2[pi[v]]=heights1[v]+1\n        #print(v,pi[v],heights1[pi[v]],heights2[pi[v]])    \n\ndef Distance_Root(s):\n    for v in adjacents_list[s]:\n        if heights1[v]+1>distances1[s]:\n            distances1[s]=heights1[v]+1\n            distances2=distances1\n        elif heights1[v]+1>distances2[s]:\n            distances2=heights1[v]+1\n\ndef DFS_Distances():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    stack.append(numbers_of_attacked_cities[0])\n    Distance_Root(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                determinate=False\n                stack.append(u)\n                if heights1[u]+1==distances1[v]:\n                    if heights1[u]+1>distances2[v]:\n                        determinate=True\n                        distances1[u]=max(heights1[u],distances2[v]+1)\n                        if distances1[u]==heights1[u]:\n                            distances2[u]=max(distances2[v]+1,heights2[u])\n                        else:\n                            distances2[u]=heights1[u]\n                if not determinate:\n                    distances1[u]=distances1[v]+1\n                    distances2[u]=heights1[u]\n\ndef BFS(s):\n    distance=[-1 for x in range(n)]\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)\n    return distance\n\n\nn,m=parser()\n#Creando los arrays necesarios para la ejecucion de DFS\n#padres\npi=[0 for x in range(n)]\n#ciudades atacadas en el subarbol\ncount_attacked_cities_subtree=[0 for x in range(n)]\n#ciudad atacada o no atacada\nattacked_city=[False for x in range(n)]\n#ciudades_que_son atacadas o sirven para llegar a las mismas\nimportant_cities=[True for x in range(n)]\n\nadjacents_list=[[] for x in range(n)]\nfor i in range(n-1):\n    v1,v2=parser()\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\n#numero de ciudades atacadas\nnumbers_of_attacked_cities=[x-1 for x in parser()]\n\n#marcando las ciudades atacadas\nfor i in numbers_of_attacked_cities:\n    attacked_city[i]=True\n\nDFS_Discriminiting()\n\nadjacents_list=[[] for x in range(n)]\n\ncount_edges=0\nfor v in range(n):\n    if v==numbers_of_attacked_cities[0]:\n        continue\n    elif important_cities[v] and important_cities[pi[v]]:\n        adjacents_list[v].append(pi[v])\n        adjacents_list[pi[v]].append(v)\n        count_edges+=1\n\n#padres\npi=[0 for x in range(n)]\n\n#alturas\nheights1=[0 for x in range(n)]\nheights2=[0 for x in range(n)]\n\nDFS_Heigths()\n\n#distances\ndistances1=[0 for x in range(n)]\ndistances2=[0 for x in range(n)]\n\nDFS_Distances()\n\nlower=distances1[numbers_of_attacked_cities[0]]\nfor i in range(n):\n    if important_cities[i] and lower>distances1[i]:\n        lower=distances1[i]\n\ncenters=[]\nfor i in range(n):\n    if distances1[i]==lower:\n        centers.append(i)\n\nposibles_begin_cities=[]\n\nfor i in centers:\n    distances_center=BFS(i)\n    max_distance=0\n    for j in range(n):\n        if distances_center[j]>max_distance:\n            max_distance=distances_center[j]\n    for j in range(n):\n        if distances_center[j]==max_distance:\n            posibles_begin_cities.append(j)\n\n\nprint(min(posibles_begin_cities)+1)\n\nprint(2*count_edges-(distances1[centers[0]]+distances2[centers[0]]))",
        "correct": false,
        "task_id": "0677",
        "depth": 2
    },
    {
        "description": "In order to do some research, n^2 labs are built on different heights of a mountain. Let's enumerate them with integers from 1 to n^2, such that the lab with the number 1 is at the lowest place, the lab with the number 2 is at the second-lowest place, \u2026, the lab with the number n^2 is at the highest place.\n\nTo transport water between the labs, pipes are built between every pair of labs. A pipe can transport at most one unit of water at a time from the lab with the number u to the lab with the number v if u > v.\n\nNow the labs need to be divided into n groups, each group should contain exactly n labs. The labs from different groups can transport water to each other. The sum of units of water that can be sent from a group A to a group B is equal to the number of pairs of labs (u, v) such that the lab with the number u is from the group A, the lab with the number v is from the group B and u > v. Let's denote this value as f(A,B) (i.e. f(A,B) is the sum of units of water that can be sent from a group A to a group B).\n\nFor example, if n=3 and there are 3 groups X, Y and Z: X = \\{1, 5, 6\\}, Y = \\{2, 4, 9\\} and Z = \\{3, 7, 8\\}. In this case, the values of f are equal to:\n\n  * f(X,Y)=4 because of 5 \u2192 2, 5 \u2192 4, 6 \u2192 2, 6 \u2192 4, \n  * f(X,Z)=2 because of 5 \u2192 3, 6 \u2192 3, \n  * f(Y,X)=5 because of 2 \u2192 1, 4 \u2192 1, 9 \u2192 1, 9 \u2192 5, 9 \u2192 6, \n  * f(Y,Z)=4 because of 4 \u2192 3, 9 \u2192 3, 9 \u2192 7, 9 \u2192 8, \n  * f(Z,X)=7 because of 3 \u2192 1, 7 \u2192 1, 7 \u2192 5, 7 \u2192 6, 8 \u2192 1, 8 \u2192 5, 8 \u2192 6, \n  * f(Z,Y)=5 because of 3 \u2192 2, 7 \u2192 2, 7 \u2192 4, 8 \u2192 2, 8 \u2192 4. \n\n\n\nPlease, divide labs into n groups with size n, such that the value min f(A,B) over all possible pairs of groups A and B (A \u2260 B) is maximal.\n\nIn other words, divide labs into n groups with size n, such that minimum number of the sum of units of water that can be transported from a group A to a group B for every pair of different groups A and B (A \u2260 B) as big as possible.\n\nNote, that the example above doesn't demonstrate an optimal division, but it demonstrates how to calculate the values f for some division.\n\nIf there are many optimal divisions, you can find any.\n\nInput\n\nThe only line contains one number n (2 \u2264 n \u2264 300).\n\nOutput\n\nOutput n lines:\n\nIn the i-th line print n numbers, the numbers of labs of the i-th group, in any order you want.\n\nIf there are multiple answers, that maximize the minimum number of the sum of units of water that can be transported from one group the another, you can print any.\n\nExample\n\nInput\n\n\n3\n\n\nOutput\n\n\n2 8 5\n9 3 4\n7 6 1\n\nNote\n\nIn the first test we can divide 9 labs into groups \\{2, 8, 5\\}, \\{9, 3, 4\\}, \\{7, 6, 1\\}.\n\nFrom the first group to the second group we can transport 4 units of water (8 \u2192 3, 8 \u2192 4, 5 \u2192 3, 5 \u2192 4).\n\nFrom the first group to the third group we can transport 5 units of water (2 \u2192 1, 8 \u2192 7, 8 \u2192 6, 8 \u2192 1, 5 \u2192 1).\n\nFrom the second group to the first group we can transport 5 units of water (9 \u2192 2, 9 \u2192 8, 9 \u2192 5, 3 \u2192 2, 4 \u2192 2).\n\nFrom the second group to the third group we can transport 5 units of water (9 \u2192 7, 9 \u2192 6, 9 \u2192 1, 3 \u2192 1, 4 \u2192 1).\n\nFrom the third group to the first group we can transport 4 units of water (7 \u2192 2, 7 \u2192 5, 6 \u2192 2, 6 \u2192 5).\n\nFrom the third group to the second group we can transport 4 units of water (7 \u2192 3, 7 \u2192 4, 6 \u2192 3, 6 \u2192 4).\n\nThe minimal number of the sum of units of water, that can be transported from one group to another is equal to 4. It can be proved, that it is impossible to make a better division.",
        "task_name": "1236_C. Labs",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys,math,fractions,bisect\ndef fi():\n    return int(sys.stdin.readline())\n\ndef fi2():\n    return map(int, sys.stdin.readline().split())\n\ndef fi3():\n    return sys.stdin.readline()\n\ndef fo(*args):\n    for s in args:\n        sys.stdout.write(str(s)+' ')\n    sys.stdout.write('\\n')\nINF=2000000000\nMOD=10**9+7\nsys.setrecursionlimit(INF)\n\n#main\nn=fi()\nans=[[] for i in range(n)]\n\nx=1\nstart=0\nwhile x<=n**2:\n    for i in range(start,start+n):\n        ans[i%n].append(x)\n        x+=1\n    start+=1\nfor i in range(n):\n    for j in range(n):\n        ans[i][j]=str(ans[i][j])\nfor i in range(n):\n    fo(\" \".join(ans[i]))\n        \n        \n    \n    \n           \n\n                           \n                \n\n            \n        \n\n        \n        \n        \n    \n    \n    \n            \n\n\n\n\n    \n            \n\n\n    \n\n        \n    \n    \n        \n        \n        \n    \n    \n    \n            \n            \n            \n            \n    \n                \n    \n        \n    \n\n        \n        \n    \n\n\n    \n    \n            \n                \n            \n            \n        \n    \n    \n        \n    \n    \n    \n            \n\n    \n    \n\n\n\n    \n        \n            \n    \n        \n",
        "correct": false,
        "task_id": "0701",
        "depth": 2
    },
    {
        "description": "A colored stripe is represented by a horizontal row of n square cells, each cell is pained one of k colors. Your task is to repaint the minimum number of cells so that no two neighbouring cells are of the same color. You can use any color from 1 to k to repaint the cells.\n\nInput\n\nThe first input line contains two integers n and k (1 \u2264 n \u2264 5\u00b7105; 2 \u2264 k \u2264 26). The second line contains n uppercase English letters. Letter \"A\" stands for the first color, letter \"B\" stands for the second color and so on. The first k English letters may be used. Each letter represents the color of the corresponding cell of the stripe.\n\nOutput\n\nPrint a single integer \u2014 the required minimum number of repaintings. In the second line print any possible variant of the repainted stripe.\n\nExamples\n\nInput\n\n6 3\nABBACC\n\n\nOutput\n\n2\nABCACA\n\n\nInput\n\n3 2\nBBB\n\n\nOutput\n\n1\nBAB",
        "task_name": "219_C. Color Stripe",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#-*-coding=utf8-*-\n\nimport string\n\nn, k = map(int, raw_input().split())\ns = raw_input()\nalpha = string.uppercase[:k]\nans1 = list(s)\nans2 = list(s)\nrec1, rec2 = 0, 0\nfor i in range(0, len(s), 2):\n    neigh = ()\n    if (i > 0):\n        neigh += (s[i - 1], )\n    if (i < n - 1):\n        neigh += (s[i+1], )\n    if (i > 0 and s[i] == s[i - 1] or i < n - 1 and s[i] == s[i + 1]):\n        for c in alpha:\n            if c not in neigh:\n                chosen = c\n                break\n        else:\n            break\n        ans1[i] = chosen\n        rec1 += 1\n\nfor i in range(1, len(s), 2):\n    neigh = ()\n    if (i > 0):\n        neigh += (s[i - 1], )\n    if (i < n - 1):\n        neigh += (s[i + 1], )\n    if (i > 0 and s[i] == s[i - 1] or i < n - 1 and s[i] == s[i + 1]):\n        for c in alpha:\n            if c not in neigh:\n                chosen = c\n                break\n        else:\n            break\n        ans2[i] = chosen\n        rec2 += 1\n\nvalid1 = True\nfor i in range(1, len(ans1)):\n    if ans1[i] == ans1[i - 1]:\n        valid1 = False\n        break\n\nvalid2 = True\nfor i in range(1, len(ans2)):\n    if ans2[i] == ans2[i - 1]:\n        valid2 = False\n        break\n\nif (rec1 < rec2 and valid1 or not valid2):\n    print(rec1)\n    print(''.join(ans1))\nelse:\n    print(rec2)\n    print(''.join(ans2))",
        "correct": false,
        "task_id": "0711",
        "depth": 2
    },
    {
        "description": "You have r red, g green and b blue balloons. To decorate a single table for the banquet you need exactly three balloons. Three balloons attached to some table shouldn't have the same color. What maximum number t of tables can be decorated if we know number of balloons of each color?\n\nYour task is to write a program that for given values r, g and b will find the maximum number t of tables, that can be decorated in the required manner.\n\nInput\n\nThe single line contains three integers r, g and b (0 \u2264 r, g, b \u2264 2\u00b7109) \u2014 the number of red, green and blue baloons respectively. The numbers are separated by exactly one space.\n\nOutput\n\nPrint a single integer t \u2014 the maximum number of tables that can be decorated in the required manner.\n\nExamples\n\nInput\n\n5 4 3\n\n\nOutput\n\n4\n\n\nInput\n\n1 1 1\n\n\nOutput\n\n1\n\n\nInput\n\n2 3 3\n\n\nOutput\n\n2\n\nNote\n\nIn the first sample you can decorate the tables with the following balloon sets: \"rgg\", \"gbb\", \"brr\", \"rrg\", where \"r\", \"g\" and \"b\" represent the red, green and blue balls, respectively.",
        "task_name": "478_C. Table Decorations",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    r, g, b = sorted(map(int, input().split()))\n\n    t = r\n    g -= r\n    b -= r\n\n    t += g // 3\n    b -= g - (g % 3)\n    g = g % 3\n\n    t += ((g == 1) and (b > 1)) + ((g == 2) and (b > 0))\n\n    print(t)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": false,
        "task_id": "0717",
        "depth": 1
    },
    {
        "description": "Polycarp likes to play with numbers. He takes some integer number x, writes it down on the board, and then performs with it n - 1 operations of the two kinds: \n\n  * divide the number x by 3 (x must be divisible by 3); \n  * multiply the number x by 2. \n\n\n\nAfter each operation, Polycarp writes down the result on the board and replaces x by the result. So there will be n numbers on the board after all.\n\nYou are given a sequence of length n \u2014 the numbers that Polycarp wrote down. This sequence is given in arbitrary order, i.e. the order of the sequence can mismatch the order of the numbers written on the board.\n\nYour problem is to rearrange (reorder) elements of this sequence in such a way that it can match possible Polycarp's game in the order of the numbers written on the board. I.e. each next number will be exactly two times of the previous number or exactly one third of previous number.\n\nIt is guaranteed that the answer exists.\n\nInput\n\nThe first line of the input contatins an integer number n (2 \u2264 n \u2264 100) \u2014 the number of the elements in the sequence. The second line of the input contains n integer numbers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 3 \u22c5 10^{18}) \u2014 rearranged (reordered) sequence that Polycarp can wrote down on the board.\n\nOutput\n\nPrint n integer numbers \u2014 rearranged (reordered) input sequence that can be the sequence that Polycarp could write down on the board.\n\nIt is guaranteed that the answer exists.\n\nExamples\n\nInput\n\n6\n4 8 6 3 12 9\n\n\nOutput\n\n9 3 6 12 4 8 \n\n\nInput\n\n4\n42 28 84 126\n\n\nOutput\n\n126 42 84 28 \n\n\nInput\n\n2\n1000000000000000000 3000000000000000000\n\n\nOutput\n\n3000000000000000000 1000000000000000000 \n\nNote\n\nIn the first example the given sequence can be rearranged in the following way: [9, 3, 6, 12, 4, 8]. It can match possible Polycarp's game which started with x = 9.",
        "task_name": "977_D. Divide by three, multiply by two",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\n\nimport sys, math, random, operator\nfrom string import ascii_lowercase, ascii_uppercase\nfrom fractions import Fraction, gcd\n#from decimal import Decimal, getcontext\nfrom itertools import product, permutations, combinations\nfrom Queue import Queue, PriorityQueue\nfrom collections import deque, defaultdict, Counter\n#getcontext().prec = 100\n\nMOD = 10**9 + 7\nINF = float(\"+inf\")\n\nif sys.subversion[0] == \"PyPy\":\n    import io, atexit\n    sys.stdout = io.BytesIO()\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n    sys.stdin = io.BytesIO(sys.stdin.read())\n    raw_input = lambda: sys.stdin.readline().rstrip()\npr = lambda *args: sys.stdout.write(\" \".join(str(x) for x in args) + \"\\n\")\nepr = lambda *args: sys.stderr.write(\" \".join(str(x) for x in args) + \"\\n\")\ndie = lambda *args: pr(*args) ^ exit(0)\n\nread_str = raw_input\nread_strs = lambda: raw_input().split()\nread_int = lambda: int(raw_input())\nread_ints = lambda: map(int, raw_input().split())\nread_float = lambda: float(raw_input())\nread_floats = lambda: map(float, raw_input().split())\n\n\"---------------------------------------------------------------\"\n\nn = read_int()\narr = read_ints()\n\nres = [arr.pop()]\narr = set(arr)\nwhile arr:\n    a = res[0]\n    if a % 2 == 0 and a / 2 in arr:\n        arr.remove(a/2)\n        res = [a/2] + res\n        continue\n    elif a * 3 in arr:\n        arr.remove(a*3)\n        res = [a*3] + res\n        continue\n\n    a = res[-1]\n    if a % 3 == 0 and a / 3 in arr:\n        arr.remove(a/3)\n        res = res + [a/3]\n        continue\n    elif a * 2 in arr:\n        arr.remove(a*2)\n        res = res + [a*2]\n        continue\n\npr(*res)\n",
        "correct": true,
        "task_id": "0727",
        "depth": 1
    },
    {
        "description": "There are N people standing in a queue from west to east.\n\nGiven is a string S of length N representing the directions of the people. The i-th person from the west is facing west if the i-th character of S is `L`, and east if that character of S is `R`.\n\nA person is happy if the person in front of him/her is facing the same direction. If no person is standing in front of a person, however, he/she is not happy.\n\nYou can perform the following operation any number of times between 0 and K (inclusive):\n\nOperation: Choose integers l and r such that 1 \\leq l \\leq r \\leq N, and rotate by 180 degrees the part of the queue: the l-th, (l+1)-th, ..., r-th persons. That is, for each i = 0, 1, ..., r-l, the (l + i)-th person from the west will stand the (r - i)-th from the west after the operation, facing east if he/she is facing west now, and vice versa.\n\nWhat is the maximum possible number of happy people you can have?\n\nConstraints\n\n* N is an integer satisfying 1 \\leq N \\leq 10^5.\n* K is an integer satisfying 1 \\leq K \\leq 10^5.\n* |S| = N\n* Each character of S is `L` or `R`.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN K\nS\n\n\nOutput\n\nPrint the maximum possible number of happy people after at most K operations.\n\nExamples\n\nInput\n\n6 1\nLRLRRL\n\n\nOutput\n\n3\n\n\nInput\n\n13 3\nLRRLRLRRLRLLR\n\n\nOutput\n\n9\n\n\nInput\n\n10 1\nLLLLLRRRRR\n\n\nOutput\n\n9\n\n\nInput\n\n9 2\nRRRLRLRLL\n\n\nOutput\n\n7",
        "task_name": "p02918 AtCoder Beginner Contest 140 - Face Produces Unhappiness",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import math\ninput = raw_input\n\ndef score(s):\n    n = len(s)\n    ans = 0\n    for i in range(n):\n        if s[i] == \"L\" and i >= 1 and s[i-1] == \"L\":\n            ans += 1\n        elif s[i] == \"R\" and i <= n-2 and s[i+1] ==\"R\":\n            ans += 1\n    return ans\n\nN,K = map(int, input().split(\" \"))\nS = list(input())\n\nif S==\"RL\":\n    print(0)\n    exit()\nif S==\"LR\":\n    print(0)\n    exit()\nif S==\"RLR\" or S==\"LRL\":\n    if K == 1:\n        print(1)\n        exit()\n    else:\n        print(2)\n        exit()\n\ns = score(S)\nk = 0\nlr = 0\nrl = 0\nfor i in range(N-1):\n    if S[i] == \"L\" and S[i+1] ==\"R\":\n        lr += 1\n    if S[i] == \"R\" and S[i+1] ==\"L\":\n        rl += 1\nlrl = 0\nrlr = 0\nfor i in range(N-2):\n    if S[i] == \"L\" and S[i+1] ==\"R\" and S[i+2] ==\"L\":\n        lrl += 1\n    if S[i] == \"R\" and S[i+1] ==\"L\" and S[i+2] ==\"R\":\n        rlr += 1\n\nif (lrl == 1 and rl == 1 and lr == 1) or (rlr == 1 and rl == 1 and lr == 1):\n    if K >= 2:\n        print(s+2)\n        exit()\n    elif K == 1:\n        print(s+1)\n        exit()\n    else:\n        print(s)\n        exit()\n\n#print(s)\n#print(lr, rl)\nc = min(K, lr, rl)\ns += 2 * c\nif K > min(lr, rl):\n    if S[0] == \"L\" and rl > lr:\n        s += 1\n    elif S[-1] == \"R\" and rl < lr:\n        s += 1\nprint(s)\n",
        "correct": false,
        "task_id": "0730",
        "depth": 1
    },
    {
        "description": "We have a rectangular grid of squares with H horizontal rows and W vertical columns. Let (i,j) denote the square at the i-th row from the top and the j-th column from the left. On this grid, there is a piece, which is initially placed at square (s_r,s_c).\n\nTakahashi and Aoki will play a game, where each player has a string of length N. Takahashi's string is S, and Aoki's string is T. S and T both consist of four kinds of letters: `L`, `R`, `U` and `D`.\n\nThe game consists of N steps. The i-th step proceeds as follows:\n\n* First, Takahashi performs a move. He either moves the piece in the direction of S_i, or does not move the piece.\n* Second, Aoki performs a move. He either moves the piece in the direction of T_i, or does not move the piece.\n\n\n\nHere, to move the piece in the direction of `L`, `R`, `U` and `D`, is to move the piece from square (r,c) to square (r,c-1), (r,c+1), (r-1,c) and (r+1,c), respectively. If the destination square does not exist, the piece is removed from the grid, and the game ends, even if less than N steps are done.\n\nTakahashi wants to remove the piece from the grid in one of the N steps. Aoki, on the other hand, wants to finish the N steps with the piece remaining on the grid. Determine if the piece will remain on the grid at the end of the game when both players play optimally.\n\nConstraints\n\n* 2 \\leq H,W \\leq 2 \\times 10^5\n* 2 \\leq N \\leq 2 \\times 10^5\n* 1 \\leq s_r \\leq H\n* 1 \\leq s_c \\leq W\n* |S|=|T|=N\n* S and T consists of the four kinds of letters `L`, `R`, `U` and `D`.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nH W N\ns_r s_c\nS\nT\n\n\nOutput\n\nIf the piece will remain on the grid at the end of the game, print `YES`; otherwise, print `NO`.\n\nExamples\n\nInput\n\n2 3 3\n2 2\nRRL\nLUD\n\n\nOutput\n\nYES\n\n\nInput\n\n4 3 5\n2 2\nUDRRR\nLLDUD\n\n\nOutput\n\nNO\n\n\nInput\n\n5 6 11\n2 1\nRLDRRUDDLRL\nURRDRLLDLRD\n\n\nOutput\n\nNO",
        "task_name": "p03054 AtCoder Grand Contest 033 - LRUD Game",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "H,W,N = map(int, raw_input().split())\nsr,sc = map(int, raw_input().split())\nS = raw_input()\nT = raw_input()\nAO = [1,W,1,H]\nflag = 0\nfor i in reversed(range(N)):\n\tif(i != N-1):\n\t\tif(T[i] == 'L'):\n\t\t\tAO[1] = min(W,AO[1]+1)\n\t\telif(T[i] == 'R'):\n\t\t\tAO[0] = max(1,AO[0]-1)\n\t\telif(T[i] == 'U'):\n\t\t\tAO[3] = min(H,AO[3]+1)\n\t\telif(T[i] == 'D'):\n\t\t\tAO[2] = max(1,AO[2]-1)\n\tif(S[i] == 'L'):\n\t\tAO[0] += 1\n\telif(S[i] == 'R'):\n\t\tAO[1] -= 1\n\telif(S[i] == 'U'):\n\t\tAO[2] += 1\n\telif(S[i] == 'D'):\n\t\tAO[3] -= 1\n\tif(AO[0] > AO[1] or AO[2] > AO[3]):\n\t\tflag = 1\n\t\tbreak\nif(AO[0] > sc or AO[1] < sc or AO[2] > sr or AO[3] < sr):\n\tflag = 1\nif(flag == 0):\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")",
        "correct": true,
        "task_id": "0731",
        "depth": 1
    },
    {
        "description": "There are an integer sequence A_1,...,A_N consisting of N terms, and N buttons. When the i-th (1 \u2266 i \u2266 N) button is pressed, the values of the i terms from the first through the i-th are all incremented by 1.\n\nThere is also another integer sequence B_1,...,B_N. Takahashi will push the buttons some number of times so that for every i, A_i will be a multiple of B_i.\n\nFind the minimum number of times Takahashi will press the buttons.\n\nConstraints\n\n* All input values are integers.\n* 1 \u2266 N \u2266 10^5\n* 0 \u2266 A_i \u2266 10^9(1 \u2266 i \u2266 N)\n* 1 \u2266 B_i \u2266 10^9(1 \u2266 i \u2266 N)\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN\nA_1 B_1\n:\nA_N B_N\n\n\nOutput\n\nPrint an integer representing the minimum number of times Takahashi will press the buttons.\n\nExamples\n\nInput\n\n3\n3 5\n2 7\n9 4\n\n\nOutput\n\n7\n\n\nInput\n\n7\n3 1\n4 1\n5 9\n2 6\n5 3\n5 8\n9 7\n\n\nOutput\n\n22",
        "task_name": "p03821 AtCoder Grand Contest 009 - Multiple Array",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n=int(raw_input())\nab=[map(int,raw_input().split()) for _ in xrange(n)]\ncnt=0\nfor i in xrange(n-1,-1,-1):\n    a,b=ab[i][0],ab[i][1]\n    if (a+cnt)%b==0:continue\n    cnt+=b-(a+cnt)%b\nprint(cnt)",
        "correct": true,
        "task_id": "0735",
        "depth": 1
    },
    {
        "description": "Alice and Bob are playing a game on a line with n cells. There are n cells labeled from 1 through n. For each i from 1 to n-1, cells i and i+1 are adjacent.\n\nAlice initially has a token on some cell on the line, and Bob tries to guess where it is. \n\nBob guesses a sequence of line cell numbers x_1, x_2, \u2026, x_k in order. In the i-th question, Bob asks Alice if her token is currently on cell x_i. That is, Alice can answer either \"YES\" or \"NO\" to each Bob's question.\n\nAt most one time in this process, before or after answering a question, Alice is allowed to move her token from her current cell to some adjacent cell. Alice acted in such a way that she was able to answer \"NO\" to all of Bob's questions.\n\nNote that Alice can even move her token before answering the first question or after answering the last question. Alice can also choose to not move at all.\n\nYou are given n and Bob's questions x_1, \u2026, x_k. You would like to count the number of scenarios that let Alice answer \"NO\" to all of Bob's questions. \n\nLet (a,b) denote a scenario where Alice starts at cell a and ends at cell b. Two scenarios (a_i, b_i) and (a_j, b_j) are different if a_i \u2260 a_j or b_i \u2260 b_j.\n\nInput\n\nThe first line contains two integers n and k (1 \u2264 n,k \u2264 10^5) \u2014 the number of cells and the number of questions Bob asked.\n\nThe second line contains k integers x_1, x_2, \u2026, x_k (1 \u2264 x_i \u2264 n) \u2014 Bob's questions.\n\nOutput\n\nPrint a single integer, the number of scenarios that let Alice answer \"NO\" to all of Bob's questions.\n\nExamples\n\nInput\n\n\n5 3\n5 1 4\n\n\nOutput\n\n\n9\n\n\nInput\n\n\n4 8\n1 2 3 4 4 3 2 1\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n100000 1\n42\n\n\nOutput\n\n\n299997\n\nNote\n\nThe notation (i,j) denotes a scenario where Alice starts at cell i and ends at cell j.\n\nIn the first example, the valid scenarios are (1, 2), (2, 1), (2, 2), (2, 3), (3, 2), (3, 3), (3, 4), (4, 3), (4, 5). For example, (3,4) is valid since Alice can start at cell 3, stay there for the first three questions, then move to cell 4 after the last question. \n\n(4,5) is valid since Alice can start at cell 4, stay there for the first question, the move to cell 5 for the next two questions. Note that (4,5) is only counted once, even though there are different questions that Alice can choose to do the move, but remember, we only count each pair of starting and ending positions once.\n\nIn the second example, Alice has no valid scenarios.\n\nIn the last example, all (i,j) where |i-j| \u2264 1 except for (42, 42) are valid scenarios.",
        "task_name": "1147_A. Hide and Seek",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\"\"\"<https://github.com/cheran-senthil/PyRival>\"\"\"\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    _str = str\n    str = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\n\n\ndef main():\n    n, k = readlist()\n    x = readlist()\n\n    counter = [(-1, -1)] * (n + 1)\n    for i, xi in enumerate(x):\n        if counter[xi][0] == -1:\n            counter[xi] = (i, -1)\n        else:\n            counter[xi] = (counter[xi][0], i)\n\n    res = 0\n    for i in range(1, n + 1):\n        if counter[i][0] == -1:\n            res += 1\n\n    for i in range(1, n):\n        if counter[i][0] != -1:\n            if counter[i][1] != -1:\n                if counter[i + 1][0] == -1 or counter[i + 1][0] > counter[i][1]:\n                    res += 1\n            else:\n                if counter[i + 1][0] == -1 or counter[i + 1][0] > counter[i][0]:\n                    res += 1\n        else:\n            res += 1\n\n    for i in range(1, n):\n        if counter[i + 1][0] != -1:\n            if counter[i + 1][1] != -1:\n                if counter[i][0] == -1 or counter[i][0] > counter[i + 1][1]:\n                    res += 1\n            else:\n                if counter[i][0] == -1 or counter[i][0] > counter[i + 1][0]:\n                    res += 1\n        else:\n            res += 1\n\n    print(res)\n\n\n# region template\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._buffer = BytesIO()\n        self._fd = file.fileno()\n        self._writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self._buffer.write if self._writable else None\n\n    def read(self):\n        if self._buffer.tell():\n            return self._buffer.read()\n        return os.read(self._fd, os.fstat(self._fd).st_size)\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n    def flush(self):\n        if self._writable:\n            os.write(self._fd, self._buffer.getvalue())\n            self._buffer.truncate(0), self._buffer.seek(0)\n\n\nclass ostream:\n    def __lshift__(self, a):\n        if a is endl:\n            sys.stdout.write(b\"\\n\")\n            sys.stdout.flush()\n        else:\n            sys.stdout.write(str(a))\n        return self\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", b\" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", b\"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\ncout, endl = ostream(), object()\n\nreadline = sys.stdin.readline\nreadlist = lambda var=int: [var(n) for n in readline().split()]\ninput = lambda: readline().rstrip(b\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "0740",
        "depth": 1
    },
    {
        "description": "You are given k sequences of integers. The length of the i-th sequence equals to n_i.\n\nYou have to choose exactly two sequences i and j (i \u2260 j) such that you can remove exactly one element in each of them in such a way that the sum of the changed sequence i (its length will be equal to n_i - 1) equals to the sum of the changed sequence j (its length will be equal to n_j - 1).\n\nNote that it's required to remove exactly one element in each of the two chosen sequences.\n\nAssume that the sum of the empty (of the length equals 0) sequence is 0.\n\nInput\n\nThe first line contains an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of sequences.\n\nThen k pairs of lines follow, each pair containing a sequence.\n\nThe first line in the i-th pair contains one integer n_i (1 \u2264 n_i < 2 \u22c5 10^5) \u2014 the length of the i-th sequence. The second line of the i-th pair contains a sequence of n_i integers a_{i, 1}, a_{i, 2}, ..., a_{i, n_i}.\n\nThe elements of sequences are integer numbers from -10^4 to 10^4.\n\nThe sum of lengths of all given sequences don't exceed 2 \u22c5 10^5, i.e. n_1 + n_2 + ... + n_k \u2264 2 \u22c5 10^5.\n\nOutput\n\nIf it is impossible to choose two sequences such that they satisfy given conditions, print \"NO\" (without quotes). Otherwise in the first line print \"YES\" (without quotes), in the second line \u2014 two integers i, x (1 \u2264 i \u2264 k, 1 \u2264 x \u2264 n_i), in the third line \u2014 two integers j, y (1 \u2264 j \u2264 k, 1 \u2264 y \u2264 n_j). It means that the sum of the elements of the i-th sequence without the element with index x equals to the sum of the elements of the j-th sequence without the element with index y.\n\nTwo chosen sequences must be distinct, i.e. i \u2260 j. You can print them in any order.\n\nIf there are multiple possible answers, print any of them.\n\nExamples\n\nInput\n\n2\n5\n2 3 1 3 2\n6\n1 1 2 2 2 1\n\n\nOutput\n\nYES\n2 6\n1 2\n\n\nInput\n\n3\n1\n5\n5\n1 1 1 1 1\n2\n2 3\n\n\nOutput\n\nNO\n\n\nInput\n\n4\n6\n2 2 2 2 2 2\n5\n2 2 2 2 2\n3\n2 2 2\n5\n2 2 2 2 2\n\n\nOutput\n\nYES\n2 2\n4 1\n\nNote\n\nIn the first example there are two sequences [2, 3, 1, 3, 2] and [1, 1, 2, 2, 2, 1]. You can remove the second element from the first sequence to get [2, 1, 3, 2] and you can remove the sixth element from the second sequence to get [1, 1, 2, 2, 2]. The sums of the both resulting sequences equal to 8, i.e. the sums are equal.",
        "task_name": "988_C. Equal Sums",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "k = int(raw_input())\n\ntk = dict()\n\njam = []\nflag = 0\nfor l in range(k):\n    ni = int(raw_input())\n    arr = list(map(int,raw_input().split()))\n    jam.append(arr)\n    s = sum(arr)\n    sk = list(set(arr))\n    for i in sk:\n        tk[i-s] = tk.get(i-s,[])\n        tk[i-s].append((l,arr.index(i)+1))\n        if len(tk[i-s]) > 1:\n            if jam[tk[i-s][0][0]] != jam[tk[i-s][1][0]]:\n                print(\"YES\")\n                print(str(tk[i-s][0][0]+1)+\" \"+str(tk[i-s][0][1]))\n                print(str(tk[i-s][1][0]+1)+\" \"+str(tk[i-s][1][1]))\n                exit(0)\n\nif not flag :\n    print(\"NO\")\n\n",
        "correct": false,
        "task_id": "0761",
        "depth": 2
    },
    {
        "description": "Write a program which reads $n$ dices constructed in the same way as Dice I, and determines whether they are all different. For the determination, use the same way as Dice III.\n\nConstraints\n\n* $2 \\leq n \\leq 100$\n* $0 \\leq $ the integer assigned to a face $ \\leq 100$\n\nInput\n\nIn the first line, the number of dices $n$ is given. In the following $n$ lines, six integers assigned to the dice faces are given respectively in the same way as Dice III.\n\nOutput\n\nPrint \"Yes\" if given dices are all different, otherwise \"No\" in a line.\n\nExamples\n\nInput\n\n3\n1 2 3 4 5 6\n6 2 4 3 5 1\n6 5 4 3 2 1\n\n\nOutput\n\nNo\n\n\nInput\n\n3\n1 2 3 4 5 6\n6 5 4 3 2 1\n5 4 3 2 1 6\n\n\nOutput\n\nYes",
        "task_name": "p02386 Dice IV",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "class Dice(object):\n    \"\"\"Dice Class\n\n    \"\"\"\n\n    def __init__(self, numbers):\n        \"\"\"\n\n        Args:\n            numbers:\n        \"\"\"\n        self.numbers_inverse = {numbers[0]: 1, numbers[1]: 2, numbers[2]: 3, numbers[3]: 4, numbers[4]: 5,\n                                numbers[5]: 6}\n        self.numbers = {1: numbers[0], 2: numbers[1], 3: numbers[2], 4: numbers[3], 5: numbers[4], 6: numbers[5]}\n\n        self.vertical = [self.numbers[1], self.numbers[2], self.numbers[6], self.numbers[5]]\n        self.horizontal = [self.numbers[4], self.numbers[1], self.numbers[3], self.numbers[6]]\n\n    def roll_dice(self, str):\n        \"\"\"\n\n        Args:\n            str: move direction\n\n        Returns:\n\n        \"\"\"\n        for s in str:\n            if s == 'N':\n                self.move_north()\n            elif s == 'S':\n                self.move_south()\n            elif s == 'W':\n                self.move_west()\n            elif s == 'E':\n                self.move_east()\n\n    def set_top(self, value):\n        \"\"\"\n        Args:\n            value: target_value\n        \"\"\"\n        counter = 0\n        while counter < 4:\n            if self.vertical[0] == value:\n                self.map_values()\n                return\n            else:\n                self.roll_dice(\"S\")\n            counter += 1\n        counter = 0\n        while counter < 4:\n            if self.vertical[0] == value:\n                self.map_values()\n                return\n            else:\n                self.roll_dice(\"W\")\n            counter += 1\n\n    def set_front(self, value):\n        \"\"\"\n        Args:\n            value: target value\n        \"\"\"\n        counter = 0\n        while counter < 4:\n            if self.vertical[1] == value:\n                self.map_values()\n                return\n            else:\n                self.roll_dice(\"SWN\")\n            counter += 1\n\n    def move_south(self):\n        \"\"\"move this dice towered north\n        \"\"\"\n        self.vertical = (self.vertical * 2)[3:7]\n        self.horizontal[1] = self.vertical[0]\n        self.horizontal[3] = self.vertical[2]\n        self.map_values()\n\n    def move_north(self):\n        \"\"\"move this dice towered south\n        \"\"\"\n        self.vertical = (self.vertical * 2)[1:5]\n        self.horizontal[1] = self.vertical[0]\n        self.horizontal[3] = self.vertical[2]\n        self.map_values()\n\n    def move_east(self):\n        \"\"\"move this dice towered east\n        \"\"\"\n        self.horizontal = (self.horizontal * 2)[3:7]\n        self.vertical[0] = self.horizontal[1]\n        self.vertical[2] = self.horizontal[3]\n        self.map_values()\n\n    def move_west(self):\n        \"\"\"move this dice towered west\n        \"\"\"\n        self.horizontal = (self.horizontal * 2)[1:5]\n        self.vertical[0] = self.horizontal[1]\n        self.vertical[2] = self.horizontal[3]\n        self.map_values()\n\n    def map_values(self):\n        self.numbers[1] = self.vertical[0]\n        self.numbers[2] = self.vertical[1]\n        self.numbers[3] = self.horizontal[2]\n        self.numbers[4] = self.horizontal[0]\n        self.numbers[5] = self.vertical[3]\n        self.numbers[6] = self.vertical[2]\n\n    def get_top(self):\n        return self.vertical[0]\n\n\ndef is_same(dice1, dice2):\n    \"\"\"compare two dices\n\n    Args:\n        dice1: dice1\n        dice2: dice2\n\n    Returns:\n        Bool (whether dice1 is equals to be dice2 or not)\n    \"\"\"\n    flag = False\n    if dice1.numbers == dice2.numbers:\n        flag = True\n    else:\n        for i in range(6):\n            dice1.set_top(i + 1)\n            for j in xrange(4):\n                dice1.roll_dice(\"SWN\")\n                if dice1.numbers == dice2.numbers:\n                    flag = True\n            dice1.roll_dice(\"S\")\n\n    return flag\n\n\ndice_number = int(raw_input())\ndices = []\ncounter = 0\nwhile counter < dice_number:\n    dices.append(Dice([int(x) for x in raw_input().split()]))\n    counter += 1\n\nans = 0\nfor i in range(dice_number - 1):\n    if ans > 0:\n        break\n    for j in range(i + 1, dice_number):\n        ans += int(is_same(dices[i], dices[j]))\n        if ans > 0:\n            print(\"No\")\n            break\n\nif ans == 0:\n    print(\"Yes\")",
        "correct": true,
        "task_id": "0769",
        "depth": 2
    },
    {
        "description": "Pinkie Pie has bought a bag of patty-cakes with different fillings! But it appeared that not all patty-cakes differ from one another with filling. In other words, the bag contains some patty-cakes with the same filling.\n\nPinkie Pie eats the patty-cakes one-by-one. She likes having fun so she decided not to simply eat the patty-cakes but to try not to eat the patty-cakes with the same filling way too often. To achieve this she wants the minimum distance between the eaten with the same filling to be the largest possible. Herein Pinkie Pie called the distance between two patty-cakes the number of eaten patty-cakes strictly between them.\n\nPinkie Pie can eat the patty-cakes in any order. She is impatient about eating all the patty-cakes up so she asks you to help her to count the greatest minimum distance between the eaten patty-cakes with the same filling amongst all possible orders of eating!\n\nPinkie Pie is going to buy more bags of patty-cakes so she asks you to solve this problem for several bags!\n\nInput\n\nThe first line contains a single integer T (1 \u2264 T \u2264 100): the number of bags for which you need to solve the problem.\n\nThe first line of each bag description contains a single integer n (2 \u2264 n \u2264 10^5): the number of patty-cakes in it. The second line of the bag description contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n): the information of patty-cakes' fillings: same fillings are defined as same integers, different fillings are defined as different integers. It is guaranteed that each bag contains at least two patty-cakes with the same filling. \n\nIt is guaranteed that the sum of n over all bags does not exceed 10^5.\n\nOutput\n\nFor each bag print in separate line one single integer: the largest minimum distance between the eaten patty-cakes with the same filling amongst all possible orders of eating for that bag.\n\nExample\n\nInput\n\n\n4\n7\n1 7 1 6 4 4 6\n8\n1 1 4 6 4 6 4 7\n3\n3 3 3\n6\n2 5 2 3 1 4\n\n\nOutput\n\n\n3\n2\n0\n4\n\nNote\n\nFor the first bag Pinkie Pie can eat the patty-cakes in the following order (by fillings): 1, 6, 4, 7, 1, 6, 4 (in this way, the minimum distance is equal to 3).\n\nFor the second bag Pinkie Pie can eat the patty-cakes in the following order (by fillings): 1, 4, 6, 7, 4, 1, 6, 4 (in this way, the minimum distance is equal to 2).",
        "task_name": "1393_C. Pinkie Pie Eats Patty-cakes",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"\n// Author : snape_here - Susanta Mukherjee\n     \n \"\"\"\n \nfrom __future__ import division, print_function\n \nimport os,sys\nfrom io import BytesIO, IOBase\n \nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n \ndef ii(): return int(input())\ndef fi(): return float(input())\ndef si(): return input()\ndef msi(): return map(str,input().split())\ndef mi(): return map(int,input().split())\ndef li(): return list(mi())\n \n \ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n \ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x*y)//(gcd(x,y))\n\nmod=1000000007 \n\ndef modInverse(b,m): \n    g = gcd(b, m)  \n    if (g != 1):         \n        return -1\n    else:          \n        return pow(b, m - 2, m) \n\ndef modu(a,b,m): \n\n    a = a % m \n    inv = modInverse(b,m) \n    if(inv == -1): \n        return -999999999\n    else: \n        return (inv*a)%m\n\nfrom math import log,sqrt,factorial,cos,tan,sin,radians,ceil,floor\n\nimport bisect\n\nfrom decimal import *\n\ngetcontext().prec = 25\n\nabc=\"abcdefghijklmnopqrstuvwxyz\"\n\npi=3.141592653589793238\n\ndef main():\n\n    for _ in range(ii()):\n        n=ii()\n        a=li()\n        a.sort(reverse=True)\n        f=[0]*100005\n        for i in range(n):\n            f[a[i]]+=1 \n        s=0\n        s=max(f)\n\n        if s==n:\n            print(0)\n            continue\n\n        if f.count(1)==n-s:\n            if s==2:\n                ans=n-s\n            else:\n                ans=(n-1)//(s+1)\n                ans+=1\n            print(ans)\n            continue\n\n        ans=(n-1)//(s+1)\n        ans+=1 \n        print(ans)\n\n\n\n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \n \nif __name__ == \"__main__\":\n    #read()\n    main()",
        "correct": false,
        "task_id": "0781",
        "depth": 2
    },
    {
        "description": "The new ITone 6 has been released recently and George got really keen to buy it. Unfortunately, he didn't have enough money, so George was going to work as a programmer. Now he faced the following problem at the work.\n\nGiven a sequence of n integers p1, p2, ..., pn. You are to choose k pairs of integers:\n\n[l1, r1], [l2, r2], ..., [lk, rk] (1 \u2264 l1 \u2264 r1 < l2 \u2264 r2 < ... < lk \u2264 rk \u2264 n; ri - li + 1 = m), \n\nin such a way that the value of sum <image> is maximal possible. Help George to cope with the task.\n\nInput\n\nThe first line contains three integers n, m and k (1 \u2264 (m \u00d7 k) \u2264 n \u2264 5000). The second line contains n integers p1, p2, ..., pn (0 \u2264 pi \u2264 109).\n\nOutput\n\nPrint an integer in a single line \u2014 the maximum possible value of sum.\n\nExamples\n\nInput\n\n5 2 1\n1 2 3 4 5\n\n\nOutput\n\n9\n\n\nInput\n\n7 1 3\n2 10 7 18 5 33 0\n\n\nOutput\n\n61",
        "task_name": "467_C. George and Job",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n# import threading\n# threading.stack_size(2**27)\n# import sys\n# sys.setrecursionlimit(10**7)\nfrom sys import stdin, stdout\nimport bisect            #c++ upperbound\nimport math\nimport heapq\ni_m=9223372036854775807\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef cin():\n    return map(int,sin().split())\ndef ain():                           #takes array as input\n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input())\nimport math  \ndef GCD(x, y): \n    x=abs(x)\n    y=abs(y)\n    if(min(x,y)==0):\n        return max(x,y)\n    while(y): \n        x, y = y, x % y \n    return x \ndef Divisors(n) : \n    l = []  \n    for i in range(1, int(math.sqrt(n) + 1)) :\n        if (n % i == 0) : \n            if (n // i == i) : \n                l.append(i) \n            else : \n                l.append(i)\n                l.append(n//i)\n    return l\n \n\ndef SieveOfEratosthenes(n): \n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n    f=[]\n    for p in range(2, n): \n        if prime[p]: \n            f.append(p)\n    return f\nq=[]       \ndef dfs(n,d,v,c):\n    global q\n    v[n]=1\n    x=d[n]\n    q.append(n)\n    j=c\n    for i in x:\n        if i not in v:\n            f=dfs(i,d,v,c+1)\n            j=max(j,f)\n            # print(f)\n    return j\n  \n\"\"\"*******************************************************\"\"\"\ndef main():\n    n,m,k=cin()\n    a=ain()\n    b=[0]\n    b.append(a[0])\n    if m==1:\n        a.sort(reverse=True)\n        print(sum(a[:k]))\n        sys.exit()\n    for i in range(1,n):\n        b.append(a[i]+b[-1])\n    d=[[0]*n]\n    for i in range(1,k+1):\n        dd=[]\n        p=0\n        for j in range(n+1):\n            if j<m:\n                dd.append(0)\n            else:\n                f=d[i-1][j-m]+b[j]-b[j-m]\n                p=max(f,p)\n                dd.append(p)\n        d.append(dd)\n    # print(d)\n    print(max(d[-1]))\n    # # print(d)\n    # m=-i_m\n    # for i in d:\n    #     m=max(m,i[0])\n    # print(m)\n\n\n######## Python 2 and 3 footer by Pajenegod and c1729\n \n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n \n# So on cf, use PyPy2 for best string performance.\n \npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n \nimport os, sys\nfrom io import IOBase, BytesIO\n \nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'R' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'R' [0]:\n        A.append(sign*numb)\n    return A\n \n# threading.Thread(target=main).start()\nif __name__== \"__main__\":\n  main()",
        "correct": true,
        "task_id": "0792",
        "depth": 2
    },
    {
        "description": "You have an array a of length n. For every positive integer x you are going to perform the following operation during the x-th second:\n\n  * Select some distinct indices i_{1}, i_{2}, \u2026, i_{k} which are between 1 and n inclusive, and add 2^{x-1} to each corresponding position of a. Formally, a_{i_{j}} := a_{i_{j}} + 2^{x-1} for j = 1, 2, \u2026, k. Note that you are allowed to not select any indices at all.\n\n\n\nYou have to make a nondecreasing as fast as possible. Find the smallest number T such that you can make the array nondecreasing after at most T seconds.\n\nArray a is nondecreasing if and only if a_{1} \u2264 a_{2} \u2264 \u2026 \u2264 a_{n}.\n\nYou have to answer t independent test cases.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^{4}) \u2014 the number of test cases.\n\nThe first line of each test case contains single integer n (1 \u2264 n \u2264 10^{5}) \u2014 the length of array a. It is guaranteed that the sum of values of n over all test cases in the input does not exceed 10^{5}.\n\nThe second line of each test case contains n integers a_{1}, a_{2}, \u2026, a_{n} (-10^{9} \u2264 a_{i} \u2264 10^{9}).\n\nOutput\n\nFor each test case, print the minimum number of seconds in which you can make a nondecreasing.\n\nExample\n\nInput\n\n\n3\n4\n1 7 6 5\n5\n1 2 3 4 5\n2\n0 -4\n\n\nOutput\n\n\n2\n0\n3\n\nNote\n\nIn the first test case, if you select indices 3, 4 at the 1-st second and 4 at the 2-nd second, then a will become [1, 7, 7, 8]. There are some other possible ways to make a nondecreasing in 2 seconds, but you can't do it faster.\n\nIn the second test case, a is already nondecreasing, so answer is 0.\n\nIn the third test case, if you do nothing at first 2 seconds and select index 2 at the 3-rd second, a will become [0, 0].",
        "task_name": "1339_C. Powered Addition",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    t = int(input())\n\n    for _ in range(t):\n        n = int(input())\n        a = [int(i) for i in input().split()]\n\n        mx = 0\n\n        p = a[0]\n        for i in range(1, n):\n            if a[i] < p:\n                mx = max(mx, (p - a[i]).bit_length())\n                a[i] = p\n\n            p = a[i]\n\n        print(mx)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "0818",
        "depth": 2
    },
    {
        "description": "Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.\n\nPetya loves long lucky numbers very much. He is interested in the minimum lucky number d that meets some condition. Let cnt(x) be the number of occurrences of number x in number d as a substring. For example, if d = 747747, then cnt(4) = 2, cnt(7) = 4, cnt(47) = 2, cnt(74) = 2. Petya wants the following condition to fulfil simultaneously: cnt(4) = a1, cnt(7) = a2, cnt(47) = a3, cnt(74) = a4. Petya is not interested in the occurrences of other numbers. Help him cope with this task.\n\nInput\n\nThe single line contains four integers a1, a2, a3 and a4 (1 \u2264 a1, a2, a3, a4 \u2264 106).\n\nOutput\n\nOn the single line print without leading zeroes the answer to the problem \u2014 the minimum lucky number d such, that cnt(4) = a1, cnt(7) = a2, cnt(47) = a3, cnt(74) = a4. If such number does not exist, print the single number \"-1\" (without the quotes).\n\nExamples\n\nInput\n\n2 2 1 1\n\n\nOutput\n\n4774\n\n\nInput\n\n4 7 3 1\n\n\nOutput\n\n-1",
        "task_name": "146_D. Lucky Number 2",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\na = [int(x) for x in stdin.readline().split()]\nif abs(a[2] - a[3]) > 1:\n    print(-1)\nelse:\n    tem, tem2 = ['4'], ['7']\n    four, seven = 1, 0\n    four2, seven2 = 0, 1\n    for i in range(a[2] + a[3]):\n        if i & 1:\n            tem.append('4')\n            tem2.append('7')\n            four += 1\n            seven2 += 1\n        else:\n            tem.append('7')\n            tem2.append('4')\n            four2 += 1\n            seven += 1\n\n    if (four > a[0] or seven > a[1]) and (four2 > a[0] or seven2 > a[1]):\n        print(-1)\n    else:\n        if (four > a[0] or seven > a[1]) or a[2] < a[3]:\n            tem, four, seven = tem2, four2, seven2\n\n        # print(tem)\n        ext4, ext7 = '4' * (a[0] - four), '7' * (a[1] - seven)\n        if tem[-1] == '7':\n            print('%s%s%s%s' % (tem[0], ext4, ''.join(tem[1:]), ext7))\n        else:\n            print('%s%s%s%s%s' % (tem[0], ext4, ''.join(tem[1:-1]), ext7, tem[-1]))\n",
        "correct": true,
        "task_id": "0823",
        "depth": 1
    },
    {
        "description": "You are given a sequence of numbers a1, a2, ..., an, and a number m.\n\nCheck if it is possible to choose a non-empty subsequence aij such that the sum of numbers in this subsequence is divisible by m.\n\nInput\n\nThe first line contains two numbers, n and m (1 \u2264 n \u2264 106, 2 \u2264 m \u2264 103) \u2014 the size of the original sequence and the number such that sum should be divisible by it.\n\nThe second line contains n integers a1, a2, ..., an (0 \u2264 ai \u2264 109).\n\nOutput\n\nIn the single line print either \"YES\" (without the quotes) if there exists the sought subsequence, or \"NO\" (without the quotes), if such subsequence doesn't exist.\n\nExamples\n\nInput\n\n3 5\n1 2 3\n\n\nOutput\n\nYES\n\n\nInput\n\n1 6\n5\n\n\nOutput\n\nNO\n\n\nInput\n\n4 6\n3 1 1 3\n\n\nOutput\n\nYES\n\n\nInput\n\n6 6\n5 5 5 5 5 5\n\n\nOutput\n\nYES\n\nNote\n\nIn the first sample test you can choose numbers 2 and 3, the sum of which is divisible by 5.\n\nIn the second sample test the single non-empty subsequence of numbers is a single number 5. Number 5 is not divisible by 6, that is, the sought subsequence doesn't exist.\n\nIn the third sample test you need to choose two numbers 3 on the ends.\n\nIn the fourth sample test you can take the whole subsequence.",
        "task_name": "577_B. Modulo Sum",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"\n________        _____________              ______\n___  __ \\____  ____  __ \\__(_)__   _______ ___  /\n__  /_/ /_  / / /_  /_/ /_  /__ | / /  __ `/_  /\n_  ____/_  /_/ /_  _, _/_  / __ |/ // /_/ /_  /\n/_/     _\\__, / /_/ |_| /_/  _____/ \\__,_/ /_/\n        /____/\n\nhttps://github.com/Cheran-Senthil/PyRival\nCopyright (c) 2018 Cheran Senthilkumar\n\"\"\"\nfrom __future__ import division, print_function\n\nimport cmath\nimport itertools\nimport math\nimport operator as op\nimport sys\nfrom atexit import register\nfrom bisect import bisect_left, bisect_right\n\n# import random\n# from collections import Counter, MutableSequence, defaultdict, deque\n# from copy import deepcopy\n# from decimal import Decimal\n# from difflib import SequenceMatcher\n# from heapq import heappop, heappush\n\nif sys.version_info[0] < 3:\n    from io import BytesIO as stream\n    # from fractions import Fraction\n    # from fractions import gcd\n    # from cPickle import dumps\n    # from Queue import PriorityQueue, Queue\nelse:\n    from io import StringIO as stream\n    # from functools import reduce\n    # from fractions import Fraction\n    # from math import gcd\n    # from pickle import dumps\n    # from queue import PriorityQueue, Queue\n\n\nif sys.version_info[0] < 3:\n    class dict(dict):\n        def items(self):\n            return dict.iteritems(self)\n\n        def keys(self):\n            return dict.iterkeys(self)\n\n        def values(self):\n            return dict.itervalues(self)\n\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\n\ndef sync_with_stdio(sync=True):\n    \"\"\"\n    Sets whether the standard Python streams are allowed to buffer their I/O.\n\n    Parameters\n    ----------\n    sync : bool, optional\n        The new synchronization setting. Default is True.\n    \"\"\"\n    global input, flush\n\n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\n\ndef main():\n    n, m = map(int, input().split(' '))\n    if n > m:\n        print('YES')\n    else:\n        a = list(map(lambda x: int(x) % m, input().split(' ')))\n        dp = [[False] * m for _ in range(n)]\n        dp[0][a[0]] = True\n        for i in range(1, n):\n            dp[i][a[i]] = True\n            for j, flag in enumerate(dp[i - 1]):\n                if flag:\n                    dp[i][j] = True\n                    dp[i][(j + a[i]) % m] = True\n\n        if dp[-1][0]:\n            print('YES')\n        else:\n            print('NO')\n\n\nif __name__ == '__main__':\n    sys.setrecursionlimit(10000)\n    sync_with_stdio(False)\n    main()\n",
        "correct": true,
        "task_id": "0832",
        "depth": 2
    },
    {
        "description": "The development of a text editor is a hard problem. You need to implement an extra module for brackets coloring in text.\n\nYour editor consists of a line with infinite length and cursor, which points to the current character. Please note that it points to only one of the characters (and not between a pair of characters). Thus, it points to an index character. The user can move the cursor left or right one position. If the cursor is already at the first (leftmost) position, then it does not move left.\n\nInitially, the cursor is in the first (leftmost) character.\n\nAlso, the user can write a letter or brackets (either (, or )) to the position that the cursor is currently pointing at. A new character always overwrites the old value at that position.\n\nYour editor must check, whether the current line is the correct text. Text is correct if the brackets in them form the correct bracket sequence.\n\nFormally, correct text (CT) must satisfy the following rules: \n\n  * any line without brackets is CT (the line can contain whitespaces); \n  * If the first character of the string \u2014 is (, the last \u2014 is ), and all the rest form a CT, then the whole line is a CT; \n  * two consecutively written CT is also CT. \n\n\n\nExamples of correct texts: hello(codeforces), round, ((i)(write))edi(tor)s, ( me). Examples of incorrect texts: hello)oops(, round), ((me).\n\nThe user uses special commands to work with your editor. Each command has its symbol, which must be written to execute this command.\n\nThe correspondence of commands and characters is as follows: \n\n  * L \u2014 move the cursor one character to the left (remains in place if it already points to the first character); \n  * R \u2014 move the cursor one character to the right; \n  * any lowercase Latin letter or bracket (( or )) \u2014 write the entered character to the position where the cursor is now. \n\n\n\nFor a complete understanding, take a look at the first example and its illustrations in the note below.\n\nYou are given a string containing the characters that the user entered. For the brackets coloring module's work, after each command you need to:\n\n  * check if the current text in the editor is a correct text; \n  * if it is, print the least number of colors that required, to color all brackets. \n\n\n\nIf two pairs of brackets are nested (the first in the second or vice versa), then these pairs of brackets should be painted in different colors. If two pairs of brackets are not nested, then they can be painted in different or the same colors. For example, for the bracket sequence ()(())()() the least number of colors is 2, and for the bracket sequence (()(()())())(()) \u2014 is 3.\n\nWrite a program that prints the minimal number of colors after processing each command.\n\nInput\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^6) \u2014 the number of commands. \n\nThe second line contains s \u2014 a sequence of commands. The string s consists of n characters. It is guaranteed that all characters in a string are valid commands.\n\nOutput\n\nIn a single line print n integers, where the i-th number is:\n\n  * -1 if the line received after processing the first i commands is not valid text, \n  * the minimal number of colors in the case of the correct text. \n\nExamples\n\nInput\n\n\n11\n(RaRbR)L)L(\n\n\nOutput\n\n\n-1 -1 -1 -1 -1 -1 1 1 -1 -1 2 \n\nInput\n\n\n11\n(R)R(R)Ra)c\n\n\nOutput\n\n\n-1 -1 1 1 -1 -1 1 1 1 -1 1 \n\nNote\n\nIn the first example, the text in the editor will take the following form:\n\n  1.     (  \n    ^\n\n  2.     (  \n     ^\n\n  3.     (a  \n     ^\n\n  4.     (a  \n      ^\n\n  5.     (ab  \n      ^\n\n  6.     (ab  \n       ^\n\n  7.     (ab)  \n       ^\n\n  8.     (ab)  \n      ^\n\n  9.     (a))  \n      ^\n\n  10.     (a))  \n     ^\n\n  11.     (())  \n     ^",
        "task_name": "1263_E. Editor",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\nn = int(input())\noperations = raw_input()\n\nans_list = []\n\noperator_map = {\n    '(':1,\n    ')':-1\n}\n\n\nleft_sum  = [0 for i in xrange(n + 2)]\nright_sum = [0 for i in xrange(n + 2)]\nleft_min = [0 for i in xrange(n + 2)]\nright_min = [0 for i in xrange(n + 2)]\nleft_max = [0 for i in xrange(n + 2)]\nright_max = [0 for i in xrange(n + 2)]\n\n# start pos is 1\ncursor_pos = 1\n# line context\ncontext = [0 for i in xrange(n + 2)]\n\nfor op in operations:\n    if op=='L':\n        cursor_pos = max(1, cursor_pos - 1)\n    elif op=='R':\n        cursor_pos += 1\n    else:\n        op_val = operator_map.get(op, 0)\n        # update current pos\n        context[cursor_pos] = op_val\n\n    # no matter cursor_pos come from left or right, cursor_pos + 1 and cursor_pos - 1 's\n    # value is freash for cursor_pos to update its value\n    left_sum[cursor_pos] = left_sum[cursor_pos-1] + context[cursor_pos]\n    right_sum[cursor_pos] = right_sum[cursor_pos+1] + right_sum[cursor_pos]\n\n    left_min[cursor_pos] =  min(left_min[cursor_pos-1] , context[cursor_pos])\n    right_min[cursor_pos] = min(right_min[cursor_pos+1] , context[cursor_pos])\n\n\n    left_max[cursor_pos] = max(left_max[cursor_pos-1] , context[cursor_pos])\n    right_max[cursor_pos] = max(right_max[cursor_pos+1] , context[cursor_pos])\n\n    ans = -1\n    if left_sum[cursor_pos] + right_sum[cursor_pos + 1] == 0 and left_min[cursor_pos] >= 0 and right_min[cursor_pos] >= 0:\n        ans = max(left_max[cursor_pos], right_max[cursor_pos])\n    ans_list.append(ans)\nprint(\" \".join(map(str, ans_list))) \n",
        "correct": false,
        "task_id": "0856",
        "depth": 1
    },
    {
        "description": "You've got two rectangular tables with sizes na \u00d7 ma and nb \u00d7 mb cells. The tables consist of zeroes and ones. We will consider the rows and columns of both tables indexed starting from 1. Then we will define the element of the first table, located at the intersection of the i-th row and the j-th column, as ai, j; we will define the element of the second table, located at the intersection of the i-th row and the j-th column, as bi, j. \n\nWe will call the pair of integers (x, y) a shift of the second table relative to the first one. We'll call the overlap factor of the shift (x, y) value:\n\n<image>\n\nwhere the variables i, j take only such values, in which the expression ai, j\u00b7bi + x, j + y makes sense. More formally, inequalities 1 \u2264 i \u2264 na, 1 \u2264 j \u2264 ma, 1 \u2264 i + x \u2264 nb, 1 \u2264 j + y \u2264 mb must hold. If there are no values of variables i, j, that satisfy the given inequalities, the value of the sum is considered equal to 0. \n\nYour task is to find the shift with the maximum overlap factor among all possible shifts.\n\nInput\n\nThe first line contains two space-separated integers na, ma (1 \u2264 na, ma \u2264 50) \u2014 the number of rows and columns in the first table. Then na lines contain ma characters each \u2014 the elements of the first table. Each character is either a \"0\", or a \"1\".\n\nThe next line contains two space-separated integers nb, mb (1 \u2264 nb, mb \u2264 50) \u2014 the number of rows and columns in the second table. Then follow the elements of the second table in the format, similar to the first table.\n\nIt is guaranteed that the first table has at least one number \"1\". It is guaranteed that the second table has at least one number \"1\".\n\nOutput\n\nPrint two space-separated integers x, y (|x|, |y| \u2264 109) \u2014 a shift with maximum overlap factor. If there are multiple solutions, print any of them.\n\nExamples\n\nInput\n\n3 2\n01\n10\n00\n2 3\n001\n111\n\n\nOutput\n\n0 1\n\n\nInput\n\n3 3\n000\n010\n000\n1 1\n1\n\n\nOutput\n\n-1 -1",
        "task_name": "228_B. Two Tables",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\n(na, ma) = [int(buf) for buf in stdin.readline().strip().split()]\na = [int(stdin.readline().strip()[::-1], 2) for i in range(0, na)]\n\n(nb, mb) = [int(buf) for buf in stdin.readline().strip().split()]\nb = [int(stdin.readline().strip()[::-1], 2) for i in range(0, nb)]\n\ndef count1(x):\n    x = (x & 0x55555555555555555555555555555555) + ((x>>0x01) & 0x55555555555555555555555555555555)\n    x = (x & 0x33333333333333333333333333333333) + ((x>>0x02) & 0x33333333333333333333333333333333)\n    x = (x & 0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F) + ((x>>0x04) & 0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F)\n    x = (x & 0x00FF00FF00FF00FF00FF00FF00FF00FF) + ((x>>0x08) & 0x00FF00FF00FF00FF00FF00FF00FF00FF)\n    x = (x & 0x0000FFFF0000FFFF0000FFFF0000FFFF) + ((x>>0x0F) & 0x0000FFFF0000FFFF0000FFFF0000FFFF)\n    x = (x & 0x00000000FFFFFFFF00000000FFFFFFFF) + ((x>>0x10) & 0x00000000FFFFFFFF00000000FFFFFFFF)\n    x = (x & 0x0000000000000000FFFFFFFFFFFFFFFF) + ((x>>0x20) & 0x0000000000000000FFFFFFFFFFFFFFFF)\n    return x\n\ndef getval(x, y):\n    cnt = 0\n    for i in range(0, na):\n        if i+x in range(0, nb):\n            if y > 0:\n                cnt += count1((a[i]<<y) & b[i+x])\n            else:\n                cnt += count1(a[i] & (b[i+x]<<-y))\n    return cnt\n\n(ans, xx, yy) = (0, 0, 0)\nfor x in range(1-na, nb):\n    for y in range(1-ma, mb):\n        val = getval(x, y)\n        if ans  < val:\n            (ans, xx, yy) = (val, x, y)\n\nprint('%d %d' % (xx, yy))\n                \n",
        "correct": false,
        "task_id": "0867",
        "depth": 2
    },
    {
        "description": "One day Bob got a letter in an envelope. Bob knows that when Berland's post officers send a letter directly from city \u00abA\u00bb to city \u00abB\u00bb, they stamp it with \u00abA B\u00bb, or \u00abB A\u00bb. Unfortunately, often it is impossible to send a letter directly from the city of the sender to the city of the receiver, that's why the letter is sent via some intermediate cities. Post officers never send a letter in such a way that the route of this letter contains some city more than once. Bob is sure that the post officers stamp the letters accurately.\n\nThere are n stamps on the envelope of Bob's letter. He understands that the possible routes of this letter are only two. But the stamps are numerous, and Bob can't determine himself none of these routes. That's why he asks you to help him. Find one of the possible routes of the letter.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 105) \u2014 amount of mail stamps on the envelope. Then there follow n lines with two integers each \u2014 description of the stamps. Each stamp is described with indexes of the cities between which a letter is sent. The indexes of cities are integers from 1 to 109. Indexes of all the cities are different. Every time the letter is sent from one city to another, exactly one stamp is put on the envelope. It is guaranteed that the given stamps correspond to some valid route from some city to some other city. \n\nOutput\n\nOutput n + 1 numbers \u2014 indexes of cities in one of the two possible routes of the letter.\n\nExamples\n\nInput\n\n2\n1 100\n100 2\n\n\nOutput\n\n2 100 1 \n\nInput\n\n3\n3 1\n100 2\n3 2\n\n\nOutput\n\n100 2 3 1 ",
        "task_name": "29_C. Mail Stamps",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from math import *\nfrom Queue import *\n\n\nn = int(raw_input())\nnbr = dict()\ncand = set()\nfor i in range(n):\n    l = raw_input().split()\n    if l[0] not in nbr:\n        nbr[l[0]] = [l[1]]\n        cand.add(l[0])\n    else:\n        nbr[l[0]].append(l[1])\n        cand.remove(l[0])\n    if l[1] not in nbr:\n        nbr[l[1]] = [l[0]]\n        cand.add(l[1])\n    else:\n        nbr[l[1]].append(l[0])\n        cand.remove(l[1])\nfor v in cand:\n    break\nmarked = set()\nmarked.add(v)\nres = [v]\nQ = [v]\nwhile len(Q) > 0:\n    v = Q.pop()\n    for i in nbr[v]:\n        if i not in marked:\n            marked.add(i)\n            res.append(i)\n            Q.append(i)\nprint(\" \".join(res))\n    \n",
        "correct": true,
        "task_id": "0869",
        "depth": 2
    },
    {
        "description": "You are given n points on the straight line \u2014 the positions (x-coordinates) of the cities and m points on the same line \u2014 the positions (x-coordinates) of the cellular towers. All towers work in the same way \u2014 they provide cellular network for all cities, which are located at the distance which is no more than r from this tower.\n\nYour task is to find minimal r that each city has been provided by cellular network, i.e. for each city there is at least one cellular tower at the distance which is no more than r.\n\nIf r = 0 then a tower provides cellular network only for the point where it is located. One tower can provide cellular network for any number of cities, but all these cities must be at the distance which is no more than r from this tower.\n\nInput\n\nThe first line contains two positive integers n and m (1 \u2264 n, m \u2264 105) \u2014 the number of cities and the number of cellular towers.\n\nThe second line contains a sequence of n integers a1, a2, ..., an ( - 109 \u2264 ai \u2264 109) \u2014 the coordinates of cities. It is allowed that there are any number of cities in the same point. All coordinates ai are given in non-decreasing order.\n\nThe third line contains a sequence of m integers b1, b2, ..., bm ( - 109 \u2264 bj \u2264 109) \u2014 the coordinates of cellular towers. It is allowed that there are any number of towers in the same point. All coordinates bj are given in non-decreasing order.\n\nOutput\n\nPrint minimal r so that each city will be covered by cellular network.\n\nExamples\n\nInput\n\n3 2\n-2 2 4\n-3 0\n\n\nOutput\n\n4\n\n\nInput\n\n5 3\n1 5 10 14 17\n4 11 15\n\n\nOutput\n\n3",
        "task_name": "702_C. Cellular Network",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from bisect import bisect_left\nn, m = map(int, raw_input().split())\na = map(int, raw_input().split())\nb = map(int, raw_input().split())\n\nmin_r = 0\n\nfor el in a:\n    i = bisect_left(b, el)\n    if i == 0:\n        min_r = max(min_r, abs(el - b[0]))\n    elif i == m:\n        min_r = max(min_r, abs(el - b[m-1]))\n    elif i == m - 1:\n        min_r = max(min_r, min(abs(el - b[m - 1]), abs(el - b[m - 2])))\n    else:\n        min_r = max(min_r, min(abs(el - b[i + 1]), abs(el - b[i - 1]), abs(el-b[i])))\n\nprint(min_r)\n\n",
        "correct": true,
        "task_id": "0879",
        "depth": 1
    },
    {
        "description": "Innokentiy likes tea very much and today he wants to drink exactly n cups of tea. He would be happy to drink more but he had exactly n tea bags, a of them are green and b are black.\n\nInnokentiy doesn't like to drink the same tea (green or black) more than k times in a row. Your task is to determine the order of brewing tea bags so that Innokentiy will be able to drink n cups of tea, without drinking the same tea more than k times in a row, or to inform that it is impossible. Each tea bag has to be used exactly once.\n\nInput\n\nThe first line contains four integers n, k, a and b (1 \u2264 k \u2264 n \u2264 105, 0 \u2264 a, b \u2264 n) \u2014 the number of cups of tea Innokentiy wants to drink, the maximum number of cups of same tea he can drink in a row, the number of tea bags of green and black tea. It is guaranteed that a + b = n.\n\nOutput\n\nIf it is impossible to drink n cups of tea, print \"NO\" (without quotes).\n\nOtherwise, print the string of the length n, which consists of characters 'G' and 'B'. If some character equals 'G', then the corresponding cup of tea should be green. If some character equals 'B', then the corresponding cup of tea should be black.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n5 1 3 2\n\n\nOutput\n\nGBGBG\n\n\nInput\n\n7 2 2 5\n\n\nOutput\n\nBBGBGBB\n\nInput\n\n4 3 4 0\n\n\nOutput\n\nNO",
        "task_name": "746_D. Green and Black Tea",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "vals=[int(x) for x in raw_input().split()]\nn=vals[0]\nk=vals[1]\na=vals[2]\nb=vals[3]\n\nc=0\nd=True\nif b>a: d=False\ns=''\n\nfor i in range(n):\n    if c==k:\n        d = not d\n        c=0\n    if d:\n        s+='G'\n        a-=1\n        c+=1\n        if a < b:\n            d=not d\n            c=0\n    else:\n        s+='B'\n        b-=1\n        c+=1\n        if b<a:\n            d=not d\n            c=0\n    if a<0 or b<0:\n        print('NO')\n        quit()\n\nprint(s)\n",
        "correct": true,
        "task_id": "0881",
        "depth": 1
    },
    {
        "description": "Consider the following game for two players. There is one white token and some number of black tokens. Each token is placed on a plane in a point with integer coordinates x and y.\n\nThe players take turn making moves, white starts. On each turn, a player moves all tokens of their color by 1 to up, down, left or right. Black player can choose directions for each token independently.\n\nAfter a turn of the white player the white token can not be in a point where a black token is located. There are no other constraints on locations of the tokens: positions of black tokens can coincide, after a turn of the black player and initially the white token can be in the same point with some black point. If at some moment the white player can't make a move, he loses. If the white player makes 10100500 moves, he wins.\n\nYou are to solve the following problem. You are given initial positions of all black tokens. It is guaranteed that initially all these positions are distinct. In how many places can the white token be located initially so that if both players play optimally, the black player wins?\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 105) \u2014 the number of black points.\n\nThe (i + 1)-th line contains two integers xi, yi ( - 105 \u2264 xi, yi, \u2264 105) \u2014 the coordinates of the point where the i-th black token is initially located.\n\nIt is guaranteed that initial positions of black tokens are distinct.\n\nOutput\n\nPrint the number of points where the white token can be located initially, such that if both players play optimally, the black player wins.\n\nExamples\n\nInput\n\n4\n-2 -1\n0 1\n0 -3\n2 -1\n\n\nOutput\n\n4\n\n\nInput\n\n4\n-2 0\n-1 1\n0 -2\n1 -1\n\n\nOutput\n\n2\n\n\nInput\n\n16\n2 1\n1 2\n-1 1\n0 1\n0 0\n1 1\n2 -1\n2 0\n1 0\n-1 -1\n1 -1\n2 2\n0 -1\n-1 0\n0 2\n-1 2\n\n\nOutput\n\n4\n\nNote\n\nIn the first and second examples initial positions of black tokens are shown with black points, possible positions of the white token (such that the black player wins) are shown with white points.\n\nThe first example: <image>\n\nThe second example: <image>\n\nIn the third example the white tokens should be located in the inner square 2 \u00d7 2, to make the black player win. <image>",
        "task_name": "930_D. Game with Tokens",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import*\nfrom itertools import*\ndef solve(a):\n    inf = 1001001001\n    C = 400010\n    lmn = [inf] * 400010\n    lmx = [-inf] * 400010\n    for x, y in a:\n        x = (x - 1) / 2 + 100005\n        if lmn[x] > y:\n            lmn[x] = y\n        if lmx[x] < y:\n            lmx[x] = y\n    rmn = lmn[:]\n    rmx = lmx[:]\n    for i in xrange(200009):\n        if lmn[i+1] > lmn[i]:\n            lmn[i+1] = lmn[i]\n    for i in xrange(200009):\n        if lmx[i+1] < lmx[i]:\n            lmx[i+1] = lmx[i]\n    for i in xrange(200009, 0, -1):\n        if rmn[i-1] > rmn[i]:\n            rmn[i-1] = rmn[i]\n    for i in xrange(200009, 0, -1):\n        if rmx[i-1] < rmx[i]:\n            rmx[i-1] = rmx[i]\n    for i in xrange(200010):\n        if lmn[i] < rmn[i]:\n            lmn[i] = rmn[i]\n    for i in xrange(200010):\n        if lmx[i] > rmx[i]:\n            lmx[i] = rmx[i]\n    ans = 0\n    for i in xrange(200009):\n        if lmn[i] < lmn[i+1]:\n            lmn[i] = lmn[i+1]\n    for i in xrange(200009):\n        if lmx[i] > lmx[i+1]:\n            lmx[i] = lmx[i+1]\n    for i in xrange(200009):\n        if lmn[i] < lmx[i]:\n            ans += (lmx[i] - lmn[i]) / 2\n    return ans\n    \ndef main():\n    n = int(stdin.readline())\n    dat = map(int, stdin.read().split(), repeat(10, 2 * n))\n    s = [[], []]\n    for i in xrange(n):\n        x, y = dat[i*2:i*2+2]\n        s[(x+y)&1].append((-x+y, x+y))\n    print(solve(s[0]) + solve(s[1]))\nmain()",
        "correct": true,
        "task_id": "0887",
        "depth": 1
    },
    {
        "description": "Iroha has a sequence of N strings S_1, S_2, ..., S_N. The length of each string is L.\n\nShe will concatenate all of the strings in some order, to produce a long string.\n\nAmong all strings that she can produce in this way, find the lexicographically smallest one.\n\nHere, a string s=s_1s_2s_3...s_n is lexicographically smaller than another string t=t_1t_2t_3...t_m if and only if one of the following holds:\n\n* There exists an index i(1\u2266i\u2266min(n,m)), such that s_j = t_j for all indices j(1\u2266j<i), and s_i<t_i.\n* s_i = t_i for all integers i(1\u2266i\u2266min(n,m)), and n<m.\n\nConstraints\n\n* 1 \u2266 N, L \u2266 100\n* For each i, the length of S_i equals L.\n* For each i, S_i consists of lowercase letters.\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nN L\nS_1\nS_2\n:\nS_N\n\n\nOutput\n\nPrint the lexicographically smallest string that Iroha can produce.\n\nExample\n\nInput\n\n3 3\ndxx\naxx\ncxx\n\n\nOutput\n\naxxcxxdxx",
        "task_name": "p04044 AtCoder Beginner Contest 042 - Iroha Loves Strings (ABC Edition)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n,l=map(int,raw_input().split())\ns=[raw_input() for _ in xrange(n)]\ns.sort()\nans=\"\"\nfor i in xrange(n):\n    ans+=s[i]\nprint(ans)\n",
        "correct": true,
        "task_id": "0894",
        "depth": 1
    },
    {
        "description": "Everybody knows that opposites attract. That is the key principle of the \"Perfect Matching\" dating agency. The \"Perfect Matching\" matchmakers have classified each registered customer by his interests and assigned to the i-th client number ti ( - 10 \u2264 ti \u2264 10). Of course, one number can be assigned to any number of customers.\n\n\"Perfect Matching\" wants to advertise its services and publish the number of opposite couples, that is, the couples who have opposite values of t. Each couple consists of exactly two clients. The customer can be included in a couple an arbitrary number of times. Help the agency and write the program that will find the sought number by the given sequence t1, t2, ..., tn. For example, if t = (1, - 1, 1, - 1), then any two elements ti and tj form a couple if i and j have different parity. Consequently, in this case the sought number equals 4.\n\nOf course, a client can't form a couple with him/herself.\n\nInput\n\nThe first line of the input data contains an integer n (1 \u2264 n \u2264 105) which represents the number of registered clients of the \"Couple Matching\". The second line contains a sequence of integers t1, t2, ..., tn ( - 10 \u2264 ti \u2264 10), ti \u2014 is the parameter of the i-th customer that has been assigned to the customer by the result of the analysis of his interests.\n\nOutput\n\nPrint the number of couples of customs with opposite t. The opposite number for x is number  - x (0 is opposite to itself). Couples that only differ in the clients' order are considered the same.\n\nNote that the answer to the problem can be large enough, so you must use the 64-bit integer type for calculations. Please, do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.\n\nExamples\n\nInput\n\n5\n-3 3 0 0 3\n\n\nOutput\n\n3\n\n\nInput\n\n3\n0 0 0\n\n\nOutput\n\n3\n\nNote\n\nIn the first sample the couples of opposite clients are: (1,2), (1,5) \u0438 (3,4).\n\nIn the second sample any couple of clients is opposite.",
        "task_name": "131_B. Opposites Attract",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "a = dict()\nfor i in range(-10, 11):\n      a[i] = 0\nn = input()\nt = map(int, raw_input().split())\nfor i in range(n):\n      a[t[i]] += 1\nans = 0\nfor i in range(-10, 0):\n      ans += a[i] * a[-i]\nans += a[0] * (a[0] - 1) / 2\nprint(ans)\n\n",
        "correct": true,
        "task_id": "0907",
        "depth": 1
    },
    {
        "description": "The Romans have attacked again. This time they are much more than the Persians but Shapur is ready to defeat them. He says: \"A lion is never afraid of a hundred sheep\". \n\nNevertheless Shapur has to find weaknesses in the Roman army to defeat them. So he gives the army a weakness number.\n\nIn Shapur's opinion the weakness of an army is equal to the number of triplets i, j, k such that i < j < k and ai > aj > ak where ax is the power of man standing at position x. The Roman army has one special trait \u2014 powers of all the people in it are distinct.\n\nHelp Shapur find out how weak the Romans are.\n\nInput\n\nThe first line of input contains a single number n (3 \u2264 n \u2264 106) \u2014 the number of men in Roman army. Next line contains n different positive integers ai (1 \u2264 i \u2264 n, 1 \u2264 ai \u2264 109) \u2014 powers of men in the Roman army. \n\nOutput\n\nA single integer number, the weakness of the Roman army. \n\nPlease, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n\nExamples\n\nInput\n\n3\n3 2 1\n\n\nOutput\n\n1\n\n\nInput\n\n3\n2 3 1\n\n\nOutput\n\n0\n\n\nInput\n\n4\n10 8 3 1\n\n\nOutput\n\n4\n\n\nInput\n\n4\n1 5 4 3\n\n\nOutput\n\n1",
        "task_name": "61_E. Enemy is weak",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def fast2():\n    import os, sys, atexit\n    from cStringIO import StringIO as BytesIO\n    # range = xrange\n    sys.stdout = BytesIO()\n    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))\n    return BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\nclass order_tree:\n    def __init__(self, n):\n        self.tree, self.n = [[0, 0] for _ in range(n << 1)], n\n\n    # get interval[l,r)\n    def query(self, r, col):\n        res = 0\n        l = self.n\n        r += self.n\n\n        while l < r:\n            if l & 1:\n                res += self.tree[l][col]\n                l += 1\n\n            if r & 1:\n                r -= 1\n                res += self.tree[r][col]\n\n            l >>= 1\n            r >>= 1\n\n        return res\n\n    def update(self, ix, val, col):\n        ix += self.n\n\n        # set new value\n        self.tree[ix][col] += val\n\n        # move up\n        while ix > 1:\n            self.tree[ix >> 1][col] = self.tree[ix][col] + self.tree[ix ^ 1][col]\n            ix >>= 1\n\n\ninput = fast2()\nn, a = int(input()), [int(x) for x in input().split()]\ntree, ans = order_tree(n), 0\nmem = {i: j for j, i in enumerate(sorted(a))}\n\nfor i in range(n - 1, -1, -1):\n    cur = mem[a[i]]\n    ans += tree.query(cur, 1)\n    tree.update(cur, 1, 0)\n    tree.update(cur, tree.query(cur, 0), 1)\n\nprint(ans)\n",
        "correct": true,
        "task_id": "0921",
        "depth": 1
    },
    {
        "description": "Little Artem found a grasshopper. He brought it to his house and constructed a jumping area for him.\n\nThe area looks like a strip of cells 1 \u00d7 n. Each cell contains the direction for the next jump and the length of that jump. Grasshopper starts in the first cell and follows the instructions written on the cells. Grasshopper stops immediately if it jumps out of the strip. Now Artem wants to find out if this will ever happen.\n\nInput\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000) \u2014 length of the strip. \n\nNext line contains a string of length n which consists of characters \"<\" and \">\" only, that provide the direction of the jump from the corresponding cell. Next line contains n integers di (1 \u2264 di \u2264 109) \u2014 the length of the jump from the i-th cell.\n\nOutput\n\nPrint \"INFINITE\" (without quotes) if grasshopper will continue his jumps forever. Otherwise print \"FINITE\" (without quotes).\n\nExamples\n\nInput\n\n2\n&gt;&lt;\n1 2\n\n\nOutput\n\nFINITE\n\n\nInput\n\n3\n&gt;&gt;&lt;\n2 1 1\n\n\nOutput\n\nINFINITE\n\nNote\n\nIn the first sample grasshopper starts from the first cell and jumps to the right on the next cell. When he is in the second cell he needs to jump two cells left so he will jump out of the strip.\n\nSecond sample grasshopper path is 1 - 3 - 2 - 3 - 2 - 3 and so on. The path is infinite.",
        "task_name": "669_B. Little Artem and Grasshopper",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = input()\nfield = raw_input()\npower = map(int, raw_input().split())\n\npos = 0\nwhile 0 <= pos < n and power[pos] != 0:\n    power[pos], pos = 0, pos + (2 * (field[pos] == '>') - 1) * power[pos]\n\nprint (\"INFINITE\" if 0 <= pos < n else \"FINITE\")\n",
        "correct": true,
        "task_id": "0923",
        "depth": 1
    },
    {
        "description": "On the way to Rio de Janeiro Ostap kills time playing with a grasshopper he took with him in a special box. Ostap builds a line of length n such that some cells of this line are empty and some contain obstacles. Then, he places his grasshopper to one of the empty cells and a small insect in another empty cell. The grasshopper wants to eat the insect.\n\nOstap knows that grasshopper is able to jump to any empty cell that is exactly k cells away from the current (to the left or to the right). Note that it doesn't matter whether intermediate cells are empty or not as the grasshopper makes a jump over them. For example, if k = 1 the grasshopper can jump to a neighboring cell only, and if k = 2 the grasshopper can jump over a single cell.\n\nYour goal is to determine whether there is a sequence of jumps such that grasshopper will get from his initial position to the cell with an insect.\n\nInput\n\nThe first line of the input contains two integers n and k (2 \u2264 n \u2264 100, 1 \u2264 k \u2264 n - 1) \u2014 the number of cells in the line and the length of one grasshopper's jump.\n\nThe second line contains a string of length n consisting of characters '.', '#', 'G' and 'T'. Character '.' means that the corresponding cell is empty, character '#' means that the corresponding cell contains an obstacle and grasshopper can't jump there. Character 'G' means that the grasshopper starts at this position and, finally, 'T' means that the target insect is located at this cell. It's guaranteed that characters 'G' and 'T' appear in this line exactly once.\n\nOutput\n\nIf there exists a sequence of jumps (each jump of length k), such that the grasshopper can get from his initial position to the cell with the insect, print \"YES\" (without quotes) in the only line of the input. Otherwise, print \"NO\" (without quotes).\n\nExamples\n\nInput\n\n5 2\n#G#T#\n\n\nOutput\n\nYES\n\n\nInput\n\n6 1\nT....G\n\n\nOutput\n\nYES\n\n\nInput\n\n7 3\nT..#..G\n\n\nOutput\n\nNO\n\n\nInput\n\n6 2\n..GT..\n\n\nOutput\n\nNO\n\nNote\n\nIn the first sample, the grasshopper can make one jump to the right in order to get from cell 2 to cell 4.\n\nIn the second sample, the grasshopper is only able to jump to neighboring cells but the way to the insect is free \u2014 he can get there by jumping left 5 times.\n\nIn the third sample, the grasshopper can't make a single jump.\n\nIn the fourth sample, the grasshopper can only jump to the cells with odd indices, thus he won't be able to reach the insect.",
        "task_name": "735_A. Ostap and Grasshopper",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "l1 = list(map(int,raw_input().split()))\n\nn,k = l1[0],l1[1]\n\nl = raw_input()\n\nmestot = None\nmestok = None\n\nfor i in range(len(l)):\n    if l[i] == \"G\":\n        mestok = i\n    if l[i] == \"T\":\n        mestot = i\n        \n    if mestok != None and mestot != None:\n        break\n\n\nfl = True\n\nif abs(mestot-mestok) % k == 0:\n    \n    for i in range(mestok,len(l),k):\n        if l[i] == \"#\":\n            fl = False\n            break\n        \n    if fl != False and mestot < mestok:\n        l = l[::-1]\n        \n        for i in range(len(l)):\n            if l[i] == \"G\":\n                mestok = i\n            if l[i] == \"T\":\n                mestot = i\n\n        for i in range(mestok,len(l),k):\n            if l[i] == \"#\":\n                fl = False\n                break\n\n    if fl == True:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    print(\"NO\")\n",
        "correct": false,
        "task_id": "0925",
        "depth": 1
    },
    {
        "description": "A binary heap which satisfies max-heap property is called max-heap. In a max-heap, for every node $i$ other than the root, $A[i] \\leq A[parent(i)]$, that is, the value of a node is at most the value of its parent. The largest element in a max-heap is stored at the root, and the subtree rooted at a node contains values no larger than that contained at the node itself.\n\nHere is an example of a max-heap.\n\n<image>\n\n\nWrite a program which reads an array and constructs a max-heap from the array based on the following pseudo code.\n\n$maxHeapify(A, i)$ move the value of $A[i]$ down to leaves to make a sub-tree of node $i$ a max-heap. Here, $H$ is the size of the heap.\n\n\n1  maxHeapify(A, i)\n2      l = left(i)\n3      r = right(i)\n4      // select the node which has the maximum value\n5      if l \u2264 H and A[l] > A[i]\n6          largest = l\n7      else\n8          largest = i\n9      if r \u2264 H and A[r] > A[largest]\n10         largest = r\n11\n12     if largest \u2260 i\u3000// value of children is larger than that of i\n13         swap A[i] and A[largest]\n14         maxHeapify(A, largest) // call recursively\n\n\nThe following procedure buildMaxHeap(A) makes $A$ a max-heap by performing maxHeapify in a bottom-up manner.\n\n\n1 buildMaxHeap(A)\n2    for i = H/2 downto 1\n3        maxHeapify(A, i)\n\n\n\n\nInput\n\nIn the first line, an integer $H$ is given. In the second line, $H$ integers which represent elements in the binary heap are given in order of node id (from $1$ to $H$).\n\nOutput\n\nPrint values of nodes in the max-heap in order of their id (from $1$ to $H$). Print a single space character before each value.\n\nExample\n\nInput\n\n10\n4 1 3 2 16 9 10 14 8 7\n\n\nOutput\n\n16 14 10 8 7 9 3 2 4 1",
        "task_name": "p02288 Maximum Heap",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\ndef get_left(i):\n    return 2 * i + 1\n\ndef get_right(i):\n    return 2 * i + 2\n\ndef get_parent(i):\n    return int((i-1)/2)\n\ndef make_heap_tree(array, i, item_num):\n    left = get_left(i)\n    right = get_right(i)\n    largest = i\n    if (left < item_num) and (array[left] > array[largest]):\n        largest = left\n    if (right < item_num) and (array[right] > array[largest]):\n        largest = right\n    if largest != i:\n        tmp = array[i]\n        array[i] = array[largest]\n        array[largest] = tmp\n        make_heap_tree(array, largest, item_num)\n\ndef main():\n    size = int(sys.stdin.readline().strip())\n    array = map(lambda x: int(x), sys.stdin.readline().strip().split(\" \"))\n    for i in reversed(range(0, get_parent(size))):\n        make_heap_tree(array, i, size)\n\nif __name__ == \"__main__\":\n    main()",
        "correct": false,
        "task_id": "0943",
        "depth": 1
    },
    {
        "description": "There are n cards numbered 1, \u2026, n. The card i has a red digit r_i and a blue digit b_i written on it.\n\nWe arrange all n cards in random order from left to right, with all permutations of 1, \u2026, n having the same probability. We then read all red digits on the cards from left to right, and obtain an integer R. In the same way, we read all blue digits and obtain an integer B. When reading a number, leading zeros can be ignored. If all digits in a number are zeros, then the number is equal to 0. Below is an illustration of a possible rearrangement of three cards, and how R and B can be found.\n\n<image>\n\nTwo players, Red and Blue, are involved in a bet. Red bets that after the shuffle R > B, and Blue bets that R < B. If in the end R = B, the bet results in a draw, and neither player wins.\n\nDetermine, which of the two players is more likely (has higher probability) to win the bet, or that their chances are equal. Refer to the Note section for a formal discussion of comparing probabilities.\n\nInput\n\nThe first line contains a single integer T (1 \u2264 T \u2264 100) \u2014 the number of test cases.\n\nDescriptions of T test cases follow. Each test case description starts with a line containing a single integer n (1 \u2264 n \u2264 1000) \u2014 the number of cards.\n\nThe following line contains a string of n digits r_1, \u2026, r_n \u2014 red digits on cards 1, \u2026, n respectively.\n\nThe following line contains a string of n digits b_1, \u2026, b_n \u2014 blue digits on cards 1, \u2026, n respectively.\n\nNote that digits in the same line are not separated with any delimiters.\n\nOutput\n\nPrint T answers for the test cases in order, one per line.\n\nIf Red has a strictly higher change to win, print \"RED\".\n\nIf Blue has a strictly higher change to win, print \"BLUE\".\n\nIf both players are equally likely to win, print \"EQUAL\".\n\nNote that all answers are case-sensitive.\n\nExample\n\nInput\n\n\n3\n3\n777\n111\n3\n314\n159\n5\n09281\n09281\n\n\nOutput\n\n\nRED\nBLUE\nEQUAL\n\nNote\n\nFormally, let n_R be the number of permutations of cards 1, \u2026, n such that the resulting numbers R and B satisfy R > B. Similarly, let n_B be the number of permutations such that R < B. If n_R > n_B, you should print \"RED\". If n_R < n_B, you should print \"BLUE\". If n_R = n_B, print \"EQUAL\".\n\nIn the first sample case, R = 777 and B = 111 regardless of the card order, thus Red always wins.\n\nIn the second sample case, there are two card orders when Red wins, and four card orders when Blue wins:\n\n  * order 1, 2, 3: 314 > 159;\n  * order 1, 3, 2: 341 > 195;\n  * order 2, 1, 3: 134 < 519;\n  * order 2, 3, 1: 143 < 591;\n  * order 3, 1, 2: 431 < 915;\n  * order 3, 2, 1: 413 < 951.\n\n\n\nSince R < B is more frequent, the answer is \"BLUE\".\n\nIn the third sample case, R = B regardless of the card order, thus the bet is always a draw, and both Red and Blue have zero chance to win.",
        "task_name": "1459_A. Red-Blue Shuffle",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\nimport sys, math, bisect, itertools\n\ninput = lambda: sys.stdin.readline().rstrip()\ndef lii(): return list(map(int, input().split()))\ndef mii(): return map(int, input().split())\n\ndef solve():\n    a = int(input())\n    b = input(); c = input()\n    first = 0; second = 0\n    for i in range(a):\n        if (int(b[i]) > int(c[i])):\n            first += 1\n        elif (int(b[i]) < int(c[i])):\n            second += 1\n    if (first > second): \n        print(\"RED\")\n    elif (second > first): \n        print(\"BLUE\")\n    else: \n        print(\"EQUAL\")\n\ndef main():\n    for _ in range(int(input())):\n        solve()\n\nif __name__ == '__main__':\n  main()",
        "correct": true,
        "task_id": "0954",
        "depth": 1
    },
    {
        "description": "Bob got a job as a system administrator in X corporation. His first task was to connect n servers with the help of m two-way direct connection so that it becomes possible to transmit data from one server to any other server via these connections. Each direct connection has to link two different servers, each pair of servers should have at most one direct connection. Y corporation, a business rival of X corporation, made Bob an offer that he couldn't refuse: Bob was asked to connect the servers in such a way, that when server with index v fails, the transmission of data between some other two servers becomes impossible, i.e. the system stops being connected. Help Bob connect the servers.\n\nInput\n\nThe first input line contains 3 space-separated integer numbers n, m, v (3 \u2264 n \u2264 105, 0 \u2264 m \u2264 105, 1 \u2264 v \u2264 n), n \u2014 amount of servers, m \u2014 amount of direct connections, v \u2014 index of the server that fails and leads to the failure of the whole system.\n\nOutput\n\nIf it is impossible to connect the servers in the required way, output -1. Otherwise output m lines with 2 numbers each \u2014 description of all the direct connections in the system. Each direct connection is described by two numbers \u2014 indexes of two servers, linked by this direct connection. The servers are numbered from 1. If the answer is not unique, output any.\n\nExamples\n\nInput\n\n5 6 3\n\n\nOutput\n\n1 2\n2 3\n3 4\n4 5\n1 3\n3 5\n\n\nInput\n\n6 100 1\n\n\nOutput\n\n-1",
        "task_name": "22_C. System Administrator",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\n\n(n,m,v) = map(int, raw_input().split())\n\nif (m < (n-1)):\n  print(-1)\n  exit()\n\n# Were going to make node 0 lose connection with the rest of the network,\n# when node 1 fails. Put all nodes > 1 on the other side of 1 results in\n# the largest possible network.\n\n# Make a line\nedges = [(i, i+1) for i in xrange(n-1)]\n\n# Keep adding edges until the requested amount is reached (if possible)\nm = m - len(edges)\nnode1_nr = 1\nwhile ((m > 0) and (node1_nr < n)):\n  node2_nr = node1_nr + 2 # Edge from node1_nr to node1_nr+1 already exists\n  while ((m > 0) and (node2_nr < n)):\n    edges.append((node1_nr, node2_nr))\n    m -= 1\n    node2_nr += 1\n  node1_nr += 1\n\nif (m > 0):\n  # Unable to make the requested amount of edges\n  print(-1)\n  exit()\n\n# Make a translation table\ntranslate = [i+1 for i in xrange(n)]\ntranslate[v-1],translate[1] = translate[1],translate[v-1] # Swap v and 1\n\n# Construct output\noutput = [(\"%d %d\" % (translate[n1], translate[n2])) for (n1, n2) in edges]\nprint(\"\\n\".join(output))\n",
        "correct": true,
        "task_id": "0960",
        "depth": 2
    },
    {
        "description": "Very soon Berland will hold a School Team Programming Olympiad. From each of the m Berland regions a team of two people is invited to participate in the olympiad. The qualifying contest to form teams was held and it was attended by n Berland students. There were at least two schoolboys participating from each of the m regions of Berland. The result of each of the participants of the qualifying competition is an integer score from 0 to 800 inclusive.\n\nThe team of each region is formed from two such members of the qualifying competition of the region, that none of them can be replaced by a schoolboy of the same region, not included in the team and who received a greater number of points. There may be a situation where a team of some region can not be formed uniquely, that is, there is more than one school team that meets the properties described above. In this case, the region needs to undertake an additional contest. The two teams in the region are considered to be different if there is at least one schoolboy who is included in one team and is not included in the other team. It is guaranteed that for each region at least two its representatives participated in the qualifying contest.\n\nYour task is, given the results of the qualifying competition, to identify the team from each region, or to announce that in this region its formation requires additional contests.\n\nInput\n\nThe first line of the input contains two integers n and m (2 \u2264 n \u2264 100 000, 1 \u2264 m \u2264 10 000, n \u2265 2m) \u2014 the number of participants of the qualifying contest and the number of regions in Berland.\n\nNext n lines contain the description of the participants of the qualifying contest in the following format: Surname (a string of length from 1 to 10 characters and consisting of large and small English letters), region number (integer from 1 to m) and the number of points scored by the participant (integer from 0 to 800, inclusive).\n\nIt is guaranteed that all surnames of all the participants are distinct and at least two people participated from each of the m regions. The surnames that only differ in letter cases, should be considered distinct.\n\nOutput\n\nPrint m lines. On the i-th line print the team of the i-th region \u2014 the surnames of the two team members in an arbitrary order, or a single character \"?\" (without the quotes) if you need to spend further qualifying contests in the region.\n\nExamples\n\nInput\n\n5 2\nIvanov 1 763\nAndreev 2 800\nPetrov 1 595\nSidorov 1 790\nSemenov 2 503\n\n\nOutput\n\nSidorov Ivanov\nAndreev Semenov\n\n\nInput\n\n5 2\nIvanov 1 800\nAndreev 2 763\nPetrov 1 800\nSidorov 1 800\nSemenov 2 503\n\n\nOutput\n\n?\nAndreev Semenov\n\nNote\n\nIn the first sample region teams are uniquely determined.\n\nIn the second sample the team from region 2 is uniquely determined and the team from region 1 can have three teams: \"Petrov\"-\"Sidorov\", \"Ivanov\"-\"Sidorov\", \"Ivanov\" -\"Petrov\", so it is impossible to determine a team uniquely.",
        "task_name": "659_B. Qualifying Contest",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\n\nn, m = rints()\nmem, ans = [[] for _ in range(m + 1)], []\nfor _ in range(n):\n    a = rstrs()\n    mem[int(a[1])].append((int(a[-1]), a[0]))\n\nfor i in range(1, m + 1):\n    mem[i].sort()\n    tem = mem[i]\n    if len(tem) > 2 and tem[-3][0] in (tem[-1][0], tem[-2][0]):\n        ans.append('?')\n    else:\n        ans.append('%s %s' % (tem[-1][1], tem[-2][1]))\n\nprint('\\n'.join(ans))\n",
        "correct": true,
        "task_id": "0972",
        "depth": 1
    },
    {
        "description": "Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).\n\nThere are n members, numbered 1 through n. m pairs of members are friends. Of course, a member can't be a friend with themselves.\n\nLet A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.\n\nFor example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.\n\nCan you help Limak and check if the network is reasonable? Print \"YES\" or \"NO\" accordingly, without the quotes.\n\nInput\n\nThe first line of the input contain two integers n and m (3 \u2264 n \u2264 150 000, <image>) \u2014 the number of members and the number of pairs of members that are friends.\n\nThe i-th of the next m lines contains two distinct integers ai and bi (1 \u2264 ai, bi \u2264 n, ai \u2260 bi). Members ai and bi are friends with each other. No pair of members will appear more than once in the input.\n\nOutput\n\nIf the given network is reasonable, print \"YES\" in a single line (without the quotes). Otherwise, print \"NO\" in a single line (without the quotes).\n\nExamples\n\nInput\n\n4 3\n1 3\n3 4\n1 4\n\n\nOutput\n\nYES\n\n\nInput\n\n4 4\n3 1\n2 3\n3 4\n1 2\n\n\nOutput\n\nNO\n\n\nInput\n\n10 4\n4 3\n5 10\n8 9\n1 2\n\n\nOutput\n\nYES\n\n\nInput\n\n3 2\n1 2\n2 3\n\n\nOutput\n\nNO\n\nNote\n\nThe drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is \"NO\" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.\n\n<image>",
        "task_name": "771_A. Bear and Friendship Condition",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nn, m = map(int, stdin.readline().rstrip().split())\n#n, m = 4,3\ngraph = {}\nfor i in range(n):\n    graph[i+1] = []\nfor i in range(m):\n    edge = map(int, stdin.readline().rstrip().split())\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n#graph = {1:[3,4], 2:[], 3:[1,4], 4:[1,3]}\n\nleftToCheck = set([i+1 for i in range(n)])\nisGood = True\nwhile len(leftToCheck) > 0:\n    checkMe = leftToCheck.pop()\n    neighbors = graph[checkMe]\n    cliqueSize = len(neighbors)\n    for neighbor in neighbors:\n        if len(graph[neighbor]) != cliqueSize:\n            isGood = False\n            leftToCheck = set([])\n            break\n    leftToCheck.discard(set(neighbors))\n\nif isGood:\n    print('YES')\nelse:\n    print('NO')\n\n\n",
        "correct": false,
        "task_id": "0975",
        "depth": 2
    },
    {
        "description": "We have a string S of length N consisting of `R`, `G`, and `B`.\n\nFind the number of triples (i,~j,~k)~(1 \\leq i < j < k \\leq N) that satisfy both of the following conditions:\n\n* S_i \\neq S_j, S_i \\neq S_k, and S_j \\neq S_k.\n* j - i \\neq k - j.\n\nConstraints\n\n* 1 \\leq N \\leq 4000\n* S is a string of length N consisting of `R`, `G`, and `B`.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nS\n\n\nOutput\n\nPrint the number of triplets in question.\n\nExamples\n\nInput\n\n4\nRRGB\n\n\nOutput\n\n1\n\n\nInput\n\n39\nRBRBGRBGGBBRRGBBRRRBGGBRBGBRBGBRBBBGBBB\n\n\nOutput\n\n1800",
        "task_name": "p02714 AtCoder Beginner Contest 162 - RGB Triplets",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import bisect\nn = int(raw_input())\ns = raw_input()\nd = {}\nfor i in s:\n\td[i] = []\nfor i in range(len(s)):\n\td[s[i]].append(i)\np = d['R']\nq = d['G']\nr = d['B']\np1 = len(p)\nq1 = len(q)\nr1 = len(r)\nz = 0\nfor i in range(len(p)):\n\tfor j in range(len(q)):\n\t\tl = sorted([p[i],q[j]])\n\t\tto = bisect.bisect_left(r,l[1])\n\t\tisTrue = bisect.bisect_left(r[to:],2*l[1]-l[0])\n\t\ttry:\n\t\t\tif (r[to:])[isTrue] == 2*l[1]-l[0]:\n\t\t\t\tz+=r1-to-1\n\t\t\telse:\n\t\t\t\tz+=r1-to\n\t\texcept:\n\t\t\tz+=r1-to\nfor i in range(len(q)):\n\tfor j in range(len(r)):\n\t\tl = sorted([q[i],r[j]])\n\t\tto = bisect.bisect_left(p,l[1])\n\t\tisTrue = bisect.bisect_left(p[to:],2*l[1]-l[0])\n\t\ttry:\n\t\t\tif (p[to:])[isTrue] == 2*l[1]-l[0]:\n\t\t\t\tz+=p1-to-1\n\t\t\telse:\n\t\t\t\tz+=p1-to\n\t\texcept:\n\t\t\tz+=p1-to\n\t\t\nfor i in range(len(p)):\n\tfor j in range(len(r)):\n\t\tl = sorted([p[i],r[j]])\n\t\tto = bisect.bisect_left(q,l[1])\n\t\tisTrue = bisect.bisect_left(q[to:],2*l[1]-l[0])\n\t\ttry:\n\t\t\tif (q[to:])[isTrue] == 2*l[1]-l[0]:\n\t\t\t\tz+=q1-to-1\n\t\t\telse:\n\t\t\t\tz+=q1-to\n\t\texcept:\n\t\t\tz+=q1-to\n\nprint(z)\n",
        "correct": false,
        "task_id": "0984",
        "depth": 2
    },
    {
        "description": "Valera has got a rectangle table consisting of n rows and m columns. Valera numbered the table rows starting from one, from top to bottom and the columns \u2013 starting from one, from left to right. We will represent cell that is on the intersection of row x and column y by a pair of integers (x, y).\n\nValera wants to place exactly k tubes on his rectangle table. A tube is such sequence of table cells (x1, y1), (x2, y2), ..., (xr, yr), that: \n\n  * r \u2265 2; \n  * for any integer i (1 \u2264 i \u2264 r - 1) the following equation |xi - xi + 1| + |yi - yi + 1| = 1 holds; \n  * each table cell, which belongs to the tube, must occur exactly once in the sequence. \n\n\n\nValera thinks that the tubes are arranged in a fancy manner if the following conditions are fulfilled: \n\n  * no pair of tubes has common cells; \n  * each cell of the table belongs to some tube. \n\n\n\nHelp Valera to arrange k tubes on his rectangle table in a fancy manner.\n\nInput\n\nThe first line contains three space-separated integers n, m, k (2 \u2264 n, m \u2264 300; 2 \u2264 2k \u2264 n\u00b7m) \u2014 the number of rows, the number of columns and the number of tubes, correspondingly. \n\nOutput\n\nPrint k lines. In the i-th line print the description of the i-th tube: first print integer ri (the number of tube cells), then print 2ri integers xi1, yi1, xi2, yi2, ..., xiri, yiri (the sequence of table cells).\n\nIf there are multiple solutions, you can print any of them. It is guaranteed that at least one solution exists. \n\nExamples\n\nInput\n\n3 3 3\n\n\nOutput\n\n3 1 1 1 2 1 3\n3 2 1 2 2 2 3\n3 3 1 3 2 3 3\n\n\nInput\n\n2 3 1\n\n\nOutput\n\n6 1 1 1 2 1 3 2 3 2 2 2 1\n\nNote\n\nPicture for the first sample: \n\n<image>\n\nPicture for the second sample: \n\n<image>",
        "task_name": "441_C. Valera and Tubes ",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"Template for Python Competitive Programmers prepared by Mayank Chaudhary \"\"\"\n\n# to use the print and division function of Python3\nfrom __future__ import division, print_function\n\n\"\"\"value of mod\"\"\"\nMOD = 998244353\nmod = 10**9 + 7\n\n\"\"\"use resource\"\"\"\n# import resource\n# resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n\n\"\"\"for factorial\"\"\"\n\n# def prepare_factorial():\n#     fact = [1]\n#     for i in range(1, 1000005):\n#         fact.append((fact[-1] * i) % mod)\n#     ifact = [0] * 1000005\n#     ifact[1000004] = pow(fact[1000004], mod - 2, mod)\n#     for i in range(1000004, 0, -1):\n#         ifact[i - 1] = (i * ifact[i]) % mod\n#\n#     return fact, ifact\n\n\"\"\"uncomment next 4 lines while doing recursion based question\"\"\"\n# import threading\n# threading.stack_size(2**27)\nimport sys\n# sys.setrecursionlimit(30000)\n\n\n\"\"\"uncomment modules according to your need\"\"\"\n# from bisect import bisect_left, bisect_right, insort\n# import itertools\n# from math import floor, ceil, sqrt, degrees, atan, pi\n# from heapq import heappop, heapify, heappush\n# from random import randint as rn\n# from Queue import Queue as Q\n# from collections import Counter, defaultdict, deque\nfrom copy import deepcopy\n'''\ndef modinv(n, p):\n    return pow(n, p - 2, p)\n'''\n\n\n# def ncr(n, r,  fact, ifact):  # for using this uncomment the lines calculating fact and ifact\n#     t = (fact[n] * (ifact[r]*ifact[n-r]) % mod)% mod\n#     return t\n\n\n\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\n\n\ndef GCD(x, y):\n    while (y):\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x*y)//(GCD(x, y))\n\n# def get_xor(n):\n#     return [n,1,n+1,0][n%4]\n\n# def binary_expo(a, b):\n#\n#     result = 1\n#     while b:\n#         if b&1:\n#             result *= a\n#             b-=1\n#         else:\n#             a *= a\n#             b >>= 1\n#     return result\n\n\n\n\"\"\"*******************************************************\"\"\"\n\n\ndef main():\n\n    rows, cols, k = get_ints()\n\n    curr_x = curr_y = 0\n    turn = 0\n    store = []\n    for i in range(rows):\n        if not turn:\n            for j in range(cols):\n                store.append([i+1, j+1])\n        else:\n            for j in range(cols-1, -1, -1):\n                store.append([i+1, j+1])\n        turn ^= 1\n\n    i = 0\n    count = 0\n    while count<(k-1):\n        print(2, end = ' ')\n        print(*store[i], end = ' ')\n        print(*store[i+1])\n        i += 2\n        count += 1\n    print(rows*cols - 2*(k-1), end = ' ')\n    while i<(rows*cols):\n        if i==(rows*cols - 1):\n            print(*store[i])\n        else:\n            print(*store[i], end = ' ')\n        i += 1\n\n\n\n\n\n\n\n\"\"\" -------- Python 2 and 3 footer by Pajenegod and c1729 ---------\"\"\"\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\n\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill();\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode('ascii'))\n            self.read = lambda: self.buffer.read().decode('ascii')\n            self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\"\"\" main function\"\"\"\n\nif __name__ == '__main__':\n    main()\n    # threading.Thread(target=main).start()",
        "correct": true,
        "task_id": "1008",
        "depth": 2
    },
    {
        "description": "Nikolay has a lemons, b apples and c pears. He decided to cook a compote. According to the recipe the fruits should be in the ratio 1: 2: 4. It means that for each lemon in the compote should be exactly 2 apples and exactly 4 pears. You can't crumble up, break up or cut these fruits into pieces. These fruits \u2014 lemons, apples and pears \u2014 should be put in the compote as whole fruits.\n\nYour task is to determine the maximum total number of lemons, apples and pears from which Nikolay can cook the compote. It is possible that Nikolay can't use any fruits, in this case print 0. \n\nInput\n\nThe first line contains the positive integer a (1 \u2264 a \u2264 1000) \u2014 the number of lemons Nikolay has. \n\nThe second line contains the positive integer b (1 \u2264 b \u2264 1000) \u2014 the number of apples Nikolay has. \n\nThe third line contains the positive integer c (1 \u2264 c \u2264 1000) \u2014 the number of pears Nikolay has.\n\nOutput\n\nPrint the maximum total number of lemons, apples and pears from which Nikolay can cook the compote.\n\nExamples\n\nInput\n\n2\n5\n7\n\n\nOutput\n\n7\n\n\nInput\n\n4\n7\n13\n\n\nOutput\n\n21\n\n\nInput\n\n2\n3\n2\n\n\nOutput\n\n0\n\nNote\n\nIn the first example Nikolay can use 1 lemon, 2 apples and 4 pears, so the answer is 1 + 2 + 4 = 7.\n\nIn the second example Nikolay can use 3 lemons, 6 apples and 12 pears, so the answer is 3 + 6 + 12 = 21.\n\nIn the third example Nikolay don't have enough pears to cook any compote, so the answer is 0. ",
        "task_name": "746_A. Compote",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def compot(x, y, z):\n    if (z<4) or (y<2) or (x<1):\n        return 0\n    else:\n        delit = z / 4\n        while delit >= 1:\n            if ((y / delit) >= 1) and ((x / delit) >= 1):\n                return delit\n\n            else:\n                delit = delit - 1\n\nif __name__ == '__main__':\n    limon = int(raw_input())\n    yabl = int(raw_input())\n    grush = int(raw_input())\n    delit = compot(limon, yabl, grush)\n    print(str(delit*7))",
        "correct": false,
        "task_id": "1015",
        "depth": 1
    },
    {
        "description": "There are N cities and M roads. The i-th road (1\u2264i\u2264M) connects two cities a_i and b_i (1\u2264a_i,b_i\u2264N) bidirectionally. There may be more than one road that connects the same pair of two cities. For each city, how many roads are connected to the city?\n\nConstraints\n\n* 2\u2264N,M\u226450\n* 1\u2264a_i,b_i\u2264N\n* a_i \u2260 b_i\n* All input values are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN M\na_1 b_1\n:\na_M b_M\n\n\nOutput\n\nPrint the answer in N lines. In the i-th line (1\u2264i\u2264N), print the number of roads connected to city i.\n\nExamples\n\nInput\n\n4 3\n1 2\n2 3\n1 4\n\n\nOutput\n\n2\n2\n1\n1\n\n\nInput\n\n2 5\n1 2\n2 1\n1 2\n2 1\n1 2\n\n\nOutput\n\n5\n5\n\n\nInput\n\n8 8\n1 2\n3 4\n1 5\n2 8\n3 7\n5 2\n4 1\n6 8\n\n\nOutput\n\n3\n3\n2\n2\n2\n1\n1\n2",
        "task_name": "p03720 AtCoder Beginner Contest 061 - Counting Roads",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, m = map(int, raw_input().split())\ncount = [0] * n\nfor i in xrange(m):\n    a, b = map(int, raw_input().split())\n    count[a - 1] += 1\n    count[b - 1] += 1\nfor i in xrange(n):\n    print(count[i])\n",
        "correct": true,
        "task_id": "1027",
        "depth": 1
    },
    {
        "description": "One day, little Vasya found himself in a maze consisting of (n + 1) rooms, numbered from 1 to (n + 1). Initially, Vasya is at the first room and to get out of the maze, he needs to get to the (n + 1)-th one.\n\nThe maze is organized as follows. Each room of the maze has two one-way portals. Let's consider room number i (1 \u2264 i \u2264 n), someone can use the first portal to move from it to room number (i + 1), also someone can use the second portal to move from it to room number pi, where 1 \u2264 pi \u2264 i.\n\nIn order not to get lost, Vasya decided to act as follows. \n\n  * Each time Vasya enters some room, he paints a cross on its ceiling. Initially, Vasya paints a cross at the ceiling of room 1. \n  * Let's assume that Vasya is in room i and has already painted a cross on its ceiling. Then, if the ceiling now contains an odd number of crosses, Vasya uses the second portal (it leads to room pi), otherwise Vasya uses the first portal. \n\n\n\nHelp Vasya determine the number of times he needs to use portals to get to room (n + 1) in the end.\n\nInput\n\nThe first line contains integer n (1 \u2264 n \u2264 103) \u2014 the number of rooms. The second line contains n integers pi (1 \u2264 pi \u2264 i). Each pi denotes the number of the room, that someone can reach, if he will use the second portal in the i-th room.\n\nOutput\n\nPrint a single number \u2014 the number of portal moves the boy needs to go out of the maze. As the number can be rather large, print it modulo 1000000007 (109 + 7).\n\nExamples\n\nInput\n\n2\n1 2\n\n\nOutput\n\n4\n\n\nInput\n\n4\n1 1 2 3\n\n\nOutput\n\n20\n\n\nInput\n\n5\n1 1 1 1 1\n\n\nOutput\n\n62",
        "task_name": "408_D. Long Path",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n# coding: utf-8\n\n# # B. Long Path\n# \n# - time limit per test: 1 second\n# - memory limit per test: 256 megabytes\n# - input: standard input\n# - output: standard output\n# \n# One day, little Vasya found himself in a maze consisting of (n\u2009+\u20091) rooms, numbered from 1 to (n\u2009+\u20091). Initially, Vasya is at the first room and to get out of the maze, he needs to get to the (n\u2009+\u20091)-th one.\n# \n# The maze is organized as follows. Each room of the maze has two one-way portals. Let's consider room number i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), someone can use the first portal to move from it to room number (i\u2009+\u20091), also someone can use the second portal to move from it to room number pi, where 1\u2009\u2264\u2009pi\u2009\u2264\u2009i.\n# \n# In order not to get lost, Vasya decided to act as follows.\n# \n# - Each time Vasya enters some room, he paints a cross on its ceiling. Initially, Vasya paints a cross at the ceiling of room 1.\n# \n# - Let's assume that Vasya is in room i and has already painted a cross on its ceiling. Then, if the ceiling now contains an odd number of crosses, Vasya uses the second portal (it leads to room pi), otherwise Vasya uses the first portal. \n# \n# Help Vasya determine the number of times he needs to use portals to get to room (n\u2009+\u20091) in the end.\n# \n# #### Input\n# \n# The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009103) \u2014 the number of rooms. The second line contains n integers pi (1\u2009\u2264\u2009pi\u2009\u2264\u2009i). Each pi denotes the number of the room, that someone can reach, if he will use the second portal in the i-th room.\n# \n# #### Output\n# \n# Print a single number \u2014 the number of portal moves the boy needs to go out of the maze. As the number can be rather large, print it modulo 1000000007 (109\u2009+\u20097).\n# \n# #### Examples\n# \n# Input\n# ```\n# 2\n# 1 2\n# ```\n# \n# Output\n# ```\n# 4\n# ```\n# \n# Input\n# ```\n# 4\n# 1 1 2 3\n# ```\n# \n# Output\n# ```\n# 20\n# ```\n# \n# Input\n# ```\n# 5\n# 1 1 1 1 1\n# ```\n# \n# Output\n# ```\n# 62\n# ```\n\n# ### Standard Input Generator\n\n# In[66]:\n\nimport sys\n\n\ndef example_generator(line):\n    \"\"\"Read example from stdin and parse it into the appropriate data structure\n    \n    Use in the following way:\n    \n    example = example_generator(stdin_generator)\n    while True:\n        numbers, target = next(example)\n        .\n        .\n        .\n    \n    \"\"\"\n    while True:\n        n = int(next(line).strip())\n        P = [int(p_i)-1 for p_i in next(line).split()] # convert to zero-indexing\n        \n        yield n, P\n\n\n# ### Workhorse Functions\n\n# In[68]:\n\ndef do_maze(n, p):\n    \"\"\"Print out the number of times Vasya needs to use portals to get to room n+1\n    \n    dp[i] is the number of portal jumps required to start off at room i with an odd\n    number of crosses and get back to room i with an even number of crosses.\n    \n    Hence the recurrence relation is as follows:\n    \n    dp[i] = 1 + [Sum_{j = p(i)}^{i-1} dp[j] + 1]\n    \n    This can be read as \"the number of portal jumps to get from room i with an odd\n    number of crosses to an even number of crosses is equivalent to taking a portal\n    jump to room p(i) into an odd number of crosees (+1), getting back into that\n    state with an even number of crosses (Sum part).\n    \n    \"\"\"\n    dp = [0]*n\n    \n    for i in range(n):\n        \n        portal_jumps = 1 # initial jump from from i to p[i]\n        \n        # This block would read cleaner if it was just a for loop!\n        for j in range(p[i], i):\n            portal_jumps += dp[j] % (1e9+7) # jumps to get you from room j with odd to room j with even\n            portal_jumps += 1 % (1e9+7) # extra jump to get you from j to j+1\n            \n        dp[i] = int(portal_jumps % (1e9+7))\n        \n    total_pjumps = 0    \n    for i in range(n):\n        total_pjumps += dp[i] % (1e9+7)\n        total_pjumps += 1 % (1e9+7)\n        \n    print(total_pjumps)\n\n\nexample = example_generator(sys.stdin)\n\nif __name__ == '__main__':\n    n, P = next(example)\n\n    do_maze(n, P)\n",
        "correct": false,
        "task_id": "1046",
        "depth": 2
    },
    {
        "description": "You are given two integers K and S.\nThree variable X, Y and Z takes integer values satisfying 0\u2264X,Y,Z\u2264K.\nHow many different assignments of values to X, Y and Z are there such that X + Y + Z = S?\n\nConstraints\n\n* 2\u2264K\u22642500\n* 0\u2264S\u22643K\n* K and S are integers.\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nK S\n\n\nOutput\n\nPrint the number of the triples of X, Y and Z that satisfy the condition.\n\nExamples\n\nInput\n\n2 2\n\n\nOutput\n\n6\n\n\nInput\n\n5 15\n\n\nOutput\n\n1",
        "task_name": "p03835 AtCoder Beginner Contest 051 - Sum of Three Integers",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "# vim: set fileencoding=utf-8 :\nk, s = map(int, raw_input().split())\npatterns = []\nct = 0\n\nfor x in range(k + 1):\n    nokori = s - x\n    for y in range(k + 1):\n        if 0 <= nokori - y <= k:\n            ct += 1\n\nprint(ct)\n",
        "correct": true,
        "task_id": "1061",
        "depth": 2
    },
    {
        "description": "Once upon a time in the Kingdom of Far Far Away lived Sam the Farmer. Sam had a cow named Dawn and he was deeply attached to her. Sam would spend the whole summer stocking hay to feed Dawn in winter. Sam scythed hay and put it into haystack. As Sam was a bright farmer, he tried to make the process of storing hay simpler and more convenient to use. He collected the hay into cubical hay blocks of the same size. Then he stored the blocks in his barn. After a summer spent in hard toil Sam stored A\u00b7B\u00b7C hay blocks and stored them in a barn as a rectangular parallelepiped A layers high. Each layer had B rows and each row had C blocks.\n\nAt the end of the autumn Sam came into the barn to admire one more time the hay he'd been stacking during this hard summer. Unfortunately, Sam was horrified to see that the hay blocks had been carelessly scattered around the barn. The place was a complete mess. As it turned out, thieves had sneaked into the barn. They completely dissembled and took away a layer of blocks from the parallelepiped's front, back, top and sides. As a result, the barn only had a parallelepiped containing (A - 1) \u00d7 (B - 2) \u00d7 (C - 2) hay blocks. To hide the evidence of the crime, the thieves had dissembled the parallelepiped into single 1 \u00d7 1 \u00d7 1 blocks and scattered them around the barn. After the theft Sam counted n hay blocks in the barn but he forgot numbers A, B \u0438 C.\n\nGiven number n, find the minimally possible and maximally possible number of stolen hay blocks.\n\nInput\n\nThe only line contains integer n from the problem's statement (1 \u2264 n \u2264 109).\n\nOutput\n\nPrint space-separated minimum and maximum number of hay blocks that could have been stolen by the thieves.\n\nNote that the answer to the problem can be large enough, so you must use the 64-bit integer type for calculations. Please, do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.\n\nExamples\n\nInput\n\n4\n\n\nOutput\n\n28 41\n\n\nInput\n\n7\n\n\nOutput\n\n47 65\n\n\nInput\n\n12\n\n\nOutput\n\n48 105\n\nNote\n\nLet's consider the first sample test. If initially Sam has a parallelepiped consisting of 32 = 2 \u00d7 4 \u00d7 4 hay blocks in his barn, then after the theft the barn has 4 = (2 - 1) \u00d7 (4 - 2) \u00d7 (4 - 2) hay blocks left. Thus, the thieves could have stolen 32 - 4 = 28 hay blocks. If Sam initially had a parallelepiped consisting of 45 = 5 \u00d7 3 \u00d7 3 hay blocks in his barn, then after the theft the barn has 4 = (5 - 1) \u00d7 (3 - 2) \u00d7 (3 - 2) hay blocks left. Thus, the thieves could have stolen 45 - 4 = 41 hay blocks. No other variants of the blocks' initial arrangement (that leave Sam with exactly 4 blocks after the theft) can permit the thieves to steal less than 28 or more than 41 blocks.",
        "task_name": "142_A. Help Farmer",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\nimport math\n\ndef doit(A,B,C): return 2*(A+1)*(B+C+2) + B*C\n\nn=eval(sys.stdin.readline().strip('\\n\\r ').split()[0])\n\nif n==1:\n  print( \"17 17\")\n  exit(0)\n\nr=int(math.sqrt(float(n))) + 1\nr3=int(10**(math.log10(float(n))/3)) - 1\n\nmx = (8*n) + 9\nmn = mx\nwhile r>0:\n  if (n%r)==0:\n    A = r\n    m = n / r\n    B = int( math.sqrt(float(m)) ) + 1\n    while B>0:\n      if (m%B) == 0:\n        C = m/B\n        mn = min( [mn, doit(A,B,C),doit(B,A,C),doit(C,B,A)] )\n      B-=1\n  r-=1\n\nprint( \"%d %d\" % ( mn, mx, ) )\n",
        "correct": true,
        "task_id": "1073",
        "depth": 2
    },
    {
        "description": "You have n chains, the i-th chain consists of c_i vertices. Vertices in each chain are numbered independently from 1 to c_i along the chain. In other words, the i-th chain is the undirected graph with c_i vertices and (c_i - 1) edges connecting the j-th and the (j + 1)-th vertices for each 1 \u2264 j < c_i.\n\nNow you decided to unite chains in one graph in the following way: \n\n  1. the first chain is skipped; \n  2. the 1-st vertex of the i-th chain is connected by an edge with the a_i-th vertex of the (i - 1)-th chain; \n  3. the last (c_i-th) vertex of the i-th chain is connected by an edge with the b_i-th vertex of the (i - 1)-th chain. \n\n<image> Picture of the first test case. Dotted lines are the edges added during uniting process\n\nCalculate the length of the longest simple cycle in the resulting graph.\n\nA simple cycle is a chain where the first and last vertices are connected as well. If you travel along the simple cycle, each vertex of this cycle will be visited exactly once.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of each test case contains the single integer n (2 \u2264 n \u2264 10^5) \u2014 the number of chains you have.\n\nThe second line of each test case contains n integers c_1, c_2, ..., c_n (2 \u2264 c_i \u2264 10^9) \u2014 the number of vertices in the corresponding chains.\n\nThe third line of each test case contains n integers a_1, a_2, ..., a_n (a_1 = -1; 1 \u2264 a_i \u2264 c_{i - 1}).\n\nThe fourth line of each test case contains n integers b_1, b_2, ..., b_n (b_1 = -1; 1 \u2264 b_i \u2264 c_{i - 1}).\n\nBoth a_1 and b_1 are equal to -1, they aren't used in graph building and given just for index consistency. It's guaranteed that the sum of n over all test cases doesn't exceed 10^5.\n\nOutput\n\nFor each test case, print the length of the longest simple cycle.\n\nExample\n\nInput\n\n\n3\n4\n3 4 3 3\n-1 1 2 2\n-1 2 2 3\n2\n5 6\n-1 5\n-1 1\n3\n3 5 2\n-1 1 1\n-1 3 5\n\n\nOutput\n\n\n7\n11\n8\n\nNote\n\nIn the first test case, the longest simple cycle is shown below: \n\n<image>\n\nWe can't increase it with the first chain, since in such case it won't be simple \u2014 the vertex 2 on the second chain will break simplicity.",
        "task_name": "1476_C. Longest Simple Cycle",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    t = int(input())\n\n    for _ in range(t):\n        n = int(input())\n        c = [int(ci) for ci in input().split()]\n        a = [int(ai) for ai in input().split()]\n        b = [int(bi) for bi in input().split()]\n\n        for i in range(n):\n            a[i], b[i] = min(a[i], b[i]), max(a[i], b[i])\n\n        best = 1\n        curr = b[1] - a[1] + 1\n\n        for i in range(1, n):\n            best = max(best, curr + c[i])\n\n            if i != n - 1:\n                curr += a[i + 1] + (c[i] - b[i + 1] + 1)\n                if a[i + 1] == b[i + 1]:\n                    curr = 1\n\n        print(best)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": false,
        "task_id": "1074",
        "depth": 2
    },
    {
        "description": "Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are n watchmen on a plane, the i-th watchman is located at point (xi, yi).\n\nThey need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen i and j to be |xi - xj| + |yi - yj|. Daniel, as an ordinary person, calculates the distance using the formula <image>.\n\nThe success of the operation relies on the number of pairs (i, j) (1 \u2264 i < j \u2264 n), such that the distance between watchman i and watchmen j calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.\n\nInput\n\nThe first line of the input contains the single integer n (1 \u2264 n \u2264 200 000) \u2014 the number of watchmen.\n\nEach of the following n lines contains two integers xi and yi (|xi|, |yi| \u2264 109).\n\nSome positions may coincide.\n\nOutput\n\nPrint the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.\n\nExamples\n\nInput\n\n3\n1 1\n7 5\n1 5\n\n\nOutput\n\n2\n\n\nInput\n\n6\n0 0\n0 1\n0 2\n-1 1\n0 1\n1 1\n\n\nOutput\n\n11\n\nNote\n\nIn the first sample, the distance between watchman 1 and watchman 2 is equal to |1 - 7| + |1 - 5| = 10 for Doctor Manhattan and <image> for Daniel. For pairs (1, 1), (1, 5) and (7, 5), (1, 5) Doctor Manhattan and Daniel will calculate the same distances.",
        "task_name": "651_C. Watchmen",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\n\nrows = {}\ncols = {}\nposi = {}\nfor i in range(n):\n\tx, y = [int(t) for t in raw_input().split(' ')]\n\tif(x in rows):\n\t\trows[x] += 1\n\telse:\n\t\trows[x] = 1\n\tif(y in cols):\n\t\tcols[y] += 1\n\telse:\n\t\tcols[y] = 1\n\tif((x, y) in posi):\n\t\tposi[(x, y)] += 1\n\telse:\n\t\tposi[(x, y)] = 1\n\nans = 0\nfor t in rows.keys():\n\tans = ans + (rows[t] - 1) * rows[t] / 2\n\nfor t in cols.keys():\n\tans = ans + (cols[t] - 1) * cols[t] / 2\n\nfor t in posi.keys():\n\tif(posi[t] > 1):\n\t\tans -= (posi[t] - 1) * posi[t] / 2\n\nprint(ans)",
        "correct": true,
        "task_id": "1085",
        "depth": 1
    },
    {
        "description": "Vladik is a competitive programmer. This year he is going to win the International Olympiad in Informatics. But it is not as easy as it sounds: the question Vladik face now is to find the cheapest way to get to the olympiad.\n\nVladik knows n airports. All the airports are located on a straight line. Each airport has unique id from 1 to n, Vladik's house is situated next to the airport with id a, and the place of the olympiad is situated next to the airport with id b. It is possible that Vladik's house and the place of the olympiad are located near the same airport. \n\nTo get to the olympiad, Vladik can fly between any pair of airports any number of times, but he has to start his route at the airport a and finish it at the airport b.\n\nEach airport belongs to one of two companies. The cost of flight from the airport i to the airport j is zero if both airports belong to the same company, and |i - j| if they belong to different companies.\n\nPrint the minimum cost Vladik has to pay to get to the olympiad.\n\nInput\n\nThe first line contains three integers n, a, and b (1 \u2264 n \u2264 105, 1 \u2264 a, b \u2264 n) \u2014 the number of airports, the id of the airport from which Vladik starts his route and the id of the airport which he has to reach. \n\nThe second line contains a string with length n, which consists only of characters 0 and 1. If the i-th character in this string is 0, then i-th airport belongs to first company, otherwise it belongs to the second.\n\nOutput\n\nPrint single integer \u2014 the minimum cost Vladik has to pay to get to the olympiad.\n\nExamples\n\nInput\n\n4 1 4\n1010\n\n\nOutput\n\n1\n\nInput\n\n5 5 2\n10110\n\n\nOutput\n\n0\n\nNote\n\nIn the first example Vladik can fly to the airport 2 at first and pay |1 - 2| = 1 (because the airports belong to different companies), and then fly from the airport 2 to the airport 4 for free (because the airports belong to the same company). So the cost of the whole flight is equal to 1. It's impossible to get to the olympiad for free, so the answer is equal to 1. \n\nIn the second example Vladik can fly directly from the airport 5 to the airport 2, because they belong to the same company.",
        "task_name": "743_A. Vladik and flights",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nn, s, f = map(int, stdin.readline().split())\nnumbers = list(map(int, list(stdin.readline().strip())))\ncnt = [0 for i in range(n)]\ns -= 1\nf -= 1\n\ns, f = min(s, f), max(s, f)\n\nif numbers[0] == numbers[s]:\n    cnt[0] = 1\n    \nfor i in range(1, n):\n    if numbers[i] == numbers[s]:\n        cnt[i] = cnt[i - 1] + 1\n    else:\n        cnt[i] = cnt[i - 1]\n\nans = f - s\nif numbers[s] != numbers[f]:\n    l = -1\n    r = n\n    while (r > l + 1):\n        m = (r + l) // 2\n        if cnt[m] > cnt[f]:\n            r = m\n        else:\n            l = m\n       \n    \n    l = -1  \n    r = n\n    while (r > l + 1):\n        m = (r + l) // 2\n        if cnt[m] >= cnt[f]:\n            r = m\n        else:\n            l = m\n            \n    if r != n:\n        ans = min(ans, f - r)\nelse:\n    ans = 0\n    \nstdout.write(str(ans))",
        "correct": false,
        "task_id": "1089",
        "depth": 1
    },
    {
        "description": "Mahmoud wrote a message s of length n. He wants to send it as a birthday present to his friend Moaz who likes strings. He wrote it on a magical paper but he was surprised because some characters disappeared while writing the string. That's because this magical paper doesn't allow character number i in the English alphabet to be written on it in a string of length more than ai. For example, if a1 = 2 he can't write character 'a' on this paper in a string of length 3 or more. String \"aa\" is allowed while string \"aaa\" is not.\n\nMahmoud decided to split the message into some non-empty substrings so that he can write every substring on an independent magical paper and fulfill the condition. The sum of their lengths should be n and they shouldn't overlap. For example, if a1 = 2 and he wants to send string \"aaa\", he can split it into \"a\" and \"aa\" and use 2 magical papers, or into \"a\", \"a\" and \"a\" and use 3 magical papers. He can't split it into \"aa\" and \"aa\" because the sum of their lengths is greater than n. He can split the message into single string if it fulfills the conditions.\n\nA substring of string s is a string that consists of some consecutive characters from string s, strings \"ab\", \"abc\" and \"b\" are substrings of string \"abc\", while strings \"acb\" and \"ac\" are not. Any string is a substring of itself.\n\nWhile Mahmoud was thinking of how to split the message, Ehab told him that there are many ways to split it. After that Mahmoud asked you three questions: \n\n  * How many ways are there to split the string into substrings such that every substring fulfills the condition of the magical paper, the sum of their lengths is n and they don't overlap? Compute the answer modulo 109 + 7. \n  * What is the maximum length of a substring that can appear in some valid splitting? \n  * What is the minimum number of substrings the message can be spit in? \n\n\n\nTwo ways are considered different, if the sets of split positions differ. For example, splitting \"aa|a\" and \"a|aa\" are considered different splittings of message \"aaa\".\n\nInput\n\nThe first line contains an integer n (1 \u2264 n \u2264 103) denoting the length of the message.\n\nThe second line contains the message s of length n that consists of lowercase English letters.\n\nThe third line contains 26 integers a1, a2, ..., a26 (1 \u2264 ax \u2264 103) \u2014 the maximum lengths of substring each letter can appear in.\n\nOutput\n\nPrint three lines.\n\nIn the first line print the number of ways to split the message into substrings and fulfill the conditions mentioned in the problem modulo 109 + 7.\n\nIn the second line print the length of the longest substring over all the ways.\n\nIn the third line print the minimum number of substrings over all the ways.\n\nExamples\n\nInput\n\n3\naab\n2 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n\nOutput\n\n3\n2\n2\n\n\nInput\n\n10\nabcdeabcde\n5 5 5 5 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n\nOutput\n\n401\n4\n3\n\nNote\n\nIn the first example the three ways to split the message are: \n\n  * a|a|b\n  * aa|b\n  * a|ab\n\n\n\nThe longest substrings are \"aa\" and \"ab\" of length 2.\n\nThe minimum number of substrings is 2 in \"a|ab\" or \"aa|b\".\n\nNotice that \"aab\" is not a possible splitting because the letter 'a' appears in a substring of length 3, while a1 = 2.",
        "task_name": "766_C. Mahmoud and a Message",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import print_function;\nn=input();\nstr=raw_input();\narr=raw_input().split();\narr=map(eval,arr);\n\nMOD=1e9+7;\ndp=[0]*3200;\ndp[0]=1;\nlastMatch=[0]*3200;\nfor i in range(len(lastMatch)) :\n\tlastMatch[i]=i;\nmaxSubLen=0;\nfor i in range(1,len(str)+1) :\n\tj=1;\n\tk=arr[ord(str[i-1])-ord('a')];\n\twhile j<=k and i-j>=0 :\n\t\tmaxSubLen=max(j,maxSubLen);\n\t\tdp[i]=(dp[i]+dp[i-j])%MOD;\n\t\tt=i-j-1;\n\t\tlastMatch[t+1]=max(lastMatch[t+1],i-1);\n\t\tt=t if t>0 else 0;\n\t\tk=min(k,arr[ord(str[t])-ord('a')]);\n\t\tj+=1;\t\nlastIndex=0;\nlastStrIndex=len(str)-1;\nsubNum=0;\nwhile lastIndex!=lastStrIndex :\n\tsubNum+=1;\n\tif lastIndex==lastMatch[lastIndex] :\n\t\tlastIndex+=1;\n\telse :\n\t\tlastIndex=lastMatch[lastIndex];\n\nprint(dp[len(str)],maxSubLen,subNum,sep='\\n');\n",
        "correct": false,
        "task_id": "1090",
        "depth": 2
    },
    {
        "description": "You are given a text of single-space separated words, consisting of small and capital Latin letters.\n\nVolume of the word is number of capital letters in the word. Volume of the text is maximum volume of all words in the text.\n\nCalculate the volume of the given text.\n\nInput\n\nThe first line contains one integer number n (1 \u2264 n \u2264 200) \u2014 length of the text.\n\nThe second line contains text of single-space separated words s1, s2, ..., si, consisting only of small and capital Latin letters.\n\nOutput\n\nPrint one integer number \u2014 volume of text.\n\nExamples\n\nInput\n\n7\nNonZERO\n\n\nOutput\n\n5\n\n\nInput\n\n24\nthis is zero answer text\n\n\nOutput\n\n0\n\n\nInput\n\n24\nHarbour Space University\n\n\nOutput\n\n1\n\nNote\n\nIn the first example there is only one word, there are 5 capital letters in it.\n\nIn the second example all of the words contain 0 capital letters.",
        "task_name": "837_A. Text Volume",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "raw_input()\nl=raw_input().split()\nm=0\nfor i in l :\n    s=0\n    for j in i:\n        if j.isupper() :\n              s+=1\n    m=max(s,m)\n        \nprint(m)\n        \n",
        "correct": true,
        "task_id": "1092",
        "depth": 2
    },
    {
        "description": "There are n slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.\n\nAny slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). \n\nWhen a slime with a value x eats a slime with a value y, the eaten slime disappears, and the value of the remaining slime changes to x - y.\n\nThe slimes will eat each other until there is only one slime left. \n\nFind the maximum possible value of the last slime.\n\nInput\n\nThe first line of the input contains an integer n (1 \u2264 n \u2264 500 000) denoting the number of slimes.\n\nThe next line contains n integers a_i (-10^9 \u2264 a_i \u2264 10^9), where a_i is the value of i-th slime.\n\nOutput\n\nPrint an only integer \u2014 the maximum possible value of the last slime.\n\nExamples\n\nInput\n\n4\n2 1 2 1\n\n\nOutput\n\n4\n\nInput\n\n5\n0 -1 -1 -1 -1\n\n\nOutput\n\n4\n\nNote\n\nIn the first example, a possible way of getting the last slime with value 4 is:\n\n  * Second slime eats the third slime, the row now contains slimes 2, -1, 1\n  * Second slime eats the third slime, the row now contains slimes 2, -2\n  * First slime eats the second slime, the row now contains 4 \n\n\n\nIn the second example, the first slime can keep eating slimes to its right to end up with a value of 4.",
        "task_name": "1038_D. Slime",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, a = int(input()), rints()\nneg = len(list(filter(lambda x: x < 0, a)))\npos = n - neg\n\nif neg:\n    print(sum(abs(x) for x in a))\nelse:\n    ans, s = 0, sum(a)\n    for i in range(n):\n        if i and a[i] < a[i - 1]:\n            ans = max(ans, s - a[i - 1])\n        elif i < n - 1 and a[i] < a[i + 1]:\n            ans = max(ans, s - a[i + 1])\n\n    print(ans)\n",
        "correct": false,
        "task_id": "1105",
        "depth": 1
    },
    {
        "description": "Suppose there is a h \u00d7 w grid consisting of empty or full cells. Let's make some definitions:\n\n  * r_{i} is the number of consecutive full cells connected to the left side in the i-th row (1 \u2264 i \u2264 h). In particular, r_i=0 if the leftmost cell of the i-th row is empty. \n  * c_{j} is the number of consecutive full cells connected to the top end in the j-th column (1 \u2264 j \u2264 w). In particular, c_j=0 if the topmost cell of the j-th column is empty. \n\n\n\nIn other words, the i-th row starts exactly with r_i full cells. Similarly, the j-th column starts exactly with c_j full cells.\n\n<image> These are the r and c values of some 3 \u00d7 4 grid. Black cells are full and white cells are empty.\n\nYou have values of r and c. Initially, all cells are empty. Find the number of ways to fill grid cells to satisfy values of r and c. Since the answer can be very large, find the answer modulo 1000000007 (10^{9} + 7). In other words, find the remainder after division of the answer by 1000000007 (10^{9} + 7).\n\nInput\n\nThe first line contains two integers h and w (1 \u2264 h, w \u2264 10^{3}) \u2014 the height and width of the grid.\n\nThe second line contains h integers r_{1}, r_{2}, \u2026, r_{h} (0 \u2264 r_{i} \u2264 w) \u2014 the values of r.\n\nThe third line contains w integers c_{1}, c_{2}, \u2026, c_{w} (0 \u2264 c_{j} \u2264 h) \u2014 the values of c.\n\nOutput\n\nPrint the answer modulo 1000000007 (10^{9} + 7).\n\nExamples\n\nInput\n\n\n3 4\n0 3 1\n0 2 3 0\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n1 1\n0\n1\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n19 16\n16 16 16 16 15 15 0 5 0 4 9 9 1 4 4 0 8 16 12\n6 12 19 15 8 6 19 19 14 6 9 16 10 11 15 4\n\n\nOutput\n\n\n797922655\n\nNote\n\nIn the first example, this is the other possible case.\n\n<image>\n\nIn the second example, it's impossible to make a grid to satisfy such r, c values.\n\nIn the third example, make sure to print answer modulo (10^9 + 7).",
        "task_name": "1228_B. Filling the Grid",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    h, w = map(int, input().split())\n    r = [int(i) for i in input().split()]\n    c = [int(i) for i in input().split()]\n\n    base = [[0] * w for _ in range(h)]\n\n    for i, ri in enumerate(r):\n        for j in range(ri):\n            base[i][j] = 1\n    for i, ci in enumerate(c):\n        for j in range(ci):\n            base[j][i] = 1\n\n    for i in range(h):\n        if r[i] < w and base[i][r[i]] == 1:\n            print(0)\n            return\n    for i in range(w):\n        if c[i] < h and base[c[i]][i] == 1:\n            print(0)\n            return\n\n    n = 0\n\n    for i in range(1, h):\n        for j in range(1, w):\n            n += (r[i] < j) and (c[j] < i)\n\n    print(pow(2, n, 1000000007))\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "1111",
        "depth": 2
    },
    {
        "description": "Gerald plays the following game. He has a checkered field of size n \u00d7 n cells, where m various cells are banned. Before the game, he has to put a few chips on some border (but not corner) board cells. Then for n - 1 minutes, Gerald every minute moves each chip into an adjacent cell. He moves each chip from its original edge to the opposite edge. Gerald loses in this game in each of the three cases:\n\n  * At least one of the chips at least once fell to the banned cell. \n  * At least once two chips were on the same cell. \n  * At least once two chips swapped in a minute (for example, if you stand two chips on two opposite border cells of a row with even length, this situation happens in the middle of the row). \n\n\n\nIn that case he loses and earns 0 points. When nothing like that happened, he wins and earns the number of points equal to the number of chips he managed to put on the board. Help Gerald earn the most points.\n\nInput\n\nThe first line contains two space-separated integers n and m (2 \u2264 n \u2264 1000, 0 \u2264 m \u2264 105) \u2014 the size of the field and the number of banned cells. Next m lines each contain two space-separated integers. Specifically, the i-th of these lines contains numbers xi and yi (1 \u2264 xi, yi \u2264 n) \u2014 the coordinates of the i-th banned cell. All given cells are distinct.\n\nConsider the field rows numbered from top to bottom from 1 to n, and the columns \u2014 from left to right from 1 to n.\n\nOutput\n\nPrint a single integer \u2014 the maximum points Gerald can earn in this game.\n\nExamples\n\nInput\n\n3 1\n2 2\n\n\nOutput\n\n0\n\n\nInput\n\n3 0\n\n\nOutput\n\n1\n\n\nInput\n\n4 3\n3 1\n3 2\n3 3\n\n\nOutput\n\n1\n\nNote\n\nIn the first test the answer equals zero as we can't put chips into the corner cells.\n\nIn the second sample we can place one chip into either cell (1, 2), or cell (3, 2), or cell (2, 1), or cell (2, 3). We cannot place two chips.\n\nIn the third sample we can only place one chip into either cell (2, 1), or cell (2, 4).",
        "task_name": "333_B. Chips",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, m = rints()\nban, r, c, ans = [rints() for _ in range(m)], [1] * (n + 1), [1] * (n + 1), 0\n\nfor x, y in ban:\n    r[x], c[y] = 0, 0\n\nfor i in range(2, 2 + (n - 2) // 2):\n    ans += sum([r[i], r[n - i + 1], c[i], c[n - i + 1]])\n\nif n % 2 and (r[(n + 1) // 2] or c[(n + 1) // 2]):\n    ans += 1\n\nprint(ans)\n",
        "correct": true,
        "task_id": "1124",
        "depth": 1
    },
    {
        "description": "Mike is trying rock climbing but he is awful at it. \n\nThere are n holds on the wall, i-th hold is at height ai off the ground. Besides, let the sequence ai increase, that is, ai < ai + 1 for all i from 1 to n - 1; we will call such sequence a track. Mike thinks that the track a1, ..., an has difficulty <image>. In other words, difficulty equals the maximum distance between two holds that are adjacent in height.\n\nToday Mike decided to cover the track with holds hanging on heights a1, ..., an. To make the problem harder, Mike decided to remove one hold, that is, remove one element of the sequence (for example, if we take the sequence (1, 2, 3, 4, 5) and remove the third element from it, we obtain the sequence (1, 2, 4, 5)). However, as Mike is awful at climbing, he wants the final difficulty (i.e. the maximum difference of heights between adjacent holds after removing the hold) to be as small as possible among all possible options of removing a hold. The first and last holds must stay at their positions.\n\nHelp Mike determine the minimum difficulty of the track after removing one hold.\n\nInput\n\nThe first line contains a single integer n (3 \u2264 n \u2264 100) \u2014 the number of holds.\n\nThe next line contains n space-separated integers ai (1 \u2264 ai \u2264 1000), where ai is the height where the hold number i hangs. The sequence ai is increasing (i.e. each element except for the first one is strictly larger than the previous one).\n\nOutput\n\nPrint a single number \u2014 the minimum difficulty of the track after removing a single hold.\n\nExamples\n\nInput\n\n3\n1 4 6\n\n\nOutput\n\n5\n\n\nInput\n\n5\n1 2 3 4 5\n\n\nOutput\n\n2\n\n\nInput\n\n5\n1 2 3 7 8\n\n\nOutput\n\n4\n\nNote\n\nIn the first sample you can remove only the second hold, then the sequence looks like (1, 6), the maximum difference of the neighboring elements equals 5.\n\nIn the second test after removing every hold the difficulty equals 2.\n\nIn the third test you can obtain sequences (1, 3, 7, 8), (1, 2, 7, 8), (1, 2, 3, 8), for which the difficulty is 4, 5 and 5, respectively. Thus, after removing the second element we obtain the optimal answer \u2014 4.",
        "task_name": "496_A. Minimum Difficulty",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import fileinput\n\ndef str_to_int(s):\n\treturn([ int(x) for x in s.split() ])\n\n# args = [ 'line 1', 'line 2', ... ]\ndef proc_input(args):\n\ta_s = tuple(str_to_int(args[1]))\n\treturn(a_s)\n\ndef solve(args, verbose=False):\n\ta_s = proc_input(args)\n\tmax_1 = -float('inf')\n\tmin_2 = float('inf')\n\t# min_1\n\tfor k in xrange(len(a_s) - 1):\n\t\tmax_1 = max(max_1, a_s[k + 1] - a_s[k])\n\tfor k in xrange(len(a_s) - 2):\n\t\tmin_2 = min(min_2, a_s[k + 2] - a_s[k])\n\treturn(max(max_1, min_2))\n\ndef test():\n\tassert(str_to_int('1 2 3') == [ 1, 2, 3 ])\n\tassert(solve([ '3', '1 4 6' ]) == 5)\n\tassert(solve([ '5', '1 2 3 4 5' ]) == 2)\n\tassert(solve([ '5', '1 2 3 7 8' ]) == 4)\n\nif __name__ == '__main__':\n\tfrom sys import argv\n\tif argv.pop() == 'test':\n\t\ttest()\n\telse:\n\t\tsolve(list(fileinput.input()), verbose=True)\n",
        "correct": false,
        "task_id": "1129",
        "depth": 1
    },
    {
        "description": "There are N stones, numbered 1, 2, \\ldots, N. For each i (1 \\leq i \\leq N), the height of Stone i is h_i.\n\nThere is a frog who is initially on Stone 1. He will repeat the following action some number of times to reach Stone N:\n\n* If the frog is currently on Stone i, jump to one of the following: Stone i + 1, i + 2, \\ldots, i + K. Here, a cost of |h_i - h_j| is incurred, where j is the stone to land on.\n\n\n\nFind the minimum possible total cost incurred before the frog reaches Stone N.\n\nConstraints\n\n* All values in input are integers.\n* 2 \\leq N \\leq 10^5\n* 1 \\leq K \\leq 100\n* 1 \\leq h_i \\leq 10^4\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN K\nh_1 h_2 \\ldots h_N\n\n\nOutput\n\nPrint the minimum possible total cost incurred.\n\nExamples\n\nInput\n\n5 3\n10 30 40 50 20\n\n\nOutput\n\n30\n\n\nInput\n\n3 1\n10 20 10\n\n\nOutput\n\n20\n\n\nInput\n\n2 100\n10 10\n\n\nOutput\n\n0\n\n\nInput\n\n10 4\n40 10 20 70 80 10 20 70 80 60\n\n\nOutput\n\n40",
        "task_name": "p03161 Educational DP Contest - Frog 2",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n# import numpy as np\ninp = sys.stdin.readline\nread = lambda: list(map(int, inp().strip().split()))\n# import profile\n\ndef solve():\n    n, k =read(); arr = read()\n    dp = [-1]*n; dp[0] = 0\n    for i in range(n):\n    \tfor j in range(1, k+1):\n    \t\tif i-j >-1:\n    \t\t\ttem = dp[i-j]+abs(arr[i-j] - arr[i])\n    \t\t\tif dp[i] == -1:\n    \t\t\t\tdp[i] = tem\n    \t\t\telif dp[i] > tem:\n    \t\t\t\tdp[i] = tem\n    \t\t\t\t# dp[i] = min(dp[i], tem)\n    print(dp[-1])\n\ndef one():\n\tl = [0]*10**7\ndef two():\n\tl = [0 for i in range(10**7)]\n\nif __name__ == \"__main__\":\n\tsolve()\n\t# cProfile.run(solve())\n\t# profile.run(one())\n\t# cProfile.run()",
        "correct": true,
        "task_id": "1143",
        "depth": 2
    },
    {
        "description": "Taro has decided to move. Taro has a lot of luggage, so I decided to ask a moving company to carry the luggage. Since there are various weights of luggage, I asked them to arrange them in order from the lightest one for easy understanding, but the mover left the luggage in a different order. So Taro tried to sort the luggage, but the luggage is heavy and requires physical strength to carry. Each piece of luggage can be carried from where it is now to any place you like, such as between other pieces of luggage or at the edge of the piece of luggage, but carrying one piece of luggage uses as much physical strength as the weight of that piece of luggage. Taro doesn't have much physical strength, so I decided to think of a way to arrange the luggage in order from the lightest one without using as much physical strength as possible.\n\nConstraints\n\n> 1 \u2264 n \u2264 105\n> 1 \u2264 xi \u2264 n (1 \u2264 i \u2264 n)\n> xi \u2260 xj (1 \u2264 i, j \u2264 n and i \u2260 j)\n>\n\n* All inputs are given as integers\n\nInput\n\n> n\n> x1 x2 ... xn\n>\n\n* n represents the number of luggage that Taro has\n* x1 to xn represent the weight of each piece of luggage, and are currently arranged in the order of x1, x2, ..., xn.\n\nOutput\n\n> S\n>\n\n* Output the total S of the minimum physical strength required to arrange the luggage in order from the lightest, but output the line break at the end\n\nExamples\n\nInput\n\n4\n1 4 2 3\n\n\nOutput\n\n4\n\n\nInput\n\n5\n1 5 3 2 4\n\n\nOutput\n\n7\n\n\nInput\n\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n0\n\n\nInput\n\n8\n6 2 1 3 8 5 4 7\n\n\nOutput\n\n19",
        "task_name": "p01545 House Moving",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import math\nimport sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass FenwickTree:\n    def __init__(self, a_list, f, default):\n        # 0-indexed\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << (math.ceil(math.log(self.N, 2)))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | (i + 1)] = self.f(self.bit[i | (i + 1)], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        # [0, n]\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & (n + 1)) - 1\n        return ret\n\n\nN = int(input())\nX = [int(x) for x in input().split()]\ndp = FenwickTree([0] * N, lambda x, y: max(x, y), 0)\nfor x, i in sorted((x, i) for i, x in enumerate(X)):\n    dp.update(i, dp.query(i) + x)\nprint(N * (N + 1) // 2 - dp.query(N - 1))",
        "correct": false,
        "task_id": "1149",
        "depth": 1
    },
    {
        "description": "You are given a sequence of n integers a_1, a_2, \u2026, a_n.\n\nYou have to construct two sequences of integers b and c with length n that satisfy:\n\n  * for every i (1\u2264 i\u2264 n) b_i+c_i=a_i \n  * b is non-decreasing, which means that for every 1<i\u2264 n, b_i\u2265 b_{i-1} must hold \n  * c is non-increasing, which means that for every 1<i\u2264 n, c_i\u2264 c_{i-1} must hold \n\n\n\nYou have to minimize max(b_i,c_i). In other words, you have to minimize the maximum number in sequences b and c.\n\nAlso there will be q changes, the i-th change is described by three integers l,r,x. You should add x to a_l,a_{l+1}, \u2026, a_r. \n\nYou have to find the minimum possible value of max(b_i,c_i) for the initial sequence and for sequence after each change.\n\nInput\n\nThe first line contains an integer n (1\u2264 n\u2264 10^5).\n\nThe secound line contains n integers a_1,a_2,\u2026,a_n (1\u2264 i\u2264 n, -10^9\u2264 a_i\u2264 10^9).\n\nThe third line contains an integer q (1\u2264 q\u2264 10^5).\n\nEach of the next q lines contains three integers l,r,x (1\u2264 l\u2264 r\u2264 n,-10^9\u2264 x\u2264 10^9), desribing the next change. \n\nOutput\n\nPrint q+1 lines.\n\nOn the i-th (1 \u2264 i \u2264 q+1) line, print the answer to the problem for the sequence after i-1 changes.\n\nExamples\n\nInput\n\n\n4\n2 -1 7 3\n2\n2 4 -3\n3 4 2\n\n\nOutput\n\n\n5\n5\n6\n\n\nInput\n\n\n6\n-9 -10 -9 -6 -5 4\n3\n2 6 -9\n1 2 -10\n4 6 -3\n\n\nOutput\n\n\n3\n3\n3\n1\n\n\nInput\n\n\n1\n0\n2\n1 1 -1\n1 1 -1\n\n\nOutput\n\n\n0\n0\n-1\n\nNote\n\nIn the first test:\n\n  * The initial sequence a = (2, -1, 7, 3). Two sequences b=(-3,-3,5,5),c=(5,2,2,-2) is a possible choice. \n  * After the first change a = (2, -4, 4, 0). Two sequences b=(-3,-3,5,5),c=(5,-1,-1,-5) is a possible choice. \n  * After the second change a = (2, -4, 6, 2). Two sequences b=(-4,-4,6,6),c=(6,0,0,-4) is a possible choice. ",
        "task_name": "1406_D. Three Sequences",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n# import threading\n# threading.stack_size(2**27)\nimport sys\nsys.setrecursionlimit(10**4)\n# sys.stdin = open('inpy.txt', 'r')\n# sys.stdout = open('outpy.txt', 'w')\nfrom sys import stdin, stdout\nimport bisect            #c++ upperbound\nimport math\nimport heapq\ni_m=9223372036854775807\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef cin():\n    return map(int,sin().split())\ndef ain():                           #takes array as input\n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input())\nimport math  \ndef GCD(x, y): \n    x=abs(x)\n    y=abs(y)\n    if(min(x,y)==0):\n        return max(x,y)\n    while(y): \n        x, y = y, x % y \n    return x \ndef Divisors(n) : \n    l = []  \n    for i in range(1, int(math.sqrt(n) + 1)) :\n        if (n % i == 0) : \n            if (n // i == i) : \n                l.append(i) \n            else : \n                l.append(i)\n                l.append(n//i)\n    return l\nprime=[]\ndef SieveOfEratosthenes(n): \n    global prime\n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n    f=[]\n    for p in range(2, n): \n        if prime[p]: \n            f.append(p)\n    return f\ndef primeFactors(n): \n    a=[]\n    # Print the number of two's that divide n \n    while n % 2 == 0: \n        a.append(2) \n        n = n // 2\n          \n    # n must be odd at this point \n    # so a skip of 2 ( i = i + 2) can be used \n    for i in range(3,int(math.sqrt(n))+1,2): \n          \n        # while i divides n , print i ad divide n \n        while n % i== 0: \n            a.append(i) \n            n = n // i \n              \n    # Condition if n is a prime \n    # number greater than 2 \n    if n > 2: \n        a.append(n)\n    return a\n\n\"\"\"*******************************************************\"\"\"\ndef main():\n    n = inin()\n    a = ain()\n    d=[]\n    p=0\n    for i in range(0,n-1):\n        d.append(a[i+1]-a[i])\n        p+=max(a[i+1]-a[i],0)\n    print((a[0] - p + 1) // 2 + p)\n    t=inin()\n    for _ in range(t):\n        l,r,x=cin()\n        l-=1\n        r-=1\n        if l == 0:\n            a[0] += x\n        if l > 0:\n            p -= max(0, d[l - 1])\n            d[l - 1] += x\n            p += max(0, d[l - 1])\n        if r < n - 1:\n            p -= max(0, d[r])\n            d[r] -= x\n            p += max(0, d[r])\n        print((a[0] - p + 1) // 2 + p)\n######## Python 2 and 3 footer by Pajenegod and c1729\n \n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is yferent which makes it kind of a mess to use.\n \n# So on cf, use PyPy2 for best string performance.\n \npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n \nimport os, sys\nfrom io import IOBase, BytesIO\n \nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'R' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'R' [0]:\n        A.append(sign*numb)\n    return A\n \n# threading.Thread(target=main).start()\nif __name__== \"__main__\":\n  main()",
        "correct": true,
        "task_id": "1164",
        "depth": 2
    },
    {
        "description": "Shaass has n books. He wants to make a bookshelf for all his books. He wants the bookshelf's dimensions to be as small as possible. The thickness of the i-th book is ti and its pages' width is equal to wi. The thickness of each book is either 1 or 2. All books have the same page heights.\n\n<image>\n\nShaass puts the books on the bookshelf in the following way. First he selects some of the books and put them vertically. Then he puts the rest of the books horizontally above the vertical books. The sum of the widths of the horizontal books must be no more than the total thickness of the vertical books. A sample arrangement of the books is depicted in the figure.\n\n<image>\n\nHelp Shaass to find the minimum total thickness of the vertical books that we can achieve.\n\nInput\n\nThe first line of the input contains an integer n, (1 \u2264 n \u2264 100). Each of the next n lines contains two integers ti and wi denoting the thickness and width of the i-th book correspondingly, (1 \u2264 ti \u2264 2, 1 \u2264 wi \u2264 100).\n\nOutput\n\nOn the only line of the output print the minimum total thickness of the vertical books that we can achieve.\n\nExamples\n\nInput\n\n5\n1 12\n1 3\n2 15\n2 5\n2 1\n\n\nOutput\n\n5\n\n\nInput\n\n3\n1 10\n2 1\n2 4\n\n\nOutput\n\n3",
        "task_name": "294_B. Shaass and Bookshelf",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\n\nmyBooks = []\nW = 0\n\nfor i in range(0,n):\n    t, w = map(int, raw_input().split())\n    W += w\n    myBooks.append([w, t])\n    \nmyBooks.sort()\nmyBooks.reverse()\n\nT = 0\nfor book in myBooks:\n    T += book[1]\n    W -= book[0]\n    if(W<=T):\n        break\n    \nprint(T)\n",
        "correct": false,
        "task_id": "1170",
        "depth": 1
    },
    {
        "description": "Leha decided to move to a quiet town Vi\u010dkopolis, because he was tired by living in Bankopolis. Upon arrival he immediately began to expand his network of hacked computers. During the week Leha managed to get access to n computers throughout the town. Incidentally all the computers, which were hacked by Leha, lie on the same straight line, due to the reason that there is the only one straight street in Vi\u010dkopolis.\n\nLet's denote the coordinate system on this street. Besides let's number all the hacked computers with integers from 1 to n. So the i-th hacked computer is located at the point xi. Moreover the coordinates of all computers are distinct. \n\nLeha is determined to have a little rest after a hard week. Therefore he is going to invite his friend Noora to a restaurant. However the girl agrees to go on a date with the only one condition: Leha have to solve a simple task.\n\nLeha should calculate a sum of F(a) for all a, where a is a non-empty subset of the set, that consists of all hacked computers. Formally, let's denote A the set of all integers from 1 to n. Noora asks the hacker to find value of the expression <image>. Here F(a) is calculated as the maximum among the distances between all pairs of computers from the set a. Formally, <image>. Since the required sum can be quite large Noora asks to find it modulo 109 + 7.\n\nThough, Leha is too tired. Consequently he is not able to solve this task. Help the hacker to attend a date.\n\nInput\n\nThe first line contains one integer n (1 \u2264 n \u2264 3\u00b7105) denoting the number of hacked computers.\n\nThe second line contains n integers x1, x2, ..., xn (1 \u2264 xi \u2264 109) denoting the coordinates of hacked computers. It is guaranteed that all xi are distinct.\n\nOutput\n\nPrint a single integer \u2014 the required sum modulo 109 + 7.\n\nExamples\n\nInput\n\n2\n4 7\n\n\nOutput\n\n3\n\n\nInput\n\n3\n4 3 1\n\n\nOutput\n\n9\n\nNote\n\nThere are three non-empty subsets in the first sample test:<image>, <image> and <image>. The first and the second subset increase the sum by 0 and the third subset increases the sum by 7 - 4 = 3. In total the answer is 0 + 0 + 3 = 3.\n\nThere are seven non-empty subsets in the second sample test. Among them only the following subsets increase the answer: <image>, <image>, <image>, <image>. In total the sum is (4 - 3) + (4 - 1) + (3 - 1) + (4 - 1) = 9.",
        "task_name": "809_A. Do you want a date?",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\ns = sorted(map(int,raw_input().split()))\nr = 0\nfor i in xrange(n):\n\tr+=(s[i]*((2**(n-1-i)-1)-(2**i-1)))%(1000000000+7)\nprint -r",
        "correct": false,
        "task_id": "1181",
        "depth": 1
    },
    {
        "description": "Snuke and Ciel went to a strange stationery store. Each of them got a transparent graph paper with H rows and W columns.\n\nSnuke painted some of the cells red in his paper. Here, the cells painted red were 4-connected, that is, it was possible to traverse from any red cell to any other red cell, by moving to vertically or horizontally adjacent red cells only.\n\nCiel painted some of the cells blue in her paper. Here, the cells painted blue were 4-connected.\n\nAfterwards, they precisely overlaid the two sheets in the same direction. Then, the intersection of the red cells and the blue cells appeared purple.\n\nYou are given a matrix of letters a_{ij} (1\u2264i\u2264H, 1\u2264j\u2264W) that describes the positions of the purple cells. If the cell at the i-th row and j-th column is purple, then a_{ij} is `#`, otherwise a_{ij} is `.`. Here, it is guaranteed that no outermost cell is purple. That is, if i=1, H or j = 1, W, then a_{ij} is `.`.\n\nFind a pair of the set of the positions of the red cells and the blue cells that is consistent with the situation described. It can be shown that a solution always exists.\n\nConstraints\n\n* 3\u2264H,W\u2264500\n* a_{ij} is `#` or `.`.\n* If i=1,H or j=1,W, then a_{ij} is `.`.\n* At least one of a_{ij} is `#`.\n\nInput\n\nThe input is given from Standard Input in the following format:\n\n\nH W\na_{11}...a_{1W}\n:\na_{H1}...a_{HW}\n\n\nOutput\n\nPrint a pair of the set of the positions of the red cells and the blue cells that is consistent with the situation, as follows:\n\n* The first H lines should describe the positions of the red cells.\n* The following 1 line should be empty.\n* The following H lines should describe the positions of the blue cells.\n\n\n\nThe description of the positions of the red or blue cells should follow the format of the description of the positions of the purple cells.\n\nExamples\n\nInput\n\n5 5\n.....\n.#.#.\n.....\n.#.#.\n.....\n\n\nOutput\n\n.....\n#####\n#....\n#####\n.....\n\n.###.\n.#.#.\n.#.#.\n.#.#.\n.....\n\n\nInput\n\n7 13\n.............\n.###.###.###.\n.#.#.#...#...\n.###.#...#...\n.#.#.#.#.#...\n.#.#.###.###.\n.............\n\n\nOutput\n\n.............\n.###########.\n.###.###.###.\n.###.###.###.\n.###.###.###.\n.###.###.###.\n.............\n\n.............\n.###.###.###.\n.#.#.#...#...\n.###.#...#...\n.#.#.#.#.#...\n.#.#########.\n.............",
        "task_name": "p04007 AtCoder Grand Contest 004 - AND Grid",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n\nn, m = map(int, raw_input().split())\nred = []\nblue = []\n\nfor i in range(n):\n    row = raw_input()\n    r = ['#']\n    b = ['.']\n    for j in range(1, m - 1):\n        if row[j] == '#':\n            r.append('#')\n            b.append('#')\n        else:\n            if i % 2 == 0:\n                r.append('#')\n                b.append('.')\n            else:\n                r.append('.')\n                b.append('#')\n    r.append('.')\n    b.append('#')\n    red.append(''.join(r))\n    blue.append(''.join(b))\n\nfor r in red:\n    print(r)\nfor b in blue:\n    print(b)\n",
        "correct": true,
        "task_id": "1189",
        "depth": 2
    },
    {
        "description": "Let a be a matrix of size r \u00d7 c containing positive integers, not necessarily distinct. Rows of the matrix are numbered from 1 to r, columns are numbered from 1 to c. We can construct an array b consisting of r + c integers as follows: for each i \u2208 [1, r], let b_i be the greatest common divisor of integers in the i-th row, and for each j \u2208 [1, c] let b_{r+j} be the greatest common divisor of integers in the j-th column. \n\nWe call the matrix diverse if all r + c numbers b_k (k \u2208 [1, r + c]) are pairwise distinct. \n\nThe magnitude of a matrix equals to the maximum of b_k.\n\nFor example, suppose we have the following matrix:\n\n\\begin{pmatrix} 2 & 9 & 7\\\\\\ 4 & 144 & 84 \\end{pmatrix} \n\nWe construct the array b:\n\n  1. b_1 is the greatest common divisor of 2, 9, and 7, that is 1; \n  2. b_2 is the greatest common divisor of 4, 144, and 84, that is 4; \n  3. b_3 is the greatest common divisor of 2 and 4, that is 2; \n  4. b_4 is the greatest common divisor of 9 and 144, that is 9; \n  5. b_5 is the greatest common divisor of 7 and 84, that is 7. \n\n\n\nSo b = [1, 4, 2, 9, 7]. All values in this array are distinct, so the matrix is diverse. The magnitude is equal to 9.\n\nFor a given r and c, find a diverse matrix that minimises the magnitude. If there are multiple solutions, you may output any of them. If there are no solutions, output a single integer 0. \n\nInput\n\nThe only line in the input contains two space separated integers r and c (1 \u2264 r,c \u2264 500) \u2014 the number of rows and the number of columns of the matrix to be found.\n\nOutput\n\nIf there is no solution, output a single integer 0.\n\nOtherwise, output r rows. The i-th of them should contain c space-separated integers, the j-th of which is a_{i,j} \u2014 the positive integer in the i-th row and j-th column of a diverse matrix minimizing the magnitude.\n\nFurthermore, it must hold that 1 \u2264 a_{i,j} \u2264 10^9. It can be shown that if a solution exists, there is also a solution with this additional constraint (still having minimum possible magnitude).\n\nExamples\n\nInput\n\n\n2 2\n\n\nOutput\n\n\n4 12\n2 9\n\nInput\n\n\n1 1\n\n\nOutput\n\n\n0\n\nNote\n\nIn the first example, the GCDs of rows are b_1 = 4 and b_2 = 1, and the GCDs of columns are b_3 = 2 and b_4 = 3. All GCDs are pairwise distinct and the maximum of them is 4. Since the GCDs have to be distinct and at least 1, it is clear that there are no diverse matrices of size 2 \u00d7 2 with magnitude smaller than 4.\n\nIn the second example, no matter what a_{1,1} is, b_1 = b_2 will always hold, so there are no diverse matrices.",
        "task_name": "1266_C. Diverse Matrix",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "(r,c)=map(int,raw_input().split())\n\nif r==1 and c==1:\n\tprint(0)\n\t\nelse:\n\n\tflag=False\n\tif c==1:\n\t\tflag=True\n\t\t(r,c)=(c,r)\n\n\tl=[[1 for _ in range(c)] for _ in range(r)]\n\tb=[i+1 for i in range(r+c)]\n\n\tfor i in range(r):\n\t\tfor j in range(c):\n\t\t\tl[i][j]*=b[i]*b[r+j]\n\n\tif flag==False:\n\t\tfor i in range(r):\n\t\t\ts=\"\"\n\t\t\tfor j in range(c):\n\t\t\t\ts+=str(l[i][j])+\" \"\n\n\t\t\tprint(s)\n\n\telse:\n\t\tfor j in range(c):\t\n\t\t\ts=\"\"\n\t\t\tfor i in range(r):\n\t\t\t\ts+=str(l[i][j])+\" \"\n\n\t\t\tprint(s)\n",
        "correct": true,
        "task_id": "1196",
        "depth": 2
    },
    {
        "description": "Ilya is very fond of graphs, especially trees. During his last trip to the forest Ilya found a very interesting tree rooted at vertex 1. There is an integer number written on each vertex of the tree; the number written on vertex i is equal to ai.\n\nIlya believes that the beauty of the vertex x is the greatest common divisor of all numbers written on the vertices on the path from the root to x, including this vertex itself. In addition, Ilya can change the number in one arbitrary vertex to 0 or leave all vertices unchanged. Now for each vertex Ilya wants to know the maximum possible beauty it can have.\n\nFor each vertex the answer must be considered independently.\n\nThe beauty of the root equals to number written on it.\n\nInput\n\nFirst line contains one integer number n \u2014 the number of vertices in tree (1 \u2264 n \u2264 2\u00b7105).\n\nNext line contains n integer numbers ai (1 \u2264 i \u2264 n, 1 \u2264 ai \u2264 2\u00b7105).\n\nEach of next n - 1 lines contains two integer numbers x and y (1 \u2264 x, y \u2264 n, x \u2260 y), which means that there is an edge (x, y) in the tree.\n\nOutput\n\nOutput n numbers separated by spaces, where i-th number equals to maximum possible beauty of vertex i.\n\nExamples\n\nInput\n\n2\n6 2\n1 2\n\n\nOutput\n\n6 6 \n\n\nInput\n\n3\n6 2 3\n1 2\n1 3\n\n\nOutput\n\n6 6 6 \n\n\nInput\n\n1\n10\n\n\nOutput\n\n10 ",
        "task_name": "842_C. Ilya And The Tree",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\na = map(int, raw_input().split())\n\ngraph = [[] for _ in range(n)]\n\nfor i in xrange(n - 1):\n    x, y = map(int, raw_input().split())\n    x -= 1; y -= 1\n#    print(x, y)\n    graph[x].append(y)\n    graph[y].append(x)\n#    graph\n#    a[i] = int(raw_input())\n    \n#n, k = map(int, raw_input().split())\n#s = str(raw_input())\n\n#a = map(int, raw_input().split())\n#b = [(y,x) for x,y in enumerate(map(int,raw_input().split()))]\n\nclass Info:\n    def __init__(self):\n        self.gcd = 0\n        self.tor1 = 0\n        self.ifr1 = 0\n        self.tor2 = 0\n        self.ifr2 = 0\n\n    def get(self):\n        r = self.gcd\n        if self.ifr1 > r:\n            r = self.ifr1\n        if self.ifr2 > r:\n            r = self.ifr2\n        return r\n\nvisited = [False] * n\n\ngcdinfo = [Info() for _ in xrange(n)]\n\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\ndef dfs(n, parent):\n    if visited[n]:\n        return\n    visited[n] = True\n    if parent != -1:\n        newgcd = gcd(gcdinfo[parent].gcd, a[n])\n#        print(\"newgcd=\", newgcd)\n        gcdinfo[n].gcd = newgcd\n        if newgcd < gcdinfo[parent].gcd:\n            # try removing self\n            gcdinfo[n].tor1 = a[n]\n            gcdinfo[n].ifr1 = gcdinfo[parent].gcd\n            if gcdinfo[parent].ifr1 == 0:\n                # alternative option\n                gcdinfo[n].tor2 = gcdinfo[parent].gcd\n                gcdinfo[n].ifr2 = a[n]\n        else:\n            # self if good, keep one of the other candidates\n            if gcdinfo[parent].ifr1:\n                newgcd1 = gcd(gcdinfo[parent].ifr1, a[n])\n            else:\n                newgcd1 = 1\n            if gcdinfo[parent].ifr2:\n                newgcd2 = gcd(gcdinfo[parent].ifr2, a[n])\n            else:\n                newgcd2 = 1\n            if newgcd1 > newgcd2:\n                gcdinfo[n].tor1 = gcdinfo[parent].tor1\n                gcdinfo[n].ifr1 = gcdinfo[parent].ifr1\n            elif newgcd2 > newgcd1:\n                gcdinfo[n].tor1 = gcdinfo[parent].tor2\n                gcdinfo[n].ifr1 = gcdinfo[parent].ifr2               \n\n    for neigh in graph[n]:\n        dfs(neigh, n)\n\ngcdinfo[0].gcd = a[0]\ngcdinfo[0].tor1 = a[0]\ngcdinfo[0].ifr1 = 0\ndfs(0, -1)\n\ns = \"\"\nfor i in xrange(n):\n    s += str(gcdinfo[i].get()) + \" \"\nprint(s)\n    \n",
        "correct": false,
        "task_id": "1217",
        "depth": 1
    },
    {
        "description": "You are given a 4-character string S consisting of uppercase English letters. Determine if S consists of exactly two kinds of characters which both appear twice in S.\n\nConstraints\n\n* The length of S is 4.\n* S consists of uppercase English letters.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nS\n\n\nOutput\n\nIf S consists of exactly two kinds of characters which both appear twice in S, print `Yes`; otherwise, print `No`.\n\nExamples\n\nInput\n\nASSA\n\n\nOutput\n\nYes\n\n\nInput\n\nSTOP\n\n\nOutput\n\nNo\n\n\nInput\n\nFFEE\n\n\nOutput\n\nYes\n\n\nInput\n\nFREE\n\n\nOutput\n\nNo",
        "task_name": "p02987 AtCoder Beginner Contest 132 - Fifty-Fifty",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom collections import Counter\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    s = Counter(input()).values()\n    print('Yes' if s == [2, 2] else 'No')\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": true,
        "task_id": "1223",
        "depth": 1
    },
    {
        "description": "You are given a Young diagram. \n\nGiven diagram is a histogram with n columns of lengths a_1, a_2, \u2026, a_n (a_1 \u2265 a_2 \u2265 \u2026 \u2265 a_n \u2265 1).\n\n<image> Young diagram for a=[3,2,2,2,1].\n\nYour goal is to find the largest number of non-overlapping dominos that you can draw inside of this histogram, a domino is a 1 \u00d7 2 or 2 \u00d7 1 rectangle.\n\nInput\n\nThe first line of input contain one integer n (1 \u2264 n \u2264 300 000): the number of columns in the given histogram.\n\nThe next line of input contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 300 000, a_i \u2265 a_{i+1}): the lengths of columns.\n\nOutput\n\nOutput one integer: the largest number of non-overlapping dominos that you can draw inside of the given Young diagram.\n\nExample\n\nInput\n\n\n5\n3 2 2 2 1\n\n\nOutput\n\n\n4\n\nNote\n\nSome of the possible solutions for the example:\n\n<image> <image>",
        "task_name": "1269_D. Domino for Young",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n# Author : raj1307 - Raj Singh\n# Date   : 01.01.2020\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\n\ndef main():\n        \n\n    #for _ in range(ii()):\n        \n        \n        \n    n=ii()\n    a=li()\n\n    w=0\n    b=0\n    for i in range(n):\n        if i%2:\n            b+=(a[i]+1)//2\n            w+=a[i]//2\n        else:\n            w+=(a[i]+1)//2\n            b+=a[i]//2\n\n\n    print(min(w,b))\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": true,
        "task_id": "1232",
        "depth": 1
    },
    {
        "description": "In order to celebrate Twice's 5th anniversary, Tzuyu and Sana decided to play a game.\n\nTzuyu gave Sana two integers a and b and a really important quest.\n\nIn order to complete the quest, Sana has to output the smallest possible value of (a \u2295 x) + (b \u2295 x) for any given x, where \u2295 denotes the [bitwise XOR operation](http://en.wikipedia.org/wiki/Bitwise_operation#XOR). \n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^{4}). Description of the test cases follows.\n\nThe only line of each test case contains two integers a and b (1 \u2264 a, b \u2264 10^{9}).\n\nOutput\n\nFor each testcase, output the smallest possible value of the given expression.\n\nExample\n\nInput\n\n\n6\n6 12\n4 9\n59 832\n28 14\n4925 2912\n1 1\n\n\nOutput\n\n\n10\n13\n891\n18\n6237\n0\n\nNote\n\nFor the first test case Sana can choose x=4 and the value will be (6 \u2295 4) + (12 \u2295 4) = 2 + 8 = 10. It can be shown that this is the smallest possible value.",
        "task_name": "1421_A. XORwice",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n# Author : raj1307 - Raj Singh\n# Date   : 18.10.2020\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii():  return int(input())\ndef si():  return input()\ndef mi():  return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li():  return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import log,sqrt,factorial,cos,tan,sin,radians\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *\n#import threading\n#from itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey,reverse=True)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\ndef ncr(n,r): return factorial(n)//(factorial(r)*factorial(max(n-r,1)))\n\ndef ceil(x,y):\n    if x%y==0:\n        return x//y\n    else:\n        return x//y+1\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin  = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\n\n\n\ndef main():\n\n    \n    for _ in range(ii()):\n        \n        \n            \n        x,y=mi()\n    \n        ans=0\n\n\n        for i in range(32):\n\n            if ((x&(1<<i)) and (y&(1<<i))) or ( not (x&(1<<i)) and  not (y&(1<<i))):\n                continue\n            else:\n                ans+=(1<<i)\n\n        print(ans)\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": true,
        "task_id": "1239",
        "depth": 2
    },
    {
        "description": "The new operating system BerOS has a nice feature. It is possible to use any number of characters '/' as a delimiter in path instead of one traditional '/'. For example, strings //usr///local//nginx/sbin// and /usr/local/nginx///sbin are equivalent. The character '/' (or some sequence of such characters) at the end of the path is required only in case of the path to the root directory, which can be represented as single character '/'.\n\nA path called normalized if it contains the smallest possible number of characters '/'.\n\nYour task is to transform a given path to the normalized form.\n\nInput\n\nThe first line of the input contains only lowercase Latin letters and character '/' \u2014 the path to some directory. All paths start with at least one character '/'. The length of the given line is no more than 100 characters, it is not empty.\n\nOutput\n\nThe path in normalized form.\n\nExamples\n\nInput\n\n//usr///local//nginx/sbin\n\n\nOutput\n\n/usr/local/nginx/sbin",
        "task_name": "20_A. BerOS file system",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nline = stdin.readline()\narray = line.split('/')\nstr = \"\"\nfor word in array:\n    if(word!=\"\"):\n        str = str+ \"/\" + word.strip()\nstdout.write(str)",
        "correct": false,
        "task_id": "1243",
        "depth": 1
    },
    {
        "description": "We have N weights indexed 1 to N. The \bmass of the weight indexed i is W_i.\n\nWe will divide these weights into two groups: the weights with indices not greater than T, and those with indices greater than T, for some integer 1 \\leq T < N. Let S_1 be the sum of the masses of the weights in the former group, and S_2 be the sum of the masses of the weights in the latter group.\n\nConsider all possible such divisions and find the minimum possible absolute difference of S_1 and S_2.\n\nConstraints\n\n* 2 \\leq N \\leq 100\n* 1 \\leq W_i \\leq 100\n* All values in input are integers.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nW_1 W_2 ... W_{N-1} W_N\n\n\nOutput\n\nPrint the minimum possible absolute difference of S_1 and S_2.\n\nExamples\n\nInput\n\n3\n1 2 3\n\n\nOutput\n\n0\n\n\nInput\n\n4\n1 3 1 1\n\n\nOutput\n\n2\n\n\nInput\n\n8\n27 23 76 2 3 5 62 52\n\n\nOutput\n\n2",
        "task_name": "p03012 AtCoder Beginner Contest 129 - Balance",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "N = input()\nV = list(map(int, input().split()))\n\nM = 1e9\nfor i in range(1, len(V)):\n\tdiff = abs(sum(V[:i])-sum(V[i:]))\n\tif(M>diff):\n\t\tM = diff\n\nprint(M)",
        "correct": false,
        "task_id": "1262",
        "depth": 1
    },
    {
        "description": "You have given tree consist of n vertices. Select a vertex as root vertex that satisfies the condition below.\n\n  * For all vertices v_{1} and v_{2}, if distance(root, v_{1}) = distance(root, v_{2}) then degree(v_{1}) = degree(v_{2}), where degree means the number of vertices connected to that vertex, and distance means the number of edges between two vertices. \n\n\n\nDetermine and find if there is such root vertex in the tree. If there are multiple answers, find any of them.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 10^{5}) \u2014 the number of vertices.\n\nEach of the next n-1 lines contains two integers v_{i} and u_{i} (1 \u2264 v_{i} < u_{i} \u2264 n) \u2014 it means there is an edge exist between v_{i} and u_{i}. It is guaranteed that the graph forms tree.\n\nOutput\n\nIf there is such root vertex exists, print any of them. Otherwise, print -1.\n\nExamples\n\nInput\n\n\n7\n1 2\n2 3\n3 4\n4 5\n3 6\n6 7\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n6\n1 3\n2 3\n3 4\n4 5\n4 6\n\n\nOutput\n\n\n-1\n\nNote\n\nThis is the picture for the first example. 1, 5, 7 also can be a valid answer.\n\n<image>\n\nThis is the picture for the second example. You can see that it's impossible to find such root vertex.\n\n<image>",
        "task_name": "1182_D. Complete Mirror",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from collections import*\nn = int(raw_input())\ne = [[] for i in range(n+1)]\nfor i in range(n - 1):\n\tu, v = map(int, raw_input().split())\n\te[u].append(v)\n\te[v].append(u)\ndep = [-1] * (n + 1)\ndep[1] = 0\nq = deque([1])\ncur = 1\nwhile q:\n\tcur = q.popleft()\n\tfor to in e[cur]:\n\t\tif dep[to] == -1:\n\t\t\tdep[to] = dep[cur] + 1\n\t\t\tq.append(to)\ndep = [-1] * (n + 1)\npred = [0] * (n + 1)\ndep[cur] = 0\nq = deque([cur])\nend = cur\nwhile q:\n\tend = q.popleft()\n\tfor to in e[end]:\n\t\tif dep[to] == -1:\n\t\t\tdep[to] = dep[end] + 1\n\t\t\tpred[to] = end\n\t\t\tq.append(to)\ndeg = [-1] * (n + 1)\nbad = False\nfor i in range(1, n + 1):\n\tif deg[dep[i]] == -1:\n\t\tdeg[dep[i]] = len(e[i])\n\telse:\n\t\tif deg[dep[i]] != len(e[i]):\n\t\t\tbad = True\n\t\t\tbreak\nif not bad:\n\tprint(cur)\n\texit()\ncenter = end\nfor i in range(dep[end] // 2):\n\tcenter = pred[center]\ndep = [-1] * (n + 1)\ndep[end] = 0\nq = deque([end])\nwhile q:\n\tcur = q.popleft()\n\tfor to in e[cur]:\n\t\tif dep[to] == -1:\n\t\t\tdep[to] = dep[cur] + 1\n\t\t\tq.append(to)\ndeg = [-1] * (n + 1)\nbad = False\nfor i in range(1, n + 1):\n\tif deg[dep[i]] == -1:\n\t\tdeg[dep[i]] = len(e[i])\n\telse:\n\t\tif deg[dep[i]] != len(e[i]):\n\t\t\tbad = True\n\t\t\tbreak\nif not bad:\n\tprint(end)\n\texit()\ntop = center\ndep = [-1] * (n + 1)\ndep[center] = 0\nq = deque([center])\nwhile q:\n\tcur = q.popleft()\n\tfor to in e[cur]:\n\t\tif dep[to] == -1:\n\t\t\tif len(e[to]) == 2:\n\t\t\t\tdep[to] = dep[cur] + 1\n\t\t\t\tq.append(to)\n\t\t\telif len(e[to]) == 1:\n\t\t\t\ttop = to\n\t\t\t\tq.clear()\n\t\t\t\tbreak\ndeg = [-1] * (n + 1)\nbad = False\nfor i in range(1, n + 1):\n\tif deg[dep[i]] == -1:\n\t\tdeg[dep[i]] = len(e[i])\n\telse:\n\t\tif deg[dep[i]] != len(e[i]):\n\t\t\tbad = True\n\t\t\tbreak\nif not bad:\n\tprint(center)\n\texit()\ndep = [-1] * (n + 1)\ndep[top] = 0\nq = deque([top])\nwhile q:\n\tcur = q.popleft()\n\tfor to in e[cur]:\n\t\tif dep[to] == -1:\n\t\t\tdep[to] = dep[cur] + 1\n\t\t\tq.append(to)\ndeg = [-1] * (n + 1)\nbad = False\nfor i in range(1, n + 1):\n\tif deg[dep[i]] == -1:\n\t\tdeg[dep[i]] = len(e[i])\n\telse:\n\t\tif deg[dep[i]] != len(e[i]):\n\t\t\tbad = True\n\t\t\tbreak\nif not bad:\n\tprint(top)\n\texit()\nprint(-1)",
        "correct": true,
        "task_id": "1273",
        "depth": 2
    },
    {
        "description": "Captain Fint is involved in another treasure hunt, but have found only one strange problem. The problem may be connected to the treasure's location or may not. That's why captain Flint decided to leave the solving the problem to his crew and offered an absurdly high reward: one day off. The problem itself sounds like this...\n\nThere are two arrays a and b of length n. Initially, an ans is equal to 0 and the following operation is defined: \n\n  1. Choose position i (1 \u2264 i \u2264 n); \n  2. Add a_i to ans; \n  3. If b_i \u2260 -1 then add a_i to a_{b_i}. \n\n\n\nWhat is the maximum ans you can get by performing the operation on each i (1 \u2264 i \u2264 n) exactly once?\n\nUncle Bogdan is eager to get the reward, so he is asking your help to find the optimal order of positions to perform the operation on them.\n\nInput\n\nThe first line contains the integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of arrays a and b.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (\u221210^6 \u2264 a_i \u2264 10^6).\n\nThe third line contains n integers b_1, b_2, \u2026, b_n (1 \u2264 b_i \u2264 n or b_i = -1).\n\nAdditional constraint: it's guaranteed that for any i (1 \u2264 i \u2264 n) the sequence b_i, b_{b_i}, b_{b_{b_i}}, \u2026 is not cyclic, in other words it will always end with -1.\n\nOutput\n\nIn the first line, print the maximum ans you can get.\n\nIn the second line, print the order of operations: n different integers p_1, p_2, \u2026, p_n (1 \u2264 p_i \u2264 n). The p_i is the position which should be chosen at the i-th step. If there are multiple orders, print any of them.\n\nExamples\n\nInput\n\n\n3\n1 2 3\n2 3 -1\n\n\nOutput\n\n\n10\n1 2 3 \n\n\nInput\n\n\n2\n-1 100\n2 -1\n\n\nOutput\n\n\n99\n2 1 \n\n\nInput\n\n\n10\n-10 -1 2 2 5 -2 -3 -4 2 -6\n-1 -1 2 2 -1 5 5 7 7 9\n\n\nOutput\n\n\n-9\n3 5 6 1 9 4 10 7 8 2",
        "task_name": "1388_D. Captain Flint and Treasure",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\"\"\"\n// Author : snape_here - Susanta Mukherjee\n     \n \"\"\"\n \nfrom __future__ import division, print_function\n \nimport os,sys\nfrom io import BytesIO, IOBase\n \nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n \ndef ii(): return int(input())\ndef fi(): return float(input())\ndef si(): return input()\ndef msi(): return map(str,input().split())\ndef mi(): return map(int,input().split())\ndef li(): return list(mi())\n \n \ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n \ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x*y)//(gcd(x,y))\n\nmod=1000000007 \n\ndef modInverse(b,m): \n    g = gcd(b, m)  \n    if (g != 1):         \n        return -1\n    else:          \n        return pow(b, m - 2, m) \n\ndef modu(a,b,m): \n\n    a = a % m \n    inv = modInverse(b,m) \n    if(inv == -1): \n        return -999999999\n    else: \n        return (inv*a)%m\n\nfrom math import log,sqrt,factorial,cos,tan,sin,radians,ceil,floor\n\nimport bisect\n\nfrom decimal import *\n\ngetcontext().prec = 25\n\nabc=\"abcdefghijklmnopqrstuvwxyz\"\n\npi=3.141592653589793238\n\ndef main():\n\n    n=ii()\n    a=li()\n    b=li()\n    l=[0]*n\n    for i in range(n):\n        if b[i]>0:\n            l[b[i]-1]+=a[i]\n    #print(*l)\n    l1=[]\n    for i in range(n):\n        l1.append([l[i],i])\n    l1.sort()\n    #print(*l1)\n    ans=0 \n    l2=[]\n    for i in range(n):\n        l2.append(l1[i][1]+1)\n        if b[l1[i][1]]>0:\n            ans+=a[l1[i][1]]\n        a[l1[i][1]]+=l1[i][0]\n        #print(ans)\n    print(ans)\n    print(*l2)\n\n\n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \n \nif __name__ == \"__main__\":\n    #read()\n    main()",
        "correct": false,
        "task_id": "1277",
        "depth": 1
    },
    {
        "description": "You've got an n \u00d7 m pixel picture. Each pixel can be white or black. Your task is to change the colors of as few pixels as possible to obtain a barcode picture.\n\nA picture is a barcode if the following conditions are fulfilled: \n\n  * All pixels in each column are of the same color. \n  * The width of each monochrome vertical line is at least x and at most y pixels. In other words, if we group all neighbouring columns of the pixels with equal color, the size of each group can not be less than x or greater than y. \n\nInput\n\nThe first line contains four space-separated integers n, m, x and y (1 \u2264 n, m, x, y \u2264 1000; x \u2264 y).\n\nThen follow n lines, describing the original image. Each of these lines contains exactly m characters. Character \".\" represents a white pixel and \"#\" represents a black pixel. The picture description doesn't have any other characters besides \".\" and \"#\".\n\nOutput\n\nIn the first line print the minimum number of pixels to repaint. It is guaranteed that the answer exists. \n\nExamples\n\nInput\n\n6 5 1 2\n##.#.\n.###.\n###..\n#...#\n.##.#\n###..\n\n\nOutput\n\n11\n\n\nInput\n\n2 5 1 1\n#####\n.....\n\n\nOutput\n\n5\n\nNote\n\nIn the first test sample the picture after changing some colors can looks as follows: \n    \n    \n      \n    .##..  \n    .##..  \n    .##..  \n    .##..  \n    .##..  \n    .##..  \n    \n\nIn the second test sample the picture after changing some colors can looks as follows: \n    \n    \n      \n    .#.#.  \n    .#.#.  \n    ",
        "task_name": "225_C. Barcode",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "'''input\n10 5 3 7\n.####\n###..\n##.##\n#..#.\n.#...\n#.##.\n.##..\n.#.##\n#.#..\n.#..#\n'''\n# connected components\nfrom sys import stdin\nfrom collections import defaultdict\nimport sys\nimport time\n\nsys.setrecursionlimit(15000)\n\ndef calculate_cost(matrix, n, m):\n\twhite_cost = []\n\tblack_cost = []\n\tfor i in range(m):\n\t\tbcount = 0; wcount = 0\n\t\tfor j in range(n):\n\t\t\tif matrix[j][i] == '.':\n\t\t\t\tbcount += 1\n\t\t\telse:\n\t\t\t\twcount += 1\n\t\twhite_cost.append(wcount)\n\t\tblack_cost.append(bcount)\n\treturn black_cost, white_cost\n\n\ndef brute(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index, w, b):\n\t#print(index, w, b)\n\tif index >= m:\n\t\tif w != 0 and w >= x:\n\t\t\treturn 0\n\t\tif b != 0 and b >= x:\n\t\t\treturn 0\n\t\treturn float('inf')\n\telse:\n\t\tif dp1[w][index] != -1 and dp2[b][index] != -1:\n\t\t\treturn min(dp1[w][index], dp2[b][index])\n\n\t\tc1 = float('inf'); c2 = float('inf'); c3 = float('inf'); c4 = float('inf')\n\t\tif w < x:\n\t\t\tc1 = 0\n\t\t\tcw = w\n\t\t\ti = index\n\t\t\twhile cw < x:\n\t\t\t\tif i == m:\n\t\t\t\t\tbreak\n\t\t\t\tc1 += white_cost[i]\t\n\t\t\t\ti +=  1; cw += 1\n\t\t\tc1 += brute(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)\n\t\t\n\t\tif b < x:\n\t\t\tc2 = 0\n\t\t\tcb = b\n\t\t\ti = index\n\t\t\twhile cb < x:\n\t\t\t\tif i == m:\n\t\t\t\t\tc2 = float('inf')\n\t\t\t\t\tbreak\n\t\t\t\tc2 += black_cost[i]\n\t\t\t\ti += 1; cb += 1\n\t\t\tc2 += brute(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)\n\t\t\n\t\tif w >= x and w + 1 <= y:\n\t\t\tc3 = white_cost[index] + brute(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)\n\t\t\n\t\tif b >= x and b + 1 <= y:\n\t\t\tc4 = black_cost[index] + brute(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, 0, b + 1)\n\t\t\n\t\t\n\t\tdp1[w][index] = min(c1, c3)\n\t\tdp2[b][index] = min(c2, c4)\n\t\treturn min(c1, c2, c3, c4)\n\t\t\n\n# main starts\nn, m, x, y = list(map(int, stdin.readline().split()))\nmatrix = []\nfor _ in range(n):\n\tmatrix.append(list(stdin.readline().strip()))\nblack_cost, white_cost = calculate_cost(matrix, n, m)\n#print(black_cost, white_cost)\ndp1 = [[-1 for j in range(m)] for k in range(y + 1)]\ndp2 = [[-1 for j in range(m)] for k in range(y + 1)]\n\nprint(brute(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, 0, 0, 0))\n",
        "correct": true,
        "task_id": "1283",
        "depth": 2
    },
    {
        "description": "Many computer strategy games require building cities, recruiting army, conquering tribes, collecting resources. Sometimes it leads to interesting problems. \n\nLet's suppose that your task is to build a square city. The world map uses the Cartesian coordinates. The sides of the city should be parallel to coordinate axes. The map contains mines with valuable resources, located at some points with integer coordinates. The sizes of mines are relatively small, i.e. they can be treated as points. The city should be built in such a way that all the mines are inside or on the border of the city square. \n\nBuilding a city takes large amount of money depending on the size of the city, so you have to build the city with the minimum area. Given the positions of the mines find the minimum possible area of the city.\n\nInput\n\nThe first line of the input contains number n \u2014 the number of mines on the map (2 \u2264 n \u2264 1000). Each of the next n lines contains a pair of integers xi and yi \u2014 the coordinates of the corresponding mine ( - 109 \u2264 xi, yi \u2264 109). All points are pairwise distinct.\n\nOutput\n\nPrint the minimum area of the city that can cover all the mines with valuable resources.\n\nExamples\n\nInput\n\n2\n0 0\n2 2\n\n\nOutput\n\n4\n\n\nInput\n\n2\n0 0\n0 3\n\n\nOutput\n\n9",
        "task_name": "485_B. Valuable Resources",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "t=int(raw_input())\nmaxx,maxy=-10**18,-10**18\nminx=10**18\nminy=10**18\nfor z in xrange(t):\n    a,b=map(int,raw_input().split())\n    maxx=max(maxx,a)\n    minx=min(minx,a)\n    maxy=max(maxy,b)\n    miny=min(miny,b)\nprint (max(maxx-minx,maxy-miny))**2\n",
        "correct": true,
        "task_id": "1289",
        "depth": 1
    },
    {
        "description": "A tennis tournament with n participants is running. The participants are playing by an olympic system, so the winners move on and the losers drop out.\n\nThe tournament takes place in the following way (below, m is the number of the participants of the current round):\n\n  * let k be the maximal power of the number 2 such that k \u2264 m, \n  * k participants compete in the current round and a half of them passes to the next round, the other m - k participants pass to the next round directly, \n  * when only one participant remains, the tournament finishes. \n\n\n\nEach match requires b bottles of water for each participant and one bottle for the judge. Besides p towels are given to each participant for the whole tournament.\n\nFind the number of bottles and towels needed for the tournament.\n\nNote that it's a tennis tournament so in each match two participants compete (one of them will win and the other will lose).\n\nInput\n\nThe only line contains three integers n, b, p (1 \u2264 n, b, p \u2264 500) \u2014 the number of participants and the parameters described in the problem statement.\n\nOutput\n\nPrint two integers x and y \u2014 the number of bottles and towels need for the tournament.\n\nExamples\n\nInput\n\n5 2 3\n\n\nOutput\n\n20 15\n\n\nInput\n\n8 2 4\n\n\nOutput\n\n35 32\n\nNote\n\nIn the first example will be three rounds:\n\n  1. in the first round will be two matches and for each match 5 bottles of water are needed (two for each of the participants and one for the judge), \n  2. in the second round will be only one match, so we need another 5 bottles of water, \n  3. in the third round will also be only one match, so we need another 5 bottles of water. \n\n\n\nSo in total we need 20 bottles of water.\n\nIn the second example no participant will move on to some round directly.",
        "task_name": "628_A. Tennis Tournament",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n, b, p = map(int, raw_input().split())\npotencias = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\ndef cm(x):\n\tfor i in range(10):\n\t\tif potencias[i] >x:\n\t\t\treturn(potencias[i-1])\t\t\t\n\nbo, to = 0,p*n\n\nwhile(n >1):\n\tk = cm(n)\n\tbo += b*(k)\n\tprint(n,k,bo)\n\n\tn = n - (k/2)\n\tbo +=(k/2)\n\tif k == 1:\n\t\tbreak\n\t\nprint(bo,to)\n",
        "correct": false,
        "task_id": "1294",
        "depth": 1
    }
]