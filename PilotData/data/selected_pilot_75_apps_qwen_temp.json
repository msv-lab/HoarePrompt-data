[
    {
        "description": "Pavel cooks barbecue. There are n skewers, they lay on a brazier in a row, each on one of n positions. Pavel wants each skewer to be cooked some time in every of n positions in two directions: in the one it was directed originally and in the reversed direction.\n\nPavel has a plan: a permutation p and a sequence b_1, b_2, ..., b_{n}, consisting of zeros and ones. Each second Pavel move skewer on position i to position p_{i}, and if b_{i} equals 1 then he reverses it. So he hope that every skewer will visit every position in both directions.\n\nUnfortunately, not every pair of permutation p and sequence b suits Pavel. What is the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements? Note that after changing the permutation should remain a permutation as well.\n\nThere is no problem for Pavel, if some skewer visits some of the placements several times before he ends to cook. In other words, a permutation p and a sequence b suit him if there is an integer k (k \u2265 2n), so that after k seconds each skewer visits each of the 2n placements.\n\nIt can be shown that some suitable pair of permutation p and sequence b exists for any n.\n\n\n-----Input-----\n\nThe first line contain the integer n (1 \u2264 n \u2264 2\u00b710^5)\u00a0\u2014 the number of skewers.\n\nThe second line contains a sequence of integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n)\u00a0\u2014 the permutation, according to which Pavel wants to move the skewers.\n\nThe third line contains a sequence b_1, b_2, ..., b_{n} consisting of zeros and ones, according to which Pavel wants to reverse the skewers.\n\n\n-----Output-----\n\nPrint single integer\u00a0\u2014 the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements.\n\n\n-----Examples-----\nInput\n4\n4 3 2 1\n0 1 1 1\n\nOutput\n2\n\nInput\n3\n2 3 1\n0 0 0\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example Pavel can change the permutation to 4, 3, 1, 2.\n\nIn the second example Pavel can change any element of b to 1.",
        "task_name": "0278",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n+1]))\n    b = list(map(int, data[n+1:2*n+1]))\n\n    # Find cycles in the permutation p\n    visited = [False] * n\n    cycles = []\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(x)\n                x = p[x] - 1\n            cycles.append(cycle)\n    \n    # Check number of components with no reversals\n    no_reverse_components = sum(all(b[x] == 0 for x in cycle) for cycle in cycles)\n    \n    # If there is only one component, no change needed\n    if len(cycles) == 1:\n        print(0)\n    else:\n        # Otherwise, we need to ensure at least one reversal in each component\n        print(no_reverse_components if no_reverse_components > 0 else 1)\n\n# Use Standard Input format\nsolve()\n",
        "correct": false,
        "task_id": "279",
        "depth": 2,
        "functions": 1
    },
    {
        "description": "The on-board computer on Polycarp's car measured that the car speed at the beginning of some section of the path equals v_1 meters per second, and in the end it is v_2 meters per second. We know that this section of the route took exactly t seconds to pass.\n\nAssuming that at each of the seconds the speed is constant, and between seconds the speed can change at most by d meters per second in absolute value (i.e., the difference in the speed of any two adjacent seconds does not exceed d in absolute value), find the maximum possible length of the path section in meters.\n\n\n-----Input-----\n\nThe first line contains two integers v_1 and v_2 (1 \u2264 v_1, v_2 \u2264 100) \u2014 the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively.\n\nThe second line contains two integers t (2 \u2264 t \u2264 100) \u2014 the time when the car moves along the segment in seconds, d (0 \u2264 d \u2264 10) \u2014 the maximum value of the speed change between adjacent seconds.\n\nIt is guaranteed that there is a way to complete the segment so that:  the speed in the first second equals v_1,  the speed in the last second equals v_2,  the absolute value of difference of speeds between any two adjacent seconds doesn't exceed d. \n\n\n-----Output-----\n\nPrint the maximum possible length of the path segment in meters. \n\n\n-----Examples-----\nInput\n5 6\n4 2\n\nOutput\n26\nInput\n10 10\n10 0\n\nOutput\n100\n\n\n-----Note-----\n\nIn the first sample the sequence of speeds of Polycarpus' car can look as follows: 5, 7, 8, 6. Thus, the total path is 5 + 7 + 8 + 6 = 26 meters.\n\nIn the second sample, as d = 0, the car covers the whole segment at constant speed v = 10. In t = 10 seconds it covers the distance of 100 meters.",
        "task_name": "0279",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "v1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\nmax_speed = max(v1, v2)\nmin_speed = min(v1, v2)\n\nmax_length = max_speed * t\nmin_length = min_speed * t\n\nfor i in range(t-1, 0, -1):\n    max_speed = max(max_speed - d, min_speed)\n    min_speed = min(min_speed + d, max_speed)\n    max_length += max_speed\n    min_length += min_speed\n\nprint(max_length)\n",
        "correct": false,
        "task_id": "280",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "The on-board computer on Polycarp's car measured that the car speed at the beginning of some section of the path equals v_1 meters per second, and in the end it is v_2 meters per second. We know that this section of the route took exactly t seconds to pass.\n\nAssuming that at each of the seconds the speed is constant, and between seconds the speed can change at most by d meters per second in absolute value (i.e., the difference in the speed of any two adjacent seconds does not exceed d in absolute value), find the maximum possible length of the path section in meters.\n\n\n-----Input-----\n\nThe first line contains two integers v_1 and v_2 (1 \u2264 v_1, v_2 \u2264 100) \u2014 the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively.\n\nThe second line contains two integers t (2 \u2264 t \u2264 100) \u2014 the time when the car moves along the segment in seconds, d (0 \u2264 d \u2264 10) \u2014 the maximum value of the speed change between adjacent seconds.\n\nIt is guaranteed that there is a way to complete the segment so that:  the speed in the first second equals v_1,  the speed in the last second equals v_2,  the absolute value of difference of speeds between any two adjacent seconds doesn't exceed d. \n\n\n-----Output-----\n\nPrint the maximum possible length of the path segment in meters. \n\n\n-----Examples-----\nInput\n5 6\n4 2\n\nOutput\n26\nInput\n10 10\n10 0\n\nOutput\n100\n\n\n-----Note-----\n\nIn the first sample the sequence of speeds of Polycarpus' car can look as follows: 5, 7, 8, 6. Thus, the total path is 5 + 7 + 8 + 6 = 26 meters.\n\nIn the second sample, as d = 0, the car covers the whole segment at constant speed v = 10. In t = 10 seconds it covers the distance of 100 meters.",
        "task_name": "0279",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "# Read input values\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Initialize the list to store the speeds at each second\nspeeds = [0] * t\n\n# Set the speed at the first second\nspeeds[0] = v1\n\n# Set the speed at the last second\nspeeds[-1] = v2\n\n# Calculate maximum possible speeds in between\nfor i in range(1, t):\n    speeds[i] = min(speeds[i-1] + d, v2 + (t - i - 1) * d)\n\n# Calculate total distance traveled\ntotal_distance = sum(speeds)\n\n# Print the result\nprint(total_distance)\n",
        "correct": true,
        "task_id": "280",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "Someone gave Alyona an array containing n positive integers a_1, a_2, ..., a_{n}. In one operation, Alyona can choose any element of the array and decrease it, i.e. replace with any positive integer that is smaller than the current one. Alyona can repeat this operation as many times as she wants. In particular, she may not apply any operation to the array at all.\n\nFormally, after applying some operations Alyona will get an array of n positive integers b_1, b_2, ..., b_{n} such that 1 \u2264 b_{i} \u2264 a_{i} for every 1 \u2264 i \u2264 n. Your task is to determine the maximum possible value of mex of this array.\n\nMex of an array in this problem is the minimum positive integer that doesn't appear in this array. For example, mex of the array containing 1, 3 and 4 is equal to 2, while mex of the array containing 2, 3 and 2 is equal to 1.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000)\u00a0\u2014 the number of elements in the Alyona's array.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 the elements of the array.\n\n\n-----Output-----\n\nPrint one positive integer\u00a0\u2014 the maximum possible value of mex of the array after Alyona applies some (possibly none) operations.\n\n\n-----Examples-----\nInput\n5\n1 3 3 3 6\n\nOutput\n5\n\nInput\n2\n2 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample case if one will decrease the second element value to 2 and the fifth element value to 4 then the mex value of resulting array 1 2 3 3 4 will be equal to 5.\n\nTo reach the answer to the second sample case one must not decrease any of the array elements.",
        "task_name": "0143",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "n = int(input())\narr = list(map(int, input().split()))\narr.sort()\nmex = 1\nfor num in arr:\n    if num == mex:\n        mex += 1\n    elif num > mex:\n        break\nprint(mex)\n",
        "correct": false,
        "task_id": "144",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "Someone gave Alyona an array containing n positive integers a_1, a_2, ..., a_{n}. In one operation, Alyona can choose any element of the array and decrease it, i.e. replace with any positive integer that is smaller than the current one. Alyona can repeat this operation as many times as she wants. In particular, she may not apply any operation to the array at all.\n\nFormally, after applying some operations Alyona will get an array of n positive integers b_1, b_2, ..., b_{n} such that 1 \u2264 b_{i} \u2264 a_{i} for every 1 \u2264 i \u2264 n. Your task is to determine the maximum possible value of mex of this array.\n\nMex of an array in this problem is the minimum positive integer that doesn't appear in this array. For example, mex of the array containing 1, 3 and 4 is equal to 2, while mex of the array containing 2, 3 and 2 is equal to 1.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000)\u00a0\u2014 the number of elements in the Alyona's array.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 the elements of the array.\n\n\n-----Output-----\n\nPrint one positive integer\u00a0\u2014 the maximum possible value of mex of the array after Alyona applies some (possibly none) operations.\n\n\n-----Examples-----\nInput\n5\n1 3 3 3 6\n\nOutput\n5\n\nInput\n2\n2 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample case if one will decrease the second element value to 2 and the fifth element value to 4 then the mex value of resulting array 1 2 3 3 4 will be equal to 5.\n\nTo reach the answer to the second sample case one must not decrease any of the array elements.",
        "task_name": "0143",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\n# Sort the array\na.sort()\n\n# Initialize the target mex value\nmex = 1\n\n# Iterate through the sorted array\nfor num in a:\n    if num >= mex:\n        mex += 1\n\n# Print the maximum possible value of mex\nprint(mex)\n",
        "correct": true,
        "task_id": "144",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "As you know, every birthday party has a cake! This time, Babaei is going to prepare the very special birthday party's cake.\n\nSimple cake is a cylinder of some radius and height. The volume of the simple cake is equal to the volume of corresponding cylinder. Babaei has n simple cakes and he is going to make a special cake placing some cylinders on each other.\n\nHowever, there are some additional culinary restrictions. The cakes are numbered in such a way that the cake number i can be placed only on the table or on some cake number j where j < i. Moreover, in order to impress friends Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j.\n\nBabaei wants to prepare a birthday cake that has a maximum possible total volume. Help him find this value.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000)\u00a0\u2014 the number of simple cakes Babaei has.\n\nEach of the following n lines contains two integers r_{i} and h_{i} (1 \u2264 r_{i}, h_{i} \u2264 10 000), giving the radius and height of the i-th cake.\n\n\n-----Output-----\n\nPrint the maximum volume of the cake that Babaei can make. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\nNamely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if $\\frac{|a - b|}{\\operatorname{max}(1, b)} \\leq 10^{-6}$.\n\n\n-----Examples-----\nInput\n2\n100 30\n40 10\n\nOutput\n942477.796077000\n\nInput\n4\n1 1\n9 7\n1 4\n10 7\n\nOutput\n3983.539484752\n\n\n\n-----Note-----\n\nIn first sample, the optimal way is to choose the cake number 1.\n\nIn second sample, the way to get the maximum volume is to use cakes with indices 1, 2 and 4.",
        "task_name": "0250",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "import math\n\nn = int(input())\ncakes = []\nfor _ in range(n):\n    r, h = map(int, input().split())\n    cakes.append((math.pi * r * r * h, r, h))\n\ncakes.sort(reverse=True)\n\ndp = [0.0] * n\ndp[0] = cakes[0][0]\n\nfor i in range(1, n):\n    dp[i] = cakes[i][0]\n    for j in range(i):\n        if cakes[i][1] < cakes[j][1] and cakes[i][2] < cakes[j][2]:\n            dp[i] = max(dp[i], dp[j] + cakes[i][0])\n\nprint(dp[-1])\n",
        "correct": false,
        "task_id": "251",
        "depth": 2,
        "functions": 0
    },
    {
        "description": "As you know, every birthday party has a cake! This time, Babaei is going to prepare the very special birthday party's cake.\n\nSimple cake is a cylinder of some radius and height. The volume of the simple cake is equal to the volume of corresponding cylinder. Babaei has n simple cakes and he is going to make a special cake placing some cylinders on each other.\n\nHowever, there are some additional culinary restrictions. The cakes are numbered in such a way that the cake number i can be placed only on the table or on some cake number j where j < i. Moreover, in order to impress friends Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j.\n\nBabaei wants to prepare a birthday cake that has a maximum possible total volume. Help him find this value.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000)\u00a0\u2014 the number of simple cakes Babaei has.\n\nEach of the following n lines contains two integers r_{i} and h_{i} (1 \u2264 r_{i}, h_{i} \u2264 10 000), giving the radius and height of the i-th cake.\n\n\n-----Output-----\n\nPrint the maximum volume of the cake that Babaei can make. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\nNamely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if $\\frac{|a - b|}{\\operatorname{max}(1, b)} \\leq 10^{-6}$.\n\n\n-----Examples-----\nInput\n2\n100 30\n40 10\n\nOutput\n942477.796077000\n\nInput\n4\n1 1\n9 7\n1 4\n10 7\n\nOutput\n3983.539484752\n\n\n\n-----Note-----\n\nIn first sample, the optimal way is to choose the cake number 1.\n\nIn second sample, the way to get the maximum volume is to use cakes with indices 1, 2 and 4.",
        "task_name": "0250",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "import sys\nimport math\ninput = sys.stdin.read\n\ndef max_cake_volume(n, cakes):\n    volumes = [(math.pi * r * r * h) for r, h in cakes]\n    dp = [0] * n\n    \n    for i in range(n):\n        dp[i] = volumes[i]\n        for j in range(i):\n            if volumes[j] < volumes[i]:\n                dp[i] = max(dp[i], dp[j] + volumes[i])\n                \n    return max(dp)\n\ndef main():\n    data = input().split()\n    n = int(data[0])\n    cakes = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n)]\n    result = max_cake_volume(n, cakes)\n    print(f\"{result:.6f}\")\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": false,
        "task_id": "251",
        "depth": 2,
        "functions": 2
    },
    {
        "description": "Amr bought a new video game \"Guess Your Way Out!\". The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height h. The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node. \n\nLet's index all the leaf nodes from the left to the right from 1 to 2^{h}. The exit is located at some node n where 1 \u2264 n \u2264 2^{h}, the player doesn't know where the exit is so he has to guess his way out!\n\nAmr follows simple algorithm to choose the path. Let's consider infinite command string \"LRLRLRLRL...\" (consisting of alternating characters 'L' and 'R'). Amr sequentially executes the characters of the string using following rules:  Character 'L' means \"go to the left child of the current node\";  Character 'R' means \"go to the right child of the current node\";  If the destination node is already visited, Amr skips current command, otherwise he moves to the destination node;  If Amr skipped two consecutive commands, he goes back to the parent of the current node before executing next command;  If he reached a leaf node that is not the exit, he returns to the parent of the current node;  If he reaches an exit, the game is finished. \n\nNow Amr wonders, if he follows this algorithm, how many nodes he is going to visit before reaching the exit?\n\n\n-----Input-----\n\nInput consists of two integers h, n (1 \u2264 h \u2264 50, 1 \u2264 n \u2264 2^{h}).\n\n\n-----Output-----\n\nOutput a single integer representing the number of nodes (excluding the exit node) Amr is going to visit before reaching the exit by following this algorithm.\n\n\n-----Examples-----\nInput\n1 2\n\nOutput\n2\nInput\n2 3\n\nOutput\n5\nInput\n3 6\n\nOutput\n10\nInput\n10 1024\n\nOutput\n2046\n\n\n-----Note-----\n\nA perfect binary tree of height h is a binary tree consisting of h + 1 levels. Level 0 consists of a single node called root, level h consists of 2^{h} nodes called leaves. Each node that is not a leaf has exactly two children, left and right one. \n\nFollowing picture illustrates the sample test number 3. Nodes are labeled according to the order of visit.\n\n[Image]",
        "task_name": "0292",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "h, n = map(int, input().split())\nans = 0\nwhile n > 1:\n    if n % 2 == 0:\n        ans += (n // 2) - 1\n    else:\n        ans += n // 2\n    n //= 2\nprint(ans)\n",
        "correct": false,
        "task_id": "293",
        "depth": 1,
        "functions": 0
    },
    {
        "description": "Amr bought a new video game \"Guess Your Way Out!\". The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height h. The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node. \n\nLet's index all the leaf nodes from the left to the right from 1 to 2^{h}. The exit is located at some node n where 1 \u2264 n \u2264 2^{h}, the player doesn't know where the exit is so he has to guess his way out!\n\nAmr follows simple algorithm to choose the path. Let's consider infinite command string \"LRLRLRLRL...\" (consisting of alternating characters 'L' and 'R'). Amr sequentially executes the characters of the string using following rules:  Character 'L' means \"go to the left child of the current node\";  Character 'R' means \"go to the right child of the current node\";  If the destination node is already visited, Amr skips current command, otherwise he moves to the destination node;  If Amr skipped two consecutive commands, he goes back to the parent of the current node before executing next command;  If he reached a leaf node that is not the exit, he returns to the parent of the current node;  If he reaches an exit, the game is finished. \n\nNow Amr wonders, if he follows this algorithm, how many nodes he is going to visit before reaching the exit?\n\n\n-----Input-----\n\nInput consists of two integers h, n (1 \u2264 h \u2264 50, 1 \u2264 n \u2264 2^{h}).\n\n\n-----Output-----\n\nOutput a single integer representing the number of nodes (excluding the exit node) Amr is going to visit before reaching the exit by following this algorithm.\n\n\n-----Examples-----\nInput\n1 2\n\nOutput\n2\nInput\n2 3\n\nOutput\n5\nInput\n3 6\n\nOutput\n10\nInput\n10 1024\n\nOutput\n2046\n\n\n-----Note-----\n\nA perfect binary tree of height h is a binary tree consisting of h + 1 levels. Level 0 consists of a single node called root, level h consists of 2^{h} nodes called leaves. Each node that is not a leaf has exactly two children, left and right one. \n\nFollowing picture illustrates the sample test number 3. Nodes are labeled according to the order of visit.\n\n[Image]",
        "task_name": "0292",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "def main():\n    import sys\n    input = sys.stdin.read\n    h, n = map(int, input().split())\n\n    # Calculate the total number of leaf nodes\n    total_leaves = 2 ** h\n\n    # Track the number of visited nodes\n    visited_count = 0\n\n    # Binary representation of the path to the exit node\n    path = bin(n - 1)[2:].zfill(h)\n\n    current_level = 0\n    current_node = 0  # Represent the root node\n\n    # Simulate the traversal\n    for direction in path:\n        visited_count += 1\n        if direction == '0':\n            current_node = 2 * current_node + 1  # Move to the left child\n        else:\n            current_node = 2 * current_node + 2  # Move to the right child\n\n    # Total nodes visited (excluding the exit node itself)\n    print(visited_count)\n\nif __name__ == \"__main__\":\n    main()\n",
        "correct": false,
        "task_id": "293",
        "depth": 1,
        "functions": 1
    },
    {
        "description": "Neko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.\n\nNeko has two integers $a$ and $b$. His goal is to find a non-negative integer $k$ such that the least common multiple of $a+k$ and $b+k$ is the smallest possible. If there are multiple optimal integers $k$, he needs to choose the smallest one.\n\nGiven his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n\n-----Input-----\n\nThe only line contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$).\n\n\n-----Output-----\n\nPrint the smallest non-negative integer $k$ ($k \\ge 0$) such that the lowest common multiple of $a+k$ and $b+k$ is the smallest possible.\n\nIf there are many possible integers $k$ giving the same value of the least common multiple, print the smallest one.\n\n\n-----Examples-----\nInput\n6 10\n\nOutput\n2\nInput\n21 31\n\nOutput\n9\nInput\n5 10\n\nOutput\n0\n\n\n-----Note-----\n\nIn the first test, one should choose $k = 2$, as the least common multiple of $6 + 2$ and $10 + 2$ is $24$, which is the smallest least common multiple possible.",
        "task_name": "0081",
        "dataset": "apps",
        "model": "llama3-70b",
        "generated_code": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\na, b = map(int, input().split())\n\nk = 0\nmin_lcm = lcm(a, b)\n\nwhile True:\n    if lcm(a + k, b + k) < min_lcm:\n        min_lcm = lcm(a + k, b + k)\n    else:\n        break\n    k += 1\n\nprint(k - 1)\n",
        "correct": false,
        "task_id": "82",
        "depth": 1,
        "functions": 2
    },
    {
        "description": "Neko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.\n\nNeko has two integers $a$ and $b$. His goal is to find a non-negative integer $k$ such that the least common multiple of $a+k$ and $b+k$ is the smallest possible. If there are multiple optimal integers $k$, he needs to choose the smallest one.\n\nGiven his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n\n-----Input-----\n\nThe only line contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$).\n\n\n-----Output-----\n\nPrint the smallest non-negative integer $k$ ($k \\ge 0$) such that the lowest common multiple of $a+k$ and $b+k$ is the smallest possible.\n\nIf there are many possible integers $k$ giving the same value of the least common multiple, print the smallest one.\n\n\n-----Examples-----\nInput\n6 10\n\nOutput\n2\nInput\n21 31\n\nOutput\n9\nInput\n5 10\n\nOutput\n0\n\n\n-----Note-----\n\nIn the first test, one should choose $k = 2$, as the least common multiple of $6 + 2$ and $10 + 2$ is $24$, which is the smallest least common multiple possible.",
        "task_name": "0081",
        "dataset": "apps",
        "model": "gpt-4o",
        "generated_code": "import math\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n\n    diff = abs(a - b)\n    min_lcm = float('inf')\n    min_k = 0\n\n    for k in range(1, int(math.sqrt(diff)) + 1):\n        if diff % k == 0:\n            # Check both k and diff // k as possible values for the smallest k\n            for candidate in [k, diff // k]:\n                new_a = (a + candidate - 1) // candidate * candidate\n                new_b = (b + candidate - 1) // candidate * candidate\n                current_lcm = lcm(new_a, new_b)\n                if current_lcm < min_lcm or (current_lcm == min_lcm and candidate < min_k):\n                    min_lcm = current_lcm\n                    min_k = candidate\n\n    return min_k\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    a = int(data[0])\n    b = int(data[1])\n    print(find_min_k(a, b))\n",
        "correct": false,
        "task_id": "82",
        "depth": 2,
        "functions": 3
    }
]