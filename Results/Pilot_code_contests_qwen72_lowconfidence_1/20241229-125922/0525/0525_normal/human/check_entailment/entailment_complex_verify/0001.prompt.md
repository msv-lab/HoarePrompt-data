
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: For years, the Day of city N was held in the most rainy day of summer. New mayor decided to break this tradition and select a not-so-rainy day for the celebration. The mayor knows the weather forecast for the n days of summer. On the i-th day, a_i millimeters of rain will fall. All values a_i are distinct.

The mayor knows that citizens will watch the weather x days before the celebration and y days after. Because of that, he says that a day d is not-so-rainy if a_d is smaller than rain amounts at each of x days before day d and and each of y days after day d. In other words, a_d < a_j should hold for all d - x ≤ j < d and d < j ≤ d + y. Citizens only watch the weather during summer, so we only consider such j that 1 ≤ j ≤ n.

Help mayor find the earliest not-so-rainy day of summer.

Input

The first line contains three integers n, x and y (1 ≤ n ≤ 100 000, 0 ≤ x, y ≤ 7) — the number of days in summer, the number of days citizens watch the weather before the celebration and the number of days they do that after.

The second line contains n distinct integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9), where a_i denotes the rain amount on the i-th day.

Output

Print a single integer — the index of the earliest not-so-rainy day of summer. We can show that the answer always exists.

Examples

Input


10 2 2
10 9 6 7 8 3 2 1 4 5


Output


3


Input


10 2 3
10 9 6 7 8 3 2 1 4 5


Output


8


Input


5 5 5
100000 10000 1000 100 10


Output


5

Note

In the first example days 3 and 8 are not-so-rainy. The 3-rd day is earlier.

In the second example day 3 is not not-so-rainy, because 3 + y = 6 and a_3 > a_6. Thus, day 8 is the answer. Note that 8 + y = 11, but we don't consider day 11, because it is not summer.
Program:
```
import sys

def func():
    sys.setrecursionlimit(10 ** 6)
    (n, x, y) = map(int, raw_input().split())
    inp2 = map(int, raw_input().split())
    for i in range(n):
        flag = True
        val = inp2[i]
        for bef in range(1, x + 1):
            indis = i - bef
            if indis < 0:
                break
            if indis >= n:
                break
            if val > inp2[indis]:
                flag = False
                break
        for aft in range(1, y + 1):
            indis = i + aft
            if indis < 0:
                break
            if indis >= n:
                break
            if val > inp2[indis]:
                flag = False
                break
        if flag:
            print(i + 1)
            break


```
Original Assessment: Correctness: **False**

Explanation: The program has a logical issue in how it handles the indices for checking the conditions for a not-so-rainy day. Specifically, the `break` statements inside the nested loops terminate the loop prematurely without ensuring that all required conditions are checked.

For example, consider the following input:
```
10 2 2
10 9 6 7 8 3 2 1 4 5
```

The expected output is `3`, but the program might incorrectly output a different value due to the premature termination of the loops.

Here's a more detailed breakdown of the issue:

1. **Premature Break in `for bef` Loop**:
   ```python
   for bef in range(1, x + 1):
       indis = i - bef
       if indis < 0:
           break
       if indis >= n:
           break
       if val > inp2[indis]:
           flag = False
           break
   ```
   If `indis < 0` or `indis >= n`, the loop breaks immediately without checking all the necessary conditions. This means that the program might miss some conditions that need to be checked.

2. **Premature Break in `for aft` Loop**:
   ```python
   for aft in range(1, y + 1):
       indis = i + aft
       if indis < 0:
           break
       if indis >= n:
           break
       if val > inp2[indis]:
           flag = False
           break
   ```
   Similarly, if `indis < 0` or `indis >= n`, the loop breaks immediately without checking all the necessary conditions.

To fix this, the loops should continue checking all conditions even if some indices are out of bounds, and only set `flag` to `False` if the condition `val > inp2[indis]` is met for any valid `indis`.

A corrected version of the program would look like this:
```python
import sys

def func():
    sys.setrecursionlimit(10 ** 6)
    (n, x, y) = map(int, input().split())
    inp2 = list(map(int, input().split()))
    for i in range(n):
        flag = True
        val = inp2[i]
        for bef in range(1, x + 1):
            indis = i - bef
            if 0 <= indis < n and val >= inp2[indis]:
                flag = False
                break
        for aft in range(1, y + 1):
            indis = i + aft
            if 0 <= indis < n and val >= inp2[indis]:
                flag = False
                break
        if flag:
            print(i + 1)
            break
```

This corrected version ensures that all conditions are checked properly, and the program will correctly identify the earliest not-so-rainy day.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
import sys

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 100,000, x and y are integers such that 0 ≤ x, y ≤ 7, and a is a list of n distinct integers where 1 ≤ a_i ≤ 10^9.
def func():
    sys.setrecursionlimit(10 ** 6)
    n, x, y = map(int, raw_input().split())
    inp2 = map(int, raw_input().split())
    for i in range(n):
        flag = True
        
        val = inp2[i]
        
        for bef in range(1, x + 1):
            indis = i - bef
            if indis < 0:
                break
            if indis >= n:
                break
            if val > inp2[indis]:
                flag = False
                break
        
        for aft in range(1, y + 1):
            indis = i + aft
            if indis < 0:
                break
            if indis >= n:
                break
            if val > inp2[indis]:
                flag = False
                break
        
        if flag:
            print(i + 1)
            break
        
    #State of the program after the  for loop has been executed: `n` is an integer from the input such that 1 ≤ n ≤ 100,000, `x` is an integer from the input such that 0 ≤ x ≤ 7, `y` is an integer from the input such that 0 ≤ y ≤ 7, `a` is a list of n distinct integers where 1 ≤ a_i ≤ 10^9, the recursion limit is set to 1,000,000, `inp2` is a list (or iterator) of integers obtained from the input, `i` is the last index of `inp2` checked, `val` is the last element of `inp2` that was processed, `aft` is the last value of `aft` before the loop terminated, `indis` is the last value of `indis` before the loop terminated. If the loop completes without breaking, `i` will be `n-1`. If the loop finds an `i` such that `val` (which is `inp2[i]`) is not greater than any element in `inp2` from `i - x` to `i + y` (inclusive), `flag` remains `True`, and `i + 1` is printed. If no such `i` is found, the loop completes without printing anything, and `flag` is `False`.
#Overall this is what the function does:The function reads two lines of input. The first line contains three integers `n`, `x`, and `y`, where `1 ≤ n ≤ 100,000` and `0 ≤ x, y ≤ 7`. The second line contains `n` distinct integers, each between `1` and `10^9`. The function then checks each element in the list to see if it is not greater than any of its `x` preceding elements or `y` following elements. If such an element is found, the function prints the 1-based index of this element and terminates. If no such element is found, the function completes without printing anything. The recursion limit is set to 1,000,000, but the function does not use recursion. The final state of the program includes the updated recursion limit and the processed input variables, but the original list `a` is not modified.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
