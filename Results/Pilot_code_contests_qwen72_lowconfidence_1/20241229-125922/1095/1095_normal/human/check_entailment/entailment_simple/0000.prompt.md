
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There are N blocks arranged in a row. Let us paint these blocks.

We will consider two ways to paint the blocks different if and only if there is a block painted in different colors in those two ways.

Find the number of ways to paint the blocks under the following conditions:

* For each block, use one of the M colors, Color 1 through Color M, to paint it. It is not mandatory to use all the colors.
* There may be at most K pairs of adjacent blocks that are painted in the same color.



Since the count may be enormous, print it modulo 998244353.

Constraints

* All values in input are integers.
* 1 \leq N, M \leq 2 \times 10^5
* 0 \leq K \leq N - 1

Input

Input is given from Standard Input in the following format:


N M K


Output

Print the answer.

Examples

Input

3 2 1


Output

6


Input

100 100 0


Output

73074801


Input

60522 114575 7559


Output

479519525
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from sys import stdin, stdout, setrecursionlimit
from functools import lru_cache

rl = lambda : stdin.readline()
rll = lambda : stdin.readline().split()
rli = lambda : map(int, stdin.readline().split())
(INF, NINF) = (float('inf'), float('-inf'))
if __name__ == '__main__':
    func_3()

#Function 1:
#State of the program right berfore the function call: n is a non-negative integer, q is a positive integer greater than 1 and is used as the modulus in the calculations.
def func_1(n, q):
    fact = [(1) for _ in range(n + 1)]
    inv = [(1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % q
        
        inv[i] = pow(fact[i], q - 2, q)
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `q` is a positive integer greater than 1, `fact` is a list of length `n + 1` where `fact[i]` is equal to the factorial of `i` modulo `q` for each `i` in the range `[0, n]`, `inv` is a list of length `n + 1` where `inv[i]` is the modular multiplicative inverse of `fact[i]` modulo `q` for each `i` in the range `[1, n]`, and all other elements are equal to 1.
    return fact, inv
    #The program returns `fact` and `inv`. `fact` is a list of length `n + 1` where each element `fact[i]` is equal to the factorial of `i` modulo `q`. `inv` is a list of length `n + 1` where each element `inv[i]` is the modular multiplicative inverse of `fact[i]` modulo `q` for each `i` in the range `[1, n]`, and all other elements are equal to 1.

#Function 2:
#State of the program right berfore the function call: n, k are non-negative integers such that 0 <= k <= n, q is a positive integer, F and I are lists of integers where F[n] and I[k] are defined and non-negative, and I[n - k] is defined and non-negative.
def func_2(n, k, q, F, I):
    return F[n] * (I[k] * I[n - k] % q) % q
    #The program returns (F[n] * (I[k] * I[n - k] % q)) % q, where F[n], I[k], and I[n - k] are non-negative integers from the lists F and I, and q is a positive integer.

#Function 3:
#State of the program right berfore the function call: n, m, and k are integers such that 1 <= n, m <= 2 * 10^5 and 0 <= k <= n - 1.
def func_3():
    MOD = 998244353
    n, m, k = rli()
    F, I = func_1(n, MOD)
    ans = 0
    for i in range(n - k, n + 1):
        ans += func_2(n - 1, i - 1, MOD, F, I) * m * pow(m - 1, i - 1, MOD) % MOD
        
    #State of the program after the  for loop has been executed: `n`, `m`, and `k` are integers such that \(1 \leq n, m \leq 2 \times 10^5\) and \(0 \leq k \leq n - 1\); `MOD` is 998244353; `F` and `I` are the values returned by `func_1(n, MOD)`, `ans` is the sum of `func_2(n - 1, i - 1, MOD, F, I) * m * pow(m - 1, i - 1, MOD) % MOD` for `i` from `n - k` to `n`.
    print(ans % MOD)


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
