
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description:     per nextum in unam tum XI conscribementis fac sic  
        vestibulo perlegementum da varo.  
        morde varo.  
        seqis cumula varum.  
    cis  
      
    per nextum in unam tum XI conscribementis fac sic  
        seqis decumulamenta da varo.  
        varum privamentum fodementum da aresulto.  
        varum tum III elevamentum tum V multiplicamentum da bresulto.  
        aresultum tum bresultum addementum da resulto.  
      
        si CD tum resultum non praestantiam fac sic  
            dictum sic f(%d) = %.2f cis tum varum tum resultum egresso describe.  
            novumversum egresso scribe.  
        cis  
        si CD tum resultum praestantiam fac sic  
            dictum sic f(%d) = MAGNA NIMIS! cis tum varum egresso describe.  
            novumversum egresso scribe.          
        cis  
    cis  
    

Input

The input consists of several integers, one per line. Each integer is between -50 and 50, inclusive.

Output

As described in the problem statement.

Example

Input


0
1
-2
-3
-4
-5
-6
-7
-8
-9
10


Output


f(10) = MAGNA NIMIS!
f(-9) = -3642.00
f(-8) = -2557.17
f(-7) = -1712.35
f(-6) = -1077.55
f(-5) = -622.76
f(-4) = -318.00
f(-3) = -133.27
f(-2) = -38.59
f(1) = 6.00
f(0) = 0.00
Program:
```
from math import *

def func():
    f = []
    for i in range(11):
        f.append(int(raw_input()))
    f.reverse()
    for x in f:
        y = abs(x)
        z = sqrt(y) + x ** 3 * 5
        if z < 400:
            print('f(%d) = %.2f' % (x, z))
        else:
            print('f(%d) = MAGNA NIMIS!' % x)


```
Original Assessment: Correctness: **False**

Explanation: The provided Python program has a few issues that make it not fully compliant with the problem description:

1. **Handling of Negative Numbers**: The program uses `y = abs(x)` before calculating the square root, which means it always takes the square root of a non-negative number. However, the problem description does not specify that the square root should be taken of the absolute value. This could lead to incorrect results for negative numbers, especially since the square root of a negative number is not defined in the real number system, and the problem does not specify how to handle this case.

2. **Order of Operations**: The problem description specifies that the square root and the cube operation should be applied to the original value of `varo` (i.e., `x`), but the program applies the square root to the absolute value of `x`. This changes the behavior of the function for negative inputs.

3. **Edge Case Handling**: The program does not explicitly handle the edge case where `x` is zero. While the current implementation works for zero, it's not clear if this was intended or if it would work in all edge cases as per the problem description.

4. **Output Format**: The output format specified in the problem description is `f(%d) = %.2f` for values less than 400 and `f(%d) = MAGNA NIMIS!` for values greater than or equal to 400. The program correctly follows this format, but the correctness of the calculations is still in question due to the issues mentioned above.

To illustrate, consider the input `-2`:
- According to the program, `y = abs(-2) = 2`, so `sqrt(y) = sqrt(2) â‰ˆ 1.41`.
- The calculation becomes `z = 1.41 + (-2)**3 * 5 = 1.41 - 40 = -38.59`.
- The program outputs `f(-2) = -38.59`, which is correct according to the program's logic but not necessarily according to the problem description, which does not specify taking the absolute value before the square root.

For these reasons, the program is considered incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from math import *

#State of the program right berfore the function call: The function reads from standard input, where each line contains an integer between -50 and 50, inclusive.
def func():
    f = []
    for i in range(11):
        f.append(int(raw_input()))
        
    #State of the program after the  for loop has been executed: `f` is a list containing 11 integer values, each value being an integer between -50 and 50, inclusive, `i` is 10
    f.reverse()
    for x in f:
        y = abs(x)
        
        z = sqrt(y) + x ** 3 * 5
        
        if z < 400:
            print('f(%d) = %.2f' % (x, z))
        else:
            print('f(%d) = MAGNA NIMIS!' % x)
        
    #State of the program after the  for loop has been executed: `f` is a list containing 11 integer values, each value being an integer between -50 and 50, inclusive, in reverse order, `i` is 10, `x` is the last element of `f`, `y` is `abs(f[10])`, `z` is `sqrt(abs(f[10])) + f[10]
#Overall this is what the function does:The function `func` reads 11 integers from standard input, where each integer is between -50 and 50, inclusive. It stores these integers in a list `f`. The list is then reversed. For each integer `x` in the reversed list, it calculates `y` as the absolute value of `x`, and `z` as the square root of `y` plus five times the cube of `x`. If `z` is less than 400, it prints `f(x) = z` formatted to two decimal places. Otherwise, it prints `f(x) = MAGNA NIMIS!`. After the function completes, the list `f` contains 11 integers in reverse order, and the program has printed the results for each integer in `f`. The function does not return any value. Edge cases include handling negative numbers and the boundary condition where `z` is exactly 400, which would still trigger the "MAGNA NIMIS!" message.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
