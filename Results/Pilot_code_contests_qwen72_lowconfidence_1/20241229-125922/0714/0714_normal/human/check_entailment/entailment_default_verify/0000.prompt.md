
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Recently, the bear started studying data structures and faced the following problem.

You are given a sequence of integers x1, x2, ..., xn of length n and m queries, each of them is characterized by two integers li, ri. Let's introduce f(p) to represent the number of such indexes k, that xk is divisible by p. The answer to the query li, ri is the sum: <image>, where S(li, ri) is a set of prime numbers from segment [li, ri] (both borders are included in the segment).

Help the bear cope with the problem.

Input

The first line contains integer n (1 ≤ n ≤ 106). The second line contains n integers x1, x2, ..., xn (2 ≤ xi ≤ 107). The numbers are not necessarily distinct.

The third line contains integer m (1 ≤ m ≤ 50000). Each of the following m lines contains a pair of space-separated integers, li and ri (2 ≤ li ≤ ri ≤ 2·109) — the numbers that characterize the current query.

Output

Print m integers — the answers to the queries on the order the queries appear in the input.

Examples

Input

6
5 5 7 10 14 15
3
2 11
3 12
4 4


Output

9
7
0


Input

7
2 3 5 7 11 4 8
2
8 10
2 123


Output

0
7

Note

Consider the first sample. Overall, the first sample has 3 queries.

  1. The first query l = 2, r = 11 comes. You need to count f(2) + f(3) + f(5) + f(7) + f(11) = 2 + 1 + 4 + 2 + 0 = 9. 
  2. The second query comes l = 3, r = 12. You need to count f(3) + f(5) + f(7) + f(11) = 1 + 4 + 2 + 0 = 7. 
  3. The third query comes l = 4, r = 4. As this interval has no prime numbers, then the sum equals 0. 
Program:
```
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase
from math import ceil,floor,log,sqrt,factorial
#Function 1:
def func_1():
    return int(input())

#Function 2:
def func_2():
    return input()

#Function 3:
def func_3():
    return map(int, input().strip().split(' '))

#Function 4:
def func_4():
    return map(str, input().strip().split(' '))

#Function 5:
def func_5():
    return list(func_3())

#Function 6:
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
def func_7(item):
    return item[1]

#Function 8:
def func_8(l):
    return sorted(l, key=getKey, reverse=True)

#Function 9:
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]

#Function 10:
def func_10(x):
    return x and (not x & x - 1)

#Function 11:
def func_11(n):
    return bin(n).replace('0b', '')

#Function 12:
def func_12(n):
    return [int(i) for i in str(n)]

#Function 13:
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(n - r))

#Function 14:
def func_14(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p
    return res

#Function 15:
def func_15(x, y):
    while y:
        (x, y) = (y, x % y)
    return x

#Function 16:
def func_16(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True

#Function 17:
def func_17():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 18:
def func_18(n):
    p = 2
    prime[1] = False
    while p * p <= n:
        if prime[p] == True:
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1

#Function 19:
def func_19():
    n = func_1()
    a = func_5()
    p = [0] * 10000005
    func_18(10000005)
    for i in range(n):
        for j in range(1, int(sqrt(a[i])) + 1):
            if prime[j] == True:
                if a[i] % j == 0:
                    p[j] += 1
            if a[i] % j == 0:
                if prime[a[i] // j] == False:
                    continue
                p[a[i] // j] += 1
    for i in range(1, 10000005):
        p[i] += p[i - 1]
    q = func_1()
    for i in range(q):
        (l, r) = func_3()
        func_20(p[r] - p[l - 1])

#Function 20:
def func_20(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()


```
Original Assessment: Correctness: **False**.

Explanation: The provided program has several issues that prevent it from correctly solving the problem as described:

1. **Prime Number Sieve Initialization**: The `prime` list, which is supposed to store the primality of numbers, is not initialized before being used in the `func_18` function. This will lead to errors when accessing `prime[j]` and `prime[a[i] // j]`.

2. **Handling of Divisors**: In the `func_19` function, the loop that checks divisors of `a[i]` only iterates up to `int(sqrt(a[i]))`. This means that if `a[i]` is a perfect square, its square root will be checked, but the corresponding divisor `a[i] // j` might not be a prime number, leading to incorrect counts.

3. **Edge Case Handling**: The program does not handle the case where the input values for `l` and `r` are very large (up to \(2 \times 10^9\)). The `p` array is only sized up to 10,000,005, which is insufficient for the upper bound of \(2 \times 10^9\).

4. **Cumulative Sum Calculation**: The cumulative sum calculation in the `p` array assumes that all indices up to 10,000,005 are valid, which may not be the case if the input values for `l` and `r` exceed this range.

Given these issues, the program will fail to produce the correct output for certain inputs, particularly those involving large values of `l` and `r` or specific edge cases in the input data. Therefore, the program is incorrect.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: Output hints for function number 20 : The function `func_20` prints the values provided in the `args` tuple to a specified stream (`file`), with each value separated by the string `sep`. After printing all values, it appends the string `end` (defaulting to a newline character `\n`). If the `flush` parameter is `True`, the stream is forcibly flushed. If `args` is an empty tuple, nothing is written to the stream, and `file` remains unchanged. The function does not return any value. The final state of the program after the function concludes is that the `file` stream contains the concatenated string representation of the elements in `args`, separated by `sep` and followed by `end`. If `flush` was `True`, the stream is guaranteed to be flushed.+


Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
