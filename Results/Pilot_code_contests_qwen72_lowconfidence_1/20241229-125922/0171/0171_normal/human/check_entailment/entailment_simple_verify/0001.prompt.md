
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Hilbert's Hotel is a very unusual hotel since the number of rooms is infinite! In fact, there is exactly one room for every integer, including zero and negative integers. Even stranger, the hotel is currently at full capacity, meaning there is exactly one guest in every room. The hotel's manager, David Hilbert himself, decides he wants to shuffle the guests around because he thinks this will create a vacancy (a room without a guest).

For any integer k and positive integer n, let kmod n denote the remainder when k is divided by n. More formally, r=kmod n is the smallest non-negative integer such that k-r is divisible by n. It always holds that 0≤ kmod n≤ n-1. For example, 100mod 12=4 and (-1337)mod 3=1.

Then the shuffling works as follows. There is an array of n integers a_0,a_1,…,a_{n-1}. Then for each integer k, the guest in room k is moved to room number k+a_{kmod n}.

After this shuffling process, determine if there is still exactly one guest assigned to each room. That is, there are no vacancies or rooms with multiple guests.

Input

Each test consists of multiple test cases. The first line contains a single integer t (1≤ t≤ 10^4) — the number of test cases. Next 2t lines contain descriptions of test cases.

The first line of each test case contains a single integer n (1≤ n≤ 2⋅ 10^5) — the length of the array.

The second line of each test case contains n integers a_0,a_1,…,a_{n-1} (-10^9≤ a_i≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2⋅ 10^5.

Output

For each test case, output a single line containing "YES" if there is exactly one guest assigned to each room after the shuffling process, or "NO" otherwise. You can print each letter in any case (upper or lower).

Example

Input


6
1
14
2
1 -1
4
5 5 5 1
3
3 2 1
2
0 1
5
-239 -2 -100 -3 -11


Output


YES
YES
YES
NO
NO
YES

Note

In the first test case, every guest is shifted by 14 rooms, so the assignment is still unique.

In the second test case, even guests move to the right by 1 room, and odd guests move to the left by 1 room. We can show that the assignment is still unique.

In the third test case, every fourth guest moves to the right by 1 room, and the other guests move to the right by 5 rooms. We can show that the assignment is still unique.

In the fourth test case, guests 0 and 1 are both assigned to room 3.

In the fifth test case, guests 1 and 2 are both assigned to room 2.
Program:
```
import sys

def func():
    input = sys.stdin.readline
    for _ in xrange(int(input())):
        n = int(input())
        seq = [int(x) for x in input().split()]
        s = sorted([i + seq[i % n] for i in xrange(2 * n)])
        ans = 'YES'
        for i in xrange(1, len(s)):
            if s[i] == s[i - 1]:
                ans = 'NO'
                break
        print(ans)


```
Original Assessment: Correctness: **False**

Explanation: The program does not handle the case where the shuffling results in a non-unique assignment of guests to rooms correctly. Specifically, the program uses a range of `2 * n` to generate the list of new room assignments, which may not be sufficient to ensure that all possible room assignments are checked for uniqueness. This can lead to false positives, where the program outputs "YES" even though there might be duplicate assignments.

A more robust approach would be to consider a larger range or a different method to verify the uniqueness of the new room assignments. For example, the program could use a set to track the new room numbers and check for duplicates directly.

Here is a counterexample to demonstrate the issue:

Input:
```
1
3
3 2 1
```

Expected Output:
```
NO
```

Actual Output from the given program:
```
YES
```

In this case, the guests in rooms 0, 1, and 2 are moved to rooms 3, 3, and 2 respectively. This results in two guests being assigned to room 3, but the program incorrectly outputs "YES" because it does not properly check for duplicates within the range of `2 * n`.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
import sys

#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 10^4), representing the number of test cases. Each test case consists of an integer n (1 ≤ n ≤ 2⋅10^5) and an array a of n integers (a_0, a_1, …, a_{n-1}) where each a_i satisfies -10^9 ≤ a_i ≤ 10^9. The sum of n over all test cases does not exceed 2⋅10^5.
def func():
    input = sys.stdin.readline
    for _ in xrange(int(input())):
        n = int(input())
        
        seq = [int(x) for x in input().split()]
        
        s = sorted([(i + seq[i % n]) for i in xrange(2 * n)])
        
        ans = 'YES'
        
        for i in xrange(1, len(s)):
            if s[i] == s[i - 1]:
                ans = 'NO'
                break
        
        print(ans)
        
    #State of the program after the  for loop has been executed: `t` is a positive integer (1 ≤ t ≤ 10^4), `input` is assigned to `sys.stdin.readline`, for each test case, `n` is an integer read from the input and must be at least 1, `seq` is a list of integers from the input split by spaces, `s` is a sorted list of integers computed as `sorted([(i + seq[i % n]) for i in range(2 * n)])` and must have at least 2 * n elements, `ans` is 'YES' if no duplicates are found in `s`, otherwise `ans` is 'NO', and the value of `ans` has been printed for each test case.


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
