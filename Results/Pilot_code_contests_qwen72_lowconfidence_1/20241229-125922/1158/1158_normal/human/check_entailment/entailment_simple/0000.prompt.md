
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Monocarp has got two strings s and t having equal length. Both strings consist of lowercase Latin letters "a" and "b". 

Monocarp wants to make these two strings s and t equal to each other. He can do the following operation any number of times: choose an index pos_1 in the string s, choose an index pos_2 in the string t, and swap s_{pos_1} with t_{pos_2}.

You have to determine the minimum number of operations Monocarp has to perform to make s and t equal, and print any optimal sequence of operations — or say that it is impossible to make these strings equal.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^{5}) — the length of s and t.

The second line contains one string s consisting of n characters "a" and "b". 

The third line contains one string t consisting of n characters "a" and "b". 

Output

If it is impossible to make these strings equal, print -1.

Otherwise, in the first line print k — the minimum number of operations required to make the strings equal. In each of the next k lines print two integers — the index in the string s and the index in the string t that should be used in the corresponding swap operation. 

Examples

Input


4
abab
aabb


Output


2
3 3
3 2


Input


1
a
b


Output


-1


Input


8
babbaabb
abababaa


Output


3
2 6
1 3
7 8

Note

In the first example two operations are enough. For example, you can swap the third letter in s with the third letter in t. Then s =  "abbb", t =  "aaab". Then swap the third letter in s and the second letter in t. Then both s and t are equal to "abab".

In the second example it's impossible to make two strings equal.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_15(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_16()

#Function 1:
#State of the program right berfore the function call: None of the variables in the function signature are used, as the function does not take any parameters.
def func_1():
    return int(input())
    #The program returns an integer value input by the user.

#Function 2:
#State of the program right berfore the function call: None of the variables are used in the function signature. The function reads input from the standard input.
def func_2():
    return input()
    #The program returns the input provided by the user through the standard input.

#Function 3:
#State of the program right berfore the function call: None of the variables are passed as arguments to the function. The function reads input from the standard input, expecting a string that can be split into integers.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing integer values obtained by splitting the input string by spaces and converting each element to an integer.

#Function 4:
#State of the program right berfore the function call: None of the variables are used in the function signature.
def func_4():
    return list(func_3())
    #The program returns a list generated by the function `func_3()`. The content of this list depends entirely on the implementation of `func_3()`, which is not provided.

#Function 5:
#State of the program right berfore the function call: This function does not take any parameters and does not depend on any external variables. It sets the recursion limit and stack size, then starts a new thread to run the `main` function.
def func_5():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 6:
#State of the program right berfore the function call: item is a tuple or list where the first element (item[0]) is comparable and can be used for sorting.
def func_6(item):
    return item[0]
    #The program returns the first element of the tuple or list `item` which is comparable and can be used for sorting.

#Function 7:
#State of the program right berfore the function call: l is a list of elements where each element is a dictionary or an object with a getKey method defined to return a comparable key.
def func_7(l):
    return sorted(l, key=getKey)
    #The program returns a sorted list of elements from `l`, where each element is a dictionary or an object with a `getKey` method, sorted based on the keys returned by `getKey`. The exact order of the elements depends on the values of the keys returned by `getKey`.

#Function 8:
#State of the program right berfore the function call: n and m are non-negative integers representing the dimensions of a 2D list, and num is a value of any type that will populate the 2D list.
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list with dimensions n x m, where each element is the value of `num`.

#Function 9:
#State of the program right berfore the function call: x is an integer.
def func_9(x):
    return x and not x & x - 1
    #The program returns 0 if x is 0, True if x is a power of 2, and False otherwise

#Function 10:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 2 ⋅ 10^5.
def func_10(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of `n` as a string without the '0b' prefix, where `n` is a positive integer such that 1 ≤ n ≤ 2 ⋅ 10^5.

#Function 11:
#State of the program right berfore the function call: n is a non-negative integer.
def func_11(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is a digit from the non-negative integer `n`.

#Function 12:
#State of the program right berfore the function call: x and y are integers, p is a positive integer.
def func_12(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is `x^y % p` where `x` and `y` are the initial values of these variables, `p` is a positive integer.
    return res
    #The program returns 1

#Function 13:
#State of the program right berfore the function call: x and y are integers.
def func_13(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the GCD of the original values of `x` and `y`
    return x
    #The program returns the GCD of the original values of `x` and `y`, where `y` is 0. Since the GCD of any number and 0 is the number itself, the program returns the original value of `x`.

#Function 14:
#State of the program right berfore the function call: n is an integer greater than 1.
def func_14(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer greater than 1, and n is greater than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *n is an integer greater than 1, and n is greater than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer greater than 1 and greater than 3, and n is not divisible by 2 and not divisible by 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is an integer greater than 1 and 3, not divisible by 2, 3, 5, or 7, and `n` is greater than or equal to the square of the largest value of `i` that was checked. `i` is the smallest integer greater than or equal to the square root of `n` such that `i` is congruent to 5 modulo 6. If `n` is divisible by any prime of the form 6k ± 1 up to this `i`, the program returns False.
    return True
    #The program returns True, indicating that `n` is not divisible by any prime of the form 6k ± 1 up to the smallest integer `i` that is greater than or equal to the square root of `n` and congruent to 5 modulo 6.

#Function 15:
#State of the program right berfore the function call: No variables are passed to the function. This function is used to redirect standard input and output to files 'input.txt' and 'output.txt', respectively.
def func_15():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 16:
#State of the program right berfore the function call: n is a positive integer representing the length of the strings s and t, s and t are lists of characters containing only 'a' and 'b', and their lengths are equal to n.
def func_16():
    n = func_1()
    s = func_2()
    t = func_2()
    s = list(s)
    t = list(t)
    a = 0
    b = 0
    for i in range(n):
        if s[i] == 'a':
            a += 1
        else:
            b += 1
        
        if t[i] == 'a':
            a += 1
        else:
            b += 1
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `t` is a list of characters equal to `s`, `s` is a list of characters returned by `func_2()`, `a` is twice the number of 'a' characters in `s` (or `t`), `b` is twice the number of non-'a' characters in `s` (or `t`).
    if (a % 2 == 1 or b % 2 == 1) :
        func_17(-1)
        exit()
    #State of the program after the if block has been executed: *`n` is a positive integer, `t` is a list of characters equal to `s`, `s` is a list of characters returned by `func_2()`, `a` is twice the number of 'a' characters in `s` (or `t`), `b` is twice the number of non-'a' characters in `s` (or `t`). If `a` % 2 == 1 or `b` % 2 == 1, the program exits; no further state information is available. Otherwise, the program continues with no changes to the variables.
    a = []
    b = []
    for i in range(n):
        if s[i] != t[i]:
            if s[i] == 'a':
                a.append(i)
            else:
                b.append(i)
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `t` is a list of characters equal to `s`, `s` is a list of characters returned by `func_2()`, `a` contains the indices of characters in `s` that are 'a' and do not match the corresponding characters in `t`, `b` contains the indices of characters in `s` that are not 'a' and do not match the corresponding characters in `t`. If no characters in `s` differ from `t`, `a` and `b` remain empty lists.
    ans = []
    if (len(a) % 2 == 0) :
        nn = len(a)
    else :
        nn = len(a) - 1
        ans.append([a[-1] + 1, a[-1] + 1])
        s[a[-1]], t[a[-1]] = t[a[-1]], s[a[-1]]
    #State of the program after the if-else block has been executed: *`n` is a positive integer, `t` is a list of characters equal to `s`, `s` is a list of characters returned by `func_2()`, `a` contains the indices of characters in `s` that are 'a' and do not match the corresponding characters in `t`, `b` contains the indices of characters in `s` that are not 'a' and do not match the corresponding characters in `t`, `ans` is an empty list, and `nn` is the length of `a`. If the length of `a` is even, `nn` remains the length of `a`. If the length of `a` is odd, `t[a[-1]]` is updated to 'a', `s[a[-1]]` is updated to the character from `t[a[-1]]`, `ans` is a list containing `[a[-1] + 1, a[-1] + 1]`, and `nn` is an even number equal to `len(a) - 1`.
    for i in range(0, nn, 2):
        ans.append([a[i] + 1, a[i + 1] + 1])
        
        s[a[i]], t[a[i + 1]] = t[a[i + 1]], s[a[i]]
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `t` is updated such that for every pair of indices `(a[i], a[i+1])` where `i` ranges from `0` to `nn-2` in steps of `2`, the values `t[a[i+1]]` and `t[a[i]]` are swapped, `s` is updated such that for every pair of indices `(a[i], a[i+1])` where `i` ranges from `0` to `nn-2` in steps of `2`, the values `s[a[i]]` and `s[a[i+1]]` are swapped, `a` and `b` are unchanged, `ans` is a list of pairs `[a[i] + 1, a[i + 1] + 1]` for every `i` from `0` to `nn-2` in steps of `2`, `nn` is an even number and is the length of `a` (if the length of `a` was initially even) or `len(a) - 1` (if the length of `a` was initially odd), `i` is `nn - 2` if `nn > 0` otherwise `i` is undefined.
    b = []
    for i in range(n):
        if s[i] != t[i]:
            if s[i] == 'a':
                a.append(i)
            else:
                b.append(i)
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `i` is `n-1` if `n > 0` otherwise `i` is undefined, `t` is updated such that for every pair of indices `(a[j], a[j+1])` where `j` ranges from `0` to `nn-2` in steps of `2`, the values `t[a[j+1]]` and `t[a[j]]` are swapped, `s` is updated such that for every pair of indices `(a[j], a[j+1])` where `j` ranges from `0` to `nn-2` in steps of `2`, the values `s[a[j]]` and `s[a[j+1]]` are swapped, `a` contains the indices `i` where `s[i] == 'a'` and `s[i] != t[i]` for every `i` from `0` to `n-1`, `b` contains the indices `i` where `s[i] != 'a'` and `s[i] != t[i]` for every `i` from `0` to `n-1`, `ans` is a list of pairs `[a[j] + 1, a[j + 1] + 1]` for every `j` from `0` to `nn-2` in steps of `2`, `nn` is an even number and is the length of `a` (if the length of `a` was initially even) or `len(a) - 1` (if the length of `a` was initially odd).
    for i in range(0, len(b), 2):
        ans.append([b[i] + 1, b[i + 1] + 1])
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `i` is undefined, `t` and `s` are updated as described, `a` contains the indices as described, `b` contains the indices as described, `ans` is a list of pairs `[b[i] + 1, b[i + 1] + 1]` for every `i` from `0` to `len(b)-2` in steps of `2`, `nn` is an even number and is the length of `a` as described.
    func_17(len(a))
    for i in ans:
        func_17(*i)
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `i` is undefined, `t` and `s` are updated as described, `a` contains the indices as described, `b` contains the indices as described, `ans` is a list of pairs `[b[i] + 1, b[i + 1] + 1]` for every `i` from `0` to `len(b)-2` in steps of `2`, `nn` is an even number and is the length of `a` as described, `func_17(len(a))` has been called, `func_17(*i)` has been called for each pair `i` in `ans`.

#Function 17:
#State of the program right berfore the function call: args is a tuple of any type of values, and kwargs is a dictionary containing optional parameters 'sep', 'file', 'end', and 'flush'. 'sep' defaults to a single space, 'file' defaults to sys.stdout, 'end' defaults to a newline character, and 'flush' defaults to False.
def func_17():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a tuple of any type of values, `kwargs` is a dictionary containing optional parameters 'end' and 'flush', `sep` is the value of `'sep'` from `kwargs` or `' '` if `'sep'` was not in `kwargs`, `file` is the value of `'file'` from `kwargs` or `sys.stdout` if `'file'` was not in `kwargs`, `at_start` is `False` if `args` contains at least one element, otherwise `at_start` remains `True`. The content of `file` includes the string representations of all elements in `args`, separated by `sep`, except there is no trailing `sep` at the end.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a tuple of any type of values, `kwargs` does not contain `'end'`, `sep` is the value of `'sep'` from `kwargs` or `' '`, `file` is the value of `'file'` from `kwargs` or `sys.stdout`, `at_start` is `False` if `args` contains at least one element, otherwise `at_start` remains `True`, the content of `file` includes the string representations of all elements in `args`, separated by `sep`, followed by the value of `'end'` from `kwargs` or `'\n'`. If `'flush'` in `kwargs` is `True`, it has been popped and the write buffer of `file` has been flushed.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
