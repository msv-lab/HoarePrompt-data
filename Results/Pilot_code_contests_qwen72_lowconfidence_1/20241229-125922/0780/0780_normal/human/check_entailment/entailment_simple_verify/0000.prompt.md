
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Slime has a sequence of positive integers a_1, a_2, …, a_n.

In one operation Orac can choose an arbitrary subsegment [l … r] of this sequence and replace all values a_l, a_{l + 1}, …, a_r to the value of median of \\{a_l, a_{l + 1}, …, a_r\}.

In this problem, for the integer multiset s, the median of s is equal to the ⌊ (|s|+1)/(2)⌋-th smallest number in it. For example, the median of \{1,4,4,6,5\} is 4, and the median of \{1,7,5,8\} is 5.

Slime wants Orac to make a_1 = a_2 = … = a_n = k using these operations.

Orac thinks that it is impossible, and he does not want to waste his time, so he decided to ask you if it is possible to satisfy the Slime's requirement, he may ask you these questions several times.

Input

The first line of the input is a single integer t: the number of queries.

The first line of each query contains two integers n\ (1≤ n≤ 100 000) and k\ (1≤ k≤ 10^9), the second line contains n positive integers a_1,a_2,...,a_n\ (1≤ a_i≤ 10^9)

The total sum of n is at most 100 000.

Output

The output should contain t lines. The i-th line should be equal to 'yes' if it is possible to make all integers k in some number of operations or 'no', otherwise. You can print each letter in lowercase or uppercase.

Example

Input


5
5 3
1 5 2 6 1
1 6
6
3 2
1 2 3
4 3
3 1 2 3
10 3
1 2 3 4 5 6 7 8 9 10


Output


no
yes
yes
no
yes

Note

In the first query, Orac can't turn all elements into 3.

In the second query, a_1=6 is already satisfied.

In the third query, Orac can select the complete array and turn all elements into 2.

In the fourth query, Orac can't turn all elements into 3.

In the fifth query, Orac can select [1,6] at first and then select [2,10].
Program:
```
from __future__ import division, print_function
import sys
from bisect import bisect_left, bisect_right, insort
from math import floor, ceil, sqrt, degrees, atan, pi, log, sin, radians
from heapq import heappop, heapify, heappush
from collections import Counter, defaultdict, deque
import os, sys
from io import IOBase, BytesIO
#Function 1:
def func_1():
    fact = [1]
    for i in range(1, 5005):
        fact.append(fact[-1] * i % mod)
    ifact = [0] * 5005
    ifact[5004] = pow(fact[5004], mod - 2, mod)
    for i in range(5004, 0, -1):
        ifact[i - 1] = i * ifact[i] % mod
    return (fact, ifact)

#Function 2:
def func_2(n, p):
    return pow(n, p - 2, p)

#Function 3:
def func_3(n, r, fact, ifact):
    t = fact[n] * (ifact[r] * ifact[n - r]) % mod % mod
    return t

#Function 4:
def func_4():
    return map(int, sys.stdin.readline().strip().split())

#Function 5:
def func_5():
    return list(map(int, sys.stdin.readline().strip().split()))

#Function 6:
def func_6():
    return sys.stdin.readline().strip()

#Function 7:
def func_7(x, y):
    while y:
        (x, y) = (y, x % y)
    return x

#Function 8:
def func_8(x, y):
    return x * y // func_7(x, y)

#Function 9:
def func_9(n):
    return [n, 1, n + 1, 0][n % 4]

#Function 10:
def func_10(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a
            b -= 1
        else:
            a = a * a
            b >>= 1
    return res

#Function 11:
def func_11():
    t = int(func_6())
    while t:
        (n, k) = func_4()
        Arr = func_5() + [0, 0, 0]
        flag1 = flag2 = 0
        if n == 1:
            if Arr[0] == k:
                print('yes')
            else:
                print('no')
            t -= 1
            continue
        for i in range(n):
            if Arr[i] == k:
                flag1 = 1
            if Arr[i] >= k:
                if Arr[i + 1] >= k or Arr[i + 2] >= k:
                    flag2 = 1
        if flag1 and flag2:
            print('yes')
        else:
            print('no')
        t -= 1


```
Original Assessment: Correctness: **False**.

Explanation: The program provided has several issues that prevent it from correctly solving the problem described. Here are the key issues:

1. **Handling of Edge Cases**: The program adds extra zeros to the end of the array `Arr` using `Arr = func_5() + [0, 0, 0]`. This can lead to incorrect results because the added zeros can affect the logic used to check the conditions for making all elements equal to `k`.

2. **Incorrect Logic for Subsegments**: The program checks if there exists an element `Arr[i]` such that `Arr[i] == k` and if there are two consecutive elements `Arr[i]` and `Arr[i+1]` (or `Arr[i+2]`) that are greater than or equal to `k`. However, this logic is insufficient to determine if the entire array can be transformed to all `k` values. The median operation can change the values in a more complex way, and simply checking adjacent elements is not enough.

3. **Median Calculation**: The program does not actually calculate the median of the subsegments. It only checks if there are elements greater than or equal to `k` and if there is at least one element equal to `k`. This does not ensure that the median of any subsegment can be made equal to `k`.

4. **Single Element Case**: The program handles the single-element case correctly, but this is a trivial case and does not cover the more complex scenarios.

To illustrate a specific case where the program fails:

**Input:**
```
1
3 4
1 4 3
```

**Expected Output:**
```
yes
```

**Actual Output:**
```
no
```

In this case, the program incorrectly outputs `no` because it does not correctly handle the transformation of the array to all `4`s. The correct approach would involve more sophisticated logic to ensure that the median operation can transform the array as required.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import sys
from bisect import bisect_left, bisect_right, insort
from math import floor, ceil, sqrt, degrees, atan, pi, log, sin, radians
from heapq import heappop, heapify, heappush
from collections import Counter, defaultdict, deque
import os, sys
from io import IOBase, BytesIO

"""Template for Python Competitive Programmers prepared by pa.n.ik, kabeer seth and Mayank Chaudhary """
'value of mod'
MOD = 998244353
mod = 10 ** 9 + 7
'use resource'
'for factorial'
'uncomment next 4 lines while doing recursion based question'
'uncomment modules according to your need'
'*****************************************************************************************'
' ********************************************************************************************* '
' -------- Python 2 and 3 footer by Pajenegod and c1729 ---------'
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = 'x' in file.mode or 'w' in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b'\n') + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            (self.truncate(0), self.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode('ascii'))
            self.read = lambda : self.buffer.read().decode('ascii')
            self.readline = lambda : self.buffer.readline().decode('ascii')
(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
' main function'
if __name__ == '__main__':
    func_11()

#Function 1:
#State of the program right berfore the function call: None, as the function `func_1` does not take any parameters.
def func_1():
    fact = [1]
    for i in range(1, 5005):
        fact.append(fact[-1] * i % mod)
        
    #State of the program after the  for loop has been executed: `fact` is a list containing `[1] + [fact[-1] * i % mod for i in range(1, 5005)]`, the range is valid (1 to 5004).
    ifact = [0] * 5005
    ifact[5004] = pow(fact[5004], mod - 2, mod)
    for i in range(5004, 0, -1):
        ifact[i - 1] = i * ifact[i] % mod
        
    #State of the program after the  for loop has been executed: `fact` is a list containing `[1] + [fact[-1] * i % mod for i in range(1, 5005)]`, `ifact` is a list of 5005 elements where `ifact[5004]` is `pow(fact[5004], mod - 2, mod)`, and for each `k` from 5003 down to 0, `ifact[k]` is `k * ifact[k + 1] % mod`.
    return fact, ifact
    #The program returns two lists: `fact` which contains `[1] + [fact[-1] * i % mod for i in range(1, 5005)]`, and `ifact` which is a list of 5005 elements where `ifact[5004]` is `pow(fact[5004], mod - 2, mod)` and for each `k` from 5003 down to 0, `ifact[k]` is `k * ifact[k + 1] % mod`.

#Function 2:
#State of the program right berfore the function call: n and p are integers such that n is not divisible by p, and p is a prime number.
def func_2(n, p):
    return pow(n, p - 2, p)
    #The program returns the modular multiplicative inverse of n modulo p, which is an integer x such that (n * x) % p = 1, given that n is not divisible by p and p is a prime number.

#Function 3:
#State of the program right berfore the function call: n and r are non-negative integers such that 0 <= r <= n, and fact and ifact are lists of integers where fact[i] represents the factorial of i and ifact[i] represents the modular multiplicative inverse of the factorial of i under a certain modulus mod.
def func_3(n, r, fact, ifact):
    t = fact[n] * (ifact[r] * ifact[n - r]) % mod % mod
    return t
    #The program returns the value of `t` which is calculated as `fact[n] * (ifact[r] * ifact[n - r]) % mod % mod`, where `n` and `r` are non-negative integers such that 0 <= r <= n, `fact` and `ifact` are lists of integers where `fact[i]` represents the factorial of i and `ifact[i]` represents the modular multiplicative inverse of the factorial of i under a certain modulus `mod`.

#Function 4:
#State of the program right berfore the function call: None. This function does not take any parameters and is used to read input from stdin, converting it into a list of integers.
def func_4():
    return map(int, sys.stdin.readline().strip().split())
    #The program returns an iterator of integers converted from the input read from stdin, where each integer is separated by spaces.

#Function 5:
#State of the program right berfore the function call: None of the variables are present in the function signature, but the function reads from standard input, expecting a line of space-separated integers.
def func_5():
    return list(map(int, sys.stdin.readline().strip().split()))
    #The program returns a list of integers read from a single line of standard input, where each integer was originally separated by spaces.

#Function 6:
#State of the program right berfore the function call: None. This function does not take any parameters and reads a line from standard input, which is expected to be available.
def func_6():
    return sys.stdin.readline().strip()
    #The program returns the first line of input from standard input, stripped of leading and trailing whitespace.

#Function 7:
#State of the program right berfore the function call: x and y are non-negative integers.
def func_7(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: To determine the final output state of the loop, we need to analyze the behavior of the loop over multiple iterations and understand the conditions under which the loop terminates.
    #
    #### Initial State:
    #- `x` is a non-negative integer.
    #- `y` is a positive integer.
    #
    #### Code of the Loop:
    #```python
    #while y:
    #    x, y = y, x % y
    #```
    #
    #### Analysis:
    #1. **First Iteration:**
    #   - `x` becomes the original value of `y`.
    #   - `y` becomes the remainder of the original `x` divided by the original `y`.
    #
    #2. **Second Iteration:**
    #   - `x` remains the original value of `y`.
    #   - `y` becomes the remainder of the original `y` divided by the previous `y` (which is the remainder of the original `x` divided by the original `y`).
    #
    #3. **Subsequent Iterations:**
    #   - The loop continues to swap and compute the remainder until `y` becomes 0.
    #   - The loop terminates when `y` is 0.
    #
    #### Final Output State:
    #- The loop computes the greatest common divisor (GCD) of the original values of `x` and `y`.
    #- When the loop terminates, `y` is 0.
    #- The value of `x` will be the GCD of the original values of `x` and `y`.
    #
    #Therefore, the output state of the loop is:
    #**`x` is the GCD of the original values of `x` and `y`, `y` is 0.**
    return x
    #The program returns `x`, which is the GCD of the original values of `x` and `y`.

#Function 8:
#State of the program right berfore the function call: x and y are positive integers.
def func_8(x, y):
    return x * y // func_7(x, y)
    #The program returns the integer result of (x * y) divided by the value returned from the function `func_7(x, y)`, where `x` and `y` are positive integers.

#Function 9:
#State of the program right berfore the function call: n is a non-negative integer.
def func_9(n):
    return [n, 1, n + 1, 0][n % 4]
    #The program returns one of the following values based on the remainder when `n` (a non-negative integer) is divided by 4:

#Function 10:
#State of the program right berfore the function call: a and b are integers, where a is a positive integer (a > 0) and b is a non-negative integer (b >= 0).
def func_10(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a
            b -= 1
        else:
            a = a * a
            b >>= 1
        
    #State of the program after the loop has been executed: `b` is 0, `res` is `a` raised to the power of the original value of `b`
    return res
    #The program returns `res` which is `a` raised to the power of 0, resulting in 1

#Function 11:
#State of the program right berfore the function call: t is a positive integer representing the number of queries, n and k are positive integers where 1 ≤ n ≤ 100,000 and 1 ≤ k ≤ 10^9, Arr is a list of n positive integers where 1 ≤ Arr[i] ≤ 10^9, and the length of Arr is n + 3 due to the addition of three zeros at the end.
def func_11():
    t = int(func_6())
    while t:
        n, k = func_4()
        
        Arr = func_5() + [0, 0, 0]
        
        flag1 = flag2 = 0
        
        if n == 1:
            if Arr[0] == k:
                print('yes')
            else:
                print('no')
            t -= 1
            continue
        
        for i in range(n):
            if Arr[i] == k:
                flag1 = 1
            if Arr[i] >= k:
                if Arr[i + 1] >= k or Arr[i + 2] >= k:
                    flag2 = 1
        
        if flag1 and flag2:
            print('yes')
        else:
            print('no')
        
        t -= 1
        
    #State of the program after the loop has been executed: `t` is 0, `n` is the last value returned by `func_4()`, `k` is the last value returned by `func_4()`, `Arr` is the last list returned by `func_5()` followed by `[0, 0, 0]` with length `n + 3`, `flag1` is 1 if any element in `Arr[:n]` is equal to `k`, otherwise `flag1` is 0, `flag2` is 1 if there exists an index `i` in `range(n)` such that `Arr[i] >= k` and either `Arr[i + 1] >= k` or `Arr[i + 2] >= k`, otherwise `flag2` is 0. If both `flag1` and `flag2` are 1, the string 'yes' has been printed for each iteration where these conditions were met. Otherwise, the string 'no' has been printed for each iteration where these conditions were not met.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
