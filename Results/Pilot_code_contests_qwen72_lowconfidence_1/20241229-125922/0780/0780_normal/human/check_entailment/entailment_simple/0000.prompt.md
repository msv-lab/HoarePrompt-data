
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Slime has a sequence of positive integers a_1, a_2, …, a_n.

In one operation Orac can choose an arbitrary subsegment [l … r] of this sequence and replace all values a_l, a_{l + 1}, …, a_r to the value of median of \\{a_l, a_{l + 1}, …, a_r\}.

In this problem, for the integer multiset s, the median of s is equal to the ⌊ (|s|+1)/(2)⌋-th smallest number in it. For example, the median of \{1,4,4,6,5\} is 4, and the median of \{1,7,5,8\} is 5.

Slime wants Orac to make a_1 = a_2 = … = a_n = k using these operations.

Orac thinks that it is impossible, and he does not want to waste his time, so he decided to ask you if it is possible to satisfy the Slime's requirement, he may ask you these questions several times.

Input

The first line of the input is a single integer t: the number of queries.

The first line of each query contains two integers n\ (1≤ n≤ 100 000) and k\ (1≤ k≤ 10^9), the second line contains n positive integers a_1,a_2,...,a_n\ (1≤ a_i≤ 10^9)

The total sum of n is at most 100 000.

Output

The output should contain t lines. The i-th line should be equal to 'yes' if it is possible to make all integers k in some number of operations or 'no', otherwise. You can print each letter in lowercase or uppercase.

Example

Input


5
5 3
1 5 2 6 1
1 6
6
3 2
1 2 3
4 3
3 1 2 3
10 3
1 2 3 4 5 6 7 8 9 10


Output


no
yes
yes
no
yes

Note

In the first query, Orac can't turn all elements into 3.

In the second query, a_1=6 is already satisfied.

In the third query, Orac can select the complete array and turn all elements into 2.

In the fourth query, Orac can't turn all elements into 3.

In the fifth query, Orac can select [1,6] at first and then select [2,10].
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import sys
from bisect import bisect_left, bisect_right, insort
from math import floor, ceil, sqrt, degrees, atan, pi, log, sin, radians
from heapq import heappop, heapify, heappush
from collections import Counter, defaultdict, deque
import os, sys
from io import IOBase, BytesIO

"""Template for Python Competitive Programmers prepared by pa.n.ik, kabeer seth and Mayank Chaudhary """
'value of mod'
MOD = 998244353
mod = 10 ** 9 + 7
'use resource'
'for factorial'
'uncomment next 4 lines while doing recursion based question'
'uncomment modules according to your need'
'*****************************************************************************************'
' ********************************************************************************************* '
' -------- Python 2 and 3 footer by Pajenegod and c1729 ---------'
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = 'x' in file.mode or 'w' in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b'\n') + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            (self.truncate(0), self.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode('ascii'))
            self.read = lambda : self.buffer.read().decode('ascii')
            self.readline = lambda : self.buffer.readline().decode('ascii')
(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
' main function'
if __name__ == '__main__':
    func_11()

#Function 1:
#State of the program right berfore the function call: None, as the function `func_1` does not take any parameters.
def func_1():
    fact = [1]
    for i in range(1, 5005):
        fact.append(fact[-1] * i % mod)
        
    #State of the program after the  for loop has been executed: `fact` is a list containing `[1] + [fact[-1] * i % mod for i in range(1, 5005)]`, the range is valid (1 to 5004).
    ifact = [0] * 5005
    ifact[5004] = pow(fact[5004], mod - 2, mod)
    for i in range(5004, 0, -1):
        ifact[i - 1] = i * ifact[i] % mod
        
    #State of the program after the  for loop has been executed: `fact` is a list containing `[1] + [fact[-1] * i % mod for i in range(1, 5005)]`, `ifact` is a list of 5005 elements where `ifact[5004]` is `pow(fact[5004], mod - 2, mod)`, and for each `k` from 5003 down to 0, `ifact[k]` is `k * ifact[k + 1] % mod`.
    return fact, ifact
    #The program returns two lists: `fact` which contains `[1] + [fact[-1] * i % mod for i in range(1, 5005)]`, and `ifact` which is a list of 5005 elements where `ifact[5004]` is `pow(fact[5004], mod - 2, mod)` and for each `k` from 5003 down to 0, `ifact[k]` is `k * ifact[k + 1] % mod`.

#Function 2:
#State of the program right berfore the function call: n and p are integers such that n is not divisible by p, and p is a prime number.
def func_2(n, p):
    return pow(n, p - 2, p)
    #The program returns the modular multiplicative inverse of n modulo p, which is an integer x such that (n * x) % p = 1, given that n is not divisible by p and p is a prime number.

#Function 3:
#State of the program right berfore the function call: n and r are non-negative integers such that 0 <= r <= n, and fact and ifact are lists of integers where fact[i] represents the factorial of i and ifact[i] represents the modular multiplicative inverse of the factorial of i under a certain modulus mod.
def func_3(n, r, fact, ifact):
    t = fact[n] * (ifact[r] * ifact[n - r]) % mod % mod
    return t
    #The program returns the value of `t` which is calculated as `fact[n] * (ifact[r] * ifact[n - r]) % mod % mod`, where `n` and `r` are non-negative integers such that 0 <= r <= n, `fact` and `ifact` are lists of integers where `fact[i]` represents the factorial of i and `ifact[i]` represents the modular multiplicative inverse of the factorial of i under a certain modulus `mod`.

#Function 4:
#State of the program right berfore the function call: None. This function does not take any parameters and is used to read input from stdin, converting it into a list of integers.
def func_4():
    return map(int, sys.stdin.readline().strip().split())
    #The program returns an iterator of integers converted from the input read from stdin, where each integer is separated by spaces.

#Function 5:
#State of the program right berfore the function call: None of the variables are present in the function signature, but the function reads from standard input, expecting a line of space-separated integers.
def func_5():
    return list(map(int, sys.stdin.readline().strip().split()))
    #The program returns a list of integers read from a single line of standard input, where each integer was originally separated by spaces.

#Function 6:
#State of the program right berfore the function call: None. This function does not take any parameters and reads a line from standard input, which is expected to be available.
def func_6():
    return sys.stdin.readline().strip()
    #The program returns the first line of input from standard input, stripped of leading and trailing whitespace.

#Function 7:
#State of the program right berfore the function call: x and y are non-negative integers.
def func_7(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: To determine the final output state of the loop, we need to analyze the behavior of the loop over multiple iterations and understand the conditions under which the loop terminates.
    #
    #### Initial State:
    #- `x` is a non-negative integer.
    #- `y` is a positive integer.
    #
    #### Code of the Loop:
    #```python
    #while y:
    #    x, y = y, x % y
    #```
    #
    #### Analysis:
    #1. **First Iteration:**
    #   - `x` becomes the original value of `y`.
    #   - `y` becomes the remainder of the original `x` divided by the original `y`.
    #
    #2. **Second Iteration:**
    #   - `x` remains the original value of `y`.
    #   - `y` becomes the remainder of the original `y` divided by the previous `y` (which is the remainder of the original `x` divided by the original `y`).
    #
    #3. **Subsequent Iterations:**
    #   - The loop continues to swap and compute the remainder until `y` becomes 0.
    #   - The loop terminates when `y` is 0.
    #
    #### Final Output State:
    #- The loop computes the greatest common divisor (GCD) of the original values of `x` and `y`.
    #- When the loop terminates, `y` is 0.
    #- The value of `x` will be the GCD of the original values of `x` and `y`.
    #
    #Therefore, the output state of the loop is:
    #**`x` is the GCD of the original values of `x` and `y`, `y` is 0.**
    return x
    #The program returns `x`, which is the GCD of the original values of `x` and `y`.

#Function 8:
#State of the program right berfore the function call: x and y are positive integers.
def func_8(x, y):
    return x * y // func_7(x, y)
    #The program returns the integer result of (x * y) divided by the value returned from the function `func_7(x, y)`, where `x` and `y` are positive integers.

#Function 9:
#State of the program right berfore the function call: n is a non-negative integer.
def func_9(n):
    return [n, 1, n + 1, 0][n % 4]
    #The program returns one of the following values based on the remainder when `n` (a non-negative integer) is divided by 4:

#Function 10:
#State of the program right berfore the function call: a and b are integers, where a is a positive integer (a > 0) and b is a non-negative integer (b >= 0).
def func_10(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a
            b -= 1
        else:
            a = a * a
            b >>= 1
        
    #State of the program after the loop has been executed: `b` is 0, `res` is `a` raised to the power of the original value of `b`
    return res
    #The program returns `res` which is `a` raised to the power of 0, resulting in 1

#Function 11:
#State of the program right berfore the function call: t is a positive integer representing the number of queries, n and k are positive integers where 1 ≤ n ≤ 100,000 and 1 ≤ k ≤ 10^9, Arr is a list of n positive integers where 1 ≤ Arr[i] ≤ 10^9, and the length of Arr is n + 3 due to the addition of three zeros at the end.
def func_11():
    t = int(func_6())
    while t:
        n, k = func_4()
        
        Arr = func_5() + [0, 0, 0]
        
        flag1 = flag2 = 0
        
        if n == 1:
            if Arr[0] == k:
                print('yes')
            else:
                print('no')
            t -= 1
            continue
        
        for i in range(n):
            if Arr[i] == k:
                flag1 = 1
            if Arr[i] >= k:
                if Arr[i + 1] >= k or Arr[i + 2] >= k:
                    flag2 = 1
        
        if flag1 and flag2:
            print('yes')
        else:
            print('no')
        
        t -= 1
        
    #State of the program after the loop has been executed: `t` is 0, `n` is the last value returned by `func_4()`, `k` is the last value returned by `func_4()`, `Arr` is the last list returned by `func_5()` followed by `[0, 0, 0]` with length `n + 3`, `flag1` is 1 if any element in `Arr[:n]` is equal to `k`, otherwise `flag1` is 0, `flag2` is 1 if there exists an index `i` in `range(n)` such that `Arr[i] >= k` and either `Arr[i + 1] >= k` or `Arr[i + 2] >= k`, otherwise `flag2` is 0. If both `flag1` and `flag2` are 1, the string 'yes' has been printed for each iteration where these conditions were met. Otherwise, the string 'no' has been printed for each iteration where these conditions were not met.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
