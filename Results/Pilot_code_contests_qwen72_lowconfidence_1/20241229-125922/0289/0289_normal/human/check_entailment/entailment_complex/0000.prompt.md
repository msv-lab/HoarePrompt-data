
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: We've got no test cases. A big olympiad is coming up. But the problemsetters' number one priority should be adding another problem to the round.

The diameter of a multiset of points on the line is the largest distance between two points from this set. For example, the diameter of the multiset {1, 3, 2, 1} is 2.

Diameter of multiset consisting of one point is 0.

You are given n points on the line. What is the minimum number of points you have to remove, so that the diameter of the multiset of the remaining points will not exceed d?

Input

The first line contains two integers n and d (1 ≤ n ≤ 100, 0 ≤ d ≤ 100) — the amount of points and the maximum allowed diameter respectively.

The second line contains n space separated integers (1 ≤ xi ≤ 100) — the coordinates of the points.

Output

Output a single integer — the minimum number of points you have to remove.

Examples

Input

3 1
2 1 4


Output

1


Input

3 0
7 7 7


Output

0


Input

6 3
1 3 4 6 9 10


Output

3

Note

In the first test case the optimal strategy is to remove the point with coordinate 4. The remaining points will have coordinates 1 and 2, so the diameter will be equal to 2 - 1 = 1.

In the second test case the diameter is equal to 0, so its is unnecessary to remove any points. 

In the third test case the optimal strategy is to remove points with coordinates 1, 9 and 10. The remaining points will have coordinates 3, 4 and 6, so the diameter will be equal to 6 - 3 = 3.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n is an integer where 1 ≤ n ≤ 100, d is an integer where 0 ≤ d ≤ 100, and xi is a list of n integers where 1 ≤ xi ≤ 100.
def func():
    R = raw_input()
    Q = R.split()
    g = int(Q[1])
    W = raw_input()
    V = W.split()
    l = len(V)
    B = []
    for i in range(l):
        B.append(int(V[i]))
        
    #State of the program after the  for loop has been executed: `n` is an integer where 1 ≤ n ≤ 100, `d` is an integer where 0 ≤ d ≤ 100, `xi` is a list of n integers where 1 ≤ xi ≤ 100, `R` is a string input by the user, `Q` is a list of substrings from `R` split by whitespace, `g` is the integer value of `Q[1]`, `W` is a string input by the user, `V` is a list of substrings from `W` split by whitespace, `l` is the number of substrings in `V`, `B` is a list containing the integer values of all elements in `V` if `l` > 0, otherwise `B` is an empty list
    A = sorted(B)
    count = l
    k = 0
    for i in range(l):
        while A[k] - A[i] <= g:
            k += 1
            if k == l:
                break
        
        if l - k + i < count:
            count = l - k + i
            rm_elem_lower = A[:i]
            rm_elem_upper = A[k:]
            rm_elem_total = rm_elem_lower + rm_elem_upper
        
        if k == l:
            break
        
    #State of the program after the  for loop has been executed: `n` is an integer where 1 ≤ n ≤ 100, `d` is an integer where 0 ≤ d ≤ 100, `xi` is a list of n integers where 1 ≤ xi ≤ 100, `R` is a string input by the user, `Q` is a list of substrings from `R` split by whitespace, `g` is the integer value of `Q[1]`, `W` is a string input by the user, `V` is a list of substrings from `W` split by whitespace, `l` is the number of substrings in `V` and must be greater than 0, `B` is a list containing the integer values of all elements in `V`, `A` is a list of elements from `B` in ascending order, `count` is the minimum number of elements that need to be removed from `A` to ensure that the difference between any two remaining elements is greater than `g`, `k` is the smallest index such that `A[k] - A[i] > g` or `k` is equal to `l` if no such index exists for the last iteration, `i` is the final index of the outer loop (which is `l-1` if the loop completes), `rm_elem_lower` is a list of elements from `A` that are less than the smallest element in the remaining valid subarray, `rm_elem_upper` is a list of elements from `A` that are greater than the largest element in the remaining valid subarray, `rm_elem_total` is the concatenation of `rm_elem_lower` and `rm_elem_upper`. If `l == 0`, then `count` is 0, `k` is 0, `i` is 0, `rm_elem_lower` is an empty list, `rm_elem_upper` is an empty list, and `rm_elem_total` is an empty list.
    print(count)
#Overall this is what the function does:The function reads two lines of input from the user. The first line is expected to contain two integers separated by whitespace, where the second integer (`g`) is used as a threshold. The second line contains a space-separated list of integers which are converted to a list of integers (`B`). It then sorts the list (`A`) and determines the minimum number of elements that need to be removed from `A` to ensure that the difference between any two remaining elements is greater than `g`. The function prints this minimum number of elements to be removed. If the list `B` is empty, the function prints `0`. The function does not accept any parameters and does not return any values. After execution, the program state includes the sorted list `A`, the minimum number of elements to remove (`count`), and lists of elements that are below and above the remaining valid subarray (`rm_elem_lower` and `rm_elem_upper`).
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
