
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: The Cybermen and the Daleks have long been the Doctor's main enemies. Everyone knows that both these species enjoy destroying everything they encounter. However, a little-known fact about them is that they both also love taking Turing tests!

Heidi designed a series of increasingly difficult tasks for them to spend their time on, which would allow the Doctor enough time to save innocent lives!

The funny part is that these tasks would be very easy for a human to solve.

The first task is as follows. There are some points on the plane. All but one of them are on the boundary of an axis-aligned square (its sides are parallel to the axes). Identify that point.

Input

The first line contains an integer n (2 ≤ n ≤ 10).

Each of the following 4n + 1 lines contains two integers x_i, y_i (0 ≤ x_i, y_i ≤ 50), describing the coordinates of the next point.

It is guaranteed that there are at least n points on each side of the square and all 4n + 1 points are distinct.

Output

Print two integers — the coordinates of the point that is not on the boundary of the square.

Examples

Input


2
0 0
0 1
0 2
1 0
1 1
1 2
2 0
2 1
2 2


Output


1 1


Input


2
0 0
0 1
0 2
0 3
1 0
1 2
2 0
2 1
2 2


Output


0 3

Note

In both examples, the square has four sides x=0, x=2, y=0, y=2.
Program:
```
from sys import stdin
from collections import *

def func():
    rints = lambda : [int(x) for x in stdin.readline().split()]
    rints_2d = lambda n: [rints() for _ in range(n)]
    get_col = lambda arr, i: [row[i] for row in arr]
    n = int(input()) * 4 + 1
    (a, memx, memy) = (rints_2d(n), [float('inf'), -1], [float('inf'), -1])
    (xs, ys) = (Counter(get_col(a, 0)), Counter(get_col(a, 1)))
    for (x, y) in a:
        if xs[x] >= n - 1 >> 2:
            memx = [min(memx[0], x), max(memx[1], x)]
        if ys[y] >= n - 1 >> 2:
            memy = [min(memy[0], y), max(memy[1], y)]
    for (x, y) in a:
        if not (memx[0] < x < memx[1] and y in memy or (x in memx and memy[0] <= y <= memy[1])):
            print('%d %d' % (x, y))
            exit()


```
Original Assessment: Correctness: **True**

Explanation:
The provided program appears to correctly identify the point that is not on the boundary of the axis-aligned square. Here's a step-by-step breakdown of why the program works correctly:

1. **Reading Input**: The program reads the number of points `n` and then reads the coordinates of the points into a list `a`.

2. **Counting X and Y Coordinates**: It uses `Counter` from the `collections` module to count the occurrences of each x-coordinate and y-coordinate.

3. **Determining the Square Boundaries**:
   - For each point `(x, y)`, it checks if the count of `x` is at least `n - 1 >> 2`. This is equivalent to checking if the count of `x` is at least `n // 4`.
   - It updates the minimum and maximum x-coordinates (`memx`) and y-coordinates (`memy`) that appear at least `n // 4` times.

4. **Identifying the Outlier Point**:
   - It iterates through the points again and checks if the point `(x, y)` is not on the boundary of the square defined by `memx` and `memy`.
   - A point is considered on the boundary if it satisfies either:
     - `memx[0] < x < memx[1]` and `y in memy`
     - `x in memx` and `memy[0] <= y <= memy[1]`
   - If a point does not satisfy these conditions, it prints the coordinates of the point and exits.

The logic ensures that the program correctly identifies the point that is not on the boundary of the square for all valid inputs. Given the constraints and the problem description, the program handles all edge cases and potential inputs correctly. Therefore, the program is correct.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: The function processes input consisting of an integer `n` (2 ≤ n ≤ 10) followed by 4n + 1 pairs of integer coordinates (0 ≤ x_i, y_i ≤ 50). It identifies the smallest axis-aligned square that contains at least `n` points on each of its four sides. The function then checks each point to ensure it lies within this square. If a point does not satisfy the condition, the function prints the coordinates of that point and exits immediately. If all points satisfy the condition, the function completes without printing any values. The function assumes that the input is valid and that there are at least `n` points on each side of the square. Edge cases such as invalid input or fewer than `n` points on any side of the square are not handled by the function.

Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
