
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: This is the easy version of the problem. The only difference is that in this version q = 1. You can make hacks only if both versions of the problem are solved.

There is a process that takes place on arrays a and b of length n and length n-1 respectively. 

The process is an infinite sequence of operations. Each operation is as follows: 

  * First, choose a random integer i (1 ≤ i ≤ n-1). 
  * Then, simultaneously set a_i = min\left(a_i, \frac{a_i+a_{i+1}-b_i}{2}\right) and a_{i+1} = max\left(a_{i+1}, \frac{a_i+a_{i+1}+b_i}{2}\right) without any rounding (so values may become non-integer). 

See notes for an example of an operation.

It can be proven that array a converges, i. e. for each i there exists a limit a_i converges to. Let function F(a, b) return the value a_1 converges to after a process on a and b.

You are given array b, but not array a. However, you are given a third array c. Array a is good if it contains only integers and satisfies 0 ≤ a_i ≤ c_i for 1 ≤ i ≤ n.

Your task is to count the number of good arrays a where F(a, b) ≥ x for q values of x. Since the number of arrays can be very large, print it modulo 10^9+7.

Input

The first line contains a single integer n (2 ≤ n ≤ 100).

The second line contains n integers c_1, c_2 …, c_n (0 ≤ c_i ≤ 100).

The third line contains n-1 integers b_1, b_2, …, b_{n-1} (0 ≤ b_i ≤ 100).

The fourth line contains a single integer q (q=1).

The fifth line contains q space separated integers x_1, x_2, …, x_q (-10^5 ≤ x_i ≤ 10^5).

Output

Output q integers, where the i-th integer is the answer to the i-th query, i. e. the number of good arrays a where F(a, b) ≥ x_i modulo 10^9+7.

Example

Input


3
2 3 4
2 1
1
-1


Output


56

Note

The following explanation assumes b = [2, 1] and c=[2, 3, 4] (as in the sample).

Examples of arrays a that are not good: 

  * a = [3, 2, 3] is not good because a_1 > c_1; 
  * a = [0, -1, 3] is not good because a_2 < 0. 



One possible good array a is [0, 2, 4]. We can show that no operation has any effect on this array, so F(a, b) = a_1 = 0.

Another possible good array a is [0, 1, 4]. In a single operation with i = 1, we set a_1 = min((0+1-2)/(2), 0) and a_2 = max((0+1+2)/(2), 1). So, after a single operation with i = 1, a becomes equal to [-1/2, 3/2, 4]. We can show that no operation has any effect on this array, so F(a, b) = -1/2.
Program:
```
from __future__ import division,print_function
from heapq import*
import sys

def func():
    le = sys.__stdin__.read().split('\n')[::-1]
    mo = 10 ** 9 + 7
    if 1:
        n = int(le.pop())
        c = list(map(int, le.pop().split()))
        b = list(map(int, le.pop().split()))
        le.pop()
        x = int(le.pop())
        prefb = [b[0]]
        for k in b[1:]:
            prefb.append(k + prefb[-1])
        prefb.append(0)
        prefbt = [0]
        for k in range(1, n - 1):
            prefbt.append(k * b[k] + prefbt[-1])
        prefbt.append(0)
    sc = sum(c)
    d = [[0] * (sc + 1) for k in range(n + 1)]
    ds = [[0] * (sc + 2) for k in range(n + 1)]
    ds[-1] = list(range(sc + 2))
    d[-1] = [1] * (sc + 1)
    for index in range(n - 1, -1, -1):
        minpref = 0
        while (minpref - index * prefb[index - 1] + prefbt[index - 1]) / (index + 1) < x:
            minpref += 1
        for pref in range(sc + 1):
            mi = min(pref + c[index] + 1, sc + 1)
            ma = max(minpref, pref)
            d[index][pref] = 0 if mi < ma else ds[index + 1][mi] - ds[index + 1][ma]
        for pref in range(1, sc + 2):
            ds[index][pref] = (ds[index][pref - 1] + d[index][pref - 1]) % mo
    print(d[0][0] % mo)


```
Original Assessment: Correctness: **True**

Explanation:
The provided program appears to correctly implement the logic described in the problem statement. Here's a breakdown of the key aspects:

1. **Input Reading and Initialization**: The program reads the input using `sys.stdin.read().split('\n')[::-1]` to handle the input lines in reverse order, which is a valid approach for reading inputs in Python. It initializes necessary variables and data structures, including the modulo constant `mo`.

2. **Prefix Sum Arrays (`prefb` and `prefbt`)**: These arrays are used to store cumulative sums of elements from the array `b`. This is a common technique to optimize certain types of queries and calculations involving subarrays.

3. **Dynamic Programming (DP) Tables (`d` and `ds`)**: The DP table `d` is used to store the number of valid arrays `a` that satisfy the conditions up to a certain prefix sum. The auxiliary table `ds` is used to maintain cumulative sums of the DP table, which helps in efficiently calculating ranges.

4. **Main Logic**:
   - The program iterates over the indices of the array `a` in reverse order.
   - For each index, it calculates the minimum prefix sum required to ensure that the condition \( F(a, b) \geq x \) is met.
   - It then updates the DP table `d` based on the current prefix sum and the constraints defined by the problem.
   - The auxiliary table `ds` is updated to maintain cumulative sums, which are used to efficiently compute the range sums needed for the DP table.

5. **Output**: The final result is printed as the value of `d[0][0] % mo`, which represents the number of valid arrays `a` that satisfy the condition \( F(a, b) \geq x \) modulo \( 10^9 + 7 \).

The program appears to handle all edge cases and constraints mentioned in the problem description. It correctly implements the dynamic programming approach to count the number of valid arrays `a` and ensures that the output is computed modulo \( 10^9 + 7 \). Therefore, the program is correct for all potential cases.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: The function reads input from standard input, processes it, and computes a specific value based on the inputs. It accepts no explicit parameters but expects the input to be provided in a specific format. The input consists of several lines, where the first line contains an integer `n` (2 ≤ n ≤ 100), the second line contains a list of `n` integers `c` (0 ≤ c_i ≤ 100), the third line contains a list of `n-1` integers `b` (0 ≤ b_i ≤ 100), and the fourth line contains an integer `x` (-10^5 ≤ x_i ≤ 10^5). The function computes and prints a single integer, which is the result of a dynamic programming algorithm that calculates the number of valid configurations of `c` and `b` that satisfy certain conditions, modulo \(10^9 + 7\). The final state of the program includes the following: `n` is an integer such that 2 ≤ n ≤ 100, `c` is a list of `n` integers where 0 ≤ c_i ≤ 100, `b` is a list of `n-1` integers where 0 ≤ b_i ≤ 100, `x` is an integer, `prefb` is a list of prefix sums of `b` with an additional `0` appended, `prefbt` is a list of weighted prefix sums of `b` with an additional `0` appended, `sc` is the sum of all elements in `c`, `d` is a 2D list used for dynamic programming, and `ds` is a 2D list used for cumulative sums. The function prints the result of `d[0][0] % (10^9 + 7)`. Potential edge cases include when `n` is 2 or less, which results in `prefbt` being `[0, 0]`.

Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
