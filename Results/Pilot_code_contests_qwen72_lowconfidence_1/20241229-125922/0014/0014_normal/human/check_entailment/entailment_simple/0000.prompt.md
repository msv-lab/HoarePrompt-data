
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: This is the easy version of the problem. The only difference is that in this version q = 1. You can make hacks only if both versions of the problem are solved.

There is a process that takes place on arrays a and b of length n and length n-1 respectively. 

The process is an infinite sequence of operations. Each operation is as follows: 

  * First, choose a random integer i (1 ≤ i ≤ n-1). 
  * Then, simultaneously set a_i = min\left(a_i, \frac{a_i+a_{i+1}-b_i}{2}\right) and a_{i+1} = max\left(a_{i+1}, \frac{a_i+a_{i+1}+b_i}{2}\right) without any rounding (so values may become non-integer). 

See notes for an example of an operation.

It can be proven that array a converges, i. e. for each i there exists a limit a_i converges to. Let function F(a, b) return the value a_1 converges to after a process on a and b.

You are given array b, but not array a. However, you are given a third array c. Array a is good if it contains only integers and satisfies 0 ≤ a_i ≤ c_i for 1 ≤ i ≤ n.

Your task is to count the number of good arrays a where F(a, b) ≥ x for q values of x. Since the number of arrays can be very large, print it modulo 10^9+7.

Input

The first line contains a single integer n (2 ≤ n ≤ 100).

The second line contains n integers c_1, c_2 …, c_n (0 ≤ c_i ≤ 100).

The third line contains n-1 integers b_1, b_2, …, b_{n-1} (0 ≤ b_i ≤ 100).

The fourth line contains a single integer q (q=1).

The fifth line contains q space separated integers x_1, x_2, …, x_q (-10^5 ≤ x_i ≤ 10^5).

Output

Output q integers, where the i-th integer is the answer to the i-th query, i. e. the number of good arrays a where F(a, b) ≥ x_i modulo 10^9+7.

Example

Input


3
2 3 4
2 1
1
-1


Output


56

Note

The following explanation assumes b = [2, 1] and c=[2, 3, 4] (as in the sample).

Examples of arrays a that are not good: 

  * a = [3, 2, 3] is not good because a_1 > c_1; 
  * a = [0, -1, 3] is not good because a_2 < 0. 



One possible good array a is [0, 2, 4]. We can show that no operation has any effect on this array, so F(a, b) = a_1 = 0.

Another possible good array a is [0, 1, 4]. In a single operation with i = 1, we set a_1 = min((0+1-2)/(2), 0) and a_2 = max((0+1+2)/(2), 1). So, after a single operation with i = 1, a becomes equal to [-1/2, 3/2, 4]. We can show that no operation has any effect on this array, so F(a, b) = -1/2.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division,print_function
from heapq import*
import sys

#State of the program right berfore the function call: n is an integer such that 2 ≤ n ≤ 100; c is a list of n integers where 0 ≤ c_i ≤ 100; b is a list of n-1 integers where 0 ≤ b_i ≤ 100; q is an integer equal to 1; x is a list of q integers where -10^5 ≤ x_i ≤ 10^5.
def func():
    le = sys.__stdin__.read().split('\n')[::-1]
    mo = 10 ** 9 + 7
    if (1) :
        n = int(le.pop())
        c = list(map(int, le.pop().split()))
        b = list(map(int, le.pop().split()))
        le.pop()
        x = int(le.pop())
        prefb = [b[0]]
        for k in b[1:]:
            prefb.append(k + prefb[-1])
            
        #State of the program after the  for loop has been executed: `n` is the integer value of the last element of `le` before the pop, `c` is a list of `n` integers where \(0 \leq c_i \leq 100\), `b` is a list of integers obtained from the last element of `le` before the pop, `q` is 1, `x` is the integer value of the last element of `le` before the pop, `le` is a list of reversed input lines minus the last four elements, `mo` is 1000000007, `prefb` is a list of prefix sums of `b` where each element is the cumulative sum of the elements of `b` up to that index, and `b` must have at least one element.
        prefb.append(0)
        prefbt = [0]
        for k in range(1, n - 1):
            prefbt.append(k * b[k] + prefbt[-1])
            
        #State of the program after the  for loop has been executed: `n` is an integer value of the last element of `le` before the pop, `c` is a list of `n` integers where \(0 \leq c_i \leq 100\), `b` is a list of integers obtained from the last element of `le` before the pop, `q` is 1, `x` is the integer value of the last element of `le` before the pop, `le` is a list of reversed input lines minus the last four elements, `mo` is 1000000007, `prefb` is a list of prefix sums of `b` where each element is the cumulative sum of the elements of `b` up to that index, followed by an additional element `0`, `b` must have at least one element, `prefbt` is a list where `prefbt[i] = i * b[i] + prefbt[i-1]` for \(1 \leq i < n - 1\) and `prefbt[0] = 0`. If `n` is less than or equal to 2, `prefbt` remains `[0]`.
        prefbt.append(0)
    #State of the program after the if block has been executed: *`n` is an integer such that 2 ≤ n ≤ 100, `c` is a list of `n` integers where 0 ≤ c_i ≤ 100, `b` is a list of integers obtained from the last element of `le` before the pop, `q` is 1, `x` is the integer value of the last element of `le` before the pop, `le` is a list of reversed input lines minus the last four elements, `mo` is 1000000007, `prefb` is a list of prefix sums of `b` where each element is the cumulative sum of the elements of `b` up to that index, followed by an additional element `0`, `b` must have at least one element, `prefbt` is a list where `prefbt[i] = i * b[i] + prefbt[i-1]` for \(1 \leq i < n - 1\) and `prefbt[0] = 0`, `prefbt` now has an additional `0` appended to its end. If `n` is less than or equal to 2, `prefbt` is `[0, 0]`.
    sc = sum(c)
    d = [([0] * (sc + 1)) for k in range(n + 1)]
    ds = [([0] * (sc + 2)) for k in range(n + 1)]
    ds[-1] = list(range(sc + 2))
    d[-1] = [1] * (sc + 1)
    for index in range(n - 1, -1, -1):
        minpref = 0
        
        while (minpref - index * prefb[index - 1] + prefbt[index - 1]) / (index + 1
            ) < x:
            minpref += 1
        
        for pref in range(sc + 1):
            mi = min(pref + c[index] + 1, sc + 1)
            ma = max(minpref, pref)
            d[index][pref] = 0 if mi < ma else ds[index + 1][mi] - ds[index + 1][ma]
        
        for pref in range(1, sc + 2):
            ds[index][pref] = (ds[index][pref - 1] + d[index][pref - 1]) % mo
        
    #State of the program after the  for loop has been executed: `n` is an integer such that \(2 \leq n \leq 100\), `c` is a list of `n` integers where \(0 \leq c_i \leq 100\), `b` is a list of integers obtained from the last element of `le` before the pop, `q` is 1, `x` is the integer value of the last element of `le` before the pop, `le` is a list of reversed input lines minus the last four elements, `mo` is \(1000000007\), `prefb` is a list of prefix sums of `b` where each element is the cumulative sum of the elements of `b` up to that index, followed by an additional element `0`, `b` must have at least one element, `prefbt` is a list where \(\text{prefbt}[i] = i \cdot b[i] + \text{prefbt}[i-1]\) for \(1 \leq i < n - 1\) and \(\text{prefbt}[0] = 0\), with an additional `0` appended to its end. If \(n \leq 2\), \(\text{prefbt}\) is \([0, 0]\), `sc` is the sum of all elements in the list `c`, `d` is a 2D list of size \((n + 1) \times (sc + 1)\) initialized to 0, with the last row being \([1] \times (sc + 1)\), `ds` is a 2D list of size \((n + 1) \times (sc + 2)\) initialized to 0, with the last row being \(\text{list(range(sc + 2))\). After the loop, `d[0][pref]` for each `pref` from 0 to `sc` is updated based on the final values of `minpref` and `c[0]`, and `ds[0][pref]` for each `pref` from 1 to `sc + 1` is the cumulative sum of `d[0][i]` for \(i\) from 0 to `pref - 1`, taken modulo `mo`.
    print(d[0][0] % mo)

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
