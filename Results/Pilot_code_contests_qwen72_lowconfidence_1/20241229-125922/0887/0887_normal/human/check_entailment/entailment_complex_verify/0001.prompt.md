
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Consider the following game for two players. There is one white token and some number of black tokens. Each token is placed on a plane in a point with integer coordinates x and y.

The players take turn making moves, white starts. On each turn, a player moves all tokens of their color by 1 to up, down, left or right. Black player can choose directions for each token independently.

After a turn of the white player the white token can not be in a point where a black token is located. There are no other constraints on locations of the tokens: positions of black tokens can coincide, after a turn of the black player and initially the white token can be in the same point with some black point. If at some moment the white player can't make a move, he loses. If the white player makes 10100500 moves, he wins.

You are to solve the following problem. You are given initial positions of all black tokens. It is guaranteed that initially all these positions are distinct. In how many places can the white token be located initially so that if both players play optimally, the black player wins?

Input

The first line contains a single integer n (1 ≤ n ≤ 105) — the number of black points.

The (i + 1)-th line contains two integers xi, yi ( - 105 ≤ xi, yi, ≤ 105) — the coordinates of the point where the i-th black token is initially located.

It is guaranteed that initial positions of black tokens are distinct.

Output

Print the number of points where the white token can be located initially, such that if both players play optimally, the black player wins.

Examples

Input

4
-2 -1
0 1
0 -3
2 -1


Output

4


Input

4
-2 0
-1 1
0 -2
1 -1


Output

2


Input

16
2 1
1 2
-1 1
0 1
0 0
1 1
2 -1
2 0
1 0
-1 -1
1 -1
2 2
0 -1
-1 0
0 2
-1 2


Output

4

Note

In the first and second examples initial positions of black tokens are shown with black points, possible positions of the white token (such that the black player wins) are shown with white points.

The first example: <image>

The second example: <image>

In the third example the white tokens should be located in the inner square 2 × 2, to make the black player win. <image>
Program:
```
from sys import*
from itertools import*
#Function 1:
def func_1(a):
    inf = 1001001001
    C = 400010
    lmn = [inf] * 400010
    lmx = [-inf] * 400010
    for (x, y) in a:
        x = (x - 1) / 2 + 100005
        if lmn[x] > y:
            lmn[x] = y
        if lmx[x] < y:
            lmx[x] = y
    rmn = lmn[:]
    rmx = lmx[:]
    for i in xrange(200009):
        if lmn[i + 1] > lmn[i]:
            lmn[i + 1] = lmn[i]
    for i in xrange(200009):
        if lmx[i + 1] < lmx[i]:
            lmx[i + 1] = lmx[i]
    for i in xrange(200009, 0, -1):
        if rmn[i - 1] > rmn[i]:
            rmn[i - 1] = rmn[i]
    for i in xrange(200009, 0, -1):
        if rmx[i - 1] < rmx[i]:
            rmx[i - 1] = rmx[i]
    for i in xrange(200010):
        if lmn[i] < rmn[i]:
            lmn[i] = rmn[i]
    for i in xrange(200010):
        if lmx[i] > rmx[i]:
            lmx[i] = rmx[i]
    ans = 0
    for i in xrange(200009):
        if lmn[i] < lmn[i + 1]:
            lmn[i] = lmn[i + 1]
    for i in xrange(200009):
        if lmx[i] > lmx[i + 1]:
            lmx[i] = lmx[i + 1]
    for i in xrange(200009):
        if lmn[i] < lmx[i]:
            ans += (lmx[i] - lmn[i]) / 2
    return ans

#Function 2:
def func_2():
    n = int(stdin.readline())
    dat = map(int, stdin.read().split(), repeat(10, 2 * n))
    s = [[], []]
    for i in xrange(n):
        (x, y) = dat[i * 2:i * 2 + 2]
        s[x + y & 1].append((-x + y, x + y))
    print(func_1(s[0]) + func_1(s[1]))


```
Original Assessment: Correctness: **True**

Explanation: The provided program appears to handle all aspects of the problem description effectively. Here’s a breakdown of why I believe it is correct:

1. **Input Handling**: The program reads the input as specified in the problem description. It processes the number of black tokens and their coordinates correctly.

2. **Data Preparation**: The program splits the black tokens into two lists based on the parity of the sum of their coordinates (x + y). This is done to handle the movement of the tokens more efficiently, as the parity of the sum of coordinates remains constant after each move.

3. **Coordinate Transformation**: The program transforms the coordinates to a range that fits within the array indices used for storing the minimum and maximum y-values for each x-value. This transformation ensures that the program can handle the given coordinate range efficiently.

4. **Dynamic Programming Arrays**: The program uses arrays `lmn`, `lmx`, `rmn`, and `rmx` to keep track of the minimum and maximum y-values for each x-value, both from left to right and right to left. These arrays are updated to ensure that the values are propagated correctly across the entire range.

5. **Combining Results**: The program combines the results from the two lists (one for each parity) to calculate the total number of initial positions for the white token where the black player can win.

6. **Edge Cases**: The program handles edge cases such as when there are no black tokens or when all black tokens are in the same position. It also handles the large input size and coordinate ranges specified in the problem description.

Given the complexity of the problem and the thorough handling of various cases, the program seems to meet the requirements of the problem description. I could not find any specific input or edge case where the program would fail to produce the correct output. Therefore, the program is correct.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import*
from itertools import*

func_2()

#Function 1:
#State of the program right berfore the function call: a is a list of tuples, where each tuple (x, y) consists of integers representing the coordinates of a black token, such that -105 ≤ x, y ≤ 105 and all tuples are distinct.
def func_1(a):
    inf = 1001001001
    C = 400010
    lmn = [inf] * 400010
    lmx = [-inf] * 400010
    for (x, y) in a:
        x = (x - 1) / 2 + 100005
        
        if lmn[x] > y:
            lmn[x] = y
        
        if lmx[x] < y:
            lmx[x] = y
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples, where each tuple (x, y) consists of integers representing the coordinates of a black token, such that -105 ≤ x, y ≤ 105 and all tuples are distinct; `inf` is 1001001001; `C` is 400010; `lmn` is a list of 400010 elements, where each element at index `x` (where `x` is transformed from the original x-coordinate using the formula `(x - 1) / 2 + 100005`) is updated to the minimum `y` value among all tuples in `a` that map to the same transformed `x`; `lmx` is a list of 400010 elements, where each element at index `x` (where `x` is transformed from the original x-coordinate using the formula `(x - 1) / 2 + 100005`) is updated to the maximum `y` value among all tuples in `a` that map to the same transformed `x`.
    rmn = lmn[:]
    rmx = lmx[:]
    for i in xrange(200009):
        if lmn[i + 1] > lmn[i]:
            lmn[i + 1] = lmn[i]
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples, `inf` is 1001001001, `C` is 400010, `lmn` is a list of 400010 elements where each element at index `x` is the minimum `y` value among all tuples in `a` that map to the same transformed `x`, `lmx` is a list of 400010 elements where each element at index `x` is the maximum `y` value among all tuples in `a` that map to the same transformed `x`, `rmn` is a shallow copy of the original `lmn`, `rmx` is a shallow copy of `lmx`, and `lmn` is modified such that for all indices `i` from 1 to 200009, `lmn[i]` is the minimum value of `lmn` from index 0 to index `i`.
    for i in xrange(200009):
        if lmx[i + 1] < lmx[i]:
            lmx[i + 1] = lmx[i]
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples, `inf` is 1001001001, `C` is 400010, `lmn` is a list of 400010 elements where each element at index `x` is the minimum `y` value among all tuples in `a` that map to the same transformed `x`, and `lmn[i]` for all indices `i` from 1 to 200009 is the minimum value of `lmn` from index 0 to index `i`, `lmx` is a list of 400010 elements where each element at index `x` is the maximum `y` value among all tuples in `a` that map to the same transformed `x`, `lmx[i]` for all indices `i` from 1 to 200009 is the maximum value of `lmx` from index 0 to index `i`, `rmn` is a shallow copy of the original `lmn`, `rmx` is a shallow copy of the original `lmx`.
    for i in xrange(200009, 0, -1):
        if rmn[i - 1] > rmn[i]:
            rmn[i - 1] = rmn[i]
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples, `inf` is 1001001001, `C` is 400010, `lmn` is a list of 400010 elements where each element at index `x` is the minimum `y` value among all tuples in `a` that map to the same transformed `x`, and `lmn[i]` for all indices `i` from 1 to 200009 is the minimum value of `lmn` from index 0 to index `i`, `lmx` is a list of 400010 elements where each element at index `x` is the maximum `y` value among all tuples in `a` that map to the same transformed `x`, and `lmx[i]` for all indices `i` from 1 to 200009 is the maximum value of `lmx` from index 0 to index `i`, `rmn` is a shallow copy of the original `lmn` with the property that for all indices `i` from 1 to 200009, `rmn[i]` is the minimum value of `rmn` from index 0 to index `i`, `rmx` is a shallow copy of the original `lmx`.
    for i in xrange(200009, 0, -1):
        if rmx[i - 1] < rmx[i]:
            rmx[i - 1] = rmx[i]
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples, `inf` is 1001001001, `C` is 400010, `lmn` is a list of 400010 elements where each element at index `x` is the minimum `y` value among all tuples in `a` that map to the same transformed `x`, and `lmn[i]` for all indices `i` from 1 to 200009 is the minimum value of `lmn` from index 0 to index `i`, `lmx` is a list of 400010 elements where each element at index `x` is the maximum `y` value among all tuples in `a` that map to the same transformed `x`, and `lmx[i]` for all indices `i` from 1 to 200009 is the maximum value of `lmx` from index 0 to index `i`, `rmn` is a shallow copy of the original `lmn` with the property that for all indices `i` from 1 to 200009, `rmn[i]` is the minimum value of `rmn` from index 0 to index `i`, `rmx` is a shallow copy of the original `lmx`, and `rmx[i]` for all indices `i` from 1 to 200009 is the maximum value of `rmx` from index 0 to index `i`.
    for i in xrange(200010):
        if lmn[i] < rmn[i]:
            lmn[i] = rmn[i]
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples, `inf` is 1001001001, `C` is 400010, `lmn` is a list of 400010 elements where each element at index `x` is the minimum `y` value among all tuples in `a` that map to the same transformed `x`, and for all indices `i` from 0 to 200009, `lmn[i]` is the maximum of the original `lmn[i]` and `rmn[i]`. `lmx` is a list of 400010 elements where each element at index `x` is the maximum `y` value among all tuples in `a` that map to the same transformed `x`, and `lmx[i]` for all indices `i` from 1 to 200009 is the maximum value of `lmx` from index 0 to index `i`. `rmn` is a shallow copy of the original `lmn` with the property that for all indices `i` from 1 to 200009, `rmn[i]` is the minimum value of `rmn` from index 0 to index `i`. `rmx` is a shallow copy of the original `lmx`, and `rmx[i]` for all indices `i` from 1 to 200009 is the maximum value of `rmx` from index 0 to index `i`.
    for i in xrange(200010):
        if lmx[i] > rmx[i]:
            lmx[i] = rmx[i]
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples, `inf` is 1001001001, `C` is 400010, `lmn` is a list of 400010 elements where each element at index `x` is the minimum `y` value among all tuples in `a` that map to the same transformed `x`, and for all indices `i` from 0 to 200009, `lmn[i]` is the maximum of the original `lmn[i]` and `rmn[i]`, `lmx` is a list of 400010 elements where each element at index `x` is the minimum of the original maximum `y` value among all tuples in `a` that map to the same transformed `x` and the corresponding value in `rmx`, `rmn` is a shallow copy of the original `lmn` with the property that for all indices `i` from 1 to 200009, `rmn[i]` is the minimum value of `rmn` from index 0 to index `i`, `rmx` is a shallow copy of the original `lmx`, and for all indices `i` from 1 to 200009, `rmx[i]` is the maximum value of `rmx` from index 0 to index `i`.
    ans = 0
    for i in xrange(200009):
        if lmn[i] < lmn[i + 1]:
            lmn[i] = lmn[i + 1]
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples, `inf` is 1001001001, `C` is 400010, `lmn` is a list of 400010 elements where each element at index `x` is the maximum `y` value among all tuples in `a` that map to the same transformed `x` and for all indices `i` from 0 to 200008, `lmn[i]` is the maximum of the original `lmn[i]` and `lmn[i + 1]`, `lmx` is a list of 400010 elements, `rmn` is a shallow copy of the original `lmn`, `rmx` is a shallow copy of the original `lmx`, `ans` is 0.
    for i in xrange(200009):
        if lmx[i] > lmx[i + 1]:
            lmx[i] = lmx[i + 1]
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples, `inf` is 1001001001, `C` is 400010, `lmn` is a list of 400010 elements where each element at index `x` is the maximum `y` value among all tuples in `a` that map to the same transformed `x`, for all indices `i` from 0 to 200008, `lmn[i]` is the maximum of the original `lmn[i]` and `lmn[i + 1]`, `lmx` is a list of 400010 elements where for all indices `i` from 0 to 200008, `lmx[i]` is the minimum of the original `lmx[i]` and all subsequent elements up to `lmx[200009]`, `rmn` is a shallow copy of the original `lmn`, `rmx` is a shallow copy of the original `lmx`, `ans` is 0.
    for i in xrange(200009):
        if lmn[i] < lmx[i]:
            ans += (lmx[i] - lmn[i]) / 2
        
    #State of the program after the  for loop has been executed: `a` is a list of tuples, `inf` is 1001001001, `C` is 400010, `lmn` is a list of 400010 elements where each element at index `x` is the maximum `y` value among all tuples in `a` that map to the same transformed `x`, for all indices `i` from 0 to 200008, `lmn[i]` is the maximum of the original `lmn[i]` and `lmn[i + 1]`, `lmx` is a list of 400010 elements where for all indices `i` from 0 to 200008, `lmx[i]` is the minimum of the original `lmx[i]` and all subsequent elements up to `lmx[200009]`, `rmn` is a shallow copy of the original `lmn`, `rmx` is a shallow copy of the original `lmx`, `i` is 200009. `ans` is the sum of `(lmx[j] - lmn[j]) / 2` for all `j` from 0 to 200008 where `lmn[j] < lmx[j]`. If no such `j` exists, `ans` remains 0.
    return ans
    #The program returns `ans`, which is the sum of `(lmx[j] - lmn[j]) / 2` for all `j` from 0 to 200008 where `lmn[j] < lmx[j]`. If no such `j` exists, `ans` remains 0.
#Overall this is what the function does:The function `func_1` takes a list `a` of distinct tuples `(x, y)` where each coordinate is an integer within the range -105 to 105. It processes these coordinates to compute the minimum and maximum `y` values for each transformed `x` coordinate (using the formula `(x - 1) / 2 + 100005`). The function then adjusts these minimum and maximum values to ensure they are non-decreasing and non-increasing, respectively, across the range of transformed `x` values. Finally, it calculates and returns the sum of `(lmx[j] - lmn[j]) / 2` for all `j` from 0 to 200008 where `lmn[j] < lmx[j]`. If no such `j` exists, the function returns 0. The input list `a` remains unchanged throughout the execution of the function.

#Function 2:
#State of the program right berfore the function call: The function does not take any parameters directly. However, it reads input from stdin where the first line is an integer n (1 ≤ n ≤ 105) representing the number of black points, followed by n lines each containing two integers x and y (-105 ≤ x, y ≤ 105) representing the coordinates of the black tokens. The coordinates are read into a list `dat` and processed to populate the list `s` which contains two sublists. Each sublist in `s` corresponds to the parity of the sum of the coordinates (x + y), and stores tuples (-x + y, x + y) for each black token.
def func_2():
    n = int(stdin.readline())
    dat = map(int, stdin.read().split(), repeat(10, 2 * n))
    s = [[], []]
    for i in xrange(n):
        x, y = dat[i * 2:i * 2 + 2]
        
        s[x + y & 1].append((-x + y, x + y))
        
    #State of the program after the  for loop has been executed: `n` is an integer between 1 and 105 (inclusive), `i` is `n - 1`, `dat` is a map object converting input from `stdin` into integers, `s` is a list where `s[0]` contains tuples `(-x + y, x + y)` for all pairs `(x, y)` where `x + y` is even, and `s[1]` contains tuples `(-x + y, x + y)` for all pairs `(x, y)` where `x + y` is odd.
    print(func_1(s[0]) + func_1(s[1]))
#Overall this is what the function does:The function `func_2` reads input from standard input (`stdin`) to process coordinates of black tokens. It expects the first line to contain an integer `n` (1 ≤ n ≤ 105) representing the number of black tokens, followed by `n` lines, each containing two integers `x` and `y` (-105 ≤ x, y ≤ 105) representing the coordinates of each token. The function populates a list `s` with two sublists based on the parity of the sum of the coordinates (`x + y`). Each sublist in `s` contains tuples `(-x + y, x + y)` for the respective parity (even or odd). After processing the coordinates, the function calls `func_1` on both sublists and prints the sum of the results. The final state of the program is that the input has been fully consumed, and the sum of the results from `func_1` for both sublists has been printed to the standard output. Edge cases and potential issues include handling invalid input (e.g., non-integer values, incorrect number of coordinates) and ensuring that `func_1` is defined and behaves correctly.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
