
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There are n boxers, the weight of the i-th boxer is a_i. Each of them can change the weight by no more than 1 before the competition (the weight cannot become equal to zero, that is, it must remain positive). Weight is always an integer number.

It is necessary to choose the largest boxing team in terms of the number of people, that all the boxers' weights in the team are different (i.e. unique).

Write a program that for given current values ​a_i will find the maximum possible number of boxers in a team.

It is possible that after some change the weight of some boxer is 150001 (but no more).

Input

The first line contains an integer n (1 ≤ n ≤ 150000) — the number of boxers. The next line contains n integers a_1, a_2, ..., a_n, where a_i (1 ≤ a_i ≤ 150000) is the weight of the i-th boxer.

Output

Print a single integer — the maximum possible number of people in a team.

Examples

Input

4
3 2 4 1


Output

4


Input

6
1 1 1 4 4 4


Output

5

Note

In the first example, boxers should not change their weights — you can just make a team out of all of them.

In the second example, one boxer with a weight of 1 can be increased by one (get the weight of 2), one boxer with a weight of 4 can be reduced by one, and the other can be increased by one (resulting the boxers with a weight of 3 and 5, respectively). Thus, you can get a team consisting of boxers with weights of 5, 4, 3, 2, 1.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from itertools import chain

#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 150000, and a list of n integers a_1, a_2, ..., a_n where each a_i satisfies 1 ≤ a_i ≤ 150000.
def func():
    n = int(raw_input())
    a = list(sorted(map(int, raw_input().split())))
    team = set()
    for boxer in a:
        if boxer - 1 > 0 and boxer - 1 <= 150001 and boxer - 1 not in team:
            team.add(boxer - 1)
        elif boxer > 0 and boxer <= 150001 and boxer not in team:
            team.add(boxer)
        elif boxer + 1 > 0 and boxer + 1 <= 150001 and boxer + 1 not in team:
            team.add(boxer + 1)
        
    #State of the program after the  for loop has been executed: `n` is a positive integer such that \(1 \leq n \leq 150000\), `a` is a sorted list of `n` integers where each element \(a_i\) satisfies \(1 \leq a_i \leq 150000\), `team` is a set containing unique integers that are either one less than, equal to, or one more than the elements of `a`, provided they satisfy the conditions \(1 \leq x \leq 150001\) and are not already in `team`. If `a` is empty, `team` remains an empty set.
    print(len(team), team)
#Overall this is what the function does:The function reads an integer `n` and a list of `n` integers `a` from the standard input, where `1 ≤ n ≤ 150000` and each `a_i` satisfies `1 ≤ a_i ≤ 150000`. It then creates a set `team` containing unique integers that are either one less than, equal to, or one more than the elements of `a`, provided they satisfy the conditions `1 ≤ x ≤ 150001` and are not already in `team`. After processing, the function prints the size of the `team` set followed by the elements of the set. If the input list `a` is empty, the function prints `0` and an empty set. The function does not return any value.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
