
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: There are famous Russian nesting dolls named matryoshkas sold in one of the souvenir stores nearby, and you'd like to buy several of them. The store has n different matryoshkas. Any matryoshka is a figure of volume out_i with an empty space inside of volume in_i (of course, out_i > in_i).

You don't have much free space inside your bag, but, fortunately, you know that matryoshkas can be nested one inside another. Formally, let's call a set of matryoshkas nested if we can rearrange dolls in such a way, that the first doll can be nested inside the second one, the second doll — inside the third one and so on. Matryoshka i can be nested inside matryoshka j if out_i ≤ in_j. So only the last doll will take space inside your bag.

Let's call extra space of a nested set of dolls as a total volume of empty space inside this structure. Obviously, it's equal to in_{i_1} + (in_{i_2} - out_{i_1}) + (in_{i_3} - out_{i_2}) + ... + (in_{i_k} - out_{i_{k-1}}), where i_1, i_2, ..., i_k are the indices of the chosen dolls in the order they are nested in each other.

Finally, let's call a nested subset of the given sequence as big enough if there isn't any doll from the sequence that can be added to the nested subset without breaking its nested property.

You want to buy many matryoshkas, so you should choose a big enough nested subset to buy it. But you will be disappointed if too much space in your bag will be wasted, so you want to choose a big enough subset so that its extra space is minimum possible among all big enough subsets. Now you wonder, how many different nested subsets meet these conditions (they are big enough, and there is no big enough subset such that its extra space is less than the extra space of the chosen subset). Two subsets are considered different if there exists at least one index i such that one of the subsets contains the i-th doll, and another subset doesn't.

Since the answer can be large, print it modulo 10^9 + 7.

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the number of matryoshkas.

The next n lines contain a description of each doll: two integers out_i and in_i (1 ≤ in_i < out_i ≤ 10^9) — the outer and inners volumes of the i-th matryoshka.

Output

Print one integer — the number of big enough nested subsets such that extra space of each of these subsets is minimum possible. Since the answer can be large, print it modulo 10^9 + 7.

Example

Input


7
4 1
4 2
4 2
2 1
5 4
6 4
3 2


Output


6

Note

There are 6 big enough nested subsets with minimum possible extra space in the example: 

  * \{1, 5\}: we can't add any other matryoshka and keep it nested; it's extra space is 1; 
  * \{1, 6\}; 
  * \{2, 4, 5\}; 
  * \{2, 4, 6\}; 
  * \{3, 4, 5\}; 
  * \{3, 4, 6\}. 



There are no more "good" subsets because, for example, subset \{6, 7\} is not big enough (we can add the 4-th matryoshka to it) or subset \{4, 6, 7\} has extra space equal to 2.
Program:
```
from __future__ import division, print_function
import os, sys
from atexit import register
from io import BytesIO
import itertools
#Function 1:
def func_1():
    return list(map(int, input().split()))

#Function 2:
def func_2(f, *dim):
    return [func_2(f, *dim[1:]) for _ in range(dim[0])] if dim else f()

#Function 3:
def func_3():
    from bisect import bisect_right


    n = int(input())
    a = [func_1() for _ in range(n)]
    a.sort()
    eps = []
    best = []
    d = dict()
    er = []
    for (ep, sp) in a:
        if not eps or eps[-1] != ep:
            eps.append(ep)
        if not er or er[-1][0] != ep:
            er.append([ep, sp])
        else:
            er[-1][1] = sp
        i = bisect_right(eps, sp) - 1
        if i == -1:
            (g, c) = (sp, 1)
        else:
            (g, c) = (sp - best[i][0], best[i][1])
        try:
            (gap, count) = d[ep]
        except KeyError:
            (gap, count) = (ep, 0)
        (gap, count) = update((gap, count), (g, c))
        d[ep] = (gap, count)
        try:
            best[len(eps) - 1] = update2(best[len(eps) - 1], (ep - g, c))
        except IndexError:
            if len(eps) == 1:
                best.append((ep - g, c))
            else:
                best.append(update2(best[len(eps) - 2], (ep - g, c)))
    debug_print(eps)
    debug_print(d)
    debug_print(best)
    debug_print(er)
    (e, sb) = er.pop()
    ans = (e, 0)
    while sb < e:
        ans = update(ans, d[e])
        if er:
            (e, s) = er.pop()
            sb = max(sb, s)
        else:
            break
    print(ans[1])

#Function 4:
def update(o, n):
    if n[0] < o[0]:
        return n
    elif n[0] == o[0]:
        return (o[0], (o[1] + n[1]) % MOD)
    else:
        return o

#Function 5:
def update2(o, n):
    if n[0] > o[0]:
        return n
    elif n[0] == o[0]:
        return (o[0], (o[1] + n[1]) % MOD)
    else:
        return o


```
Original Assessment: Correctness: **False**

Explanation: The provided program has several issues that prevent it from meeting the requirements of the problem description. One critical issue is in the handling of the `update` and `update2` functions, which are used to manage the gap and count of nested subsets. The logic in these functions does not correctly handle all edge cases, leading to incorrect results.

For example, consider the following input:
```
3
4 1
5 2
6 3
```

The correct output for this input should be `1`, as the only big enough nested subset with the minimum possible extra space is `{1, 2, 3}`. However, the provided program may produce an incorrect result due to the flawed logic in the `update` and `update2` functions.

Additionally, the program's handling of the `best` array and the `d` dictionary is not robust enough to ensure that all big enough nested subsets are correctly identified and counted. This can lead to incorrect counts and gaps, further contributing to the program's incorrectness.

To ensure the program is correct, it would need significant revisions to the logic handling the nested subsets and their properties.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: Output hints for function number 5 : The function `update2` takes two tuples `o` and `n`, each containing two integers. The function compares the first elements of these tuples (`o[0]` and `n[0]`) and returns one of the following:

1. If `n[0]` is greater than `o[0]`, the function returns the tuple `n`. This means the returned tuple contains the inner volume `n[0]` and a count or cumulative value `n[1]`.

2. If `n[0]` is equal to `o[0]`, the function returns a new tuple `(o[0], (o[1] + n[1]) % MOD)`. Here, `o[0]` is the outer volume, and the second element is the sum of `o[1]` and `n[1]`, taken modulo `MOD`.

3. If `n[0]` is less than `o[0]`, the function returns the tuple `o`. This means the returned tuple contains the outer volume `o[0]` and a count or cumulative value `o[1]`.

Edge Cases and Missing Functionality:
- The function assumes that `o` and `n` are always tuples of exactly two integers. If either `o` or `n` is not a tuple or does not contain exactly two integers, the function will raise an error.
- The function does not handle cases where `MOD` is not defined or is zero, which would cause a division by zero error during the modulo operation.
- The function does not validate the types or values of `o[0]`, `o[1]`, `n[0]`, and `n[1]` to ensure they are integers, which could lead to unexpected behavior if non-integer values are passed.+


Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
