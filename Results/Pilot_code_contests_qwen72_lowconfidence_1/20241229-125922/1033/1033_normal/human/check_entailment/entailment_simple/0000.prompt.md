
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There are famous Russian nesting dolls named matryoshkas sold in one of the souvenir stores nearby, and you'd like to buy several of them. The store has n different matryoshkas. Any matryoshka is a figure of volume out_i with an empty space inside of volume in_i (of course, out_i > in_i).

You don't have much free space inside your bag, but, fortunately, you know that matryoshkas can be nested one inside another. Formally, let's call a set of matryoshkas nested if we can rearrange dolls in such a way, that the first doll can be nested inside the second one, the second doll — inside the third one and so on. Matryoshka i can be nested inside matryoshka j if out_i ≤ in_j. So only the last doll will take space inside your bag.

Let's call extra space of a nested set of dolls as a total volume of empty space inside this structure. Obviously, it's equal to in_{i_1} + (in_{i_2} - out_{i_1}) + (in_{i_3} - out_{i_2}) + ... + (in_{i_k} - out_{i_{k-1}}), where i_1, i_2, ..., i_k are the indices of the chosen dolls in the order they are nested in each other.

Finally, let's call a nested subset of the given sequence as big enough if there isn't any doll from the sequence that can be added to the nested subset without breaking its nested property.

You want to buy many matryoshkas, so you should choose a big enough nested subset to buy it. But you will be disappointed if too much space in your bag will be wasted, so you want to choose a big enough subset so that its extra space is minimum possible among all big enough subsets. Now you wonder, how many different nested subsets meet these conditions (they are big enough, and there is no big enough subset such that its extra space is less than the extra space of the chosen subset). Two subsets are considered different if there exists at least one index i such that one of the subsets contains the i-th doll, and another subset doesn't.

Since the answer can be large, print it modulo 10^9 + 7.

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the number of matryoshkas.

The next n lines contain a description of each doll: two integers out_i and in_i (1 ≤ in_i < out_i ≤ 10^9) — the outer and inners volumes of the i-th matryoshka.

Output

Print one integer — the number of big enough nested subsets such that extra space of each of these subsets is minimum possible. Since the answer can be large, print it modulo 10^9 + 7.

Example

Input


7
4 1
4 2
4 2
2 1
5 4
6 4
3 2


Output


6

Note

There are 6 big enough nested subsets with minimum possible extra space in the example: 

  * \{1, 5\}: we can't add any other matryoshka and keep it nested; it's extra space is 1; 
  * \{1, 6\}; 
  * \{2, 4, 5\}; 
  * \{2, 4, 6\}; 
  * \{3, 4, 5\}; 
  * \{3, 4, 6\}. 



There are no more "good" subsets because, for example, subset \{6, 7\} is not big enough (we can add the 4-th matryoshka to it) or subset \{4, 6, 7\} has extra space equal to 2.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import os, sys
from atexit import register
from io import BytesIO
import itertools

DEBUG = 0
INF = float('inf')
MOD = 10 ** 9 + 7
if sys.version_info[0] < 3:
    input = raw_input
    range = xrange
    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip
if DEBUG:
    debug_print = print
else:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
    sys.stdout = BytesIO()
    register(lambda : os.write(1, sys.stdout.getvalue()))
    input = lambda : sys.stdin.readline().rstrip('\r\n')
    debug_print = lambda *x, **y: None
func_3()

#Function 1:
#State of the program right berfore the function call: No variables are passed to the function. This function reads input from the user and returns a list of integers.
def func_1():
    return list(map(int, input().split()))
    #The program returns a list of integers obtained from the user input, where each element is converted to an integer.

#Function 2:
#State of the program right berfore the function call: f is a callable object (function or lambda), and *dim is a sequence of positive integers representing the dimensions of the nested list to be generated.
def func_2(f):
    return [func_2(f, *dim[1:]) for _ in range(dim[0])] if dim else f()
    #The program returns a nested list where each element is the result of calling `f()` if `dim` is empty, otherwise it returns a list of length `dim[0]` where each element is the result of recursively calling `func_2(f, *dim[1:])`. The depth of the nesting matches the length of `dim`, and the size of each dimension matches the corresponding value in `dim`.

#Function 3:
#State of the program right berfore the function call: The function `func_3` does not take any parameters directly. However, it relies on external inputs and other functions (`func_1`, `update`, `update2`, `debug_print`) being defined and working correctly. It processes a sorted list `a` of tuples, each containing two integers `(ep, sp)` representing the outer and inner volumes of matryoshkas. The list `a` is expected to be non-empty and sorted based on the outer volume `ep`. The integers `ep` and `sp` satisfy the condition `1 ≤ sp < ep ≤ 10^9`.
def func_3():
    n = int(input())
    a = [func_1() for _ in range(n)]
    a.sort()
    eps = []
    best = []
    d = dict()
    er = []
    for (ep, sp) in a:
        if not eps or eps[-1] != ep:
            eps.append(ep)
        
        if not er or er[-1][0] != ep:
            er.append([ep, sp])
        else:
            er[-1][1] = sp
        
        i = bisect_right(eps, sp) - 1
        
        if i == -1:
            g, c = sp, 1
        else:
            g, c = sp - best[i][0], best[i][1]
        
        try:
            gap, count = d[ep]
        except KeyError:
            gap, count = ep, 0
        
        gap, count = update((gap, count), (g, c))
        
        d[ep] = gap, count
        
        try:
            best[len(eps) - 1] = update2(best[len(eps) - 1], (ep - g, c))
        except IndexError:
            if len(eps) == 1:
                best.append((ep - g, c))
            else:
                best.append(update2(best[len(eps) - 2], (ep - g, c)))
        
    #State of the program after the  for loop has been executed: `a` is a list of `n` tuples, each of the form `(ep, sp)` where `1 ≤ sp < ep ≤ 10^9`, and `a` is sorted based on the outer volume `ep`; `n` is an input integer; `func_1`, `update`, `update2`, `debug_print` are defined and working correctly; `eps` is a list of unique `ep` values from `a` in the order they appear; `best` is a list of pairs `(gap, count)` where each pair is the result of applying `update2` to the best values for each unique `ep` in `eps`; `d` is a dictionary where each key is a unique `ep` from `a` and the value is the final `(gap, count)` for that `ep`; `er` is a list of pairs `[ep, sp]` where `ep` is unique and `sp` is the last `sp` for that `ep` in `a`.
    debug_print(eps)
    debug_print(d)
    debug_print(best)
    debug_print(er)
    e, sb = er.pop()
    ans = e, 0
    while sb < e:
        ans = update(ans, d[e])
        
        if er:
            e, s = er.pop()
            sb = max(sb, s)
        else:
            break
        
    #State of the program after the loop has been executed: `a` is a list of `n` tuples, each of the form `(ep, sp)` where `1 ≤ sp < ep ≤ 10^9`, and `a` is sorted based on the outer volume `ep`; `n` is an input integer; `func_1`, `update`, `update2`, `debug_print` are defined and working correctly; `eps` is a list of unique `ep` values from `a` in the order they appear; `best` is a list of pairs `(gap, count)` where each pair is the result of applying `update2` to the best values for each unique `ep` in `eps`; `d` is a dictionary where each key is a unique `ep` from `a` and the value is the final `(gap, count)` for that `ep`; `er` is an empty list if it was non-empty initially; `sb` is the maximum of all `sp` values from the tuples in `er` that were popped; `e` and `s` do not exist if `er` is empty; `ans` is the result of multiple `update` calls with the values from `d[e]` for each `e` popped from `er`.
    print(ans[1])

#Function 4:
#State of the program right berfore the function call: o and n are tuples where each tuple consists of two integers. The first element of each tuple represents a volume, and the second element represents a count. MOD is a constant integer greater than 1.
def update(o, n):
    if (n[0] < o[0]) :
        return n
        #The program returns the tuple `n`, where `n` is a tuple consisting of two integers, with the first element representing a volume that is less than the volume represented by the first element of tuple `o`. The second element of `n` represents a count.
    else :
        if (n[0] == o[0]) :
            return o[0], (o[1] + n[1]) % MOD
            #The program returns the volume o[0] and the result of (o[1] + n[1]) % MOD, where o[0] is the same as n[0], o[1] and n[1] are counts, and MOD is a constant integer greater than 1.
        else :
            return o
            #The program returns tuple `o` which consists of two integers where the first element represents a volume and the second element represents a count. The first element of `o` (volume) is less than the first element of `n` (volume), and both elements are integers.

#Function 5:
#State of the program right berfore the function call: o and n are tuples, each containing two elements. o[0] and n[0] are integers representing the outer and inner volumes of matryoshkas, respectively, and o[1] and n[1] are integers representing counts or cumulative values.
def update2(o, n):
    if (n[0] > o[0]) :
        return n
        #The program returns tuple `n` where `n[0]` is greater than `o[0]`, and both `n[0]` and `n[1]` are integers representing the inner volume and a count or cumulative value, respectively.
    else :
        if (n[0] == o[0]) :
            return o[0], (o[1] + n[1]) % MOD
            #The program returns the integer value o[0], which represents the outer volume of the matryoshka, and (o[1] + n[1]) % MOD, where o[1] and n[1] are integers representing counts or cumulative values, and MOD is the modulus value used in the calculation. Since n[0] is equal to o[0], the first returned value is the same as n[0].
        else :
            return o
            #The program returns tuple `o`, where `o[0]` is an integer representing the outer volume of matryoshkas, `o[1]` is an integer representing counts or cumulative values, and `n[0]` (an integer representing the inner volume of matryoshkas) is less than or equal to `o[0]` but not equal to `o[0]`.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
