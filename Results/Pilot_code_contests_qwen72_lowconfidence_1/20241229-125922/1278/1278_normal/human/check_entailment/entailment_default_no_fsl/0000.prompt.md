
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You are given four integers a, b, x and y. Initially, a ≥ x and b ≥ y. You can do the following operation no more than n times:

  * Choose either a or b and decrease it by one. However, as a result of this operation, value of a cannot become less than x, and value of b cannot become less than y. 



Your task is to find the minimum possible product of a and b (a ⋅ b) you can achieve by applying the given operation no more than n times.

You have to answer t independent test cases.

Input

The first line of the input contains one integer t (1 ≤ t ≤ 2 ⋅ 10^4) — the number of test cases. Then t test cases follow.

The only line of the test case contains five integers a, b, x, y and n (1 ≤ a, b, x, y, n ≤ 10^9). Additional constraint on the input: a ≥ x and b ≥ y always holds.

Output

For each test case, print one integer: the minimum possible product of a and b (a ⋅ b) you can achieve by applying the given operation no more than n times.

Example

Input


7
10 10 8 5 3
12 8 8 7 2
12343 43 4543 39 123212
1000000000 1000000000 1 1 1
1000000000 1000000000 1 1 1000000000
10 11 2 1 5
10 11 9 1 10


Output


70
77
177177
999999999000000000
999999999
55
10

Note

In the first test case of the example, you need to decrease b three times and obtain 10 ⋅ 7 = 70.

In the second test case of the example, you need to decrease a one time, b one time and obtain 11 ⋅ 7 = 77.

In the sixth test case of the example, you need to decrease a five times and obtain 5 ⋅ 11 = 55.

In the seventh test case of the example, you need to decrease b ten times and obtain 10 ⋅ 1 = 10.
Functions with output description for each function:
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
vow = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_18(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_19()

Function number 1 :
 Code:
 '''
def func_1():
    return int(input())
''' 

 Output hints for function1:  The function `func_1` reads an integer from the standard input, which is intended to represent the number of test cases `t`. The function then returns this integer. According to the return postconditions, the integer should be within the range 1 ≤ t ≤ 2 ⋅ 10^4. However, the function does not enforce this constraint, so the returned value could be outside this range if the input is invalid.
Function number 2 :
 Code:
 '''
def func_2():
    return input()
''' 

 Output hints for function2:  The function `func_2` does not accept any parameters and returns the input provided by the user. It reads a line of input from the user and returns it as a string. The function does not modify any external variables or state. Edge cases include scenarios where the user provides no input (an empty string is returned), or where the input contains special characters or multiple lines (the entire input up to the first newline character is returned).
Function number 3 :
 Code:
 '''
def func_3():
    return map(int, input().strip().split())
''' 

 Output hints for function3:  The function `func_3` reads a single line of input from standard input (stdin), expecting the input to be a sequence of space-separated integers. It then returns an iterator that yields each of these integers as an `int`. If the input contains non-integer values or is not properly formatted (e.g., contains non-numeric characters), the function will raise a `ValueError`. If the input line is empty, the function will return an empty iterator.
Function number 4 :
 Code:
 '''
def func_4():
    return map(str, input().strip().split())
''' 

 Output hints for function4:  The function `func_4` reads a line of input from standard input (stdin), strips any leading and trailing whitespace, splits the resulting string by whitespace, and returns a list of the resulting substrings. If the input is empty or consists only of whitespace, the function will return an empty list.
Function number 5 :
 Code:
 '''
def func_5():
    return list(func_3())
''' 

 Output hints for function5:  The function `func_5` does not accept any parameters and returns a list that is the result of calling `func_3()`. The contents of this list depend entirely on the implementation of `func_3()`, which is not provided. If `func_3()` raises an exception, `func_5` will also raise that exception. If `func_3()` returns an iterable other than a list, `func_5` will convert it to a list before returning.
Function number 6 :
 Code:
 '''
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
''' 

 Output hints for function6:  `func_6` does not accept any parameters. It sets the recursion limit to 1,000,000 and the stack size to 1,024,000 bytes. It then creates a new thread that starts the `main` function and begins executing it. The function itself does not return any value. After `func_6` concludes, the new thread continues to run independently, potentially affecting the program state depending on what `main` does. The main thread that called `func_6` will continue its execution immediately after starting the new thread.
Function number 7 :
 Code:
 '''
def func_7(item):
    return item[1]
''' 

 Output hints for function7:  The function `func_7` accepts a parameter `item`, which is expected to be a list or tuple with at least two elements, and returns the second element of `item`. If `item` does not have at least two elements, the function will raise an `IndexError`.
Function number 8 :
 Code:
 '''
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
''' 

 Output hints for function8:  The function `func_8` takes a list `l` as input, where each element in the list is either a dictionary or an object that has a key or attribute accessible via the `getKey` function. It returns a new list that is a sorted version of `l` in descending order based on the values returned by `getKey` for each element. The original list `l` remains unchanged. If `l` is empty, the function returns an empty list. If any element in `l` does not have a valid key or attribute for `getKey`, the behavior is undefined and may result in an error.
Function number 9 :
 Code:
 '''
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
''' 

 Output hints for function9:  The function `func_9` accepts three parameters: `n`, `m`, and `num`. It returns a list of `n` lists, where each inner list contains `m` elements, all of which are the integer `num`. The function assumes that `n` and `m` are non-negative integers. If `n` is 0, the function returns an empty list. If `m` is 0, the function returns a list of `n` empty lists. The function does not modify the input parameters.
Function number 10 :
 Code:
 '''
def func_10(x):
    return x and (not x & x - 1)
''' 

 Output hints for function10:  The function `func_10` accepts an integer `x` and returns `0` if `x` is `0`, `True` if `x` is a power of 2, and `False` otherwise. Note that the function correctly identifies powers of 2 and non-powers of 2, including negative integers, which will always return `False`.
Function number 11 :
 Code:
 '''
def func_11(n):
    return bin(n).replace('0b', '')
''' 

 Output hints for function11:  The function `func_11` accepts a non-negative integer `n` and returns its binary representation as a string without the '0b' prefix. If `n` is 0, the function returns '0'. For any other non-negative integer, it returns the corresponding binary string. The function does not handle negative integers or non-integer inputs, and such inputs would result in a `TypeError`.
Function number 12 :
 Code:
 '''
def func_12(n):
    return [int(i) for i in str(n)]
''' 

 Output hints for function12:  The function `func_12` accepts an integer `n` and returns a list of integers, where each integer is a digit from `n` in the same order as they appear in `n`. If `n` is 0, the function returns `[0]`. If `n` is negative, the function converts `n` to its absolute value before processing, ensuring the returned list contains only positive digits.
Function number 13 :
 Code:
 '''
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
''' 

 Output hints for function13:  The function `func_13` accepts two parameters `n` and `r`, both of which are non-negative integers with `n` ≥ `r`. It returns the integer value of the combination formula C(n, r) = n! / (r! * (n - r)!), which represents the number of ways to choose `r` elements from a set of `n` elements without repetition and without order. However, there is a potential edge case where if `n - r` is 0, the function uses `max(n - r, 1)` in the denominator, which could lead to incorrect results when `n = r` (since it should be 1, not 0!). The correct behavior should be to use `factorial(n - r)` directly to ensure accuracy. After the function concludes, the program state is unchanged except for the return value, which is the computed combination.
Function number 14 :
 Code:
 '''
def func_14(x, y):
    if x % y == 0:
        return x // y
    else:
        return x // y + 1
''' 

 Output hints for function14:  The function `func_14` accepts two integers `x` and `y` (where `y > 0`). It returns the integer division result of `x` by `y` if `x` is divisible by `y` (i.e., `x % y == 0`). If `x` is not divisible by `y` (i.e., `x % y ≠ 0`), it returns the integer division result plus 1. Edge cases to consider include when `x` is negative, in which case the function still follows the same logic, returning the integer division result or the result plus 1 based on divisibility.
Function number 15 :
 Code:
 '''
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p
    return res
''' 

 Output hints for function15:  The function `func_15` takes three parameters `x`, `y`, and `p`, where `x` and `p` are non-negative integers, `y` is a non-negative integer, and `p` is greater than 0. The function computes and returns `res`, which is `x^y % p`. The function effectively calculates the modular exponentiation of `x` raised to the power of `y`, modulo `p`. The state of the program after the function concludes is that `x` is modified to `x % p`, `y` is reduced to 0, and `p` remains unchanged. The final value of `res` is the result of the modular exponentiation. The function handles edge cases where `y` is 0, returning 1, and ensures that the result is always within the range `[0, p-1]`.
Function number 16 :
 Code:
 '''
def func_16(x, y):
    while y:
        (x, y) = (y, x % y)
    return x
''' 

 Output hints for function16:  The function `func_16` accepts two non-negative integers `x` and `y`. It computes and returns the Greatest Common Divisor (GCD) of `x` and `y`. After the function executes, the variable `y` is guaranteed to be 0, and `x` holds the GCD of the original values of `x` and `y`. The function handles the edge case where either `x` or `y` is 0, returning the non-zero value as the GCD. If both `x` and `y` are 0, the function returns 0.
Function number 17 :
 Code:
 '''
def func_17(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True
''' 

 Output hints for function17:  The function `func_17` accepts an integer `n` and determines whether `n` is a prime number. It returns `True` if `n` is a prime number and `False` otherwise. Specifically, the function handles the following cases:
- If `n` is less than or equal to 1, it returns `False`.
- If `n` is 2 or 3, it returns `True`.
- If `n` is greater than 3 and divisible by 2 or 3, it returns `False`.
- For `n` greater than 3 and not divisible by 2 or 3, the function checks divisibility by all integers of the form `6k ± 1` (where `k` is an integer) up to the square root of `n`. If `n` is divisible by any of these numbers, it returns `False`.
- If no divisors are found, the function returns `True`, indicating that `n` is a prime number.

Potential edge cases and missing functionality:
- The function correctly handles the edge case where `n` is less than or equal to 1.
- The function correctly identifies 2 and 3 as prime numbers.
- The function efficiently checks for primality by only considering potential divisors of the form `6k ± 1`, which covers all possible prime divisors.
- The function does not explicitly handle negative integers, but since the initial check ensures `n` is greater than 1, negative values are implicitly handled by returning `False`.
Function number 18 :
 Code:
 '''
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
''' 

 Output hints for function18:  The function `func_18` does not accept any parameters. It redirects the standard input to read from the file `input.txt` and the standard output to write to the file `output.txt`. The function does not return any value. After the function executes, any subsequent input operations (e.g., `input()`) will read from `input.txt`, and any subsequent output operations (e.g., `print()`) will write to `output.txt`. If `input.txt` does not exist or cannot be opened, the function will raise an `IOError` or `FileNotFoundError`. Similarly, if `output.txt` cannot be opened for writing, the function will also raise an `IOError`.
Function number 19 :
 Code:
 '''
def func_19():
    for _ in range(func_1()):
        (a, b, x, y, n) = func_3()
        if a - x + (b - y) <= n:
            func_20(int(x * y))
        else:
            a1 = a - x
            b1 = b - y
            if min(a1, b1) >= n:
                if a < b:
                    func_20((a - n) * b)
                else:
                    func_20((b - n) * a)
            elif max(a1, b1) == n:
                if a1 > b1:
                    func_20(x * b)
                else:
                    func_20(y * a)
            elif max(a1, b1) > n:
                if a1 < b1:
                    a2 = x * (b - (n - a1))
                    b2 = a * (b - n)
                    func_20(min(a2, b2))
                else:
                    a2 = y * (a - (n - b1))
                    b2 = b * (a - n)
                    func_20(min(a2, b2))
            elif a1 < b1:
                a2 = x * (b - (n - a1))
                b2 = a * (b - n)
                func_20(max(a2, b2))
            else:
                a2 = x * (a - (n - b1))
                b2 = b * (a - n)
                func_20(max(a2, b2))
''' 

 Output hints for function19:  The function `func_19` processes a series of operations based on the input parameters `a`, `b`, `x`, `y`, and `n`, all of which are integers within the range 1 ≤ a, b, x, y, n ≤ 10^9, with the additional constraints a ≥ x and b ≥ y. The function iterates a number of times determined by the return value of `func_1()`, which must be a positive integer. During each iteration, the values of `a`, `b`, `x`, `y`, and `n` are updated to the values returned by `func_3()`. Depending on the relationship between these values, the function calls `func_20` with different arguments. Specifically, if `a - x + (b - y) <= n`, `func_20` is called with the argument `int(x * y)`. If `a - x + (b - y) > n`, the function computes intermediate values `a1 = a - x` and `b1 = b - y`, and then calls `func_20` with one of several possible arguments based on the values of `a1`, `b1`, and `n`. The exact argument passed to `func_20` depends on the specific conditions met during each iteration. After the loop completes, the final values of `a`, `b`, `x`, `y`, and `n` are the last set of values returned by `func_3()`. If `func_1()` returns 0, the function does not execute the loop, and the values of `a`, `b`, `x`, `y`, and `n` remain unchanged.
Function number 20 :
 Code:
 '''
def func_20(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()
''' 

 Output hints for function20:  This function prints the values of the given arguments to a specified stream, typically `sys.stdout`, with options to customize the separator between values, the end character, and whether to flush the stream. The function accepts `*args` (any number of arguments of any type) and `



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.