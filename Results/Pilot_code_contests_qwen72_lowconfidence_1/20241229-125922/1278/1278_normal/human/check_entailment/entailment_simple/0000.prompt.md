
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given four integers a, b, x and y. Initially, a ≥ x and b ≥ y. You can do the following operation no more than n times:

  * Choose either a or b and decrease it by one. However, as a result of this operation, value of a cannot become less than x, and value of b cannot become less than y. 



Your task is to find the minimum possible product of a and b (a ⋅ b) you can achieve by applying the given operation no more than n times.

You have to answer t independent test cases.

Input

The first line of the input contains one integer t (1 ≤ t ≤ 2 ⋅ 10^4) — the number of test cases. Then t test cases follow.

The only line of the test case contains five integers a, b, x, y and n (1 ≤ a, b, x, y, n ≤ 10^9). Additional constraint on the input: a ≥ x and b ≥ y always holds.

Output

For each test case, print one integer: the minimum possible product of a and b (a ⋅ b) you can achieve by applying the given operation no more than n times.

Example

Input


7
10 10 8 5 3
12 8 8 7 2
12343 43 4543 39 123212
1000000000 1000000000 1 1 1
1000000000 1000000000 1 1 1000000000
10 11 2 1 5
10 11 9 1 10


Output


70
77
177177
999999999000000000
999999999
55
10

Note

In the first test case of the example, you need to decrease b three times and obtain 10 ⋅ 7 = 70.

In the second test case of the example, you need to decrease a one time, b one time and obtain 11 ⋅ 7 = 77.

In the sixth test case of the example, you need to decrease a five times and obtain 5 ⋅ 11 = 55.

In the seventh test case of the example, you need to decrease b ten times and obtain 10 ⋅ 1 = 10.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
vow = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_18(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_19()

#Function 1:
#State of the program right berfore the function call: This function does not take any parameters, and it is expected to read an integer from the standard input which represents the number of test cases t, where 1 ≤ t ≤ 2 ⋅ 10^4.
def func_1():
    return int(input())
    #The program returns an integer representing the number of test cases t, where 1 ≤ t ≤ 2 ⋅ 10^4.

#Function 2:
#State of the program right berfore the function call: None of the variables in the function signature are present. The function `func_2` does not take any parameters and simply returns the input from the user. This function is likely used to read input for the test cases but does not directly interact with the variables a, b, x, y, or n.
def func_2():
    return input()
    #The program returns the input provided by the user.

#Function 3:
#State of the program right berfore the function call: This function does not take any arguments and is used to read input from stdin. It assumes that the input is a line of space-separated integers.
def func_3():
    return map(int, input().strip().split())
    #The program returns an iterator that converts each element of the input line (a sequence of space-separated integers) into an integer.

#Function 4:
#State of the program right berfore the function call: None of the variables are used in the function signature. The function reads input from stdin and returns a list of strings.
def func_4():
    return map(str, input().strip().split())
    #The program returns a list of strings obtained from splitting the stripped input from stdin.

#Function 5:
#State of the program right berfore the function call: None of the variables from the original problem (a, b, x, y, n, t) are present in the function `func_5`. This function does not take any parameters and does not directly contribute to solving the problem described.
def func_5():
    return list(func_3())
    #The program returns a list that is the result of calling `func_3()`. The contents of this list depend entirely on the implementation of `func_3()`, which is not provided here.

#Function 6:
#State of the program right berfore the function call: This function does not take any parameters, and thus there are no preconditions related to input variables.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a list or tuple with at least two elements.
def func_7(item):
    return item[1]
    #The program returns the second element of the list or tuple 'item'.

#Function 8:
#State of the program right berfore the function call: l is a list of elements where each element is a dictionary or an object that has a key or attribute accessible by the getKey function, which is not provided in the snippet.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns a new list that is a sorted version of `l`, where the sorting is done in descending order based on the value returned by `getKey` for each element. Each element in this returned list is a dictionary or an object from the original list `l`.

#Function 9:
#State of the program right berfore the function call: n and m are non-negative integers, and num is an integer.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of lists where each inner list contains `m` elements, all being the integer `num`, and there are `n` such inner lists.

#Function 10:
#State of the program right berfore the function call: x is an integer.
def func_10(x):
    return x and not x & x - 1
    #The program returns 0 if `x` is 0, `True` if `x` is a power of 2, and `False` otherwise.

#Function 11:
#State of the program right berfore the function call: n is a non-negative integer.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of n as a string without the '0b' prefix, where n is a non-negative integer.

#Function 12:
#State of the program right berfore the function call: n is an integer.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is a digit from the integer 'n'. The order of the digits in the list corresponds to their order in 'n'.

#Function 13:
#State of the program right berfore the function call: n and r are non-negative integers where n ≥ r.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the integer value of the combination formula C(n, r) = n! / (r! * (n - r)!) where n and r are non-negative integers and n ≥ r. The result is the number of ways to choose r elements from a set of n elements without repetition and without order.

#Function 14:
#State of the program right berfore the function call: x and y are integers such that y > 0.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer division result of x by y, which is the quotient of x divided by y without the remainder, given that x is divisible by y (i.e., x % y == 0) and y > 0.
    else :
        return x // y + 1
        #The program returns the integer division of x by y (which is not a perfect division since x % y ≠ 0) plus 1

#Function 15:
#State of the program right berfore the function call: x, y, and p are integers where x and p are non-negative, and y is non-negative. Additionally, p must be greater than 0.
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `x` is `x^(2^iterations) % p`, `y` is `y // (2^iterations)`, `p` is an integer greater than 0, `res` is `x^(y_binary_sum) % p`, where `y_binary_sum` is the sum of the binary digits of the original value of `y`.
    return res
    #The program returns `res`, which is `x^(y_binary_sum) % p`, where `x` is `x^(2^iterations) % p`, `y` is `y // (2^iterations)`, `p` is an integer greater than 0, and `y_binary_sum` is the sum of the binary digits of the original value of `y`.

#Function 16:
#State of the program right berfore the function call: x and y are non-negative integers.
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the GCD of the original values of `x` and `y`
    return x
    #The program returns the GCD of the original values of `x` and `y`, where `y` is 0.

#Function 17:
#State of the program right berfore the function call: n is an integer greater than 1.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: `n` is an integer greater than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer greater than 3, and `n` is not divisible by 2 and not divisible by 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is an integer greater than 3, not divisible by 2, 3, or any prime number up to the largest prime `p` such that \( p^2 \leq n \); `i` is the smallest integer greater than the last checked prime such that \( i \equiv 5 \pmod{6} \) or \( i \equiv 11 \pmod{6} \). If `n` is divisible by any checked prime, the program returns False.
    return True
    #The program returns True, indicating that `n` is a prime number greater than 3 and not divisible by 2, 3, or any prime number up to the largest prime `p` such that \( p^2 \leq n \).

#Function 18:
#State of the program right berfore the function call: None of the variables a, b, x, y, n, or t are used in the function `func_18`. This function is responsible for redirecting standard input and output to files `input.txt` and `output.txt`, respectively. It does not operate on the variables mentioned in the problem description.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: a, b, x, y, and n are integers such that 1 ≤ a, b, x, y, n ≤ 10^9 and a ≥ x and b ≥ y.
def func_19():
    for _ in range(func_1()):
        a, b, x, y, n = func_3()
        
        if a - x + (b - y) <= n:
            func_20(int(x * y))
        else:
            a1 = a - x
            b1 = b - y
            if min(a1, b1) >= n:
                if a < b:
                    func_20((a - n) * b)
                else:
                    func_20((b - n) * a)
            elif max(a1, b1) == n:
                if a1 > b1:
                    func_20(x * b)
                else:
                    func_20(y * a)
            elif max(a1, b1) > n:
                if a1 < b1:
                    a2 = x * (b - (n - a1))
                    b2 = a * (b - n)
                    func_20(min(a2, b2))
                else:
                    a2 = y * (a - (n - b1))
                    b2 = b * (a - n)
                    func_20(min(a2, b2))
            elif a1 < b1:
                a2 = x * (b - (n - a1))
                b2 = a * (b - n)
                func_20(max(a2, b2))
            else:
                a2 = x * (a - (n - b1))
                b2 = b * (a - n)
                func_20(max(a2, b2))
        
    #State of the program after the  for loop has been executed: `a`, `b`, `x`, `y`, and `n` are updated to the values returned by `func_3()` for each iteration of the loop. The loop executes a number of times determined by `func_1()`, which must return a positive integer for the loop to execute. After the loop completes, the final values of `a`, `b`, `x`, `y`, and `n` are the last set of values returned by `func_3()`. If the condition `a - x + (b - y) <= n` holds true at any iteration, `func_20(int(x * y))` is called. If `a - x + (b - y) > n`, various conditions involving `a1 = a - x` and `b1 = b - y` determine which arguments are passed to `func_20`. The exact values passed to `func_20` depend on the specific values of `a1`, `b1`, and `n` during each iteration. If the loop does not execute, the values of `a`, `b`, `x`, `y`, and `n` remain as they were in the initial state.

#Function 20:
#State of the program right berfore the function call: args is a tuple containing any number of arguments of any type, and kwargs is a dictionary containing optional parameters such as 'sep', 'file', 'end', and 'flush'. 'sep' is a string used to separate the arguments when printed, defaulting to a single space. 'file' is a stream where the output will be written, defaulting to sys.stdout. 'end' is a string appended after the last value, defaulting to a newline character. 'flush' is a boolean indicating whether to forcibly flush the stream, defaulting to False.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a tuple containing any number of arguments of any type, `kwargs` is a dictionary containing optional parameters such as 'sep', 'file', 'end', and 'flush' (excluding 'sep' and 'file' if they were present), `sep` is the value of `kwargs['sep']` if it existed, otherwise ' ', `file` is the value of `kwargs['file']` if it existed, otherwise `sys.stdout`, `end` is a string appended after the last value, defaulting to a newline character, `flush` is a boolean indicating whether to forcibly flush the stream, defaulting to False, `at_start` is `False` if `args` is not empty, otherwise `True`. Each element in `args` has been written to `file` as a string, separated by `sep` if `args` contains more than one element.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a tuple containing any number of arguments of any type, `kwargs` is a dictionary containing optional parameters such as 'sep', 'file', 'end', and 'flush' (excluding 'sep' and 'file' if they were present) with `'end'` removed if it was present and `'flush'` removed if it was present, `sep` is the value of `kwargs['sep']` if it existed, otherwise ' ', `file` is the value of `kwargs['file']` if it existed, otherwise `sys.stdout`, `end` is a string appended after the last value, defaulting to a newline character, `flush` is a boolean indicating whether to forcibly flush the stream, defaulting to False, `at_start` is `False` if `args` is not empty, otherwise `True`, each element in `args` has been written to `file` as a string, separated by `sep` if `args` contains more than one element, and the value of `end` (or `'\n'` if `end` was not in `kwargs`) has been written to `file`. If `flush` is `True`, the file buffer has been flushed.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
