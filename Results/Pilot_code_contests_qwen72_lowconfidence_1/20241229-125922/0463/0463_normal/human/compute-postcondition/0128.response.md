Output State: **`n` is a valid integer greater than or equal to 3, `spg` is a list of length `int(n) + 1` where each element from index 3 to `n` is the result of the `mex` calculation for that iteration, `xor` is a list of length `int(n) + 1` where each element from index 3 to `n` is the cumulative XOR of the `mex` values up to that index, `i` is `n`, `k` is such that `k * (k + 1) > 2 * i`, `movs` is the set of all possible moves for the final iteration, `mex` is the smallest non-negative integer not present in `movs` for the final iteration, `spg[n]` is true. If the loop did not break early due to the condition `xor[a + k - 1] ^ xor[a - 1] == 0`, `k` will be the smallest integer such that `k * (k + 1) > 2 * i`.**