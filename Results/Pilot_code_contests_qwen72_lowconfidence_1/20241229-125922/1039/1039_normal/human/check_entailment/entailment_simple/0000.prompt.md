
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: The only difference between easy and hard versions is on constraints. In this version constraints are higher. You can make hacks only if all versions of the problem are solved.

Koa the Koala is at the beach!

The beach consists (from left to right) of a shore, n+1 meters of sea and an island at n+1 meters from the shore.

She measured the depth of the sea at 1, 2, ..., n meters from the shore and saved them in array d. d_i denotes the depth of the sea at i meters from the shore for 1 ≤ i ≤ n.

Like any beach this one has tide, the intensity of the tide is measured by parameter k and affects all depths from the beginning at time t=0 in the following way:

  * For a total of k seconds, each second, tide increases all depths by 1.

  * Then, for a total of k seconds, each second, tide decreases all depths by 1.

  * This process repeats again and again (ie. depths increase for k seconds then decrease for k seconds and so on ...).

Formally, let's define 0-indexed array p = [0, 1, 2, …, k - 2, k - 1, k, k - 1, k - 2, …, 2, 1] of length 2k. At time t (0 ≤ t) depth at i meters from the shore equals d_i + p[t mod 2k] (t mod 2k denotes the remainder of the division of t by 2k). Note that the changes occur instantaneously after each second, see the notes for better understanding. 




At time t=0 Koa is standing at the shore and wants to get to the island. Suppose that at some time t (0 ≤ t) she is at x (0 ≤ x ≤ n) meters from the shore:

  * In one second Koa can swim 1 meter further from the shore (x changes to x+1) or not swim at all (x stays the same), in both cases t changes to t+1.

  * As Koa is a bad swimmer, the depth of the sea at the point where she is can't exceed l at integer points of time (or she will drown). More formally, if Koa is at x (1 ≤ x ≤ n) meters from the shore at the moment t (for some integer t≥ 0), the depth of the sea at this point — d_x + p[t mod 2k] — can't exceed l. In other words, d_x + p[t mod 2k] ≤ l must hold always.

  * Once Koa reaches the island at n+1 meters from the shore, she stops and can rest.

Note that while Koa swims tide doesn't have effect on her (ie. she can't drown while swimming). Note that Koa can choose to stay on the shore for as long as she needs and neither the shore or the island are affected by the tide (they are solid ground and she won't drown there). 




Koa wants to know whether she can go from the shore to the island. Help her!

Input

The first line of the input contains one integer t (1 ≤ t ≤ 10^4) — the number of test cases. Description of the test cases follows.

The first line of each test case contains three integers n, k and l (1 ≤ n ≤ 3 ⋅ 10^5; 1 ≤ k ≤ 10^9; 1 ≤ l ≤ 10^9) — the number of meters of sea Koa measured and parameters k and l.

The second line of each test case contains n integers d_1, d_2, …, d_n (0 ≤ d_i ≤ 10^9) — the depths of each meter of sea Koa measured.

It is guaranteed that the sum of n over all test cases does not exceed 3 ⋅ 10^5.

Output

For each test case:

Print Yes if Koa can get from the shore to the island, and No otherwise.

You may print each letter in any case (upper or lower).

Example

Input


7
2 1 1
1 0
5 2 3
1 2 3 2 2
4 3 4
0 2 4 3
2 3 5
3 0
7 2 3
3 0 2 1 3 0 1
7 1 4
4 4 3 0 2 4 2
5 2 3
1 2 3 2 2


Output


Yes
No
Yes
Yes
Yes
No
No

Note

In the following s denotes the shore, i denotes the island, x denotes distance from Koa to the shore, the underline denotes the position of Koa, and values in the array below denote current depths, affected by tide, at 1, 2, ..., n meters from the shore.

In test case 1 we have n = 2, k = 1, l = 1, p = [ 0, 1 ].

Koa wants to go from shore (at x = 0) to the island (at x = 3). Let's describe a possible solution:

  * Initially at t = 0 the beach looks like this: [\underline{s}, 1, 0, i]. 
  * At t = 0 if Koa would decide to swim to x = 1, beach would look like: [s, \underline{2}, 1, i] at t = 1, since 2 > 1 she would drown. So Koa waits 1 second instead and beach looks like [\underline{s}, 2, 1, i] at t = 1. 
  * At t = 1 Koa swims to x = 1, beach looks like [s, \underline{1}, 0, i] at t = 2. Koa doesn't drown because 1 ≤ 1. 
  * At t = 2 Koa swims to x = 2, beach looks like [s, 2, \underline{1}, i] at t = 3. Koa doesn't drown because 1 ≤ 1. 
  * At t = 3 Koa swims to x = 3, beach looks like [s, 1, 0, \underline{i}] at t = 4. 
  * At t = 4 Koa is at x = 3 and she made it! 



We can show that in test case 2 Koa can't get to the island.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import os, sys, itertools

_interactive = False
INF = float('inf')
MOD = 10 ** 9 + 7
if sys.version_info[0] < 3:
    input = raw_input
    range = xrange
    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip
if _interactive:
    flush = sys.stdout.flush

    def printf(*args, **kwargs):
        print(*args, **kwargs)
        flush()
LOCAL = 'LOCAL_' in os.environ
debug_print = print if LOCAL else lambda *x, **y: None
if not LOCAL and (not _interactive):
    from io import BytesIO
    from atexit import register
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
    sys.stdout = BytesIO()
    register(lambda : os.write(1, sys.stdout.getvalue()))
    input = lambda : sys.stdin.readline().rstrip('\r\n')
func_1()

#Function 1:
#State of the program right berfore the function call: n, k, L are integers such that 1 ≤ n ≤ 3 ⋅ 10^5, 1 ≤ k ≤ 10^9, 1 ≤ L ≤ 10^9. ar is a list of n integers d_1, d_2, …, d_n such that 0 ≤ d_i ≤ 10^9.
def func_1():
    for _ in range(int(input())):
        n, k, L = func_2()
        
        ar = func_2()
        
        pos = None
        
        for x in ar:
            if x > L:
                print('No')
                break
            if x + k <= L:
                pos = None
            elif pos is not None:
                limit = L - x
                pos = max(pos + 1, -(L - x))
                if pos > limit:
                    print('No')
                    break
            else:
                pos = -(L - x)
        else:
            print('Yes')
        
    #State of the program after the  for loop has been executed: `n`, `k`, `L` are the values returned by `func_2()` each time the outer loop runs, `ar` is a list of `n` integers \(d_1, d_2, \ldots, d_n\) such that \(0 \leq d_i \leq 10^9\). `pos` is either `None` or the last computed value based on the conditions inside the loop. For each iteration of the outer loop, if any element `x` in `ar` is greater than `L` or if `x + k > L` and `pos` is `None`, the program prints 'No' and the loop terminates early. If the loop completes without breaking, the program prints 'Yes'. After all iterations of the outer loop, the program will have printed 'No' or 'Yes' for each set of `n`, `k`, `L`, and `ar` provided by `func_2()`.

#Function 2:
#State of the program right berfore the function call: None
def func_2():
    return [int(x) for x in input().split()]
    #The program returns a list of integers, where each integer is converted from a string obtained by splitting the input provided by the user.

#Function 3:
#State of the program right berfore the function call: o is an integer.
def func_3(o):
    return [(int(x) + o) for x in input().split()]
    #The program returns a list where each element is the result of converting a string from the input (split by spaces) into an integer and adding the integer `o` to it. The value of `o` is an integer.

#Function 4:
#State of the program right berfore the function call: n is a non-negative integer, m is not used in the function and can be of any type.
def func_4(n, m):
    return [func_2() for _ in range(n)]
    #The program returns a list containing the results of calling `func_2()` `n` times, where `n` is a non-negative integer. The variable `m` is not used in the function and does not affect the output.

#Function 5:
#State of the program right berfore the function call: f is a callable function, and *dim is a tuple of non-negative integers representing the dimensions of the nested list to be created.
def func_5(f):
    return [func_5(f, *dim[1:]) for _ in range(dim[0])] if dim else f()
    #The program returns a nested list of calls to `f()` with the structure defined by `*dim`. If `dim` is empty, the program returns the result of calling `f()`. Each level of the nested list corresponds to one dimension in `*dim`, and the length of each sublist at a given level is determined by the corresponding value in `*dim`.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
