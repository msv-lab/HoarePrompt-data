
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: The ancient Berlanders believed that the longer the name, the more important its bearer is. Thus, Berland kings were famous for their long names. But long names are somewhat inconvenient, so the Berlanders started to abbreviate the names of their kings. They called every king by the first letters of its name. Thus, the king, whose name was Victorious Vasily Pupkin, was always called by the berlanders VVP.

In Berland over its long history many dynasties of kings replaced each other, but they were all united by common traditions. Thus, according to one Berland traditions, to maintain stability in the country, the first name of the heir should be the same as the last name his predecessor (hence, the first letter of the abbreviated name of the heir coincides with the last letter of the abbreviated name of the predecessor). Berlanders appreciate stability, so this tradition has never been broken. Also Berlanders like perfection, so another tradition requires that the first name of the first king in the dynasty coincides with the last name of the last king in this dynasty (hence, the first letter of the abbreviated name of the first king coincides with the last letter of the abbreviated name of the last king). This tradition, of course, has also been always observed.

The name of a dynasty is formed by very simple rules: we take all the short names of the kings in the order in which they ruled, and write them in one line. Thus, a dynasty of kings "ab" and "ba" is called "abba", and the dynasty, which had only the king "abca", is called "abca".

Vasya, a historian, has recently found a list of abbreviated names of all Berland kings and their relatives. Help Vasya to find the maximally long name of the dynasty that could have existed in Berland.

Note that in his list all the names are ordered by the time, that is, if name A is earlier in the list than B, then if A and B were kings, then king A ruled before king B.

Input

The first line contains integer n (1 ≤ n ≤ 5·105) — the number of names in Vasya's list. Next n lines contain n abbreviated names, one per line. An abbreviated name is a non-empty sequence of lowercase Latin letters. Its length does not exceed 10 characters.

Output

Print a single number — length of the sought dynasty's name in letters.

If Vasya's list is wrong and no dynasty can be found there, print a single number 0.

Examples

Input

3
abc
ca
cba


Output

6


Input

4
vvp
vvp
dam
vvp


Output

0


Input

3
ab
c
def


Output

1

Note

In the first sample two dynasties can exist: the one called "abcca" (with the first and second kings) and the one called "abccba" (with the first and third kings). 

In the second sample there aren't acceptable dynasties.

The only dynasty in the third sample consists of one king, his name is "c".
Program:
```
def func():
    __author__ = 'Rikishi'
    n = int(raw_input())
    dyn = [[0] * 26 for i in range(26)]
    for i in range(n):
        s = raw_input()
        first = ord(s[0]) - ord('a')
        last = ord(s[-1]) - ord('a')
        for j in range(26):
            if dyn[j][first] > 0:
                dyn[j][last] = dyn[j][first] + len(s)
        dyn[first][last] = max(dyn[first][last], len(s))
    ans = max([dyn[i][i] for i in range(26)])
    print(ans)


```
Original Assessment: Correctness: **True**.

Explanation:
The provided program correctly implements the logic required to find the maximum length of a valid dynasty name according to the problem description. Here's a breakdown of why the program is correct:

1. **Initialization**: The program initializes a 2D array `dyn` with dimensions 26x26, where `dyn[i][j]` will store the maximum length of a dynasty name that starts with the i-th letter and ends with the j-th letter.

2. **Input Processing**: For each name in the input:
   - It calculates the indices of the first and last characters of the name.
   - It updates the `dyn` array to consider all possible previous states (i.e., all possible first characters of the previous name) that can connect to the current name.
   - It ensures that the current name is considered as a potential start and end point for the dynasty.

3. **Finding the Maximum Length**: After processing all names, the program finds the maximum value in the diagonal of the `dyn` array (`dyn[i][i]`), which represents the length of a valid dynasty name that starts and ends with the same letter.

4. **Output**: The program prints the maximum length found. If no valid dynasty is found, the maximum length will be 0, which is the correct output according to the problem description.

The program handles all edge cases, including:
- Single-character names.
- No valid dynasties in the input.
- Multiple valid dynasties with different lengths.

Since the program correctly follows the problem description and handles all potential cases, it is correct.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
#State of the program right berfore the function call: n is an integer where 1 ≤ n ≤ 5·10^5, and the list of names is a list of n strings, each string consisting of lowercase Latin letters and having a length between 1 and 10 characters.
def func():
    __author__ = 'Rikishi'
    n = int(raw_input())
    dyn = [([0] * 26) for i in range(26)]
    for i in range(n):
        s = raw_input()
        
        first = ord(s[0]) - ord('a')
        
        last = ord(s[-1]) - ord('a')
        
        for j in range(26):
            if dyn[j][first] > 0:
                dyn[j][last] = dyn[j][first] + len(s)
        
        dyn[first][last] = max(dyn[first][last], len(s))
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `i` is `n-1` if `n > 0` or undefined if `n = 0`, the list of names is a list of `n` strings, each string consisting of lowercase Latin letters and having a length between 1 and 10 characters, `__author__` is 'Rikishi', `dyn` is a 26x26 list of lists where each element is 0 except for those elements `dyn[j][last]` which are updated to `dyn[j][first] + len(s)` for all `j` where `dyn[j][first] > 0` and for each string `s` in the list of names, `first` is `ord(s[0]) - ord('a')`, `last` is `ord(s[-1]) - ord('a')`, and `dyn[first][last]` is the maximum of its original value and `len(s)`. If `n = 0`, `dyn` remains a 26x26 list of lists where each element is 0.
    ans = max([dyn[i][i] for i in range(26)])
    print(ans)
#Overall this is what the function does:The function reads an integer `n` and a list of `n` strings from the standard input, where each string consists of lowercase Latin letters and has a length between 1 and 10 characters. It then constructs a 26x26 matrix `dyn` where each element represents the maximum possible length of a chain of strings that can be formed such that the last character of one string matches the first character of the next string. The function finally prints the maximum value in the diagonal of this matrix, which represents the longest such chain that can be formed using the given strings. If no valid chains exist, it prints 0. The function does not return any value. Edge cases include when `n` is 0, in which case the function initializes the matrix `dyn` to a 26x26 zero matrix and prints 0.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
