
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Bob has a string s consisting of lowercase English letters. He defines s' to be the string after removing all "a" characters from s (keeping all other characters in the same order). He then generates a new string t by concatenating s and s'. In other words, t=s+s' (look at notes for an example).

You are given a string t. Your task is to find some s that Bob could have used to generate t. It can be shown that if an answer exists, it will be unique.

Input

The first line of input contains a string t (1 ≤ |t| ≤ 10^5) consisting of lowercase English letters.

Output

Print a string s that could have generated t. It can be shown if an answer exists, it is unique. If no string exists, print ":(" (without double quotes, there is no space between the characters).

Examples

Input


aaaaa


Output


aaaaa


Input


aacaababc


Output


:(


Input


ababacacbbcc


Output


ababacac


Input


baba


Output


:(

Note

In the first example, we have s =  "aaaaa", and s' =  "".

In the second example, no such s can work that will generate the given t.

In the third example, we have s =  "ababacac", and s' =  "bbcc", and t = s + s' =  "ababacacbbcc".
Functions with output description for each function:
from __future__ import division, print_function
import itertools,os,sys
from collections import deque, Counter, OrderedDict, defaultdict
import os
import sys
from io import BytesIO, IOBase

"""
Author    : raj1307 - Raj Singh
Institute : Jalpaiguri Government Engineering College
Date      : 20.04.19
"""
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
else:
    from builtins import str as __str__
    str = lambda x=b'': x if type(x) is bytes else __str__(x).encode()
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._buffer = BytesIO()
        self._fd = file.fileno()
        self._writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self._buffer.write if self._writable else None

    def read(self):
        return self._buffer.read() if self._buffer.tell() else os.read(self._fd, os.fstat(self._fd).st_size)

    def readline(self):
        while self.newlines == 0:
            (b, ptr) = (os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)), self._buffer.tell())
            (self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr))
            self.newlines += b.count(b'\n') + (not b)
        self.newlines -= 1
        return self._buffer.readline()

    def flush(self):
        if self._writable:
            os.write(self._fd, self._buffer.getvalue())
            (self._buffer.truncate(0), self._buffer.seek(0))
(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
input = lambda : sys.stdin.readline().rstrip(b'\r\n')
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
if __name__ == '__main__':
    func_12()

Function number 1 :
 Code:
 '''
def func_1(*args, **kwargs):
    (sep, file) = (kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', b'\n'))
    if kwargs.pop('flush', False):
        file.flush()
''' 

 Output hints for function1:  The function `func_1` accepts a variable number of arguments (`args`), a bytes separator (`sep`), a file-like object (`file`), a bytes end-of-line character (`end`), and a boolean flush flag (`flush`). It writes the string representations of the arguments to the specified file, separated by `sep`, and appends `end` at the end. If `flush` is `True`, it flushes the file after writing. The function does not return any value. After the function executes, the `file` contains the concatenated string representations of all elements in `args` (if `args` is not empty) separated by `sep`, followed by `end`. If `args` is empty, the `file` remains unchanged except for the addition of `end`. The `kwargs` dictionary is modified by removing the keys `'sep'`, `'file'`, `'end'`, and `'flush'` if they were present.
Function number 2 :
 Code:
 '''
def func_2():
    return int(input())
''' 

 Output hints for function2:  The function `func_2` does not accept any parameters and returns an integer obtained from user input. If the user inputs a non-integer value, a `ValueError` will be raised, and the function will terminate without returning a value.
Function number 3 :
 Code:
 '''
def func_3():
    return str(input())
''' 

 Output hints for function3:  The function `func_3` does not accept any parameters and returns a string input by the user. The function reads a line of input from the user and converts it to a string before returning it. The final state of the program after the function concludes is that it has returned the user's input as a string. Potential edge cases include the user providing an empty input (which would result in an empty string being returned) or the user interrupting the input process (e.g., using Ctrl+C), which could raise a `KeyboardInterrupt` exception.
Function number 4 :
 Code:
 '''
def func_4():
    return map(int, input().strip().split(' '))
''' 

 Output hints for function4:  The function `func_4` reads a line of input from the user or standard input, which is expected to be a string of integers separated by spaces. It then splits this string into individual substrings based on spaces, converts each substring into an integer using the `int` function, and returns a map object that contains these integers. If the input contains non-integer values or is empty, the function will raise a `ValueError` when attempting to convert the substrings to integers. The final state of the program after the function executes is that the map object is returned, and it can be iterated over to access the converted integers.
Function number 5 :
 Code:
 '''
def func_5():
    return list(func_4())
''' 

 Output hints for function5:  The function `func_5` does not accept any parameters and returns a list of values generated by calling the function `func_4()`. The exact content of the returned list depends on the implementation of `func_4()`, which is not provided. The function assumes that `func_4()` is defined elsewhere and returns an iterable (e.g., a list, tuple, generator). If `func_4()` returns a non-iterable or raises an exception, `func_5` will fail and propagate the exception. After the function concludes, the program state includes the returned list, and no other side effects are observed.
Function number 6 :
 Code:
 '''
def func_6(item):
    return item[0]
''' 

 Output hints for function6:  The function `func_6` accepts a single parameter `item`, which is expected to be a tuple or list. It returns the first element of `item`. The type of the returned element is unspecified as it can be of any type. If `item` is empty or not a tuple/list, the function will raise an error (e.g., `IndexError` for an empty list/tuple or `TypeError` if `item` is not a sequence). After the function executes, the first element of `item` is returned, and no changes are made to `item` itself.
Function number 7 :
 Code:
 '''
def func_7(l):
    return sorted(l, key=getKey)
''' 

 Output hints for function7:  The function `func_7` accepts a list `l` and a function `getKey`. It returns a new list that is sorted based on the values returned by the `getKey` function for each element in the original list `l`. The elements in the returned list maintain their relative order as determined by the values of `getKey(element)`. The function does not modify the original list `l`. If `getKey` returns the same value for multiple elements, those elements will appear in the same order in the sorted list as they did in the original list. The function assumes that `getKey` is defined and works correctly for all elements in `l`. If `l` is empty, the function returns an empty list.
Function number 8 :
 Code:
 '''
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
''' 

 Output hints for function8:  The function `func_8` accepts three parameters: `n`, `m`, and `num`. It returns a list of `n` inner lists, where each inner list contains `m` occurrences of `num`. The function assumes that `n` and `m` are non-negative integers, and `num` can be of any type. If `n` or `m` is 0, the function will return an empty list or a list of empty lists, respectively. The function does not modify any of its input parameters and does not have any side effects.
Function number 9 :
 Code:
 '''
def func_9(n):
    return [int(i) for i in str(n)]
''' 

 Output hints for function9:  The function `func_9` accepts an integer `n` and returns a list of integers, where each integer is a digit from `n`. The function converts the integer `n` into its string representation, then iterates over each character in the string, converts each character back to an integer, and collects these integers into a list. If `n` is 0, the function will return `[0]`. If `n` is negative, the function will return a list of the digits without the negative sign (e.g., `func_9(-123)` will return `[1, 2, 3]). The function does not handle non-integer inputs or floating-point numbers.
Function number 10 :
 Code:
 '''
def func_10(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p1
    return res
''' 

 Output hints for function10:  The function `func_10` accepts three parameters: `x` (an integer), `y` (a non-negative integer), and `p` (a positive integer). It computes and returns `res`, which is the result of `x` raised to the power of the initial value of `y`, modulo `p`. After the function executes, the final state is as follows: `y` is 0, `res` holds the value `x^initial_y % p`, `p` remains a positive integer, and `x` is the result of repeatedly squaring the initial value of `x` modulo `p` for the number of bits in the initial `y`. Note that there is a minor issue in the code where `p1` is used instead of `p` in the line `x = x * x % p1`, which should be corrected to `x = x * x % p` to match the intended functionality.
Function number 11 :
 Code:
 '''
def func_11(x, y):
    while y:
        (x, y) = (y, x % y)
    return x
''' 

 Output hints for function11:  The function `func_11` accepts two parameters `x` and `y`, where both are integers and `y` is non-negative. It returns the greatest common divisor (GCD) of the original values of `x` and `y`. After the function executes, the state of the program is such that the GCD of the original values of `x` and `y` is returned, and the internal variables `x` and `y` used within the function no longer affect the external state. If `y` is 0 initially, the function returns `x` without entering the loop, which is consistent with the mathematical definition of GCD (GCD(a, 0) = a).
Function number 12 :
 Code:
 '''
def func_12():
    s = func_3()
    s = list(s)
    l = []
    n = len(s)
    flag = 0
    (a, x) = (0, 0)
    if s.count('a') == n:
        func_1(''.join(s))
        exit()
    for i in range(len(s)):
        if s[i] != 'a':
            x += 1
            l.append(s[i])
            if x + i + 1 == n:
                if s[:i + 1] + l == s:
                    func_1(''.join(s[:i + 1]))
                    flag = 1
                    exit()
        else:
            a += 1
    func_1(':(')
''' 

 Output hints for function12:  The function `func_12` does not accept any parameters. It generates a string `s` from a previous function call `func_3()`, which is guaranteed to consist of lowercase English letters. The function then processes this string to determine if it meets specific conditions:

1. If the string `s` consists entirely of the character 'a', the function calls `func_1` with the string `s` and exits the program.
2. If the string `s` contains a prefix such that appending all non-'a' characters from `s` to this prefix reconstructs `s`, the function calls `func_1` with this prefix and exits the program.
3. If neither of the above conditions is met, the function calls `func_1` with the string `':('`.

In all cases, the function `func_1` is called exactly once, and the program exits immediately after the call. The final state of the program is that `func_1` has been called with one of the three possible strings: the original string `s` (if all characters are 'a'), a prefix of `s` (if the condition involving non-'a' characters is met), or `':('` (if neither condition is met).



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.