
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Carousel Boutique is busy again! Rarity has decided to visit the pony ball and she surely needs a new dress, because going out in the same dress several times is a sign of bad manners. First of all, she needs a dress pattern, which she is going to cut out from the rectangular piece of the multicolored fabric.

The piece of the multicolored fabric consists of n × m separate square scraps. Since Rarity likes dresses in style, a dress pattern must only include scraps sharing the same color. A dress pattern must be the square, and since Rarity is fond of rhombuses, the sides of a pattern must form a 45^{\circ} angle with sides of a piece of fabric (that way it will be resembling the traditional picture of a rhombus).

Examples of proper dress patterns: <image> Examples of improper dress patterns: <image> The first one consists of multi-colored scraps, the second one goes beyond the bounds of the piece of fabric, the third one is not a square with sides forming a 45^{\circ} angle with sides of the piece of fabric.

Rarity wonders how many ways to cut out a dress pattern that satisfies all the conditions that do exist. Please help her and satisfy her curiosity so she can continue working on her new masterpiece!

Input

The first line contains two integers n and m (1 ≤ n, m ≤ 2000). Each of the next n lines contains m characters: lowercase English letters, the j-th of which corresponds to scrap in the current line and in the j-th column. Scraps having the same letter share the same color, scraps having different letters have different colors.

Output

Print a single integer: the number of ways to cut out a dress pattern to satisfy all of Rarity's conditions.

Examples

Input


3 3
aaa
aaa
aaa


Output


10


Input


3 4
abab
baba
abab


Output


12


Input


5 5
zbacg
baaac
aaaaa
eaaad
weadd


Output


31

Note

In the first example, all the dress patterns of size 1 and one of size 2 are satisfactory.

In the second example, only the dress patterns of size 1 are satisfactory.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import sys
from atexit import register

if sys.version_info[0] < 3:
    from io import BytesIO as stream
else:
    from io import StringIO as stream
sys.stdin = stream(sys.stdin.read())
input = lambda : sys.stdin.readline().rstrip('\r\n')
sys.stdout = stream()
register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
if __name__ == '__main__':
    print(func_3())

#Function 1:
#State of the program right berfore the function call: None. This function does not take any parameters and is independent of the problem's main logic. It simply reads an integer from the standard input.
def func_1():
    return int(input())
    #The program returns an integer read from the standard input.

#Function 2:
#State of the program right berfore the function call: None of the variables in the function signature are used, but the function is expected to read input that can be split into integers.
def func_2():
    return list(map(int, input().split(' ')))
    #The program returns a list of integers obtained by splitting the input string on spaces and converting each segment into an integer.

#Function 3:
#State of the program right berfore the function call: n and m are positive integers representing the dimensions of the fabric, where 1 ≤ n, m ≤ 2000. table is a list of n strings, each of length m, consisting of lowercase English letters, representing the colors of the scraps.
def func_3():
    n, m = func_2()
    table = []
    for _ in range(n):
        table.append(input())
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list containing `n` user inputs. If `n` is 0, `table` remains an empty list.
    top_left = create_table()
    top_right = create_table()
    bottom_left = create_table()
    bottom_right = create_table()
    for i in range(n):
        for j in range(m):
            if i > 0 and j > 0 and table[i - 1][j] == table[i][j - 1] == table[i][j]:
                top_left[i][j] = min(top_left[i - 1][j], top_left[i][j - 1]) + 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list containing `n` user inputs (if `n` is 0, `table` remains an empty list), `top_left` is a table where for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i > 0 and j > 0 and (table[i - 1][j] == table[i][j - 1] == table[i][j])`, then `top_left[i][j]` is updated to `min(top_left[i - 1][j], top_left[i][j - 1]) + 1`; otherwise, `top_left[i][j]` remains unchanged, `top_right` is the value returned by `create_table()`, `bottom_left` is the value returned by `create_table()`, `bottom_right` is the value returned by `create_table()`
    for i in range(n):
        for j in range(m - 1, -1, -1):
            if i > 0 and j < m - 1 and table[i - 1][j] == table[i][j + 1] == table[i][j
                ]:
                top_right[i][j] = min(top_right[i - 1][j], top_right[i][j + 1]) + 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list containing `n` user inputs (or remains an empty list if `n` is 0). `top_left` is a table where for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i > 0 and j > 0 and (table[i - 1][j] == table[i][j - 1] == table[i][j])`, then `top_left[i][j]` is updated to `min(top_left[i - 1][j], top_left[i][j - 1]) + 1`; otherwise, `top_left[i][j]` remains unchanged. `top_right` is a table where for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i > 0 and j < m - 1 and (table[i - 1][j] == table[i][j + 1] == table[i][j])`, then `top_right[i][j]` is updated to `min(top_right[i - 1][j], top_right[i][j + 1]) + 1`; otherwise, `top_right[i][j]` remains unchanged. `bottom_left` and `bottom_right` remain as the values returned by `create_table()`.
    for i in range(n - 1, -1, -1):
        for j in range(m):
            if i < n - 1 and j > 0 and table[i + 1][j] == table[i][j - 1] == table[i][j
                ]:
                bottom_left[i][j] = min(bottom_left[i + 1][j], bottom_left[i][j - 1]
                    ) + 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list containing `n` user inputs (or remains an empty list if `n` is 0). `top_left` and `top_right` are tables with specific conditions based on `table`. `bottom_left` and `bottom_right` are initialized by `create_table()`. After the loop finishes, for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i < n - 1` and `j > 0` and `table[i + 1][j] == table[i][j - 1] == table[i][j]`, then `bottom_left[i][j]` is set to `min(bottom_left[i + 1][j], bottom_left[i][j - 1]) + 1`. If the loop does not execute (i.e., if `n` is 0 or `m` is 0), then `bottom_left` remains as initialized by `create_table()`.
    for i in range(n - 1, -1, -1):
        for j in range(m - 1, -1, -1):
            if i < n - 1 and j < m - 1 and table[i + 1][j] == table[i][j + 1] == table[
                i][j]:
                bottom_right[i][j] = min(bottom_right[i + 1][j], bottom_right[i][j + 1]
                    ) + 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list of `n` user inputs (or an empty list if `n` is 0). `bottom_right` is updated such that for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i < n - 1` and `j < m - 1` and `table[i + 1][j] == table[i][j + 1] == table[i][j]`, then `bottom_right[i][j]` is `min(bottom_right[i + 1][j], bottom_right[i][j + 1]) + 1`. If `n` is 0 or `m` is 0, `bottom_right` remains as initialized by `create_table()`.
    answer = 0
    for i in range(n):
        for j in range(m):
            answer += min(top_left[i][j], top_right[i][j], bottom_left[i][j],
                bottom_right[i][j])
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list of `n` user inputs (or an empty list if `n` is 0), `bottom_right` is updated as described in the initial state, `answer` is the sum of the minimum values of `top_left[i][j]`, `top_right[i][j]`, `bottom_left[i][j]`, and `bottom_right[i][j]` for each `i` from 0 to `n-1` and for each `j` from 0 to `m-1`.
    return answer
    #The program returns the sum of the minimum values of `top_left[i][j]`, `top_right[i][j]`, `bottom_left[i][j]`, and `bottom_right[i][j]` for each `i` from 0 to `n-1` and for each `j` from 0 to `m-1`. Here, `n` is a non-negative integer, `m` is the second value returned by `func_2()`, and `bottom_right` is updated as described in the initial state.

#Function 4:
#State of the program right berfore the function call: m and n are positive integers representing the dimensions of the table to be created.
def create_table():
    return [[(1) for _ in range(m)] for _ in range(n)]
    #The program returns a list of lists, where each inner list has `m` elements, all set to 1, and there are `n` such inner lists.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
