
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Carousel Boutique is busy again! Rarity has decided to visit the pony ball and she surely needs a new dress, because going out in the same dress several times is a sign of bad manners. First of all, she needs a dress pattern, which she is going to cut out from the rectangular piece of the multicolored fabric.

The piece of the multicolored fabric consists of n × m separate square scraps. Since Rarity likes dresses in style, a dress pattern must only include scraps sharing the same color. A dress pattern must be the square, and since Rarity is fond of rhombuses, the sides of a pattern must form a 45^{\circ} angle with sides of a piece of fabric (that way it will be resembling the traditional picture of a rhombus).

Examples of proper dress patterns: <image> Examples of improper dress patterns: <image> The first one consists of multi-colored scraps, the second one goes beyond the bounds of the piece of fabric, the third one is not a square with sides forming a 45^{\circ} angle with sides of the piece of fabric.

Rarity wonders how many ways to cut out a dress pattern that satisfies all the conditions that do exist. Please help her and satisfy her curiosity so she can continue working on her new masterpiece!

Input

The first line contains two integers n and m (1 ≤ n, m ≤ 2000). Each of the next n lines contains m characters: lowercase English letters, the j-th of which corresponds to scrap in the current line and in the j-th column. Scraps having the same letter share the same color, scraps having different letters have different colors.

Output

Print a single integer: the number of ways to cut out a dress pattern to satisfy all of Rarity's conditions.

Examples

Input


3 3
aaa
aaa
aaa


Output


10


Input


3 4
abab
baba
abab


Output


12


Input


5 5
zbacg
baaac
aaaaa
eaaad
weadd


Output


31

Note

In the first example, all the dress patterns of size 1 and one of size 2 are satisfactory.

In the second example, only the dress patterns of size 1 are satisfactory.
Program:
```
from __future__ import division, print_function
import sys
from atexit import register
#Function 1:
def func_1():
    return int(input())

#Function 2:
def func_2():
    return list(map(int, input().split(' ')))

#Function 3:
def func_3():
    (n, m) = func_2()
    table = []
    for _ in range(n):
        table.append(input())

    top_left = create_table()
    top_right = create_table()
    bottom_left = create_table()
    bottom_right = create_table()
    for i in range(n):
        for j in range(m):
            if i > 0 and j > 0 and (table[i - 1][j] == table[i][j - 1] == table[i][j]):
                top_left[i][j] = min(top_left[i - 1][j], top_left[i][j - 1]) + 1
    for i in range(n):
        for j in range(m - 1, -1, -1):
            if i > 0 and j < m - 1 and (table[i - 1][j] == table[i][j + 1] == table[i][j]):
                top_right[i][j] = min(top_right[i - 1][j], top_right[i][j + 1]) + 1
    for i in range(n - 1, -1, -1):
        for j in range(m):
            if i < n - 1 and j > 0 and (table[i + 1][j] == table[i][j - 1] == table[i][j]):
                bottom_left[i][j] = min(bottom_left[i + 1][j], bottom_left[i][j - 1]) + 1
    for i in range(n - 1, -1, -1):
        for j in range(m - 1, -1, -1):
            if i < n - 1 and j < m - 1 and (table[i + 1][j] == table[i][j + 1] == table[i][j]):
                bottom_right[i][j] = min(bottom_right[i + 1][j], bottom_right[i][j + 1]) + 1
    answer = 0
    for i in range(n):
        for j in range(m):
            answer += min(top_left[i][j], top_right[i][j], bottom_left[i][j], bottom_right[i][j])
    return answer

#Function 4:
def create_table():
    return [[1 for _ in range(m)] for _ in range(n)]


```
Original Assessment: Correctness: **True**

Explanation: The program appears to correctly implement the logic required to count the number of valid dress patterns that meet Rarity's conditions. It constructs four dynamic programming tables (`top_left`, `top_right`, `bottom_left`, `bottom_right`) to track the maximum size of a valid square pattern centered at each cell, considering the 45° angle constraint. The final count of valid patterns is derived by taking the minimum value among these four tables for each cell, which ensures that the pattern is a square and fits within the fabric. The program handles edge cases such as single-cell patterns and ensures that the pattern remains within the bounds of the fabric. Given the problem constraints and the examples provided, the program seems to handle all potential cases correctly.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import sys
from atexit import register

if sys.version_info[0] < 3:
    from io import BytesIO as stream
else:
    from io import StringIO as stream
sys.stdin = stream(sys.stdin.read())
input = lambda : sys.stdin.readline().rstrip('\r\n')
sys.stdout = stream()
register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
if __name__ == '__main__':
    print(func_3())

#Function 1:
#State of the program right berfore the function call: None. This function does not take any parameters and is independent of the problem's main logic. It simply reads an integer from the standard input.
def func_1():
    return int(input())
    #The program returns an integer read from the standard input.

#Function 2:
#State of the program right berfore the function call: None of the variables in the function signature are used, but the function is expected to read input that can be split into integers.
def func_2():
    return list(map(int, input().split(' ')))
    #The program returns a list of integers obtained by splitting the input string on spaces and converting each segment into an integer.

#Function 3:
#State of the program right berfore the function call: n and m are positive integers representing the dimensions of the fabric, where 1 ≤ n, m ≤ 2000. table is a list of n strings, each of length m, consisting of lowercase English letters, representing the colors of the scraps.
def func_3():
    n, m = func_2()
    table = []
    for _ in range(n):
        table.append(input())
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list containing `n` user inputs. If `n` is 0, `table` remains an empty list.
    top_left = create_table()
    top_right = create_table()
    bottom_left = create_table()
    bottom_right = create_table()
    for i in range(n):
        for j in range(m):
            if i > 0 and j > 0 and table[i - 1][j] == table[i][j - 1] == table[i][j]:
                top_left[i][j] = min(top_left[i - 1][j], top_left[i][j - 1]) + 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list containing `n` user inputs (if `n` is 0, `table` remains an empty list), `top_left` is a table where for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i > 0 and j > 0 and (table[i - 1][j] == table[i][j - 1] == table[i][j])`, then `top_left[i][j]` is updated to `min(top_left[i - 1][j], top_left[i][j - 1]) + 1`; otherwise, `top_left[i][j]` remains unchanged, `top_right` is the value returned by `create_table()`, `bottom_left` is the value returned by `create_table()`, `bottom_right` is the value returned by `create_table()`
    for i in range(n):
        for j in range(m - 1, -1, -1):
            if i > 0 and j < m - 1 and table[i - 1][j] == table[i][j + 1] == table[i][j
                ]:
                top_right[i][j] = min(top_right[i - 1][j], top_right[i][j + 1]) + 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list containing `n` user inputs (or remains an empty list if `n` is 0). `top_left` is a table where for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i > 0 and j > 0 and (table[i - 1][j] == table[i][j - 1] == table[i][j])`, then `top_left[i][j]` is updated to `min(top_left[i - 1][j], top_left[i][j - 1]) + 1`; otherwise, `top_left[i][j]` remains unchanged. `top_right` is a table where for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i > 0 and j < m - 1 and (table[i - 1][j] == table[i][j + 1] == table[i][j])`, then `top_right[i][j]` is updated to `min(top_right[i - 1][j], top_right[i][j + 1]) + 1`; otherwise, `top_right[i][j]` remains unchanged. `bottom_left` and `bottom_right` remain as the values returned by `create_table()`.
    for i in range(n - 1, -1, -1):
        for j in range(m):
            if i < n - 1 and j > 0 and table[i + 1][j] == table[i][j - 1] == table[i][j
                ]:
                bottom_left[i][j] = min(bottom_left[i + 1][j], bottom_left[i][j - 1]
                    ) + 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list containing `n` user inputs (or remains an empty list if `n` is 0). `top_left` and `top_right` are tables with specific conditions based on `table`. `bottom_left` and `bottom_right` are initialized by `create_table()`. After the loop finishes, for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i < n - 1` and `j > 0` and `table[i + 1][j] == table[i][j - 1] == table[i][j]`, then `bottom_left[i][j]` is set to `min(bottom_left[i + 1][j], bottom_left[i][j - 1]) + 1`. If the loop does not execute (i.e., if `n` is 0 or `m` is 0), then `bottom_left` remains as initialized by `create_table()`.
    for i in range(n - 1, -1, -1):
        for j in range(m - 1, -1, -1):
            if i < n - 1 and j < m - 1 and table[i + 1][j] == table[i][j + 1] == table[
                i][j]:
                bottom_right[i][j] = min(bottom_right[i + 1][j], bottom_right[i][j + 1]
                    ) + 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list of `n` user inputs (or an empty list if `n` is 0). `bottom_right` is updated such that for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i < n - 1` and `j < m - 1` and `table[i + 1][j] == table[i][j + 1] == table[i][j]`, then `bottom_right[i][j]` is `min(bottom_right[i + 1][j], bottom_right[i][j + 1]) + 1`. If `n` is 0 or `m` is 0, `bottom_right` remains as initialized by `create_table()`.
    answer = 0
    for i in range(n):
        for j in range(m):
            answer += min(top_left[i][j], top_right[i][j], bottom_left[i][j],
                bottom_right[i][j])
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list of `n` user inputs (or an empty list if `n` is 0), `bottom_right` is updated as described in the initial state, `answer` is the sum of the minimum values of `top_left[i][j]`, `top_right[i][j]`, `bottom_left[i][j]`, and `bottom_right[i][j]` for each `i` from 0 to `n-1` and for each `j` from 0 to `m-1`.
    return answer
    #The program returns the sum of the minimum values of `top_left[i][j]`, `top_right[i][j]`, `bottom_left[i][j]`, and `bottom_right[i][j]` for each `i` from 0 to `n-1` and for each `j` from 0 to `m-1`. Here, `n` is a non-negative integer, `m` is the second value returned by `func_2()`, and `bottom_right` is updated as described in the initial state.

#Function 4:
#State of the program right berfore the function call: m and n are positive integers representing the dimensions of the table to be created.
def create_table():
    return [[(1) for _ in range(m)] for _ in range(n)]
    #The program returns a list of lists, where each inner list has `m` elements, all set to 1, and there are `n` such inner lists.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
