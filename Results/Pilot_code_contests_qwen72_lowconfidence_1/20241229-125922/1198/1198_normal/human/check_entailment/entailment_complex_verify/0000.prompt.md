
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Carousel Boutique is busy again! Rarity has decided to visit the pony ball and she surely needs a new dress, because going out in the same dress several times is a sign of bad manners. First of all, she needs a dress pattern, which she is going to cut out from the rectangular piece of the multicolored fabric.

The piece of the multicolored fabric consists of n × m separate square scraps. Since Rarity likes dresses in style, a dress pattern must only include scraps sharing the same color. A dress pattern must be the square, and since Rarity is fond of rhombuses, the sides of a pattern must form a 45^{\circ} angle with sides of a piece of fabric (that way it will be resembling the traditional picture of a rhombus).

Examples of proper dress patterns: <image> Examples of improper dress patterns: <image> The first one consists of multi-colored scraps, the second one goes beyond the bounds of the piece of fabric, the third one is not a square with sides forming a 45^{\circ} angle with sides of the piece of fabric.

Rarity wonders how many ways to cut out a dress pattern that satisfies all the conditions that do exist. Please help her and satisfy her curiosity so she can continue working on her new masterpiece!

Input

The first line contains two integers n and m (1 ≤ n, m ≤ 2000). Each of the next n lines contains m characters: lowercase English letters, the j-th of which corresponds to scrap in the current line and in the j-th column. Scraps having the same letter share the same color, scraps having different letters have different colors.

Output

Print a single integer: the number of ways to cut out a dress pattern to satisfy all of Rarity's conditions.

Examples

Input


3 3
aaa
aaa
aaa


Output


10


Input


3 4
abab
baba
abab


Output


12


Input


5 5
zbacg
baaac
aaaaa
eaaad
weadd


Output


31

Note

In the first example, all the dress patterns of size 1 and one of size 2 are satisfactory.

In the second example, only the dress patterns of size 1 are satisfactory.
Program:
```
from __future__ import division, print_function
import sys
from atexit import register
#Function 1:
def func_1():
    return int(input())

#Function 2:
def func_2():
    return list(map(int, input().split(' ')))

#Function 3:
def func_3():
    (n, m) = func_2()
    table = []
    for _ in range(n):
        table.append(input())

    top_left = create_table()
    top_right = create_table()
    bottom_left = create_table()
    bottom_right = create_table()
    for i in range(n):
        for j in range(m):
            if i > 0 and j > 0 and (table[i - 1][j] == table[i][j - 1] == table[i][j]):
                top_left[i][j] = min(top_left[i - 1][j], top_left[i][j - 1]) + 1
    for i in range(n):
        for j in range(m - 1, -1, -1):
            if i > 0 and j < m - 1 and (table[i - 1][j] == table[i][j + 1] == table[i][j]):
                top_right[i][j] = min(top_right[i - 1][j], top_right[i][j + 1]) + 1
    for i in range(n - 1, -1, -1):
        for j in range(m):
            if i < n - 1 and j > 0 and (table[i + 1][j] == table[i][j - 1] == table[i][j]):
                bottom_left[i][j] = min(bottom_left[i + 1][j], bottom_left[i][j - 1]) + 1
    for i in range(n - 1, -1, -1):
        for j in range(m - 1, -1, -1):
            if i < n - 1 and j < m - 1 and (table[i + 1][j] == table[i][j + 1] == table[i][j]):
                bottom_right[i][j] = min(bottom_right[i + 1][j], bottom_right[i][j + 1]) + 1
    answer = 0
    for i in range(n):
        for j in range(m):
            answer += min(top_left[i][j], top_right[i][j], bottom_left[i][j], bottom_right[i][j])
    return answer

#Function 4:
def create_table():
    return [[1 for _ in range(m)] for _ in range(n)]


```
Original Assessment: Correctness: **True**.

Explanation:
The program appears to correctly implement the solution for counting the number of ways to cut out a dress pattern that satisfies all of Rarity's conditions. Here’s a detailed breakdown of why the program is correct:

1. **Input Handling**: The program reads the dimensions of the fabric (`n` and `m`) and the fabric itself, storing it in a 2D list called `table`.

2. **Dynamic Programming Tables**: Four dynamic programming tables (`top_left`, `top_right`, `bottom_left`, `bottom_right`) are created to keep track of the maximum size of a square pattern that can be formed starting from each cell in the fabric, considering the 45-degree angle requirement.

3. **Filling DP Tables**:
   - `top_left[i][j]`: The maximum size of a square pattern starting from cell `(i, j)` and extending towards the top-left direction.
   - `top_right[i][j]`: The maximum size of a square pattern starting from cell `(i, j)` and extending towards the top-right direction.
   - `bottom_left[i][j]`: The maximum size of a square pattern starting from cell `(i, j)` and extending towards the bottom-left direction.
   - `bottom_right[i][j]`: The maximum size of a square pattern starting from cell `(i, j)` and extending towards the bottom-right direction.

   These tables are filled by iterating through the fabric and checking the conditions for each cell.

4. **Counting Valid Patterns**: After filling the DP tables, the program iterates through each cell and calculates the minimum value from the four DP tables for that cell. This minimum value represents the size of the largest valid square pattern that can be formed starting from that cell. The total number of valid patterns is then summed up.

5. **Output**: The final answer is printed, which is the total number of valid patterns.

The program handles all edge cases and constraints mentioned in the problem description. It ensures that the patterns are squares with sides forming a 45-degree angle with the sides of the fabric, and that they consist of the same color. Therefore, the program is correct for all potential cases.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import sys
from atexit import register

if sys.version_info[0] < 3:
    from io import BytesIO as stream
else:
    from io import StringIO as stream
sys.stdin = stream(sys.stdin.read())
input = lambda : sys.stdin.readline().rstrip('\r\n')
sys.stdout = stream()
register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
if __name__ == '__main__':
    print(func_3())

#Function 1:
#State of the program right berfore the function call: None. This function does not take any parameters and is independent of the problem's main logic. It simply reads an integer from the standard input.
def func_1():
    return int(input())
    #The program returns an integer read from the standard input.
#Overall this is what the function does:The function `func_1` reads an integer from the standard input and returns it. The function does not accept any parameters and does not modify any external state. The final state of the program after the function concludes is that an integer value, which was provided by the user via standard input, is returned. Potential edge cases include scenarios where the user inputs a non-integer value, which would result in a `ValueError` being raised. Additionally, if the standard input is closed or unavailable, the function will raise an `EOFError`.

#Function 2:
#State of the program right berfore the function call: None of the variables in the function signature are used, but the function is expected to read input that can be split into integers.
def func_2():
    return list(map(int, input().split(' ')))
    #The program returns a list of integers obtained by splitting the input string on spaces and converting each segment into an integer.
#Overall this is what the function does:The function `func_2` reads a single line of input from the user, splits the input string by spaces, converts each resulting substring into an integer, and returns a list of these integers. If the input contains non-integer values, a `ValueError` will be raised. If the input is empty or consists only of spaces, an empty list will be returned.

#Function 3:
#State of the program right berfore the function call: n and m are positive integers representing the dimensions of the fabric, where 1 ≤ n, m ≤ 2000. table is a list of n strings, each of length m, consisting of lowercase English letters, representing the colors of the scraps.
def func_3():
    n, m = func_2()
    table = []
    for _ in range(n):
        table.append(input())
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list containing `n` user inputs. If `n` is 0, `table` remains an empty list.
    top_left = create_table()
    top_right = create_table()
    bottom_left = create_table()
    bottom_right = create_table()
    for i in range(n):
        for j in range(m):
            if i > 0 and j > 0 and table[i - 1][j] == table[i][j - 1] == table[i][j]:
                top_left[i][j] = min(top_left[i - 1][j], top_left[i][j - 1]) + 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list containing `n` user inputs (if `n` is 0, `table` remains an empty list), `top_left` is a table where for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i > 0 and j > 0 and (table[i - 1][j] == table[i][j - 1] == table[i][j])`, then `top_left[i][j]` is updated to `min(top_left[i - 1][j], top_left[i][j - 1]) + 1`; otherwise, `top_left[i][j]` remains unchanged, `top_right` is the value returned by `create_table()`, `bottom_left` is the value returned by `create_table()`, `bottom_right` is the value returned by `create_table()`
    for i in range(n):
        for j in range(m - 1, -1, -1):
            if i > 0 and j < m - 1 and table[i - 1][j] == table[i][j + 1] == table[i][j
                ]:
                top_right[i][j] = min(top_right[i - 1][j], top_right[i][j + 1]) + 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list containing `n` user inputs (or remains an empty list if `n` is 0). `top_left` is a table where for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i > 0 and j > 0 and (table[i - 1][j] == table[i][j - 1] == table[i][j])`, then `top_left[i][j]` is updated to `min(top_left[i - 1][j], top_left[i][j - 1]) + 1`; otherwise, `top_left[i][j]` remains unchanged. `top_right` is a table where for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i > 0 and j < m - 1 and (table[i - 1][j] == table[i][j + 1] == table[i][j])`, then `top_right[i][j]` is updated to `min(top_right[i - 1][j], top_right[i][j + 1]) + 1`; otherwise, `top_right[i][j]` remains unchanged. `bottom_left` and `bottom_right` remain as the values returned by `create_table()`.
    for i in range(n - 1, -1, -1):
        for j in range(m):
            if i < n - 1 and j > 0 and table[i + 1][j] == table[i][j - 1] == table[i][j
                ]:
                bottom_left[i][j] = min(bottom_left[i + 1][j], bottom_left[i][j - 1]
                    ) + 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list containing `n` user inputs (or remains an empty list if `n` is 0). `top_left` and `top_right` are tables with specific conditions based on `table`. `bottom_left` and `bottom_right` are initialized by `create_table()`. After the loop finishes, for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i < n - 1` and `j > 0` and `table[i + 1][j] == table[i][j - 1] == table[i][j]`, then `bottom_left[i][j]` is set to `min(bottom_left[i + 1][j], bottom_left[i][j - 1]) + 1`. If the loop does not execute (i.e., if `n` is 0 or `m` is 0), then `bottom_left` remains as initialized by `create_table()`.
    for i in range(n - 1, -1, -1):
        for j in range(m - 1, -1, -1):
            if i < n - 1 and j < m - 1 and table[i + 1][j] == table[i][j + 1] == table[
                i][j]:
                bottom_right[i][j] = min(bottom_right[i + 1][j], bottom_right[i][j + 1]
                    ) + 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list of `n` user inputs (or an empty list if `n` is 0). `bottom_right` is updated such that for each `i` in the range `[0, n-1]` and `j` in the range `[0, m-1]`, if `i < n - 1` and `j < m - 1` and `table[i + 1][j] == table[i][j + 1] == table[i][j]`, then `bottom_right[i][j]` is `min(bottom_right[i + 1][j], bottom_right[i][j + 1]) + 1`. If `n` is 0 or `m` is 0, `bottom_right` remains as initialized by `create_table()`.
    answer = 0
    for i in range(n):
        for j in range(m):
            answer += min(top_left[i][j], top_right[i][j], bottom_left[i][j],
                bottom_right[i][j])
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `m` is the second value returned by `func_2()`, `table` is a list of `n` user inputs (or an empty list if `n` is 0), `bottom_right` is updated as described in the initial state, `answer` is the sum of the minimum values of `top_left[i][j]`, `top_right[i][j]`, `bottom_left[i][j]`, and `bottom_right[i][j]` for each `i` from 0 to `n-1` and for each `j` from 0 to `m-1`.
    return answer
    #The program returns the sum of the minimum values of `top_left[i][j]`, `top_right[i][j]`, `bottom_left[i][j]`, and `bottom_right[i][j]` for each `i` from 0 to `n-1` and for each `j` from 0 to `m-1`. Here, `n` is a non-negative integer, `m` is the second value returned by `func_2()`, and `bottom_right` is updated as described in the initial state.
#Overall this is what the function does:The function `func_3` processes a fabric represented by a grid of colors (a list of strings) and calculates a score based on the patterns of colors in the grid. Specifically, it initializes four auxiliary tables (`top_left`, `top_right`, `bottom_left`, `bottom_right`) to store the sizes of square patterns found in the fabric. These tables are updated based on the following conditions:

1. For each cell `(i, j)` in the grid:
   - If `i > 0` and `j > 0` and the colors of the cells `(i-1, j)`, `(i, j-1)`, and `(i, j)` are the same, `top_left[i][j]` is updated to `min(top_left[i-1][j], top_left[i][j-1]) + 1`.
   - If `i > 0` and `j < m-1` and the colors of the cells `(i-1, j)`, `(i, j+1)`, and `(i, j)` are the same, `top_right[i][j]` is updated to `min(top_right[i-1][j], top_right[i][j+1]) + 1`.
   - If `i < n-1` and `j > 0` and the colors of the cells `(i+1, j)`, `(i, j-1)`, and `(i, j)` are the same, `bottom_left[i][j]` is updated to `min(bottom_left[i+1][j], bottom_left[i][j-1]) + 1`.
   - If `i < n-1` and `j < m-1` and the colors of the cells `(i+1, j)`, `(i, j+1)`, and `(i, j)` are the same, `bottom_right[i][j]` is updated to `min(bottom_right[i+1][j], bottom_right[i][j+1]) + 1`.

2. After updating these tables, the function calculates the final score by summing the minimum values of `top_left[i][j]`, `top_right[i][j]`, `bottom_left[i][j]`, and `bottom_right[i][j]` for each cell `(i, j)` in the grid.

3. The function returns this score.

Edge Cases:
- If `n` is 0, the function returns 0 because there are no rows in the grid.
- If `m` is 0, the function also returns 0 because there are no columns in the grid.
- If the grid is empty (both `n` and `m` are 0), the function returns 0.
- If the grid contains only one row or one column, the function will not update the auxiliary tables for cells that do not have the required neighbors, and the score will be based on the initial values of these tables (which are typically initialized to 0).

Missing Functionality:
- The function assumes that the `create_table()` function initializes the auxiliary tables correctly. If `create_table()` does not initialize the tables properly, the function's behavior could be incorrect.
- The function does not handle invalid input (e.g., if `func_2()` returns invalid dimensions or if the input strings are not of the correct length). This could lead to runtime errors or incorrect results.

#Function 4:
#State of the program right berfore the function call: m and n are positive integers representing the dimensions of the table to be created.
def create_table():
    return [[(1) for _ in range(m)] for _ in range(n)]
    #The program returns a list of lists, where each inner list has `m` elements, all set to 1, and there are `n` such inner lists.
#Overall this is what the function does:The function `create_table` is intended to accept two parameters `m` and `n`, both positive integers, and return a list of lists where each inner list contains `m` elements set to 1, and there are `n` such inner lists. However, the function as written does not actually accept any parameters, which means it will result in a `NameError` when `m` and `n` are not defined in the global scope. If `m` and `n` are defined externally, the function will behave as described in the annotations. Therefore, the function should be modified to accept `m` and `n` as parameters to ensure it works correctly. After the function executes, assuming `m` and `n` are defined, it will return a 2D list (a list of lists) with `n` rows and `m` columns, where each element is 1.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
