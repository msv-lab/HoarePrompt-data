
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: So the Beautiful Regional Contest (BeRC) has come to an end! n students took part in the contest. The final standings are already known: the participant in the i-th place solved p_i problems. Since the participants are primarily sorted by the number of solved problems, then p_1 ≥ p_2 ≥ ... ≥ p_n.

Help the jury distribute the gold, silver and bronze medals. Let their numbers be g, s and b, respectively. Here is a list of requirements from the rules, which all must be satisfied:

  * for each of the three types of medals, at least one medal must be awarded (that is, g>0, s>0 and b>0); 
  * the number of gold medals must be strictly less than the number of silver and the number of bronze (that is, g<s and g<b, but there are no requirements between s and b); 
  * each gold medalist must solve strictly more problems than any awarded with a silver medal; 
  * each silver medalist must solve strictly more problems than any awarded a bronze medal; 
  * each bronze medalist must solve strictly more problems than any participant not awarded a medal; 
  * the total number of medalists g+s+b should not exceed half of all participants (for example, if n=21, then you can award a maximum of 10 participants, and if n=26, then you can award a maximum of 13 participants). 



The jury wants to reward with medals the total maximal number participants (i.e. to maximize g+s+b) so that all of the items listed above are fulfilled. Help the jury find such a way to award medals.

Input

The first line of the input contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the input. Then t test cases follow.

The first line of a test case contains an integer n (1 ≤ n ≤ 4⋅10^5) — the number of BeRC participants. The second line of a test case contains integers p_1, p_2, ..., p_n (0 ≤ p_i ≤ 10^6), where p_i is equal to the number of problems solved by the i-th participant from the final standings. The values p_i are sorted in non-increasing order, i.e. p_1 ≥ p_2 ≥ ... ≥ p_n.

The sum of n over all test cases in the input does not exceed 4⋅10^5.

Output

Print t lines, the j-th line should contain the answer to the j-th test case.

The answer consists of three non-negative integers g, s, b.

  * Print g=s=b=0 if there is no way to reward participants with medals so that all requirements from the statement are satisfied at the same time. 
  * Otherwise, print three positive numbers g, s, b — the possible number of gold, silver and bronze medals, respectively. The sum of g+s+b should be the maximum possible. If there are several answers, print any of them. 

Example

Input


5
12
5 4 4 3 2 2 1 1 1 1 1 1
4
4 3 2 1
1
1000000
20
20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
32
64 64 63 58 58 58 58 58 37 37 37 37 34 34 28 28 28 28 28 28 24 24 19 17 17 17 17 16 16 16 16 11


Output


1 2 3
0 0 0
0 0 0
2 5 3
2 6 6

Note

In the first test case, it is possible to reward 1 gold, 2 silver and 3 bronze medals. In this case, the participant solved 5 tasks will be rewarded with the gold medal, participants solved 4 tasks will be rewarded with silver medals, participants solved 2 or 3 tasks will be rewarded with bronze medals. Participants solved exactly 1 task won't be rewarded. It's easy to see, that in this case, all conditions are satisfied and it is possible to reward participants in this way. It is impossible to give more than 6 medals because the number of medals should not exceed half of the number of participants. The answer 1, 3, 2 is also correct in this test case.

In the second and third test cases, it is impossible to reward medals, because at least one medal of each type should be given, but the number of medals should not exceed half of the number of participants.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import os
import sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_1()

#Function 1:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases, n is a positive integer representing the number of participants in each test case, and the input for each test case includes a line with n space-separated integers representing the number of problems solved by each participant in non-increasing order.
def func_1():
    t = int(input())
    for _ in range(t):
        n = int(input())
        
        g, s, b = 0, 0, 0
        
        l = 0
        
        p = -1
        
        for i, j in enumerate(map(int, input().split())):
            if i > n // 2:
                break
            if p != j:
                if g == 0:
                    g = l
                elif s <= g:
                    s += l
                else:
                    b += l
                l = 0
            l += 1
            p = j
        
        if g == 0 or s == 0 or b == 0 or g >= s or g >= b:
            func_2(0, 0, 0)
        else:
            func_2(g, s, b)
        
    #State of the program after the  for loop has been executed: `t` is a non-negative integer, `_` is in the range [0, t-1], `n` is a positive integer representing the number of participants in each test case, `g` is the length of the longest sequence of consecutive identical integers encountered up to the midpoint of the input for the last test case, `s` is the sum of the lengths of sequences of consecutive identical integers where the length is less than or equal to `g` for the last test case, `b` is the sum of the lengths of sequences of consecutive identical integers where the length is greater than `g` for the last test case, `l` is 0, `p` is the last integer processed (up to the midpoint) for the last test case, `i` is the index of the last integer processed (up to the midpoint) for the last test case, `j` is the last integer processed for the last test case. If `g == 0` or `s == 0` or `b == 0` or `g >= s` or `g >= b` for any test case, `func_2(0, 0, 0)` is called, otherwise `func_2(g, s, b)` is called with the respective values of `g`, `s`, and `b` for the last test case.

#Function 2:
#State of the program right berfore the function call: args is a tuple containing any number of arguments of any type, and kwargs is a dictionary that can contain the keys 'sep', 'file', 'end', and 'flush'. 'sep' is a string used to separate the arguments when printed, 'file' is a stream object to which the output will be written, 'end' is a string appended after the last value, and 'flush' is a boolean indicating whether to forcibly flush the stream.
def func_2():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a tuple containing any number of arguments of any type, `kwargs` is a dictionary that can contain the keys 'end' and 'flush', `sep` is a string equal to the value of 'sep' from `kwargs` or ' ' if 'sep' was not in `kwargs`, `file` is a stream object equal to the value of 'file' from `kwargs` or `sys.stdout` if 'file' was not in `kwargs`, `at_start` is `False` if `args` is not empty, otherwise `at_start` remains `True`. The string representations of all elements in `args` have been written to `file`, separated by `sep` if there are multiple elements.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a tuple containing any number of arguments of any type, `kwargs` is a dictionary that may or may not contain the key 'flush' but does not contain the key 'end', `sep` is a string equal to the value of 'sep' from `kwargs` or ' ' if 'sep' was not in `kwargs`, `file` is a stream object equal to the value of 'file' from `kwargs` or `sys.stdout` if 'file' was not in `kwargs`, `at_start` is `False` if `args` is not empty, otherwise `at_start` remains `True`. If 'flush' is present in `kwargs`, it is removed, and `file` is flushed. Otherwise, `kwargs` remains unchanged and `file` is not flushed.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
