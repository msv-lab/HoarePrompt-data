
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: SmallR is an archer. SmallR is taking a match of archer with Zanoes. They try to shoot in the target in turns, and SmallR shoots first. The probability of shooting the target each time is <image> for SmallR while <image> for Zanoes. The one who shoots in the target first should be the winner.

Output the probability that SmallR will win the match.

Input

A single line contains four integers <image>.

Output

Print a single real number, the probability that SmallR will win the match.

The answer will be considered correct if the absolute or relative error doesn't exceed 10 - 6.

Examples

Input

1 2 1 2


Output

0.666666666667
Program:
```
from __future__ import division
from bisect import *
from fractions import Fraction
import sys
from math import *
from fractions import *
import io
import re
from datetime import date
#Function 1:
def func_1(delimiter=' '):
    return map(int, raw_input().split(delimiter))

#Function 2:
def func_2(delimiter=' '):
    return raw_input().split(delimiter)

#Function 3:
def func_3(delimiter=' '):
    return map(float, raw_input().split(delimiter))

#Function 4:
def func_4(a, x):
    """Locate the leftmost value exactly equal to x"""
    i = bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    raise ValueError

#Function 5:
def func_5(a, x):
    """Find rightmost value less than x"""
    i = bisect_left(a, x)
    if i:
        return a[i - 1]
    raise ValueError

#Function 6:
def func_6(a, x):
    """Find rightmost value less than or equal to x"""
    i = bisect_right(a, x)
    if i:
        return a[i - 1]
    raise ValueError

#Function 7:
def func_7(a, x):
    """Find leftmost value greater than x"""
    i = bisect_right(a, x)
    if i != len(a):
        return a[i]
    raise ValueError

#Function 8:
def func_8(a, x):
    """Find leftmost item greater than or equal to x"""
    i = bisect_left(a, x)
    if i != len(a):
        return a[i]
    raise ValueError

#Function 9:
def func_9(a, x, left, right):
    while left <= right:
        mid = (left + right) // 2
        if a[mid] == x:
            return mid
        elif a[mid] < x:
            left = mid + 1
        elif a[mid] > x:
            right = mid - 1
        pass
    return -1
    pass

#Function 10:
def func_10(format, *args):
    """Format args with the first argument as format string, and write.
	Return the last arg, or format itself if there are no args."""
    sys.stdout.write(str(format) % args)


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not actually solve the problem described. It includes several functions that are not used in the context of the problem. The problem requires calculating the probability that SmallR wins the match, but the program does not contain any logic to perform this calculation. Specifically, the program lacks:

1. Reading the input values (a, b, c, d).
2. Calculating the probabilities for SmallR and Zanoes.
3. Computing the probability that SmallR wins the match.
4. Printing the result with the required precision.

Since the program does not address the core requirements of the problem, it is incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division
from bisect import *
from fractions import Fraction
import sys
from math import *
from fractions import *
import io
import re
from datetime import date

INF = 987654321987654321987654321
if __name__ == '__main__':
    (a, b, c, d) = func_1()
    prob_a = a / b
    prob_b = c / d
    prev = 0
    now = 0
    now += prob_a
    acc = (1 - prob_a) * (1 - prob_b)
    ii = 0
    while now - prev > 1e-07:
        prev = now
        ii += 1
        now += acc * prob_a
        acc *= (1 - prob_a) * (1 - prob_b)
        pass
    func_10('%.6f\n', now)
    pass

#Function 1:
#State of the program right berfore the function call: delimiter is a string used to split the input, defaulting to a single space (' ').
def func_1(delimiter):
    return map(int, raw_input().split(delimiter))
    #The program returns a map object that converts each element from the split input (split by the delimiter, which defaults to a single space) into an integer. The exact integers depend on the user's input.
#Overall this is what the function does:The function `func_1` accepts a parameter `delimiter`, which is a string used to split the input, defaulting to a single space (' '). It reads a line of input from the user, splits the input using the specified delimiter, and returns a map object that converts each element from the split input into an integer. The exact integers depend on the user's input. If the user inputs non-integer values, the `int` conversion will raise a `ValueError`. If no input is provided, the function will block and wait for user input. After the function concludes, the program will have a map object containing the converted integers, or it will raise an exception if the conversion fails.

#Function 2:
#State of the program right berfore the function call: delimiter is a string used to split the input, defaulting to a single space (' ').
def func_2(delimiter):
    return raw_input().split(delimiter)
    #The program returns a list of strings obtained by splitting the user input using the delimiter, which defaults to a single space (' ').
#Overall this is what the function does:The function `func_2` accepts a parameter `delimiter`, which is a string used to split the user input, defaulting to a single space (' '). It reads user input from the standard input (stdin) and returns a list of strings obtained by splitting the input using the specified delimiter. If the user input is empty or consists only of the delimiter, the function will return an empty list or a list containing an empty string, respectively. If the delimiter is an empty string, the function will raise a `ValueError`.

#Function 3:
#State of the program right berfore the function call: delimiter is a string used to split the input, defaulting to a single space (' ').
def func_3(delimiter):
    return map(float, raw_input().split(delimiter))
    #The program returns a map object which is an iterator over the elements of the input string (provided by the user) split by the delimiter (defaulting to a single space), with each element converted to a float.
#Overall this is what the function does:The function `func_3` accepts a parameter `delimiter` (a string, defaulting to a single space ' ') and returns a map object that iterates over the elements of the input string (provided by the user via `raw_input()`) split by the `delimiter`, with each element converted to a float. If the input string contains non-numeric values, the conversion to float will raise a `ValueError`. If the input string is empty, the returned map object will be empty.

#Function 4:
#State of the program right berfore the function call: a is a sorted list of elements, and x is an element of the same type as the elements in a.
def func_4(a, x):
    """Locate the leftmost value exactly equal to x"""
    i = bisect_left(a, x)
    if (i != len(a) and a[i] == x) :
        return i
        #The program returns the index `i` of the first occurrence of `x` in the sorted list `a`.
    #State of the program after the if block has been executed: *`a` is a sorted list of elements, `x` is an element of the same type as the elements in `a`, `i` is the index of the first occurrence of `x` in `a` or the insertion point to maintain sorted order, and either `i` is equal to the length of `a` or `a[i]` is not equal to `x`
    raise ValueError
#Overall this is what the function does:The function `func_4` accepts a sorted list `a` and an element `x`. It returns the index `i` of the first occurrence of `x` in the sorted list `a`. If `x` is not found in the list, the function raises a `ValueError`. After the function concludes, the list `a` remains unchanged, and `x` retains its original value. The index `i` is either the position of the first occurrence of `x` in `a` or the insertion point where `x` would be inserted to maintain the sorted order of `a`.

#Function 5:
#State of the program right berfore the function call: a is a sorted list of integers, and x is an integer.
def func_5(a, x):
    """Find rightmost value less than x"""
    i = bisect_left(a, x)
    if i :
        return a[i - 1]
        #The program returns the integer immediately before the position where `x` should be inserted in the sorted list `a` to maintain its sorted order, or the integer immediately before the leftmost occurrence of `x` if `x` is already in `a`. Since `i` is non-zero, this value is guaranteed to exist.
    #State of the program after the if block has been executed: *`a` is a sorted list of integers, `x` is an integer, `i` is the index where `x` should be inserted in `a` to maintain sorted order (or the index of the leftmost occurrence of `x` if it is already in `a`). `i` is 0
    raise ValueError
#Overall this is what the function does:The function `func_5` takes a sorted list of integers `a` and an integer `x` as parameters. It returns the integer immediately before the position where `x` should be inserted in the list `a` to maintain its sorted order. If `x` is already in the list, it returns the integer immediately before the leftmost occurrence of `x`. If `x` is less than or equal to the smallest element in `a`, the function raises a `ValueError`.

#Function 6:
#State of the program right berfore the function call: a is a sorted list of integers, and x is an integer.
def func_6(a, x):
    """Find rightmost value less than or equal to x"""
    i = bisect_right(a, x)
    if i :
        return a[i - 1]
        #The program returns the integer from the sorted list `a` that is located at the index `i-1`. This integer is the largest element in `a` that is less than `x`.
    #State of the program after the if block has been executed: `a` is a sorted list of integers, `x` is an integer, `i` is the index in `a` where `x` should be inserted to keep `a` sorted, and `i` is 0.
    raise ValueError
#Overall this is what the function does:The function `func_6` accepts a sorted list of integers `a` and an integer `x`. It returns the largest element in `a` that is less than or equal to `x`. If no such element exists (i.e., all elements in `a` are greater than `x`), the function raises a `ValueError`. After the function concludes, the list `a` remains unchanged, and `x` retains its original value.

#Function 7:
#State of the program right berfore the function call: a is a sorted list of integers, and x is an integer.
def func_7(a, x):
    """Find leftmost value greater than x"""
    i = bisect_right(a, x)
    if (i != len(a)) :
        return a[i]
        #The program returns the first element in the sorted list `a` that is strictly greater than the integer `x`.
    #State of the program after the if block has been executed: *`a` is a sorted list of integers, `x` is an integer, `i` is the index of the first element in `a` that is strictly greater than `x`, and `i` is equal to the length of `a`
    raise ValueError
#Overall this is what the function does:The function `func_7` accepts a sorted list of integers `a` and an integer `x`. It returns the first element in `a` that is strictly greater than `x`. If no such element exists (i.e., all elements in `a` are less than or equal to `x`), the function raises a `ValueError`. After the function concludes, the list `a` remains unchanged, and the integer `x` is also unchanged. The function only modifies the program state by either returning a value from the list or raising an exception.

#Function 8:
#State of the program right berfore the function call: a is a sorted list of numbers, x is a number of any value.
def func_8(a, x):
    """Find leftmost item greater than or equal to x"""
    i = bisect_left(a, x)
    if (i != len(a)) :
        return a[i]
        #The program returns the value at index `i` in the sorted list `a`, which is the number that is either the leftmost occurrence of `x` in `a` or the number immediately less than `x` if `x` is not in `a`.
    #State of the program after the if block has been executed: *`a` is a sorted list of numbers, `x` is a number of any value, `i` is the index in `a` where `x` should be inserted to maintain sorted order, or the index of the leftmost occurrence of `x` if it is already in `a`, and `i` is equal to the length of `a`
    raise ValueError
#Overall this is what the function does:The function `func_8` accepts a sorted list of numbers `a` and a number `x`. It returns the smallest element in `a` that is greater than or equal to `x`. If no such element exists (i.e., all elements in `a` are less than `x`), the function raises a `ValueError`. The function does not modify the input list `a` or the number `x`.

#Function 9:
#State of the program right berfore the function call: a is a list of integers sorted in non-decreasing order, x is an integer, left and right are integers such that 0 <= left <= right < len(a).
def func_9(a, x, left, right):
    while left <= right:
        mid = (left + right) // 2
        
        if a[mid] == x:
            return mid
        elif a[mid] < x:
            left = mid + 1
        elif a[mid] > x:
            right = mid - 1
        
        pass
        
    #State of the program after the loop has been executed: `a` is a list of integers sorted in non-decreasing order, `x` is an integer, `left` and `right` are integers such that 0 <= `left` <= `right` < len(`a`). After the loop, `left` > `right`. If `x` is found in `a`, the loop returns the index of `x` in `a`. If `x` is not found in `a`, the loop terminates with `left` > `right` and no index is returned.
    return -1
    #The program returns -1, indicating that the integer `x` was not found in the list `a` after the loop terminated with `left` > `right`.
#Overall this is what the function does:This function, `func_9`, performs a binary search on a sorted list of integers `a` to find the index of a given integer `x`. It accepts four parameters: a sorted list `a`, an integer `x`, and two integers `left` and `right` such that `0 <= left <= right < len(a)`. The function returns the index `mid` where `a[mid] == x` if `x` is found in the list. If `x` is not found, the function returns `-1`. The function ensures that after the loop terminates, `left` is greater than `right`, indicating that the search space has been exhausted without finding `x`. The function correctly handles the edge case where `x` is not present in the list and returns `-1`.

#Function 10:
#State of the program right berfore the function call: format is a string that represents a format pattern, and *args is a variable-length argument list of values that correspond to the format pattern.
def func_10(format):
    """Format args with the first argument as format string, and write.
	Return the last arg, or format itself if there are no args."""
    sys.stdout.write(str(format) % args)
#Overall this is what the function does:The function `func_10` accepts a single parameter `format`, which is expected to be a string representing a format pattern. It also implicitly accepts a variable-length argument list `*args`, although this is not explicitly mentioned in the function signature. The function writes a formatted string to `sys.stdout` using the provided format pattern and the corresponding values from `*args`. However, the function does not return any value, contrary to the annotation. If `*args` is not provided, the function will raise a `TypeError` because `args` is not defined. If `format` is not a valid format string, a `TypeError` or `ValueError` may also be raised. After the function executes, the formatted string is printed to the standard output, and the function does not return any value.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
