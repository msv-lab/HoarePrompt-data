
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: SmallR is an archer. SmallR is taking a match of archer with Zanoes. They try to shoot in the target in turns, and SmallR shoots first. The probability of shooting the target each time is <image> for SmallR while <image> for Zanoes. The one who shoots in the target first should be the winner.

Output the probability that SmallR will win the match.

Input

A single line contains four integers <image>.

Output

Print a single real number, the probability that SmallR will win the match.

The answer will be considered correct if the absolute or relative error doesn't exceed 10 - 6.

Examples

Input

1 2 1 2


Output

0.666666666667
Program:
```
from __future__ import division
from bisect import *
from fractions import Fraction
import sys
from math import *
from fractions import *
import io
import re
from datetime import date
#Function 1:
def func_1(delimiter=' '):
    return map(int, raw_input().split(delimiter))

#Function 2:
def func_2(delimiter=' '):
    return raw_input().split(delimiter)

#Function 3:
def func_3(delimiter=' '):
    return map(float, raw_input().split(delimiter))

#Function 4:
def func_4(a, x):
    """Locate the leftmost value exactly equal to x"""
    i = bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    raise ValueError

#Function 5:
def func_5(a, x):
    """Find rightmost value less than x"""
    i = bisect_left(a, x)
    if i:
        return a[i - 1]
    raise ValueError

#Function 6:
def func_6(a, x):
    """Find rightmost value less than or equal to x"""
    i = bisect_right(a, x)
    if i:
        return a[i - 1]
    raise ValueError

#Function 7:
def func_7(a, x):
    """Find leftmost value greater than x"""
    i = bisect_right(a, x)
    if i != len(a):
        return a[i]
    raise ValueError

#Function 8:
def func_8(a, x):
    """Find leftmost item greater than or equal to x"""
    i = bisect_left(a, x)
    if i != len(a):
        return a[i]
    raise ValueError

#Function 9:
def func_9(a, x, left, right):
    while left <= right:
        mid = (left + right) // 2
        if a[mid] == x:
            return mid
        elif a[mid] < x:
            left = mid + 1
        elif a[mid] > x:
            right = mid - 1
        pass
    return -1
    pass

#Function 10:
def func_10(format, *args):
    """Format args with the first argument as format string, and write.
	Return the last arg, or format itself if there are no args."""
    sys.stdout.write(str(format) % args)


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not actually solve the problem described. It includes several functions that are not used in the context of the problem. The problem requires calculating the probability that SmallR wins the match, but the program does not contain any logic to perform this calculation. Specifically, the program lacks:

1. Reading the input values (a, b, c, d).
2. Calculating the probabilities for SmallR and Zanoes.
3. Computing the probability that SmallR wins the match.
4. Printing the result with the required precision.

Since the program does not address the core requirements of the problem, it is incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division
from bisect import *
from fractions import Fraction
import sys
from math import *
from fractions import *
import io
import re
from datetime import date

INF = 987654321987654321987654321
if __name__ == '__main__':
    (a, b, c, d) = func_1()
    prob_a = a / b
    prob_b = c / d
    prev = 0
    now = 0
    now += prob_a
    acc = (1 - prob_a) * (1 - prob_b)
    ii = 0
    while now - prev > 1e-07:
        prev = now
        ii += 1
        now += acc * prob_a
        acc *= (1 - prob_a) * (1 - prob_b)
        pass
    func_10('%.6f\n', now)
    pass

#Function 1:
#State of the program right berfore the function call: delimiter is a string used to split the input, defaulting to a single space (' ').
def func_1(delimiter):
    return map(int, raw_input().split(delimiter))
    #The program returns a map object that converts each element from the split input (split by the delimiter, which defaults to a single space) into an integer. The exact integers depend on the user's input.

#Function 2:
#State of the program right berfore the function call: delimiter is a string used to split the input, defaulting to a single space (' ').
def func_2(delimiter):
    return raw_input().split(delimiter)
    #The program returns a list of strings obtained by splitting the user input using the delimiter, which defaults to a single space (' ').

#Function 3:
#State of the program right berfore the function call: delimiter is a string used to split the input, defaulting to a single space (' ').
def func_3(delimiter):
    return map(float, raw_input().split(delimiter))
    #The program returns a map object which is an iterator over the elements of the input string (provided by the user) split by the delimiter (defaulting to a single space), with each element converted to a float.

#Function 4:
#State of the program right berfore the function call: a is a sorted list of elements, and x is an element of the same type as the elements in a.
def func_4(a, x):
    """Locate the leftmost value exactly equal to x"""
    i = bisect_left(a, x)
    if (i != len(a) and a[i] == x) :
        return i
        #The program returns the index `i` of the first occurrence of `x` in the sorted list `a`.
    #State of the program after the if block has been executed: *`a` is a sorted list of elements, `x` is an element of the same type as the elements in `a`, `i` is the index of the first occurrence of `x` in `a` or the insertion point to maintain sorted order, and either `i` is equal to the length of `a` or `a[i]` is not equal to `x`
    raise ValueError

#Function 5:
#State of the program right berfore the function call: a is a sorted list of integers, and x is an integer.
def func_5(a, x):
    """Find rightmost value less than x"""
    i = bisect_left(a, x)
    if i :
        return a[i - 1]
        #The program returns the integer immediately before the position where `x` should be inserted in the sorted list `a` to maintain its sorted order, or the integer immediately before the leftmost occurrence of `x` if `x` is already in `a`. Since `i` is non-zero, this value is guaranteed to exist.
    #State of the program after the if block has been executed: *`a` is a sorted list of integers, `x` is an integer, `i` is the index where `x` should be inserted in `a` to maintain sorted order (or the index of the leftmost occurrence of `x` if it is already in `a`). `i` is 0
    raise ValueError

#Function 6:
#State of the program right berfore the function call: a is a sorted list of integers, and x is an integer.
def func_6(a, x):
    """Find rightmost value less than or equal to x"""
    i = bisect_right(a, x)
    if i :
        return a[i - 1]
        #The program returns the integer from the sorted list `a` that is located at the index `i-1`. This integer is the largest element in `a` that is less than `x`.
    #State of the program after the if block has been executed: `a` is a sorted list of integers, `x` is an integer, `i` is the index in `a` where `x` should be inserted to keep `a` sorted, and `i` is 0.
    raise ValueError

#Function 7:
#State of the program right berfore the function call: a is a sorted list of integers, and x is an integer.
def func_7(a, x):
    """Find leftmost value greater than x"""
    i = bisect_right(a, x)
    if (i != len(a)) :
        return a[i]
        #The program returns the first element in the sorted list `a` that is strictly greater than the integer `x`.
    #State of the program after the if block has been executed: *`a` is a sorted list of integers, `x` is an integer, `i` is the index of the first element in `a` that is strictly greater than `x`, and `i` is equal to the length of `a`
    raise ValueError

#Function 8:
#State of the program right berfore the function call: a is a sorted list of numbers, x is a number of any value.
def func_8(a, x):
    """Find leftmost item greater than or equal to x"""
    i = bisect_left(a, x)
    if (i != len(a)) :
        return a[i]
        #The program returns the value at index `i` in the sorted list `a`, which is the number that is either the leftmost occurrence of `x` in `a` or the number immediately less than `x` if `x` is not in `a`.
    #State of the program after the if block has been executed: *`a` is a sorted list of numbers, `x` is a number of any value, `i` is the index in `a` where `x` should be inserted to maintain sorted order, or the index of the leftmost occurrence of `x` if it is already in `a`, and `i` is equal to the length of `a`
    raise ValueError

#Function 9:
#State of the program right berfore the function call: a is a list of integers sorted in non-decreasing order, x is an integer, left and right are integers such that 0 <= left <= right < len(a).
def func_9(a, x, left, right):
    while left <= right:
        mid = (left + right) // 2
        
        if a[mid] == x:
            return mid
        elif a[mid] < x:
            left = mid + 1
        elif a[mid] > x:
            right = mid - 1
        
        pass
        
    #State of the program after the loop has been executed: `a` is a list of integers sorted in non-decreasing order, `x` is an integer, `left` and `right` are integers such that 0 <= `left` <= `right` < len(`a`). After the loop, `left` > `right`. If `x` is found in `a`, the loop returns the index of `x` in `a`. If `x` is not found in `a`, the loop terminates with `left` > `right` and no index is returned.
    return -1
    #The program returns -1, indicating that the integer `x` was not found in the list `a` after the loop terminated with `left` > `right`.

#Function 10:
#State of the program right berfore the function call: format is a string that represents a format pattern, and *args is a variable-length argument list of values that correspond to the format pattern.
def func_10(format):
    """Format args with the first argument as format string, and write.
	Return the last arg, or format itself if there are no args."""
    sys.stdout.write(str(format) % args)



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
