
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: SmallR is an archer. SmallR is taking a match of archer with Zanoes. They try to shoot in the target in turns, and SmallR shoots first. The probability of shooting the target each time is <image> for SmallR while <image> for Zanoes. The one who shoots in the target first should be the winner.

Output the probability that SmallR will win the match.

Input

A single line contains four integers <image>.

Output

Print a single real number, the probability that SmallR will win the match.

The answer will be considered correct if the absolute or relative error doesn't exceed 10 - 6.

Examples

Input

1 2 1 2


Output

0.666666666667
Functions with output description for each function:
from __future__ import division
from bisect import *
from fractions import Fraction
import sys
from math import *
from fractions import *
import io
import re
from datetime import date

INF = 987654321987654321987654321
if __name__ == '__main__':
    (a, b, c, d) = func_1()
    prob_a = a / b
    prob_b = c / d
    prev = 0
    now = 0
    now += prob_a
    acc = (1 - prob_a) * (1 - prob_b)
    ii = 0
    while now - prev > 1e-07:
        prev = now
        ii += 1
        now += acc * prob_a
        acc *= (1 - prob_a) * (1 - prob_b)
        pass
    func_10('%.6f\n', now)
    pass

Function number 1 :
 Code:
 '''
def func_1(delimiter=' '):
    return map(int, raw_input().split(delimiter))
''' 

 Output hints for function1:  The function `func_1` accepts a parameter `delimiter`, which is a string used to split the input, defaulting to a single space (' '). It reads a line of input from the user, splits the input using the specified delimiter, and returns a map object that converts each element from the split input into an integer. The exact integers depend on the user's input. If the user inputs non-integer values, the `int` conversion will raise a `ValueError`. If no input is provided, the function will block and wait for user input. After the function concludes, the program will have a map object containing the converted integers, or it will raise an exception if the conversion fails.
Function number 2 :
 Code:
 '''
def func_2(delimiter=' '):
    return raw_input().split(delimiter)
''' 

 Output hints for function2:  The function `func_2` accepts a parameter `delimiter`, which is a string used to split the user input, defaulting to a single space (' '). It reads user input from the standard input (stdin) and returns a list of strings obtained by splitting the input using the specified delimiter. If the user input is empty or consists only of the delimiter, the function will return an empty list or a list containing an empty string, respectively. If the delimiter is an empty string, the function will raise a `ValueError`.
Function number 3 :
 Code:
 '''
def func_3(delimiter=' '):
    return map(float, raw_input().split(delimiter))
''' 

 Output hints for function3:  The function `func_3` accepts a parameter `delimiter` (a string, defaulting to a single space ' ') and returns a map object that iterates over the elements of the input string (provided by the user via `raw_input()`) split by the `delimiter`, with each element converted to a float. If the input string contains non-numeric values, the conversion to float will raise a `ValueError`. If the input string is empty, the returned map object will be empty.
Function number 4 :
 Code:
 '''
def func_4(a, x):
    """Locate the leftmost value exactly equal to x"""
    i = bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    raise ValueError
''' 

 Output hints for function4:  The function `func_4` accepts a sorted list `a` and an element `x`. It returns the index `i` of the first occurrence of `x` in the sorted list `a`. If `x` is not found in the list, the function raises a `ValueError`. After the function concludes, the list `a` remains unchanged, and `x` retains its original value. The index `i` is either the position of the first occurrence of `x` in `a` or the insertion point where `x` would be inserted to maintain the sorted order of `a`.
Function number 5 :
 Code:
 '''
def func_5(a, x):
    """Find rightmost value less than x"""
    i = bisect_left(a, x)
    if i:
        return a[i - 1]
    raise ValueError
''' 

 Output hints for function5:  The function `func_5` takes a sorted list of integers `a` and an integer `x` as parameters. It returns the integer immediately before the position where `x` should be inserted in the list `a` to maintain its sorted order. If `x` is already in the list, it returns the integer immediately before the leftmost occurrence of `x`. If `x` is less than or equal to the smallest element in `a`, the function raises a `ValueError`.
Function number 6 :
 Code:
 '''
def func_6(a, x):
    """Find rightmost value less than or equal to x"""
    i = bisect_right(a, x)
    if i:
        return a[i - 1]
    raise ValueError
''' 

 Output hints for function6:  The function `func_6` accepts a sorted list of integers `a` and an integer `x`. It returns the largest element in `a` that is less than or equal to `x`. If no such element exists (i.e., all elements in `a` are greater than `x`), the function raises a `ValueError`. After the function concludes, the list `a` remains unchanged, and `x` retains its original value.
Function number 7 :
 Code:
 '''
def func_7(a, x):
    """Find leftmost value greater than x"""
    i = bisect_right(a, x)
    if i != len(a):
        return a[i]
    raise ValueError
''' 

 Output hints for function7:  The function `func_7` accepts a sorted list of integers `a` and an integer `x`. It returns the first element in `a` that is strictly greater than `x`. If no such element exists (i.e., all elements in `a` are less than or equal to `x`), the function raises a `ValueError`. After the function concludes, the list `a` remains unchanged, and the integer `x` is also unchanged. The function only modifies the program state by either returning a value from the list or raising an exception.
Function number 8 :
 Code:
 '''
def func_8(a, x):
    """Find leftmost item greater than or equal to x"""
    i = bisect_left(a, x)
    if i != len(a):
        return a[i]
    raise ValueError
''' 

 Output hints for function8:  The function `func_8` accepts a sorted list of numbers `a` and a number `x`. It returns the smallest element in `a` that is greater than or equal to `x`. If no such element exists (i.e., all elements in `a` are less than `x`), the function raises a `ValueError`. The function does not modify the input list `a` or the number `x`.
Function number 9 :
 Code:
 '''
def func_9(a, x, left, right):
    while left <= right:
        mid = (left + right) // 2
        if a[mid] == x:
            return mid
        elif a[mid] < x:
            left = mid + 1
        elif a[mid] > x:
            right = mid - 1
        pass
    return -1
    pass
''' 

 Output hints for function9:  This function, `func_9`, performs a binary search on a sorted list of integers `a` to find the index of a given integer `x`. It accepts four parameters: a sorted list `a`, an integer `x`, and two integers `left` and `right` such that `0 <= left <= right < len(a)`. The function returns the index `mid` where `a[mid] == x` if `x` is found in the list. If `x` is not found, the function returns `-1`. The function ensures that after the loop terminates, `left` is greater than `right`, indicating that the search space has been exhausted without finding `x`. The function correctly handles the edge case where `x` is not present in the list and returns `-1`.
Function number 10 :
 Code:
 '''
def func_10(format, *args):
    """Format args with the first argument as format string, and write.
	Return the last arg, or format itself if there are no args."""
    sys.stdout.write(str(format) % args)
''' 

 Output hints for function10:  The function `func_10` accepts a single parameter `format`, which is expected to be a string representing a format pattern. It also implicitly accepts a variable-length argument list `*args`, although this is not explicitly mentioned in the function signature. The function writes a formatted string to `sys.stdout` using the provided format pattern and the corresponding values from `*args`. However, the function does not return any value, contrary to the annotation. If `*args` is not provided, the function will raise a `TypeError` because `args` is not defined. If `format` is not a valid format string, a `TypeError` or `ValueError` may also be raised. After the function executes, the formatted string is printed to the standard output, and the function does not return any value.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.