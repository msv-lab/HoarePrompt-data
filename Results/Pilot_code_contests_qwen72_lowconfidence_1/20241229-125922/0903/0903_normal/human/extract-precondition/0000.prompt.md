
You are given a programming problem description and a function that contributes to the solution of this problem. The total solution compromises of multiple functions and this is just one of them. 
From the problem description, and based on the variables used in the signature of this specific function, extract a description of the values of the variables in the function signature and the relationship between them. We refer to this description as precondition. Print the precondition following the word "Precondition", and surrounded with double asterisks (**). Follow these examples:
Remember the function given may not solve the problem directly but perform a side functionality that contributes to the total solution. Include information only about the variables in the function signature.
# Example 1

Problem description: write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].
Program:
```
def min_cost(cost, m, n):
	tc = [[0 for x in range(C)] for x in range(R)]
	tc[0][0] = cost[0][0]
	for i in range(1, m+1):
		tc[i][0] = tc[i-1][0] + cost[i][0]
	for j in range(1, n+1):
		tc[0][j] = tc[0][j-1] + cost[0][j]
	for i in range(1, m+1):
		for j in range(1, n+1):
			tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]
	return tc[m][n]
```

Precondition: **cost is a 2D list of non-negative integers, m and n are non-negative integers such that 0 <= m < len(cost) and 0 <= n < len(cost[0]).**

# Example 2

Problem description: Write a function to find the similar elements from the given two tuple lists.
Program:
```
def are_similar(elem, elem1):
  if elem == elem1:
    return True
  else:
    return False
```

Precondition: **elem1 and elem are values of any type and value**
# Example 3

Problem description: Write a python function to identify if 2 consecutive integers in a list are not prime".
Program:
```
import math
def is_not_prime(n):
    result = False
    for i in range(2,int(math.sqrt(n)) + 1):
        if n % i == 0:
            result = True
    return result
```

Precondition: **n is an integer greater than 1.**

# Example 4

Problem description: Write a function to find the largest integers from a given list of numbers using heap queue algorithm.
Program:
```
import heapq as hq
def heap_queue_largest(nums,n):
  largest_nums = hq.nlargest(n, nums)
  return largest_nums
```

Precondition: **nums is a list of integers, and n is a non-negative integer such that 0 <= n <= len(nums).**


# Your task

Problem description: Now Serval is a junior high school student in Japari Middle School, and he is still thrilled on math as before. 

As a talented boy in mathematics, he likes to play with numbers. This time, he wants to play with numbers on a rooted tree.

A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a node v is the last different from v vertex on the path from the root to the vertex v. Children of vertex v are all nodes for which v is the parent. A vertex is a leaf if it has no children.

The rooted tree Serval owns has n nodes, node 1 is the root. Serval will write some numbers into all nodes of the tree. However, there are some restrictions. Each of the nodes except leaves has an operation max or min written in it, indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons, respectively. 

Assume that there are k leaves in the tree. Serval wants to put integers 1, 2, …, k to the k leaves (each number should be used exactly once). He loves large numbers, so he wants to maximize the number in the root. As his best friend, can you help him?

Input

The first line contains an integer n (2 ≤ n ≤ 3⋅ 10^5), the size of the tree.

The second line contains n integers, the i-th of them represents the operation in the node i. 0 represents min and 1 represents max. If the node is a leaf, there is still a number of 0 or 1, but you can ignore it.

The third line contains n-1 integers f_2, f_3, …, f_n (1 ≤ f_i ≤ i-1), where f_i represents the parent of the node i.

Output

Output one integer — the maximum possible number in the root of the tree.

Examples

Input


6
1 0 1 1 0 1
1 2 2 2 2


Output


1


Input


5
1 0 1 0 1
1 1 1 1


Output


4


Input


8
1 0 0 1 0 1 1 0
1 1 2 2 3 3 3


Output


4


Input


9
1 1 0 0 1 0 1 0 1
1 1 2 2 3 3 4 4


Output


5

Note

Pictures below explain the examples. The numbers written in the middle of the nodes are their indices, and the numbers written on the top are the numbers written in the nodes.

In the first example, no matter how you arrange the numbers, the answer is 1.

<image>

In the second example, no matter how you arrange the numbers, the answer is 4.

<image>

In the third example, one of the best solution to achieve 4 is to arrange 4 and 5 to nodes 4 and 5.

<image>

In the fourth example, the best solution is to arrange 5 to node 5.

<image>
Program:
```
def func_4(root):
    global memo
    if len(G[root]) == 0:
        return 1
    if root in memo:
        return memo[root]
    res = 0
    if op[root] == 0:
        for v in G[root]:
            res = max(res, func_4(v))
    else:
        nl = nleaf[root]
        for v in G[root]:
            nlv = nleaf[v]
            res = max(res, nl - (nlv - func_4(v)))
    memo[root] = res
    return memo[root]
```

