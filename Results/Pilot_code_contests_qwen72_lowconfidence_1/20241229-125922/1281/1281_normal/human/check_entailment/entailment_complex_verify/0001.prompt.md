
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Polycarpus has a hobby — he develops an unusual social network. His work is almost completed, and there is only one more module to implement — the module which determines friends. Oh yes, in this social network one won't have to add friends manually! Pairs of friends are deduced in the following way. Let's assume that user A sent user B a message at time t1, and user B sent user A a message at time t2. If 0 < t2 - t1 ≤ d, then user B's message was an answer to user A's one. Users A and B are considered to be friends if A answered at least one B's message or B answered at least one A's message.

You are given the log of messages in chronological order and a number d. Find all pairs of users who will be considered to be friends.

Input

The first line of the input contains two integers n and d (1 ≤ n, d ≤ 1000). The next n lines contain the messages log. The i-th line contains one line of the log formatted as "Ai Bi ti" (without the quotes), which means that user Ai sent a message to user Bi at time ti (1 ≤ i ≤ n). Ai and Bi are non-empty strings at most 20 characters long, consisting of lowercase letters ('a' ... 'z'), and ti is an integer (0 ≤ ti ≤ 10000). It is guaranteed that the lines are given in non-decreasing order of ti's and that no user sent a message to himself. The elements in the lines are separated by single spaces.

Output

In the first line print integer k — the number of pairs of friends. In the next k lines print pairs of friends as "Ai Bi" (without the quotes). You can print users in pairs and the pairs themselves in any order. Each pair must be printed exactly once.

Examples

Input

4 1
vasya petya 1
petya vasya 2
anya ivan 2
ivan anya 4


Output

1
petya vasya


Input

1 1000
a b 0


Output

0

Note

In the first sample test case Vasya and Petya are friends because their messages' sending times are one second apart. Anya and Ivan are not, because their messages' sending times differ by more than one second.
Program:
```
def func():
    (n, d) = map(int, raw_input().split())
    res = set()
    data = [[]] * n
    for i in range(0, n):
        data[i] = raw_input().split()
        data[i][2] = int(data[i][2])
    for i in range(0, n):
        for j in range(i + 1, n):
            if data[i][0] == data[j][1] and data[i][1] == data[j][0] and (0 < abs(data[i][2] - data[j][2]) <= d):
                res |= {data[i][0] + ' ' + data[i][1]}
    print(len(res))
    for l in res:
        print(l)


```
Original Assessment: Correctness: **False**

Explanation:
The program has a potential issue with how it initializes the `data` list. Specifically, the line `data = [[]] * n` creates a list of `n` references to the same empty list. This means that modifying one element in the `data` list will affect all other elements because they all reference the same underlying list. This can lead to incorrect behavior when the program processes the input data.

To illustrate, consider the following input:
```
3 1
a b 1
b a 2
c d 3
```

The expected output is:
```
1
a b
```

However, due to the issue with the list initialization, the program might produce incorrect results. For example, after the first iteration of the loop where `i = 0`, `data` might look like this:
```
[['a', 'b', 1], ['a', 'b', 1], ['a', 'b', 1]]
```

This is clearly incorrect, and it will affect the subsequent processing of the data.

To fix this issue, the list should be initialized using a list comprehension:
```python
data = [None] * n
for i in range(n):
    data[i] = raw_input().split()
    data[i][2] = int(data[i][2])
```

This ensures that each element in the `data` list is a separate list, and modifying one element will not affect the others. After fixing this, the program should work correctly for all potential cases.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
#State of the program right berfore the function call: n and d are integers such that 1 ≤ n, d ≤ 1000. The log of messages is a list of n lines, each containing three space-separated values: the sender Ai, the receiver Bi, and the time ti (0 ≤ ti ≤ 10000), where Ai and Bi are non-empty strings of lowercase letters ('a' ... 'z') at most 20 characters long, and no user sends a message to themselves. The log is provided in non-decreasing order of ti.
def func():
    n, d = map(int, raw_input().split())
    res = set()
    data = [[]] * n
    for i in range(0, n):
        data[i] = raw_input().split()
        
        data[i][2] = int(data[i][2])
        
    #State of the program after the  for loop has been executed: `n` is an integer read from input, 1 ≤ n ≤ 1000, `d` is an integer read from input, 1 ≤ d ≤ 1000, the log of messages is a list of n lines, each containing three space-separated values: the sender Ai, the receiver Bi, and the time ti (0 ≤ ti ≤ 10000), `res` is an empty set, `data` is a list of n lists, each list in `data` contains three elements [sender Ai, receiver Bi, time ti as an integer], `i` is n-1, `n` is the number of lines in the log.
    for i in range(0, n):
        for j in range(i + 1, n):
            if data[i][0] == data[j][1] and data[i][1] == data[j][0] and 0 < abs(
                data[i][2] - data[j][2]) <= d:
                res |= {data[i][0] + ' ' + data[i][1]}
        
    #State of the program after the  for loop has been executed: `n` is an integer read from input, 1 ≤ n ≤ 1000, `d` is an integer read from input, 1 ≤ d ≤ 1000, the log of messages is a list of `n` lines, each containing three space-separated values: the sender `Ai`, the receiver `Bi`, and the time `ti` (0 ≤ ti ≤ 10000), `data` is a list of `n` lists, each list in `data` contains three elements `[sender Ai, receiver Bi, time ti as an integer]`, `i` is `n-1`, and `n` is the number of lines in the log. `res` is a set containing strings of the form `data[i][0] + ' ' + data[i][1]` for all pairs of messages where `data[i][0] == data[j][1]` and `data[i][1] == data[j][0]` and `0 < abs(data[i][2] - data[j][2]) <= d` for all valid `i` and `j` in the range `0` to `n-1` with `j > i`. If no such pairs exist, `res` remains an empty set.
    print(len(res))
    for l in res:
        print(l)
        
    #State of the program after the  for loop has been executed: `res` is a set of strings representing pairs of messages `[sender Ai, receiver Bi]` that satisfy the condition `0 < abs(data[i][2] - data[j][2]) <= d` for all valid `i` and `j` in the range `0` to `n-1` with `j > i`. If no such pairs exist, `res` is an empty set. Each element in `res` has been printed exactly once.
#Overall this is what the function does:The function reads two integers `n` and `d` from the input, where `1 ≤ n, d ≤ 1000`. It then reads `n` lines of message logs, each containing the sender (`Ai`), receiver (`Bi`), and time (`ti`) of a message. The function processes these logs to identify pairs of messages where the sender and receiver are swapped, and the time difference between the messages is within the range `(0, d]`. The function prints the number of unique pairs of users who exchanged messages meeting these criteria, followed by the pairs themselves. If no such pairs exist, it prints 0 and no additional lines. The function does not return any value; it only outputs the results to the console. Potential edge cases include scenarios where no messages meet the criteria, or where multiple pairs of messages involve the same users. The function assumes that no user sends a message to themselves and that the log is provided in non-decreasing order of time.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
