
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and a_i < a_j. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).

You are given a permutation p of size n. However, the numbers on some positions are replaced by -1. Let the valid permutation be such a replacement of -1 in this sequence back to numbers from 1 to n in such a way that the resulting sequence is a permutation of size n.

The given sequence was turned into a valid permutation randomly with the equal probability of getting each valid permutation.

Calculate the expected total number of inversions in the resulting valid permutation.

It can be shown that it is in the form of P/Q where P and Q are non-negative integers and Q ≠ 0. Report the value of P ⋅ Q^{-1} \pmod {998244353}.

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the sequence.

The second line contains n integers p_1, p_2, ..., p_n (-1 ≤ p_i ≤ n, p_i ≠ 0) — the initial sequence.

It is guaranteed that all elements not equal to -1 are pairwise distinct.

Output

Print a single integer — the expected total number of inversions in the resulting valid permutation.

It can be shown that it is in the form of P/Q where P and Q are non-negative integers and Q ≠ 0. Report the value of P ⋅ Q^{-1} \pmod {998244353}.

Examples

Input


3
3 -1 -1


Output


499122179


Input


2
1 2


Output


0


Input


2
-1 -1


Output


499122177

Note

In the first example two resulting valid permutations are possible:

  * [3, 1, 2] — 2 inversions; 
  * [3, 2, 1] — 3 inversions. 



The expected value is (2 ⋅ 1 + 3 ⋅ 1)/(2) = 2.5.

In the second example no -1 are present, thus the only valid permutation is possible — the given one. It has 0 inversions.

In the third example there are two resulting valid permutations — one with 0 inversions and one with 1 inversion.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
mod = 998244353
fac = [1]
for i in range(1, 200010):
    fac.append(i * fac[-1] % mod)
facInv = []
for i in fac:
    facInv.append(pow(i, mod - 2, mod))
n = input()
p = list(map(lambda x: int(x) - 1, raw_input().split()))
numMissing = len([x for x in p if x == -2])
A = [0 for i in range(n)]
A = func_1(A)
cnt = 0
for i in p:
    if i == -2:
        continue
    cnt += func_3(A, n - 1) - func_3(A, i)
    func_2(A, i, 1)
cnt *= fac[numMissing]
cntNeg = 0
for i in p:
    if i == -2:
        cntNeg += 1
        continue
    missingGreater = n - i - 1 - (func_3(A, n - 1) - func_3(A, i))
    missingSmaller = i - func_3(A, i - 1)
    missingLeftPos = cntNeg
    missingRightPos = numMissing - cntNeg
    cnt += fac[numMissing - 1] * missingGreater * missingLeftPos + fac[numMissing - 1] * missingSmaller * missingRightPos
cnt += fac[numMissing] * numMissing * (numMissing - 1) / 4
cnt %= mod
print(cnt * facInv[numMissing] % mod)

#Function 1:
#State of the program right berfore the function call: arr is a list of integers, where each element is either -1 or a positive integer from 1 to n, and n is the length of arr.
def func_1(arr):
    fwtree = [0] * (len(arr) + 1)
    for i in range(len(arr)):
        func_2(fwtree, i, arr[i])
        
    #State of the program after the  for loop has been executed: `arr` is a list of integers with elements being either -1 or positive integers from 1 to n, and n is the length of `arr`; `fwtree` is a list of integers with a length of `len(arr) + 1`, where each element of `fwtree` has been updated by the function `func_2` according to the corresponding elements of `arr` and their indices; `i` is `len(arr) - 1`.
    return fwtree
    #The program returns `fwtree`, which is a list of integers with a length of `len(arr) + 1`. Each element of `fwtree` has been updated by the function `func_2` according to the corresponding elements of `arr` and their indices.

#Function 2:
#State of the program right berfore the function call: fwtree is a list of integers, i is a non-negative integer such that 0 <= i < len(fwtree), and val is an integer.
def func_2(fwtree, i, val):
    i += 1
    while i < len(fwtree):
        fwtree[i] += val
        
        i += i & -i
        
    #State of the program after the loop has been executed: `fwtree` is a list of integers where each element at indices `i`, `i + (i & -i)`, `i + (i & -i) + ((i + (i & -i)) & -(i + (i & -i)))`, etc., up to the last valid index, is incremented by `val`. `i` is now the smallest value such that `i >= len(fwtree)`, and `val` remains unchanged.

#Function 3:
#State of the program right berfore the function call: fwtree is a list of integers representing a Fenwick Tree, and i is a non-negative integer such that 0 <= i < len(fwtree).
def func_3(fwtree, i):
    s = 0
    i += 1
    while i > 0:
        s += fwtree[i]
        
        i -= i & -i
        
    #State of the program after the loop has been executed: `i` is 0, `s` is the sum of elements in `fwtree` indexed by all the positions that contribute to the Fenwick Tree representation of the original value of `i`
    return s
    #The program returns the sum of elements in `fwtree` indexed by all the positions that contribute to the Fenwick Tree representation of the original value of `i`, which is 0.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
