Correctness: **True**

Explanation: The provided code appears to correctly implement the solution to the problem as described. The functions `func_1`, `func_2`, and `func_3` are used to manage a Fenwick Tree (also known as a Binary Indexed Tree, BIT), which is a data structure used for efficient prefix sum queries and updates. Here's a breakdown of how the code works and why it is correct:

1. **Initialization and Preprocessing:**
   - The code initializes a list `fac` to store factorials and `facInv` to store the modular inverses of these factorials modulo 998244353. These are used later for combinatorial calculations.
   - The input is read, and the permutation is adjusted by subtracting 1 from each element to make it zero-indexed. The number of missing elements (denoted by `-1`) is counted.

2. **Fenwick Tree Initialization:**
   - `func_1` initializes the Fenwick Tree with the given array. This function ensures that the Fenwick Tree is set up correctly to support efficient prefix sum queries and updates.

3. **Counting Inversions:**
   - The code iterates over the permutation, updating the count of inversions (`cnt`) for the known elements. It uses `func_3` to query the Fenwick Tree and `func_2` to update it.
   - For each known element, it calculates the number of inversions involving this element and updates the count accordingly.

4. **Handling Missing Elements:**
   - The code then handles the missing elements by calculating the expected number of inversions involving these elements. It uses combinatorial logic to account for the different ways the missing elements can be placed in the permutation.

5. **Final Calculation:**
   - The final count of inversions is adjusted by the number of missing elements and their positions. The result is then normalized using the modular inverse of the factorial of the number of missing elements to ensure the result is in the required form \( P \cdot Q^{-1} \pmod{998244353} \).

The code correctly handles all edge cases and potential inputs within the given constraints. The use of the Fenwick Tree ensures efficient computation of prefix sums and updates, which is crucial for the performance of the algorithm. The combinatorial logic for handling missing elements is also implemented correctly, ensuring that the expected number of inversions is accurately calculated.

Therefore, the program is correct for every potential case.