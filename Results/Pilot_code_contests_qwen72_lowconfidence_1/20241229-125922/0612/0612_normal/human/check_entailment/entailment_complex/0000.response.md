Correctness: **True**

Explanation:
The provided code appears to correctly implement the solution for the problem described. Hereâ€™s a detailed breakdown of why the code is correct:

1. **Input Handling**:
   - The input is read and processed correctly. The permutation `p` is adjusted by subtracting 1 from each element to facilitate 0-based indexing, which is a common practice in programming.

2. **Fenwick Tree (Binary Indexed Tree)**:
   - The functions `func_1`, `func_2`, and `func_3` correctly implement the Fenwick Tree (Binary Indexed Tree) operations. These functions are used to efficiently count inversions and update the tree.

3. **Handling Missing Elements**:
   - The code correctly identifies and counts the number of missing elements (`-1` in the permutation). It then uses combinatorial methods to calculate the expected number of inversions.

4. **Inversion Calculation**:
   - The code calculates the number of inversions in the permutation, considering both the known and unknown elements. It uses the Fenwick Tree to efficiently count inversions and updates the tree accordingly.

5. **Expected Inversions**:
   - The code correctly calculates the expected number of inversions by considering the contributions from known elements and the expected contributions from unknown elements. The use of factorials and modular inverses ensures that the calculations are done correctly under modulo `998244353`.

6. **Modular Arithmetic**:
   - The code uses modular arithmetic to handle large numbers and ensure that the results are within the required constraints.

7. **Edge Cases**:
   - The code handles edge cases such as permutations with no `-1` elements and permutations where all elements are `-1`. The examples provided in the problem description are correctly handled by the code.

Given the above points, the code appears to meet the requirements of the problem description for every potential case. Therefore, the code is correct.