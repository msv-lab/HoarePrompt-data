
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Two little greedy bears have found two pieces of cheese in the forest of weight a and b grams, correspondingly. The bears are so greedy that they are ready to fight for the larger piece. That's where the fox comes in and starts the dialog: "Little bears, wait a little, I want to make your pieces equal" "Come off it fox, how are you going to do that?", the curious bears asked. "It's easy", said the fox. "If the mass of a certain piece is divisible by two, then I can eat exactly a half of the piece. If the mass of a certain piece is divisible by three, then I can eat exactly two-thirds, and if the mass is divisible by five, then I can eat four-fifths. I'll eat a little here and there and make the pieces equal". 

The little bears realize that the fox's proposal contains a catch. But at the same time they realize that they can not make the two pieces equal themselves. So they agreed to her proposal, but on one condition: the fox should make the pieces equal as quickly as possible. Find the minimum number of operations the fox needs to make pieces equal.

Input

The first line contains two space-separated integers a and b (1 ≤ a, b ≤ 109). 

Output

If the fox is lying to the little bears and it is impossible to make the pieces equal, print -1. Otherwise, print the required minimum number of operations. If the pieces of the cheese are initially equal, the required number is 0.

Examples

Input

15 20


Output

3


Input

14 8


Output

-1


Input

6 6


Output

0
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from fractions import gcd

(a, b) = (int(s) for s in raw_input().split())
g = gcd(a, b)
a /= g
b /= g
(a, x) = func_1(a)
(b, y) = func_1(b)
if a != b:
    print(-1)
else:
    print(x + y)

#State of the program right berfore the function call: a and b are integers such that 1 ≤ a, b ≤ 10^9.
def func_1(n):
    res = 0
    div = [2, 3, 5]
    for d in div:
        while n % d == 0:
            n /= d
            res += 1
        
    #State of the program after the  for loop has been executed: `a` and `b` are integers such that 1 ≤ `a`, `b` ≤ 10^9, `res` is the total number of times the original `n` (which is the product of `a` and `b`) was divisible by any of the elements in `div` (2, 3, 5) without leaving a remainder, `n` is the original `n` divided by 2, 3, and 5 as many times as possible without leaving a remainder, and `div` = [2, 3, 5].
    return n, res
    #The program returns `n`, which is the original product of `a` and `b` divided by 2, 3, and 5 as many times as possible without leaving a remainder, and `res`, which is the total number of times the original `n` was divisible by any of the elements in `div` (2, 3, 5) without leaving a remainder.

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
