
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You are given a string s, consisting of lowercase Latin letters. While there is at least one character in the string s that is repeated at least twice, you perform the following operation: 

  * you choose the index i (1 ≤ i ≤ |s|) such that the character at position i occurs at least two times in the string s, and delete the character at position i, that is, replace s with s_1 s_2 … s_{i-1} s_{i+1} s_{i+2} … s_n. 



For example, if s="codeforces", then you can apply the following sequence of operations: 

  * i=6 ⇒ s="codefrces"; 
  * i=1 ⇒ s="odefrces"; 
  * i=7 ⇒ s="odefrcs"; 



Given a given string s, find the lexicographically maximum string that can be obtained after applying a certain sequence of operations after which all characters in the string become unique.

A string a of length n is lexicographically less than a string b of length m, if: 

  * there is an index i (1 ≤ i ≤ min(n, m)) such that the first i-1 characters of the strings a and b are the same, and the i-th character of the string a is less than i-th character of string b; 
  * or the first min(n, m) characters in the strings a and b are the same and n < m. 



For example, the string a="aezakmi" is lexicographically less than the string b="aezus".

Input

The first line contains one integer t (1 ≤ t ≤ 10^4). Then t test cases follow.

Each test case is characterized by a string s, consisting of lowercase Latin letters (1 ≤ |s| ≤ 2 ⋅ 10^5).

It is guaranteed that the sum of the lengths of the strings in all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, output the lexicographically maximum string that can be obtained after applying a certain sequence of operations after which all characters in the string become unique.

Example

Input


6
codeforces
aezakmi
abacaba
convexhull
swflldjgpaxs
myneeocktxpqjpz


Output


odfrces
ezakmi
cba
convexhul
wfldjgpaxs
myneocktxqjpz
Program:
```
from __future__ import division, print_function
from fractions import Fraction
import sys
import os
from io import BytesIO, IOBase
from itertools import *
import bisect
from heapq import *
from math import ceil, floor
from copy import *
from collections import deque, defaultdict
from collections import Counter as counter
from itertools import combinations
from itertools import permutations as permutate
from bisect import bisect_left as bl
from operator import *
from bisect import bisect_right as br
from bisect import bisect
from sys import stderr
from types import GeneratorType
from functools import reduce
from collections import defaultdict
#Function 1:
def func_1(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for A in args:
        if not at_start:
            file.write(sep)
        file.write(str(A))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()

#Function 2:
def func_2(f, stack=[]):

    return wrapped_func

#Function 3:
def wrapped_func(*args, **kwargs):
    if stack:
        return f(*args, **kwargs)
    to = f(*args, **kwargs)
    while True:
        if type(to) is GeneratorType:
            stack.append(to)
            to = next(to)
            continue
        stack.pop()
        if not stack:
            break
        to = stack[-1].send(to)
    return to

#Function 4:
def func_3(t):
    for p in range(t):
        func_29()

#Function 5:
def func_4(A, B, p):
    res = 1
    A = A % p
    if A == 0:
        return 0
    while B > 0:
        if B & 1 == 1:
            res = res * A % p
        B = B >> 1
        A = A * A % p
    return res

#Function 6:
def func_5(n):
    return set(reduce(list.__add__, ([start, n // start] for start in range(1, int(n ** 0.5) + 1) if n % start == 0)))

#Function 7:
def func_6(a, b):
    if a == b:
        return a
    while b > 0:
        (a, b) = (b, a % b)
    return a

#Function 8:
def func_7(ar):
    return list(accumulate(ar))

#Function 9:
def func_8(ar):
    return list(accumulate(ar[::-1]))[::-1]

#Function 10:
def func_9():
    return int(func_17())

#Function 11:
def func_10():
    func_1('YES')

#Function 12:
def func_11():
    func_1('NO')

#Function 13:
def func_12():
    func_1('Yes')

#Function 14:
def func_13():
    func_1('No')

#Function 15:
def func_14(start):
    start = start - (start >> 1 & 1431655765)
    start = (start & 858993459) + (start >> 2 & 858993459)
    return ((start + (start >> 4) & 252645135) * 16843009 & 4294967295) >> 24

#Function 16:
def func_15(a, b):
    return abs(a // func_6(a, b) * b)

#Function 17:
def func_16(n, r):
    if n < r:
        return 0
    else:
        return fac[n] * (finv[r] * finv[n - r] % mod) % mod

#Function 18:
def func_17():
    return sys.stdin.readline().rstrip('\r\n')

#Function 19:
def func_18(var):
    sys.stdout.write(str(var))

#Function 20:
def func_19():
    return list(map(int, func_17().split()))

#Function 21:
def func_20():
    return list(map(str, func_17().split()))

#Function 22:
def func_21():
    return map(int, func_17().split())

#Function 23:
def func_22():
    return map(str, func_17().split())

#Function 24:
def func_23():
    return map(float, func_17().split())

#Function 25:
def func_24():
    func_18('\n')

#Function 26:
def func_25(n, v):
    return [v] * n

#Function 27:
def func_26(n, m, v):
    return [[v] * m for _ in range(n)]

#Function 28:
def func_27(n, m, p, v):
    return [[[v] * p for _ in range(m)] for start in range(n)]

#Function 29:
def func_28(a, b):
    return (a + b - 1) // b

#Function 30:
def func_29():
    s = func_17()
    ans = []
    n = len(s)
    c = counter(s)
    torem = set()
    for i in range(n - 1):
        if s[i] in torem:
            c[s[i]] -= 1
            continue
        if c[s[i]] == 1:
            if ans:
                if s[i] > ans[-1]:
                    if c[ans[-1]] > 0:
                        if ans[-1] in torem:
                            torem.remove(ans[-1])
                        ans.pop()
            ans.append(s[i])
            c[s[i]] -= 1
            continue
        if s[i] < s[i + 1]:
            c[s[i]] -= 1
            continue
        else:
            if ans:
                if s[i] > ans[-1]:
                    if c[ans[-1]] > 0:
                        ans.pop()
            ans.append(s[i])
            torem.add(s[i])
            c[s[i]] -= 1
            continue
    if s[-1] not in torem:
        ans.append(s[-1])
    func_1(''.join(ans))


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
