
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings a and b of equal length are called equivalent in one of the two cases: 

  1. They are equal. 
  2. If we split string a into two halves of the same size a1 and a2, and string b into two halves of the same size b1 and b2, then one of the following is correct: 
    1. a1 is equivalent to b1, and a2 is equivalent to b2
    2. a1 is equivalent to b2, and a2 is equivalent to b1



As a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.

Gerald has already completed this home task. Now it's your turn!

Input

The first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200 000 and consists of lowercase English letters. The strings have the same length.

Output

Print "YES" (without the quotes), if these two strings are equivalent, and "NO" (without the quotes) otherwise.

Examples

Input

aaba
abaa


Output

YES


Input

aabb
abab


Output

NO

Note

In the first sample you should split the first string into strings "aa" and "ba", the second one â€” into strings "ab" and "aa". "aa" is equivalent to "aa"; "ab" is equivalent to "ba" as "ab" = "a" + "b", "ba" = "b" + "a".

In the second sample the first string can be splitted into strings "aa" and "bb", that are equivalent only to themselves. That's why string "aabb" is equivalent only to itself and to string "bbaa".
Program:
```

#Function 1:
def func_1(text1, text2, i1, j1, i2, j2, hash1, hash2):
    mid1 = int((j1 + i1) / 2)
    mid2 = int((j2 + i2) / 2)
    if (j1 - i1) % 4 != 0 or j1 - i1 == 2:
        a1 = hash1.substring_hash(i1, mid1)
        a2 = hash1.substring_hash(mid1, j1)
        b1 = hash2.substring_hash(i2, mid2)
        b2 = hash2.substring_hash(mid2, j2)
        if a1 == b1:
            return a2 == b2
        elif a2 == b1:
            return a1 == b2
        return False
    return func_1(text1, text2, i1, mid1, i2, mid2, hash1, hash2) and func_1(text1, text2, mid1, j1, mid2, j2, hash1, hash2) or (func_1(text1, text2, i1, mid1, mid2, j2, hash1, hash2) and func_1(text1, text2, mid1, j1, i2, mid2, hash1, hash2))

#Function 2:
def func_2(text1, text2):
    hash1 = Hasher(text1)
    hash2 = Hasher(text2)
    return func_1(text1, text2, 0, len(text1), 0, len(text2), hash1, hash2)

#Function 3:
def func_3():
    s1 = raw_input()
    s2 = raw_input()
    print(func_2(s1, s2))


```
Original Assessment: Correctness: **False**.

Explanation:
The program has a few issues that make it incorrect:

1. **Handling Odd-Length Strings**: The function `func_1` assumes that the strings are always of even length or lengths that are multiples of 4. However, the problem description states that the strings can be of any length from 1 to 200,000. This means the function will fail for strings of odd lengths or lengths that are not multiples of 4.

2. **Hashing Mechanism**: The `Hasher` class is mentioned but not defined in the provided code. Without the implementation of the `Hasher` class, it's impossible to verify if the hashing mechanism works correctly.

3. **Edge Cases**: The program does not handle edge cases where the strings are of length 1 or 2 correctly. For example, if both strings are of length 1, they should be considered equivalent if they are the same character. Similarly, for strings of length 2, the function should check if they are equivalent directly without further recursion.

Here is a potential case where the program fails:

- **Input**: 
  ```
  ab
  ba
  ```
- **Expected Output**: 
  ```
  YES
  ```
- **Actual Output**: 
  The program will likely return `NO` because it does not handle strings of length 2 correctly.

To fix these issues, the program needs to handle all possible string lengths and ensure that the `Hasher` class is properly implemented and used. Additionally, edge cases for short strings should be explicitly handled.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
prime = 2 ** 32 - 1
english_base = 30
class Hasher(object):

    def __init__(self, word, modulo=prime):
        self.word = word
        self.modulo = modulo
        self.h = self.compute_hashes(self.word)
        self.powers = self.compute_power(len(self.word))

    def substring_hash(self, i, j):
        result = self.h[j] - self.h[i] * self.powers[j - i]
        return result % self.modulo

    def compute_hashes(self, word, base=english_base, modulo=prime):
        h = [None for _ in range(len(word) + 1)]
        h[0] = 0
        for i in range(len(word)):
            letter_as_number = ord(word[i]) - ord('a') + 1
            h[i + 1] = h[i] * base + letter_as_number
            h[i + 1] %= modulo
        return h

    def compute_power(self, n, base=english_base, modulo=prime):
        powers = [None for _ in range(n + 1)]
        powers[0] = 1
        for i in range(n):
            powers[i + 1] = powers[i] * base % modulo
        return powers
if __name__ == '__main__':
    func_3()

#Function 1:
#State of the program right berfore the function call: text1 and text2 are strings of equal length consisting of lowercase English letters, i1, j1, i2, j2 are integers where 0 <= i1 <= j1 <= len(text1) and 0 <= i2 <= j2 <= len(text2), hash1 and hash2 are objects that provide a substring_hash method which returns a hash value for the substring defined by the indices passed to it.
def func_1(text1, text2, i1, j1, i2, j2, hash1, hash2):
    mid1 = int((j1 + i1) / 2)
    mid2 = int((j2 + i2) / 2)
    if ((j1 - i1) % 4 != 0 or j1 - i1 == 2) :
        a1 = hash1.substring_hash(i1, mid1)
        a2 = hash1.substring_hash(mid1, j1)
        b1 = hash2.substring_hash(i2, mid2)
        b2 = hash2.substring_hash(mid2, j2)
        if (a1 == b1) :
            return a2 == b2
            #The program returns whether the hash value of the substring of `text1` from `mid1` to `j1` (`a2`) is equal to the hash value of the substring of `text2` from `mid2` to `j2` (`b2`).
        else :
            if (a2 == b1) :
                return a1 == b2
                #The program returns False because `a1` is not equal to `b2`.
            #State of the program after the if block has been executed: *`text1` and `text2` are strings of equal length consisting of lowercase English letters, 0 <= `i1` <= `j1` <= len(`text1`), 0 <= `i2` <= `j2` <= len(`text2`), `hash1` and `hash2` are objects that provide a substring_hash method, `mid1` is `(j1 + i1) // 2`, `mid2` is `(j2 + i2) // 2`, the difference `j1 - i1` is either not a multiple of 4 or equal to 2, `a1` is the hash value of the substring of `text1` from `i1` to `mid1`, `a2` is the hash value of the substring of `text1` from `mid1` to `j1`, `b1` is the hash value of the substring of `text2` from `i2` to `mid2`, `b2` is the hash value of the substring of `text2` from `mid2` to `j2`, `a1` is not equal to `b1`, and `a2` is not equal to `b1`.
        #State of the program after the if-else block has been executed: *`text1` and `text2` are strings of equal length consisting of lowercase English letters, 0 <= `i1` <= `j1` <= len(`text1`), 0 <= `i2` <= `j2` <= len(`text2`), `hash1` and `hash2` are objects that provide a substring_hash method, `mid1` is `(j1 + i1) // 2`, `mid2` is `(j2 + i2) // 2`, the difference `j1 - i1` is either not a multiple of 4 or equal to 2, `a1` is the hash value of the substring of `text1` from `i1` to `mid1`, `a2` is the hash value of the substring of `text1` from `mid1` to `j1`, `b1` is the hash value of the substring of `text2` from `i2` to `mid2`, `b2` is the hash value of the substring of `text2` from `mid2` to `j2`, `a1` is not equal to `b1`, and `a2` is not equal to `b1`.
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`text1` and `text2` are strings of equal length consisting of lowercase English letters, 0 <= `i1` <= `j1` <= len(`text1`), 0 <= `i2` <= `j2` <= len(`text2`), `hash1` and `hash2` are objects that provide a substring_hash method which returns a hash value for the substring defined by the indices passed to it, `mid1` is `(j1 + i1) // 2`, `mid2` is `(j2 + i2) // 2`, and (`(j1 - i1) % 4 == 0 and j1 - i1 != 2`)
    return func_1(text1, text2, i1, mid1, i2, mid2, hash1, hash2) and func_1(text1,
    text2, mid1, j1, mid2, j2, hash1, hash2) or func_1(text1, text2, i1,
    mid1, mid2, j2, hash1, hash2) and func_1(text1, text2, mid1, j1, i2,
    mid2, hash1, hash2)
    #The program returns the result of a complex logical expression involving multiple calls to `func_1`. The expression evaluates the AND and OR of the results from these calls, using substrings of `text1` and `text2` defined by the indices `i1`, `mid1`, `j1`, `i2`, `mid2`, and `j2`. The exact value returned depends on the implementation of `func_1` and the content of `text1` and `text2`.

#Function 2:
#State of the program right berfore the function call: text1 and text2 are strings consisting of lowercase English letters, and they have the same length.
def func_2(text1, text2):
    hash1 = Hasher(text1)
    hash2 = Hasher(text2)
    return func_1(text1, text2, 0, len(text1), 0, len(text2), hash1, hash2)
    #The program returns the result of `func_1` with parameters (`text1`, `text2`, 0, `len(text1)`, 0, `len(text2)`, `hash1`, `hash2`). `text1` and `text2` are strings consisting of lowercase English letters and have the same length; `hash1` is the hash representation of `text1`; `hash2` is the hash representation of `text2`.

#Function 3:
#State of the program right berfore the function call: s1 and s2 are strings consisting of lowercase English letters, and their lengths are equal and within the range 1 to 200,000.
def func_3():
    s1 = raw_input()
    s2 = raw_input()
    print(func_2(s1, s2))



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
