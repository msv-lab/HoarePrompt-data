
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.

The current state of the wall can be respresented by a sequence a of n integers, with a_i being the height of the i-th part of the wall.

Vova can only use 2 × 1 bricks to put in the wall (he has infinite supply of them, however).

Vova can put bricks only horizontally on the neighbouring parts of the wall of equal height. It means that if for some i the current height of part i is the same as for part i + 1, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part 1 of the wall or to the right of part n of it).

Note that Vova can't put bricks vertically.

Vova is a perfectionist, so he considers the wall completed when:

  * all parts of the wall has the same height; 
  * the wall has no empty spaces inside it. 



Can Vova complete the wall using any amount of bricks (possibly zero)?

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the number of parts in the wall.

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9) — the initial heights of the parts of the wall.

Output

Print "YES" if Vova can complete the wall using any amount of bricks (possibly zero).

Print "NO" otherwise.

Examples

Input


5
2 1 1 2 5


Output


YES


Input


3
4 5 3


Output


NO


Input


2
10 10


Output


YES

Note

In the first example Vova can put a brick on parts 2 and 3 to make the wall [2, 2, 2, 2, 5] and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it [5, 5, 5, 5, 5].

In the second example Vova can put no bricks in the wall.

In the third example the wall is already complete.
Program:
```
import sys,math
from collections import defaultdict
from io import BytesIO

def func():
    sys.stdin = BytesIO(sys.stdin.read())
    input = lambda : sys.stdin.readline().rstrip('\r\n')
    n = int(input())
    arr = [int(x) for x in input().split(' ')]
    h = max(arr)
    res = list()
    for el in arr:
        if len(res) == 0 or res[-1] != el:
            if len(res) > 0:
                if res[-1] < el:
                    print('NO')
                    exit()
            res.append(el)
        else:
            res.pop()
    if len(res) > 1:
        print('NO')
    elif len(res) == 0:
        print('YES')
    else:
        print('NO' if res[-1] < h else 'YES')


```
Original Assessment: Correctness: **False**.

Explanation: The program does not handle the case where the input array has multiple segments of equal height that cannot be uniformly increased to match the maximum height. For example, consider the input:

```
5
2 1 1 2 4
```

In this case, the program will output `NO`, but the correct output should be `YES` because Vova can place bricks on the segments `[2, 1, 1, 2]` to make them all `3`, and then place more bricks to make all segments `4`.

This shows that the program fails to correctly identify scenarios where multiple segments of equal height can be uniformly increased to match the maximum height, leading to incorrect results.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
import sys,math
from collections import defaultdict
from io import BytesIO

#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 2 ⋅ 10^5, and a is a list of n integers where each integer a_i satisfies 1 ≤ a_i ≤ 10^9.
def func():
    sys.stdin = BytesIO(sys.stdin.read())
    input = lambda : sys.stdin.readline().rstrip('\r\n')
    n = int(input())
    arr = [int(x) for x in input().split(' ')]
    h = max(arr)
    res = list()
    for el in arr:
        if len(res) == 0 or res[-1] != el:
            if len(res) > 0:
                if res[-1] < el:
                    print('NO')
                    exit()
            res.append(el)
        else:
            res.pop()
        
    #State of the program after the  for loop has been executed: - If the loop exits early due to the 'NO' condition, the program terminates and the final state is that 'NO' has been printed.
    #   - If the loop completes without exiting early, `res` will contain a non-decreasing subsequence of elements from `arr`.
    #
    #Therefore, the output state of the loop after all iterations have finished is:
    #
    #Output State:
    if (len(res) > 1) :
        print('NO')
    else :
        if (len(res) == 0) :
            print('YES')
        else :
            print('NO' if res[-1] < h else 'YES')
        #State of the program after the if-else block has been executed: *The loop exits early due to the 'NO' condition, the program terminates and the final state is that 'NO' has been printed, or if the loop completes without exiting early, `res` will contain a non-decreasing subsequence of elements from `arr`. Additionally, the length of `res` is less than or equal to 1. If the length of `res` is 0, 'YES' has been printed. If the length of `res` is greater than 0, the program may have terminated with 'NO' being printed or `res` contains a valid non-decreasing subsequence.
    #State of the program after the if-else block has been executed: *If the length of `res` is greater than 1, 'NO' has been printed. If the length of `res` is 0, 'YES' has been printed. If the length of `res` is 1, the program may have terminated with 'NO' being printed, or `res` contains a valid non-decreasing subsequence of elements from `arr`.
#Overall this is what the function does:This function reads input from standard input, expecting a positive integer `n` (1 ≤ n ≤ 2 ⋅ 10^5) followed by a list of `n` integers (1 ≤ a_i ≤ 10^9). It processes the list to determine if it can be reduced to a non-decreasing subsequence of length 1 or 0. If at any point during processing, it finds that the sequence cannot be reduced to such a subsequence, it prints 'NO' and terminates the program. If the sequence can be reduced to a non-decreasing subsequence of length 1 or 0, it prints 'YES'. The final state of the program is that either 'YES' or 'NO' is printed to the standard output, and the program terminates.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
