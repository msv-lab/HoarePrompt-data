
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: You have a pot and N ingredients. Each ingredient has a real number parameter called value, and the value of the i-th ingredient (1 \leq i \leq N) is v_i.

When you put two ingredients in the pot, they will vanish and result in the formation of a new ingredient. The value of the new ingredient will be (x + y) / 2 where x and y are the values of the ingredients consumed, and you can put this ingredient again in the pot.

After you compose ingredients in this way N-1 times, you will end up with one ingredient. Find the maximum possible value of this ingredient.

Constraints

* 2 \leq N \leq 50
* 1 \leq v_i \leq 1000
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


N
v_1 v_2 \ldots v_N


Output

Print a decimal number (or an integer) representing the maximum possible value of the last ingredient remaining.

Your output will be judged correct when its absolute or relative error from the judge's output is at most 10^{-5}.

Examples

Input

2
3 4


Output

3.5


Input

3
500 300 200


Output

375


Input

5
138 138 138 138 138


Output

138
Program:
```
n = int(input())
v = [float(x) for x in raw_input().split()]
v.sort()
result = v[0]
for i in range(1, n):
    result = func_1(result, v[i])
print(result)

def func_1(a, b):
    return (a + b) / 2


```
Original Assessment: Correctness: **False**.

Explanation:
The program fails to handle the input where `n` is greater than 2, and the values in `v` are not all the same. The issue lies in the sorting step. The program sorts the list `v`, which means that the initial values are not processed in their original order. This can lead to a suboptimal result because the order in which the ingredients are combined affects the final result.

For example, consider the input:
```
3
500 300 200
```

The sorted list will be `[200.0, 300.0, 500.0]`. The program will first combine `200.0` and `300.0` to get `250.0`, and then combine `250.0` and `500.0` to get `375.0`.

However, the optimal way to combine these values to maximize the final result would be to combine `500.0` and `300.0` first to get `400.0`, and then combine `400.0` and `200.0` to get `300.0`, which is not the maximum possible value.

To achieve the maximum possible value, the program should always combine the two largest values at each step. A priority queue (max-heap) could be used to efficiently implement this approach. The current implementation does not ensure this, leading to incorrect results in certain cases.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
n = int(input())
v = [float(x) for x in raw_input().split()]
v.sort()
result = v[0]
for i in range(1, n):
    result = func_1(result, v[i])
print(result)

#State of the program right berfore the function call: a is an integer representing the number of ingredients N such that 2 <= a <= 50, and b is a list of integers representing the values of the ingredients v_i such that 1 <= v_i <= 1000 and len(b) = a.
def func_1(a, b):
    return (a + b) / 2
    #The program returns the value of (a + sum(b)) / 2, where 'a' is an integer between 2 and 50 inclusive, representing the number of ingredients, and 'b' is a list of integers each between 1 and 1000 inclusive, with the length of 'b' equal to 'a'.


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
