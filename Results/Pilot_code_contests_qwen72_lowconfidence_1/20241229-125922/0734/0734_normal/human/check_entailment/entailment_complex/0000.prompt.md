
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There are N squares in a row. The leftmost square contains the integer A, and the rightmost contains the integer B. The other squares are empty.

Aohashi would like to fill the empty squares with integers so that the following condition is satisfied:

* For any two adjacent squares, the (absolute) difference of the two integers in those squares is between C and D (inclusive).



As long as the condition is satisfied, it is allowed to use arbitrarily large or small integers to fill the squares. Determine whether it is possible to fill the squares under the condition.

Constraints

* 3 \leq N \leq 500000
* 0 \leq A \leq 10^9
* 0 \leq B \leq 10^9
* 0 \leq C \leq D \leq 10^9
* All input values are integers.

Input

Input is given from Standard Input in the following format:


N A B C D


Output

Print `YES` if it is possible to fill the squares under the condition; print `NO` otherwise.

Examples

Input

5 1 5 2 4


Output

YES


Input

4 7 6 4 5


Output

NO


Input

48792 105960835 681218449 90629745 90632170


Output

NO


Input

491995 412925347 825318103 59999126 59999339


Output

YES
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
(n, a, b, c, d) = map(int, raw_input().split())
dd = b - a
if dd < 0:
    dd = -dd
l = func_1(n, c, d)
ok = False
for i in range(l, n + 1):
    ll = i * c - (n - i) * d
    rr = i * d - (n - i) * c
    if ll <= dd and rr >= dd:
        ok = True
    if ll > dd:
        break
if ok:
    print('YES')
else:
    print('NO')

#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 500000, c and d are integers such that 0 ≤ c ≤ d ≤ 10^9.
def func_1(n, c, d):
    l = -1
    r = n
    while l + 1 < r:
        mid = (l + r) / 2
        
        if mid * c - (n - mid) * d >= 0:
            r = mid
        else:
            l = mid
        
    #State of the program after the loop has been executed: `l` is the largest integer such that `l * c - (n - l) * d < 0`, `r` is the smallest integer such that `r * c - (n - r) * d >= 0`, `mid` is no longer relevant as the loop has terminated, `n` remains an integer such that 3 ≤ n ≤ 500000, `c` and `d` remain integers such that 0 ≤ c ≤ d ≤ 10^9.
    return r
    #The program returns `r`, which is the smallest integer such that `r * c - (n - r) * d >= 0`. Here, `r` is determined based on the initial conditions where `n` is an integer such that 3 ≤ n ≤ 500000, and `c` and `d` are integers such that 0 ≤ c ≤ d ≤ 10^9.
#Overall this is what the function does:The function `func_1` accepts three parameters `n`, `c`, and `d`, where `n` is an integer such that 3 ≤ n ≤ 500000, and `c` and `d` are integers such that 0 ≤ c ≤ d ≤ 10^9. It returns the smallest integer `r` such that `r * c - (n - r) * d >= 0`. The function uses a binary search approach to find this value of `r`. After the function concludes, `r` is the smallest integer satisfying the condition, and the values of `n`, `c`, and `d` remain unchanged. Edge cases include when `c` is 0, in which case `r` will always be 0, and when `d` is 0, in which case `r` will be `n`.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
