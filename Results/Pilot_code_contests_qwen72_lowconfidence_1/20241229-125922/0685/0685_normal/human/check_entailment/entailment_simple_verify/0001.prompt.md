
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: The cities of Byteland and Berland are located on the axis Ox. In addition, on this axis there are also disputed cities, which belong to each of the countries in their opinion. Thus, on the line Ox there are three types of cities:

  * the cities of Byteland, 
  * the cities of Berland, 
  * disputed cities. 



Recently, the project BNET has been launched — a computer network of a new generation. Now the task of the both countries is to connect the cities so that the network of this country is connected.

The countries agreed to connect the pairs of cities with BNET cables in such a way that:

  * If you look at the only cities of Byteland and the disputed cities, then in the resulting set of cities, any city should be reachable from any other one by one or more cables, 
  * If you look at the only cities of Berland and the disputed cities, then in the resulting set of cities, any city should be reachable from any other one by one or more cables. 



Thus, it is necessary to choose a set of pairs of cities to connect by cables in such a way that both conditions are satisfied simultaneously. Cables allow bi-directional data transfer. Each cable connects exactly two distinct cities.

The cost of laying a cable from one city to another is equal to the distance between them. Find the minimum total cost of laying a set of cables so that two subsets of cities (Byteland and disputed cities, Berland and disputed cities) are connected.

Each city is a point on the line Ox. It is technically possible to connect the cities a and b with a cable so that the city c (a < c < b) is not connected to this cable, where a, b and c are simultaneously coordinates of the cities a, b and c.

Input

The first line contains a single integer n (2 ≤ n ≤ 2 ⋅ 10^{5}) — the number of cities.

The following n lines contains an integer x_i and the letter c_i (-10^{9} ≤ x_i ≤ 10^{9}) — the coordinate of the city and its type. If the city belongs to Byteland, c_i equals to 'B'. If the city belongs to Berland, c_i equals to «R». If the city is disputed, c_i equals to 'P'. 

All cities have distinct coordinates. Guaranteed, that the cities are given in the increasing order of their coordinates.

Output

Print the minimal total length of such set of cables, that if we delete all Berland cities (c_i='R'), it will be possible to find a way from any remaining city to any other remaining city, moving only by cables. Similarly, if we delete all Byteland cities (c_i='B'), it will be possible to find a way from any remaining city to any other remaining city, moving only by cables.

Examples

Input

4
-5 R
0 P
3 P
7 B


Output

12


Input

5
10 R
14 B
16 B
21 R
32 R


Output

24

Note

In the first example, you should connect the first city with the second, the second with the third, and the third with the fourth. The total length of the cables will be 5 + 3 + 4 = 12.

In the second example there are no disputed cities, so you need to connect all the neighboring cities of Byteland and all the neighboring cities of Berland. The cities of Berland have coordinates 10, 21, 32, so to connect them you need two cables of length 11 and 11. The cities of Byteland have coordinates 14 and 16, so to connect them you need one cable of length 2. Thus, the total length of all cables is 11 + 11 + 2 = 24.
Program:
```
n = int(raw_input())
a = []
for i in range(n):
    (x, y) = raw_input().split()
    x = int(x)
    a.append([x, y])
first = -1
last = -1
ans = 0
for i in range(n):
    if a[i][1] == 'P':
        if first == -1:
            first = i
        else:
            ans += func_1(a[last][0], a[i][0], a[last + 1:i])
        last = i
    ans1 = 0
r = []
b = []
if first != -1:
    for i in a[:first]:
        if i[1] == 'R':
            r.append(i[0])
        elif i[1] == 'B':
            b.append(i[0])
    for i in range(len(r) - 1):
        ans += r[i + 1] - r[i]
    for i in range(len(b) - 1):
        ans += b[i + 1] - b[i]
    if len(r):
        ans += a[first][0] - r[-1]
    if len(b):
        ans += a[first][0] - b[-1]
    r = []
    b = []
    for i in a[last:]:
        if i[1] == 'R':
            r.append(i[0])
        elif i[1] == 'B':
            b.append(i[0])
    for i in range(len(r) - 1):
        ans += r[i + 1] - r[i]
    for i in range(len(b) - 1):
        ans += b[i + 1] - b[i]
    if len(r):
        ans += r[0] - a[last][0]
    if len(b):
        ans += b[0] - a[last][0]
else:
    r = []
    b = []
    for i in a:
        if i[1] == 'R':
            r.append(i[0])
        elif i[1] == 'B':
            b.append(i[0])
    for i in range(len(r) - 1):
        ans += r[i + 1] - r[i]
    for i in range(len(b) - 1):
        ans += b[i + 1] - b[i]
print(ans)

def func_1(p1, p2, a1):
    ans1 = 0
    r = []
    b = []
    for i in a1:
        if i[1] == 'R':
            r.append(i[0])
        elif i[1] == 'B':
            b.append(i[0])
    ans1 = 2 * (p2 - p1)
    ans2 = p2 - p1
    if len(r):
        L = [r[0] - p1]
        R = [p2 - r[-1]]
        for i in range(1, len(r)):
            L.append(r[i] - r[i - 1] + L[-1])
        for i in range(len(r) - 1, 0, -1):
            R.append(r[i] - r[i - 1] + R[-1])
        min1 = min(L[-1], R[-1])
        for i in range(len(r) - 1):
            min1 = min(min1, L[i] + R[len(r) - i - 2])
        ans2 += min1
    if len(b):
        L = [b[0] - p1]
        R = [p2 - b[-1]]
        for i in range(1, len(b)):
            L.append(b[i] - b[i - 1] + L[-1])
        for i in range(len(b) - 1, 0, -1):
            R.append(b[i] - b[i - 1] + R[-1])
        min1 = min(L[-1], R[-1])
        for i in range(len(b) - 1):
            min1 = min(min1, L[i] + R[len(b) - i - 2])
        ans2 += min1
    return min(ans1, ans2)


```
Original Assessment: Correctness: **True**

Explanation:
The program appears to handle all the specified requirements of the problem description. It correctly processes the input to identify and connect cities in such a way that the cities of Byteland and the disputed cities form a connected component, and similarly for the cities of Berland and the disputed cities. The program calculates the minimum total cost of laying cables to achieve this connectivity.

The logic of the program is broken down into several parts:
1. **Initialization and Input Reading**: The program reads the number of cities and their coordinates and types.
2. **Handling Disputed Cities**: It identifies the first and last disputed cities and ensures that all cities between these points are connected, considering the cities of both countries.
3. **Connecting Non-Disputed Cities**: For segments without disputed cities, it connects the cities of the same country directly.
4. **Edge Cases**: The program handles cases where there are no disputed cities or where the first or last city is a disputed city.

The function `func_1` is used to calculate the minimum cost to connect cities between two disputed cities, considering the presence of Byteland and Berland cities. This function ensures that the connections are made in a way that minimizes the total cable length.

Given the problem constraints and the examples provided, the program seems to cover all potential cases and correctly computes the minimum total cost of laying the cables. Therefore, the program is considered correct.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
n = int(raw_input())
a = []
for i in range(n):
    (x, y) = raw_input().split()
    x = int(x)
    a.append([x, y])
first = -1
last = -1
ans = 0
for i in range(n):
    if a[i][1] == 'P':
        if first == -1:
            first = i
        else:
            ans += func_1(a[last][0], a[i][0], a[last + 1:i])
        last = i
    ans1 = 0
r = []
b = []
if first != -1:
    for i in a[:first]:
        if i[1] == 'R':
            r.append(i[0])
        elif i[1] == 'B':
            b.append(i[0])
    for i in range(len(r) - 1):
        ans += r[i + 1] - r[i]
    for i in range(len(b) - 1):
        ans += b[i + 1] - b[i]
    if len(r):
        ans += a[first][0] - r[-1]
    if len(b):
        ans += a[first][0] - b[-1]
    r = []
    b = []
    for i in a[last:]:
        if i[1] == 'R':
            r.append(i[0])
        elif i[1] == 'B':
            b.append(i[0])
    for i in range(len(r) - 1):
        ans += r[i + 1] - r[i]
    for i in range(len(b) - 1):
        ans += b[i + 1] - b[i]
    if len(r):
        ans += r[0] - a[last][0]
    if len(b):
        ans += b[0] - a[last][0]
else:
    r = []
    b = []
    for i in a:
        if i[1] == 'R':
            r.append(i[0])
        elif i[1] == 'B':
            b.append(i[0])
    for i in range(len(r) - 1):
        ans += r[i + 1] - r[i]
    for i in range(len(b) - 1):
        ans += b[i + 1] - b[i]
print(ans)

#State of the program right berfore the function call: p1 and p2 are tuples representing the coordinates and types of the cities, where each tuple is structured as (x_i, c_i), x_i is an integer representing the coordinate of the city, and c_i is a character ('B', 'R', or 'P') indicating the type of the city (Byteland, Berland, or disputed, respectively). a1 is an integer representing the number of cities, such that 2 ≤ a1 ≤ 2 ⋅ 10^5. All x_i are distinct integers within the range -10^9 ≤ x_i ≤ 10^9, and the cities are given in the increasing order of their coordinates.
def func_1(p1, p2, a1):
    ans1 = 0
    r = []
    b = []
    for i in a1:
        if i[1] == 'R':
            r.append(i[0])
        elif i[1] == 'B':
            b.append(i[0])
        
    #State of the program after the  for loop has been executed: `p1` and `p2` are tuples representing the coordinates and types of the cities, `a1` is an integer such that \(2 \leq a1 \leq 2 \cdot 10^5\), all \(x_i\) are distinct integers within the range \(-10^9 \leq x_i \leq 10^9\), and the cities are given in the increasing order of their coordinates. `ans1` is 0, `r` is a list containing the coordinates of all cities of type 'R', `b` is a list containing the coordinates of all cities of type 'B'.
    ans1 = 2 * (p2 - p1)
    ans2 = p2 - p1
    if len(r) :
        L = [r[0] - p1]
        R = [p2 - r[-1]]
        for i in range(1, len(r)):
            L.append(r[i] - r[i - 1] + L[-1])
            
        #State of the program after the  for loop has been executed: `p1` and `p2` are tuples representing the coordinates and types of the cities, `a1` is an integer such that \(2 \leq a1 \leq 2 \cdot 10^5\), all \(x_i\) are distinct integers within the range \(-10^9 \leq x_i \leq 10^9\), the cities are given in the increasing order of their coordinates, `ans1` is \(2 \times (p2 - p1)\), `ans2` is \(p2 - p1\), `r` is a list containing the coordinates of all cities of type 'R' and must have at least 1 element, `b` is a list containing the coordinates of all cities of type 'B', `L` is `[r[0] - p1, r[1] - p1, r[2] - p1, ..., r[len(r) - 1] - p1]`, `R` is `[p2 - r[-1]]`.
        for i in range(len(r) - 1, 0, -1):
            R.append(r[i] - r[i - 1] + R[-1])
            
        #State of the program after the  for loop has been executed: `p1` and `p2` are tuples representing the coordinates and types of the cities, `a1` is an integer such that \(2 \leq a1 \leq 2 \cdot 10^5\), all \(x_i\) are distinct integers within the range \(-10^9 \leq x_i \leq 10^9\), the cities are given in the increasing order of their coordinates, `ans1` is \(2 \times (p2 - p1)\), `ans2` is \(p2 - p1\), `r` is a list containing the coordinates of all cities of type 'R' and must have at least 1 element, `b` is a list containing the coordinates of all cities of type 'B', `L` is `[r[0] - p1, r[1] - p1, r[2] - p1, ..., r[len(r) - 1] - p1]`, `R` is `[p2 - r[-1], p2 - r[len(r) - 2], p2 - r[len(r) - 3], ..., p2 - r[0]]`.
        min1 = min(L[-1], R[-1])
        for i in range(len(r) - 1):
            min1 = min(min1, L[i] + R[len(r) - i - 2])
            
        #State of the program after the  for loop has been executed: `p1` and `p2` are tuples representing the coordinates and types of the cities, `a1` is an integer such that \(2 \leq a1 \leq 2 \cdot 10^5\), all \(x_i\) are distinct integers within the range \(-10^9 \leq x_i \leq 10^9\), the cities are given in the increasing order of their coordinates, `ans1` is \(2 \times (p2 - p1)\), `ans2` is \(p2 - p1\), `r` is a list containing the coordinates of all cities of type 'R' and must have at least 1 element, `b` is a list containing the coordinates of all cities of type 'B', `L` is `[r[0] - p1, r[1] - p1, r[2] - p1, ..., r[len(r) - 1] - p1]`, `R` is `[p2 - r[-1], p2 - r[len(r) - 2], p2 - r[len(r) - 3], ..., p2 - r[0]]`, `min1` is the minimum of `r[len(r) - 1] - p1`, `p2 - r[0]`, and the sums `L[i] + R[len(r) - i - 2]` for all `i` in the range `0` to `len(r) - 2`.
        ans2 += min1
    #State of the program after the if block has been executed: *`p1` and `p2` are tuples representing the coordinates and types of the cities, `a1` is an integer such that \(2 \leq a1 \leq 2 \cdot 10^5\), all \(x_i\) are distinct integers within the range \(-10^9 \leq x_i \leq 10^9\), and the cities are given in the increasing order of their coordinates. `ans1` is \(2 \times (p2 - p1)\). If `r` is not empty, `ans2` is \(p2 - p1 + \text{min1}\), where `min1` is the minimum of `r[len(r) - 1] - p1`, `p2 - r[0]`, and the sums `L[i] + R[len(r) - i - 2]` for all `i` in the range `0` to `len(r) - 2`. Additionally, `L` is `[r[0] - p1, r[1] - p1, r[2] - p1, ..., r[len(r) - 1] - p1]` and `R` is `[p2 - r[-1], p2 - r[len(r) - 2], p2 - r[len(r) - 3], ..., p2 - r[0]]`. If `r` is empty, `ans2` remains \(p2 - p1\).
    if len(b) :
        L = [b[0] - p1]
        R = [p2 - b[-1]]
        for i in range(1, len(b)):
            L.append(b[i] - b[i - 1] + L[-1])
            
        #State of the program after the  for loop has been executed: `p1` and `p2` are tuples representing the coordinates and types of the cities, `a1` is an integer such that \(2 \leq a1 \leq 2 \cdot 10^5\), all \(x_i\) are distinct integers within the range \(-10^9 \leq x_i \leq 10^9\), and the cities are given in the increasing order of their coordinates, `ans1` is \(2 \times (p2 - p1)\), if `r` is not empty, `ans2` is \(p2 - p1 + \text{min1}\), where `min1` is the minimum of `r[len(r) - 1] - p1`, `p2 - r[0]`, and the sums `L[i] + R[len(r) - i - 2]` for all `i` in the range `0` to `len(r) - 2`. If `r` is empty, `ans2` remains \(p2 - p1\), the length of `b` is greater than 0, `L` is `[b[0] - p1, b[1] - p1, ..., b[len(b) - 1] - p1]`, `R` is `[p2 - b[-1]]`.
        for i in range(len(b) - 1, 0, -1):
            R.append(b[i] - b[i - 1] + R[-1])
            
        #State of the program after the  for loop has been executed: `p1` and `p2` are tuples representing the coordinates and types of the cities, `a1` is an integer such that \(2 \leq a1 \leq 2 \cdot 10^5\), all \(x_i\) are distinct integers within the range \(-10^9 \leq x_i \leq 10^9\), the cities are given in the increasing order of their coordinates, `ans1` is \(2 \times (p2 - p1)\), if `r` is not empty, `ans2` is \(p2 - p1 + \text{min1}\), where `min1` is the minimum of `r[len(r) - 1] - p1`, `p2 - r[0]`, and the sums `L[i] + R[len(r) - i - 2]` for all `i` in the range `0` to `len(r) - 2`, if `r` is empty, `ans2` remains \(p2 - p1\), the length of `b` is greater than 0, `L` is `[b[0] - p1, b[1] - p1, ..., b[len(b) - 1] - p1]`, `R` is `[p2 - b[-1], p2 - b[-2], p2 - b[-3], ..., p2 - b[0]]`.
        min1 = min(L[-1], R[-1])
        for i in range(len(b) - 1):
            min1 = min(min1, L[i] + R[len(b) - i - 2])
            
        #State of the program after the  for loop has been executed: `p1` and `p2` are tuples representing the coordinates and types of the cities, `a1` is an integer such that \(2 \leq a1 \leq 2 \cdot 10^5\), all \(x_i\) are distinct integers within the range \(-10^9 \leq x_i \leq 10^9\), the cities are given in the increasing order of their coordinates, `ans1` is \(2 \times (p2 - p1)\), if `r` is not empty, `ans2` is \(p2 - p1 + \text{min1}\), where `min1` is the minimum of `b[len(b) - 1] - p1`, `p2 - b[0]`, and the sums `L[i] + R[len(b) - i - 2]` for all `i` in the range `0` to `len(b) - 2`, if `r` is empty, `ans2` remains \(p2 - p1\), `L` is `[b[0] - p1, b[1] - p1, ..., b[len(b) - 1] - p1]`, `R` is `[p2 - b[-1], p2 - b[-2], p2 - b[-3], ..., p2 - b[0]]`.
        ans2 += min1
    #State of the program after the if block has been executed: *`p1` and `p2` are tuples representing the coordinates and types of the cities, `a1` is an integer such that \(2 \leq a1 \leq 2 \cdot 10^5\), all \(x_i\) are distinct integers within the range \(-10^9 \leq x_i \leq 10^9\), and the cities are given in the increasing order of their coordinates. `ans1` is \(2 \times (p2 - p1)\). If `b` is not empty, `ans2` is \(p2 - p1 + 2 \times \text{min1}\), where `min1` is the minimum of `b[len(b) - 1] - p1`, `p2 - b[0]`, and the sums `L[i] + R[len(b) - i - 2]` for all `i` in the range `0` to `len(b) - 2`. Additionally, `L` is `[b[0] - p1, b[1] - p1, ..., b[len(b) - 1] - p1]` and `R` is `[p2 - b[-1], p2 - b[-2], p2 - b[-3], ..., p2 - b[0]]`. If `b` is empty, `ans2` remains \(p2 - p1\).
    return min(ans1, ans2)
    #The program returns the minimum value between `ans1` and `ans2`, where `ans1` is \(2 \times (p2 - p1)\), and `ans2` is calculated as \(p2 - p1 + 2 \times \text{min1}\) if `b` is not empty. If `b` is empty, `ans2` is \(p2 - p1\). Here, `min1` is the minimum of `b[len(b) - 1] - p1`, `p2 - b[0]`, and the sums `L[i] + R[len(b) - i - 2]` for all `i` in the range `0` to `len(b) - 2`. `L` is `[b[0] - p1, b[1] - p1, ..., b[len(b) - 1] - p1]` and `R` is `[p2 - b[-1], p2 - b[-2], p2 - b[-3], ..., p2 - b[0]]`.


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
