
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Polycarp plays a well-known computer game (we won't mention its name). In this game, he can craft tools of two types — shovels and swords. To craft a shovel, Polycarp spends two sticks and one diamond; to craft a sword, Polycarp spends two diamonds and one stick.

Each tool can be sold for exactly one emerald. How many emeralds can Polycarp earn, if he has a sticks and b diamonds?

Input

The first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases.

The only line of each test case contains two integers a and b (0 ≤ a, b ≤ 10^9) — the number of sticks and the number of diamonds, respectively.

Output

For each test case print one integer — the maximum number of emeralds Polycarp can earn.

Example

Input


4
4 4
1000000000 0
7 15
8 7


Output


2
0
7
5

Note

In the first test case Polycarp can earn two emeralds as follows: craft one sword and one shovel.

In the second test case Polycarp does not have any diamonds, so he cannot craft anything.
Program:
```
from __future__ import division, print_function
import sys
from bisect import bisect_left, bisect_right, insort
from math import floor, ceil, sqrt, degrees, atan, pi, log, sin, radians, factorial
from heapq import heappop, heapify, heappush
from collections import Counter, defaultdict, deque
import os, sys
from io import IOBase, BytesIO
#Function 1:
def func_1():
    fact = [1]
    for i in range(1, 20):
        fact.append(fact[-1] * i % mod)
    ifact = [0] * 105
    ifact[104] = pow(fact[104], mod - 2, mod)
    for i in range(104, 0, -1):
        ifact[i - 1] = i * ifact[i] % mod
    return (fact, ifact)

#Function 2:
def func_2(n, p):
    return pow(n, p - 2, p)

#Function 3:
def func_3(n, r, fact, ifact):
    t = fact[n] * (ifact[r] * ifact[n - r]) % mod % mod
    return t

#Function 4:
def func_4():
    return map(int, sys.stdin.readline().strip().split())

#Function 5:
def func_5():
    return list(map(int, sys.stdin.readline().strip().split()))

#Function 6:
def func_6():
    return sys.stdin.readline().strip()

#Function 7:
def func_7(x, y):
    while y:
        (x, y) = (y, x % y)
    return x

#Function 8:
def func_8(x, y):
    return x * y // func_7(x, y)

#Function 9:
def func_9(n):
    return [n, 1, n + 1, 0][n % 4]

#Function 10:
def func_10(P):
    ans = (-1 + sqrt(1 + 8 * P)) // 2
    return ans

#Function 11:
def func_11():
    for _ in range(int(func_6())):
        (l, r) = func_4()
        print(min(l, r, (l + r) // 3))


```
Original Assessment: Correctness: **False**

Explanation: The provided program does not match the problem description. Specifically, the function `func_11` is supposed to solve the problem of calculating the maximum number of emeralds Polycarp can earn by crafting shovels and swords. However, the implementation of `func_11` does not correctly handle the logic required to solve this problem. 

For example, consider the input:
```
4 4
```
According to the problem, Polycarp can craft 2 shovels and 2 swords, earning 4 emeralds in total. However, the function `func_11` will output `2`, which is incorrect.

The function `func_11` currently calculates the minimum of the number of sticks, the number of diamonds, and one-third of their sum, which does not align with the logic needed to maximize the number of emeralds by crafting shovels and swords. Therefore, the program is incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import sys
from bisect import bisect_left, bisect_right, insort
from math import floor, ceil, sqrt, degrees, atan, pi, log, sin, radians, factorial
from heapq import heappop, heapify, heappush
from collections import Counter, defaultdict, deque
import os, sys
from io import IOBase, BytesIO

MOD = 998244353
mod = 10 ** 9 + 7
'*****************************************************************************************'
' ********************************************************************************************* '
' -------- Python 2 and 3 footer by Pajenegod and c1729 ---------'
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = 'x' in file.mode or 'w' in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b'\n') + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            (self.truncate(0), self.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode('ascii'))
            self.read = lambda : self.buffer.read().decode('ascii')
            self.readline = lambda : self.buffer.readline().decode('ascii')
(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_11()

#Function 1:
#State of the program right berfore the function call: None. This function does not take any parameters. It initializes and returns two lists, `fact` and `ifact`, which are related to factorials and their modular inverses.
def func_1():
    fact = [1]
    for i in range(1, 20):
        fact.append(fact[-1] * i % mod)
        
    #State of the program after the  for loop has been executed: `fact` = [1, 1 % mod, 2 % mod, (2 % mod) * 3 % mod, ..., (19! % mod)], `i` is 19, the range is from 1 to 19 (inclusive)
    ifact = [0] * 105
    ifact[104] = pow(fact[104], mod - 2, mod)
    for i in range(104, 0, -1):
        ifact[i - 1] = i * ifact[i] % mod
        
    #State of the program after the  for loop has been executed: `fact` = [1, 1 % mod, 2 % mod, (2 % mod) * 3 % mod, ..., (19! % mod)], `i` is 0, `ifact` = [0] * 105, `ifact[104]` = `pow(fact[104], mod - 2, mod)`, `ifact[103]` = `104 * ifact[104] % mod`, `ifact[102]` = `103 * ifact[103] % mod`, ..., `ifact[0]` = `1 * ifact[1] % mod`
    return fact, ifact
    #The program returns `fact` which is a list containing the factorial of numbers from 0 to 19 modulo `mod`, and `ifact` which is a list containing the modular multiplicative inverses of the factorials in `fact` modulo `mod`. The lists are precomputed as described in the initial state.
#Overall this is what the function does:The function `func_1` does not accept any parameters. It initializes and returns two lists, `fact` and `ifact`. 

- `fact` is a list containing the factorial of numbers from 0 to 19, each computed modulo `mod`.
- `ifact` is a list containing the modular multiplicative inverses of the factorials in `fact`, also computed modulo `mod`.

The function computes the factorials and their modular inverses up to 19 and 104 respectively. However, there is a discrepancy in the size of the `ifact` list: while it is initialized to have 105 elements, only the last 104 elements (from index 1 to 104) are populated with the correct modular inverses. The first element (`ifact[0]`) remains 0, which might be an unintended side effect or a potential edge case depending on the intended use of the function. After the function executes, it returns the two lists `fact` and `ifact`.

#Function 2:
#State of the program right berfore the function call: n and p are integers, p is a positive integer greater than 1.
def func_2(n, p):
    return pow(n, p - 2, p)
    #The program returns the result of `n` raised to the power of `p - 2`, modulo `p`, where `n` and `p` are integers and `p` is a positive integer greater than 1.
#Overall this is what the function does:The function `func_2` accepts two parameters `n` and `p`, where `n` is an integer and `p` is a positive integer greater than 1. It returns the result of `n` raised to the power of `p - 2`, modulo `p`. This effectively computes the modular inverse of `n` under modulo `p` when `n` and `p` are coprime. If `n` and `p` are not coprime, the result may not be meaningful as a modular inverse.

#Function 3:
#State of the program right berfore the function call: n and r are non-negative integers such that 0 <= r <= n, and fact and ifact are lists of integers where fact[i] represents the factorial of i and ifact[i] represents the modular multiplicative inverse of the factorial of i, under a modulus mod.
def func_3(n, r, fact, ifact):
    t = fact[n] * (ifact[r] * ifact[n - r]) % mod % mod
    return t
    #The program returns the value of `t`, which is calculated as `fact[n] * (ifact[r] * ifact[n - r]) % mod % mod`. Here, `fact[n]` is the factorial of `n`, `ifact[r]` is the modular multiplicative inverse of the factorial of `r` under modulus `mod`, and `ifact[n - r]` is the modular multiplicative inverse of the factorial of `n - r` under modulus `mod`.
#Overall this is what the function does:The function `func_3` takes four parameters: `n`, `r`, `fact`, and `ifact`. It calculates the value of `t` as `fact[n] * (ifact[r] * ifact[n - r]) % mod % mod`, where `fact[n]` is the factorial of `n`, `ifact[r]` is the modular multiplicative inverse of the factorial of `r` under modulus `mod`, and `ifact[n - r]` is the modular multiplicative inverse of the factorial of `n - r` under modulus `mod`. The function returns the value of `t`.

The function assumes that `n` and `r` are non-negative integers with `0 <= r <= n`, and that `fact` and `ifact` are precomputed lists where `fact[i]` and `ifact[i]` are the factorial and modular multiplicative inverse of `i` under modulus `mod`, respectively. The function does not handle cases where `r` is greater than `n` or where `n` or `r` are negative, and it relies on the correctness and completeness of the `fact` and `ifact` lists.

#Function 4:
#State of the program right berfore the function call: None of the variables are passed as arguments to the function `func_4`. This function reads input from stdin, expecting a line of space-separated integers.
def func_4():
    return map(int, sys.stdin.readline().strip().split())
    #The program returns an iterator of integers converted from a line of space-separated integers read from stdin.
#Overall this is what the function does:The function `func_4` reads a single line of input from standard input (stdin), expecting the line to contain space-separated integers. It then converts each string in the line to an integer and returns an iterator of these integers. If the input contains non-integer values or is empty, the behavior is undefined and may result in a `ValueError` or an empty iterator, respectively. The function does not modify any external state or variables and only returns the iterator.

#Function 5:
#State of the program right berfore the function call: None of the variables are passed as arguments to the function. This function reads input from stdin and returns a list of integers.
def func_5():
    return list(map(int, sys.stdin.readline().strip().split()))
    #The program returns a list of integers read from the standard input (stdin), where each integer is obtained by splitting the input line by spaces, stripping any leading or trailing whitespace, and converting each split part into an integer.
#Overall this is what the function does:The function `func_5` does not accept any parameters. It reads a single line of input from the standard input (stdin), splits the line by spaces, trims any leading or trailing whitespace, converts each split part into an integer, and returns a list of these integers. If the input line is empty or contains only whitespace, the function will return an empty list. If the input contains non-integer values, a `ValueError` will be raised.

#Function 6:
#State of the program right berfore the function call: This function does not take any parameters and is not directly related to the variables a and b from the problem description. It reads a single line from standard input, which could be part of a larger program that processes input for multiple test cases.
def func_6():
    return sys.stdin.readline().strip()
    #The program returns a string read from standard input, with leading and trailing whitespace removed.
#Overall this is what the function does:The function `func_6` does not accept any parameters. It reads a single line from standard input and returns this line as a string with leading and trailing whitespace removed. If the input line is empty or contains only whitespace, the function will return an empty string. The function does not modify any external state or variables and is purely focused on reading and processing a single line of input.

#Function 7:
#State of the program right berfore the function call: x and y are non-negative integers.
def func_7(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the GCD of the original values of `x` and `y`
    return x
    #The program returns the GCD of the original values of `x` and `y`, where `y` is 0.
#Overall this is what the function does:The function `func_7` accepts two non-negative integer parameters `x` and `y`. It computes and returns the Greatest Common Divisor (GCD) of the original values of `x` and `y`. After the function executes, `y` is guaranteed to be 0, and `x` holds the GCD of the original values of `x` and `y`. The function handles edge cases where either `x` or `y` is 0 by correctly returning the non-zero value as the GCD.

#Function 8:
#State of the program right berfore the function call: x and y are non-negative integers representing the number of sticks and diamonds, respectively, such that 0 <= x, y <= 10^9.
def func_8(x, y):
    return x * y // func_7(x, y)
    #The program returns the integer division of the product of x and y by the result of func_7(x, y), where x and y are non-negative integers representing the number of sticks and diamonds, respectively, such that 0 <= x, y <= 10^9.
#Overall this is what the function does:The function `func_8` accepts two parameters `x` and `y`, both of which are non-negative integers (0 <= x, y <= 10^9). It returns the integer division of the product of `x` and `y` by the result of `func_7(x, y)`. If `func_7(x, y)` returns 0, a ZeroDivisionError will be raised. The function does not modify the input parameters `x` and `y`. After the function concludes, the state of the program remains unchanged except for the returned value.

#Function 9:
#State of the program right berfore the function call: n is an integer.
def func_9(n):
    return [n, 1, n + 1, 0][n % 4]
    #The program returns n if n % 4 == 0, returns 1 if n % 4 == 1, returns n + 1 if n % 4 == 2, and returns 0 if n % 4 == 3.
#Overall this is what the function does:The function `func_9` accepts an integer `n` and returns a value based on the remainder when `n` is divided by 4. Specifically, it returns `n` if `n % 4 == 0`, returns `1` if `n % 4 == 1`, returns `n + 1` if `n % 4 == 2`, and returns `0` if `n % 4 == 3`. The function covers all possible remainders (0, 1, 2, 3) when dividing by 4, ensuring that every integer input results in one of these four outputs. There are no missing functionalities or edge cases in the provided code.

#Function 10:
#State of the program right berfore the function call: P is a non-negative integer.
def func_10(P):
    ans = (-1 + sqrt(1 + 8 * P)) // 2
    return ans
    #The program returns the value of `ans` which is calculated as `(-1 + sqrt(1 + 8 * P)) // 2`, where `P` is a non-negative integer.
#Overall this is what the function does:The function `func_10` accepts a non-negative integer `P` and returns the largest integer `ans` such that the sum of the first `ans` natural numbers (i.e., `1 + 2 + ... + ans`) is less than or equal to `P`. The function calculates `ans` using the formula `(-1 + sqrt(1 + 8 * P)) // 2`. If `P` is negative, the function will raise a `ValueError` due to the square root of a negative number. For valid non-negative inputs, the function will always return a non-negative integer.

#Function 11:
#State of the program right berfore the function call: No input parameters are present in the function signature. The function internally uses values returned by `func_6()` and `func_4()`, where `func_6()` should return an integer representing the number of test cases, and `func_4()` should return a tuple of two integers (l, r) representing the number of sticks and diamonds, respectively.
def func_11():
    for _ in range(int(func_6())):
        l, r = func_4()
        
        print(min(l, r, (l + r) // 3))
        
    #State of the program after the  for loop has been executed: `func_6()` must return an integer greater than or equal to 0. If `func_6()` returns 0, the loop does not execute, and no values of `l` or `r` are defined. If `func_6()` returns an integer greater than 0, the loop executes that many times. For each iteration, `l` and `r` are integers returned by `func_4()`, and the minimum of `l`, `r`, and `(l + r) // 3` is printed. After the loop completes, no variables are modified or retained outside the loop, except for the side effect of the printed values.
#Overall this is what the function does:The function `func_11` does not accept any parameters. It retrieves the number of test cases from the function `func_6()`, which should return a non-negative integer. For each test case, it calls `func_4()` to get a tuple of two integers `(l, r)` representing the number of sticks and diamonds, respectively. The function then calculates the minimum value among `l`, `r`, and `(l + r) // 3` and prints this value. If `func_6()` returns 0, the loop does not execute, and no values are printed. After the loop completes, no variables are retained outside the loop, and the only side effect is the printed values. Edge cases include `func_6()` returning 0 (resulting in no iterations), and `func_4()` returning negative values or non-integer values, which are not explicitly handled in the code.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
