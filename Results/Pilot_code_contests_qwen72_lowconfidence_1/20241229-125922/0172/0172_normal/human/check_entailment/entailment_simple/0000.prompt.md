
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Polycarp plays a well-known computer game (we won't mention its name). In this game, he can craft tools of two types — shovels and swords. To craft a shovel, Polycarp spends two sticks and one diamond; to craft a sword, Polycarp spends two diamonds and one stick.

Each tool can be sold for exactly one emerald. How many emeralds can Polycarp earn, if he has a sticks and b diamonds?

Input

The first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases.

The only line of each test case contains two integers a and b (0 ≤ a, b ≤ 10^9) — the number of sticks and the number of diamonds, respectively.

Output

For each test case print one integer — the maximum number of emeralds Polycarp can earn.

Example

Input


4
4 4
1000000000 0
7 15
8 7


Output


2
0
7
5

Note

In the first test case Polycarp can earn two emeralds as follows: craft one sword and one shovel.

In the second test case Polycarp does not have any diamonds, so he cannot craft anything.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import sys
from bisect import bisect_left, bisect_right, insort
from math import floor, ceil, sqrt, degrees, atan, pi, log, sin, radians, factorial
from heapq import heappop, heapify, heappush
from collections import Counter, defaultdict, deque
import os, sys
from io import IOBase, BytesIO

MOD = 998244353
mod = 10 ** 9 + 7
'*****************************************************************************************'
' ********************************************************************************************* '
' -------- Python 2 and 3 footer by Pajenegod and c1729 ---------'
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = 'x' in file.mode or 'w' in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b'\n') + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            (self.truncate(0), self.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode('ascii'))
            self.read = lambda : self.buffer.read().decode('ascii')
            self.readline = lambda : self.buffer.readline().decode('ascii')
(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_11()

#Function 1:
#State of the program right berfore the function call: None. This function does not take any parameters. It initializes and returns two lists, `fact` and `ifact`, which are related to factorials and their modular inverses.
def func_1():
    fact = [1]
    for i in range(1, 20):
        fact.append(fact[-1] * i % mod)
        
    #State of the program after the  for loop has been executed: `fact` = [1, 1 % mod, 2 % mod, (2 % mod) * 3 % mod, ..., (19! % mod)], `i` is 19, the range is from 1 to 19 (inclusive)
    ifact = [0] * 105
    ifact[104] = pow(fact[104], mod - 2, mod)
    for i in range(104, 0, -1):
        ifact[i - 1] = i * ifact[i] % mod
        
    #State of the program after the  for loop has been executed: `fact` = [1, 1 % mod, 2 % mod, (2 % mod) * 3 % mod, ..., (19! % mod)], `i` is 0, `ifact` = [0] * 105, `ifact[104]` = `pow(fact[104], mod - 2, mod)`, `ifact[103]` = `104 * ifact[104] % mod`, `ifact[102]` = `103 * ifact[103] % mod`, ..., `ifact[0]` = `1 * ifact[1] % mod`
    return fact, ifact
    #The program returns `fact` which is a list containing the factorial of numbers from 0 to 19 modulo `mod`, and `ifact` which is a list containing the modular multiplicative inverses of the factorials in `fact` modulo `mod`. The lists are precomputed as described in the initial state.

#Function 2:
#State of the program right berfore the function call: n and p are integers, p is a positive integer greater than 1.
def func_2(n, p):
    return pow(n, p - 2, p)
    #The program returns the result of `n` raised to the power of `p - 2`, modulo `p`, where `n` and `p` are integers and `p` is a positive integer greater than 1.

#Function 3:
#State of the program right berfore the function call: n and r are non-negative integers such that 0 <= r <= n, and fact and ifact are lists of integers where fact[i] represents the factorial of i and ifact[i] represents the modular multiplicative inverse of the factorial of i, under a modulus mod.
def func_3(n, r, fact, ifact):
    t = fact[n] * (ifact[r] * ifact[n - r]) % mod % mod
    return t
    #The program returns the value of `t`, which is calculated as `fact[n] * (ifact[r] * ifact[n - r]) % mod % mod`. Here, `fact[n]` is the factorial of `n`, `ifact[r]` is the modular multiplicative inverse of the factorial of `r` under modulus `mod`, and `ifact[n - r]` is the modular multiplicative inverse of the factorial of `n - r` under modulus `mod`.

#Function 4:
#State of the program right berfore the function call: None of the variables are passed as arguments to the function `func_4`. This function reads input from stdin, expecting a line of space-separated integers.
def func_4():
    return map(int, sys.stdin.readline().strip().split())
    #The program returns an iterator of integers converted from a line of space-separated integers read from stdin.

#Function 5:
#State of the program right berfore the function call: None of the variables are passed as arguments to the function. This function reads input from stdin and returns a list of integers.
def func_5():
    return list(map(int, sys.stdin.readline().strip().split()))
    #The program returns a list of integers read from the standard input (stdin), where each integer is obtained by splitting the input line by spaces, stripping any leading or trailing whitespace, and converting each split part into an integer.

#Function 6:
#State of the program right berfore the function call: This function does not take any parameters and is not directly related to the variables a and b from the problem description. It reads a single line from standard input, which could be part of a larger program that processes input for multiple test cases.
def func_6():
    return sys.stdin.readline().strip()
    #The program returns a string read from standard input, with leading and trailing whitespace removed.

#Function 7:
#State of the program right berfore the function call: x and y are non-negative integers.
def func_7(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the GCD of the original values of `x` and `y`
    return x
    #The program returns the GCD of the original values of `x` and `y`, where `y` is 0.

#Function 8:
#State of the program right berfore the function call: x and y are non-negative integers representing the number of sticks and diamonds, respectively, such that 0 <= x, y <= 10^9.
def func_8(x, y):
    return x * y // func_7(x, y)
    #The program returns the integer division of the product of x and y by the result of func_7(x, y), where x and y are non-negative integers representing the number of sticks and diamonds, respectively, such that 0 <= x, y <= 10^9.

#Function 9:
#State of the program right berfore the function call: n is an integer.
def func_9(n):
    return [n, 1, n + 1, 0][n % 4]
    #The program returns n if n % 4 == 0, returns 1 if n % 4 == 1, returns n + 1 if n % 4 == 2, and returns 0 if n % 4 == 3.

#Function 10:
#State of the program right berfore the function call: P is a non-negative integer.
def func_10(P):
    ans = (-1 + sqrt(1 + 8 * P)) // 2
    return ans
    #The program returns the value of `ans` which is calculated as `(-1 + sqrt(1 + 8 * P)) // 2`, where `P` is a non-negative integer.

#Function 11:
#State of the program right berfore the function call: No input parameters are present in the function signature. The function internally uses values returned by `func_6()` and `func_4()`, where `func_6()` should return an integer representing the number of test cases, and `func_4()` should return a tuple of two integers (l, r) representing the number of sticks and diamonds, respectively.
def func_11():
    for _ in range(int(func_6())):
        l, r = func_4()
        
        print(min(l, r, (l + r) // 3))
        
    #State of the program after the  for loop has been executed: `func_6()` must return an integer greater than or equal to 0. If `func_6()` returns 0, the loop does not execute, and no values of `l` or `r` are defined. If `func_6()` returns an integer greater than 0, the loop executes that many times. For each iteration, `l` and `r` are integers returned by `func_4()`, and the minimum of `l`, `r`, and `(l + r) // 3` is printed. After the loop completes, no variables are modified or retained outside the loop, except for the side effect of the printed values.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
