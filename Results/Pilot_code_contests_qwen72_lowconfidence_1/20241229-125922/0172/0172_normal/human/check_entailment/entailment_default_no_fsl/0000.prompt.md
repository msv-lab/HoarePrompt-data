
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Polycarp plays a well-known computer game (we won't mention its name). In this game, he can craft tools of two types — shovels and swords. To craft a shovel, Polycarp spends two sticks and one diamond; to craft a sword, Polycarp spends two diamonds and one stick.

Each tool can be sold for exactly one emerald. How many emeralds can Polycarp earn, if he has a sticks and b diamonds?

Input

The first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases.

The only line of each test case contains two integers a and b (0 ≤ a, b ≤ 10^9) — the number of sticks and the number of diamonds, respectively.

Output

For each test case print one integer — the maximum number of emeralds Polycarp can earn.

Example

Input


4
4 4
1000000000 0
7 15
8 7


Output


2
0
7
5

Note

In the first test case Polycarp can earn two emeralds as follows: craft one sword and one shovel.

In the second test case Polycarp does not have any diamonds, so he cannot craft anything.
Functions with output description for each function:
from __future__ import division, print_function
import sys
from bisect import bisect_left, bisect_right, insort
from math import floor, ceil, sqrt, degrees, atan, pi, log, sin, radians, factorial
from heapq import heappop, heapify, heappush
from collections import Counter, defaultdict, deque
import os, sys
from io import IOBase, BytesIO

MOD = 998244353
mod = 10 ** 9 + 7
'*****************************************************************************************'
' ********************************************************************************************* '
' -------- Python 2 and 3 footer by Pajenegod and c1729 ---------'
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = 'x' in file.mode or 'w' in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b'\n') + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            (self.truncate(0), self.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode('ascii'))
            self.read = lambda : self.buffer.read().decode('ascii')
            self.readline = lambda : self.buffer.readline().decode('ascii')
(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_11()

Function number 1 :
 Code:
 '''
def func_1():
    fact = [1]
    for i in range(1, 20):
        fact.append(fact[-1] * i % mod)
    ifact = [0] * 105
    ifact[104] = pow(fact[104], mod - 2, mod)
    for i in range(104, 0, -1):
        ifact[i - 1] = i * ifact[i] % mod
    return (fact, ifact)
''' 

 Output hints for function1:  The function `func_1` does not accept any parameters. It initializes and returns two lists, `fact` and `ifact`. 

- `fact` is a list containing the factorial of numbers from 0 to 19, each computed modulo `mod`.
- `ifact` is a list containing the modular multiplicative inverses of the factorials in `fact`, also computed modulo `mod`.

The function computes the factorials and their modular inverses up to 19 and 104 respectively. However, there is a discrepancy in the size of the `ifact` list: while it is initialized to have 105 elements, only the last 104 elements (from index 1 to 104) are populated with the correct modular inverses. The first element (`ifact[0]`) remains 0, which might be an unintended side effect or a potential edge case depending on the intended use of the function. After the function executes, it returns the two lists `fact` and `ifact`.
Function number 2 :
 Code:
 '''
def func_2(n, p):
    return pow(n, p - 2, p)
''' 

 Output hints for function2:  The function `func_2` accepts two parameters `n` and `p`, where `n` is an integer and `p` is a positive integer greater than 1. It returns the result of `n` raised to the power of `p - 2`, modulo `p`. This effectively computes the modular inverse of `n` under modulo `p` when `n` and `p` are coprime. If `n` and `p` are not coprime, the result may not be meaningful as a modular inverse.
Function number 3 :
 Code:
 '''
def func_3(n, r, fact, ifact):
    t = fact[n] * (ifact[r] * ifact[n - r]) % mod % mod
    return t
''' 

 Output hints for function3:  The function `func_3` takes four parameters: `n`, `r`, `fact`, and `ifact`. It calculates the value of `t` as `fact[n] * (ifact[r] * ifact[n - r]) % mod % mod`, where `fact[n]` is the factorial of `n`, `ifact[r]` is the modular multiplicative inverse of the factorial of `r` under modulus `mod`, and `ifact[n - r]` is the modular multiplicative inverse of the factorial of `n - r` under modulus `mod`. The function returns the value of `t`.

The function assumes that `n` and `r` are non-negative integers with `0 <= r <= n`, and that `fact` and `ifact` are precomputed lists where `fact[i]` and `ifact[i]` are the factorial and modular multiplicative inverse of `i` under modulus `mod`, respectively. The function does not handle cases where `r` is greater than `n` or where `n` or `r` are negative, and it relies on the correctness and completeness of the `fact` and `ifact` lists.
Function number 4 :
 Code:
 '''
def func_4():
    return map(int, sys.stdin.readline().strip().split())
''' 

 Output hints for function4:  The function `func_4` reads a single line of input from standard input (stdin), expecting the line to contain space-separated integers. It then converts each string in the line to an integer and returns an iterator of these integers. If the input contains non-integer values or is empty, the behavior is undefined and may result in a `ValueError` or an empty iterator, respectively. The function does not modify any external state or variables and only returns the iterator.
Function number 5 :
 Code:
 '''
def func_5():
    return list(map(int, sys.stdin.readline().strip().split()))
''' 

 Output hints for function5:  The function `func_5` does not accept any parameters. It reads a single line of input from the standard input (stdin), splits the line by spaces, trims any leading or trailing whitespace, converts each split part into an integer, and returns a list of these integers. If the input line is empty or contains only whitespace, the function will return an empty list. If the input contains non-integer values, a `ValueError` will be raised.
Function number 6 :
 Code:
 '''
def func_6():
    return sys.stdin.readline().strip()
''' 

 Output hints for function6:  The function `func_6` does not accept any parameters. It reads a single line from standard input and returns this line as a string with leading and trailing whitespace removed. If the input line is empty or contains only whitespace, the function will return an empty string. The function does not modify any external state or variables and is purely focused on reading and processing a single line of input.
Function number 7 :
 Code:
 '''
def func_7(x, y):
    while y:
        (x, y) = (y, x % y)
    return x
''' 

 Output hints for function7:  The function `func_7` accepts two non-negative integer parameters `x` and `y`. It computes and returns the Greatest Common Divisor (GCD) of the original values of `x` and `y`. After the function executes, `y` is guaranteed to be 0, and `x` holds the GCD of the original values of `x` and `y`. The function handles edge cases where either `x` or `y` is 0 by correctly returning the non-zero value as the GCD.
Function number 8 :
 Code:
 '''
def func_8(x, y):
    return x * y // func_7(x, y)
''' 

 Output hints for function8:  The function `func_8` accepts two parameters `x` and `y`, both of which are non-negative integers (0 <= x, y <= 10^9). It returns the integer division of the product of `x` and `y` by the result of `func_7(x, y)`. If `func_7(x, y)` returns 0, a ZeroDivisionError will be raised. The function does not modify the input parameters `x` and `y`. After the function concludes, the state of the program remains unchanged except for the returned value.
Function number 9 :
 Code:
 '''
def func_9(n):
    return [n, 1, n + 1, 0][n % 4]
''' 

 Output hints for function9:  The function `func_9` accepts an integer `n` and returns a value based on the remainder when `n` is divided by 4. Specifically, it returns `n` if `n % 4 == 0`, returns `1` if `n % 4 == 1`, returns `n + 1` if `n % 4 == 2`, and returns `0` if `n % 4 == 3`. The function covers all possible remainders (0, 1, 2, 3) when dividing by 4, ensuring that every integer input results in one of these four outputs. There are no missing functionalities or edge cases in the provided code.
Function number 10 :
 Code:
 '''
def func_10(P):
    ans = (-1 + sqrt(1 + 8 * P)) // 2
    return ans
''' 

 Output hints for function10:  The function `func_10` accepts a non-negative integer `P` and returns the largest integer `ans` such that the sum of the first `ans` natural numbers (i.e., `1 + 2 + ... + ans`) is less than or equal to `P`. The function calculates `ans` using the formula `(-1 + sqrt(1 + 8 * P)) // 2`. If `P` is negative, the function will raise a `ValueError` due to the square root of a negative number. For valid non-negative inputs, the function will always return a non-negative integer.
Function number 11 :
 Code:
 '''
def func_11():
    for _ in range(int(func_6())):
        (l, r) = func_4()
        print(min(l, r, (l + r) // 3))
''' 

 Output hints for function11:  The function `func_11` does not accept any parameters. It retrieves the number of test cases from the function `func_6()`, which should return a non-negative integer. For each test case, it calls `func_4()` to get a tuple of two integers `(l, r)` representing the number of sticks and diamonds, respectively. The function then calculates the minimum value among `l`, `r`, and `(l + r) // 3` and prints this value. If `func_6()` returns 0, the loop does not execute, and no values are printed. After the loop completes, no variables are retained outside the loop, and the only side effect is the printed values. Edge cases include `func_6()` returning 0 (resulting in no iterations), and `func_4()` returning negative values or non-integer values, which are not explicitly handled in the code.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.