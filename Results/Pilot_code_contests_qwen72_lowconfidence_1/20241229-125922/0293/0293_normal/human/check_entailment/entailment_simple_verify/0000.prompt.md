
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: We have N switches with "on" and "off" state, and M bulbs. The switches are numbered 1 to N, and the bulbs are numbered 1 to M.

Bulb i is connected to k_i switches: Switch s_{i1}, s_{i2}, ..., and s_{ik_i}. It is lighted when the number of switches that are "on" among these switches is congruent to p_i modulo 2.

How many combinations of "on" and "off" states of the switches light all the bulbs?

Constraints

* 1 \leq N, M \leq 10
* 1 \leq k_i \leq N
* 1 \leq s_{ij} \leq N
* s_{ia} \neq s_{ib} (a \neq b)
* p_i is 0 or 1.
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


N M
k_1 s_{11} s_{12} ... s_{1k_1}
:
k_M s_{M1} s_{M2} ... s_{Mk_M}
p_1 p_2 ... p_M


Output

Print the number of combinations of "on" and "off" states of the switches that light all the bulbs.

Examples

Input

2 2
2 1 2
1 2
0 1


Output

1


Input

2 3
2 1 2
1 1
1 2
0 0 1


Output

0


Input

5 2
3 1 2 5
2 2 3
1 0


Output

8
Program:
```
(N, M) = map(int, raw_input().split())
ks = []
for i in range(M):
    ks2 = map(int, raw_input().split())
    ks.append(ks2)
pm = map(int, raw_input().split())
plist = []
for i in ks:
    t = [0] * N
    ini = 1
    for j in i:
        if ini == 1:
            ini = 0
            continue
        else:
            t[j - 1] = 1
    plist.append(t)
slist = []
for i in range(2 ** N):
    t = []
    for j in range(N):
        t.append(i % 2)
        i = i / 2
    slist.append(t)
r = 0
for p in plist:
    s2 = []
    for s in slist:
        if func_1(p, s) % 2 == pm[r]:
            s2.append(s)
    r = r + 1
    slist = s2
print(len(slist))

def func_1(a, b):
    c = 0
    for i in range(len(a)):
        c += a[i] * b[i]
    return c


```
Original Assessment: Correctness: **False**.

Explanation: The program fails to handle the input correctly due to the use of `raw_input()` which is specific to Python 2. In Python 3, `input()` should be used instead. This will cause the program to fail in environments where Python 3 is used, which is the current standard. Therefore, the program is incorrect because it does not work as expected in Python 3 environments.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
(N, M) = map(int, raw_input().split())
ks = []
for i in range(M):
    ks2 = map(int, raw_input().split())
    ks.append(ks2)
pm = map(int, raw_input().split())
plist = []
for i in ks:
    t = [0] * N
    ini = 1
    for j in i:
        if ini == 1:
            ini = 0
            continue
        else:
            t[j - 1] = 1
    plist.append(t)
slist = []
for i in range(2 ** N):
    t = []
    for j in range(N):
        t.append(i % 2)
        i = i / 2
    slist.append(t)
r = 0
for p in plist:
    s2 = []
    for s in slist:
        if func_1(p, s) % 2 == pm[r]:
            s2.append(s)
    r = r + 1
    slist = s2
print(len(slist))

#State of the program right berfore the function call: a and b are lists where a represents the configuration of N switches (each element is either 0 or 1 indicating "off" or "on"), and b represents the configuration of M bulbs (each element is a list containing the switch indices connected to the bulb followed by the parity requirement p_i which is 0 or 1). The lengths of a and b satisfy 1 <= len(a) <= 10 and 1 <= len(b) <= 10, respectively. Each switch index in b is an integer between 1 and len(a), inclusive, and each p_i in b is either 0 or 1.
def func_1(a, b):
    c = 0
    for i in range(len(a)):
        c += a[i] * b[i]
        
    #State of the program after the  for loop has been executed: `a` is a list of N switches where 1 <= len(a) <= 10, `b` is a list of M bulbs where 1 <= len(b) <= 10, each switch index in `b` is an integer between 1 and len(a), inclusive, each p_i in `b` is either 0 or 1, `c` is the sum of the products of corresponding elements from `a` and `b`, `i` is len(a) - 1.
    return c
    #The program returns the sum of the products of corresponding elements from lists `a` and `b`. Each element in `b` is an integer between 1 and len(a), inclusive, and each p_i in `b` is either 0 or 1. The length of `a` is between 1 and 10, and the length of `b` is between 1 and 10.


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
