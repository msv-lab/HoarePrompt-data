
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: You've got a list of program warning logs. Each record of a log stream is a string in this format: 

"2012-MM-DD HH:MM:SS:MESSAGE" (without the quotes). 

String "MESSAGE" consists of spaces, uppercase and lowercase English letters and characters "!", ".", ",", "?". String "2012-MM-DD" determines a correct date in the year of 2012. String "HH:MM:SS" determines a correct time in the 24 hour format.

The described record of a log stream means that at a certain time the record has got some program warning (string "MESSAGE" contains the warning's description).

Your task is to print the first moment of time, when the number of warnings for the last n seconds was not less than m.

Input

The first line of the input contains two space-separated integers n and m (1 ≤ n, m ≤ 10000).

The second and the remaining lines of the input represent the log stream. The second line of the input contains the first record of the log stream, the third line contains the second record and so on. Each record of the log stream has the above described format. All records are given in the chronological order, that is, the warning records are given in the order, in which the warnings appeared in the program. 

It is guaranteed that the log has at least one record. It is guaranteed that the total length of all lines of the log stream doesn't exceed 5·106 (in particular, this means that the length of some line does not exceed 5·106 characters). It is guaranteed that all given dates and times are correct, and the string 'MESSAGE" in all records is non-empty.

Output

If there is no sought moment of time, print -1. Otherwise print a string in the format "2012-MM-DD HH:MM:SS" (without the quotes) — the first moment of time when the number of warnings for the last n seconds got no less than m.

Examples

Input

60 3
2012-03-16 16:15:25: Disk size is
2012-03-16 16:15:25: Network failute
2012-03-16 16:16:29: Cant write varlog
2012-03-16 16:16:42: Unable to start process
2012-03-16 16:16:43: Disk size is too small
2012-03-16 16:16:53: Timeout detected


Output

2012-03-16 16:16:43


Input

1 2
2012-03-16 23:59:59:Disk size
2012-03-17 00:00:00: Network
2012-03-17 00:00:01:Cant write varlog


Output

-1


Input

2 2
2012-03-16 23:59:59:Disk size is too sm
2012-03-17 00:00:00:Network failute dete
2012-03-17 00:00:01:Cant write varlogmysq


Output

2012-03-17 00:00:00
Program:
```
import sys

(n, m) = map(int, raw_input().split())
times = []
a = sys.stdin.readlines()
for i in range(len(a)):
    str1 = a[i]
    MM = int(str1[5:7])
    DD = int(str1[8:10])
    HH = int(str1[11:13])
    MIN = int(str1[14:16])
    SEC = int(str1[17:19])
    times.append(func_1(MM, DD, HH, MIN, SEC))
for i in range(len(times)):
    tmp = 0
    j = i
    bol = False
    while j >= 0 and times[i] - times[j] < n:
        j -= 1
        tmp += 1
    if tmp >= m:
        print(a[i][:19])
        exit()
print(-1)

def func_1(mon, day, hour, min, sec):
    mons = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    days = 0
    for i in range(mon):
        days += mons[i]
    return (days + day) * 86400 + 3600 * hour + 60 * min + sec


```
Original Assessment: Correctness: **False**

Explanation:
The provided program has a logical issue in how it handles the conversion of the date and time strings to a timestamp. Specifically, the `func_1` function calculates the total seconds from the beginning of the year, but it incorrectly accumulates the days by adding the day of the month directly to the sum of the days in the previous months. This results in an incorrect timestamp calculation, especially for dates after the first day of any month.

Here is a more detailed breakdown of the issue:

1. **Incorrect Day Calculation**: In the `func_1` function, the days are calculated as follows:
   ```python
   days = 0
   for i in range(mon):
       days += mons[i]
   return (days + day) * 86400 + 3600 * hour + 60 * min + sec
   ```
   This logic is incorrect because it adds the day of the month (`day`) directly to the sum of the days in the previous months. For example, for the date `2012-03-16`, the days should be calculated as:
   - January: 31 days
   - February: 29 days (leap year)
   - March: 16 days
   The total days should be `31 + 29 + 16 - 1 = 75` (subtracting 1 because the current day is included in the count).

2. **Impact on Timestamp Calculation**: Due to the incorrect day calculation, the timestamps generated by `func_1` will be off, leading to incorrect comparisons in the main loop where the program checks the number of warnings within the last `n` seconds.

To fix this, the `func_1` function should be modified to correctly calculate the total days from the beginning of the year:
```python
def func_1(mon, day, hour, min, sec):
    mons = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    days = sum(mons[:mon-1]) + day
    return (days - 1) * 86400 + 3600 * hour + 60 * min + sec
```

With this correction, the program should work correctly for all potential cases. However, since the original program has this issue, it is considered incorrect.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: The function `func_1` takes five parameters: `mon`, `day`, `hour`, `min`, and `sec`, which represent a valid date and time in the year 2012. It calculates and returns the total number of seconds elapsed since the start of the year 2012 up to the given date and time. The calculation accounts for the correct number of days in each month, including February with 29 days (since 2012 is a leap year). The function correctly handles the conversion of days, hours, minutes, and seconds into the total number of seconds. However, the function does not validate the input to ensure that the provided date and time are valid (e.g., it does not check if `day` is within the valid range for the given `mon`). If invalid inputs are provided, the function may return incorrect results.

Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
