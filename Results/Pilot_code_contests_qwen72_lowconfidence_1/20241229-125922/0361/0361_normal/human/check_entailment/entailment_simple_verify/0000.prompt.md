
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: You've got a list of program warning logs. Each record of a log stream is a string in this format: 

"2012-MM-DD HH:MM:SS:MESSAGE" (without the quotes). 

String "MESSAGE" consists of spaces, uppercase and lowercase English letters and characters "!", ".", ",", "?". String "2012-MM-DD" determines a correct date in the year of 2012. String "HH:MM:SS" determines a correct time in the 24 hour format.

The described record of a log stream means that at a certain time the record has got some program warning (string "MESSAGE" contains the warning's description).

Your task is to print the first moment of time, when the number of warnings for the last n seconds was not less than m.

Input

The first line of the input contains two space-separated integers n and m (1 ≤ n, m ≤ 10000).

The second and the remaining lines of the input represent the log stream. The second line of the input contains the first record of the log stream, the third line contains the second record and so on. Each record of the log stream has the above described format. All records are given in the chronological order, that is, the warning records are given in the order, in which the warnings appeared in the program. 

It is guaranteed that the log has at least one record. It is guaranteed that the total length of all lines of the log stream doesn't exceed 5·106 (in particular, this means that the length of some line does not exceed 5·106 characters). It is guaranteed that all given dates and times are correct, and the string 'MESSAGE" in all records is non-empty.

Output

If there is no sought moment of time, print -1. Otherwise print a string in the format "2012-MM-DD HH:MM:SS" (without the quotes) — the first moment of time when the number of warnings for the last n seconds got no less than m.

Examples

Input

60 3
2012-03-16 16:15:25: Disk size is
2012-03-16 16:15:25: Network failute
2012-03-16 16:16:29: Cant write varlog
2012-03-16 16:16:42: Unable to start process
2012-03-16 16:16:43: Disk size is too small
2012-03-16 16:16:53: Timeout detected


Output

2012-03-16 16:16:43


Input

1 2
2012-03-16 23:59:59:Disk size
2012-03-17 00:00:00: Network
2012-03-17 00:00:01:Cant write varlog


Output

-1


Input

2 2
2012-03-16 23:59:59:Disk size is too sm
2012-03-17 00:00:00:Network failute dete
2012-03-17 00:00:01:Cant write varlogmysq


Output

2012-03-17 00:00:00
Program:
```
import sys

(n, m) = map(int, raw_input().split())
times = []
a = sys.stdin.readlines()
for i in range(len(a)):
    str1 = a[i]
    MM = int(str1[5:7])
    DD = int(str1[8:10])
    HH = int(str1[11:13])
    MIN = int(str1[14:16])
    SEC = int(str1[17:19])
    times.append(func_1(MM, DD, HH, MIN, SEC))
for i in range(len(times)):
    tmp = 0
    j = i
    bol = False
    while j >= 0 and times[i] - times[j] < n:
        j -= 1
        tmp += 1
    if tmp >= m:
        print(a[i][:19])
        exit()
print(-1)

def func_1(mon, day, hour, min, sec):
    mons = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    days = 0
    for i in range(mon):
        days += mons[i]
    return (days + day) * 86400 + 3600 * hour + 60 * min + sec


```
Original Assessment: Correctness: **True**.

Explanation:
The program appears to correctly implement the solution according to the problem description. Here's a breakdown of why:

1. **Input Parsing**: The program reads the input values `n` and `m`, and then reads the log entries from standard input. It correctly parses the date and time from each log entry.

2. **Time Conversion**: The function `func_1` converts the date and time into a single integer representing the number of seconds since the start of the year. This conversion is accurate and handles leap years correctly (since 2012 is a leap year, February has 29 days).

3. **Sliding Window Check**: The program uses a sliding window approach to check the number of warnings within the last `n` seconds. It iterates through the list of converted times and counts the number of warnings within the last `n` seconds for each log entry. If the count reaches or exceeds `m`, it prints the corresponding log entry's timestamp and exits.

4. **Edge Cases**: The program handles edge cases such as the first log entry and the last log entry correctly. It also handles cases where no such moment exists by printing `-1`.

Given the problem constraints and the provided examples, the program seems to handle all potential cases correctly. Therefore, the program is correct.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
import sys

(n, m) = map(int, raw_input().split())
times = []
a = sys.stdin.readlines()
for i in range(len(a)):
    str1 = a[i]
    MM = int(str1[5:7])
    DD = int(str1[8:10])
    HH = int(str1[11:13])
    MIN = int(str1[14:16])
    SEC = int(str1[17:19])
    times.append(func_1(MM, DD, HH, MIN, SEC))
for i in range(len(times)):
    tmp = 0
    j = i
    bol = False
    while j >= 0 and times[i] - times[j] < n:
        j -= 1
        tmp += 1
    if tmp >= m:
        print(a[i][:19])
        exit()
print(-1)

#State of the program right berfore the function call: mon, day, hour, min, and sec are integers representing a valid date and time in the year 2012, where 1 ≤ mon ≤ 12, 1 ≤ day ≤ 31, 0 ≤ hour ≤ 23, 0 ≤ min ≤ 59, and 0 ≤ sec ≤ 59.
def func_1(mon, day, hour, min, sec):
    mons = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    days = 0
    for i in range(mon):
        days += mons[i]
        
    #State of the program after the  for loop has been executed: `mon` is an integer between 1 and 12, `day` is an integer between 1 and 31, `hour` is an integer between 0 and 23, `min` is an integer between 0 and 59, `sec` is an integer between 0 and 59, `mons` is [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], `days` is the sum of the first `mon` elements of `mons`.
    return (days + day) * 86400 + 3600 * hour + 60 * min + sec
    #The program returns the total number of seconds since the start of the year, calculated as (days + day) * 86400 + 3600 * hour + 60 * min + sec, where `days` is the sum of the first `mon` elements of the list `mons`, `day` is an integer between 1 and 31, `hour` is an integer between 0 and 23, `min` is an integer between 0 and 59, and `sec` is an integer between 0 and 59.


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
