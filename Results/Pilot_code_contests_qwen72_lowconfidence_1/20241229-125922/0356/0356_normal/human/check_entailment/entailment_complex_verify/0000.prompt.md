
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: On the competitive programming platform CodeCook, every person has a rating graph described by an array of integers a of length n. You are now updating the infrastructure, so you've created a program to compress these graphs.

The program works as follows. Given an integer parameter k, the program takes the minimum of each contiguous subarray of length k in a.

More formally, for an array a of length n and an integer k, define the k-compression array of a as an array b of length n-k+1, such that $$$b_j =min_{j≤ i≤ j+k-1}a_i$$$

For example, the 3-compression array of [1, 3, 4, 5, 2] is [min\{1, 3, 4\}, min\{3, 4, 5\}, min\{4, 5, 2\}]=[1, 3, 2].

A permutation of length m is an array consisting of m distinct integers from 1 to m in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (m=3 but there is 4 in the array).

A k-compression array will make CodeCook users happy if it will be a permutation. Given an array a, determine for all 1≤ k≤ n if CodeCook users will be happy after a k-compression of this array or not.

Input

The first line contains a single integer t (1≤ t≤ 10^4) — the number of test cases.

The first line of the description of each test case contains a single integer n (1≤ n≤ 3⋅ 10^5) — the length of the array.

The second line of the description of each test case contains n integers a_1,…,a_n (1≤ a_i≤ n) — the elements of the array.

It is guaranteed, that the sum of n for all test cases does not exceed 3⋅ 10^5.

Output

For each test case, print a binary string of length n. 

The k-th character of the string should be 1 if CodeCook users will be happy after a k-compression of the array a, and 0 otherwise. 

Example

Input


5
5
1 5 3 4 2
4
1 3 2 1
5
1 3 3 3 2
10
1 2 3 4 5 6 7 8 9 10
3
3 3 2


Output


10111
0001
00111
1111111111
000

Note

In the first test case, a=[1, 5, 3, 4, 2].

  * The 1-compression of a is [1, 5, 3, 4, 2] and it is a permutation. 
  * The 2-compression of a is [1, 3, 3, 2] and it is not a permutation, since 3 appears twice. 
  * The 3-compression of a is [1, 3, 2] and it is a permutation. 
  * The 4-compression of a is [1, 2] and it is a permutation. 
  * The 5-compression of a is [1] and it is a permutation. 
Program:
```
from sys import stdin

def func():
    rint = lambda : int(stdin.readline())
    rints = lambda : [int(x) for x in stdin.readline().split()]
    out = []
    for _ in range(int(input())):
        (n, a) = (rint(), rints())
        (ans, mem) = (['0'] * n, [0] * (n + 1))
        (ans[0], l, r) = ('1', 0, n - 1)
        for i in range(n):
            mem[a[i]] += 1
            if mem[a[i]] == 2:
                ans[0] = '0'
        for i in range(1, n):
            if not mem[i]:
                break
            ans[n - i] = '1'
            if a[l] != i and a[r] != i or a[l] == a[r] == i:
                break
            elif a[l] == i:
                l += 1
            else:
                r -= 1
        out.append(''.join(ans))
    print('\n'.join(out))


```
Original Assessment: Correctness: **False**.

Explanation:
The provided program does not correctly handle the k-compression of the array for all possible values of k. Specifically, the program fails to properly compute the k-compression for k > 1 and does not correctly check if the resulting array is a permutation.

### Case Analysis:
1. **k = 1**:
   - The program correctly sets `ans[0]` to '1' because the 1-compression of any array is the array itself, which is always a permutation if all elements are distinct.

2. **k > 1**:
   - The program attempts to check if the array is a permutation by using a `mem` array to track the frequency of each element. However, this approach is flawed because it only checks the frequency of elements in the original array and not the k-compression array.
   - The loop that updates `ans[n - i]` to '1' is incorrect. It breaks the loop if any element from 1 to n is missing from the original array, which is not the correct condition for checking if the k-compression is a permutation.
   - The conditions inside the loop (`if a[l] != i and a[r] != i or a[l] == a[r] == i`) are not sufficient to ensure that the k-compression array is a permutation.

### Example of Failure:
Consider the input:
```
1
5
1 3 2 4 5
```
- The 1-compression is `[1, 3, 2, 4, 5]`, which is a permutation.
- The 2-compression is `[1, 2, 2, 4]`, which is not a permutation (2 appears twice).
- The 3-compression is `[1, 2, 4]`, which is a permutation.
- The 4-compression is `[1, 2]`, which is a permutation.
- The 5-compression is `[1]`, which is a permutation.

The correct output should be:
```
10111
```

However, the provided program will output:
```
10000
```

This shows that the program fails to correctly compute the k-compression for k > 1 and does not correctly determine if the resulting array is a permutation. Therefore, the program is incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import stdin

#State of the program right berfore the function call: t is an integer where 1 ≤ t ≤ 10^4; for each test case, n is an integer where 1 ≤ n ≤ 3⋅10^5, and a is a list of n integers where 1 ≤ a_i ≤ n. The sum of n over all test cases does not exceed 3⋅10^5.
def func():
    rint = lambda : int(stdin.readline())
    rints = lambda : [int(x) for x in stdin.readline().split()]
    out = []
    for _ in range(int(input())):
        n, a = rint(), rints()
        
        ans, mem = ['0'] * n, [0] * (n + 1)
        
        ans[0], l, r = '1', 0, n - 1
        
        for i in range(n):
            mem[a[i]] += 1
            if mem[a[i]] == 2:
                ans[0] = '0'
        
        for i in range(1, n):
            if not mem[i]:
                break
            ans[n - i] = '1'
            if a[l] != i and a[r] != i or a[l] == a[r] == i:
                break
            elif a[l] == i:
                l += 1
            else:
                r -= 1
        
        out.append(''.join(ans))
        
    #State of the program after the  for loop has been executed: `t` is an integer where 1 ≤ t ≤ 10^4, `out` is a list of strings, each string is the result of `''.join(ans)` for each test case, `ans` is a list of '0' with length `n` for each test case where `ans[0]` is '0' if any element in `a` appears more than once, otherwise `ans[0]` is '1', and for each `i` in the range [1, n-1], if `mem[i]` is non-zero and the conditions in the loop did not cause a break, `ans[n - i]` will be '1'. Otherwise, `ans[n - i]` will remain '0', `mem` is a list of 0 with length `n + 1` for each test case and `mem[a[i]]` contains the count of `a[i]` for each `i` in the range [0, n-1], `l` is the last index where `a[l]` matched `i` or the number of elements from the start of `a` that match the corresponding `i` values, `r` is the last index where `a[r]` matched `i` or the number of elements from the end of `a` that match the corresponding `i` values, and `i` is the value of the iteration where the loop either completed or broke.
    print('\n'.join(out))
#Overall this is what the function does:The function `func` reads multiple test cases from standard input, where each test case consists of an integer `n` and a list `a` of `n` integers. For each test case, the function generates a binary string of length `n` where the first character is '0' if any integer in `a` appears more than once, otherwise it is '1'. For subsequent characters in the string, starting from the end, the function sets the character to '1' if the integer corresponding to its position from the end (1-indexed) appears exactly once in `a` and meets certain conditions involving the leftmost (`l`) and rightmost (`r`) positions of the array `a`. The final result is a list of these binary strings, one for each test case, which is then printed to standard output, each on a new line. The function modifies no external state and does not return any value. Edge cases include when `a` contains duplicate values, when `a` is a permutation of integers from 1 to `n`, and when `a` has repeated values but still meets the conditions for setting '1' in the result string.

Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
