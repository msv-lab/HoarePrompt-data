
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: You and your friend are playing the game Mortal Kombat XI. You are trying to pass a challenge tower. There are n bosses in this tower, numbered from 1 to n. The type of the i-th boss is a_i. If the i-th boss is easy then its type is a_i = 0, otherwise this boss is hard and its type is a_i = 1.

During one session, either you or your friend can kill one or two bosses (neither you nor your friend can skip the session, so the minimum number of bosses killed during one session is at least one). After your friend session, your session begins, then again your friend session begins, your session begins, and so on. The first session is your friend's session.

Your friend needs to get good because he can't actually kill hard bosses. To kill them, he uses skip points. One skip point can be used to kill one hard boss.

Your task is to find the minimum number of skip points your friend needs to use so you and your friend kill all n bosses in the given order.

For example: suppose n = 8, a = [1, 0, 1, 1, 0, 1, 1, 1]. Then the best course of action is the following:

  * your friend kills two first bosses, using one skip point for the first boss; 
  * you kill the third and the fourth bosses; 
  * your friend kills the fifth boss; 
  * you kill the sixth and the seventh bosses; 
  * your friend kills the last boss, using one skip point, so the tower is completed using two skip points. 



You have to answer t independent test cases.

Input

The first line of the input contains one integer t (1 ≤ t ≤ 2 ⋅ 10^4) — the number of test cases. Then t test cases follow.

The first line of the test case contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the number of bosses. The second line of the test case contains n integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 1), where a_i is the type of the i-th boss.

It is guaranteed that the sum of n does not exceed 2 ⋅ 10^5 (∑ n ≤ 2 ⋅ 10^5).

Output

For each test case, print the answer: the minimum number of skip points your friend needs to use so you and your friend kill all n bosses in the given order.

Example

Input


6
8
1 0 1 1 0 1 1 1
5
1 1 1 1 0
7
1 1 1 1 0 0 1
6
1 1 1 1 1 1
1
1
1
0


Output


2
2
2
2
1
0
Program:
```
def func():
    t = int(raw_input())
    for _ in range(t):
        n = int(raw_input())
        A = map(int, raw_input().split())
        A.reverse()
        F = [0] * n
        M = [0] * n
        F[0] = A[0]
        if n == 1:
            print(F[0])
            continue
        F[1] = A[1]
        for i in range(2, n):
            M[i] = min(F[i - 1], F[i - 2])
            F[i] = min(A[i] + M[i - 1], A[i] + A[i - 1] + M[i - 2])
        print(F[-1])


```
Original Assessment: Correctness: **False**.

Explanation: The program fails to handle certain edge cases correctly. Specifically, it does not handle the case where the sequence of bosses starts with an easy boss (a_1 = 0). In such cases, the initial assignment `F[0] = A[0]` will set `F[0]` to 0, which is incorrect because the first session is always your friend's session, and if the first boss is easy, no skip points should be used initially. This can lead to incorrect results.

For example, consider the input:
```
1
3
0 1 0
```
The expected output should be 0 because your friend can kill the first boss (which is easy) without using any skip points, and you can kill the remaining bosses. However, the program will incorrectly compute the result as 1.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: The function `func` reads multiple test cases from standard input, processes each test case, and prints the result for each one. Each test case consists of an integer `n` followed by a list of `n` integers (each being 0 or 1). The function calculates the minimum cost to traverse the list from the start to the end, where the cost of moving to the next element is determined by the values in the list. The function prints the minimum cost for each test case. After processing all test cases, the function terminates. The state of the program after the function concludes is that `t` is an integer such that 1 ≤ t ≤ 2 ⋅ 10^4, `_` is `t - 1`, `n` is the last input integer, `A` is a list of the last input integers in reversed order, `F` and `M` are lists of length `n` used for dynamic programming calculations, and the results for each test case have been printed. Edge cases include when `n` is 1, in which case the function directly prints the first element of `A`.

Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
