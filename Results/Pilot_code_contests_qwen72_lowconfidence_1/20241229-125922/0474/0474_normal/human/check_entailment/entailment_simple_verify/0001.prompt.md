
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Cowboy Vlad has a birthday today! There are n children who came to the celebration. In order to greet Vlad, the children decided to form a circle around him. Among the children who came, there are both tall and low, so if they stand in a circle arbitrarily, it may turn out, that there is a tall and low child standing next to each other, and it will be difficult for them to hold hands. Therefore, children want to stand in a circle so that the maximum difference between the growth of two neighboring children would be minimal possible.

Formally, let's number children from 1 to n in a circle order, that is, for every i child with number i will stand next to the child with number i+1, also the child with number 1 stands next to the child with number n. Then we will call the discomfort of the circle the maximum absolute difference of heights of the children, who stand next to each other.

Please help children to find out how they should reorder themselves, so that the resulting discomfort is smallest possible.

Input

The first line contains a single integer n (2 ≤ n ≤ 100) — the number of the children who came to the cowboy Vlad's birthday.

The second line contains integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9) denoting heights of every child.

Output

Print exactly n integers — heights of the children in the order in which they should stand in a circle. You can start printing a circle with any child.

If there are multiple possible answers, print any of them.

Examples

Input


5
2 1 1 3 2


Output


1 2 3 2 1


Input


3
30 10 20


Output


10 20 30

Note

In the first example, the discomfort of the circle is equal to 1, since the corresponding absolute differences are 1, 1, 1 and 0. Note, that sequences [2, 3, 2, 1, 1] and [3, 2, 1, 1, 2] form the same circles and differ only by the selection of the starting point.

In the second example, the discomfort of the circle is equal to 20, since the absolute difference of 10 and 30 is equal to 20.
Program:
```
import sys
import random, math
from collections import defaultdict

def func():
    n = int(raw_input())
    arr = [int(__) for __ in raw_input().split()]
    arr.sort(reverse=True)
    newl = list()
    fl = 0
    for el in arr:
        if fl == 0:
            newl.append(el)
            fl = 1
        else:
            newl = [el] + newl
            fl = 0
    print(' '.join([str(x) for x in newl]))


```
Original Assessment: Correctness: **True**

Explanation:
The program sorts the heights of the children in descending order and then alternates placing the tallest remaining child at the end and the beginning of a new list `newl`. This approach ensures that the maximum difference between adjacent elements in the final list is minimized. Here's why this works:

1. **Sorting in Descending Order**: By sorting the heights in descending order, the largest and smallest differences are spread out more evenly. This helps in minimizing the maximum difference between adjacent elements.

2. **Alternating Placement**: The program alternates placing the tallest remaining child at the end and the beginning of the list. This creates a pattern where the largest differences are distributed across the list, rather than being concentrated in one area.

3. **Circular Property**: Since the children form a circle, the last element in the list is considered adjacent to the first element. The alternating placement ensures that the largest height differences are spread out, including the last and first elements.

4. **Edge Cases**: The program handles edge cases such as small input sizes (e.g., n=2 or n=3) correctly. For example, if there are only two children, the program will place them in the order they are sorted, which is optimal. If there are three children, the program will place them in a sorted order, which is also optimal.

Given these points, the program appears to handle all potential cases correctly and produces the desired output for minimizing the discomfort of the circle. Therefore, the program is correct.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
import sys
import random, math
from collections import defaultdict

#State of the program right berfore the function call: n is an integer such that 2 ≤ n ≤ 100, and a list of integers a_1, a_2, ..., a_n where 1 ≤ a_i ≤ 10^9 representing the heights of the children.
def func():
    n = int(raw_input())
    arr = [int(__) for __ in raw_input().split()]
    arr.sort(reverse=True)
    newl = list()
    fl = 0
    for el in arr:
        if fl == 0:
            newl.append(el)
            fl = 1
        else:
            newl = [el] + newl
            fl = 0
        
    #State of the program after the  for loop has been executed: `n` is an integer (2 ≤ n ≤ 100), `arr` is a list of integers representing the heights of the children sorted in descending order with a length of `n`, `newl` is a list containing the elements of `arr` in an alternating order (first element of `arr` is the last in `newl`, second is the first in `newl`, and so on), `fl` is 0 if `n` is even and 1 if `n` is odd, `el` is the last element of `arr`.
    print(' '.join([str(x) for x in newl]))


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
