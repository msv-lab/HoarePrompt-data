
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Karen has just arrived at school, and she has a math test today!

<image>

The test is about basic addition and subtraction. Unfortunately, the teachers were too busy writing tasks for Codeforces rounds, and had no time to make an actual test. So, they just put one question in the test that is worth all the points.

There are n integers written on a row. Karen must alternately add and subtract each pair of adjacent integers, and write down the sums or differences on the next row. She must repeat this process on the values on the next row, and so on, until only one integer remains. The first operation should be addition.

Note that, if she ended the previous row by adding the integers, she should start the next row by subtracting, and vice versa.

The teachers will simply look at the last integer, and then if it is correct, Karen gets a perfect score, otherwise, she gets a zero for the test.

Karen has studied well for this test, but she is scared that she might make a mistake somewhere and it will cause her final answer to be wrong. If the process is followed, what number can she expect to be written on the last row?

Since this number can be quite large, output only the non-negative remainder after dividing it by 109 + 7.

Input

The first line of input contains a single integer n (1 ≤ n ≤ 200000), the number of numbers written on the first row.

The next line contains n integers. Specifically, the i-th one among these is ai (1 ≤ ai ≤ 109), the i-th number on the first row.

Output

Output a single integer on a line by itself, the number on the final row after performing the process above.

Since this number can be quite large, print only the non-negative remainder after dividing it by 109 + 7.

Examples

Input

5
3 6 9 12 15


Output

36


Input

4
3 7 5 2


Output

1000000006

Note

In the first test case, the numbers written on the first row are 3, 6, 9, 12 and 15.

Karen performs the operations as follows:

<image>

The non-negative remainder after dividing the final number by 109 + 7 is still 36, so this is the correct output.

In the second test case, the numbers written on the first row are 3, 7, 5 and 2.

Karen performs the operations as follows:

<image>

The non-negative remainder after dividing the final number by 109 + 7 is 109 + 6, so this is the correct output.
Program:
```

#Function 1:
def func_1(n, p):
    l = [1] * (n + 1)
    for i in range(n):
        l[i + 1] = l[i] * (n - i) * pow(i + 1, p - 2, p) % p
    return l

#Function 2:
def func_2(n, p):
    l = []
    if n % 4 == 0:
        for e in func_1(n // 2 - 1, p):
            l += [e, -e]
        return l
    if n % 4 == 1:
        for e in func_1(n // 2, p):
            l += [e, 0]
        l.pop(-1)
        return l
    if n % 4 == 2:
        for e in func_1(n // 2 - 1, p):
            l += [e, e]
        return l
    pre_l = []
    for e in func_1(n // 2 - 1, p):
        pre_l += [e, e]
    l.append(pre_l[0])
    for i in range(1, n - 1):
        l.append(pre_l[i] + pre_l[i - 1] * (-1) ** (i + 1))
    l.append(pre_l[n - 2] * (-1) ** n)
    return l


```
Original Assessment: Correctness: **False**.

Explanation:
The provided program does not directly solve the problem as described in the problem statement. The functions `func_1` and `func_2` seem to be attempting to generate coefficients or sequences that might be used in solving the problem, but they do not directly implement the alternating addition and subtraction process as required.

Here are a few issues with the provided program:

1. **Direct Implementation Missing**: The program does not contain a function that directly takes the initial list of integers, performs the alternating addition and subtraction, and returns the final result modulo \(10^9 + 7\).

2. **Function Purpose Unclear**: The functions `func_1` and `func_2` are not clearly related to the problem of alternating addition and subtraction. They appear to be generating some kind of sequence, but it's not evident how these sequences are used to solve the problem.

3. **Modulo Operation**: The problem requires the final result to be taken modulo \(10^9 + 7\). It's not clear from the provided code whether this operation is being performed correctly or at all.

4. **Edge Cases**: The program does not handle edge cases such as when the input list has only one element or when the list has an even number of elements. The problem description specifies that the operations should alternate starting with addition, and the program does not explicitly show this behavior.

Given these issues, the program does not meet the requirements of the problem description, and therefore, it is incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
if __name__ == '__main__':
    n = int(raw_input())
    s = func_2(n, 10 ** 9 + 7)
    t = 0
    l = map(lambda x: int(x), raw_input().split(' '))
    for i in range(n):
        t += s[i] * l[i]
        t %= 10 ** 9 + 7
    print(str(t))

#Function 1:
#State of the program right berfore the function call: n is a non-negative integer representing the number of elements in the initial row, and p is a positive integer used as the modulus for the calculations, where p is typically set to 10^9 + 7.
def func_1(n, p):
    l = [1] * (n + 1)
    for i in range(n):
        l[i + 1] = l[i] * (n - i) * pow(i + 1, p - 2, p) % p
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `p` is a positive integer, `l` is a list of length `n + 1` where `l[0]` is 1, and for each `i` from 1 to `n`, `l[i]` is calculated as follows: `l[i] = ((...((n % p) * (n - 1) * pow(2, p - 2, p) % p) * (n - 2) * pow(3, p - 2, p) % p)...) * (n - (i - 1)) * pow(i, p - 2, p) % p`.
    return l
    #The program returns a list `l` of length `n + 1` where `l[0]` is 1, and for each `i` from 1 to `n`, `l[i]` is calculated as `l[i] = ((...((n % p) * (n - 1) * pow(2, p - 2, p) % p) * (n - 2) * pow(3, p - 2, p) % p)...) * (n - (i - 1)) * pow(i, p - 2, p) % p`.

#Function 2:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 200000), p is a positive integer representing the modulo value (10^9 + 7).
def func_2(n, p):
    l = []
    if (n % 4 == 0) :
        for e in func_1(n // 2 - 1, p):
            l += [e, -e]
            
        #State of the program after the  for loop has been executed: `n` is a positive integer (1 ≤ n ≤ 200000) and divisible by 4, `p` is a positive integer (10^9 + 7), `l` is a list containing pairs `[e, -e]` for each element `e` in the iterable returned by `func_1(n // 2 - 1, p)`, and the length of `l` is twice the length of the iterable returned by `func_1(n // 2 - 1, p)`.
        return l
        #The program returns a list `l` containing pairs `[e, -e]` for each element `e` in the iterable returned by `func_1(n // 2 - 1, p)`. The length of `l` is twice the length of the iterable returned by `func_1(n // 2 - 1, p)`. Here, `n` is a positive integer (1 ≤ n ≤ 200000) and divisible by 4, and `p` is a positive integer (10^9 + 7).
    #State of the program after the if block has been executed: *`n` is a positive integer (1 ≤ n ≤ 200000), `p` is a positive integer representing the modulo value (10^9 + 7), `l` is an empty list, and `n % 4` is not equal to 0
    if (n % 4 == 1) :
        for e in func_1(n // 2, p):
            l += [e, 0]
            
        #State of the program after the  for loop has been executed: `n` is a positive integer (1 ≤ n ≤ 200000) such that `n % 4` is equal to 1, `p` is a positive integer representing the modulo value (10^9 + 7), `l` is a list of `2m` elements where `m` is the length of the iterable returned by `func_1(n // 2, p)`, and each pair of elements in `l` is `[e, 0]` where `e` is an element from the iterable. If `func_1(n // 2, p)` returns an empty iterable, `l` remains an empty list.
        l.pop(-1)
        return l
        #The program returns a list `l` of `2m - 2` elements where `m` is the length of the iterable returned by `func_1(n // 2, p)`, and each pair of elements in `l` is `[e, 0]` where `e` is an element from the iterable. If `func_1(n // 2, p)` returns an empty iterable, `l` remains an empty list.
    #State of the program after the if block has been executed: *`n` is a positive integer (1 ≤ n ≤ 200000), `p` is a positive integer representing the modulo value (10^9 + 7), `l` is an empty list, and `n % 4` is not equal to 1
    if (n % 4 == 2) :
        for e in func_1(n // 2 - 1, p):
            l += [e, e]
            
        #State of the program after the  for loop has been executed: `n` is a positive integer (1 ≤ n ≤ 200000), `p` is 10^9 + 7, `l` is a list containing `2 * m` elements, where `m` is the number of elements returned by `func_1(n // 2 - 1, p)`, `n % 4` is 2. If `func_1(n // 2 - 1, p)` returns an empty iterable, `l` remains an empty list.
        return l
        #The program returns a list `l` containing `2 * m` elements, where `m` is the number of elements returned by `func_1(n // 2 - 1, p)`. If `func_1(n // 2 - 1, p)` returns an empty iterable, `l` remains an empty list.
    #State of the program after the if block has been executed: *`n` is a positive integer (1 ≤ n ≤ 200000), `p` is a positive integer representing the modulo value (10^9 + 7), `l` is an empty list, and `n % 4` is not equal to 2
    pre_l = []
    for e in func_1(n // 2 - 1, p):
        pre_l += [e, e]
        
    #State of the program after the  for loop has been executed: `n` is a positive integer (1 ≤ n ≤ 200000), `p` is a positive integer (10^9 + 7), `l` is an empty list, `n % 4` is not equal to 2, `pre_l` is a list containing `2 * m` elements, where `m` is the length of the sequence returned by `func_1(n // 2 - 1, p)`, and each element `e` from `func_1(n // 2 - 1, p)` appears twice in `pre_l`.
    l.append(pre_l[0])
    for i in range(1, n - 1):
        l.append(pre_l[i] + pre_l[i - 1] * (-1) ** (i + 1))
        
    #State of the program after the  for loop has been executed: `n` is a positive integer (1 ≤ n ≤ 200000), `p` is a positive integer (10^9 + 7), `l` is a list containing `n - 1` elements where the first element is `pre_l[0]` and the subsequent elements are `pre_l[i] + pre_l[i - 1] * (-1)
    l.append(pre_l[n - 2] * (-1) ** n)
    return l
    #The program returns the list `l` containing `n` elements, where the first element is `pre_l[0]`, each subsequent element is calculated as `pre_l[i] + pre_l[i - 1] * (-1)`, and the last element is `pre_l[n - 2] * (-1)`. The length of the list `l` is `n`, and the list is generated based on the provided formula using the initial values from `pre_l`.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
