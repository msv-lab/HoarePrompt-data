Correctness: **False**

Explanation:
The program does not handle the case where the string `S` consists entirely of `.` or `#`. For example, if the input is:

```
5
.....
```

The expected output is `0` because there are no white stones immediately to the right of a black stone. However, the program will incorrectly output `5` because it initializes `tail` to `n - temp` (which is `5 - 0 = 5`) and then proceeds to calculate the result, leading to an incorrect answer.

Additionally, the program has a logical error in the way it updates `head` and `tail`. The variable `tail` is decremented for each `.` encountered, but this does not correctly reflect the number of stones that need to be recolored to avoid having a white stone immediately to the right of a black stone. The correct approach would involve counting the number of black stones to the left and white stones to the right for each position and finding the minimum number of changes required.

Here is a corrected version of the program:

```python
def func():
    n = int(input())
    s = input()
    prefix_black = [0] * (n + 1)
    suffix_white = [0] * (n + 1)

    # Calculate prefix sums of black stones
    for i in range(n):
        prefix_black[i + 1] = prefix_black[i] + (s[i] == '#')

    # Calculate suffix sums of white stones
    for i in range(n - 1, -1, -1):
        suffix_white[i] = suffix_white[i + 1] + (s[i] == '.')

    # Find the minimum number of changes
    min_changes = float('inf')
    for i in range(n + 1):
        changes = prefix_black[i] + suffix_white[i]
        if changes < min_changes:
            min_changes = changes

    print(min_changes)
```

This version correctly handles all edge cases and ensures that the minimum number of stones to be recolored is calculated accurately.