
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Vasya is currently at a car rental service, and he wants to reach cinema. The film he has bought a ticket for starts in t minutes. There is a straight road of length s from the service to the cinema. Let's introduce a coordinate system so that the car rental service is at the point 0, and the cinema is at the point s.

There are k gas stations along the road, and at each of them you can fill a car with any amount of fuel for free! Consider that this operation doesn't take any time, i.e. is carried out instantly.

There are n cars in the rental service, i-th of them is characterized with two integers ci and vi — the price of this car rent and the capacity of its fuel tank in liters. It's not allowed to fuel a car with more fuel than its tank capacity vi. All cars are completely fueled at the car rental service.

Each of the cars can be driven in one of two speed modes: normal or accelerated. In the normal mode a car covers 1 kilometer in 2 minutes, and consumes 1 liter of fuel. In the accelerated mode a car covers 1 kilometer in 1 minutes, but consumes 2 liters of fuel. The driving mode can be changed at any moment and any number of times.

Your task is to choose a car with minimum price such that Vasya can reach the cinema before the show starts, i.e. not later than in t minutes. Assume that all cars are completely fueled initially.

Input

The first line contains four positive integers n, k, s and t (1 ≤ n ≤ 2·105, 1 ≤ k ≤ 2·105, 2 ≤ s ≤ 109, 1 ≤ t ≤ 2·109) — the number of cars at the car rental service, the number of gas stations along the road, the length of the road and the time in which the film starts. 

Each of the next n lines contains two positive integers ci and vi (1 ≤ ci, vi ≤ 109) — the price of the i-th car and its fuel tank capacity.

The next line contains k distinct integers g1, g2, ..., gk (1 ≤ gi ≤ s - 1) — the positions of the gas stations on the road in arbitrary order.

Output

Print the minimum rent price of an appropriate car, i.e. such car that Vasya will be able to reach the cinema before the film starts (not later than in t minutes). If there is no appropriate car, print -1.

Examples

Input

3 1 8 10
10 8
5 7
11 9
3


Output

10


Input

2 2 10 18
10 4
20 6
5 3


Output

20

Note

In the first sample, Vasya can reach the cinema in time using the first or the third cars, but it would be cheaper to choose the first one. Its price is equal to 10, and the capacity of its fuel tank is 8. Then Vasya can drive to the first gas station in the accelerated mode in 3 minutes, spending 6 liters of fuel. After that he can full the tank and cover 2 kilometers in the normal mode in 4 minutes, spending 2 liters of fuel. Finally, he drives in the accelerated mode covering the remaining 3 kilometers in 3 minutes and spending 6 liters of fuel. 
Program:
```
from sys import stdin

input = func_1()
rints = lambda : [int(x) for x in input().split()]
rints_2d = lambda n: [tuple(rints()) for _ in range(n)]
(n, k, s, t) = rints()
(a, g) = (sorted(rints_2d(n), key=lambda x: (x[1], x[0])), sorted(rints()) + [s])
(be, en, ans) = (0, n - 1, float('inf'))
while be <= en:
    md = be + en >> 1
    (fuel, point, time) = (a[md][1], 0, 0)
    for i in range(k + 1):
        dist = g[i] - point
        rem = fuel - dist
        if rem < 0:
            time = float('inf')
            break
        else:
            x = min(dist, rem)
            time += x + (dist - x) * 2
        point = g[i]
    if time > t:
        be = md + 1
    else:
        en = md - 1
        ans = min(ans, a[md][0])
print(-1 if ans == float('inf') else ans)

def func_1():
    import os, sys, atexit
    from cStringIO import StringIO as BytesIO
    sys.stdout = BytesIO()
    atexit.register(lambda : os.write(1, sys.stdout.getvalue()))
    return BytesIO(os.read(0, os.fstat(0).st_size)).readline


```
Original Assessment: Correctness: **False**

Explanation: The program has a potential issue with how it calculates the time required to travel between gas stations. Specifically, the logic for determining the time spent in normal and accelerated modes is not handled correctly in the following block:

```python
x = min(dist, rem)
time += x + (dist - x) * 2
```

This logic assumes that the car will always use the accelerated mode as much as possible, and then switch to the normal mode for the remaining distance. However, this approach might not always yield the minimum time. For example, consider a scenario where the car has just enough fuel to cover the entire distance in the normal mode but not in the accelerated mode. In such a case, the car should use the normal mode throughout to minimize the total time, but the current logic might incorrectly force the car to use the accelerated mode for part of the distance, leading to an incorrect total time calculation.

To illustrate this, consider the following test case:

Input:
```
1 1 10 20
10 10
5
```

Expected Output:
```
10
```

Actual Output:
```
-1
```

In this test case, the car has a fuel tank capacity of 10 liters and the road length is 10 kilometers. The car can reach the cinema in exactly 20 minutes by driving in the normal mode the entire way (10 kilometers in 20 minutes, consuming 10 liters of fuel). However, the program incorrectly calculates the time and outputs -1, indicating that no car can reach the cinema in time. This demonstrates that the program does not handle this specific edge case correctly.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import stdin

input = func_1()
rints = lambda : [int(x) for x in input().split()]
rints_2d = lambda n: [tuple(rints()) for _ in range(n)]
(n, k, s, t) = rints()
(a, g) = (sorted(rints_2d(n), key=lambda x: (x[1], x[0])), sorted(rints()) + [s])
(be, en, ans) = (0, n - 1, float('inf'))
while be <= en:
    md = be + en >> 1
    (fuel, point, time) = (a[md][1], 0, 0)
    for i in range(k + 1):
        dist = g[i] - point
        rem = fuel - dist
        if rem < 0:
            time = float('inf')
            break
        else:
            x = min(dist, rem)
            time += x + (dist - x) * 2
        point = g[i]
    if time > t:
        be = md + 1
    else:
        en = md - 1
        ans = min(ans, a[md][0])
print(-1 if ans == float('inf') else ans)

#State of the program right berfore the function call: n, k, s, and t are positive integers where 1 ≤ n ≤ 2·10^5, 1 ≤ k ≤ 2·10^5, 2 ≤ s ≤ 10^9, and 1 ≤ t ≤ 2·10^9. ci and vi are positive integers for each car i, where 1 ≤ ci, vi ≤ 10^9. The list of gas station positions g is a list of k distinct integers, each in the range 1 to s-1.
def func_1():
    sys.stdout = BytesIO()
    atexit.register(lambda : os.write(1, sys.stdout.getvalue()))
    return BytesIO(os.read(0, os.fstat(0).st_size)).readline
    #The program returns the readline method of a BytesIO object that was initialized with the content read from the standard input (file descriptor 0) up to the size of the file.


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
