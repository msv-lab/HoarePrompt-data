
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: You've got an n × m pixel picture. Each pixel can be white or black. Your task is to change the colors of as few pixels as possible to obtain a barcode picture.

A picture is a barcode if the following conditions are fulfilled: 

  * All pixels in each column are of the same color. 
  * The width of each monochrome vertical line is at least x and at most y pixels. In other words, if we group all neighbouring columns of the pixels with equal color, the size of each group can not be less than x or greater than y. 

Input

The first line contains four space-separated integers n, m, x and y (1 ≤ n, m, x, y ≤ 1000; x ≤ y).

Then follow n lines, describing the original image. Each of these lines contains exactly m characters. Character "." represents a white pixel and "#" represents a black pixel. The picture description doesn't have any other characters besides "." and "#".

Output

In the first line print the minimum number of pixels to repaint. It is guaranteed that the answer exists. 

Examples

Input

6 5 1 2
##.#.
.###.
###..
#...#
.##.#
###..


Output

11


Input

2 5 1 1
#####
.....


Output

5

Note

In the first test sample the picture after changing some colors can looks as follows: 
    
    
      
    .##..  
    .##..  
    .##..  
    .##..  
    .##..  
    .##..  
    

In the second test sample the picture after changing some colors can looks as follows: 
    
    
      
    .#.#.  
    .#.#.  
    
Program:
```
from sys import stdin
from collections import defaultdict
import sys
import time
#Function 1:
def func_1(matrix, n, m):
    white_cost = []
    black_cost = []
    for i in range(m):
        bcount = 0
        wcount = 0
        for j in range(n):
            if matrix[j][i] == '.':
                bcount += 1
            else:
                wcount += 1
        white_cost.append(wcount)
        black_cost.append(bcount)
    return (black_cost, white_cost)

#Function 2:
def func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index, w, b):
    if index >= m:
        if w != 0 and w >= x:
            return 0
        if b != 0 and b >= x:
            return 0
        return float('inf')
    else:
        if dp1[w][index] != -1 and dp2[b][index] != -1:
            return min(dp1[w][index], dp2[b][index])
        c1 = float('inf')
        c2 = float('inf')
        c3 = float('inf')
        c4 = float('inf')
        if w < x:
            c1 = 0
            cw = w
            i = index
            while cw < x:
                if i == m:
                    break
                c1 += white_cost[i]
                i += 1
                cw += 1
            c1 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)
        if b < x:
            c2 = 0
            cb = b
            i = index
            while cb < x:
                if i == m:
                    c2 = float('inf')
                    break
                c2 += black_cost[i]
                i += 1
                cb += 1
            c2 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)
        if w >= x and w + 1 <= y:
            c3 = white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)
        if b >= x and b + 1 <= y:
            c4 = black_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, 0, b + 1)
        dp1[w][index] = min(c1, c3)
        dp2[b][index] = min(c2, c4)
        return min(c1, c2, c3, c4)


```
Original Assessment: Correctness: **False**.

Explanation: The program does not handle the initialization of the `dp1` and `dp2` arrays, which are used for dynamic programming. These arrays are not defined or initialized before being used in the `func_2` function, leading to a potential error. Specifically, the line `if dp1[w][index] != -1 and dp2[b][index] != -1:` will raise an error if `dp1` or `dp2` are not properly initialized with the correct dimensions and default values.

To fix this, `dp1` and `dp2` should be initialized with dimensions that cover all possible states, typically using a large enough value to represent infinity. For example:

```python
dp1 = [[-1 for _ in range(m)] for _ in range(y + 1)]
dp2 = [[-1 for _ in range(m)] for _ in range(y + 1)]
```

This initialization ensures that the program can correctly use and update the `dp1` and `dp2` arrays without encountering out-of-bounds errors or undefined behavior. Without this initialization, the program will fail for any input, making it incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import stdin
from collections import defaultdict
import sys
import time

"""input
10 5 3 7
.####
###..
##.##
#..#.
.#...
#.##.
.##..
.#.##
#.#..
.#..#
"""
sys.setrecursionlimit(15000)
(n, m, x, y) = list(map(int, stdin.readline().split()))
matrix = []
for _ in range(n):
    matrix.append(list(stdin.readline().strip()))
(black_cost, white_cost) = func_1(matrix, n, m)
dp1 = [[-1 for j in range(m)] for k in range(y + 1)]
dp2 = [[-1 for j in range(m)] for k in range(y + 1)]
print(func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, 0, 0, 0))

#Function 1:
#State of the program right berfore the function call: matrix is a 2D list of strings where each string is either "." or "#", representing white and black pixels respectively, and n and m are positive integers such that 1 ≤ n, m ≤ 1000, indicating the dimensions of the matrix (n rows and m columns).
def func_1(matrix, n, m):
    white_cost = []
    black_cost = []
    for i in range(m):
        bcount = 0
        
        wcount = 0
        
        for j in range(n):
            if matrix[j][i] == '.':
                bcount += 1
            else:
                wcount += 1
        
        white_cost.append(wcount)
        
        black_cost.append(bcount)
        
    #State of the program after the  for loop has been executed: `matrix` is a 2D list of strings where each string is either "." or "#", `n` and `m` are positive integers such that 1 ≤ n, m ≤ 1000, `white_cost` is a list of length `m` where each element is the count of "#" in the corresponding column of `matrix`, `black_cost` is a list of length `m` where each element is the count of "." in the corresponding column of `matrix`.
    return black_cost, white_cost
    #The program returns two lists, `black_cost` and `white_cost`. `black_cost` is a list of length `m` where each element is the count of "." in the corresponding column of `matrix`. `white_cost` is a list of length `m` where each element is the count of "#" in the corresponding column of `matrix`.
#Overall this is what the function does:The function `func_1` takes a 2D list `matrix` of strings where each string is either "." or "#", and two positive integers `n` and `m` indicating the dimensions of the matrix (n rows and m columns). It returns two lists, `black_cost` and `white_cost`, each of length `m`. `black_cost` contains the count of "." in each column, and `white_cost` contains the count of "#" in each column. The function correctly counts the occurrences of "." and "#" in each column and populates the respective lists accordingly. If the matrix is empty or contains invalid characters (not "." or "#"), the function will still execute but may produce incorrect results.

#Function 2:
#State of the program right berfore the function call: dp1 and dp2 are 2D lists initialized to -1, matrix is a 2D list of characters ('.' or '#') representing the image, n and m are positive integers representing the dimensions of the matrix, x and y are positive integers where 1 ≤ x ≤ y ≤ 1000, black_cost and white_cost are lists of integers of length m, index is an integer starting from 0, w and b are integers representing the current widths of white and black segments, respectively.
def func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index, w, b):
    if (index >= m) :
        if (w != 0 and w >= x) :
            return 0
            #The program returns 0
        #State of the program after the if block has been executed: dp1 and dp2 are 2D lists initialized to -1, matrix is a 2D list of characters ('.' or '#') representing the image, n and m are positive integers representing the dimensions of the matrix, x and y are positive integers where 1 ≤ x ≤ y ≤ 1000, black_cost and white_cost are lists of integers of length m, index is an integer starting from 0, w and b are integers representing the current widths of white and black segments, respectively. The current value of index is greater than or equal to m, and either w is 0 or w is less than x.
        if (b != 0 and b >= x) :
            return 0
            #The program returns 0
        #State of the program after the if block has been executed: dp1 and dp2 are 2D lists initialized to -1, matrix is a 2D list of characters ('.' or '#') representing the image, n and m are positive integers representing the dimensions of the matrix, x and y are positive integers where 1 ≤ x ≤ y ≤ 1000, black_cost and white_cost are lists of integers of length m, index is an integer starting from 0, w and b are integers representing the current widths of white and black segments, respectively. The current value of index is greater than or equal to m, and either w is 0 or w is less than x. Additionally, either b is 0 or b is less than x.
        return float('inf')
        #The program returns infinity (float('inf'))
    else :
        if (dp1[w][index] != -1 and dp2[b][index] != -1) :
            return min(dp1[w][index], dp2[b][index])
            #The program returns the minimum value between `dp1[w][index]` and `dp2[b][index]`, where `dp1[w][index]` and `dp2[b][index]` are integers and not -1, `w` and `b` are the current widths of white and black segments, respectively, and `index` is an integer less than `m`.
        #State of the program after the if block has been executed: dp1 and dp2 are 2D lists initialized to -1, matrix is a 2D list of characters ('.' or '#') representing the image, n and m are positive integers representing the dimensions of the matrix, x and y are positive integers where 1 ≤ x ≤ y ≤ 1000, black_cost and white_cost are lists of integers of length m, index is an integer starting from 0, w and b are integers representing the current widths of white and black segments, respectively, and `index` is less than `m`. Additionally, either `dp1[w][index] == -1` or `dp2[b][index] == -1` (or both).
        c1 = float('inf')
        c2 = float('inf')
        c3 = float('inf')
        c4 = float('inf')
        if (w < x) :
            c1 = 0
            cw = w
            i = index
            while cw < x:
                if i == m:
                    break
                
                c1 += white_cost[i]
                
                i += 1
                
                cw += 1
                
            #State of the program after the loop has been executed: `dp1` and `dp2` are 2D lists initialized to -1, `matrix` is a 2D list of characters ('.' or '#') representing the image, `n` and `m` are positive integers representing the dimensions of the matrix, `x` and `y` are positive integers where 1 ≤ x ≤ y ≤ 1000, `black_cost` and `white_cost` are lists of integers of length m, `index` is an integer starting from 0, `w` and `b` are integers representing the current widths of white and black segments, respectively, `index` is less than `m`, either `dp1[w][index] == -1` or `dp2[b][index] == -1` (or both), `c1` is the sum of `white_cost` from `index` to `min(index + x - w, m) - 1`, `c2` is float('inf'), `c3` is float('inf'), `c4` is float('inf'), `w` is less than `x`, `cw` is equal to `min(x, w + (m - index))`, `i` is equal to `min(m, index + (x - w))`. If `i` is equal to `m`, the loop breaks.
            c1 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)
        #State of the program after the if block has been executed: *`dp1` and `dp2` are 2D lists initialized to -1, `matrix` is a 2D list of characters ('.' or '#') representing the image, `n` and `m` are positive integers representing the dimensions of the matrix, `x` and `y` are positive integers where 1 ≤ x ≤ y ≤ 1000, `black_cost` and `white_cost` are lists of integers of length m, `index` is an integer starting from 0, `w` and `b` are integers representing the current widths of white and black segments, respectively, `index` is less than `m`, either `dp1[w][index] == -1` or `dp2[b][index] == -1` (or both), `c1` is float('inf'), `c2` is float('inf'), `c3` is float('inf'), `c4` is float('inf'). If `w < x`, `c1` is updated to the sum of `white_cost` from `index` to `min(index + x - w, m) - 1` plus the result of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`, `cw` is equal to `min(x, w + (m - index))`, and `i` is equal to `min(m, index + (x - w))`. If `i` is equal to `m`, the loop breaks. Otherwise, all variables remain unchanged.
        if (b < x) :
            c2 = 0
            cb = b
            i = index
            while cb < x:
                if i == m:
                    c2 = float('inf')
                    break
                
                c2 += black_cost[i]
                
                i += 1
                
                cb += 1
                
            #State of the program after the loop has been executed: `dp1` and `dp2` are 2D lists initialized to -1, `matrix` is a 2D list of characters ('.' or '#') representing the image, `n` and `m` are positive integers representing the dimensions of the matrix, `x` and `y` are positive integers where 1 ≤ x ≤ y ≤ 1000, `black_cost` and `white_cost` are lists of integers of length m, `index` is an integer starting from 0, `w` and `b` are integers representing the current widths of white and black segments, respectively, `index` is less than `m`, either `dp1[w][index] == -1` or `dp2[b][index] == -1` (or both), `c1` is float('inf'), `c2` is float('inf') + the sum of `black_cost[index + k]` for `k` from 0 to `min(x - b, m - index) - 1`, `c3` is float('inf'), `c4` is float('inf'), `b` is less than `x`, `cb` is `b + min(x - b, m - index)`, `i` is `index + min(x - b, m - index)`. If `i` equals `m`, `c2` is float('inf').
            c2 += func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)
        #State of the program after the if block has been executed: *`dp1` and `dp2` are 2D lists initialized to -1, `matrix` is a 2D list of characters ('.' or '#') representing the image, `n` and `m` are positive integers representing the dimensions of the matrix, `x` and `y` are positive integers where 1 ≤ x ≤ y ≤ 1000, `black_cost` and `white_cost` are lists of integers of length m, `index` is an integer starting from 0, `w` and `b` are integers representing the current widths of white and black segments, respectively, `index` is less than `m`, either `dp1[w][index] == -1` or `dp2[b][index] == -1` (or both). If `b < x`, `c2` is updated to float('inf') + the sum of `black_cost[index + k]` for `k` from 0 to `min(x - b, m - index) - 1` + `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, 0, cb)`, `cb` is `b + min(x - b, m - index)`, `i` is `index + min(x - b, m - index)`. If `i` equals `m`, `c2` is float('inf'). If `w < x`, `c1` is updated to the sum of `white_cost` from `index` to `min(index + x - w, m) - 1` plus the result of `func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, i, cw, 0)`, `cw` is equal to `min(x, w + (m - index))`, and `i` is equal to `min(m, index + (x - w))`. If `i` is equal to `m`, the loop breaks. Otherwise, all variables remain unchanged.
        if (w >= x and w + 1 <= y) :
            c3 = white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost,
    white_cost, index + 1, w + 1, 0)
        #State of the program after the if block has been executed: *`dp1` and `dp2` are 2D lists initialized to -1, `matrix` is a 2D list of characters ('.' or '#'), `n` and `m` are positive integers representing the dimensions of the matrix, `x` and `y` are positive integers where 1 ≤ x ≤ y ≤ 1000, `black_cost` and `white_cost` are lists of integers of length `m`, `index` is an integer starting from 0, `w` and `b` are integers representing the current widths of white and black segments, respectively, `index` is less than `m`, either `dp1[w][index] == -1` or `dp2[b][index] == -1` (or both). If `w >= x` and `w + 1 <= y`, `c3` is updated to `white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)`. Otherwise, all variables remain unchanged.
        if (b >= x and b + 1 <= y) :
            c4 = black_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost,
    white_cost, index + 1, 0, b + 1)
        #State of the program after the if block has been executed: *`dp1` and `dp2` are 2D lists initialized to -1, `matrix` is a 2D list of characters ('.' or '#'), `n` and `m` are positive integers representing the dimensions of the matrix, `x` and `y` are positive integers where 1 ≤ x ≤ y ≤ 1000, `black_cost` and `white_cost` are lists of integers of length `m`, `index` is an integer starting from 0, `w` and `b` are integers representing the current widths of white and black segments, respectively, `index` is less than `m`, either `dp1[w][index] == -1` or `dp2[b][index] == -1` (or both). If `b >= x` and `b + 1 <= y`, then `c4` is updated to `black_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, 0, b + 1)`. Additionally, if `w >= x` and `w + 1 <= y`, `c3` is updated to `white_cost[index] + func_2(dp1, dp2, matrix, n, m, x, y, black_cost, white_cost, index + 1, w + 1, 0)`. Otherwise, all variables remain unchanged.
        dp1[w][index] = min(c1, c3)
        dp2[b][index] = min(c2, c4)
        return min(c1, c2, c3, c4)
        #The program returns the minimum value among `c1`, `c2`, `c3`, and `c4`. `c1` and `c2` are the current values stored in `dp1[w][index]` and `dp2[b][index]`, respectively. `c3` and `c4` are updated if their respective conditions are met, otherwise they retain their previous values or are set to a default value (if not previously defined).
#Overall this is what the function does:The function does not handle cases where the `black_cost` or `white_cost` lists are shorter than `m`, which could lead to out-of-bounds errors. Additionally, the function assumes that `dp1` and `dp2` are correctly initialized to -1, but this is not checked within the function.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
