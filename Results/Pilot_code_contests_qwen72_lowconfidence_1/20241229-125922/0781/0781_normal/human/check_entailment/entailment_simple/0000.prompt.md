
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Pinkie Pie has bought a bag of patty-cakes with different fillings! But it appeared that not all patty-cakes differ from one another with filling. In other words, the bag contains some patty-cakes with the same filling.

Pinkie Pie eats the patty-cakes one-by-one. She likes having fun so she decided not to simply eat the patty-cakes but to try not to eat the patty-cakes with the same filling way too often. To achieve this she wants the minimum distance between the eaten with the same filling to be the largest possible. Herein Pinkie Pie called the distance between two patty-cakes the number of eaten patty-cakes strictly between them.

Pinkie Pie can eat the patty-cakes in any order. She is impatient about eating all the patty-cakes up so she asks you to help her to count the greatest minimum distance between the eaten patty-cakes with the same filling amongst all possible orders of eating!

Pinkie Pie is going to buy more bags of patty-cakes so she asks you to solve this problem for several bags!

Input

The first line contains a single integer T (1 ≤ T ≤ 100): the number of bags for which you need to solve the problem.

The first line of each bag description contains a single integer n (2 ≤ n ≤ 10^5): the number of patty-cakes in it. The second line of the bag description contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ n): the information of patty-cakes' fillings: same fillings are defined as same integers, different fillings are defined as different integers. It is guaranteed that each bag contains at least two patty-cakes with the same filling. 

It is guaranteed that the sum of n over all bags does not exceed 10^5.

Output

For each bag print in separate line one single integer: the largest minimum distance between the eaten patty-cakes with the same filling amongst all possible orders of eating for that bag.

Example

Input


4
7
1 7 1 6 4 4 6
8
1 1 4 6 4 6 4 7
3
3 3 3
6
2 5 2 3 1 4


Output


3
2
0
4

Note

For the first bag Pinkie Pie can eat the patty-cakes in the following order (by fillings): 1, 6, 4, 7, 1, 6, 4 (in this way, the minimum distance is equal to 3).

For the second bag Pinkie Pie can eat the patty-cakes in the following order (by fillings): 1, 4, 6, 7, 4, 1, 6, 4 (in this way, the minimum distance is equal to 2).
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase
from math import log,sqrt,factorial,cos,tan,sin,radians,ceil,floor
import bisect
from decimal import *

"""
// Author : snape_here - Susanta Mukherjee
     
 """
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
mod = 1000000007
getcontext().prec = 25
abc = 'abcdefghijklmnopqrstuvwxyz'
pi = 3.141592653589793
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_7(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_12()

#Function 1:
#State of the program right berfore the function call: None. This function does not take any parameters.
def func_1():
    return int(input())
    #The program returns an integer value entered by the user.

#Function 2:
#State of the program right berfore the function call: None
def func_2():
    return float(input())
    #The program returns a float value input by the user.

#Function 3:
#State of the program right berfore the function call: None. This function does not take any parameters.
def func_3():
    return input()
    #The program returns the input provided by the user.

#Function 4:
#State of the program right berfore the function call: None
def func_4():
    return map(str, input().split())
    #The program returns a map object which applies the `str` function to each element from the input split by spaces. The input is not defined in the initial state, so the exact elements of the map object depend on the user's input.

#Function 5:
#State of the program right berfore the function call: None. This function does not take any parameters. It reads input from stdin, expecting a line of space-separated integers.
def func_5():
    return map(int, input().split())
    #The program returns a map object containing the integers read from a line of space-separated input.

#Function 6:
#State of the program right berfore the function call: None of the variables in the function signature. This function does not take any arguments and does not seem to contribute directly to solving the given problem.
def func_6():
    return list(func_5())
    #The program returns a list generated by calling the function `func_5()`. The content of the list depends on the implementation of `func_5()`, which is not provided.

#Function 7:
#State of the program right berfore the function call: None of the variables in the function signature are used. This function appears to set up input and output redirection and does not contribute to the core logic of solving the patty-cake problem.
def func_7():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 8:
#State of the program right berfore the function call: x and y are non-negative integers.
def func_8(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`, `y` is 0, and the original value of `y` was greater than 0.
    return x
    #The program returns the greatest common divisor (GCD) of the original values of `x` and `y`, where the original value of `y` was greater than 0.

#Function 9:
#State of the program right berfore the function call: x and y are positive integers.
def func_9(x, y):
    return x * y // func_8(x, y)
    #The program returns the integer division result of (x * y) by the value returned from func_8(x, y), where x and y are positive integers.

#Function 10:
#State of the program right berfore the function call: b and m are integers such that m > 1 and b is a positive integer.
def func_10(b, m):
    g = func_8(b, m)
    if (g != 1) :
        return -1
        #The program returns -1
    else :
        return pow(b, m - 2, m)
        #The program returns the result of `pow(b, m - 2, m)`, where `b` is a positive integer and `m` is an integer such that `m > 1`. The value of `g` is 1, but it does not affect the return value.

#Function 11:
#State of the program right berfore the function call: a and b are integers, m is a positive integer.
def func_11(a, b, m):
    a = a % m
    inv = func_10(b, m)
    if (inv == -1) :
        return -999999999
        #The program returns -999999999
    else :
        return inv * a % m
        #The program returns the result of `(inv * a) % m`, where `a` is `a % m`, `b` is an integer, `m` is a positive integer, `inv` is the result of `func_10(b, m)`, and `inv` is not equal to -1.

#Function 12:
#State of the program right berfore the function call: No input parameters are provided to `func_12()`. It internally uses `func_1()` to get the number of test cases `T` and the number of patty-cakes `n` for each test case, and `func_6()` to get the list of integers representing the patty-cakes' fillings `a` for each test case.
def func_12():
    for _ in range(func_1()):
        n = func_1()
        
        a = func_6()
        
        a.sort(reverse=True)
        
        f = [0] * 100005
        
        for i in range(n):
            f[a[i]] += 1
        
        s = 0
        
        s = max(f)
        
        if s == n:
            func_13(0)
            continue
        
        if f.count(1) == n - s:
            if s == 2:
                ans = n - s
            else:
                ans = (n - 1) // (s + 1)
                ans += 1
            func_13(ans)
            continue
        
        ans = (n - 1) // (s + 1)
        
        ans += 1
        
        func_13(ans)
        
    #State of the program after the  for loop has been executed: `func_1()` returns a non-negative integer `T` indicating the number of test cases. For each test case, `n` is a non-negative integer representing the number of patty-cakes, and `a` is a list of integers representing the fillings of the patty-cakes, sorted in descending order. The list `f` is a list of 100,005 elements initialized to 0, and for each `i` in the range `[0, n-1]`, `f[a[i]]` is incremented by 1. The variable `s` is the maximum value in `f`. If `s` equals `n`, `func_13(0)` is called. Otherwise, `ans` is calculated as `(n - 1) // (s + 1) + 1`, and `func_13(ans)` is called. After all iterations, the loop has processed `T` test cases, and `func_13` has been called with the appropriate `ans` value for each test case.

#Function 13:
#State of the program right berfore the function call: args is a tuple containing any number of values of any type, and kwargs is a dictionary containing optional keyword arguments such as 'sep', 'file', 'end', and 'flush'. 'sep' is a string used to separate the values, 'file' is a stream object to which the values will be written, 'end' is a string appended after the last value, and 'flush' is a boolean indicating whether to forcibly flush the stream.
def func_13():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a tuple containing any number of values, `kwargs` is a dictionary, `sep` is a string (default ' ' if not specified in `kwargs`), `file` is a stream object (default `sys.stdout` if not specified in `kwargs`), `end` is a string, `flush` is a boolean, `at_start` is False if `args` is not empty, otherwise `at_start` remains True, and the string representations of all elements in `args` are written to `file` separated by `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a tuple containing any number of values, `kwargs` is a dictionary with `'end'` removed if it was present, `sep` is a string (default ' ' if not specified in `kwargs`), `file` is a stream object (default `sys.stdout` if not specified in `kwargs`). The string representations of all elements in `args` are written to `file` separated by `sep`. The newline character or the value of `'end'` has been written to `file`. If `flush` is `True`, the buffer of `file` has been flushed. `end` is a string, `flush` is a boolean, and `at_start` is False if `args` is not empty, otherwise `at_start` remains True.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
