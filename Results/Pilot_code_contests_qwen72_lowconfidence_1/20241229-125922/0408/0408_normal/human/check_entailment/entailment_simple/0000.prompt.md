
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Recently Pashmak has been employed in a transportation company. The company has k buses and has a contract with a school which has n students. The school planned to take the students to d different places for d days (each day in one place). Each day the company provides all the buses for the trip. Pashmak has to arrange the students in the buses. He wants to arrange the students in a way that no two students become close friends. In his ridiculous idea, two students will become close friends if and only if they are in the same buses for all d days.

Please help Pashmak with his weird idea. Assume that each bus has an unlimited capacity.

Input

The first line of input contains three space-separated integers n, k, d (1 ≤ n, d ≤ 1000; 1 ≤ k ≤ 109).

Output

If there is no valid arrangement just print -1. Otherwise print d lines, in each of them print n integers. The j-th integer of the i-th line shows which bus the j-th student has to take on the i-th day. You can assume that the buses are numbered from 1 to k.

Examples

Input

3 2 2


Output

1 1 2 
1 2 1 


Input

3 2 1


Output

-1

Note

Note that two students become close friends only if they share a bus each day. But the bus they share can differ from day to day.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
func_2()

#Function 1:
#State of the program right berfore the function call: a is a list of non-negative integers, and k is a positive integer.
def func_1(a, k):
    carry = 1
    for i in range(len(a) - 1, -1, -1):
        newval = a[i] + carry
        
        if newval >= k:
            if i == 0:
                return False
            newval = 0
            carry = 1
        else:
            carry = 0
        
        a[i] = newval
        
    #State of the program after the  for loop has been executed: `a` is a list of non-negative integers where each element has been updated according to the rules defined in the loop. `k` is a positive integer. `carry` is 0 if no overflow occurred during the last update, otherwise, if an overflow occurred at the first element of `a` (index 0), the function returns `False`. If the loop does not execute (i.e., if `a` is an empty list), `carry` remains 1, and the function does not return `False`.
    return True
    #The program returns True

#Function 2:
#State of the program right berfore the function call: n, k, and d are integers such that 1 ≤ n, d ≤ 1000 and 1 ≤ k ≤ 10^9.
def func_2():
    n, k, d = map(int, raw_input().split())
    a = [0] * d
    res = list()
    nextFine = True
    for want in xrange(n):
        if not nextFine:
            print(-1)
            return
        
        res.append(list(val + 1 for val in a))
        
        nextFine = func_1(a, k)
        
    #State of the program after the  for loop has been executed: `n` is an integer such that 1 ≤ n ≤ 1000, `k` is an integer such that 1 ≤ k ≤ 10^9, `d` is an integer such that 1 ≤ d ≤ 1000, `a` is a list of `d` zeros, `res` is a list containing `n` lists of `d` ones, `nextFine` is the result of the last call to `func_1(a, k)`, `want` is `n - 1`. If `nextFine` becomes `False` at any point during the loop, the loop terminates early, `res` contains fewer than `n` lists, and the program returns `-1`. If `n` is 0, the loop does not execute, and `res` remains an empty list, `nextFine` remains `True`, and `want` is undefined.
    print('\n'.join(' '.join(map(str, l)) for l in res))


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
