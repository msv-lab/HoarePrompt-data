
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Zookeeper is playing a game. In this game, Zookeeper must use bombs to bomb a string that consists of letters 'A' and 'B'. He can use bombs to bomb a substring which is either "AB" or "BB". When he bombs such a substring, the substring gets deleted from the string and the remaining parts of the string get concatenated.

For example, Zookeeper can use two such operations: AABABBA → AABBA → AAA.

Zookeeper wonders what the shortest string he can make is. Can you help him find the length of the shortest string?

Input

Each test contains multiple test cases. The first line contains a single integer t (1 ≤ t ≤ 20000) — the number of test cases. The description of the test cases follows.

Each of the next t lines contains a single test case each, consisting of a non-empty string s: the string that Zookeeper needs to bomb. It is guaranteed that all symbols of s are either 'A' or 'B'.

It is guaranteed that the sum of |s| (length of s) among all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, print a single integer: the length of the shortest string that Zookeeper can make.

Example

Input


3
AAA
BABA
AABBBABBBB


Output


3
2
0

Note

For the first test case, you can't make any moves, so the answer is 3.

For the second test case, one optimal sequence of moves is BABA → BA. So, the answer is 2.

For the third test case, one optimal sequence of moves is AABBBABBBB → AABBBABB → AABBBB → ABBB → AB → (empty string). So, the answer is 0.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
import math
import os, sys
from sys import maxint
from io import BytesIO, IOBase
from itertools import permutations

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_17(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_18()

#Function 1:
#State of the program right berfore the function call: None. This function does not take any arguments.
def func_1():
    return int(input())
    #The program returns an integer value input by the user.

#Function 2:
#State of the program right berfore the function call: No variables are present in the function signature.
def func_2():
    return input()
    #The program returns the user input as a string.

#Function 3:
#State of the program right berfore the function call: This function does not take any parameters, and it is intended to read input from the standard input, expecting a line of space-separated integers.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object that converts each element of the space-separated integers input from the standard input into an integer.

#Function 4:
#State of the program right berfore the function call: None of the variables in the function signature are used; the function reads input from the standard input.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns an iterator that yields each element from the input string split by spaces, with each element converted to a string. The input string is read from the standard input and any leading or trailing whitespace is removed before splitting.

#Function 5:
#State of the program right berfore the function call: None of the variables in the function signature are used, thus there are no preconditions related to input variables.
def func_5():
    return list(func_3())
    #The program returns a list that is the result of calling `func_3()`. The content of the list depends on the implementation of `func_3()`.

#Function 6:
#State of the program right berfore the function call: No input variables are present in the function signature. This function appears to be setting up the environment for another function (`main`) to run, possibly handling large inputs or recursive calls by adjusting system limits and thread settings.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a tuple or list with at least two elements.
def func_7(item):
    return item[1]
    #The program returns the second element of the tuple or list 'item'.

#Function 8:
#State of the program right berfore the function call: l is a list of elements that can be compared and sorted, and `getKey` is a function that takes an element of l as input and returns a value used for sorting.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns a new list that is a sorted version of `l`, using the values returned by `getKey` for each element as the basis for comparison, and the list is sorted in descending order.

#Function 9:
#State of the program right berfore the function call: n and m are non-negative integers, and num is a value of any type.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of lists, where each inner list contains `m` elements, each element being the value of `num`. The outer list contains `n` such inner lists.

#Function 10:
#State of the program right berfore the function call: x is an integer.
def func_10(x):
    return x and not x & x - 1
    #The program returns 0 if `x` is 0, `True` if `x` is a power of 2, and `False` if `x` is any other non-zero integer.

#Function 11:
#State of the program right berfore the function call: n is a non-negative integer.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of n as a string, without the '0b' prefix.

#Function 12:
#State of the program right berfore the function call: n is an integer.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is a digit from the integer `n`.

#Function 13:
#State of the program right berfore the function call: x and y are integers where y is not zero.
def func_13(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer division result of x by y, which is an integer since x is divisible by y (i.e., x % y == 0)
    else :
        return x // y + 1
        #The program returns the integer division of x by y (which is not zero) plus 1, where x % y is not equal to 0.

#Function 14:
#State of the program right berfore the function call: x and p are integers where p > 1, and y is a non-negative integer.
def func_14(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is `x^y % p` where `x` and `y` are the original values, `x` is `x^(2^iterations) % p` where `iterations` is the number of times the loop executed, `p` is an integer greater than 1.
    return res
    #The program returns `res` which is calculated as `x^y % p`, where `x` and `y` are the original values, and `p` is an integer greater than 1. Since `y` is 0, the calculation simplifies to `x^0 % p`, which results in 1 (since any non-zero number raised to the power of 0 is 1). Therefore, the program returns 1.

#Function 15:
#State of the program right berfore the function call: x and y are non-negative integers.
def func_15(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the greatest common divisor (GCD) of the original values of `x` and `y`
    return x
    #The program returns the greatest common divisor (GCD) of the original values of `x` and `y`, where `y` is 0. Since the GCD of any number and 0 is the number itself, the program returns the original value of `x`.

#Function 16:
#State of the program right berfore the function call: n is an integer greater than 1.
def func_16(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer greater than 1, and n is greater than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: n is an integer greater than 1, and n is greater than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer greater than 1 and greater than 3, and n is not divisible by 2 and not divisible by 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is an integer greater than 1 and greater than 3, not divisible by 2 or 3, and `n` is not divisible by any prime number less than or equal to the square root of `n`. `i` is the smallest integer such that `i * i > n`. If `n` is divisible by any prime number `p` where `5 ≤ p ≤ sqrt(n)` and `p ≡ 1 or 5 (mod 6)`, the program returns False.
    return True
    #The program returns True

#Function 17:
#State of the program right berfore the function call: None of the variables in the function signature are relevant to the problem's input or output. This function is used for redirecting standard input and output to files and does not take any parameters related to the problem's context.
def func_17():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 18:
#State of the program right berfore the function call: None of the variables in the function signature are provided; the function reads input directly. However, it is expected that the input conforms to the problem description: the first line should be an integer t (1 ≤ t ≤ 20000), followed by t lines, each containing a string s consisting only of 'A' and 'B', with the total length of all strings not exceeding 2 ⋅ 10^5.
def func_18():
    for _ in range(int(input())):
        s = raw_input()
        
        func_19(solve(s))
        
    #State of the program after the  for loop has been executed: `t` is an integer such that 1 ≤ t ≤ 20000, `s` is the last string read from the input, consisting only of 'A' and 'B', with the total length of all strings not exceeding 2 ⋅ 10^5. The function `solve(s)` has been called `t` times, and its result has been passed to `func_19` each time. If `t` is 0, the loop does not execute, and no calls to `solve(s)` or `func_19` are made.

#Function 19:
#State of the program right berfore the function call: s is a non-empty string consisting only of the characters 'A' and 'B'.
def solve(s):
    if (s.find('AB') == -1 and s.find('BB') == -1) :
        return len(s)
        #The program returns the length of the string `s`, which is a non-empty string consisting only of the characters 'A' and 'B', and does not contain the substrings 'AB' or 'BB'.
    #State of the program after the if block has been executed: *s is a non-empty string consisting only of the characters 'A' and 'B'. The string s contains at least one occurrence of either 'AB' or 'BB'.
    while s.find('AB') != -1:
        s = s.replace('AB', '')
        
    #State of the program after the loop has been executed: `s` is a non-empty string with all 'AB' substrings removed, and if the original `s` contained 'AB' or 'BB', the resulting `s` will no longer contain 'AB' and may contain 'B' characters only if they were part of 'BB' sequences.
    while s.find('BB') != -1:
        s = s.replace('BB', '')
        
    #State of the program after the loop has been executed: `s` is a non-empty string with all 'AB' and 'BB' substrings removed, and `s` does not contain any 'BB' sequence.
    return len(s)
    #The program returns the length of string `s`, which is a non-empty string with all 'AB' and 'BB' substrings removed, and does not contain any 'BB' sequence.

#Function 20:
#State of the program right berfore the function call: args is a tuple containing any number of arguments of any type, and kwargs is a dictionary that can contain the keys 'sep', 'file', 'end', and 'flush' with corresponding values of string, writable file object, string, and boolean respectively.
def func_19():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a tuple containing any number of arguments of any type, `kwargs` is a dictionary that may contain the keys 'end' and 'flush' with corresponding values, `sep` is the value of `kwargs['sep']` if `'sep'` was in `kwargs` otherwise it is `' '`, `file` is the value of `kwargs['file']` if `'file'` was in `kwargs` otherwise it is `sys.stdout` and now contains the string representations of all elements in `args` separated by `sep` (except before the first element), `at_start` is `False` if `args` is not empty, otherwise `at_start` remains `True`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a tuple containing any number of arguments of any type, `kwargs` is a dictionary that may contain the key 'flush' with the corresponding value (if 'end' was present, it is removed). `sep` is the value of `kwargs['sep']` if `'sep'` was in `kwargs` otherwise it is `' '`. `file` is the value of `kwargs['file']` if `'file'` was in `kwargs` otherwise it is `sys.stdout` and now contains the string representations of all elements in `args` separated by `sep` (except before the first element) followed by the value of `'end'` or `'\n'` if `'end'` was not in `kwargs`. `at_start` is `False` if `args` is not empty, otherwise `at_start` remains `True`. If `kwargs['flush']` is `True` and this key has been removed from `kwargs` if it was present, then `file` has flushed its buffer.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
