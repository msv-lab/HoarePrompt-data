
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Zookeeper is playing a game. In this game, Zookeeper must use bombs to bomb a string that consists of letters 'A' and 'B'. He can use bombs to bomb a substring which is either "AB" or "BB". When he bombs such a substring, the substring gets deleted from the string and the remaining parts of the string get concatenated.

For example, Zookeeper can use two such operations: AABABBA → AABBA → AAA.

Zookeeper wonders what the shortest string he can make is. Can you help him find the length of the shortest string?

Input

Each test contains multiple test cases. The first line contains a single integer t (1 ≤ t ≤ 20000) — the number of test cases. The description of the test cases follows.

Each of the next t lines contains a single test case each, consisting of a non-empty string s: the string that Zookeeper needs to bomb. It is guaranteed that all symbols of s are either 'A' or 'B'.

It is guaranteed that the sum of |s| (length of s) among all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case, print a single integer: the length of the shortest string that Zookeeper can make.

Example

Input


3
AAA
BABA
AABBBABBBB


Output


3
2
0

Note

For the first test case, you can't make any moves, so the answer is 3.

For the second test case, one optimal sequence of moves is BABA → BA. So, the answer is 2.

For the third test case, one optimal sequence of moves is AABBBABBBB → AABBBABB → AABBBB → ABBB → AB → (empty string). So, the answer is 0.
Functions with output description for each function:
from __future__ import division, print_function
import math
import os, sys
from sys import maxint
from io import BytesIO, IOBase
from itertools import permutations

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_17(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_18()

Function number 1 :
 Code:
 '''
def func_1():
    return int(input())
''' 

 Output hints for function1:  The function `func_1` does not accept any parameters and prompts the user to input a value. It then converts the input to an integer and returns this integer. If the user inputs a non-integer value, a `ValueError` will be raised. After the function concludes, the program will have returned an integer value based on the user's input, or it will have raised an exception if the input was invalid.
Function number 2 :
 Code:
 '''
def func_2():
    return input()
''' 

 Output hints for function2:  The function `func_2` does not accept any parameters and returns the user input as a string. However, the function lacks error handling for cases where the user might provide no input or input that could cause issues (e.g., special characters, very large inputs). After the function executes, the program will have returned a string containing whatever the user entered, or an empty string if the user provided no input.
Function number 3 :
 Code:
 '''
def func_3():
    return map(int, input().strip().split(' '))
''' 

 Output hints for function3:  The function `func_3` does not accept any parameters. It reads a single line of input from the standard input, which is expected to contain space-separated integers. The function then returns a map object that converts each of these space-separated strings into integers. If the input contains non-integer values or is empty, the behavior of the function is undefined and may result in a runtime error or an empty map object, respectively.
Function number 4 :
 Code:
 '''
def func_4():
    return map(str, input().strip().split(' '))
''' 

 Output hints for function4:  The function `func_4` reads a single line of input from the standard input, trims any leading and trailing whitespace, splits the resulting string by spaces, and returns an iterator that yields each element as a string. If the input is empty or contains only whitespace, the function will return an iterator that yields no elements.
Function number 5 :
 Code:
 '''
def func_5():
    return list(func_3())
''' 

 Output hints for function5:  The function `func_5` does not accept any parameters and returns a list that is the result of calling `func_3()`. The content of the returned list depends entirely on the implementation of `func_3()`. If `func_3()` raises an exception, `func_5` will also raise that exception. If `func_3()` returns a non-iterable, `func_5` will raise a `TypeError` when attempting to convert it to a list.
Function number 6 :
 Code:
 '''
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
''' 

 Output hints for function6:  The function `func_6` does not accept any parameters. It sets the recursion limit to 1,000,000 and the stack size for threads to 1,024,000 bytes. It then creates a new thread that targets the `main` function and starts this thread. The function itself does not return any value. After the function completes, the system limits are adjusted to handle large inputs or deep recursion, and a new thread is running the `main` function. If the `main` function throws an exception or if the system does not support setting the recursion limit or stack size, the behavior is undefined and may result in runtime errors.
Function number 7 :
 Code:
 '''
def func_7(item):
    return item[1]
''' 

 Output hints for function7:  The function `func_7` accepts a parameter `item`, which is expected to be a tuple or list with at least two elements, and returns the second element of `item`. If `item` has fewer than two elements, the function will raise an `IndexError`. The function does not modify the input `item` and does not have any side effects. After the function concludes, the second element of `item` is returned, and the state of the program remains unchanged except for the return value.
Function number 8 :
 Code:
 '''
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
''' 

 Output hints for function8:  The function `func_8` accepts a list `l` of elements that can be compared and sorted, along with a function `getKey` that is used to extract a comparison key from each element of the list. It returns a new list that is a sorted version of `l` in descending order based on the values returned by `getKey`. The original list `l` remains unchanged. If `l` is empty, the function returns an empty list. If `getKey` raises an exception for any element in `l`, the function will also raise an exception.
Function number 9 :
 Code:
 '''
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
''' 

 Output hints for function9:  The function `func_9` accepts three parameters: `n`, `m`, and `num`. It returns a list of `n` lists, where each inner list contains `m` elements, all set to the value of `num`. 

- If `n` is 0, the function returns an empty list.
- If `m` is 0, the function returns a list containing `n` empty lists.
- If both `n` and `m` are 0, the function returns an empty list.
- The function does not modify the input parameters and has no side effects.
Function number 10 :
 Code:
 '''
def func_10(x):
    return x and (not x & x - 1)
''' 

 Output hints for function10:  The function `func_10` accepts an integer `x` and returns a value based on the following conditions:
- It returns `0` if `x` is `0`.
- It returns `True` if `x` is a power of 2 (i.e., `x` is a positive integer and its binary representation contains exactly one '1').
- It returns `False` for all other non-zero integers. 

The function effectively checks if `x` is a power of 2 or not, with special handling for `0`. The state of the program after the function call is that the function has returned one of these three values based on the input `x`.
Function number 11 :
 Code:
 '''
def func_11(n):
    return bin(n).replace('0b', '')
''' 

 Output hints for function11:  The function `func_11` accepts a non-negative integer `n` and returns its binary representation as a string, excluding the '0b' prefix. If `n` is 0, the function returns "0". The function does not handle negative integers or non-integer inputs.
Function number 12 :
 Code:
 '''
def func_12(n):
    return [int(i) for i in str(n)]
''' 

 Output hints for function12:  The function `func_12` accepts an integer `n` and returns a list of integers where each integer is a digit from `n`. The function handles positive and negative integers, converting them into a list of their digits. For example, `func_12(123)` returns `[1, 2, 3]` and `func_12(-456)` returns `[4, 5, 6]`. If `n` is 0, the function returns `[0]`. The function does not handle non-integer inputs, and passing such inputs would result in an error.
Function number 13 :
 Code:
 '''
def func_13(x, y):
    if x % y == 0:
        return x // y
    else:
        return x // y + 1
''' 

 Output hints for function13:  The function `func_13` takes two integers, `x` and `y` (where `y` is not zero), and returns an integer. If `x` is divisible by `y` (i.e., `x % y == 0`), it returns the integer division result of `x` by `y`. If `x` is not divisible by `y` (i.e., `x % y != 0`), it returns the integer division result of `x` by `y` plus 1. The function ensures that the returned value is always an integer, and it handles both cases where `x` is exactly divisible by `y` and where it is not.
Function number 14 :
 Code:
 '''
def func_14(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p
    return res
''' 

 Output hints for function14:  The function `func_14` accepts three integers `x`, `y`, and `p` where `p > 1` and `y` is a non-negative integer. It calculates and returns the result of `x^y % p`. After the function concludes, the value of `y` is 0, `res` contains the result of `x^y % p`, and `x` is updated to `x^(2^iterations) % p` where `iterations` is the number of times the loop executed. The function correctly handles the case where `y` is 0, returning 1 as `x^0 % p` is always 1 for any non-zero `x`.
Function number 15 :
 Code:
 '''
def func_15(x, y):
    while y:
        (x, y) = (y, x % y)
    return x
''' 

 Output hints for function15:  The function `func_15` accepts two non-negative integers `x` and `y` and returns their greatest common divisor (GCD). After the function concludes, the value returned is the GCD of the original values of `x` and `y`. The function correctly handles the case where either `x` or `y` is zero, returning the non-zero value as the GCD. If both `x` and `y` are zero, the function returns 0, which can be considered the GCD of 0 and 0.
Function number 16 :
 Code:
 '''
def func_16(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True
''' 

 Output hints for function16:  The function `func_16` accepts an integer `n` (where `n` > 1) and returns a boolean value indicating whether `n` is a prime number. It returns `False` if `n` is less than or equal to 1, if `n` is 2 or 3, or if `n` is divisible by 2 or 3. For values of `n` greater than 3, it checks divisibility by all prime numbers up to the square root of `n` using a loop that increments by 6. If `n` is divisible by any such prime, the function returns `False`; otherwise, it returns `True`. The function correctly handles edge cases where `n` is 2 or 3, and it ensures that `n` is not divisible by any smaller prime before concluding that `n` is prime.
Function number 17 :
 Code:
 '''
def func_17():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
''' 

 Output hints for function17:  The function `func_17` does not accept any parameters and does not return any value. Its primary purpose is to redirect the standard input (`sys.stdin`) to read from a file named `input.txt` and the standard output (`sys.stdout`) to write to a file named `output.txt`. After the function executes, any subsequent input operations (e.g., `input()`) will read from `input.txt`, and any subsequent output operations (e.g., `print()`) will write to `output.txt`. The function does not handle any potential errors, such as the files not existing or being inaccessible, which could lead to runtime exceptions.
Function number 18 :
 Code:
 '''
def func_18():
    for _ in range(int(input())):
        s = raw_input()

        func_19(solve(s))
''' 

 Output hints for function18:  The function `func_18` reads an integer `t` from the standard input, which indicates the number of test cases. It then reads `t` lines, each containing a string `s` consisting only of 'A' and 'B'. For each string `s`, the function calls `solve(s)` and passes the result to `func_19`. The function does not return any value. After the function concludes, the program state includes having processed `t` test cases, with each string `s` being passed through `solve` and the result being passed to `func_19`. If `t` is 0, no strings are read, and neither `solve` nor `func_19` are called. The function assumes that the input is well-formed according to the problem description, but it does not handle invalid input or edge cases such as empty strings or input lengths exceeding the specified limits.
Function number 19 :
 Code:
 '''
def solve(s):
    if s.find('AB') == -1 and s.find('BB') == -1:
        return len(s)
    while s.find('AB') != -1:
        s = s.replace('AB', '')
    while s.find('BB') != -1:
        s = s.replace('BB', '')
    return len(s)
''' 

 Output hints for function19:  The function `solve` takes a non-empty string `s` consisting only of the characters 'A' and 'B'. It returns the length of `s` after removing all occurrences of the substrings 'AB' and 'BB'. If `s` initially does not contain 'AB' or 'BB', it simply returns the length of `s`. The final state of the string `s` is such that it no longer contains any 'AB' or 'BB' substrings. The function ensures that the resulting string `s` consists only of 'A' characters or is empty if all characters are removed.
Function number 20 :
 Code:
 '''
def func_19(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()
''' 

 Output hints for function20:  The function `func_19` prints the values of the provided positional arguments (`args`) to a specified output stream (`file`). It accepts any number of positional arguments of any type and optional keyword arguments (`kwargs`) which can include `sep`, `file`, `end`, and `flush`. The function writes the string representation of each argument to the output stream, separating them by the value of `sep` (defaulting to a space `' '`), and appends the value of `end` (defaulting to a newline `'\n'`) at the end. If the `flush` keyword argument is set to `True`, the output stream is flushed after writing. The function does not return any value. After the function executes, the `args` tuple remains unchanged, and the `kwargs` dictionary may have the keys `sep`, `end`, and `flush` removed if they were present. The `file` object will contain the concatenated string representations of the `args` elements, separated by `sep` and terminated by `end`. If `flush` was `True`, the buffer of `file` will have been flushed.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.