
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: There are N monsters, numbered 1, 2, ..., N.

Initially, the health of Monster i is A_i.

Below, a monster with at least 1 health is called alive.

Until there is only one alive monster, the following is repeated:

* A random alive monster attacks another random alive monster.
* As a result, the health of the monster attacked is reduced by the amount equal to the current health of the monster attacking.



Find the minimum possible final health of the last monster alive.

Constraints

* All values in input are integers.
* 2 \leq N \leq 10^5
* 1 \leq A_i \leq 10^9

Input

Input is given from Standard Input in the following format:


N
A_1 A_2 ... A_N


Output

Print the minimum possible final health of the last monster alive.

Examples

Input

4
2 10 8 40


Output

2


Input

4
5 13 8 1000000000


Output

1


Input

3
1000000000 1000000000 1000000000


Output

1000000000
Program:
```
def func():
    n = input()
    A = map(int, raw_input().split(' '))
    A.sort()
    ans = A[0]
    for a in A[1:]:
        m = a % ans
        if m != 0:
            ans = min(m, ans)
    print(ans)


```
Original Assessment: Correctness: **True**

Explanation:
The provided program correctly implements the logic to find the minimum possible final health of the last monster alive. Here's a step-by-step breakdown of why the program works:

1. **Reading Input**: The program reads the number of monsters `n` and the initial health values of the monsters `A` from standard input. It uses `input()` for `n` and `map(int, raw_input().split(' '))` for `A`. Note that `raw_input()` is used instead of `input()` for the list of health values, which is appropriate for Python 2.

2. **Sorting the Health Values**: The program sorts the list `A` in ascending order. This ensures that the smallest health values are processed first, which is crucial for the subsequent steps.

3. **Initialization**: The variable `ans` is initialized to the smallest health value in the sorted list `A`.

4. **Iterating Through the Sorted List**: The program iterates through the remaining elements in the sorted list `A`. For each element `a`, it calculates the remainder `m` when `a` is divided by `ans` (`m = a % ans`). If `m` is non-zero, it updates `ans` to be the minimum of `m` and `ans`.

5. **Final Output**: After processing all elements, the program prints the value of `ans`, which represents the minimum possible final health of the last monster alive.

### Why This Works:
- **GCD Property**: The key insight is that the minimum possible final health of the last monster is the greatest common divisor (GCD) of the initial health values. This is because each attack operation reduces the health of the attacked monster by a multiple of the attacker's health, and this process effectively reduces the problem to finding the GCD of the initial health values.
- **Modulo Operation**: The modulo operation `a % ans` ensures that we are always considering the remainder, which helps in reducing the health values step by step until we reach the GCD.
- **Minimum Value**: By updating `ans` to the minimum of `m` and `ans`, the program ensures that it always keeps track of the smallest possible value that can be the final health.

### Edge Cases:
- **Single Element List**: The program handles the case where there is only one monster (though the problem constraints guarantee at least two monsters).
- **Large Input Values**: The program efficiently handles large input values (up to \(10^9\)) due to the properties of the GCD and modulo operations.
- **Multiple Monsters with the Same Health**: The program correctly handles cases where multiple monsters have the same initial health value.

Given these points, the program appears to handle all potential cases correctly, and thus it is correct.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: The function reads an integer `N` from the input, followed by a list of `N` integers `A`. It then calculates the greatest common divisor (GCD) of the elements in `A` and prints the result. The function does not return any value; instead, it outputs the GCD directly to the console. After the function concludes, the state of the program includes the original integer `N`, a sorted list `A` of integers (each between 1 and \(10^9\)), and the GCD of the elements in `A` printed to the console. Note that the function assumes valid input and does not handle invalid input cases (e.g., non-integer values or incorrect input formats).

Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
