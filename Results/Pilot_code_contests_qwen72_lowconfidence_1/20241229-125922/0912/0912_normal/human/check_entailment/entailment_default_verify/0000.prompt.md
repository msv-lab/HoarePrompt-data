
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.

We assume that Bajtek can only heap up snow drifts at integer coordinates.

Input

The first line of input contains a single integer n (1 ≤ n ≤ 100) — the number of snow drifts. Each of the following n lines contains two integers xi and yi (1 ≤ xi, yi ≤ 1000) — the coordinates of the i-th snow drift.

Note that the north direction coinсides with the direction of Oy axis, so the east direction coinсides with the direction of the Ox axis. All snow drift's locations are distinct.

Output

Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.

Examples

Input

2
2 1
1 2


Output

1


Input

2
2 1
4 1


Output

0
Program:
```
from __future__ import division, print_function
import threading
import sys
from math import floor, ceil, sqrt
import os, sys
from io import IOBase, BytesIO
#Function 1:
def func_1():
    return map(int, sys.stdin.readline().strip().split())

#Function 2:
def func_2():
    return list(map(int, sys.stdin.readline().strip().split()))

#Function 3:
def func_3():
    return sys.stdin.readline().strip()

#Function 4:
def func_4():

    n = int(func_3())
    lst = []
    count_of_components = 0
    mydict_x = {i: [] for i in range(1, 1001)}
    mydict_y = {i: [] for i in range(1, 1001)}
    for i in range(n):
        (x, y) = func_1()
        lst.append((x, y))
        mydict_x[x].append(y)
        mydict_y[y].append(x)
    visited = set()
    for i in lst:
        if i not in visited:
            dfs(i)
            count_of_components += 1
    print(count_of_components - 1)

#Function 5:
def dfs(i):
    if i not in visited:
        visited.add(i)
        for child in mydict_x[i[0]]:
            if (i[0], child) not in visited:
                dfs((i[0], child))
        for child in mydict_y[i[1]]:
            if (child, i[1]) not in visited:
                dfs((child, i[1]))


```
Original Assessment: Correctness: **True**.

Explanation:
The provided program appears to correctly solve the problem of determining the minimum number of additional snow drifts needed so that Bajtek can travel between any two existing snow drifts. Here's a breakdown of why the program is considered correct:

1. **Data Structures**: The program uses dictionaries (`mydict_x` and `mydict_y`) to store the y-coordinates and x-coordinates of the snow drifts respectively. This allows efficient lookup of connected components in the grid.

2. **DFS for Connected Components**: The program uses a depth-first search (DFS) to explore the connected components of the grid. The `dfs` function ensures that all snow drifts connected horizontally or vertically are visited and marked as part of the same component.

3. **Counting Components**: The program counts the number of connected components. Since Bajtek can only move horizontally or vertically, each connected component represents a group of snow drifts that can be reached from each other without needing additional snow drifts.

4. **Result Calculation**: The program prints `count_of_components - 1`, which is the minimum number of additional snow drifts needed to connect all components. This is because adding one snow drift can connect two components, and thus, `n - 1` additional snow drifts are needed to connect `n` components.

The program handles all edge cases and inputs within the given constraints (1 ≤ n ≤ 100, 1 ≤ xi, yi ≤ 1000). It correctly identifies and counts the connected components and calculates the minimum number of additional snow drifts required. Therefore, the program is correct for all potential cases.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: Output hints for function number 5 : The `dfs` function performs a depth-first search (DFS) starting from the given snow drift coordinates `i`. It marks the current snow drift as visited by adding `i` to the `visited` set. Then, it recursively explores all connected snow drifts that share the same x-coordinate and y-coordinate, marking them as visited if they haven't been visited yet. The function modifies the `visited` set to include all reachable snow drifts from the starting point `i`. If `i` is already in `visited`, the function does nothing. The dictionaries `mydict_x` and `mydict_y` are used to efficiently find connected snow drifts. The final state of the program after the function concludes is that `visited` contains all the snow drifts that are reachable from the starting point `i`, and `i` itself is marked as visited.+


Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
