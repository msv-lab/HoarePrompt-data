
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

I am giving you some examples to understand the task better. Then I am giving you your task.
# Example 1

Problem description: Write a python function to identify non-prime numbers.
Program:
```
def is_not_prime(n):
    if n < 2:
        return True
    for i in range(2, n):
        if n % i == 0:
            return True
    return False
```
Example Answer 1:
Correctness: **True**.

# Example 2

Problem description: Write a python function to count all the substrings starting and ending with same characters.
Program:
```
def count_Substring_With_Equal_Ends(s):
    count = 0
    for i in range(len(s)-1):
        for j in range(i,len(s)-1):
            if s[i] == s[j+1]:
                count += 1
    return count
```

Example Answer 2:
Correctness: **False**.

# Example 3

Problem description: Write a function to perform binary search of a number in an list
Program:
```
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid
        else:
            right = mid - 1
    if arr[left] == target:
        return left
    return -1
```
Example answer 3:
Correctness: **False**.

# Your task:
Problem description: Ryouko is an extremely forgetful girl, she could even forget something that has just happened. So in order to remember, she takes a notebook with her, called Ryouko's Memory Note. She writes what she sees and what she hears on the notebook, and the notebook became her memory.

Though Ryouko is forgetful, she is also born with superb analyzing abilities. However, analyzing depends greatly on gathered information, in other words, memory. So she has to shuffle through her notebook whenever she needs to analyze, which is tough work.

Ryouko's notebook consists of n pages, numbered from 1 to n. To make life (and this problem) easier, we consider that to turn from page x to page y, |x - y| pages should be turned. During analyzing, Ryouko needs m pieces of information, the i-th piece of information is on page ai. Information must be read from the notebook in order, so the total number of pages that Ryouko needs to turn is <image>.

Ryouko wants to decrease the number of pages that need to be turned. In order to achieve this, she can merge two pages of her notebook. If Ryouko merges page x to page y, she would copy all the information on page x to y (1 ≤ x, y ≤ n), and consequently, all elements in sequence a that was x would become y. Note that x can be equal to y, in which case no changes take place.

Please tell Ryouko the minimum number of pages that she needs to turn. Note she can apply the described operation at most once before the reading. Note that the answer can exceed 32-bit integers.

Input

The first line of input contains two integers n and m (1 ≤ n, m ≤ 105).

The next line contains m integers separated by spaces: a1, a2, ..., am (1 ≤ ai ≤ n).

Output

Print a single integer — the minimum number of pages Ryouko needs to turn.

Examples

Input

4 6
1 2 3 4 3 2


Output

3


Input

10 5
9 4 3 8 8


Output

6

Note

In the first sample, the optimal solution is to merge page 4 to 3, after merging sequence a becomes {1, 2, 3, 3, 3, 2}, so the number of pages Ryouko needs to turn is |1 - 2| + |2 - 3| + |3 - 3| + |3 - 3| + |3 - 2| = 3.

In the second sample, optimal solution is achieved by merging page 9 to 4.
Program:
```
from __future__ import division, print_function
from fractions import Fraction
import sys
import os
from io import BytesIO, IOBase
from itertools import *
import bisect
from heapq import *
from math import ceil, floor
from copy import *
from collections import deque, defaultdict
from collections import Counter as counter
from itertools import combinations
from itertools import permutations as permutate
from bisect import bisect_left as bl
from operator import *
from bisect import bisect_right as br
from bisect import bisect
from sys import stderr
from types import GeneratorType
from functools import reduce
from collections import defaultdict
#Function 1:
def func_1(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()

#Function 2:
def func_2(f, stack=[]):

    return wrapped_func

#Function 3:
def wrapped_func(*args, **kwargs):
    if stack:
        return f(*args, **kwargs)
    to = f(*args, **kwargs)
    while True:
        if type(to) is GeneratorType:
            stack.append(to)
            to = next(to)
            continue
        stack.pop()
        if not stack:
            break
        to = stack[-1].send(to)
    return to

#Function 4:
def func_3(t):
    for p in range(t):
        func_29()

#Function 5:
def func_4(x, y, p):
    res = 1
    x = x % p
    if x == 0:
        return 0
    while y > 0:
        if y & 1 == 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p
    return res

#Function 6:
def func_5(n):
    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))

#Function 7:
def func_6(a, b):
    if a == b:
        return a
    while b > 0:
        (a, b) = (b, a % b)
    return a

#Function 8:
def func_7(ar):
    return list(accumulate(ar))

#Function 9:
def func_8(ar):
    return list(accumulate(ar[::-1]))[::-1]

#Function 10:
def func_9():
    return int(func_17())

#Function 11:
def func_10():
    func_1('YES')

#Function 12:
def func_11():
    func_1('NO')

#Function 13:
def func_12():
    func_1('Yes')

#Function 14:
def func_13():
    func_1('No')

#Function 15:
def func_14(i):
    i = i - (i >> 1 & 1431655765)
    i = (i & 858993459) + (i >> 2 & 858993459)
    return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24

#Function 16:
def func_15(a, b):
    return abs(a // func_6(a, b) * b)

#Function 17:
def func_16(n, r):
    if n < r:
        return 0
    else:
        return fac[n] * (finv[r] * finv[n - r] % mod) % mod

#Function 18:
def func_17():
    return sys.stdin.readline().rstrip('\r\n')

#Function 19:
def func_18(var):
    sys.stdout.write(str(var))

#Function 20:
def func_19():
    return list(map(int, func_17().split()))

#Function 21:
def func_20():
    return list(map(str, func_17().split()))

#Function 22:
def func_21():
    return map(int, func_17().split())

#Function 23:
def func_22():
    return map(str, func_17().split())

#Function 24:
def func_23():
    return map(float, func_17().split())

#Function 25:
def func_24():
    func_18('\n')

#Function 26:
def func_25(n, v):
    return [v] * n

#Function 27:
def func_26(n, m, v):
    return [[v] * m for _ in range(n)]

#Function 28:
def func_27(n, m, p, v):
    return [[[v] * p for _ in range(m)] for i in range(n)]

#Function 29:
def func_28(a, b):
    return (a + b - 1) // b

#Function 30:
def func_29():
    (n, m) = func_21()
    ar = func_19()
    adj = [[] for _ in range(n + 1)]
    for i in range(m):
        if i - 1 >= 0:
            if ar[i] != ar[i - 1]:
                adj[ar[i]].append(ar[i - 1])
        if i + 1 < m:
            if ar[i] != ar[i + 1]:
                adj[ar[i]].append(ar[i + 1])
    totscore = 0
    for i in range(1, m):
        totscore += abs(ar[i] - ar[i - 1])
    redscore = 0
    for i in range(1, n + 1):
        adj[i].sort()
        curscore = 0
        l = len(adj[i])
        if l == 0:
            continue
        med = adj[i][l // 2]
        besscore = 0
        for j in adj[i]:
            curscore += abs(i - j)
            besscore += abs(med - j)
        redscore = max(redscore, curscore - besscore)
    func_1(min(totscore - redscore, totscore))


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
