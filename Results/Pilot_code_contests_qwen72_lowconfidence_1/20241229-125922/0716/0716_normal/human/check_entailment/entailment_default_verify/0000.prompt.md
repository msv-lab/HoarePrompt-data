
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Ryouko is an extremely forgetful girl, she could even forget something that has just happened. So in order to remember, she takes a notebook with her, called Ryouko's Memory Note. She writes what she sees and what she hears on the notebook, and the notebook became her memory.

Though Ryouko is forgetful, she is also born with superb analyzing abilities. However, analyzing depends greatly on gathered information, in other words, memory. So she has to shuffle through her notebook whenever she needs to analyze, which is tough work.

Ryouko's notebook consists of n pages, numbered from 1 to n. To make life (and this problem) easier, we consider that to turn from page x to page y, |x - y| pages should be turned. During analyzing, Ryouko needs m pieces of information, the i-th piece of information is on page ai. Information must be read from the notebook in order, so the total number of pages that Ryouko needs to turn is <image>.

Ryouko wants to decrease the number of pages that need to be turned. In order to achieve this, she can merge two pages of her notebook. If Ryouko merges page x to page y, she would copy all the information on page x to y (1 ≤ x, y ≤ n), and consequently, all elements in sequence a that was x would become y. Note that x can be equal to y, in which case no changes take place.

Please tell Ryouko the minimum number of pages that she needs to turn. Note she can apply the described operation at most once before the reading. Note that the answer can exceed 32-bit integers.

Input

The first line of input contains two integers n and m (1 ≤ n, m ≤ 105).

The next line contains m integers separated by spaces: a1, a2, ..., am (1 ≤ ai ≤ n).

Output

Print a single integer — the minimum number of pages Ryouko needs to turn.

Examples

Input

4 6
1 2 3 4 3 2


Output

3


Input

10 5
9 4 3 8 8


Output

6

Note

In the first sample, the optimal solution is to merge page 4 to 3, after merging sequence a becomes {1, 2, 3, 3, 3, 2}, so the number of pages Ryouko needs to turn is |1 - 2| + |2 - 3| + |3 - 3| + |3 - 3| + |3 - 2| = 3.

In the second sample, optimal solution is achieved by merging page 9 to 4.
Program:
```
from __future__ import division, print_function
from fractions import Fraction
import sys
import os
from io import BytesIO, IOBase
from itertools import *
import bisect
from heapq import *
from math import ceil, floor
from copy import *
from collections import deque, defaultdict
from collections import Counter as counter
from itertools import combinations
from itertools import permutations as permutate
from bisect import bisect_left as bl
from operator import *
from bisect import bisect_right as br
from bisect import bisect
from sys import stderr
from types import GeneratorType
from functools import reduce
from collections import defaultdict
#Function 1:
def func_1(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()

#Function 2:
def func_2(f, stack=[]):

    return wrapped_func

#Function 3:
def wrapped_func(*args, **kwargs):
    if stack:
        return f(*args, **kwargs)
    to = f(*args, **kwargs)
    while True:
        if type(to) is GeneratorType:
            stack.append(to)
            to = next(to)
            continue
        stack.pop()
        if not stack:
            break
        to = stack[-1].send(to)
    return to

#Function 4:
def func_3(t):
    for p in range(t):
        func_29()

#Function 5:
def func_4(x, y, p):
    res = 1
    x = x % p
    if x == 0:
        return 0
    while y > 0:
        if y & 1 == 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p
    return res

#Function 6:
def func_5(n):
    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))

#Function 7:
def func_6(a, b):
    if a == b:
        return a
    while b > 0:
        (a, b) = (b, a % b)
    return a

#Function 8:
def func_7(ar):
    return list(accumulate(ar))

#Function 9:
def func_8(ar):
    return list(accumulate(ar[::-1]))[::-1]

#Function 10:
def func_9():
    return int(func_17())

#Function 11:
def func_10():
    func_1('YES')

#Function 12:
def func_11():
    func_1('NO')

#Function 13:
def func_12():
    func_1('Yes')

#Function 14:
def func_13():
    func_1('No')

#Function 15:
def func_14(i):
    i = i - (i >> 1 & 1431655765)
    i = (i & 858993459) + (i >> 2 & 858993459)
    return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24

#Function 16:
def func_15(a, b):
    return abs(a // func_6(a, b) * b)

#Function 17:
def func_16(n, r):
    if n < r:
        return 0
    else:
        return fac[n] * (finv[r] * finv[n - r] % mod) % mod

#Function 18:
def func_17():
    return sys.stdin.readline().rstrip('\r\n')

#Function 19:
def func_18(var):
    sys.stdout.write(str(var))

#Function 20:
def func_19():
    return list(map(int, func_17().split()))

#Function 21:
def func_20():
    return list(map(str, func_17().split()))

#Function 22:
def func_21():
    return map(int, func_17().split())

#Function 23:
def func_22():
    return map(str, func_17().split())

#Function 24:
def func_23():
    return map(float, func_17().split())

#Function 25:
def func_24():
    func_18('\n')

#Function 26:
def func_25(n, v):
    return [v] * n

#Function 27:
def func_26(n, m, v):
    return [[v] * m for _ in range(n)]

#Function 28:
def func_27(n, m, p, v):
    return [[[v] * p for _ in range(m)] for i in range(n)]

#Function 29:
def func_28(a, b):
    return (a + b - 1) // b

#Function 30:
def func_29():
    (n, m) = func_21()
    ar = func_19()
    adj = [[] for _ in range(n + 1)]
    for i in range(m):
        if i - 1 >= 0:
            if ar[i] != ar[i - 1]:
                adj[ar[i]].append(ar[i - 1])
        if i + 1 < m:
            if ar[i] != ar[i + 1]:
                adj[ar[i]].append(ar[i + 1])
    totscore = 0
    for i in range(1, m):
        totscore += abs(ar[i] - ar[i - 1])
    redscore = 0
    for i in range(1, n + 1):
        adj[i].sort()
        curscore = 0
        l = len(adj[i])
        if l == 0:
            continue
        med = adj[i][l // 2]
        besscore = 0
        for j in adj[i]:
            curscore += abs(i - j)
            besscore += abs(med - j)
        redscore = max(redscore, curscore - besscore)
    func_1(min(totscore - redscore, totscore))


```
Original Assessment: Correctness: **True**.

Explanation:
The provided program appears to correctly implement the logic required to solve the problem as described. The program reads the input, constructs an adjacency list representing the transitions between pages, calculates the initial total score (the sum of absolute differences between consecutive pages), and then tries to optimize this score by merging pages. It does this by calculating the reduction in the total score that can be achieved by merging each page with its adjacent pages and selecting the maximum possible reduction. Finally, it prints the minimum number of pages that Ryouko needs to turn.

The logic for merging pages and calculating the potential reduction in the total score is sound. The program handles edge cases, such as when the number of pages or the number of pieces of information is small, and it correctly updates the adjacency list and calculates the scores. Given the constraints and the problem requirements, the program seems to cover all necessary cases and operates correctly for all inputs I can think of.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: Output hints for function number 30 : The function `func_29` processes a list `ar` of `m` integers, where each integer is between 1 and `n` (inclusive), and `n` and `m` are positive integers such that 1 ≤ n, m ≤ 105. The function constructs an adjacency list `adj` where `adj[i]` contains the indices of elements in `ar` that are adjacent to `i` and are not equal to `i`. It then calculates two scores: `totscore`, which is the sum of the absolute differences between consecutive elements in `ar`, and `redscore`, which is the maximum reduction in score achievable by replacing each element `i` in `ar` with the median of its adjacent elements in `adj[i]`. Finally, the function calls `func_1` with the minimum of `totscore` and `totscore - redscore`. The function does not return a value directly but affects the state by calling `func_1` with the computed result.+


Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
