
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Ryouko is an extremely forgetful girl, she could even forget something that has just happened. So in order to remember, she takes a notebook with her, called Ryouko's Memory Note. She writes what she sees and what she hears on the notebook, and the notebook became her memory.

Though Ryouko is forgetful, she is also born with superb analyzing abilities. However, analyzing depends greatly on gathered information, in other words, memory. So she has to shuffle through her notebook whenever she needs to analyze, which is tough work.

Ryouko's notebook consists of n pages, numbered from 1 to n. To make life (and this problem) easier, we consider that to turn from page x to page y, |x - y| pages should be turned. During analyzing, Ryouko needs m pieces of information, the i-th piece of information is on page ai. Information must be read from the notebook in order, so the total number of pages that Ryouko needs to turn is <image>.

Ryouko wants to decrease the number of pages that need to be turned. In order to achieve this, she can merge two pages of her notebook. If Ryouko merges page x to page y, she would copy all the information on page x to y (1 ≤ x, y ≤ n), and consequently, all elements in sequence a that was x would become y. Note that x can be equal to y, in which case no changes take place.

Please tell Ryouko the minimum number of pages that she needs to turn. Note she can apply the described operation at most once before the reading. Note that the answer can exceed 32-bit integers.

Input

The first line of input contains two integers n and m (1 ≤ n, m ≤ 105).

The next line contains m integers separated by spaces: a1, a2, ..., am (1 ≤ ai ≤ n).

Output

Print a single integer — the minimum number of pages Ryouko needs to turn.

Examples

Input

4 6
1 2 3 4 3 2


Output

3


Input

10 5
9 4 3 8 8


Output

6

Note

In the first sample, the optimal solution is to merge page 4 to 3, after merging sequence a becomes {1, 2, 3, 3, 3, 2}, so the number of pages Ryouko needs to turn is |1 - 2| + |2 - 3| + |3 - 3| + |3 - 3| + |3 - 2| = 3.

In the second sample, optimal solution is achieved by merging page 9 to 4.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
from fractions import Fraction
import sys
import os
from io import BytesIO, IOBase
from itertools import *
import bisect
from heapq import *
from math import ceil, floor
from copy import *
from collections import deque, defaultdict
from collections import Counter as counter
from itertools import combinations
from itertools import permutations as permutate
from bisect import bisect_left as bl
from operator import *
from bisect import bisect_right as br
from bisect import bisect
from sys import stderr
from types import GeneratorType
from functools import reduce
from collections import defaultdict

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
class SortedList:

    def __init__(self, iterable=[], _load=200):
        """Initialize sorted list instance."""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):
        """Build a fenwick tree instance."""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):
        """Update `fen_tree[index] += value`."""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):
        """Return `sum(_fen_tree[:end])`."""
        if self._rebuild:
            self._fen_build()
        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):
        """Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`)."""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return (0, k)
        if k >= self._len - _list_lens[-1]:
            return (len(_list_lens) - 1, k + _list_lens[-1] - self._len)
        if self._rebuild:
            self._fen_build()
        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return (idx + 1, k)

    def _delete(self, pos, idx):
        """Delete value at the given `(pos, idx)`."""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1
        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):
        """Return an index pair that corresponds to the first position of `value` in the sorted list."""
        if not self._len:
            return (0, 0)
        _lists = self._lists
        _mins = self._mins
        (lo, pos) = (-1, len(_lists) - 1)
        while lo + 1 < pos:
            mi = lo + pos >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi
        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1
        _list = _lists[pos]
        (lo, idx) = (-1, len(_list))
        while lo + 1 < idx:
            mi = lo + idx >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi
        return (pos, idx)

    def _loc_right(self, value):
        """Return an index pair that corresponds to the last position of `value` in the sorted list."""
        if not self._len:
            return (0, 0)
        _lists = self._lists
        _mins = self._mins
        (pos, hi) = (0, len(_lists))
        while pos + 1 < hi:
            mi = pos + hi >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi
        _list = _lists[pos]
        (lo, idx) = (-1, len(_list))
        while lo + 1 < idx:
            mi = lo + idx >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi
        return (pos, idx)

    def add(self, value):
        """Add `value` to sorted list."""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
        self._len += 1
        if _lists:
            (pos, idx) = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):
        """Remove `value` from sorted list if it is a member."""
        _lists = self._lists
        if _lists:
            (pos, idx) = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):
        """Remove `value` from sorted list; `value` must be a member."""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):
        """Remove and return value at `index` in sorted list."""
        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):
        """Return the first index to insert `value` in the sorted list."""
        (pos, idx) = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):
        """Return the last index to insert `value` in the sorted list."""
        (pos, idx) = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):
        """Return number of occurrences of `value` in the sorted list."""
        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):
        """Return the size of the sorted list."""
        return self._len

    def __getitem__(self, index):
        """Lookup value at `index` in sorted list."""
        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):
        """Remove value at `index` from sorted list."""
        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):
        """Return true if `value` is an element of the sorted list."""
        _lists = self._lists
        if _lists:
            (pos, idx) = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):
        """Return an iterator over the sorted list."""
        return (value for _list in self._lists for value in _list)

    def __reversed__(self):
        """Return a reverse iterator over the sorted list."""
        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):
        """Return string representation of sorted list."""
        return 'SortedList({0})'.format(list(self))
mod = 1000000007
dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]
class MergeFind:

    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n
        self.num_sets = n

    def find(self, a):
        to_update = []
        while a != self.parent[a]:
            to_update.append(a)
            a = self.parent[a]
        for b in to_update:
            self.parent[b] = a
        return self.parent[a]

    def merge(self, a, b):
        a = self.find(a)
        b = self.find(b)
        if a == b:
            return
        if self.size[a] < self.size[b]:
            (a, b) = (b, a)
        self.num_sets -= 1
        self.parent[b] = a
        self.size[a] += self.size[b]

    def set_size(self, a):
        return self.size[self.find(a)]

    def __len__(self):
        return self.num_sets
func_29()

#Function 1:
#State of the program right berfore the function call: args is a tuple containing any number of items to be printed, and kwargs is a dictionary that may contain the keys 'sep', 'file', 'end', and 'flush' with corresponding values. 'sep' is a string used to separate the items to be printed, 'file' is the stream to which the items will be written (default is sys.stdout), 'end' is the string appended after the last item, and 'flush' is a boolean indicating whether to forcibly flush the stream.
def func_1():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a tuple containing any number of items to be printed, `kwargs` is a dictionary that may contain the keys 'end' and 'flush' with corresponding values, `sep` is the value associated with 'sep' from `kwargs` or `' '` if 'sep' was not in `kwargs`, `file` contains the concatenated string representations of all items in `args`, separated by `sep`, `at_start` is `False` if `args` is not empty, otherwise `at_start` is `True`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a tuple containing any number of items to be printed, `kwargs` is a dictionary that may contain the key 'flush' with the value `True` (and 'sep' with its corresponding value, if present), `sep` is the value associated with 'sep' from `kwargs` or `' '` if 'sep' was not in `kwargs`, `file` contains the concatenated string representations of all items in `args`, separated by `sep`, followed by the value of `'end'` from `kwargs` or `'\n'` if `'end'` was not in `kwargs`, `at_start` is `False` if `args` is not empty, otherwise `at_start` is `True`. If `kwargs` contained the key 'flush' with the value `True`, the buffer of `file` has been flushed.

#Function 2:
#State of the program right berfore the function call: f is a function, and stack is an optional parameter initialized as an empty list.
def func_2(f, stack):
    return wrapped_func
    #The program returns `wrapped_func`, which is a reference to the function `f` possibly modified or wrapped with additional functionality, and `stack` remains an empty list.

#Function 3:
#State of the program right berfore the function call: This function signature does not provide specific variables related to the problem context. The function `wrapped_func` is a generic wrapper that accepts any arguments and keyword arguments, and it uses a stack to handle generator-based operations. It is not directly related to the problem of minimizing page turns in Ryouko's notebook.
def wrapped_func():
    if stack :
        return f(*args, **kwargs)
        #The program returns the result of calling the function `f` with the arguments `*args` and keyword arguments `
    #State of the program after the if block has been executed: The function `wrapped_func` is a generic wrapper that accepts any arguments and keyword arguments, and it uses a stack to handle generator-based operations. The stack is empty.
    to = f(*args, **kwargs)
    while True:
        if type(to) is GeneratorType:
            stack.append(to)
            to = next(to)
            continue
        
        stack.pop()
        
        if not stack:
            break
        
        to = stack[-1].send(to)
        
    #State of the program after the loop has been executed: The stack is empty, and `to` holds the final return value from the last generator or function call that was part of the wrapped operation. The original value of `to` was the return value of `f(*args,
    return to
    #The program returns the final return value from the last generator or function call that was part of the wrapped operation, originally the return value of `f(*args)`

#Function 4:
#State of the program right berfore the function call: t is a non-negative integer.
def func_3(t):
    for p in range(t):
        func_29()
        
    #State of the program after the  for loop has been executed: `t` is a non-negative integer, `p` is `t-1` if `t` > 0, otherwise `p` is undefined.

#Function 5:
#State of the program right berfore the function call: x and y are non-negative integers, and p is a positive integer.
def func_4(x, y, p):
    res = 1
    x = x % p
    if (x == 0) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: *`x` is a non-negative integer less than `p`, `y` is a non-negative integer, `p` is a positive integer, `res` is 1, and `x` is not equal to 0
    while y > 0:
        if y & 1 == 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `x` is a non-negative integer less than `p`, `res` is `x` raised to the power of the original value of `y` modulo `p`.
    return res
    #The program returns the value of `res` which is `x` (a non-negative integer less than `p`) raised to the power of the original value of `y` (which is 0) modulo `p`. Since any number raised to the power of 0 is 1, `res` is 1.

#Function 6:
#State of the program right berfore the function call: n is a positive integer.
def func_5(n):
    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5
    ) + 1) if n % i == 0)))
    #The program returns a set containing all the divisors of `n`, including 1 and `n` itself, where `n` is a positive integer.

#Function 7:
#State of the program right berfore the function call: a and b are non-negative integers.
def func_6(a, b):
    if (a == b) :
        return a
        #The program returns a, which is a non-negative integer and currently equal to b.
    #State of the program after the if block has been executed: a and b are non-negative integers, and a is not equal to b
    while b > 0:
        a, b = b, a % b
        
    #State of the program after the loop has been executed: To determine the final output state of the loop, we need to analyze the behavior of the loop and the changes in the variables `a` and `b` over multiple iterations.
    #
    #### Initial State:
    #- `a` and `b` are non-negative integers.
    #- `a` is not equal to `b`.
    #
    #### Loop Code:
    #```python
    #while b > 0:
    #    a, b = b, a % b
    #```
    #
    #### Step-by-Step Analysis:
    #
    #1. **First Iteration:**
    #   - Before the loop: `a` is `a0`, `b` is `b0`.
    #   - After the loop: `a` is `b0`, `b` is `a0 % b0`.
    #   - Conditions: `b0 > 0`.
    #
    #2. **Second Iteration:**
    #   - Before the loop: `a` is `b0`, `b` is `a0 % b0`.
    #   - After the loop: `a` is `a0 % b0`, `b` is `b0 % (a0 % b0)`.
    #   - Conditions: `a0 % b0 > 0`.
    #
    #3. **Third Iteration:**
    #   - Before the loop: `a` is `a0 % b0`, `b` is `b0 % (a0 % b0)`.
    #   - After the loop: `a` is `b0 % (a0 % b0)`, `b` is `(a0 % b0) % (b0 % (a0 % b0))`.
    #   - Conditions: `b0 % (a0 % b0) > 0`.
    #
    #### General Pattern:
    #- Each iteration reduces `b` to a smaller non-negative integer.
    #- The loop continues until `b` becomes `0`.
    #- When `b` becomes `0`, the loop terminates, and `a` holds the value of the greatest common divisor (GCD) of the original `a` and `b`.
    #
    #### Final Output State:
    #- The loop will terminate when `b` becomes `0`.
    #- At this point, `a` will hold the GCD of the original values of `a` and `b`.
    #
    #Therefore, the output state is:
    #**`a` is the GCD of the original values of `a` and `b`, `b` is `0`.**
    return a
    #The program returns the GCD of the original values of `a` and `b`.

#Function 8:
#State of the program right berfore the function call: ar is a list of integers.
def func_7(ar):
    return list(accumulate(ar))
    #The program returns a list where each element is the cumulative sum of the elements from the original list 'ar' up to that position.

#Function 9:
#State of the program right berfore the function call: ar is a list of integers.
def func_8(ar):
    return list(accumulate(ar[::-1]))[::-1]
    #The program returns a list where each element is the cumulative sum of the elements from the original list `ar`, starting from the last element and moving towards the first. The cumulative sums are then reversed to match the original order of `ar`.

#Function 10:
#State of the program right berfore the function call: This function does not have any parameters.
def func_9():
    return int(func_17())
    #The program returns an integer value produced by the function `func_17()`. The specific value depends on the implementation of `func_17()`.

#Function 11:
#State of the program right berfore the function call: n and m are positive integers where 1 ≤ n, m ≤ 105, and a is a list of m integers such that 1 ≤ ai ≤ n.
def func_10():
    func_1('YES')

#Function 12:
#State of the program right berfore the function call: This function does not have any parameters.
def func_11():
    func_1('NO')

#Function 13:
#State of the program right berfore the function call: The provided function `func_12` does not contain any parameters or use any variables related to the problem statement. It simply calls another function `func_1` with the string 'Yes' as an argument. Since there are no variables in the function signature related to the problem, it is not possible to derive a precondition based on the function signature alone.

However, if you need a precondition based on the problem description and typical requirements for solving the problem, here is a general precondition that could be associated with a function designed to solve this problem:

**n and m are positive integers where 1 ≤ n, m ≤ 105, and a is a list of m integers where each element ai satisfies 1 ≤ ai ≤ n.**

This precondition reflects the constraints given in the problem description and would typically apply to a function that processes the input for this problem. However, it does not directly relate to the provided `func_12` function.
def func_12():
    func_1('Yes')

#Function 14:
#State of the program right berfore the function call: n and m are positive integers (1 ≤ n, m ≤ 105), and a is a list of m integers where each element ai satisfies 1 ≤ ai ≤ n.
def func_13():
    func_1('No')

#Function 15:
#State of the program right berfore the function call: i is an integer.
def func_14(i):
    i = i - (i >> 1 & 1431655765)
    i = (i & 858993459) + (i >> 2 & 858993459)
    return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24
    #The program returns the result of `((i_new + (i_new >> 4) & 252645135) * 16843009 & 4294967295) >> 24`, where `i_new` is the value of `i` after being updated to `(i & 858993459) + (i >> 2 & 858993459)`.

#Function 16:
#State of the program right berfore the function call: a and b are integers such that b ≠ 0.
def func_15(a, b):
    return abs(a // func_6(a, b) * b)
    #The program returns the absolute value of the result of `a // func_6(a, b) * b`, where `func_6(a, b)` is an unknown function that returns an integer.

#Function 17:
#State of the program right berfore the function call: n and r are non-negative integers such that 0 <= r <= n.
def func_16(n, r):
    if (n < r) :
        return 0
        #The program returns 0
    else :
        return fac[n] * (finv[r] * finv[n - r] % mod) % mod
        #The program returns the value of `fac[n] * (finv[r] * finv[n - r] % mod) % mod`, where `fac` is a list containing factorials, `finv` is a list containing modular inverses of factorials, and `mod` is a constant used for modular arithmetic. The variables `n` and `r` are non-negative integers with `0 <= r <= n`.

#Function 18:
#State of the program right berfore the function call: None. This function does not take any parameters and reads input from stdin, which is not directly related to the variables in the function signature.
def func_17():
    return sys.stdin.readline().rstrip('\r\n')
    #The program returns a string read from the standard input (stdin), with the newline character(s) removed.

#Function 19:
#State of the program right berfore the function call: var is a value of any type that can be converted to a string.
def func_18(var):
    sys.stdout.write(str(var))

#Function 20:
#State of the program right berfore the function call: None of the variables in the function signature are used; the function calls another function `func_17` and processes its output.
def func_19():
    return list(map(int, func_17().split()))
    #The program returns a list of integers obtained from splitting the string returned by `func_17()` and converting each element to an integer.

#Function 21:
#State of the program right berfore the function call: This function does not have any parameters, and it relies on the output of `func_17()`. It assumes that `func_17()` returns a string that can be split into a list of strings.
def func_20():
    return list(map(str, func_17().split()))
    #The program returns a list of strings obtained by splitting the string returned by `func_17()`

#Function 22:
#State of the program right berfore the function call: None of the variables in the function signature are used; the function `func_21` calls another function `func_17` and processes its output.
def func_21():
    return map(int, func_17().split())
    #The program returns a map object that converts each element from the string returned by `func_17()` into an integer. The string from `func_17()` is split by whitespace.

#Function 23:
#State of the program right berfore the function call: This function does not have any parameters.
def func_22():
    return map(str, func_17().split())
    #The program returns a map object that applies the `str` function to each element resulting from splitting the string returned by `func_17()` by spaces.

#Function 24:
#State of the program right berfore the function call: This function does not have any parameters. It relies on the output of `func_17()` which is expected to return a string that can be split and converted into a list of floats.
def func_23():
    return map(float, func_17().split())
    #The program returns a map object that converts each element from the string returned by `func_17()`, after splitting it, into a float. The exact values depend on the output of `func_17()`.

#Function 25:
#State of the program right berfore the function call: None of the variables used in the function signature are relevant to the problem's context or the function's operation.
def func_24():
    func_18('\n')

#Function 26:
#State of the program right berfore the function call: n is a non-negative integer, and v is a value of any type.
def func_25(n, v):
    return [v] * n
    #The program returns a list containing `n` repetitions of `v`, where `n` is a non-negative integer and `v` is a value of any type.

#Function 27:
#State of the program right berfore the function call: n and m are positive integers, and v is a value of any type.
def func_26(n, m, v):
    return [([v] * m) for _ in range(n)]
    #The program returns a list containing `n` sublists, each of which is a list of length `m` filled with the value `v`.

#Function 28:
#State of the program right berfore the function call: n, m, and p are non-negative integers, v is a value of any type.
def func_27(n, m, p, v):
    return [[([v] * p) for _ in range(m)] for i in range(n)]
    #The program returns a nested list structure with `n` layers of lists, where each layer contains `m` sublists, and each sublist contains `p` instances of the value `v`.

#Function 29:
#State of the program right berfore the function call: a and b are integers such that b > 0.
def func_28(a, b):
    return (a + b - 1) // b
    #The program returns the integer division result of (a + b - 1) by b, where a and b are integers and b > 0.

#Function 30:
#State of the program right berfore the function call: n and m are positive integers such that 1 ≤ n, m ≤ 105, and ar is a list of m integers where each element ai satisfies 1 ≤ ai ≤ n.
def func_29():
    n, m = func_21()
    ar = func_19()
    adj = [[] for _ in range(n + 1)]
    for i in range(m):
        if i - 1 >= 0:
            if ar[i] != ar[i - 1]:
                adj[ar[i]].append(ar[i - 1])
        
        if i + 1 < m:
            if ar[i] != ar[i + 1]:
                adj[ar[i]].append(ar[i + 1])
        
    #State of the program after the  for loop has been executed: `n` and `m` are positive integers such that 1 ≤ n, m ≤ 105, `ar` is a list of `m` integers where each element `ai` satisfies 1 ≤ ai ≤ n, `adj` is a list of `n + 1` lists where `adj[ai]` contains the indices of the elements in `ar` that are adjacent to `ai` and are not equal to `ai`.
    totscore = 0
    for i in range(1, m):
        totscore += abs(ar[i] - ar[i - 1])
        
    #State of the program after the  for loop has been executed: `n` and `m` are positive integers such that \(1 \leq n, m \leq 105\), `ar` is a list of `m` integers where each element \(a_i\) satisfies \(1 \leq a_i \leq n\), `adj` is a list of `n + 1` lists where `adj[a_i]` contains the indices of the elements in `ar` that are adjacent to \(a_i\) and are not equal to \(a_i\), `totscore` is the sum of the absolute differences between consecutive elements in `ar`.
    redscore = 0
    for i in range(1, n + 1):
        adj[i].sort()
        
        curscore = 0
        
        l = len(adj[i])
        
        if l == 0:
            continue
        
        med = adj[i][l // 2]
        
        besscore = 0
        
        for j in adj[i]:
            curscore += abs(i - j)
            besscore += abs(med - j)
        
        redscore = max(redscore, curscore - besscore)
        
    #State of the program after the  for loop has been executed: `n` is a positive integer such that \(1 \leq n \leq 105\), `m` is a positive integer such that \(1 \leq m \leq 105\), `ar` is a list of `m` integers where each element \(a_i\) satisfies \(1 \leq a_i \leq n\), `adj` is a list of `n + 1` lists where each sublist `adj[i]` for \(1 \leq i \leq n\) is sorted in ascending order, `totscore` is the sum of the absolute differences between consecutive elements in `ar`, `redscore` is the maximum value of `curscore - besscore` for all `i` from 1 to `n`.
    func_1(min(totscore - redscore, totscore))


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
