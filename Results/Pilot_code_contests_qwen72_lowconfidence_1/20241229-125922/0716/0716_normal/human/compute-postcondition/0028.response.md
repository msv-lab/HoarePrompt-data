To determine the final output state of the loop, let's analyze the loop step by step and consider the effects of all iterations.

### Initial State:
- `n` and `m` are positive integers such that 1 ≤ n, m ≤ 105.
- `ar` is a list of `m` integers where each element `ai` satisfies 1 ≤ ai ≤ n.
- `n` and `m` have been updated to the values returned by `func_21()`.
- `ar` is the list returned by `func_19()`.
- `adj` is a list of `n + 1` empty lists.

### Loop Code:
```python
for i in range(m):
    if i - 1 >= 0:
        if ar[i] != ar[i - 1]:
            adj[ar[i]].append(ar[i - 1])
    if i + 1 < m:
        if ar[i] != ar[i + 1]:
            adj[ar[i]].append(ar[i + 1])
```

### Analysis:
1. **Loop Execution**:
   - The loop iterates `m` times, where `m` is the length of the list `ar`.
   - For each iteration `i`:
     - If `i - 1 >= 0` (i.e., `i` is not the first element), and `ar[i] != ar[i - 1]`, then `ar[i - 1]` is appended to `adj[ar[i]]`.
     - If `i + 1 < m` (i.e., `i` is not the last element), and `ar[i] != ar[i + 1]`, then `ar[i + 1]` is appended to `adj[ar[i]]`.

2. **Effect on `adj`**:
   - After the loop completes, `adj` will contain the adjacency list representation of the graph formed by the elements of `ar`.
   - Specifically, `adj[ai]` will contain all the elements `aj` such that `aj` is adjacent to `ai` in the list `ar` and `ai != aj`.

3. **Final State**:
   - `n` and `m` remain as positive integers such that 1 ≤ n, m ≤ 105.
   - `ar` remains the list of `m` integers where each element `ai` satisfies 1 ≤ ai ≤ n.
   - `adj` is a list of `n + 1` lists, where each `adj[ai]` contains the indices of the elements in `ar` that are adjacent to `ai` and are not equal to `ai`.

### Output State:
Output State: **`n` and `m` are positive integers such that 1 ≤ n, m ≤ 105, `ar` is a list of `m` integers where each element `ai` satisfies 1 ≤ ai ≤ n, `adj` is a list of `n + 1` lists where `adj[ai]` contains the indices of the elements in `ar` that are adjacent to `ai` and are not equal to `ai`.**