The code `adj[ar[i]].append(ar[i - 1])` appends the value of `ar[i - 1]` to the list located at index `ar[i]` in the `adj` list.

Given the initial state:
- `n` and `m` are positive integers such that 1 ≤ n, m ≤ 105.
- `ar` is a list of `m` integers where each element `ai` satisfies 1 ≤ ai ≤ n.
- `n` and `m` have been updated to the values returned by `func_21()`.
- `ar` is the list returned by `func_19()`.
- `adj` is a list of `n + 1` lists.
- `i` is 2.
- `m` must be greater than 2.
- If `i + 1 < m` and `ar[i] != ar[i + 1]`, `adj[ar[2]]` will be modified in the next iteration.

Step-by-step impact:
1. `i` is 2.
2. `ar[i]` refers to `ar[2]`.
3. `ar[i - 1]` refers to `ar[1]`.
4. The code appends `ar[1]` to the list at index `ar[2]` in `adj`.

Since `i` is 2, the condition `i + 1 < m` (which is `3 < m`) is true, and the condition `ar[i] != ar[i + 1]` (which is `ar[2] != ar[3]`) is also assumed to be true for the modification to occur.

Therefore, the list at index `ar[2]` in `adj` will have `ar[1]` appended to it.

Output State: **`n` and `m` are positive integers such that 1 ≤ n, m ≤ 105, `ar` is a list of `m` integers where each element `ai` satisfies 1 ≤ ai ≤ n, `n` and `m` have been updated to the values returned by `func_21()`, `ar` is the list returned by `func_19()`, `adj` is a list of `n + 1` lists, `i` is 2, `m` must be greater than 2, `adj[ar[2]]` now includes `ar[1]`.**