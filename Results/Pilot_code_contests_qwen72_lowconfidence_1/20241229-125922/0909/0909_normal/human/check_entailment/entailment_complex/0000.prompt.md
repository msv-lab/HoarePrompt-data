
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: There are n warriors in a row. The power of the i-th warrior is a_i. All powers are pairwise distinct.

You have two types of spells which you may cast: 

  1. Fireball: you spend x mana and destroy exactly k consecutive warriors; 
  2. Berserk: you spend y mana, choose two consecutive warriors, and the warrior with greater power destroys the warrior with smaller power. 



For example, let the powers of warriors be [2, 3, 7, 8, 11, 5, 4], and k = 3. If you cast Berserk on warriors with powers 8 and 11, the resulting sequence of powers becomes [2, 3, 7, 11, 5, 4]. Then, for example, if you cast Fireball on consecutive warriors with powers [7, 11, 5], the resulting sequence of powers becomes [2, 3, 4].

You want to turn the current sequence of warriors powers a_1, a_2, ..., a_n into b_1, b_2, ..., b_m. Calculate the minimum amount of mana you need to spend on it.

Input

The first line contains two integers n and m (1 ≤ n, m ≤ 2 ⋅ 10^5) — the length of sequence a and the length of sequence b respectively.

The second line contains three integers x, k, y (1 ≤ x, y, ≤ 10^9; 1 ≤ k ≤ n) — the cost of fireball, the range of fireball and the cost of berserk respectively.

The third line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ n). It is guaranteed that all integers a_i are pairwise distinct.

The fourth line contains m integers b_1, b_2, ..., b_m (1 ≤ b_i ≤ n). It is guaranteed that all integers b_i are pairwise distinct.

Output

Print the minimum amount of mana for turning the sequnce a_1, a_2, ..., a_n into b_1, b_2, ..., b_m, or -1 if it is impossible.

Examples

Input


5 2
5 2 3
3 1 4 5 2
3 5


Output


8


Input


4 4
5 1 4
4 3 1 2
2 4 3 1


Output


-1


Input


4 4
2 1 11
1 3 2 4
1 3 2 4


Output


0
Annotated Functions:
from __future__ import division, print_function
import os, sys, itertools

_interactive = False
INF = float('inf')
MOD = 10 ** 9 + 7
if sys.version_info[0] < 3:
    input = raw_input
    range = xrange
    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip
if _interactive:
    flush = sys.stdout.flush

    def printf(*args, **kwargs):
        print(*args, **kwargs)
        flush()
LOCAL = 'LOCAL_' in os.environ
debug_print = print if LOCAL else lambda *x, **y: None
if not LOCAL and (not _interactive):
    from io import BytesIO
    from atexit import register
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
    sys.stdout = BytesIO()
    register(lambda : os.write(1, sys.stdout.getvalue()))
    input = lambda : sys.stdin.readline().rstrip('\r\n')
func_1()

#Function 1:
#State of the program right berfore the function call: n and m are positive integers representing the lengths of sequences a and b respectively, where 1 ≤ n, m ≤ 2 ⋅ 10^5. x, k, y are positive integers representing the cost of casting a fireball, the range of the fireball, and the cost of casting berserk respectively, with 1 ≤ x, y ≤ 10^9 and 1 ≤ k ≤ n. a is a list of n integers representing the powers of the warriors, where 1 ≤ a_i ≤ n and all a_i are pairwise distinct. b is a list of m integers representing the target sequence of powers, where 1 ≤ b_i ≤ n and all b_i are pairwise distinct.
def func_1():
    n, m = func_2()
    x, k, y = func_2()
    a = func_2()
    b = func_2()
    j = 0
    for (i, ax) in enumerate(a):
        if j < m and ax == b[j]:
            j += 1
        
    #State of the program after the  for loop has been executed: `n` and `m` are positive integers, `x`, `k`, `y` are positive integers returned by `func_2()`, `a` is a list of integers returned by `func_2()`, `b` is a list of `m` integers with all elements being pairwise distinct, 1 ≤ `b_i` ≤ `n`, `j` is the number of elements in `a` that match the corresponding elements in `b` up to the minimum of `len(a)` and `m`, `i` is `len(a) - 1`, `ax` is the last element of `a`. If `j < m` and `ax == b[j]`, then `j` is incremented by 1.
    if (j < m) :
        print(-1)
        return
        #The program returns None
    #State of the program after the if block has been executed: `n` and `m` are positive integers, `x`, `k`, `y` are positive integers returned by `func_2()`, `a` is a list of integers returned by `func_2()`, `b` is a list of `m` integers with all elements being pairwise distinct, 1 ≤ `b_i` ≤ `n`, `j` is the number of elements in `a` that match the corresponding elements in `b` up to the minimum of `len(a)` and `m`, `i` is `len(a) - 1`, `ax` is the last element of `a`. `j` is equal to `m`.
    sa = set(a)
    sb = set(b)
    if (sa == sb) :
        print(0)
        return
        #The program returns nothing (None)
    #State of the program after the if block has been executed: `n` and `m` are positive integers, `x`, `k`, `y` are positive integers returned by `func_2()`, `a` is a list of integers returned by `func_2()`, `b` is a list of `m` integers with all elements being pairwise distinct, 1 ≤ `b_i` ≤ `n`, `j` is the number of elements in `a` that match the corresponding elements in `b` up to the minimum of `len(a)` and `m`, `i` is `len(a) - 1`, `ax` is the last element of `a`, `j` is equal to `m`, `sa` is a set containing unique elements from `a`, `sb` is a set containing unique elements from `b`, and `sa` is not equal to `sb`.
    mx = max(sa - sb)
    gaps = []
    j = 0
    gl = 0
    special = False
    for (i, ax) in enumerate(a):
        if j < m and ax == b[j]:
            j += 1
            if special:
                specialgap = gl
            gaps.append(gl)
            gl = 0
            special = False
        else:
            if ax == mx:
                special = True
            gl += 1
        
    #State of the program after the  for loop has been executed: `n` and `m` are positive integers, `x`, `k`, `y` are positive integers returned by `func_2()`, `a` is a list of integers returned by `func_2()` that must have at least 1 element, `b` is a list of `m` integers with all elements being pairwise distinct, 1 ≤ `b_i` ≤ `n`, `i` is `len(a) - 1`, `ax` is the last element of `a`, `j` is the number of elements in `b` that match elements in `a` in order, `sa` is a set containing unique elements from `a`, `sb` is a set containing unique elements from `b`, `sa` is not equal to `sb`, `mx` is the maximum element in the set difference between `sa` and `sb`, `gaps` is a list containing the lengths of gaps between matching elements in `a` and `b`, `gl` is the length of the final gap (or 0 if the last element of `a` matches an element in `b`), `special` is `True` if the last element of `a` is `mx` and no matching element was found in `b`, otherwise `special` is `False`. If `special` is `True`, `specialgap` is the length of the gap where `ax` was `mx` and no matching element was found in `b`.
    if special :
        specialgap = gl
    #State of the program after the if block has been executed: *`n` and `m` are positive integers, `x`, `k`, `y` are positive integers returned by `func_2()`, `a` is a list of integers returned by `func_2()` that must have at least 1 element, `b` is a list of `m` integers with all elements being pairwise distinct, 1 ≤ `b_i` ≤ `n`, `i` is `len(a) - 1`, `ax` is the last element of `a`, `j` is the number of elements in `b` that match elements in `a` in order, `sa` is a set containing unique elements from `a`, `sb` is a set containing unique elements from `b`, `sa` is not equal to `sb`, `mx` is the maximum element in the set difference between `sa` and `sb`, `gaps` is a list containing the lengths of gaps between matching elements in `a` and `b`, `gl` is the length of the final gap (or 0 if the last element of `a` matches an element in `b`). If `special` is `True`, meaning the last element of `a` is `mx` and no matching element was found in `b`, then `specialgap` is set to `gl`.
    gaps.append(gl)
    debug_print(gaps)
    if (specialgap < k) :
        print(-1)
        return
        #The program does not return any value.
    #State of the program after the if block has been executed: `n` and `m` are positive integers, `x`, `k`, `y` are positive integers returned by `func_2()`, `a` is a list of integers returned by `func_2()` that must have at least 1 element, `b` is a list of `m` integers with all elements being pairwise distinct, 1 ≤ `b_i` ≤ `n`, `i` is `len(a) - 1`, `ax` is the last element of `a`, `j` is the number of elements in `b` that match elements in `a` in order, `sa` is a set containing unique elements from `a`, `sb` is a set containing unique elements from `b`, `sa` is not equal to `sb`, `mx` is the maximum element in the set difference between `sa` and `sb`, `gaps` is a list containing the lengths of gaps between matching elements in `a` and `b` and now includes `gl`, `gl` is the length of the final gap (or 0 if the last element of `a` matches an element in `b`). If `special` is `True`, meaning the last element of `a` is `mx` and no matching element was found in `b`, then `specialgap` is set to `gl`. The `gaps` list has been printed. Additionally, `specialgap` is greater than or equal to `k`.
    ans = 0
    if (x < y * k) :
        for g in gaps:
            ans += x * (g // k) + y * (g % k)
            
        #State of the program after the  for loop has been executed: `n` and `m` are positive integers, `x`, `k`, `y` are positive integers returned by `func_2()`, `a` is a list of integers returned by `func_2()` that must have at least 1 element, `b` is a list of `m` integers with all elements being pairwise distinct, 1 ≤ `b_i` ≤ `n`, `i` is `len(a) - 1`, `ax` is the last element of `a`, `j` is the number of elements in `b` that match elements in `a` in order, `sa` is a set containing unique elements from `a`, `sb` is a set containing unique elements from `b`, `sa` is not equal to `sb`, `mx` is the maximum element in the set difference between `sa` and `sb`, `gaps` is a list containing the lengths of gaps between matching elements in `a` and `b` and now is empty (if the loop executed), `gl` is the length of the final gap (or 0 if the last element of `a` matches an element in `b`), `special` is `True` if the last element of `a` is `mx` and no matching element was found in `b`, `specialgap` is set to `gl` and is greater than or equal to `k`, `ans` is the sum of `x * (g // k) + y * (g % k)` for all `g` in the original `gaps` list, and `x` is less than `y * k`. If the loop did not execute, `ans` remains 0 and `gaps` remains unchanged.
    else :
        for g in gaps:
            ans += y * g
            
        #State of the program after the  for loop has been executed: `n` and `m` are positive integers, `x`, `k`, `y` are positive integers returned by `func_2()`, `a` is a list of integers returned by `func_2()` that must have at least 1 element, `b` is a list of `m` integers with all elements being pairwise distinct, 1 ≤ `b_i` ≤ `n`, `i` is `len(a) - 1`, `ax` is the last element of `a`, `j` is the number of elements in `b` that match elements in `a` in order, `sa` is a set containing unique elements from `a`, `sb` is a set containing unique elements from `b`, `sa` is not equal to `sb`, `mx` is the maximum element in the set difference between `sa` and `sb`, `gaps` is a list containing the lengths of gaps between matching elements in `a` and `b` and now includes `gl`, `gl` is the length of the final gap (or 0 if the last element of `a` matches an element in `b`), if `special` is `True`, meaning the last element of `a` is `mx` and no matching element was found in `b`, then `specialgap` is set to `gl`, `specialgap` is greater than or equal to `k`, `ans` is `y * sum(gaps)`, `x` is greater than or equal to `y * k`.
    #State of the program after the if-else block has been executed: *`n` and `m` are positive integers, `x`, `k`, `y` are positive integers returned by `func_2()`, `a` is a list of integers returned by `func_2()` that must have at least 1 element, `b` is a list of `m` integers with all elements being pairwise distinct, 1 ≤ `b_i` ≤ `n`, `i` is `len(a) - 1`, `ax` is the last element of `a`, `j` is the number of elements in `b` that match elements in `a` in order, `sa` is a set containing unique elements from `a`, `sb` is a set containing unique elements from `b`, `sa` is not equal to `sb`, `mx` is the maximum element in the set difference between `sa` and `sb`, `gaps` is a list containing the lengths of gaps between matching elements in `a` and `b`. If `x < y * k`, `gaps` is emptied, `ans` is the sum of `x * (g // k) + y * (g % k)` for all `g` in the original `gaps` list, and `specialgap` is set to `gl` if `special` is `True`. Otherwise, `gaps` includes `gl`, `ans` is `y * sum(gaps)`, and `specialgap` is set to `gl` if `special` is `True`. In both cases, `specialgap` is greater than or equal to `k` and `gaps` has been printed.
    print(ans)
#Overall this is what the function does:The function `func_1` processes two lists `a` and `b` to determine the minimum cost required to transform the sequence `a` into the sequence `b` using two operations: casting a fireball (with cost `x`) and casting berserk (with cost `y`). The function assumes that the lengths of `a` and `b` are provided as `n` and `m` respectively, and that `a` and `b` contain distinct integers within the range [1, n]. The function also uses the parameters `x`, `k`, and `y` which represent the costs and the range of the fireball operation. 

1. The function first checks if the sequence `a` contains all the elements of `b` in the same order. If not, it prints `-1` and returns.
2. If the sets of elements in `a` and `b` are identical, it prints `0` and returns.
3. If the sets of elements in `a` and `b` are not identical, it finds the maximum element in `a` that is not in `b` (`mx`).
4. The function then calculates the gaps between consecutive matching elements in `a` and `b`, and keeps track of a special gap where the element `mx` appears without a matching element in `b`.
5. If the special gap is less than `k`, it prints `-1` and returns.
6. Finally, it calculates the total cost to fill the gaps:
   - If the cost of a single fireball (`x`) is less than the cost of `k` berserks (`y * k`), it uses a combination of fireballs and berserks to minimize the cost.
   - Otherwise, it uses only berserks to fill the gaps.
7. The function prints the total cost and does not return any value.

Edge Cases and Missing Functionality:
- The function assumes that `a` and `b` are provided and that `func_2` correctly returns the necessary parameters. If `func_2` fails or returns invalid data, the function may not behave as expected.
- The function does not handle cases where `a` or `b` are empty or where `n` or `m` are zero.
- The function does not validate the inputs to ensure they meet the specified constraints (e.g., `1 ≤ n, m ≤ 2 ⋅ 10^5`, `1 ≤ x, y ≤ 10^9`, etc.). If these constraints are not met, the function may produce incorrect results or fail.
- The function does not handle cases where the special gap is exactly equal to `k`. It only checks if the special gap is less than `k` and prints `-1` if true, but it should also handle the case where the special gap is exactly `k`.

#Function 2:
#State of the program right berfore the function call: None
def func_2():
    return [int(x) for x in input().split()]
    #The program returns a list of integers converted from the input string, where each integer is separated by spaces in the input.
#Overall this is what the function does:The function `func_2` does not accept any parameters. It reads a line of input from the user, splits the input string by spaces, converts each resulting substring into an integer, and returns a list of these integers. If the input contains non-integer values, a `ValueError` will be raised. If the input is empty, an empty list is returned. The function does not modify any external state or variables.

#Function 3:
#State of the program right berfore the function call: o is an integer offset to be added to each element read from the input.
def func_3(o):
    return [(int(x) + o) for x in input().split()]
    #The program returns a list where each element is an integer from the input split by spaces, with the integer offset `o` added to each.
#Overall this is what the function does:The function `func_3` accepts an integer `o` and returns a list where each element is an integer from the input split by spaces, with the integer offset `o` added to each. The function assumes that the input is a string of space-separated integers. If the input contains non-integer values, a `ValueError` will be raised during the conversion to integers. The function does not handle any edge cases such as empty input or non-numeric input values.

#Function 4:
#State of the program right berfore the function call: n and m are non-negative integers.
def func_4(n, m):
    return [func_2() for _ in range(n)]
    #The program returns a list of length `n` where each element is the result of calling `func_2()`. The values in the list depend on the implementation of `func_2()`.
#Overall this is what the function does:The function `func_4` accepts two non-negative integer parameters `n` and `m`. It returns a list of length `n` where each element is the result of calling `func_2()`. The values in the list depend on the implementation of `func_2()`. The parameter `m` is not used within the function and has no effect on the output. If `n` is 0, the function returns an empty list.

#Function 5:
#State of the program right berfore the function call: f is a callable object (function), and *dim is a sequence of positive integers representing dimensions.
def func_5(f):
    return [func_5(f, *dim[1:]) for _ in range(dim[0])] if dim else f()
    #The program returns a list of `dim[0]` elements, each of which is the result of calling `func_5(f, *dim[1:])`, or it returns the result of calling `f()` if `dim` is an empty sequence.
#Overall this is what the function does:The function `func_5` accepts a callable object `f` and a sequence of positive integers `*dim`. It recursively constructs a nested list structure where the depth of the nesting corresponds to the length of `*dim`, and each innermost list contains the result of calling `f()`. If `*dim` is an empty sequence, the function directly returns the result of calling `f()`. The final state of the program after the function concludes is that it returns either a nested list of results from `f()` or a single result from `f()`, depending on the length of `*dim`. Edge cases include when `*dim` is an empty sequence, in which case the function simply returns the result of `f()`, and when `*dim` contains only one element, in which case the function returns a list of `dim[0]` elements, each being the result of `f()`.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.