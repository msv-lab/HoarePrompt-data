
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: You are given an array a of length n and array b of length m both consisting of only integers 0 and 1. Consider a matrix c of size n × m formed by following rule: c_{i, j} = a_i ⋅ b_j (i.e. a_i multiplied by b_j). It's easy to see that c consists of only zeroes and ones too.

How many subrectangles of size (area) k consisting only of ones are there in c?

A subrectangle is an intersection of a consecutive (subsequent) segment of rows and a consecutive (subsequent) segment of columns. I.e. consider four integers x_1, x_2, y_1, y_2 (1 ≤ x_1 ≤ x_2 ≤ n, 1 ≤ y_1 ≤ y_2 ≤ m) a subrectangle c[x_1 ... x_2][y_1 ... y_2] is an intersection of the rows x_1, x_1+1, x_1+2, ..., x_2 and the columns y_1, y_1+1, y_1+2, ..., y_2.

The size (area) of a subrectangle is the total number of cells in it.

Input

The first line contains three integers n, m and k (1 ≤ n, m ≤ 40 000, 1 ≤ k ≤ n ⋅ m), length of array a, length of array b and required size of subrectangles.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ a_i ≤ 1), elements of a.

The third line contains m integers b_1, b_2, …, b_m (0 ≤ b_i ≤ 1), elements of b.

Output

Output single integer — the number of subrectangles of c with size (area) k consisting only of ones.

Examples

Input


3 3 2
1 0 1
1 1 1


Output


4


Input


3 5 4
1 1 1
1 1 1 1 1


Output


14

Note

In first example matrix c is:

<image>

There are 4 subrectangles of size 2 consisting of only ones in it:

<image>

In second example matrix c is:

<image>
Program:
```
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase
#Function 1:
def func_1():
    return int(input())

#Function 2:
def func_2():
    return input()

#Function 3:
def func_3():
    return map(int, input().strip().split(' '))

#Function 4:
def func_4():
    return map(str, input().strip().split(' '))

#Function 5:
def func_5():
    return list(func_3())

#Function 6:
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
def func_7(item):
    return item[1]

#Function 8:
def func_8(l):
    return sorted(l, key=getKey, reverse=True)

#Function 9:
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]

#Function 10:
def func_10(x):
    return x and (not x & x - 1)

#Function 11:
def func_11(n):
    return bin(n).replace('0b', '')

#Function 12:
def func_12(n):
    return [int(i) for i in str(n)]

#Function 13:
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(n - r))

#Function 14:
def func_14(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p
    return res

#Function 15:
def func_15(x, y):
    while y:
        (x, y) = (y, x % y)
    return x

#Function 16:
def func_16(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True

#Function 17:
def func_17():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 18:
def func_18():
    if True:
        (n, m, k) = func_3()
        a = func_5()
        b = func_5()
        x = [0] * (n + 5)
        y = [0] * (m + 5)
        x[0] = a[0]
        fx = {}
        p = []
        q = []
        if x[0] == 1:
            fx[1] = 1
            p.append(1)
        for i in range(1, n):
            if a[i] != 0:
                x[i] += x[i - 1] + a[i]
                if fx.get(x[i], 0) == 0:
                    fx[x[i]] = 1
                else:
                    fx[x[i]] += 1
                p.append(x[i])
            else:
                x[i] = 0
        y[0] = b[0]
        fy = {}
        if y[0] == 1:
            fy[1] = 1
            q.append(1)
        for i in range(1, m):
            if b[i] != 0:
                y[i] += y[i - 1] + b[i]
                if fy.get(y[i], 0) == 0:
                    fy[y[i]] = 1
                else:
                    fy[y[i]] += 1
                q.append(y[i])
            else:
                y[i] = 0
        p = list(set(p))
        q = list(set(q))
        cnt = 0
        for i in range(len(p) - 1, -1, -1):
            fx[p[i]] = fx[p[i]] + cnt
            cnt = fx[p[i]]
        cnt = 0
        for i in range(len(q) - 1, -1, -1):
            fy[q[i]] = fy[q[i]] + cnt
            cnt = fy[q[i]]
        ans = 0
        for i in p:
            if k & i != 0:
                continue
            if fx.get(i, 0) == 0 or fy.get(k // i, 0) == 0:
                continue
            if k % i == 0:
                ans += fx[i] * fy[k // i]
        func_19(ans)

#Function 19:
def func_19(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False):
        file.flush()


```
Original Assessment: Correctness: **False**

Explanation:
The program does not handle the case where the input values `a` and `b` contain zeros, which can lead to incorrect results. Specifically, the program incorrectly accumulates the counts of continuous ones in arrays `a` and `b`, which can lead to incorrect subrectangle counts.

For example, consider the input:
```
3 3 2
1 0 1
1 0 1
```
The matrix `c` formed would be:
```
1 0 1
0 0 0
1 0 1
```
The program should output `2` because there are two subrectangles of size 2 consisting only of ones:
- The top-left 1x2 subrectangle.
- The bottom-left 1x2 subrectangle.

However, the program will incorrectly count more subrectangles due to the way it accumulates the counts of continuous ones in `a` and `b`.

This indicates that the program does not correctly handle the presence of zeros in the input arrays, leading to incorrect results. Therefore, the program is incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
abc = 'abcdefghijklmnopqrstuvwxyz'
abd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod = 1000000007
inf = float('inf')
vow = ['a', 'e', 'i', 'o', 'u']
(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def func_17(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            (self.buffer.truncate(0), self.buffer.seek(0))
class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda : self.buffer.read().decode('ascii')
        self.readline = lambda : self.buffer.readline().decode('ascii')
if sys.version_info[0] < 3:
    (sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))
else:
    (sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))
input = lambda : sys.stdin.readline().rstrip('\r\n')
if __name__ == '__main__':
    func_18()

#Function 1:
#State of the program right berfore the function call: None of the variables from the problem description or the other functions are used in this function. This function is likely intended to read an integer input from the user, but does not align with the specific requirements of the problem described.
def func_1():
    return int(input())
    #The program returns an integer value input by the user.

#Function 2:
#State of the program right berfore the function call: None of the variables from the problem description are used in the function signature of `func_2`. This function does not take any parameters and is not directly related to solving the problem described.
def func_2():
    return input()
    #The program returns the user input

#Function 3:
#State of the program right berfore the function call: This function does not take any parameters and is designed to read input from stdin, expecting at least one line of space-separated integers.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing the integers from the input line, which was expected to be space-separated integers.

#Function 4:
#State of the program right berfore the function call: None of the variables in the function signature are relevant to the problem or have any preconditions. The function `func_4` does not take any parameters and its purpose is to read input from the user, which is not directly related to the main problem of finding subrectangles of size k consisting only of ones in the matrix c.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object that converts each element from the input (split by spaces) into a string.

#Function 5:
#State of the program right berfore the function call: None of the variables in the function signature are used; the function calls another function `func_3` and returns its output as a list.
def func_5():
    return list(func_3())
    #The program returns the output of `func_3()` as a list. The content of the list depends on the implementation of `func_3()`.

#Function 6:
#State of the program right berfore the function call: This function does not take any parameters, thus no preconditions apply to input variables.
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a tuple or list where the second element (item[1]) is of a type that supports comparison (e.g., int, float, str).
def func_7(item):
    return item[1]
    #The program returns the second element of the tuple or list 'item', which is of a type that supports comparison (e.g., int, float, str).

#Function 8:
#State of the program right berfore the function call: l is a list of elements that can be compared and sorted.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns a new list that is a sorted version of `l`, with elements sorted in descending order based on the key obtained from the `getKey` function.

#Function 9:
#State of the program right berfore the function call: n and m are positive integers, and num is an integer.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of lists where each inner list contains `m` occurrences of the integer `num`, and there are `n` such inner lists.

#Function 10:
#State of the program right berfore the function call: x is a non-negative integer.
def func_10(x):
    return x and not x & x - 1
    #The program returns `True` if `x` is a non-zero power of 2, otherwise it returns `False`.

#Function 11:
#State of the program right berfore the function call: n is a non-negative integer.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of `n` as a string without the '0b' prefix, where `n` is a non-negative integer.

#Function 12:
#State of the program right berfore the function call: n is a non-negative integer.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers where each integer is a digit from the original non-negative integer `n`.

#Function 13:
#State of the program right berfore the function call: n and r are non-negative integers such that 0 <= r <= n.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(n - r))
    #The program returns the integer value representing the combination of n items taken r at a time, which is calculated as the factorial of n divided by the product of the factorial of r and the factorial of (n - r).

#Function 14:
#State of the program right berfore the function call: x is an integer, y is a non-negative integer, and p is a positive integer.
def func_14(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is `x^y % p` where `x` and `y` are the original values, `x` is the result of repeatedly squaring the initial value of `x` modulo `p` for each bit position of `y`, and `p` remains a positive integer.
    return res
    #The program returns `res`, which is the result of `x^y % p` where `x` and `y` are the original values, and `x` is the result of repeatedly squaring the initial value of `x` modulo `p` for each bit position of `y`, and `p` remains a positive integer. Given that `y` is 0, `res` simplifies to `1` since any number to the power of 0 is 1.

#Function 15:
#State of the program right berfore the function call: x and y are non-negative integers.
def func_15(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the greatest common divisor (GCD) of the original values of `x` and `y`
    return x
    #The program returns the greatest common divisor (GCD) of the original values of `x` and `y`, where `y` is 0.

#Function 16:
#State of the program right berfore the function call: n is an integer greater than 1.
def func_16(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *n is an integer greater than 1, and n is greater than 1
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: `n` is an integer greater than 1, and `n` is greater than 3
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer greater than 1 and greater than 3, and `n` is not divisible by 2 and not divisible by 3
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is an integer greater than 1, greater than 3, not divisible by 2, 3, or any prime number up to the largest prime less than or equal to the square root of `n`. If `n` is divisible by any such prime, the function returns False. `i` is the smallest integer greater than the square root of `n` that is congruent to 5 modulo 6.
    return True
    #The program returns True

#Function 17:
#State of the program right berfore the function call: This function does not have any parameters, and thus no preconditions can be defined for the input variables. However, it assumes that 'input.txt' and 'output.txt' files exist and are accessible for reading and writing, respectively.
def func_17():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 18:
#State of the program right berfore the function call: n, m, and k are positive integers such that 1 ≤ n, m ≤ 40000 and 1 ≤ k ≤ n * m. a is a list of n integers where each element is either 0 or 1. b is a list of m integers where each element is either 0 or 1.
def func_18():
    if (True) :
        n, m, k = func_3()
        a = func_5()
        b = func_5()
        x = [0] * (n + 5)
        y = [0] * (m + 5)
        x[0] = a[0]
        fx = {}
        p = []
        q = []
        if (x[0] == 1) :
            fx[1] = 1
            p.append(1)
        #State of the program after the if block has been executed: *`n`, `m`, and `k` are the values returned by `func_3()`, `a` is the value returned by `func_5()`, `b` is the value returned by `func_5()`, `x` is a list of length `n + 5` with the first element set to `a[0]` and all other elements set to 0, `y` is a list of length `m + 5` with all elements set to 0, the condition `True` is satisfied, `fx` is an empty dictionary, `q` is an empty list. If the first element of `x` is 1, `p` is `[1]`; otherwise, `p` remains an empty list.
        for i in range(1, n):
            if a[i] != 0:
                x[i] += x[i - 1] + a[i]
                if fx.get(x[i], 0) == 0:
                    fx[x[i]] = 1
                else:
                    fx[x[i]] += 1
                p.append(x[i])
            else:
                x[i] = 0
            
        #State of the program after the  for loop has been executed: `n`, `m`, and `k` are the values returned by `func_3()`, `a` and `b` are the values returned by `func_5()`. `x` is a list of length `n + 5` where the first element is `a[0]` and subsequent elements are updated based on the loop. For each `i` in the range `[1, n-1]`, if `a[i]` is not 0, `x[i]` is set to `x[i-1] + a[i]`, otherwise `x[i]` is set to 0. `p` is a list containing all non-zero values of `x[i]` for `i` in the range `[1, n-1]`. The dictionary `fx` contains the frequency count of each unique value in `p`. `y` is a list of length `m + 5` with all elements set to 0, and `q` is an empty list. If the first element of `x` is 1, `p` starts with `[1]`; otherwise, `p` starts as an empty list.
        y[0] = b[0]
        fy = {}
        if (y[0] == 1) :
            fy[1] = 1
            q.append(1)
        #State of the program after the if block has been executed: *`n`, `m`, and `k` are the values returned by `func_3()`, `a` and `b` are the values returned by `func_5()`. `x` is a list of length `n + 5` where the first element is `a[0]` and subsequent elements are updated based on the loop. For each `i` in the range `[1, n-1]`, if `a[i]` is not 0, `x[i]` is set to `x[i-1] + a[i]`, otherwise `x[i]` is set to 0. `p` is a list containing all non-zero values of `x[i]` for `i` in the range `[1, n-1]`. The dictionary `fx` contains the frequency count of each unique value in `p`. `y` is a list of length `m + 5` with the first element set to `b[0]` and the rest set to 0. If `y[0]` is 1, `q` is a list containing `[1]` and `fy` is a dictionary with the key `1` set to `1`. Otherwise, `q` remains an empty list and `fy` remains an empty dictionary.
        for i in range(1, m):
            if b[i] != 0:
                y[i] += y[i - 1] + b[i]
                if fy.get(y[i], 0) == 0:
                    fy[y[i]] = 1
                else:
                    fy[y[i]] += 1
                q.append(y[i])
            else:
                y[i] = 0
            
        #State of the program after the  for loop has been executed: `n`, `m`, and `k` are the values returned by `func_3()`, `a` and `b` are the values returned by `func_5()`, `x` is a list of length `n + 5` where the first element is `a[0]` and subsequent elements are updated based on the loop, `p` is a list containing all non-zero values of `x[i]` for `i` in the range `[1, n-1]`, `fx` contains the frequency count of each unique value in `p`, `y` is a list of length `m + 5` with the first element set to `b[0]` and the rest set to 0, `q` is a list containing all non-zero values of `y[i]` for `i` in the range `[1, m-1]`, `fy` is a dictionary containing the frequency count of each unique value in `q`. If `b[i]` is not 0 for any `i` in the range `[1, m-1]`, `y[i]` is set to the cumulative sum of non-zero `b` values up to index `i`, and `q` and `fy` are updated accordingly. If all `b[i]` for `i` in the range `[1, m-1]` are 0, `y` remains unchanged, and `q` and `fy` retain their initial states as described in the precondition.
        p = list(set(p))
        q = list(set(q))
        cnt = 0
        for i in range(len(p) - 1, -1, -1):
            fx[p[i]] = fx[p[i]] + cnt
            
            cnt = fx[p[i]]
            
        #State of the program after the  for loop has been executed: `n`, `m`, and `k` are the values returned by `func_3()`. `a` and `b` are the values returned by `func_5()`. `x` is a list of length `n + 5` where the first element is `a[0]` and subsequent elements are updated based on the loop. `p` is a list containing all unique non-zero values of `x[i]` for `i` in the range `[1, n-1]`. `fx` contains the frequency count of each unique value in the original `p`, with each value incremented by the cumulative sum of the frequencies of the elements processed in previous iterations. `y` is a list of length `m + 5` with the first element set to `b[0]` and the rest set to 0. `q` is a list containing all non-zero values of `y[i]` for `i` in the range `[1, m-1]`. `fy` is a dictionary containing the frequency count of each unique value in `q`. `q` is now a list of unique non-zero values from `q`. `cnt` is the final value of `fx[p[0]]` after all the increments.
        cnt = 0
        for i in range(len(q) - 1, -1, -1):
            fy[q[i]] = fy[q[i]] + cnt
            
            cnt = fy[q[i]]
            
        #State of the program after the  for loop has been executed: `n`, `m`, and `k` are the values returned by `func_3()`, `a` and `b` are the values returned by `func_5()`, `x` is a list of length `n + 5` where the first element is `a[0]` and subsequent elements are updated based on the loop, `p` is a list containing all unique non-zero values of `x[i]` for `i` in the range `[1, n-1]`, `fx` contains the frequency count of each unique value in the original `p`, with each value incremented by the cumulative sum of the frequencies of the elements processed in previous iterations, `y` is a list of length `m + 5` with the first element set to `b[0]` and the rest set to 0, `q` is a list containing all non-zero values of `y[i]` for `i` in the range `[1, m-1]`, `q` is now a list of unique non-zero values from `q`, `fy` is a dictionary containing the frequency count of each unique value in `q`, where each value is the original frequency count plus the cumulative sum of the frequencies of all elements processed after it, `cnt` is the frequency count of the first element in `q` after all updates.
        ans = 0
        for i in p:
            if k & i != 0:
                continue
            
            if fx.get(i, 0) == 0 or fy.get(k // i, 0) == 0:
                continue
            
            if k % i == 0:
                ans += fx[i] * fy[k // i]
            
        #State of the program after the  for loop has been executed: - If the loop does not execute (i.e., `p` is empty or no `i` in `p` satisfies the conditions), `ans` remains 0.
        #   - If the loop executes, `ans` will be the sum of the products of the frequency counts of valid pairs `(i, k // i)`.
        #
        #Output State:
        func_19(ans)
    #State of the program after the if block has been executed: *`n`, `m`, and `k` are positive integers such that 1 ≤ n, m ≤ 40000 and 1 ≤ k ≤ n * m. `a` is a list of n integers where each element is either 0 or 1. `b` is a list of m integers where each element is either 0 or 1. If the loop did not execute, `ans` remains 0. If the loop executed, `ans` is the sum of the products of the frequency counts of valid pairs `(i, k // i)`, and the function `func_19` was called with `ans` as an argument.

#Function 19:
#State of the program right berfore the function call: args is a tuple containing any number of values of any type, and kwargs is a dictionary that can contain the keys 'sep', 'file', 'end', and 'flush'. 'sep' is a string used to separate the values in args, 'file' is a stream object where the output will be written, 'end' is a string appended after the last value, and 'flush' is a boolean indicating whether to forcibly flush the stream.
def func_19():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a tuple containing any number of values of any type, `kwargs` is a dictionary that can contain the keys 'end' and 'flush', `sep` is the value of `kwargs['sep']` if it existed or `' '` if it did not, `file` is the value of `kwargs['file']` if it existed or `sys.stdout` if it did not, `at_start` is False (if `args` is not empty), `str(args[0])` through `str(args[-1])` have been written to `file` separated by `sep` (if `args` contains more than one element). If `args` is empty, `at_start` remains True and nothing is written to `file`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a tuple containing any number of values of any type, `kwargs` is a dictionary that may contain the key 'flush' but not 'end'. `sep` is the value of `kwargs['sep']` if it existed or `' '` if it did not. `file` is the value of `kwargs['file']` if it existed or `sys.stdout` if it did not. `at_start` is False if `args` is not empty. The value of `'end'` in `kwargs` or `'\n'` if `'end'` was not in `kwargs` has been written to `file`. If `kwargs` contained the key 'flush' and its value was `True`, then `kwargs` no longer contains the key 'flush' and the buffer of `file` has been flushed.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
