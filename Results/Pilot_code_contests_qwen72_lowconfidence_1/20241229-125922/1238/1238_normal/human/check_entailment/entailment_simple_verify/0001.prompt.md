
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Ziota found a video game called "Monster Invaders".

Similar to every other shooting RPG game, "Monster Invaders" involves killing monsters and bosses with guns.

For the sake of simplicity, we only consider two different types of monsters and three different types of guns.

Namely, the two types of monsters are: 

  * a normal monster with 1 hp. 
  * a boss with 2 hp. 



And the three types of guns are: 

  * Pistol, deals 1 hp in damage to one monster, r_1 reloading time 
  * Laser gun, deals 1 hp in damage to all the monsters in the current level (including the boss), r_2 reloading time 
  * AWP, instantly kills any monster, r_3 reloading time 



The guns are initially not loaded, and the Ziota can only reload 1 gun at a time.

The levels of the game can be considered as an array a_1, a_2, …, a_n, in which the i-th stage has a_i normal monsters and 1 boss. Due to the nature of the game, Ziota cannot use the Pistol (the first type of gun) or AWP (the third type of gun) to shoot the boss before killing all of the a_i normal monsters.

If Ziota damages the boss but does not kill it immediately, he is forced to move out of the current level to an arbitrary adjacent level (adjacent levels of level i (1 < i < n) are levels i - 1 and i + 1, the only adjacent level of level 1 is level 2, the only adjacent level of level n is level n - 1). Ziota can also choose to move to an adjacent level at any time. Each move between adjacent levels are managed by portals with d teleportation time.

In order not to disrupt the space-time continuum within the game, it is strictly forbidden to reload or shoot monsters during teleportation. 

Ziota starts the game at level 1. The objective of the game is rather simple, to kill all the bosses in all the levels. He is curious about the minimum time to finish the game (assuming it takes no time to shoot the monsters with a loaded gun and Ziota has infinite ammo on all the three guns). Please help him find this value.

Input

The first line of the input contains five integers separated by single spaces: n (2 ≤ n ≤ 10^6) — the number of stages, r_1, r_2, r_3 (1 ≤ r_1 ≤ r_2 ≤ r_3 ≤ 10^9) — the reload time of the three guns respectively, d (1 ≤ d ≤ 10^9) — the time of moving between adjacent levels.

The second line of the input contains n integers separated by single spaces a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^6, 1 ≤ i ≤ n).

Output

Print one integer, the minimum time to finish the game.

Examples

Input


4 1 3 4 3
3 2 5 1


Output


34

Input


4 2 4 4 1
4 5 1 2


Output


31

Note

In the first test case, the optimal strategy is:

  * Use the pistol to kill three normal monsters and AWP to kill the boss (Total time 1⋅3+4=7) 
  * Move to stage two (Total time 7+3=10) 
  * Use the pistol twice and AWP to kill the boss (Total time 10+1⋅2+4=16) 
  * Move to stage three (Total time 16+3=19) 
  * Use the laser gun and forced to move to either stage four or two, here we move to stage four (Total time 19+3+3=25) 
  * Use the pistol once, use AWP to kill the boss (Total time 25+1⋅1+4=30) 
  * Move back to stage three (Total time 30+3=33) 
  * Kill the boss at stage three with the pistol (Total time 33+1=34) 



Note that here, we do not finish at level n, but when all the bosses are killed.
Program:
```
import sys
import math

def func():
    if sys.subversion[0] == 'PyPy':
        import io, atexit
        sys.stdout = io.BytesIO()
        atexit.register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
        sys.stdin = io.BytesIO(sys.stdin.read())
        input = lambda : sys.stdin.readline().rstrip()
    str1 = raw_input().split(' ')
    (n, r1, r2, r3, d) = map(int, str1)
    str2 = raw_input().split(' ')
    a = map(int, str2)
    fs = 0
    c1 = 0
    c2 = 2 * d
    for i in range(n):
        indcost = r3 + a[i] * r1
        aoecost = min(r2 + r1, r1 * (a[i] + 2))
        mincost = min(indcost, aoecost)
        mincost2l = min(indcost - d, aoecost)
        oto = indcost
        ott = mincost + 2 * d
        ttt = mincost + 2 * d
        tto = mincost
        if i < n - 1:
            c3 = min(c1 + oto, c2 + tto) + d
            c4 = min(c1 + ott, c2 + ttt) + d
        else:
            c3 = min(c1 + oto, c2 + mincost2l) + d
            c4 = min(c1 + ott, c2 + ttt) + d
        c1 = c3
        c2 = c4
    ans = min(c1, c2) - d
    print(ans)


```
Original Assessment: Correctness: **True**

Explanation:
The program appears to handle all the requirements and edge cases as described in the problem statement. It correctly calculates the minimum time required to finish the game by considering the costs of using different guns and the costs of moving between levels. Here's a detailed breakdown of why the program is considered correct:

1. **Initialization and Input Reading**: The program reads the input values and initializes necessary variables. It handles the input in a way that is compatible with both standard Python and PyPy.

2. **Cost Calculation**: For each level, it calculates the cost of using different strategies:
   - `indcost`: Cost of using the AWP to kill the boss and the pistol to kill all normal monsters.
   - `aoecost`: Cost of using the laser gun to deal 1 HP to all monsters and the pistol to finish off the boss.
   - `mincost`: Minimum cost between the above two strategies.
   - `mincost2l`: Adjusted cost if the player moves to the next level after using the laser gun.

3. **Dynamic Programming Approach**: The program uses a dynamic programming approach to keep track of the minimum time to complete the game up to the current level. It maintains two states:
   - `c1`: Minimum time if the player is currently at the current level.
   - `c2`: Minimum time if the player is currently at the next level.

4. **Transition Between Levels**: The program correctly updates the states for moving to the next level and considers the costs of moving and the different strategies.

5. **Final Calculation**: After processing all levels, it calculates the minimum time required to finish the game by considering the final state.

The program handles all the constraints and edge cases mentioned in the problem description, and it correctly computes the minimum time required to kill all the bosses in all levels. Therefore, the program is correct.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
import sys
import math

#State of the program right berfore the function call: n is an integer where 2 ≤ n ≤ 10^6, r_1, r_2, r_3 are integers where 1 ≤ r_1 ≤ r_2 ≤ r_3 ≤ 10^9, d is an integer where 1 ≤ d ≤ 10^9, and a is a list of n integers where 1 ≤ a_i ≤ 10^6 for 1 ≤ i ≤ n.
def func():
    if (sys.subversion[0] == 'PyPy') :
        sys.stdout = io.BytesIO()
        atexit.register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
        sys.stdin = io.BytesIO(sys.stdin.read())
        input = lambda : sys.stdin.readline().rstrip()
    #State of the program after the if block has been executed: *`n` is an integer where 2 ≤ n ≤ 10^6, `r_1`, `r_2`, `r_3` are integers where 1 ≤ r_1 ≤ r_2 ≤ r_3 ≤ 10^9, `d` is an integer where 1 ≤ d ≤ 10^9, `a` is a list of `n` integers where 1 ≤ a_i ≤ 10^6 for 1 ≤ i ≤ n. If the interpreter is PyPy, `sys.stdout` is an instance of `io.BytesIO()`, a function is registered to write the content of `sys.stdout` to `sys.__stdout__` upon normal termination, `sys.stdin` is an instance of `io.BytesIO` initialized with the content of the original `sys.stdin`, and `input` is a function that reads a line from `sys.stdin` and returns it stripped of trailing newline characters.
    str1 = raw_input().split(' ')
    n, r1, r2, r3, d = map(int, str1)
    str2 = raw_input().split(' ')
    a = map(int, str2)
    fs = 0
    c1 = 0
    c2 = 2 * d
    for i in range(n):
        indcost = r3 + a[i] * r1
        
        aoecost = min(r2 + r1, r1 * (a[i] + 2))
        
        mincost = min(indcost, aoecost)
        
        mincost2l = min(indcost - d, aoecost)
        
        oto = indcost
        
        ott = mincost + 2 * d
        
        ttt = mincost + 2 * d
        
        tto = mincost
        
        if i < n - 1:
            c3 = min(c1 + oto, c2 + tto) + d
            c4 = min(c1 + ott, c2 + ttt) + d
        else:
            c3 = min(c1 + oto, c2 + mincost2l) + d
            c4 = min(c1 + ott, c2 + ttt) + d
        
        c1 = c3
        
        c2 = c4
        
    #State of the program after the  for loop has been executed: `n` is the first integer from `str1` and must be greater than 0, `r1` is the second integer from `str1`, `r2` is the third integer from `str1`, `r3` is the fourth integer from `str1`, `d` is the fifth integer from `str1`, `r_1`, `r_2`, `r_3` are integers where 1 ≤ r_1 ≤ r_2 ≤ r_3 ≤ 10^9, `d` is an integer where 1 ≤ d ≤ 10^9, `a` is a map object containing integers converted from the elements of `str2`, `str1` is a list of strings split from the input line, `sys.stdout` is an instance of `io.BytesIO()`, a function is registered to write the content of `sys.stdout` to `sys.__stdout__` upon normal termination, `sys.stdin` is an instance of `io.BytesIO` initialized with the content of the original `sys.stdin`, and `input` is a function that reads a line from `sys.stdin` and returns it stripped of trailing newline characters, `str2` is a list of strings split from the input line read by `raw_input()`, `fs` is 0, `c1` is the minimum cost of the last segment plus the appropriate adjustments, `c2` is the minimum cost of the last segment plus the appropriate adjustments.
    ans = min(c1, c2) - d
    print(ans)


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
