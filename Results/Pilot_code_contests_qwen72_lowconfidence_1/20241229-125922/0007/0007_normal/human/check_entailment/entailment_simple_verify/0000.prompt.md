
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Easy and hard versions are actually different problems, so read statements of both problems completely and carefully.

Summer vacation has started so Alice and Bob want to play and joy, but... Their mom doesn't think so. She says that they have to read some amount of books before all entertainments. Alice and Bob will read each book together to end this exercise faster.

There are n books in the family library. The i-th book is described by three integers: t_i — the amount of time Alice and Bob need to spend to read it, a_i (equals 1 if Alice likes the i-th book and 0 if not), and b_i (equals 1 if Bob likes the i-th book and 0 if not).

So they need to choose some books from the given n books in such a way that:

  * Alice likes at least k books from the chosen set and Bob likes at least k books from the chosen set; 
  * the total reading time of these books is minimized (they are children and want to play and joy as soon a possible). 



The set they choose is the same for both Alice an Bob (it's shared between them) and they read all books together, so the total reading time is the sum of t_i over all books that are in the chosen set.

Your task is to help them and find any suitable set of books or determine that it is impossible to find such a set.

Input

The first line of the input contains two integers n and k (1 ≤ k ≤ n ≤ 2 ⋅ 10^5).

The next n lines contain descriptions of books, one description per line: the i-th line contains three integers t_i, a_i and b_i (1 ≤ t_i ≤ 10^4, 0 ≤ a_i, b_i ≤ 1), where:

  * t_i — the amount of time required for reading the i-th book; 
  * a_i equals 1 if Alice likes the i-th book and 0 otherwise; 
  * b_i equals 1 if Bob likes the i-th book and 0 otherwise. 

Output

If there is no solution, print only one integer -1. Otherwise print one integer T — the minimum total reading time of the suitable set of books.

Examples

Input

8 4
7 1 1
2 1 1
4 0 1
8 1 1
1 0 1
1 1 1
1 0 1
3 0 0


Output

18


Input

5 2
6 0 0
9 0 0
1 0 1
2 1 1
5 1 0


Output

8


Input

5 3
3 0 0
2 1 0
3 1 0
5 0 1
3 0 1


Output

-1
Program:
```
import sys
import math
from collections import defaultdict

def func():
    (n, k) = list(map(int, sys.stdin.readline().strip().split(' ')))
    t = []
    a = []
    b = []
    for _ in range(n):
        (ti, ai, bi) = list(map(int, sys.stdin.readline().strip().split(' ')))
        t.append(ti)
        a.append(ai)
        b.append(bi)
    alice_only = []
    alice = 0
    bob = 0
    bob_only = []
    taken = [0 for i in range(n)]
    ts = sorted(enumerate(t), key=lambda x: x[1])
    for (i, ti) in ts:
        if a[i] and b[i]:
            if alice == k and bob == k:
                if alice_only and bob_only:
                    if ti < alice_only[-1] + bob_only[-1]:
                        taken[alice_only.pop()] = 0
                        taken[bob_only.pop()] = 0
                        taken[i] = 1
                continue
            if alice == k:
                if alice_only:
                    j = alice_only.pop()
                    taken[j] = 0
            else:
                alice += 1
            if bob == k:
                if bob_only:
                    j = bob_only.pop()
                    taken[j] = 0
            else:
                bob += 1
            taken[i] = 1
            continue
        if a[i] and alice < k:
            alice += 1
            alice_only.append(i)
            taken[i] = 1
        if b[i] and bob < k:
            bob += 1
            bob_only.append(i)
            taken[i] = 1
    if alice != k or bob != k:
        print(-1)
    else:
        ans = 0
        for (i, ti) in ts:
            if taken[i]:
                ans += ti
        print(ans)


```
Original Assessment: Correctness: **False**.

Explanation: The provided program does not correctly handle the scenario where there are more than enough books that both Alice and Bob like, but also additional books that only one of them likes, which could potentially reduce the total reading time further.

For example, consider the following input:
```
8 4
7 1 1
2 1 1
4 0 1
8 1 1
1 0 1
1 1 1
1 0 1
3 0 0
```

In this case, the program outputs `18`, which is correct. However, consider a slightly modified input:
```
8 4
7 1 1
2 1 1
4 0 1
8 1 1
1 0 1
1 1 1
1 0 1
3 1 0
```

Here, the program still outputs `18`. However, the correct output should be `17` because the book with time `3` and liked by Alice can be included instead of one of the books with time `7` or `8`.

The issue arises because the program does not always replace a book that both Alice and Bob like with two books that only one of them likes, even if doing so would reduce the total reading time. This edge case demonstrates that the program does not always find the optimal solution.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
import sys
import math
from collections import defaultdict

#State of the program right berfore the function call: n and k are integers such that 1 ≤ k ≤ n ≤ 2 ⋅ 10^5. Each of the next n lines contains three integers t_i, a_i, and b_i, where 1 ≤ t_i ≤ 10^4 and 0 ≤ a_i, b_i ≤ 1.
def func():
    n, k = list(map(int, sys.stdin.readline().strip().split(' ')))
    t = []
    a = []
    b = []
    for _ in range(n):
        ti, ai, bi = list(map(int, sys.stdin.readline().strip().split(' ')))
        
        t.append(ti)
        
        a.append(ai)
        
        b.append(bi)
        
    #State of the program after the  for loop has been executed: `n` and `k` are integers read from the input, 1 ≤ k ≤ n ≤ 2 ⋅ 10^5, `t` is a list containing `n` elements where each element is an integer `ti` read from the input, `a` is a list containing `n` elements where each element is an integer `ai` read from the input, `b` is a list containing `n` elements where each element is an integer `bi` read from the input.
    alice_only = []
    alice = 0
    bob = 0
    bob_only = []
    taken = [(0) for i in range(n)]
    ts = sorted(enumerate(t), key=lambda x: x[1])
    for (i, ti) in ts:
        if a[i] and b[i]:
            if alice == k and bob == k:
                if alice_only and bob_only:
                    if ti < alice_only[-1] + bob_only[-1]:
                        taken[alice_only.pop()] = 0
                        taken[bob_only.pop()] = 0
                        taken[i] = 1
                continue
            if alice == k:
                if alice_only:
                    j = alice_only.pop()
                    taken[j] = 0
            else:
                alice += 1
            if bob == k:
                if bob_only:
                    j = bob_only.pop()
                    taken[j] = 0
            else:
                bob += 1
            taken[i] = 1
            continue
        
        if a[i] and alice < k:
            alice += 1
            alice_only.append(i)
            taken[i] = 1
        
        if b[i] and bob < k:
            bob += 1
            bob_only.append(i)
            taken[i] = 1
        
    #State of the program after the  for loop has been executed: `n` and `k` are integers with \(1 \leq k \leq n \leq 2 \cdot 10^5\), `t`, `a`, and `b` are lists containing `n` elements each. `alice` is the number of items chosen for Alice, and `bob` is the number of items chosen for Bob, both of which are at most `k`. `alice_only` is a list containing indices of items chosen exclusively for Alice, and `bob_only` is a list containing indices of items chosen exclusively for Bob. `taken` is a list of `n` integers where `taken[i]` is 1 if the item at index `i` has been chosen for either Alice or Bob, and 0 otherwise. If `alice` and `bob` are both `k`, and there are items that could potentially replace items in `alice_only` and `bob_only` to reduce the total time, such replacements have been made.
    if (alice != k or bob != k) :
        print(-1)
    else :
        ans = 0
        for (i, ti) in ts:
            if taken[i]:
                ans += ti
            
        #State of the program after the  for loop has been executed: `n` and `k` are integers with \(1 \leq k \leq n \leq 2 \cdot 10^5\), `t`, `a`, and `b` are lists containing `n` elements each, `alice` is `k`, `bob` is `k`, `alice_only` is a list containing indices of items chosen exclusively for Alice, `bob_only` is a list containing indices of items chosen exclusively for Bob, `taken` is a list of `n` integers where `taken[i]` is 1 if the item at index `i` has been chosen for either Alice or Bob, and 0 otherwise, `ans` is the sum of `ti` for all indices `i` in `ts` where `taken[i]` is 1. If `ts` is empty or no `i` in `ts` satisfies `taken[i] == 1`, `ans` remains 0.
        print(ans)
    #State of the program after the if-else block has been executed: *`n` and `k` are integers with \(1 \leq k \leq n \leq 2 \cdot 10^5\), `t`, `a`, and `b` are lists containing `n` elements each. `alice` is the number of items chosen for Alice, and `bob` is the number of items chosen for Bob, both of which are at most `k`. `alice_only` is a list containing indices of items chosen exclusively for Alice, and `bob_only` is a list containing indices of items chosen exclusively for Bob. `taken` is a list of `n` integers where `taken[i]` is 1 if the item at index `i` has been chosen for either Alice or Bob, and 0 otherwise. If `alice` is not equal to `k` or `bob` is not equal to `k`, `-1` has been printed. Otherwise, if `alice` and `bob` are both `k`, `ans` is the sum of `ti` for all indices `i` in `ts` where `taken[i]` is 1. If `ts` is empty or no `i` in `ts` satisfies `taken[i] == 1`, `ans` remains 0. The value of `ans` has been printed.


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
