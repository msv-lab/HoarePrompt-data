
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Hiasat registered a new account in NeckoForces and when his friends found out about that, each one of them asked to use his name as Hiasat's handle.

Luckily for Hiasat, he can change his handle in some points in time. Also he knows the exact moments friends will visit his profile page. Formally, you are given a sequence of events of two types:

  * 1 — Hiasat can change his handle. 
  * 2 s — friend s visits Hiasat's profile. 



The friend s will be happy, if each time he visits Hiasat's profile his handle would be s.

Hiasat asks you to help him, find the maximum possible number of happy friends he can get.

Input

The first line contains two integers n and m (1 ≤ n ≤ 10^5, 1 ≤ m ≤ 40) — the number of events and the number of friends.

Then n lines follow, each denoting an event of one of two types: 

  * 1 — Hiasat can change his handle. 
  * 2 s — friend s (1 ≤ |s| ≤ 40) visits Hiasat's profile. 



It's guaranteed, that each friend's name consists only of lowercase Latin letters.

It's guaranteed, that the first event is always of the first type and each friend will visit Hiasat's profile at least once.

Output

Print a single integer — the maximum number of happy friends.

Examples

Input


5 3
1
2 motarack
2 mike
1
2 light


Output


2


Input


4 3
1
2 alice
2 bob
2 tanyaromanova


Output


1

Note

In the first example, the best way is to change the handle to the "motarack" in the first event and to the "light" in the fourth event. This way, "motarack" and "light" will be happy, but "mike" will not.

In the second example, you can choose either "alice", "bob" or "tanyaromanova" and only that friend will be happy.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: The function `func` is expected to process inputs representing events and friends' names, where the number of events `n` and the number of friends `m` are integers within the ranges 1 ≤ n ≤ 10^5 and 1 ≤ m ≤ 40. The events consist of changes to Hiasat's handle and visits by friends, with each friend's name being a string of lowercase Latin letters and having a length of 1 to 40 characters. The first event is always a handle change, and each friend visits Hiasat's profile at least once.
def func():
    n, m = [int(x) for x in raw_input().split()]
    start_counting = 'NO'
    counter = {}
    final_cnt = 0
    for i in range(0, n):
        tmp_str = raw_input().split()
        
        state = int(tmp_str[0])
        
        if state == 1:
            if start_counting == 'YES':
                if len(counter):
                    final_cnt += max(counter.values())
                counter = {}
            start_counting = 'YES'
        else:
            frnd = tmp_str[1]
            if frnd in counter:
                counter[frnd] += 1
            else:
                counter[frnd] = 1
        
    #State of the program after the  for loop has been executed: `n` is an input integer, `m` is an input integer, `start_counting` is 'YES' if any `state` in the input lines was 1, otherwise it remains 'NO', `final_cnt` is the sum of the maximum values in `counter` each time `state` is 1 and `start_counting` is 'YES', `counter` is an empty dictionary if the last `state` is 1, otherwise it contains the counts of friends (if any) from the last segment of input where `start_counting` was 'YES', `tmp_str` is the list of the last input line split by spaces, `state` is the integer value of the last `tmp_str[0]`, and `frnd` is the last friend string from `tmp_str[1]` if `state` is not 1.
    if (start_counting == 'YES') :
        if len(counter) :
            final_cnt += max(counter.values())
        #State of the program after the if block has been executed: *`n` is an input integer, `m` is an input integer, `start_counting` is 'YES', `final_cnt` is the sum of the maximum values in `counter` each time `state` is 1 and `start_counting` is 'YES'. If `counter` is non-empty, `final_cnt` is updated to include the maximum value in `counter`, and `counter` remains a non-empty dictionary containing the counts of friends (if any) from the last segment of input where `start_counting` was 'YES'. `tmp_str` is the list of the last input line split by spaces, `state` is the integer value of the last `tmp_str[0]`, and `frnd` is the last friend string from `tmp_str[1]` if `state` is not 1.
    #State of the program after the if block has been executed: *`n` is an input integer, `m` is an input integer, `start_counting` is either 'YES' or 'NO', `final_cnt` is the sum of the maximum values in `counter` each time `state` is 1 and `start_counting` is 'YES'. If `start_counting` is 'YES', and `counter` is non-empty, `final_cnt` is updated to include the maximum value in `counter`, and `counter` remains a non-empty dictionary containing the counts of friends (if any) from the last segment of input where `start_counting` was 'YES'. `tmp_str` is the list of the last input line split by spaces, `state` is the integer value of the last `tmp_str[0]`, and `frnd` is the last friend string from `tmp_str[1]` if `state` is not 1. If `start_counting` is 'NO', `counter` is an empty dictionary, and `final_cnt` remains unchanged.
    print(final_cnt)

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
