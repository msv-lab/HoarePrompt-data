
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: An array of integers p_{1},p_{2}, …,p_{n} is called a permutation if it contains each number from 1 to n exactly once. For example, the following arrays are permutations: [3,1,2], [1], [1,2,3,4,5] and [4,3,1,2]. The following arrays are not permutations: [2], [1,1], [2,3,4].

There is a hidden permutation of length n.

For each index i, you are given s_{i}, which equals to the sum of all p_{j} such that j < i and p_{j} < p_{i}. In other words, s_i is the sum of elements before the i-th element that are smaller than the i-th element.

Your task is to restore the permutation.

Input

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^{5}) — the size of the permutation.

The second line contains n integers s_{1}, s_{2}, …, s_{n} (0 ≤ s_{i} ≤ (n(n-1))/(2)).

It is guaranteed that the array s corresponds to a valid permutation of length n.

Output

Print n integers p_{1}, p_{2}, …, p_{n} — the elements of the restored permutation. We can show that the answer is always unique.

Examples

Input


3
0 0 0


Output


3 2 1


Input


2
0 1


Output


1 2


Input


5
0 1 1 1 10


Output


1 4 3 2 5

Note

In the first example for each i there is no index j satisfying both conditions, hence s_i are always 0.

In the second example for i = 2 it happens that j = 1 satisfies the conditions, so s_2 = p_1.

In the third example for i = 2, 3, 4 only j = 1 satisfies the conditions, so s_2 = s_3 = s_4 = 1. For i = 5 all j = 1, 2, 3, 4 are possible, so s_5 = p_1 + p_2 + p_3 + p_4 = 10.
Program:
```
from sys import stdin, stdout
from collections import Counter, defaultdict
from itertools import permutations, combinations
#Function 1:
def func_1():
    return int(raw_input())

#Function 2:
def func_2():
    return map(int, raw_input().split())

#Function 3:
def func_3(n):
    stdout.write(str(n) + '\n')

#Function 4:
def func_4(arr):
    pr(' '.join(map(str, arr)) + '\n')

#Function 5:
def func_5():
    return map(int, stdin.read().split())

#Function 6:
def func_6(i):
    s = 0
    i = i + 1
    while i > 0:
        s += BITTree[i]
        i -= i & -i
    return s

#Function 7:
def func_7(i, v):
    i += 1
    while i <= n:
        BITTree[i] += v
        i += i & -i

#Function 8:
def func_8(x):
    ret = 0
    sm = 0
    for i in range(21, -1, -1):
        pw = 1 << i
        if ret + pw <= n and sm + BITTree[ret + pw] <= x:
            ret += pw
            sm += BITTree[ret]
    return ret


```
Original Assessment: Correctness: **False**

Explanation: The provided program is incomplete and does not contain the main logic required to solve the problem as described. Specifically, the functions `func_1` to `func_8` are defined but not used in a way that would solve the problem of restoring the permutation from the given sums. The program lacks the main function or loop that would read the input, process the data using the defined functions, and output the result. Therefore, the program does not meet the requirements of the problem description for any potential case.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import stdin, stdout
from collections import Counter, defaultdict
from itertools import permutations, combinations

raw_input = stdin.readline
pr = stdout.write
mod = 10 ** 9 + 7
range = xrange
n = func_1()
BITTree = [0] * (n + 1)
l = func_2()
for i in range(n):
    func_7(i, i)
ans = [0] * n
for i in range(n - 1, -1, -1):
    ans[i] = func_8(l[i])
    func_7(ans[i], -ans[i])
func_4(ans)

#Function 1:
#State of the program right berfore the function call: This function does not take any parameters and is intended to read an integer from standard input, which should represent the size of the permutation n where 1 ≤ n ≤ 2 ⋅ 10^{5}.
def func_1():
    return int(raw_input())
    #The program returns an integer that represents the size of the permutation n, where 1 ≤ n ≤ 2 ⋅ 10^{5}
#Overall this is what the function does:The function `func_1` does not accept any parameters. It reads an integer from standard input, which is expected to represent the size of a permutation `n` where 1 ≤ n ≤ 2 ⋅ 10^5. The function then returns this integer `n`. If the input is not a valid integer or is outside the specified range, the behavior is undefined.

#Function 2:
#State of the program right berfore the function call: None. This function does not take any parameters and is designed to read input from stdin, which is expected to be a space-separated string of integers.
def func_2():
    return map(int, raw_input().split())
    #The program returns an iterator that converts each element from a space-separated string of integers (read from stdin) into an integer.
#Overall this is what the function does:The function `func_2` reads a line of input from standard input (stdin), which is expected to be a space-separated string of integers. It then converts each substring in the split result into an integer and returns an iterator that yields these integers. If the input is not a valid space-separated string of integers, the function will raise a `ValueError`. The function does not handle any other types of input or edge cases, such as empty input or non-integer values.

#Function 3:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 ⋅ 10^{5}.
def func_3(n):
    stdout.write(str(n) + '\n')
#Overall this is what the function does:The function `func_3` accepts an integer `n` within the range 1 ≤ n ≤ 2 ⋅ 10^5. It writes the string representation of `n` followed by a newline character to the standard output (stdout). The function does not return any value. After the function executes, the string representation of `n` will have been printed to the console, and the program state will remain unchanged except for the side effect of the output.

#Function 4:
#State of the program right berfore the function call: arr is a list of integers representing the restored permutation.
def func_4(arr):
    pr(' '.join(map(str, arr)) + '\n')
#Overall this is what the function does:The function `func_4` accepts a parameter `arr`, which is a list of integers representing a restored permutation. It prints the elements of `arr` as a space-separated string followed by a newline character. The function does not return any value. After the function concludes, the list `arr` remains unchanged, and the only observable effect is the printed output. Potential edge cases include an empty `arr`, which would result in an empty line being printed, and non-integer elements in `arr`, which would be converted to strings and included in the output.

#Function 5:
#State of the program right berfore the function call: None of the variables in the function signature are used, as the function `func_5` does not take any parameters.
def func_5():
    return map(int, stdin.read().split())
    #The program returns a map object that applies the `int` function to each element in the list obtained by splitting the input read from `stdin` by whitespace.
#Overall this is what the function does:The function `func_5` does not accept any parameters. It reads a line of input from standard input (`stdin`), splits the input string by whitespace, and returns a map object that applies the `int` function to each element of the resulting list. The returned map object can be iterated over to obtain the converted integers. If the input contains non-integer values, the `int` function will raise a `ValueError`. If no input is provided, the function will return a map object that can be iterated over, but it will yield no elements.

#Function 6:
#State of the program right berfore the function call: i is a non-negative integer such that 0 <= i < n, where n is the length of the permutation.
def func_6(i):
    s = 0
    i = i + 1
    while i > 0:
        s += BITTree[i]
        
        i -= i & -i
        
    #State of the program after the loop has been executed: `i` is 0, `s` is the sum of `BITTree[j]` for all `j` in the sequence generated by repeatedly subtracting `j & -j` from the initial value of `i` until `i` becomes 0, `n` is the length of the permutation
    return s
    #The program returns the sum of `BITTree[j]` for all `j` in the sequence generated by repeatedly subtracting `j & -j` from the initial value of `i` (which is 0) until `i` becomes 0. Since `i` starts at 0 and the operation `j & -j` would not change it (as 0 & -0 is 0), the sequence does not generate any valid indices for `BITTree`, and thus `s` remains 0. Therefore, the program returns 0.
#Overall this is what the function does:The function `func_6` takes a non-negative integer `i` as input, where `0 <= i < n` and `n` is the length of the `BITTree` array. It returns the sum of elements in `BITTree` starting from index `i+1` and moving backwards by repeatedly subtracting `i & -i` until `i` becomes 0. If `i` is 0, the function will return 0 because no valid indices will be generated. For any other valid input, the function will return the cumulative sum of the specified elements in `BITTree`. The function does not modify any external state or variables.

#Function 7:
#State of the program right berfore the function call: i is a non-negative integer, v is an integer, and n is a positive integer such that 0 <= i <= n.
def func_7(i, v):
    i += 1
    while i <= n:
        BITTree[i] += v
        
        i += i & -i
        
    #State of the program after the loop has been executed: `i` is the smallest value greater than `n` that can be reached by repeatedly adding `i & -i` to the initial value of `i`, `v` is an integer, `n` is a positive integer such that `0 <= i-1 <= n`, `BITTree[i_initial]`, `BITTree[i_initial + (i_initial & -i_initial)]`, `BITTree[i_initial + 2 * (i_initial & -i_initial)]`, etc., up to the last valid index, are each incremented by `v`.
#Overall this is what the function does:The function `func_7(i, v)` accepts two parameters: `i`, a non-negative integer, and `v`, an integer. It increments the values in a Binary Indexed Tree (BITTree) starting from index `i` (after incrementing `i` by 1) until `i` exceeds `n`. The function updates the BITTree by adding `v` to the elements at indices `i`, `i + (i & -i)`, `i + 2 * (i & -i)`, and so on, up to the largest valid index within the range `[1, n]`. After the function completes, the state of the program is such that the BITTree has been updated with the specified increments, and `i` is the smallest value greater than `n` that can be reached by repeatedly adding `i & -i` to the initial value of `i`. The function does not return any value. Edge cases to consider include when `i` is already greater than `n` before the loop starts, in which case no updates are made to the BITTree.

#Function 8:
#State of the program right berfore the function call: x is a non-negative integer such that 0 ≤ x ≤ (n(n-1))/2, and n is a positive integer indicating the size of the permutation. BITTree is a list of integers initialized to represent a Binary Indexed Tree (BIT) or Fenwick Tree, where BITTree[i] stores the sum of a segment of the array.
def func_8(x):
    ret = 0
    sm = 0
    for i in range(21, -1, -1):
        pw = 1 << i
        
        if ret + pw <= n and sm + BITTree[ret + pw] <= x:
            ret += pw
            sm += BITTree[ret]
        
    #State of the program after the  for loop has been executed: `x` is a non-negative integer such that \(0 \leq x \leq \frac{n(n-1)}{2}\), `n` is a positive integer indicating the size of the permutation, `BITTree` is a list of integers representing a Binary Indexed Tree (BIT) or Fenwick Tree, `ret` is the largest integer such that the sum of the prefix sums up to `ret` in the `BITTree` is less than or equal to `x`, `sm` is the sum of the prefix sums up to `ret` in the `BITTree`, `i` is -1, `pw` is 1.
    return ret
    #The program returns `ret`, which is the largest integer such that the sum of the prefix sums up to `ret` in the `BITTree` is less than or equal to `x`. Here, `x` is a non-negative integer within the range \(0 \leq x \leq \frac{n(n-1)}{2}\), `n` is a positive integer indicating the size of the permutation, and `BITTree` is a list of integers representing a Binary Indexed Tree (BIT) or Fenwick Tree.
#Overall this is what the function does:The function `func_8` takes a non-negative integer `x` within the range \(0 \leq x \leq \frac{n(n-1)}{2}\) and returns the largest integer `ret` such that the sum of the prefix sums up to `ret` in the `BITTree` is less than or equal to `x`. The `BITTree` is a list of integers representing a Binary Indexed Tree (BIT) or Fenwick Tree. The function iterates through powers of 2 from 2^20 down to 2^0, checking if adding the current power to `ret` and the corresponding value in `BITTree` would still keep the sum `sm` within the limit `x`. If so, it updates `ret` and `sm` accordingly. The function ensures that `ret` is the largest possible value satisfying the condition, and the final state of the program includes `x` remaining unchanged, `n` unchanged, and `BITTree` unchanged. Edge cases include when `x` is 0 (resulting in `ret` being 0) and when `x` is the maximum possible value (resulting in `ret` being the largest index in `BITTree` that satisfies the condition).



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
