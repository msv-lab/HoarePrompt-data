
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: One day Mr. Takahashi picked up a dictionary containing all of the N! permutations of integers 1 through N. The dictionary has N! pages, and page i (1 ≤ i ≤ N!) contains the i-th permutation in the lexicographical order.

Mr. Takahashi wanted to look up a certain permutation of length N in this dictionary, but he forgot some part of it.

His memory of the permutation is described by a sequence P_1, P_2, ..., P_N. If P_i = 0, it means that he forgot the i-th element of the permutation; otherwise, it means that he remembered the i-th element of the permutation and it is P_i.

He decided to look up all the possible permutations in the dictionary. Compute the sum of the page numbers of the pages he has to check, modulo 10^9 + 7.

Constraints

* 1 ≤ N ≤ 500000
* 0 ≤ P_i ≤ N
* P_i ≠ P_j if i ≠ j (1 ≤ i, j ≤ N), P_i ≠ 0 and P_j ≠ 0.

Input

The input is given from Standard Input in the following format:


N
P_1 P_2 ... P_N


Output

Print the sum of the page numbers of the pages he has to check, as modulo 10^9 + 7.

Examples

Input

4
0 2 3 0


Output

23


Input

3
0 0 0


Output

21


Input

5
1 2 3 5 4


Output

2


Input

1
0


Output

1


Input

10
0 3 0 0 1 0 4 0 0 0


Output

953330050
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
N = int(raw_input())
a = [int(x) - 1 for x in raw_input().split()]
weight = [1] * N
M = 10 ** 9 + 7
for i in xrange(N - 1):
    weight[N - 2 - i] = weight[N - 1 - i] * (i + 1) % M
missing = list(set(xrange(N)) - set(a))
missing.sort()
n_missing = len(missing)
sum_missing = sum(missing)
avg_missing = sum_missing * func_2(n_missing)
n_present = N - n_missing
n_rows = func_1(n_missing)
acc = 0
i_missing = 0
i_present = 0
missing_lt_tot = 0
for (i, (w, x)) in enumerate(zip(weight, a)):
    if x == -1:
        ai = avg_missing
        bi = i_missing * func_2(2) + i_present - missing_lt_tot * func_2(n_missing)
        i_missing += 1
    else:
        ai = x
        bi = 0
        for j in xrange(i):
            if a[j] != -1 and a[j] < a[i]:
                bi += 1
        missing_lt = 0
        for j in missing:
            if j < a[i]:
                missing_lt += 1
        missing_lt_tot += missing_lt
        bi += missing_lt * func_2(n_missing) * i_missing
        coeff = 1
        i_present += 1
    acc = (acc + (ai - bi) * n_rows * w) % M
print(acc + n_rows) % M

#Function 1:
#State of the program right berfore the function call: n is a non-negative integer such that 0 <= n <= 500000, and M is a constant integer equal to 10^9 + 7.
def func_1(n):
    acc = 1
    for i in xrange(1, 1 + n):
        acc = acc * i % M
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer such that 0 <= `n` <= 500000, `M` is a constant integer equal to \(10^9 + 7\), `acc` is the factorial of `n` modulo \(10^9 + 7\)
    return acc
    #The program returns `acc`, which is the factorial of `n` modulo \(10^9 + 7\), where `n` is a non-negative integer such that 0 <= `n` <= 500000.

#Function 2:
#State of the program right berfore the function call: n is an integer, and M is an integer greater than 2.
def func_2(n):
    return pow(n, M - 2, M)
    #The program returns the result of n raised to the power of (M - 2), modulo M, where n is an integer, and M is an integer greater than 2.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
