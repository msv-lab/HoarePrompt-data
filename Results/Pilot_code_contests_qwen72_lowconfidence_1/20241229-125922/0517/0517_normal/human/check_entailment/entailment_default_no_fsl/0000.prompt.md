
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and the description of program's output. If the program is correct, that is it meets the requirements in the problem description,  print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the Output hints to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
The output hints summarise the code functionality and might give you examples of some of the cases that the code is not working corectly, but make sure the hints agree with the code.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: One day Mr. Takahashi picked up a dictionary containing all of the N! permutations of integers 1 through N. The dictionary has N! pages, and page i (1 ≤ i ≤ N!) contains the i-th permutation in the lexicographical order.

Mr. Takahashi wanted to look up a certain permutation of length N in this dictionary, but he forgot some part of it.

His memory of the permutation is described by a sequence P_1, P_2, ..., P_N. If P_i = 0, it means that he forgot the i-th element of the permutation; otherwise, it means that he remembered the i-th element of the permutation and it is P_i.

He decided to look up all the possible permutations in the dictionary. Compute the sum of the page numbers of the pages he has to check, modulo 10^9 + 7.

Constraints

* 1 ≤ N ≤ 500000
* 0 ≤ P_i ≤ N
* P_i ≠ P_j if i ≠ j (1 ≤ i, j ≤ N), P_i ≠ 0 and P_j ≠ 0.

Input

The input is given from Standard Input in the following format:


N
P_1 P_2 ... P_N


Output

Print the sum of the page numbers of the pages he has to check, as modulo 10^9 + 7.

Examples

Input

4
0 2 3 0


Output

23


Input

3
0 0 0


Output

21


Input

5
1 2 3 5 4


Output

2


Input

1
0


Output

1


Input

10
0 3 0 0 1 0 4 0 0 0


Output

953330050
Functions with output description for each function:
N = int(raw_input())
a = [int(x) - 1 for x in raw_input().split()]
weight = [1] * N
M = 10 ** 9 + 7
for i in xrange(N - 1):
    weight[N - 2 - i] = weight[N - 1 - i] * (i + 1) % M
missing = list(set(xrange(N)) - set(a))
missing.sort()
n_missing = len(missing)
sum_missing = sum(missing)
avg_missing = sum_missing * func_2(n_missing)
n_present = N - n_missing
n_rows = func_1(n_missing)
acc = 0
i_missing = 0
i_present = 0
missing_lt_tot = 0
for (i, (w, x)) in enumerate(zip(weight, a)):
    if x == -1:
        ai = avg_missing
        bi = i_missing * func_2(2) + i_present - missing_lt_tot * func_2(n_missing)
        i_missing += 1
    else:
        ai = x
        bi = 0
        for j in xrange(i):
            if a[j] != -1 and a[j] < a[i]:
                bi += 1
        missing_lt = 0
        for j in missing:
            if j < a[i]:
                missing_lt += 1
        missing_lt_tot += missing_lt
        bi += missing_lt * func_2(n_missing) * i_missing
        coeff = 1
        i_present += 1
    acc = (acc + (ai - bi) * n_rows * w) % M
print(acc + n_rows) % M

Function number 1 :
 Code:
 '''
def func_1(n):
    acc = 1
    for i in xrange(1, 1 + n):
        acc = acc * i % M
    return acc
''' 

 Output hints for function1:  The function `func_1` accepts a non-negative integer `n` such that 0 <= `n` <= 500000. It computes the factorial of `n` modulo \(10^9 + 7\) and returns this value. The function ensures that the result is always within the range [0, \(10^9 + 7\) - 1]. Edge cases are handled correctly, including when `n` is 0, in which case the function returns 1 (since 0! is defined as 1).
Function number 2 :
 Code:
 '''
def func_2(n):
    return pow(n, M - 2, M)
''' 

 Output hints for function2:  The function `func_2` accepts a single parameter `n`, which is an integer. It implicitly assumes another parameter `M` is defined outside the function, where `M` is an integer greater than 2. The function returns the result of `n` raised to the power of `(M - 2)`, modulo `M`. 

However, the function definition only includes `n` as a parameter, and `M` is not passed explicitly. This can lead to issues if `M` is not defined or is not an integer greater than 2 before calling the function. If `M` is not properly defined, the function will raise an error. Additionally, if `M` is 2 or less, the behavior of the function is undefined because the modulo operation might not behave as expected.



Does the code do what  the problem description says,  for every potential case?
If the program does not follow the problem description for every potential case then  then Correctness **False**. The hints might provide such cases but make sure that the hints indeed agree with the code. Also the program description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.