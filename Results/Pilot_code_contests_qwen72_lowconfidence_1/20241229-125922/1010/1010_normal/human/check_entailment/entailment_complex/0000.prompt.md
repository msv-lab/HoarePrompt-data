
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Fox Ciel is playing a mobile puzzle game called "Two Dots". The basic levels are played on a board of size n × m cells, like this:

<image>

Each cell contains a dot that has some color. We will use different uppercase Latin characters to express different colors.

The key of this game is to find a cycle that contain dots of same color. Consider 4 blue dots on the picture forming a circle as an example. Formally, we call a sequence of dots d1, d2, ..., dk a cycle if and only if it meets the following condition:

  1. These k dots are different: if i ≠ j then di is different from dj. 
  2. k is at least 4. 
  3. All dots belong to the same color. 
  4. For all 1 ≤ i ≤ k - 1: di and di + 1 are adjacent. Also, dk and d1 should also be adjacent. Cells x and y are called adjacent if they share an edge. 



Determine if there exists a cycle on the field.

Input

The first line contains two integers n and m (2 ≤ n, m ≤ 50): the number of rows and columns of the board.

Then n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter.

Output

Output "Yes" if there exists a cycle, and "No" otherwise.

Examples

Input

3 4
AAAA
ABCA
AAAA


Output

Yes


Input

3 4
AAAA
ABCA
AADA


Output

No


Input

4 4
YYYR
BYBY
BBBY
BBBY


Output

Yes


Input

7 6
AAAAAB
ABBBAB
ABAAAB
ABABBB
ABAAAB
ABBBAB
AAAAAB


Output

Yes


Input

2 13
ABCDEFGHIJKLM
NOPQRSTUVWXYZ


Output

No

Note

In first sample test all 'A' form a cycle.

In second sample there is no such cycle.

The third sample is displayed on the picture above ('Y' = Yellow, 'B' = Blue, 'R' = Red).
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
(n, m) = map(int, raw_input().split())
l = [raw_input() for i in xrange(n)]
res = False
row = 0
while row < n and (not res):
    for column in xrange(m):
        conj = set()
        tmp = func_1(True, l[row][column], l, row, column, n, m, row, column, row, column, conj)
        if tmp:
            res = True
            break
    row += 1
if res:
    print('Yes')
else:
    print('No')

#State of the program right berfore the function call: first is a boolean, let is a character, l is a list of strings, x, y, xInit, yInit, xAnt, yAnt are integers, n and m are integers such that 2 <= n, m <= 50, and conj is a set or list.
def func_1(first, let, l, x, y, n, m, xInit, yInit, xAnt, yAnt, conj):
    if (not (x >= 0 and x < n and y >= 0 and y < m) or (x, y) in conj) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: first is a boolean, let is a character, l is a list of strings, x, y, xInit, yInit, xAnt, yAnt are integers, n and m are integers such that 2 <= n, m <= 50, and conj is a set or list. Additionally, x is greater than or equal to 0 and less than n, y is greater than or equal to 0 and less than m, and (x, y) is not in conj.
    if (x == xInit and y == yInit and len(conj) > 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: first is a boolean, let is a character, l is a list of strings, x, y, xInit, yInit, xAnt, yAnt are integers, n and m are integers such that 2 <= n, m <= 50, and conj is a set or list. Additionally, x is greater than or equal to 0 and less than n, y is greater than or equal to 0 and less than m, and (x, y) is not in conj. Either x is not equal to xInit, or y is not equal to yInit, or the length of conj is less than or equal to 3.
    if (l[x][y] == let) :
        if (not first) :
            conj.add((x, y))
        #State of the program after the if block has been executed: *first is a boolean, let is a character, l is a list of strings, x, y, xInit, yInit, xAnt, yAnt are integers, n and m are integers such that 2 <= n, m <= 50, and conj is a set or list. Additionally, x is greater than or equal to 0 and less than n, y is greater than or equal to 0 and less than m, and (x, y) is not in conj. Either x is not equal to xInit, or y is not equal to yInit, or the length of conj is less than or equal to 3. The current value of `l[x][y]` is equal to `let`. If `first` is false, (x, y) is added to conj, and the length of conj is less than or equal to 4.
        cima = False
        if (y - 1 != yAnt) :
            cima = func_1(False, let, l, x, y - 1, n, m, xInit, yInit, x, y, conj)
        #State of the program after the if block has been executed: *`first` is a boolean, `let` is a character, `l` is a list of strings, `x`, `y`, `xInit`, `yInit`, `xAnt`, `yAnt` are integers, `n` and `m` are integers such that 2 <= `n`, `m` <= 50, and `conj` is a set or list. Additionally, `x` is greater than or equal to 0 and less than `n`, `y` is greater than or equal to 0 and less than `m`, and (`x`, `y`) is not in `conj`. Either `x` is not equal to `xInit`, or `y` is not equal to `yInit`, or the length of `conj` is less than or equal to 3. The current value of `l[x][y]` is equal to `let`. If `first` is false, (`x`, `y`) is added to `conj`, and the length of `conj` is less than or equal to 4. `cima` is False. If `y - 1` is not equal to `yAnt`, `cima` is the return value of `func_1(False, let, l, x, y - 1, n, m, xInit, yInit, x, y, conj)`. Otherwise, `cima` remains False.
        direita = False
        if (x + 1 != xAnt) :
            direita = func_1(False, let, l, x + 1, y, n, m, xInit, yInit, x, y, conj)
        #State of the program after the if block has been executed: *`first` is a boolean, `let` is a character, `l` is a list of strings, `x`, `y`, `xInit`, `yInit`, `xAnt`, `yAnt` are integers, `n` and `m` are integers such that 2 <= `n`, `m` <= 50, and `conj` is a set or list. Additionally, `x` is greater than or equal to 0 and less than `n`, `y` is greater than or equal to 0 and less than `m`, and (`x`, `y`) is not in `conj`. Either `x` is not equal to `xInit`, or `y` is not equal to `yInit`, or the length of `conj` is less than or equal to 3. The current value of `l[x][y]` is equal to `let`. If `first` is false, (`x`, `y`) is added to `conj`, and the length of `conj` is less than or equal to 4. `cima` is False. If `x + 1` is not equal to `xAnt`, `direita` is the return value of `func_1(False, let, l, x + 1, y, n, m, xInit, yInit, x, y, conj)`. Otherwise, `direita` remains unchanged.
        baixo = False
        if (y + 1 != yAnt) :
            baixo = func_1(False, let, l, x, y + 1, n, m, xInit, yInit, x, y, conj)
        #State of the program after the if block has been executed: *`first` is a boolean, `let` is a character, `l` is a list of strings, `x`, `y`, `xInit`, `yInit`, `xAnt`, `yAnt` are integers, `n` and `m` are integers such that 2 <= `n`, `m` <= 50, and `conj` is a set or list. Additionally, `x` is greater than or equal to 0 and less than `n`, `y` is greater than or equal to 0 and less than `m`, and (`x`, `y`) is not in `conj`. Either `x` is not equal to `xInit`, or `y` is not equal to `yInit`, or the length of `conj` is less than or equal to 3. The current value of `l[x][y]` is equal to `let`. If `first` is false, (`x`, `y`) is added to `conj`, and the length of `conj` is less than or equal to 4. `cima` is False. If `y + 1` is not equal to `yAnt`, `baixo` is the return value of `func_1(False, let, l, x, y + 1, n, m, xInit, yInit, x, y, conj)`. If `x + 1` is not equal to `xAnt`, `direita` is the return value of `func_1(False, let, l, x + 1, y, n, m, xInit, yInit, x, y, conj)`. Otherwise, `direita` remains unchanged.
        esquerda = False
        if (x - 1 != xAnt) :
            esquerda = func_1(False, let, l, x - 1, y, n, m, xInit, yInit, x, y, conj)
        #State of the program after the if block has been executed: *`first` is a boolean, `let` is a character, `l` is a list of strings, `x`, `y`, `xInit`, `yInit`, `xAnt`, `yAnt` are integers, `n` and `m` are integers such that 2 <= `n`, `m` <= 50, and `conj` is a set or list. Additionally, `x` is greater than or equal to 0 and less than `n`, `y` is greater than or equal to 0 and less than `m`, and (`x`, `y`) is not in `conj`. Either `x` is not equal to `xInit`, or `y` is not equal to `yInit`, or the length of `conj` is less than or equal to 3. The current value of `l[x][y]` is equal to `let`. If `first` is false, (`x`, `y`) is added to `conj`, and the length of `conj` is less than or equal to 4. `cima` is False. If `y + 1` is not equal to `yAnt`, `baixo` is the return value of `func_1(False, let, l, x, y + 1, n, m, xInit, yInit, x, y, conj)`. If `x + 1` is not equal to `xAnt`, `direita` is the return value of `func_1(False, let, l, x + 1, y, n, m, xInit, yInit, x, y, conj)`. If `x - 1` is not equal to `xAnt`, `esquerda` is the return value of `func_1(False, let, l, x - 1, y, n, m, xInit, yInit, x, y, conj)`. Otherwise, `esquerda` is False.
        return cima or baixo or direita or esquerda
        #The program returns the logical OR of `cima`, `baixo`, `direita`, and `esquerda`. `cima` is False. `baixo` is the return value of `func_1(False, let, l, x, y + 1, n, m, xInit, yInit, x, y, conj)` if `y + 1` is not equal to `yAnt`. `direita` is the return value of `func_1(False, let, l, x + 1, y, n, m, xInit, yInit, x, y, conj)` if `x + 1` is not equal to `xAnt`. `esquerda` is the return value of `func_1(False, let, l, x - 1, y, n, m, xInit, yInit, x, y, conj)` if `x - 1` is not equal to `xAnt`; otherwise, `esquerda` is False.
    else :
        return False
        #The program returns False
#Overall this is what the function does:The function `func_1` checks if a path exists in a grid `l` starting from coordinates `(x, y)` to the initial coordinates `(xInit, yInit)` while avoiding previously visited cells stored in `conj`. The function returns `True` if such a path exists, and `False` otherwise. Here are the key points:

1.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
