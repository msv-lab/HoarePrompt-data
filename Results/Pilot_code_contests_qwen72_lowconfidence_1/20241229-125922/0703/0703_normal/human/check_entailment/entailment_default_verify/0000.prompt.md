
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Tanya wants to go on a journey across the cities of Berland. There are n cities situated along the main railroad line of Berland, and these cities are numbered from 1 to n. 

Tanya plans her journey as follows. First of all, she will choose some city c_1 to start her journey. She will visit it, and after that go to some other city c_2 > c_1, then to some other city c_3 > c_2, and so on, until she chooses to end her journey in some city c_k > c_{k - 1}. So, the sequence of visited cities [c_1, c_2, ..., c_k] should be strictly increasing.

There are some additional constraints on the sequence of cities Tanya visits. Each city i has a beauty value b_i associated with it. If there is only one city in Tanya's journey, these beauty values imply no additional constraints. But if there are multiple cities in the sequence, then for any pair of adjacent cities c_i and c_{i + 1}, the condition c_{i + 1} - c_i = b_{c_{i + 1}} - b_{c_i} must hold.

For example, if n = 8 and b = [3, 4, 4, 6, 6, 7, 8, 9], there are several three possible ways to plan a journey:

  * c = [1, 2, 4]; 
  * c = [3, 5, 6, 8]; 
  * c = [7] (a journey consisting of one city is also valid). 



There are some additional ways to plan a journey that are not listed above.

Tanya wants her journey to be as beautiful as possible. The beauty value of the whole journey is the sum of beauty values over all visited cities. Can you help her to choose the optimal plan, that is, to maximize the beauty value of the journey?

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the number of cities in Berland.

The second line contains n integers b_1, b_2, ..., b_n (1 ≤ b_i ≤ 4 ⋅ 10^5), where b_i is the beauty value of the i-th city.

Output

Print one integer — the maximum beauty of a journey Tanya can choose.

Examples

Input


6
10 7 1 9 10 15


Output


26


Input


1
400000


Output


400000


Input


7
8 9 26 11 12 29 14


Output


55

Note

The optimal journey plan in the first example is c = [2, 4, 5].

The optimal journey plan in the second example is c = [1].

The optimal journey plan in the third example is c = [3, 6].
Program:
```
import sys

def func():
    input = sys.stdin.readline
    n = int(input())
    seq = sorted(((int(x) - i, int(x)) for (i, x) in enumerate(input().split())), key=lambda x: x[0])
    d = dict()
    ans = 0
    ansb = 0
    for (g, val) in seq:
        try:
            d[abs(g)] += val
        except:
            d[abs(g)] = val
        ans = max(ans, d[abs(g)])
        ansb = max(val, ansb)
    if ans == 0:
        ans = ansb
    print(ans)


```
Original Assessment: Correctness: **False**.

Explanation:
The provided solution has a logical flaw that can lead to incorrect results in certain cases. Specifically, the way the dictionary `d` is used to accumulate the beauty values might not correctly handle all scenarios where the condition \(c_{i + 1} - c_i = b_{c_{i + 1}} - b_{c_i}\) must hold.

Here's a potential case where the program fails:

**Input:**
```
6
10 7 1 9 10 15
```

**Expected Output:**
```
26
```

**Actual Output:**
The program may output a different value because it incorrectly accumulates the beauty values in the dictionary `d`.

The issue lies in how the dictionary `d` is updated and used. The program sorts the cities based on the difference \( \text{val} - \text{i} \) and then tries to accumulate the beauty values. However, this approach does not ensure that the sequence of cities is strictly increasing and that the condition \(c_{i + 1} - c_i = b_{c_{i + 1}} - b_{c_i}\) is always satisfied.

To illustrate, consider the sequence of cities and their beauty values:
- City 1: \(b_1 = 10\)
- City 2: \(b_2 = 7\)
- City 3: \(b_3 = 1\)
- City 4: \(b_4 = 9\)
- City 5: \(b_5 = 10\)
- City 6: \(b_6 = 15\)

The optimal journey is `[2, 4, 5]` with a total beauty of \(7 + 9 + 10 = 26\). However, the program might not correctly identify this sequence due to the way it accumulates the beauty values in the dictionary.

Thus, the program is incorrect for this specific case and potentially others.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: The function reads a positive integer `n` (1 ≤ n ≤ 2 ⋅ 10^5) and a list `b` of `n` integers (1 ≤ b_i ≤ 4 ⋅ 10^5) from standard input. It then processes these inputs to compute the maximum cumulative value associated with the absolute difference between the elements of `b` and their indices. Specifically, it creates a dictionary `d` where each key is the absolute difference (`|b_i - i|`) and the value is the cumulative sum of the corresponding `b_i` values. The function outputs the maximum value found in this dictionary. If no cumulative value is found (i.e., `ans` is 0), it outputs the maximum individual value from the list `b`. The final state of the program includes the original `n`, the original list `b`, the dictionary `d`, and the computed maximum value `ans`.

Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
