
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: A famous Berland's painter Kalevitch likes to shock the public. One of his last obsessions is chess. For more than a thousand years people have been playing this old game on uninteresting, monotonous boards. Kalevitch decided to put an end to this tradition and to introduce a new attitude to chessboards.

As before, the chessboard is a square-checkered board with the squares arranged in a 8 × 8 grid, each square is painted black or white. Kalevitch suggests that chessboards should be painted in the following manner: there should be chosen a horizontal or a vertical line of 8 squares (i.e. a row or a column), and painted black. Initially the whole chessboard is white, and it can be painted in the above described way one or more times. It is allowed to paint a square many times, but after the first time it does not change its colour any more and remains black. Kalevitch paints chessboards neatly, and it is impossible to judge by an individual square if it was painted with a vertical or a horizontal stroke.

Kalevitch hopes that such chessboards will gain popularity, and he will be commissioned to paint chessboards, which will help him ensure a comfortable old age. The clients will inform him what chessboard they want to have, and the painter will paint a white chessboard meeting the client's requirements.

It goes without saying that in such business one should economize on everything — for each commission he wants to know the minimum amount of strokes that he has to paint to fulfill the client's needs. You are asked to help Kalevitch with this task.

Input

The input file contains 8 lines, each of the lines contains 8 characters. The given matrix describes the client's requirements, W character stands for a white square, and B character — for a square painted black.

It is guaranteed that client's requirments can be fulfilled with a sequence of allowed strokes (vertical/column or horizontal/row).

Output

Output the only number — the minimum amount of rows and columns that Kalevitch has to paint on the white chessboard to meet the client's requirements.

Examples

Input

WWWBWWBW
BBBBBBBB
WWWBWWBW
WWWBWWBW
WWWBWWBW
WWWBWWBW
WWWBWWBW
WWWBWWBW


Output

3


Input

WWWWWWWW
BBBBBBBB
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW


Output

1
Program:
```
import sys
#Function 1:
def func_1(col_num):
    painted_by_rows = True
    for (row_num, x) in enumerate(board):
        if x[col_num] != True:
            return False
        painted_by_rows = painted_by_rows and painted_rows[row_num]
    return True and (not painted_by_rows)

#Function 2:
def func_2():
    for y in xrange(8):
        board.append([True if x == 'B' else False for x in raw_input()])
    strokes = 0
    for (row_num, row) in enumerate(board):
        if all(row):
            strokes += 1
            painted_rows[row_num] = True
    for col_num in xrange(8):
        if func_1(col_num):
            strokes += 1
            painted_cols[col_num] = True
    print(strokes)


```
Original Assessment: Correctness: **False**.

Explanation:
The provided program has a few issues that make it incorrect for certain inputs:

1. **Use of `xrange`**: The function `xrange` is specific to Python 2. In Python 3, `range` should be used instead. This would cause the program to fail in Python 3 environments.

2. **Handling of Input**: The program uses `raw_input()` to read input, which is also specific to Python 2. In Python 3, `input()` should be used instead.

3. **Logic for Painting Columns**: The function `func_1` checks if a column is completely painted black, but it also checks if the column was painted by rows. This logic is unnecessary and can lead to incorrect results if the board is painted in a way that both rows and columns overlap.

4. **Initialization of `painted_rows` and `painted_cols`**: These lists are not initialized before being used, which will cause a runtime error.

5. **Edge Case Handling**: The program does not handle edge cases where the entire board is already painted black or where no black squares are present. These cases should be handled explicitly to ensure the program works correctly for all possible inputs.

To make the program correct, these issues need to be addressed. Here is a corrected version of the program:

```python
def func_1(col_num):
    painted_by_rows = True
    for (row_num, x) in enumerate(board):
        if x[col_num] != True:
            return False
        painted_by_rows = painted_by_rows and painted_rows[row_num]
    return True and (not painted_by_rows)

def func_2():
    global board, painted_rows, painted_cols
    board = []
    painted_rows = [False] * 8
    painted_cols = [False] * 8
    strokes = 0
    for _ in range(8):
        board.append([True if x == 'B' else False for x in input().strip()])
    
    for (row_num, row) in enumerate(board):
        if all(row):
            strokes += 1
            painted_rows[row_num] = True
    
    for col_num in range(8):
        if func_1(col_num):
            strokes += 1
            painted_cols[col_num] = True
    
    print(strokes)

# Example usage:
# func_2()
```

This corrected version initializes the `painted_rows` and `painted_cols` lists, uses `input()` for reading input, and removes the unnecessary check for painting by rows in `func_1`. With these changes, the program should work correctly for all valid inputs.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
import sys

sys.setrecursionlimit(2 ** 15)
board = []
painted_rows = [False] * 8
painted_cols = [False] * 8
func_2()

#Function 1:
#State of the program right berfore the function call: col_num is an integer representing a column index in the board, where 0 <= col_num < 8. board is a 2D list of booleans with dimensions 8x8, where True represents a black square and False represents a white square. painted_rows is a list of booleans with length 8, where True indicates that the corresponding row has been painted black.
def func_1(col_num):
    painted_by_rows = True
    for (row_num, x) in enumerate(board):
        if x[col_num] != True:
            return False
        
        painted_by_rows = painted_by_rows and painted_rows[row_num]
        
    #State of the program after the  for loop has been executed: `col_num` is an integer with \(0 \leq \text{col_num} < 8\), `board` is a 2D list of booleans with dimensions 8x8, `painted_rows` is a list of booleans with length 8, `painted_by_rows` is the logical AND of all elements in `painted_rows`, `row_num` is 7, `x` is the last row of `board`, and `x[col_num]` is `board[7][col_num]`. If any `x[col_num]` is not True, the program returns False. If the loop does not execute (which would only happen if `board` is empty, but it is given that `board` is 8x8), `painted_by_rows` remains True.
    return True and not painted_by_rows
    #The program returns the result of `True and not painted_by_rows`, where `painted_by_rows` is the logical AND of all elements in `painted_rows`, a list of booleans with length 8.
#Overall this is what the function does:The function `func_1` takes a single parameter `col_num`, which is an integer representing a column index in a 2D list `board` of booleans with dimensions 8x8. The function checks if all cells in the specified column `col_num` are `True` (indicating black squares). If any cell in the column is `False`, the function immediately returns `False`. If all cells in the column are `True`, the function then evaluates whether all rows have been painted black by checking the `painted_rows` list. If any row has not been painted black (`painted_rows` contains a `False`), the function returns `True`. Otherwise, if all rows have been painted black (`painted_rows` contains only `True` values), the function returns `False`. The function does not modify the `board` or `painted_rows` lists.

#Function 2:
#State of the program right berfore the function call: board is a list of 8 lists, each containing 8 boolean values; painted_rows is a dictionary with keys being integers from 0 to 7 and values being booleans indicating whether the corresponding row has been painted; painted_cols is a dictionary with keys being integers from 0 to 7 and values being booleans indicating whether the corresponding column has been painted.
def func_2():
    for y in xrange(8):
        board.append([(True if x == 'B' else False) for x in raw_input()])
        
    #State of the program after the  for loop has been executed: `board` is a list of 16 lists, each containing 8 boolean values, where the last 8 lists are determined by the input strings (each 'B' in the input corresponds to `True`, all others to `False`). `painted_rows` is a dictionary with keys being integers from 0 to 7 and values being booleans, `painted_cols` is a dictionary with keys being integers from 0 to 7 and values being booleans, `y` is 7.
    strokes = 0
    for (row_num, row) in enumerate(board):
        if all(row):
            strokes += 1
            painted_rows[row_num] = True
        
    #State of the program after the  for loop has been executed: `board` is a list of 16 lists, each containing 8 boolean values, `painted_rows` is a dictionary with keys being integers from 0 to 7 and values being booleans, `painted_cols` is a dictionary with keys being integers from 0 to 7 and values being booleans, `y` is 7, `strokes` is the number of rows in `board` where all elements are `True`, `painted_rows[row_num]` is `True` for each `row_num` where all elements in `board[row_num]` are `True`.
    for col_num in xrange(8):
        if func_1(col_num):
            strokes += 1
            painted_cols[col_num] = True
        
    #State of the program after the  for loop has been executed: `board` is a list of 16 lists, each containing 8 boolean values, `painted_rows` is a dictionary with keys being integers from 0 to 7 and values being booleans, `painted_cols` is a dictionary with keys being integers from 0 to 7 and values being booleans. After the loop executes, `painted_cols[col_num]` is `True` for each `col_num` where `func_1(col_num)` returned `True`. `strokes` is the number of rows in `board` where all elements are `True` plus the number of columns for which `func_1(col_num)` returned `True`. `painted_rows[row_num]` is `True` for each `row_num` where all elements in `board[row_num]` are `True`, `y` is 7, and the loop has iterated over all column numbers from 0 to 7.
    print(strokes)
#Overall this is what the function does:The function `func_2` reads 8 lines of input, each line consisting of 8 characters, and appends these lines to the existing `board` list, converting each character to a boolean (`True` if the character is 'B', otherwise `False`). It then counts the number of fully painted rows and columns, updating the `painted_rows` and `painted_cols` dictionaries accordingly. Finally, it prints the total count of such rows and columns. The function does not return any value. Edge cases include scenarios where the input lines do not contain exactly 8 characters, which would cause the function to behave incorrectly. Additionally, the function assumes that `board`, `painted_rows`, and `painted_cols` are pre-defined and correctly initialized before the function is called.



Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
