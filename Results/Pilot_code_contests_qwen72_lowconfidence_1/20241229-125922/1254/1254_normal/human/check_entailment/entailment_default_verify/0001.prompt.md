
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: A famous Berland's painter Kalevitch likes to shock the public. One of his last obsessions is chess. For more than a thousand years people have been playing this old game on uninteresting, monotonous boards. Kalevitch decided to put an end to this tradition and to introduce a new attitude to chessboards.

As before, the chessboard is a square-checkered board with the squares arranged in a 8 × 8 grid, each square is painted black or white. Kalevitch suggests that chessboards should be painted in the following manner: there should be chosen a horizontal or a vertical line of 8 squares (i.e. a row or a column), and painted black. Initially the whole chessboard is white, and it can be painted in the above described way one or more times. It is allowed to paint a square many times, but after the first time it does not change its colour any more and remains black. Kalevitch paints chessboards neatly, and it is impossible to judge by an individual square if it was painted with a vertical or a horizontal stroke.

Kalevitch hopes that such chessboards will gain popularity, and he will be commissioned to paint chessboards, which will help him ensure a comfortable old age. The clients will inform him what chessboard they want to have, and the painter will paint a white chessboard meeting the client's requirements.

It goes without saying that in such business one should economize on everything — for each commission he wants to know the minimum amount of strokes that he has to paint to fulfill the client's needs. You are asked to help Kalevitch with this task.

Input

The input file contains 8 lines, each of the lines contains 8 characters. The given matrix describes the client's requirements, W character stands for a white square, and B character — for a square painted black.

It is guaranteed that client's requirments can be fulfilled with a sequence of allowed strokes (vertical/column or horizontal/row).

Output

Output the only number — the minimum amount of rows and columns that Kalevitch has to paint on the white chessboard to meet the client's requirements.

Examples

Input

WWWBWWBW
BBBBBBBB
WWWBWWBW
WWWBWWBW
WWWBWWBW
WWWBWWBW
WWWBWWBW
WWWBWWBW


Output

3


Input

WWWWWWWW
BBBBBBBB
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW


Output

1
Program:
```
import sys
#Function 1:
def func_1(col_num):
    painted_by_rows = True
    for (row_num, x) in enumerate(board):
        if x[col_num] != True:
            return False
        painted_by_rows = painted_by_rows and painted_rows[row_num]
    return True and (not painted_by_rows)

#Function 2:
def func_2():
    for y in xrange(8):
        board.append([True if x == 'B' else False for x in raw_input()])
    strokes = 0
    for (row_num, row) in enumerate(board):
        if all(row):
            strokes += 1
            painted_rows[row_num] = True
    for col_num in xrange(8):
        if func_1(col_num):
            strokes += 1
            painted_cols[col_num] = True
    print(strokes)


```
Original Assessment: Correctness: **False**

Explanation:
The program provided has several issues that make it incorrect for some inputs:

1. **Use of `xrange`**: The function `xrange` is not available in Python 3; it should be replaced with `range`.

2. **Reading Input**: The program uses `raw_input()` to read input, which is also not available in Python 3. It should be replaced with `input()`.

3. **Initialization of `painted_rows` and `painted_cols`**: The variables `painted_rows` and `painted_cols` are used but never initialized. This will cause a `NameError` when the program tries to access these variables.

4. **Handling of Rows and Columns**: The logic in `func_1` is overly complex and may not correctly handle all edge cases. Specifically, the condition `return True and (not painted_by_rows)` might not accurately reflect whether a column needs to be painted.

5. **Edge Case Handling**: The program does not handle cases where a row or column is partially painted (e.g., a row with a mix of 'B' and 'W' squares). It assumes that if a row or column is fully black, it can be painted in one stroke, but it does not check if a row or column can be part of a valid solution if it is not fully black.

To fix these issues, the program should be updated to use Python 3 syntax, properly initialize variables, and simplify the logic for checking rows and columns. Here is a corrected version of the program:

```python
def min_strokes(board):
    # Initialize painted rows and columns
    painted_rows = [False] * 8
    painted_cols = [False] * 8

    # Count the number of fully black rows and columns
    strokes = 0

    # Check rows
    for row_num, row in enumerate(board):
        if all(cell == 'B' for cell in row):
            strokes += 1
            painted_rows[row_num] = True

    # Check columns
    for col_num in range(8):
        if all(board[row_num][col_num] == 'B' for row_num in range(8)):
            if not all(painted_rows[row_num] for row_num in range(8)):
                strokes += 1
                painted_cols[col_num] = True

    return strokes

# Read input
board = [input().strip() for _ in range(8)]

# Calculate and print the result
print(min_strokes(board))
```

This corrected version initializes `painted_rows` and `painted_cols`, uses `range` instead of `xrange`, and `input` instead of `raw_input`. It also simplifies the logic for checking rows and columns, ensuring that it handles all edge cases correctly.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: Output hints for function number 2 : The function `func_2` reads 8 lines of input, each line consisting of 8 characters, and appends these lines to the existing `board` list, converting each character to a boolean (`True` if the character is 'B', otherwise `False`). It then counts the number of fully painted rows and columns, updating the `painted_rows` and `painted_cols` dictionaries accordingly. Finally, it prints the total count of such rows and columns. The function does not return any value. Edge cases include scenarios where the input lines do not contain exactly 8 characters, which would cause the function to behave incorrectly. Additionally, the function assumes that `board`, `painted_rows`, and `painted_cols` are pre-defined and correctly initialized before the function is called.+


Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
