
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: A famous Berland's painter Kalevitch likes to shock the public. One of his last obsessions is chess. For more than a thousand years people have been playing this old game on uninteresting, monotonous boards. Kalevitch decided to put an end to this tradition and to introduce a new attitude to chessboards.

As before, the chessboard is a square-checkered board with the squares arranged in a 8 × 8 grid, each square is painted black or white. Kalevitch suggests that chessboards should be painted in the following manner: there should be chosen a horizontal or a vertical line of 8 squares (i.e. a row or a column), and painted black. Initially the whole chessboard is white, and it can be painted in the above described way one or more times. It is allowed to paint a square many times, but after the first time it does not change its colour any more and remains black. Kalevitch paints chessboards neatly, and it is impossible to judge by an individual square if it was painted with a vertical or a horizontal stroke.

Kalevitch hopes that such chessboards will gain popularity, and he will be commissioned to paint chessboards, which will help him ensure a comfortable old age. The clients will inform him what chessboard they want to have, and the painter will paint a white chessboard meeting the client's requirements.

It goes without saying that in such business one should economize on everything — for each commission he wants to know the minimum amount of strokes that he has to paint to fulfill the client's needs. You are asked to help Kalevitch with this task.

Input

The input file contains 8 lines, each of the lines contains 8 characters. The given matrix describes the client's requirements, W character stands for a white square, and B character — for a square painted black.

It is guaranteed that client's requirments can be fulfilled with a sequence of allowed strokes (vertical/column or horizontal/row).

Output

Output the only number — the minimum amount of rows and columns that Kalevitch has to paint on the white chessboard to meet the client's requirements.

Examples

Input

WWWBWWBW
BBBBBBBB
WWWBWWBW
WWWBWWBW
WWWBWWBW
WWWBWWBW
WWWBWWBW
WWWBWWBW


Output

3


Input

WWWWWWWW
BBBBBBBB
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW


Output

1
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
import sys

sys.setrecursionlimit(2 ** 15)
board = []
painted_rows = [False] * 8
painted_cols = [False] * 8
func_2()

#Function 1:
#State of the program right berfore the function call: col_num is an integer representing a column index in the board, where 0 <= col_num < 8. board is a 2D list of booleans with dimensions 8x8, where True represents a black square and False represents a white square. painted_rows is a list of booleans with length 8, where True indicates that the corresponding row has been painted black.
def func_1(col_num):
    painted_by_rows = True
    for (row_num, x) in enumerate(board):
        if x[col_num] != True:
            return False
        
        painted_by_rows = painted_by_rows and painted_rows[row_num]
        
    #State of the program after the  for loop has been executed: `col_num` is an integer with \(0 \leq \text{col_num} < 8\), `board` is a 2D list of booleans with dimensions 8x8, `painted_rows` is a list of booleans with length 8, `painted_by_rows` is the logical AND of all elements in `painted_rows`, `row_num` is 7, `x` is the last row of `board`, and `x[col_num]` is `board[7][col_num]`. If any `x[col_num]` is not True, the program returns False. If the loop does not execute (which would only happen if `board` is empty, but it is given that `board` is 8x8), `painted_by_rows` remains True.
    return True and not painted_by_rows
    #The program returns the result of `True and not painted_by_rows`, where `painted_by_rows` is the logical AND of all elements in `painted_rows`, a list of booleans with length 8.

#Function 2:
#State of the program right berfore the function call: board is a list of 8 lists, each containing 8 boolean values; painted_rows is a dictionary with keys being integers from 0 to 7 and values being booleans indicating whether the corresponding row has been painted; painted_cols is a dictionary with keys being integers from 0 to 7 and values being booleans indicating whether the corresponding column has been painted.
def func_2():
    for y in xrange(8):
        board.append([(True if x == 'B' else False) for x in raw_input()])
        
    #State of the program after the  for loop has been executed: `board` is a list of 16 lists, each containing 8 boolean values, where the last 8 lists are determined by the input strings (each 'B' in the input corresponds to `True`, all others to `False`). `painted_rows` is a dictionary with keys being integers from 0 to 7 and values being booleans, `painted_cols` is a dictionary with keys being integers from 0 to 7 and values being booleans, `y` is 7.
    strokes = 0
    for (row_num, row) in enumerate(board):
        if all(row):
            strokes += 1
            painted_rows[row_num] = True
        
    #State of the program after the  for loop has been executed: `board` is a list of 16 lists, each containing 8 boolean values, `painted_rows` is a dictionary with keys being integers from 0 to 7 and values being booleans, `painted_cols` is a dictionary with keys being integers from 0 to 7 and values being booleans, `y` is 7, `strokes` is the number of rows in `board` where all elements are `True`, `painted_rows[row_num]` is `True` for each `row_num` where all elements in `board[row_num]` are `True`.
    for col_num in xrange(8):
        if func_1(col_num):
            strokes += 1
            painted_cols[col_num] = True
        
    #State of the program after the  for loop has been executed: `board` is a list of 16 lists, each containing 8 boolean values, `painted_rows` is a dictionary with keys being integers from 0 to 7 and values being booleans, `painted_cols` is a dictionary with keys being integers from 0 to 7 and values being booleans. After the loop executes, `painted_cols[col_num]` is `True` for each `col_num` where `func_1(col_num)` returned `True`. `strokes` is the number of rows in `board` where all elements are `True` plus the number of columns for which `func_1(col_num)` returned `True`. `painted_rows[row_num]` is `True` for each `row_num` where all elements in `board[row_num]` are `True`, `y` is 7, and the loop has iterated over all column numbers from 0 to 7.
    print(strokes)


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
