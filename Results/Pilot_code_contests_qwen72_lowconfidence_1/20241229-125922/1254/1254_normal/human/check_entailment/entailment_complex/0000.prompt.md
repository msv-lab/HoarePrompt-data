
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: A famous Berland's painter Kalevitch likes to shock the public. One of his last obsessions is chess. For more than a thousand years people have been playing this old game on uninteresting, monotonous boards. Kalevitch decided to put an end to this tradition and to introduce a new attitude to chessboards.

As before, the chessboard is a square-checkered board with the squares arranged in a 8 × 8 grid, each square is painted black or white. Kalevitch suggests that chessboards should be painted in the following manner: there should be chosen a horizontal or a vertical line of 8 squares (i.e. a row or a column), and painted black. Initially the whole chessboard is white, and it can be painted in the above described way one or more times. It is allowed to paint a square many times, but after the first time it does not change its colour any more and remains black. Kalevitch paints chessboards neatly, and it is impossible to judge by an individual square if it was painted with a vertical or a horizontal stroke.

Kalevitch hopes that such chessboards will gain popularity, and he will be commissioned to paint chessboards, which will help him ensure a comfortable old age. The clients will inform him what chessboard they want to have, and the painter will paint a white chessboard meeting the client's requirements.

It goes without saying that in such business one should economize on everything — for each commission he wants to know the minimum amount of strokes that he has to paint to fulfill the client's needs. You are asked to help Kalevitch with this task.

Input

The input file contains 8 lines, each of the lines contains 8 characters. The given matrix describes the client's requirements, W character stands for a white square, and B character — for a square painted black.

It is guaranteed that client's requirments can be fulfilled with a sequence of allowed strokes (vertical/column or horizontal/row).

Output

Output the only number — the minimum amount of rows and columns that Kalevitch has to paint on the white chessboard to meet the client's requirements.

Examples

Input

WWWBWWBW
BBBBBBBB
WWWBWWBW
WWWBWWBW
WWWBWWBW
WWWBWWBW
WWWBWWBW
WWWBWWBW


Output

3


Input

WWWWWWWW
BBBBBBBB
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW


Output

1
Annotated Functions:
import sys

sys.setrecursionlimit(2 ** 15)
board = []
painted_rows = [False] * 8
painted_cols = [False] * 8
func_2()

#Function 1:
#State of the program right berfore the function call: col_num is an integer representing a column index in the board, where 0 <= col_num < 8. board is a 2D list of booleans with dimensions 8x8, where True represents a black square and False represents a white square. painted_rows is a list of booleans with length 8, where True indicates that the corresponding row has been painted black.
def func_1(col_num):
    painted_by_rows = True
    for (row_num, x) in enumerate(board):
        if x[col_num] != True:
            return False
        
        painted_by_rows = painted_by_rows and painted_rows[row_num]
        
    #State of the program after the  for loop has been executed: `col_num` is an integer with \(0 \leq \text{col_num} < 8\), `board` is a 2D list of booleans with dimensions 8x8, `painted_rows` is a list of booleans with length 8, `painted_by_rows` is the logical AND of all elements in `painted_rows`, `row_num` is 7, `x` is the last row of `board`, and `x[col_num]` is `board[7][col_num]`. If any `x[col_num]` is not True, the program returns False. If the loop does not execute (which would only happen if `board` is empty, but it is given that `board` is 8x8), `painted_by_rows` remains True.
    return True and not painted_by_rows
    #The program returns the result of `True and not painted_by_rows`, where `painted_by_rows` is the logical AND of all elements in `painted_rows`, a list of booleans with length 8.
#Overall this is what the function does:The function `func_1` takes a single parameter `col_num`, which is an integer representing a column index in a 2D list `board` of booleans with dimensions 8x8. The function checks if all cells in the specified column `col_num` are `True` (indicating black squares). If any cell in the column is `False`, the function immediately returns `False`. If all cells in the column are `True`, the function then evaluates whether all rows have been painted black by checking the `painted_rows` list. If any row has not been painted black (`painted_rows` contains a `False`), the function returns `True`. Otherwise, if all rows have been painted black (`painted_rows` contains only `True` values), the function returns `False`. The function does not modify the `board` or `painted_rows` lists.

#Function 2:
#State of the program right berfore the function call: board is a list of 8 lists, each containing 8 boolean values; painted_rows is a dictionary with keys being integers from 0 to 7 and values being booleans indicating whether the corresponding row has been painted; painted_cols is a dictionary with keys being integers from 0 to 7 and values being booleans indicating whether the corresponding column has been painted.
def func_2():
    for y in xrange(8):
        board.append([(True if x == 'B' else False) for x in raw_input()])
        
    #State of the program after the  for loop has been executed: `board` is a list of 16 lists, each containing 8 boolean values, where the last 8 lists are determined by the input strings (each 'B' in the input corresponds to `True`, all others to `False`). `painted_rows` is a dictionary with keys being integers from 0 to 7 and values being booleans, `painted_cols` is a dictionary with keys being integers from 0 to 7 and values being booleans, `y` is 7.
    strokes = 0
    for (row_num, row) in enumerate(board):
        if all(row):
            strokes += 1
            painted_rows[row_num] = True
        
    #State of the program after the  for loop has been executed: `board` is a list of 16 lists, each containing 8 boolean values, `painted_rows` is a dictionary with keys being integers from 0 to 7 and values being booleans, `painted_cols` is a dictionary with keys being integers from 0 to 7 and values being booleans, `y` is 7, `strokes` is the number of rows in `board` where all elements are `True`, `painted_rows[row_num]` is `True` for each `row_num` where all elements in `board[row_num]` are `True`.
    for col_num in xrange(8):
        if func_1(col_num):
            strokes += 1
            painted_cols[col_num] = True
        
    #State of the program after the  for loop has been executed: `board` is a list of 16 lists, each containing 8 boolean values, `painted_rows` is a dictionary with keys being integers from 0 to 7 and values being booleans, `painted_cols` is a dictionary with keys being integers from 0 to 7 and values being booleans. After the loop executes, `painted_cols[col_num]` is `True` for each `col_num` where `func_1(col_num)` returned `True`. `strokes` is the number of rows in `board` where all elements are `True` plus the number of columns for which `func_1(col_num)` returned `True`. `painted_rows[row_num]` is `True` for each `row_num` where all elements in `board[row_num]` are `True`, `y` is 7, and the loop has iterated over all column numbers from 0 to 7.
    print(strokes)
#Overall this is what the function does:The function `func_2` reads 8 lines of input, each line consisting of 8 characters, and appends these lines to the existing `board` list, converting each character to a boolean (`True` if the character is 'B', otherwise `False`). It then counts the number of fully painted rows and columns, updating the `painted_rows` and `painted_cols` dictionaries accordingly. Finally, it prints the total count of such rows and columns. The function does not return any value. Edge cases include scenarios where the input lines do not contain exactly 8 characters, which would cause the function to behave incorrectly. Additionally, the function assumes that `board`, `painted_rows`, and `painted_cols` are pre-defined and correctly initialized before the function is called.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.