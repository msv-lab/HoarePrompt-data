
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: The Third Doctor Who once correctly said that travel between parallel universes is "like travelling sideways". However, he incorrectly thought that there were infinite parallel universes, whereas in fact, as we now all know, there will never be more than 250.

Heidi recently got her hands on a multiverse observation tool. She was able to see all n universes lined up in a row, with non-existent links between them. She also noticed that the Doctor was in the k-th universe.

The tool also points out that due to restrictions originating from the space-time discontinuum, the number of universes will never exceed m.

Obviously, the multiverse is unstable because of free will. Each time a decision is made, one of two events will randomly happen: a new parallel universe is created, or a non-existent link is broken.

More specifically, 

  * When a universe is created, it will manifest itself between any two adjacent universes or at one of the ends. 
  * When a link is broken, it could be cut between any two adjacent universes. After separating the multiverse into two segments, the segment NOT containing the Doctor will cease to exist. 



Heidi wants to perform a simulation of t decisions. Each time a decision is made, Heidi wants to know the length of the multiverse (i.e. the number of universes), and the position of the Doctor.

Input

The first line contains four integers n, k, m and t (2 ≤ k ≤ n ≤ m ≤ 250, 1 ≤ t ≤ 1000).

Each of the following t lines is in one of the following formats: 

  * "1 i" — meaning that a universe is inserted at the position i (1 ≤ i ≤ l + 1), where l denotes the current length of the multiverse. 
  * "0 i" — meaning that the i-th link is broken (1 ≤ i ≤ l - 1), where l denotes the current length of the multiverse. 

Output

Output t lines. Each line should contain l, the current length of the multiverse and k, the current position of the Doctor.

It is guaranteed that the sequence of the steps will be valid, i.e. the multiverse will have length at most m and when the link breaking is performed, there will be at least one universe in the multiverse.

Example

Input


5 2 10 4
0 1
1 1
0 4
1 2


Output


4 1
5 2
4 2
5 3

Note

The multiverse initially consisted of 5 universes, with the Doctor being in the second.

First, link 1 was broken, leaving the multiverse with 4 universes, and the Doctor in the first.

Then, a universe was added to the leftmost end of the multiverse, increasing the multiverse length to 5, and the Doctor was then in the second universe.

Then, the rightmost link was broken.

Finally, a universe was added between the first and the second universe.
Program:
```
from __future__ import division, print_function
import os,sys
from io import BytesIO, IOBase
#Function 1:
def func_1():
    return int(input())

#Function 2:
def func_2():
    return input()

#Function 3:
def func_3():
    return map(int, input().strip().split(' '))

#Function 4:
def func_4():
    return list(func_3())

#Function 5:
def func_5():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 6:
def func_6(item):
    return item[0]

#Function 7:
def func_7(l):
    return sorted(l, key=getKey)

#Function 8:
def func_8(n, m, num):
    return [[num for x in range(m)] for y in range(n)]

#Function 9:
def func_9(x):
    return x and (not x & x - 1)

#Function 10:
def func_10(n):
    return bin(n).replace('0b', '')

#Function 11:
def func_11(n):
    return [i for i in str(n)]

#Function 12:
def func_12(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        y = y >> 1
        x = x * x % p1
    return res

#Function 13:
def func_13(x, y):
    while y:
        (x, y) = (y, x % y)
    return x

#Function 14:
def func_14(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True

#Function 15:
def func_15():
    (n, k, m, t) = func_3()
    for i in range(t):
        (a, b) = func_3()
        if a == 1:
            n += 1
            if b <= k:
                k += 1
        elif b < k:
            n -= b
            k -= b
        else:
            n -= n - b
        func_16(n, k)

#Function 16:
def func_16(*args, **kwargs):
    """Prints the values to a stream, or to sys.stdout by default."""
    (sep, file) = (kwargs.pop('sep', b' '), kwargs.pop('file', sys.stdout))
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop('end', b'\n'))
    if kwargs.pop('flush', False):
        file.flush()


```
Original Assessment: Correctness: **False**.

Explanation: The program does not handle the breaking of a link correctly when the Doctor is in the segment that remains after the break. Specifically, the program incorrectly updates the position of the Doctor and the length of the multiverse when a link is broken. Here's a detailed breakdown of the issue:

In the `func_15` function, the logic for breaking a link (when `a == 0`) is flawed. The program attempts to update the length of the multiverse and the Doctor's position, but it does so incorrectly. Let's consider the following scenario:

- Initial state: `n = 5`, `k = 2` (Doctor is in the 2nd universe).
- Decision: Break the link at position `b = 1`.

According to the problem description, breaking the link at position 1 should result in the multiverse being split into two segments: `[1, 2]` and `[3, 4, 5]`. The segment containing the Doctor is `[1, 2]`, so the other segment `[3, 4, 5]` ceases to exist. The new multiverse length should be 2, and the Doctor's position should remain 2.

However, the program incorrectly updates the length and position as follows:
- `n -= b` results in `n = 4` (which is incorrect; it should be 2).
- `k -= b` results in `k = 1` (which is incorrect; it should be 2).

This error occurs because the program does not correctly handle the logic for updating the multiverse length and the Doctor's position when a link is broken. Therefore, the program is incorrect.

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: Output hints for function number 16 : The function `func_16` accepts a variable number of positional arguments (`args`) and keyword arguments (`kwargs`). It prints the string representations of the positional arguments to a specified file (defaulting to `sys.stdout`), separated by the value of the `sep` key (defaulting to a single space byte string), and appends the value of the `end` key (defaulting to a newline byte string) at the end. If the `flush` key is set to `True`, it flushes the output buffer. The function does not return any value. 

- If `args` is an empty tuple, nothing is written to the file except the value of `end`.
- If `kwargs` contains keys other than 'sep', 'file', 'end', and 'flush', these keys remain in `kwargs` after the function executes.
- The `sep` and `end` values must be byte strings; if they are not, the function will raise a `TypeError` when attempting to write to the file.+


Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
