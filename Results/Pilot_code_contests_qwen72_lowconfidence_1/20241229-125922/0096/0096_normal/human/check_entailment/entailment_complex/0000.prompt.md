
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You want to perform the combo on your opponent in one popular fighting game. The combo is the string s consisting of n lowercase Latin letters. To perform the combo, you have to press all buttons in the order they appear in s. I.e. if s="abca" then you have to press 'a', then 'b', 'c' and 'a' again.

You know that you will spend m wrong tries to perform the combo and during the i-th try you will make a mistake right after p_i-th button (1 ≤ p_i < n) (i.e. you will press first p_i buttons right and start performing the combo from the beginning). It is guaranteed that during the m+1-th try you press all buttons right and finally perform the combo.

I.e. if s="abca", m=2 and p = [1, 3] then the sequence of pressed buttons will be 'a' (here you're making a mistake and start performing the combo from the beginning), 'a', 'b', 'c', (here you're making a mistake and start performing the combo from the beginning), 'a' (note that at this point you will not perform the combo because of the mistake), 'b', 'c', 'a'.

Your task is to calculate for each button (letter) the number of times you'll press it.

You have to answer t independent test cases.

Input

The first line of the input contains one integer t (1 ≤ t ≤ 10^4) — the number of test cases.

Then t test cases follow.

The first line of each test case contains two integers n and m (2 ≤ n ≤ 2 ⋅ 10^5, 1 ≤ m ≤ 2 ⋅ 10^5) — the length of s and the number of tries correspondingly.

The second line of each test case contains the string s consisting of n lowercase Latin letters.

The third line of each test case contains m integers p_1, p_2, ..., p_m (1 ≤ p_i < n) — the number of characters pressed right during the i-th try.

It is guaranteed that the sum of n and the sum of m both does not exceed 2 ⋅ 10^5 (∑ n ≤ 2 ⋅ 10^5, ∑ m ≤ 2 ⋅ 10^5).

It is guaranteed that the answer for each letter does not exceed 2 ⋅ 10^9.

Output

For each test case, print the answer — 26 integers: the number of times you press the button 'a', the number of times you press the button 'b', ..., the number of times you press the button 'z'.

Example

Input


3
4 2
abca
1 3
10 5
codeforces
2 8 3 2 9
26 10
qwertyuioplkjhgfdsazxcvbnm
20 10 1 2 3 5 10 5 9 4


Output


4 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 9 4 5 3 0 0 0 0 0 0 0 0 9 0 0 3 1 0 0 0 0 0 0 0 
2 1 1 2 9 2 2 2 5 2 2 2 1 1 5 4 11 8 2 7 5 1 10 1 5 2 

Note

The first test case is described in the problem statement. Wrong tries are "a", "abc" and the final try is "abca". The number of times you press 'a' is 4, 'b' is 2 and 'c' is 2.

In the second test case, there are five wrong tries: "co", "codeforc", "cod", "co", "codeforce" and the final try is "codeforces". The number of times you press 'c' is 9, 'd' is 4, 'e' is 5, 'f' is 3, 'o' is 9, 'r' is 3 and 's' is 1.
Annotated Functions:
from collections import defaultdict
import sys, math
from copy import deepcopy

f = None
try:
    f = open('q1.input', 'r')
except IOError:
    f = sys.stdin
if 'xrange' in dir(__builtins__):
    range = xrange
if 'xrange' in dir(__builtins__):
    import cStringIO
    output = cStringIO.StringIO()
if __name__ == '__main__':
    func_10()
"stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* BITS - THINK HOW TO MASK PROPERLY\n\t* PERMUTATIONS - PARITY AND CYCLES\n\t* Think simple, if it becomes over complicated, try to look at it from a different perspective.\n\t* Have fun!!!\n\t* TRY FIXING SOMETHING, and then maybe binary search around it.\n\t* Remember heaps. \n\t* Remember how to add a value to a segment when using prefix sum.\n\t\tsuppose you have an array[1,2,3,4,5] and you want to add 3 to array[1:4]. Then just \n\t\tadd 3 to A[1], and decrease 3 from A[4]. Let's look at what happens:\n\t\toriginal prefixsums is \t\t\t\t\t [1,3,6,10,15]\n\t\tarray -> [1,5,3,4,2] and prefix sums are [1,6,9,13,15] \n\t\tAs you see, exactly +3 in A[1:4]\n\t\t*** The previous method can help checking how many x,y you can choose to get s=x+y from two arrays.\n"
'\nbinary search \n\twhile(r - l > 1) {\n\t\tll mid = l + (r - l) / 2;\n\t\tsolve(mid);\n\t\tll sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum += b[i];\n\t\tif (sum <= k)\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t}\n'

#Function 1:
#State of the program right berfore the function call: case_num is a positive integer representing the case number, and iterable is a collection of integers representing the counts of presses for each letter from 'a' to 'z'.
def func_1(case_num, iterable):
    print('Case #{}: {}'.format(case_num, ' '.join(map(str, iterable))))
#Overall this is what the function does:The function `func_1` accepts two parameters: `case_num`, which is a positive integer representing a case number, and `iterable`, which is a collection of integers representing the counts of presses for each letter from 'a' to 'z'. The function prints a formatted string that includes the case number and the space-separated counts of presses. The function does not return any value; it only prints the result. The state of the program after the function concludes remains unchanged except for the output printed to the console. Potential edge cases include an empty `iterable` or a non-positive `case_num`, but the function does not handle these cases specifically and will still attempt to print the formatted string.

#Function 2:
#State of the program right berfore the function call: case_num is a positive integer representing the case number, and iterable is a sequence of integers or strings.
def func_2(case_num, iterable):
    print('Case #{}: {}'.format(case_num, iterable))
#Overall this is what the function does:The function `func_2` accepts two parameters: a positive integer `case_num` and a sequence of integers or strings `iterable`. It prints a formatted string that includes the `case_num` and the `iterable`. However, the function does not return any value based on the `case_num` as described in the annotations. Instead, it only prints the formatted string and then the function ends. The state of the program after the function concludes is that the formatted string has been printed to the console, and no value is returned. Potential edge cases include an empty `iterable`, which would still result in the formatted string being printed, but it might not be meaningful.

#Function 3:
#State of the program right berfore the function call: A is a list of strings where each string represents a non-negative integer.
def func_3(A):
    print(' '.join(A))
#Overall this is what the function does:The function `func_3` accepts a list `A` of strings, where each string represents a non-negative integer. It prints the elements of the list `A` joined by a single space. The function does not return any value. After the function concludes, the list `A` remains unchanged, and the output is a single line of text containing the concatenated strings from `A` separated by spaces. Edge cases include an empty list, which would result in an empty string being printed, and a list with a single element, which would print that element without any trailing space.

#Function 4:
#State of the program right berfore the function call: No variables are passed to the function `func_4`. This function reads a single line from a file object `f` and returns the integer representation of the stripped line.
def func_4():
    return int(f.readline().strip())
    #The program returns the integer representation of the stripped line read from the file object `f`.
#Overall this is what the function does:The function `func_4` reads a single line from a file object `f`, strips any leading or trailing whitespace, and returns the integer representation of the stripped line. If the line cannot be converted to an integer (e.g., due to non-numeric characters), a `ValueError` will be raised. The file object `f` is advanced by one line after the function call.

#Function 5:
#State of the program right berfore the function call: None. This function does not take any arguments and is designed to read a line from a file object `f` and convert it into a list of integers.
def func_5():
    return [int(x) for x in f.readline().strip().split(' ')]
    #The program returns a list of integers converted from the first line of the file object `f`. Each integer in the list was originally separated by spaces in the line read from the file.
#Overall this is what the function does:The function `func_5` reads a line from a file object `f`, splits the line into substrings based on spaces, converts each substring to an integer, and returns a list of these integers. If the line is empty or contains non-integer values, the behavior is undefined and may result in an error. The file object `f` remains open after the function execution.

#Function 6:
#State of the program right berfore the function call: This function does not take any parameters, but it reads from a file object `f` which is expected to contain lines of space-separated values. The first value is expected to be an integer, and the second value is a string.
def func_6():
    a = [x for x in f.readline().split(' ')]
    return int(a[0]), a[1].strip()
    #The program returns the integer value of the first element in list `a` and the stripped string of the second element in list `a`.
#Overall this is what the function does:The function `func_6` reads a single line from a file object `f` and processes it. It expects the line to contain space-separated values where the first value can be converted to an integer and the second value is a string. The function returns a tuple containing the integer value of the first element and the stripped string of the second element. If the line does not contain at least two elements or if the first element cannot be converted to an integer, the function will raise a `ValueError` or `IndexError`.

#Function 7:
#State of the program right berfore the function call: No variables are passed to the function, and it reads a line from a file object `f` which is assumed to be open and iterable, returning a list of characters from the stripped line.
def func_7():
    return list(f.readline().strip())
    #The program returns a list of characters from the stripped line read from the file object `f`.
#Overall this is what the function does:The function `func_7` does not accept any parameters. It reads a single line from a file object `f`, which is assumed to be open and iterable. It then strips any leading and trailing whitespace from the line and returns a list of characters from the stripped line. If the file is empty or the end of the file is reached, it will return an empty list.

#Function 8:
#State of the program right berfore the function call: x is an integer.
def func_8(x):
    return bin(x)[2:]
    #The program returns the binary representation of integer 'x' as a string, excluding the '0b' prefix.
#Overall this is what the function does:The function `func_8` accepts an integer `x` and returns its binary representation as a string, excluding the '0b' prefix. If `x` is 0, the function returns '0'. If `x` is negative, the function returns the binary representation of the absolute value of `x`. The function does not handle non-integer inputs, and passing such inputs will result in a TypeError.

#Function 9:
#State of the program right berfore the function call: s is a string of length n consisting of lowercase Latin letters, n is a positive integer, p is a list of m integers where 1 ≤ p_i < n, and m is a positive integer.
def func_9(s, n, p, m):
    s = [0] + s
    dp = [[(0) for _ in range(26)] for _ in range(n + 1)]
    p.sort()
    for i in range(1, n + 1):
        for j in range(26):
            dp[i][j] = dp[i - 1][j] + int(j == ord(s[i]) - ord('a'))
        
    #State of the program after the  for loop has been executed: `s` is a string of length `n + 1` starting with '0' followed by the original `s`, `n` is a positive integer, `p` is a sorted list of `m` integers where `1 ≤ p_i < n`, `m` is a positive integer, `dp` is a 2D list of size `(n + 1) x 26` where `dp[i][j]` is the cumulative count of the character corresponding to `j` (where `j` ranges from 0 to 25, representing 'a' to 'z') from the start of `s` up to and including the `i`-th character.
    res = [x for x in dp[n]]
    for i in range(m):
        x = p[i]
        
        for j in range(26):
            res[j] += dp[x][j]
        
    #State of the program after the  for loop has been executed: To determine the final output state after all iterations of the loop have finished, let's analyze the code step by step, considering the initial state and the changes made during each iteration.
    #
    #### Initial State:
    #- `s` is a string of length `n + 1` starting with '0' followed by the original `s`.
    #- `n` is a positive integer.
    #- `p` is a sorted list of `m` integers where `1 ≤ p_i < n`.
    #- `m` is a positive integer.
    #- `dp` is a 2D list of size `(n + 1) x 26` where `dp[i][j]` is the cumulative count of the character corresponding to `j` from the start of `s` up to and including the `i`-th character.
    #- `res` is a list containing the elements from the `n`-th row of `dp`.
    #
    #### Code of the Loop:
    #```python
    #for i in range(m):
    #    x = p[i]
    #    for j in range(26):
    #        res[j] += dp[x][j]
    #```
    #
    #### Step-by-Step Analysis:
    #1. **First Iteration (i = 0):**
    #   - `x = p[0]`
    #   - For each `j` in `range(26)`, `res[j]` is updated to `res[j] + dp[p[0]][j]`.
    #   - After this iteration, `res[j]` for all `j` in `range(26)` becomes `dp[n][j] + dp[p[0]][j]`.
    #
    #2. **Second Iteration (i = 1):**
    #   - `x = p[1]`
    #   - For each `j` in `range(26)`, `res[j]` is updated to `res[j] + dp[p[1]][j]`.
    #   - After this iteration, `res[j]` for all `j` in `range(26)` becomes `dp[n][j] + dp[p[0]][j] + dp[p[1]][j]`.
    #
    #3. **Third Iteration (i = 2):**
    #   - `x = p[2]`
    #   - For each `j` in `range(26)`, `res[j]` is updated to `res[j] + dp[p[2]][j]`.
    #   - After this iteration, `res[j]` for all `j` in `range(26)` becomes `dp[n][j] + dp[p[0]][j] + dp[p[1]][j] + dp[p[2]][j]`.
    #
    #4. **General Case (i = k, where 0 ≤ k < m):**
    #   - `x = p[k]`
    #   - For each `j` in `range(26)`, `res[j]` is updated to `res[j] + dp[p[k]][j]`.
    #   - After this iteration, `res[j]` for all `j` in `range(26)` becomes `dp[n][j] + dp[p[0]][j] + dp[p[1]][j] + ... + dp[p[k]][j]`.
    #
    #### Final Output State:
    #After all `m` iterations of the loop, the final state of the variables will be:
    #- `s` remains a string of length `n + 1` starting with '0' followed by the original `s`.
    #- `n` remains a positive integer.
    #- `p` remains a sorted list of `m` integers where `1 ≤ p_i < n`.
    #- `m` remains a positive integer.
    #- `dp` remains a 2D list of size `(n + 1) x 26` where `dp[i][j]` is the cumulative count of the character corresponding to `j` from the start of `s` up to and including the `i`-th character.
    #- `res` is a list where each element `res[j]` for all `j` in `range(26)` is the sum of `dp[n][j]` and the cumulative counts of the character corresponding to `j` at positions `p[0], p[1], ..., p[m-1]` in the string `s`.
    #
    #Therefore, the Output State is:
    #**`s` is a string of length `n + 1` starting with '0' followed by the original `s`, `n` is a positive integer, `p` is a sorted list of `m` integers where `1 ≤ p_i < n`, `m` is a positive integer, `dp` is a 2D list of size `(n + 1) x 26` where `dp[i][j]` is the cumulative count of the character corresponding to `j` from the start of `s` up to and including the `i`-th character, `res` is a list where each element `res[j]` for all `j` in `range(26)` is `dp[n][j] + sum(dp[p[i]][j] for i in range(m))`.**
    return ' '.join(map(str, res))
    #The program returns a space-separated string of the elements in `res`, where each element `res[j]` for all `j` in `range(26)` is `dp[n][j] + sum(dp[p[i]][j] for i in range(m))`. Each `res[j]` represents the cumulative count of the character corresponding to `j` from the start of `s` up to and including the `n`-th character, plus the cumulative counts at the positions specified in `p`.
#Overall this is what the function does:The function `func_9` accepts a string `s` of lowercase Latin letters, a positive integer `n` indicating the length of `s`, a list of integers `p` where each element is less than `n`, and a positive integer `m` indicating the number of elements in `p`. It modifies `s` by prepending a '0' to it, creating a 2D list `dp` where `dp[i][j]` represents the cumulative count of the character corresponding to `j` (where `j` ranges from 0 to 25, representing 'a' to 'z') from the start of the modified `s` up to and including the `i`-th character. The function then iterates over the positions specified in `p`, updating a result list `res` to accumulate the cumulative counts of characters at these positions. Finally, it returns a space-separated string of the elements in `res`, where each element `res[j]` for all `j` in `range(26)` is `dp[n][j] + sum(dp[p[i]][j] for i in range(m))`. This means `res[j]` represents the cumulative count of the character corresponding to `j` from the start of `s` up to the `n`-th character, plus the cumulative counts at the positions specified in `p`.

Potential Edge Cases and Missing Functionality:
- If `s` is an empty string, the function will prepend '0' to it, making `s` a string of length 1. The `dp` table will still be constructed, but the subsequent operations will not be meaningful since there are no characters in `s` to count.
- If `p` is an empty list, the function will still construct the `dp` table and initialize `res` based on `dp[n]`, but no additional updates will be made to `res` from `p`.
- If `n` is 1, the function will still prepend '0' to `s`, making `s` a string of length 2. The `dp` table will be constructed, but the only meaningful character count will be for the single character in the original `s`.
- If `p` contains duplicate values, the function will still add the same cumulative counts multiple times, which might not be the intended behavior.
- If `p` contains values that are out of bounds (i.e., greater than or equal to `n`), the function will raise an index error when accessing `dp[p[i]]`.

Final State After Execution:
- `s` is a string of length `n + 1` starting with '0' followed by the original `s`.
- `n` remains a positive integer.
- `p` remains a sorted list of `m` integers where `1 ≤ p_i < n`.
- `m` remains a positive integer.
- `dp` is a 2D list of size `(n + 1) x 26` where `dp[i][j]` is the cumulative count of the character corresponding to `j` from the start of `s` up to and including the `i`-th character.
- `res` is a list where each element `res[j]` for all `j` in `range(26)` is `dp[n][j] + sum(dp[p[i]][j] for i in range(m))`.
- The function returns a space-separated string of the elements in `res`.

#Function 10:
#State of the program right berfore the function call: T is a positive integer representing the number of test cases, n and m are positive integers such that 2 ≤ n ≤ 2 ⋅ 10^5 and 1 ≤ m ≤ 2 ⋅ 10^5, s is a string of length n consisting of lowercase Latin letters, and p is a list of m integers where each integer p_i satisfies 1 ≤ p_i < n.
def func_10():
    T = func_4()
    for i in range(T):
        n, m = func_5()
        
        s = func_7()
        
        p = func_5()
        
        x = func_9(s, n, p, m)
        
        if 'xrange' not in dir(__builtins__):
            print(x)
        else:
            print >> output, str(x)
        
    #State of the program after the  for loop has been executed: `T` is a positive integer (result of `func_4()`), `n` and `m` are the final values returned by `func_5()` after the last iteration, `s` is the final string of lowercase Latin letters (updated by `func_7()` in the last iteration), `p` is the final list of `m` integers (updated by `func_5()` in the last iteration), `i` is `T-1`, and `x` is the result of `func_9(s, n, p, m)` from the last iteration. If `'xrange'` is not in the built-in namespace, `x` has been printed `T` times. If `'xrange'` is in the built-in namespace, `x` has been written to the output stream `T` times.
    if ('xrange' in dir(__builtins__)) :
        print(output.getvalue())
        output.close()
    #State of the program after the if block has been executed: *`T` is a positive integer, `n` and `m` are the final values returned by `func_5()` after the last iteration, `s` is the final string of lowercase Latin letters, `p` is the final list of `m` integers, `i` is `T-1`, `x` is the result of `func_9(s, n, p, m)` from the last iteration. If `'xrange'` is in the built-in namespace, the output stream is closed. If `'xrange'` is not in the built-in namespace, `x` has been printed `T` times.
#Overall this is what the function does:The function `func_10` processes a series of test cases defined by the integer `T`. For each test case, it reads two integers `n` and `m`, a string `s` of length `n`, and a list `p` of `m` integers. It then calls `func_9` with these parameters, storing the result in `x`. Depending on whether the `xrange` function is available in the built-in namespace, the function either prints `x` to the console or writes it to an output stream. After processing all test cases, if `xrange` is in the built-in namespace, the output stream is closed. The final state of the program includes `T` being a positive integer, `n` and `m` being the final values returned by `func_5` after the last iteration, `s` being the final string of lowercase Latin letters, `p` being the final list of `m` integers, and `i` being `T-1`. The result `x` from the last iteration is stored, and the output stream is closed if `xrange` is in the built-in namespace.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.