Functionality: ** The function `func_2` processes a set of (a, b) pairs, where 1 ≤ a, b ≤ n and a ≠ b, to populate a list `station` of n empty lists. Each sublist `station[i]` stores the indices of stations connected to station `i + 1`. After populating `station`, the function calculates the minimum distance to the closest connected station for each station and stores these values in `max_candy`. Finally, it computes and prints the maximum distance for each starting station, considering all possible paths through the connected stations. The function handles edge cases where no connections exist for a station by skipping those iterations. The function modifies the `station` list in place and prints a sequence of n integers, each representing the maximum distance for the corresponding starting station. **

### Detailed Summary:
- **Parameters:** The function does not accept any parameters. It reads `n` and `m` from the input, where `n` is the number of stations and `m` is the number of (a, b) pairs.
- **Returns:** The function does not return any value. It prints a sequence of n integers.
- **Final State:**
  - `n` and `m` are integers such that 2 ≤ n ≤ 5000 and 1 ≤ m ≤ 20000.
  - `station` is a list of n lists, where each `station[i]` contains the indices of stations connected to station `i + 1`.
  - `max_candy` is a list of n elements, where each `max_candy[j]` is the minimum value in `station[j]` based on a custom key function if `station[j]` is not empty; otherwise, `max_candy[j]` remains 0.
  - The function prints n integers, each representing the maximum distance for the corresponding starting station.
- **Edge Cases:**
  - If `m` is 0, the function initializes `station` as a list of n empty lists and prints 0 n times.
  - If a station has no connections, the corresponding `max_candy` value remains 0, and the distance calculation skips that station.
  - The function correctly handles the circular nature of the stations by using modulo operations.