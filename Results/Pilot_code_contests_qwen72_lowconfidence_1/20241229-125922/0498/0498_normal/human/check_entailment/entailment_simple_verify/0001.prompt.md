
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Wilbur is playing with a set of n points on the coordinate plane. All points have non-negative integer coordinates. Moreover, if some point (x, y) belongs to the set, then all points (x', y'), such that 0 ≤ x' ≤ x and 0 ≤ y' ≤ y also belong to this set.

Now Wilbur wants to number the points in the set he has, that is assign them distinct integer numbers from 1 to n. In order to make the numbering aesthetically pleasing, Wilbur imposes the condition that if some point (x, y) gets number i, then all (x',y') from the set, such that x' ≥ x and y' ≥ y must be assigned a number not less than i. For example, for a set of four points (0, 0), (0, 1), (1, 0) and (1, 1), there are two aesthetically pleasing numberings. One is 1, 2, 3, 4 and another one is 1, 3, 2, 4.

Wilbur's friend comes along and challenges Wilbur. For any point he defines it's special value as s(x, y) = y - x. Now he gives Wilbur some w1, w2,..., wn, and asks him to find an aesthetically pleasing numbering of the points in the set, such that the point that gets number i has it's special value equal to wi, that is s(xi, yi) = yi - xi = wi.

Now Wilbur asks you to help him with this challenge.

Input

The first line of the input consists of a single integer n (1 ≤ n ≤ 100 000) — the number of points in the set Wilbur is playing with.

Next follow n lines with points descriptions. Each line contains two integers x and y (0 ≤ x, y ≤ 100 000), that give one point in Wilbur's set. It's guaranteed that all points are distinct. Also, it is guaranteed that if some point (x, y) is present in the input, then all points (x', y'), such that 0 ≤ x' ≤ x and 0 ≤ y' ≤ y, are also present in the input.

The last line of the input contains n integers. The i-th of them is wi ( - 100 000 ≤ wi ≤ 100 000) — the required special value of the point that gets number i in any aesthetically pleasing numbering.

Output

If there exists an aesthetically pleasant numbering of points in the set, such that s(xi, yi) = yi - xi = wi, then print "YES" on the first line of the output. Otherwise, print "NO".

If a solution exists, proceed output with n lines. On the i-th of these lines print the point of the set that gets number i. If there are multiple solutions, print any of them.

Examples

Input

5
2 0
0 0
1 0
1 1
0 1
0 -1 -2 1 0


Output

YES
0 0
1 0
2 0
0 1
1 1


Input

3
1 0
0 0
2 0
0 1 2


Output

NO

Note

In the first sample, point (2, 0) gets number 3, point (0, 0) gets number one, point (1, 0) gets number 2, point (1, 1) gets number 5 and point (0, 1) gets number 4. One can easily check that this numbering is aesthetically pleasing and yi - xi = wi.

In the second sample, the special values of the points in the set are 0,  - 1, and  - 2 while the sequence that the friend gives to Wilbur is 0, 1, 2. Therefore, the answer does not exist.
Program:
```
from sys import stdin
from collections import *

rints = lambda : [int(x) for x in stdin.readline().split()]
(n, labels) = (int(input()), [[0 for _ in range(1000)] for _ in range(1000)])
(a, w) = ([rints() for _ in range(n)], rints())
func_1()

def func_1():
    (mem, mem2, out) = (Counter(w), defaultdict(list), [])
    for (x, y) in a:
        mem2[y - x].append([x, y])
    for (i, j) in mem.items():
        if len(mem2[i]) != j:
            print('NO')
            exit()
        mem2[i].sort(reverse=True)
    for i in range(n):
        (x, y) = mem2[w[i]][-1]
        labels[x][y] = i + 1
        if i and labels[x + 1][y] < labels[x][y] or labels[x][y + 1] < labels[x][y]:
            print('NO')
            exit()
        out.append(' '.join(map(str, mem2[w[i]].pop())))
    print('YES')
    print('\n'.join(out))


```
Original Assessment: Correctness: **False**

Explanation: The program does not handle the case where the coordinates of the points exceed the predefined size of the `labels` array. Specifically, the `labels` array is initialized with a fixed size of 1000x1000, but the problem description states that the coordinates can be up to 100,000. This can lead to an index out of bounds error when trying to access `labels[x][y]`.

For example, consider the following input:

```
2
100000 0
0 0
0 100000
```

This input will cause the program to fail because it tries to access `labels[100000][0]`, which is out of bounds for the `labels` array. Therefore, the program is incorrect.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
from sys import stdin
from collections import *

rints = lambda : [int(x) for x in stdin.readline().split()]
(n, labels) = (int(input()), [[0 for _ in range(1000)] for _ in range(1000)])
(a, w) = ([rints() for _ in range(n)], rints())
func_1()

#State of the program right berfore the function call: n is an integer where 1 ≤ n ≤ 100,000; the points are described by pairs of integers (x, y) where 0 ≤ x, y ≤ 100,000, and all points are distinct; the list of special values w is a list of integers of length n where -100,000 ≤ wi ≤ 100,000.
def func_1():
    mem, mem2, out = Counter(w), defaultdict(list), []
    for (x, y) in a:
        mem2[y - x].append([x, y])
        
    #State of the program after the  for loop has been executed: `n` is an integer where 1 ≤ n ≤ 100,000, the points are described by pairs of integers (x, y) where 0 ≤ x, y ≤ 100,000, and all points are distinct, `w` is a list of integers of length `n` where -100,000 ≤ `wi` ≤ 100,000, `mem` is a `Counter` object that counts the occurrences of each element in `w`, `mem2` is a `defaultdict` with a default type of `list`, and for each (x, y) in `a`, `mem2[y - x]` contains the list of all [x, y] pairs that have the same difference `y - x`, `out` is an empty list, `a` is a list of point pairs (x, y) that must have at least `n` points.
    for (i, j) in mem.items():
        if len(mem2[i]) != j:
            print('NO')
            exit()
        
        mem2[i].sort(reverse=True)
        
    #State of the program after the  for loop has been executed: `n` is an integer where \(1 \leq n \leq 100,000\), `w` is a list of integers of length `n` where \(-100,000 \leq w_i \leq 100,000\), `mem` is a `Counter` object that counts the occurrences of each element in `w`, `mem2` is a `defaultdict` with a default type of `list`, and for each (x, y) in `a`, `mem2[y - x]` contains the list of all [x, y] pairs that have the same difference `y - x`. Each list in `mem2` is sorted in descending order. `out` is an empty list, `a` is a list of point pairs (x, y) that must have at least `n` points, and for every key `i` in `mem`, the length of `mem2[i]` is equal to the corresponding value `j` in `mem`.
    for i in range(n):
        x, y = mem2[w[i]][-1]
        
        labels[x][y] = i + 1
        
        if i and labels[x + 1][y] < labels[x][y] or labels[x][y + 1] < labels[x][y]:
            print('NO')
            exit()
        
        out.append(' '.join(map(str, mem2[w[i]].pop())))
        
    #State of the program after the  for loop has been executed: `n` is an integer where \(1 \leq n \leq 100,000\), `w` is a list of integers of length `n` where \(-100,000 \leq w_i \leq 100,000\), `mem` is a `Counter` object that counts the occurrences of each element in `w`, `mem2` is a `defaultdict` with a default type of `list`, and for each (x, y) in `a`, `mem2[y - x]` contains the list of all [x, y] pairs that have the same difference `y - x`. Each list in `mem2` is sorted in descending order, `out` is a list containing `n` elements, each being the string representation of the last element of `mem2[w[i]]` before it was popped for each iteration `i` from 0 to `n-1`. For every key `i` in `mem`, the length of `mem2[i]` is equal to the corresponding value `j` in `mem` minus `j` (i.e., `mem2[i]` is empty). `i` is `n-1`, `x` and `y` are the last elements of the list `mem2[w[n-1]]` before it was popped, `labels[x][y]` is `n`. If during any iteration `i` is true and either `labels[x + 1][y] < labels[x][y]` or `labels[x][y + 1] < labels[x][y]`, the program terminates with no further changes to the state.
    print('YES')
    print('\n'.join(out))


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
