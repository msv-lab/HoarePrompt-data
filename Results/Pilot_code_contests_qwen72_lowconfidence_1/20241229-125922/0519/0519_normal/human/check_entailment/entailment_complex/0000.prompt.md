
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Quick sort is based on the Divide-and-conquer approach. In QuickSort(A, p, r), first, a procedure Partition(A, p, r) divides an array A[p..r] into two subarrays A[p..q-1] and A[q+1..r] such that each element of A[p..q-1] is less than or equal to A[q], which is, inturn, less than or equal to each element of A[q+1..r]. It also computes the index q.

In the conquer processes, the two subarrays A[p..q-1] and A[q+1..r] are sorted by recursive calls of QuickSort(A, p, q-1) and QuickSort(A, q+1, r).

Your task is to read a sequence A and perform the Partition based on the following pseudocode:


Partition(A, p, r)
1 x = A[r]
2 i = p-1
3 for j = p to r-1
4     do if A[j] <= x
5        then i = i+1
6            exchange A[i] and A[j]
7 exchange A[i+1] and A[r]
8 return i+1


Note that, in this algorithm, Partition always selects an element A[r] as a pivot element around which to partition the array A[p..r].

Constraints

* 1 ≤ n ≤ 100,000
* 0 ≤ Ai ≤ 100,000

Input

The first line of the input includes an integer n, the number of elements in the sequence A.

In the second line, Ai (i = 1,2,...,n), elements of the sequence are given separated by space characters.

Output

Print the sorted sequence. Two contiguous elements of the sequence should be separated by a space character. The element which is selected as the pivot of the partition should be indicated by [  ].

Example

Input

12
13 19 9 5 12 8 7 4 21 2 6 11


Output

9 5 8 7 4 2 6 [11] 21 13 19 12
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
from __future__ import division, print_function
from sys import stdin

n = int(stdin.readline())
data = [int(s) for s in stdin.readline().split()]
pat = func_1(data, 0, data[-1])
print(*data[:pat], end=' ')
print('[{}]'.format(data[pat]), *data[pat + 1:])

#State of the program right berfore the function call: a is a list of integers where 1 ≤ len(a) ≤ 100,000 and 0 ≤ ai ≤ 100,000, p and r are non-negative integers such that 0 ≤ p ≤ r < len(a).
def func_1(a, p, r):
    x = a[r]
    i = p - 1
    for j in range(p, r):
        if a[j] <= x:
            i += 1
            a[i], a[j] = a[j], a[i]
        
    #State of the program after the  for loop has been executed: `a` is a list of integers where \(1 \leq \text{len}(a) \leq 100,000\) and \(0 \leq a_i \leq 100,000\). `p` and `r` are non-negative integers such that \(0 \leq p \leq r < \text{len}(a)\). `x` is equal to `a[r]`. After the loop, all elements `a[p]` to `a[i]` are less than or equal to `x`, and all elements `a[i+1]` to `a[r-1]` are greater than `x`. `i` is the index of the last element in the segment from `a[p]` to `a[r-1]` that is less than or equal to `x`.
    a[i + 1], a[r] = a[r], a[i + 1]
    return i + 1
    #The program returns the index `i + 1`, where `i` is the index of the last element in the segment from `a[p]` to `a[r-1]` that is less than or equal to `x`. The value `x` is originally `a[r]`, and after the operation, `a[i + 1]` is equal to `x`, and `a[r]` is equal to the original value of `a[i + 1]`.
#Overall this is what the function does:The function `func_1` accepts a list of integers `a` and two non-negative integers `p` and `r` where `0 ≤ p ≤ r < len(a)`. It partitions the sublist `a[p:r+1]` such that all elements less than or equal to `a[r]` (the pivot) are moved to the left of the pivot, and all elements greater than the pivot are moved to the right. The function then places the pivot in its correct position within the sorted sublist and returns the index of the pivot. The final state of the list `a` is such that `a[p:i+1]` contains elements less than or equal to the pivot, and `a[i+2:r+1]` contains elements greater than the pivot, where `i + 1` is the returned index. The pivot element, originally at `a[r]`, is now at `a[i + 1]`. Edge cases include when `p == r` (the sublist contains only one element), in which case the function returns `r`, and when all elements in the sublist are equal to the pivot, in which case the function still correctly partitions the list and returns the appropriate index.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.

Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
