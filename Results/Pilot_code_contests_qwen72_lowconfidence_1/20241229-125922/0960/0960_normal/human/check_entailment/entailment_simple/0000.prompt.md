
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Bob got a job as a system administrator in X corporation. His first task was to connect n servers with the help of m two-way direct connection so that it becomes possible to transmit data from one server to any other server via these connections. Each direct connection has to link two different servers, each pair of servers should have at most one direct connection. Y corporation, a business rival of X corporation, made Bob an offer that he couldn't refuse: Bob was asked to connect the servers in such a way, that when server with index v fails, the transmission of data between some other two servers becomes impossible, i.e. the system stops being connected. Help Bob connect the servers.

Input

The first input line contains 3 space-separated integer numbers n, m, v (3 ≤ n ≤ 105, 0 ≤ m ≤ 105, 1 ≤ v ≤ n), n — amount of servers, m — amount of direct connections, v — index of the server that fails and leads to the failure of the whole system.

Output

If it is impossible to connect the servers in the required way, output -1. Otherwise output m lines with 2 numbers each — description of all the direct connections in the system. Each direct connection is described by two numbers — indexes of two servers, linked by this direct connection. The servers are numbered from 1. If the answer is not unique, output any.

Examples

Input

5 6 3


Output

1 2
2 3
3 4
4 5
1 3
3 5


Input

6 100 1


Output

-1
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n, m, v are integers such that 3 ≤ n ≤ 105, 0 ≤ m ≤ 105, 1 ≤ v ≤ n, where n represents the number of servers, m represents the number of direct connections, and v represents the index of the server whose failure will disconnect the system.
def func():
    n, m, v = map(int, raw_input().split())
    if (m < n - 1) :
        print(-1)
        exit()
    #State of the program after the if block has been executed: *`n`, `m`, and `v` are integers such that 3 ≤ n ≤ 105, 0 ≤ m ≤ 105, 1 ≤ v ≤ n. If `m` < `n - 1`, `-1` has been printed and the program has terminated.
    edges = [(i, i + 1) for i in xrange(n - 1)]
    m = m - len(edges)
    node1_nr = 1
    while m > 0 and node1_nr < n:
        node2_nr = node1_nr + 2
        
        while m > 0 and node2_nr < n:
            edges.append((node1_nr, node2_nr))
            m -= 1
            node2_nr += 1
        
        node1_nr += 1
        
    #State of the program after the loop has been executed: `n` is unchanged, `m` is the original value of `m` minus the total number of edges added, `v` is an integer such that 1 ≤ v ≤ n, `edges` is a list of tuples `[(i, i + 1) for i in range(n - 1)]` plus additional tuples `(node1_nr, node2_nr)` for each valid pair where `node1_nr` ranges from 1 to `n-1` and `node2_nr` ranges from `node1_nr + 2` to `n-1` while `m > 0`, `node1_nr` is `n`, `node2_nr` is `n` or greater.
    if (m > 0) :
        print(-1)
        exit()
    #State of the program after the if block has been executed: *`n` is unchanged, `m` is the original value of `m` minus the total number of edges added, `v` is an integer such that 1 ≤ v ≤ n, `edges` is a list of tuples `[(i, i + 1) for i in range(n - 1)]` plus additional tuples `(node1_nr, node2_nr)` for each valid pair where `node1_nr` ranges from 1 to `n-1` and `node2_nr` ranges from `node1_nr + 2` to `n-1` while `m > 0`, `node1_nr` is `n`, `node2_nr` is `n` or greater. If `m` > 0, the program has terminated.
    translate = [(i + 1) for i in xrange(n)]
    translate[v - 1], translate[1] = translate[1], translate[v - 1]
    output = [('%d %d' % (translate[n1], translate[n2])) for n1, n2 in edges]
    print('\n'.join(output))

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
