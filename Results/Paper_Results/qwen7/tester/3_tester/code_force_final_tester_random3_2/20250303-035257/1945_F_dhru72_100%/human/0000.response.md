To address the given problem, we need to implement a solution that finds the optimal number of mushrooms to pick to maximize the elixir's strength while ensuring the minimum number of mushrooms is used. Here are the comprehensive test cases:

### Basic Test Cases

#### Test 1
**Objective**: Verify the function works correctly when the permutation is the identity permutation.
**Input**:
```
3
9 8 14
1 2 3
```
**Output**:
```
16 2
```
**Explanation**: The permutation is the identity, so the first two mushrooms have the highest minimum value, and thus the optimal choice is to pick the first two mushrooms.

#### Test 2
**Objective**: Verify the function works correctly when the permutation is the reverse of the identity permutation.
**Input**:
```
3
9 8 14
3 2 1
```
**Output**:
```
16 2
```
**Explanation**: The permutation is the reverse of the identity, so the first two mushrooms still have the highest minimum value, and thus the optimal choice is to pick the first two mushrooms.

#### Test 3
**Objective**: Verify the function works correctly when the permutation is a random permutation.
**Input**:
```
3
9 8 14
2 1 3
```
**Output**:
```
16 2
```
**Explanation**: The permutation is a random permutation, but the first two mushrooms still have the highest minimum value, and thus the optimal choice is to pick the first two mushrooms.

### Edge Test Cases

#### Test 4
**Objective**: Verify the function handles a single mushroom.
**Input**:
```
1
10
10
1
```
**Output**:
```
10 1
```
**Explanation**: There is only one mushroom, so picking it gives the maximum strength and the minimum number of mushrooms.

#### Test 5
**Objective**: Verify the function handles a large number of mushrooms where the permutation is the identity.
**Input**:
```
1
5
1 2 3 4 5
1 2 3 4 5
```
**Output**:
```
15 3
```
**Explanation**: The permutation is the identity, so the first three mushrooms have the highest minimum value, and thus the optimal choice is to pick the first three mushrooms.

#### Test 6
**Objective**: Verify the function handles a large number of mushrooms where the permutation is the reverse of the identity.
**Input**:
```
1
5
1 2 3 4 5
5 4 3 2 1
```
**Output**:
```
15 3
```
**Explanation**: The permutation is the reverse of the identity, so the first three mushrooms still have the highest minimum value, and thus the optimal choice is to pick the first three mushrooms.

#### Test 7
**Objective**: Verify the function handles a large number of mushrooms where the permutation is a random permutation.
**Input**:
```
1
5
1 2 3 4 5
3 1 5 2 4
```
**Output**:
```
15 3
```
**Explanation**: The permutation is a random permutation, but the first three mushrooms still have the highest minimum value, and thus the optimal choice is to pick the first three mushrooms.

#### Test 8
**Objective**: Verify the function handles a large number of mushrooms where the permutation causes some mushrooms to have zero magic power.
**Input**:
```
1
5
1 2 3 4 5
2 1 4 3 5
```
**Output**:
```
12 3
```
**Explanation**: The permutation causes the second and fourth mushrooms to have zero magic power, so the first three mushrooms still have the highest minimum value, and thus the optimal choice is to pick the first three mushrooms.

#### Test 9
**Objective**: Verify the function handles a large number of mushrooms where the permutation causes all but one mushroom to have zero magic power.
**Input**:
```
1
5
1 2 3 4 5
5 4 3 2 1
```
**Output**:
```
5 1
```
**Explanation**: The permutation causes all but the first mushroom to have zero magic power, so the optimal choice is to pick the first mushroom.

### Full Implementation

```python
def max_strength_and_min_mushrooms(n, v, p):
    # Create a list to store the effective magic powers after applying the permutation
    effective_v = [0] * n
    for i in range(n):
        effective_v[i] = v[p[i] - 1]
    
    # Sort the effective magic powers
    sorted_v = sorted(effective_v)
    
    # Find the maximum strength and the minimum number of mushrooms needed
    max_strength = 0
    min_mushrooms = float('inf')
    for k in range(1, n + 1):
        current_strength = k * sorted_v[k - 1]
        if current_strength > max_strength:
            max_strength = current_strength
            min_mushrooms = k
    
    return max_strength, min_mushrooms

# Test cases
if __name__ == "__main__":
    # Test 1
    print("# Test 1")
    print("Input:")
    print("3\n9 8 14\n1 2 3")
    print("Output:")
    print(max_strength_and_min_mushrooms(3, [9, 8, 14], [1, 2, 3]))
    
    # Test 2
    print("\n# Test 2")
    print("Input:")
    print("3\n9 8 14\n3 2 1")
    print("Output:")
    print(max_strength_and_min_mushrooms(3, [9, 8, 14], [3, 2, 1]))
    
    # Test 3
    print("\n# Test 3")
    print("Input:")
    print("3\n9 8 14\n2 1 3")
    print("Output:")
    print(max_strength_and_min_mushrooms(3, [9, 8, 14], [2, 1, 3]))
    
    # Test 4
    print("\n# Test 4")
    print("Input:")
    print("1\n10\n10\n1")
    print("Output:")
    print(max_strength_and_min_mushrooms(1, [10], [1]))
    
    # Test 5
    print("\n# Test 5")
    print("Input:")
    print("1\n5\n1 2 3 4 5\n1 2 3 4 5")
    print("Output:")
    print(max_strength_and_min_mushrooms(5, [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]))
    
    # Test 6
    print("\n# Test 6")
    print("Input:")
    print("1\n5\n1 2 3 4 5\n5 4 3 2 1")
    print("Output:")
    print(max_strength_and_min_mushrooms(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]))
    
    # Test 7
    print("\n# Test 7")
    print("Input:")
    print("1\n5\n1 2 3 4 5\n3 1 5 2 4")
    print("Output:")
    print(max_strength_and_min_mushrooms(5, [1, 2, 3, 4, 5], [3, 1, 5, 2, 4]))
    
    # Test 8
    print("\n# Test 8")
    print("Input:")
    print("1\n5\n1 2 3 4 5\n2 1 4 3 5")
    print("Output:")
    print(max_strength_and_min_mushrooms(5, [1, 2, 3, 4, 5], [2, 1, 4, 3, 5]))
    
    # Test 9
    print("\n# Test 9")
    print("Input:")
    print("1\n5\n1 2 3 4 5\n5 4 3 2 1")
    print("Output:")
    print(max_strength_and_min_mushrooms(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]))
```

This implementation and the test cases cover both basic and edge scenarios, ensuring the robustness and reliability of the solution.