#State of the program right berfore the function call: func is a callable object representing a function that takes no arguments and returns a dictionary.
def func_1(func):
    d = {}
    return wrapper
    #The program returns a wrapper function that takes no arguments and returns a dictionary.
#Overall this is what the function does:The function accepts a callable object `func` that takes no arguments and returns a dictionary. It generates and returns a wrapper function that also takes no arguments and returns a dictionary.

#State of the program right berfore the function call: t is an integer such that 1 <= t <= 10^4. For each test case, n, m, and k are integers such that 2 <= n <= 10^5, 1 <= m, k <= 2 * 10^5. a is a list of n integers where 1 <= a_i <= 2 * 10^9 and a_i < a_{i+1}. d is a list of m integers where 1 <= d_i <= 10^9. f is a list of k integers where 1 <= f_i <= 10^9.
def wrapper():
    if (args not in d) :
        d[args] = func(*args)
    #State: `t` is an integer such that 1 <= t <= 10^4. For each test case, n, m, and k are integers such that 2 <= n <= 10^5, 1 <= m, k <= 2 * 10^5. `a` is a list of n integers where 1 <= a_i <= 2 * 10^9 and a_i < a_{i+1}. `d` is a list of m integers where 1 <= d_i <= 10^9. `f` is a list of k integers where 1 <= f_i <= 10^9. If the arguments passed are not in the list `d`, then `d[args]` is assigned the result of `func(*args)`.
    return d[args]
    #The program returns an element from list `d` based on the `args` provided, which are integers within the range 1 to m. If the provided arguments are not found in list `d`, then `d[args]` is assigned the result of `func(*args)`.
#Overall this is what the function does:The function `wrapper()` checks if the provided arguments are present in the list `d`. If the arguments are found, it returns the corresponding value from `d`. If the arguments are not found, it calls another function `func()` with the provided arguments, stores the result in `d`, and then returns this result.

#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 10^4. For each test case, n, m, and k are integers such that 2 ≤ n ≤ 10^5, 1 ≤ m, k ≤ 2·10^5. a is a list of n integers where 1 ≤ a_i ≤ 2·10^9 and a_i < a_{i+1}. d is a list of m integers where 1 ≤ d_i ≤ 10^9. f is a list of k integers where 1 ≤ f_i ≤ 10^9.
def func_2():
    return sys.stdin.readline().strip()
    #The program reads a line from standard input, strips any trailing whitespace, and returns it as a string.
#Overall this is what the function does:The function reads a line from standard input, removes any trailing whitespace, and returns it as a string.

#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 10^4. For each test case, n, m, and k are integers such that 2 ≤ n ≤ 10^5, 1 ≤ m, k ≤ 2⋅10^5. The list a is a sorted list of n integers such that 1 ≤ a_i ≤ 2⋅10^9 and a_i < a_{i+1}. The list d is a list of m integers such that 1 ≤ d_i ≤ 10^9. The list f is a list of k integers such that 1 ≤ f_i ≤ 10^9.
def func_3():
    return int(func_2())
    #The program returns an integer value generated by the function `func_2()` for each test case, given the constraints and initial states of variables `t`, `n`, `m`, `k`, lists `a`, `d`, and `f`.
#Overall this is what the function does:The function processes variables t, n, m, k, list a, list d, and list f according to their given constraints. For each test case defined by t, it calculates an integer value using the function `func_2()` and returns this integer value.

#State of the program right berfore the function call: t is an integer such that 1 <= t <= 10^4. For each test case, n, m, and k are integers such that 2 <= n <= 10^5, 1 <= m, k <= 2 * 10^5. a is a list of n integers where 1 <= a_i <= 2 * 10^9 and a_i < a_{i+1}. d is a list of m integers where 1 <= d_i <= 10^9. f is a list of k integers where 1 <= f_i <= 10^9.
def func_4(delimiter):
    return list(map(int, func_2().split(delimiter)))
    #The program returns a list of integers converted from a string split by a delimiter, where the string is obtained from the function `func_2()`
#Overall this is what the function does:The function accepts a `delimiter` parameter and returns a list of integers. This list is derived by splitting a string obtained from `func_2()` using the provided delimiter and then converting each resulting substring into an integer.

#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 10^4. For each test case, n, m, and k are integers such that 2 ≤ n ≤ 10^5, 1 ≤ m, k ≤ 2⋅10^5. a is a list of n integers where 1 ≤ a_i ≤ 2⋅10^9 and a_i < a_{i+1}. d is a list of m integers where 1 ≤ d_i ≤ 10^9. f is a list of k integers where 1 ≤ f_i ≤ 10^9.
def func_5():
    return func_2()
    #The program returns the result of calling the function `func_2()` with all the given parameters and lists intact.
#Overall this is what the function does:The function calls another function `func_2()` with the parameters `t`, `n`, `m`, `k`, and the lists `a`, `d`, and `f` intact and returns the result of this call.

#State of the program right berfore the function call: (n, m, k) are positive integers such that 2 ≤ n ≤ 10^5, 1 ≤ m, k ≤ 2 × 10^5; A is a list of n integers representing the complexities of the prepared problems, where 1 ≤ A[i] ≤ 2 × 10^9 and A[i] < A[i + 1]; D is a list of unique integers representing the complexities of the models, sorted in ascending order, where 1 ≤ D[i] ≤ 10^9; F is a list of k integers representing the complexities of the functions, where 1 ≤ F[i] ≤ 10^9.
def func_6():
    n, m, k = func_4()
    A = func_4()
    D = sorted(set(func_4()))
    F = func_4()
    max_diff, next_max_diff, index = -inf, -inf, None
    for i in range(1, n):
        diff = A[i] - A[i - 1]
        
        if diff > max_diff:
            max_diff = diff
            index = i
        elif diff > next_max_diff:
            next_max_diff = diff
        
    #State: Output State: `max_diff` is the largest difference found between consecutive elements in the list `A`, `next_max_diff` is the second largest difference found between consecutive elements in the list `A`, `index` is the index of the element where `max_diff` was found.
    left, right = A[index - 1], A[index]
    ans = max_diff
    for f in F:
        l = bisect_right(D, left - f)
        
        h = bisect_left(D, right - f) - 1
        
        while l < h:
            mid = l + (h - l) // 2
            mid_sum, mid_next_sum = D[mid] + f, D[mid + 1] + f
            if mid_sum - left < right - mid_next_sum:
                l = mid + 1
            else:
                h = mid
        
        if l == h:
            ans = min(ans, max(D[l] + f - left, right - D[l] - f))
        
    #State: max_diff is the largest difference found between consecutive elements in the list A, next_max_diff is the second largest difference found between consecutive elements in the list A, index is the index of the element where max_diff was found, left is A[index - 1], right is A[index], ans is the minimum value of max(D[l] + f - left, right - D[l] - f) for all f in F where l is the result of bisect_right(D, left - f) and h is the result of bisect_left(D, right - f) - 1, and l equals h.
    print(max(ans, next_max_diff))
    #This is printed: max(ans, next_max_diff)
#Overall this is what the function does:The function processes three lists: A, D, and F. List A contains the complexities of n problems, D contains unique complexities of models, and F contains complexities of k functions. It finds the largest and second-largest differences between consecutive problem complexities in A. Then, for each function complexity in F, it uses binary search to find the closest model complexities to the boundaries defined by these differences. Finally, it calculates the minimum adjusted difference considering the function complexity and prints the maximum of the largest difference and the calculated minimum adjusted difference.

#State of the program right berfore the function call: t is an integer such that 1 <= t <= 10^4. For each test case, n, m, and k are integers such that 2 <= n <= 10^5, 1 <= m, k <= 2 * 10^5. The list a is a sorted list of n integers such that 1 <= a_i <= 2 * 10^9 and a_i < a_{i+1}. The list d is a list of m integers such that 1 <= d_i <= 10^9. The list f is a list of k integers such that 1 <= f_i <= 10^9.
def func_7():
    testcases = func_3()
    for _ in range(testcases):
        func_6()
        
    #State: Output State: `testcases` is the result of `func_3()`, `t` is an integer such that 1 <= t <= 10^4. After executing the loop `testcases` times, for each test case, n, m, and k remain the same integers such that 2 <= n <= 10^5, 1 <= m, k <= 2 * 10^5. The list a remains a sorted list of n integers such that 1 <= a_i <= 2 * 10^9 and a_i < a_{i+1}. The list d remains a list of m integers such that 1 <= d_i <= 10^9. The list f remains a list of k integers such that 1 <= f_i <= 10^9. The loop does not modify these lists or variables; it only calls `func_6()` for each test case.
#Overall this is what the function does:The function processes multiple test cases, each involving a sorted list `a`, and lists `d` and `f`. For each test case, it calls `func_6()` without modifying the input lists `a`, `d`, and `f`. The function ultimately returns the result of `func_3()`, which represents the number of test cases processed.

