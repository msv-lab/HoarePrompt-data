Correctness: **False**

### Explanation:
The provided solution does not correctly solve the problem. The logic in the code is flawed because it does not properly identify the minimum number of elements that need to be removed to break the "beautiful" property of the array. Hereâ€™s why the current implementation is incorrect:

1. **Incorrect Logic for Identifying Minimum Removals**: The code attempts to find the minimum length of consecutive segments where elements are the same but does not account for the requirement to break the "beautiful" property by removing elements. It only finds the longest segment of consecutive identical elements and incorrectly assumes that removing this segment would be the solution.

2. **Misunderstanding the Problem**: The problem requires us to find the minimum number of removals to ensure the array is no longer "beautiful". The current approach does not correctly handle this requirement.

### Correct Approach:
To correctly solve this problem, we need to track the indices where the array loses its "beautiful" property. We should iterate through the array and keep track of the positions where elements change. The idea is to count these transitions and use them to determine the minimum number of removals needed.

Here is a corrected version of the program:

```python
def func():
    for _ in range(int(input())):
        n = int(input())
        ar = list(map(int, input().split()))
        
        # Track the indices where the array changes
        changes = []
        last_value = ar[0]
        for i in range(1, n):
            if ar[i] != last_value:
                changes.append(i)
                last_value = ar[i]
        
        # If there are no changes, the array is already beautiful
        if not changes:
            print(-1)
            continue
        
        # Calculate the minimum number of removals
        min_removals = len(changes) - 1
        print(min_removals)

# Example usage
func()
```

This solution works as follows:
1. **Track Changes**: Iterate through the array and record the indices where the value changes.
2. **Calculate Removals**: The number of removals needed is one less than the number of changes because each change indicates a point where the array can be split to break its "beautiful" property.

This approach ensures that the solution correctly identifies the minimum number of elements to remove to make the array non-beautiful.