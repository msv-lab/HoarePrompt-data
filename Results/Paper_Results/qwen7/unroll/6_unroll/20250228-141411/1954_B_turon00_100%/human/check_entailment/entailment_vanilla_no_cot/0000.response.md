Correctness: **False**

### Explanation:
The provided program does not correctly solve the problem. The logic in the program does not account for the specific operation required to determine if the array is beautiful or to find the minimum number of elements to remove to make it non-beautiful.

Hereâ€™s why the current implementation is incorrect:

1. **Incorrect Logic for Determining Beauty**: The program checks if consecutive elements are equal and counts the maximum streak of identical elements but does not simulate the operation described in the problem statement (i.e., replacing `a_i` with `a_{i-1}`).

2. **Misunderstanding the Problem**: The program tries to find the longest sequence of identical elements and considers that as the answer, which is not correct according to the problem's definition of a beautiful array.

3. **Handling Edge Cases**: The program does not handle edge cases properly, such as when the array has only one element or when the entire array is already beautiful.

### Correct Approach:
To solve this problem correctly, you need to simulate the operation described in the problem statement. Here's a corrected version of the program:

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().strip().split()))
        
        # Create a list to store the indices where the value changes
        change_points = []
        prev_value = a[0]
        for i in range(1, n):
            if a[i] != prev_value:
                change_points.append(i)
                prev_value = a[i]
        
        # If there are no change points, the array is already beautiful
        if len(change_points) == 0:
            print(-1)
            continue
        
        # Find the minimum number of elements to remove
        min_removals = float('inf')
        for i in range(len(change_points)):
            left = change_points[i-1] if i > 0 else 0
            right = change_points[i]
            min_removals = min(min_removals, right - left - 1)
        
        print(min_removals)

func()
```

This solution works as follows:

1. **Identify Change Points**: It identifies the indices where the value in the array changes.
2. **Calculate Minimum Removals**: For each segment between change points, it calculates the minimum number of removals needed to break the beauty condition.
3. **Output Result**: It outputs the minimum number of removals or `-1` if it's impossible to make the array non-beautiful.