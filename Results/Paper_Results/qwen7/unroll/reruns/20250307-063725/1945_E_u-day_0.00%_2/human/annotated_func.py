#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 2⋅10^4. Each test case consists of n and x, where 1 ≤ x ≤ n ≤ 2⋅10^5, and p is a permutation of integers from 1 to n.
def func_1():
    return map(int, input().split())
    #The program returns a map object containing two integers, which are the values of n and x separated by a space, converted to integers.
#Overall this is what the function does:The function reads two integers, `n` and `x`, from the standard input, separated by a space, converts them to integers, and returns a map object containing these two integers.

#State of the program right berfore the function call: t is a positive integer representing the number of test cases, each test case consists of two integers n and x where 1 ≤ x ≤ n ≤ 2⋅10^5, and a permutation p of size n consisting of distinct integers from 1 to n.
def func_2():
    return list(func_1())
    #The program returns a list generated by func_1(), which we do not have the definition of, but it processes the test cases, n, x, and permutation p as described.
#Overall this is what the function does:The function processes a series of test cases, each containing an integer \( t \) (the number of test cases), two integers \( n \) and \( x \) (where \( 1 \leq x \leq n \leq 2 \cdot 10^5 \)), and a permutation \( p \) of size \( n \) consisting of distinct integers from 1 to \( n \). After processing all test cases, it returns a list generated by `func_1()`.

#State of the program right berfore the function call: n is a positive integer representing the length of the permutation, k is an integer such that 1 ≤ k ≤ n, and arr is a list of n distinct integers from 1 to n representing the permutation.
def func_3():
    n, k = func_1()
    arr = func_2()
    pos = -1
    for i in range(n):
        if arr[i] == k:
            pos = i
        
    #State: Output State: `n` is a positive integer, `k` is an integer such that 1 ≤ k ≤ n, `arr` is the result of the function `func_2()` call, and `pos` is the index of the first occurrence of `k` in `arr`, or -1 if `k` is not found in `arr`.
    low, high = 0, n - 1
    st = set()
    while low + 1 < high:
        mid = (low + high) // 2
        
        st.add(mid)
        
        if arr[mid] > k:
            high = mid
        else:
            low = mid
        
    #State: Output State: `pos` is either the index of the first occurrence of `k` in `arr` where `low` + 1 equals `high`, or -1 if `k` is not found in `arr`. The set `st` contains all the indices `mid` calculated during the loop iterations, where `low + 1 < high`. Variables `low`, `high`, and `st` reflect the final state after the loop terminates.
    #
    #Explanation: The loop continues as long as `low + 1` is less than `high`. During each iteration, it calculates the middle index `mid` and updates `low` or `high` based on the comparison of `arr[mid]` with `k`. The set `st` accumulates all these `mid` values. When the loop ends, `low` and `high` will be adjacent, and `pos` will be the index of the first occurrence of `k` if it exists within this range; otherwise, `pos` remains -1.
    if (arr[low] == k) :
        print(0)
        #This is printed: 0
    else :
        print(1)
        #This is printed: 1
        print(low + 1, pos + 1)
        #This is printed: high, 0
    #State: `pos` is either the index of the first occurrence of `k` in `arr` where `low` + 1 equals `high`, or -1 if `k` is not found in `arr`. The set `st` contains all the indices `mid` calculated during the loop iterations, where `low + 1 < high`. Variables `low`, `high`, and `st` reflect the final state after the loop terminates. Regardless of whether `arr[low]` is equal to `k` or not, the final state of `pos`, `st`, `low`, and `high` remains consistent with the conditions described above.
#Overall this is what the function does:The function accepts a positive integer `n`, an integer `k` such that 1 ≤ k ≤ n, and a list `arr` of `n` distinct integers from 1 to n. It performs a binary search to find the first occurrence of `k` in `arr`. If `k` is found, it prints 0. If `k` is not found, it prints 1 followed by the value of `low + 1` and `pos + 1`. The function returns an integer, which will be 0 if `k` is found or 1 if `k` is not found.

