#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 2⋅10^4, n is an integer such that 1 ≤ n ≤ 2⋅10^5, x is an integer such that 1 ≤ x ≤ n, and p is a list of n integers representing a permutation of length n.
def func_1():
    return map(int, input().split())
    #The program returns a map object containing integers split from the input string.
#Overall this is what the function does:The function reads a line of space-separated integers from the standard input, converts each integer to a string, and returns a map object containing these integers.

#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 2⋅10^4, each test case consists of n and x where 1 ≤ x ≤ n ≤ 2⋅10^5, and p is a list of n integers representing a permutation of integers from 1 to n.
def func_2():
    return list(func_1())
    #The program returns a list generated by func_1(), which we do not have the definition of, but it processes the variables t, n, x, and p.
#Overall this is what the function does:The function processes the variables t, n, x, and p, where t is an integer between 1 and 20000, n and x are integers between 1 and 200000, and p is a list of n integers representing a permutation of integers from 1 to n. It then calls another function, func_1(), with these variables as input and returns the list generated by func_1().

#State of the program right berfore the function call: n is a positive integer representing the length of the permutation array, k is an integer such that 1 ≤ k ≤ n, and arr is a list of n distinct integers from 1 to n representing the permutation.
def func_3():
    n, k = func_1()
    arr = func_2()
    pos = -1
    for i in range(n):
        if arr[i] == k:
            pos = i
        
    #State: Output State: `n` is a positive integer representing the length of the permutation array, `k` is an integer such that 1 ≤ k ≤ n, `arr` is the result of calling `func_2()`, and `pos` is either the index `i` where `arr[i] == k` or -1 if no such index exists after all iterations.
    low, high = 0, n - 1
    st = set()
    while low + 1 < high:
        mid = (low + high) // 2
        
        st.add(mid)
        
        if arr[mid] > k:
            high = mid
        else:
            low = mid
        
    #State: The variable `pos` will be the index `i` where `arr[i] == k`, or -1 if no such index exists. The variable `st` will contain all the indices `mid` that were added during the loop iterations, which are calculated as `(low + high) // 2`. The variables `low` and `high` will be adjusted based on the condition `if arr[mid] > k: high = mid; else: low = mid`, until `low + 1` is no longer less than `high`.
    if (arr[low] == k) :
        print(0)
        #This is printed: 0
    else :
        print(1)
        #This is printed: 1
        print(low + 1, pos + 1)
        #This is printed: low + 1, -1
    #State: The variable `pos` is the index `low` where `arr[low] == k`, or -1 if no such index exists. The variable `st` contains all the indices `mid` that were added during the loop iterations, which are calculated as `(low + high) // 2`. The variables `low` and `high` are adjusted based on the condition `if arr[mid] > k: high = mid; else: low = mid`, until `low + 1` is no longer less than `high`. Additionally, if `arr[low]` is not equal to `k`, `pos` will be -1.
#Overall this is what the function does:The function determines whether the integer `k` is present in the permutation array `arr`. If `k` is found in `arr`, it prints `0` and exits. If `k` is not found, it prints `1` followed by the smallest index greater than or equal to `k` and `-1`. The function returns an integer indicating whether `k` was found (`0`) or not found (`1`).

