#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 2⋅10^4. Each test case consists of two integers n and x such that 1 ≤ x ≤ n ≤ 2⋅10^5, and a permutation p of length n consisting of distinct integers from 1 to n.
def func_1():
    return map(int, input().split())
    #The program returns a map object containing two integers, which are the result of splitting the input string based on spaces and converting each element to an integer.
#Overall this is what the function does:The function reads a line of input from the standard input, splits it into two parts based on spaces, converts these parts into integers, and returns them as a map object.

#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 2⋅10^4, each test case consists of n (1 ≤ n ≤ 2⋅10^5) and x (1 ≤ x ≤ n) where n is the length of the permutation p, and p is a list of n distinct integers from 1 to n.
def func_2():
    return list(func_1())
    #The program returns a list generated by func_1(), which we do not have the definition for, but it is expected to manipulate the permutation p based on the given conditions.
#Overall this is what the function does:The function accepts no parameters and returns a list. This list is generated by calling `func_1()`, which is expected to manipulate a permutation `p` of length `n` (where `1 ≤ n ≤ 2⋅10^5`) based on given conditions involving `n` and `x` (where `1 ≤ x ≤ n`). The final state of the program is the returned list from `func_1()`.

#State of the program right berfore the function call: n is a positive integer representing the length of the permutation array arr, k is an integer such that 1 ≤ k ≤ n, and arr is a list of n distinct integers from 1 to n representing the permutation.
def func_3():
    n, k = func_1()
    arr = func_2()
    pos = -1
    for i in range(n):
        if arr[i] == k:
            pos = i
        
    #State: Output State: `pos` is the index in the list `arr` where the value `k` is found, or `-1` if `k` is not present in `arr`.
    low, high = 0, n - 1
    st = set()
    while low + 1 < high:
        mid = (low + high) // 2
        
        st.add(mid)
        
        if arr[mid] > k:
            high = mid
        else:
            low = mid
        
    #State: The variable `low` will be equal to `high - 1`, `high` will be the index of the last element checked or `n` if `k` was not found, `pos` will be `-1` if `k` was not found in the array `arr`, and `st` will contain all the indices from `low` to `high - 1` inclusive.
    if (arr[low] == k) :
        print(0)
        #This is printed: 0
    else :
        print(1)
        #This is printed: 1
        print(low + 1, pos + 1)
        #This is printed: high, 0
    #State: The variable `low` will be equal to `high - 1`, `high` will be the index of the last element checked or `n` if `k` was not found, `pos` will be `-1` if `k` was not found in the array `arr`, and `st` will contain all the indices from `low` to `high - 1` inclusive. Additionally, if `arr[low]` is equal to `k`, then `pos` will be updated to `low`. Otherwise, `pos` remains `-1` and `st` remains unchanged.
#Overall this is what the function does:The function accepts a positive integer `n`, an integer `k` such that \(1 \leq k \leq n\), and a list `arr` of `n` distinct integers from 1 to n representing a permutation. It searches for the value `k` in the list `arr` and prints either `0` or `1` based on whether `k` is found. If `k` is found, it also prints the positions of `k` and the last element checked during the search. The function returns nothing but modifies the global variable `pos` to indicate the position of `k` if found, otherwise leaves it as `-1`.

