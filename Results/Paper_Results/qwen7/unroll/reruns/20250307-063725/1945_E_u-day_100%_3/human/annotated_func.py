#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 2⋅10^4. Each test case consists of n and x where 1 ≤ x ≤ n ≤ 2⋅10^5, and p is a list of n integers representing a permutation of numbers from 1 to n.
def func_1():
    return map(int, input().split())
    #The program returns a map object containing integers parsed from user input, which consists of two space-separated integers representing the variables t and another integer.
#Overall this is what the function does:The function reads two space-separated integers from user input, where the first integer represents a value t (with 1 ≤ t ≤ 2⋅10^4), and the second integer is another integer. It then returns a map object containing these two integers.

#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 2⋅10^4. Each test case consists of n and x where 1 ≤ x ≤ n ≤ 2⋅10^5, and p is a list of n integers representing a permutation of size n.
def func_2():
    return list(func_1())
    #The program returns a list generated by func_1(), which is not defined in the given information.
#Overall this is what the function does:The function returns a list generated by `func_1()`, which processes a permutation list `p` and integers `n` and `x` from a test case. The function itself does not accept any parameters and does not perform any operations directly; it solely relies on the output of `func_1()` to produce its result.

#State of the program right berfore the function call: n is a positive integer representing the length of the permutation, k is an integer such that 1 ≤ k ≤ n, and arr is a list of n distinct integers from 1 to n representing the permutation.
def func_3():
    n, k = func_1()
    arr = func_2()
    pos = -1
    for i in range(n):
        if arr[i] == k:
            pos = i
        
    #State: Output State: `n` is a positive integer representing the length of the permutation, `k` is an integer such that 1 ≤ k ≤ n, `arr` is the result of the function `func_2()`, and `pos` is either the index `i` where `arr[i] == k` or -1 if no such index exists.
    low, high = 0, n
    st = set()
    while low + 1 < high:
        mid = (low + high) // 2
        
        st.add(mid)
        
        if arr[mid] > k:
            high = mid
        else:
            low = mid
        
    #State: The variable `low` will be equal to the largest index `mid` such that `arr[mid] <= k`, `high` will be `low + 1`, `st` will contain all the indices `mid` that were added during the loop, and `pos` will be either the value of `low` if `arr[low] == k`, or -1 if no such index exists.
    if (arr[low] == k) :
        print(0)
        #This is printed: 0
    else :
        print(1)
        #This is printed: 1
        print(low + 1, pos + 1)
        #This is printed: low + 1, 0
    #State: Postcondition: `low` is the largest index such that `arr[mid] <= k`, `high` is `low + 1`, `st` contains all the indices `mid` that were added during the loop, and `pos` is either `low` if `arr[low] == k`, or -1 if no such index exists.
#Overall this is what the function does:The function accepts a positive integer `n` representing the length of a permutation, an integer `k` such that 1 ≤ k ≤ n, and a list `arr` of `n` distinct integers from 1 to n representing the permutation. It then finds the largest index `low` such that `arr[low] <= k`. If `arr[low] == k`, it prints 0; otherwise, it prints 1 followed by `low + 1` and `pos + 1`, where `pos` is the index of `k` in `arr` if it exists, or -1 if it does not. The function returns nothing.

