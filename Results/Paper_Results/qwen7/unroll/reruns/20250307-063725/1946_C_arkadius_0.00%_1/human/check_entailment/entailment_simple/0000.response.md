Reasoning:

1. **Tree Construction**: The program correctly constructs the tree using the `Tree` class and the `add_edge` method. The tree is rooted at vertex 0, and the `root_tree_non_recursive` method is used to populate the `children` and `subtree_size` attributes for each node.

2. **Finding Good Components**: The `func_1` function uses a post-order traversal to calculate the number of good components (`good_components`) and the remaining size (`remaining_size`) in the subtree rooted at each node. This function correctly updates these attributes based on the conditions provided.

3. **Checking Conditions**: The `func_3` function checks if it is possible to remove exactly `k` edges such that the size of each remaining connected component is at least `x`. It does this by calling `func_1` and checking the conditions:
   - If `good_components > k`, it returns `True` because we can always remove more than `k` edges.
   - If `good_components == k` and `remaining_size >= x`, it returns `True` because we can remove exactly `k` edges and satisfy the condition.
   - Otherwise, it returns `False`.

4. **Binary Search for Maximum `x`**: The `func_4` function performs a binary search to find the maximum `x` such that it is possible to remove exactly `k` edges and ensure that each remaining connected component has at least `x` vertices. This function correctly implements the binary search logic and uses `func_3` to check the conditions.

5. **Main Function**: The `func_5` function reads the input, constructs the tree, and prints the result of `func_4`, which is the maximum `x` satisfying the conditions.

Given that all functions are implemented correctly and the logic follows the problem statement accurately, the program should work as intended.

Correctness: **True**