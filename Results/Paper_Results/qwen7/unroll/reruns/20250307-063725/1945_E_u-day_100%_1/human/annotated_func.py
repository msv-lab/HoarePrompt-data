#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 2⋅10^4. Each test case consists of two integers n and x such that 1 ≤ x ≤ n ≤ 2⋅10^5, and a permutation p of length n consisting of integers from 1 to n.
def func_1():
    return map(int, input().split())
    #The program returns a map object containing two integers, which are the values of variables n and x separated by a space, converted to integers.
#Overall this is what the function does:The function reads a line of input from the standard input, splits it into two parts, converts these parts into integers, and returns a map object containing these two integers. These integers represent the values of variables n and x, where n and x are constrained by specific ranges (1 ≤ x ≤ n ≤ 2⋅10^5).

#State of the program right berfore the function call: t is a positive integer such that 1 ≤ t ≤ 2⋅10^4. Each test case consists of n, x, and a permutation p of size n where 1 ≤ x ≤ n ≤ 2⋅10^5, and 1 ≤ p_i ≤ n. The sum of all n values across all test cases does not exceed 2⋅10^5.
def func_2():
    return list(func_1())
    #The program returns a list generated by func_1(), which we do not have the definition for. However, we know each test case includes n, x, and a permutation p of size n, and the function likely processes these inputs to produce the list.
#Overall this is what the function does:The function does not accept any direct parameters but processes inputs (n, x, and a permutation p of size n) from the calling context to generate a list. This list is returned to the caller after being produced by `func_1()`.

#State of the program right berfore the function call: n is a positive integer representing the length of the permutation, k is an integer such that 1 ≤ k ≤ n, and arr is a list of n distinct integers from 1 to n representing the permutation.
def func_3():
    n, k = func_1()
    arr = func_2()
    pos = -1
    for i in range(n):
        if arr[i] == k:
            pos = i
        
    #State: pos is the index of the first occurrence of k in arr, or -1 if k is not in arr.
    low, high = 0, n
    st = set()
    while low + 1 < high:
        mid = (low + high) // 2
        
        st.add(mid)
        
        if arr[mid] > k:
            high = mid
        else:
            low = mid
        
    #State: low is the index of the first occurrence of `k` in `arr` or -1 if `k` is not in `arr`, `high` is `n`, `pos` is the index of the first occurrence of `k` in `arr` or -1 if `k` is not in `arr`, and `st` is a set containing all the indices `mid` that were checked during the binary search process.
    if (arr[low] == k) :
        print(0)
        #This is printed: 0
    else :
        print(1)
        #This is printed: 1
        print(low + 1, pos + 1)
        #This is printed: 0 0
    #State: Postcondition: `low` is the index of the first occurrence of `k` in `arr` or -1 if `k` is not in `arr`, `high` is `n`, `pos` is the index of the first occurrence of `k` in `arr` or -1 if `k` is not in `arr`, and `st` is a set containing all the indices `mid` that were checked during the binary search process. If `arr[low]` is equal to `k`, `low` and `pos` are set to the index of the first occurrence of `k`. Otherwise, `low` and `pos` retain their original values indicating that `k` is not found or the first occurrence of `k` could not be determined.
#Overall this is what the function does:The function accepts a positive integer `n`, an integer `k` such that `1 ≤ k ≤ n`, and a list `arr` of `n` distinct integers from 1 to n representing a permutation. It performs a binary search to find the first occurrence of `k` in `arr`. If `k` is found, it prints `0` and the index of the first occurrence of `k`. If `k` is not found or the first occurrence cannot be determined, it prints `1` and `0 0`. The function returns an integer, either `0` or `1`, based on whether `k` was found or not.

