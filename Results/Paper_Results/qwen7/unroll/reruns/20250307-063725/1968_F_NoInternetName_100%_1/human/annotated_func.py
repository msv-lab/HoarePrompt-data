#State of the program right berfore the function call: cast is a callable function that can convert strings to the appropriate type (e.g., int), and the input is a space-separated string of integers.
def func_1(cast):
    return map(cast, input().split())
    #The program returns a map object that applies the 'cast' function to each element in the input string split by spaces.
#Overall this is what the function does:The function accepts a callable function `cast` and a space-separated string of integers as input. It splits the string into individual elements, converts each element to the type specified by `cast`, and returns a map object containing these converted values.

#State of the program right berfore the function call: arr is a list of integers, and predicate is a function that takes an integer as input and returns a boolean. The predicate function is used to check a condition on the elements of arr, and the goal is to find the leftmost index where the predicate returns True within the range [l, r).
def func_2(arr, predicate):
    l, r = 0, len(arr)
    while l + 1 < r:
        mid = (l + r) // 2
        
        if predicate(arr[mid]):
            l = mid
        else:
            r = mid
        
    #State: l is the index of the first element that does not satisfy the predicate, or l is equal to the length of arr if no such element exists; r is l + 1.
    if predicate(arr[l]) :
        return l
        #The program returns the index 'l' of the first element that satisfies the predicate, or 'l' equals the length of 'arr' if no such element exists.
    #State: l is the index of the first element that does not satisfy the predicate, or l is equal to the length of arr if no such element exists; r is l + 1, and the predicate(arr[l]) is False
    return None
    #The program returns None
#Overall this is what the function does:The function `func_2` accepts a list of integers `arr` and a predicate function `predicate`. It searches for the leftmost index `l` in the list where the predicate returns `True`. If such an index is found, it returns `l`; otherwise, it returns `None`.

#State of the program right berfore the function call: arr is a list of integers, and predicate is a function that takes an integer and returns a boolean.
def func_3(arr, predicate):
    return func_2(arr, predicate)
    #The program returns a value determined by applying function `func_2` to list `arr` using predicate function `predicate`
#Overall this is what the function does:The function accepts a list of integers `arr` and a predicate function `predicate`. It applies the predicate function to each element in the list `arr` and returns a value determined by the results of these applications.

#State of the program right berfore the function call: arr is a list of integers where each element is in the range [0, 2^30), and predicate is a function that takes an integer and returns a boolean.
def func_4(arr, predicate):
    result = func_2(arr, predicate)
    if (result is not None) :
        return result + 1
        #The program returns the value of `result` plus 1, where `result` is the return value of `func_2(arr, predicate)`
    #State: `arr` is a list of integers where each element is in the range [0, 2^30), and `result` is None
    return None
    #The program returns None
#Overall this is what the function does:The function accepts a list of integers `arr` and a predicate function `predicate`. It calls another function `func_2(arr, predicate)` and returns the value returned by `func_2` incremented by 1, if `func_2` returns a value. If `func_2` does not return a value, the function returns `None`.

#State of the program right berfore the function call: (n, q) are positive integers such that 2 <= n <= 2 * 10^5 and 1 <= q <= 2 * 10^5. a is a list of integers where 0 <= a_i < 2^30. l and r are positive integers such that 1 <= l < r <= n for each query.
def func_5():
    n, q = func_1(int)
    a = list(func_1(int))
    x = [0]
    inds = defaultdict(list)
    inds[0].append(0)
    for i in a:
        x.append(x[-1] ^ i)
        
        inds[x[-1]].append(len(x) - 1)
        
    #State: Output State: `inds` is a dictionary where each key is an integer generated by the expression `x[-1] ^ i` for each iteration, and the value for each key is a list of indices where that key appears in the list `x`. The list `x` contains integers generated by XORing the previous element with each element in the list `a`. The variable `l`, `r`, and `x` remain unchanged from their initial state, with `x` containing a single element 0.
    for i in range(q):
        l, r = func_1(int)
        
        if x[l - 1] == x[r]:
            print('Yes')
            continue
        
        lower = inds[x[r]][func_4(inds[x[r]], lambda arg: arg < l) or 0]
        
        upper = inds[x[l - 1]][func_3(inds[x[l - 1]], lambda arg: arg <= r)]
        
        if upper > lower:
            print('Yes')
        else:
            print('No')
        
    #State: The dictionary `inds` remains unchanged, and the loop prints 'Yes' if there exists any valid pair `(l, r)` such that either `x[l-1] == x[r]` or the number of indices in the range `[lower, upper]` where the condition holds true, otherwise it prints 'No'.
#Overall this is what the function does:The function accepts two positive integers \( n \) and \( q \), along with a list \( a \) of integers and multiple queries defined by pairs of positive integers \( l \) and \( r \). It constructs a list \( x \) where each element is the cumulative XOR of the previous element in \( x \) and the corresponding element in \( a \). For each query, it checks if there exists any valid pair \( (l, r) \) such that either \( x[l-1] == x[r] \) or the number of indices in the range \([lower, upper]\) where the condition holds true. If such a pair exists, it prints 'Yes'; otherwise, it prints 'No'. The function does not modify the input list \( a \) or the dictionary \( inds \).

