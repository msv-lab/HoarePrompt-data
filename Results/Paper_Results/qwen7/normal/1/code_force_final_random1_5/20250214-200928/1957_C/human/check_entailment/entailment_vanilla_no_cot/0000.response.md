Correctness: **False**

### Explanation:

The provided program does not correctly solve the problem. Here's why:

1. **Dynamic Programming Initialization and Calculation**: The `func_1` function initializes the dynamic programming array `dp` but only calculates values up to `dp[300000]`. However, the actual size of the chessboard `n` can be much smaller than this limit, and the calculation logic is incomplete. The formula used in the loop is also incorrect for the problem's requirements.

2. **Set Usage for Invalid Positions**: The `invalid` set is used to track positions that are already occupied. This part is correct in terms of identifying invalid positions. However, the usage of `max(1, dp[n - len(invalid)])` is incorrect because it does not correctly calculate the number of valid configurations based on the remaining positions.

3. **Final Configuration Calculation**: The core logic to calculate the number of valid final configurations is missing. The dynamic programming approach should consider the remaining rows and columns after accounting for the invalid positions. The current implementation does not handle this correctly.

### Correct Approach:

To solve this problem correctly, you need to use combinatorial mathematics and dynamic programming to count the number of ways to place the remaining rooks. Here's a more accurate approach:

1. **Count Remaining Rows and Columns**: After accounting for the invalid positions, count the number of remaining rows and columns.
2. **Dynamic Programming for Configurations**: Use dynamic programming to count the number of ways to place the remaining rooks such that no two rooks attack each other.

Hereâ€™s a corrected version of the program:

```python
import sys

sys.setrecursionlimit(400000)
mod = 1000000007

def count_ways(n, invalid_rows, invalid_cols):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        if i not in invalid_rows and i not in invalid_cols:
            dp[i] = (dp[i-1] + 2 * (i - 1) * dp[i-2]) % mod
    return dp[n]

t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    invalid_rows = set()
    invalid_cols = set()
    for _ in range(k):
        r, c = map(int, input().split())
        invalid_rows.add(r)
        invalid_cols.add(c)
    
    remaining_rows = n - len(invalid_rows)
    remaining_cols = n - len(invalid_cols)
    ans = count_ways(min(remaining_rows, remaining_cols), invalid_rows, invalid_cols)
    print(ans)
```

This corrected version properly counts the number of valid configurations using dynamic programming and handles the constraints and requirements of the problem accurately.