Correctness: **False**

### Explanation:
The provided solution has a logical error in how it handles the operations and queries. Specifically, the function `func_1` does not correctly simulate the operations as described in the problem statement. Hereâ€™s why:

1. **Operation Handling**: 
   - When an operation of type 1 is performed, the value should be appended to the array.
   - When an operation of type 2 is performed, the array should be extended by appending `x` copies of the current array.

2. **Current Implementation**:
   - The function `func_1` only handles the extension operation correctly but fails to handle the append operation properly. It simply appends the value directly without considering the previous state of the array.
   - The modulo operation used in the query (`(k - 1) % len(array)`) will not give the correct result because the array length can change dynamically with each operation.

To fix this, we need to maintain the history of the array and its length after each operation. Here is a corrected version of the code:

```python
def func_1(n, operations, queries):
    array = []
    lengths = [0]  # To keep track of the length of the array after each operation
    for (op_type, value) in operations:
        if op_type == 1:
            array.append(value)
            lengths.append(len(array))
        else:
            x = value
            new_length = lengths[-1] * x
            array.extend([array[i % lengths[-1]] for i in range(new_length)])
            lengths.append(new_length)
    
    result = []
    for k in queries:
        index = k - 1
        for i in range(len(lengths) - 1, 0, -1):
            if index >= lengths[i]:
                index -= lengths[i]
            else:
                break
        result.append(array[index])
    return result

def func_2():
    t = int(input())
    for _ in range(t):
        (n, q) = map(int, input().split())
        operations = [list(map(int, input().split())) for _ in range(n)]
        queries = list(map(int, input().split()))
        result = func_1(n, operations, queries)
        print(*result)

# Example usage
if __name__ == "__main__":
    func_2()
```

This corrected version maintains the history of the array and its length after each operation, ensuring that the queries are answered correctly.