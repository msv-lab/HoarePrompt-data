Correctness: **False**

### Explanation:
The provided Python program does not correctly solve the problem. Here are the key issues:

1. **Function `func_1` is not properly defined**: The function `func_1` is defined but never called within the main loop where the test cases are processed. Instead, the function `func_1` should be called inside the loop to process each test case.

2. **Incorrect logic for determining if the array is beautiful**: The current implementation checks if the array is already beautiful by comparing adjacent elements. However, this is not the correct approach. The problem states that an array is beautiful if you can make all its elements the same by using the specified operation. The current implementation does not correctly identify whether the array is beautiful according to the given definition.

3. **Incorrect calculation of the minimum number of removals**: The logic for calculating the minimum number of removals is flawed. It assumes that the array is already beautiful and tries to find the minimum number of consecutive elements that are the same. This does not account for the possibility of making the array non-beautiful by removing elements in a way that breaks the pattern required for the array to be beautiful.

### Corrected Program:
Here is a corrected version of the program:

```python
def func_1():
    n = int(input())
    arr = list(map(int, input().split()))
    
    # Find the longest segment of consecutive equal elements
    max_consecutive = 1
    current_consecutive = 1
    for i in range(1, n):
        if arr[i] == arr[i - 1]:
            current_consecutive += 1
            max_consecutive = max(max_consecutive, current_consecutive)
        else:
            current_consecutive = 1
    
    # If the entire array is made of one element, it's already beautiful
    if max_consecutive == n:
        print(-1)
    else:
        print(n - max_consecutive)

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        func_1()
```

This corrected program:
- Determines the length of the longest segment of consecutive equal elements.
- Checks if the entire array is made of one element, in which case it prints `-1`.
- Otherwise, it calculates the minimum number of elements to remove by subtracting the length of the longest segment from the total number of elements.