
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
In a well-known school, a physical education lesson took place. As usual,
everyone was lined up and asked to settle in "the first–k -th" position.

As is known, settling in "the first–k -th" position occurs as follows: the
first k people have numbers 1, 2, 3, \ldots, k , the next k - 2 people have
numbers k - 1, k - 2, \ldots, 2 , the next k people have numbers 1, 2, 3,
\ldots, k , and so on. Thus, the settling repeats every 2k - 2 positions.
Examples of settling are given in the "Note" section.

The boy Vasya constantly forgets everything. For example, he forgot the number
k described above. But he remembers the position he occupied in the line, as
well as the number he received during the settling. Help Vasya understand how
many natural numbers k fit under the given constraints.

Note that the settling exists if and only if k > 1 . In particular, this means
that the settling does not exist for k = 1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 100 ) — the number of test cases. This is followed by
the description of the test cases.

The only line of each test case contains two integers n and x (1 \le x < n \le
10^9 ) — Vasya's position in the line and the number Vasya received during the
settling.

Output

For each test case, output a single integer — the number of different k that
fit under the given constraints.

It can be proven that under the given constraints, the answer is finite.

Example

Input

    5
    
    10 2
    
    3 1
    
    76 4
    
    100 99
    
    1000000000 500000000

Output

    4
    1
    9
    0
    1
    
Note

In the first test case, k equals 2, 3, 5, 6 are suitable.

An example of settling for these k :

k / №| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10   
---|---|---|---|---|---|---|---|---|---|---  
2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2   
3 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 | 2   
5 | 1 | 2 | 3 | 4 | 5 | 4 | 3 | 2 | 1 | 2   
6 | 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 | 3 | 2   
  
In the second test case, k = 2 is suitable.

# Annotated Functions:
for _ in range(int(input())):
    (n, x) = map(int, input().split())
    ans = 1
    h = n - x
    ans = set((k for k in func_1(h) if not k % 2 and k / 2 + 1 >= x))
    ans2 = set()
    if x != 1:
        h = n + x - 2
        ans2 = set((k for k in func_1(h) if not k % 2 and k / 2 + 1 >= x))
    ans = ans.union(ans2)
    print(len(ans))

#Function 1:
#State of the program right berfore the function call: n is a positive integer greater than 1.
def func_1(n):
    factors = {}
    nn = n
    i = 2
    while i * i <= nn:
        while nn % i == 0:
            factors[i] = factors.get(i, 0) + 1
            nn //= i
        
        i += 1
        
    #State: Output State: `i` is 4; `nn` is 1; `factors` is a dictionary with key 2 and value 2, key 3 and value 3.
    #
    #Explanation: After the loop has executed all its iterations, the value of `i` will be incremented to 4 (since it starts from 2 and increments by 1 each iteration). The value of `nn` becomes 1 because it is continuously divided by its factors until it can no longer be divided (as seen in the output states after 2 and 3 iterations). The `factors` dictionary contains the prime factorization of the original number `n`, which in this case is 2^2 * 3^3 based on the given output states.
    if (nn > 1) :
        factors[nn] = factors.get(nn, 0) + 1
    #State: `i` is 4, `nn` is 1, `factors` is a dictionary with key 2 and value 2, key 3 and value 3, and if `nn` is greater than 1, `factors[nn]` is 1.
    primes = list(factors.keys())
    for factor in generate(0):
        yield factor
        
    #State: Output State: The loop will continue to execute until `generate(0)` no longer produces any values. Since we do not have the definition of `generate(0)`, we can infer that the loop will keep yielding factors until there are no more factors left to yield. After executing all iterations, `factor` will be set to the last value generated by `generate(0)`. The variables `i`, `nn`, `factors`, and `primes` will retain their final states from the last iteration of the loop.
    #
    #In Natural Language: After all iterations of the loop have finished, the variable `factor` will hold the last value generated by the `generate(0)` function. The values of `i`, `nn`, `factors`, and `primes` will remain unchanged from their state after the last iteration of the loop.
#Overall this is what the function does:The function accepts a positive integer \( n \) greater than 1 and returns a generator that yields the prime factors of \( n \). If \( n \) is a prime number, it will yield \( n \) itself. The function computes the prime factorization of \( n \) and stores it in a dictionary called `factors`. It then yields each prime factor, one by one, using a generator function `generate(0)`. The final state of the program includes the prime factors stored in `factors` and the last yielded factor from `generate(0)`.

#Function 2:
#State of the program right berfore the function call: **
def generate(k):
    if (k == len(primes)) :
        yield 1
    else :
        rest = generate(k + 1)
        prime = primes[k]
        for factor in rest:
            prime_to_i = 1
            
            for _ in range(factors[prime] + 1):
                yield factor * prime_to_i
                prime_to_i *= prime
            
        #State: Output State: All prime factors in the `factors` dictionary have been processed, meaning their corresponding values are all set to -1. For each prime factor `prime` that appeared in the `factors` dictionary, `prime_to_i` will hold the product of `prime` raised to the power of its original count in `factors`. Additionally, the loop will have yielded a sequence of values, each being the product of a `factor` from `rest` and the final value of `prime_to_i` for each prime factor processed.
        #
        #In more detail:
        #- The `factors` dictionary will no longer contain any keys with non-zero values; all values will be -1, indicating that all prime factors have been fully processed.
        #- The variable `prime_to_i` will hold the product of `prime` raised to the power of its original count in `factors`.
        #- The variable `rest` will be empty, as all factors have been processed.
        #- The loop will have yielded a sequence of values, each being the product of a `factor` from `rest` and the final value of `prime_to_i` for each prime factor processed.
    #State: `k` is equal to the length of the list `primes`, and 1 is yielded. If `k` is not equal to the length of the list `primes`, then all prime factors in the `factors` dictionary have been processed, meaning their corresponding values are all set to -1. For each prime factor `prime` that appeared in the `factors` dictionary, `prime_to_i` will hold the product of `prime` raised to the power of its original count in `factors`. Additionally, the loop will have yielded a sequence of values, each being the product of a `factor` from `rest` and the final value of `prime_to_i` for each prime factor processed.
#Overall this is what the function does:The function `generate` processes a dictionary of prime factors (`factors`) and yields a sequence of values. Initially, it checks if the current index `k` equals the length of the list `primes`. If so, it yields 1. Otherwise, it recursively generates factors for the next prime and multiplies them with the current prime to produce new values. It continues this process until all prime factors in the `factors` dictionary are processed, at which point it yields the final sequence of values. The function modifies the `factors` dictionary by setting all remaining values to -1, indicating that all prime factors have been fully processed.




# Your response:
Reasoning:  
Correctness: **True** or **False**

