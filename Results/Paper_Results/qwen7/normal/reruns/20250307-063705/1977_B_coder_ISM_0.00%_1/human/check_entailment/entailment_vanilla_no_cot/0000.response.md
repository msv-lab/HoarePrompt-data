Correctness: **False**

### Explanation:
The provided solution attempts to solve the problem but contains several issues that make it incorrect:

1. **Incorrect Initialization and Logic**: The initial logic for constructing the array `s` from the binary representation of `x` is flawed. It simply appends '1' or '0' based on whether `x` has the bit set at position `i`. This does not ensure the constraints of the problem, particularly the constraint about consecutive non-zero elements.

2. **Modification Logic**: The subsequent logic to modify the array `s` to meet the constraints is also incorrect. It incorrectly changes elements to '-1' and '0', which doesn't necessarily ensure that no two consecutive non-zero elements exist.

3. **Length Calculation**: The length calculation and appending of elements to the array `s` do not correctly reflect the constraints of the problem.

Here's a corrected version of the program:

```python
def func():
    t = int(input())
    for _ in range(t):
        x = int(input())
        # Convert x to its binary representation with leading zeros
        binary_representation = bin(x)[2:].zfill(30)
        
        # Construct the array a
        a = []
        for bit in binary_representation:
            a.append(int(bit))
        
        # Ensure no two consecutive non-zero elements
        for i in range(len(a) - 1):
            if a[i] != 0 and a[i + 1] != 0:
                if a[i] == 1 and a[i + 1] == 1:
                    a[i] = -1
                    a[i + 1] = 0
                elif a[i] == -1 and a[i + 1] == -1:
                    a[i] = 0
                    a[i + 1] = -1
        
        # Determine the length of the array
        length = len(a)
        
        # Print the length and the array
        print(length)
        print(' '.join(map(str, a)))

func()
```

This corrected version ensures that the binary representation of `x` is constructed correctly and then modifies the array to ensure no two consecutive non-zero elements exist.