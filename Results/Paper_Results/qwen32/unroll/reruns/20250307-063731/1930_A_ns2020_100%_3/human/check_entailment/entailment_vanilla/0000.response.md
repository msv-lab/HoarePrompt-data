### Reasoning:
To solve this problem, we need to maximize the score by performing the described operations optimally. The key insight is that to maximize the sum of the minimums of pairs, we should pair the smallest numbers together. This is because the smallest number in each pair will contribute to the score, and by pairing the smallest numbers, we ensure that the contributions to the score are maximized.

Here's a step-by-step breakdown of the program:

1. **Reading Input**:
   - The program first reads the number of test cases `t`.
   - For each test case, it reads the integer `n` (which indicates that there are `2n` numbers on the whiteboard).
   - It then reads the `2n` integers representing the numbers on the whiteboard.

2. **Sorting**:
   - The program sorts the list of numbers in ascending order. This is crucial because we want to pair the smallest numbers together to maximize the sum of the minimums.

3. **Calculating the Score**:
   - After sorting, the program calculates the score by summing every second element starting from the first element (i.e., `A[0]`, `A[2]`, `A[4]`, ..., `A[2n-2]`). This is because, in the sorted list, these elements are the smaller ones in their respective pairs.

4. **Output**:
   - The program prints the calculated score for each test case.

### Verification:
- The approach ensures that we are always adding the smallest possible number from each pair to the score, which is optimal.
- The time complexity of the solution is dominated by the sorting step, which is \(O(2n \log(2n)) = O(n \log n)\), which is efficient given the constraints.

### Conclusion:
The provided program correctly implements the optimal strategy to solve the problem. Therefore, the correctness of the program is:

Correctness: **True**