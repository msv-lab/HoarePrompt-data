### Reasoning:

1. **Problem Understanding:**
   - We need to find the maximum number `x` such that after removing exactly `k` edges from a tree with `n` vertices, all resulting connected components have at least `x` vertices.

2. **Approach:**
   - The solution employs a binary search on the possible values of `x` (from `1` to `n // k`).
   - For each `x`, the `check` function determines if it's possible to remove exactly `k` edges such that all resulting connected components have at least `x` vertices.
   - The `check` function uses a depth-first search (DFS) to traverse the tree and count the sizes of the subtrees.

3. **Function `func_1`:**
   - This function initializes the adjacency list `g` for the tree.
   - It performs a binary search on the possible values of `x` to find the maximum possible value that satisfies the condition.
   - It prints the maximum value of `x` for which the `check` function returns `True`.

4. **Function `check`:**
   - This function performs a DFS to traverse the tree.
   - It keeps track of the sizes of the subtrees.
   - It checks if the number of subtrees with sizes at least `A` is exactly `k` or if the entire tree's size is at least `A` and exactly `k` subtrees meet the condition.

5. **Correctness:**
   - The binary search ensures that we efficiently find the maximum possible value of `x`.
   - The `check` function correctly determines if the condition is met by using DFS to traverse the tree and count the sizes of the subtrees.
   - The adjacency list `g` is correctly initialized and used in the DFS traversal.
   - The program handles multiple test cases and processes each set of input data correctly.

### Conclusion:
The provided program correctly implements the logic required to solve the problem as described. The binary search and DFS traversal work together to find the maximum number `x` such that after removing exactly `k` edges, all resulting connected components have at least `x` vertices.

**Correctness: True**