### Reasoning:

The problem requires counting the number of "beautiful pairs" in an array for multiple test cases. A pair \(\langle i, j \rangle\) is considered beautiful if:
1. \(a_i + a_j\) is divisible by \(x\).
2. \(a_i - a_j\) is divisible by \(y\).

#### Analysis of `func_1`:
1. **Initialization**: `freq` is a dictionary to keep track of the frequency of pairs \((rx, ry)\) where `rx` is the adjusted remainder of an element when divided by `x` and `ry` is the remainder of the element when divided by `y`.
2. **Loop through array**: For each element `a` in the array:
   - Calculate `rx` as \((-a \% x + x) \% x\). This ensures that `rx` is always non-negative and represents the remainder when `-a` is divided by `x`.
   - Calculate `ry` as `a \% y`.
   - If the pair `(rx, ry)` has been seen before, add its frequency to the count of beautiful pairs.
   - Update the frequency dictionary with the current pair `(a \% x, a \% y)`.
3. **Return results**: After processing all elements in the array, append the count of beautiful pairs to the results list.

#### Analysis of `func_2`:
1. **Reading input**: Reads the entire input and splits it into lines.
2. **Parsing test cases**: For each test case, parse the number of elements `n`, the integers `x` and `y`, and the array `arr`.
3. **Processing test cases**: Calls `func_1` to process all test cases and get the results.
4. **Output results**: Prints the results for each test case.

### Correctness Verification:
- **Logic for beautiful pairs**: The logic in `func_1` correctly identifies pairs \(\langle i, j \rangle\) that satisfy both conditions:
  - \(a_i + a_j \equiv 0 \pmod{x}\) translates to \(-a_i \equiv a_j \pmod{x}\), which is checked using `rx`.
  - \(a_i - a_j \equiv 0 \pmod{y}\) translates to \(a_i \equiv a_j \pmod{y}\), which is checked using `ry`.
- **Efficiency**: The use of a dictionary to keep track of previously seen pairs ensures that the solution is efficient, with a time complexity of \(O(n)\) per test case, which is suitable given the constraints.

### Conclusion:
The program correctly implements the logic to find the number of beautiful pairs for each test case and outputs the results as required.

**Correctness: True**