Task ID,unique_id,Dataset,model_created,model_run,description,Code,run_number,original correctness,summary fsl,naive correctness fsl,vanilla,vanilla_no_cot,simple tree,complex tree,summary,simple verify fsl,complex verify fsl,summary verify fsl,simple verify,complex verify,summary verify,consistency,consistency_mine,consistency_old
1974_A,1974_A_Ridham__100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Little Rosie has a phone with a desktop (or launcher, as it is also called).
The desktop can consist of several screens. Each screen is represented as a
grid of size 5 \times 3 , i.e., five rows and three columns.

There are x applications with an icon size of 1 \times 1 cells; such an icon
occupies only one cell of the screen. There are also y applications with an
icon size of 2 \times 2 cells; such an icon occupies a square of 4 cells on
the screen. Each cell of each screen can be occupied by no more than one icon.

Rosie wants to place the application icons on the minimum number of screens.
Help her find the minimum number of screens needed.

Input

The first line of the input contains t (1 \leq t \leq 10^4 ) — the number of
test cases.

The first and only line of each test case contains two integers x and y (0
\leq x, y \leq 99 ) — the number of applications with a 1 \times 1 icon and
the number of applications with a 2 \times 2 icon, respectively.

Output

For each test case, output the minimal number of required screens on a
separate line.

Example

Input

    11
    
    1 1
    
    7 2
    
    12 4
    
    0 3
    
    1 0
    
    8 1
    
    0 0
    
    2 0
    
    15 0
    
    8 2
    
    0 9

Output

    1
    1
    2
    2
    1
    1
    0
    1
    1
    2
    5
    
Note

The solution for the first test case can look as follows:

![](https://espresso.codeforces.com/f9882979f0d9b5c31c5260fd626217227c2f05de.png)
Blue squares represent empty spaces for icons, green squares represent 1
\times 1 icons, red squares represent 2 \times 2 icons

The solution for the third test case can look as follows:

![](https://espresso.codeforces.com/0e737a290e056a29f38918bf06c13be790307a8d.png)","n = int(input())
 
result = []
 
for _ in range(n):
    
    x , y = list(map(int , input().split()))
    
    space_x = x*1
    space_y = y*4
    total_space = space_y + space_x
    
    if (y % 2 == 0):
        screen_require_for_y = y // 2
    else:
        screen_require_for_y = (y // 2) + 1
        
    # print(screen_require_for_y)
    
    
    remaining_cells =( 15*screen_require_for_y) - space_y
    
    if (space_x <= remaining_cells):
        result.append(screen_require_for_y)
    else :
        extra_space = space_x - remaining_cells
        # if extra_space <= 15 :
        #     extra_screen = 1
        if extra_space % 15 == 0:
            extra_screen = extra_space // 15
        else :
           extra_screen = ( extra_space // 15 ) + 1
           
        result.append(extra_screen + screen_require_for_y)
    
 
print(""\n"".join(map(str,result)))",1,True,True,False,True,True,True,True,True,True,False,False,True,True,True,0.6193543023221867,0.1089695043870584,0.5833333333333334
1923_A,1923_A_Athena___100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There is a ribbon divided into n cells, numbered from 1 to n from left to
right. Each cell either contains a chip or is free.

You can perform the following operation any number of times (possibly zero):
choose a chip and move it to the closest free cell to the left. You can choose
any chip that you want, provided that there is at least one free cell to the
left of it. When you move the chip, the cell where it was before the operation
becomes free.

Your goal is to move the chips in such a way that they form a single block,
without any free cells between them. What is the minimum number of operations
you have to perform?

Input

The first line contains one integer t (1 \le t \le 1000 ) — the number of test
cases.

Each test case consists of two lines:

  * the first line contains one integer n (2 \le n \le 50 ) — the number of cells; 
  * the second line contains n integers a_1, a_2, \dots, a_n (0 \le a_i \le 1 ); a_i = 0 means that the i -th cell is free; a_i = 1 means that the i -th cell contains a chip. 

Additional constraint on the input: in each test case, at least one cell
contains a chip.

Output

For each test case, print one integer — the minimum number of operations you
have to perform so that all chips form a single block without any free cells
between them.

Example

Input

    5
    
    8
    
    0 1 1 1 0 1 1 0
    
    6
    
    0 1 0 0 0 0
    
    6
    
    1 1 1 1 1 1
    
    5
    
    1 0 1 0 1
    
    9
    
    0 1 1 0 0 0 1 1 0

Output

    1
    0
    0
    2
    3
    
Note

In the first example, you can perform the operation on the chip in the 7 -th
cell. The closest free cell to the left is the 5 -th cell, so it moves there.
After that, all chips form a single block.

In the second example, all chips are already in a single block. Same for the
third example.","t=int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    res = 0
    
    while a and a[0]== 0:
        a.pop(0)
    
    while a and a[-1] == 0:
        a.pop()
        
    for i in range(len(a)):
        if a[i]==0:
            res += 1 
    print(res)",1,True,True,False,True,False,True,True,True,False,True,False,True,True,False,0.6934867526887587,0.20831313677005722,0.5833333333333334
1968_C,1968_C_tah23seen_6.67%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an array x_2,x_3,\dots,x_n . Your task is to find any array
a_1,\dots,a_n , where:

  * 1\le a_i\le 10^9 for all 1\le i\le n . 
  * x_i=a_i \bmod a_{i-1} for all 2\le i\le n . 

Here c\bmod d denotes the remainder of the division of the integer c by the
integer d . For example 5 \bmod 2 = 1 , 72 \bmod 3 = 0 , 143 \bmod 14 = 3 .

Note that if there is more than one a which satisfies the statement, you are
allowed to find any.

Input

The first line contains a single integer t (1\le t\le 10^4) — the number of
test cases.

The first line of each test case contains a single integer n (2\le n\le 500) —
the number of elements in a .

The second line of each test case contains n-1 integers x_2,\dots,x_n (1\le
x_i\le 500) — the elements of x .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 .

Output

For each test case output any a_1,\dots,a_n (1 \le a_i \le 10^9 ) which
satisfies the statement.

Example

Input

    5
    
    4
    
    2 4 1
    
    3
    
    1 1
    
    6
    
    4 2 5 1 2
    
    2
    
    500
    
    3
    
    1 5

Output

    3 5 4 9
    2 5 11
    5 14 16 5 11 24
    501 500
    2 7 5

Note

In the first test case a=[3,5,4,9] satisfies the conditions, because:

  * a_2\bmod a_1=5\bmod 3=2=x_2 ; 
  * a_3\bmod a_2=4\bmod 5=4=x_3 ; 
  * a_4\bmod a_3=9\bmod 4=1=x_4 ;","def solve(arr,n):
  ans=[0]*(n)
  ans[0]=arr[0]+1
  for i in range(n-2):
    ans[i+1]=arr[i]+ans[i]
    if ans[i+1]<arr[i+1]:
      while ans[i+1]<=arr[i+1]:
        ans[i+1]+=ans[i]
  ans[-1]=ans[-2]+arr[-1]
  return ans
 
t=int(input())
while t:
  n=int(input())
  arr=[int(x) for x in input().split("" "")]
  ans=solve(arr,n)
  for i in ans:
    print(i,end=' ')
  print()
  t-=1",1,False,False,False,False,False,True,True,False,False,False,False,True,False,False,0.7740908088003147,0.31561793909854163,0.6666666666666666
1928_C,1928_C_jinyiqi_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"In a well-known school, a physical education lesson took place. As usual,
everyone was lined up and asked to settle in ""the first–k -th"" position.

As is known, settling in ""the first–k -th"" position occurs as follows: the
first k people have numbers 1, 2, 3, \ldots, k , the next k - 2 people have
numbers k - 1, k - 2, \ldots, 2 , the next k people have numbers 1, 2, 3,
\ldots, k , and so on. Thus, the settling repeats every 2k - 2 positions.
Examples of settling are given in the ""Note"" section.

The boy Vasya constantly forgets everything. For example, he forgot the number
k described above. But he remembers the position he occupied in the line, as
well as the number he received during the settling. Help Vasya understand how
many natural numbers k fit under the given constraints.

Note that the settling exists if and only if k > 1 . In particular, this means
that the settling does not exist for k = 1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 100 ) — the number of test cases. This is followed by
the description of the test cases.

The only line of each test case contains two integers n and x (1 \le x < n \le
10^9 ) — Vasya's position in the line and the number Vasya received during the
settling.

Output

For each test case, output a single integer — the number of different k that
fit under the given constraints.

It can be proven that under the given constraints, the answer is finite.

Example

Input

    5
    
    10 2
    
    3 1
    
    76 4
    
    100 99
    
    1000000000 500000000

Output

    4
    1
    9
    0
    1
    
Note

In the first test case, k equals 2, 3, 5, 6 are suitable.

An example of settling for these k :

k / №| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10   
---|---|---|---|---|---|---|---|---|---|---  
2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2   
3 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 | 2   
5 | 1 | 2 | 3 | 4 | 5 | 4 | 3 | 2 | 1 | 2   
6 | 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 | 3 | 2   
  
In the second test case, k = 2 is suitable.","def sep_num(x):
    output1 = []
    output2 = []
    for i in range(1, int(x ** 0.5) + 1):
        if x % i == 0:
            output1.append(i)
            output2.append(int(x / i))
    output1.reverse()
    return output2 + output1
 
t = int(input())
 
for i in range(t):
    n, x = map(int, input().split())
    output = []
    if (n + x - 2) % 2 == 0:
        sep = sep_num(n + x - 2)
        for s in sep:
            if (s + 2) % 2 == 0 and (s + 2) / 2 >= x:
                output.append((s + 2) / 2)
    if (n - x) % 2 == 0:
        sep = sep_num(n - x)
        for s in sep:
            if (s + 2) % 2 == 0 and (s + 2) / 2 >= x:
                output.append((s + 2) / 2)
    output = list(set(output))
    print(len(output))",1,True,False,False,False,False,True,True,False,False,True,False,True,True,False,0.7116860173769588,0.2247467626540343,0.5833333333333334
1974_A,1974_A_chiwuu_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Little Rosie has a phone with a desktop (or launcher, as it is also called).
The desktop can consist of several screens. Each screen is represented as a
grid of size 5 \times 3 , i.e., five rows and three columns.

There are x applications with an icon size of 1 \times 1 cells; such an icon
occupies only one cell of the screen. There are also y applications with an
icon size of 2 \times 2 cells; such an icon occupies a square of 4 cells on
the screen. Each cell of each screen can be occupied by no more than one icon.

Rosie wants to place the application icons on the minimum number of screens.
Help her find the minimum number of screens needed.

Input

The first line of the input contains t (1 \leq t \leq 10^4 ) — the number of
test cases.

The first and only line of each test case contains two integers x and y (0
\leq x, y \leq 99 ) — the number of applications with a 1 \times 1 icon and
the number of applications with a 2 \times 2 icon, respectively.

Output

For each test case, output the minimal number of required screens on a
separate line.

Example

Input

    11
    
    1 1
    
    7 2
    
    12 4
    
    0 3
    
    1 0
    
    8 1
    
    0 0
    
    2 0
    
    15 0
    
    8 2
    
    0 9

Output

    1
    1
    2
    2
    1
    1
    0
    1
    1
    2
    5
    
Note

The solution for the first test case can look as follows:

![](https://espresso.codeforces.com/f9882979f0d9b5c31c5260fd626217227c2f05de.png)
Blue squares represent empty spaces for icons, green squares represent 1
\times 1 icons, red squares represent 2 \times 2 icons

The solution for the third test case can look as follows:

![](https://espresso.codeforces.com/0e737a290e056a29f38918bf06c13be790307a8d.png)","n=int(input())
for i in range(n):
    a,b=input().split()
    a=int(a)
    b=int(b)
    t=b*2
    if t%5==0:
        t=t//5
    else:
        t=t//5+1
    t1=t*15-b*4
    if t1>=a:
        t=t
    else:
        t2=a-t1
        if t2%15==0:
            t=t+t2//15
        else:
            t=t+t2//15+1
    print(t)",1,False,False,False,False,True,True,False,False,False,False,False,False,False,False,0.5034942620944419,0.003558429730204223,0.5
1979_C,1979_C_akashtiwari0704_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You have been offered to play a game. In this game, there are n possible
outcomes, and for each of them, you must bet a certain integer amount of
coins. In the event that the i -th outcome turns out to be winning, you will
receive back the amount of coins equal to your bet on that outcome, multiplied
by k_i . Note that exactly one of the n outcomes will be winning.

Your task is to determine how to distribute the coins in such a way that you
will come out ahead in the event of any winning outcome. More formally, the
total amount of coins you bet on all outcomes must be strictly less than the
number of coins received back for each possible winning outcome.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 50 )
— the number of outcomes.

The second line of each test case contains n integers k_1,k_2,\ldots,k_n (2
\le k_i \le 20 ) — the multiplier for the amount of coins if the i -th outcome
turns out to be winning.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output -1 if there is no way to distribute the coins as
required. Otherwise, output n integers x_1, x_2,\ldots, x_n (1 \le x_i \le
10^{9} ) — your bets on the outcomes.

It can be shown that if a solution exists, there is always a solution that
satisfies these constraints.

If there are multiple suitable solutions, output any of them.

Example

Input

    6
    
    3
    
    3 2 7
    
    2
    
    3 3
    
    5
    
    5 5 5 5 5
    
    6
    
    7 9 3 17 9 13
    
    3
    
    6 3 2
    
    5
    
    9 4 6 8 3

Output

    27 41 12 
    1 1 
    -1
    1989 1547 4641 819 1547 1071 
    -1
    8 18 12 9 24
    
Note

In the first test case, the coins can be distributed as follows: 27 coins on
the first outcome, 41 coins on the second outcome, 12 coins on the third
outcome. Then the total amount of coins bet on all outcomes is 27 + 41 + 12 =
80 coins. If the first outcome turns out to be winning, you will receive back
3 \cdot 27 = 81 coins, if the second outcome turns out to be winning, you will
receive back 2 \cdot 41 = 82 coins, if the third outcome turns out to be
winning, you will receive back 7 \cdot 12 = 84 coins. All these values are
strictly greater than 80 .

In the second test case, one way is to bet one coin on each of the outcomes.","from math import gcd
t = int(input())
for T in range(t):
	#x, y, k = map(int, input().split())
	def lcm(l):
	    g=1
	    for i in range(len(l)):
	        g=g*l[i]//gcd(g,l[i])
	    return g
	bets=int(input())
	a = [int(x) for x in input().split()]
	prod=lcm(a)
	
	sumo=0
	for i in range(bets):
	    a[i]=(prod//a[i])
	    sumo+=int(a[i])
	
	if sumo>=prod:
	    print(-1)
	else:
	    ans=""""
	    for i in range(bets):
	        ans+=str(a[i])+"" ""
	    print(ans)",1,True,True,False,True,False,True,True,True,True,True,True,True,False,True,0.7993990421817424,0.34449932638372327,0.75
1957_C,1957_C_DevK01_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)","def sol(n):
 
    dp=[1,1]
    for i in range(2,n+1):
        dp+=[(dp[-1]+2*(i-1)*dp[-2])%(7+10**9)]
        dp.pop(0)
    return dp[-1]
 
t=int(input())
for _ in range(t):
    L=list(map(int,input().split()))
    n,k=L[0],L[1]
    for j in range(k):
        L1=list(map(int,input().split()))
        a,b=L1[0],L1[1]
        if a!=b:
            n-=2
        else:
            n-=1
    print(sol(n))
    continue",1,True,True,False,True,False,True,True,True,False,True,True,True,True,True,0.5721055503863547,0.07567107112319255,0.5833333333333334
1930_B,1930_B_bigdamdam_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given a positive integer n .

Find a permutation^\dagger p of length n such that there do not exist two
distinct indices i and j (1 \leq i, j < n ; i \neq j ) such that p_i divides
p_j and p_{i+1} divides p_{j+1} .

Refer to the Notes section for some examples.

Under the constraints of this problem, it can be proven that at least one p
exists.

^\dagger A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (3 \leq n \leq
10^5 ) — the length of the permutation p .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output p_1, p_2, \ldots, p_n .

If there are multiple solutions, you may output any one of them.

Example

Input

    2
    
    4
    
    3

Output

    4 1 2 3
    1 2 3
    
Note

In the first test case, p=[4,1,2,3] is a valid permutation. However, the
permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and
j=3 . Then p_1=1 divides p_3=3 and p_2=2 divides p_4=4 . Note that the
permutation p=[3, 4, 2, 1] is also not a valid permutation as we can choose
i=3 and j=2 . Then p_3=2 divides p_2=4 and p_4=1 divides p_3=2 .

In the second test case, p=[1,2,3] is a valid permutation. In fact, all 6
permutations of length 3 are valid.","for i in range(int(input())):
      n = [int(i)for i in input().split()][0]
      p = [0]*n;ind = n
      for i in range(0,n,2):p[i]=ind;ind -= 2
      ind = 1 + n%2
      for i in range(1,n,2):p[i]=ind;ind += 2
      print(*p)",1,True,True,True,True,True,True,True,True,True,True,True,True,True,True,0.722070980084832,0.23786776414090813,0.5833333333333334
1923_A,1923_A_Athena___100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There is a ribbon divided into n cells, numbered from 1 to n from left to
right. Each cell either contains a chip or is free.

You can perform the following operation any number of times (possibly zero):
choose a chip and move it to the closest free cell to the left. You can choose
any chip that you want, provided that there is at least one free cell to the
left of it. When you move the chip, the cell where it was before the operation
becomes free.

Your goal is to move the chips in such a way that they form a single block,
without any free cells between them. What is the minimum number of operations
you have to perform?

Input

The first line contains one integer t (1 \le t \le 1000 ) — the number of test
cases.

Each test case consists of two lines:

  * the first line contains one integer n (2 \le n \le 50 ) — the number of cells; 
  * the second line contains n integers a_1, a_2, \dots, a_n (0 \le a_i \le 1 ); a_i = 0 means that the i -th cell is free; a_i = 1 means that the i -th cell contains a chip. 

Additional constraint on the input: in each test case, at least one cell
contains a chip.

Output

For each test case, print one integer — the minimum number of operations you
have to perform so that all chips form a single block without any free cells
between them.

Example

Input

    5
    
    8
    
    0 1 1 1 0 1 1 0
    
    6
    
    0 1 0 0 0 0
    
    6
    
    1 1 1 1 1 1
    
    5
    
    1 0 1 0 1
    
    9
    
    0 1 1 0 0 0 1 1 0

Output

    1
    0
    0
    2
    3
    
Note

In the first example, you can perform the operation on the chip in the 7 -th
cell. The closest free cell to the left is the 5 -th cell, so it moves there.
After that, all chips form a single block.

In the second example, all chips are already in a single block. Same for the
third example.","t=int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    res = 0
    
    while a and a[0]== 0:
        a.pop(0)
    
    while a and a[-1] == 0:
        a.pop()
        
    for i in range(len(a)):
        if a[i]==0:
            res += 1 
    print(res)",2,True,True,False,True,True,True,True,True,False,True,False,False,True,True,0.6934867526887587,0.20831313677005722,0.5833333333333334
1968_C,1968_C_tah23seen_6.67%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an array x_2,x_3,\dots,x_n . Your task is to find any array
a_1,\dots,a_n , where:

  * 1\le a_i\le 10^9 for all 1\le i\le n . 
  * x_i=a_i \bmod a_{i-1} for all 2\le i\le n . 

Here c\bmod d denotes the remainder of the division of the integer c by the
integer d . For example 5 \bmod 2 = 1 , 72 \bmod 3 = 0 , 143 \bmod 14 = 3 .

Note that if there is more than one a which satisfies the statement, you are
allowed to find any.

Input

The first line contains a single integer t (1\le t\le 10^4) — the number of
test cases.

The first line of each test case contains a single integer n (2\le n\le 500) —
the number of elements in a .

The second line of each test case contains n-1 integers x_2,\dots,x_n (1\le
x_i\le 500) — the elements of x .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 .

Output

For each test case output any a_1,\dots,a_n (1 \le a_i \le 10^9 ) which
satisfies the statement.

Example

Input

    5
    
    4
    
    2 4 1
    
    3
    
    1 1
    
    6
    
    4 2 5 1 2
    
    2
    
    500
    
    3
    
    1 5

Output

    3 5 4 9
    2 5 11
    5 14 16 5 11 24
    501 500
    2 7 5

Note

In the first test case a=[3,5,4,9] satisfies the conditions, because:

  * a_2\bmod a_1=5\bmod 3=2=x_2 ; 
  * a_3\bmod a_2=4\bmod 5=4=x_3 ; 
  * a_4\bmod a_3=9\bmod 4=1=x_4 ;","def solve(arr,n):
  ans=[0]*(n)
  ans[0]=arr[0]+1
  for i in range(n-2):
    ans[i+1]=arr[i]+ans[i]
    if ans[i+1]<arr[i+1]:
      while ans[i+1]<=arr[i+1]:
        ans[i+1]+=ans[i]
  ans[-1]=ans[-2]+arr[-1]
  return ans
 
t=int(input())
while t:
  n=int(input())
  arr=[int(x) for x in input().split("" "")]
  ans=solve(arr,n)
  for i in ans:
    print(i,end=' ')
  print()
  t-=1",2,False,False,False,True,False,True,True,False,False,False,False,True,True,True,0.7740908088003147,0.31561793909854163,0.6666666666666666
1928_C,1928_C_jinyiqi_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"In a well-known school, a physical education lesson took place. As usual,
everyone was lined up and asked to settle in ""the first–k -th"" position.

As is known, settling in ""the first–k -th"" position occurs as follows: the
first k people have numbers 1, 2, 3, \ldots, k , the next k - 2 people have
numbers k - 1, k - 2, \ldots, 2 , the next k people have numbers 1, 2, 3,
\ldots, k , and so on. Thus, the settling repeats every 2k - 2 positions.
Examples of settling are given in the ""Note"" section.

The boy Vasya constantly forgets everything. For example, he forgot the number
k described above. But he remembers the position he occupied in the line, as
well as the number he received during the settling. Help Vasya understand how
many natural numbers k fit under the given constraints.

Note that the settling exists if and only if k > 1 . In particular, this means
that the settling does not exist for k = 1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 100 ) — the number of test cases. This is followed by
the description of the test cases.

The only line of each test case contains two integers n and x (1 \le x < n \le
10^9 ) — Vasya's position in the line and the number Vasya received during the
settling.

Output

For each test case, output a single integer — the number of different k that
fit under the given constraints.

It can be proven that under the given constraints, the answer is finite.

Example

Input

    5
    
    10 2
    
    3 1
    
    76 4
    
    100 99
    
    1000000000 500000000

Output

    4
    1
    9
    0
    1
    
Note

In the first test case, k equals 2, 3, 5, 6 are suitable.

An example of settling for these k :

k / №| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10   
---|---|---|---|---|---|---|---|---|---|---  
2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2   
3 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 | 2   
5 | 1 | 2 | 3 | 4 | 5 | 4 | 3 | 2 | 1 | 2   
6 | 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 | 3 | 2   
  
In the second test case, k = 2 is suitable.","def sep_num(x):
    output1 = []
    output2 = []
    for i in range(1, int(x ** 0.5) + 1):
        if x % i == 0:
            output1.append(i)
            output2.append(int(x / i))
    output1.reverse()
    return output2 + output1
 
t = int(input())
 
for i in range(t):
    n, x = map(int, input().split())
    output = []
    if (n + x - 2) % 2 == 0:
        sep = sep_num(n + x - 2)
        for s in sep:
            if (s + 2) % 2 == 0 and (s + 2) / 2 >= x:
                output.append((s + 2) / 2)
    if (n - x) % 2 == 0:
        sep = sep_num(n - x)
        for s in sep:
            if (s + 2) % 2 == 0 and (s + 2) / 2 >= x:
                output.append((s + 2) / 2)
    output = list(set(output))
    print(len(output))",2,True,False,False,True,False,True,True,False,False,False,False,False,False,True,0.7116860173769588,0.2247467626540343,0.5833333333333334
1974_A,1974_A_chiwuu_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Little Rosie has a phone with a desktop (or launcher, as it is also called).
The desktop can consist of several screens. Each screen is represented as a
grid of size 5 \times 3 , i.e., five rows and three columns.

There are x applications with an icon size of 1 \times 1 cells; such an icon
occupies only one cell of the screen. There are also y applications with an
icon size of 2 \times 2 cells; such an icon occupies a square of 4 cells on
the screen. Each cell of each screen can be occupied by no more than one icon.

Rosie wants to place the application icons on the minimum number of screens.
Help her find the minimum number of screens needed.

Input

The first line of the input contains t (1 \leq t \leq 10^4 ) — the number of
test cases.

The first and only line of each test case contains two integers x and y (0
\leq x, y \leq 99 ) — the number of applications with a 1 \times 1 icon and
the number of applications with a 2 \times 2 icon, respectively.

Output

For each test case, output the minimal number of required screens on a
separate line.

Example

Input

    11
    
    1 1
    
    7 2
    
    12 4
    
    0 3
    
    1 0
    
    8 1
    
    0 0
    
    2 0
    
    15 0
    
    8 2
    
    0 9

Output

    1
    1
    2
    2
    1
    1
    0
    1
    1
    2
    5
    
Note

The solution for the first test case can look as follows:

![](https://espresso.codeforces.com/f9882979f0d9b5c31c5260fd626217227c2f05de.png)
Blue squares represent empty spaces for icons, green squares represent 1
\times 1 icons, red squares represent 2 \times 2 icons

The solution for the third test case can look as follows:

![](https://espresso.codeforces.com/0e737a290e056a29f38918bf06c13be790307a8d.png)","n=int(input())
for i in range(n):
    a,b=input().split()
    a=int(a)
    b=int(b)
    t=b*2
    if t%5==0:
        t=t//5
    else:
        t=t//5+1
    t1=t*15-b*4
    if t1>=a:
        t=t
    else:
        t2=a-t1
        if t2%15==0:
            t=t+t2//15
        else:
            t=t+t2//15+1
    print(t)",2,False,False,False,False,False,True,False,True,False,False,False,False,False,False,0.5034942620944419,0.003558429730204223,0.5
1979_C,1979_C_akashtiwari0704_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You have been offered to play a game. In this game, there are n possible
outcomes, and for each of them, you must bet a certain integer amount of
coins. In the event that the i -th outcome turns out to be winning, you will
receive back the amount of coins equal to your bet on that outcome, multiplied
by k_i . Note that exactly one of the n outcomes will be winning.

Your task is to determine how to distribute the coins in such a way that you
will come out ahead in the event of any winning outcome. More formally, the
total amount of coins you bet on all outcomes must be strictly less than the
number of coins received back for each possible winning outcome.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 50 )
— the number of outcomes.

The second line of each test case contains n integers k_1,k_2,\ldots,k_n (2
\le k_i \le 20 ) — the multiplier for the amount of coins if the i -th outcome
turns out to be winning.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output -1 if there is no way to distribute the coins as
required. Otherwise, output n integers x_1, x_2,\ldots, x_n (1 \le x_i \le
10^{9} ) — your bets on the outcomes.

It can be shown that if a solution exists, there is always a solution that
satisfies these constraints.

If there are multiple suitable solutions, output any of them.

Example

Input

    6
    
    3
    
    3 2 7
    
    2
    
    3 3
    
    5
    
    5 5 5 5 5
    
    6
    
    7 9 3 17 9 13
    
    3
    
    6 3 2
    
    5
    
    9 4 6 8 3

Output

    27 41 12 
    1 1 
    -1
    1989 1547 4641 819 1547 1071 
    -1
    8 18 12 9 24
    
Note

In the first test case, the coins can be distributed as follows: 27 coins on
the first outcome, 41 coins on the second outcome, 12 coins on the third
outcome. Then the total amount of coins bet on all outcomes is 27 + 41 + 12 =
80 coins. If the first outcome turns out to be winning, you will receive back
3 \cdot 27 = 81 coins, if the second outcome turns out to be winning, you will
receive back 2 \cdot 41 = 82 coins, if the third outcome turns out to be
winning, you will receive back 7 \cdot 12 = 84 coins. All these values are
strictly greater than 80 .

In the second test case, one way is to bet one coin on each of the outcomes.","from math import gcd
t = int(input())
for T in range(t):
	#x, y, k = map(int, input().split())
	def lcm(l):
	    g=1
	    for i in range(len(l)):
	        g=g*l[i]//gcd(g,l[i])
	    return g
	bets=int(input())
	a = [int(x) for x in input().split()]
	prod=lcm(a)
	
	sumo=0
	for i in range(bets):
	    a[i]=(prod//a[i])
	    sumo+=int(a[i])
	
	if sumo>=prod:
	    print(-1)
	else:
	    ans=""""
	    for i in range(bets):
	        ans+=str(a[i])+"" ""
	    print(ans)",2,True,True,False,True,False,True,True,True,False,True,False,False,True,False,0.7993990421817424,0.34449932638372327,0.75
1957_C,1957_C_DevK01_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)","def sol(n):
 
    dp=[1,1]
    for i in range(2,n+1):
        dp+=[(dp[-1]+2*(i-1)*dp[-2])%(7+10**9)]
        dp.pop(0)
    return dp[-1]
 
t=int(input())
for _ in range(t):
    L=list(map(int,input().split()))
    n,k=L[0],L[1]
    for j in range(k):
        L1=list(map(int,input().split()))
        a,b=L1[0],L1[1]
        if a!=b:
            n-=2
        else:
            n-=1
    print(sol(n))
    continue",2,True,False,False,True,False,False,False,False,False,True,False,True,False,True,0.5721055503863547,0.07567107112319255,0.5833333333333334
1930_B,1930_B_bigdamdam_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given a positive integer n .

Find a permutation^\dagger p of length n such that there do not exist two
distinct indices i and j (1 \leq i, j < n ; i \neq j ) such that p_i divides
p_j and p_{i+1} divides p_{j+1} .

Refer to the Notes section for some examples.

Under the constraints of this problem, it can be proven that at least one p
exists.

^\dagger A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (3 \leq n \leq
10^5 ) — the length of the permutation p .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output p_1, p_2, \ldots, p_n .

If there are multiple solutions, you may output any one of them.

Example

Input

    2
    
    4
    
    3

Output

    4 1 2 3
    1 2 3
    
Note

In the first test case, p=[4,1,2,3] is a valid permutation. However, the
permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and
j=3 . Then p_1=1 divides p_3=3 and p_2=2 divides p_4=4 . Note that the
permutation p=[3, 4, 2, 1] is also not a valid permutation as we can choose
i=3 and j=2 . Then p_3=2 divides p_2=4 and p_4=1 divides p_3=2 .

In the second test case, p=[1,2,3] is a valid permutation. In fact, all 6
permutations of length 3 are valid.","for i in range(int(input())):
      n = [int(i)for i in input().split()][0]
      p = [0]*n;ind = n
      for i in range(0,n,2):p[i]=ind;ind -= 2
      ind = 1 + n%2
      for i in range(1,n,2):p[i]=ind;ind += 2
      print(*p)",2,True,True,True,True,True,True,True,True,True,True,True,True,True,True,0.722070980084832,0.23786776414090813,0.5833333333333334
1974_A,1974_A_Ridham__100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Little Rosie has a phone with a desktop (or launcher, as it is also called).
The desktop can consist of several screens. Each screen is represented as a
grid of size 5 \times 3 , i.e., five rows and three columns.

There are x applications with an icon size of 1 \times 1 cells; such an icon
occupies only one cell of the screen. There are also y applications with an
icon size of 2 \times 2 cells; such an icon occupies a square of 4 cells on
the screen. Each cell of each screen can be occupied by no more than one icon.

Rosie wants to place the application icons on the minimum number of screens.
Help her find the minimum number of screens needed.

Input

The first line of the input contains t (1 \leq t \leq 10^4 ) — the number of
test cases.

The first and only line of each test case contains two integers x and y (0
\leq x, y \leq 99 ) — the number of applications with a 1 \times 1 icon and
the number of applications with a 2 \times 2 icon, respectively.

Output

For each test case, output the minimal number of required screens on a
separate line.

Example

Input

    11
    
    1 1
    
    7 2
    
    12 4
    
    0 3
    
    1 0
    
    8 1
    
    0 0
    
    2 0
    
    15 0
    
    8 2
    
    0 9

Output

    1
    1
    2
    2
    1
    1
    0
    1
    1
    2
    5
    
Note

The solution for the first test case can look as follows:

![](https://espresso.codeforces.com/f9882979f0d9b5c31c5260fd626217227c2f05de.png)
Blue squares represent empty spaces for icons, green squares represent 1
\times 1 icons, red squares represent 2 \times 2 icons

The solution for the third test case can look as follows:

![](https://espresso.codeforces.com/0e737a290e056a29f38918bf06c13be790307a8d.png)","n = int(input())
 
result = []
 
for _ in range(n):
    
    x , y = list(map(int , input().split()))
    
    space_x = x*1
    space_y = y*4
    total_space = space_y + space_x
    
    if (y % 2 == 0):
        screen_require_for_y = y // 2
    else:
        screen_require_for_y = (y // 2) + 1
        
    # print(screen_require_for_y)
    
    
    remaining_cells =( 15*screen_require_for_y) - space_y
    
    if (space_x <= remaining_cells):
        result.append(screen_require_for_y)
    else :
        extra_space = space_x - remaining_cells
        # if extra_space <= 15 :
        #     extra_screen = 1
        if extra_space % 15 == 0:
            extra_screen = extra_space // 15
        else :
           extra_screen = ( extra_space // 15 ) + 1
           
        result.append(extra_screen + screen_require_for_y)
    
 
print(""\n"".join(map(str,result)))",3,True,True,True,True,False,True,True,True,True,True,True,True,False,True,0.6193543023221867,0.1089695043870584,0.5833333333333334
1923_A,1923_A_Athena___100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There is a ribbon divided into n cells, numbered from 1 to n from left to
right. Each cell either contains a chip or is free.

You can perform the following operation any number of times (possibly zero):
choose a chip and move it to the closest free cell to the left. You can choose
any chip that you want, provided that there is at least one free cell to the
left of it. When you move the chip, the cell where it was before the operation
becomes free.

Your goal is to move the chips in such a way that they form a single block,
without any free cells between them. What is the minimum number of operations
you have to perform?

Input

The first line contains one integer t (1 \le t \le 1000 ) — the number of test
cases.

Each test case consists of two lines:

  * the first line contains one integer n (2 \le n \le 50 ) — the number of cells; 
  * the second line contains n integers a_1, a_2, \dots, a_n (0 \le a_i \le 1 ); a_i = 0 means that the i -th cell is free; a_i = 1 means that the i -th cell contains a chip. 

Additional constraint on the input: in each test case, at least one cell
contains a chip.

Output

For each test case, print one integer — the minimum number of operations you
have to perform so that all chips form a single block without any free cells
between them.

Example

Input

    5
    
    8
    
    0 1 1 1 0 1 1 0
    
    6
    
    0 1 0 0 0 0
    
    6
    
    1 1 1 1 1 1
    
    5
    
    1 0 1 0 1
    
    9
    
    0 1 1 0 0 0 1 1 0

Output

    1
    0
    0
    2
    3
    
Note

In the first example, you can perform the operation on the chip in the 7 -th
cell. The closest free cell to the left is the 5 -th cell, so it moves there.
After that, all chips form a single block.

In the second example, all chips are already in a single block. Same for the
third example.","t=int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    res = 0
    
    while a and a[0]== 0:
        a.pop(0)
    
    while a and a[-1] == 0:
        a.pop()
        
    for i in range(len(a)):
        if a[i]==0:
            res += 1 
    print(res)",3,True,False,False,True,False,False,True,True,False,False,False,True,True,True,0.6934867526887587,0.20831313677005722,0.5833333333333334
1968_C,1968_C_tah23seen_6.67%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an array x_2,x_3,\dots,x_n . Your task is to find any array
a_1,\dots,a_n , where:

  * 1\le a_i\le 10^9 for all 1\le i\le n . 
  * x_i=a_i \bmod a_{i-1} for all 2\le i\le n . 

Here c\bmod d denotes the remainder of the division of the integer c by the
integer d . For example 5 \bmod 2 = 1 , 72 \bmod 3 = 0 , 143 \bmod 14 = 3 .

Note that if there is more than one a which satisfies the statement, you are
allowed to find any.

Input

The first line contains a single integer t (1\le t\le 10^4) — the number of
test cases.

The first line of each test case contains a single integer n (2\le n\le 500) —
the number of elements in a .

The second line of each test case contains n-1 integers x_2,\dots,x_n (1\le
x_i\le 500) — the elements of x .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 .

Output

For each test case output any a_1,\dots,a_n (1 \le a_i \le 10^9 ) which
satisfies the statement.

Example

Input

    5
    
    4
    
    2 4 1
    
    3
    
    1 1
    
    6
    
    4 2 5 1 2
    
    2
    
    500
    
    3
    
    1 5

Output

    3 5 4 9
    2 5 11
    5 14 16 5 11 24
    501 500
    2 7 5

Note

In the first test case a=[3,5,4,9] satisfies the conditions, because:

  * a_2\bmod a_1=5\bmod 3=2=x_2 ; 
  * a_3\bmod a_2=4\bmod 5=4=x_3 ; 
  * a_4\bmod a_3=9\bmod 4=1=x_4 ;","def solve(arr,n):
  ans=[0]*(n)
  ans[0]=arr[0]+1
  for i in range(n-2):
    ans[i+1]=arr[i]+ans[i]
    if ans[i+1]<arr[i+1]:
      while ans[i+1]<=arr[i+1]:
        ans[i+1]+=ans[i]
  ans[-1]=ans[-2]+arr[-1]
  return ans
 
t=int(input())
while t:
  n=int(input())
  arr=[int(x) for x in input().split("" "")]
  ans=solve(arr,n)
  for i in ans:
    print(i,end=' ')
  print()
  t-=1",3,False,True,False,False,False,False,False,True,False,True,True,False,False,False,0.7740908088003147,0.31561793909854163,0.6666666666666666
1979_C,1979_C_akashtiwari0704_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You have been offered to play a game. In this game, there are n possible
outcomes, and for each of them, you must bet a certain integer amount of
coins. In the event that the i -th outcome turns out to be winning, you will
receive back the amount of coins equal to your bet on that outcome, multiplied
by k_i . Note that exactly one of the n outcomes will be winning.

Your task is to determine how to distribute the coins in such a way that you
will come out ahead in the event of any winning outcome. More formally, the
total amount of coins you bet on all outcomes must be strictly less than the
number of coins received back for each possible winning outcome.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 50 )
— the number of outcomes.

The second line of each test case contains n integers k_1,k_2,\ldots,k_n (2
\le k_i \le 20 ) — the multiplier for the amount of coins if the i -th outcome
turns out to be winning.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output -1 if there is no way to distribute the coins as
required. Otherwise, output n integers x_1, x_2,\ldots, x_n (1 \le x_i \le
10^{9} ) — your bets on the outcomes.

It can be shown that if a solution exists, there is always a solution that
satisfies these constraints.

If there are multiple suitable solutions, output any of them.

Example

Input

    6
    
    3
    
    3 2 7
    
    2
    
    3 3
    
    5
    
    5 5 5 5 5
    
    6
    
    7 9 3 17 9 13
    
    3
    
    6 3 2
    
    5
    
    9 4 6 8 3

Output

    27 41 12 
    1 1 
    -1
    1989 1547 4641 819 1547 1071 
    -1
    8 18 12 9 24
    
Note

In the first test case, the coins can be distributed as follows: 27 coins on
the first outcome, 41 coins on the second outcome, 12 coins on the third
outcome. Then the total amount of coins bet on all outcomes is 27 + 41 + 12 =
80 coins. If the first outcome turns out to be winning, you will receive back
3 \cdot 27 = 81 coins, if the second outcome turns out to be winning, you will
receive back 2 \cdot 41 = 82 coins, if the third outcome turns out to be
winning, you will receive back 7 \cdot 12 = 84 coins. All these values are
strictly greater than 80 .

In the second test case, one way is to bet one coin on each of the outcomes.","from math import gcd
t = int(input())
for T in range(t):
	#x, y, k = map(int, input().split())
	def lcm(l):
	    g=1
	    for i in range(len(l)):
	        g=g*l[i]//gcd(g,l[i])
	    return g
	bets=int(input())
	a = [int(x) for x in input().split()]
	prod=lcm(a)
	
	sumo=0
	for i in range(bets):
	    a[i]=(prod//a[i])
	    sumo+=int(a[i])
	
	if sumo>=prod:
	    print(-1)
	else:
	    ans=""""
	    for i in range(bets):
	        ans+=str(a[i])+"" ""
	    print(ans)",3,True,False,False,False,False,True,True,True,False,True,True,True,False,True,0.7993990421817424,0.34449932638372327,0.75
1957_C,1957_C_DevK01_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)","def sol(n):
 
    dp=[1,1]
    for i in range(2,n+1):
        dp+=[(dp[-1]+2*(i-1)*dp[-2])%(7+10**9)]
        dp.pop(0)
    return dp[-1]
 
t=int(input())
for _ in range(t):
    L=list(map(int,input().split()))
    n,k=L[0],L[1]
    for j in range(k):
        L1=list(map(int,input().split()))
        a,b=L1[0],L1[1]
        if a!=b:
            n-=2
        else:
            n-=1
    print(sol(n))
    continue",3,True,False,False,True,False,True,True,True,True,False,True,True,True,True,0.5721055503863547,0.07567107112319255,0.5833333333333334
1930_B,1930_B_bigdamdam_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given a positive integer n .

Find a permutation^\dagger p of length n such that there do not exist two
distinct indices i and j (1 \leq i, j < n ; i \neq j ) such that p_i divides
p_j and p_{i+1} divides p_{j+1} .

Refer to the Notes section for some examples.

Under the constraints of this problem, it can be proven that at least one p
exists.

^\dagger A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (3 \leq n \leq
10^5 ) — the length of the permutation p .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output p_1, p_2, \ldots, p_n .

If there are multiple solutions, you may output any one of them.

Example

Input

    2
    
    4
    
    3

Output

    4 1 2 3
    1 2 3
    
Note

In the first test case, p=[4,1,2,3] is a valid permutation. However, the
permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and
j=3 . Then p_1=1 divides p_3=3 and p_2=2 divides p_4=4 . Note that the
permutation p=[3, 4, 2, 1] is also not a valid permutation as we can choose
i=3 and j=2 . Then p_3=2 divides p_2=4 and p_4=1 divides p_3=2 .

In the second test case, p=[1,2,3] is a valid permutation. In fact, all 6
permutations of length 3 are valid.","for i in range(int(input())):
      n = [int(i)for i in input().split()][0]
      p = [0]*n;ind = n
      for i in range(0,n,2):p[i]=ind;ind -= 2
      ind = 1 + n%2
      for i in range(1,n,2):p[i]=ind;ind += 2
      print(*p)",3,True,True,True,True,True,True,True,True,True,True,True,True,True,False,0.722070980084832,0.23786776414090813,0.5833333333333334
