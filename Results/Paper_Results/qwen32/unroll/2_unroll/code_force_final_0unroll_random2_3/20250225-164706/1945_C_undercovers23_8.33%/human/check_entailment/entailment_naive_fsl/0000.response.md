Correctness: **False**.

### Explanation:

The provided program has several issues that make it incorrect based on the problem description:

1. **Incorrect Calculation of `zero_perc` and `one_perc`**:
   - The code calculates `zero_perc` and `one_perc` as percentages, which is not required. The problem requires counting the number of zeros and ones and checking if they meet the condition of at least half of the residents being satisfied.
   - The correct approach would be to check if `zero >= math.ceil((i + 1) / 2)` and `one >= math.ceil((n - i - 1) / 2)`.

2. **Handling Edge Cases**:
   - The code does not handle the edge case where the road can be placed before the first house (`i = 0`) or after the last house (`i = n`). These cases need to be checked separately.
   - The code checks if placing the road before the first house (`i = 0`) is valid by checking if the number of ones in the entire string is at least half. Similarly, it checks if placing the road after the last house (`i = n`) is valid by checking if the number of zeros in the entire string is at least half.

3. **Optimization**:
   - The code uses a list `lst` to store all valid positions and then finds the position closest to the middle. This can be optimized by keeping track of the closest valid position directly during the iteration.

Here is a corrected version of the program:

```python
import math

def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        s = input()
        pk = n // 2
        o = s.count('1')
        z = s.count('0')
        (zero, one) = (0, 0)
        best_i = None
        min_diff = float('inf')
        
        for i in range(n):
            if s[i] == '0':
                zero += 1
            else:
                one += 1
            if zero >= math.ceil((i + 1) / 2) and one >= math.ceil((n - i - 1) / 2):
                diff = abs(pk - i)
                if diff < min_diff or (diff == min_diff and i < best_i):
                    min_diff = diff
                    best_i = i
        
        # Check if placing the road before the first house is valid
        if o >= math.ceil(n / 2):
            diff = abs(pk - 0)
            if diff < min_diff or (diff == min_diff and 0 < best_i):
                best_i = 0
        
        # Check if placing the road after the last house is valid
        if z >= math.ceil(n / 2):
            diff = abs(pk - n)
            if diff < min_diff or (diff == min_diff and n < best_i):
                best_i = n
        
        print(best_i)

```

This corrected version properly checks all conditions and handles edge cases, ensuring that the road is placed as close to the middle as possible while satisfying the given conditions.