
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
There is a hidden array a of size n consisting of only 1 and -1 . Let p be the
prefix sums of array a . More formally, p is an array of length n defined as
p_i = a_1 + a_2 + \ldots + a_i . Afterwards, array p is sorted in non-
decreasing order. For example, if a = [1, -1, -1, 1, 1] , then p = [1, 0, -1,
0, 1] before sorting and p = [-1, 0, 0, 1, 1] after sorting.

You are given the prefix sum array p after sorting, but you do not know what
array a is. Your task is to count the number of initial arrays a such that the
above process results in the given sorted prefix sum array p . As this number
can be large, you are only required to find it modulo 998\,244\,353 .

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 1000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 5000
) — the size of the hidden array a .

The second line of each test case contains n integers p_1, p_2, \ldots, p_n
(|p_i| \le n ) — the n prefix sums of a sorted in non-decreasing order.

It is guaranteed that p_1 \le p_2 \le \ldots \le p_n .

It is guaranteed that the sum of n over all test cases does not exceed 5000 .

Output

For each test case, output the answer modulo 998\,244\,353 .

Example

Input

    5
    
    1
    
    0
    
    1
    
    1
    
    3
    
    -1 1 2
    
    5
    
    -1 0 0 1 1
    
    5
    
    -4 -3 -3 -2 -1

Output

    0
    1
    0
    3
    1
    
Note

In the first two test cases, the only possible arrays a for n = 1 are a = [1]
and a = [-1] . Their respective sorted prefix sum arrays p are p = [1] and p =
[-1] . Hence, there is no array a that can result in the sorted prefix sum
array p = [0] and there is exactly 1 array a that can result in the sorted
prefix sum array p = [1] .

In the third test case, it can be proven that there is no array a that could
result in the sorted prefix sum array p = [-1, 1, 2] .

In the fourth test case, the 3 possible arrays a that could result in the
sorted prefix sum array p = [-1, 0, 0, 1, 1] are:

  * a = [1, -1, 1, -1, -1] . The prefix sum array before sorting is p = [1, 0, 1, 0, -1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [1, -1, -1, 1, 1] . The prefix sum array before sorting is p = [1, 0, -1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [-1, 1, 1, -1, 1] . The prefix sum array before sorting is p = [-1, 0, 1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 

For the fifth test case, the only possible array a that could result in the
sorted prefix sum array p = [-4, -3, -3, -2, -1] is a = [-1, -1, -1, -1, 1] .

- Program: 

#Function 1:
def func_1(n, p):
    dp = [0] * (2 * n + 1)
    offset = n
    dp[offset] = 1
    for i in range(1, n + 1):
        new_dp = [0] * (2 * n + 1)
        for j in range(2 * n + 1):
            if dp[j] > 0:
                if j + 1 <= 2 * n:
                    new_dp[j + 1] = (new_dp[j + 1] + dp[j]) % MOD
                if j - 1 >= 0:
                    new_dp[j - 1] = (new_dp[j - 1] + dp[j]) % MOD
        dp = new_dp
    final_sum = p[-1] + offset
    return dp[final_sum]

#Function 2:
def func_2():
    import sys
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        index += 1
        p = list(map(int, data[index:index + n]))
        index += n
        result = func_1(n, p)
        results.append(result)
    for res in results:
        print(res)



- Annotated Code: 
MOD = 998244353
if __name__ == '__main__':
    func_2()

#Function 1:
#State of the program right berfore the function call: n is a positive integer representing the size of the hidden array a, and p is a list of integers of length n representing the sorted prefix sums of array a, where each element in p satisfies |p_i| <= n.
def func_1(n, p):
    dp = [0] * (2 * n + 1)
    offset = n
    dp[offset] = 1
    for i in range(1, n + 1):
        new_dp = [0] * (2 * n + 1)
        
        for j in range(2 * n + 1):
            if dp[j] > 0:
                if j + 1 <= 2 * n:
                    new_dp[j + 1] = (new_dp[j + 1] + dp[j]) % MOD
                if j - 1 >= 0:
                    new_dp[j - 1] = (new_dp[j - 1] + dp[j]) % MOD
        
        dp = new_dp
        
    #State: `dp` is a list of `2 * n + 1` elements where `dp[j]` is the binomial coefficient `C(n, (n + j) / 2) % MOD` if `(n + j)` is even, and `0` if `(n + j)` is odd. All other variables remain unchanged.
    final_sum = p[-1] + offset
    return dp[final_sum]
    #The program returns `dp[dp[-1] + offset]`
#Overall this is what the function does:The function `func_1` takes a positive integer `n` and a list of integers `p` of length `n` as input. It computes and returns a specific value from a dynamic programming array `dp` based on the input parameters. The returned value is `dp[dp[-1] + offset]`, where `offset` is a predefined value within the function.

#Function 2:
#State of the program right berfore the function call: n is a positive integer representing the size of the hidden array a, and p is a list of n integers representing the sorted prefix sums of array a.
def func_2():
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        
        index += 1
        
        p = list(map(int, data[index:index + n]))
        
        index += n
        
        result = func_1(n, p)
        
        results.append(result)
        
    #State: `n` is the integer value from the last iteration, `p` is the list of integers from the last iteration, `index` is the position after the last `p` was read, `t` is the initial integer value, `data` is the initial list of strings, `input` is reassigned to `sys.stdin.read`, and `results` is a list of results from `func_1(n, p)` for each iteration.
    for res in results:
        print(res)
        
    #State: `n` is the integer value from the last iteration, `p` is the list of integers from the last iteration, `index` is the position after the last `p` was read, `t` is the initial integer value, `data` is the initial list of strings, `input` is reassigned to `sys.stdin.read`, and `results` is a list of results from `func_1(n, p)` for each iteration. The elements of `results` have been printed.
#Overall this is what the function does:The function reads input from standard input, processes multiple test cases, and for each test case, it reconstructs an array `a` from given prefix sums `p`. It then prints the reconstructed array for each test case.




Beggining of Original Assessment: 
Let's analyze the provided program and see if it meets the problem description for all potential cases.

### Analysis

The problem requires counting the number of initial arrays `a` such that the sorted prefix sums of `a` match the given sorted prefix sum array `p`. The program uses dynamic programming to solve this problem.

#### Key Points:
1. **Dynamic Programming Array (`dp`)**: The `dp` array is used to keep track of the number of ways to achieve a particular prefix sum at each step. The array is offset by `n` to handle negative sums.
2. **Transition**: For each prefix sum calculation, the program considers the possibility of adding `1` or `-1` to the current prefix sum.
3. **Final Calculation**: After processing all prefix sums, the program returns the number of ways to achieve the final prefix sum in the `dp` array.

### Edge Cases and Considerations:
1. **Single Element Case**: If `n = 1`, the program should correctly return `1` for `p = [1]` and `0` for `p = [0]`.
2. **Multiple Elements**: The program should correctly handle cases where `n > 1` and the sorted prefix sums `p` are given.
3. **Negative Prefix Sums**: The program should handle negative prefix sums correctly by using the offset `n`.

### Testing the Program with Examples

Let's test the program with the provided examples to ensure it works correctly.

1. **Example 1**:
   - Input: `n = 1`, `p = [0]`
   - Expected Output: `0`
   - Program Output: `0` (Correct)

2. **Example 2**:
   - Input: `n = 1`, `p = [1]`
   - Expected Output: `1`
   - Program Output: `1` (Correct)

3. **Example 3**:
   - Input: `n = 3`, `p = [-1, 1, 2]`
   - Expected Output: `0`
   - Program Output: `0` (Correct)

4. **Example 4**:
   - Input: `n = 5`, `p = [-1, 0, 0, 1, 1]`
   - Expected Output: `3`
   - Program Output: `3` (Correct)

5. **Example 5**:
   - Input: `n = 5`, `p = [-4, -3, -3, -2, -1]`
   - Expected Output: `1`
   - Program Output: `1` (Correct)

### Conclusion

The program appears to handle the given examples correctly. However, to ensure correctness, we need to consider other potential edge cases, such as:
- **All Elements Positive**: `n = 5`, `p = [1, 2, 3, 4, 5]`
- **All Elements Negative**: `n = 5`, `p = [-5, -4, -3, -2, -1]`
- **Mixed Elements**: `n = 5`, `p = [-2, -1, 0, 1, 2]`
- **Repeated Prefix Sums**: `n = 5`, `p = [0, 0, 0, 0, 0]`

Testing these cases, the program seems to handle them correctly as well. Therefore, based on the analysis and testing, the program appears to be correct for all potential cases.

### Final Answer
Correctness: **True**

### Explanation
The program correctly uses dynamic programming to count the number of initial arrays `a` that can produce the given sorted prefix sum array `p`. It handles various edge cases, including single-element arrays, all positive/negative prefix sums, mixed elements, and repeated prefix sums. The program also correctly applies the modulo operation to ensure the result fits within the required constraints.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

