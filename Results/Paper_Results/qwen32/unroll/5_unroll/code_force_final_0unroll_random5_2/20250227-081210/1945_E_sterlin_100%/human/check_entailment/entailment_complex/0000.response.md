### Reasoning:
Let's break down the problem and the provided solution step by step to verify its correctness.

1. **Input Parsing**:
   - `func_1()`: Reads the number of test cases `t`.
   - `func_2()`: Reads the values `n` and `x` for each test case.
   - `func_3()`: Reads the permutation `p` for each test case.

2. **Main Logic**:
   - The program maintains a dictionary `num_indx` to quickly find the index of any number in the permutation `p`.
   - It initializes `left` to 0 and `right` to `n` and performs a binary search to find the position where `p[left]` could potentially be equal to `x`.
   - If `p[left]` is equal to `x` after the binary search, no swaps are needed (`k = 0`).
   - If `x` was never seen during the binary search (`seen[x - 1]` is False), it means `x` is not in the current range and can be swapped into position `left + 1` (`k = 1`).
   - If `x` was seen but `p[left]` is not `x`, it means `x` is in the permutation but not in the correct position. The program identifies an unseen element and swaps it with `x` and then with `p[left]` to achieve the desired position (`k = 2`).

3. **Output**:
   - The program outputs the number of swaps `k` and the indices of the elements being swapped.

### Verification:
- **Correctness of Input Parsing**: `func_1`, `func_2`, and `func_3` correctly parse the input as described in the problem statement.
- **Binary Search Implementation**: The binary search implementation is correct for finding the position where `p[left]` could be equal to `x`.
- **Handling Different Cases**:
  - **Case 1**: When `p[left] == x`, the program correctly outputs `0`.
  - **Case 2**: When `x` was never seen, the program correctly identifies the position to swap `x` into and outputs `1` along with the swap indices.
  - **Case 3**: When `x` was seen but `p[left]` is not `x`, the program correctly identifies an unseen element and performs two swaps to place `x` at the correct position, outputting `2` along with the swap indices.

### Conclusion:
The provided program correctly implements the logic to rearrange the permutation `p` such that after performing up to 2 swaps, the binary search will find `x` at position `p[left]`. The program handles all edge cases as described and outputs the correct number of swaps and their indices.

**Correctness: True**