### Reasoning:

1. **Input Parsing**:
   - The program reads the entire input at once using `sys.stdin.read()` and splits it into a list of strings `data`.
   - It then parses the number of test cases `T` from the first element of `data`.
   - For each test case, it reads the number of signs `n` and the list of periodicities `a`.

2. **Logic to Find the Year of the N-th Sign**:
   - For each test case, the program initializes `last_year` with the first periodicity `a[0]`.
   - It then iterates over the remaining signs (from the second to the n-th sign).
   - For each sign, it calculates the `next_year` as follows:
     - `(last_year + 1 + a[i] - 1) // a[i] * a[i]` computes the smallest multiple of `a[i]` that is strictly greater than `last_year`.
     - This ensures that the next sign occurs strictly after the previous one.
   - It updates `last_year` to `next_year` for the next iteration.
   - After processing all signs, `last_year` holds the year in which the n-th sign occurs.

3. **Output**:
   - The program collects the results for all test cases in the `results` list.
   - It then prints the results, each on a new line.

### Verification Against the Example:

- **First Test Case**:
  - `n = 6`, `a = [3, 2, 4, 5, 9, 18]`
  - `last_year` starts at `3`.
  - For the second sign, `next_year = (3 + 1 + 2 - 1) // 2 * 2 = 4`.
  - For the third sign, `next_year = (4 + 1 + 4 - 1) // 4 * 4 = 8`.
  - For the fourth sign, `next_year = (8 + 1 + 5 - 1) // 5 * 5 = 10`.
  - For the fifth sign, `next_year = (10 + 1 + 9 - 1) // 9 * 9 = 18`.
  - For the sixth sign, `next_year = (18 + 1 + 18 - 1) // 18 * 18 = 36`.
  - The output is `36`.

- **Second Test Case**:
  - `n = 5`, `a = [1, 2, 3, 4, 5]`
  - `last_year` starts at `1`.
  - For the second sign, `next_year = (1 + 1 + 2 - 1) // 2 * 2 = 2`.
  - For the third sign, `next_year = (2 + 1 + 3 - 1) // 3 * 3 = 3`.
  - For the fourth sign, `next_year = (3 + 1 + 4 - 1) // 4 * 4 = 4`.
  - For the fifth sign, `next_year = (4 + 1 + 5 - 1) // 5 * 5 = 5`.
  - The output is `5`.

- **Third Test Case**:
  - `n = 5`, `a = [1, 1, 1, 1, 1]`
  - `last_year` starts at `1`.
  - For each subsequent sign, `next_year` is always `last_year + 1`.
  - The output is `5`.

- **Fourth Test Case**:
  - `n = 6`, `a = [50, 30, 711, 200, 503, 1006]`
  - `last_year` starts at `50`.
  - For the second sign, `next_year = (50 + 1 + 30 - 1) // 30 * 30 = 60`.
  - For the third sign, `next_year = (60 + 1 + 711 - 1) // 711 * 711 = 771`.
  - For the fourth sign, `next_year = (771 + 1 + 200 - 1) // 200 * 200 = 1000`.
  - For the fifth sign, `next_year = (1000 + 1 + 503 - 1) // 503 * 503 = 1512`.
  - For the sixth sign, `next_year = (1512 + 1 + 1006 - 1) // 1006 * 1006 = 2012`.
  - The output is `2012`.

### Conclusion:
The program correctly implements the logic to determine the year in which the n-th sign occurs for each test case. It matches the expected output for the provided examples.

**Correctness: True**