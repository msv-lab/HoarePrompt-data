Let's break down the reasoning step-by-step to determine if the provided program is correct:

1. **Understanding the Problem**:
   - We need to decode a string `b` which was encoded using a specific method.
   - The encoding process involves creating an auxiliary string `r` which contains all distinct characters of `b` sorted in alphabetical order.
   - Each character in `b` is replaced by its symmetric character from `r`.
   - For decoding, we need to reverse this process.

2. **Approach in the Program**:
   - The program reads multiple test cases.
   - For each test case, it reads the length of the encoded string `n` and the encoded string `b`.
   - It then calls the function `func_1` to decode the string `b`.

3. **Function `func_1`**:
   - It creates the auxiliary string `r` by taking the set of characters from `b` (to get unique characters), sorting them alphabetically, and joining them.
   - It creates a dictionary `mapping` where each character in `r` is mapped to its symmetric character from `r`.
   - It then decodes the string `b` by replacing each character with its mapped character from `mapping`.

4. **Validation**:
   - The function correctly identifies the unique characters and sorts them to create `r`.
   - It correctly sets up the mapping between characters in `r` and their symmetric counterparts.
   - It correctly decodes the string `b` by using the mapping dictionary.

5. **Testing with Example**:
   - For the first test case, `b="serofedsoc"`, the unique characters sorted alphabetically form `r="cdefors"`. The mapping is `{'c':'s', 'd':'r', 'e':'o', 'f':'e', 'o':'d', 'r':'c', 's':'f'}`. Decoding `b` using this mapping results in `s="codeforces"`, which is correct.
   - Similarly, the other test cases can be verified to produce the correct outputs.

Based on the above reasoning, the program correctly decodes the encoded string `b` as per the problem description.

**Correctness: True**