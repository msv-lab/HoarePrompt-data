Let's analyze the problem and the provided program step by step to determine if it is correct.

### Problem Analysis

1. **Objective**: Determine the number of different final configurations possible after `k` moves, given the constraints of the game.
2. **Game Rules**:
   - Players alternate turns placing rooks on an `n x n` chessboard.
   - The player places a white rook, and the computer places a black rook at the mirrored position `(c, r)`.
   - If `r == c`, the computer skips its turn.
   - No two rooks can attack each other (i.e., no two rooks can be in the same row or column).
3. **Constraints**:
   - `1 <= t <= 10^4` (number of test cases)
   - `1 <= n <= 3 * 10^5` (size of the board)
   - `0 <= k <= n` (number of moves already played)
   - The sum of `n` over all test cases does not exceed `3 * 10^5`.

### Program Analysis

1. **Initialization**:
   - The program sets the recursion limit to 400,000 and initializes a `dp` array of size `300007` with `-1`.
   - It calls `func_1(300000)`, which is supposed to fill the `dp` array with the number of configurations for board sizes up to 300,000.
   - The `dp` array is used to store the number of configurations for a board of size `n` with no invalid positions.

2. **Dynamic Programming Function (`func_1`)**:
   - The function initializes `dp[1]` to `1` (one configuration for a 1x1 board).
   - It initializes `dp[2]` to `3` (three configurations for a 2x2 board).
   - For board sizes `i` from 3 to `n`, it calculates the number of configurations using the formula:
     \[
     dp[i] = (dp[i - 1] + 2 \cdot (i - 1) \cdot dp[i - 2]) \mod 1000000007
     \]
   - This formula seems to be derived from the combinatorial nature of placing rooks on a board while avoiding attacks.

3. **Processing Test Cases**:
   - For each test case, the program reads `n` and `k`.
   - It reads `k` pairs of `(r, c)` representing the already played moves.
   - It adds `r` and `c` to a set `invalid` to keep track of rows and columns that are already occupied.
   - It calculates the number of configurations for a board of size `n - len(invalid)` using the precomputed `dp` array.
   - It prints the result, ensuring it is at least `1`.

### Correctness

1. **Dynamic Programming Formula**:
   - The formula used in `func_1` is correct for calculating the number of configurations for a board of size `n` with no invalid positions. It is derived from the fact that for each new row/column, you can place a rook in any of the available positions, and the number of configurations is influenced by the previous configurations.
   
2. **Handling Invalid Positions**:
   - The program correctly handles invalid positions by subtracting the number of invalid positions from `n` and using the resulting value to index into the `dp` array.
   - This approach ensures that the number of configurations is calculated based on the remaining available positions on the board.

3. **Edge Cases**:
   - The program handles the edge cases where `k = 0` (no moves played yet) and `k = n` (no more moves possible) correctly.
   - It ensures that the result is at least `1` by using `max(1, dp[n - len(invalid)])`.

### Conclusion

The program correctly implements the logic to calculate the number of different final configurations possible after `k` moves, given the constraints and rules of the game. It uses dynamic programming to efficiently compute the number of configurations for a board of size `n` with no invalid positions and adjusts for the already played moves.

**Correctness: True**