### Reasoning:

The provided program calculates the number of different final configurations of a chessboard game involving rooks. Here's a detailed breakdown of the program and its correctness:

1. **Initialization and Recursion Limit**: The program starts by setting the recursion limit to 400,000, which is necessary for potentially deep recursive calls, though this is not used in the current implementation. This is fine as long as no recursive functions are used.

2. **Dynamic Programming Array**:
   - `dp` is initialized with `-1` for all indices up to `300007`.
   - `func_1(300000)` is called to fill the `dp` array. This function computes the number of configurations for chessboards of size 1 up to 300000 using a dynamic programming approach.
   - The recurrence relation used is `dp[i] = (dp[i - 1] + 2 * (i - 1) * dp[i - 2]) % 1000000007`. This relation is designed to count the number of valid configurations for a board of size `i` based on the configurations of smaller boards.

3. **Input Handling**:
   - The program reads the number of test cases `t`.
   - For each test case, it reads the size of the chessboard `n` and the number of moves `k` already played.
   - It then reads the `k` moves and adds the row and column indices to the `invalid` set, indicating positions that are already occupied by rooks.

4. **Final Configuration Calculation**:
   - The number of possible final configurations for the remaining empty positions on the board is given by `dp[n - len(invalid)]`. This is because `n - len(invalid)` represents the number of empty rows (or columns) left on the board after accounting for the `k` moves.

5. **Edge Cases**:
   - The program correctly handles the case where `n - len(invalid)` is less than 1 by using `max(1, dp[n - len(invalid)])`. This ensures that the output is at least 1, which is appropriate when no moves are possible.

6. **Modulo Operation**:
   - All calculations are done modulo `1000000007` to ensure that the results fit within standard integer ranges and to comply with the problem's requirements.

### Conclusion:
The program appears to correctly implement the logic to calculate the number of different final configurations for the given chessboard game. The dynamic programming approach and the handling of input and edge cases seem to be appropriate for the problem description.

Correctness: **True**