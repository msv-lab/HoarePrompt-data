### Reasoning:

The problem requires determining the minimum number of contiguous substrings (pieces) a binary string must be cut into so that these pieces can be rearranged to form a sorted binary string (all '0's followed by all '1's). 

The provided program reads the number of test cases, and for each test case, it reads a binary string `s`. It then iterates through the string and counts the number of times a '1' is followed by a '0'. This count represents the number of boundaries where the string needs to be cut to ensure that each piece is non-decreasing (i.e., all '0's are before '1's in each piece). Since each such boundary indicates a new piece is needed, the total number of pieces required is `count + 1`.

Let's verify this logic with the example provided in the problem:

1. **Input: `11010`**
   - The string has transitions from '1' to '0' at indices 1 and 3.
   - The count of such transitions is 2.
   - Thus, the number of pieces required is `2 + 1 = 3`.

2. **Input: `00000000`**
   - There are no transitions from '1' to '0'.
   - The count is 0.
   - Thus, the number of pieces required is `0 + 1 = 1`.

3. **Input: `1`**
   - There are no transitions from '1' to '0'.
   - The count is 0.
   - Thus, the number of pieces required is `0 + 1 = 1`.

4. **Input: `10`**
   - There is a transition from '1' to '0' at index 0.
   - The count is 1.
   - Thus, the number of pieces required is `1 + 1 = 2`.

5. **Input: `0001111`**
   - There are no transitions from '1' to '0'.
   - The count is 0.
   - Thus, the number of pieces required is `0 + 1 = 1`.

6. **Input: `0110`**
   - There is a transition from '1' to '0' at index 2.
   - The count is 1.
   - Thus, the number of pieces required is `1 + 1 = 2`.

The program correctly computes the number of pieces required for each test case as per the logic described. Therefore, the program is correct.

### Correctness: **True**