The only variable in the loop head is `neighbor`, so we can only adjust that one. According to the code, the loop iterates over each `neighbor` in `tree[current]`. For the loop to execute one more time, there must be another `neighbor` in `tree[current]` that has not yet been processed.

At the end of the last iteration, `current` holds the node that was at the front of the `queue` and `tree[current]` contains at least one neighbor. If `neighbor` is not in `visited`, the `queue` includes the tuple `((neighbor, dist + 1))`.

Since we just finished processing one `neighbor`, for the loop to execute again, there must be another `neighbor` in `tree[current]` that hasn't been assigned to `neighbor` yet.

State: **`current` holds the node that was at the front of the `queue` and `tree[current]` contains at least one more neighbor that has not been processed as `neighbor`.**