### Reasoning:

Let's break down the logic and correctness of the provided Python program.

#### Overview:
The program calculates the number of permutations of length `n` that have specific prefix and suffix maximums. It uses combinatorial mathematics, particularly binomial coefficients, to compute the result efficiently.

#### Key Points:
1. **Factorials Precomputation**: The program precomputes factorials up to `200001` modulo `10^9 + 7`. This is used to calculate binomial coefficients later.
   
2. **Input Parsing**: For each test case, it reads `n`, `m1`, `m2`, the list of prefix maximum indices `p`, and the list of suffix maximum indices `s`.

3. **Initial Checks**:
   - If the last prefix maximum index `p[-1]` is not equal to the first suffix maximum index `s[0]`, or if the first prefix maximum index `p[0]` is not `1`, or if the last suffix maximum index `s[-1]` is not `n`, the program outputs `0` because such a permutation is impossible.
   
4. **Combinatorial Calculations**:
   - The program calculates the number of ways to arrange elements between suffix maximums using binomial coefficients.
   - It also calculates the number of ways to arrange elements between prefix maximums using binomial coefficients.
   - Finally, it multiplies the counts of arrangements between prefix and suffix maximums with the factorial of gaps between consecutive prefix and suffix maximums.

5. **Modular Arithmetic**: All calculations are performed modulo `10^9 + 7` to handle large numbers.

#### Function Analysis:
- **`func_1(a, b)`**: This function implements the Extended Euclidean Algorithm, which finds integers `x` and `y` such that `ax + by = gcd(a, b)`. Here, it is used to find the modular multiplicative inverse of `b` modulo `10^9 + 7`.
- **`func_2(a, b)`**: This function calculates `(a / b) % 10^9 + 7` by using the result from `func_1` to get the modular multiplicative inverse of `b`.

#### Verification Against Example:
Let's verify the program against the provided example:

- **Test Case 1**: `n=1, m1=1, m2=1, p=[1], s=[1]`
  - Only one permutation `[1]` is possible.
  - Output: `1`

- **Test Case 2**: `n=4, m1=2, m2=3, p=[1, 2], s=[2, 3, 4]`
  - Possible permutations: `[1, 4, 3, 2]`, `[2, 4, 3, 1]`, `[3, 4, 2, 1]`.
  - Output: `3`

- **Test Case 3**: `n=3, m1=3, m2=1, p=[1, 2, 3], s=[3]`
  - Only one permutation `[1, 2, 3]` is possible.
  - Output: `1`

- **Test Case 4**: `n=5, m1=3, m2=4, p=[1, 2, 3], s=[2, 3, 4, 5]`
  - No valid permutation exists.
  - Output: `0`

- **Test Case 5**: `n=20, m1=5, m2=4, p=[1, 2, 3, 4, 12], s=[12, 13, 18, 20]`
  - Output: `317580808`

- **Test Case 6**: `n=6, m1=2, m2=3, p=[1, 3], s=[3, 4, 6]`
  - Possible permutations: `[2, 1, 6, 5, 3, 4]`, `[3, 1, 6, 5, 2, 4]`, `[3, 2, 6, 5, 1, 4]`, `[4, 1, 6, 5, 2, 3]`, `[4, 2, 6, 5, 1, 3]`, `[4, 3, 6, 5, 1, 2]`, `[5, 1, 6, 4, 2, 3]`, `[5, 2, 6, 4, 1, 3]`, `[5, 3, 6, 4, 1, 2]`, `[5, 4, 6, 3, 1, 2]`.
  - Output: `10`

The program correctly handles these test cases, indicating that it is logically sound and correctly implemented.

### Conclusion:
Based on the above analysis, the program appears to be correct.

**Correctness: True**