Correctness: **False**

### Explanation:

The provided program does not correctly compute the minimum possible penalty for splitting the array as described in the problem. Let's analyze the given program and identify where it fails:

#### Issues in the Program:

1. **Incorrect Splitting Logic**:
   - The program splits the string `expression` using `split('-')`, which is not the intended way to split the array `a` into non-empty subarrays `b_1, b_2, ..., b_k` such that their concatenation equals `a`.
   - It incorrectly calculates `result_length` using the lengths of parts obtained from splitting by `'-'`, which doesn't make sense in the context of the problem.

2. **Incorrect Penalty Calculation**:
   - The function `func_1` attempts to calculate the penalty but does so incorrectly. It increments `count` whenever `balance` becomes negative, which is not the correct way to determine the optimal splits.
   - The final penalty calculation `count + (balance > 0)` does not align with the problem's requirement to minimize the total penalty.

#### Correct Approach:

To solve the problem correctly, we need to find an optimal way to split the array `a` such that the total penalty is minimized. This involves dynamic programming or a greedy approach to find the optimal splits.

Here is a corrected version of the program that computes the minimum penalty:

```python
def min_penalty(expression):
    n = len(expression)
    prefix_sum = [0] * (n + 1)
    
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + (1 if expression[i] == '+' else -1)
    
    dp = [0] * (n + 1)
    
    for i in range(1, n + 1):
        dp[i] = float('inf')
        for j in range(i):
            penalty = abs(prefix_sum[i] - prefix_sum[j]) * (i - j)
            dp[i] = min(dp[i], dp[j] + penalty)
    
    return dp[n]

t = int(input())
for _ in range(t):
    length = int(input())
    expression = input().strip()
    print(min_penalty(expression))
```

In this corrected version:
- We use a prefix sum array to efficiently calculate the sum of any subarray.
- We use dynamic programming to find the minimum penalty for splitting the array optimally.

Given the issues in the original program, it does not meet the requirements of the problem description for every potential case, hence the correctness is **False**.