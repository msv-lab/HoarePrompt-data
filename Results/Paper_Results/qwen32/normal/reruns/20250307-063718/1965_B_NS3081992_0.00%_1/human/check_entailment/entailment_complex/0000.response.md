### Reasoning:

1. **Input Reading**:
   - `func_10()` reads the number of test cases `t`.
   - `func_14()` is called `t` times within `func_15()`, and it reads two integers `n` and `k` for each test case.

2. **Logic of `func_14()`**:
   - If `k == 1`:
     - If `n == 2`, it returns `1\n2`.
     - Otherwise, it constructs a sequence starting with `[2, 3]` and continues with powers of 2 up to the length of the binary representation of `n`.
   - If `k != 1`:
     - It constructs a sequence starting with powers of 2 up to the length of the binary representation of `k`.
     - It then appends `k - 1 - sum(ans)`, `k + 1`, and `2 * k + 1` to the sequence.
     - It continues with powers of 2 from the length of the binary representation of `k` up to the length of the binary representation of `n`.

3. **Output**:
   - For each test case, `func_14()` returns a space-separated string of integers.
   - `func_15()` prints the result of `func_14()` for each test case.

4. **Verification**:
   - The sequence generated by `func_14()` ensures that no subsequence sums to `k` but all other sums from `1` to `n` (except `k`) are possible.
   - For `k == 1`, the sequence `[2, 3, 4, ...]` ensures no subsequence sums to `1`.
   - For `k != 1`, the sequence includes `k - 1 - sum(ans)`, `k + 1`, and `2 * k + 1` which ensures that `k` cannot be formed as a sum but all other sums are possible.

### Conclusion:

The logic in `func_14()` correctly constructs the required sequence based on the given conditions. The program reads the input, processes each test case using `func_14()`, and outputs the correct sequence for each test case.

**Correctness: True**