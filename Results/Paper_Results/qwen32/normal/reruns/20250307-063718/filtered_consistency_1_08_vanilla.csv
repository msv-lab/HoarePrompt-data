Task ID,unique_id,Dataset,model_created,model_run,description,Code,run_number,original correctness,summary fsl,naive correctness fsl,vanilla,vanilla_no_cot,simple tree,complex tree,summary,simple verify fsl,complex verify fsl,summary verify fsl,simple verify,complex verify,summary verify,consistency,consistency_mine,consistency_old
1950_C,1950_C_imaginary_faye_50.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Given the time in 24-hour format, output the equivalent time in 12-hour
format.

  * [24-hour format](https://en.wikipedia.org/wiki/24-hour_clock#Description) divides the day into 24 hours from 00 to 23 , each of which has 60 minutes from 00 to 59 . 
  * [12-hour format](https://en.wikipedia.org/wiki/12-hour_clock#Description) divides the day into two halves: the first half is \mathrm{AM} , and the second half is \mathrm{PM} . In each half, the hours are numbered in the order 12, 01, 02, 03, \dots, 11 . Each hour has 60 minutes numbered from 00 to 59 . 

Input

The first line contains a single integer t (1 \leq t \leq 1440 ) — the number
of test cases.

The only line of each test case contains a string s of length 5 with format
hh:mm representing a valid time in the 24-hour format. hh represents the hour
from 00 to 23 , and mm represents the minute from 00 to 59 .

The input will always be a valid time in 24-hour format.

Output

For each test case, output two strings separated by a space (""hh:mm AM"" or
""hh:mm PM""), which are the 12-hour equivalent to the time provided in the test
case (without quotes).

You should output the time exactly as indicated; in particular, you should not
remove leading zeroes.

Example

Input

    11
    
    09:41
    
    18:06
    
    12:14
    
    00:59
    
    00:00
    
    14:34
    
    01:01
    
    19:07
    
    11:59
    
    12:00
    
    21:37

Output

    09:41 AM
    06:06 PM
    12:14 PM
    12:59 AM
    12:00 AM
    02:34 PM
    01:01 AM
    07:07 PM
    11:59 AM
    12:00 PM
    09:37 PM","def gb114():
    for t in range(int(input())):
        s = input()
        h = s[:2]
        if h == '00':
            print('12', end='')
        elif int(h) <= 12:
            print(h, end='')
        else:
            print('0{}'.format(int(h) - 12), end='')
        print(s[2:], ['AM', 'PM'][int(h) >= 12])
gb114()",1,False,False,False,False,False,True,False,True,False,True,True,False,False,False,0.7347037984086121,0.24710690842272917,0.5833333333333334
1937_C,1937_C_Surin_5.88%,codeforces2024,human,qwen2p5-coder-32b-instruct,"This is an interactive problem.

There is a secret sequence p_0, p_1, \ldots, p_{n-1} , which is a permutation
of \\{0,1,\ldots,n-1\\} .

You need to find any two indices i and j such that p_i \oplus p_j is
maximized, where \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

To do this, you can ask queries. Each query has the following form: you pick arbitrary indices a , b , c , and d (0 \le a,b,c,d < n ). Next, the jury calculates x = (p_a \mid p_b) and y = (p_c \mid p_d) , where | denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR). Finally, you receive the result of comparison between x and y . In other words, you are told if x < y , x > y , or x = y .

Please find any two indices i and j (0 \le i,j < n ) such that p_i \oplus p_j
is maximum among all such pairs, using at most 3n queries. If there are
multiple pairs of indices satisfying the condition, you may output any one of
them.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^3 ). The description of the test cases follows.

Interaction

The first line of each test case contains one integer n (2 \le n \le 10^4 ).
At this moment, the permutation p_0, p_1, \ldots, p_{n-1} is chosen. The
interactor in this task is not adaptive. In other words, the sequence p is
fixed in every test case and does not change during the interaction.

To ask a query, you need to pick four indices a , b , c , and d (0 \le a,b,c,d
< n ) and print the line of the following form:

  * ""? a b c d"" 

After that, you receive:

  * ""<"" if (p_a \mid p_b) < (p_c \mid p_d) ; 
  * ""="" if (p_a \mid p_b) = (p_c \mid p_d) ; 
  * "">"" if (p_a \mid p_b) > (p_c \mid p_d) . 

You can make at most 3n queries of this form.

Next, if your program has found a pair of indices i and j (0 \le i, j < n )
such that p_i \oplus p_j is maximized, print the line of the following form:

  * ""! i j"" 

Note that this line is not considered a query and is not taken into account
when counting the number of queries asked.

After this, proceed to the next test case.

If you make more than 3n queries during an interaction, your program must
terminate immediately, and you will receive the Wrong Answer verdict.
Otherwise, you can get an arbitrary verdict because your solution will
continue to read from a closed stream.

After printing a query or the answer for a test case, do not forget to output
the end of line and flush the output. Otherwise, you will get the verdict
Idleness Limit Exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

It is guaranteed that the sum of n over all test cases does not exceed 10^4 .

Hacks

To hack, follow the test format below.

The first line contains the number of test cases t (1 \le t \le 10^3 ). The
description of the test cases follows.

The first line of each test case contains one integer n (2 \le n \le 10^4 ).

The second line of each test case contains n integers p_0,p_1,\ldots,p_{n-1} ,
which represent a permutation of integers from 0 to n - 1 .

The sum of n over all test cases should not exceed 10^4 .

Example

Input

    2
    4
    
    <
    
    =
    
    >
    
    2
    
Output

    ? 0 2 3 1
    
    ? 1 1 2 3
    
    ? 1 2 0 3
    
    ! 3 2
    
    ! 0 1
    
Note

In the first test case, the hidden permutation is p=[0,3,1,2] .

For the query ""? 0 2 3 1"", the jury return ""<"" because (p_0 \mid p_2) = (0
\mid 1) =1 < (p_3 \mid p_1) = (2 \mid 3) = 3 .

For the query ""? 1 1 2 3"", the jury return ""="" because (p_1 \mid p_1) = (3\mid
3)= 3 = (p_2 \mid p_3) = (1 \mid 2)=3 .

For the query ""? 1 2 0 3"", the jury return "">"" because (p_1 \mid p_2) = (3
\mid 1) = 3 > (p_0 \mid p_3) = (0\mid 2)=2 .

The answer i = 3 and j = 2 is valid: (p_3 \oplus p_2) = (2 \oplus 1) = 3 is
indeed equal to the maximum possible value of p_i \oplus p_j . Another valid
answer would be i=0 and j=1 . As the number of queries does not exceed 3n=12 ,
the answer is considered correct.

In the second test case, n = 2 , so p is either [0, 1] or [1, 0] . In any
case, p_0 \oplus p_1 = 1 is maximum possible.","I = lambda : list(map(int, input().split(' ')))
R = lambda : (int(input()))
 
import sys
# import bisect
# from bisect import bisect_left, bisect_right
import math
 
for kp in range(int(input())):
 
    n = int(input())
    # sys.stdout.flush()
    # print()
 
    g = 0
    v1 = 0
    for i in range(1,n):
        # v1 = 0
        v2 = i
        print(f""? {v1} {v1} {v2} {v2}"")
        sys.stdout.flush()
 
        r = input('')
        # print()
 
        if r == ""<"": v1 = v2
 
    prev = 0
    for i in range(1,n):
        print(f""? {v1} {i} {v1} {prev}"")
        sys.stdout.flush()
        r = input()
        if r == '>': prev = i
 
    # print(prev,i)
    print(f""! {prev} {v1}"")
    # print()
    sys.stdout.flush()",1,False,False,False,False,False,True,False,True,False,False,False,False,False,False,0.6380259942529448,0.1368946727398954,0.5833333333333334
1972_B,1972_B_r1813._0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There are n coins on the table forming a circle, and each coin is either
facing up or facing down. Alice and Bob take turns to play the following game,
and Alice goes first.

In each operation, the player chooses a facing-up coin, removes the coin, and
flips the two coins that are adjacent to it. If (before the operation) there
are only two coins left, then one will be removed and the other won't be
flipped (as it would be flipped twice). If (before the operation) there is
only one coin left, no coins will be flipped. If (before the operation) there
are no facing-up coins, the player loses.

Decide who will win the game if they both play optimally. It can be proved
that the game will end in a finite number of operations, and one of them will
win.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\le t\le 100 ). The description of the test cases follows.

The first line of each test case contains only one positive integer n (1 \leq
n \leq 100 ), representing the number of the coins.

A string s of length n follows on the second line of each test case,
containing only ""U"" and ""D"", representing that each coin is facing up or
facing down.

Output

For each test case, print ""YES"" if Alice will win the game, and ""NO""
otherwise.

You can output the answer in any case (upper or lower). For example, the
strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be recognized as positive
responses.

Example

Input

    3
    
    5
    
    UUDUD
    
    5
    
    UDDUD
    
    2
    
    UU

Output

    YES
    NO
    NO
    
Note

In the first test case, the game may go as follows.

  * Alice chooses the first coin and s becomes ""DDUU"". 
  * Bob chooses the last coin and s becomes ""UDD"". 
  * Alice chooses the first coin and s becomes ""UU"". 
  * Bob chooses the first coin and s becomes ""U"". 
  * Alice chooses the only coin and s becomes empty. 
  * Bob can't choose any coin now, and he loses the game. 

It can be proved that Bob will always lose if they both play optimally.","def solve_coin_game():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    t = int(data[index])
    index += 1
    
    results = []
    
    for _ in range(t):
        n = int(data[index])
        index += 1
        s = data[index]
        index += 1
        
        # Count the number of 'U' (face-up) coins
        num_up_coins = s.count('U')
        
        # Determine the winner based on the parity of the count
        if num_up_coins % 2 == 1:
            results.append(""YES"")
        else:
            results.append(""NO"")
    
    # Print all results
    for result in results:
        print(result)
 
# Uncomment the following line to run the function with standard input
# solve_coin_game()",1,False,True,True,True,True,True,True,True,True,True,True,True,True,True,0.6903501855456995,0.2067854943891225,0.5
1957_C,1957_C_hx199411_2.78%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)","t = int(input())
while t:
    t -= 1
    n,k = list(map(int,input().split(' ')))
    num = 0
    for i in range(k):
        c,r = list(map(int,input().split(' ')))
        if c == r:
            num += 1
        else:
            num += 2
    m = n - num
    if m == 0:
        print(0)
    elif m == 1:
        print(1)
    else:
        dp = [0 for i in range(m+1)]
        dp[1] = 1
        dp[2] = 3
        for i in range(3,m+1):
            dp[i] = (dp[i-1] + (i-1)*dp[i-2]*2)%(10**9+7)
        print(dp[m])",1,False,True,False,True,False,True,False,True,False,True,False,True,True,True,0.7433089548186087,0.3209398334641705,0.5833333333333334
1972_B,1972_B_chri217._0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There are n coins on the table forming a circle, and each coin is either
facing up or facing down. Alice and Bob take turns to play the following game,
and Alice goes first.

In each operation, the player chooses a facing-up coin, removes the coin, and
flips the two coins that are adjacent to it. If (before the operation) there
are only two coins left, then one will be removed and the other won't be
flipped (as it would be flipped twice). If (before the operation) there is
only one coin left, no coins will be flipped. If (before the operation) there
are no facing-up coins, the player loses.

Decide who will win the game if they both play optimally. It can be proved
that the game will end in a finite number of operations, and one of them will
win.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\le t\le 100 ). The description of the test cases follows.

The first line of each test case contains only one positive integer n (1 \leq
n \leq 100 ), representing the number of the coins.

A string s of length n follows on the second line of each test case,
containing only ""U"" and ""D"", representing that each coin is facing up or
facing down.

Output

For each test case, print ""YES"" if Alice will win the game, and ""NO""
otherwise.

You can output the answer in any case (upper or lower). For example, the
strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be recognized as positive
responses.

Example

Input

    3
    
    5
    
    UUDUD
    
    5
    
    UDDUD
    
    2
    
    UU

Output

    YES
    NO
    NO
    
Note

In the first test case, the game may go as follows.

  * Alice chooses the first coin and s becomes ""DDUU"". 
  * Bob chooses the last coin and s becomes ""UDD"". 
  * Alice chooses the first coin and s becomes ""UU"". 
  * Bob chooses the first coin and s becomes ""U"". 
  * Alice chooses the only coin and s becomes empty. 
  * Bob can't choose any coin now, and he loses the game. 

It can be proved that Bob will always lose if they both play optimally.","def determine_winner(s):
    # Count the number of 'U' characters in the string
    num_up = s.count('U')
    
    # Determine the winner based on the parity of the number of 'U' characters
    if num_up % 2 == 1:
        return ""YES""
    else:
        return ""NO""
 
# Read input
import sys
input = sys.stdin.read
data = input().split()
 
# Parse the number of test cases
t = int(data[0])
 
# Iterate over each test case
for _ in range(t):
    # Read the number of coins
    n = int(data[1])
    
    # Read the string representation of the coins
    s = data[2]
    
    # Determine and print the result
    print(determine_winner(s))",1,False,True,True,True,True,True,True,True,True,True,True,True,True,True,0.6039097492430465,0.10523649229049625,0.5
1957_C,1957_C_hx199411_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)","t = int(input())
while t:
    t -= 1
    n,k = list(map(int,input().split(' ')))
    num = 0
    for i in range(k):
        c,r = list(map(int,input().split(' ')))
        if c == r:
            num += 1
        else:
            num += 2
    m = n - num
    if m == 0:
        print(1)
    elif m == 1:
        print(1)
    else:
        dp = [0 for i in range(m+1)]
        dp[1] = 1
        dp[2] = 3
        for i in range(3,m+1):
            dp[i] = (dp[i-1] + (i-1)*dp[i-2]*2)%(10**9+7)
        print(dp[m])",1,True,True,False,True,True,True,True,True,False,False,False,True,True,True,0.40849978776192514,-0.09525744994067215,0.5
1978_B,1978_B__professor-_50.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Bob decided to open a bakery. On the opening day, he baked n buns that he can
sell. The usual price of a bun is a coins, but to attract customers, Bob
organized the following promotion:

  * Bob chooses some integer k (0 \le k \le \min(n, b) ).
  * Bob sells the first k buns at a modified price. In this case, the price of the i -th (1 \le i \le k ) sold bun is (b - i + 1) coins.
  * The remaining (n - k) buns are sold at a coins each.

Note that k can be equal to 0 . In this case, Bob will sell all the buns at a
coins each.

Help Bob determine the maximum profit he can obtain by selling all n buns.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains three integers n , a , and b (1 \le
n, a, b \le 10^9 ) — the number of buns, the usual price of a bun, and the
price of the first bun to be sold at a modified price.

Output

For each test case, output a single integer — the maximum profit that Bob can
obtain.

Example

Input

    7
    
    4 4 5
    
    5 5 9
    
    10 10 5
    
    5 5 11
    
    1000000000 1000000000 1000000000
    
    1000000000 1000000000 1
    
    1000 1 1000

Output

    17
    35
    100
    45
    1000000000000000000
    1000000000000000000
    500500
    
Note

In the first test case, it is optimal for Bob to choose k = 1 . Then he will
sell one bun for 5 coins, and three buns at the usual price for 4 coins each.
Then the profit will be 5 + 4 + 4 + 4 = 17 coins.

In the second test case, it is optimal for Bob to choose k = 5 . Then he will
sell all the buns at the modified price and obtain a profit of 9 + 8 + 7 + 6 +
5 = 35 coins.

In the third test case, it is optimal for Bob to choose k = 0 . Then he will
sell all the buns at the usual price and obtain a profit of 10 \cdot 10 = 100
coins.","t=int(input())
for _ in range(t):
    n,a,b=map(int,input().split())
    if b<=a:
        print(n*a)
    else:
        if (b-a)>=n:
            print(int((2*b-n+1)*n/2))
        else:
            print(int((b-a)/2*(b-a+1)+a*n))",1,False,False,False,False,False,False,False,False,False,False,False,False,False,False,0.7709564406191117,0.30954473066548477,0.75
1968_A,1968_A_klu_30309_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an integer x . Your task is to find any integer y (1\le y<x)
such that \gcd(x,y)+y is maximum possible.

Note that if there is more than one y which satisfies the statement, you are
allowed to find any.

\gcd(a,b) is the Greatest Common Divisor of a and b . For example, \gcd(6,4)=2
.

Input

The first line contains a single integer t (1 \le t \le 1000 ) — the number of
test cases.

Each of the following t lines contains a single integer x (2 \le x \le 1000 ).

Output

For each test case, output any y (1 \le y < x ), which satisfies the
statement.

Example

Input

    7
    
    10
    
    7
    
    21
    
    100
    
    2
    
    1000
    
    6

Output

    5
    6
    18
    98
    1
    750
    3","def maximize_gcd_plus_y(x):
  """"""Finds the y that maximizes gcd(x, y) + y.
 
  Args:
    x: The given integer.
 
  Returns:
    The optimal y.
  """"""
 
  max_val = 1
  for y in range(x - 1, 1, -1):
    if x % y == 0:
      if 2 * y >= x:
        return y
      max_val = y
  return max_val
 
if __name__ == ""__main__"":
  t = int(input())
 
  for _ in range(t):
    x = int(input())
    y = maximize_gcd_plus_y(x)
    print(y)",1,False,True,False,True,True,True,True,True,False,False,False,False,True,False,0.6907066668782557,0.21258425069513912,0.6666666666666666
1923_C,1923_C_harshkankhar1_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"An array a of length m is considered good if there exists an integer array b
of length m such that the following conditions hold:

  1. \sum\limits_{i=1}^{m} a_i = \sum\limits_{i=1}^{m} b_i ; 
  2. a_i \neq b_i for every index i from 1 to m ; 
  3. b_i > 0 for every index i from 1 to m . 

You are given an array c of length n . Each element of this array is greater
than 0 .

You have to answer q queries. During the i -th query, you have to determine
whether the subarray c_{l_{i}}, c_{l_{i}+1}, \dots, c_{r_{i}} is good.

Input

The first line contains one integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains two integers n and q (1 \le n, q \le
3 \cdot 10^5 ) — the length of the array c and the number of queries.

The second line of each test case contains n integers c_1, c_2, \dots, c_n (1
\le c_i \le 10^9 ).

Then q lines follow. The i -th of them contains two integers l_i and r_i (1
\le l_i \le r_i \le n ) — the borders of the i -th subarray.

Additional constraints on the input: the sum of n over all test cases does not
exceed 3 \cdot 10^5 ; the sum of q over all test cases does not exceed 3 \cdot
10^5 .

Output

For each query, print YES if the subarray is good. Otherwise, print NO.

You can output each letter of the answer in any case (upper or lower). For
example, the strings yEs, yes, Yes, and YES will all be recognized as positive
responses.

Example

Input

    1
    
    5 4
    
    1 2 1 4 5
    
    1 5
    
    4 4
    
    3 4
    
    1 3

Output

    YES
    NO
    YES
    NO","from itertools import accumulate
def solve():
    n,q=map(int,input().split())
    a=[0]+[int(x) for x in input().split()]
    b=[0]*(n+1)
    for i in range(1,n+1):
        x = 1 if a[i]>1 else 2
        b[i]=b[i-1] + x
    a=list(accumulate(a))
 
    for _ in range(q):
        x,y=map(int,input().split())
        print(""NO"") if a[y]-a[x-1]<b[y]-b[x-1] or x==y else print(""YES"") 
   
   
 
for _ in range(int(input())):
    solve()",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False,0.6082707322568786,0.10784409477044866,0.5
1968_C,1968_C_tah23seen_6.67%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an array x_2,x_3,\dots,x_n . Your task is to find any array
a_1,\dots,a_n , where:

  * 1\le a_i\le 10^9 for all 1\le i\le n . 
  * x_i=a_i \bmod a_{i-1} for all 2\le i\le n . 

Here c\bmod d denotes the remainder of the division of the integer c by the
integer d . For example 5 \bmod 2 = 1 , 72 \bmod 3 = 0 , 143 \bmod 14 = 3 .

Note that if there is more than one a which satisfies the statement, you are
allowed to find any.

Input

The first line contains a single integer t (1\le t\le 10^4) — the number of
test cases.

The first line of each test case contains a single integer n (2\le n\le 500) —
the number of elements in a .

The second line of each test case contains n-1 integers x_2,\dots,x_n (1\le
x_i\le 500) — the elements of x .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 .

Output

For each test case output any a_1,\dots,a_n (1 \le a_i \le 10^9 ) which
satisfies the statement.

Example

Input

    5
    
    4
    
    2 4 1
    
    3
    
    1 1
    
    6
    
    4 2 5 1 2
    
    2
    
    500
    
    3
    
    1 5

Output

    3 5 4 9
    2 5 11
    5 14 16 5 11 24
    501 500
    2 7 5

Note

In the first test case a=[3,5,4,9] satisfies the conditions, because:

  * a_2\bmod a_1=5\bmod 3=2=x_2 ; 
  * a_3\bmod a_2=4\bmod 5=4=x_3 ; 
  * a_4\bmod a_3=9\bmod 4=1=x_4 ;","def solve(arr,n):
  ans=[0]*(n)
  ans[0]=arr[0]+1
  for i in range(n-2):
    ans[i+1]=arr[i]+ans[i]
    if ans[i+1]<arr[i+1]:
      while ans[i+1]<=arr[i+1]:
        ans[i+1]+=ans[i]
  ans[-1]=ans[-2]+arr[-1]
  return ans
 
t=int(input())
while t:
  n=int(input())
  arr=[int(x) for x in input().split("" "")]
  ans=solve(arr,n)
  for i in ans:
    print(i,end=' ')
  print()
  t-=1",1,False,True,False,False,False,True,False,True,False,False,True,False,False,False,0.7740908088003147,0.31561793909854163,0.6666666666666666
1930_B,1930_B_bigdamdam_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given a positive integer n .

Find a permutation^\dagger p of length n such that there do not exist two
distinct indices i and j (1 \leq i, j < n ; i \neq j ) such that p_i divides
p_j and p_{i+1} divides p_{j+1} .

Refer to the Notes section for some examples.

Under the constraints of this problem, it can be proven that at least one p
exists.

^\dagger A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (3 \leq n \leq
10^5 ) — the length of the permutation p .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output p_1, p_2, \ldots, p_n .

If there are multiple solutions, you may output any one of them.

Example

Input

    2
    
    4
    
    3

Output

    4 1 2 3
    1 2 3
    
Note

In the first test case, p=[4,1,2,3] is a valid permutation. However, the
permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and
j=3 . Then p_1=1 divides p_3=3 and p_2=2 divides p_4=4 . Note that the
permutation p=[3, 4, 2, 1] is also not a valid permutation as we can choose
i=3 and j=2 . Then p_3=2 divides p_2=4 and p_4=1 divides p_3=2 .

In the second test case, p=[1,2,3] is a valid permutation. In fact, all 6
permutations of length 3 are valid.","for i in range(int(input())):
      n = [int(i)for i in input().split()][0]
      p = [0]*n;ind = n
      for i in range(0,n,2):p[i]=ind;ind -= 2
      ind = 1 + n%2
      for i in range(1,n,2):p[i]=ind;ind += 2
      print(*p)",1,True,True,True,True,True,True,True,True,True,True,True,True,True,True,0.722070980084832,0.23786776414090813,0.5833333333333334
