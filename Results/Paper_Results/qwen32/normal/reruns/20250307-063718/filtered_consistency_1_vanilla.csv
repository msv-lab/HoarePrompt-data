Task ID,unique_id,Dataset,model_created,model_run,description,Code,run_number,original correctness,summary fsl,naive correctness fsl,vanilla,vanilla_no_cot,simple tree,complex tree,summary,simple verify fsl,complex verify fsl,summary verify fsl,simple verify,complex verify,summary verify,consistency,consistency_mine,consistency_old
1932_B,1932_B_permaximum_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"The Chaya tribe believes that there are n signs of the apocalypse. Over time,
it has been found out that the i -th sign occurs every a_i years (in years a_i
, 2 \cdot a_i , 3 \cdot a_i , \dots ).

According to the legends, for the apocalypse to happen, the signs must occur
sequentially. That is, first they wait for the first sign to occur, then
strictly after it, the second sign will occur, and so on. That is, if the i
-th sign occurred in the year x , the tribe starts waiting for the occurrence
of the (i+1) -th sign, starting from the year x+1 .

In which year will the n -th sign occur and the apocalypse will happen?

Input

The first line of the input contains a single integer t (1 \le t \le 1000 ) —
the number of test cases. Then follow the descriptions of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 100
) — the number of signs.

The second line of each test case contains n integers a_1, a_2, a_3, \dots,
a_n (1 \le a_i \le 10^6 ) — the periodicities of the signs.

Output

For each test case, output a single integer — the year in which all n signs
will occur.

Example

Input

    4
    
    6
    
    3 2 4 5 9 18
    
    5
    
    1 2 3 4 5
    
    5
    
    1 1 1 1 1
    
    6
    
    50 30 711 200 503 1006

Output

    36
    5
    5
    2012
    
Note

In the first set of input data of the example:

  * The tribe will wait for the first sign in the 3 -rd year; 
  * the tribe will wait for the second sign in the 4 -th year (since year 2 have already passed); 
  * the tribe will wait for the third sign in the 8 -th year (since the second sign has already occurred in the 4 -th year); 
  * the tribe will wait for the fourth sign in the 10 -th year (since year 5 have already passed); 
  * the tribe will wait for the fifth sign in the 18 -th year (since year 9 have already passed); 
  * the tribe will wait for the sixth sign in the 36 -th year (since the fifth sign has already occurred in the 18 -th year).","def apocalypse(t, test_cases):
    results = []
    for test in test_cases:
        n, a = test
        current_year = 0
        for ai in a:
            # Find the next year when the sign ai occurs
            if current_year % ai == 0:
                next_year = current_year + ai
            else:
                next_year = ((current_year // ai) + 1) * ai
            current_year = next_year
        results.append(current_year)
    return results
 
# Read input
t = int(input().strip())
test_cases = []
for _ in range(t):
    n = int(input().strip())
    a = list(map(int, input().strip().split()))
    test_cases.append((n, a))
 
# Get results
results = apocalypse(t, test_cases)
 
# Print results
for result in results:
    print(result)",1,True,False,True,True,True,True,True,True,True,True,True,True,True,True,,,
1965_A,1965_A_panda.BANDANA_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Alice and Bob are playing a game on n piles of stones. On each player's turn,
they select a positive integer k that is at most the size of the smallest
nonempty pile and remove k stones from each nonempty pile at once. The first
player who is unable to make a move (because all piles are empty) loses.

Given that Alice goes first, who will win the game if both players play
optimally?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le
2\cdot 10^5 ) — the number of piles in the game.

The next line of each test case contains n integers a_1, a_2, \ldots a_n (1
\le a_i \le 10^9 ), where a_i is the initial number of stones in the i -th
pile.

It is guaranteed that the sum of n over all test cases does not exceed 2\cdot
10^5 .

Output

For each test case, print a single line with the name of the winner, assuming
both players play optimally. If Alice wins, print ""Alice"", otherwise print
""Bob"" (without quotes).

Example

Input

    7
    
    5
    
    3 3 3 3 3
    
    2
    
    1 7
    
    7
    
    1 3 9 7 4 2 100
    
    3
    
    1 2 3
    
    6
    
    2 1 3 4 2 4
    
    8
    
    5 7 2 9 6 3 3 2
    
    1
    
    1000000000

Output

    Alice
    Bob
    Alice
    Alice
    Bob
    Alice
    Alice
    
Note

In the first test case, Alice can win by choosing k=3 on her first turn, which
will empty all of the piles at once.

In the second test case, Alice must choose k=1 on her first turn since there
is a pile of size 1 , so Bob can win on the next turn by choosing k=6 .","t=int(input())
for i in range(t):
    n=int(input())
    l=map(int,input().split())
    lis=sorted(set(l))
    if (1 not in lis) or (len(lis)==1) :
        print(""Alice"")
    else:
        
        test=True
        for j in range(1,len(lis)):
            if lis[j]-lis[j-1]>1:
                if j%2==1:
                    print(""Bob"")
                else:
                    print(""Alice"")
                test=False
                break
        if test==True:
            if len(lis)%2==1:
                print(""Alice"")
            else:
                print(""Bob"")",1,True,True,False,False,False,True,False,False,False,False,False,False,False,False,0.9761342795561893,0.8942548828936666,0.9166666666666666
1957_C,1957_C_Phyber_Optik_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)","import sys
 
sys.setrecursionlimit(400000)
 
dp = [-1 for _ in range(300007)]
 
def go(n):
    # if n <= 1:
    #     return 1
 
    # if dp[n] != -1:
    #     return dp[n]
 
    # dp[n] = (go(n - 1) + 2 * (n - 1) * go(n - 2)) % 1000000007
 
    # return dp[n]
    dp[1] = 1
    dp[2] = 3
    for i in range(3, n + 1):
        dp[i] = (dp[i - 1] + 2 * (i - 1) * dp[i - 2]) % 1000000007
 
go(300000)
t = int(input())
 
for _ in range(t):
    n, k = map(int, input().split())
    invalid = set([])
 
    for _ in range(k):
        r, c = map(int, input().split())
        invalid.add(r)
        invalid.add(c)
 
 
    print(max(1, dp[n - len(invalid)]))",1,True,False,False,True,False,True,True,False,False,False,False,True,True,True,0.8952528185874715,0.4797126352451899,0.8333333333333334
1950_C,1950_C_imaginary_faye_50.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Given the time in 24-hour format, output the equivalent time in 12-hour
format.

  * [24-hour format](https://en.wikipedia.org/wiki/24-hour_clock#Description) divides the day into 24 hours from 00 to 23 , each of which has 60 minutes from 00 to 59 . 
  * [12-hour format](https://en.wikipedia.org/wiki/12-hour_clock#Description) divides the day into two halves: the first half is \mathrm{AM} , and the second half is \mathrm{PM} . In each half, the hours are numbered in the order 12, 01, 02, 03, \dots, 11 . Each hour has 60 minutes numbered from 00 to 59 . 

Input

The first line contains a single integer t (1 \leq t \leq 1440 ) — the number
of test cases.

The only line of each test case contains a string s of length 5 with format
hh:mm representing a valid time in the 24-hour format. hh represents the hour
from 00 to 23 , and mm represents the minute from 00 to 59 .

The input will always be a valid time in 24-hour format.

Output

For each test case, output two strings separated by a space (""hh:mm AM"" or
""hh:mm PM""), which are the 12-hour equivalent to the time provided in the test
case (without quotes).

You should output the time exactly as indicated; in particular, you should not
remove leading zeroes.

Example

Input

    11
    
    09:41
    
    18:06
    
    12:14
    
    00:59
    
    00:00
    
    14:34
    
    01:01
    
    19:07
    
    11:59
    
    12:00
    
    21:37

Output

    09:41 AM
    06:06 PM
    12:14 PM
    12:59 AM
    12:00 AM
    02:34 PM
    01:01 AM
    07:07 PM
    11:59 AM
    12:00 PM
    09:37 PM","def gb114():
    for t in range(int(input())):
        s = input()
        h = s[:2]
        if h == '00':
            print('12', end='')
        elif int(h) <= 12:
            print(h, end='')
        else:
            print('0{}'.format(int(h) - 12), end='')
        print(s[2:], ['AM', 'PM'][int(h) >= 12])
gb114()",1,False,False,False,False,False,True,False,True,False,True,True,False,False,False,0.7347037984086121,0.24710690842272917,0.5833333333333334
1937_D,1937_D_Dipta_bar_5.26%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There is a one-dimensional grid of length n . The i -th cell of the grid
contains a character s_i , which is either '<' or '>'.

When a pinball is placed on one of the cells, it moves according to the
following rules:

  * If the pinball is on the i -th cell and s_i is '<', the pinball moves one cell to the left in the next second. If s_i is '>', it moves one cell to the right. 
  * After the pinball has moved, the character s_i is inverted (i. e. if s_i used to be '<', it becomes '>', and vice versa). 
  * The pinball stops moving when it leaves the grid: either from the left border or from the right one. 

You need to answer n independent queries. In the i -th query, a pinball will
be placed on the i -th cell. Note that we always place a pinball on the
initial grid.

For each query, calculate how many seconds it takes the pinball to leave the
grid. It can be shown that the pinball will always leave the grid within a
finite number of steps.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^5 ). The description of the test cases follows.

The first line of each test case contains an integer n (1 \le n \le 5 \cdot
10^5 ).

The second line of each test case contains a string s_1s_2 \ldots s_{n} of
length n consisting of characters '<' and '>'.

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^5 .

Output

For each test case, for each i (1 \le i \le n ) output the answer if a pinball
is initially placed on the i -th cell.

Example

Input

    3
    
    3
    
    ><<
    
    4
    
    <<<<
    
    6
    
    <><<<>

Output

    3 6 5 
    1 2 3 4 
    1 4 7 10 8 1 
    
Note

In the first test case, the movement of the pinball for i=1 is shown in the
following pictures. It takes the pinball 3 seconds to leave the grid.

![](https://espresso.codeforces.com/775b656d27e63ce8901e1ef80487972d536b4a54.png)

The movement of the pinball for i=2 is shown in the following pictures. It
takes the pinball 6 seconds to leave the grid.

![](https://espresso.codeforces.com/515bd5576868cf33d4190893928faa21e69dd5c7.png)","t = int(input())
 
 
 
def solve(s):
    n = len(s)
    A = [] 
    idx_A = []
    for i in range(0, n):
        if s[i] == '>':
            if (len(idx_A) == 0):
                A.append(0)
            else:
                x = A[len(A) - 1] + (i - idx_A[len(idx_A) - 1]) * len(idx_A)
                A.append(x)
            idx_A.append(i)
    B = []
    idx_B = []
    for j in range(0, n):
        i = n - 1 - j
        if s[i] == '<':
            if (len(idx_B) == 0):
                B.append(0)
            else:
                x = B[len(B) - 1] + (idx_B[len(B) - 1] - i) * len(idx_B)
                B.append(x)
            idx_B.append(i)
    l = 0
    r = len(B)
 
    for i in range(0, n):
        if (s[i] == '>'):
            if l < r:
                a = A[l]
                x = r - (l + 2)
                b = B[r - 1]
                if x >= 0:
                    b = b - B[x]
                    b = b - (idx_B[x] - idx_B[r - 1]) * (x + 1)
                b = (idx_B[r - 1] - i) * (l + 1)
                print(a * 2 + b * 2 + i + 1, end = "" "")
            else:
                if (r == 0):
                    print(n - i, end = "" "")
                else:
                    a = B[r - 1] + (idx_B[r - 1] - i) * r
                    b = A[l - 1]
                    if l - r > 0:
                        b = b - A[l - r - 1]
                        b = b - (idx_A[l - 1] - idx_A[l - r - 1]) * (l - r)
                    b = b + (i - idx_A[l - 1]) * r
                    print(a * 2 + b * 2 + (n - i), end = "" "")
            l += 1
        else:
            r -= 1
            if (l <= r):
                if (l == 0):
                    print(i + 1, end = "" "")
                else:
                    a = A[l - 1]
                    a = a + (i - idx_A[l - 1]) * l
                    b = B[r]
                    if r - l >= 0:
                        b = b - B[r - l]
                        b = b - (idx_B[r - l] - i) * (r - l)
                    b = b + (idx_B[r] - i) * l
                    print(a * 2 + b * 2 + i + 1, end = "" "")
            else:
                if (r == 0):
                    print((n - i) + (i - idx_A[l - 1]) * 2, end = "" "")
                else:
                    a = B[r]
                    b = A[l - 1]
                    if l - r - 1 > 0:
                        b = b - A[l - r - 2]
                        b = b - (idx_A[l - 1] - idx_A[l - r - 2]) * (l - r - 1)
                    b = b + (i - idx_A[l - 1]) * (r + 1)
                    print(a * 2 + b * 2 + (n - i), end = "" "")
 
 
for i in range(0, t):
    n = int(input())
    s = input()
    solve(s)
    print()",1,False,True,False,False,False,False,False,False,True,True,False,False,True,True,0.9013560687849426,0.6104291437976334,0.75
1937_D,1937_D_Dipta_bar_5.26%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There is a one-dimensional grid of length n . The i -th cell of the grid
contains a character s_i , which is either '<' or '>'.

When a pinball is placed on one of the cells, it moves according to the
following rules:

  * If the pinball is on the i -th cell and s_i is '<', the pinball moves one cell to the left in the next second. If s_i is '>', it moves one cell to the right. 
  * After the pinball has moved, the character s_i is inverted (i. e. if s_i used to be '<', it becomes '>', and vice versa). 
  * The pinball stops moving when it leaves the grid: either from the left border or from the right one. 

You need to answer n independent queries. In the i -th query, a pinball will
be placed on the i -th cell. Note that we always place a pinball on the
initial grid.

For each query, calculate how many seconds it takes the pinball to leave the
grid. It can be shown that the pinball will always leave the grid within a
finite number of steps.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^5 ). The description of the test cases follows.

The first line of each test case contains an integer n (1 \le n \le 5 \cdot
10^5 ).

The second line of each test case contains a string s_1s_2 \ldots s_{n} of
length n consisting of characters '<' and '>'.

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^5 .

Output

For each test case, for each i (1 \le i \le n ) output the answer if a pinball
is initially placed on the i -th cell.

Example

Input

    3
    
    3
    
    ><<
    
    4
    
    <<<<
    
    6
    
    <><<<>

Output

    3 6 5 
    1 2 3 4 
    1 4 7 10 8 1 
    
Note

In the first test case, the movement of the pinball for i=1 is shown in the
following pictures. It takes the pinball 3 seconds to leave the grid.

![](https://espresso.codeforces.com/775b656d27e63ce8901e1ef80487972d536b4a54.png)

The movement of the pinball for i=2 is shown in the following pictures. It
takes the pinball 6 seconds to leave the grid.

![](https://espresso.codeforces.com/515bd5576868cf33d4190893928faa21e69dd5c7.png)","t = int(input())
 
 
 
def solve(s):
    n = len(s)
    A = [] 
    idx_A = []
    for i in range(0, n):
        if s[i] == '>':
            if (len(idx_A) == 0):
                A.append(0)
            else:
                x = A[len(A) - 1] + (i - idx_A[len(idx_A) - 1]) * len(idx_A)
                A.append(x)
            idx_A.append(i)
    B = []
    idx_B = []
    for j in range(0, n):
        i = n - 1 - j
        if s[i] == '<':
            if (len(idx_B) == 0):
                B.append(0)
            else:
                x = B[len(B) - 1] + (idx_B[len(B) - 1] - i) * len(idx_B)
                B.append(x)
            idx_B.append(i)
    l = 0
    r = len(B)
 
    for i in range(0, n):
        if (s[i] == '>'):
            if l < r:
                a = A[l]
                x = r - (l + 2)
                b = B[r - 1]
                if x >= 0:
                    b = b - B[x]
                    b = b - (idx_B[x] - idx_B[r - 1]) * (x + 1)
                b = (idx_B[r - 1] - i) * (l + 1)
                print(a * 2 + b * 2 + i + 1, end = "" "")
            else:
                if (r == 0):
                    print(n - i, end = "" "")
                else:
                    a = B[r - 1] + (idx_B[r - 1] - i) * r
                    b = A[l - 1]
                    if l - r > 0:
                        b = b - A[l - r - 1]
                        b = b - (idx_A[l - 1] - idx_A[l - r - 1]) * (l - r)
                    b = b + (i - idx_A[l - 1]) * r
                    print(a * 2 + b * 2 + (n - i), end = "" "")
            l += 1
        else:
            r -= 1
            if (l <= r):
                if (l == 0):
                    print(i + 1, end = "" "")
                else:
                    a = A[l - 1]
                    a = a + (i - idx_A[l - 1]) * l
                    b = B[r]
                    if r - l >= 0:
                        b = b - B[r - l]
                        b = b - (idx_B[r - l] - i) * (r - l)
                    b = b + (idx_B[r] - i) * l
                    print(a * 2 + b * 2 + i + 1, end = "" "")
            else:
                if (r == 0):
                    print((n - i) + (i - idx_A[l - 1]) * 2, end = "" "")
                else:
                    a = B[r]
                    b = A[l - 1]
                    if l - r - 1 > 0:
                        b = b - A[l - r - 2]
                        b = b - (idx_A[l - 1] - idx_A[l - r - 2]) * (l - r - 1)
                    b = b + (i - idx_A[l - 1]) * (r + 1)
                    print(a * 2 + b * 2 + (n - i), end = "" "")
 
 
for i in range(0, t):
    n = int(input())
    s = input()
    solve(s)
    print()",1,False,False,False,False,False,True,False,True,True,True,True,False,False,False,0.9013560687849426,0.6104291437976334,0.75
1919_A,1919_A_vjudge.9_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Alice and Bob are bored, so they decide to play a game with their wallets.
Alice has a coins in her wallet, while Bob has b coins in his wallet.

Both players take turns playing, with Alice making the first move. In each
turn, the player will perform the following steps in order:

  1. Choose to exchange wallets with their opponent, or to keep their current wallets. 
  2. Remove 1 coin from the player's current wallet. The current wallet cannot have 0 coins before performing this step. 

The player who cannot make a valid move on their turn loses. If both Alice and
Bob play optimally, determine who will win the game.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 1000 ) — the number of test cases. The description of
the test cases follows.

The first and only line of each test case contains two integers a and b (1 \le
a, b \le 10^9 ) — the number of coins in Alice's and Bob's wallets,
respectively.

Output

For each test case, output ""Alice"" if Alice will win the game, and ""Bob"" if
Bob will win the game.

Example

Input

    10
    
    1 1
    
    1 4
    
    5 3
    
    4 5
    
    11 9
    
    83 91
    
    1032 9307
    
    839204 7281
    
    1000000000 1000000000
    
    53110 2024

Output

    Bob
    Alice
    Bob
    Alice
    Bob
    Bob
    Alice
    Alice
    Bob
    Bob
    
Note

In the first test case, an example of the game is shown below:

  * Alice chooses to not swap wallets with Bob in step 1 of her move. Now, a=0 and b=1 . 
  * Since Alice's wallet is empty, Bob must choose to not swap their wallets in step 1 of his move. Now, a=0 and b=0 . 
  * Since both Alice's and Bob's wallets are empty, Alice is unable to make a move. Hence, Bob wins. 

In the second test case, an example of the game is shown below:

  * Alice chooses to swap wallets with Bob in step 1 of her move. Now, a=3 and b=1 . 
  * Bob chooses to swap wallets with Alice in step 1 of his move. Now, a=1 and b=2 . 
  * Alice chooses to not swap wallets with Bob in step 1 of her move. Now, a=0 and b=2 . 
  * Since Alice's wallet is empty, Bob can only choose to not swap wallets with Alice in step 1 of his move. Now, a=0 and b=1 . 
  * Since Alice's wallet is empty, Alice can only choose to swap wallets with Bob in step 1 of her move. Now, a=0 and b=0 . 
  * Since both Alice's wallet and Bob's wallet are empty, Bob is unable to make a move. Hence, Alice wins.","def determine_winner(a, b):
    # If the sum of coins is odd, Alice wins, because she can always force Bob
    # to face an empty wallet scenario first due to having the first move advantage.
    # For an even sum, Bob wins, by following Alice's strategy and ensuring
    # that Alice faces the empty wallet scenario first.
    if (a + b) % 2 == 0:
        return ""Bob""
    else:
        return ""Alice""
 
def main():
    t = int(input(""Enter the number of test cases: ""))  # Read the number of test cases
    
    results = []
    
    for _ in range(t):
        a, b = map(int, input().strip().split())  # Read the number of coins in Alice's and Bob's wallets
        winner = determine_winner(a, b)
        results.append(winner)
    
    for result in results:
        print(result)
 
if __name__ == ""__main__"":
    main()",1,False,False,True,True,True,True,True,True,True,True,True,True,True,True,0.9330968445441384,0.6451700861708208,0.8333333333333334
1937_C,1937_C_Surin_5.88%,codeforces2024,human,qwen2p5-coder-32b-instruct,"This is an interactive problem.

There is a secret sequence p_0, p_1, \ldots, p_{n-1} , which is a permutation
of \\{0,1,\ldots,n-1\\} .

You need to find any two indices i and j such that p_i \oplus p_j is
maximized, where \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

To do this, you can ask queries. Each query has the following form: you pick arbitrary indices a , b , c , and d (0 \le a,b,c,d < n ). Next, the jury calculates x = (p_a \mid p_b) and y = (p_c \mid p_d) , where | denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR). Finally, you receive the result of comparison between x and y . In other words, you are told if x < y , x > y , or x = y .

Please find any two indices i and j (0 \le i,j < n ) such that p_i \oplus p_j
is maximum among all such pairs, using at most 3n queries. If there are
multiple pairs of indices satisfying the condition, you may output any one of
them.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^3 ). The description of the test cases follows.

Interaction

The first line of each test case contains one integer n (2 \le n \le 10^4 ).
At this moment, the permutation p_0, p_1, \ldots, p_{n-1} is chosen. The
interactor in this task is not adaptive. In other words, the sequence p is
fixed in every test case and does not change during the interaction.

To ask a query, you need to pick four indices a , b , c , and d (0 \le a,b,c,d
< n ) and print the line of the following form:

  * ""? a b c d"" 

After that, you receive:

  * ""<"" if (p_a \mid p_b) < (p_c \mid p_d) ; 
  * ""="" if (p_a \mid p_b) = (p_c \mid p_d) ; 
  * "">"" if (p_a \mid p_b) > (p_c \mid p_d) . 

You can make at most 3n queries of this form.

Next, if your program has found a pair of indices i and j (0 \le i, j < n )
such that p_i \oplus p_j is maximized, print the line of the following form:

  * ""! i j"" 

Note that this line is not considered a query and is not taken into account
when counting the number of queries asked.

After this, proceed to the next test case.

If you make more than 3n queries during an interaction, your program must
terminate immediately, and you will receive the Wrong Answer verdict.
Otherwise, you can get an arbitrary verdict because your solution will
continue to read from a closed stream.

After printing a query or the answer for a test case, do not forget to output
the end of line and flush the output. Otherwise, you will get the verdict
Idleness Limit Exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

It is guaranteed that the sum of n over all test cases does not exceed 10^4 .

Hacks

To hack, follow the test format below.

The first line contains the number of test cases t (1 \le t \le 10^3 ). The
description of the test cases follows.

The first line of each test case contains one integer n (2 \le n \le 10^4 ).

The second line of each test case contains n integers p_0,p_1,\ldots,p_{n-1} ,
which represent a permutation of integers from 0 to n - 1 .

The sum of n over all test cases should not exceed 10^4 .

Example

Input

    2
    4
    
    <
    
    =
    
    >
    
    2
    
Output

    ? 0 2 3 1
    
    ? 1 1 2 3
    
    ? 1 2 0 3
    
    ! 3 2
    
    ! 0 1
    
Note

In the first test case, the hidden permutation is p=[0,3,1,2] .

For the query ""? 0 2 3 1"", the jury return ""<"" because (p_0 \mid p_2) = (0
\mid 1) =1 < (p_3 \mid p_1) = (2 \mid 3) = 3 .

For the query ""? 1 1 2 3"", the jury return ""="" because (p_1 \mid p_1) = (3\mid
3)= 3 = (p_2 \mid p_3) = (1 \mid 2)=3 .

For the query ""? 1 2 0 3"", the jury return "">"" because (p_1 \mid p_2) = (3
\mid 1) = 3 > (p_0 \mid p_3) = (0\mid 2)=2 .

The answer i = 3 and j = 2 is valid: (p_3 \oplus p_2) = (2 \oplus 1) = 3 is
indeed equal to the maximum possible value of p_i \oplus p_j . Another valid
answer would be i=0 and j=1 . As the number of queries does not exceed 3n=12 ,
the answer is considered correct.

In the second test case, n = 2 , so p is either [0, 1] or [1, 0] . In any
case, p_0 \oplus p_1 = 1 is maximum possible.","I = lambda : list(map(int, input().split(' ')))
R = lambda : (int(input()))
 
import sys
# import bisect
# from bisect import bisect_left, bisect_right
import math
 
for kp in range(int(input())):
 
    n = int(input())
    # sys.stdout.flush()
    # print()
 
    g = 0
    v1 = 0
    for i in range(1,n):
        # v1 = 0
        v2 = i
        print(f""? {v1} {v1} {v2} {v2}"")
        sys.stdout.flush()
 
        r = input('')
        # print()
 
        if r == ""<"": v1 = v2
 
    prev = 0
    for i in range(1,n):
        print(f""? {v1} {i} {v1} {prev}"")
        sys.stdout.flush()
        r = input()
        if r == '>': prev = i
 
    # print(prev,i)
    print(f""! {prev} {v1}"")
    # print()
    sys.stdout.flush()",1,False,False,False,False,False,True,False,True,False,False,False,False,False,False,0.6380259942529448,0.1368946727398954,0.5833333333333334
1923_C,1923_C_tgfgvfbvd_2.33%,codeforces2024,human,qwen2p5-coder-32b-instruct,"An array a of length m is considered good if there exists an integer array b
of length m such that the following conditions hold:

  1. \sum\limits_{i=1}^{m} a_i = \sum\limits_{i=1}^{m} b_i ; 
  2. a_i \neq b_i for every index i from 1 to m ; 
  3. b_i > 0 for every index i from 1 to m . 

You are given an array c of length n . Each element of this array is greater
than 0 .

You have to answer q queries. During the i -th query, you have to determine
whether the subarray c_{l_{i}}, c_{l_{i}+1}, \dots, c_{r_{i}} is good.

Input

The first line contains one integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains two integers n and q (1 \le n, q \le
3 \cdot 10^5 ) — the length of the array c and the number of queries.

The second line of each test case contains n integers c_1, c_2, \dots, c_n (1
\le c_i \le 10^9 ).

Then q lines follow. The i -th of them contains two integers l_i and r_i (1
\le l_i \le r_i \le n ) — the borders of the i -th subarray.

Additional constraints on the input: the sum of n over all test cases does not
exceed 3 \cdot 10^5 ; the sum of q over all test cases does not exceed 3 \cdot
10^5 .

Output

For each query, print YES if the subarray is good. Otherwise, print NO.

You can output each letter of the answer in any case (upper or lower). For
example, the strings yEs, yes, Yes, and YES will all be recognized as positive
responses.

Example

Input

    1
    
    5 4
    
    1 2 1 4 5
    
    1 5
    
    4 4
    
    3 4
    
    1 3

Output

    YES
    NO
    YES
    NO","for _ in range(int(input())):
    n,m=map(int,input().split())
    l=list(map(int,input().split()))
    p=[]
    c=0
 
    for x in l:
        c+=x
        p.append(c)
 
    for _ in range(m):
        a,b=map(int,input().split())
        s=p[b-1]
        
        if a-2>=0:
            s-=p[a-2]
 
        if b-a+1>1 and s>=2*(b-a+1):
            print('YES')
        else:
            print('NO')",1,False,False,False,True,True,True,True,True,False,False,False,True,True,True,0.8972038752617657,0.49577496835635393,0.8333333333333334
1972_B,1972_B_r1813._0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There are n coins on the table forming a circle, and each coin is either
facing up or facing down. Alice and Bob take turns to play the following game,
and Alice goes first.

In each operation, the player chooses a facing-up coin, removes the coin, and
flips the two coins that are adjacent to it. If (before the operation) there
are only two coins left, then one will be removed and the other won't be
flipped (as it would be flipped twice). If (before the operation) there is
only one coin left, no coins will be flipped. If (before the operation) there
are no facing-up coins, the player loses.

Decide who will win the game if they both play optimally. It can be proved
that the game will end in a finite number of operations, and one of them will
win.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\le t\le 100 ). The description of the test cases follows.

The first line of each test case contains only one positive integer n (1 \leq
n \leq 100 ), representing the number of the coins.

A string s of length n follows on the second line of each test case,
containing only ""U"" and ""D"", representing that each coin is facing up or
facing down.

Output

For each test case, print ""YES"" if Alice will win the game, and ""NO""
otherwise.

You can output the answer in any case (upper or lower). For example, the
strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be recognized as positive
responses.

Example

Input

    3
    
    5
    
    UUDUD
    
    5
    
    UDDUD
    
    2
    
    UU

Output

    YES
    NO
    NO
    
Note

In the first test case, the game may go as follows.

  * Alice chooses the first coin and s becomes ""DDUU"". 
  * Bob chooses the last coin and s becomes ""UDD"". 
  * Alice chooses the first coin and s becomes ""UU"". 
  * Bob chooses the first coin and s becomes ""U"". 
  * Alice chooses the only coin and s becomes empty. 
  * Bob can't choose any coin now, and he loses the game. 

It can be proved that Bob will always lose if they both play optimally.","def solve_coin_game():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    t = int(data[index])
    index += 1
    
    results = []
    
    for _ in range(t):
        n = int(data[index])
        index += 1
        s = data[index]
        index += 1
        
        # Count the number of 'U' (face-up) coins
        num_up_coins = s.count('U')
        
        # Determine the winner based on the parity of the count
        if num_up_coins % 2 == 1:
            results.append(""YES"")
        else:
            results.append(""NO"")
    
    # Print all results
    for result in results:
        print(result)
 
# Uncomment the following line to run the function with standard input
# solve_coin_game()",1,False,True,True,True,True,True,True,True,True,True,True,True,True,True,0.6903501855456995,0.2067854943891225,0.5
1957_C,1957_C_hx199411_2.78%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)","t = int(input())
while t:
    t -= 1
    n,k = list(map(int,input().split(' ')))
    num = 0
    for i in range(k):
        c,r = list(map(int,input().split(' ')))
        if c == r:
            num += 1
        else:
            num += 2
    m = n - num
    if m == 0:
        print(0)
    elif m == 1:
        print(1)
    else:
        dp = [0 for i in range(m+1)]
        dp[1] = 1
        dp[2] = 3
        for i in range(3,m+1):
            dp[i] = (dp[i-1] + (i-1)*dp[i-2]*2)%(10**9+7)
        print(dp[m])",1,False,True,False,True,False,True,False,True,False,True,False,True,True,True,0.7433089548186087,0.3209398334641705,0.5833333333333334
1955_B,1955_B_lol_twister_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"A progressive square of size n is an n \times n matrix. Maxim chooses three
integers a_{1,1} , c , and d and constructs a progressive square according to
the following rules:

For example, if n = 3 , a_{1,1} = 1 , c=2 , and d=3 , then the progressive
square looks as follows:

Last month Maxim constructed a progressive square and remembered the values of
n , c , and d . Recently, he found an array b of n^2 integers in random order
and wants to make sure that these elements are the elements of that specific
square.

It can be shown that for any values of n , a_{1,1} , c , and d , there exists
exactly one progressive square that satisfies all the rules.

Input

The first line contains an integer t (1 \le t \le {10} ^ 4 ) — the number of
test cases.

The first line of each test case contains three integers n , c , and d (2 \le
n \le 500 , 1 \le c, d \le 10^6 ) — the size of the square and the values of c
and d as described in the statement.

The second line of each test case contains n \cdot n integers b_1, b_2, \dots,
b_{n \cdot n} (1 \le b_i \le 10^9 ) — the elements found by Maxim.

It is guaranteed that the sum of n ^ 2 over all test cases does not exceed 25
\cdot {10} ^ 4 .

Output

For each test case, output ""YES"" in a separate line if a progressive square
for the given n , c , and d can be constructed from the array elements a ,
otherwise output ""NO"".

You can output each letter in any case (lowercase or uppercase). For example,
the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be accepted as a positive
answer.

Example

Input

    5
    
    3 2 3
    
    3 9 6 5 7 1 10 4 8
    
    3 2 3
    
    3 9 6 5 7 1 11 4 8
    
    2 100 100
    
    400 300 400 500
    
    3 2 3
    
    3 9 6 6 5 1 11 4 8
    
    4 4 4
    
    15 27 7 19 23 23 11 15 7 3 19 23 11 15 11 15

Output

    NO
    YES
    YES
    NO
    NO","def fn(n,c,d,l):
    a=min(l)
    li=[]
    for k in range(0,n):
        for h in range(0,n):
            li.append(a+k*c+d*h)
    li.sort()
    l.sort()
    if l==li:
        return 'yes'
    return 'no'
    
t=int(input())
for _ in range(t):
    n,c,d=map(int,input().split())
    l=list(map(int,input().split()))
    print(fn(n,c,d,l))",1,True,True,False,True,False,True,True,True,True,False,False,True,True,True,0.9366935917411497,0.6654258279567974,0.8333333333333334
1972_B,1972_B_chri217._0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There are n coins on the table forming a circle, and each coin is either
facing up or facing down. Alice and Bob take turns to play the following game,
and Alice goes first.

In each operation, the player chooses a facing-up coin, removes the coin, and
flips the two coins that are adjacent to it. If (before the operation) there
are only two coins left, then one will be removed and the other won't be
flipped (as it would be flipped twice). If (before the operation) there is
only one coin left, no coins will be flipped. If (before the operation) there
are no facing-up coins, the player loses.

Decide who will win the game if they both play optimally. It can be proved
that the game will end in a finite number of operations, and one of them will
win.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\le t\le 100 ). The description of the test cases follows.

The first line of each test case contains only one positive integer n (1 \leq
n \leq 100 ), representing the number of the coins.

A string s of length n follows on the second line of each test case,
containing only ""U"" and ""D"", representing that each coin is facing up or
facing down.

Output

For each test case, print ""YES"" if Alice will win the game, and ""NO""
otherwise.

You can output the answer in any case (upper or lower). For example, the
strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be recognized as positive
responses.

Example

Input

    3
    
    5
    
    UUDUD
    
    5
    
    UDDUD
    
    2
    
    UU

Output

    YES
    NO
    NO
    
Note

In the first test case, the game may go as follows.

  * Alice chooses the first coin and s becomes ""DDUU"". 
  * Bob chooses the last coin and s becomes ""UDD"". 
  * Alice chooses the first coin and s becomes ""UU"". 
  * Bob chooses the first coin and s becomes ""U"". 
  * Alice chooses the only coin and s becomes empty. 
  * Bob can't choose any coin now, and he loses the game. 

It can be proved that Bob will always lose if they both play optimally.","def determine_winner(s):
    # Count the number of 'U' characters in the string
    num_up = s.count('U')
    
    # Determine the winner based on the parity of the number of 'U' characters
    if num_up % 2 == 1:
        return ""YES""
    else:
        return ""NO""
 
# Read input
import sys
input = sys.stdin.read
data = input().split()
 
# Parse the number of test cases
t = int(data[0])
 
# Iterate over each test case
for _ in range(t):
    # Read the number of coins
    n = int(data[1])
    
    # Read the string representation of the coins
    s = data[2]
    
    # Determine and print the result
    print(determine_winner(s))",1,False,True,True,True,True,True,True,True,True,True,True,True,True,True,0.6039097492430465,0.10523649229049625,0.5
1945_D,1945_D_vjudge.1_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"The guys lined up in a queue of n people, starting with person number i = 1 ,
to ask Serafim the Owl about the meaning of life. Unfortunately, Kirill was
very busy writing the legend for this problem, so he arrived a little later
and stood at the end of the line after the n -th person. Kirill is completely
dissatisfied with this situation, so he decided to bribe some people ahead of
him.

For the i -th person in the queue, Kirill knows two values: a_i and b_i . If
at the moment Kirill is standing at position i , then he can choose any
position j such that j < i and exchange places with the person at position j .
In this case, Kirill will have to pay him a_j coins. And for each k such that
j < k < i , Kirill will have to pay b_k coins to the person at position k .
Kirill can perform this action any number of times.

Kirill is thrifty, so he wants to spend as few coins as possible, but he
doesn't want to wait too long, so Kirill believes he should be among the first
m people in line.

Help Kirill determine the minimum number of coins he will have to spend in
order to not wait too long.

Input

Each test consists of several sets of input data. The first line contains a
single integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows
the description of the test case.

The first line of each test case contains two integers n and m (1 \le m \le n
\le 200\,000 ) — the number of people in the queue besides Kirill and the
maximum allowable final position of Kirill, respectively.

The second line contains n integers a_1, a_2, \dots, a_n separated by spaces
(1 \le a_i \le 10^9 ).

The third line contains n integers b_1, b_2, \dots, b_n separated by spaces (1
\le b_i \le 10^9 ).

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of coins
Kirill needs to spend.

Example

Input

    4
    
    4 2
    
    7 3 6 9
    
    4 3 8 5
    
    6 2
    
    6 9 7 1 8 3
    
    5 8 8 1 4 1
    
    7 7
    
    7 2 9 2 6 5 9
    
    9 1 10 7 1 4 9
    
    2 1
    
    2 3
    
    1 1

Output

    14
    22
    9
    3","def moedasMinimas():
    n, k = map(int, input().split())
    lista_A = list(map(int, input().split()))
    lista_A.reverse()
 
    lista_B = list(map(int, input().split()))
    lista_B.reverse()
 
    soma_b = 0
    pref = 0
 
    for i in range(n - k):
        if lista_A[i] < lista_B[i]:
            pref += soma_b
            pref += lista_A[i]
            soma_b = 0
        else:
            soma_b += lista_B[i]
 
    resultado = float('inf')
    
    for i in range(n - k, n):
        resultado = min(resultado, pref + soma_b + lista_A[i])
        soma_b += lista_B[i]
 
    print(resultado)
 
def main():
    numero_testes = int(input())
    for _ in range(numero_testes):
        moedasMinimas()",1,False,False,False,False,False,True,True,True,False,False,False,False,False,False,0.9714602587066375,0.8462299197047529,0.9166666666666666
1928_C,1928_C_DevK01_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"In a well-known school, a physical education lesson took place. As usual,
everyone was lined up and asked to settle in ""the first–k -th"" position.

As is known, settling in ""the first–k -th"" position occurs as follows: the
first k people have numbers 1, 2, 3, \ldots, k , the next k - 2 people have
numbers k - 1, k - 2, \ldots, 2 , the next k people have numbers 1, 2, 3,
\ldots, k , and so on. Thus, the settling repeats every 2k - 2 positions.
Examples of settling are given in the ""Note"" section.

The boy Vasya constantly forgets everything. For example, he forgot the number
k described above. But he remembers the position he occupied in the line, as
well as the number he received during the settling. Help Vasya understand how
many natural numbers k fit under the given constraints.

Note that the settling exists if and only if k > 1 . In particular, this means
that the settling does not exist for k = 1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 100 ) — the number of test cases. This is followed by
the description of the test cases.

The only line of each test case contains two integers n and x (1 \le x < n \le
10^9 ) — Vasya's position in the line and the number Vasya received during the
settling.

Output

For each test case, output a single integer — the number of different k that
fit under the given constraints.

It can be proven that under the given constraints, the answer is finite.

Example

Input

    5
    
    10 2
    
    3 1
    
    76 4
    
    100 99
    
    1000000000 500000000

Output

    4
    1
    9
    0
    1
    
Note

In the first test case, k equals 2, 3, 5, 6 are suitable.

An example of settling for these k :

k / №| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10   
---|---|---|---|---|---|---|---|---|---|---  
2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2   
3 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 | 2   
5 | 1 | 2 | 3 | 4 | 5 | 4 | 3 | 2 | 1 | 2   
6 | 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 | 3 | 2   
  
In the second test case, k = 2 is suitable.","import math
def factors(q,x):
    M=[]
    w=math.sqrt(q)
    if w==w//1 and w>=x-1:
        M+=[w]
    i=1
    while i<w:
        if q%i==0:
            if i>=x-1:
                M+=[i]
            if (q//i)>=x-1:
                M+=[q//i]
        i+=1
    return M
 
t=int(input())
for _ in range(t):
    L=list(map(int, input().split()))
    n=L[0]
    x=L[1]
    ans=0
    y=(n+x)
    if y%2!=0:
        print(0)
        continue
    else:
        L1=factors((y-2)//2,x)
        if n>=3*x-2:
            L1+=factors((n-x)//2,x)
        L1=list(set(L1))
        print(len(L1))
        continue",1,True,True,False,True,True,True,True,True,False,False,False,True,True,True,0.9802420441794518,0.8804437489253759,0.9166666666666666
1946_A,1946_A_amulya5283_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an array a of n integers.

The median of an array q_1, q_2, \ldots, q_k is the number p_{\lceil
\frac{k}{2} \rceil} , where p is the array q sorted in non-decreasing order.
For example, the median of the array [9, 5, 1, 2, 6] is 5 , as in the sorted
array [1, 2, 5, 6, 9] , the number at index \lceil \frac{5}{2} \rceil = 3 is 5
, and the median of the array [9, 2, 8, 3] is 3 , as in the sorted array [2,
3, 8, 9] , the number at index \lceil \frac{4}{2} \rceil = 2 is 3 .

You are allowed to choose an integer i (1 \le i \le n ) and increase a_i by 1
in one operation.

Your task is to find the minimum number of operations required to increase the
median of the array.

Note that the array a may not necessarily contain distinct numbers.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the array a .

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of operations
required to increase the median of the array.

Example

Input

    8
    
    3
    
    2 2 8
    
    4
    
    7 3 3 1
    
    1
    
    1000000000
    
    5
    
    5 5 5 4 5
    
    6
    
    2 1 2 3 1 4
    
    2
    
    1 2
    
    2
    
    1 1
    
    4
    
    5 5 5 5

Output

    1
    2
    1
    3
    2
    1
    2
    3
    
Note

In the first test case, you can apply one operation to the first number and
obtain the array [3, 2, 8] , the median of this array is 3 , as it is the
number at index \lceil \frac{3}{2} \rceil = 2 in the non-decreasing sorted
array [2, 3, 8] . The median of the original array [2, 2, 8] is 2 , as it is
the number at index \lceil \frac{3}{2} \rceil = 2 in the non-decreasing sorted
array [2, 2, 8] . Thus, the median increased (3 > 2 ) in just one operation.

In the fourth test case, you can apply one operation to each of the numbers at
indices 1, 2, 3 and obtain the array [6, 6, 6, 4, 5] , the median of this
array is 6 , as it is the number at index \lceil \frac{5}{2} \rceil = 3 in the
non-decreasing sorted array [4, 5, 6, 6, 6] . The median of the original array
[5, 5, 5, 4, 5] is 5 , as it is the number at index \lceil \frac{5}{2} \rceil
= 2 in the non-decreasing sorted array [4, 5, 5, 5, 5] . Thus, the median
increased (6 > 5 ) in three operations. It can be shown that this is the
minimum possible number of operations.

In the fifth test case, you can apply one operation to each of the numbers at
indices 1, 3 and obtain the array [3, 1, 3, 3, 1, 4] , the median of this
array is 3 , as it is the number at index \lceil \frac{6}{2} \rceil = 3 in the
non-decreasing sorted array [1, 1, 3, 3, 3, 4] . The median of the original
array [2, 1, 2, 3, 1, 4] is 2 , as it is the number at index \lceil
\frac{6}{2} \rceil = 3 in the non-decreasing sorted array [1, 1, 2, 2, 3, 4] .
Thus, the median increased (3 > 2 ) in two operations. It can be shown that
this is the minimum possible number of operations.","import heapq
 
def icecreamParlor(t, test_cases):
    results = []
    
    for i in range(t):
        n, arr = test_cases[i]
        arr.sort()
        median_index = n // 2
        current_median = arr[median_index]
        
        # Use a min-heap to keep track of elements from median_index to end
        heap = arr[median_index:]
        heapq.heapify(heap)
        
        operations = 0
        while heap[0] <= current_median:
            # Increase the smallest element in the heap
            smallest = heapq.heappop(heap)
            heapq.heappush(heap, smallest + 1)
            operations += 1
            
        results.append(operations)
    
    return results
 
if __name__ == '__main__':
    import sys
    input = sys.stdin.read
    data = input().split()
    
    t = int(data[0])
    index = 1
    test_cases = []
    
    for _ in range(t):
        n = int(data[index])
        arr = list(map(int, data[index + 1: index + 1 + n]))
        test_cases.append((n, arr))
        index += 1 + n
    
    results = icecreamParlor(t, test_cases)
    for result in results:
        print(result)",1,False,False,False,True,False,True,True,True,False,False,False,True,True,True,0.8793041659350627,0.44253042515023466,0.75
1957_C,1957_C_hx199411_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)","t = int(input())
while t:
    t -= 1
    n,k = list(map(int,input().split(' ')))
    num = 0
    for i in range(k):
        c,r = list(map(int,input().split(' ')))
        if c == r:
            num += 1
        else:
            num += 2
    m = n - num
    if m == 0:
        print(1)
    elif m == 1:
        print(1)
    else:
        dp = [0 for i in range(m+1)]
        dp[1] = 1
        dp[2] = 3
        for i in range(3,m+1):
            dp[i] = (dp[i-1] + (i-1)*dp[i-2]*2)%(10**9+7)
        print(dp[m])",1,True,True,False,True,True,True,True,True,False,False,False,True,True,True,0.40849978776192514,-0.09525744994067215,0.5
1968_F,1968_F_NoInternetName_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Let us call an array x_1,\dots,x_m interesting if it is possible to divide the
array into k>1 parts so that [bitwise XOR](http://tiny.cc/xor_wiki_eng) of
values from each part are equal.

More formally, you must split array x into k consecutive segments, each
element of x must belong to exactly 1 segment. Let y_1,\dots,y_k be the XOR of
elements from each part respectively. Then y_1=y_2=\dots=y_k must be
fulfilled.

For example, if x = [1, 1, 2, 3, 0] , you can split it as follows:
[\color{blue}1], [\color{green}1], [\color{red}2, \color{red}3, \color{red}0]
. Indeed \color{blue}1=\color{green}1=\color{red}2 \oplus \color{red}3\oplus
\color{red}0 .

You are given an array a_1,\dots,a_n . Your task is to answer q queries:

  * For fixed l , r , determine whether the subarray a_l,a_{l+1},\dots,a_r is interesting. 

Input

The first line contains a single integer t (1\le t\le 10^4 ) — the number of
test cases.

The first line of each test case contains two integers n and q (2 \le n \le 2
\cdot 10^5 , 1 \le q \le 2 \cdot 10^5 ) — the number of elements in the array
and the number of queries respectively.

The next line contains n integers a_1,\dots,a_n (0 \le a_i < 2^{30} ) —
elements of the array.

Each of the next q lines contains two integers l and r (1 \le l < r \le n )
describing the query.

It is guaranteed that the sum of n over all testcases does not exceed 2 \cdot
10^5 .

It is guaranteed that the sum of q over all testcases does not exceed 2 \cdot
10^5 .

Output

For each query, output ""YES"" if the subarray is interesting and ""NO""
otherwise.

You can output ""Yes"" and ""No"" in any case (for example, the strings ""yES"",
""yes"", and ""Yes"" will be recognized as correct answers).

Example

Input

    4
    
    5 5
    
    1 1 2 3 0
    
    1 5
    
    2 4
    
    3 5
    
    1 3
    
    3 4
    
    5 5
    
    1 2 3 4 5
    
    1 5
    
    2 4
    
    3 5
    
    1 3
    
    2 3
    
    7 4
    
    12 9 10 9 10 11 9
    
    1 5
    
    1 7
    
    2 6
    
    2 7
    
    11 4
    
    0 0 1 0 0 1 0 1 1 0 1
    
    1 2
    
    2 5
    
    6 9
    
    7 11

Output

    YES
    YES
    NO
    NO
    NO
    
    YES
    NO
    NO
    YES
    NO
    
    NO
    NO
    NO
    NO
    
    YES
    NO
    YES
    YES
    
Note

Explanation for the first test case:

The first query is described in the statement.

In the second query, we should divide [1,2,3] . A possible division is
[1,2],[3] , since 1\oplus 2=3 .

It can be shown that for queries 3,4,5 , the subarrays are not interesting.","from collections import defaultdict
 
 
def read(cast):
    return map(cast, input().split())
 
 
def bin_search(arr, predicate):
    l, r = 0, len(arr)
 
    while l + 1 < r:
        mid = (l + r) // 2
        if predicate(arr[mid]):
            l = mid
        else:
            r = mid
 
    if predicate(arr[l]):
        return l
    return None
 
 
def upper_bound(arr, predicate):
    return bin_search(arr, predicate)
 
 
def lower_bound(arr, predicate):
    result = bin_search(arr, predicate)
    if result is not None:
        return result + 1
    return None
 
 
def main():
    n, q = read(int)
 
    a = list(read(int))
    x = [0]
    inds = defaultdict(list)
    inds[0].append(0)
    for i in a:
        x.append(x[-1] ^ i)
        inds[x[-1]].append(len(x) - 1)
 
    for i in range(q):
        l, r = read(int)
 
        if x[l - 1] == x[r]:
            print('Yes')
            continue
 
        lower = inds[x[r]][lower_bound(inds[x[r]], lambda arg: arg < l) or 0]
        upper = inds[x[l - 1]][upper_bound(inds[x[l - 1]], lambda arg: arg <= r)]
 
        if upper > lower:
            print('Yes')
        else:
            print('No')
 
 
if __name__ == '__main__':
    # t = 1
    t, = read(int)
    for _ in range(t):
        main()",1,True,True,False,True,False,True,True,True,True,True,True,True,True,True,0.9137071974363752,0.5100758392676379,0.8333333333333334
1936_A,1936_A_mihir111p_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"This is an interactive problem.

There is a secret sequence p_0, p_1, \ldots, p_{n-1} , which is a permutation
of \\{0,1,\ldots,n-1\\} .

You need to find any two indices i and j such that p_i \oplus p_j is
maximized, where \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

To do this, you can ask queries. Each query has the following form: you pick arbitrary indices a , b , c , and d (0 \le a,b,c,d < n ). Next, the jury calculates x = (p_a \mid p_b) and y = (p_c \mid p_d) , where | denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR). Finally, you receive the result of comparison between x and y . In other words, you are told if x < y , x > y , or x = y .

Please find any two indices i and j (0 \le i,j < n ) such that p_i \oplus p_j
is maximum among all such pairs, using at most 3n queries. If there are
multiple pairs of indices satisfying the condition, you may output any one of
them.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 10^3 ). The description of the test cases follows.

Interaction

The first line of each test case contains one integer n (2 \le n \le 10^4 ).
At this moment, the permutation p_0, p_1, \ldots, p_{n-1} is chosen. The
interactor in this task is not adaptive. In other words, the sequence p is
fixed in every test case and does not change during the interaction.

To ask a query, you need to pick four indices a , b , c , and d (0 \le a,b,c,d
< n ) and print the line of the following form:

  * ""? a b c d"" 

After that, you receive:

  * ""<"" if (p_a \mid p_b) < (p_c \mid p_d) ; 
  * ""="" if (p_a \mid p_b) = (p_c \mid p_d) ; 
  * "">"" if (p_a \mid p_b) > (p_c \mid p_d) . 

You can make at most 3n queries of this form.

Next, if your program has found a pair of indices i and j (0 \le i, j < n )
such that p_i \oplus p_j is maximized, print the line of the following form:

  * ""! i j"" 

Note that this line is not considered a query and is not taken into account
when counting the number of queries asked.

After this, proceed to the next test case.

If you make more than 3n queries during an interaction, your program must
terminate immediately, and you will receive the Wrong Answer verdict.
Otherwise, you can get an arbitrary verdict because your solution will
continue to read from a closed stream.

After printing a query or the answer for a test case, do not forget to output
the end of line and flush the output. Otherwise, you will get the verdict
Idleness Limit Exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

It is guaranteed that the sum of n over all test cases does not exceed 10^4 .

Hacks

To hack, follow the test format below.

The first line contains the number of test cases t (1 \le t \le 10^3 ). The
description of the test cases follows.

The first line of each test case contains one integer n (2 \le n \le 10^4 ).

The second line of each test case contains n integers p_0,p_1,\ldots,p_{n-1} ,
which represent a permutation of integers from 0 to n - 1 .

The sum of n over all test cases should not exceed 10^4 .

Example

Input

    2
    4
    
    <
    
    =
    
    >
    
    2
    
Output

    ? 0 2 3 1
    
    ? 1 1 2 3
    
    ? 1 2 0 3
    
    ! 3 2
    
    ! 0 1
    
Note

In the first test case, the hidden permutation is p=[0,3,1,2] .

For the query ""? 0 2 3 1"", the jury return ""<"" because (p_0 \mid p_2) = (0
\mid 1) =1 < (p_3 \mid p_1) = (2 \mid 3) = 3 .

For the query ""? 1 1 2 3"", the jury return ""="" because (p_1 \mid p_1) = (3\mid
3)= 3 = (p_2 \mid p_3) = (1 \mid 2)=3 .

For the query ""? 1 2 0 3"", the jury return "">"" because (p_1 \mid p_2) = (3
\mid 1) = 3 > (p_0 \mid p_3) = (0\mid 2)=2 .

The answer i = 3 and j = 2 is valid: (p_3 \oplus p_2) = (2 \oplus 1) = 3 is
indeed equal to the maximum possible value of p_i \oplus p_j . Another valid
answer would be i=0 and j=1 . As the number of queries does not exceed 3n=12 ,
the answer is considered correct.

In the second test case, n = 2 , so p is either [0, 1] or [1, 0] . In any
case, p_0 \oplus p_1 = 1 is maximum possible.","def find(a,b,c,d):
    print(""?"",a,b,c,d)
    return input()
    
for _ in range(int(input())):
    n = int(input())
    ans1 = 0
    for i in range(1,n):
        x = find(ans1,ans1,i,i)
        if x == ""<"":
            ans1 = i
    mx = 0
    v = [0]
    # print(ans1)
    for i in range(1,n):
        x = find(mx,ans1,i,ans1)
        if x == ""<"":
            v = []
            mx = i
            v.append(i)
        elif x ==""="":
            v.append(i)
    mx= v[0]
    # print(v)
    ans = v[0]
    for i in range(1,len(v)):
        x = find(ans,ans,v[i],v[i])
        if x == "">"":
            ans = v[i]
    print(""!"", ans,ans1)",1,True,False,False,False,False,False,False,False,False,False,False,True,False,False,0.8819248617484324,0.46449771740090734,0.75
1973_A,1973_A_rcd_25.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Three friends gathered to play a few games of chess together.

In every game, two of them play against each other. The winner gets 2 points
while the loser gets 0 , and in case of a draw, both players get 1 point each.
Note that the same pair of players could have played any non-negative number
of times (possibly zero). It is also possible that no games were played at
all.

You've been told that their scores after all the games were played were p_1 ,
p_2 and p_3 . Additionally, it is guaranteed that p_1 \leq p_2 \leq p_3 holds.

Find the maximum number of draws that could have happened and print it. If
there isn't any way to obtain p_1 , p_2 and p_3 as a result of a non-negative
number of games between the three players, print -1 instead.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of the test cases follows.

The first line of each test case contains three integers p_1 , p_2 and p_3 (0
\leq p_1 \leq p_2 \leq p_3 \leq 30 ) — the scores of the three players, sorted
non-decreasingly.

Output

For each testcase, print one number — the maximum possible number of draws
that could've happened, or -1 if the scores aren't consistent with any valid
set of games and results.

Example

Input

    7
    
    0 0 0
    
    0 1 1
    
    1 1 1
    
    1 1 2
    
    3 3 3
    
    3 4 5
    
    1 1 10

Output

    0
    1
    -1
    2
    -1
    6
    2
    
Note

In the first example, no games were played at all, so no draws could occur
either.

For the second example, exactly one game occurred between the second and the
third player and it ended in draw, so the answer is 1 .

It's easy to see that there's no set of games achieving the scores in third
example, so the answer for it is -1 .","t=int(input())
for _ in range(t):
    p1,p2,p3=map(int,input().split())
    if (p1+p2+p3)%2!=0:
        print(-1)
        continue
    if p3>=p1+p2:
        print(p1+p2)
    else:
        low,high=min(p3-p1,p3-p2),max(p3-p1,p3-p2)
        cur=low
        while high>=cur:
            if p1-cur<=p2-(p3-cur):
                print(p1-cur+p3)
                break
            else:
                cur+=1
        else:
            print(p3)",1,False,True,True,True,False,True,True,True,False,False,True,True,True,False,0.966881726917667,0.7779882590670804,0.9166666666666666
1980_B,1980_B_Flikman_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Dmitry has n cubes, numbered from left to right from 1 to n . The cube with
index f is his favorite.

Dmitry threw all the cubes on the table, and the i -th cube showed the value
a_i (1 \le a_i \le 100 ). After that, he arranged the cubes in non-increasing
order of their values, from largest to smallest. If two cubes show the same
value, they can go in any order.

After sorting, Dmitry removed the first k cubes. Then he became interested in
whether he removed his favorite cube (note that its position could have
changed after sorting).

For example, if n=5 , f=2 , a = [4, \color{green}3, 3, 2, 3] (the favorite
cube is highlighted in green), and k = 2 , the following could have happened:

  * After sorting a=[4, \color{green}3, 3, 3, 2] , since the favorite cube ended up in the second position, it will be removed. 
  * After sorting a=[4, 3, \color{green}3, 3, 2] , since the favorite cube ended up in the third position, it will not be removed. 

Input

The first line contains an integer t (1 \le t \le 1000 ) — the number of test
cases. Then follow the descriptions of the test cases.

The first line of each test case description contains three integers n , f ,
and k (1 \le f, k \le n \le 100 ) — the number of cubes, the index of Dmitry's
favorite cube, and the number of removed cubes, respectively.

The second line of each test case description contains n integers a_i (1 \le
a_i \le 100 ) — the values shown on the cubes.

Output

For each test case, output one line — ""YES"" if the cube will be removed in all
cases, ""NO"" if it will not be removed in any case, ""MAYBE"" if it may be either
removed or left.

You can output the answer in any case. For example, the strings ""YES"", ""nO"",
""mAyBe"" will be accepted as answers.

Example

Input

    12
    
    5 2 2
    
    4 3 3 2 3
    
    5 5 3
    
    4 2 1 3 5
    
    5 5 2
    
    5 2 4 1 3
    
    5 5 5
    
    1 2 5 4 3
    
    5 5 4
    
    3 1 2 4 5
    
    5 5 5
    
    4 3 2 1 5
    
    6 5 3
    
    1 2 3 1 2 3
    
    10 1 1
    
    1 1 1 1 1 1 1 1 1 1
    
    1 1 1
    
    42
    
    5 2 3
    
    2 2 1 1 2
    
    2 1 1
    
    2 1
    
    5 3 1
    
    3 3 2 3 2

Output

    MAYBE
    YES
    NO
    YES
    YES
    YES
    MAYBE
    MAYBE
    YES
    YES
    YES
    NO","t = int(input())
 
for _ in range(t):
    # Чтение входных данных
    n, f, k = map(int, input().split())
    a = list(map(int, input().split()))
 
    # Значение любимого кубика
    favorite_value = a[f - 1]
 
    # Сортируем кубики по невозрастанию значений
    sorted_a = sorted(a, reverse=True)
 
    # Подсчёт индекса любимого кубика в отсортированном массиве
    removed_count = 0
    for i in range(k):
        if sorted_a[i] == favorite_value:
            removed_count += 1
 
    # Подсчитываем количество одинаковых любимому кубику
    favorite_count = sorted_a.count(favorite_value)
 
    # Определяем, удалён ли любимый кубик
    if removed_count == favorite_count:
        print(""YES"")
    elif removed_count == 0:
        print(""NO"")
    else:
        print(""MAYBE"")",1,True,True,False,True,False,True,True,True,False,False,True,True,True,True,0.9124140076172881,0.5888183446554242,0.75
1978_B,1978_B__professor-_50.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Bob decided to open a bakery. On the opening day, he baked n buns that he can
sell. The usual price of a bun is a coins, but to attract customers, Bob
organized the following promotion:

  * Bob chooses some integer k (0 \le k \le \min(n, b) ).
  * Bob sells the first k buns at a modified price. In this case, the price of the i -th (1 \le i \le k ) sold bun is (b - i + 1) coins.
  * The remaining (n - k) buns are sold at a coins each.

Note that k can be equal to 0 . In this case, Bob will sell all the buns at a
coins each.

Help Bob determine the maximum profit he can obtain by selling all n buns.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains three integers n , a , and b (1 \le
n, a, b \le 10^9 ) — the number of buns, the usual price of a bun, and the
price of the first bun to be sold at a modified price.

Output

For each test case, output a single integer — the maximum profit that Bob can
obtain.

Example

Input

    7
    
    4 4 5
    
    5 5 9
    
    10 10 5
    
    5 5 11
    
    1000000000 1000000000 1000000000
    
    1000000000 1000000000 1
    
    1000 1 1000

Output

    17
    35
    100
    45
    1000000000000000000
    1000000000000000000
    500500
    
Note

In the first test case, it is optimal for Bob to choose k = 1 . Then he will
sell one bun for 5 coins, and three buns at the usual price for 4 coins each.
Then the profit will be 5 + 4 + 4 + 4 = 17 coins.

In the second test case, it is optimal for Bob to choose k = 5 . Then he will
sell all the buns at the modified price and obtain a profit of 9 + 8 + 7 + 6 +
5 = 35 coins.

In the third test case, it is optimal for Bob to choose k = 0 . Then he will
sell all the buns at the usual price and obtain a profit of 10 \cdot 10 = 100
coins.","t=int(input())
for _ in range(t):
    n,a,b=map(int,input().split())
    if b<=a:
        print(n*a)
    else:
        if (b-a)>=n:
            print(int((2*b-n+1)*n/2))
        else:
            print(int((b-a)/2*(b-a+1)+a*n))",1,False,False,False,False,False,False,False,False,False,False,False,False,False,False,0.7709564406191117,0.30954473066548477,0.75
1968_B,1968_B_ashikarjen_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given two binary strings a and b . A binary string is a string
consisting of the characters '0' and '1'.

Your task is to determine the maximum possible number k such that a prefix of
string a of length k is a subsequence of string b .

A sequence a is a subsequence of a sequence b if a can be obtained from b by
the deletion of several (possibly, zero or all) elements.

Input

The first line consists of a single integer t (1 \le t \le 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and m (1\le n,m \le 2
\cdot 10^5 ) — the length of string a and the length of string b ,
respectively.

The second line of each test case contains a binary string a of length n .

The third line of each test case contains a binary string b of length m .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 . Similarly, the sum of values m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single number — the maximum k , such that the
first k characters of a form a subsequence of b .

Example

Input

    6
    
    5 4
    
    10011
    
    1110
    
    3 3
    
    100
    
    110
    
    1 3
    
    1
    
    111
    
    4 4
    
    1011
    
    1111
    
    3 5
    
    100
    
    11010
    
    3 1
    
    100
    
    0

Output

    2
    2
    1
    1
    3
    0
    
Note

In the first example, the string '10 ' is a subsequence of
'1\color{red}11\color{red}0 ' but the string '100 ' is not. So the answer is 2
.

In the fifth example, a ='100 ', b ='1\color{red}{10}1\color{red}0 ', whole
string a is a subsequence of string b . So the answer is 3 .

In the sixth example, string b does not contain '1 ' so the answer is 0 .","def solve():
    n, m = map(int, input().split())
    a = input()
    b = input()
    
    k = 0
    j = 0  # Pointer in b
 
    for i in range(n):  # Iterate over a
        while j < m and b[j] != a[i]:
            j += 1
        if j < m:
            k += 1
            j += 1
        else:
            break
    print(k)",1,False,True,True,True,True,True,True,True,True,True,True,True,True,True,0.9764233742776764,0.8750687544812689,0.9166666666666666
1968_A,1968_A_klu_30309_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an integer x . Your task is to find any integer y (1\le y<x)
such that \gcd(x,y)+y is maximum possible.

Note that if there is more than one y which satisfies the statement, you are
allowed to find any.

\gcd(a,b) is the Greatest Common Divisor of a and b . For example, \gcd(6,4)=2
.

Input

The first line contains a single integer t (1 \le t \le 1000 ) — the number of
test cases.

Each of the following t lines contains a single integer x (2 \le x \le 1000 ).

Output

For each test case, output any y (1 \le y < x ), which satisfies the
statement.

Example

Input

    7
    
    10
    
    7
    
    21
    
    100
    
    2
    
    1000
    
    6

Output

    5
    6
    18
    98
    1
    750
    3","def maximize_gcd_plus_y(x):
  """"""Finds the y that maximizes gcd(x, y) + y.
 
  Args:
    x: The given integer.
 
  Returns:
    The optimal y.
  """"""
 
  max_val = 1
  for y in range(x - 1, 1, -1):
    if x % y == 0:
      if 2 * y >= x:
        return y
      max_val = y
  return max_val
 
if __name__ == ""__main__"":
  t = int(input())
 
  for _ in range(t):
    x = int(input())
    y = maximize_gcd_plus_y(x)
    print(y)",1,False,True,False,True,True,True,True,True,False,False,False,False,True,False,0.6907066668782557,0.21258425069513912,0.6666666666666666
1923_C,1923_C_harshkankhar1_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"An array a of length m is considered good if there exists an integer array b
of length m such that the following conditions hold:

  1. \sum\limits_{i=1}^{m} a_i = \sum\limits_{i=1}^{m} b_i ; 
  2. a_i \neq b_i for every index i from 1 to m ; 
  3. b_i > 0 for every index i from 1 to m . 

You are given an array c of length n . Each element of this array is greater
than 0 .

You have to answer q queries. During the i -th query, you have to determine
whether the subarray c_{l_{i}}, c_{l_{i}+1}, \dots, c_{r_{i}} is good.

Input

The first line contains one integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains two integers n and q (1 \le n, q \le
3 \cdot 10^5 ) — the length of the array c and the number of queries.

The second line of each test case contains n integers c_1, c_2, \dots, c_n (1
\le c_i \le 10^9 ).

Then q lines follow. The i -th of them contains two integers l_i and r_i (1
\le l_i \le r_i \le n ) — the borders of the i -th subarray.

Additional constraints on the input: the sum of n over all test cases does not
exceed 3 \cdot 10^5 ; the sum of q over all test cases does not exceed 3 \cdot
10^5 .

Output

For each query, print YES if the subarray is good. Otherwise, print NO.

You can output each letter of the answer in any case (upper or lower). For
example, the strings yEs, yes, Yes, and YES will all be recognized as positive
responses.

Example

Input

    1
    
    5 4
    
    1 2 1 4 5
    
    1 5
    
    4 4
    
    3 4
    
    1 3

Output

    YES
    NO
    YES
    NO","from itertools import accumulate
def solve():
    n,q=map(int,input().split())
    a=[0]+[int(x) for x in input().split()]
    b=[0]*(n+1)
    for i in range(1,n+1):
        x = 1 if a[i]>1 else 2
        b[i]=b[i-1] + x
    a=list(accumulate(a))
 
    for _ in range(q):
        x,y=map(int,input().split())
        print(""NO"") if a[y]-a[x-1]<b[y]-b[x-1] or x==y else print(""YES"") 
   
   
 
for _ in range(int(input())):
    solve()",1,True,False,False,False,False,False,False,False,False,False,False,False,False,False,0.6082707322568786,0.10784409477044866,0.5
1931_B,1931_B_Lentreo_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"There are n containers of water lined up, numbered from left to right from 1
to n . Each container can hold any amount of water; initially, the i -th
container contains a_i units of water. The sum of a_i is divisible by n .

You can apply the following operation any (possibly zero) number of times:
pour any amount of water from the i -th container to the j -th container,
where i must be less than j (i.e. i<j ). Any index can be chosen as i or j any
number of times.

Determine whether it is possible to make the amount of water in all containers
the same using this operation.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of containers with water.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (0
\le a_i \le 10^9 ) — the amounts of water in the containers. It is guaranteed
that the sum of a_i in each test case does not exceed 2 \cdot 10^9 . Also, the
sum of a_i is divisible by n .

It is guaranteed that the sum of n over all test cases in the input does not
exceed 2 \cdot 10^5 .

Output

Output t lines, each of which is the answer to the corresponding test case. As
the answer, output ""YES"" if it is possible to make the amount of water in all
containers the same using the described operation. Otherwise, output ""NO"".

You can output each letter in any case (lowercase or uppercase). For example,
the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be accepted as a positive
answer.

Example

Input

    6
    
    1
    
    43
    
    2
    
    1 3
    
    5
    
    4 5 2 1 3
    
    3
    
    1 2 3
    
    7
    
    4 5 5 0 6 4 4
    
    7
    
    6 5 5 1 3 4 4

Output

    YES
    NO
    YES
    NO
    NO
    YES
    
Note

In the third test case of the example (a=[4, 5, 2, 1, 3] ), you can proceed as
follows:

  * pour 1 unit of water from the first vessel to the fourth, then a=[3, 5, 2, 2, 3] ; 
  * pour 1 unit of water from the second vessel to the third, then a=[3, 4, 3, 2, 3] ; 
  * pour 1 unit of water from the second vessel to the fourth, then a=[3, 3, 3, 3, 3] .","def test_case(nums):
    n = len(nums)
 
    total = sum(nums)
    if total % n != 0:
        return ""NO""
 
    mean = total // n
    curr = 0
 
    for i in range(n):
        curr += nums[i] - mean
 
        if curr < 0:
            return ""NO""
    return ""YES""
 
 
t = int(input())
 
for _ in range(t):
    n = int(input())
    nums = list(map(int, input().strip().split()))
 
    print(test_case(nums))",1,True,True,False,True,True,False,False,True,False,True,True,True,True,True,0.8049481012044726,0.32051328001124507,0.6666666666666666
1931_A,1931_A_Outlastqr_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Nikita had a word consisting of exactly 3 lowercase Latin letters. The letters
in the Latin alphabet are numbered from 1 to 26 , where the letter ""a"" has the
index 1 , and the letter ""z"" has the index 26 .

He encoded this word as the sum of the positions of all the characters in the
alphabet. For example, the word ""cat"" he would encode as the integer 3 + 1 +
20 = 24 , because the letter ""c"" has the index 3 in the alphabet, the letter
""a"" has the index 1 , and the letter ""t"" has the index 20 .

However, this encoding turned out to be ambiguous! For example, when encoding
the word ""ava"", the integer 1 + 22 + 1 = 24 is also obtained.

Determine the lexicographically smallest word of 3 letters that could have
been encoded.

A string a is lexicographically smaller than a string b if and only if one of
the following holds:

  * a is a prefix of b , but a \ne b ;
  * in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b .

Input

The first line of the input contains a single integer t (1 \le t \le 100 ) —
the number of test cases in the test.

This is followed by the descriptions of the test cases.

The first and only line of each test case contains an integer n (3 \le n \le
78 ) — the encoded word.

Output

For each test case, output the lexicographically smallest three-letter word
that could have been encoded on a separate line.

Example

Input

    5
    
    24
    
    70
    
    3
    
    55
    
    48

Output

    aav
    rzz
    aaa
    czz
    auz","import string
 
alphabet = string.ascii_lowercase
 
for i in range(int(input())):
    n = int(input())
    word = """"
    if n > 52:
        word += alphabet[n - 53] + ""zz""
    elif n > 27:
        word += ""a"" + alphabet[n - 28] + ""z""
    elif n == 27:
        word = ""aay""
    else:
        word += ""aa"" + alphabet[n - 3]
    print(word)",1,True,False,True,True,False,True,True,True,False,False,False,False,False,True,0.9755738041762556,0.767488312627103,0.9166666666666666
1929_B,1929_B_avaniagr_0.00%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Even in kindergarten, Sasha liked a girl. Therefore, he wanted to give her a
drawing and attract her attention.

As a drawing, he decided to draw a square grid of size n \times n , in which
some cells are colored. But coloring the cells is difficult, so he wants to
color as few cells as possible. But at the same time, he wants at least k
diagonals to have at least one colored cell. Note that the square grid of size
n \times n has a total of 4n - 2 diagonals.

Help little Sasha to make the girl fall in love with him and tell him the
minimum number of cells he needs to color.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 1000 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains two integers n and k (2 \leq n \leq
10^8 , 1 \leq k \leq 4n - 2 ) — the size of the square grid and the minimum
number of diagonals in which there should be at least one colored cell.

Output

For each test case, output a single integer — the minimum number of cells that
need to be colored.

Example

Input

    7
    
    3 4
    
    3 3
    
    3 10
    
    3 9
    
    4 7
    
    7 11
    
    2 3

Output

    2
    2
    6
    5
    4
    6
    2
    
Note

In the pictures below, the colored cells are marked in black, and all
diagonals are marked in purple.

In the first test case, you can color 2 cells so that 4 diagonals contain at
least one colored cell:

![](https://espresso.codeforces.com/c88e80de5be4f91764dbe5bdc534c50fec115db3.png)

In the third test case, you can color 6 cells so that all 10 diagonals contain
at least one colored cell:

![](https://espresso.codeforces.com/624a36083689f6fb20bf243e5d1707fdcd71ef60.png)","for s in [*open(0)][1:]:
    n,k=map(int,s.split())
    print((k//2 + k%2)*(k<(4*n-3)) + (2*n)*(k>=(4*n-3)) + (k==(4*n-2)))",1,False,False,False,True,False,True,False,False,False,False,False,True,True,False,0.8832500100152313,0.4492905240382878,0.75
1968_C,1968_C_tah23seen_6.67%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given an array x_2,x_3,\dots,x_n . Your task is to find any array
a_1,\dots,a_n , where:

  * 1\le a_i\le 10^9 for all 1\le i\le n . 
  * x_i=a_i \bmod a_{i-1} for all 2\le i\le n . 

Here c\bmod d denotes the remainder of the division of the integer c by the
integer d . For example 5 \bmod 2 = 1 , 72 \bmod 3 = 0 , 143 \bmod 14 = 3 .

Note that if there is more than one a which satisfies the statement, you are
allowed to find any.

Input

The first line contains a single integer t (1\le t\le 10^4) — the number of
test cases.

The first line of each test case contains a single integer n (2\le n\le 500) —
the number of elements in a .

The second line of each test case contains n-1 integers x_2,\dots,x_n (1\le
x_i\le 500) — the elements of x .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 .

Output

For each test case output any a_1,\dots,a_n (1 \le a_i \le 10^9 ) which
satisfies the statement.

Example

Input

    5
    
    4
    
    2 4 1
    
    3
    
    1 1
    
    6
    
    4 2 5 1 2
    
    2
    
    500
    
    3
    
    1 5

Output

    3 5 4 9
    2 5 11
    5 14 16 5 11 24
    501 500
    2 7 5

Note

In the first test case a=[3,5,4,9] satisfies the conditions, because:

  * a_2\bmod a_1=5\bmod 3=2=x_2 ; 
  * a_3\bmod a_2=4\bmod 5=4=x_3 ; 
  * a_4\bmod a_3=9\bmod 4=1=x_4 ;","def solve(arr,n):
  ans=[0]*(n)
  ans[0]=arr[0]+1
  for i in range(n-2):
    ans[i+1]=arr[i]+ans[i]
    if ans[i+1]<arr[i+1]:
      while ans[i+1]<=arr[i+1]:
        ans[i+1]+=ans[i]
  ans[-1]=ans[-2]+arr[-1]
  return ans
 
t=int(input())
while t:
  n=int(input())
  arr=[int(x) for x in input().split("" "")]
  ans=solve(arr,n)
  for i in ans:
    print(i,end=' ')
  print()
  t-=1",1,False,True,False,False,False,True,False,True,False,False,True,False,False,False,0.7740908088003147,0.31561793909854163,0.6666666666666666
1945_A,1945_A_josie.elliston_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"The organizing committee plans to take the participants of the Olympiad on a
hike after the tour. Currently, the number of tents needed to be taken is
being calculated. It is known that each tent can accommodate up to 3 people.

Among the participants, there are a introverts, b extroverts, and c
universals:

  * Each introvert wants to live in a tent alone. Thus, a tent with an introvert must contain exactly one person — only the introvert himself. 
  * Each extrovert wants to live in a tent with two others. Thus, the tent with an extrovert must contain exactly three people. 
  * Each universal is fine with any option (living alone, with one other person, or with two others). 

The organizing committee respects the wishes of each participant very much, so
they want to fulfill all of them.

Tell us the minimum number of tents needed to be taken so that all
participants can be accommodated according to their preferences. If it is
impossible to accommodate the participants in a way that fulfills all the
wishes, output -1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
the descriptions of the test cases.

Each test case is described by a single line containing three integers a , b ,
c (0 \le a, b, c \le 10^9 ) — the number of introverts, extroverts, and
universals, respectively.

Output

For each test case, output a single integer — the minimum number of tents, or
-1 if it is impossible to accommodate the participants.

Example

Input

    10
    
    1 2 3
    
    1 4 1
    
    1 4 2
    
    1 1 1
    
    1 3 2
    
    19 7 18
    
    0 0 0
    
    7 0 0
    
    0 24 0
    
    1000000000 1000000000 1000000000

Output

    3
    -1
    3
    -1
    3
    28
    0
    7
    8
    1666666667
    
Note

In the first test case, 1 tent will be given to the introverts, 1 tent will be
shared by two extroverts and one universal, and the last tent will be shared
by two universals. In total, 3 tents are needed.

In the second test case, three extroverts will take 1 tent, and 1 tent will be
taken by an introvert. Then, one extrovert and one universal will be left.
This extrovert will not be able to live with two others.","from math import ceil
from typing import Optional
 
 
# Each introvert wants to live in a tent alone. Thus, a tent with an introvert must contain exactly one person — only the introvert himself.
# Each extrovert wants to live in a tent with two others. Thus, the tent with an extrovert must contain exactly three people.
# Each universal is fine with any option(living alone, with one other person, or with two others).
 
 
def f(extroverts: int, universals: int) -> Optional[int]:
    if extroverts % 3 != 0:
        if extroverts % 3 + universals < 3:
            return None
    return ceil((extroverts + universals) / 3)
 
 
def g(introverts: int, extroverts: int, universals: int) -> int:
    ret = f(extroverts, universals)
    return -1 if ret is None else introverts+ret
 
test_case_n = int(input())
for _ in range(test_case_n):
    (introverts, extroverts, universals) = map(int, input().split(' '))
    # return min area
    print(g(introverts, extroverts, universals))
 
 
# for line in '''1 2 3
# 1 4 1
# 1 4 2
# 1 1 1
# 1 3 2
# 19 7 18
# 0 0 0
# 7 0 0
# 0 24 0
# 1000000000 1000000000 1000000000'''.splitlines():
#     (introverts, extroverts, universals) = map(int, line.split(' '))
#     print('line:', line)
#     print('ret:', g(introverts, extroverts, universals))",1,True,True,False,True,True,True,True,True,True,True,True,False,False,False,0.8786389892330472,0.5522690850328354,0.6666666666666666
1955_C,1955_C_joker_Pham_3.33%,codeforces2024,human,qwen2p5-coder-32b-instruct,"n ships set out to explore the depths of the ocean. The ships are numbered
from 1 to n and follow each other in ascending order; the i -th ship has a
durability of a_i .

The Kraken attacked the ships k times in a specific order. First, it attacks
the first of the ships, then the last, then the first again, and so on.

Each attack by the Kraken reduces the durability of the ship by 1 . When the
durability of the ship drops to 0 , it sinks and is no longer subjected to
attacks (thus the ship ceases to be the first or last, and the Kraken only
attacks the ships that have not yet sunk). If all the ships have sunk, the
Kraken has nothing to attack and it swims away.

For example, if n=4 , k=5 , and a=[1, 2, 4, 3] , the following will happen:

  1. The Kraken attacks the first ship, its durability becomes zero and now a = [2, 4, 3] ; 
  2. The Kraken attacks the last ship, now a = [2, 4, 2] ; 
  3. The Kraken attacks the first ship, now a = [1, 4, 2] ; 
  4. The Kraken attacks the last ship, now a = [1, 4, 1] ; 
  5. The Kraken attacks the first ship, its durability becomes zero and now a = [4, 1] . 

How many ships were sunk after the Kraken's attack?

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains two integers n and k (1 \le n \le 2
\cdot 10^5 , 1 \le k \le 10^{15} ) — the number of ships and how many times
the Kraken will attack the ships.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (1
\le a_i \le 10^9 ) — the durability of the ships.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output the number of ships sunk by the Kraken on a
separate line.

Example

Input

    6
    
    4 5
    
    1 2 4 3
    
    4 6
    
    1 2 4 3
    
    5 20
    
    2 7 1 8 2
    
    2 2
    
    3 2
    
    2 15
    
    1 5
    
    2 7
    
    5 2

Output

    2
    3
    5
    0
    2
    2","def solve(n, k, a):
    l, r = 0, n - 1
    sunks = 0
    while l <= r:
        if k == 0:
            break
        if l == r:
            if k >= a[r]:
                sunks += 1
                break
            break
            
        if a[l] <= a[r]:
            if k >= a[l] * 2:
                k -= a[l] * 2
                a[r] -= a[l]
                if a[r] == 0:
                    sunks += 1
                    r -= 1
                sunks += 1
                l += 1
                continue
            else:
                if a[l] * 2 - 1 == k:
                    sunks += 1
                    break
                else:
                    break
                
        if k == 0:
            break
                
        if a[r] < a[l]:
            if k >= a[r] * 2:
                k -= a[r] * 2
                a[l] -= a[r]
                if a[l] == 0:
                    sunks += 1
                    l += 1
                sunks += 1
                r -= 1
                continue
            else:
                if a[r] * 2 - 1 == k:
                    sunks += 1
                    break
                else:
                    break
            
        
    return sunks
    
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())
    a = map(int, input().split())
    print(solve(n, k, list(a)))",1,False,False,False,False,False,True,False,False,False,True,False,False,False,False,0.9649303116363888,0.7703503976121363,0.9166666666666666
1930_B,1930_B_bigdamdam_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"You are given a positive integer n .

Find a permutation^\dagger p of length n such that there do not exist two
distinct indices i and j (1 \leq i, j < n ; i \neq j ) such that p_i divides
p_j and p_{i+1} divides p_{j+1} .

Refer to the Notes section for some examples.

Under the constraints of this problem, it can be proven that at least one p
exists.

^\dagger A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (3 \leq n \leq
10^5 ) — the length of the permutation p .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output p_1, p_2, \ldots, p_n .

If there are multiple solutions, you may output any one of them.

Example

Input

    2
    
    4
    
    3

Output

    4 1 2 3
    1 2 3
    
Note

In the first test case, p=[4,1,2,3] is a valid permutation. However, the
permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and
j=3 . Then p_1=1 divides p_3=3 and p_2=2 divides p_4=4 . Note that the
permutation p=[3, 4, 2, 1] is also not a valid permutation as we can choose
i=3 and j=2 . Then p_3=2 divides p_2=4 and p_4=1 divides p_3=2 .

In the second test case, p=[1,2,3] is a valid permutation. In fact, all 6
permutations of length 3 are valid.","for i in range(int(input())):
      n = [int(i)for i in input().split()][0]
      p = [0]*n;ind = n
      for i in range(0,n,2):p[i]=ind;ind -= 2
      ind = 1 + n%2
      for i in range(1,n,2):p[i]=ind;ind += 2
      print(*p)",1,True,True,True,True,True,True,True,True,True,True,True,True,True,True,0.722070980084832,0.23786776414090813,0.5833333333333334
1919_A,1919_A_vjudge.7_100%,codeforces2024,human,qwen2p5-coder-32b-instruct,"Alice and Bob are bored, so they decide to play a game with their wallets.
Alice has a coins in her wallet, while Bob has b coins in his wallet.

Both players take turns playing, with Alice making the first move. In each
turn, the player will perform the following steps in order:

  1. Choose to exchange wallets with their opponent, or to keep their current wallets. 
  2. Remove 1 coin from the player's current wallet. The current wallet cannot have 0 coins before performing this step. 

The player who cannot make a valid move on their turn loses. If both Alice and
Bob play optimally, determine who will win the game.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 1000 ) — the number of test cases. The description of
the test cases follows.

The first and only line of each test case contains two integers a and b (1 \le
a, b \le 10^9 ) — the number of coins in Alice's and Bob's wallets,
respectively.

Output

For each test case, output ""Alice"" if Alice will win the game, and ""Bob"" if
Bob will win the game.

Example

Input

    10
    
    1 1
    
    1 4
    
    5 3
    
    4 5
    
    11 9
    
    83 91
    
    1032 9307
    
    839204 7281
    
    1000000000 1000000000
    
    53110 2024

Output

    Bob
    Alice
    Bob
    Alice
    Bob
    Bob
    Alice
    Alice
    Bob
    Bob
    
Note

In the first test case, an example of the game is shown below:

  * Alice chooses to not swap wallets with Bob in step 1 of her move. Now, a=0 and b=1 . 
  * Since Alice's wallet is empty, Bob must choose to not swap their wallets in step 1 of his move. Now, a=0 and b=0 . 
  * Since both Alice's and Bob's wallets are empty, Alice is unable to make a move. Hence, Bob wins. 

In the second test case, an example of the game is shown below:

  * Alice chooses to swap wallets with Bob in step 1 of her move. Now, a=3 and b=1 . 
  * Bob chooses to swap wallets with Alice in step 1 of his move. Now, a=1 and b=2 . 
  * Alice chooses to not swap wallets with Bob in step 1 of her move. Now, a=0 and b=2 . 
  * Since Alice's wallet is empty, Bob can only choose to not swap wallets with Alice in step 1 of his move. Now, a=0 and b=1 . 
  * Since Alice's wallet is empty, Alice can only choose to swap wallets with Bob in step 1 of her move. Now, a=0 and b=0 . 
  * Since both Alice's wallet and Bob's wallet are empty, Bob is unable to make a move. Hence, Alice wins.","test = int(input())
for t in range(test):
    a,b=map(int,input().split())
    if (a+b)&1==0:
        print(""Bob"")
    else:
        print(""Alice"")",1,True,False,True,True,True,True,True,True,True,True,True,True,True,True,0.8480091814352945,0.456940958143876,0.75
