### Reasoning:

To determine the correctness of the given program, we need to verify whether the logic implemented in `func_1` correctly calculates the minimum total cost to sort a binary string in non-descending order using the described cyclic shift operation.

The key observation is that the cost to sort the string is determined by the number of '1's that precede each '0'. Each '0' encountered after a sequence of '1's incurs a cost equal to the number of preceding '1's plus one. This is because each '0' needs to be shifted past all the preceding '1's, and the cost of shifting a substring of length `r - l + 1` is `r - l + 1`.

Let's break down the logic of `func_1`:

1. **Initialization**: 
   - `cost` is initialized to 0. This variable will accumulate the total cost.
   - `one` is initialized to 0. This variable keeps track of the number of '1's encountered so far.

2. **Iteration through the string**:
   - For each character `i` in the string `s`:
     - If `i` is '1', increment the `one` counter.
     - If `i` is '0' and `one` is greater than 0, it means there are '1's preceding this '0'. The cost to move this '0' past all preceding '1's is `one + 1` (the length of the substring that includes this '0' and all preceding '1's). This cost is added to `cost`, and `one` remains unchanged because the '0' is now effectively moved past the '1's.

3. **Return the accumulated cost**:
   - After iterating through the string, the function returns the accumulated `cost`.

The logic correctly captures the cost associated with each '0' that needs to be moved past preceding '1's, and the provided example cases seem to align with this explanation.

### Conclusion:

The program correctly implements the logic to calculate the minimum total cost to sort a binary string in non-descending order using the described cyclic shift operation.

**Correctness: True**