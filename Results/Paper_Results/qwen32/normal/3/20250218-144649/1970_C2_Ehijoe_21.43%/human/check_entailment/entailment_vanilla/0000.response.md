### Reasoning:

1. **Understanding the Game Mechanics:**
   - The game is played on a tree with `n` nodes.
   - A stone starts on a given node, and players take turns moving the stone to an adjacent, inactive node.
   - The player who cannot make a move loses.

2. **Optimal Play:**
   - Both players play optimally, meaning they will always make the best move available to them.
   - The key to determining the winner is the number of moves available from the starting node.

3. **Distance Calculation:**
   - The function `func_1` calculates the distances from the starting node to all other nodes in the tree.
   - It does this recursively, checking each node's neighbors and calculating the distance to each leaf node.

4. **Winning Strategy:**
   - If there is at least one path from the starting node that has an odd number of moves (i.e., an odd number of edges), Ron will win because he will be the one to make the final move.
   - If all paths from the starting node have an even number of moves, Hermione will win because Ron will be the one who cannot make a move.

5. **Implementation Details:**
   - The program reads the input for the number of nodes and edges and constructs the tree using an adjacency list.
   - It then identifies all leaf nodes (nodes with only one connection) and starts the distance calculation from the given starting node.
   - Finally, it checks if any of the calculated distances are odd. If so, it prints "Ron"; otherwise, it prints "Hermione".

6. **Edge Cases:**
   - The program handles the case where the starting node is a leaf node correctly, as the distance to itself is 0 (even).
   - It also handles larger trees efficiently using recursion and adjacency lists.

### Conclusion:
The program correctly implements the logic to determine the winner based on the number of moves available from the starting node. It handles both the construction of the tree and the calculation of distances accurately.

**Correctness: True**