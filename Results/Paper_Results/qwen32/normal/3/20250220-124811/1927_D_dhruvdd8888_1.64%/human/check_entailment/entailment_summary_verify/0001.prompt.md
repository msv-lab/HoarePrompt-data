
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
You are given an array a of n integers, and q queries.

Each query is represented by two integers l and r (1 \le l \le r \le n ). Your
task is to find, for each query, two indices i and j (or determine that they
do not exist) such that:

  * l \le i \le r ; 
  * l \le j \le r ; 
  * a_i \ne a_j . 

In other words, for each query, you need to find a pair of different elements
among a_l, a_{l+1}, \dots, a_r , or report that such a pair does not exist.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The descriptions of the test cases follow.

The first line of each test case contains a single integer n (2 \le n \le 2
\cdot 10^5 ) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \dots, a_n (1
\le a_i \le 10^6 ) — the elements of the array a .

The third line of each test case contains a single integer q (1 \le q \le 2
\cdot 10^5 ) — the number of queries.

The next q lines contain two integers each, l and r (1 \le l < r \le n ) — the
boundaries of the query.

It is guaranteed that the sum of the values of n across all test cases does
not exceed 2 \cdot 10^5 . Similarly, it is guaranteed that the sum of the
values of q across all test cases does not exceed 2 \cdot 10^5 .

Output

For each query, output two integers separated by space: i and j (l \le i, j
\le r ), for which a_i \ne a_j . If such a pair does not exist, output i=-1
and j=-1 .

You may separate the outputs for the test cases with empty lines. This is not
a mandatory requirement.

Example

Input

    5
    
    5
    
    1 1 2 1 1
    
    3
    
    1 5
    
    1 2
    
    1 3
    
    6
    
    30 20 20 10 10 20
    
    5
    
    1 2
    
    2 3
    
    2 4
    
    2 6
    
    3 5
    
    4
    
    5 2 3 4
    
    4
    
    1 2
    
    1 4
    
    2 3
    
    2 4
    
    5
    
    1 4 3 2 4
    
    5
    
    1 5
    
    2 4
    
    3 4
    
    3 5
    
    4 5
    
    5
    
    2 3 1 4 2
    
    7
    
    1 2
    
    1 4
    
    1 5
    
    2 4
    
    2 5
    
    3 5
    
    4 5

Output

    2 3
    -1 -1
    1 3
    
    2 1
    -1 -1
    4 2
    4 6
    5 3
    
    1 2
    1 2
    2 3
    3 2
    
    1 3
    2 4
    3 4
    5 3
    5 4
    
    1 2
    4 2
    1 3
    2 3
    3 2
    5 4
    5 4

- Program:
from collections import *
from math import log,log2,pow,gcd,ceil,floor
from heapq import *
import sys
from bisect import *

tc = int(input())
for ppp in range(tc):
    func_1()

def func_1():
    input = sys.stdin.readline
    N = int(input())
    nums = list(map(int, input().split()))
    s = 0
    e = 0
    num = nums[0]
    arr = []
    nums.append(-1)
    for i in range(N + 1):
        if nums[i] != num:
            arr.append((1 + s, i, num))
            s = i
        num = nums[i]
    LA = len(arr) - 1
    if ppp == 23:
        print(nums)
    for _ in range(int(input())):
        (l, r) = tuple(map(int, input().split()))
        if tc > 5:
            if ppp == 23:
                print(l, r)
            continue
        eli = bisect_left(arr, (l, 0, 0))
        (s, e, _) = arr[min(eli, LA)]
        if s > l:
            if s == 1:
                print(-1, -1)
            else:
                print(s - 1, s)
        elif e >= r:
            print(-1, -1)
        elif e < N:
            print(s, e + 1)
        else:
            print(-1, -1)



- Function Summary: 
The function processes multiple test cases, where each test case consists of an array of integers and a set of queries. For each query, it determines and prints a pair of indices representing a subarray that meets specific conditions related to the queried range. The function does not return a value explicitly; instead, it outputs results directly.

Beggining of Original Assessment: 
Let's analyze the provided program and see if it correctly solves the problem as described.

### Problem Analysis

The problem requires us to find two different indices within a given range `[l, r]` such that the elements at these indices are not equal. If no such pair exists, we should return `-1 -1`.

### Program Analysis

1. **Input Reading**: The program reads the number of test cases `t` and then processes each test case separately. For each test case, it reads the length of the array `n`, the array itself, the number of queries `q`, and then the queries themselves.

2. **Preprocessing**: The program processes the array to create a list of segments where each segment contains a contiguous block of the same number. This is done using a loop that iterates through the array and records the start and end indices of each segment along with the value of the segment.

3. **Query Processing**: For each query, the program uses binary search (`bisect_left`) to find the segment that starts at or just after the left boundary `l` of the query. It then checks the segment to see if it can find a valid pair of indices within the range `[l, r]`.

4. **Output**: The program prints the indices of the valid pair or `-1 -1` if no such pair exists.

### Issues in the Program

1. **Incorrect Query Handling**: The program uses `bisect_left` to find the segment starting at or just after `l`, but it does not correctly handle the case where the segment found does not cover the entire range `[l, r]`. Specifically, it does not check if the segment found contains more than one distinct element or if the segment ends before `r`.

2. **Incorrect Logic for Finding Indices**: The logic for finding indices within the segment is flawed. For example, it checks if the start of the segment is greater than `l` and then assumes that `s-1` and `s` are valid indices. However, this does not guarantee that `a[s-1] != a[s]` or that both indices are within the range `[l, r]`.

3. **Inconsistent Logic for Different Test Cases**: The program includes conditional logic that seems to be for debugging or testing purposes (e.g., `if ppp == 23:`), which does not affect the correctness of the solution but suggests that the program may not be fully tested or optimized.

### Correctness

Given the issues identified, the program does not correctly handle all cases and may produce incorrect results for some queries.

### Conclusion

Correctness: **False**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

