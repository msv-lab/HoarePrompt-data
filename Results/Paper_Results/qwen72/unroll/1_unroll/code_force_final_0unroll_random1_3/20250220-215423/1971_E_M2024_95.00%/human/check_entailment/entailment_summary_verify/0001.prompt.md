
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Timur is in a car traveling on the number line from point 0 to point n . The
car starts moving from point 0 at minute 0 .

There are k+1 signs on the line at points 0, a_1, a_2, \dots, a_k , and Timur
knows that the car will arrive there at minutes 0, b_1, b_2, \dots, b_k ,
respectively. The sequences a and b are strictly increasing with a_k = n .

![](https://espresso.codeforces.com/eaf3bfb8e7a8fa4f5e8673f9a02116761cb86c93.png)

Between any two adjacent signs, the car travels with a constant speed. Timur
has q queries: each query will be an integer d , and Timur wants you to output
how many minutes it takes the car to reach point d , rounded down to the
nearest integer.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains three integers n , k , and q , (k
\leq n \leq 10^9 ; 1 \leq k, q \leq 10^5 ) — the final destination, the number
of points Timur knows the time for, and the number of queries respectively.

The second line of each test case contains k integers a_i (1 \leq a_i \leq n ;
a_i < a_{i+1} for every 1 \leq i \leq k-1 ; a_k = n ).

The third line of each test case contains k integers b_i (1 \leq b_i \leq 10^9
; b_i < b_{i+1} for every 1 \leq i \leq k-1 ).

Each of the following q lines contains a single integer d (0 \leq d \leq n ) —
the distance that Timur asks the minutes passed for.

The sum of k over all test cases doesn't exceed 10^5 , and the sum of q over
all test cases doesn't exceed 10^5 .

Output

For each query, output a single integer — the number of minutes passed until
the car reaches the point d , rounded down.

Example

Input

    4
    
    10 1 3
    
    10
    
    10
    
    0
    
    6
    
    7
    
    10 2 4
    
    4 10
    
    4 7
    
    6
    
    4
    
    2
    
    7
    
    1000000000 1 1
    
    1000000000
    
    1000000000
    
    99999999
    
    6 1 3
    
    6
    
    5
    
    2
    
    6
    
    5

Output

    0 6 7 
    5 4 2 5 
    99999999 
    1 5 4 
    
Note

For the first test case, the car goes from point 0 to point 10 in 10 minutes,
so the speed is 1 unit per minute and:

  * At point 0 , the time will be 0 minutes. 
  * At point 6 , the time will be 6 minutes. 
  * At point 7 , the time will be 7 minutes. 

For the second test case, between points 0 and 4 , the car travels at a speed
of 1 unit per minute and between 4 and 10 with a speed of 2 units per minute
and:

  * At point 6 , the time will be 5 minutes. 
  * At point 4 , the time will be 4 minutes. 
  * At point 2 , the time will be 2 minutes. 
  * At point 7 , the time will be 5.5 minutes, so the answer is 5 . 

For the fourth test case, the car travels with 1.2 units per minute, so the
answers to the queries are:

  * At point 2 , the time will be 1.66\dots minutes, so the answer is 1 . 
  * At point 6 , the time will be 5 minutes. 
  * At point 5 , the time will be 4.16\dots minutes, so the answer is 4 .

- Program:
from bisect import bisect_left

def func():
    t = int(input())
    for _ in range(t):
        (n, k, q) = map(int, input().split())
        a = [0] + list(map(int, input().split()))
        b = [0] + list(map(int, input().split()))
        ad = [0]
        bd = [0]
        for i in range(1, len(a)):
            ad.append(a[i] - a[i - 1])
        for i in range(1, len(b)):
            bd.append(b[i] - b[i - 1])
        v = [0]
        for i in range(1, len(a)):
            v.append(ad[i] / bd[i])
        for l in range(q):
            m = 0
            i = 1
            ql = int(input())
            s = bisect_left(a, ql)
            if a[s] == ql:
                print(b[s], end=' ')
                continue
            ql -= a[s - 1]
            m += b[s - 1]
            m += bd[s] * ql / ad[s]
            print(int(m), end=' ')
        print()



- Function Summary: 
The function processes multiple test cases, each defined by parameters `n`, `k`, `q`, `a`, and `b`. For each test case, it reads a list of distances `d` from user input, and for each distance in `d`, it calculates and prints the time it takes to reach that distance based on the known points and times provided in `a` and `b`. The function does not return any value; it directly prints the results. After processing all test cases, the function concludes, and the final state includes the printed times for each query distance in each test case.

Beggining of Original Assessment: 
### Reasoning:

1. **Input Parsing and Initialization:**
   - The program correctly reads the number of test cases `t`.
   - For each test case, it reads `n`, `k`, and `q` which represent the final destination, the number of known points, and the number of queries, respectively.
   - It reads the lists `a` and `b` which contain the positions and times of the known points.
   - It initializes `ad` and `bd` lists to store the distances and time differences between consecutive known points.
   - It initializes `v` to store the speeds between consecutive known points.

2. **Speed Calculation:**
   - The program correctly calculates the distances between consecutive points and stores them in `ad`.
   - It correctly calculates the time differences between consecutive points and stores them in `bd`.
   - It calculates the speeds between consecutive points and stores them in `v`.

3. **Query Processing:**
   - For each query, it uses `bisect_left` to find the index `s` of the first known point that is greater than or equal to the query point `ql`.
   - If the query point `ql` is exactly at a known point `a[s]`, it directly prints the corresponding time `b[s]`.
   - If the query point `ql` is not at a known point, it calculates the time to reach `ql` by:
     - Subtracting the distance to the previous known point `a[s-1]` from `ql`.
     - Adding the time to reach the previous known point `b[s-1]` to the time it takes to travel the remaining distance at the speed between `a[s-1]` and `a[s]`.

4. **Output:**
   - The program prints the calculated time for each query, rounded down to the nearest integer.

### Potential Issues:
- **Indexing in `bisect_left`:**
  - The program uses `bisect_left` on the list `a` which includes the initial point 0. This is correct because `a` is strictly increasing and includes 0.
  - However, the program should ensure that `s` is within the bounds of the lists `a` and `b`.

- **Speed Calculation:**
  - The speed calculation `v.append(ad[i] / bd[i])` is correct, but it should be noted that `ad[i]` and `bd[i]` are the differences between consecutive points, not the points themselves.

- **Time Calculation:**
  - The time calculation `m += bd[s] * ql / ad[s]` is correct, but it should be noted that `ql` is adjusted to the remaining distance after subtracting `a[s-1]`.

### Conclusion:
The program appears to correctly handle the problem as described. It correctly parses the input, calculates the speeds, and processes the queries to output the time taken to reach each query point, rounded down to the nearest integer.

### Correctness:
Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

