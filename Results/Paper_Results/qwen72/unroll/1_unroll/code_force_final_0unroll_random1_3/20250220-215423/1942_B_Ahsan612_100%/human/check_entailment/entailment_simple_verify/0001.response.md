Reasoning:

1. **Understanding the Problem**:
   - The problem requires constructing a permutation `p` from an array `a` where `a[i] = MEX(p[1], p[2], ..., p[i]) - p[i]`.
   - The MEX of an array is the smallest non-negative integer not present in the array.

2. **Reconstructing the Permutation**:
   - The approach of working backwards from the end of the array `a` to the beginning is a good strategy because it allows us to determine the MEX of the prefix `p[1], p[2], ..., p[i]` more easily.
   - By starting with `mex = n`, we assume that initially, the MEX of the full permutation is `n` (since `p` is a permutation of `0` to `n-1`).

3. **Algorithm**:
   - The algorithm initializes `mex` to `n`.
   - It iterates from the last element of `a` to the first.
   - For each `i`, it calculates `p[i]` as `mex - a[i]`.
   - It updates `mex` to `mex - a[i]` if `mex` is greater than `mex - a[i]`.

4. **Correctness Check**:
   - The key part of the algorithm is the update of `mex` to `mex - a[i]` if `mex` is greater than `mex - a[i]`. This ensures that `mex` is always the correct MEX for the current prefix `p[1], p[2], ..., p[i]`.
   - However, the condition `if mex > mex - ar[i]` is always true because `ar[i]` is an integer and `mex` is a positive integer. This means the update `mex = mex - ar[i]` will always be executed, which is not necessarily correct.

5. **Potential Issue**:
   - The condition `if mex > mex - ar[i]` should be `if mex > mex - ar[i] and mex - ar[i] >= 0`. This ensures that `mex` is only updated if the new value is non-negative and smaller than the current `mex`.

6. **Example Verification**:
   - For the input `a = [1, 1, -2, 1, 2]`:
     - `mex = 5`
     - `res[4] = 5 - 2 = 3`, `mex = 3`
     - `res[3] = 3 - 1 = 2`, `mex = 2`
     - `res[2] = 2 - (-2) = 4`, `mex = 4` (This is incorrect because `mex` should be 2)
     - `res[1] = 2 - 1 = 1`, `mex = 1`
     - `res[0] = 1 - 1 = 0`, `mex = 0`
     - The output is `[0, 1, 4, 2, 3]`, which is incorrect because the MEX of the prefix `[0, 1, 4]` is 2, not 4.

   - For the input `a = [1, 1, 1, 1, 1]`:
     - `mex = 5`
     - `res[4] = 5 - 1 = 4`, `mex = 4`
     - `res[3] = 4 - 1 = 3`, `mex = 3`
     - `res[2] = 3 - 1 = 2`, `mex = 2`
     - `res[1] = 2 - 1 = 1`, `mex = 1`
     - `res[0] = 1 - 1 = 0`, `mex = 0`
     - The output is `[0, 1, 2, 3, 4]`, which is correct.

   - For the input `a = [-2, 1, 2]`:
     - `mex = 3`
     - `res[2] = 3 - 2 = 1`, `mex = 1`
     - `res[1] = 1 - 1 = 0`, `mex = 0`
     - `res[0] = 0 - (-2) = 2`, `mex = 2` (This is incorrect because `mex` should be 0)
     - The output is `[2, 0, 1]`, which is incorrect because the MEX of the prefix `[2, 0]` is 1, not 2.

Given the above reasoning, the provided program is incorrect due to the flawed condition for updating `mex`.

Final: **False**