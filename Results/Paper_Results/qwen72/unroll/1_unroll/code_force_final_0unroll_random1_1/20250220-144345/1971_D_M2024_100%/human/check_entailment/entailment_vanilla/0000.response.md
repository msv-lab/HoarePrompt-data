### Reasoning:

1. **Understanding the Problem:**
   - We are given a binary string, and we need to determine the minimum number of contiguous substrings (pieces) that the string can be divided into such that these pieces can be rearranged to form a sorted binary string (i.e., all '0's come before all '1's).

2. **Key Observations:**
   - A sorted binary string has all '0's before all '1's.
   - To achieve this, we need to identify the points where the string transitions from '1' to '0' and from '0' to '1'.
   - Each transition from '1' to '0' indicates a point where we need to make a cut to ensure that the '1' can be moved to the end of the sorted string.
   - Each transition from '0' to '1' indicates a point where we need to make a cut to ensure that the '0' can be moved to the beginning of the sorted string.

3. **Algorithm Analysis:**
   - The program iterates through the string and counts the number of transitions from '1' to '0' (`cut1`) and from '0' to '1' (`cut0`).
   - If there are no transitions from '0' to '1' (`cut0 == 0`), it means the string is already sorted or can be sorted by just moving '1's to the end. In this case, the number of pieces needed is `cut1 + 1`.
   - If there are transitions from '0' to '1', it means we need to make cuts to separate the '0's and '1's properly. In this case, the number of pieces needed is `cut0 + cut1`.

4. **Edge Cases:**
   - If the string is already sorted (all '0's before all '1's), the program correctly outputs `1`.
   - If the string consists of only '0's or only '1's, the program correctly outputs `1`.
   - If the string has a mix of '0's and '1's, the program correctly counts the necessary cuts and outputs the correct number of pieces.

5. **Example Verification:**
   - For the input "11010":
     - Transitions: '1' to '0' (2 times), '0' to '1' (1 time).
     - Output: `cut0 + cut1 = 1 + 2 = 3`.
   - For the input "00000000":
     - No transitions.
     - Output: `1`.
   - For the input "1":
     - No transitions.
     - Output: `1`.
   - For the input "10":
     - Transitions: '1' to '0' (1 time).
     - Output: `cut1 + 1 = 1 + 1 = 2`.
   - For the input "0001111":
     - No transitions.
     - Output: `1`.
   - For the input "0110":
     - Transitions: '0' to '1' (1 time), '1' to '0' (1 time).
     - Output: `cut0 + cut1 = 1 + 1 = 2`.

### Conclusion:
The program correctly implements the logic to determine the minimum number of pieces needed to rearrange the binary string into a sorted binary string. It handles all edge cases and examples provided in the problem description.

**Correctness: True**