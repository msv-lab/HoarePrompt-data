Correctness: **False**

### Explanation:

The program has a few issues that make it incorrect:

1. **Incorrect Calculation of `pk`:**
   - The program calculates `pk` as `n / 2` regardless of whether `n` is even or odd. This is incorrect because for odd `n`, `pk` should be `n // 2 + 1` to ensure that the road is as close to the middle as possible.

2. **Incorrect Use of Percentages:**
   - The program uses percentages to check if more than half of the residents on each side are satisfied. This is unnecessary and can lead to incorrect results. Instead, it should directly check if the number of satisfied residents on each side meets the required condition.

3. **Handling Edge Cases:**
   - The program does not correctly handle the edge cases where the road should be laid before the first house or after the last house. The logic for these cases is flawed.

4. **Multiple Valid Positions:**
   - The program does not correctly handle the case where there are multiple valid positions with the same minimum distance to the middle. It should output the smallest valid position.

### Corrected Program:

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        s = input()
        
        # Calculate the prefix sum of zeros and ones
        zeros = [0] * (n + 1)
        ones = [0] * (n + 1)
        
        for i in range(n):
            zeros[i + 1] = zeros[i] + (s[i] == '0')
            ones[i + 1] = ones[i] + (s[i] == '1')
        
        best_i = -1
        min_diff = float('inf')
        
        for i in range(n):
            left_zeros = zeros[i + 1]
            left_ones = i + 1 - left_zeros
            right_zeros = zeros[n] - zeros[i + 1]
            right_ones = ones[n] - ones[i + 1]
            
            left_satisfied = left_zeros >= (i + 1) // 2 + (i + 1) % 2
            right_satisfied = right_ones >= (n - i - 1) // 2 + (n - i - 1) % 2
            
            if left_satisfied and right_satisfied:
                diff = abs(n // 2 - i)
                if diff < min_diff:
                    min_diff = diff
                    best_i = i
        
        if best_i == -1:
            if ones[n] >= n // 2 + n % 2:
                best_i = 0
            else:
                best_i = n
        
        print(best_i)

# Example usage
func()
```

### Explanation of the Corrected Program:

1. **Prefix Sums:**
   - We use prefix sums to efficiently calculate the number of zeros and ones on the left and right sides of the road for each possible position.

2. **Check Satisfied Condition:**
   - For each position `i`, we check if the number of zeros on the left side is at least half of the left side, and the number of ones on the right side is at least half of the right side.

3. **Find the Best Position:**
   - We keep track of the best position `best_i` that minimizes the distance to the middle of the village.

4. **Handle Edge Cases:**
   - If no valid position is found, we check if the entire village can be declared as the right side (if there are more ones) or the left side (if there are more zeros).

This corrected program should now correctly determine the position of the road for each test case.