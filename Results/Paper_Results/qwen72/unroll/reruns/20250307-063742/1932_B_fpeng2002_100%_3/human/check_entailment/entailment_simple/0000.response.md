### Reasoning:

The program is designed to solve the problem of finding the year when the n-th sign will occur, given the periodicity of each sign. The key logic in the program is the loop that calculates the year for each sign to occur, ensuring that each sign occurs strictly after the previous one.

Let's break down the logic:

1. **Input Reading:**
   - `num_tests = int(input())`: Reads the number of test cases.
   - `n = int(input())`: Reads the number of signs for the current test case.
   - `nums = [int(x) for x in input().split(' ')]`: Reads the periodicities of the signs.

2. **Initialization:**
   - `start_year = 0`: Initializes the starting year for the first sign.

3. **Loop to Calculate the Year for Each Sign:**
   - `for x in range(0, len(nums)):`: Iterates over each sign.
   - `start_year = (start_year // nums[x] + 1) * nums[x]`: This line ensures that the current sign occurs in the next year that is a multiple of its periodicity, strictly after the previous sign.

4. **Output:**
   - `print(start_year)`: Prints the year when the n-th sign will occur.

### Explanation of the Key Line:
- `start_year = (start_year // nums[x] + 1) * nums[x]`:
  - `start_year // nums[x]` finds the largest integer `k` such that `k * nums[x]` is less than or equal to `start_year`.
  - Adding 1 to `k` ensures that we move to the next multiple of `nums[x]`.
  - Multiplying by `nums[x]` gives the next year when the sign will occur.

This logic correctly ensures that each sign occurs strictly after the previous one, and the program will output the correct year for the n-th sign to occur.

### Verification with Example Test Cases:
1. **Test Case 1:**
   - Input: `3 2 4 5 9 18`
   - Calculation:
     - First sign: `start_year = (0 // 3 + 1) * 3 = 3`
     - Second sign: `start_year = (3 // 2 + 1) * 2 = 4`
     - Third sign: `start_year = (4 // 4 + 1) * 4 = 8`
     - Fourth sign: `start_year = (8 // 5 + 1) * 5 = 10`
     - Fifth sign: `start_year = (10 // 9 + 1) * 9 = 18`
     - Sixth sign: `start_year = (18 // 18 + 1) * 18 = 36`
   - Output: `36` (Correct)

2. **Test Case 2:**
   - Input: `1 2 3 4 5`
   - Calculation:
     - First sign: `start_year = (0 // 1 + 1) * 1 = 1`
     - Second sign: `start_year = (1 // 2 + 1) * 2 = 2`
     - Third sign: `start_year = (2 // 3 + 1) * 3 = 3`
     - Fourth sign: `start_year = (3 // 4 + 1) * 4 = 4`
     - Fifth sign: `start_year = (4 // 5 + 1) * 5 = 5`
   - Output: `5` (Correct)

3. **Test Case 3:**
   - Input: `1 1 1 1 1`
   - Calculation:
     - First sign: `start_year = (0 // 1 + 1) * 1 = 1`
     - Second sign: `start_year = (1 // 1 + 1) * 1 = 2`
     - Third sign: `start_year = (2 // 1 + 1) * 1 = 3`
     - Fourth sign: `start_year = (3 // 1 + 1) * 1 = 4`
     - Fifth sign: `start_year = (4 // 1 + 1) * 1 = 5`
   - Output: `5` (Correct)

4. **Test Case 4:**
   - Input: `50 30 711 200 503 1006`
   - Calculation:
     - First sign: `start_year = (0 // 50 + 1) * 50 = 50`
     - Second sign: `start_year = (50 // 30 + 1) * 30 = 60`
     - Third sign: `start_year = (60 // 711 + 1) * 711 = 711`
     - Fourth sign: `start_year = (711 // 200 + 1) * 200 = 800`
     - Fifth sign: `start_year = (800 // 503 + 1) * 503 = 1006`
     - Sixth sign: `start_year = (1006 // 1006 + 1) * 1006 = 2012`
   - Output: `2012` (Correct)

### Conclusion:
The program correctly implements the logic to find the year when the n-th sign will occur, ensuring that each sign occurs strictly after the previous one. The provided test cases also confirm that the program produces the correct output.

### Correctness:
Correctness: **True**