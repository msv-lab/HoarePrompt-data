
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
You are given an array x_2,x_3,\dots,x_n . Your task is to find any array
a_1,\dots,a_n , where:

  * 1\le a_i\le 10^9 for all 1\le i\le n . 
  * x_i=a_i \bmod a_{i-1} for all 2\le i\le n . 

Here c\bmod d denotes the remainder of the division of the integer c by the
integer d . For example 5 \bmod 2 = 1 , 72 \bmod 3 = 0 , 143 \bmod 14 = 3 .

Note that if there is more than one a which satisfies the statement, you are
allowed to find any.

Input

The first line contains a single integer t (1\le t\le 10^4) — the number of
test cases.

The first line of each test case contains a single integer n (2\le n\le 500) —
the number of elements in a .

The second line of each test case contains n-1 integers x_2,\dots,x_n (1\le
x_i\le 500) — the elements of x .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 .

Output

For each test case output any a_1,\dots,a_n (1 \le a_i \le 10^9 ) which
satisfies the statement.

Example

Input

    5
    
    4
    
    2 4 1
    
    3
    
    1 1
    
    6
    
    4 2 5 1 2
    
    2
    
    500
    
    3
    
    1 5

Output

    3 5 4 9
    2 5 11
    5 14 16 5 11 24
    501 500
    2 7 5

Note

In the first test case a=[3,5,4,9] satisfies the conditions, because:

  * a_2\bmod a_1=5\bmod 3=2=x_2 ; 
  * a_3\bmod a_2=4\bmod 5=4=x_3 ; 
  * a_4\bmod a_3=9\bmod 4=1=x_4 ;

- Program: 
def func():
    t = int(input())
    while t:
        t = t - 1
        n = int(input())
        line = input('')
        T = list(map(int, line.split()))
        a = [1000]
        for i in range(1, n):
            a.append(a[i - 1] + T[i - 1])
        result = ' '.join(map(str, a))
        print(result)



- Annotated Code: 
#State of the program right berfore the function call: t is an integer such that 1 <= t <= 10^4, n is an integer such that 2 <= n <= 500, and x is a list of n-1 integers where 1 <= x_i <= 500.
def func():
    t = int(input())
    while t:
        t = t - 1
        
        n = int(input())
        
        line = input('')
        
        T = list(map(int, line.split()))
        
        a = [1000]
        
        for i in range(1, n):
            a.append(a[i - 1] + T[i - 1])
        
        result = ' '.join(map(str, a))
        
        print(result)
        
    #State: t = 0, n remains unchanged, x remains unchanged, a is a list of n integers where each integer is the cumulative sum of the elements in T up to that index, result is a string of space-separated integers representing the list a.



Beggining of Original Assessment: 
Correctness: **False**.

Explanation: The program does not correctly handle the case where the input values for `x` are such that the constructed array `a` does not satisfy the condition \( x_i = a_i \bmod a_{i-1} \) for all \( 2 \le i \le n \).

For example, consider the following input:
```
1
3
1 2
```
The program constructs the array `a` as follows:
- `a[0] = 1000`
- `a[1] = 1000 + 1 = 1001`
- `a[2] = 1001 + 2 = 1003`

The output is:
```
1000 1001 1003
```

However, this does not satisfy the condition:
- \( a_2 \bmod a_1 = 1003 \bmod 1001 = 2 \), which is correct.
- \( a_1 \bmod a_0 = 1001 \bmod 1000 = 1 \), which is correct.

But the initial value of `a[0]` is set to 1000, which is not a valid value since \( 1 \le a_i \le 10^9 \) and \( a_1 \bmod a_0 \) should be equal to \( x_1 \), which is 1 in this case. The program should ensure that the first element of `a` is chosen such that the conditions are met for all elements.

A correct approach would be to initialize `a[0]` to a value that is greater than or equal to the maximum value in `x` and then construct the array `a` accordingly. For instance, initializing `a[0]` to 1001 in the above example would work:
- `a[0] = 1001`
- `a[1] = 1001 + 1 = 1002`
- `a[2] = 1002 + 2 = 1004`

The output would be:
```
1001 1002 1004
```

This satisfies the conditions:
- \( a_2 \bmod a_1 = 1004 \bmod 1002 = 2 \)
- \( a_1 \bmod a_0 = 1002 \bmod 1001 = 1 \)

Thus, the program is incorrect because it does not handle the initialization of `a[0]` properly.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

