### Reasoning:

1. **Tree Construction and Rooting:**
   - The `Tree` class is used to construct the tree from the input edges.
   - The `add_edge` method correctly adds edges to the tree.
   - The `root_tree_non_recursive` method roots the tree at a specified vertex (0 in this case) and calculates the subtree sizes for each vertex. This is done using a stack to simulate a depth-first search (DFS) in a non-recursive manner, which is necessary to avoid stack overflow for large trees.

2. **Component Calculation:**
   - `func_1` and `func_2` are used to calculate the number of good components and the remaining size of the subtree rooted at a given vertex.
   - `func_1` uses a stack to perform a DFS and updates the `good_components` and `remaining_size` attributes of each vertex.
   - `func_2` is a recursive version of the same logic, but it is not used in the main program. Both functions should produce the same results.

3. **Binary Search for Maximum Component Size:**
   - `func_3` checks if it is possible to remove exactly `k` edges such that each remaining component has at least `x` vertices.
   - `func_4` uses binary search to find the maximum value of `x` for which `func_3` returns `True`. This is an efficient way to find the maximum `x` because the problem is monotonic: if it is possible to achieve `x`, it is also possible to achieve any smaller value.

4. **Input Handling and Output:**
   - `func_5` reads the input for each test case, constructs the tree, roots it, and then calls `func_4` to find and print the maximum `x` for the given `n` and `k`.

### Correctness:

- **Tree Construction and Rooting:**
  - The tree is constructed correctly, and the non-recursive DFS method ensures that the tree is rooted and subtree sizes are calculated accurately.

- **Component Calculation:**
  - Both `func_1` and `func_2` correctly calculate the number of good components and the remaining size of the subtree. However, `func_2` is not used in the main program, so it is irrelevant to the correctness of the solution.

- **Binary Search for Maximum Component Size:**
  - The binary search in `func_4` is implemented correctly. It efficiently finds the maximum `x` by checking the conditions using `func_3`.

- **Input Handling and Output:**
  - `func_5` correctly handles the input and output for each test case. It reads the number of vertices `n` and the number of edges to remove `k`, constructs the tree, roots it, and then prints the result of `func_4`.

### Conclusion:

The program is correct based on the problem description and the provided execution states. It correctly constructs the tree, roots it, calculates the number of good components and remaining sizes, and uses binary search to find the maximum `x` such that each remaining component has at least `x` vertices after removing `k` edges.

**Correctness: True**