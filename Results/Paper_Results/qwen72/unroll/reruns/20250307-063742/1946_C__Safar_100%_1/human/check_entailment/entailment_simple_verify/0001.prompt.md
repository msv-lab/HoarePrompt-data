
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
You are given a tree with n vertices.

Your task is to find the maximum number x such that it is possible to remove
exactly k edges from this tree in such a way that the size of each remaining
connected component^{\dagger} is at least x .

^{\dagger} Two vertices v and u are in the same connected component if there
exists a sequence of numbers t_1, t_2, \ldots, t_k of arbitrary length k ,
such that t_1 = v , t_k = u , and for each i from 1 to k - 1 , vertices t_i
and t_{i+1} are connected by an edge.

Input

Each test consists of several sets of input data. The first line contains a
single integer t (1 \le t \le 10^4 ) — the number of sets of input data. This
is followed by a description of the sets of input data.

The first line of each set of input data contains two integers n and k (1 \le
k < n \le 10^5 ) — the number of vertices in the tree and the number of edges
to be removed.

Each of the next n - 1 lines of each set of input data contains two integers v
and u (1 \le v, u \le n ) — the next edge of the tree.

It is guaranteed that the sum of the values of n for all sets of input data
does not exceed 10^5 .

Output

For each set of input data, output a single line containing the maximum number
x such that it is possible to remove exactly k edges from the tree in such a
way that the size of each remaining connected component is at least x .

Example

Input

    6
    
    5 1
    
    1 2
    
    1 3
    
    3 4
    
    3 5
    
    2 1
    
    1 2
    
    6 1
    
    1 2
    
    2 3
    
    3 4
    
    4 5
    
    5 6
    
    3 1
    
    1 2
    
    1 3
    
    8 2
    
    1 2
    
    1 3
    
    2 4
    
    2 5
    
    3 6
    
    3 7
    
    3 8
    
    6 2
    
    1 2
    
    2 3
    
    1 4
    
    4 5
    
    5 6

Output

    2
    1
    3
    1
    1
    2
    
Note

The tree in the first set of input data:

![](https://espresso.codeforces.com/799bacd3be0dda357800fdfc3eadbf38ab259c51.png)

After removing the edge 1 — 3 , the tree will look as follows:

![](https://espresso.codeforces.com/a59ae10eeac1212e1e56fc7fe5f6a47764269104.png)

The tree has split into two connected components. The first component consists
of two vertices: 1 and 2 . The second connected component consists of three
vertices: 3, 4 and 5 . In both connected components, there are at least two
vertices. It can be shown that the answer 3 is not achievable, so the answer
is 2 .

- Program: 

#Function 1:
def func_1(n, k, edges):
    g = [[] for _ in range(n + 1)]
    for (a, b) in edges:
        g[a].append(b)
        g[b].append(a)
    c = 0

    l = 1
    r = n // k
    while l <= r:
        mid = l + (r - l) // 2
        if check(mid):
            l = mid + 1
        else:
            r = mid - 1
    print(r)

#Function 2:
def check(A):
    stack = [(1, 1)]
    visited = set()
    d = {1: 1}
    r = 0
    while True:
        (x, p) = stack[-1]
        if x not in visited:
            visited.add(x)
            d[x] = 1
            for node in g[x]:
                if node != p:
                    stack.append((node, x))
        else:
            if x == 1:
                break
            if d[x] >= A:
                r += 1
            else:
                d[p] += d[x]
            stack.pop()
            visited.remove(x)
            del d[x]
    if r > k or (d[1] >= A and r == k):
        return True
    return False



- Annotated Code: 
q = []
for i in range(int(input())):
    (n, k) = map(int, input().split(' '))
    edges = []
    for _ in range(n - 1):
        (a, b) = map(int, input().split(' '))
        edges.append((a, b))
    func_1(n, k, edges)
for (n, k, edges) in q:
    func_1(n, k, edges)

#Function 1:
#State of the program right berfore the function call: n and k are integers such that 1 ≤ k < n ≤ 10^5, and edges is a list of tuples (a, b) where 1 ≤ a, b ≤ n, representing the edges of the tree.
def func_1(n, k, edges):
    g = [[] for _ in range(n + 1)]
    for (a, b) in edges:
        g[a].append(b)
        
        g[b].append(a)
        
    #State: `g` is a list of lists where each list at index `i` contains the indices of nodes directly connected to node `i` in the tree. The lengths of the lists in `g` will vary depending on the degree of each node in the tree. The variables `n` and `k` remain unchanged.
    c = 0
    l = 1
    r = n // k
    while l <= r:
        mid = l + (r - l) // 2
        
        if check(mid):
            l = mid + 1
        else:
            r = mid - 1
        
    #State: `l` is `n // k + 1` and `r` is `n // k - 1`.
    print(r)
    #This is printed: n // k - 1 (where n and k are the values of n and k, and n // k is the integer division of n by k)

#Function 2:
#State of the program right berfore the function call: A is a positive integer, g is a dictionary representing the adjacency list of a tree with n vertices, and k is a non-negative integer such that 1 <= k < n.
def check(A):
    stack = [(1, 1)]
    visited = set()
    d = {(1): 1}
    r = 0
    while True:
        x, p = stack[-1]
        
        if x not in visited:
            visited.add(x)
            d[x] = 1
            for node in g[x]:
                if node != p:
                    stack.append((node, x))
        else:
            if x == 1:
                break
            if d[x] >= A:
                r += 1
            else:
                d[p] += d[x]
            stack.pop()
            visited.remove(x)
            del d[x]
        
    #State: The loop terminates with `stack` being empty, `visited` containing only the root node (1), `d` containing the count of nodes in each subtree rooted at each node (except for the root node which is not deleted), and `r` being the count of nodes (excluding the root) whose subtree size is greater than or equal to `A`.
    if (r > k or d[1] >= A and r == k) :
        return True
        #The program returns True.
    #State: The loop terminates with `stack` being empty, `visited` containing only the root node (1), `d` containing the count of nodes in each subtree rooted at each node (except for the root node which is not deleted), and `r` being the count of nodes (excluding the root) whose subtree size is greater than or equal to `A`. Additionally, `r` is less than or equal to `k` and either `d[1]` is less than `A` or `r` is not equal to `k`.
    return False
    #The program returns False.




Beggining of Original Assessment: 
### Reasoning:

1. **Problem Understanding:**
   - We are given a tree with `n` vertices and need to remove `k` edges such that each remaining connected component has at least `x` vertices.
   - The goal is to find the maximum possible value of `x`.

2. **Program Structure:**
   - The program consists of two functions: `func_1` and `check`.
   - `func_1` is the main function that processes the input and uses binary search to find the maximum `x`.
   - `check` is a helper function that verifies if a given `x` can be achieved by removing `k` edges.

3. **Binary Search in `func_1`:**
   - The function initializes a graph `g` using adjacency lists.
   - It sets the initial range for binary search: `l = 1` and `r = n // k`.
   - The binary search iterates while `l <= r`, calculating the midpoint `mid` and checking if it is possible to achieve a component size of at least `mid` using the `check` function.
   - If `check(mid)` returns `True`, it means `mid` is a valid component size, so we try a larger value by setting `l = mid + 1`.
   - If `check(mid)` returns `False`, it means `mid` is not a valid component size, so we try a smaller value by setting `r = mid - 1`.
   - The function prints `r` after the binary search completes, which should be the maximum valid `x`.

4. **Helper Function `check`:**
   - The function uses a depth-first search (DFS) approach to traverse the tree.
   - It maintains a stack to keep track of the current node and its parent.
   - It uses a dictionary `d` to store the size of each component.
   - The function iterates through the stack, marking nodes as visited and calculating the size of each component.
   - If a node's size is at least `A`, it increments the count `r`.
   - If a node's size is less than `A`, it adds its size to its parent's size.
   - The function returns `True` if the number of valid components `r` is greater than `k` or if the root component is valid and `r` equals `k`.

5. **Potential Issues:**
   - The `check` function does not correctly handle the case where the root component is valid but `r` is less than `k`.
   - The `check` function should ensure that the total number of valid components is exactly `k` or more, but it currently only checks if `r` is greater than `k` or if the root component is valid and `r` equals `k`.
   - The `check` function should also handle the case where the root component is valid and `r` is exactly `k`.

6. **Correctness Check:**
   - The binary search in `func_1` is correctly implemented.
   - The `check` function needs to be adjusted to correctly count the number of valid components and handle the root component properly.

### Conclusion:
The program is **not** correct because the `check` function does not correctly handle the case where the root component is valid but the total number of valid components is less than `k`. This can lead to incorrect results in some cases.

Correctness: **False**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

