
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Some permutation of length n is guessed.

You are given the indices of its prefix maximums and suffix maximums.

Recall that a permutation of length k is an array of size k such that each
integer from 1 to k occurs exactly once.

Prefix maximums are the elements that are the maximum on the prefix ending at
that element. More formally, the element a_i is a prefix maximum if a_i > a_j
for every j < i .

Similarly, suffix maximums are defined, the element a_i is a suffix maximum if
a_i > a_j for every j > i .

You need to output the number of different permutations that could have been
guessed.

As this number can be very large, output the answer modulo 10^9 + 7 .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains three integers n, m_1 and m_2 (1 \le
m_1, m_2 \le n \le 2 \cdot 10^5 ) — the length of the permutation, the number
of prefix maximums, and the number of suffix maximums, respectively.

The second line of each test case contains m_1 integers p_1 < p_2 < \ldots <
p_{m_1} (1 \le p_i \le n ) — the indices of the prefix maximums in increasing
order.

The third line of each test case contains m_2 integers s_1 < s_2 < \ldots <
s_{m_2} (1 \le s_i \le n ) — the indices of the suffix maximums in increasing
order.

It is guaranteed that the sum of the values of n for all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer on a separate line — the number of
suitable permutations modulo 10^9 + 7 .

Example

Input

    6
    
    1 1 1
    
    1
    
    1
    
    4 2 3
    
    1 2
    
    2 3 4
    
    3 3 1
    
    1 2 3
    
    3
    
    5 3 4
    
    1 2 3
    
    2 3 4 5
    
    20 5 4
    
    1 2 3 4 12
    
    12 13 18 20
    
    6 2 3
    
    1 3
    
    3 4 6

Output

    1
    3
    1
    0
    317580808
    10
    
Note

The following permutations are suitable for the second set of input data:

  * [1, 4, 3, 2] 
  * [2, 4, 3, 1] 
  * [3, 4, 2, 1] 

The following permutations are suitable for the sixth set of input data:

  * [2, 1, 6, 5, 3, 4] 
  * [3, 1, 6, 5, 2, 4] 
  * [3, 2, 6, 5, 1, 4] 
  * [4, 1, 6, 5, 2, 3] 
  * [4, 2, 6, 5, 1, 3] 
  * [4, 3, 6, 5, 1, 2] 
  * [5, 1, 6, 4, 2, 3] 
  * [5, 2, 6, 4, 1, 3] 
  * [5, 3, 6, 4, 1, 2] 
  * [5, 4, 6, 3, 1, 2]

- Program: 
import sys
import math

input = sys.stdin.readline
MOD = int(1000000000.0 + 7)
for _ in range(int(input())):
    print(func_1())

def func_1():
    (N, M1, M2) = map(int, input().split())
    L = list(map(int, input().split()))
    R = list(map(int, input().split()))
    if L[-1] != R[0]:
        return 0
    if L[0] != 1 or R[0] != N:
        return 0
    if M1 > 1 and M2 > 1 and (L[-2] == R[1]):
        return 0
    ans = math.comb(N - 1, L[-1] - 1)
    cur = M1 - 2
    if M1 > 1:
        nums_left = L[-1] - 2
        i = L[-1] - 1
        while i > 1:
            if i == L[cur]:
                cur -= 1
            else:
                ans = ans * nums_left % MOD
            nums_left -= 1
            i -= 1
    nums_left = N - R[0] - 1
    if M2 > 1:
        cur = 1
        i = R[0] + 1
        while i < N:
            if i == R[cur]:
                cur += 1
            else:
                ans = ans * nums_left % MOD
            nums_left -= 1
            i += 1
    return ans



- Annotated Code: 
import sys
import math

input = sys.stdin.readline
MOD = int(1000000000.0 + 7)
for _ in range(int(input())):
    print(func_1())

#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 10^4) representing the number of test cases. cases is a list of tuples, where each tuple contains three elements: (n, m_1, m_2), and two lists of integers (p_1, p_2, ..., p_{m_1}) and (s_1, s_2, ..., s_{m_2}). For each test case, n is a positive integer (1 ≤ n ≤ 2 * 10^5), m_1 and m_2 are positive integers (1 ≤ m_1, m_2 ≤ n) representing the number of prefix and suffix maximums, respectively. The lists p and s contain distinct integers in strictly increasing order, with 1 ≤ p_i, s_i ≤ n, and the sum of n values across all test cases does not exceed 2 * 10^5.
def func_1():
    N, M1, M2 = map(int, input().split())
    L = list(map(int, input().split()))
    R = list(map(int, input().split()))
    if (L[-1] != R[0]) :
        return 0
        #The program returns 0.
    #State: *`t` is a positive integer (1 ≤ t ≤ 10^4), `cases` is a list of tuples, `N` is an input integer, `M1` is an input integer, `M2` is an input integer, `L` is a list of integers read from the input, `R` is a list of integers read from the input, and the last element of `L` is equal to the first element of `R`.
    if (L[0] != 1 or R[0] != N) :
        return 0
        #The program returns 0.
    #State: *`t` is a positive integer (1 ≤ t ≤ 10^4), `cases` is a list of tuples, `N` is an input integer, `M1` is an input integer, `M2` is an input integer, `L` is a list of integers read from the input, `R` is a list of integers read from the input, and the last element of `L` is equal to the first element of `R`. Additionally, `L[0]` is 1 and `R[0]` is `N`.
    if (M1 > 1 and M2 > 1 and L[-2] == R[1]) :
        return 0
        #The program returns 0.
    #State: `t` is a positive integer (1 ≤ t ≤ 10^4), `cases` is a list of tuples, `N` is an input integer, `M1` is an input integer, `M2` is an input integer, `L` is a list of integers read from the input, `R` is a list of integers read from the input, and the last element of `L` is equal to the first element of `R`. Additionally, `L[0]` is 1 and `R[0]` is `N`. Either `M1` is less than or equal to 1, or `M2` is less than or equal to 1, or the second-to-last element of `L` is not equal to the second element of `R`.
    ans = math.comb(N - 1, L[-1] - 1)
    cur = M1 - 2
    if (M1 > 1) :
        nums_left = L[-1] - 2
        i = L[-1] - 1
        while i > 1:
            if i == L[cur]:
                cur -= 1
            else:
                ans = ans * nums_left % MOD
            
            nums_left -= 1
            
            i -= 1
            
        #State: `i` is 1, `cur` is `M1 - L[-1]`, `nums_left` is 0, `ans` is the result of the computation `ans * (L[-1] - 2)! % MOD`.
    #State: *`t` is a positive integer (1 ≤ t ≤ 10^4), `cases` is a list of tuples, `N` is an input integer, `M1` is an input integer, `M2` is an input integer, `L` is a list of integers read from the input, `R` is a list of integers read from the input, and the last element of `L` is equal to the first element of `R`. Additionally, `L[0]` is 1 and `R[0]` is `N`. Either `M1` is less than or equal to 1, or `M2` is less than or equal to 1, or the second-to-last element of `L` is not equal to the second element of `R`. `ans` is the combination of `N-1` choose `L[-1]-1`. If `M1` > 1, `i` is 1, `cur` is `M1 - L[-1]`, and `ans` is the result of the computation `ans * (L[-1] - 2)! % MOD`. Otherwise, `cur` is `M1 - 2`.
    nums_left = N - R[0] - 1
    if (M2 > 1) :
        cur = 1
        i = R[0] + 1
        while i < N:
            if i == R[cur]:
                cur += 1
            else:
                ans = ans * nums_left % MOD
            
            nums_left -= 1
            
            i += 1
            
        #State: `i = N`, `cur = M1 - 1`, `ans = ans * (L[-1] - 2)! % MOD`, `nums_left = -N`.
    #State: *`t` is a positive integer (1 ≤ t ≤ 10^4), `cases` is a list of tuples, `N` is an input integer, `M1` is an input integer, `M2` is an input integer, `L` is a list of integers read from the input, `R` is a list of integers read from the input, and the last element of `L` is equal to the first element of `R`. Additionally, `L[0]` is 1 and `R[0]` is `N`. Either `M1` is less than or equal to 1, or `M2` is less than or equal to 1, or the second-to-last element of `L` is not equal to the second element of `R`. `ans` is the combination of `N-1` choose `L[-1]-1`. If `M1` > 1, `i` is 1, `cur` is `M1 - L[-1]`, and `ans` is the result of the computation `ans * (L[-1] - 2)! % MOD`. Otherwise, `cur` is `M1 - 2`. If `M2` > 1, `i` is `N`, `cur` is `M1 - 1`, `ans` is `ans * (L[-1] - 2)! % MOD`, and `nums_left` is `-N`. Otherwise, `nums_left` is `-1`.
    return ans
    #The program returns the value of `ans`, which is the combination of `N-1` choose `L[-1]-1` and may be further modified by the conditions involving `M1` and `M2`. If `M1` > 1, `ans` is multiplied by `(L[-1] - 2)!` and the result is taken modulo `MOD`. If `M2` > 1, `ans` is also multiplied by `(L[-1] - 2)!` and the result is taken modulo `MOD`. If neither `M1` nor `M2` is greater than 1, `ans` remains the initial combination value.
#Overall this is what the function does:The function `func_1` reads input values for `N`, `M1`, and `M2`, and two lists of integers `L` and `R`. It checks several conditions and returns 0 if any of the following are true: the last element of `L` is not equal to the first element of `R`, `L[0]` is not 1 or `R[0]` is not `N`, or if both `M1` and `M2` are greater than 1 and the second-to-last element of `L` is equal to the second element of `R`. If none of these conditions are met, the function computes a value `ans` based on the combination of `N-1` choose `L[-1]-1`. If `M1` is greater than 1, `ans` is further modified by multiplying it by the factorial of `L[-1] - 2` and taking the result modulo `MOD`. Similarly, if `M2` is greater than 1, `ans` is again modified by the same factorial and modulo operation. The final value of `ans` is returned.


Beggining of Original Assessment: 
Correctness: **False**.

Explanation:
The program has a logical error in handling the input and the conditions specified in the problem description. Specifically, the function `func_1` is called without passing the necessary parameters, which are required to read the input for each test case. This will lead to incorrect behavior or runtime errors.

Additionally, the conditions in the function are not correctly handling all edge cases. For example, the condition `if L[0] != 1 or R[0] != N` is incorrect because the first element of the prefix maximums list `L` should be 1, and the first element of the suffix maximums list `R` should be `N`. However, the program checks `R[0]` instead of `R[-1]` for the last element of the suffix maximums list.

A correct implementation should ensure that:
1. The first element of the prefix maximums list `L` is 1.
2. The last element of the suffix maximums list `R` is `N`.
3. The last element of the prefix maximums list `L` is the same as the first element of the suffix maximums list `R`.

Here is a corrected version of the function for reference:

```python
import sys
import math

input = sys.stdin.readline
MOD = int(1000000000.0 + 7)

def func_1(N, M1, M2, L, R):
    if L[-1] != R[0]:
        return 0
    if L[0] != 1 or R[-1] != N:
        return 0
    if M1 > 1 and M2 > 1 and (L[-2] == R[1]):
        return 0
    ans = math.comb(N - 1, L[-1] - 1)
    cur = M1 - 2
    if M1 > 1:
        nums_left = L[-1] - 2
        i = L[-1] - 1
        while i > 1:
            if i == L[cur]:
                cur -= 1
            else:
                ans = ans * nums_left % MOD
            nums_left -= 1
            i -= 1
    nums_left = N - R[0] - 1
    if M2 > 1:
        cur = 1
        i = R[0] + 1
        while i < N:
            if i == R[cur]:
                cur += 1
            else:
                ans = ans * nums_left % MOD
            nums_left -= 1
            i += 1
    return ans

for _ in range(int(input())):
    (N, M1, M2) = map(int, input().split())
    L = list(map(int, input().split()))
    R = list(map(int, input().split()))
    print(func_1(N, M1, M2, L, R))
```

In the original program, the function `func_1` is called without passing the necessary parameters, and the conditions are not correctly set up to handle all edge cases. Therefore, the program is incorrect.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

