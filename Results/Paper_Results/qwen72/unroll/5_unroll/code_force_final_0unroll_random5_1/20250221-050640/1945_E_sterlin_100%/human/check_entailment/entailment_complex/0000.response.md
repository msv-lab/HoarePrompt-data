### Reasoning:

1. **Input Handling**:
   - `func_1()` reads the number of test cases `t`.
   - `func_2()` reads the integers `n` and `x` for each test case.
   - `func_3()` reads the permutation `p` for each test case.
   - These functions are correctly implemented and handle the input as described in the problem.

2. **Binary Search Logic**:
   - The binary search loop is correctly implemented. It initializes `left` and `right` to 0 and `n` respectively.
   - The loop continues until `left + 1 < right`, which is the correct termination condition for binary search.
   - Inside the loop, it calculates the middle index `mid` and updates `left` or `right` based on the value of `p[mid]` compared to `x`.

3. **Permutation Handling**:
   - The program creates a dictionary `num_indx` to map each number in the permutation to its index.
   - It also maintains a list `seen` to track which elements have been visited during the binary search.

4. **Output Logic**:
   - If `p[left] == x` after the binary search, it prints `0` (no swaps needed).
   - If `x` is not in the `seen` list, it prints `1` and the indices to swap `x` to the correct position.
   - If `x` is in the `seen` list but not at `p[left]`, it prints `2` and the indices to swap `x` and another element to the correct position.

5. **Edge Cases**:
   - The program correctly handles the case where `x` is already in the correct position.
   - It also handles the case where `x` is not in the correct position but can be moved with one or two swaps.

6. **Algorithm Validity**:
   - The problem states that 2 operations are always sufficient to rearrange the permutation so that the binary search will find `x`.
   - The program's logic ensures that it performs the necessary swaps to achieve this.

### Conclusion:
The program correctly implements the required algorithm and handles all edge cases as described in the problem. Therefore, the program is correct.

**Correctness: True**