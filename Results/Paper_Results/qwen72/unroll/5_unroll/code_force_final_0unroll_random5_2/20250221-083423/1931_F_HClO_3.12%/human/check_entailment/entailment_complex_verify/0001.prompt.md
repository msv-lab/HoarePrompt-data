
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
There are n people in the programming contest chat. Chat participants are
ordered by activity, but each person sees himself at the top of the list.

For example, there are 4 participants in the chat, and their order is [2, 3,
1, 4] . Then

  * 1 -st user sees the order [1, 2, 3, 4] . 
  * 2 -nd user sees the order [2, 3, 1, 4] . 
  * 3 -rd user sees the order [3, 2, 1, 4] . 
  * 4 -th user sees the order [4, 2, 3, 1] . 

k people posted screenshots in the chat, which show the order of participants
shown to this user. The screenshots were taken within a short period of time,
and the order of participants has not changed.

Your task is to determine whether there is a certain order that all
screenshots correspond to.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
input test cases. The descriptions of test cases follow.

The first line of the description of each test case contains two integers n
and k (1 \le k \le n \le 2 \cdot 10^5, n \cdot k \le 2 \cdot 10^5 ) — the
number of chat participants and the number of participants who posted
screenshots.

The following k lines contain descriptions of screenshots posted by the
participants.

The i -th row contains n integers a_{ij} each (1 \le a_{ij} \le n , all a_{ij}
are different) — the order of participants shown to the participant a_{i0} ,
where a_{i0} — the author of the screenshot. You can show that in the
screenshot description it will always be at the top of the list.

It is guaranteed that the sum of n \cdot k for all test cases does not exceed
2 \cdot 10^5 . It is also guaranteed that all the authors of the screenshots
are different.

Output

Output t lines, each of which is the answer to the corresponding test case. As
an answer, output "YES" if there exists at least one order of participants,
under which all k screenshots could have been obtained. Otherwise, output
"NO".

You can output the answer in any case (upper or lower). For example, the
strings "yEs", "yes", "Yes", and "YES" will be recognized as positive
responses.

Example

Input

    10
    
    5 1
    
    1 2 3 4 5
    
    4 4
    
    1 2 3 4
    
    2 3 1 4
    
    3 2 1 4
    
    4 2 3 1
    
    6 2
    
    1 3 5 2 4 6
    
    6 3 5 2 1 4
    
    3 3
    
    1 2 3
    
    2 3 1
    
    3 2 1
    
    10 2
    
    1 2 3 4 5 6 7 8 9 10
    
    10 9 8 7 6 5 4 3 2 1
    
    1 1
    
    1
    
    5 2
    
    1 2 3 5 4
    
    2 1 3 5 4
    
    3 3
    
    3 1 2
    
    2 3 1
    
    1 3 2
    
    5 4
    
    3 5 1 4 2
    
    2 5 1 4 3
    
    1 5 4 3 2
    
    5 1 4 3 2
    
    3 3
    
    1 3 2
    
    2 1 3
    
    3 2 1

Output

    YES
    YES
    YES
    YES
    NO
    YES
    YES
    YES
    YES
    NO

- Program: 
from heapq import *

def func():
    t = int(input())
    for _ in range(t):
        (n, m) = map(int, input().split())
        if m == 1:
            input()
            print('yes')
            continue
        (a1, *l1) = map(int, input().split())
        (a2, *l2) = map(int, input().split())
        l11 = [i for i in l1 if i != a2]
        l22 = [i for i in l2 if i != a1]
        if l11 != l22:
            for _ in range(m - 2):
                input()
            print('no')
            continue
        idx1 = idx2 = -1
        p1 = p2 = 0
        for i in range(n - 1):
            if i + max(p1, p2) == n - 1:
                break
            if l1[i + p1] != l2[i + p2]:
                if l1[i + p1] == a2 and l2[i + p2] == a1:
                    idx1 = idx2 = i
                    break
                else:
                    if l1[i + p1] == a2:
                        idx1 = i
                        p1 = 1
                    else:
                        idx2 = i
                        p2 = 1
                    if idx1 >= 0 and idx2 >= 0:
                        break
        val = []
        if idx1 < idx2:
            l2.insert(idx1, a2)
            l = l2
        elif idx1 > idx2:
            l1.insert(idx2, a1)
            l = l1
        else:
            if m == 2:
                print('yes')
                continue
            (a3, *l3) = map(int, input().split())
            if l3.index(a1) < l3.index(a2):
                l1.insert(idx2, a1)
                l = l1
            else:
                l2.insert(idx1, a2)
                l = l2
            val.append((a3, l3))
            m -= 1
        for _ in range(m - 2):
            (a3, *l3) = map(int, input().split())
            val.append((a3, l3))
        for (a3, l3) in val:
            if l3 != [i for i in l if i != a3]:
                print('no')
                break
        else:
            print('yes')



- Annotated Code: 
from heapq import *

#State of the program right berfore the function call: t is a positive integer such that 1 \le t \le 10^4. For each test case, n and k are positive integers where 1 \le k \le n \le 2 \cdot 10^5 and n \cdot k \le 2 \cdot 10^5. Each of the k lines contains n integers a_{ij} (1 \le a_{ij} \le n) representing the order of participants shown to the participant a_{i0}, and all a_{ij} are distinct for each line. The sum of n \cdot k across all test cases does not exceed 2 \cdot 10^5, and all authors of the screenshots are different.
def func():
    t = int(input())
    for _ in range(t):
        n, m = map(int, input().split())
        
        if m == 1:
            input()
            print('yes')
            continue
        
        a1, *l1 = map(int, input().split())
        
        a2, *l2 = map(int, input().split())
        
        l11 = [i for i in l1 if i != a2]
        
        l22 = [i for i in l2 if i != a1]
        
        if l11 != l22:
            for _ in range(m - 2):
                input()
            print('no')
            continue
        
        idx1 = idx2 = -1
        
        p1 = p2 = 0
        
        for i in range(n - 1):
            if i + max(p1, p2) == n - 1:
                break
            if l1[i + p1] != l2[i + p2]:
                if l1[i + p1] == a2 and l2[i + p2] == a1:
                    idx1 = idx2 = i
                    break
                else:
                    if l1[i + p1] == a2:
                        idx1 = i
                        p1 = 1
                    else:
                        idx2 = i
                        p2 = 1
                    if idx1 >= 0 and idx2 >= 0:
                        break
        
        val = []
        
        if idx1 < idx2:
            l2.insert(idx1, a2)
            l = l2
        elif idx1 > idx2:
            l1.insert(idx2, a1)
            l = l1
        else:
            if m == 2:
                print('yes')
                continue
            a3, *l3 = map(int, input().split())
            if l3.index(a1) < l3.index(a2):
                l1.insert(idx2, a1)
                l = l1
            else:
                l2.insert(idx1, a2)
                l = l2
            val.append((a3, l3))
            m -= 1
        
        for _ in range(m - 2):
            a3, *l3 = map(int, input().split())
            val.append((a3, l3))
        
        for a3, l3 in val:
            if l3 != [i for i in l if i != a3]:
                print('no')
                break
        else:
            print('yes')
        
    #State: The loop iterates `t` times, and for each iteration, it reads `n` and `m` from input. Depending on the values of `n` and `m`, and the lists `l1` and `l2`, it either prints 'yes' or 'no'. After all iterations, the values of `t`, `n`, and `m` are no longer relevant, and the lists `l1`, `l2`, and `l3` are modified or reset during each iteration, so they do not retain any specific state from one iteration to the next. The only consistent state is that the loop has completed `t` iterations.
#Overall this is what the function does:The function reads `t` test cases, where `t` is a positive integer (1 ≤ t ≤ 10^4). For each test case, it reads two positive integers `n` and `m` (1 ≤ k ≤ n ≤ 2 * 10^5, n * k ≤ 2 * 10^5) representing the number of participants and the number of orders, respectively. It then reads `m` lines, each containing `n` distinct integers representing the order of participants shown to a particular participant. The function checks if the orders are consistent with a specific condition and prints 'yes' if they are, or 'no' if they are not. After processing all test cases, the function has no lasting state, as all variables are reset or redefined for each test case.


Beggining of Original Assessment: 
### Reasoning:

1. **Input Handling**:
   - The program correctly reads the number of test cases `t`.
   - For each test case, it reads the number of participants `n` and the number of screenshots `m`.

2. **Special Case Handling**:
   - If there is only one screenshot (`m == 1`), the program correctly prints "yes" because a single screenshot can always correspond to some order of participants.

3. **Initial Comparisons**:
   - The program reads the first two screenshots and extracts the author and the list of other participants.
   - It then removes the author from the list of other participants to create `l11` and `l22`.

4. **Consistency Check**:
   - The program checks if `l11` and `l22` are the same. If they are not, it prints "no" and skips the remaining screenshots for this test case.

5. **Index and Position Adjustments**:
   - The program initializes `idx1` and `idx2` to -1 and `p1` and `p2` to 0.
   - It iterates through the lists to find the positions where the elements differ and adjusts the indices and positions accordingly.

6. **Inserting Authors**:
   - Based on the indices found, the program inserts the authors back into the lists to create a consistent order.
   - If `m == 2`, it directly prints "yes" because the two screenshots are consistent.

7. **Further Validation**:
   - For more than two screenshots, the program reads the remaining screenshots and stores them in a list `val`.
   - It then checks if each remaining screenshot is consistent with the adjusted list `l`.

8. **Output**:
   - The program prints "no" if any screenshot is inconsistent.
   - If all screenshots are consistent, it prints "yes".

### Detailed Analysis:

- **Special Case Handling**:
  - The program correctly handles the case where `m == 1` by printing "yes" and continuing to the next test case.

- **Initial Comparisons**:
  - The program correctly removes the author from the list of other participants to create `l11` and `l22`.
  - It checks if `l11` and `l22` are the same. If they are not, it prints "no" and continues to the next test case.

- **Index and Position Adjustments**:
  - The program iterates through the lists to find the positions where the elements differ and adjusts the indices and positions accordingly.
  - This step is crucial for determining the correct order of participants.

- **Inserting Authors**:
  - The program inserts the authors back into the lists to create a consistent order.
  - If `m == 2`, it directly prints "yes" because the two screenshots are consistent.

- **Further Validation**:
  - The program reads the remaining screenshots and stores them in a list `val`.
  - It then checks if each remaining screenshot is consistent with the adjusted list `l`.
  - This step ensures that all screenshots correspond to the same order of participants.

### Conclusion:
The program appears to correctly handle all the given test cases and follows the logic required to determine if there is a consistent order of participants for the given screenshots. The steps are well-defined and the conditions are checked appropriately.

### Correctness:
Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

