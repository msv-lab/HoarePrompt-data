#State of the program right berfore the function call: None of the variables in the function signature. This function does not take any parameters and is used to read input, which is not directly related to the problem's core logic.
def func_1():
    return map(int, input().split())
    #The program returns a map object that converts the input string into a sequence of integers, where the input string is split by spaces.
#Overall this is what the function does:The function `func_1` reads a line of input from the user, splits the input string by spaces, converts each part into an integer, and returns a map object containing the sequence of integers. The function does not take any parameters and does not modify any external state. After the function concludes, the user will have a map object that can be iterated over to access the sequence of integers.

#State of the program right berfore the function call: None of the variables in the function signature are used, so there are no specific preconditions related to the function's parameters.
def func_2():
    return list(func_1())
    #The program returns a list generated by calling the function `func_1()`. The contents of the list depend on the implementation of `func_1()`, which is not provided, so the exact values in the list cannot be determined.
#Overall this is what the function does:The function `func_2` does not accept any parameters and returns a list generated by calling the function `func_1()`. The exact contents of the list depend on the implementation of `func_1()`, which is not provided, so the final state of the program includes a returned list whose values cannot be determined from the given code.

#State of the program right berfore the function call: n is a positive integer representing the length of the permutation, k is an integer such that 1 <= k <= n representing the number to be found, and arr is a list of integers representing the permutation of size n with elements ranging from 1 to n.
def func_3():
    n, k = func_1()
    arr = func_2()
    pos = -1
    for i in range(n):
        if arr[i] == k:
            pos = i
        
    #State: `n` is greater than or equal to 0, `i` is `n-1`, `k` is updated to the value returned by `func_1()`, `arr` is a list of integers representing the permutation of size `n` with elements ranging from 1 to `n`. If `k` is found in `arr`, `pos` is the index of the first occurrence of `k` in `arr`. Otherwise, `pos` remains -1.
    low, high = 0, n - 1
    st = set()
    while low + 1 < high:
        mid = (low + high) // 2
        
        st.add(mid)
        
        if arr[mid] > k:
            high = mid
        else:
            low = mid
        
    #State: `n` is greater than or equal to 0, `i` is `n-1`, `k` is the value returned by `func_1()`, `arr` is a list of integers representing the permutation of size `n` with elements ranging from 1 to `n`. If `k` is found in `arr`, `pos` is the index of the first occurrence of `k` in `arr`. Otherwise, `pos` remains -1. `low` is the index of the element in `arr` that is just less than or equal to `k` (or the last index if all elements are greater than `k`), `high` is the index of the element in `arr` that is just greater than `k` (or the first index if all elements are less than or equal to `k`), `st` is a set containing the indices that were checked during the binary search process.
    if (arr[low] == k) :
        print(0)
        #This is printed: 0
    else :
        print(1)
        #This is printed: 1
        print(low + 1, pos + 1)
        #This is printed: (low + 1, pos + 1) (where low is the index of the element just less than or equal to k, and pos is the index of the first occurrence of k in arr if k is found, otherwise pos is -1)
    #State: *`n` is greater than or equal to 0, `i` is `n-1`, `k` is the value returned by `func_1()`, `arr` is a list of integers representing the permutation of size `n` with elements ranging from 1 to `n`. If `k` is found in `arr`, `pos` is the index of the first occurrence of `k` in `arr`. Otherwise, `pos` remains -1. `low` is the index of the element in `arr` that is just less than or equal to `k` (or the last index if all elements are greater than `k`), `high` is the index of the element in `arr` that is just greater than `k` (or the first index if all elements are less than or equal to `k`), `st` is a set containing the indices that were checked during the binary search process. If `arr[low]` is equal to `k`, then `pos` is set to `low`. Otherwise, `arr[low]` is not equal to `k` and `pos` remains as it was determined earlier.
#Overall this is what the function does:The function `func_3` does not explicitly accept any parameters but internally calls `func_1` to get `n` and `k`, and `func_2` to get `arr`. It searches for the integer `k` in the list `arr`, which is a permutation of integers from 1 to `n`. If `k` is found in `arr`, it prints `0`. If `k` is not found, it prints `1` followed by the indices `low + 1` and `pos + 1`, where `low` is the index of the element in `arr` that is just less than or equal to `k` (or the last index if all elements are greater than `k`), and `pos` is the index of the first occurrence of `k` in `arr` if `k` is found, otherwise `pos` remains -1. The function does not return any value.

