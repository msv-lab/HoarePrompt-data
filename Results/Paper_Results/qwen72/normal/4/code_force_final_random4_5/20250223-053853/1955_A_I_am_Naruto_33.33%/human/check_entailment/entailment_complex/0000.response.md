Reasoning:

1. **Input Handling**: The function correctly reads the number of test cases `t` and then iterates over each test case. For each test case, it reads the values of `n`, `a`, and `b` using `map(int, input().split())`.

2. **Base Case**: When `n == 1`, the function correctly prints the price of one yogurt, which is `a`. This is the simplest case and is handled correctly.

3. **General Case**: When `n > 1`, the function calculates two possible costs:
   - `ans1 = a * n`: This is the cost if all yogurts are bought at the regular price.
   - `ans2 = b * (n // 2) + a * (n % 2)`: This is the cost if Maxim buys as many pairs of yogurts as possible at the promotional price `b` and the remaining yogurts (if any) at the regular price `a`.

4. **Minimum Cost Calculation**: The function then prints the minimum of `ans1` and `ans2`. This ensures that Maxim spends the least amount of burles possible.

5. **Output**: The function correctly prints the minimum cost for each test case in a separate line, as required by the problem statement.

6. **Edge Cases**: The function handles edge cases correctly:
   - If `n == 1`, it prints `a`.
   - If `n` is even, it calculates the cost using only the promotional price.
   - If `n` is odd, it calculates the cost using the promotional price for as many pairs as possible and the regular price for the remaining one yogurt.

Given the above reasoning, the function appears to correctly solve the problem as described.

Correctness: **True**