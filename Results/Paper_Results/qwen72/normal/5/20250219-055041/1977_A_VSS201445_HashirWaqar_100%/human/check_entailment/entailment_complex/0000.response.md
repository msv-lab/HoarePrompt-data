### Reasoning:

1. **Input Handling**: The function starts by reading the number of test cases `t` from the input. It then iterates `t` times, reading two integers `n` and `m` for each test case.

2. **Condition Check**: For each test case, the function checks two conditions:
   - `n >= m`: This ensures that the number of moves `n` is at least as large as the number of cubes `m` that Nikita wants in the tower.
   - `(n - m) % 2 == 0`: This ensures that the difference between the number of moves `n` and the number of cubes `m` is even. This is necessary because each move can either add or remove a cube, and the net effect of `n` moves must be an even number of additions or removals to end up with exactly `m` cubes.

3. **Output**: If both conditions are met, the function prints 'YES'. Otherwise, it prints 'NO'.

4. **Edge Cases**:
   - If `n` is less than `m`, it is impossible to end up with `m` cubes after `n` moves.
   - If `n` is equal to `m`, the condition `(n - m) % 2 == 0` is always true, so the function correctly prints 'YES'.
   - If `n` is greater than `m` but the difference is odd, the function correctly prints 'NO'.

5. **Test Cases**:
   - For `n = 3` and `m = 3`, the function prints 'YES' because `3 >= 3` and `(3 - 3) % 2 == 0`.
   - For `n = 2` and `m = 4`, the function prints 'NO' because `2 < 4`.
   - For `n = 5` and `m = 3`, the function prints 'YES' because `5 >= 3` and `(5 - 3) % 2 == 0`.

### Conclusion:
The function correctly implements the logic to determine if it is possible for Nikita to build a tower with exactly `m` cubes after `n` moves. The conditions and the logic are sound and handle all edge cases as described in the problem statement.

### Correctness:
**True**