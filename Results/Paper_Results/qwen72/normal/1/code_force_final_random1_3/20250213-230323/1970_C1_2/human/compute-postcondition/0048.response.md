The only objects in the loop head are `neighbor` and `tree[current]`, so we can only adjust those. According to the code, whether the loop can execute depends on the `tree[current]` having more neighbors. At the end of the last iteration, `tree[current]` must contain at least one neighbor, and `neighbor` is the first neighbor in `tree[current]`.

For the loop to execute one more time, `tree[current]` must still contain at least one neighbor (after the first neighbor has been processed), and `neighbor` should now refer to the next neighbor in `tree[current]`.

State: **`tree[current]` must contain at least two neighbors, `neighbor` is the second neighbor in `tree[current]`. If `neighbor` is not in `visited`, `neighbor` is added to `visited`, and `queue` contains a new tuple `(neighbor, dist + 1)` at the end.**