
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
[The HU - Shireg Shireg](https://youtu.be/SNCx4n2m5_o)

ඞ

There are n cows participating in a coding tournament. Cow i has a Cowdeforces
rating of a_i (all distinct), and is initially in position i . The tournament
consists of n-1 matches as follows:

  * The first match is between the cow in position 1 and the cow in position 2 . 
  * Subsequently, each match i is between the cow in position i+1 and the winner of match i-1 . 
  * In each match, the cow with the higher Cowdeforces rating wins and proceeds to the next match. 

You are the owner of cow k . For you, winning the tournament is not important;
rather, you want your cow to win in as many matches as possible. As an
acquaintance of the tournament organizers, you can ask them to swap the
position of your cow with another cow only once, or you can choose to do
nothing.

Find the maximum number of wins your cow can achieve.

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains two integers n and k (2 \le n \le
10^5, 1 \le k \le n ) — the number of cows and your cow's index.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the Cowdeforces rating of the cows. It is guaranteed that
a_i 's are pairwise different.

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, print one integer: the maximum number of wins cow k can
achieve if you choose to swap (or do nothing) optimally.

Example

Input

    3
    
    6 1
    
    12 10 14 11 8 3
    
    6 5
    
    7 2 727 10 12 13
    
    2 2
    
    1000000000 1

Output

    1
    2
    0
    
Note

In the first test case, it is optimal to do nothing. Let a' be the Cowdeforces
rating of the cows in the original order (with your cow's rating bolded), then

  * Initially, a' = [\mathbf{12}, 10, 14, 11, 8, 3] . 
  * Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [\mathbf{12}, 14, 11, 8, 3] . 
  * Your cow plays against the cow with Cowdeforces rating 14 and loses. 

In total, your cow wins 1 match.

In the second test case, it is optimal to swap your cow to position 3 . Then,
let a' be the Cowdeforces rating of the cows in the order after the swap.

  * Initially, a' = [7, 2, \mathbf{12}, 10, 727, 13] . 
  * The cow with Cowdeforces rating 7 plays against the cow with Cowdeforces rating 2 and wins. a' = [7, \mathbf{12}, 10, 727, 13] . 
  * The cow with Cowdeforces rating 7 plays against your cow, and your cow wins. a' = [\mathbf{12}, 10, 727, 13] . 
  * Your cow plays against the cow with Cowdeforces rating 10 and wins. a' = [\mathbf{12}, 727, 13] . 
  * Your cow plays against the cow with Cowdeforces rating 727 and loses. 

In total, your cow wins 2 matches.

- Program: 
for _ in range(int(input())):
    (n, k) = list(map(int, input().split()))
    l = list(map(int, input().split()))
    k -= 1
    print(func_1(l))

def func_1(a):
    x = a[k]
    ind = []
    c = 0
    for i in range(n):
        if a[i] > x:
            ind.append(i)
            c += 1
        if c == 2:
            break
    if ind == []:
        return n - 1
    if len(ind) == 1:
        if ind[0] == 0:
            return k - 1
        if ind[0] > k:
            return ind[0] - 1
        return max(k - ind[0], ind[0] - 1)
    if ind[0] == 0:
        return min(ind[1] - 1, k - 1)
    if k > ind[1]:
        return max(ind[0] - 1, ind[1] - ind[0])
    return max(ind[0] - 1, k - ind[0])



- Annotated Code: 
for _ in range(int(input())):
    (n, k) = list(map(int, input().split()))
    l = list(map(int, input().split()))
    k -= 1
    print(func_1(l))

#State of the program right berfore the function call: a is a list of integers where each integer represents the Cowdeforces rating of a cow, and the ratings are pairwise distinct.
def func_1(a):
    x = a[k]
    ind = []
    c = 0
    for i in range(n):
        if a[i] > x:
            ind.append(i)
            c += 1
        
        if c == 2:
            break
        
    #State: `a` is a list of integers where each integer represents the Cowdeforces rating of a cow, and the ratings are pairwise distinct; `x` is equal to the integer at index `k` in the list `a`; `ind` is a list containing the indices of the first two elements in `a` that are greater than `x`, if such elements exist; `c` is 2 if there are at least two elements in `a` that are greater than `x`, otherwise `c` is the number of elements in `a` that are greater than `x` and the loop breaks if `c` reaches 2; `i` is the index of the last element checked in `a` (which could be less than `n-1` if the loop breaks early); `n` remains unchanged.
    if (ind == []) :
        return n - 1
        #The program returns the value of `n - 1`, where `n` is the length of the list `a` and remains unchanged.
    #State: `a` is a list of integers where each integer represents the Cowdeforces rating of a cow, and the ratings are pairwise distinct; `x` is equal to the integer at index `k` in the list `a`; `ind` is a list containing the indices of the first two elements in `a` that are greater than `x`, if such elements exist; `c` is 2 if there are at least two elements in `a` that are greater than `x`, otherwise `c` is the number of elements in `a` that are greater than `x` and the loop breaks if `c` reaches 2; `i` is the index of the last element checked in `a` (which could be less than `n-1` if the loop breaks early); `n` remains unchanged; `ind` is not an empty list.
    if (len(ind) == 1) :
        if (ind[0] == 0) :
            return k - 1
            #The program returns the value of `k - 1`, where `k` is the index of the integer `x` in the list `a`.
        #State: `a` is a list of integers where each integer represents the Cowdeforces rating of a cow, and the ratings are pairwise distinct; `x` is equal to the integer at index `k` in the list `a`; `ind` is a list containing the indices of the first two elements in `a` that are greater than `x`, if such elements exist; `c` is 2 if there are at least two elements in `a` that are greater than `x`, otherwise `c` is the number of elements in `a` that are greater than `x` and the loop breaks if `c` reaches 2; `i` is the index of the last element checked in `a` (which could be less than `n-1` if the loop breaks early); `n` remains unchanged; `ind` is not an empty list and contains exactly one index; `ind[0]` is not equal to 0.
        if (ind[0] > k) :
            return ind[0] - 1
            #The program returns the index of the first element in `a` that is greater than `x`, minus 1.
        #State: `a` is a list of integers where each integer represents the Cowdeforces rating of a cow, and the ratings are pairwise distinct; `x` is equal to the integer at index `k` in the list `a`; `ind` is a list containing the indices of the first two elements in `a` that are greater than `x`, if such elements exist; `c` is 2 if there are at least two elements in `a` that are greater than `x`, otherwise `c` is the number of elements in `a` that are greater than `x` and the loop breaks if `c` reaches 2; `i` is the index of the last element checked in `a` (which could be less than `n-1` if the loop breaks early); `n` remains unchanged; `ind` is not an empty list and contains exactly one index; `ind[0]` is not equal to 0; `ind[0]` is less than or equal to `k`.
        return max(k - ind[0], ind[0] - 1)
        #The program returns the maximum value between `k - ind[0]` and `ind[0] - 1`, where `k` is the index of the integer `x` in the list `a`, and `ind[0]` is the index of the first element in `a` that is greater than `x`.
    #State: *`a` is a list of integers where each integer represents the Cowdeforces rating of a cow, and the ratings are pairwise distinct; `x` is equal to the integer at index `k` in the list `a`; `ind` is a list containing the indices of the first two elements in `a` that are greater than `x`, if such elements exist; `c` is 2 if there are at least two elements in `a` that are greater than `x`, otherwise `c` is the number of elements in `a` that are greater than `x` and the loop breaks if `c` reaches 2; `i` is the index of the last element checked in `a` (which could be less than `n-1` if the loop breaks early); `n` remains unchanged; `ind` is not an empty list, and the length of `ind` is not equal to 1
    if (ind[0] == 0) :
        return min(ind[1] - 1, k - 1)
        #The program returns the minimum value between the index of the second element in `ind` minus 1 and `k` minus 1.
    #State: `a` is a list of integers where each integer represents the Cowdeforces rating of a cow, and the ratings are pairwise distinct; `x` is equal to the integer at index `k` in the list `a`; `ind` is a list containing the indices of the first two elements in `a` that are greater than `x`, if such elements exist; `c` is 2 if there are at least two elements in `a` that are greater than `x`, otherwise `c` is the number of elements in `a` that are greater than `x` and the loop breaks if `c` reaches 2; `i` is the index of the last element checked in `a` (which could be less than `n-1` if the loop breaks early); `n` remains unchanged; `ind` is not an empty list, and the length of `ind` is not equal to 1; `ind[0]` is not equal to 0.
    if (k > ind[1]) :
        return max(ind[0] - 1, ind[1] - ind[0])
        #The program returns the maximum value between `ind[0] - 1` and `ind[1] - ind[0]`, where `ind[0]` and `ind[1]` are the indices of the first two elements in `a` that are greater than `x`.
    #State: `a` is a list of integers where each integer represents the Cowdeforces rating of a cow, and the ratings are pairwise distinct; `x` is equal to the integer at index `k` in the list `a`; `ind` is a list containing the indices of the first two elements in `a` that are greater than `x`, if such elements exist; `c` is 2 if there are at least two elements in `a` that are greater than `x`, otherwise `c` is the number of elements in `a` that are greater than `x` and the loop breaks if `c` reaches 2; `i` is the index of the last element checked in `a` (which could be less than `n-1` if the loop breaks early); `n` remains unchanged; `ind` is not an empty list, and the length of `ind` is not equal to 1; `ind[0]` is not equal to 0; `k` is less than or equal to `ind[1]`
    return max(ind[0] - 1, k - ind[0])
    #The program returns the maximum value between `ind[0] - 1` and `k - ind[0]`. `ind[0]` is the index of the first element in `a` that is greater than `x`, and `k` is the index of `x` in the list `a`.
#Overall this is what the function does:The function `func_1` accepts a list `a` of distinct integers representing Cowdeforces ratings and an implicit parameter `k` (the index of a specific rating `x` in the list `a`). It returns an integer based on the following conditions:
- If there are no elements in `a` greater than `x`, it returns `n - 1`, where `n` is the length of the list `a`.
- If there is exactly one element in `a` greater than `x`:
  - If this element is at index 0, it returns `k - 1`.
  - If this element is at an index greater than `k`, it returns `ind[0] - 1`, where `ind[0]` is the index of this element.
  - Otherwise, it returns the maximum of `k - ind[0]` and `ind[0] - 1`.
- If there are at least two elements in `a` greater than `x`:
  - If the first of these elements is at index 0, it returns the minimum of `ind[1] - 1` and `k - 1`.
  - If `k` is greater than the index of the second element (`ind[1]`), it returns the maximum of `ind[0] - 1` and `ind[1] - ind[0]`.
  - Otherwise, it returns the maximum of `ind[0] - 1` and `k - ind[0]`.

The list `a` and its length `n` remain unchanged after the function call.


Beggining of Original Assessment: 
To determine the correctness of the given Python program, let's break down the problem and the solution step-by-step.

### Problem Understanding:
1. **Tournament Structure**:
   - The tournament consists of \( n-1 \) matches.
   - The first match is between the cows in positions 1 and 2.
   - Each subsequent match is between the cow in position \( i+1 \) and the winner of the previous match.
   - The cow with the higher rating wins each match.

2. **Objective**:
   - You are the owner of cow \( k \).
   - You want to maximize the number of matches your cow \( k \) wins.
   - You can swap your cow's position with another cow's position exactly once or choose to do nothing.

### Solution Analysis:
The function `func_1` is supposed to determine the maximum number of wins for cow \( k \) by either swapping or not swapping.

#### Key Steps in the Function:
1. **Identify the Rating of Your Cow**:
   - `x = a[k]` stores the rating of your cow.

2. **Find Positions of Cows with Higher Ratings**:
   - `ind = []` is a list to store the positions of cows with ratings higher than your cow.
   - `c = 0` is a counter to keep track of how many such cows are found.
   - The loop iterates through the list `a` to find the first two cows with higher ratings and adds their positions to `ind`.

3. **Determine the Maximum Wins**:
   - If no cows have a higher rating (`ind == []`), your cow can win all \( n-1 \) matches.
   - If only one cow has a higher rating:
     - If this cow is at position 0, your cow can win \( k-1 \) matches.
     - If this cow is after your cow, your cow can win up to the position of this cow minus one.
     - Otherwise, the maximum wins are the maximum of the number of matches before this cow and the number of matches between this cow and your cow.
   - If two cows have higher ratings:
     - If the first cow with a higher rating is at position 0, your cow can win up to the position of the second cow minus one or \( k-1 \) matches, whichever is smaller.
     - If your cow is after the second cow with a higher rating, your cow can win up to the position of the first cow minus one or the number of matches between the first and second cows.
     - Otherwise, the maximum wins are the maximum of the number of matches before the first cow and the number of matches between the first and second cows.

### Verification:
Let's verify the solution with the provided test cases:

1. **Test Case 1**:
   - Input: \( n = 6 \), \( k = 1 \), \( a = [12, 10, 14, 11, 8, 3] \)
   - Your cow's rating: \( 12 \)
   - Cows with higher ratings: \( 14 \) at position 2
   - Since your cow is at position 1 and the only higher-rated cow is at position 2, your cow wins 1 match.
   - Output: \( 1 \) (Correct)

2. **Test Case 2**:
   - Input: \( n = 6 \), \( k = 5 \), \( a = [7, 2, 727, 10, 12, 13] \)
   - Your cow's rating: \( 12 \)
   - Cows with higher ratings: \( 727 \) at position 2, \( 13 \) at position 5
   - If you swap your cow to position 3, your cow wins 2 matches.
   - Output: \( 2 \) (Correct)

3. **Test Case 3**:
   - Input: \( n = 2 \), \( k = 2 \), \( a = [1000000000, 1] \)
   - Your cow's rating: \( 1 \)
   - No cows have a higher rating.
   - Since your cow is at position 2 and there are no higher-rated cows, your cow wins 0 matches.
   - Output: \( 0 \) (Correct)

### Conclusion:
The function `func_1` correctly handles the logic for determining the maximum number of wins for your cow \( k \) by either swapping or not swapping. It correctly identifies the positions of cows with higher ratings and calculates the maximum wins based on these positions.

Therefore, the program is correct.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

