Reasoning:

The problem requires us to determine the minimum total cost to make a binary string sorted in non-descending order using cyclic shifts. The key insight is that we need to move all '1's to the right of all '0's to achieve a sorted string. The cost of each operation is the length of the chosen substring.

The provided function `func_1` works as follows:
- It initializes `cost` to 0 and `one` to 0.
- It iterates through each character in the string `s`.
- If the character is '1', it increments the `one` counter.
- If the character is '0' and there are preceding '1's (i.e., `one > 0`), it adds `one + 1` to the `cost`.

The logic of adding `one + 1` to the `cost` when encountering a '0' after some '1's is correct because:
- `one` represents the number of '1's that need to be moved to the right of the current '0'.
- The `+1` accounts for the length of the substring that includes the '0' and all the preceding '1's.

This approach ensures that the cost is minimized by only considering the necessary shifts to move '1's to the right of '0's.

However, there is a potential issue in the function:
- The function does not handle the case where the string ends with a sequence of '1's. In such cases, the `one` counter will be non-zero at the end of the loop, but no additional cost is added to move these '1's to the end of the string. This can lead to an incorrect result.

To fix this, we should add the final value of `one` to the `cost` after the loop if `one` is greater than 0. This ensures that any trailing '1's are accounted for in the total cost.

Given the current implementation, the function is **not** correct for all cases. For example, the string "1110" would incorrectly return a cost of 4 instead of 3.

Correctness: **False**

To correct the function, we can add the following line after the loop:

```python
if one > 0:
    cost += one
```

This ensures that any trailing '1's are accounted for in the total cost.

Here is the corrected function:

```python
def func_1(s):
    cost = 0
    one = 0
    for i in s:
        if i == '1':
            one += 1
        elif i == '0' and one > 0:
            cost += one + 1
    if one > 0:
        cost += one
    return cost
```

With this correction, the function should now correctly handle all cases.