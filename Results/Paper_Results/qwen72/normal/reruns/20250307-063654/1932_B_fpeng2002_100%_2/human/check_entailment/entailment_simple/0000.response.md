### Reasoning:

1. **Input Handling**:
   - The function reads the number of test cases (`num_tests`) and processes each test case one by one.
   - For each test case, it reads the number of signs (`n`) and the periodicities of the signs (`nums`).

2. **Logic for Finding the Year**:
   - The function initializes `start_year` to 0.
   - For each sign, it calculates the next occurrence of the sign that is strictly after the previous sign's occurrence.
   - The formula used is `start_year = (start_year // nums[x] + 1) * nums[x]`, which ensures that `start_year` is the smallest multiple of `nums[x]` that is greater than or equal to the current `start_year`.

3. **Correctness of the Formula**:
   - The formula `start_year = (start_year // nums[x] + 1) * nums[x]` works as follows:
     - `start_year // nums[x]` gives the number of complete cycles of `nums[x]` that fit into `start_year`.
     - Adding 1 to this quotient ensures that we move to the next cycle.
     - Multiplying by `nums[x]` gives the year of the next occurrence of the sign.
   - This ensures that the signs occur sequentially and strictly after the previous sign.

4. **Output**:
   - After processing all signs for a test case, the function prints the `start_year` for that test case.
   - The function correctly handles multiple test cases by using a while loop.

5. **Edge Cases**:
   - The function handles the case where `n` is 1 correctly.
   - The function also handles the case where all periodicities are 1 correctly, as it will always find the next year for each sign.

### Conclusion:
The program correctly implements the logic to find the year in which the n-th sign will occur, ensuring that each sign occurs strictly after the previous one. The input and output handling is also correct.

### Correctness:
**True**