Task ID,Dataset,model_created,model_run,description,Code,Test Result,Correctness,Post,original correctness,naive correctness,annotated correctness,annotated correctness simple,naive no fsl correctness,Correctness no fsl,simple verify,complex verify,default verify,simple verify no fsl,complex verify no fsl,default verify no fsl,data file
279,apps,gpt-4o,qwen2.5-7b-instruct,"Pavel cooks barbecue. There are n skewers, they lay on a brazier in a row, each on one of n positions. Pavel wants each skewer to be cooked some time in every of n positions in two directions: in the one it was directed originally and in the reversed direction.

Pavel has a plan: a permutation p and a sequence b_1, b_2, ..., b_{n}, consisting of zeros and ones. Each second Pavel move skewer on position i to position p_{i}, and if b_{i} equals 1 then he reverses it. So he hope that every skewer will visit every position in both directions.

Unfortunately, not every pair of permutation p and sequence b suits Pavel. What is the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements? Note that after changing the permutation should remain a permutation as well.

There is no problem for Pavel, if some skewer visits some of the placements several times before he ends to cook. In other words, a permutation p and a sequence b suit him if there is an integer k (k ≥ 2n), so that after k seconds each skewer visits each of the 2n placements.

It can be shown that some suitable pair of permutation p and sequence b exists for any n.


-----Input-----

The first line contain the integer n (1 ≤ n ≤ 2·10^5) — the number of skewers.

The second line contains a sequence of integers p_1, p_2, ..., p_{n} (1 ≤ p_{i} ≤ n) — the permutation, according to which Pavel wants to move the skewers.

The third line contains a sequence b_1, b_2, ..., b_{n} consisting of zeros and ones, according to which Pavel wants to reverse the skewers.


-----Output-----

Print single integer — the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements.


-----Examples-----
Input
4
4 3 2 1
0 1 1 1

Output
2

Input
3
2 3 1
0 0 0

Output
1



-----Note-----

In the first example Pavel can change the permutation to 4, 3, 1, 2.

In the second example Pavel can change any element of b to 1.","def solve():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    n = int(data[0])
    p = list(map(int, data[1:n+1]))
    b = list(map(int, data[n+1:2*n+1]))

    # Find cycles in the permutation p
    visited = [False] * n
    cycles = []
    for i in range(n):
        if not visited[i]:
            cycle = []
            x = i
            while not visited[x]:
                visited[x] = True
                cycle.append(x)
                x = p[x] - 1
            cycles.append(cycle)
    
    # Check number of components with no reversals
    no_reverse_components = sum(all(b[x] == 0 for x in cycle) for cycle in cycles)
    
    # If there is only one component, no change needed
    if len(cycles) == 1:
        print(0)
    else:
        # Otherwise, we need to ensure at least one reversal in each component
        print(no_reverse_components if no_reverse_components > 0 else 1)

# Use Standard Input format
solve()
",,False,post,False,False,False,False,False,False,False,False,False,False,False,False,selected_pilot_75_apps_qwen_temp.json
280,apps,llama3-70b,qwen2.5-7b-instruct,"The on-board computer on Polycarp's car measured that the car speed at the beginning of some section of the path equals v_1 meters per second, and in the end it is v_2 meters per second. We know that this section of the route took exactly t seconds to pass.

Assuming that at each of the seconds the speed is constant, and between seconds the speed can change at most by d meters per second in absolute value (i.e., the difference in the speed of any two adjacent seconds does not exceed d in absolute value), find the maximum possible length of the path section in meters.


-----Input-----

The first line contains two integers v_1 and v_2 (1 ≤ v_1, v_2 ≤ 100) — the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively.

The second line contains two integers t (2 ≤ t ≤ 100) — the time when the car moves along the segment in seconds, d (0 ≤ d ≤ 10) — the maximum value of the speed change between adjacent seconds.

It is guaranteed that there is a way to complete the segment so that:  the speed in the first second equals v_1,  the speed in the last second equals v_2,  the absolute value of difference of speeds between any two adjacent seconds doesn't exceed d. 


-----Output-----

Print the maximum possible length of the path segment in meters. 


-----Examples-----
Input
5 6
4 2

Output
26
Input
10 10
10 0

Output
100


-----Note-----

In the first sample the sequence of speeds of Polycarpus' car can look as follows: 5, 7, 8, 6. Thus, the total path is 5 + 7 + 8 + 6 = 26 meters.

In the second sample, as d = 0, the car covers the whole segment at constant speed v = 10. In t = 10 seconds it covers the distance of 100 meters.","v1, v2 = map(int, input().split())
t, d = map(int, input().split())

max_speed = max(v1, v2)
min_speed = min(v1, v2)

max_length = max_speed * t
min_length = min_speed * t

for i in range(t-1, 0, -1):
    max_speed = max(max_speed - d, min_speed)
    min_speed = min(min_speed + d, max_speed)
    max_length += max_speed
    min_length += min_speed

print(max_length)
",,False,post,False,False,False,False,False,False,False,False,False,False,False,False,selected_pilot_75_apps_qwen_temp.json
280,apps,gpt-4o,qwen2.5-7b-instruct,"The on-board computer on Polycarp's car measured that the car speed at the beginning of some section of the path equals v_1 meters per second, and in the end it is v_2 meters per second. We know that this section of the route took exactly t seconds to pass.

Assuming that at each of the seconds the speed is constant, and between seconds the speed can change at most by d meters per second in absolute value (i.e., the difference in the speed of any two adjacent seconds does not exceed d in absolute value), find the maximum possible length of the path section in meters.


-----Input-----

The first line contains two integers v_1 and v_2 (1 ≤ v_1, v_2 ≤ 100) — the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively.

The second line contains two integers t (2 ≤ t ≤ 100) — the time when the car moves along the segment in seconds, d (0 ≤ d ≤ 10) — the maximum value of the speed change between adjacent seconds.

It is guaranteed that there is a way to complete the segment so that:  the speed in the first second equals v_1,  the speed in the last second equals v_2,  the absolute value of difference of speeds between any two adjacent seconds doesn't exceed d. 


-----Output-----

Print the maximum possible length of the path segment in meters. 


-----Examples-----
Input
5 6
4 2

Output
26
Input
10 10
10 0

Output
100


-----Note-----

In the first sample the sequence of speeds of Polycarpus' car can look as follows: 5, 7, 8, 6. Thus, the total path is 5 + 7 + 8 + 6 = 26 meters.

In the second sample, as d = 0, the car covers the whole segment at constant speed v = 10. In t = 10 seconds it covers the distance of 100 meters.","# Read input values
v1, v2 = map(int, input().split())
t, d = map(int, input().split())

# Initialize the list to store the speeds at each second
speeds = [0] * t

# Set the speed at the first second
speeds[0] = v1

# Set the speed at the last second
speeds[-1] = v2

# Calculate maximum possible speeds in between
for i in range(1, t):
    speeds[i] = min(speeds[i-1] + d, v2 + (t - i - 1) * d)

# Calculate total distance traveled
total_distance = sum(speeds)

# Print the result
print(total_distance)
",,False,post,True,False,True,False,False,False,False,False,False,False,False,False,selected_pilot_75_apps_qwen_temp.json
144,apps,llama3-70b,qwen2.5-7b-instruct,"Someone gave Alyona an array containing n positive integers a_1, a_2, ..., a_{n}. In one operation, Alyona can choose any element of the array and decrease it, i.e. replace with any positive integer that is smaller than the current one. Alyona can repeat this operation as many times as she wants. In particular, she may not apply any operation to the array at all.

Formally, after applying some operations Alyona will get an array of n positive integers b_1, b_2, ..., b_{n} such that 1 ≤ b_{i} ≤ a_{i} for every 1 ≤ i ≤ n. Your task is to determine the maximum possible value of mex of this array.

Mex of an array in this problem is the minimum positive integer that doesn't appear in this array. For example, mex of the array containing 1, 3 and 4 is equal to 2, while mex of the array containing 2, 3 and 2 is equal to 1.


-----Input-----

The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of elements in the Alyona's array.

The second line of the input contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9) — the elements of the array.


-----Output-----

Print one positive integer — the maximum possible value of mex of the array after Alyona applies some (possibly none) operations.


-----Examples-----
Input
5
1 3 3 3 6

Output
5

Input
2
2 1

Output
3



-----Note-----

In the first sample case if one will decrease the second element value to 2 and the fifth element value to 4 then the mex value of resulting array 1 2 3 3 4 will be equal to 5.

To reach the answer to the second sample case one must not decrease any of the array elements.","n = int(input())
arr = list(map(int, input().split()))
arr.sort()
mex = 1
for num in arr:
    if num == mex:
        mex += 1
    elif num > mex:
        break
print(mex)
",,False,post,False,False,True,False,False,False,False,False,False,False,False,False,selected_pilot_75_apps_qwen_temp.json
144,apps,gpt-4o,qwen2.5-7b-instruct,"Someone gave Alyona an array containing n positive integers a_1, a_2, ..., a_{n}. In one operation, Alyona can choose any element of the array and decrease it, i.e. replace with any positive integer that is smaller than the current one. Alyona can repeat this operation as many times as she wants. In particular, she may not apply any operation to the array at all.

Formally, after applying some operations Alyona will get an array of n positive integers b_1, b_2, ..., b_{n} such that 1 ≤ b_{i} ≤ a_{i} for every 1 ≤ i ≤ n. Your task is to determine the maximum possible value of mex of this array.

Mex of an array in this problem is the minimum positive integer that doesn't appear in this array. For example, mex of the array containing 1, 3 and 4 is equal to 2, while mex of the array containing 2, 3 and 2 is equal to 1.


-----Input-----

The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of elements in the Alyona's array.

The second line of the input contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9) — the elements of the array.


-----Output-----

Print one positive integer — the maximum possible value of mex of the array after Alyona applies some (possibly none) operations.


-----Examples-----
Input
5
1 3 3 3 6

Output
5

Input
2
2 1

Output
3



-----Note-----

In the first sample case if one will decrease the second element value to 2 and the fifth element value to 4 then the mex value of resulting array 1 2 3 3 4 will be equal to 5.

To reach the answer to the second sample case one must not decrease any of the array elements.","n = int(input())
a = list(map(int, input().split()))

# Sort the array
a.sort()

# Initialize the target mex value
mex = 1

# Iterate through the sorted array
for num in a:
    if num >= mex:
        mex += 1

# Print the maximum possible value of mex
print(mex)
",,False,post,True,False,True,True,True,False,False,False,False,True,True,True,selected_pilot_75_apps_qwen_temp.json
251,apps,llama3-70b,qwen2.5-7b-instruct,"As you know, every birthday party has a cake! This time, Babaei is going to prepare the very special birthday party's cake.

Simple cake is a cylinder of some radius and height. The volume of the simple cake is equal to the volume of corresponding cylinder. Babaei has n simple cakes and he is going to make a special cake placing some cylinders on each other.

However, there are some additional culinary restrictions. The cakes are numbered in such a way that the cake number i can be placed only on the table or on some cake number j where j < i. Moreover, in order to impress friends Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j.

Babaei wants to prepare a birthday cake that has a maximum possible total volume. Help him find this value.


-----Input-----

The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of simple cakes Babaei has.

Each of the following n lines contains two integers r_{i} and h_{i} (1 ≤ r_{i}, h_{i} ≤ 10 000), giving the radius and height of the i-th cake.


-----Output-----

Print the maximum volume of the cake that Babaei can make. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.

Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if $\frac{|a - b|}{\operatorname{max}(1, b)} \leq 10^{-6}$.


-----Examples-----
Input
2
100 30
40 10

Output
942477.796077000

Input
4
1 1
9 7
1 4
10 7

Output
3983.539484752



-----Note-----

In first sample, the optimal way is to choose the cake number 1.

In second sample, the way to get the maximum volume is to use cakes with indices 1, 2 and 4.","import math

n = int(input())
cakes = []
for _ in range(n):
    r, h = map(int, input().split())
    cakes.append((math.pi * r * r * h, r, h))

cakes.sort(reverse=True)

dp = [0.0] * n
dp[0] = cakes[0][0]

for i in range(1, n):
    dp[i] = cakes[i][0]
    for j in range(i):
        if cakes[i][1] < cakes[j][1] and cakes[i][2] < cakes[j][2]:
            dp[i] = max(dp[i], dp[j] + cakes[i][0])

print(dp[-1])
",,False,post,False,True,True,False,True,False,True,True,True,True,True,True,selected_pilot_75_apps_qwen_temp.json
251,apps,gpt-4o,qwen2.5-7b-instruct,"As you know, every birthday party has a cake! This time, Babaei is going to prepare the very special birthday party's cake.

Simple cake is a cylinder of some radius and height. The volume of the simple cake is equal to the volume of corresponding cylinder. Babaei has n simple cakes and he is going to make a special cake placing some cylinders on each other.

However, there are some additional culinary restrictions. The cakes are numbered in such a way that the cake number i can be placed only on the table or on some cake number j where j < i. Moreover, in order to impress friends Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j.

Babaei wants to prepare a birthday cake that has a maximum possible total volume. Help him find this value.


-----Input-----

The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of simple cakes Babaei has.

Each of the following n lines contains two integers r_{i} and h_{i} (1 ≤ r_{i}, h_{i} ≤ 10 000), giving the radius and height of the i-th cake.


-----Output-----

Print the maximum volume of the cake that Babaei can make. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.

Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if $\frac{|a - b|}{\operatorname{max}(1, b)} \leq 10^{-6}$.


-----Examples-----
Input
2
100 30
40 10

Output
942477.796077000

Input
4
1 1
9 7
1 4
10 7

Output
3983.539484752



-----Note-----

In first sample, the optimal way is to choose the cake number 1.

In second sample, the way to get the maximum volume is to use cakes with indices 1, 2 and 4.","import sys
import math
input = sys.stdin.read

def max_cake_volume(n, cakes):
    volumes = [(math.pi * r * r * h) for r, h in cakes]
    dp = [0] * n
    
    for i in range(n):
        dp[i] = volumes[i]
        for j in range(i):
            if volumes[j] < volumes[i]:
                dp[i] = max(dp[i], dp[j] + volumes[i])
                
    return max(dp)

def main():
    data = input().split()
    n = int(data[0])
    cakes = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n)]
    result = max_cake_volume(n, cakes)
    print(f""{result:.6f}"")

if __name__ == ""__main__"":
    main()
",,False,post,False,True,True,True,True,False,True,True,True,True,True,True,selected_pilot_75_apps_qwen_temp.json
293,apps,llama3-70b,qwen2.5-7b-instruct,"Amr bought a new video game ""Guess Your Way Out!"". The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height h. The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node. 

Let's index all the leaf nodes from the left to the right from 1 to 2^{h}. The exit is located at some node n where 1 ≤ n ≤ 2^{h}, the player doesn't know where the exit is so he has to guess his way out!

Amr follows simple algorithm to choose the path. Let's consider infinite command string ""LRLRLRLRL..."" (consisting of alternating characters 'L' and 'R'). Amr sequentially executes the characters of the string using following rules:  Character 'L' means ""go to the left child of the current node"";  Character 'R' means ""go to the right child of the current node"";  If the destination node is already visited, Amr skips current command, otherwise he moves to the destination node;  If Amr skipped two consecutive commands, he goes back to the parent of the current node before executing next command;  If he reached a leaf node that is not the exit, he returns to the parent of the current node;  If he reaches an exit, the game is finished. 

Now Amr wonders, if he follows this algorithm, how many nodes he is going to visit before reaching the exit?


-----Input-----

Input consists of two integers h, n (1 ≤ h ≤ 50, 1 ≤ n ≤ 2^{h}).


-----Output-----

Output a single integer representing the number of nodes (excluding the exit node) Amr is going to visit before reaching the exit by following this algorithm.


-----Examples-----
Input
1 2

Output
2
Input
2 3

Output
5
Input
3 6

Output
10
Input
10 1024

Output
2046


-----Note-----

A perfect binary tree of height h is a binary tree consisting of h + 1 levels. Level 0 consists of a single node called root, level h consists of 2^{h} nodes called leaves. Each node that is not a leaf has exactly two children, left and right one. 

Following picture illustrates the sample test number 3. Nodes are labeled according to the order of visit.

[Image]","h, n = map(int, input().split())
ans = 0
while n > 1:
    if n % 2 == 0:
        ans += (n // 2) - 1
    else:
        ans += n // 2
    n //= 2
print(ans)
",,False,post,False,False,False,False,False,False,False,False,False,False,False,False,selected_pilot_75_apps_qwen_temp.json
293,apps,gpt-4o,qwen2.5-7b-instruct,"Amr bought a new video game ""Guess Your Way Out!"". The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height h. The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node. 

Let's index all the leaf nodes from the left to the right from 1 to 2^{h}. The exit is located at some node n where 1 ≤ n ≤ 2^{h}, the player doesn't know where the exit is so he has to guess his way out!

Amr follows simple algorithm to choose the path. Let's consider infinite command string ""LRLRLRLRL..."" (consisting of alternating characters 'L' and 'R'). Amr sequentially executes the characters of the string using following rules:  Character 'L' means ""go to the left child of the current node"";  Character 'R' means ""go to the right child of the current node"";  If the destination node is already visited, Amr skips current command, otherwise he moves to the destination node;  If Amr skipped two consecutive commands, he goes back to the parent of the current node before executing next command;  If he reached a leaf node that is not the exit, he returns to the parent of the current node;  If he reaches an exit, the game is finished. 

Now Amr wonders, if he follows this algorithm, how many nodes he is going to visit before reaching the exit?


-----Input-----

Input consists of two integers h, n (1 ≤ h ≤ 50, 1 ≤ n ≤ 2^{h}).


-----Output-----

Output a single integer representing the number of nodes (excluding the exit node) Amr is going to visit before reaching the exit by following this algorithm.


-----Examples-----
Input
1 2

Output
2
Input
2 3

Output
5
Input
3 6

Output
10
Input
10 1024

Output
2046


-----Note-----

A perfect binary tree of height h is a binary tree consisting of h + 1 levels. Level 0 consists of a single node called root, level h consists of 2^{h} nodes called leaves. Each node that is not a leaf has exactly two children, left and right one. 

Following picture illustrates the sample test number 3. Nodes are labeled according to the order of visit.

[Image]","def main():
    import sys
    input = sys.stdin.read
    h, n = map(int, input().split())

    # Calculate the total number of leaf nodes
    total_leaves = 2 ** h

    # Track the number of visited nodes
    visited_count = 0

    # Binary representation of the path to the exit node
    path = bin(n - 1)[2:].zfill(h)

    current_level = 0
    current_node = 0  # Represent the root node

    # Simulate the traversal
    for direction in path:
        visited_count += 1
        if direction == '0':
            current_node = 2 * current_node + 1  # Move to the left child
        else:
            current_node = 2 * current_node + 2  # Move to the right child

    # Total nodes visited (excluding the exit node itself)
    print(visited_count)

if __name__ == ""__main__"":
    main()
",,False,post,False,False,False,False,False,False,False,False,False,False,False,False,selected_pilot_75_apps_qwen_temp.json
82,apps,llama3-70b,qwen2.5-7b-instruct,"Neko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.

Neko has two integers $a$ and $b$. His goal is to find a non-negative integer $k$ such that the least common multiple of $a+k$ and $b+k$ is the smallest possible. If there are multiple optimal integers $k$, he needs to choose the smallest one.

Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?


-----Input-----

The only line contains two integers $a$ and $b$ ($1 \le a, b \le 10^9$).


-----Output-----

Print the smallest non-negative integer $k$ ($k \ge 0$) such that the lowest common multiple of $a+k$ and $b+k$ is the smallest possible.

If there are many possible integers $k$ giving the same value of the least common multiple, print the smallest one.


-----Examples-----
Input
6 10

Output
2
Input
21 31

Output
9
Input
5 10

Output
0


-----Note-----

In the first test, one should choose $k = 2$, as the least common multiple of $6 + 2$ and $10 + 2$ is $24$, which is the smallest least common multiple possible.","import math

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

a, b = map(int, input().split())

k = 0
min_lcm = lcm(a, b)

while True:
    if lcm(a + k, b + k) < min_lcm:
        min_lcm = lcm(a + k, b + k)
    else:
        break
    k += 1

print(k - 1)
",,False,post,False,False,False,False,False,False,False,False,False,False,False,False,selected_pilot_75_apps_qwen_temp.json
82,apps,gpt-4o,qwen2.5-7b-instruct,"Neko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.

Neko has two integers $a$ and $b$. His goal is to find a non-negative integer $k$ such that the least common multiple of $a+k$ and $b+k$ is the smallest possible. If there are multiple optimal integers $k$, he needs to choose the smallest one.

Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?


-----Input-----

The only line contains two integers $a$ and $b$ ($1 \le a, b \le 10^9$).


-----Output-----

Print the smallest non-negative integer $k$ ($k \ge 0$) such that the lowest common multiple of $a+k$ and $b+k$ is the smallest possible.

If there are many possible integers $k$ giving the same value of the least common multiple, print the smallest one.


-----Examples-----
Input
6 10

Output
2
Input
21 31

Output
9
Input
5 10

Output
0


-----Note-----

In the first test, one should choose $k = 2$, as the least common multiple of $6 + 2$ and $10 + 2$ is $24$, which is the smallest least common multiple possible.","import math

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def lcm(x, y):
    return x * y // gcd(x, y)

def find_min_k(a, b):
    if a == b:
        return 0

    diff = abs(a - b)
    min_lcm = float('inf')
    min_k = 0

    for k in range(1, int(math.sqrt(diff)) + 1):
        if diff % k == 0:
            # Check both k and diff // k as possible values for the smallest k
            for candidate in [k, diff // k]:
                new_a = (a + candidate - 1) // candidate * candidate
                new_b = (b + candidate - 1) // candidate * candidate
                current_lcm = lcm(new_a, new_b)
                if current_lcm < min_lcm or (current_lcm == min_lcm and candidate < min_k):
                    min_lcm = current_lcm
                    min_k = candidate

    return min_k

if __name__ == ""__main__"":
    import sys
    input = sys.stdin.read
    data = input().strip().split()
    a = int(data[0])
    b = int(data[1])
    print(find_min_k(a, b))
",,True,post,False,False,False,False,True,True,False,False,False,True,True,True,selected_pilot_75_apps_qwen_temp.json
