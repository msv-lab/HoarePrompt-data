
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given string $s$ of length $n$ consisting of 0-s and 1-s. You build an infinite string $t$ as a concatenation of an infinite number of strings $s$, or $t = ssss \dots$ For example, if $s =$ 10010, then $t =$ 100101001010010...

Calculate the number of prefixes of $t$ with balance equal to $x$. The balance of some string $q$ is equal to $cnt_{0, q} - cnt_{1, q}$, where $cnt_{0, q}$ is the number of occurrences of 0 in $q$, and $cnt_{1, q}$ is the number of occurrences of 1 in $q$. The number of such prefixes can be infinite; if it is so, you must say that.

A prefix is a string consisting of several first letters of a given string, without any reorders. An empty prefix is also a valid prefix. For example, the string "abcd" has 5 prefixes: empty string, "a", "ab", "abc" and "abcd".


-----Input-----

The first line contains the single integer $T$ ($1 \le T \le 100$) — the number of test cases.

Next $2T$ lines contain descriptions of test cases — two lines per test case. The first line contains two integers $n$ and $x$ ($1 \le n \le 10^5$, $-10^9 \le x \le 10^9$) — the length of string $s$ and the desired balance, respectively.

The second line contains the binary string $s$ ($|s| = n$, $s_i \in \{\text{0}, \text{1}\}$).

It's guaranteed that the total sum of $n$ doesn't exceed $10^5$.


-----Output-----

Print $T$ integers — one per test case. For each test case print the number of prefixes or $-1$ if there is an infinite number of such prefixes.


-----Example-----
Input
4
6 10
010010
5 3
10101
1 0
0
2 0
01

Output
3
0
1
-1



-----Note-----

In the first test case, there are 3 good prefixes of $t$: with length $28$, $30$ and $32$.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: T is a positive integer (1 <= T <= 100) representing the number of test cases. Each test case consists of two values: n is a positive integer (1 <= n <= 100000) representing the length of the binary string s, and x is an integer (-10^9 <= x <= 10^9) representing the desired balance. The binary string s is of length n and consists only of characters '0' and '1'. The total length of all strings s across test cases does not exceed 100000.
def func():
    T = int(input())
    for _ in range(T):
        n, x = map(int, input().split())
        
        s = input()
        
        cnt0, cnt1 = s.count('0'), s.count('1')
        
        balance = cnt0 - cnt1
        
        if balance == x:
            print(n + 1)
        elif (x - balance) % (cnt0 - cnt1) == 0:
            print(-1)
        else:
            print((x - balance) // (cnt0 - cnt1) + 1)
        
    #State of the program after the  for loop has been executed: `T` is a positive integer (greater than 0), `n` is the input integer for the last test case, `x` is the input integer for the last test case, `s` is the input string for the last test case, `cnt0` is the count of '0' in `s`, `cnt1` is the count of '1' in `s`, and `balance` is equal to `cnt0 - cnt1`. For each test case, if `balance` equals `x`, then `n + 1` is printed. If `balance` does not equal `x` and `(x - balance)` is divisible by `(cnt0 - cnt1)`, then -1 is printed; otherwise, the printed result is `(x - balance) // (cnt0 - cnt1) + 1`. If no test cases are processed, `n`, `x`, `cnt0`, `cnt1`, and `balance` remain undefined.
#Overall this is what the function does:The function accepts multiple test cases, where each test case includes a positive integer `n` (the length of a binary string `s`), an integer `x` (the desired balance), and a binary string `s` consisting of '0's and '1's. It calculates the balance as the difference between the count of '0's and '1's in `s`. The function prints `n + 1` if the balance equals `x`. If the balance does not equal `x` and the difference `x - balance` is divisible by `cnt0 - cnt1` (where `cnt0` is the count of '0's and `cnt1` is the count of '1's), it prints `-1`. Otherwise, it prints the result of `(x - balance) // (cnt0 - cnt1) + 1`. The function does not handle cases where `cnt0` equals `cnt1` and `x` differs from `balance`, which could lead to division by zero.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
