To determine the correctness of the provided program, we first analyze the problem description and the code.

**Problem description:** The function should check whether the given list contains consecutive numbers or not.

**Program:**
```python
def func_1(lst):
    if not lst:
        return False
    lst_sorted = sorted(lst)
    for i in range(len(lst_sorted) - 1):
        if lst_sorted[i + 1] - lst_sorted[i] != 1:
            return False
    return True
```

The function checks if the list is empty, returns `False` if it is. It then sorts the list and checks if all consecutive elements differ by 1. If any two consecutive elements do not meet this criteria, it returns `False`. If the loop completes without finding any issues, it returns `True`.

Now, let's consider edge cases:
1. **Empty List:** The code correctly returns `False` for an empty list.
2. **Single Element List:** If the input list has only one element (e.g., `[3]`), the function will return `True` because there are no pairs to compare, which is not aligned with the typical understanding of consecutive numbers. According to the problem description, we should consider that a single number does not constitute consecutive numbers.
3. **Duplicates:** The code does not account for duplicates (e.g., `[1, 2, 2, 3]`), which should also return `False` since consecutive numbers must be unique.

**Output hints:** The hints clarify that the function should return `True` for a list with fewer than two elements, which contradicts the understanding that we need at least two distinct numbers for a consecutive sequence.

Given the considerations above, the code does not adhere to the problem description for all cases, particularly with single-element lists and duplicates.

Correctness: **False**.