Postcondition: ***`final_x` is equal to `x + (count_R - count_L)`; `final_y` is equal to `y + (count_U - count_D)`; if `operations[i]` is 'U', then `current_y` is increased by 1 and `target_pos` is equal to `(current_x + dx, current_y + dy + 1)` with `position_map[current_x, current_y]` now equal to `i`, and `i` is incremented by 1 (and must be less than `n`). If `operations[i]` is 'D', then `current_y` is decreased by 1, and `target_pos` remains as `(current_x + dx, current_y + dy)`, with `position_map[current_x, current_y]` now equal to `i`, and `i` is incremented by 1 (and must be less than `n`). If `operations[i]` is 'L', then `target_pos` is `(current_x - 1 + dx, current_y + dy)`, and `current_x` is decremented by 1 while `position_map[current_x, current_y]` is updated to `i`, and `i` is incremented by 1 (and must be less than `n`). Otherwise, if `operations[i]` is 'R', then `target_pos` is `(current_x + dx, current_y + dy)`, and `current_x` is updated to `current_x + 1`, while `position_map[current_x, current_y]` is equal to `i` and `i` is incremented by 1 (and must be less than `n`).***