Correctness: **False**

The program does not work correctly for all potential cases. 

For example, when the input string `s` is longer than the number of rotations `n`, the program will not work as expected. This is because the program creates a new string `s` by repeating the original string `s` enough times to cover the number of rotations `n`. However, if `s` is already longer than `n`, this repetition is unnecessary and will cause the program to count the number of odd values in the repeated string instead of the original string.

For instance, if `s = '101010'` and `n = 3`, the program will repeat `s` to get `'101010101010'` and then count the number of odd values in this repeated string, which is not the expected behavior.

To fix this issue, the program should only repeat the string `s` if `n` is greater than the length of `s`. Here is the corrected code:

```python
def func_1(s, n):
    if n > len(s):
        s = s * (n // len(s) + 1)
    count = 0
    for i in range(n):
        temp = s[i:i + len(s)]
        count += temp.count('1') % 2
    return count
```

However, even with this correction, the program can still be optimized and simplified. The current implementation has a time complexity of O(n^2) due to the repeated string concatenation and counting operations. A more efficient solution would be to count the number of odd values in the original string and then multiply it by the number of rotations, which would have a time complexity of O(n). 

Here is a more efficient and correct implementation:

```python
def func_1(s, n):
    count = s.count('1') % 2
    return (count * (n // len(s))) + (s[:n % len(s)].count('1') % 2)
```