Correctness: **True**

The program is correct because it meets all the requirements specified in the problem description. Here's why:

1. The program takes a non-empty string `s` of length at most 50 characters, containing only lowercase English letters, as input.
2. It initializes `max_len` to 0, which will store the length of the longest non-palindrome substring of `s`.
3. The program uses two nested loops to generate all possible substrings of `s`. For each substring, it checks if it is a palindrome by comparing it with its reverse (`substr[::-1]`).
4. If a substring is not a palindrome, it updates `max_len` with the maximum length found so far.
5. After checking all substrings, the program prints `max_len` if it is greater than 0, indicating that there is at least one non-palindrome substring in `s`. If `max_len` is 0, it means that all substrings of `s` are palindromes, and the program prints 0.

The program's logic is sound, and it handles all possible cases:

* If `s` is a palindrome, the program will correctly print 0, as all substrings of `s` will be palindromes.
* If `s` contains at least one non-palindrome substring, the program will find the longest one and print its length.
* The program handles edge cases, such as single-character strings (which are always palindromes) and strings with only one non-palindrome substring.

Overall, the program accurately implements the problem description and produces the correct output for all possible inputs.