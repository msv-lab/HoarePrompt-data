
You have been assigned the role of a program verifier, responsible for simulating the execution of Python code. You will be provided with a function description and a Python function code snippet. You need to provide if the code does what the function description says. Please avoid describing how the program runs. If the code satisfies the description reply CORRECT, otherwise reply INCORRECT with an explanation. You must adhere to the text format: RESULT: **Correct or Incorrect**.

Description: You are given a sequence a_1, a_2, ..., a_{n} of one-dimensional segments numbered 1 through n. Your task is to find two distinct indices i and j such that segment a_{i} lies within segment a_{j}.

Segment [l_1, r_1] lies within segment [l_2, r_2] iff l_1 ≥ l_2 and r_1 ≤ r_2.

Print indices i and j. If there are multiple answers, print any of them. If no answer exists, print -1 -1.


-----Input-----

The first line contains one integer n (1 ≤ n ≤ 3·10^5) — the number of segments.

Each of the next n lines contains two integers l_{i} and r_{i} (1 ≤ l_{i} ≤ r_{i} ≤ 10^9) — the i-th segment.


-----Output-----

Print two distinct indices i and j such that segment a_{i} lies within segment a_{j}. If there are multiple answers, print any of them. If no answer exists, print -1 -1.


-----Examples-----
Input
5
1 10
2 9
3 9
2 3
2 9

Output
2 1

Input
3
1 5
2 6
6 20

Output
-1 -1



-----Note-----

In the first example the following pairs are considered correct:  (2, 1), (3, 1), (4, 1), (5, 1) — not even touching borders;  (3, 2), (4, 2), (3, 5), (4, 5) — touch one border;  (5, 2), (2, 5) — match exactly.
Python Fucntion:
```
n = int(input())
segments = []

for i in range(n):
    l, r = map(int, input().split())
    segments.append((l, r, i + 1))

# Sort segments by starting point, and in case of tie by ending point in descending order
segments.sort(key=lambda x: (x[0], -x[1]))

# We will keep track of the maximum ending point seen so far
max_right = -1
max_index = -1

for l, r, index in segments:
    # If the current segment's end is less than or equal to max_right, it means
    # there is a segment that completely contains the current segment
    if r <= max_right:
        print(index, max_index)
        break
    # Update the maximum ending point and its index
    max_right = r
    max_index = index
else:
    # If no such pair is found
    print(-1, -1)

```
Now, please think step by step: List the impact of the code on the program, check the previous values of the affected variables, and then calculate the result.
Use the format: RESULT: **Correct or Incorrect**.
