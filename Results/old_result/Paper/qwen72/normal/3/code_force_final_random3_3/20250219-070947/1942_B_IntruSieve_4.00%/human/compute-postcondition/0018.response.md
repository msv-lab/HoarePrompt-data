The only variables in the loop head are `i` and `n`, so we can only adjust those. According to the code, whether the loop can execute again depends on the value of `i` being less than `n`. At the end of the last iteration, `i` is 0 and `n` is greater than 0. After the iteration, `i` will be incremented by 1, so `i` will be 1. For the loop to execute one more time, `n` must still be greater than `i`, which means `n` must be greater than 1.

State: **`n` is greater than 1, `i` is 1, `t` is an integer representing the number of test cases (1 ≤ t ≤ 10^4), `test_cases` is a list of tuples, each containing an integer `n` (1 ≤ n ≤ 2 · 10^5) and a list `a` of `n` integers (-n ≤ a_i ≤ n), `arr` is a list of integers input by the user, `mex` is a list containing either [0] or the value `abs(arr[0] - minn)`, `minn` is either 1 or 0, and `maxx` is either 0 or `abs(arr[0] - minn)`. If `arr[0]` is greater than 0, `mex` is [0], `minn` is 1, and `maxx` is 0. If `arr[0]` is less than or equal to 0, `mex` is [abs(arr[0] - minn)], `minn` is 0, and `maxx` is either `abs(arr[0] - minn)` if `abs(arr[0] - minn)` is greater than the initial `maxx`, or remains the initial `maxx` otherwise.**