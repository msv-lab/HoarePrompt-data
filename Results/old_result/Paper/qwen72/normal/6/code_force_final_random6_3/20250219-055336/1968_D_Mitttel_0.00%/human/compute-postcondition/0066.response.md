Postcondition: ***`start_pos` is a positive integer such that 1 <= `start_pos` <= `n`, `score` is the sum of the elements at the positions `current_pos - 1` in the list `a` for each step taken, `current_pos` is the final position after `k` steps or when a cycle is detected, `steps` is `k` or the number of steps taken until a cycle is detected, `visited` is a dictionary with keys representing the positions visited and their values representing the step at which they were visited. If `cycle_start` is not -1, `cycle_length` is greater than 0, `cycle_score` is incremented by the value of `a[cycle_pos - 1]` for each iteration, `cycle_pos` is updated to `p[cycle_pos - 1]` after each iteration, the loop executes `cycle_length` times, `remaining_steps` is `k - steps`, `full_cycles` is `remaining_steps // cycle_length`, `remainder_steps` is `remaining_steps % cycle_length` and must be greater than or equal to 0, `score` is increased by `full_cycles * cycle_score` and the sum of `a[current_pos - 1]` for the first `remainder_steps` iterations, `current_pos` is updated to `p[current_pos - 1]` after the first `remainder_steps` iterations. If `cycle_start` is -1, the program state remains unchanged.***