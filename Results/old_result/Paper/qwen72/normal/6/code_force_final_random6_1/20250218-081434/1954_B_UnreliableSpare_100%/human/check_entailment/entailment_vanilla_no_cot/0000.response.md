Correctness: **False**

The given program does not correctly solve the problem for all cases. The logic for determining the minimum number of elements to remove to make the array non-beautiful is flawed. Here's a detailed explanation:

1. **Check for All Identical Elements**:
   - The program correctly identifies if all elements in the array are identical and prints `-1` in such cases. This is correct because an array of identical elements will always remain beautiful no matter how many elements are removed.

2. **Logic for Finding Minimum Removals**:
   - The program attempts to find the minimum number of elements to remove by counting the number of consecutive elements equal to the first element (`arr[0]`). It then takes the minimum of these counts as the answer.
   - This approach is incorrect because it only considers the first element and does not account for other possible elements that could be used to make the array non-beautiful.

3. **Correct Approach**:
   - To determine the minimum number of elements to remove to make the array non-beautiful, you need to consider the structure of the array and the conditions under which it remains beautiful.
   - A beautiful array can be made non-beautiful by breaking the pattern of equal elements at positions `i-1` and `i+1` for some `i` where `2 <= i <= n-1`.

Here is a corrected version of the program:

```python
def func_1():
    n = int(input())
    arr = list(map(int, input().split()))
    
    # Check if all elements are the same
    if len(set(arr)) == 1:
        print(-1)
        return
    
    # Check if the array is already non-beautiful
    for i in range(1, n - 1):
        if arr[i] != arr[i - 1] and arr[i] != arr[i + 1]:
            print(0)
            return
    
    # Find the minimum number of elements to remove
    ans = float('inf')
    for i in range(1, n - 1):
        if arr[i] == arr[i - 1] or arr[i] == arr[i + 1]:
            continue
        # Count the number of elements to remove to break the beauty
        left = i - 1
        right = i + 1
        while left >= 0 and right < n and arr[left] == arr[right]:
            left -= 1
            right += 1
        ans = min(ans, right - left - 1)
    
    if ans == float('inf'):
        print(-1)
    else:
        print(ans)

if __name__ == '__main__':
    for _ in range(int(input())):
        func_1()
```

### Explanation of the Corrected Program:
1. **Check for All Identical Elements**:
   - If all elements in the array are the same, print `-1` and return.

2. **Check if the Array is Already Non-Beautiful**:
   - If there is any element `arr[i]` (where `1 <= i <= n-2`) that is different from both `arr[i-1]` and `arr[i+1]`, the array is already non-beautiful, and the answer is `0`.

3. **Find the Minimum Number of Elements to Remove**:
   - For each element `arr[i]` (where `1 <= i <= n-2`), if it is equal to either `arr[i-1]` or `arr[i+1]`, continue to the next element.
   - Otherwise, count the number of elements to remove to break the beauty pattern by expanding around `arr[i]` and finding the minimum length of the segment that needs to be removed.

This corrected program should handle all the cases correctly as per the problem description.