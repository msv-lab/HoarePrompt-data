Correctness: **False**

Explanation:
The program has a logical error in how it calculates the satisfaction percentage for the left and right sides. Specifically, the lines:

```python
zero_perc = math.ceil(zero * 100 / (i + 1))
one_perc = math.ceil((o - one) * 100 / (n - i - 1))
```

These lines calculate the percentage of satisfied residents, but they do not correctly implement the requirement that "at least half of the residents on each side of the village are satisfied." Instead, they calculate the percentage of zeros and ones, which is not the same as checking if at least half of the residents are satisfied.

The correct check should be:

- For the left side: `zero >= math.ceil((i + 1) / 2)`
- For the right side: `(o - one) >= math.ceil((n - i - 1) / 2)`

Additionally, the program does not handle the edge cases correctly, such as when the road should be placed before the first house or after the last house. The logic for these cases is not robust enough.

Here is a corrected version of the function:

```python
import math

def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        s = input()
        if n % 2 == 0:
            pk = n // 2
        else:
            pk = n // 2
        sl = list(s)
        o = sl.count('1')
        z = sl.count('0')
        (zero, one) = (0, 0)
        lst = []
        mini = float('inf')
        for i in range(n + 1):  # Consider placing the road before the first house and after the last house
            if i > 0:
                if s[i-1] == '0':
                    zero += 1
                else:
                    one += 1
            if zero >= math.ceil((i) / 2) and (o - one) >= math.ceil((n - i) / 2):
                lst.append(i)
            if i < n:
                if s[i] == '0':
                    zero -= 1
                else:
                    one -= 1
        for ele in lst:
            mini = min(mini, abs(pk - ele))
        final = []
        for elem in lst:
            if abs(pk - elem) == mini:
                final.append(elem)
        final.sort()
        if len(final) == 0:
            c1 = o * 100 // n
            if c1 >= 50:
                final.append(0)
            else:
                final.append(n)
        print(final[0])
```

This corrected version ensures that the conditions for satisfaction are correctly checked and handles edge cases properly.