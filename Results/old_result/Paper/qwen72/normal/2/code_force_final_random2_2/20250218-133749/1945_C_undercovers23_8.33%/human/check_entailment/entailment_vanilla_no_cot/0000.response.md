Correctness: **False**

Explanation:

The provided solution has a few issues that prevent it from being correct:

1. **Incorrect Percentage Calculation**: The code calculates the percentage of zeros and ones on each side of the road using `math.ceil(zero * 100 / (i + 1))` and `math.ceil((o - one) * 100 / (n - i - 1))`. However, the problem requires checking if at least half of the residents on each side are satisfied, not their percentage. The correct condition should be:
   - For the left side: `zero >= (i + 1) // 2`
   - For the right side: `(o - one) >= (n - i - 1) // 2`

2. **Handling Edge Cases**: The code does not handle the edge cases where the road is placed before the first house or after the last house correctly. Specifically, it should check if placing the road before the first house or after the last house satisfies the conditions.

3. **Optimization and Clarity**: The code can be optimized and made more readable by simplifying the logic and directly checking the conditions without unnecessary calculations.

Here is a corrected version of the code:

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        s = input()
        
        # Count the total number of 1s and 0s
        o = s.count('1')
        z = s.count('0')
        
        # Initialize prefix sums for 0s and 1s
        zero = 0
        one = 0
        
        # List to store valid positions
        valid_positions = []
        
        # Check positions from 0 to n-1
        for i in range(n):
            if i > 0:
                if s[i-1] == '0':
                    zero += 1
                else:
                    one += 1
            
            # Calculate remaining 1s and 0s
            remaining_zero = z - zero
            remaining_one = o - one
            
            # Check conditions for the left and right sides
            left_satisfied = zero >= (i + 1) // 2
            right_satisfied = remaining_one >= (n - i - 1) // 2
            
            if left_satisfied and right_satisfied:
                valid_positions.append(i)
        
        # Add edge cases
        if o >= n // 2:
            valid_positions.append(0)
        if z >= n // 2:
            valid_positions.append(n)
        
        # Find the position closest to the middle
        mid = n // 2
        valid_positions.sort(key=lambda x: abs(mid - x))
        
        # Output the smallest valid position
        print(valid_positions[0])

func()
```

This corrected version ensures that the conditions are checked correctly and handles edge cases properly. It also optimizes the logic for clarity and efficiency.