
Given a Python loop, an initial execution state, and the output states after the first 3 iterations of the loop, determine the output state after all the executions of the loop have finished. 

You must adhere to the text format: Output State: **output state.**

Initial State: The function `func` is intended to interact with a predefined interactor that manages the graph and responses. The graph is a complete undirected graph with `n` vertices, from which exactly `(n - 2)` edges have been removed. The function can handle multiple test cases, where the number of test cases `t` satisfies \(1 \le t \le 1000\), and for each test case, `n` satisfies \(2 \le n \le 10^5\). The sum of `n` over all test cases does not exceed \(10^5\). The function can make up to `n` queries of the form "? d" to the interactor, where `d` is an integer such that \(0 \le d \le n - 1\). The interactor responds with two integers representing a vertex and another vertex not connected to it, or "0 0" if no such vertex exists. The function must output a Hamiltonian path in the form "! v_1 v_2 ... v_n" and flush the output buffer after each query and answer. The variable `q` is now a function that sends a query to the interactor with the given distance `d` and returns the response as a map of integers.
Code of the loop:
for _ in range(int(input())):
    vx, ops = set(i for i in range(1, int(input()) + 1)), []
    while len(vx) > 2:
        v1, v2 = q(len(vx) - 2)
        vx.remove(v1)
        if v2 > 0:
            ops += [(v1, v2)]
        else:
            v3, _ = q(0)
            vx.remove(v3)
            ops += [(v3, 0), (v1, 0)]
    p1, p2 = list(vx), []
    for v1, v2 in ops[::-1]:
        (p2 if p1[-1] == v2 else p1).append(v1)
    print('! %s' % ' '.join(map(str, p1[::-1] + p2)), flush=True)


The output state after the loop executes the first 3 of times includes what needed to be true for the loop to execute at least that number of times:

Output State after the loop executes 1 time: `p1` is a list containing all integers from the set `vx` plus any `v1` values appended from `ops` where `p1[-1] != v2`, `p2` is a list containing any `v1` values appended from `ops` where `p1[-1] == v2`, `vx` is a set containing exactly 2 integers from the original set of integers from 1 to `int(input())` inclusive, `ops` is a list of tuples representing the operations performed during each iteration.

**Output State after the loop executes 2 times**: `vx` is a set containing exactly 2 integers from the original set of integers from 1 to `int(input())` inclusive, `ops` is a list containing tuples based on the value of `v2` for each iteration, `p1` is a list containing the two integers from `vx` and all `v1` values from the tuples in `ops` where `p1[-1]` was not equal to `v2` at the start of the iteration, `p2` is a list containing all `v1` values from the tuples in `ops` where `p1[-1]` was equal to `v2` at the start of the iteration, `int(input())` must be greater than 1.

**Output State after the loop executes 3 times**: `vx` is a set containing the last two integers that were not removed during the loop iterations. `ops` is a list containing tuples representing the operations performed during the loop. `p1` is a list containing the two integers from `vx`, plus any integers from `ops` that were appended to `p1` because `p1[-1]` was not equal to `v2` at the time of the operation. `p2` is a list containing any integers from `ops` that were appended to `p2` because `p1[-1]` was equal to `v2` at the time of the operation.




What is the ouput state after the loop executes all the iterations? Change the values of only the variables in the loop head and body.The state of the other variables in the precondition that are not affected by the loop head and body must remain unchanged.
In your response strictly use the format: Output State: **the output state you calculate.**, and describe this output state in Natural language easily understandable by humans.

