Reasoning:

1. **Input Reading**: The function correctly reads the number of test cases `t` and for each test case, it reads the number of cells `n` and the string `arr` representing the ribbon. This part is correct.

2. **Finding the First and Last Chip Positions**:
   - `x = arr.find('1')` finds the index of the first chip (1) in the ribbon.
   - `y = arr[::-1].find('1')` finds the index of the last chip (1) in the ribbon by reversing the string and finding the first occurrence of '1'. This is a bit indirect but works correctly because `y` will be the distance from the end of the string to the last chip, which can be used to find the index of the last chip in the original string.

3. **Extracting the Substring**:
   - `z = arr[x:n - y]` extracts the substring from the first chip to the last chip. This is correct because `x` is the starting index and `n - y` is the ending index (since `y` is the distance from the end).

4. **Counting Free Cells**:
   - `print(z.count('0'))` counts the number of free cells (0) in the extracted substring and prints it. This is the correct approach because the number of free cells between the first and last chip is the minimum number of moves required to form a single block of chips.

5. **Edge Cases**:
   - The function handles cases where all chips are already in a single block by printing 0, which is correct.
   - The function also handles cases where there is only one chip by printing 0, which is correct.

6. **General Behavior**:
   - The function correctly processes each test case independently and prints the result for each one.

Given the above reasoning, the program appears to correctly solve the problem as described.

Correctness: **True**