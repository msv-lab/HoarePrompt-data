### Reasoning:

1. **Initialization and Input Reading:**
   - The function reads the number of test cases `t` and iterates over each test case.
   - For each test case, it reads the length of the array `n` and the array `ar` itself.
   - This part is correct and follows the problem description.

2. **Tracking Consecutive Elements:**
   - The variable `same` is initialized to 1, which will be used to count the number of consecutive elements that are the same.
   - The variable `num` is initialized to the first element of the array `ar[0]`.
   - The variable `minn` is initialized to infinity (`inf`), which will be used to track the minimum length of any contiguous subarray of the same element.

3. **Iterating Through the Array:**
   - The loop iterates through the array `ar` starting from the second element.
   - If the current element `ar[i]` is the same as `num`, `same` is incremented.
   - If the current element `ar[i]` is different from `num`, the index `i` is incremented by 1, `num` is updated to the new current element, and `minn` is updated to the minimum of `minn` and `same`.
   - `same` is reset to 1 for the new subarray.

4. **Final Update of `minn`:**
   - After the loop, `minn` is updated to the minimum of `minn` and `same` to account for the last subarray of consecutive elements.

5. **Output:**
   - If `minn` is still infinity or equal to the length of the array `len(ar)`, it means that the array consists of identical elements, and it is impossible to make it non-beautiful by removing elements. Therefore, the function prints `-1`.
   - Otherwise, the function prints `minn`, which is the minimum number of elements that need to be removed to make the array non-beautiful.

### Analysis of the Logic:
- The logic correctly identifies the minimum length of any contiguous subarray of the same element.
- If the array consists entirely of the same element, the function correctly outputs `-1` because removing any number of elements will still leave the array beautiful.
- If the array has at least one different element, the function correctly outputs the minimum number of elements that need to be removed to break the beauty condition.

### Potential Issues:
- The logic does not handle the case where the array has only one element. According to the problem, if the array has only one element, it is guaranteed to be beautiful, and it is impossible to make it non-beautiful by removing elements. The function should output `-1` in this case.
- The logic does not correctly handle the case where the array has two elements. If the array has two elements and they are the same, it is also guaranteed to be beautiful, and it is impossible to make it non-beautiful by removing elements. The function should output `-1` in this case.

### Correctness:
- The function is correct for arrays with more than two elements.
- However, it fails to handle the edge cases where the array has one or two elements.

### Conclusion:
- The function is **not** correct for all possible inputs as described in the problem statement.

### Correctness: **False**