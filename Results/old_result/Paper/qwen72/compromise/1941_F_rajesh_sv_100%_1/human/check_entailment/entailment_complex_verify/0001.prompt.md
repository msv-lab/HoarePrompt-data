
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Rudolf has prepared a set of n problems with complexities a_1 < a_2 < a_3 <
\dots < a_n . He is not entirely satisfied with the balance, so he wants to
add at most one problem to fix it.

For this, Rudolf came up with m models of problems and k functions. The
complexity of the i -th model is d_i , and the complexity of the j -th
function is f_j . To create a problem, he selects values i and j (1 \le i \le
m , 1 \le j \le k ) and by combining the i -th model with the j -th function,
he obtains a new problem with complexity d_i + f_j (a new element is inserted
into the array a ).

To determine the imbalance of the set, Rudolf sorts the complexities of the
problems in ascending order and finds the largest value of a_i - a_{i - 1} (i
> 1 ).

What is the minimum value of imbalance that Rudolf can achieve by adding at
most one problem, created according to the described rules?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of testcases.

The first line of each test case contains three integers n , m , and k (2 \le
n \le 10^5 , 1 \le m, k \le 2 \cdot 10^5 ) — the number of prepared problems,
the number of models, and the number of functions, respectively.

The second line of each test case contains n integers a_1, a_2, a_3, \dots a_n
(1 \le a_i \le 2 \cdot 10^9 , a_i < a_{i+1} ) — the complexities of the
prepared problems.

The third line of each test case contains m integers d_1, d_2, d_3, \dots d_m
(1 \le d_i \le 10^9 ) — the complexities of the models.

The fourth line of each test case contains k integers f_1, f_2, f_3, \dots f_k
(1 \le f_i \le 10^9 ) — the complexities of the functions.

It is guaranteed that the sum of n over all testcases does not exceed 10^5 .

It is guaranteed that the sum of m over all testcases does not exceed 2 \cdot
10^5 .

It is guaranteed that the sum of k over all testcases does not exceed 2 \cdot
10^5 .

Output

For each testcase, output a single number — the minimum imbalance that Rudolf
can achieve.

Example

Input

    7
    
    5 5 5
    
    5 10 15 20 26
    
    11 14 16 13 8
    
    16 4 5 3 1
    
    7 6 5
    
    1 4 7 10 18 21 22
    
    2 3 5 7 4 2
    
    6 8 9 3 2
    
    7 6 5
    
    1 4 7 10 18 21 22
    
    2 3 5 7 4 2
    
    6 8 13 3 2
    
    5 6 3
    
    2 10 13 20 25
    
    11 6 10 16 14 5
    
    6 17 15
    
    4 2 2
    
    11 12 14 15
    
    19 14
    
    10 6
    
    8 4 2
    
    3 10 16 18 21 22 29 30
    
    9 13 16 15
    
    4 2
    
    2 4 7
    
    4 21
    
    4 15 14 5
    
    20 1 15 1 12 5 11

Output

    5
    4
    5
    8
    2
    7
    11

- Program: 
from collections import *
from math import *
from heapq import *
from bisect import *
import sys
from os import path
#Function 1:
def func_1(func):
    d = {}

    return wrapper

#Function 2:
def wrapper(*args):
    if args not in d:
        d[args] = func(*args)
    return d[args]

#Function 3:
def func_2():
    return sys.stdin.readline().strip()

#Function 4:
def func_3():
    return int(func_2())

#Function 5:
def func_4(delimiter=' '):
    return list(map(int, func_2().split(delimiter)))

#Function 6:
def func_5():
    return func_2()

#Function 7:
def func_6():
    (n, m, k) = func_4()
    A = func_4()
    D = sorted(set(func_4()))
    F = func_4()
    (max_diff, next_max_diff, index) = (-inf, -inf, None)
    for i in range(1, n):
        diff = A[i] - A[i - 1]
        if diff > max_diff:
            next_max_diff = max_diff
            max_diff = diff
            index = i
        elif diff > next_max_diff:
            next_max_diff = diff
    (left, right) = (A[index - 1], A[index])
    ans = max_diff
    for f in F:
        l = bisect_right(D, left - f)
        h = bisect_left(D, right - f) - 1
        while l < h:
            mid = l + (h - l) // 2
            (mid_sum, mid_next_sum) = (D[mid] + f, D[mid + 1] + f)
            if mid_sum - left < right - mid_next_sum:
                l = mid + 1
            else:
                h = mid
        if l == h:
            ans = min(ans, max(D[l] + f - left, right - D[l] - f))
    print(max(ans, next_max_diff))

#Function 8:
def func_7():
    testcases = func_3()
    for _ in range(testcases):
        func_6()



- Annotated Code: 
from collections import *
from math import *
from heapq import *
from bisect import *
import sys
from os import path

class FenwickTree:

    def __init__(self, x):
        bit = self.bit = list(x)
        size = self.size = len(bit)
        for i in range(size):
            j = i | i + 1
            if j < size:
                bit[j] += bit[i]

    def update(self, idx, x):
        """updates bit[idx] += x"""
        while idx < self.size:
            self.bit[idx] += x
            idx |= idx + 1

    def __call__(self, end):
        """calc sum(bit[:end])"""
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x

    def find_kth(self, k):
        """Find largest idx such that sum(bit[:idx]) <= k"""
        idx = -1
        for d in reversed(range(self.size.bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < self.size and self.bit[right_idx] <= k:
                idx = right_idx
                k -= self.bit[idx]
        return (idx + 1, k)
class SortedList:
    block_size = 700

    def __init__(self, iterable=()):
        self.macro = []
        self.micros = [[]]
        self.micro_size = [0]
        self.fenwick = FenwickTree([0])
        self.size = 0
        for item in iterable:
            self.insert(item)

    def insert(self, x):
        i = bisect_left(self.macro, x)
        j = bisect_right(self.micros[i], x)
        self.micros[i].insert(j, x)
        self.size += 1
        self.micro_size[i] += 1
        self.fenwick.update(i, 1)
        if len(self.micros[i]) >= self.block_size:
            self.micros[i:i + 1] = (self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:])
            self.micro_size[i:i + 1] = (self.block_size >> 1, self.block_size >> 1)
            self.fenwick = FenwickTree(self.micro_size)
            self.macro.insert(i, self.micros[i + 1][0])

    def pop(self, k=-1):
        (i, j) = self._find_kth(k)
        self.size -= 1
        self.micro_size[i] -= 1
        self.fenwick.update(i, -1)
        return self.micros[i].pop(j)

    def __getitem__(self, k):
        (i, j) = self._find_kth(k)
        return self.micros[i][j]

    def count(self, x):
        return self.bisect_right(x) - self.bisect_left(x)

    def __contains__(self, x):
        return self.count(x) > 0

    def bisect_left(self, x):
        i = bisect_left(self.macro, x)
        return self.fenwick(i) + bisect_left(self.micros[i], x)

    def bisect_right(self, x):
        i = bisect_right(self.macro, x)
        return self.fenwick(i) + bisect_right(self.micros[i], x)

    def _find_kth(self, k):
        return self.fenwick.find_kth(k + self.size if k < 0 else k)

    def __len__(self):
        return self.size

    def __iter__(self):
        return (x for micro in self.micros for x in micro)

    def __repr__(self):
        return str(list(self))
if __name__ == '__main__':
    if path.exists('input.txt'):
        sys.stdin = open('input.txt', 'r')
        sys.stdout = open('output.txt', 'w')
    func_7()

#Function 1:
#State of the program right berfore the function call: func is a callable function.
def func_1(func):
    d = {}
    return wrapper
    #The program returns a callable function named 'wrapper'.
#Overall this is what the function does:The function `func_1` accepts a callable function `func` as a parameter and returns a new callable function named `wrapper`. The function `func_1` does not modify the input `func` or any other external state; it simply creates and returns the `wrapper` function.

#Function 2:
#State of the program right berfore the function call: args is a tuple of arguments that can be passed to the function `func`, and `d` is a dictionary used for memoization where the keys are tuples of arguments and the values are the results of `func` for those arguments.
def wrapper():
    if (args not in d) :
        d[args] = func(*args)
    #State: *`args` is a tuple of arguments that can be passed to the function `func`, and `d` is a dictionary used for memoization where the keys are tuples of arguments and the values are the results of `func` for those arguments. If `args` is not in `d`, the current tuple `args` is now a key in the dictionary `d`, and the value associated with `args` in `d` is the result of `func(*args)`. If `args` is already in `d`, the dictionary `d` remains unchanged.
    return d[args]
    #The program returns the value associated with `args` in the dictionary `d`. If `args` was not already in `d`, the value returned is the result of `func(*args)`, and `args` is now a key in `d` with this result as its value. If `args` was already in `d`, the dictionary `d` remains unchanged, and the value returned is the previously stored result for `args`.
#Overall this is what the function does:The function `wrapper` does not accept any parameters. It checks if the tuple `args` is a key in the dictionary `d`. If `args` is not in `d`, it calls `func` with the arguments in `args`, stores the result in `d` with `args` as the key, and returns this result. If `args` is already in `d`, it simply returns the value associated with `args` in `d` without modifying the dictionary.

#Function 3:
#State of the program right berfore the function call: None of the variables in the function signature are used, as the function does not take any parameters.
def func_2():
    return sys.stdin.readline().strip()
    #The program returns the first line of input from the user, with any leading or trailing whitespace removed.
#Overall this is what the function does:The function `func_2` does not accept any parameters. It reads the first line of input from the user, removes any leading or trailing whitespace, and returns the resulting string.

#Function 4:
#State of the program right berfore the function call: No variables are present in the function signature.
def func_3():
    return int(func_2())
    #The program returns an integer value that is the result of calling the function `func_2()`.
#Overall this is what the function does:The function `func_3` does not accept any parameters and returns an integer value that is the result of calling the function `func_2()`.

#Function 5:
#State of the program right berfore the function call: delimiter is a string used to split the input, defaulting to a single space (' ').
def func_4(delimiter):
    return list(map(int, func_2().split(delimiter)))
    #The program returns a list of integers obtained by splitting the string returned by `func_2()` using the `delimiter` and converting each split part to an integer.
#Overall this is what the function does:The function `func_4` accepts a parameter `delimiter` (a string, defaulting to a single space ' ') and returns a list of integers. This list is obtained by splitting the string returned by `func_2()` using the specified `delimiter` and converting each split part to an integer.

#Function 6:
#State of the program right berfore the function call: None of the variables in the function signature are used, as the function does not take any parameters.
def func_5():
    return func_2()
    #The program returns the value or output of `func_2()`. Since `func_2()` is not defined in the initial state, we do not know its specific output or value.
#Overall this is what the function does:The function `func_5` does not accept any parameters and returns the output of `func_2()`. The final state of the program after the function concludes is that it has the return value of `func_2()`, which is unknown without the definition of `func_2()`.

#Function 7:
#State of the program right berfore the function call: n, m, and k are integers such that 2 <= n <= 10^5, 1 <= m, k <= 2 * 10^5. A is a sorted list of n integers where 1 <= A[i] <= 2 * 10^9 and A[i] < A[i+1]. D is a sorted list of unique integers derived from m integers where 1 <= D[i] <= 10^9. F is a list of k integers where 1 <= F[i] <= 10^9.
def func_6():
    n, m, k = func_4()
    A = func_4()
    D = sorted(set(func_4()))
    F = func_4()
    max_diff, next_max_diff, index = -inf, -inf, None
    for i in range(1, n):
        diff = A[i] - A[i - 1]
        
        if diff > max_diff:
            next_max_diff = max_diff
            max_diff = diff
            index = i
        elif diff > next_max_diff:
            next_max_diff = diff
        
    #State: `n` is greater than 1, `i` is `n-1`, `m` and `k` are the values returned by `func_4()`, `A` is a sorted list of `n` integers where 1 <= A[i] <= 2 * 10^9 and A[i] < A[i+1], `D` is a sorted list of unique integers derived from the values returned by `func_4()`, `F` is a list of `k` integers where 1 <= F[i] <= 10^9, `max_diff` is the largest difference between any two consecutive elements in `A`, `next_max_diff` is the second largest difference between any two consecutive elements in `A`, and `index` is the index of the element in `A` where the largest difference occurs.
    left, right = A[index - 1], A[index]
    ans = max_diff
    for f in F:
        l = bisect_right(D, left - f)
        
        h = bisect_left(D, right - f) - 1
        
        while l < h:
            mid = l + (h - l) // 2
            mid_sum, mid_next_sum = D[mid] + f, D[mid + 1] + f
            if mid_sum - left < right - mid_next_sum:
                l = mid + 1
            else:
                h = mid
        
        if l == h:
            ans = min(ans, max(D[l] + f - left, right - D[l] - f))
        
    #State: The loop has finished executing, and the final value of `ans` is the minimum value of the maximum of `D[l] + f - left` and `right - D[l] - f` after each iteration of the loop. The values of `n`, `i`, `m`, `k`, `A`, `D`, `F`, `max_diff`, `next_max_diff`, `index`, `left`, and `right` remain unchanged.
    print(max(ans, next_max_diff))
    #This is printed: max(ans, next_max_diff) (where ans is the minimum value of the maximum of D[l] + f - left and right - D[l] - f after each iteration of the loop, and next_max_diff is a predefined value)
#Overall this is what the function does:The function `func_6` processes three lists `A`, `D`, and `F` to find the minimum value of the maximum difference between two segments of the list `A` after applying a transformation based on elements in `F` and `D`. It first identifies the largest and second-largest differences between consecutive elements in `A`. Then, it iterates over each element in `F`, using binary search on `D` to find the optimal transformation that minimizes the maximum difference. Finally, it prints the maximum of this minimized difference and the second-largest difference found in `A`. The function does not return any value.

#Function 8:
#State of the program right berfore the function call: No variables are used in the function signature.
def func_7():
    testcases = func_3()
    for _ in range(testcases):
        func_6()
        
    #State: `testcases` must be greater than or equal to 0, `func_6()` has been called `testcases` times.
#Overall this is what the function does:The function `func_7` does not accept any parameters. It retrieves a non-negative integer value from `func_3` and uses this value to call `func_6` the same number of times. The function does not return any value, and its primary purpose is to execute `func_6` a specific number of times determined by the result of `func_3`. After the function concludes, `func_6` has been called `testcases` times, where `testcases` is a non-negative integer.




Beggining of Original Assessment: 
### Reasoning:

1. **Input Handling:**
   - The program uses a series of functions to handle input. `func_2` reads a line from standard input and strips any trailing whitespace. `func_3` converts this line to an integer. `func_4` splits the line by a delimiter and converts the resulting list to integers. These functions are used to read the number of test cases, the values of `n`, `m`, and `k`, the complexities of the problems, models, and functions, respectively.

2. **Problem Complexity Array:**
   - The array `A` is read and contains the complexities of the prepared problems. It is assumed to be sorted in ascending order, as per the problem description.

3. **Model and Function Arrays:**
   - The array `D` is read and contains the complexities of the models. It is sorted and duplicates are removed using `set` and `sorted` to ensure uniqueness and sorted order.
   - The array `F` is read and contains the complexities of the functions.

4. **Finding the Maximum Difference:**
   - The program iterates through the array `A` to find the maximum difference between consecutive elements (`max_diff`). It also keeps track of the second largest difference (`next_max_diff`) and the index where the maximum difference occurs (`index`).

5. **Binary Search for Optimal Insertion:**
   - For each function complexity `f` in `F`, the program uses binary search to find the optimal position to insert a new problem complexity `d_i + f` into the array `A` to minimize the imbalance.
   - `bisect_right` is used to find the position `l` where `left - f` would be inserted in `D` to maintain sorted order.
   - `bisect_left` is used to find the position `h` where `right - f` would be inserted in `D` to maintain sorted order.
   - The program then uses a binary search within the range `[l, h]` to find the optimal `d_i` that minimizes the maximum difference.

6. **Calculating the Minimum Imbalance:**
   - The program calculates the potential new imbalance by considering the insertion of `d_i + f` at the optimal position and updates `ans` with the minimum possible imbalance.
   - Finally, it prints the maximum of `ans` and `next_max_diff` to ensure that the imbalance is minimized even if the new problem does not change the maximum difference.

7. **Test Case Loop:**
   - The program reads the number of test cases and processes each test case using the `func_6` function, which calls the main logic function `func_5`.

### Correctness:
- The program correctly handles the input and processes each test case.
- It uses binary search to efficiently find the optimal position for inserting a new problem complexity, which is a valid approach for minimizing the imbalance.
- The logic for finding the maximum difference and the second largest difference is correct.
- The final output is the minimum possible imbalance, which is the correct solution to the problem.

### Conclusion:
Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

