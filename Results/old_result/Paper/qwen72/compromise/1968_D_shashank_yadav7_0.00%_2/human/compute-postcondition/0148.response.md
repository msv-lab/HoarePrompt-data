Postcondition: **`i` is `n - 1`, `k` is `k - n` (or `k` is `-1` if `k - n` is less than or equal to 0), `b` is `p[p[...[p[b - 1]... - 1] - 1] - 1` (where `p` is applied `n` times), `s` is `p[p[...[p[s - 1]... - 1] - 1] - 1` (where `p` is applied `n` times), `bm` is the cumulative result of `bm += max(bm, a[b] * k + bp)` over `n` iterations, `sm` is the cumulative result of `sm += max(sm, a[s] * k + sp)` over `n` iterations, `sp` is `sp + sum(a[p[s] - 1] for _ in range(n))`, `bp` is `bp + sum(a[p[b] - 1] for _ in range(n))`, and `bm` is less than `sm`.** 

In natural language: `i` is `n - 1`, `k` is `k - n` (or `-1` if `k - n` is less than or equal to 0), `b` and `s` are both the result of applying the function `p` `n` times to `b - 1` and `s - 1` respectively, `bm` and `sm` are the cumulative results of their respective update rules over `n` iterations, `sp` and `bp` are updated by summing the values of `a` at indices derived from applying `p` to `s` and `b` respectively over `n` iterations, and the current value of `bm` is less than the current value of `sm`.