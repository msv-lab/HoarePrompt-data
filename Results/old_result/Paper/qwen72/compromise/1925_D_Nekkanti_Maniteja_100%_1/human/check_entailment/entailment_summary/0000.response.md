Reasoning:

1. **Input Handling**: The function correctly reads the number of test cases `t` and processes each test case individually. For each test case, it reads `n`, `m`, and `k` from the input, and then reads `m` lines of input containing the pairs of friends and their friendship values.

2. **Modular Inverse Calculation**: The function calculates the modular inverse `c` of \( \frac{n(n-1)}{2} \) modulo \(10^9 + 7\). This is correct because \( \frac{n(n-1)}{2} \) is the number of ways to choose 2 children from `n` children, and the modular inverse is used to divide by this number in modular arithmetic.

3. **Sum of Friendship Values**: The function correctly sums up the initial friendship values `f` for all pairs of friends and stores this sum in `a`.

4. **Expected Value Calculation**: The function calculates the expected value of the sum of friendship values for all `k` pairs chosen. The formula used is:
   \[
   s = s + c \cdot i \cdot c \cdot m + c \cdot a
   \]
   Here, `c * i * c * m` represents the expected increase in the friendship value due to the chosen pairs being friends, and `c * a` represents the expected value of the initial friendship values.

5. **Modulo Operation**: The final result `s` is taken modulo \(10^9 + 7\) before being printed, which is correct as per the problem statement.

However, there is a potential issue with the formula used for the expected value calculation. The formula should account for the fact that the friendship value increases by 1 for each subsequent excursion if the same pair is chosen again. The correct formula for the expected value of the sum of friendship values should be:
\[
s = s + c \cdot (a + i \cdot m)
\]
This is because for each excursion, the expected value of the sum of friendship values is the sum of the initial friendship values plus the expected increase due to the pairs being chosen again.

Given this, the current implementation is incorrect because it does not correctly account for the cumulative increase in friendship values.

Correctness: **False**

The correct implementation should be:

```python
def func():
    t = int(input())
    M = 10 ** 9 + 7
    for _ in range(t):
        (n, m, k) = map(int, input().split())
        c = pow(n * (n - 1) // 2, -1, M)
        a = 0
        for i in range(m):
            (u, v, f) = map(int, input().split())
            a = (a + f) % M
        s = 0
        for i in range(k):
            s = (s + c * (a + i * m)) % M
        print(s)
```

This corrects the formula for the expected value calculation and ensures that the cumulative increase in friendship values is properly accounted for.