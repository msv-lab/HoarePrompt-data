Reasoning:  
The program aims to solve the problem by converting the given integer `x` into a binary representation and then applying transformations to ensure that no two consecutive non-zero elements exist in the resulting array. Hereâ€™s a detailed breakdown of the logic and its correctness:

1. **Binary Conversion**: The program starts by converting the integer `x` into a binary string representation using bitwise operations. This step is correct and essential for the subsequent transformations.

2. **Initial Transformation**: The program iterates through the binary string and applies the following rules:
   - If a '1' is followed by another '1', the current '1' is changed to '-1', and a flag is set to indicate that the next position should be adjusted.
   - If the flag is set and the current position is '0', it changes the '0' to '1' and resets the flag.
   - If the flag is set and the current position is '1', it changes the '1' to '0' and continues setting the flag.
   - If the flag is set and the current position is the last bit, it adjusts the last bit and appends a '1' if necessary.

3. **Final Adjustments**: After the initial transformation, the program makes additional adjustments to ensure that no two consecutive non-zero elements exist. Specifically, it checks for any '-1' followed by a '1' and resolves them by changing the '1' to '0' and the '-1' to '-1'.

4. **Output**: The program prints the length of the resulting array and the array itself.

### Verification:
- **Test Cases**: The provided test cases in the example are correctly handled by the program. For instance, for `x = 14`, the program correctly outputs `0 -1 0 0 1`, which satisfies the conditions.
- **Edge Cases**: The program handles edge cases such as `x = 1` and `x = 27` correctly, ensuring that the resulting array meets the specified conditions.

### Potential Issues:
- **Length Calculation**: The program sets the initial length to 30 and adjusts it if necessary. This is a safe approach given the constraint \(1 \le x < 2^{30}\).
- **Flag Handling**: The flag mechanism ensures that the transformations are applied correctly, preventing consecutive non-zero elements.

Given the above reasoning, the program appears to correctly implement the required logic and handle the specified constraints and test cases.

Correctness: **True**