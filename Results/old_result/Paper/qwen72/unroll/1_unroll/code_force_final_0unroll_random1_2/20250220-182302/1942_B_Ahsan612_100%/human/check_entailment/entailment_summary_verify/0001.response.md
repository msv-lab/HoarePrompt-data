### Reasoning:

1. **Understanding the Problem:**
   - We are given an array `a` of length `n` where each element `a_i` is defined as `a_i = MEX(p_1, p_2, ..., p_i) - p_i`.
   - We need to reconstruct a permutation `p` of integers from `0` to `n-1` that satisfies this condition.

2. **Key Observations:**
   - The MEX of an array is the smallest non-negative integer that is not present in the array.
   - Given `a_i = MEX(p_1, p_2, ..., p_i) - p_i`, we can rearrange this to find `p_i`:
     \[
     p_i = MEX(p_1, p_2, ..., p_i) - a_i
     \]
   - We need to maintain the MEX of the prefix of `p` as we construct it.

3. **Algorithm Analysis:**
   - The program initializes `mex` to `n`, which is the highest possible MEX value for the permutation.
   - It iterates over the array `ar` in reverse order (from the last element to the first).
   - For each element `ar[i]`, it calculates `p_i` as `mex - ar[i]`.
   - If `mex` is greater than `mex - ar[i]`, it updates `mex` to `mex - ar[i]`.

4. **Correctness of the Algorithm:**
   - The program correctly calculates `p_i` using the formula `p_i = mex - ar[i]`.
   - However, the update condition `if mex > mex - ar[i]` is not sufficient to ensure that `mex` is always the smallest non-negative integer not in the prefix of `p` up to `i`.
   - The correct condition should be `if mex > mex - ar[i] and (mex - ar[i]) not in res[:i+1]` to ensure that the new `mex` value is not already in the prefix of `p`.

5. **Edge Cases:**
   - The program handles the case where `n = 1` correctly.
   - However, it may fail in cases where `a_i` values are such that the MEX calculation and update are not correctly managed.

6. **Output:**
   - The program prints the constructed permutation `p` for each test case.

### Example Analysis:
- For the input `5 1 1 -2 1 2`:
  - The program calculates `p` as follows:
    - `i = 4`: `p_4 = 5 - 2 = 3`, `mex = 3`
    - `i = 3`: `p_3 = 3 - 1 = 2`, `mex = 2`
    - `i = 2`: `p_2 = 2 - (-2) = 4`, `mex = 4` (incorrect, should be 2)
    - `i = 1`: `p_1 = 2 - 1 = 1`, `mex = 1`
    - `i = 0`: `p_0 = 1 - 1 = 0`, `mex = 0`
  - The output is `0 1 4 2 3`, which is incorrect because the MEX calculation for `p_2` is wrong.

### Conclusion:
The program's logic for updating `mex` is flawed. The update condition should ensure that the new `mex` value is not already in the prefix of `p`. Therefore, the original assessment is inaccurate.

### Final Evaluation:
Final: **False**