To determine what will be printed by the given `print` statement, let's break down the initial state and the variables involved:

### Initial State:
- **`grid`**: A list of `n` lists, each containing `m` elements read from the input. This represents a grid where each cell can contain different elements, such as players or the Quaffle.
- **`elements`**: A dictionary that is updated to reflect the final positions of all players and the Quaffle ('.B') after the loop executes. The keys are likely the identifiers of the players and the Quaffle, and the values are their final positions.
- **`allPlayers`**: A dictionary that is updated to reflect the final state (True or False) of each player after the loop executes. The keys are the identifiers of the players, and the values indicate whether the player is still active or not.
- **`goal`**: A list containing the coordinates of the 'BG' (Blue Goal) and 'WG' (White Goal) elements. These coordinates are fixed and do not change.
- **`points`**: A list updated to reflect the final score of each team after the loop executes. The first element (`points[0]`) represents the score of the Blue team, and the second element (`points[1]`) represents the score of the White team.

### Code Snippet:
```python
print('FINAL SCORE: %d %d' % (points[0], points[1]))
```

### Explanation:
- The `print` statement uses string formatting to output the final scores of the two teams.
- `points[0]` is the final score of the Blue team.
- `points[1]` is the final score of the White team.

### Output:
The `print` statement will output the final scores of the Blue team and the White team. Since the exact values of `points[0]` and `points[1]` are not provided in the initial state, we can only describe them in terms of the final state of the game.

Output: **FINAL SCORE: [points[0]] [points[1]] (where points[0] is the final score of the Blue team and points[1] is the final score of the White team)**