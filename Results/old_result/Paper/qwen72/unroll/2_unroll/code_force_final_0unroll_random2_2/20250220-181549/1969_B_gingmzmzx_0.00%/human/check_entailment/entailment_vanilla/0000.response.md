### Reasoning:

1. **Input Handling:**
   - The function starts by reading an integer `n` which represents the number of test cases.
   - For each test case, it reads a binary string `s` and converts it into a list of integers (0s and 1s).

2. **Counting Zeroes:**
   - The variable `zeroes` is used to count the number of 0s in the string `s`.

3. **Counting and Cost Calculation:**
   - The variable `cnt` is a list with two elements, where `cnt[0]` counts the number of 0s encountered so far and `cnt[1]` counts the number of 1s encountered so far.
   - The variable `ans` is initialized to 0 and will store the total cost of sorting the string.

4. **Iterating Through the String:**
   - For each character `c` in the string `s`:
     - If `c` is 0, it increments `cnt[0]` and adds 1 to `ans` if there are any 1s encountered so far (`cnt[1] > 0`).
     - If `c` is 1, it increments `cnt[1]` and adds the difference between the total number of 0s and the number of 0s encountered so far (`zeroes - cnt[0]`) to `ans`.

5. **Output:**
   - After processing the string, the function prints the total cost `ans` for the current test case.

### Analysis:

- **Objective:**
  - The goal is to determine the minimum total cost to sort the binary string in non-descending order using cyclic shifts on substrings.

- **Algorithm:**
  - The algorithm works by iterating through the string and calculating the cost of making the string sorted based on the positions of 0s and 1s.
  - The cost is calculated by counting the number of 0s that need to be moved past 1s to achieve a sorted order.

- **Correctness:**
  - The algorithm correctly identifies the number of 0s and 1s and calculates the cost of moving 0s past 1s.
  - The logic of adding 1 to `ans` when a 0 is encountered and there are 1s before it, and adding the difference between total 0s and encountered 0s when a 1 is encountered, is correct for the problem's requirements.

### Conclusion:

The provided program correctly implements the logic to determine the minimum total cost to sort a binary string using cyclic shifts on substrings. The algorithm is efficient and handles the constraints specified in the problem.

Correctness: **True**