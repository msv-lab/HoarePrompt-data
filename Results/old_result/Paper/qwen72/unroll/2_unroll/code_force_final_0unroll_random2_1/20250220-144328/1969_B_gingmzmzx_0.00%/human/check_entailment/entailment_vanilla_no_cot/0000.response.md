Correctness: **True**

The provided Python program appears to correctly solve the problem as described. The program reads the number of test cases and then processes each test case individually. For each test case, it converts the input binary string into a list of integers, counts the number of zeros, and then iterates through the string to calculate the minimum total cost required to sort the string in non-descending order using cyclic shifts.

The logic in the program is as follows:
- It initializes a counter `cnt` to keep track of the number of 0s and 1s encountered so far.
- It initializes `ans` to 0, which will store the total cost.
- It iterates through each character in the string:
  - If the character is 0, it adds 1 to `ans` if there has been at least one 1 encountered before (i.e., `cnt[1] > 0`).
  - If the character is 1, it adds the number of 0s that have not been encountered yet (`zeroes - cnt[0]`) to `ans`.
- Finally, it prints the total cost for each test case.

This approach correctly calculates the minimum cost by considering the positions of 0s and 1s and the cost of moving 0s to the front of the string and 1s to the back. The program handles all the constraints and edge cases mentioned in the problem description. Therefore, the program is correct.