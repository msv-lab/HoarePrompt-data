#State of the program right berfore the function call: func is a callable function.
def func_1(func):
    d = {}
    return wrapper
    #The program returns a function named 'wrapper' which is a callable function, while `d` remains an empty dictionary.
#Overall this is what the function does:The function `func_1` accepts a callable function `func` and returns a new callable function named `wrapper`. The dictionary `d` remains an empty dictionary and is not used or modified by the function.

#State of the program right berfore the function call: args is a tuple of arguments that can be passed to func, and d is a dictionary where keys are tuples and values are the results of func when called with the corresponding keys.
def wrapper():
    if (args not in d) :
        d[args] = func(*args)
    #State: *args is a tuple of arguments that can be passed to func, and d is a dictionary where keys are tuples and values are the results of func when called with the corresponding keys. If args is not in d, then args is added as a key to d, and d[args] is set to the result of func(*args). If args is already in d, no changes are made to d.
    return d[args]
    #The program returns the value associated with the key `args` in the dictionary `d`, which is the result of `func` when called with the arguments in `args`. If `args` is not in `d`, it is added as a key, and the value is set to the result of `func(*args)`. If `args` is already in `d`, the existing value is returned without any changes to `d`.
#Overall this is what the function does:The function `wrapper` does not accept any parameters. It returns the result of `func` when called with the arguments in `args`. If `args` is not a key in the dictionary `d`, it adds `args` as a key and sets the value to the result of `func(*args)`. If `args` is already a key in `d`, it returns the existing value associated with `args` without modifying `d`.

#State of the program right berfore the function call: None of the variables in the function signature are used.
def func_2():
    return sys.stdin.readline().strip()
    #The program returns a line of input read from the standard input (stdin), with any trailing whitespace removed.
#Overall this is what the function does:Reads a line of input from the standard input (stdin), removes any trailing whitespace, and returns the result.

#State of the program right berfore the function call: None of the variables in the function signature are relevant to the problem description.
def func_3():
    return int(func_2())
    #The program returns an integer value that is the result of calling the function `func_2()`.
#Overall this is what the function does:The function `func_3` does not accept any parameters and returns an integer value obtained by calling the function `func_2()`. After the function concludes, the program state includes a return value that is the integer result of `func_2()`.

#State of the program right berfore the function call: delimiter is a string used to split the input, typically a space (' ').
def func_4(delimiter):
    return list(map(int, func_2().split(delimiter)))
    #The program returns a list of integers obtained by splitting the string returned by `func_2()` using the `delimiter` and then converting each split part to an integer.
#Overall this is what the function does:The function `func_4` accepts a parameter `delimiter` and returns a list of integers. This list is generated by splitting the string returned by `func_2()` using the `delimiter` and then converting each split part to an integer. The final state of the program includes the returned list of integers, and the `delimiter` remains unchanged.

#State of the program right berfore the function call: None of the variables in the function signature are used, as the function does not take any parameters.
def func_5():
    return func_2()
    #The program returns the result of the function `func_2()`. Since no information is provided about `func_2()`, the specific value or type of the return is unknown.
#Overall this is what the function does:The function `func_5` does not accept any parameters and returns the result of calling `func_2()`. The specific value or type of the return is unknown as no information is provided about `func_2()`.

#State of the program right berfore the function call: (n, m, k) are integers such that 2 <= n <= 10^5, 1 <= m, k <= 2 * 10^5. A is a list of n integers in strictly increasing order, where 1 <= A[i] <= 2 * 10^9. D is a sorted list of unique integers, representing the complexities of the models, where 1 <= len(D) <= m and 1 <= D[i] <= 10^9. F is a list of k integers, representing the complexities of the functions, where 1 <= len(F) <= k and 1 <= F[i] <= 10^9.
def func_6():
    n, m, k = func_4()
    A = func_4()
    D = sorted(set(func_4()))
    F = func_4()
    max_diff, next_max_diff, index = -inf, -inf, None
    for i in range(1, n):
        diff = A[i] - A[i - 1]
        
        if diff > max_diff:
            next_max_diff = max_diff
            max_diff = diff
            index = i
        elif diff > next_max_diff:
            next_max_diff = diff
        
    #State: The values of `max_diff` and `next_max_diff` will be the largest and second largest differences between consecutive elements in the list `A`, respectively. The value of `index` will be the index of the element in `A` where the largest difference occurs. The values of `n`, `m`, `k`, `A`, `D`, and `F` will remain unchanged.
    left, right = A[index - 1], A[index]
    ans = max_diff
    for f in F:
        l = bisect_right(D, left - f)
        
        h = bisect_left(D, right - f) - 1
        
        while l < h:
            mid = l + (h - l) // 2
            mid_sum, mid_next_sum = D[mid] + f, D[mid + 1] + f
            if mid_sum - left < right - mid_next_sum:
                l = mid + 1
            else:
                h = mid
        
        if l == h:
            ans = min(ans, max(D[l] + f - left, right - D[l] - f))
        
    #State: `ans` is the minimum of the initial `max_diff` and the maximum differences found during the binary search for each `f` in `F`. The values of `max_diff`, `next_max_diff`, `index`, `n`, `m`, `k`, `A`, `D`, and `F` remain unchanged. `left` and `right` also remain unchanged.
    print(max(ans, next_max_diff))
    #This is printed: max(ans, next_max_diff) (where ans is the minimum of the initial max_diff and the maximum differences found during the binary search for each f in F, and next_max_diff is the given value)
#Overall this is what the function does:The function `func_6` processes a list `A` of `n` strictly increasing integers, a sorted list `D` of unique integers representing model complexities, and a list `F` of integers representing function complexities. It identifies the largest and second largest differences between consecutive elements in `A`. Then, it calculates the minimum possible maximum difference between pairs of elements in `A` after applying each function complexity `f` in `F` to the model complexities in `D`. Finally, it prints the maximum of the initial largest difference and the calculated minimum possible maximum difference. The function does not return any value. The values of `n`, `m`, `k`, `A`, `D`, and `F` remain unchanged throughout the function's execution.

#State of the program right berfore the function call: No variables are passed to the function `func_7`.
def func_7():
    testcases = func_3()
    for _ in range(testcases):
        func_6()
        
    #State: `testcases` remains the value returned by `func_3()`.
#Overall this is what the function does:The function `func_7` does not accept any parameters. It retrieves a value from `func_3` and uses this value to determine the number of times `func_6` is called in a loop. After the function concludes, the variable `testcases` retains the value returned by `func_3`. The function typically returns `None`.

