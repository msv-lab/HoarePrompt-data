### Reasoning:

1. **Understanding the Problem**:
   - We are given an array `a` of length `n` where each element `a_i` is defined as `a_i = MEX(p_1, p_2, ..., p_i) - p_i`.
   - The task is to reconstruct the permutation `p` from the array `a`.

2. **Reconstructing the Permutation**:
   - The key observation is that the MEX of the first `i` elements of `p` is the smallest non-negative integer not present in `p_1, p_2, ..., p_i`.
   - Given `a_i = MEX(p_1, p_2, ..., p_i) - p_i`, we can rearrange this to find `p_i`:
     \[
     p_i = MEX(p_1, p_2, ..., p_i) - a_i
     \]
   - To find `MEX(p_1, p_2, ..., p_i)`, we need to keep track of the smallest non-negative integer not yet used in the permutation up to index `i`.

3. **Algorithm**:
   - Initialize `mex` to `n` (the maximum possible value for MEX in the permutation).
   - Iterate from the last element to the first element of `a` (i.e., from `n-1` to `0`).
   - For each `i`, set `p[i]` to `mex - a[i]`.
   - Update `mex` to be the minimum of `mex` and `p[i]` to ensure that `mex` is the smallest non-negative integer not yet used in the permutation up to index `i`.

4. **Verification**:
   - The algorithm ensures that `p` is a valid permutation because it always assigns the smallest possible value that is not yet used in the permutation.
   - The values of `a` are calculated correctly based on the definition of MEX and the given formula.

5. **Edge Cases**:
   - The algorithm handles the edge case where `n = 1` correctly.
   - The algorithm also handles the case where `a` is a constant array (e.g., all elements are 1) correctly.

### Conclusion:
The provided program correctly reconstructs the permutation `p` from the array `a` based on the given problem description and constraints. The logic and implementation are sound.

### Correctness:
**True**