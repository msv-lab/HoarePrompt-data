### Reasoning:

1. **Input Handling**:
   - The program reads all input data at once and splits it into a list `data`.
   - It then processes the number of test cases `T` and iterates over each test case.

2. **Test Case Processing**:
   - For each test case, it reads the number of signs `n` and the list of periodicities `a`.
   - It initializes `last_year` to the first periodicity `a[0]`, which is the year the first sign will occur.

3. **Calculating the Next Year for Each Sign**:
   - For each subsequent sign (from the second to the nth), it calculates the next year when the sign will occur.
   - The formula `(last_year + 1 + a[i] - 1) // a[i] * a[i]` ensures that the next year is the smallest multiple of `a[i]` that is strictly greater than `last_year`.
   - This is correct because it ensures that the next sign occurs after the previous sign and follows the periodicity `a[i]`.

4. **Output**:
   - After processing all test cases, it writes the results to the standard output, each on a new line.

5. **Edge Cases**:
   - The program correctly handles the edge case where `n = 1` (only one sign).
   - It also handles the case where all periodicities are 1, as shown in the third test case of the example.

6. **Correctness of the Formula**:
   - The formula `(last_year + 1 + a[i] - 1) // a[i] * a[i]` is mathematically correct for finding the next multiple of `a[i]` that is strictly greater than `last_year`.
   - This formula can be broken down as:
     - `last_year + 1` ensures we start looking for the next occurrence after the current year.
     - `+ a[i] - 1` ensures that the division by `a[i]` rounds up to the next multiple.
     - `// a[i] * a[i]` completes the rounding up to the next multiple.

### Conclusion:
The program correctly implements the logic to find the year in which the nth sign will occur, ensuring that each sign occurs sequentially and strictly after the previous one. The input and output handling is also correct according to the problem description.

### Correctness:
**True**