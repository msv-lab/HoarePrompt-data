To determine the correctness of the provided program, we need to analyze the function `func_1(n)` in relation to the problem description, which requires finding the n-th Lucas number.

The Lucas numbers are defined similarly to Fibonacci numbers and start from:
- L(0) = 2
- L(1) = 1
- L(2) = 3 (2 + 1)
- L(3) = 4 (1 + 3)
- L(4) = 7 (3 + 4)
- L(n) = L(n-1) + L(n-2) for n â‰¥ 2

Now, let's review the implementation in `func_1(n)`:

```python
def func_1(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        (a, b) = (2, 1)  # Initializes for the Lucas numbers
        for _ in range(2, n + 1):
            (a, b) = (b, a + b)  # a = L(n-1), b = L(n), computes next Lucas number
        return b
```

### Analyze the logic:
- For `n = 0`, it correctly returns `2`.
- For `n = 1`, it correctly returns `1`.
- For `n = 2`, it computes using the loop:
  - Starts with `a = 2` (L(0)) and `b = 1` (L(1)).
  - On the first iteration (when `_` is `2`), it updates:
    - `a` becomes `1` (L(1))
    - `b` becomes `3` (L(0) + L(1) which is 2 + 1)
  - It exits the loop and returns `b`, which is `3`. (`L(2)` is indeed `3`).
- Continuing this logic for higher `n` follows similarly: it updates `a` and `b` correctly to compute `L(n)`.

### Use Cases:
- If we test with `n = 3`, the values will be:
  - `a` = `1`, `b` = `3` => on next update, `b` becomes `4` which is L(3).
- For `n = 4`, will return `7` which matches L(4).
- For `n = 5`, it computes correctly to return `11`, which is L(5).

The implementation accurately calculates the n-th Lucas number as per the definition.

### Conclusion:
There are no found edge cases or incorrect behavior based on the problem description, and the function adheres to the requirements for all positive integers and zero.

Correctness: **True**