
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Polycarpus likes giving presents to Paraskevi. He has bought two chocolate bars, each of them has the shape of a segmented rectangle. The first bar is a_1 × b_1 segments large and the second one is a_2 × b_2 segments large.

Polycarpus wants to give Paraskevi one of the bars at the lunch break and eat the other one himself. Besides, he wants to show that Polycarpus's mind and Paraskevi's beauty are equally matched, so the two bars must have the same number of squares.

To make the bars have the same number of squares, Polycarpus eats a little piece of chocolate each minute. Each minute he does the following:  he either breaks one bar exactly in half (vertically or horizontally) and eats exactly a half of the bar,  or he chips of exactly one third of a bar (vertically or horizontally) and eats exactly a third of the bar. 

In the first case he is left with a half, of the bar and in the second case he is left with two thirds of the bar.

Both variants aren't always possible, and sometimes Polycarpus cannot chip off a half nor a third. For example, if the bar is 16 × 23, then Polycarpus can chip off a half, but not a third. If the bar is 20 × 18, then Polycarpus can chip off both a half and a third. If the bar is 5 × 7, then Polycarpus cannot chip off a half nor a third.

What is the minimum number of minutes Polycarpus needs to make two bars consist of the same number of squares? Find not only the required minimum number of minutes, but also the possible sizes of the bars after the process.


-----Input-----

The first line of the input contains integers a_1, b_1 (1 ≤ a_1, b_1 ≤ 10^9) — the initial sizes of the first chocolate bar. The second line of the input contains integers a_2, b_2 (1 ≤ a_2, b_2 ≤ 10^9) — the initial sizes of the second bar.

You can use the data of type int64 (in Pascal), long long (in С++), long (in Java) to process large integers (exceeding 2^31 - 1).


-----Output-----

In the first line print m — the sought minimum number of minutes. In the second and third line print the possible sizes of the bars after they are leveled in m minutes. Print the sizes using the format identical to the input format. Print the sizes (the numbers in the printed pairs) in any order. The second line must correspond to the first bar and the third line must correspond to the second bar. If there are multiple solutions, print any of them.

If there is no solution, print a single line with integer -1.


-----Examples-----
Input
2 6
2 3

Output
1
1 6
2 3

Input
36 5
10 16

Output
3
16 5
5 16

Input
3 5
2 1

Output
-1
Program:
```
def func_1(a, b):
    if b == 0:
        return a
    else:
        return func_1(b, a % b)
(a1, b1) = map(int, input().split())
(a2, b2) = map(int, input().split())
area1 = a1 * b1
area2 = a2 * b2
if area1 != area2:
    print(-1)
else:
    g = func_1(a1, b1)
    a1 //= g
    b1 //= g
    g = func_1(a2, b2)
    a2 //= b2
    b2 //= g
    minutes = 0
    while a1 != a2 or b1 != b2:
        if a1 > a2:
            if a1 % 2 == 0:
                a1 //= 2
            elif a1 % 3 == 0:
                a1 //= 3
            else:
                break
            minutes += 1
        elif a1 < a2:
            if a2 % 2 == 0:
                a2 //= 2
            elif a2 % 3 == 0:
                a2 //= 3
            else:
                break
            minutes += 1
        if b1 > b2:
            if b1 % 2 == 0:
                b1 //= 2
            elif b1 % 3 == 0:
                b1 //= 3
            else:
                break
            minutes += 1
        elif b1 < b2:
            if b2 % 2 == 0:
                b2 //= 2
            elif b2 % 3 == 0:
                b2 //= 3
            else:
                break
            minutes += 1
    if a1 == a2 and b1 == b2:
        print(minutes)
        print(a1, b1)
        print(a2, b2)
    else:
        print(-1)
```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
