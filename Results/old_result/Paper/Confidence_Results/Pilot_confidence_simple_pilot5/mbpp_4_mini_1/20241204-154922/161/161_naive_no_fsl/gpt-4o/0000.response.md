To determine the correctness of the provided Python program in relation to the problem description (finding the n-th Lucas number), let's analyze the program.

The Lucas numbers are defined similarly to Fibonacci numbers, with the following base cases:
- L(0) = 2
- L(1) = 1
- For n >= 2: L(n) = L(n-1) + L(n-2)

The provided function `func_1` implements this logic correctly. 

Now, let's verify the assertions in the provided code:
- `func_1(9)` should return 76.
- `func_1(4)` should return 7.
- `func_1(3)` should return 4.

By calculating the Lucas numbers manually:
- L(0) = 2
- L(1) = 1
- L(2) = L(1) + L(0) = 1 + 2 = 3
- L(3) = L(2) + L(1) = 3 + 1 = 4
- L(4) = L(3) + L(2) = 4 + 3 = 7
- L(5) = L(4) + L(3) = 7 + 4 = 11
- L(6) = L(5) + L(4) = 11 + 7 = 18
- L(7) = L(6) + L(5) = 18 + 11 = 29
- L(8) = L(7) + L(6) = 29 + 18 = 47
- L(9) = L(8) + L(7) = 47 + 29 = 76

The function returns the expected values for the provided assertions:
- `func_1(9) == 76` is correct.
- `func_1(4) == 7` is correct.
- `func_1(3) == 4` is correct.

Next, let's consider edge cases:
- For negative integers, the function currently does not handle them, but the traditional Lucas sequence is defined for non-negative integers only. This is a reasonable assumption based on mathematical conventions for the sequence.
- For larger values of n, the function should compute the correct Lucas number without any overflow or performance issues (Python handles large integers well).

Thus, no invalid or unexpected cases arise.

Based on these evaluations, the logic in the function is sound and adheres to the problem description accurately.

Correctness: **True**