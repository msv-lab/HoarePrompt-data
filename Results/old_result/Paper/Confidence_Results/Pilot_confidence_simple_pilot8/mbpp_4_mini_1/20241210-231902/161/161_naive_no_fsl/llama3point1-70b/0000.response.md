To determine the correctness of the provided program for finding the n-th Lucas number, let's analyze the Lucas number sequence and the implementation.

The Lucas numbers are defined as follows:
- L(0) = 2
- L(1) = 1
- L(n) = L(n-1) + L(n-2) for n > 1

The provided implementation in `func_1` is as follows:

```python
def func_1(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        (a, b) = (2, 1)
        for _ in range(2, n + 1):
            (a, b) = (b, a + b)
        return b
```

### Analysis of the Implementation:
1. **Base Cases**: 
   - For `n = 0`, it correctly returns `2`.
   - For `n = 1`, it correctly returns `1`.

2. **Recursive Calculation**:
   - For `n > 1`, it initializes `a` to `2` (L(0)) and `b` to `1` (L(1)), then iteratively computes the next Lucas numbers using the formula L(n) = L(n-1) + L(n-2).
   - The loop iterates from `2` to `n`, updating `a` and `b` accordingly.

### Testing Edge Cases:
- For `n = 2`: 
  - Expected: L(2) = L(1) + L(0) = 1 + 2 = 3
  - Actual: The loop will run once, updating `a` to `1` and `b` to `3`, which is correct.
  
- For `n = 3`: 
  - Expected: L(3) = L(2) + L(1) = 3 + 1 = 4
  - Actual: The loop will run twice, resulting in `a` being `3` and `b` being `4`, which is correct.

- For `n = 4`: 
  - Expected: L(4) = L(3) + L(2) = 4 + 3 = 7
  - Actual: The loop will run three times, resulting in `a` being `4` and `b` being `7`, which is correct.

- For `n = 5`: 
  - Expected: L(5) = L(4) + L(3) = 7 + 4 = 11
  - Actual: The loop will run four times, resulting in `a` being `7` and `b` being `11`, which is correct.

### Conclusion:
The program correctly implements the logic for calculating the n-th Lucas number for all tested cases and follows the problem description accurately. It handles the base cases and the recursive case correctly.

Since I cannot find any input or potential case where the program does not work as expected, I conclude that the implementation is correct.

Correctness: **True**