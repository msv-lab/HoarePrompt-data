Alright, I have this problem to solve. It's about a game between Alice and Bob on an array, and I need to find the final score of the game based on their optimal plays. The score is defined as the MEX of the array that Alice collects. MEX is the smallest non-negative integer not present in the array.

First, I need to understand the game rules:

1. The game is played on an array `a` of size `n`.

2. Alice starts with an empty array `c`.

3. Players take turns, with Alice going first.

4. On Alice's turn, she picks one element from `a`, appends it to `c`, and deletes it from `a`.

5. On Bob's turn, he picks one element from `a`, deletes it from `a`, but does not add it to `c`.

6. The game ends when `a` is empty, and the score is the MEX of `c`.

Alice wants to maximize the MEX, and Bob wants to minimize it. I need to find the final score assuming both play optimally.

Okay, so MEX is about finding the smallest missing non-negative integer in the array. So, if `c` contains all numbers from 0 to k except some, the MEX will be that missing number, or k+1 if all up to k are present.

Given that Alice wants to maximize MEX and Bob wants to minimize it, I need to think about how their actions affect the MEX.

Alice can choose which elements to include in `c`, and Bob can choose which elements to remove (without adding to `c`). So, Bob can potentially remove elements that Alice wants for `c`, but since he doesn't add to `c`, he can only influence the MEX by limiting Alice's choices.

Wait, actually, Bob removes elements from `a`, which might be elements that Alice could have picked later. So, Bob can strategically remove elements that Alice needs for her `c` to achieve a higher MEX.

Let me think about the example provided:

Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Output:

2

1

0

In the first test case, with array [0,0,1,1], the MEX of c=[1,0] is 2, which seems to be achievable.

In the second test case, [0,1,2,3], the MEX of c could be 1, meaning c might be [0,2,3], so 1 is missing.

In the third test case, [1,1], the MEX of c could be 0, meaning c might be [1], and 0 is missing.

I need to find a general strategy for Alice and Bob to play optimally.

Let me consider that Alice wants to include as many small numbers as possible in `c` to maximize the MEX, while Bob wants to prevent that.

But actually, since Bob can remove elements from `a`, he can try to remove elements that Alice needs for her `c`.

Wait, but Alice picks first, and she can choose which elements to include in `c`.

Let me think differently. The game alternates between Alice and Bob, with Alice going first. Each turn, Alice picks an element to add to `c` and removes it from `a`, while Bob just removes an element from `a`.

The game ends when `a` is empty.

I need to model this game to find the MEX of `c` when both play optimally.

Perhaps I can think in terms of the frequency of each number in the array.

Let's consider counting the frequency of each number in `a`.

For each number `i`, if it appears `cnt[i]` times, then Alice and Bob will have choices based on these counts.

Alice wants to include numbers in `c` to maximize the MEX, which means she wants to have as many small numbers as possible in `c`.

Bob, on the other hand, wants to minimize the MEX, so he wants to prevent Alice from having certain numbers in `c`.

Given that Bob can remove elements from `a`, he can try to remove elements that Alice needs for her `c`.

Wait, but Alice picks first, and she can choose which elements to include in `c`.

Let me consider the turns:

- Total number of turns is `n`, since each turn removes one element from `a`.

- Alice plays on turns 1, 3, 5, ... (1-indexed)

- Bob plays on turns 2, 4, 6, ...

- Alice adds to `c` on her turns, and Bob just removes on his turns.

So, the sequence of moves affects which elements are available at each step.

This seems complicated to model directly.

Maybe I can think in terms of the frequency of each number.

Suppose I have the count of each number in the array.

For each number `i`, if `cnt[i]` is the count, then Alice and Bob will fight over these counts.

Wait, perhaps I can think in terms of who has the majority control over the inclusion of each number.

Wait, perhaps it's better to think in terms of the number of times Alice can include a particular number in `c`.

Given that Alice plays on odd turns and Bob on even turns, and Alice can choose to include elements in `c` on her turns.

Wait, perhaps I can think in terms of the number of times a particular number can be included in `c`, depending on the total counts and who gets to pick them.

This seems too vague.

Let me try to think differently.

I recall that MEX is about the smallest missing non-negative integer in the array.

So, to maximize MEX, Alice wants to have as many small numbers in `c` as possible.

Bob, wanting to minimize MEX, would want to prevent Alice from having those small numbers.

Given that, perhaps I can consider for each number `i`, whether it's possible for Alice to include it in `c`.

If Alice can include all numbers from 0 to k in `c`, then the MEX would be k+1.

I need to find the maximum k such that Alice can include all numbers from 0 to k in `c`, despite Bob's efforts.

Wait, but numbers can be repeated, so I need to consider the counts.

Let me formalize it.

Let `cnt[i]` be the count of number `i` in the array `a`.

Alice needs to include `i` in `c` at least once for all `i` from 0 to k to achieve MEX of k+1.

Bob will try to prevent Alice from including some `i` in `c`.

Given that, for each `i`, the number of times Alice can include `i` in `c` is related to the count `cnt[i]` and the turns.

Wait, perhaps I can think in terms of the number of times Alice can pick `i` before it's removed.

But this seems too vague.

Let me consider a simpler approach.

Suppose I try to find the smallest `i` such that Alice cannot include `i` in `c`, no matter how she plays.

That `i` would be the MEX.

Wait, but I need to find the MEX of `c`, which is the smallest missing number in `c`.

So, if Alice cannot include some `i` in `c`, then `i` would be missing, hence MEX would be `i`.

So, I need to find the smallest `i` for which Alice cannot include `i` in `c`, given that Bob is trying to prevent her from doing so.

Now, how do I determine for each `i` whether Alice can include at least one `i` in `c`?

Given that, perhaps I can iterate through `i` from 0 to n, and check if Alice can include `i` in `c`.

If she can, then `i` is included in `c`, and I continue to the next `i`.

If she cannot, then `i` is the MEX.

So, I need a way to decide for each `i`, whether Alice can include at least one `i` in `c`.

Given that, let's consider the counts of each `i`.

If `cnt[i]` is the count of `i` in `a`, then Alice and Bob will have turns to pick or remove `i`.

Since Alice picks on odd turns and Bob on even turns, and Alice can choose to include `i` in `c` on her turns, while Bob can choose to remove `i` on his turns.

I need to see how many times Alice can include `i` in `c` before all `i`s are removed.

Wait, perhaps I can model this as a game where there are `cnt[i]` instances of `i`, and Alice and Bob take turns picking them.

But it's more complicated because the game is played on the entire array, not just on one number.

Wait, perhaps I can think in terms of the total number of turns and who gets to pick which elements.

Alternatively, perhaps I can think in terms of the parity of the counts.

Wait, let's consider that Alice and Bob take turns, with Alice starting.

Each turn, either Alice picks an element to include in `c` and removes it from `a`, or Bob just removes an element from `a`.

So, in total, there are `n` turns: Alice's turns (odd-numbered turns) and Bob's turns (even-numbered turns).

I need to see, for each `i`, whether Alice can include at least one `i` in `c` before all `i`s are removed.

Given that, perhaps I can think about the number of times Alice gets to pick `i` before Bob removes it.

Wait, perhaps I can think in terms of the number of times Alice can pick `i` before all `i`s are removed.

Given that, perhaps for each `i`, the number of times Alice can pick it is ceil(cnt[i]/2).

Because for every two turns, Alice gets one pick and Bob gets one removal.

Wait, but it's not exactly alternating removals and picks.

Wait, perhaps I need to simulate the turns.

Let's consider a simple case.

Suppose `cnt[i] = 1`.

Then, if Alice picks it on her turn, it goes to `c`.

If Bob picks it on his turn, it's removed, and Alice cannot include it in `c`.

So, for `cnt[i] = 1`, Alice can include it in `c` only if she picks it before Bob removes it.

Given that, who gets to pick it depends on the turn order.

Since Alice picks first, if `cnt[i] = 1`, Alice can include it in `c` by picking it on her first turn.

Wait, but Bob can also remove it on his turn.

Wait, let's think carefully.

Suppose `cnt[i] = 1`.

- If Alice picks it on her turn, it goes to `c`.

- If Bob picks it on his turn, it's removed, and not in `c`.

So, Alice can include it in `c` only if she picks it before Bob removes it.

Given that, since Alice picks first, if `cnt[i] >= 1`, Alice can always include it in `c` by picking it on her first turn.

Wait, but Bob can remove it on his turn if it's still in `a`.

Wait, no: Alice picks first, so she can pick it first and add it to `c`.

Bob can only remove it if it's still in `a` on his turn.

But if Alice picks it on her first turn, it's added to `c` and removed from `a`, so Bob can't remove it.

Hence, for `cnt[i] >= 1`, Alice can always include it in `c` by picking it on her first turn.

Wait, but what if Bob removes another element on his turn?

Well, Bob can remove any element from `a` on his turn.

So, if Alice picks `i` on her first turn, adds it to `c`, and removes it from `a`, then Bob can remove another element.

So, for `cnt[i] >= 1`, Alice can always include `i` in `c` by picking it on her first turn.

Hence, for all `i` with `cnt[i] >= 1`, Alice can include them in `c`.

Wait, but this seems too optimistic.

Suppose `cnt[i] = 1`, and Alice picks it on her first turn, adds to `c`, removes from `a`.

Then, Bob removes another element.

Then, the game continues until `a` is empty.

But Alice has already included `i` in `c`.

So, for `cnt[i] >= 1`, Alice can always include `i` in `c`.

Hence, the MEX would be the smallest `i` with `cnt[i] = 0`.

But that seems too straightforward, and contradicts the examples.

Wait, in the first example:

n=4

a=[0,0,1,1]

cnt[0]=2

cnt[1]=2

cnt[2]=0

cnt[3]=0

According to this, the MEX would be 2, since cnt[2]=0.

But according to the explanation, it's possible to achieve MEX=2.

But in the second example:

n=4

a=[0,1,2,3]

cnt[0]=1

cnt[1]=1

cnt[2]=1

cnt[3]=1

According to this, MEX would be 4, since cnt[4]=0.

But the output is 1, which contradicts this.

Wait, perhaps I'm missing something.

In the second example, the output is 1, meaning that c=[0,2,3], so MEX=1.

But according to my earlier reasoning, since cnt[1]=1, Alice should be able to include 1 in c.

But in the output, it's 1, meaning that 1 is missing in c.

So, perhaps Alice cannot always include `i` in c even if cnt[i] >=1.

Wait, perhaps Bob can prevent Alice from including certain `i`s.

Let me think again.

Suppose cnt[i] =1.

Alice can pick it on her first turn, add to c, and remove from a.

Bob can remove another element.

So, in this case, Alice can include it.

Wait, but in the second example, with cnt[1]=1, Alice should be able to include 1 in c.

But the output suggests that c=[0,2,3], with MEX=1.

Wait, perhaps in that particular game, Alice didn't include 1.

But according to optimal play, Alice wants to maximize MEX, which would be higher if she includes all smaller numbers.

Wait, perhaps I need to think differently.

Let me consider that Alice wants to include as many small numbers as possible, but Bob can interfere by removing elements that Alice needs.

So, perhaps for numbers with cnt[i]=1, Bob can choose to remove it before Alice picks it.

Wait, but Alice picks first.

Wait, in the first turn, Alice picks an element to include in c and removes it from a.

Bob then picks an element to remove from a.

So, in the first turn, Alice can pick i=1, add to c, remove from a.

Then, Bob can remove another element, say 0.

Then, Alice picks again, picks 2, adds to c, removes from a.

Bob removes 3.

So, c=[1,2], MEX=0, which is worse for Alice.

Wait, but Alice can choose to pick 0 first.

So, Alice picks 0, adds to c, removes from a.

Bob removes 1.

Alice picks 2, adds to c.

Bob removes 3.

So, c=[0,2], MEX=1.

Alternatively, Alice picks 0, adds to c.

Bob removes 0.

Now, a=[1,1].

Alice picks 1, adds to c.

Bob removes 1.

c=[0,1], MEX=2.

So, different sequences lead to different MEX values.

Hence, the game is about choosing which elements to include in c.

Bob can remove elements that Alice needs.

So, perhaps for cnt[i]=1, Bob can choose to remove it if Alice hasn't picked it yet.

Wait, in the first scenario, Alice picks 1, adds to c, removes from a.

Then, Bob removes 0.

Then, Alice picks 2, adds to c.

Bob removes 3.

c=[1,2], MEX=0.

But Alice could have picked 0 first, added to c, then Bob removes 0, but Alice can still pick 1 later.

Wait, no.

If Alice picks 0 first, adds to c, then Bob removes 0.

Now, a=[1,1].

Alice picks 1, adds to c.

Bob removes 1.

c=[0,1], MEX=2.

So, in this case, MEX=2.

In the other case, MEX=0.

So, Alice can choose a better sequence to maximize MEX.

Hence, in this case, MEX=2 is achievable.

Wait, but according to the example, the output is 2 for the first test case.

But in the second test case, with cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1, the output is 1.

According to my earlier reasoning, Alice should be able to include all of them, but the output suggests otherwise.

Wait, perhaps I need to consider that Alice has to include certain numbers in a way that maximizes MEX, but Bob can force some numbers to be removed in a way that minimizes MEX.

Wait, perhaps I need to consider that for each number, the number of times Alice can include it in c is related to the count and the turn order.

Let me try to think in terms of the number of times Alice gets to pick each element.

Given that Alice picks on odd turns and Bob on even turns, and that Bob can remove elements that Alice might need.

Wait, perhaps I can think in terms of the number of available copies of each number and who gets to pick them.

Let's consider that for each number i, the number of times Alice can include it in c is ceil(cnt[i]/2).

Because for every two turns, Alice gets one inclusion.

Wait, but it's not exactly like that, because turns are interleaved.

Wait, perhaps I can think that for cnt[i] >=2, Alice can include at least one in c, and for cnt[i]=1, Alice can include it only if she picks it before Bob removes it.

Wait, but in the earlier example, with cnt[i]=1, Alice can include it by picking it on her first turn.

Hence, perhaps for cnt[i]>=1, Alice can include it in c.

Then, the MEX would be the smallest i with cnt[i]=0.

But in the second test case, n=4, a=[0,1,2,3], cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1, and the output is 1.

According to my earlier reasoning, Alice can include all numbers from 0 to 3, so MEX should be 4.

But the output is 1, which contradicts this.

Hence, my reasoning must be flawed.

So, perhaps I need to think differently.

Let me look at the provided code to understand what it's doing.

The code is:

from collections import defaultdict

for tc in range(int(input())):

print(func_1())

def func_1():

N = int(input())

a = list(map(int, input().split()))

cnt = defaultdict(int)

for i in range(N):

cnt[a[i]] += 1

t = 0

for i in range(N + 1):

if cnt[i] == 1:

t += 1

if t >= 2 or cnt[i] == 0:

return i

So, it's counting the frequency of each number in a.

Then, it iterates from 0 to N:

- If cnt[i] ==1, it increments t.

- If t >=2 or cnt[i]==0, it returns i.

Wait, so it's looking for the smallest i where either cnt[i]==0 or there are at least two numbers with cnt[j]==1.

Wait, that seems arbitrary.

Wait, perhaps it's trying to find the smallest i that Alice cannot guarantee to include in c.

But I'm not sure.

Given the examples:

First test case:

n=4

a=[0,0,1,1]

cnt[0]=2

cnt[1]=2

cnt[2]=0

cnt[3]=0

So, t starts at 0.

i=0: cnt[0]=2 !=1, so t不变.

i=1: cnt[1]=2 !=1, so t不变.

i=2: cnt[2]=0, so return 2.

Which matches the first output.

Second test case:

n=4

a=[0,1,2,3]

cnt[0]=1

cnt[1]=1

cnt[2]=1

cnt[3]=1

t=0

i=0: cnt[0]=1, t=1

i=1: cnt[1]=1, t=2, t>=2, return 1

Which matches the second output.

Third test case:

n=2

a=[1,1]

cnt[1]=2

cnt[0]=0

t=0

i=0: cnt[0]=0, return 0

Which matches the third output.

So, the code seems to be correct, but I need to understand why this logic works.

So, the logic is:

- For each i from 0 to N:

- If cnt[i]==1, increment t.

- If t >=2 or cnt[i]==0, return i.

So, it's returning the smallest i where either cnt[i]==0 or there are at least two numbers with cnt[j]==1.

Wait, but why does this work?

Let me think.

In the first test case, cnt[0]=2, cnt[1]=2, cnt[2]=0, cnt[3]=0.

So, t remains 0 until i=2, where cnt[2]=0, so return 2.

In the second test case, cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1.

At i=1, t=2 (cnt[0]=1 and cnt[1]=1), so return 1.

In the third test case, cnt[1]=2, cnt[0]=0.

At i=0, cnt[0]=0, so return 0.

So, it seems to be working correctly for the examples.

But I need to understand why this logic gives the correct MEX.

Let me try to reason about it.

First, if cnt[i]==0 for some i, then i is not present in a, so it's necessarily in the MEX, because it's missing in c.

But, Alice can include numbers that are present in a, depending on their counts and the actions of Bob.

So, perhaps the presence of multiple numbers with cnt[j]==1 affects Alice's ability to include all small numbers in c.

Wait, perhaps if there are at least two numbers with cnt[j]==1, then Bob can prevent Alice from including one of them in c.

Hence, the smallest such i where t >=2 or cnt[i]==0 is the MEX.

Wait, that makes sense.

Let me think.

Suppose there are at least two numbers with cnt[j]==1.

Then, Bob can choose to remove one of them, preventing Alice from including it in c.

Hence, Alice cannot guarantee including both in c, so the MEX would be the smallest such i.

Wait, but in the first test case, cnt[0]=2, cnt[1]=2, so no cnt[j]==1, and cnt[2]=0, so MEX=2.

In the second test case, cnt[0]=1, cnt[1]=1, so t=2 at i=1, hence MEX=1.

In the third test case, cnt[1]=2, cnt[0]=0, so MEX=0.

So, it seems to work.

Let me try to think of another example.

Suppose n=3

a=[0,1,1]

cnt[0]=1

cnt[1]=2

cnt[2]=0

So, t=0

i=0: cnt[0]=1, t=1

i=1: cnt[1]=2, t=1 (<2)

i=2: cnt[2]=0, return 2

So, MEX=2

But let's see:

Alice can pick 0, add to c, remove from a.

Bob removes 1.

Alice picks 1, adds to c.

So, c=[0,1], MEX=2.

Alternatively, Alice picks 1, adds to c.

Bob removes 1.

Alice picks 1, adds to c.

So, c=[1,1], MEX=0.

But in the first sequence, MEX=2, in the second, MEX=0.

So, Alice can choose to maximize MEX by picking 0 first.

Hence, MEX=2 is achievable.

So, according to the code, it returns 2, which is correct.

Another example:

n=5

a=[0,1,2,3,4]

cnt[0]=1

cnt[1]=1

cnt[2]=1

cnt[3]=1

cnt[4]=1

So, t=0

i=0: cnt[0]=1, t=1

i=1: cnt[1]=1, t=2, t>=2, return 1

So, MEX=1.

Meaning that Bob can prevent Alice from including at least one number among 0 and 1.

Wait, but in this case, Alice can pick 0, add to c.

Bob removes 1.

Alice picks 2, add to c.

Bob removes 3.

Alice picks 4, add to c.

So, c=[0,2,4], MEX=1.

Hence, MEX=1.

Alternatively, Alice picks 1, add to c.

Bob removes 0.

Alice picks 2, add to c.

Bob removes 3.

Alice picks 4, add to c.

So, c=[1,2,4], MEX=0.

So, in both cases, MEX is less than 2.

Hence, MEX=1 is the best Alice can achieve.

So, the code correctly returns 1.

Another example:

n=3

a=[0,0,1]

cnt[0]=2

cnt[1]=1

cnt[2]=0

t=0

i=0: cnt[0]=2, t=0

i=1: cnt[1]=1, t=1 (<2)

i=2: cnt[2]=0, return 2

So, MEX=2.

Is that correct?

Alice picks 0, adds to c.

Bob removes 0.

Alice picks 1, adds to c.

So, c=[0,1], MEX=2.

Alternatively, Alice picks 0, adds to c.

Bob removes 1.

Alice picks 0, adds to c.

c=[0,0], MEX=1.

So, Alice can choose a sequence where MEX=2.

Hence, MEX=2 is achievable.

So, the code is correct in this case.

Another example:

n=1

a=[0]

cnt[0]=1

t=0

i=0: cnt[0]=1, t=1

i=1: cnt[1]=0, return 1

So, MEX=1.

But actually, Alice picks 0, adds to c.

So, c=[0], MEX=1.

Hence, correct.

Another example:

n=2

a=[0,0]

cnt[0]=2

cnt[1]=0

t=0

i=0: cnt[0]=2, t=0

i=1: cnt[1]=0, return 1

But actually, Alice can pick 0, add to c.

Bob removes 0.

Alice picks nothing, as a is empty.

So, c=[0], MEX=1.

Hence, correct.

Seems like the code is working correctly for these cases.

So, perhaps the logic is:

- If there are at least two numbers with cnt[j]==1, then MEX is the smaller one of those.

- Else, MEX is the smallest i with cnt[i]==0.

Because with at least two numbers having cnt[j]==1, Bob can choose to remove one of them, preventing Alice from including it in c.

Hence, the smallest such i is the MEX.

Otherwise, if there's only one j with cnt[j]==1, Alice can include it in c, and MEX is the smallest i with cnt[i]==0.

Wait, but in the second test case, there are four numbers with cnt[j]==1, and MEX is 1.

But according to this, MEX should be the smallest j where cnt[j]==0, which would be 4.

But it's returning 1, which is correct.

Wait, perhaps I need to think differently.

Wait, perhaps MEX is the smallest i where cnt[i] < 2.

Because if cnt[i] >=2, Alice can include it in c by picking it on her turn, even if Bob removes one.

If cnt[i]==1, Bob can remove it before Alice picks it.

Hence, for cnt[i]==1, Alice cannot guarantee including it in c.

Hence, MEX is the smallest i where cnt[i] <2.

Wait, in the first test case, cnt[0]=2, cnt[1]=2, cnt[2]=0, cnt[3]=0.

So, cnt[0]>=2, cnt[1]>=2, cnt[2]<2, so MEX=2.

In the second test case, cnt[0]=1 <2, so MEX=1.

In the third test case, cnt[1]=2, cnt[0]=0, so MEX=0.

Wait, but in the second test case, cnt[0]=1, which is <2, so MEX=1.

Hence, the MEX is the smallest i where cnt[i]<2.

Hence, the code is checking for cnt[i]==1, incrementing t, and if t>=2 or cnt[i]==0, return i.

Wait, but in the second test case, t=2 at i=1, so return 1.

Which matches cnt[0]=1 and cnt[1]=1.

Hence, when t>=2, it returns i.

Which aligns with the logic that if there are at least two numbers with cnt[j]==1, then MEX is the smaller one among them.

Otherwise, it's the smallest i with cnt[i]==0.

Wait, but in the first test case, t=0 since cnt[i]>=2 for i=0,1, so it returns the smallest i with cnt[i]==0, which is 2.

In the second test case, t=2 at i=1, so return 1.

In the third test case, t=0 at i=0, cnt[0]==0, so return 0.

Hence, the code seems to be correctly implementing this logic.

Hence, the code is correct.

**Final Solution**

To solve this problem, we need to determine the final score of a game played between Alice and Bob on an array, where the score is defined as the MEX of the array collected by Alice. Both players play optimally, with Alice aiming to maximize the score and Bob aiming to minimize it.

## Approach

1. **Understanding MEX**: MEX of an array is the smallest non-negative integer not present in the array.
2. **Game Mechanics**:
   - Alice starts with an empty array `c`.
   - Players take turns, starting with Alice.
   - Alice picks an element from `a`, appends it to `c`, and deletes it from `a`.
   - Bob picks an element from `a`, deletes it from `a`, but does not add it to `c`.
   - The game ends when `a` is empty.
3. **Optimal Play**:
   - Alice wants to maximize the MEX of `c`.
   - Bob wants to minimize the MEX of `c`.
4. **Strategy**:
   - Count the frequency of each element in `a`.
   - For each number `i` from 0 to `n`:
     - If the count of `i` is 0, it's immediately a candidate for MEX.
     - If the count of `i` is 1, it's vulnerable to being removed by Bob before Alice can include it in `c`.
     - If the count of `i` is 2 or more, Alice can ensure at least one instance of `i` is included in `c`.

5. **Logic**:
   - Track the numbers with a count of 1.
   - If there are at least two numbers with a count of 1, the MEX is the smaller one among them.
   - Otherwise, the MEX is the smallest `i` where the count is 0.

## Solution Code

```python
from collections import defaultdict

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    tc = int(data[0])
    idx = 1
    for _ in range(tc):
        N = int(data[idx])
        idx += 1
        a = list(map(int, data[idx:idx+N]))
        idx += N
        print(func_1(N, a))

def func_1(N, a):
    cnt = defaultdict(int)
    for num in a:
        cnt[num] += 1
    t = 0
    for i in range(N + 1):
        if cnt[i] == 1:
            t += 1
        if t >= 2 or cnt[i] == 0:
            return i

if __name__ == "__main__":
    main()
```

## Explanation

1. **Reading Input**:
   - Read the number of test cases.
   - For each test case, read `n` and the array `a`.

2. **Counting Frequencies**:
   - Use a dictionary to count the occurrences of each element in `a`.

3. **Determining MEX**:
   - Iterate from 0 to `n`:
     - If the count of `i` is 1, increment a counter `t`.
     - If `t` reaches 2 or the count of `i` is 0, return `i` as the MEX.

This approach ensures that we correctly determine the smallest possible MEX that Alice can achieve against Bob's optimal strategy.