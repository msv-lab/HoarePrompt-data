Alright, I have this problem to solve. Let's see what it's about. So, there's this physical education lesson in a school, and students are lining up and getting assigned numbers based on their positions and a parameter k. The goal is to help Vasya remember possible values of k given his position n and the number x he received.

First, I need to understand how the numbering works. It says that the first k people get numbers 1 through k, and then the next k-2 people get numbers k-1 down to 2, and this pattern repeats every 2k-2 positions.

So, for example, if k=3, the sequence would be:

Position: 1 2 3 4 5 6 7 8 9 10...

Numbers: 1 2 3 2 1 2 3 2 1 2...

Wait, in the example for k=3:

1:1, 2:2, 3:3, 4:2, 5:1, 6:2, 7:3, 8:2, 9:1, 10:2,...

Yes, that matches.

Another example for k=2:

1:1, 2:2, 3:1, 4:2, 5:1, 6:2, 7:1, 8:2,...

And for k=5:

1:1, 2:2, 3:3, 4:4, 5:5, 6:4, 7:3, 8:2, 9:1, 10:2,...

Okay, I see the pattern. It's like a wave that goes up to k and then down to 2, and repeats every 2k-2 positions.

Now, Vasya remembers his position n and the number x he received. I need to find all possible k >1 such that in this numbering scheme, position n would be assigned number x.

Constraints:

- t (number of test cases) is between 1 and 100.

- For each test case, n and x are integers where 1 <= x < n <= 10^9.

Given that n can be up to 10^9, any solution needs to be efficient, probably O(1) or O(sqrt(n)) per test case to handle large inputs in time.

First, I need to model the problem mathematically.

Let's think about the repeating pattern every 2k-2 positions.

Let’s denote p = 2k - 2.

So, the pattern repeats every p positions.

Within each block of p positions, the first k positions are 1 to k, and the next k-2 positions are k-1 down to 2.

So, for position n, we can find out which block it falls into and its position within the block.

Let’s compute block_number = (n-1) // p

And position_in_block = (n-1) % p + 1

Then, within the block, if position_in_block <= k, number is position_in_block

Else, number is p - position_in_block + 2

Wait, let's verify that.

For k=3, p=4

Positions in block:

1:1, 2:2, 3:3, 4:2

So, for position_in_block from 1 to k (1 to 3): number = position_in_block

From k+1 to p (4): number = p - position_in_block + 2 = 4 - 4 + 2 = 2

Yes, matches the sequence.

For k=2, p=2

Positions:

1:1, 2:2, 3:1, 4:2,...

So, position_in_block from 1 to k (1 to 2): number = position_in_block

From k+1 to p (3): but p=2, so only positions 1 and 2 in each block.

Wait, for k=2, p=2, so blocks are [1,2], [1,2],...

No, according to the problem, for k=2, the pattern is 1,2,1,2,...

Yes, so p=2, block size 2.

For k=3, p=4, block size 4: 1,2,3,2

For k=5, p=8: 1,2,3,4,5,4,3,2

Yes.

So, in general:

- p = 2k - 2

- For position_in_block from 1 to k: number = position_in_block

- For position_in_block from k+1 to p: number = p - position_in_block + 2

Wait, for position_in_block > k:

number = p - position_in_block + 2

Let's test for k=3, p=4:

position_in_block=4: number = 4 - 4 + 2 = 2

position_in_block=3: number = 4 - 3 + 2 = 3

position_in_block=2: number = 4 - 2 + 2 = 4, but in the sequence for k=3, position 2 is 2, not 4.

Wait, perhaps my formula is incorrect.

Wait, for position_in_block > k, number decreases from k-1 down to 2.

So, for position_in_block from k+1 to p:

number = p - (position_in_block - k) + 1

Wait, need to think differently.

Let’s think of the sequence as:

- Positions 1 to k: 1 to k

- Positions k+1 to 2k-2: k-1 down to 2

So, for position_in_block > k:

number = k - (position_in_block - k) + 1

Simplify: number = 2k - position_in_block + 1

Let's test for k=3, p=4

position_in_block=4: number = 2*3 - 4 + 1 = 6 - 4 +1 =3, but in the sequence, position 4 should be 2.

Wait, that doesn't match.

Wait, perhaps number = k + 1 - (position_in_block - k)

For k=3, position_in_block=4: number = 3 + 1 - (4 - 3) =4 -1=3, but should be 2.

Hmm.

Wait, maybe number = p - position_in_block + 2

For k=3, p=4, position_in_block=4: 4 - 4 +2=2, position_in_block=3:4-3+2=3

Which matches the sequence.

For k=5, p=8, position_in_block=8:8-8+2=2, position_in_block=7:8-7+2=3, position_in_block=6:8-6+2=4

Which matches 1,2,3,4,5,4,3,2

Yes, so for position_in_block > k:

number = p - position_in_block + 2

Good.

So, in code:

if position_in_block <= k:

number = position_in_block

else:

number = p - position_in_block + 2

Now, given n and x, I need to find all k >1 such that for this n, the number assigned is x.

So, for each k, compute p = 2k -2

Compute position_in_block = n % p

If position_in_block ==0, position_in_block = p

Then, compute number based on position_in_block and k

Check if number == x

If yes, k is valid.

But since n and k can be up to 1e9, I need an efficient way to find all such k.

Also, k must be >=2.

And since p = 2k -2, p increases with k.

Given that n can be up to 1e9, I need a smarter way than iterating over all possible k.

Let me see.

First, let's consider the general case where p = 2k -2, and k >=2.

So, p >=2.

Now, for a given n and x, I need to find k such that:

- p = 2k -2

- position_in_block = n % p

- if position_in_block ==0, position_in_block = p

- if position_in_block <=k, number = position_in_block

- else, number = p - position_in_block +2

- check if number ==x

Now, I need to find all k >=2 where this condition holds.

This seems a bit involved. Maybe there's a mathematical way to find all such k.

Let me try to express position_in_block in terms of k.

position_in_block = n - floor((n-1)/p) * p

Wait, more accurately:

position_in_block = n - floor(n/p) * p

If position_in_block ==0, it means n is a multiple of p, so position_in_block =p

Else, position_in_block = n % p

So, position_in_block = n % p

if position_in_block ==0: position_in_block =p

Ok, now, for a given k, p=2k-2

So, position_in_block = n % (2k-2)

if position_in_block ==0: position_in_block=2k-2

Then, if position_in_block <=k: number=position_in_block

else: number= (2k-2) - position_in_block +2

Simplify: number=2k - position_in_block

So, number=2k - position_in_block

Wait, for position_in_block >k:

number=2k - position_in_block

Yes, that matches the earlier formula.

So, in general:

if position_in_block <=k:

number=position_in_block

else:

number=2k - position_in_block

Now, set number=x, so:

if position_in_block <=k:

x=position_in_block

else:

x=2k - position_in_block

Now, position_in_block = n % p, where p=2k-2

If position_in_block ==0: position_in_block=2k-2

So, position_in_block = n % (2k-2)

if position_in_block ==0: position_in_block=2k-2

Now, I need to consider two cases:

1. position_in_block <=k, so x=position_in_block

2. position_in_block >k, so x=2k - position_in_block

Let's consider each case separately.

Case 1: position_in_block <=k, so x=position_in_block

Which means position_in_block=x, and x<=k

But position_in_block = n % p, where p=2k-2

So, n % (2k-2) =x, and x<=k

But n % (2k-2) can be from 1 to 2k-2

Wait, n % p can be from 0 to p-1, but since p=2k-2, and if n % p ==0, position_in_block=p=2k-2

So, position_in_block can be from 1 to 2k-2

But in this case, position_in_block <=k, which implies x<=k

And position_in_block =x

So, x <=k

Also, position_in_block = n % p, with adjustment for 0

So, n % p =x, if x !=0

If x=0, position_in_block=p=2k-2

But x is at least 1, as per constraints (1<=x<n<=1e9)

So, n % p =x

Thus, n -x is divisible by p

So, p divides (n -x)

But p=2k-2

So, 2k-2 divides n -x

Therefore, 2k-2 divides n -x

Additionally, since position_in_block <=k, which is x<=k

So, x <=k

But k >=2, and x >=1

So, from 2k -2 divides n -x, and x <=k

We can express this as:

2k -2 divides n -x, and k >=x

Wait, x <=k

Wait, no: position_in_block <=k implies x <=k

But k can be larger than x

Wait, but in this case, x <=k

Wait, but in the problem, x can be less than or equal to k

Wait, but in the problem, x can be up to n-1, and n can be up to 1e9

But in this case, x <=k

Wait, but k can be up to n, but in this case, we have to find k such that x <=k and 2k-2 divides n -x

So, for each k >=2, such that x <=k, and 2k-2 divides n -x

That's one set of possible k

Now, case 2:

position_in_block >k, so x=2k - position_in_block

And position_in_block = n % p or p if n % p ==0

So, position_in_block >k

So, x=2k - position_in_block

Also, position_in_block >k, and position_in_block <=2k-2

So, position_in_block >k, position_in_block <=2k-2

Therefore, x=2k - position_in_block <2k -k= k

So, x <k

Also, position_in_block >=k+1, so x=2k - position_in_block <=2k - (k+1)=k-1

Therefore, x <=k-1

So, in this case, x <k

Now, position_in_block = n % p or p if n % p ==0

So, position_in_block = n % (2k-2)

if n % (2k-2) ==0: position_in_block=2k-2

else: position_in_block= n % (2k-2)

Given that position_in_block >k, so either 2k-2 >k, which is true since k >=2, 2k-2 >=2, and 2k-2 >k when k >2

Wait, for k=2, 2k-2=2, which is equal to k=2, so for k=2, position_in_block >k would be position_in_block >2, but 2k-2=2, so position_in_block=2k-2=2, which is equal to k=2, so position_in_block >k is position_in_block >2, but position_in_block=2, so no.

Wait, for k=2, p=2, position_in_block = n %2

if n%2==0, position_in_block=2

else, position_in_block=1

Then, for position_in_block >k, which is position_in_block >2, but position_in_block=2 or 1, so only position_in_block=2 >k=2 is false, since 2>2 is false.

Wait, so for k=2, position_in_block >k is false, so only case 1 applies.

Similarly, for k=3, p=4

position_in_block = n%4

if n%4==0, position_in_block=4

else, position_in_block=n%4

Then, position_in_block >k=3 implies position_in_block=4

So, position_in_block=4 >3, so x=2*3 -4=2

So, x=2

So, in this case, x=2 <k=3

So, it fits.

So, in general, for case 2:

x=2k - position_in_block

position_in_block >k, so position_in_block = n % p or p if n % p ==0

So, position_in_block >k

Thus, position_in_block = n % p or p if n % p ==0

So, position_in_block = n mod p

if position_in_block ==0: position_in_block=p

So, position_in_block >k implies n mod p >k or (n mod p ==0 and p >k)

But p=2k-2

So, position_in_block >k implies n mod p >k or (n mod p ==0 and p >k)

But p=2k-2

So, n mod (2k-2) >k or (n mod (2k-2)==0 and 2k-2 >k)

So, in this case, x=2k - position_in_block

So, position_in_block = n mod (2k-2) or 2k-2 if n mod (2k-2)==0

Then, x=2k - position_in_block

So, x=2k - position_in_block

Therefore, x + position_in_block =2k

But position_in_block = n mod (2k-2) or 2k-2 if n mod (2k-2)==0

So, x + position_in_block =2k

Therefore, position_in_block =2k -x

But position_in_block = n mod (2k-2) or 2k-2 if n mod (2k-2)==0

So, 2k -x = n mod (2k-2) or 2k-2 if n mod (2k-2)==0

So, 2k -x = n mod (2k-2) or 2k-2

Therefore, n mod (2k-2) =2k -x or n mod (2k-2)==0 and 2k-2=2k -x

So, n mod (2k-2) =2k -x or (n mod (2k-2)==0 and 2k-2=2k -x)

Simplify:

n mod (2k-2) =2k -x or (n mod (2k-2)==0 and 2k-2=2k -x)

But 2k -x= position_in_block

And position_in_block <=2k-2

So, 2k -x <=2k-2

Which implies x >=2

Also, x <k in this case

Wait, earlier we had x <k in this case

So, x <k, and x >=1

So, 1 <=x <k

Now, from 2k -x = n mod (2k-2) or (n mod (2k-2)==0 and 2k-2=2k -x)

Wait, n mod (2k-2) =2k -x or (n mod (2k-2)==0 and 2k-2=2k -x)

But 2k -x= position_in_block

Also, position_in_block >k, which is position_in_block=2k -x >k

So, 2k -x >k => k >x

Which is consistent with x <k

Also, position_in_block <=2k-2

So, 2k -x <=2k-2 => x >=2

Therefore, in this case, x >=2 and x <k

Now, from n mod (2k-2) =2k -x or (n mod (2k-2)==0 and 2k-2=2k -x)

Wait, if n mod (2k-2)==0, then position_in_block=2k-2=2k -x

So, 2k -2=2k -x => x=2

Therefore, in this subcase, x=2

Otherwise, n mod (2k-2)=2k -x

So, two subcases:

1. n mod (2k-2)=2k -x, with x >=2 and x <k

2. n mod (2k-2)==0 and x=2

Now, let's consider these subcases.

First subcase:

n mod (2k-2)=2k -x

Which implies n - (2k -x) is divisible by (2k-2)

So, n -2k +x is divisible by (2k-2)

Therefore, (2k-2) divides (n -2k +x)

Simplify: (2k-2) divides (n +x -2k)

So, 2k -2 divides n +x -2k

Which can be written as 2k -2 divides -(n +x -2k)

Which is the same as 2k -2 divides n +x -2k

Wait, actually, if a divides b, then a divides -b

So, 2k -2 divides n +x -2k

Now, let's rearrange:

n +x -2k is divisible by 2k -2

Let’s set d=2k -2

Then, n +x -2k = n +x - (d +2)

So, n +x -d -2 is divisible by d

Which is (n +x -2) -d is divisible by d

But d divides d, so d divides (n +x -2) -d implies d divides n +x -2 -d

But n +x -2 -d = n +x -2 - (2k -2) = n +x -2k

Wait, I'm going in circles.

Let me think differently.

Given that 2k -2 divides n -2k +x

I can write this as 2k -2 divides n +x -2k

Let’s set m=2k -2

Then, m divides n +x -k -k +x

Wait, perhaps not helpful.

Alternatively, solve for k:

m=2k -2

So, k=(m +2)/2

Then, m divides n +x -k -k +x

Wait, perhaps not helpful.

Alternatively, since m=2k -2, and m divides n +x -2k

But 2k =m +2

So, m divides n +x - (m +2)

Which is n +x -m -2

So, m divides (n +x -2) -m

Which implies m divides n +x -2 -m

But m divides m, so m divides n +x -2 -m implies m divides n +x -2

Therefore, m divides n +x -2

But m=2k -2

So, 2k -2 divides n +x -2

Therefore, for case 1: 2k -2 divides n -x

And x <=k

For case 2: 2k -2 divides n +x -2

And x <k and x >=2

Wait, in subcase 2, x=2 when n mod (2k-2)==0

So, x=2 and 2k -2 divides n -x

Wait, no, in subcase 2, x=2 and n mod (2k-2)==0

But 2k -2 divides n -x, with x=2

So, 2k -2 divides n -2

But in subcase 1, 2k -2 divides n +x -2k

Wait, perhaps I need to combine these.

Wait, perhaps it's better to consider y=n +x -2

Then, in case 1: 2k -2 divides y, with x <=k

In case 2: 2k -2 divides y, with x <k and x >=2

Wait, but in case 1, 2k -2 divides n -x

Wait, no, in case 1, 2k -2 divides n -x, and x <=k

In case 2, 2k -2 divides n +x -2

Wait, perhaps I need to reconcile these.

Wait, perhaps it's better to consider that in both cases, 2k -2 divides n +x -2

Wait, let's check:

In case 1: position_in_block <=k, so x=position_in_block

position_in_block = n mod (2k-2) or 2k-2 if n mod (2k-2)==0

So, position_in_block = n mod (2k-2)

if n mod (2k-2)==0: position_in_block=2k-2

So, x=position_in_block

So, x <=k

So, x <=k

Now, in case 2: position_in_block >k, so x=2k - position_in_block

position_in_block = n mod (2k-2) or 2k-2 if n mod (2k-2)==0

So, position_in_block >k

So, x=2k - position_in_block

So, x + position_in_block =2k

But position_in_block = n mod (2k-2) or 2k-2 if n mod (2k-2)==0

So, x + position_in_block =2k

Therefore, x + position_in_block =2k

But position_in_block = n mod (2k-2) or 2k-2

So, x + (n mod (2k-2)) =2k or x + 2k -2=2k

In the second case, x + 2k -2=2k => x=2

In the first case, x + n mod (2k-2)=2k

So, n mod (2k-2)=2k -x

Therefore, in both cases:

- If n mod (2k-2)=2k -x, then x <=k (case 1)

- If n mod (2k-2)==0 and x=2, then position_in_block=2k-2=2k -x => x=2

Wait, when n mod (2k-2)==0, position_in_block=2k-2

Then, x=2k - position_in_block=2k - (2k -2)=2

So, x=2

Therefore, in this subcase, x=2

So, overall, in both cases:

n mod (2k-2)=2k -x

But when n mod (2k-2)==0, x=2

Otherwise, x=position_in_block <=k

Wait, but in case 1, x=position_in_block <=k, and position_in_block = n mod (2k-2)

So, n mod (2k-2)=x

In case 2, n mod (2k-2)=2k -x, and x=2 when n mod (2k-2)==0

So, in general, n mod (2k-2)=2k -x

But when n mod (2k-2)==0, x=2

Otherwise, x=position_in_block <=k

Wait, perhaps it's better to consider y=n +x -2

Then, in both cases, 2k -2 divides y

Wait, let's see:

In case 1: 2k -2 divides n -x

In case 2: 2k -2 divides n +x -2

But in case 2, x=2 when n mod (2k-2)==0

Wait, perhaps it's better to consider that in both cases, 2k -2 divides n +x -2

Wait, let's check:

In case 1: 2k -2 divides n -x

In case 2: 2k -2 divides n +x -2

So, in general, 2k -2 divides either n -x or n +x -2

But I need to find a way to combine these.

Wait, perhaps I can consider that in both cases, 2k -2 divides n +x -2

Wait, let's see:

In case 1: 2k -2 divides n -x

In case 2: 2k -2 divides n +x -2

So, y=n +x -2

In case 1: 2k -2 divides y -2x

Because y -2x = n +x -2 -2x = n -x -2

Wait, not helpful.

Alternatively, perhaps consider that in both cases, 2k -2 divides some expression involving n and x

Wait, perhaps I need to think differently.

Let’s set m=2k -2

Then, k=(m +2)/2

Now, in case 1: m divides n -x, with x <=k

In case 2: m divides n +x -2, with x <k and x >=2

Now, since k=(m +2)/2, we can express x in terms of m

In case 1: x <=k=(m +2)/2

In case 2: x <k=(m +2)/2 and x >=2

So, for each m, which is even since m=2k -2 and k >=2 implies m >=2 and m is even

Wait, m=2k -2

For k=2, m=2

For k=3, m=4

For k=4, m=6

So, m is even for k >=2

So, m >=2 and m is even

Now, for each m, check if m divides n -x or m divides n +x -2, with constraints on x in terms of m and k

But perhaps it's better to iterate over possible m and check the conditions.

Wait, perhaps I can consider that in both cases, m divides n +x -2

Wait, in case 1: m divides n -x

In case 2: m divides n +x -2

So, overall, m divides either n -x or n +x -2

But I need to find m such that m divides either n -x or n +x -2, with m=2k -2 and k >=2

Now, to find all k >=2 such that m=2k -2 divides either n -x or n +x -2, with constraints on x in terms of k

But this seems complicated.

Wait, perhaps I can consider that in both cases, m divides n +x -2

Wait, in case 1: m divides n -x

In case 2: m divides n +x -2

So, overall, m divides (n -x) or (n +x -2)

Now, m=2k -2

So, for each m, check if m divides (n -x) or m divides (n +x -2), with k=(m +2)/2 >=2 and integer

Also, k >=x in case 1, and k >x in case 2 with x >=2

Wait, perhaps it's better to consider y=n +x -2

Then, in both cases, m divides y

Because in case 1: m divides n -x

But n -x = y -2x +2

Wait, n -x = (n +x -2) -2x +2 = y -2x +2

So, m divides y -2x +2

But also m divides y

Wait, no, that's not helping.

Alternatively, perhaps consider that in both cases, m divides y

Wait, perhaps I need to accept that in both cases, m divides y=n +x -2

Wait, in case 1: m divides n -x

In case 2: m divides n +x -2

So, perhaps I can consider that m divides n +x -2 in both cases

Wait, but in case 1, m divides n -x, which is different

Unless there's a relationship between n -x and n +x -2

Let’s see: n -x = n +x -2 -2x +2

So, n -x = (n +x -2) -2x +2

So, if m divides n -x and n +x -2, then m divides their sum and difference

But perhaps this is not helpful.

Wait, perhaps I need to consider that in both cases, m divides y=n +x -2

Then, for k=(m +2)/2, check if x <=k in case 1 or x <k in case 2

But this seems too convoluted.

Maybe I need to think about the possible values of m that divide y=n +x -2

Then, for each such m, set k=(m +2)/2 and check if k is integer and >=2, and satisfies x <=k or x <k depending on the case.

Wait, perhaps it's better to consider that m divides y=n +x -2, and m=2k -2

So, for m dividing y, m=2k -2, k=(m +2)/2

Then, k needs to be integer, so m must be even

Also, k >=2, so m >=2

Now, for each m that divides y=n +x -2, with m >=2 and even, set k=(m +2)/2

Then, check if x <=k or x <k depending on the case

Wait, but in case 1, x <=k, and in case 2, x <k and x >=2

So, perhaps I can consider that for each m dividing y, with m >=2 and even, k=(m +2)/2

Then, check if x <=k or x <k depending on the case

But I need to distinguish between the two cases.

Wait, perhaps it's better to consider that for each m dividing y, with m >=2 and even, k=(m +2)/2

Then, check if x <=k or x <k based on the position_in_block

But this seems too involved.

Maybe there's a better way.

Let’s look at the sample input and output to get some intuition.

Sample Input:

5

10 2

3 1

76 4

100 99

1000000000 500000000

Sample Output:

4

1

9

0

1

So, for n=10, x=2, there are 4 possible k: 2,3,5,6

Let’s verify:

For k=2: p=2, sequence:1,2,1,2,1,2,1,2,1,2

Position 10:2, which matches x=2

For k=3: p=4, sequence:1,2,3,2,1,2,3,2,1,2

Position 10:2, matches x=2

For k=5: p=8, sequence:1,2,3,4,5,4,3,2,1,2

Position 10:2, matches x=2

For k=6: p=10, sequence:1,2,3,4,5,6,5,4,3,2

Position 10:2, matches x=2

So, these k are valid.

Similarly, for n=3, x=1:

Possible k:2

For k=2: p=2, sequence:1,2,1

Position 3:1, matches x=1

Hence, only one k=2

Another test case: n=76, x=4

Possible k:3,4,5,8,9,10,11,12,13

Total 9

And so on.

So, in the first test case, k=2,3,5,6 are valid

Wait, but according to the sequence for k=4:

p=6, sequence:1,2,3,4,3,2,1,2,3,4,3,2,...

Position 10:4, matches x=4

Wait, but in the first test case, k=4 should also be valid, but it's not listed in the 4 possible k:2,3,5,6

Wait, perhaps I made a mistake.

Wait, no, in the first test case, k=4 is not listed among the 4 possible k:2,3,5,6

But according to the sequence for k=4, position 10 is 4, which matches x=2?

Wait, no, for k=4, p=6

Sequence:1,2,3,4,3,2,1,2,3,4,3,2,...

Position 10:4, but x=2, which does not match.

Wait, in the first test case, n=10, x=2

So, for k=4, position 10 is 4, which does not match x=2

Hence, k=4 is invalid in this case.

Wait, perhaps I misread the sequence.

Wait, for k=4, p=6

Positions:1:1,2:2,3:3,4:4,5:3,6:2,7:1,8:2,9:3,10:4,...

So, position 10:4, which does not match x=2

Hence, k=4 is invalid.

Similarly, for k=7: p=12, sequence:1,2,3,4,5,6,7,6,5,4,3,2,1,2,...

Position 10:4, which does not match x=2

Hence, k=7 is invalid.

Wait, but according to the sample input, for n=10, x=2, k=2,3,5,6 are valid

So, perhaps there's a pattern where k divides something related to n and x.

I need to find a general way to compute the number of k for given n and x.

Let me look back at the earlier approach.

We have y=n +x -2

Then, in both cases, m=2k -2 divides y

Also, k >=x in case 1, and k >x in case 2 with x >=2

Now, m=2k -2 divides y

So, for each m that divides y, with m >=2 and even, set k=(m +2)/2

Then, check if k satisfies the constraints based on the case.

But this seems too involved.

Perhaps I can consider that m divides y, m >=2, m even, and then k=(m +2)/2

Then, check if x <=k or x <k based on the case.

But I need to find a way to count the number of such m that satisfy these conditions.

Wait, perhaps I can iterate over all possible m that divide y, with m >=2 and even, and then check the constraints on x and k.

But since y can be up to 2*1e9, which is 2e9, iterating over all divisors of y might be too slow, as y can be up to 2e9.

But, in reality, finding the divisors of y can be done efficiently if I factorize y.

But factorizing y up to 2e9 per test case might be time-consuming, but perhaps feasible if I implement an efficient factorization method.

But perhaps there's a smarter way.

Let’s consider that m=2k -2 divides y=n +x -2

So, m divides y

Hence, m is a divisor of y

So, to find all m that divide y, with m >=2 and even, then set k=(m +2)/2

Then, check if k >=2 and satisfies the constraints based on the case.

But, perhaps, since m=2k -2, and m divides y, then for each divisor m of y, with m >=2 and even, set k=(m +2)/2 and check if k >=2 and satisfies x <=k or x <k based on the case.

But, perhaps, since m=2k -2 divides y, and m >=2 and even, then k=(m +2)/2 is integer and >=2

Then, the number of such k is equal to the number of even divisors of y that are >=2, provided that k >=x in case 1 or k >x in case 2.

Wait, but I need to consider the constraints on x in relation to k.

Wait, perhaps it's sufficient to just count the number of m that divide y, with m >=2 and even, and then set k=(m +2)/2, and ensure that k >=x in case 1 or k >x in case 2.

But this seems too vague.

Let me think differently.

Let’s consider that m=2k -2 divides y=n +x -2

So, m divides y

Hence, m is a divisor of y

So, to find all m that divide y, with m >=2 and even

Then, for each such m, set k=(m +2)/2

Then, check if k >=x in case 1 or k >x in case 2

But, in case 1, position_in_block <=k, which corresponds to x <=k

In case 2, position_in_block >k, which corresponds to x <k and x >=2

So, for each m dividing y, with m >=2 and even, set k=(m +2)/2

Then, check if x <=k or (x <k and x >=2)

But x <k is already covered in the case 2, and x >=2

So, perhaps I can just count the number of m dividing y, with m >=2 and even, and k=(m +2)/2 >=x

Wait, but in case 1, x <=k, and in case 2, x <k and x >=2

So, overall, x <=k or (x <k and x >=2)

But x <k is already covered in x <=k

Wait, perhaps I can just count the number of m dividing y, with m >=2 and even, and k=(m +2)/2 >=x

But need to ensure that in case 2, x >=2

But perhaps it's sufficient to count the number of m dividing y, with m >=2 and even, and k=(m +2)/2 >=x

Then, adjust for x >=2 in case 2

But this seems too tangled.

Maybe I need to accept that it's complex and proceed to implement a function that finds all even divisors of y that are >=2, and then set k=(m +2)/2, and check if k >=x

But, in practice, for efficiency, I need a fast way to find the divisors of y.

Given that y=n +x -2, and n and x are up to 1e9, y can be up to 2e9 -1

To find all divisors of y efficiently, I can implement a function that finds all divisors of y in O(sqrt(y)) time.

Then, iterate over all divisors m of y, check if m >=2 and m is even, then set k=(m +2)/2, and check if k >=x

But, in case 2, x <k and x >=2

Wait, perhaps I need to split the counting into two parts: case 1 and case 2

For case 1: m=2k -2 divides n -x, with x <=k

For case 2: m=2k -2 divides n +x -2, with x <k and x >=2

So, overall, the number of k is the number of m dividing n -x, with m >=2 and even, and k=(m +2)/2 >=x

Plus the number of m dividing n +x -2, with m >=2 and even, and k=(m +2)/2 >x and x >=2

Wait, but this might double-count some k

So, perhaps I need to ensure that the two cases are mutually exclusive.

Wait, in case 1: m divides n -x, and x <=k

In case 2: m divides n +x -2, and x <k and x >=2

Now, for a given k, m=2k -2

If m divides both n -x and n +x -2, then it would be counted in both cases, but that's not possible because x cannot be both <=k and <k unless x=k

Wait, if x=k, then it falls into case 1: x <=k

But in case 2, x <k

So, if x=k, it's only in case 1

Hence, the two cases are mutually exclusive.

Therefore, the total number of k