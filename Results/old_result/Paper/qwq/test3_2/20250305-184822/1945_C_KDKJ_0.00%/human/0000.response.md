Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n houses in a village, and the villagers want to build a big road that divides the village into left and right sides. Each resident has a preference for either the left or the right side, represented by a sequence of 0s and 1s, where 0 means they want to live on the left and 1 means they want to live on the right.

The road can be built between any two houses, or before the first house or after the last house. The goal is to place the road such that at least half of the residents on each side are satisfied with their side. Satisfaction means that their preferred side matches the side they end up on.

Moreover, among all possible positions where this condition is satisfied, we need to choose the position that is as close as possible to the middle of the village. If there are multiple positions that are equally close to the middle, we should choose the smallest one.

First, I need to understand the problem fully. We have a sequence of houses with their side preferences. We need to split this sequence at some point, creating a left group and a right group. For each group, we need to check if at least half of the residents want to be on that side.

For example, if we split after the k-th house, the left side will be houses 1 to k, and the right side will be houses k+1 to n. We need to ensure that in the left group, at least ceil(k/2) houses have a=0, and in the right group, at least ceil((n-k)/2) houses have a=1.

The task is to find the split position i (where the road is built after the i-th house) that minimizes |n/2 - i|, and among such positions, choose the smallest i.

The problem states that a solution always exists, so I don't need to worry about cases where no such split is possible.

Now, looking at the provided code, it seems to implement a function func_1() that handles one test case, and func_2() that iterates over multiple test cases.

In func_1(), it reads the input for one test case: n and the string a of length n consisting of 0s and 1s.

It then creates a list S that seems to accumulate the counts of 0s and 1s up to each position. S is initialized with [0,0], and for each character in a, it increments either the first element (for '0') or the second element (for '1') in the accumulated list S.

Then, it iterates over each possible split position i from 0 to n-1. For each i, it calculates the left side as houses 1 to i, and the right side as houses i+1 to n.

It calculates the number of 0s and 1s on each side and checks if at least half of the residents on each side are satisfied with their side.

If the condition is met, it checks if the current position i is closer to n/2 than the previous best answer. If it is, it updates the answer to i.

Finally, it prints the answer.

Wait, but in the code, ans is initialized to 0, which would correspond to splitting before the first house. But according to the problem, splitting before the first house means the entire village is on the right side.

I need to make sure that the code correctly handles the case when i=0 and when i=n.

Let me check the logic:

- For i=0: left side has 0 houses, right side has all n houses.

- For i=n: left side has all n houses, right side has 0 houses.

But in the code, i iterates from 0 to n-1, and the left side is houses 1 to i, right side is i+1 to n.

Wait, but in the code, S[i][0] gives the number of 0s up to house i, and S[i][1] gives the number of 1s up to house i.

So, for i=0: left side has 0 houses, right side has all n houses.

For i=0:

left = S[0][0] = 0 (since S[0] = [0,0])

lsum = S[0][0] + S[0][1] = 0

right = S[-1][1] - S[0][1] = total 1s - 0 = total 1s

rsum = n - lsum = n - 0 = n

Then, it checks if left * 2 < lsum or right * 2 < rsum.

Since lsum = 0, left * 2 = 0 < 0 is False, so it doesn't skip.

Then, it checks if abs(n / 2 - 0) <= abs(n / 2 - ans), and if so, sets ans = 0.

Similarly, for i from 1 to n-1, it calculates left and right accordingly.

Seems correct.

But in the problem, i is the number of houses on the left side, so i can be from 0 to n.

Wait, in the code, i ranges from 0 to n-1, and left side is houses 1 to i.

So, i=0 means no houses on the left, all on the right.

i=1 means one house on the left, n-1 on the right.

...

i=n-1 means n-1 houses on the left, 1 on the right.

i=n would mean all houses on the left, none on the right, but in the code, i only goes up to n-1.

But in the problem, i can be from 0 to n, inclusive.

Wait, in the code, when i=n-1, left side has i=n-1 houses, right side has n - (n-1) = 1 house.

But to cover i=n, which means all houses on the left, right side has 0 houses, we need to handle i=n separately.

Wait, in the code, S is of length n+1, since it starts with [0,0], and then appends n more elements.

So, S[-1] is S[n], which has the total counts of 0s and 1s.

In the loop, for i in range(n), which is i from 0 to n-1.

When i=n-1, left side is houses 1 to n-1, right side is house n.

When i=n, left side is houses 1 to n, right side is empty.

But in the code, i only goes up to n-1.

So, to cover i=n, we need to add an extra step.

Wait, but in the problem, i can be from 0 to n inclusive.

In the code, i goes from 0 to n-1, and S[-1] gives the total counts.

To handle i=n, we need to consider left side having all houses, right side having 0 houses.

In that case, left = S[n][0], lsum = S[n][0] + S[n][1] = n, and right = S[-1][1] - S[n][1] = 0.

But S[n][1] is total 1s, so right = total 1s - total 1s = 0.

rsum = n - lsum = 0.

Then, check if left * 2 < lsum or right * 2 < rsum.

For left * 2 < lsum: left * 2 < n.

Since left is number of 0s, and lsum is n, this would be number of 0s * 2 < n.

Similarly, right * 2 < rsum: 0 < 0 is False.

So, if number of 0s * 2 < n, it skips.

Else, it checks if abs(n / 2 - n) <= abs(n / 2 - ans), and if so, sets ans = n.

Similarly, for i=0: left * 2 < 0 is False, so it doesn't skip.

So, the code seems to handle i from 0 to n-1, but not i=n.

Wait, S is of length n+1, with S[0] = [0,0], S[1] = [a1==0, a1==1], ..., S[n] = [total 0s, total 1s].

In the loop, i goes from 0 to n-1.

To handle i=n, we need to consider left side having all houses, right side having 0 houses.

In the code, when i=n-1, left side is houses 1 to n-1, right side is house n.

To handle i=n, we need to set left side as houses 1 to n, right side as empty.

In that case, left = S[n][0], lsum = S[n][0] + S[n][1] = n, right = 0, rsum = 0.

So, we can add an extra check after the loop for i=n.

But in the code, it only goes up to i=n-1.

Wait, but in the problem, i can be from 0 to n inclusive.

So, perhaps the code is missing the case when i=n.

Wait, but in the problem, i is the number of houses on the left side, so i can be from 0 to n.

In the code, i is from 0 to n-1.

To fix this, we need to extend the loop to i=n.

But in Python, when i=n, S[i][0] would be S[n][0], which is total 0s, and S[i][1] would be total 1s.

And S[-1][1] - S[i][1] would be 0, since S[i][1] = total 1s when i=n.

So, perhaps it's handled.

Wait, but in the code, the loop is for i in range(n), which is i from 0 to n-1.

To include i=n, we need to add an extra step.

Alternatively, we can set the loop to range(n+1), but then S[i] would be out of range.

Wait, S is of length n+1, with indices from 0 to n.

So, for i in range(n+1):

left = S[i][0]

lsum = S[i][0] + S[i][1]

right = S[-1][1] - S[i][1]

rsum = n - lsum

Then, check the conditions.

So, perhaps the loop should be for i in range(n+1):

But in the current code, it's only for i in range(n):

Wait, maybe it's a mistake.

Looking back at the code:

for i in range(n):

left = S[i][0]

lsum = S[i][0] + S[i][1]

right = S[-1][1] - S[i][1]

rsum = n - lsum

if left * 2 < lsum or right * 2 < rsum:

continue

elif abs(n / 2 - i) <= abs(n / 2 - ans):

ans = i

So, when i=n-1, it's handling left side as houses 1 to n-1, right side as house n.

To handle i=n, we need to set i=n in the loop.

But in Python, range(n) goes from 0 to n-1.

So, to include i=n, we need to use range(n+1), and make sure S[n][0] and S[n][1] are total 0s and 1s.

Yes, S[n][0] is total 0s, S[n][1] is total 1s.

So, modifying the loop to for i in range(n+1):

left = S[i][0]

lsum = S[i][0] + S[i][1]

right = S[-1][1] - S[i][1]

rsum = n - lsum

if left * 2 < lsum or right * 2 < rsum:

continue

elif abs(n / 2 - i) <= abs(n / 2 - ans):

ans = i

This would include i=n.

But in the original code, it's only for i in range(n):

So, it's missing i=n.

But according to the problem, i can be from 0 to n inclusive.

So, this might be a mistake.

Wait, but in the problem, it says "the road also may pass before the first and after the last house; in this case, the entire village is declared to be either the right or left side, respectively."

So, i=0 means all houses are on the right side, and i=n means all houses are on the left side.

So, we need to consider both cases.

Therefore, the loop should be for i in range(n+1):

But in the code, it's only for i in range(n):

So, it's missing i=n.

This might be a mistake.

Wait, but in the problem, it says "the road will pass between two houses. The houses to the left of it will be declared the left-side, and the houses to the right will be declared the right-side."

But it also says "the road also may pass before the first and after the last house; in this case, the entire village is declared to be either the left or right side, respectively."

So, i=0: all houses on the right side.

i=n: all houses on the left side.

So, both need to be considered.

Therefore, the loop should be for i in range(n+1):

But in the code, it's only for i in range(n):

So, it's missing i=n.

This could be a mistake.

Wait, but S is of length n+1, with S[n][0] being total 0s and S[n][1] being total 1s.

So, to include i=n, we need to extend the loop to i in range(n+1):

left = S[i][0]

lsum = S[i][0] + S[i][1]

right = S[-1][1] - S[i][1]

rsum = n - lsum

if left * 2 < lsum or right * 2 < rsum:

continue

elif abs(n / 2 - i) <= abs(n / 2 - ans):

ans = i

So, to fix the code, we need to change the loop to for i in range(n+1):

But in the original code, it's for i in range(n):

So, it's missing i=n.

This might be a mistake.

Wait, but in the problem, it says "if there are multiple suitable positions i with the minimum |n/2 - i|, output the smaller one."

So, if both i=n and some smaller i have the same |n/2 - i|, we should choose the smaller i.

But in the code, ans is initialized to 0, and it updates ans only if the new |n/2 - i| is less than or equal to the current |n/2 - ans|.

So, if i=n is the only position that satisfies the condition, it might not be selected if there are positions with smaller i that also satisfy the condition.

Wait, but according to the problem, among all suitable positions, choose the one with minimal |n/2 - i|, and if there are multiple, choose the smallest i.

So, the code seems to be attempting this by initializing ans to 0 and updating ans only if the new |n/2 - i| is less than or equal to the current |n/2 - ans|.

But, to ensure that i=n is considered, the loop needs to include i=n.

Therefore, the loop should be for i in range(n+1):

But in the code, it's only for i in range(n):

So, it's missing i=n.

This is likely a mistake.

To fix it, change the loop to for i in range(n+1):

left = S[i][0]

lsum = S[i][0] + S[i][1]

right = S[-1][1] - S[i][1]

rsum = n - lsum

if left * 2 < lsum or right * 2 < rsum:

continue

elif abs(n / 2 - i) <= abs(n / 2 - ans):

ans = i

This way, i=n is also considered.

Moreover, in the problem, i is the number of houses on the left side.

So, left side has i houses, right side has n - i houses.

We need to ensure that at least ceil(i/2) houses on the left want to be on the left, and at least ceil((n-i)/2) houses on the right want to be on the right.

Given that, in the code, left * 2 < lsum checks if the number of 0s is less than half of lsum, which is i.

Similarly, right * 2 < rsum checks if the number of 1s is less than half of rsum, which is n - i.

If either is true, it skips that i.

Else, it checks if this i is closer to n/2 than the current ans, and if so, updates ans.

This seems correct.

But, to make sure, let's consider an example.

Take n=3, a='101'

So, S = [[0,0], [0,1], [1,1], [1,2]]

For i=0:

left = 0

lsum = 0

right = S[-1][1] - S[0][1] = 2 - 0 = 2

rsum = 3 - 0 = 3

Check if 0*2 < 0 or 2*2 < 3, which is 0 < 0 or 4 < 3, which is False or False, so it doesn't skip.

Then, check if |3/2 - 0| <= |3/2 - 0|, which is 1.5 <= 1.5, so ans = 0

For i=1:

left = 0

lsum = 0 + 1 = 1

right = 2 - 1 = 1

rsum = 3 - 1 = 2

Check if 0*2 < 1 or 1*2 < 2, which is 0 < 1 or 2 < 2, which is True or False, so skip.

For i=2:

left = 1

lsum = 1 + 1 = 2

right = 2 - 1 = 1

rsum = 3 - 2 = 1

Check if 1*2 < 2 or 1*2 < 1, which is 2 < 2 or 2 < 1, which is False or False, so don't skip.

Then, check if |1.5 - 2| <= |1.5 - 0|, which is 0.5 <= 1.5, so ans = 2

For i=3:

left = 1

lsum = 1 + 2 = 3

right = 2 - 2 = 0

rsum = 3 - 3 = 0

Check if 1*2 < 3 or 0*2 < 0, which is 2 < 3 or 0 < 0, which is True or False, so skip.

So, the possible i are 0 and 2, with |1.5 - 0| = 1.5 and |1.5 - 2| = 0.5, so ans = 2, which matches the first sample output.

Good.

Another sample: n=6, a='010111'

S = [[0,0], [1,0], [1,1], [2,1], [2,2], [2,3], [2,4]]

i=0:

left=0, lsum=0, right=4, rsum=6

0*2 < 0 or 4*2 < 6? 0 < 0 or 8 < 6? False or False, so ans=0

i=1:

left=1, lsum=1, right=4 - 0=4, rsum=5

1*2 < 1 or 4*2 < 5? 2 < 1 or 8 < 5? False or False, so check |3 -1| <= |3-0|, which is 2 <= 3, so ans=1

i=2:

left=1, lsum=2, right=4 -1=3, rsum=4

1*2 < 2 or 3*2 < 4? 2 < 2 or 6 < 4? False or False, so check |3-2| <= |3-1|, which is 1 <= 2, so ans=2

i=3:

left=2, lsum=3, right=4 -1=3, rsum=3

2*2 < 3 or 3*2 < 3? 4 < 3 or 6 < 3? False or False, so check |3-3| <= |3-2|, which is 0 <= 1, so ans=3

i=4:

left=2, lsum=4, right=4 -2=2, rsum=2

2*2 < 4 or 2*2 < 2? 4 < 4 or 4 < 2? False or False, so check |3-4| <= |3-3|, which is 1 <= 0? No, so keep ans=3

i=5:

left=2, lsum=5, right=4 -2=2, rsum=1

2*2 < 5 or 2*2 < 1? 4 < 5 or 4 < 1? True or False, so skip

i=6:

left=2, lsum=6, right=4 -4=0, rsum=0

2*2 < 6 or 0*2 < 0? 4 < 6 or 0 < 0? True or False, so skip

So, ans=3, which matches the second sample output.

Good.

Another sample: n=6, a='011001'

S = [[0,0], [1,0], [1,1], [2,1], [2,2], [2,2], [2,3]]

i=0:

left=0, lsum=0, right=3, rsum=6

0*2 < 0 or 3*2 < 6? False or False, ans=0

i=1:

left=1, lsum=1, right=3 -0=3, rsum=5

1*2 <1 or 3*2 <5? False or False, check |3-1| <= |3-0|, which is 2 <=3, ans=1

i=2:

left=1, lsum=2, right=3 -1=2, rsum=4

1*2 <2 or 2*2 <4? False or False, check |3-2| <= |3-1|, which is 1 <=2, ans=2

i=3:

left=2, lsum=3, right=3 -1=2, rsum=3

2*2 <3 or 2*2 <3? False or False, check |3-3| <= |3-2|, which is 0 <=1, ans=3

i=4:

left=2, lsum=4, right=3 -2=1, rsum=2

2*2 <4 or 1*2 <2? False or False, check |3-4| <= |3-3|, which is 1 <=0? No, keep ans=3

i=5:

left=2, lsum=5, right=3 -2=1, rsum=1

2*2 <5 or 1*2 <1? True or False, skip

i=6:

left=2, lsum=6, right=3 -3=0, rsum=0

2*2 <6 or 0*2 <0? True or False, skip

So, ans=3, which should be correct, but according to the sample output, it's 2.

Wait, in the sample input, for n=6, a='011001', output is 2.

But according to this, ans=3.

Wait, perhaps I made a mistake.

Wait, S[i][0] is the number of 0s up to house i.

For n=6, a='011001'

S[0] = [0,0]

S[1] = [1,0] (a[0]='0')

S[2] = [1,1] (a[1]='1')

S[3] = [1,2] (a[2]='1')

S[4] = [2,2] (a[3]='0')

S[5] = [2,2] (a[4]='0')

S[6] = [2,3] (a[5]='1')

So, for i=2:

left = 1

lsum = 1 +1 =2

right = 3 -1=2

rsum =6 -2=4

Check 1*2 <2 or 2*2 <4? 2 <2 or 4 <4? False or False, so consider ans=2

For i=3:

left=1

lsum=1 +2=3

right=3 -1=2

rsum=6 -3=3

Check 1*2 <3 or 2*2 <3? 2 <3 or 4 <3? True or False, so skip

Wait, but earlier I thought ans=2, but according to the code, it would consider i=2, but then for i=3, it wouldn't update ans because |3-3| <= |3-2| is 0 <=1, which is true, so ans=3.

But according to the sample output, it should be 2.

Wait, perhaps I need to adjust the condition to minimize |n/2 - i|, and if equal, choose the smaller i.

But in the code, it's updating ans when |n/2 - i| <= |n/2 - ans|, which would prefer larger i in case of ties.

Wait, no, it's choosing the smaller i.

Wait, in Python, <= includes equality, so if |n/2 - i| <= |n/2 - ans|, it updates ans to i.

So, if |n/2 - i| == |n/2 - ans|, it updates ans only if i < ans.

Wait, no, it's just |n/2 - i| <= |n/2 - ans|, so if |n/2 - i| == |n/2 - ans|, it updates ans to i, which would keep the smaller i.

Wait, no, it doesn't necessarily keep the smaller i.

Wait, suppose ans=2, then for i=3, |3-3|=0 and |3-2|=1, 0 <=1 is true, so ans=3.

But according to the problem, we need to choose the smaller i if multiple positions have the same |n/2 - i|.

So, perhaps the condition should be |n/2 - i| < |n/2 - ans| or |n/2 - i| == |n/2 - ans| and i < ans.

In the code, it's combined into one condition: |n/2 - i| <= |n/2 - ans|.

But due to the way Python handles floating point arithmetic, it might not work correctly.

Wait, perhaps there is an issue with floating point precision.

n is an integer, i is an integer, but n/2 may be a float.

So, when comparing |n/2 - i|, it's comparing floats, which can have precision issues.

Maybe it's better to work with integers.

Alternatively, since n and i are integers, we can compute |n - 2*i| and minimize that.

Because |n/2 - i| = |n - 2*i| / 2.

So, minimizing |n - 2*i| is equivalent to minimizing |n/2 - i|.

And since n and i are integers, |n - 2*i| will be an integer or half-integer, but in practice, we can compare 2*|n/2 - i|, which is |n - 2*i|.

So, to avoid floating points, we can compute |n - 2*i| and minimize that.

If |n - 2*i| is smaller than the current minimum, update ans to i.

If |n - 2*i| == current minimum, choose the smaller i.

So, in code, keep a variable min_diff = |n - 2*ans|

For each i, compute diff = |n - 2*i|

If diff < min_diff:

min_diff = diff

ans = i

elif diff == min_diff:

if i < ans:

ans = i

This way, we ensure that the smallest i is chosen when ties occur.

In the current code, it's using abs(n / 2 - i) <= abs(n / 2 - ans), which might work, but using integer operations would be safer.

But for now, let's assume it's okay.

Back to the earlier discrepancy: for n=6, a='011001', the sample output is 2, but according to the code, it might output 3.

Wait, perhaps the code is incorrect in this case.

Looking back:

For i=2:

left=1, lsum=2, right=2, rsum=4

Check 1*2 <2 or 2*2 <4? False or False, so consider ans=2

For i=3:

left=1, lsum=3, right=2, rsum=3

Check 1*2 <3 or 2*2 <3? 2 <3 or 4 <3? True or False, so skip

So, only i=0,1,2 satisfy the condition.

Then, |3 -0|=3, |3-1|=2, |3-2|=1

So, the smallest |n/2 - i| is 1, achieved at i=2

Hence, ans=2, which matches the sample output.

Earlier, I mistakenly thought that i=3 was considered, but actually, for i=3, the condition fails because left=1 and lsum=3, so 1*2 <3 is True, which skips it.

Wait, but 1*2 <3 is 2 <3, which is True, so it skips i=3.

Hence, only i=0,1,2 are considered, and among them, i=2 is the best.

So, the code seems correct in this case.

Another sample: n=3, a='000'

S = [[0,0], [1,0], [2,0], [3,0]]

i=0:

left=0, lsum=0, right=0, rsum=3

0*2 <0 or 0*2 <3? False or False, ans=0

i=1:

left=1, lsum=1, right=0, rsum=2

1*2 <1 or 0*2 <2? 2 <1 or 0 <2? True or False, skip

i=2:

left=2, lsum=2, right=0, rsum=1

2*2 <2 or 0*2 <1? 4 <2 or 0 <1? False or True, so skip

i=3:

left=3, lsum=3, right=0, rsum=0

3*2 <3 or 0*2 <0? 6 <3 or 0 <0? False or False, so consider ans=3

Now, compare |3/2 -0| =1.5, |3/2 -3|=1.5, so ans=0

But according to the sample output, for n=3, a='000', output is 3.

Wait, perhaps I need to recheck.

Wait, in the sample input, for n=3, a='000', output is 3.

But according to the code, it would consider i=0 and i=3, both with |1.5 -0|=1.5 and |1.5 -3|=1.5, and choose the smaller i, which is 0, but the sample output is 3.

Wait, there must be a mistake in my reasoning.

Wait, for i=0:

left=0, lsum=0, right=0, rsum=3

Check 0*2 <0 or 0*2 <3? False or False, so consider ans=0

For i=1:

left=1, lsum=1, right=0, rsum=2

1*2 <1 or 0*2 <2? 2 <1 or 0 <2? True or False, skip

For i=2:

left=2, lsum=2, right=0, rsum=1

2*2 <2 or 0*2 <1? 4 <2 or 0 <1? False or True, so skip

For i=3:

left=3, lsum=3, right=0, rsum=0

3*2 <3 or 0*2 <0? 6 <3 or 0 <0? False or False, so consider ans=3

Now, among i=0 and i=3, both have |1.5 -0|=1.5 and |1.5 -3|=1.5, but according to the problem, we should choose the smaller i, which is 0, but the sample output is 3.

Wait, perhaps I misread the sample input.

Wait, in the sample input, for n=3, a='000', output is 3.

But according to the condition, splitting after the third house means all houses are on the left side, and there are 3 zeros on the left side, which is more than half of 3, since ceil(3/2)=2, and 3 >=2.

On the right side, there are 0 houses, which is fine.

Similarly, splitting before the first house, i=0, right side has all 3 houses with 0s, which is more than half, since ceil(3/2)=2, and 3 >=2.

So, both i=0 and i=3 satisfy the condition, and both have |1.5 -0|=1.5 and |1.5 -3|=1.5.

But according to the problem, we should choose the smaller i, which is 0, but the sample output is 3.

This suggests that there is a mistake in the problem statement or in my understanding.

Wait, perhaps the problem specifies that when multiple positions have the same |n/2 - i|, we choose the smaller i.

But in this case, i=0 is smaller than i=3, so it should output 0, but the sample output is 3.

Wait, perhaps I misread the sample input.

Looking back at the sample input:

7

3

101

6

010111

6

011001

3

000

3

110

3

001

4

1100

And the corresponding outputs:

2

3

2

3

0

1

0

Wait, for n=3, a='000', output is 3, which contradicts my earlier reasoning.

Wait, perhaps the problem has a misprint in the sample output.

Alternatively, maybe the condition is not correctly implemented in the code.

Wait, perhaps I misread the problem.

Looking back at the problem statement:

"Determine after which house i the road should be laid in order to satisfy the described condition and be as close to the middle of the village as possible.

Formally, among all suitable positions i, minimize |n/2 - i|.

If there are multiple suitable positions i with the minimum |n/2 - i|, output the smaller one."

So, it says to choose the smaller i when multiple positions have the same |n/2 - i|.

But in the sample input where n=3, a='000', output is 3, which is larger.

Wait, perhaps I need to reconsider the condition.

Wait, for i=3, left side has all 3 houses with a='000', which are all satisfied with being on the left side, which is fine.

Right side has 0 houses, which is fine.

For i=0, right side has all 3 houses with a='000', which are all satisfied with being on the right side, which is also fine.

But according to the problem, we should choose the smaller i when multiple positions have the same |n/2 - i|.

So, why is the sample output 3?

Wait, perhaps there is a misunderstanding.

Wait, in the problem, i is the number of houses on the left side.

So, for i=3, left side has 3 houses, right side has 0 houses.

For i=0, left side has 0 houses, right side has 3 houses.

The condition is to choose the i that minimizes |n/2 - i|, and if multiple, choose the smaller i.

For n=3, n/2=1.5

|1.5 -0|=1.5

|1.5 -3|=1.5

So, both have the same |n/2 - i|, so should choose i=0.

But the sample output is 3, which contradicts this.

Wait, perhaps the problem actually wants to choose the larger i when |n/2 - i| is equal.

But according to the problem statement, it's to choose the smaller i.

So, perhaps there is an error in the sample output.

Alternatively, maybe I'm miscounting i.

Wait, perhaps i is the position after the house, so i=3 means after the third house, which is the same as having all houses on the left side.

But according to the problem, it's to choose the smallest i when |n/2 - i| is equal.

So, perhaps the sample output is wrong, or I'm misunderstanding something.

Wait, perhaps the problem actually wants the position before which the road is built, meaning i=0 means after the last house, i=1 means after the first house, etc.

Wait, no, the problem says "after which house i the road should be laid", with i=0 meaning before the first house.

So, i=0: road before first