Alright, I've got this problem to solve. Let's see what it's asking for. So, I have n sticks, each with a length of 2 raised to the power of a certain number, specifically 2^{a_i} for each stick i. I need to choose exactly 3 sticks and form a non-degenerate triangle with them. A non-degenerate triangle means that the area is greater than 0, which in terms of side lengths means that the sum of any two sides must be greater than the third side. That's the triangle inequality theorem.

So, my task is to count how many ways I can choose 3 sticks such that their lengths satisfy the triangle inequality.

First, I need to understand the input and output format. There are multiple test cases, and for each test case, I get n, the number of sticks, and then a list of n integers a_i, which represent the exponents in the lengths of the sticks.

The constraints are:

- t (number of test cases) is up to 10^4.

- n can be up to 3*10^5 per test case.

- a_i can be from 0 to n.

- The sum of n over all test cases doesn't exceed 3*10^5.

Given these constraints, I need to make sure that my solution is efficient, probably O(n log n) per test case or better, since O(n^2) would be too slow given the constraints.

Let me think about the properties of the stick lengths. Since lengths are of the form 2^{a_i}, and 2 raised to any integer is a distinct power of 2, the lengths are powers of 2.

Wait a minute, powers of 2 are distinct and double each time. So, 2^0=1, 2^1=2, 2^2=4, 2^3=8, and so on.

Now, for three lengths to form a triangle, the sum of the two smaller lengths must be greater than the largest length.

Given that lengths are powers of 2, let's see what happens when I try to pick three sticks.

Suppose I have sticks with lengths 2^a, 2^b, and 2^c, where a <= b <= c.

For these to form a triangle, 2^a + 2^b > 2^c must hold.

But, since 2^a + 2^b is equal to 2^b (1 + 2^{a-b}) if a <= b.

Wait, more accurately, 2^a + 2^b = 2^a (1 + 2^{b-a}) .

But perhaps it's easier to think in terms of properties of exponents.

Let me consider that in sorted order, a <= b <= c.

Then, 2^a + 2^b > 2^c.

Given that 2^c is the largest, and 2^b is less than or equal to 2^c, and 2^a is less than or equal to 2^b.

I need to find when 2^a + 2^b > 2^c.

Let me see for small values.

If a=0, b=0, c=0: lengths are 1,1,1. 1+1>1, so yes.

a=0, b=0, c=1: lengths 1,1,2. 1+1=2, which is not greater than 2. So, no.

a=0, b=1, c=1: lengths 1,2,2. 1+2>2, so yes.

a=0, b=1, c=2: lengths 1,2,4. 1+2=3, which is less than 4. So, no.

a=1, b=1, c=2: lengths 2,2,4. 2+2=4, which is not greater than 4. So, no.

a=1, b=2, c=2: lengths 2,4,4. 2+4>4, so yes.

a=2, b=2, c=2: lengths 4,4,4. 4+4>4, so yes.

From these examples, it seems that when a == b < c, it's no unless c = b + 1.

Wait, in a=0, b=1, c=1, it's yes.

In a=0, b=1, c=2, it's no.

In a=1, b=1, c=2, it's no.

In a=1, b=2, c=2, it's yes.

So, it seems that if a + 1 >= c, then it's yes.

Wait, let's think in terms of exponents.

Given a <= b <= c, then 2^a + 2^b > 2^c.

If a < b < c, then 2^a + 2^b = 2^a (1 + 2^{b-a}) < 2^b (since 1 + 2^{b-a} < 2 * 2^{b-a} = 2^{b-a+1} <= 2^b / 2^{a}) Wait, this is getting messy.

Let me try another approach.

I recall that for powers of 2, the sum of two smaller ones can only exceed the largest one in specific cases.

Specifically, 2^k + 2^k = 2^{k+1}, which is equal to 2^{k+1}, so not greater.

But 2^k + 2^{k+1} = 2^k (1 + 2) = 3 * 2^k, which is greater than 2^{k+1} = 2 * 2^k.

Because 3 * 2^k > 2 * 2^k.

Similarly, 2^k + 2^{k+1} > 2^{k+1}.

Wait, but in the earlier example, when a=1, b=2, c=2: lengths 2,4,4.

2 + 4 > 4, which holds.

Similarly, a=1, b=1, c=2: lengths 2,2,4.

2 + 2 = 4, which is not greater, so it doesn't hold.

a=0, b=1, c=1: lengths 1,2,2.

1 + 2 > 2, which holds.

a=0, b=1, c=2: lengths 1,2,4.

1 + 2 < 4, which doesn't hold.

So, seems like when a == b < c, it holds only if c == b + 1.

Wait, in a=1, b=1, c=2: c = b + 1, and 2 + 2 = 4, which is not greater.

Wait, but in a=0, b=1, c=1: a < b == c, and 1 + 2 > 2.

So, perhaps the condition is a < b < c and c < a + b or something.

Wait, perhaps it's easier to think in terms of the exponents.

Let me assume that a <= b <= c.

Then, 2^a + 2^b > 2^c.

I can divide both sides by 2^a, since it's positive.

So, 1 + 2^{b - a} > 2^{c - a}.

Now, let k = b - a, m = c - a.

So, 1 + 2^k > 2^m, with k >= 0, m >= k.

I need to find when 1 + 2^k > 2^m.

Let's consider cases.

If m > k, then 2^m = 2^k * 2^{m - k}.

So, 1 + 2^k > 2^k * 2^{m - k}.

Factor out 2^k:

1 + 2^k > 2^k * (2^{m - k}).

Which is 1 + 2^k > 2^k * (some number >= 2, since m - k >=1).

But 2^k * 2 >= 2^{k+1}, and 1 + 2^k is less than 2^{k+1}, because 1 + 2^k < 2*2^k = 2^{k+1}.

Therefore, 1 + 2^k < 2^{k+1} <= 2^m, since m > k.

Thus, 1 + 2^k < 2^m when m > k.

Therefore, in this case, 1 + 2^k > 2^m holds only if m <= k.

But m >= k by definition, since b <= c.

So, m = k.

Thus, only when m = k, which means c - a = b - a, so c = b.

So, only when c = b.

Wait, but in earlier examples, when c = b, it holds only sometimes.

Wait, in a=1, b=2, c=2: a=1, b=2, c=2.

Here, c = b = 2, and a =1.

So, c = b.

But in a=1, b=1, c=2: c != b.

Wait, I'm getting confused.

Let me double-check.

Given a <= b <= c.

Case 1: a < b < c.

Then, 2^a + 2^b <= 2^{b-1} + 2^b = 1.5 * 2^b < 2^{b+1} <= 2^c.

So, 2^a + 2^b < 2^c.

Thus, no triangle.

Case 2: a < b == c.

Then, 2^a + 2^b = 2^a + 2^b.

Need to check if 2^a + 2^b > 2^c = 2^b.

Which is 2^a + 2^b > 2^b.

This simplifies to 2^a > 0, which is always true.

Therefore, whenever a < b == c, it's always true.

Wait, but earlier example: a=1, b=2, c=2: 2 + 4 > 4, which is true.

a=0, b=1, c=1: 1 + 2 > 2, which is true.

a=0, b=1, c=2: 1 + 2 < 4, which is false.

So, in a < b == c, it's true.

But in a < b < c, it's false.

Case 3: a == b < c.

Then, 2^a + 2^b = 2^{a+1}.

Need 2^{a+1} > 2^c.

Which holds if a + 1 > c.

But since a < c, and a, c are integers, a + 1 <= c.

So, a + 1 > c implies a + 1 > c, but a < c implies a + 1 <= c.

Thus, a + 1 > c cannot hold.

Therefore, in a == b < c, it's never true.

Wait, but in a=1, b=1, c=2: 2 + 2 > 4? 4 > 4? No, 4 is not greater than 4.

So, it's false.

Wait, but earlier I thought it's true, but actually it's false.

Wait, in my initial examples, a=1, b=1, c=2: 2 + 2 = 4, which is not greater than 4.

So, it's false.

But in a=1, b=2, c=2: 2 + 4 > 4, which is true.

Wait, so in a < b == c, it's true.

In a == b < c, it's false.

In a == b == c, it's true.

Wait, a == b == c.

For example, a=1, b=1, c=1: lengths 2,2,2.

2 + 2 > 2, which is true.

So, in a == b == c, it's true.

In a == b < c, it's false.

In a < b == c, it's true.

In a < b < c, it's false.

So, to summarize:

- If a < b == c, then true.

- If a == b == c, then true.

- If a == b < c, then false.

- If a < b < c, then false.

Wait, but in a == b == c, it's true.

In a == b < c, it's false.

So, overall, only when the largest two exponents are equal, and the smallest is less than or equal to the other two.

Wait, more precisely:

- If the smallest exponent is less than the middle one, and the middle one equals the largest one, then it's true.

- If all three exponents are equal, it's true.

- In all other cases, it's false.

So, in terms of sorted exponents a <= b <= c:

- If b == c, then true.

- Else, false.

Wait, but in a < b == c, it's true.

In a == b == c, which is a special case of a < b == c when a == b.

Wait, but a == b == c implies a <= b <= c.

So, b == c in all cases where b == c.

So, seems like the condition is simply b == c.

Wait, but in a == b < c, it's false.

Wait, in a == b == c, it's true.

Wait, perhaps it's b == c, and a < c.

Wait, no, in a == b == c, a < c is false.

Wait, a <= b <= c.

If b == c, then it's true.

But in a == b == c, it's true.

In a == b < c, it's false.

Wait, perhaps it's b == c and a < c.

So, in a == b == c, a < c is false, but in a == b < c, it's false.

Wait, but in a < b == c, it's true.

Wait, perhaps it's b == c, regardless of a.

But in a == b == c, it's true.

In a == b < c, it's false.

In a < b == c, it's true.

So, perhaps it's b == c and a < c.

Wait, but in a == b == c, a < c is false.

Wait, a <= b <= c.

If b == c, then:

- If a < c, then true.

- If a == c, then true.

Wait, but a <= b <= c, and b == c.

So, a <= c.

Therefore, a < c or a == c.

So, in both cases, it's true.

Wait, but in a == b == c, it's true.

In a < b == c, it's true.

So, overall, if b == c, then true, else false.

Wait, but in a == b < c, it's false.

Wait, perhaps it's b == c and a < c + 1 or something.

Wait, exponents are integers, so a < c + 1 is always true if a <= c.

Wait, no, a can be less than c.

Wait, perhaps it's b == c and a >= c - 1 or something.

Wait, in a == b < c, it's false.

In a < b == c, it's true.

In a == b == c, it's true.

So, perhaps it's b == c and a >= c - 1.

Wait, in a == b < c, a = c - k for some k > 0.

But in a < b == c, a can be less than c.

Wait, perhaps it's b == c and a >= c - 1.

Wait, in a == b < c, a = c - k, k > 0.

But a >= c - 1 would make a >= c - 1, which could be true for k =1.

Wait, but in a == b < c, it's false.

Wait, perhaps it's b == c and a >= b.

Wait, but in a < b == c, a < b, so a >= b is false.

So, in that case, it would be false, which contradicts the earlier conclusion that a < b == c is true.

Wait, I'm getting tangled up here.

Let me try to think differently.

Given a <= b <= c, the condition is 2^a + 2^b > 2^c.

I can take logarithms, but since we're dealing with powers of 2, maybe it's better to think in terms of exponents.

Let me consider that 2^a + 2^b > 2^c.

Since all lengths are powers of 2, and exponents are integers, perhaps there's a way to compare exponents directly.

Let me consider that 2^a + 2^b > 2^c.

If a <= b <= c, then 2^a + 2^b <= 2*2^b = 2^{b+1}.

And 2^{b+1} > 2^c if and only if b + 1 > c.

But since b <= c, b + 1 > c implies b > c - 1.

But b <= c, so b > c - 1 implies b = c.

Therefore, 2^{b+1} > 2^c if and only if b + 1 > c, which is only possible if b >= c.

But b <= c, so b + 1 > c only if b = c.

Wait, b + 1 > c when b >= c.

But b <= c, so b + 1 > c only if b = c.

Wait, if b = c, then b + 1 = c + 1 > c is true.

If b < c, then b + 1 <= c.

Therefore, 2^{b+1} > 2^c if and only if b = c.

But earlier, 2^a + 2^b <= 2^{b+1}.

So, if b = c, then 2^a + 2^b <= 2^{b+1} = 2^{c+1} > 2^c.

Therefore, when b = c, 2^a + 2^b > 2^c.

Wait, is that always true?

Wait, no.

If a is much smaller than b and c, then 2^a + 2^b could be less than 2^c.

Wait, but if b = c, then 2^a + 2^b = 2^a + 2^b.

And since b = c, we have 2^a + 2^b > 2^b.

Which simplifies to 2^a > 0, which is always true.

Therefore, if b = c, then 2^a + 2^b > 2^c is always true.

Therefore, the condition is satisfied if and only if b = c.

Wait, but earlier I had a confusion with a == b < c.

Wait, in a == b < c, with b = c, which can't happen if b < c.

Wait, perhaps I need to think differently.

Wait, in sorted order a <= b <= c.

If b == c, then 2^a + 2^b > 2^c is always true, as established.

If b < c, then 2^a + 2^b <= 2^{b+1} <= 2^c, since b + 1 <= c.

Therefore, only when b == c, the condition holds.

Therefore, the condition is satisfied if and only if the second largest exponent is equal to the largest exponent.

In other words, in the sorted list of exponents, the last two must be equal.

Therefore, for any three exponents a <= b <= c, the condition is b == c.

So, now, the problem reduces to counting the number of triplets where the second largest and largest exponents are equal.

Given that, I need an efficient way to count such triplets.

Given the constraints on n and t, I need an efficient algorithm.

Let's think about how to count these triplets efficiently.

One way is to group the exponents into their frequencies.

Let freq[x] be the frequency of exponent x.

Then, for each possible value of c, I can choose two sticks with exponent c and one stick with exponent less than or equal to c.

Wait, but according to the condition, b == c.

So, in the sorted triplet (a, b, c), with b == c.

So, a can be any exponent less than or equal to c.

Wait, but in sorted order, a <= b <= c, and b == c.

So, a <= c.

Therefore, for each c, I can choose freq[c] choose 2 for b and c, and then for a, any exponent less than or equal to c.

Wait, but a can be less than or equal to c.

But, in the triplet, a <= b <= c, with b == c.

So, a can be less than or equal to c.

Therefore, the number of ways for a is the cumulative frequency up to c.

Wait, but I need to choose a separately.

Wait, perhaps it's better to iterate over c, and for each c, iterate over b from 0 to c, and for each b, iterate over a <= b.

Wait, but that might be too slow.

Wait, perhaps I can sort the exponents and then use prefix sums.

Let me think.

Suppose I sort the exponents in non-decreasing order.

Let’s denote the sorted list as ex[1] <= ex[2] <= ... <= ex[n].

Now, for each triplet (i,j,k), with i < j < k, ex[i] <= ex[j] <= ex[k].

We need ex[j] == ex[k].

So, for each pair (j,k) where ex[j] == ex[k], and for each i < j, ex[i] <= ex[j].

Since ex is sorted, ex[i] <= ex[j] for all i < j.

Therefore, for each pair (j,k) with ex[j] == ex[k], the number of valid i is j.

Wait, no, i can be from 1 to j-1.

So, for each pair (j,k) with ex[j] == ex[k], the number of valid i is j.

Wait, but i can be from 1 to j-1.

So, for each pair (j,k) with ex[j] == ex[k], add j-1 to the count.

Wait, but this seems inefficient for large n.

Given that n can be up to 3*10^5, and t up to 10^4, but sum of n over t is up to 3*10^5, it's acceptable as long as per test case time is O(n log n).

But I need a better approach.

Let me think in terms of frequencies.

Suppose I have frequencies freq[x] for each exponent x.

I can sort the exponents in non-decreasing order.

Then, for each exponent x, the number of ways to choose b and c with ex[j] == ex[k] == x is freq[x] choose 2.

Then, for each such pair, the number of possible a is the number of ex[i] <= x.

Since the exponents are sorted, this is just the cumulative frequency up to x.

Wait, but I need to make sure that a is less than j, which is not directly translatable.

Wait, perhaps not.

Wait, in the sorted list, for each pair (j,k) with ex[j] == ex[k] == x, the number of valid i is the number of ex[i] <= x and i < j.

But since the list is sorted, ex[i] <= x for all i < k.

Wait, but j < k, and ex[j] == ex[k] == x.

So, for each such pair (j,k), the number of valid i is j-1.

But summing j-1 for all such pairs is complicated.

Let me think differently.

Suppose I group the exponents by their value.

Let’s say I have groups g[x], which is the list of indices where ex[i] == x.

Then, for each x, I can choose two sticks from g[x] for b and c.

Then, for each such pair, I can choose a from any group y <= x.

But since the sticks are chosen without regard to index, I need to count the number of ways to choose y <= x and choose one stick from g[y].

Wait, but this seems similar to counting frequencies.

Let me formalize it.

Let freq[x] be the frequency of exponent x.

Then, for each x, the number of ways to choose b and c with ex[j] == ex[k] == x is C(freq[x], 2).

Then, for each such pair, the number of ways to choose a with ex[i] <= x is the cumulative frequency up to x, minus freq[x], since b and c are already chosen.

Wait, but b and c are chosen from freq[x], so a can be from any y <= x, including y = x.

Wait, but in the sorted list, a can be from any y <= x.

So, the cumulative frequency up to x.

But I need to be careful not to overcount.

Wait, perhaps it's better to iterate over x in sorted order, maintain a prefix sum of frequencies up to x, and for each x, add C(freq[x], 2) * prefix[x] to the total.

Wait, but this might overcount.

Wait, perhaps I need to subtract freq[x] from the prefix sum, to avoid including b and c in the choice of a.

Wait, no, a can be equal to x, since a <= b == c.

Wait, but in the triplet, a, b, c are distinct sticks.

So, when choosing a, it should be a different stick from b and c.

Wait, but in the triplet, indices i, j, k are distinct.

So, a, b, c are from different sticks.

Therefore, when choosing a, it should be from sticks not equal to b or c.

Therefore, for each pair (b,c) with ex[b] == ex[c] == x, the number of possible a is the cumulative frequency up to x, minus 2 (for b and c).

Wait, but b and c are specific sticks, not their exponents.

Wait, this is getting messy.

Let me try another approach.

Suppose I iterate over all possible pairs (j,k) where ex[j] == ex[k] == x, and for each such pair, count the number of i < j with ex[i] <= x.

Since the list is sorted, ex[i] <= x for all i < k.

Wait, but j < k.

So, ex[i] <= x for all i < k.

But since j < k, and ex[j] == ex[k] == x, then ex[i] <= x for all i < j.

Therefore, for each pair (j,k) with ex[j] == ex[k] == x, the number of valid i is j.

Wait, but indices start from 0, so i ranges from 0 to j-1.

So, for each such pair (j,k), add j to the total.

But summing j for all such pairs is still O(n^2), which is too slow.

I need a smarter way.

Let me consider frequency counts.

Let freq[x] be the frequency of exponent x.

Sort the exponents in non-decreasing order.

Then, for each x, the number of pairs (b,c) with ex[b] == ex[c] == x is C(freq[x], 2).

Then, for each such pair, the number of possible a is the number of sticks with ex[a] <= x, excluding b and c.

But since exponents are sorted, the number of a with ex[a] <= x is the cumulative frequency up to x, minus 2.

Wait, but in the sorted list, the cumulative frequency up to x includes all sticks with ex[a] <= x.

But I need to exclude b and c, but b and c are part of freq[x].

Wait, perhaps it's the cumulative frequency up to x minus 2.

Wait, but freq[x] might be larger than 2.

Wait, perhaps it's better to think in terms of prefix sums.

Let me compute prefix[x] = sum of freq[y] for all y <= x.

Then, for each x, the number of ways is C(freq[x], 2) * (prefix[x] - freq[x]).

Wait, but prefix[x] includes freq[x], so prefix[x] - freq[x] is the cumulative frequency up to x - 1.

But in the sorted list, ex[a] <= x, and a < j.

But j is the index of b, which is less than k.

Wait, this is getting too complicated.

Let me try to look for a formula.

I recall that in combinatorics, the number of triplets where b == c can be calculated efficiently.

Let me consider that.

Suppose I sort the exponents and group them by their value.

Let’s say the unique exponents in sorted order are x1, x2, ..., xm.

For each group gx with frequency freq[x], the number of ways to choose b and c is C(freq[x], 2).

Then, for each such pair, the number of a with ex[a] <= x is the cumulative frequency up to x, minus 2.

Wait, but a can be from any group y <= x, and a != b, c.

But since a can be equal to x, and b and c are already chosen, I need to subtract 2 from the cumulative frequency up to x.

Wait, but freq[x] includes b and c.

Wait, perhaps it's better to consider that the number of a with ex[a] <= x is prefix[x] - 2.

But prefix[x] is the total number of sticks with ex[a] <= x.

Then, for each pair (b,c) with ex[b] == ex[c] == x, the number of a with ex[a] <= x and a != b, c is prefix[x] - 2.

Therefore, the total number of triplets is sum over x of C(freq[x], 2) * (prefix[x] - 2).

Wait, but in this case, a can be equal to x, since ex[a] <= x.

But b and c are already chosen, so a cannot be equal to b or c.

Therefore, prefix[x] - 2.

But in reality, prefix[x] includes all sticks with ex[a] <= x, so subtracting 2 accounts for excluding b and c.

So, this seems correct.

Therefore, the total number of triplets is sum over x of C(freq[x], 2) * (prefix[x] - 2).

But in the case where a == b == c, i.e., freq[x] >= 3, then C(freq[x], 3) triplets are counted multiple times.

Wait, no, in this formula, C(freq[x], 2) * (prefix[x] - 2) accounts for choosing b and c with ex[b] == ex[c] == x, and a with ex[a] <= x, excluding b and c.

If freq[x] >= 3, then C(freq[x], 3) triplets where a, b, c all have ex == x are included in this count.

So, no overcounting.

Therefore, this formula seems correct.

Now, I need to implement this efficiently.

Given that n can be up to 3*10^5 and t up to 10^4, but sum of n over t is up to 3*10^5, I need an O(n log n) per test case solution.

Here's the plan:

- For each test case:

- Read n and the list a of n integers.

- Count the frequency of each a_i, since a_i can be up to n, which is up to 3*10^5, I can use a list q of size n+1 to store freq[x].

- Sort the unique exponents in increasing order.

- Compute the prefix sum of freq[x] up to each x.

- For each x, compute C(freq[x], 2) * (prefix[x] - 2), and sum them up.

- Output the total sum.

Wait, but in the sorted list, prefix[x] is the sum of freq[y] for y <= x.

So, for each x, C(freq[x], 2) * (prefix[x] - 2).

But in the case where freq[x] >= 2, and prefix[x] includes all frequencies up to x.

Wait, but in the earlier analysis, it's correct.

Let me verify with an example.

Take the first test case:

n=7, a=[1,1,1,1,1,1,1]

So, freq[1]=7.

prefix[1]=7.

For x=1, C(7,2)=21.

prefix[1]-2=5.

So, 21 * 5 = 105.

But the correct answer is 35, which is C(7,3)=35.

Wait, this doesn't match.

So, my formula is incorrect.

Wait, perhaps I missed something.

In this case, since all exponents are equal, the condition is satisfied for all triplets, which is C(7,3)=35.

But according to my formula, it's C(7,2)* (prefix[1]-2) = 21 * 5 = 105, which is wrong.

So, my formula overcounts.

Wait, perhaps I need to subtract the C(freq[x], 3) triplets.

Wait, no, in this case, C(7,3)=35, which is less than 105.

Wait, perhaps the formula is sum over x of C(freq[x], 2) * (prefix[x] - freq[x]).

Wait, no, in this case, prefix[x] - freq[x] = prefix[1] - 7 = 7 -7=0, which would give 21*0=0, which is also wrong.

Wait, perhaps it's sum over x of C(freq[x], 2) * (prefix[x] - C(freq[x],1)).

Wait, that doesn't make sense.

Wait, perhaps it's sum over x of C(freq[x], 2) * (prefix[x] - 2).

But in this case, it's 21 * (7 - 2) = 21 *5 =105, which is too much.

Wait, perhaps I need to subtract C(freq[x],3).

So, total triplets = sum over x of C(freq[x],2) * (prefix[x] - 2) - C(freq[x],3).

In the first test case, that would be 105 - 35 =70, still not 35.

Wait, perhaps it's only C(freq[x],2) * (prefix[x] - freq[x]).

In this case, 21 * (7 -7)=0, which is wrong.

Wait, perhaps I need to think differently.

Let me consider that for each pair (b,c) with ex[b]==ex[c]==x, the number of a with ex[a]<=x and a !=b and a !=c is prefix[x] -2.

But in the case where ex[a]==x, and a !=b and a !=c, it's already included in prefix[x]-2.

But in the first test case, all exponents are 1, so prefix[1]=7.

C(7,2)=21.

Then, 21 * (7 -2)=105.

But the correct answer is C(7,3)=35.

So, my formula is overcounting.

I need to find a way to correct this.

Wait, perhaps the correct formula is sum over x of C(freq[x],2) * (prefix[x] - C(freq[x],1)).

In this case, 21 * (7 -7)=0, which is wrong.

Wait, perhaps it's sum over x of C(freq[x],2) * (prefix[x] - freq[x] +1).

In this case, 21 * (7 -7 +1)=