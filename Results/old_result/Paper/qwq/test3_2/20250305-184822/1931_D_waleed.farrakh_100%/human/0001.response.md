Alright, I've got this problem to solve. Let's see what it's asking for. So, Polycarp has two favorite integers, x and y, and he has an array of numbers. He considers a pair of indices <i, j> beautiful if two conditions are met: first, the sum of the elements at those indices is divisible by x, and second, the difference between those elements is divisible by y. My task is to find out how many such beautiful pairs exist in the array for each test case.

First, I need to understand what it means for a sum or difference to be divisible by a number. For two numbers a and b, their sum a + b is divisible by x if (a + b) % x == 0. Similarly, their difference a - b is divisible by y if (a - b) % y == 0.

Now, the problem is that iterating through all possible pairs for large n (up to 2*10^5 per test case) would be too slow because it's O(n^2), and with t test cases up to 10^4, that's not feasible. So, I need a smarter way to count these pairs without checking every possible pair.

Let me think about the properties of modulo operations. If a + b is divisible by x, then (a + b) % x == 0. Similarly, (a - b) % y == 0. I need to find pairs (a, b) where both these conditions hold.

Maybe I can look at the residues of the elements modulo x and y. Let's denote a_res_x = a % x and a_res_y = a % y for each element a in the array.

Wait, but x and y are two different moduli, and they might not be related. Hmm.

Perhaps I can consider the residues of a with respect to both x and y simultaneously. Since x and y can be different and potentially not coprime, this might be tricky.

Let me consider the Chinese Remainder Theorem, but I'm not sure if that's directly applicable here.

Alternatively, maybe I can look for a way to group elements based on their residues modulo some value.

Wait, perhaps I can think in terms of system of congruences. I need to find pairs where a + b ≡ 0 mod x and a - b ≡ 0 mod y.

Let me write this down:

a + b ≡ 0 mod x ⇒ a ≡ -b mod x

a - b ≡ 0 mod y ⇒ a ≡ b mod y

So, a ≡ -b mod x and a ≡ b mod y.

This seems like a system of congruences for a and b.

Let me try to solve for b in terms of a.

From a ≡ b mod y, we have b ≡ a mod y.

Substituting into the first equation: a ≡ -b mod x ⇒ a ≡ -a mod x (since b ≡ a mod y)

Wait, that doesn't seem right. Maybe I need to consider the residues more carefully.

Let me denote:

Let’s say a ≡ p mod x

And a ≡ q mod y

But I’m getting confused.

Maybe I should try to fix one variable and see what the other variable must satisfy.

Let’s fix a, and see what b must satisfy in terms of a.

Given a, for b to form a beautiful pair with a:

1. a + b ≡ 0 mod x ⇒ b ≡ -a mod x

2. a - b ≡ 0 mod y ⇒ b ≡ a mod y

So, b must satisfy:

b ≡ -a mod x

and

b ≡ a mod y

This is a system of two congruences for b.

If I can solve this system, I can find the possible values of b that pair beautifully with a.

Then, I can count how many such b's exist in the array for each a, and sum these counts appropriately to get the total number of beautiful pairs.

But solving this system for each a separately would be inefficient for large n.

I need a better way to handle this.

Let me think about the Chinese Remainder Theorem (CRT). CRT tells us that if we have two congruences with coprime moduli, there is a unique solution modulo the product of the moduli.

But in this problem, x and y may not be coprime. So, I need to be careful.

Let me consider the general case where x and y are not necessarily coprime.

Given the system:

b ≡ -a mod x

b ≡ a mod y

I can write this as:

b ≡ -a mod x

b ≡ a mod y

Which can be rewritten as:

b + a ≡ 0 mod x

b - a ≡ 0 mod y

So, b + a is divisible by x, and b - a is divisible by y.

Let me denote s = b - a. Then s ≡ 0 mod y, so s is a multiple of y.

Similarly, b + a = (b - a) + 2a = s + 2a, which needs to be divisible by x.

So, s + 2a ≡ 0 mod x.

Since s ≡ 0 mod y, we have 2a ≡ -s ≡ 0 mod x.

Wait, but s is a multiple of y, so s ≡ 0 mod y.

But I'm not sure if that helps directly.

Maybe I need to approach this differently.

Let me consider the residues of a modulo x and y.

Suppose I group the elements based on their residues modulo some value.

But again, since x and y are different, this seems tricky.

Wait, perhaps I can consider the residues of a modulo the least common multiple (LCM) of x and y.

Let me denote L = LCM(x, y).

Then, a modulo L would capture the combined periodicity of x and y.

Let me see.

If I take a modulo L, then for any a, I can determine b modulo L based on the system above.

But I'm not sure.

Alternatively, perhaps I can iterate through the array, group elements based on their residues modulo x and y, and then count pairs accordingly.

But this seems vague.

Let me try to think of small test cases to see if I can find a pattern.

Take the first example:

n = 6, x = 5, y = 2

a = [1, 2, 7, 4, 9, 6]

Beautiful pairs are <1,5> and <4,6>.

Let's verify:

<1,5>: 1 + 9 = 10, which is divisible by 5; 1 - 9 = -8, divisible by 2.

<4,6>: 4 + 6 = 10, divisible by 5; 4 - 6 = -2, divisible by 2.

So, these are indeed beautiful pairs.

Let me see if there are any other pairs that satisfy the conditions.

Check <1,2>: 1 + 2 = 3 not divisible by 5; 1 - 2 = -1 divisible by 2 → not beautiful.

<1,3>: 1 + 7 = 8 not divisible by 5; 1 - 7 = -6 divisible by 2 → not beautiful.

<1,4>: 1 + 4 = 5 divisible by 5; 1 - 4 = -3 not divisible by 2 → not beautiful.

<1,6>: 1 + 6 = 7 not divisible by 5; 1 - 6 = -5 divisible by 5 → but 5 is not y=2; wait, y=2.

Wait, -5 is not divisible by 2, since -5 / 2 is not an integer. Wait, -5 divided by 2 is -2.5, which is not an integer, so it's not divisible.

Hence, <1,6> is not beautiful.

<2,3>: 2 + 7 = 9 not divisible by 5; 2 - 7 = -5 divisible by 5, but y=2.

Wait, -5 is not divisible by 2, as earlier.

<2,4>: 2 + 4 = 6 not divisible by 5; 2 - 4 = -2 divisible by 2 → not beautiful.

<2,5>: 2 + 9 = 11 not divisible by 5; 2 - 9 = -7 not divisible by 2 → not beautiful.

<2,6>: 2 + 6 = 8 not divisible by 5; 2 - 6 = -4 divisible by 2 → not beautiful.

<3,4>: 7 + 4 = 11 not divisible by 5; 7 - 4 = 3 not divisible by 2 → not beautiful.

<3,5>: 7 + 9 = 16 not divisible by 5; 7 - 9 = -2 divisible by 2 → not beautiful.

<3,6>: 7 + 6 = 13 not divisible by 5; 7 - 6 = 1 not divisible by 2 → not beautiful.

<4,5>: 4 + 9 = 13 not divisible by 5; 4 - 9 = -5 divisible by 5, but y=2 → -5 not divisible by 2.

<4,6>: already checked, beautiful.

<5,6>: 9 + 6 = 15 divisible by 5; 9 - 6 = 3 not divisible by 2 → not beautiful.

So, only two beautiful pairs, which matches the example.

Now, to generalize this, I need a way to count such pairs efficiently.

Let me think about the conditions again.

We have:

a + b ≡ 0 mod x ⇒ a ≡ -b mod x

a - b ≡ 0 mod y ⇒ a ≡ b mod y

So, a ≡ -b mod x and a ≡ b mod y.

This means that b ≡ -a mod x and b ≡ a mod y.

So, for a given a, b must satisfy both b ≡ -a mod x and b ≡ a mod y.

This is a system of congruences for b.

If x and y are coprime, by the Chinese Remainder Theorem, there is a unique solution for b modulo x*y.

But if they are not coprime, it's more complicated.

I need to find, for each a, how many b's satisfy both conditions, and then sum these counts appropriately, making sure to avoid double-counting since pairs are unordered.

Wait, but since pairs are unordered, counting ordered pairs and then dividing by two would be necessary, but we have to be careful with pairs where a == b, but in this problem, since i < j, a and b are distinct.

But in the problem, n >=2, and pairs are distinct.

But in the conditions, a and b can be equal only if a + a is divisible by x and a - a is divisible by y, which is only possible if 2a is divisible by x and 0 is divisible by y. But 0 is always divisible by y, as long as y != 0, which it isn't since y >=1. So, a == b is possible only if 2a is divisible by x.

But in the example, all beautiful pairs have a != b.

But according to this, a == b is possible if 2a is divisible by x.

So, in the counting, I need to be careful about a == b cases.

Wait, but in the problem statement, it's specified that 1 <= i < j <= n, so a and b are distinct elements.

Wait, no, i and j are indices, and a and b are elements. So, if there are duplicates in the array, a and b can be equal in value but are considered distinct if they are in different positions.

But in the problem, it's about indices, so even if a_i == a_j, they are considered distinct as long as i != j.

But in the conditions, a_i and a_j are treated by their values.

So, duplicates in the array are allowed, and in that case, pairs with the same value but different indices are allowed.

I need to make sure that in my counting, I don't double-count pairs.

Now, back to the system of congruences:

For a given a, b must satisfy:

b ≡ -a mod x

b ≡ a mod y

I need to find the number of b's in the array that satisfy both conditions.

If I can find a way to group the elements based on their residues modulo some value, I can count how many b's satisfy these conditions for each a.

But doing this naively would still be O(n^2).

I need a smarter approach.

Let me consider combining the two conditions into one.

Since b ≡ -a mod x and b ≡ a mod y, I can look for a common b that satisfies both.

This is equivalent to finding b such that:

b ≡ a mod y

and

b ≡ -a mod x

This is a system of congruences, and if x and y are coprime, there is a unique solution modulo x*y by the Chinese Remainder Theorem.

But if x and y are not coprime, it might not have a solution unless a ≡ -a mod gcd(x,y).

Wait, let's think about solvability.

The system:

b ≡ a mod y

b ≡ -a mod x

Has a solution if a ≡ -a mod gcd(x,y), which simplifies to 2a ≡ 0 mod gcd(x,y).

So, if 2a is divisible by gcd(x,y), then the system has solutions.

Otherwise, there are no solutions for that a.

Assuming that 2a is divisible by gcd(x,y), which it always is since a is an integer and gcd(x,y) divides x and y, but I need to verify this.

Wait, no, 2a mod gcd(x,y) needs to be zero for the system to have solutions.

But a can be any integer from 1 to 10^9, so 2a mod gcd(x,y) == 0 only if gcd(x,y) divides 2a.

But since a can be any integer, this may or may not hold.

Wait, but in the problem, a_i >=1, so a can be any positive integer.

So, for some a, the system might have no solutions.

But in the problem, since we're looking for pairs where both conditions are satisfied, and a and b are elements of the array, I need to consider only those a for which the system has solutions.

But this seems too complicated.

Let me try another approach.

Let me consider the difference and sum conditions separately.

From a - b ≡ 0 mod y ⇒ y divides (a - b) ⇒ a ≡ b mod y

From a + b ≡ 0 mod x ⇒ x divides (a + b) ⇒ a ≡ -b mod x

So, a ≡ b mod y and a ≡ -b mod x.

Let me denote a ≡ p mod y and a ≡ q mod x.

Then, from a ≡ b mod y and a ≡ -b mod x, we have:

b ≡ p mod y and b ≡ -q mod x.

So, for each a, which has a specific p and q, I need to find b's that have b ≡ p mod y and b ≡ -q mod x.

Now, if I can group the elements based on their residues modulo y and x, I can count how many b's satisfy these conditions for each a.

But again, this seems inefficient for large n.

Wait, perhaps I can precompute frequency counts.

Let me try to think in terms of frequency tables.

Let me create a frequency map where the key is a pair (r_x, r_y), where r_x = a % x and r_y = a % y, and the value is the count of elements in the array with those residues.

Then, for each a, I can compute r_x = a % x and r_y = a % y.

To find b's that satisfy b ≡ -a mod x and b ≡ a mod y, which is b ≡ -r_x mod x and b ≡ r_y mod y.

But again, I need to find b's with specific residues.

This seems similar to looking up frequencies based on certain residues.

But I need to make sure that I'm not counting the same pair multiple times.

Also, I need to handle the case where a == b, but since indices are distinct, I need to ensure that I don't count a pair where i == j.

But in this problem, since i < j, all pairs are distinct indices.

Wait, but in the earlier analysis, I saw that a == b is possible only if 2a is divisible by x, but in the problem, indices are distinct, so a and b are different elements, even if their values are the same.

So, I need to count only pairs where a and b are distinct elements, even if their values are the same.

In the frequency approach, I need to make sure that when a == b (in value), and there are multiple occurrences, I count the pairs correctly without double-counting.

This seems tricky.

Let me consider a different approach.

Let me consider combining the two conditions into one.

I need a + b ≡ 0 mod x and a - b ≡ 0 mod y.

Let me add and subtract these equations.

From a + b ≡ 0 mod x and a - b ≡ 0 mod y, I can write:

2a ≡ 0 mod lcm(x, y)

Because adding the two equations:

(a + b) + (a - b) = 2a ≡ 0 mod lcm(x, y)

Similarly, subtracting the two equations:

(a + b) - (a - b) = 2b ≡ 0 mod lcm(x, y)

Wait, but this might not be directly helpful.

Alternatively, perhaps I can iterate through the array and group elements based on their residues modulo x and y.

Wait, perhaps I can consider the residues of a modulo x and y together.

Let me think about creating a frequency map where the key is a pair (a % x, a % y), and the value is the count of elements with those residues.

Then, for each a, I can compute the required residues for b: b % x ≡ -a % x and b % y ≡ a % y.

Then, the number of b's that satisfy these conditions is the frequency of the pair (-a % x, a % y).

But I need to handle the negative residue for x.

In Python, a % x is in the range [0, x), and (-a) % x is also in [0, x).

So, I can compute rx = (-a % x + x) % x to get the positive equivalent of -a % x.

Then, for each a, I can look up the frequency of (rx, ry), where ry = a % y.

But I need to ensure that I don't count a itself if a == b and a satisfies the conditions.

Wait, but in this problem, indices are distinct, so a and b are different elements.

So, for each a, I can add the frequency of (rx, ry), but since pairs are unordered, I need to ensure that I don't double-count.

Wait, actually, since I'm iterating through each a and adding the frequency of the required b's, and since each pair is counted twice in this approach (once for a and once for b), I need to divide the total count by 2.

But wait, that would work if all pairs are distinct, but if there are multiple elements with the same residues, I need to be careful.

Alternatively, I can use a frequency map and, for each unique pair (rx, ry), keep track of how many a's map to that pair and how many b's satisfy the conditions.

This seems complicated.

Let me try to implement this step-by-step.

First, create a frequency map where the key is (a % x, a % y), and the value is the count of elements with those residues.

Then, for each a, compute rx = (-a % x + x) % x and ry = a % y.

Then, look up the frequency of (rx, ry) in the frequency map.

Add this frequency to the total count.

But since each pair is counted twice, I need to divide the total count by 2.

Wait, but in the problem, pairs are unordered, so dividing by 2 would be necessary to avoid double-counting.

However, I need to be careful with pairs where a == b, but since indices are distinct, and a and b are different elements, even if their values are the same, they are considered different pairs.

But in practice, since I'm looking at frequency counts, and a and b are distinct, I need to ensure that when a == b (in value), and there are multiple occurrences, I don't count the same pair multiple times.

Wait, no, since indices are distinct, and I'm counting frequency of (rx, ry), which corresponds to potential b's for each a, I need to make sure that I don't count a itself if it satisfies the conditions.

But in the initial approach, I'm adding the frequency of (rx, ry) for each a, which includes a itself if a satisfies the conditions.

So, if a satisfies both a + a ≡ 0 mod x and a - a ≡ 0 mod y, which simplifies to 2a ≡ 0 mod x and 0 ≡ 0 mod y.

So, a is only counted if 2a is divisible by x.

In that case, I need to subtract 1 from the frequency if a satisfies the conditions, because a cannot be paired with itself.

Wait, but indices are distinct, so a and b must be different elements.

So, for each a, I should add freq[(-a % x, a % y)] to the total count, but if a satisfies the conditions with itself (i.e., 2a ≡ 0 mod x and 0 ≡ 0 mod y), I need to subtract 1 to exclude the pair where i == j.

But in practice, since indices are distinct, and I'm dealing with frequency counts, I need to handle this carefully to avoid overcounting.

This seems error-prone.

Let me consider an alternative approach.

Let me iterate through the array, and for each a, compute rx = (-a % x + x) % x and ry = a % y.

Then, look up the frequency of elements with residues (rx, ry).

Add this frequency to the total count.

At the end, since each pair is counted twice (once for a and once for b), divide the total count by 2.

But I need to make sure that I'm not including pairs where a == b.

To handle this, when adding freq[rx, ry] to the count, if a itself satisfies the conditions (i.e., a % x == rx and a % y == ry), then I need to subtract 1 to exclude the case where a is paired with itself.

But this requires checking if a satisfies the conditions.

Wait, a satisfies a + a ≡ 0 mod x and a - a ≡ 0 mod y, which is equivalent to 2a ≡ 0 mod x and 0 ≡ 0 mod y.

So, 0 is always divisible by y, and 2a ≡ 0 mod x.

So, a satisfies the conditions if 2a is divisible by x.

Hence, if 2a % x == 0, then a can be paired with itself, but since indices must be distinct, I need to exclude this case.

Therefore, for each a, I add freq[rx, ry] to the count, and if 2a % x == 0, subtract 1 to exclude the self-pair.

At the end, since each pair is counted twice, divide the total count by 2.

This seems like a viable approach.

Let me try it with the first example.

n = 6, x = 5, y = 2

a = [1, 2, 7, 4, 9, 6]

First, create frequency map of (a % x, a % y):

1 % 5 = 1, 1 % 2 = 1 → (1,1):1

2 % 5 = 2, 2 % 2 = 0 → (2,0):1

7 % 5 = 2, 7 % 2 = 1 → (2,1):1

4 % 5 = 4, 4 % 2 = 0 → (4,0):1

9 % 5 = 4, 9 % 2 = 1 → (4,1):1

6 % 5 = 1, 6 % 2 = 0 → (1,0):1

Frequency map:

(1,1):1

(2,0):1

(2,1):1

(4,0):1

(4,1):1

(1,0):1

Now, iterate through each a and compute rx and ry:

For a=1:

rx = (-1 % 5 + 5) % 5 = (4 % 5) = 4

ry = 1 % 2 = 1

Look up freq[(4,1)] = 1

Check if 2*1 % 5 == 0: 2 % 5 == 2, not 0, so don't subtract 1

Add 1 to count

For a=2:

rx = (-2 % 5 + 5) % 5 = (3 % 5) = 3

ry = 2 % 2 = 0

Look up freq[(3,0)] = 0

Add 0 to count

For a=7:

rx = (-7 % 5 + 5) % 5 = (-2 % 5 + 5) % 5 = (3 % 5) = 3

ry = 7 % 2 = 1

Look up freq[(3,1)] = 0

Add 0 to count

For a=4:

rx = (-4 % 5 + 5) % 5 = (1 % 5) = 1

ry = 