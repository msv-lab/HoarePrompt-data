Alright, I've got this problem to solve. Let's see what it's asking for. So, Bob has a bakery, and on the opening day, he baked n buns that he wants to sell. The usual price for each bun is a coins. But to attract customers, he's running a promotion where he can choose some integer k (between 0 and the minimum of n and b) and sell the first k buns at a modified price. The price for the i-th bun (where i goes from 1 to k) is (b - i + 1) coins. The remaining (n - k) buns are sold at the usual price of a coins each.

My task is to help Bob determine the maximum profit he can make by choosing the best k for selling all n buns.

First, I need to understand the promotion clearly. If Bob chooses k = 0, he sells all n buns at the usual price a coins each. So, the total profit would be n * a.

If he chooses k = 1, he sells the first bun at b coins, and the remaining (n - 1) buns at a coins each. Total profit would be b + (n - 1) * a.

If he chooses k = 2, he sells the first bun at b coins, the second at (b - 1) coins, and the remaining (n - 2) buns at a coins each. Total profit would be b + (b - 1) + (n - 2) * a.

This pattern continues up to k = min(n, b), where he sells k buns at prices decreasing from b by 1 each time, and the remaining buns at price a.

My goal is to maximize this total profit.

I need to find the value of k that maximizes the total profit.

Let me try to generalize the total profit for a given k.

Total profit for a given k is:

sum from i=1 to k of (b - i + 1) + (n - k) * a

Simplify the sum:

sum from i=1 to k of (b - i + 1) = sum from i=1 to k of b - sum from i=1 to k of i + sum from i=1 to k of 1 = k * b - (k * (k + 1)) / 2 + k

So, total profit is:

k * b - (k * (k + 1)) / 2 + k + (n - k) * a

Simplify further:

= k * b - (k^2 + k)/2 + k + n * a - k * a

= - (k^2 + k)/2 + k * b + k + n * a - k * a

This seems a bit messy. Maybe there's a better way to approach this.

Alternatively, I can think of the total profit as the sum of the first k modified prices plus the sum of the remaining (n - k) usual prices.

Sum of first k modified prices is the sum of an arithmetic series where the first term is b and the last term is b - k + 1.

Sum of an arithmetic series is (number of terms)/2 * (first term + last term).

So, sum of first k modified prices = k/2 * (b + (b - k + 1)) = k/2 * (2b - k + 1)

Sum of remaining (n - k) usual prices = (n - k) * a

Therefore, total profit = k/2 * (2b - k + 1) + (n - k) * a

I need to maximize this expression with respect to k.

This is a quadratic equation in terms of k.

Let me write it in standard quadratic form:

Total profit = - (k^2)/2 + (2b + 1)/2 * k + (n - k) * a

= - (k^2)/2 + (2b + 1)/2 * k + n * a - k * a

= - (k^2)/2 + [(2b + 1)/2 - a] * k + n * a

This is a quadratic equation in k: P(k) = - (1/2) k^2 + C k + n a, where C = (2b + 1)/2 - a

Since the coefficient of k^2 is negative (-1/2), the quadratic opens downwards, meaning it has a maximum value at its vertex.

The vertex of a parabola given by P(k) = A k^2 + B k + C occurs at k = -B/(2A)

In this case, A = -1/2, B = (2b + 1)/2 - a

So, k = -B/(2A) = -[(2b + 1)/2 - a] / (2 * -1/2) = [a - (2b + 1)/2] / 1 = a - (2b + 1)/2

But k has to be an integer between 0 and min(n, b), so I need to choose the integer k within this range that maximizes the profit.

However, since n and b can be up to 1e9, and t can be up to 1e4, I need an efficient way to compute this for each test case without using too much time.

Computing the sum for each possible k up to 1e9 is not feasible; I need a smarter approach.

Given that the quadratic function is unimodal and opens downwards, the maximum value occurs at the vertex or at the nearest integer to the vertex.

But in this case, since k has to be an integer between 0 and min(n, b), I should check the value of k at the vertex if it's within the range, else check the boundary values.

Wait, but in programming problems with large constraints, often there's a formula or a way to compute the answer directly without iterating.

Let me see if I can find a condition based on a and b to decide the optimal k.

Suppose b <= a, meaning that the modified price for the first bun is less than or equal to the usual price. In this case, it's better not to use the promotion at all, i.e., set k = 0 and sell all buns at price a.

Because if b <= a, then selling any bun at a modified price less than a would decrease the total profit.

Wait, but according to the problem, the modified price for the i-th bun is (b - i + 1), which could be higher or lower than a depending on b and i.

Wait, no, the problem says b is the price of the first bun in the promotion, and it decreases by 1 for each subsequent bun.

Wait, but in the problem statement, it's written as:

"the price of the first k buns is (b - i + 1) coins."

Wait, re-reading the problem:

"Bob chooses some integer k (0 ≤ k ≤ min(n, b)). Bob sells the first k buns at a modified price. In this case, the price of the i-th (1 ≤ i ≤ k) sold bun is (b - i + 1) coins. The remaining (n - k) buns are sold at a coins each."

So, the first bun sold in the promotion is b coins, the second is b - 1, and so on, down to the k-th bun being (b - k + 1) coins.

Now, to maximize profit, I need to choose k such that the sum of the modified prices for the first k buns plus the usual price for the remaining buns is maximized.

I need to find the k that maximizes this sum.

Let me consider different cases based on the relationship between a and b.

Case 1: b <= a

In this case, the first bun in the promotion is sold at b coins, which is less than or equal to a. Moreover, the subsequent buns are sold at even lower prices, down to (b - k + 1). Since these prices are less than or equal to a, it's better to sell all buns at the usual price a.

Hence, in this case, the optimal k is 0, and the total profit is n * a.

Case 2: b > a

Now, the first bun in the promotion is sold at b coins, which is higher than a. The second at b - 1, which might still be higher than a, and so on, until some point where b - i + 1 <= a.

So, in this case, there might be some k > 0 where the sum of the modified prices for the first k buns plus the usual price for the remaining buns is greater than n * a.

I need to find the optimal k in this scenario.

Let me define the sum of the modified prices for the first k buns as S_k = sum from i=1 to k of (b - i + 1) = k * b - (k * (k + 1)) / 2 + k

Simplify: S_k = k * b - (k^2 + k)/2 + k = k * b - k^2 / 2 - k / 2 + k = k * b - k^2 / 2 + k / 2

Total profit P(k) = S_k + (n - k) * a = k * b - k^2 / 2 + k / 2 + n * a - k * a

I can write this as P(k) = -k^2 / 2 + k * (b + 1/2 - a) + n * a

This is a quadratic in k: P(k) = A*k^2 + B*k + C, where A = -1/2, B = b + 1/2 - a, C = n*a

Since A < 0, the maximum occurs at k = floor(-B/(2*A))

Let me compute that.

First, -B/(2*A) = -(b + 1/2 - a)/(2*(-1/2)) = (b + 1/2 - a)/1 = b + 1/2 - a

So, k = floor(b + 1/2 - a)

But k has to be between 0 and min(n, b).

Wait, but k has to be an integer, and b and a are integers, but in the expression b + 1/2 - a, there's a 1/2. So, if b - a is an integer, adding 1/2 makes it non-integer.

Wait, but in programming, I need to handle this carefully.

Actually, in the quadratic formula, the maximum k is at k = floor(b + 0.5 - a)

But since b and a are integers, b - a is integer, so b + 0.5 - a is x + 0.5 where x is integer.

So, floor(x + 0.5) is the standard rounding operation.

But in this context, since k has to be integer, perhaps I should set k = floor(b + 0.5 - a)

Wait, but b + 0.5 - a could be fractional.

Wait, perhaps I need to think differently.

Let me consider the difference in profit between choosing k and k-1.

Compute P(k) - P(k-1) and see when it's positive or negative.

P(k) - P(k-1) = [-k^2 / 2 + k*(b + 0.5 - a) + n*a] - [-(k-1)^2 / 2 + (k-1)*(b + 0.5 - a) + n*a]

Simplify:

= [-k^2 / 2 + k*(b + 0.5 - a)] - [-(k^2 - 2k + 1)/2 + (k - 1)*(b + 0.5 - a)]

= -k^2 / 2 + k*(b + 0.5 - a) + (k^2 - 2k + 1)/2 - (k - 1)*(b + 0.5 - a)

= [-k^2 / 2 + (k^2 - 2k + 1)/2] + [k*(b + 0.5 - a) - (k - 1)*(b + 0.5 - a)]

= [-k^2 + k^2 - 2k + 1]/2 + [k - (k - 1)]*(b + 0.5 - a)

= [-2k + 1]/2 + [1]*(b + 0.5 - a)

= -k + 0.5 + b + 0.5 - a

= -k + b - a + 1

So, P(k) - P(k-1) = -k + b - a + 1

We want P(k) - P(k-1) > 0 to decide whether increasing k increases the profit.

So, -k + b - a + 1 > 0 ⇒ k < b - a + 1

This means that as long as k < b - a + 1, increasing k increases the profit.

At k = b - a + 1, P(k) - P(k-1) = 0, meaning profit remains the same.

Beyond that, P(k) - P(k-1) < 0, so profit decreases.

Therefore, the optimal k is k = b - a + 1 - 1 = b - a

Wait, let's see.

Wait, from k < b - a + 1, the profit increases.

At k = b - a + 1, P(k) - P(k-1) = 0.

Then, for k > b - a + 1, P(k) - P(k-1) < 0.

So, the maximum profit is achieved at k = b - a + 1 - 1 = b - a

Wait, no.

Wait, if k < b - a + 1, P(k) - P(k-1) > 0.

At k = b - a + 1, P(k) - P(k-1) = 0.

For k > b - a + 1, P(k) - P(k-1) < 0.

Therefore, the maximum is at k = b - a + 1.

But k has to be <= min(n, b).

So, the optimal k is min(b - a + 1, min(n, b)).

Wait, but b - a + 1 could be negative.

If b - a + 1 <= 0, meaning b <= a - 1, then the optimal k is 0.

But earlier, we considered that if b <= a, then k = 0.

Wait, but if b - a + 1 <= 0, which is equivalent to b <= a - 1, then k = 0.

But if b = a, then b - a + 1 = 1, which is positive.

So, in that case, k = 1.

Wait, but if b = a, then according to earlier reasoning, it's better to set k = 0.

However, according to this, k = 1.

Wait, there might be inconsistency here.

Let me check with an example.

Take the first test case:

n = 4, a = 4, b = 5

According to the formula, k = b - a + 1 = 5 - 4 + 1 = 2

So, k = 2

But in the explanation, it says k = 1 gives 5 + 4 + 4 + 4 = 17, while k = 2 would be 5 + 4 + 4 + 4 = 17 again.

Wait, but according to the formula, k = 2 should be optimal.

Wait, but in the explanation, k = 1 is chosen.

Wait, perhaps there's a mistake in the explanation or in my reasoning.

Wait, let's compute P(k) for k = 0,1,2,3,4.

For k = 0: P(0) = 0 + 4*4 = 16

k = 1: 5 + 3*4 = 5 + 12 = 17

k = 2: 5 + 4 + 2*4 = 9 + 8 = 17

k = 3: 5 + 4 + 3 + 1*4 = 12 + 4 = 16

k = 4: 5 + 4 + 3 + 2 = 14

So, indeed, the maximum is at k = 1 or k = 2, both giving 17.

So, in this case, k = b - a + 1 = 2, which is one of the optimal ks.

But according to the earlier reasoning, P(k) - P(k-1) = -k + b - a + 1

At k = 2: P(2) - P(1) = -2 + 5 - 4 + 1 = 0, which matches that P(2) = P(1)

At k = 3: P(3) - P(2) = -3 + 5 - 4 + 1 = -1 < 0, so P(3) < P(2)

At k = 1: P(1) - P(0) = -1 + 5 - 4 + 1 = 1 > 0, so P(1) > P(0)

So, the maximum is at k = 1 and k = 2.

Hence, choosing k = b - a + 1 = 2 is also optimal.

So, in general, choosing k = min(b - a + 1, min(n, b)) would be optimal.

But in the case where b - a + 1 > min(n, b), we should choose k = min(n, b).

Wait, but b - a + 1 could be negative.

So, to generalize:

If b - a + 1 <= 0, choose k = 0

Else, choose k = min(b - a + 1, min(n, b))

But min(n, b) could be less than b - a + 1, in which case k = min(n, b)

Wait, but b - a + 1 could be greater than min(n, b), in which case k = min(n, b)

Let me consider another example.

Take n = 5, a = 5, b = 9

k = b - a + 1 = 9 - 5 + 1 = 5

So, k = 5

Total profit: sum of first 5 modified prices: 9 + 8 + 7 + 6 + 5 = 35

Alternatively, k = 0: 5*5 = 25, which is less than 35.

So, k = 5 is optimal.

Another example: n = 10, a = 10, b = 5

k = b - a + 1 = 5 - 10 + 1 = -4 <= 0, so k = 0

Total profit: 10*10 = 100

Which matches the third test case.

Another example: n = 5, a = 5, b = 11

k = 11 - 5 + 1 = 7, but min(n, b) = 5, so k = 5

Total profit: 11 + 10 + 9 + 8 + 7 = 45

Which matches the fourth test case.

Another example: n = 1000000000, a = 1000000000, b = 1000000000

k = 1000000000 - 1000000000 + 1 = 1, but min(n, b) = 1000000000, so k = 1

Total profit: sum of first 1 modified price: 1000000000, plus 999999999*1000000000

Wait, but according to the problem's sample output, it's 1000000000000000000, which is 1e18, meaning k = 0 or k = something else.

Wait, 1e18 is 1000000000 * 1000000000 = 1e18, so k = 0 gives 1e18, and k = 1 gives 1e9 + 999999999e9 = 1e18, same as k = 0.

Wait, but according to the formula, k = 1 is optimal, but in this case, it's same as k = 0.

Wait, but according to the problem's sample output, it's 1e18.

So, in this case, choosing k = 1 gives the same profit as k = 0.

Hence, k = 0 is also acceptable.

Wait, but according to the formula, k = b - a + 1 = 1, so k = 1 is optimal.

But since k = 1 gives the same profit as k = 0, both are acceptable.

Another example: n = 1000000000, a = 1000000000, b = 1

k = 1 - 1000000000 + 1 = 2 - 1000000000 = -999999998 <= 0, so k = 0

Total profit: 1000000000 * 1000000000 = 1e18

Which matches the sample output.

Last example: n = 1000, a = 1, b = 1000

k = 1000 - 1 + 1 = 1000, min(n, b) = 1000, so k = 1000

Total profit: sum of first 1000 modified prices: 1000 + 999 + ... + 1 = 1000*1001/2 = 500500

Which matches the sample output.

So, in general, the optimal k is min(b - a + 1, min(n, b))

Now, to compute the total profit for this k efficiently.

Given that n, a, b can be up to 1e9, and t up to 1e4, I need an O(1) computation per test case.

So, for each test case, compute k = min(b - a + 1, min(n, b))

Then, compute the sum of the first k modified prices: sum from i=1 to k of (b - i + 1) = sum from j=b - k + 1 to b of j, where j = b - i + 1 when i=1 to k.

This is an arithmetic series sum: sum from j=m to n of j = (n*(n+1)/2 - (m-1)*m/2)

Here, m = b - k + 1, n = b

So, sum = b*(b+1)/2 - (b - k)*(b - k + 1)/2

Plus the sum of the remaining (n - k) usual prices: (n - k) * a

Hence, total profit = sum of first k modified prices + sum of remaining usual prices.

But since n, a, b can be up to 1e9, I need to handle large numbers carefully to avoid integer overflows, but in Python, integers can be arbitrarily large, so no issue.

Let me verify this with the first test case:

n = 4, a = 4, b = 5

k = min(5 - 4 + 1, min(4,5)) = min(2,4) = 2

sum of first 2 modified prices: 5 + 4 = 9

sum of remaining 2 usual prices: 2 * 4 = 8

total profit: 9 + 8 = 17

Which matches the sample.

Another test case:

n = 5, a = 5, b = 9

k = min(9 - 5 + 1, min(5,9)) = min(5,5) = 5

sum of first 5 modified prices: 9 + 8 + 7 + 6 + 5 = 35

sum of remaining 0 usual prices: 0

total profit: 35 + 0 = 35

Matches the sample.

Third test case:

n = 10, a = 10, b = 5

k = min(5 - 10 + 1, min(10,5)) = min(-4,5) = 0

sum of first 0 modified prices: 0

sum of remaining 10 usual prices: 10 * 10 = 100

total profit: 0 + 100 = 100

Matches the sample.

Fourth test case:

n = 5, a = 5, b = 11

k = min(11 - 5 + 1, min(5,11)) = min(7,5) = 5

sum of first 5 modified prices: 11 + 10 + 9 + 8 + 7 = 45

sum of remaining 0 usual prices: 0

total profit: 45 + 0 = 45

Matches the sample.

Fifth test case:

n = 1000000000, a = 1000000000, b = 1000000000

k = min(1000000000 - 1000000000 + 1, min(1000000000,1000000000)) = min(1,1000000000) = 1

sum of first 1 modified price: 1000000000

sum of remaining 999999999 usual prices: 999999999 * 1000000000

total profit: 1000000000 + 999999999*1000000000 = 1000000000 + 999999999000000000 = 1000000000000000000

Matches the sample.

Sixth test case:

n = 1000000000, a = 1000000000, b = 1

k = min(1 - 1000000000 + 1, min(1000000000,1)) = min(2 - 1000000000,1) = min(-999999998,1) = 0

sum of first 0 modified prices: 0

sum of remaining 1000000000 usual prices: 1000000000 * 1000000000 = 1000000000000000000

Matches the sample.

Seventh test case:

n = 1000, a = 1, b = 1000

k = min(1000 - 1 + 1, min(1000,1000)) = min(1000,1000) = 1000

sum of first 1000 modified prices: 1000 + 999 + ... + 1 = 1000*1001/2 = 500500

sum of remaining 0 usual prices: 0

total profit: 500500 + 0 = 500500

Matches the sample.

Hence, this approach seems correct.

Now, in terms of implementation, I need to read t test cases, each with n, a, b.

For each test case, compute k = min(b - a + 1, min(n, b))

Then, compute the sum of the first k modified prices: sum from j = b - k + 1 to b of j

Which is (b*(b+1)/2 - (b - k)*(b - k + 1)/2)

Plus (n - k) * a

Output this sum for each test case.

I need to handle large numbers, but in Python, integers can handle that.

I need to make sure that k is an integer and non-negative.

Also, ensure that when b - a + 1 <= 0, k = 0.

Let me think if there's a way to simplify the sum computation.

Alternatively, since the sum of the first k modified prices is the sum of an arithmetic series from b - k + 1 to b.

Sum = k*(b - k + 1 + b)/2 = k*(2b - k + 1)/2

So, sum = k*(2b - k + 1)/2

Then, total profit = sum + (n - k)*a

So, total profit = k*(2b - k + 1)/2 + (n - k)*a

This seems simpler to compute.

Let me verify with the first test case:

k = 2

sum = 2*(2*5 - 2 + 1)/2 + (4 - 2)*4 = 2*(10 - 2 + 1)/2 + 2*4 = 2*9/2 + 8 = 9 + 8 = 17

Matches.

Another test case:

n = 5, a = 5, b = 9

k = 5

sum = 5*(2*9 - 5 + 1)/2 + (5 - 5)*5 = 5*(18 - 5 + 1)/2 + 0 = 5*14/2 = 5*7 = 35

Matches.

Another test case:

n = 10, a = 10, b = 5

k = 0

sum = 0*(2*5 - 0 + 1)/2 + (10 - 0)*10 = 0 + 100 = 100

Matches.

So, this formula works.

Hence, in code, for each test case:

Read n, a, b

Compute k = min(b - a + 1, min(n, b))

If k < 0, set k = 0

Compute sum = k*(2*b - k + 1)//2 + (n - k)*a

Output sum

In Python, integer division with '//' gives the floor division.

Edge cases to consider:

- k = 0

- k = n

- k = b

- n = 1, a = 1, b = 1

- n = 1, a = 1, b = 2

- n = 2, a = 2, b = 1

- n = 1000000000, a = 1000000000, b = 1000000000

- n = 1000000000, a = 1, b = 1

- n = 1, a = 1, b = 1000000000

Ensure that the computation doesn't have integer overflow issues, but in Python, it's handled automatically.

Also, ensure that the code runs efficiently since t can be up to 1e4, but since each test case is O(1), it should be fine.

Now, looking at the given program:

def func():

t = int(input())

for _ in range(t):

(n, a, b) = map(int, input().split())

if b <= a:

print(n * a)

elif b - a >= n:

print(int((2 * b - n + 1) * n // 2))

else:

print(int((b - a) * (b - a + 1) // 2 + a * n))

I need to verify if this code implements the correct logic.

First, it checks if b <= a, in which case it sets k = 0 and prints n * a.

This matches our earlier reasoning.

If b > a, it checks if b - a >= n.

If b - a >= n, it computes the sum as (2 * b - n + 1) * n // 2

Else, it computes the sum as (b - a) * (b - a + 1) // 2 + a * n

I need to verify if these formulas are correct.

First, when b - a >= n, it means that k = min(b - a + 1, min(n, b)) = n

Because b - a + 1 >= n (since b - a >= n)

And min(n, b) could be n or b, but since b - a >= n and b >= a + n - 1, and n <= b, so min(n, b) = n

Hence, k = n

Then, sum = n*(2*b - n + 1)//2 + (n - n)*a = n*(2*b - n + 1)//2

Which matches the formula in the code: (2 * b - n + 1) * n // 2

Hence, this part is correct.

Else, when b - a < n, it uses (b - a) * (b - a + 1) // 2 + a * n

But according to our earlier formula, it should be k*(2*b - k + 1)//2 + (n - k)*a, where k = b - a + 1

So, substituting k = b - a + 1:

sum = (b - a + 1)*(2*b - (b - a + 1) + 1)//2 + (n - (b - a + 1))*a

Simplify:

= (b - a + 1)*(2b - b + a - 1 + 1)//2 + (n - b + a - 1)*a

= (b - a + 1)*(b + a)//2 + (n - b + a - 1)*a

Wait, but in the code, it's (b - a)*(b - a + 1)//2 + a*n

Which is different from what I have.

Let me check with an example.

Take n = 4, a = 4, b = 5

k = b - a + 1 = 2

sum = 2*(2*5 - 2 + 1)//2 + (4 - 2)*4 = 2*9//2 + 2*4 = 9 + 8 = 17

According to the code:

since b - a = 1 < n = 4, so sum = (1)*(1 + 1)//2 + 4*4 = 1*2//2 + 16 = 1 + 16 = 17

Which matches.

Another example: n = 5, a = 5, b = 9

k = 5

sum = 5*(2*9 - 5 + 1)//2 + (5 - 5)*5 = 5*14//2 + 0 = 35

According to the code:

b - a = 4 < n = 5, so sum = 4*5//2 + 5*5 = 10 + 25 = 35

Wait, but according to the formula, it should be k*(2*b - k + 1)//2 + (n - k)*a = 5*(18 - 5 + 1)//2 + 0 = 5*14//2 = 35

But the code computes (b - a)* (b - a + 1)//2 + a*n = 4*5//2 + 25 = 10 + 25 = 35

Which matches.

Another example: n = 10, a = 10, b = 5

b - a = -5 < n = 10, so sum = (-5)*(-5 + 1)//2 + 10*10 = positive because (-5)*(-4)/2 = 10 + 100 = 110

But earlier, we saw that k = 0, sum should be 100.

This is inconsistent.

Wait, perhaps I missed something.

In the code, it has:

elif b - a >= n:

print(int((2 * b - n + 1) * n // 2))

else:

print(int((b - a) * (b - a + 1) // 2 + a * n))

But in the case where b - a < 0, which is b < a, it should set k = 0.

But in the code, it computes (b - a)* (b - a + 1)//2 + a*n, which for b - a = -5, computes (-5)*(-4)/2 + 100 = 10 + 100 = 110

But it should be k = 0, sum = 0 + 10*10 = 100

So, this seems incorrect.

Wait, perhaps the code handles negative values differently.

In Python, (-5)*(-4)/2 = 10, which is added to a*n = 100, giving 110, but it should be just 100.

This suggests that the code is incorrect in this case.

Hence, the given program is incorrect.

Therefore, Correctness: False

**Final Solution**

To solve this problem, we need to maximize Bob's profit from selling his buns given the promotion constraints. We need to carefully choose how many buns to sell at the modified price to achieve the highest possible profit.

### Approach

1. **Understanding the Promotion:**
   - Bob can choose to sell the first `k` buns at decreasing prices starting from `b` coins down to `(b - k + 1)` coins.
   - The remaining `(n - k)` buns are sold at the usual price `a` coins each.

2. **Key Insights:**
   - If the modified price for the first bun (`b`) is less than or equal to the usual price (`a`), it's better to sell all buns at the usual price.
   - If `b` is greater than `a`, we need to find the optimal `k` that maximizes the profit.

3. **Optimal `k` Calculation:**
   - The optimal `k` is the minimum of `(b - a + 1)` and `min(n, b)`.
   - If `b - a + 1` is less than or equal to 0, set `k` to 0.
   - Otherwise, set `k` to the minimum of `(b - a + 1)` and `min(n, b)`.

4. **Profit Calculation:**
   - Sum of the first `k` modified prices: `k*(2*b - k + 1)/2`.
   - Sum of the remaining `(n - k)` usual prices: `(n - k)*a`.
   - Total profit is the sum of these two amounts.

### Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    t = int(data[idx])
    idx += 1
    for _ in range(t):
        n = int(data[idx])
        a = int(data[idx+1])
        b = int(data[idx+2])
        idx += 3
        if b <= a:
            print(n * a)
        else:
            k = min(b - a + 1, min(n, b))
            sum_k = k * (2 * b - k + 1) // 2
            sum_remaining = (n - k) * a
            print(sum_k + sum_remaining)

if __name__ == "__main__":
    main()
```

### Explanation

1. **Reading Input:**
   - Read the number of test cases `t`.
   - For each test case, read `n`, `a`, and `b`.

2. **Choosing `k`:**
   - If `b <= a`, set `k = 0` because selling at the usual price is more profitable.
   - Otherwise, set `k` to the minimum of `(b - a + 1)` and `min(n, b)`.

3. **Calculating Profit:**
   - Compute the sum of the first `k` modified prices using the formula `k*(2*b - k + 1)/2`.
   - Compute the sum of the remaining `(n - k)` usual prices as `(n - k)*a`.
   - Output the total profit for each test case.

This approach ensures that we efficiently compute the maximum profit for each test case in constant time, making it suitable for large inputs.