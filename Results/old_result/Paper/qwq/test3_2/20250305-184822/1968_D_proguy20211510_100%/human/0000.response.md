Alright, I've got this problem to solve. Let's see what it's asking for. So, there are two players, Bodya and Sasha, and they're playing a game involving a permutation and an array. The game lasts for k turns, and each turn, both players simultaneously decide to stay in their current position or move to a new position based on the permutation. Their score increases by the value of the array at their current position each turn. The goal is to determine who wins the game, given that both players play optimally.

First, I need to understand the inputs and what they represent. The input consists of multiple test cases. For each test case, I have:

- n: the length of the permutation and the array.

- k: the number of turns in the game.

- P_B and P_S: the starting positions of Bodya and Sasha, respectively.

- The permutation p, which is a list of n integers where each integer is between 1 and n, and all are distinct.

- The array a, which contains n integers representing the scores.

The players can choose to stay in their current position or move to the position specified by the permutation at each turn. They do this simultaneously, and the one with the higher score after k turns wins.

I need to figure out, for each test case, who wins the game if both players play optimally.

Alright, let's think about how to approach this.

First, since both players make decisions simultaneously and independently, their choices don't directly affect each other's moves. Each player is trying to maximize their own score.

Given that, for each player, the problem reduces to finding the optimal sequence of stays and moves to maximize their total score over k turns.

But computing this directly for each player separately for up to 10^5 test cases with n up to 2*10^5 and k up to 10^9 is not feasible if done naively. So, there must be a smarter way to model this.

Let's consider the movement based on the permutation. A permutation can be decomposed into cycles. When a player moves according to the permutation, they are essentially traversing these cycles.

So, if a player is in a cycle, after some number of moves, they will return to their starting position. The length of the cycle determines how many moves it takes to return.

Given that, the optimal strategy might involve staying put at certain points to maximize the score, especially if the current position has a higher score than the next one in the permutation.

Wait, but the problem allows each player to choose independently at each turn whether to stay or move. So, for each turn, they can decide based on the current position and the next position in the permutation.

But considering k can be up to 10^9, simulating each turn individually is not practical. I need a way to compute the maximum possible score for each player in an efficient manner.

Let me think about it differently. For each player, I can model their movement as a graph where nodes are positions, and there are edges from each position to itself (staying) and to p_x (moving). Then, the problem becomes finding the path of length k that maximizes the sum of a_x along the path.

This seems like a standard dynamic programming problem, but with n up to 2*10^5 and k up to 10^9, standard DP approaches would be too slow.

I need to exploit the structure of the permutation. Since permutations consist of disjoint cycles, I can analyze each cycle separately.

Let's consider that each position belongs to exactly one cycle. Within a cycle, the movement is deterministic once the initial choice to stay or move is made.

Wait, but since players can choose to stay or move independently at each turn, it's not purely deterministic. They can choose to stay at any point.

Hmm.

Maybe I should consider for each player the sequence of positions they can reach by choosing to stay or move at each step.

Given that, for a player starting at position x, at each step, they can either stay at x or move to p_x.

So, their position at each step is determined by their choice at that step.

Given that, the sequence of positions they visit can be represented as a sequence of choices: stay or move.

But with k up to 10^9, enumerating all possible sequences is not feasible.

I need a smarter way to compute the maximum possible score for each player.

Let me consider the fact that permutations consist of cycles. If a player is in a cycle of length m, then after m moves, they return to their starting position if they keep moving.

But since they can choose to stay at any step, it complicates things.

Wait, perhaps I can model the game as each player having a choice at each step: stay and collect a_x, or move to p_x and collect a_{p_x}.

But they have to make this choice simultaneously at each step.

Wait, but they don't know the other player's choice, so they have to make their own choices independently.

Given that, perhaps for each player, the optimal strategy is to choose at each step whether to stay or move based on which action gives the higher immediate score, considering the potential future scores.

But with k up to 10^9, I need a way to compute this efficiently.

Let me consider that for each player, their movement can be modeled as a graph where each node has two outgoing edges: one to itself (stay) and one to p_x (move).

Then, finding the path of length k that maximizes the sum of a_x is equivalent to finding the maximum sum path in this graph.

But again, with n up to 2*10^5 and k up to 10^9, this is not feasible directly.

I need to find a way to compute this efficiently, perhaps by exploiting the structure of the permutation.

Let me consider that in a permutation, cycles are independent. So, I can consider each cycle separately.

For each cycle, I can compute the maximum score a player can achieve if they are in that cycle.

But I need to consider that players can be in different cycles, and their movements don't affect each other.

Wait, but since p is a permutation, and it's a single structure, players can move between different positions in the permutation, but the cycles are independent in the sense that once you're in a cycle, you can't leave it by moving according to p.

But in this problem, since players can choose to stay at any step, they can choose to stay in a particular position even if it's not in their current cycle.

Wait, no. The choice is: at each step, either stay at the current position or move to p_x.

So, from any position, they can choose to stay or move to p_x, but p_x is determined by the permutation.

Given that, I need to model this carefully.

Let me consider that for each player, their position at time t depends on their choices up to time t.

But with k up to 10^9, I need a smarter way.

Perhaps I can model this as a DP where for each position, I compute the maximum score achievable from that position in k steps.

But with n up to 2*10^5, and k up to 10^9, this seems infeasible.

I need to find a way to compute this efficiently.

Let me think about the movement in the permutation.

Suppose a player is at position x.

At each step, they can choose to stay at x and collect a_x, or move to p_x and collect a_{p_x}.

So, for each step, the player has two choices: stay and collect a_x, or move to p_x and collect a_{p_x}.

Given that, the player's position at time t depends on their choices in the previous steps.

But with k up to 10^9, I need a way to compute the maximum possible score without simulating each step.

Let me consider that the player can choose to stay at any position for any number of steps before moving to p_x.

So, for example, the player can choose to stay at x for s steps, collect s * a_x, and then move to p_x, and repeat the process.

But this seems too vague.

Wait, perhaps I can model this as the player choosing a sequence of positions where each position is either the same as the previous one or p_x.

Given that, the sequence of positions can be represented as a path where each edge is either staying or moving.

But again, with k up to 10^9, this seems too slow.

I need to find a mathematical way to compute the maximum score for each player.

Let me consider that for each player, their movement can be represented as a sequence of positions x_0, x_1, ..., x_k, where x_{t+1} is either x_t (if they stay) or p_{x_t} (if they move).

Their total score is the sum of a_{x_t} for t from 0 to k-1.

I need to maximize this sum for each player.

Given that, perhaps I can model this as a DP where dp[x][t] is the maximum score achievable at position x at time t.

But with n up to 2*10^5 and k up to 10^9, this is not feasible.

I need to find a smarter way.

Let me consider that for each player, their movement can be represented as a binary decision at each step: stay or move.

So, for each step, the player can choose to stay and collect a_x, or move to p_x and collect a_{p_x}.

Given that, perhaps I can think of the total score as the sum of a_x * number of times the player chooses to stay at x, plus a_{p_x} * number of times the player chooses to move to p_x.

But this seems too vague.

Wait, perhaps I can model this as the player choosing how many times to stay at each position before moving on.

Given that, for each cycle in the permutation, I can compute the maximum score separately.

But I need to consider that the permutation is a set of disjoint cycles, and each player is in one of these cycles.

Wait, actually, in a permutation, the positions are divided into disjoint cycles.

So, for example, if a player starts in a cycle of length m, after m moves, they return to their starting position if they keep moving.

But since they can choose to stay at any step, they can choose to stay at any position in the cycle.

Given that, perhaps for each cycle, I can compute the maximum score a player can achieve.

But I need to consider that the player can choose to stay at any position in the cycle for any number of steps before moving to the next position.

This seems complicated.

Let me think differently.

Suppose I fix a player and consider their movement.

At each step, they can choose to stay at their current position x and collect a_x, or move to p_x and collect a_{p_x}.

So, their position at time t+1 is either x_t (if they stay) or p_{x_t} (if they move).

Their total score is the sum of a_{x_t} for t from 0 to k-1.

I need to maximize this sum over all possible sequences of choices.

This seems like a dynamic programming problem, but with k up to 10^9, I need a way to compute this efficiently.

Let me consider that for each position x, the maximum score achievable starting from x for k steps can be computed based on the maximum score achievable from x and from p_x for k-1 steps.

So, dp[x][k] = max(a_x + dp[x][k-1], a_{p_x} + dp[p_x][k-1])

But with k up to 10^9, this is too slow.

I need to find a way to compute this without iterating through each step.

Let me consider that the player can choose to stay at x for s steps, collecting s * a_x, and then move to p_x and repeat the process.

So, the total score would be s * a_x + dp[p_x][k - s]

I need to maximize this over s from 0 to k.

But again, with k up to 10^9, this is not feasible.

Wait, perhaps I can consider that the optimal strategy is to stay at x for a certain number of steps and then move to p_x, and repeat this process.

But I need a way to compute this efficiently.

Let me consider that for each position x, the maximum score achievable is the maximum over all s from 0 to k of (s * a_x + dp[p_x][k - s])

This seems similar to the convolution of two sequences.

But I need a way to compute this efficiently.

Perhaps I can model this using mathematical optimization.

Wait, perhaps I can consider that for each position x, the optimal number of steps to stay is such that staying longer increases the score, and moving decreases it.

So, perhaps the optimal number of steps to stay at x is when a_x is greater than a_{p_x}.

Wait, that might be a direction.

Suppose that a_x >= a_{p_x}, then it's better to stay at x as long as possible, because a_x is at least as good as a_{p_x}.

Otherwise, it's better to move to p_x.

But, since the player can choose to stay or move at each step, and they make this choice simultaneously, I need to consider the sequence of choices over k steps.

Wait, perhaps I can think of it as the player choosing at each step whether to stay and collect a_x or move to p_x and collect a_{p_x}.

Given that, for each step, the player can choose to stay and collect a_x, or move to p_x and collect a_{p_x}.

So, for k steps, the total score is the sum of the choices made at each step.

Given that, the optimal strategy would be, at each step, to choose to stay if a_x >= a_{p_x}, otherwise move to p_x.

But, since they make this choice simultaneously, and the movement is based on the permutation, which is deterministic, I need to model this carefully.

Wait, perhaps the optimal strategy is for each player to stay at a position as long as a_x is greater than or equal to a_{p_x}, and move otherwise.

But I need to formalize this.

Let me consider that for each player, their movement can be modeled as a sequence of stays and moves, and I need to maximize the sum of a_x over k steps.

Given that, perhaps I can model this as follows:

For each player, starting from their initial position, at each step, they can choose to stay at x and collect a_x, or move to p_x and collect a_{p_x}.

So, their position at time t+1 is either x_t (if they stay) or p_{x_t} (if they move).

Their total score is the sum of a_{x_t} for t from 0 to k-1.

I need to maximize this sum.

Given that, perhaps I can model this as a graph where each node has two outgoing edges: one to itself with weight a_x, and one to p_x with weight a_{p_x}.

Then, the problem reduces to finding the path of length k that maximizes the sum of the weights.

But with n up to 2*10^5 and k up to 10^9, this is not feasible directly.

I need to find a way to compute this efficiently.

Let me consider that for each player, their movement can be represented as a sequence of positions where at each step, they choose to stay or move.

Given that, perhaps I can find a way to represent this movement in terms of cycles.

Wait, since the permutation consists of disjoint cycles, I can analyze each cycle separately.

For a cycle of length m, the movement within the cycle is cyclic.

But since the player can choose to stay at any step, they can choose to stay at any position in the cycle for any number of steps before moving to the next position.

Given that, perhaps for each cycle, I can precompute the maximum score achievable from each position in the cycle for any k.

But this still seems too slow for n up to 2*10^5 and k up to 10^9.

I need a better approach.

Let me consider that for each player, their movement can be modeled as a Markov decision process, where at each step, they choose to stay or move, and transition to the next state accordingly.

But again, with k up to 10^9, this is not practical.

I need to find a mathematical formula or a way to compute the maximum score efficiently.

Let me consider that for each player, their movement can be represented as a sequence of positions where they can choose to stay or move at each step.

Given that, perhaps I can model this as a recurrence relation.

Let dp[x][k] be the maximum score achievable from position x with k steps.

Then, dp[x][k] = max(a_x + dp[x][k-1], a_{p_x} + dp[p_x][k-1])

But with k up to 10^9, this is too slow.

I need to find a way to compute dp[x][k] efficiently.

Perhaps I can find a closed-form formula for dp[x][k].

Let me consider that for each position x, if a_x >= a_{p_x}, then the optimal strategy is to stay at x for all k steps, collecting k * a_x.

Otherwise, it's better to move to p_x and collect a_{p_x}, and then repeat the process from p_x.

But even this seems too slow for large k.

Wait, perhaps I can compute for each position x, the maximum score achievable by staying at x for s steps, and then moving to p_x and repeating the process.

So, dp[x][k] = max over s from 0 to k of (s * a_x + dp[p_x][k - s])

But this is similar to the previous approach and still too slow.

I need a better way.

Let me consider that for each position x, if a_x >= a_{p_x}, then it's always better to stay at x as long as possible, because staying gives a higher or equal score per step.

So, in this case, the maximum score is k * a_x.

Otherwise, if a_x < a_{p_x}, it's better to move to p_x and collect a_{p_x}, and then repeat the decision at p_x.

So, in this case, dp[x][k] = max(a_x + dp[x][k-1], a_{p_x} + dp[p_x][k-1])

But this is still too slow for large k.

Wait, perhaps I can compute for each position x, whether it's better to stay or move, and then compute the maximum score accordingly.

Let me try to formalize this.

Define for each position x:

- If a_x >= a_{p_x}, then dp[x][k] = k * a_x

- Else, dp[x][k] = a_{p_x} + dp[p_x][k-1]

But this only considers moving once and then staying at p_x.

Wait, that might not be optimal.

Wait, perhaps I need to iterate this process.

Let me consider that for each position x, if a_x >= a_{p_x}, then staying is better, so dp[x][k] = k * a_x.

Otherwise, it's better to move to p_x and repeat the decision at p_x.

So, dp[x][k] = a_{p_x} + dp[p_x][k-1]

This seems like a recursive definition.

But with k up to 10^9, this recursion depth would be too large.

I need a way to compute this efficiently.

Let me consider that for each position x, if a_x >= a_{p_x}, then dp[x][k] = k * a_x.

Otherwise, dp[x][k] = a_{p_x} + dp[p_x][k-1]

I can compute this iteratively.

Start from x, and if a_x < a_{p_x}, move to p_x and add a_{p_x}, and repeat until a_x >= a_{p_x}, then stay for the remaining steps.

So, for each player, I can simulate this process:

- Initialize current position as starting position.

- While a[current] < a[p[current]], move to p[current] and collect a[p[current]], decrement k.

- Then, stay at the current position for the remaining k steps, collecting k * a[current].

This seems efficient, as the while loop will terminate since permutations have finite cycles.

Wait, but in a cycle, if a_x < a_{p_x} for all x in the cycle, then the player would keep moving forever.

But in reality, since permutations have cycles, and if a_x < a_{p_x} for all x in a cycle, the player would cycle through the positions indefinitely.

But in this case, since a_x are positive integers, the total score would be maximized by staying at the position with the highest a_x in the cycle.

Wait, perhaps I need to handle cycles separately.

Let me consider that for each player, their movement can eventually lead to a cycle where a_x >= a_{p_x}.

Then, the player can choose to stay at that position for the remaining steps.

But I need to handle the case where a_x < a_{p_x} for all positions in a cycle.

Wait, but since a_x are positive integers, and permutations have finite cycles, eventually, the player would have to choose to stay at some position.

Wait, no, in the problem, the player can choose to stay or move at each step independently.

So, the player can choose to stay at any position at any step.

Given that, perhaps the optimal strategy is to find the position in the cycle with the maximum a_x and stay there for as many steps as possible.

But I need to formalize this.

Let me consider that for each player, their movement can be represented as a path where they can choose to stay or move at each step.

Given that, the player can choose to stay at any position for any number of steps before moving to another position.

So, to maximize the score, the player should identify the position with the highest a_x in their cycle and stay there for as many steps as possible.

But to do this efficiently, I need to find, for each player, the position in their cycle with the maximum a_x, and then stay there for as many steps as possible.

But, since k can be up to 10^9, and n up to 2*10^5, I need to compute this efficiently.

Let me try to implement this idea.

First, for each player, find their cycle.

But since n is up to 2*10^5, and t is up to 10^4, I need an efficient way to handle this.

Wait, perhaps I can precompute for each position x, the maximum a_x in its cycle.

Then, for each player, find their cycle, find the maximum a_x in that cycle, and then stay at that position for k steps.

But, to find cycles for each position would be too slow for n up to 2*10^5 and t up to 10^4.

Wait, but in the problem, n is up to 2*10^5, and t is up to 10^4, but the sum of n over all t is up to 2*10^5, so it's manageable.

But I need a way to find, for each position, the maximum a_x in its cycle.

I can do this by iterating through the permutation and finding the cycles, and for each cycle, find the maximum a_x.

Then, for each player, find their cycle, find the maximum a_x in that cycle, and compute k * that maximum a_x.

But wait, this assumes that the player can instantly move to the position with the maximum a_x in their cycle.

But in reality, they can only move to p_x or stay at x at each step.

So, they might need to move through the cycle to reach the position with the maximum a_x.

Given that, and with k potentially being up to 10^9, I need to consider how many steps it takes to reach the position with the maximum a_x and then stay there for the remaining steps.

But this seems too slow for the time constraints.

I need a better approach.

Let me consider that for each player, their movement can be modeled as choosing to stay at a position or move to p_x at each step.

Given that, perhaps I can model this as finding the maximum possible sum of a_x over k steps, where at each step, x can either stay or move to p_x.

This seems similar to the problem of finding the maximum sum path in a graph with multiple choices at each step.

But again, with k up to 10^9, I need a smarter way.

Let me consider that for each player, their movement can be represented as a sequence of positions where they choose to stay or move at each step.

Given that, perhaps I can model this as a binary decision tree, where each node has two choices: stay or move.

But with k up to 10^9, this is not feasible.

I need to find a mathematical formula or a way to compute this efficiently.

Let me consider that for each player, their movement can be represented as a sequence of positions where they can choose to stay or move at each step.

Given that, perhaps I can model this as a linear recurrence.

But I'm not sure.

Wait, perhaps I can consider that for each player, their movement can be represented as a sequence of positions where they can choose to stay or move, and find a way to compute the maximum sum over k steps.

But I need a better approach.

Let me look at the sample input and output to understand what's expected.

Looking at the first sample input:

4 2 3 2

4 1 2 3

7 2 5 6

So, n=4, k=2, P_B=3, P_S=2

p = [4,1,2,3]

a = [7,2,5,6]

According to the explanation, Bodya starts at 3, with a_3=5. He chooses to stay at 3 for both turns, collecting 5 + 5 = 10.

Sasha starts at 2, with a_2=2. He chooses to move to p_2=1 on the first turn, collecting 2, and then stays at 1 on the second turn, collecting 7. Total score: 2 + 7 = 9.

So, Bodya wins with 10 > 9.

From this, it seems that the optimal strategy is to stay at the position with the highest a_x possible.

In this case, for Bodya, position 3 has a_3=5, and p_3=2, with a_2=5. But wait, in the sample, a_2=2, not 5. Wait, no, a = [7,2,5,6], so a_1=7, a_2=2, a_3=5, a_4=6.

p = [4,1,2,3], meaning p_1=4, p_2=1, p_3=2, p_4=3.

So, Bodya starts at 3, p_3=2, a_2=2.

So, if he stays at 3, he collects a_3=5 both turns, total 10.

If he moves to 2 on the first turn, collects a_2=2, then on the second turn, he can choose to stay at 2 and collect a_2=2 again, or move to p_2=1 and collect a_1=7.

So, if he moves to 2 and then stays at 2, total is 2 + 2 = 4.

If he moves to 2 and then moves to 1, total is 2 + 7 = 9.

So, his options are:

- Stay at 3 both turns: 5 + 5 = 10

- Move to 2 first turn, stay at 2 second turn: 2 + 2 = 4

- Move to 2 first turn, move to 1 second turn: 2 + 7 = 9

So, the maximum is 10.

Similarly, for Sasha starting at 2:

- Stay at 2 both turns: 2 + 2 = 4

- Move to 1 first turn, stay at 1 second turn: 2 + 7 = 9

- Move to 1 first turn, move to p_1=4, collect a_4=6: 2 + 6 = 8

So, the maximum is 9.

Hence, Bodya wins with 10 > 9.

From this, it seems that the optimal strategy is to identify the position in the cycle with the maximum a_x and stay there for as many steps as possible.

In Bodya's case, position 3 has a_3=5, p_3=2 has a_2=2, p_2=1 has a_1=7, p_1=4 has a_4=6, p_4=3, which loops back.

So, the cycle is 3 -> 2 -> 1 -> 4 -> 3.

The maximum a_x in this cycle is a_1=7.

However, Bodya can choose to stay at position 3, collecting 5 each turn, which is better than moving to position 1 and collecting 7 only once and then having to move elsewhere.

But in this specific case, since k=2 is small, it's manageable to compute all possibilities.

But for larger k, I need a general approach.

Let me consider that for each player, their movement can be modeled as choosing to stay at a position or move to p_x at each step.

Given that, perhaps I can model this as a graph where each node has two outgoing edges: one to itself with weight a_x, and one to p_x with weight a_{p_x}.

Then, the problem reduces to finding the path of length k with the maximum sum of weights.

But with n up to 2*10^5 and k up to 10^9, this is not feasible directly.

I need a better way.

Let me consider that for each player, their movement can be represented as a sequence of positions where they can choose to stay or move at each step.

Given that, perhaps I can model this as a decision tree, where at each step, they choose to stay or move.

But again, with k up to 10^9, this is not practical.

I need to find a mathematical formula or a way to compute the maximum score efficiently.

Let me consider that for each player, their movement can be represented as a sequence of positions where they can choose to stay or move at each step.

Given that, perhaps I can model this as a binary decision at each step: stay or move.

Then, the total score is the sum of a_x for each step, where x is the position chosen at that step.

Given that, perhaps I can model this as the sum over all steps of a_x, where x is either the current position or p_x, depending on the choice.

But this seems too vague.

Wait, perhaps I can model this as a recursion where at each step, the player chooses to stay and collect a_x, or move to p_x and collect a_{p_x}.

Then, the maximum score is the maximum over all possible sequences of choices.

But with k up to 10^9, I need a way to compute this efficiently.

Let me consider that for each player, their movement can be represented as a sequence of positions where they can choose to stay or move at each step.

Given that, perhaps I can model this as a geometric series, where the player chooses to stay at a position for s steps, collecting s * a_x, and then moves to p_x and repeats the process.

But I need to formalize this.

Let me consider that for each position x, the maximum score achievable is:

dp[x][k] = max over s from 0 to k of (s * a_x + dp[p_x][k - s])

This is similar to the convolution of the sequence a_x and dp[p_x][k].

But with k up to 10^9, this is not feasible.

I need a better approach.

Let me consider that for each player, their movement can be represented as a sequence of positions where they can choose to stay or move at each step.

Given that, perhaps I can model this as a Markov decision process, where at each step, the player chooses an action (stay or move), and transitions to the next state accordingly.

But again, with k up to 10^9, this is not practical.

I need to find a way to compute the maximum score efficiently.

Let me consider that for each player, their movement can be represented as a sequence of positions where they can choose to stay or move at each step.

Given that, perhaps I can model this as a binary tree, where each node represents a position, and has two children: staying and moving.

But with n up to 2*10^5 and k up to 10^9, this is not feasible.

I need a better way.

Let me consider that for each player, their movement can be represented as a sequence of positions where they can choose to stay or move at each step.

Given that, perhaps I can model this as a mathematical formula.

Wait, perhaps I can model this as the player choosing to stay at a position x for s steps, collecting s * a_x, and then moving to p_x and repeating the process.

Then, the total score would be s * a_x + dp[p_x][k - s]

I need to maximize this over s from 0 to k.

But with k up to 10^9, I need a way to compute this efficiently.

Let me consider that for each position x, if a_x >= a_{p_x}, then the optimal strategy is to stay at x for all k steps, collecting k * a_x.

Otherwise, it's better to move to p_x and collect a_{p_x}, and then repeat the process from p_x.

So, dp[x][k] = max(k * a_x, a_{p_x} + dp[p_x][k - 1])

But with k up to 10^9, this is still too slow.

I need a way to compute this efficiently.

Let me consider that for each position x, if a_x >= a_{p_x}, then dp[x][k] = k * a_x.

Otherwise, dp[x][k] = a_{p_x} + dp[p_x][k - 1]

I can compute dp[x][k] iteratively.

Start from x, if a_x < a_{p_x}, move to p_x and collect a_{p_x}, and repeat until a_x >= a_{p_x}, then stay at that position for the remaining k steps.

So, for each player, I can simulate this process:

- Initialize current position as starting position.

- While a[current] < a[p[current]], move to p[current], collect a[p[current]], decrement k.

- Then, stay at the current position for the remaining k steps, collecting k * a[current].

This seems efficient, as the while loop will terminate since permutations have finite cycles.

In the sample input, for Bodya starting at 3:

a[3]=5, a[p[3]]=a[2]=2

Since 5 >= 2, stay at 3 for both turns: 5 + 5 = 10.

For Sasha starting at 2:

a[2]=2, a[p[2]]=a[1]=7

Since 2 