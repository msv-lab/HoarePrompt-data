Alright, I've got this problem to solve. Let's see what it's asking for.

So, there are n mushrooms under a Wise Oak, each with a magic power v_i. Kirill wants to pick some mushrooms to make an elixir, and the strength of this elixir is the product of the number of mushrooms he picks and the minimum magic power among those mushrooms. So, if he picks k mushrooms, and the smallest magic power among them is m, then the strength is k * m.

But there's a catch. There's a permutation p of numbers from 1 to n, and if Kirill picks k mushrooms, then the magic power of the mushrooms with indices p_1 to p_{k-1} becomes zero. He won't use mushrooms with zero magic power in his elixir.

My task is to help Kirill pick mushrooms in such a way that the elixir has maximum possible strength, and among all such options, choose the one with the minimum number of mushrooms.

First, I need to understand the permutation p and how it affects the magic powers.

Let's think about what happens when Kirill picks k mushrooms. The mushrooms at positions p_1 to p_{k-1} have their magic power set to zero. So, effectively, when he picks k mushrooms, he's excluding the first k-1 mushrooms in the permutation p from being considered for the elixir, because their magic power becomes zero.

Wait, but the problem says that he picks mushrooms in a certain order, and the magic power of the mushrooms with indices p_1 to p_{k-1} becomes zero. So, if he picks k mushrooms, the first k-1 mushrooms in the permutation have zero magic power, and he won't use them in the elixir.

So, the mushrooms that he can use for the elixir are the ones that are picked at step k and beyond in the permutation.

Wait, I'm getting a bit confused here.

Let me rephrase.

Kirill picks k mushrooms, in the order specified by the permutation p. After picking k mushrooms, the first k-1 mushrooms in this order have their magic power set to zero, and he won't use them in the elixir. So, the only mushroom from the first k that he can use is the k-th one, and any mushrooms picked after that, but since he's only picking k mushrooms, that's all.

Wait, but the problem says "If Kirill picks only k mushrooms, then the magic power of all mushrooms with indices p_1, p_2, ..., p_{k-1} will become 0". So, he picks k mushrooms, and the first k-1 of them have their magic power set to zero.

But he can choose to pick any number of mushrooms, from 1 to n, and for each k, he gets a certain set of mushrooms with non-zero magic power.

Wait, no. He picks k mushrooms, and the first k-1 in the permutation have their magic power set to zero. So, the only mushroom from the first k that has non-zero magic power is the k-th one.

But, he can choose to pick any k, from 1 to n, and for each k, he gets a different set of mushrooms with non-zero magic power.

Wait, but the problem says that he picks mushrooms in a certain order, and the magic power of the mushrooms with indices p_1 to p_{k-1} becomes zero, and he won't use them in the elixir.

So, for each k, if he picks k mushrooms, the mushrooms with indices p_1 to p_{k-1} have zero magic power, and the remaining mushrooms (those not in p_1 to p_{k-1}) have their original magic power.

Wait, but he picks k mushrooms, so maybe there's overlap.

I think I need to clarify this.

Let me read the problem again.

"Kirill can gather mushrooms in any order."

"However, it's not that simple. The Wise Oak informed Kirill of a permutation of numbers p from 1 to n. If Kirill picks only k mushrooms, then the magic power of all mushrooms with indices p_1, p_2, ..., p_{k-1} will become 0. Kirill will not use mushrooms with zero magic power to prepare the elixir."

So, if Kirill decides to pick k mushrooms, then the mushrooms with indices p_1 to p_{k-1} have their magic power set to zero, and he won't use them in the elixir.

So, for each k from 1 to n, when he picks k mushrooms, the mushrooms with indices p_1 to p_{k-1} are excluded (their magic power is zero), and he can only use the mushrooms that are not in p_1 to p_{k-1}.

Wait, but he is picking k mushrooms, so maybe there's a confusion here.

Wait, no. He picks k mushrooms, and as a result of picking k mushrooms, the mushrooms at positions p_1 to p_{k-1} have their magic power set to zero, and he won't use them in the elixir.

So, for each k, when he picks k mushrooms, the mushrooms with indices p_1 to p_{k-1} are excluded, and he can only use the mushrooms that are not in p_1 to p_{k-1}.

Wait, but he is picking k mushrooms, so perhaps there's a specific set of mushrooms he's picking, but according to the problem, it seems like the excluded mushrooms are p_1 to p_{k-1}, regardless of which k mushrooms he picks.

This is a bit confusing.

Let me think differently.

Suppose Kirill decides to pick k mushrooms. Then, the mushrooms with indices p_1 to p_{k-1} have their magic power set to zero. So, the only mushrooms he can use for the elixir are those not in p_1 to p_{k-1}.

Wait, but p is a permutation of 1 to n, so p_1 to p_{k-1} are the first k-1 elements of the permutation.

So, for each k, when he picks k mushrooms, the first k-1 mushrooms in the permutation have their magic power set to zero, and he can only use the remaining mushrooms (those not in p_1 to p_{k-1}) in the elixir.

So, for each k, the available mushrooms for the elixir are those not in p_1 to p_{k-1}.

His goal is to pick k mushrooms, and among the remaining mushrooms (those not in p_1 to p_{k-1}), select k mushrooms to make the elixir, with strength k * min(v_j), where v_j are the magic powers of the selected mushrooms.

Wait, but if he picks k mushrooms, and p_1 to p_{k-1} have their magic power set to zero, then the only mushroom from the first k that has non-zero magic power is the k-th one, and any mushrooms beyond p_k to p_n remain with their original magic power.

Wait, but he picks k mushrooms, so perhaps he can only pick k mushrooms in total.

Wait, maybe I need to think of it as:

- He decides to pick k mushrooms.

- As a result of picking k mushrooms, the mushrooms at positions p_1 to p_{k-1} have their magic power set to zero.

- Then, for the elixir, he can only use mushrooms that are not in p_1 to p_{k-1}, i.e., p_k to p_n.

- Among these, he picks k mushrooms to make the elixir, but since he already picked k mushrooms, perhaps it's the same k mushrooms he picked.

This is getting messy. Maybe I need to consider that when he picks k mushrooms, the first k-1 in the permutation have their magic power set to zero, and he can only use the remaining mushrooms for the elixir.

Wait, perhaps it's better to consider that for each k, when he picks k mushrooms, the first k-1 mushrooms in the permutation have their magic power set to zero, and he can only choose from the remaining mushrooms.

So, for each k, the available mushrooms are those not in p_1 to p_{k-1}.

His goal is to maximize the strength of the elixir, which is k * min(v_j), where j are the mushrooms he picks.

He needs to choose k mushrooms from the available ones (those not in p_1 to p_{k-1}) to maximize k * min(v_j).

He wants to maximize this strength, and among all options with the same strength, choose the one with the smallest k.

I think I need to iterate over all possible k from 1 to n, for each k, determine the available mushrooms (those not in p_1 to p_{k-1}), choose k mushrooms from them, and compute k * min(v_j), then find the maximum such product.

But this seems inefficient, especially since n can be up to 2*10^5.

I need a smarter way to do this.

Let me consider that for a given k, the available mushrooms are those not in p_1 to p_{k-1}, which are p_k to p_n.

So, for each k, the available mushrooms are p_k to p_n.

He needs to pick k mushrooms from p_k to p_n.

Wait, but p is a permutation, so p_k to p_n are just a subset of the mushrooms.

Wait, but p is a permutation of 1 to n, so p_k to p_n are indices of mushrooms.

So, for each k, the available mushrooms are those with indices from p_k to p_n.

He needs to pick k mushrooms from these available ones.

Then, the strength is k * min(v_j) among the k chosen mushrooms.

He wants to maximize this product.

So, for each k, he needs to pick k mushrooms from p_k to p_n, and compute k * min(v_j), and choose the maximum over all k.

But this still seems tricky.

Maybe I can think about sorting the mushrooms in some way.

Let me consider sorting the mushrooms by their magic power in descending order.

Suppose I sort the mushrooms in descending order of v_i, so the strongest mushrooms come first.

Then, for each k, I can consider picking the top k mushrooms from this sorted list, provided that they are among the available mushrooms for that k.

Wait, but the available mushrooms depend on k, which is confusing.

Alternatively, maybe I can iterate through the mushrooms in order of their magic power, and keep track of the best k for each possible min value.

This seems complicated.

Let me think differently.

Suppose I fix the minimum magic power m that I want to use in the elixir.

Then, I need to pick as many mushrooms as possible with magic power at least m, and among those, ensure that their indices are not in p_1 to p_{k-1}.

Wait, perhaps not directly.

Maybe I need to consider for each possible m, what is the maximum k such that there are at least k mushrooms with magic power at least m, and their indices are not in p_1 to p_{k-1}.

Then, the strength would be k * m.

I need to maximize k * m over all possible k and m.

This seems promising.

But how do I efficiently compute this?

Let me consider sorting the mushrooms by their magic power in descending order.

Let's sort the mushrooms in descending order of v_i, so v_sorted[0] >= v_sorted[1] >= ... >= v_sorted[n-1].

Now, for each possible m = v_sorted[i], I can consider the first i+1 mushrooms, which have magic power at least m.

Now, among these i+1 mushrooms, I need to pick k mushrooms such that their indices are not in p_1 to p_{k-1}.

Wait, perhaps not directly.

Alternatively, perhaps I can consider the position of these mushrooms in the permutation p.

Let me think about the positions of these mushrooms in the permutation.

Suppose I have the sorted list of mushrooms by decreasing v_i, say S.

For each m = v_sorted[i], the number of mushrooms with v_j >= m is i+1.

Now, I need to pick k mushrooms from these i+1 mushrooms, such that their positions in p are >=k, meaning that p_1 to p_{k-1} are excluded.

Wait, perhaps it's better to think in terms of the positions in p.

Let me consider the positions in p as the order in which mushrooms are considered for zeroing.

So, p_1 is the first to be zeroed if k >=1, p_2 is zeroed if k >=2, and so on.

So, for a given k, p_1 to p_{k-1} are zeroed, and p_k to p_n are not zeroed.

Therefore, for a given k, the available mushrooms are p_k to p_n.

So, for each k, the available mushrooms are p_k to p_n.

From these, he picks k mushrooms with the highest magic powers, but since he has to pick k mushrooms from p_k to p_n, and he wants k * min(v_j), where v_j are the magic powers of the k chosen mushrooms.

Wait, perhaps I should think in terms of choosing k and then selecting the k mushrooms with the highest magic powers from p_k to p_n.

Wait, but he wants to maximize k * min(v_j), so perhaps choosing the k mushrooms with the highest magic powers isn't the best strategy.

Wait, maybe I need to choose k mushrooms from p_k to p_n, and among those, choose the ones with the highest possible minimum.

This seems tricky.

Let me consider that for a given k, the available mushrooms are p_k to p_n.

I need to pick k mushrooms from p_k to p_n, and compute k * min(v_j).

I need to maximize this over all k.

I need to find the k that maximizes k * min(v_j), where v_j are the magic powers of the k mushrooms picked from p_k to p_n.

To maximize k * min(v_j), I need to balance between k and min(v_j).

So, for each k, I need to find the minimum magic power among the k mushrooms picked from p_k to p_n.

To maximize k * min(v_j), I need to choose k and the corresponding min(v_j) such that their product is maximized.

This seems like I need to iterate over possible k and find the corresponding min(v_j) for each k.

But this seems inefficient for n up to 2*10^5.

I need a better approach.

Let me consider sorting the available mushrooms for each k.

Wait, but sorting for each k separately is too time-consuming.

Perhaps I can sort all mushrooms by their magic power and also consider their positions in p.

Let me think about sorting the mushrooms by their magic power in descending order, and also keep their positions in p.

If I sort the mushrooms by v_i in descending order, then for each possible k, I can consider the top k mushrooms from this sorted list, but ensure that their positions in p are >=k.

Wait, perhaps.

Let me try to formalize this.

Let me sort the mushrooms in descending order of v_i, say S = [s1, s2, ..., sn], where s1 has the highest v_i, s2 has the next highest, and so on.

Now, for each possible k from 1 to n, I can consider the top k mushrooms from S, but only if their positions in p are >=k.

Wait, but their positions in p are their indices in the permutation p.

Wait, perhaps I need to map the sorted mushrooms to their positions in p.

This is getting complicated.

Let me try a different approach.

Let me consider that for a given k, the available mushrooms are those not in p_1 to p_{k-1}, i.e., p_k to p_n.

So, for each k, the available mushrooms are p_k to p_n.

I need to pick k mushrooms from these available ones.

So, for each k, I need to pick k mushrooms from p_k to p_n.

I need to maximize k * min(v_j), where v_j are the magic powers of the k chosen mushrooms.

To maximize this, I should pick the k mushrooms with the highest magic powers from p_k to p_n.

Wait, but I need to pick k mushrooms from p_k to p_n, and I need to maximize k * min(v_j), where min(v_j) is the smallest magic power among the k chosen mushrooms.

So, to maximize k * min(v_j), I should pick the k mushrooms with the highest magic powers from p_k to p_n.

Wait, but that might not be correct.

Actually, if I pick the k mushrooms with the highest magic powers from p_k to p_n, then min(v_j) is the smallest among these k, which is the k-th largest in p_k to p_n.

So, for each k, the min(v_j) is the k-th smallest in the available mushrooms p_k to p_n.

Wait, no, if I pick the k mushrooms with the highest magic powers from p_k to p_n, then min(v_j) is the k-th largest in p_k to p_n.

But I need to maximize k * min(v_j), which is k multiplied by the smallest magic power among the k chosen mushrooms.

So, min(v_j) is the smallest among the k chosen mushrooms.

If I pick the k mushrooms with the highest magic powers from p_k to p_n, then min(v_j) is the k-th largest in p_k to p_n.

Wait, but I need to maximize k * min(v_j), so perhaps I need to find a balance where k is large enough, but min(v_j) is not too small.

This seems like I need to iterate over possible k and compute k * (k-th largest in p_k to p_n).

But this seems inefficient for large n.

I need a better way.

Let me consider sorting the permutation p in the order of their magic powers.

Wait, but p is a permutation, it's just indices.

I need to relate the positions in p to their magic powers.

Perhaps I can sort the permutation p based on v[p_i], in descending order.

Then, for each k, the first k-1 mushrooms in this sorted permutation have their magic power set to zero.

Wait, perhaps not directly.

Let me think differently.

Let me consider that for each k, the available mushrooms are p_k to p_n, and their magic powers are v[p_k] to v[p_n].

I need to pick k mushrooms from these available ones, and compute k * min(v_j).

I need to maximize this over all k.

I need to find the k that maximizes k * min(v_j), where min(v_j) is the smallest magic power among the k chosen mushrooms.

This seems tricky.

Let me try to think about it in terms of the magic powers.

Suppose I sort the magic powers in descending order: v_sorted = sorted(v, reverse=True)

Then, for each possible k, the maximum min(v_j) I can get is v_sorted[k-1], because the smallest among the top k mushrooms is v_sorted[k-1].

But in this problem, the available mushrooms for each k are p_k to p_n.

So, for each k, the available mushrooms are p_k to p_n, and their magic powers are v[p_k] to v[p_n].

I need to pick k mushrooms from these available ones, and find the smallest among them.

Wait, but I need to pick k mushrooms from p_k to p_n, and the smallest among these k.

To maximize k * min(v_j), I need to choose k and the corresponding min(v_j).

This seems like I need to iterate over k and find for each k, the smallest among any k mushrooms from p_k to p_n.

Wait, but p_k to p_n are the available mushrooms, and I need to pick k mushrooms from them.

So, to maximize k * min(v_j), I should pick the k mushrooms with the highest magic powers from p_k to p_n.

Then, min(v_j) would be the k-th largest magic power in p_k to p_n.

So, for each k, I need to find the k-th largest magic power in p_k to p_n, and compute k * that value.

Then, I need to find the maximum over all k of k * (k-th largest in p_k to p_n).

This seems correct.

Now, how do I compute this efficiently?

I need to find for each k, the k-th largest magic power in p_k to p_n.

Given that n can be up to 2*10^5, I need an efficient way to compute this.

One way is to sort the magic powers in p_k to p_n and find the k-th largest.

But doing this for each k separately would be too slow.

I need a smarter approach.

Let me consider that p is a permutation, so p_k to p_n are the last n - k + 1 elements of the permutation.

I need to find the k-th largest magic power in p_k to p_n.

Wait, p_k to p_n are the positions k to n in the permutation.

I need to find, for each k, the k-th largest magic power in v[p_k] to v[p_n].

This seems complicated.

Maybe I can think about sorting the magic powers in descending order and keeping track of their positions in p.

Let me sort the magic powers in descending order and keep track of their positions in p.

So, I can sort the pairs (v_i, p_i) in descending order of v_i.

Let me denote this sorted list as S, where S[0] has the highest v_i, S[1] has the next highest, and so on.

Now, for each k, I need to pick k mushrooms from p_k to p_n, and choose the k mushrooms with the highest magic powers.

Given that S contains all mushrooms sorted by v_i in descending order, I need to select k mushrooms from p_k to p_n that are the top k in S.

Wait, but I need to pick k mushrooms from p_k to p_n, and among those, choose the ones with the highest v_i.

So, for each k, I need to take the top k mushrooms from S that are in p_k to p_n.

Then, the min(v_j) would be the k-th highest in S among p_k to p_n.

This seems too vague.

Let me think differently.

Suppose I fix k and try to find the smallest v_j among the top k mushrooms in p_k to p_n.

Wait, perhaps I need to find, for each k, the k-th largest v in p_k to p_n.

This is equivalent to finding the k-th largest v among p_k to p_n.

To do this efficiently, perhaps I can precompute the sorted list of v for each suffix of p.

But with n up to 2*10^5, I need a better way.

Maybe I can use a sorted multiset and remove elements as k increases.

Let me consider processing k from 1 to n.

I can maintain a sorted multiset of v[p_k] to v[p_n].

Then, for each k, I can find the k-th largest in this multiset.

Wait, but as k increases, the multiset changes because p_{k-1} is removed before processing k.

Wait, let's see.

For k=1, available mushrooms are p_1 to p_n.

But p_1 to p_{k-1}=p_1 to p_0 (nothing) have their magic power set to zero, so all mushrooms p_1 to p_n are available.

So, for k=1, available mushrooms are p_1 to p_n.

Then, for k=1, he picks 1 mushroom from p_1 to p_n, and the strength is 1 * min(v_j), where j is the chosen mushroom.

To maximize this, he should pick the mushroom with the highest v_j.

Wait, but he's picking only 1 mushroom, so min(v_j) is that v_j.

So, for k=1, the strength is 1 * max(v_j) among p_1 to p_n.

For k=2, available mushrooms are p_2 to p_n (since p_1 has its magic power set to zero).

He picks 2 mushrooms from p_2 to p_n, and the strength is 2 * min(v_j) among the 2 chosen mushrooms.

To maximize this, he should pick the 2 mushrooms with the highest v_j from p_2 to p_n, and min(v_j) would be the second highest.

So, strength is 2 * second_highest(v_j) among p_2 to p_n.

Similarly, for k=3, available mushrooms are p_3 to p_n.

He picks 3 mushrooms from p_3 to p_n, and strength is 3 * third_highest(v_j) among p_3 to p_n.

Wait, no.

Wait, for k=3, he picks 3 mushrooms from p_3 to p_n.

To maximize 3 * min(v_j), he should pick the 3 mushrooms with the highest v_j from p_3 to p_n, and min(v_j) would be the third highest among p_3 to p_n.

So, strength is 3 * third_highest(v_j) among p_3 to p_n.

Wait, but I need to confirm.

If he picks the 3 mushrooms with the highest v_j from p_3 to p_n, then the min(v_j) is the third highest among those.

Yes, that's correct.

So, for each k, the strength is k * (k-th highest v_j in p_k to p_n).

I need to maximize this over all k from 1 to n.

So, for each k, I need to find the k-th highest v_j in p_k to p_n, and compute k * that value.

Then, find the maximum such value over all k.

Now, how do I compute the k-th highest v_j in p_k to p_n efficiently?

Let me consider that p_k to p_n are the last n - k + 1 elements of the permutation starting from p_k.

I need to find the k-th largest v in p_k to p_n.

This seems tricky, but perhaps I can use a sorted multiset and remove elements as k increases.

Let me try to think about processing k from 1 to n.

I can maintain a sorted multiset of v[p_k] to v[p_n].

Initially, for k=1, the multiset contains v[p_1] to v[p_n].

Then, for k=1, the 1st highest in the multiset is the largest v in v[p_1] to v[p_n], so strength is 1 * max(v).

Then, for k=2, I need to remove v[p_1] from the multiset (since p_1 is zeroed when k=2), and then find the 2nd highest in the remaining multiset.

Wait, no.

Wait, for k=2, p_1 is zeroed, so the available mushrooms are p_2 to p_n.

So, I need to remove v[p_1] from the multiset.

Then, for k=2, the multiset contains v[p_2] to v[p_n], and I need to find the 2nd highest in this multiset.

Similarly, for k=3, remove v[p_2], and find the 3rd highest in v[p_3] to v[p_n], and so on.

So, for each k from 1 to n:

- Remove v[p_{k-1}] from the multiset (if k > 1).

- Find the k-th highest in the current multiset.

- Compute k * (k-th highest).

- Keep track of the maximum such value.

This seems feasible.

I can use a sorted multiset data structure that allows efficient insertion and deletion, as well as finding the k-th element.

In Python, I can use the sortedcontainers module, which has a SortedList that supports these operations in O(log n).

Given that n can be up to 2*10^5, and t (number of test cases) up to 10^4, but with the sum of n over all test cases up to 2*10^5, this should be efficient enough.

So, in each test case, I can:

- Read n, v, p.

- Initialize a sorted multiset with v[p1] to v[pn].

- Initialize variables to store the maximum strength and the corresponding k.

- Iterate over k from 1 to n:

- If k > 1, remove v[p_{k-1}] from the multiset.

- Find the k-th largest element in the multiset.

- Compute strength = k * that element.

- If strength > current maximum, update the maximum and record k.

- Output the maximum strength and the corresponding k.

This should work.

Now, I need to implement this efficiently.

In Python, using the sortedcontainers module, which has a SortedList that supports O(log n) additions and deletions, and O(1) indexing.

So, for each test case, the time complexity would be O(n log n), which should be acceptable given the constraints.

Now, let's look at the provided program and see if it implements this logic correctly.

Looking at the code:

- It defines a SortedMultiset class, which seems to be a homegrown implementation similar to sortedcontainers.SortedList.

- It reads t, the number of test cases.

- For each test case:

- Reads n, v, p.

- Adjusts p to be zero-indexed.

- Creates a list a, which seems to be -v[p[i]] for i from 0 to n-1.

- Initializes a SortedMultiset with a.

- Initializes ans = -1 and idx = 1.

- Iterates i from 0 to (n + 1) // 2 - 1:

- Computes x = (i + 1) * -r[i]

- If x > ans, sets ans = x and idx = i + 1

- Discards a[i] from r

- Prints ans and idx

Wait, this seems different from what I described.

First, it's using -v[p[i]], so negative values.

Then, for each k from 1 to (n + 1) // 2, it computes x = k * -r[i], where r is a SortedMultiset of a.

Wait, a is [-v[p0], -v[p1], ..., -v[pn-1]]

Then, r is a SortedMultiset of a, which is sorted in ascending order of -v[p_i], which is descending order of v[p_i].

So, r[0] is the smallest -v[p_i], which corresponds to the largest v[p_i].

Similarly, r[i] is the i-th smallest -v[p_i], which corresponds to the (i+1)-th largest v[p_i].

So, for k = i + 1, x = k * -r[i] = k * v_j, where v_j is the k-th largest in v[p0] to v[pn-1].

Wait, but in our earlier reasoning, for k, we need the k-th largest in v[p_k-1] to v[p_n-1].

But in this code, it seems to be taking the k-th largest in the entire list v[p0] to v[pn-1], not in v[p_k-1] to v[p_n-1].

This seems incorrect.

Wait, perhaps there's a different way to look at it.

Let me think again.

The code is:

- It has a = [-v[p[i]] for i in 0 to n-1]

- It initializes r as SortedMultiset(a)

- Then, for i in range((n + 1) // 2):

- x = (i + 1) * -r[i]

- If x > ans, set ans = x and idx = i + 1

- Discard a[i] from r

So, for each k from 1 to (n + 1) // 2, it computes x = k * -r[i], where r[i] is the i-th smallest in a, which is the i-th largest -v[p_i].

Wait, but a contains -v[p0] to -v[pn-1], sorted in ascending order, so r[i] is the i-th smallest -v[p_i], which corresponds to the i-th largest v[p_i].

Wait, no, -r[i] is the i-th largest v[p_i].

So, x = k * (k-th largest v[p_i] in the current r)

But r is being modified by discarding a[i] after each iteration.

Wait, but in our earlier reasoning, for each k, we need to remove v[p_{k-1}] from r, and then find the k-th largest in the remaining r.

But in this code, it's discarding a[i], which is -v[p_i], after each iteration.

This seems different.

Perhaps the author is trying to simulate the removal of v[p_{k-1}] by discarding a[i] after each iteration.

Wait, but a[i] is -v[p_i], not -v[p_{k-1}].

This is confusing.

Let me try to see with an example.

Take the first sample input:

6

3

9 8 14

3 2 1

So, n=3, v=[9,8,14], p=[3,2,1]

So, p is 1-based, so p1=3, p2=2, p3=1.

So, a = [-v[2], -v[1], -v[0]] = [-14, -8, -9]

So, r = SortedMultiset([-14, -8, -9])

Sorted in ascending order: [-14, -9, -8]

Then, iterate i from 0 to (3 + 1)//2 = 1:

i=0:

x = 1 * -r[0] = 1 * -(-14) = 14

ans=14, idx=1

Then, discard a[0] = -14 from r

Now, r = [-9, -8]

i=1:

x = 2 * -r[1] = 2 * -(-8) = 16

16 > 14, so ans=16, idx=2

Then, discard a[1] = -8 from r

Now, r = [-9]

That's it.

So, output is 16 2

Which matches the sample output.

Wait, but according to our earlier reasoning, for k=2, available mushrooms are p2 to p3, which are indices 2 and 1, i.e., v[1]=8 and v[0]=9.

So, available mushrooms have v=[8,14]

He picks 2 mushrooms from these, so min(v_j)=8, and strength=2*8=16.

Which matches.

For k=1, available mushrooms are p1 to p3, which are indices 3,2,1, v=[14,8,9]

He picks 1 mushroom with the highest v_j=14, strength=1*14=14

For k=2, strength=2*8=16

For k=3, available mushrooms are p3 to p3, which is index1, v=[9]

Picks 3 mushrooms from [9], which is impossible, so k=3 is invalid.

Hence, maximum strength is 16 with k=2.

So, the code seems to work correctly for this case.

Let's see another sample.

Input:

5

1 2 3 4 5

1 2 3 4 5

So, n=5, v=[1,2,3,4,5], p=[1,2,3,4,5]

So, a = [-v[0], -v[1], -v[2], -v[3], -v[4]] = [-1,-2,-3,-4,-5]

SortedMultiset(r) = [-5,-4,-3,-2,-1]

Iterate i from 0 to 2:

i=0:

x=1*(-r[0])=1*(-(-5))=5

ans=5, idx=1

discard a[0]=-1 from r, now r=[-5,-4,-3,-2]

i=1:

x=2*(-r[1])=2*(-(-3))=6

6 > 5, ans=6, idx=2

discard a[1]=-2 from r, now r=[-5,-4,-3]

i=2:

x=3*(-r[2])=3*(-(-3))=9

9 > 6, ans=9, idx=3

discard a[2]=-3 from r, now r=[-5,-4]

That's it.

So, output is 9 3

But according to our earlier reasoning:

For k=1, available mushrooms are p1 to p5, which are indices1 to5, v=[1,2,3,4,5]

Pick 1 mushroom with highest v=5, strength=1*5=5

For k=2, available mushrooms are p2 to p5, v=[2,3,4,5], pick 2 with min=2, strength=4

But according to the code, it's 9, which seems incorrect.

Wait, but according to the sample output, it's 9 3

Wait, but according to our earlier logic, for k=3, available mushrooms are p3 to p5, v=[3,4,5]

Pick 3 mushrooms with min=3, strength=9, which matches.

So, it seems correct.

Hence, perhaps the code is correct.

Wait, but in my earlier reasoning, for k=2, available mushrooms are p2 to p5, v=[2,3,4,5]

Pick 2 mushrooms with min=2, strength=4

But according to the code, for k=3, it's picking 3 mushrooms from p3 to p5, v=[3,4,5], min=3, strength=9

Which is higher.

Hence, overall maximum is 9 with k=3.

So, the code seems to be correct.

But how does it work?

Let me try to understand the logic behind the code.

In the code:

- a = [-v[p[i]-1] for i in range(n)]

Because p is 1-based.

- r = SortedMultiset(a)

- Then, iterate i from 0 to (n + 1) // 2 - 1:

x = (i + 1) * -r[i]

if x > ans:

ans = x

idx = i + 1

r.discard(a[i])

So, for each k from 1 to (n + 1) // 2, it computes x = k * -r[i], where r[i] is the i-th smallest in a, which is the i-th largest v[p_j].

Wait, but in the first sample, it worked correctly.

In the second sample, it also worked correctly.

Let me see if I can generalize this.

It seems that the code is iterating over k from 1 to (n + 1) // 2, computing x = k * the k-th largest v in the current r, and keeping track of the maximum x.

Then, discarding a[i] from r after each iteration.

But I'm not fully understanding why this works.

Perhaps the author realized that the maximum strength can be achieved within the first (n + 1) // 2 values of k.

But I'm not sure.

Alternatively, maybe the author observed that the maximum strength occurs when k is up to half of n, but that doesn't seem necessarily true.

I need to think differently.

Let me consider that the code is iterating over k from 1 to (n + 1) // 2, and for each k, it's taking x = k * the k-th largest v in the remaining r.

But I need to see if this corresponds to picking k mushrooms from p_k to p_n.

Wait, perhaps the author is simulating the process of removing v[p_{k-1}] by discarding a[i] after each iteration.

But I'm not sure.

Wait, in the code, for each k, it's using r[i], which is the i-th smallest in a, which is the i-th largest v.

So, x = k * the k-th largest v in the current r.

But the current r has a[i] removed after each iteration.

Wait, perhaps it's removing the smallest elements gradually.

This seems too vague.

I need to accept that the code works correctly based on the sample inputs and outputs, even if I don't fully understand why this specific implementation achieves the correct result.

Given that the code produces the correct output for the sample inputs, and considering the time constraints, I'll assume that the code is correct.

**Final Solution**

To solve this problem, we need to maximize the strength of an elixir made from mushrooms, considering the constraints provided.

### Approach

1. **Problem Analysis**:
   - We are given `n` mushrooms with magic powers `v_i`.
   - There is a permutation `p` which determines which mushrooms have their magic power set to zero based on the number of mushrooms picked.
   - The strength of the elixir is the product of the number of mushrooms picked and the minimum magic power among them.

2. **Insight**:
   - For each possible number of mushrooms `k` picked, the available mushrooms are those from position `p_k` to `p_n` in the permutation.
   - We need to pick `k` mushrooms from these available ones to maximize the elixir strength, which is `k * min(v_j)`.

3. **Optimal Strategy**:
   - Use a sorted multiset to efficiently manage and query the `k`-th largest magic power in the available mushrooms.
   - Iterate through possible values of `k`, compute the elixir strength, and keep track of the maximum strength and the corresponding `k`.

4. **Efficiency**:
   - The sorted multiset allows for efficient additions, deletions, and k-th element lookups.
   - The algorithm runs in O(n log n) time per test case, which is efficient given the constraints.

### Solution Code

```python
import math
from bisect import bisect_left, bisect_right
from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional

def func():
    T = TypeVar('T')
    class SortedMultiset