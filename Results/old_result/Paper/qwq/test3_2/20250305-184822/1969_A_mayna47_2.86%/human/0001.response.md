Alright, I have this problem to solve. Monocarp wants to throw a party and invite some of his friends, but there are some conditions. He has n friends, and each friend has a best friend, which is specified by p_i. The p_i are all distinct and no one is their own best friend. So, for each friend i, their best friend is p_i, and p_i is different from i.

Now, for a friend to come to the party, both the friend and their best friend need to receive an invitation. But, the best friend doesn't necessarily have to come, just receive an invitation. So, if I invite friend i and their best friend p_i, then friend i will come. But, if I only invite friend i without inviting p_i, friend i won't come.

My goal is to send the minimum number of invitations so that at least two friends come to the party.

First, I need to understand the relationship between the friends and their best friends. Since p_i are distinct and p_i != i, this means that the best friend relationships form a permutation of the friends. In other words, it's like a mapping where each friend is mapped to another friend, and this mapping is one-to-one and onto because the p_i are distinct.

So, in graph theory terms, this permutation can be represented as a directed graph where each node has out-degree 1 and in-degree 1, forming cycles. Each cycle is a group of friends where each one's best friend is another in the cycle, and the cycle is closed.

For example, if n=3 and p=[2,3,1], then friend 1's best friend is 2, friend 2's best friend is 3, and friend 3's best friend is 1. This forms a cycle of length 3.

Similarly, if n=4 and p=[2,3,4,1], it's a cycle of length 4.

If n=5 and p=[3,1,2,5,4], then friend 1's best friend is 3, friend 3's best friend is 2, friend 2's best friend is 1, forming a cycle of length 3 (1->3->2->1), and friends 4 and 5 form a cycle of length 2 (4->5->4).

So, in general, the best friend relationships form disjoint cycles.

Now, to minimize the number of invitations while ensuring that at least two friends come to the party, I need to find a way to invite the minimal number of friends such that at least two friends have both themselves and their best friends invited.

Let's consider different cycle lengths and see what's the minimal number of invitations needed.

Case 1: All friends are in a single cycle.

For example, n=3, p=[2,3,1]. The only cycle is 1->2->3->1.

To have at least two friends come, I need to invite pairs (i, p_i) such that both are invited.

If I invite two friends, say 1 and 2, then friend 1 has p_1=2 invited, so friend 1 will come. Friend 2 has p_2=3 not invited, so friend 2 won't come. So, only friend 1 comes.

If I invite 1 and 3, then friend 1 has p_1=3 invited, so friend 1 comes. Friend 3 has p_3=2 not invited, so friend 3 doesn't come. Again, only one comes.

If I invite 2 and 3, then friend 2 has p_2=3 invited, so friend 2 comes. Friend 3 has p_3=2 invited, so friend 3 comes. So, two friends come.

So, in this case, inviting two friends is sufficient to have two come.

Wait, but according to the program, for n=3, it prints 2, which matches.

Another example: n=4, p=[2,3,4,1]. Cycle is 1->2->3->4->1.

If I invite 1 and 2, then friend 1 has p_1=2 invited, so friend 1 comes. Friend 2 has p_2=3 invited, so friend 2 comes. So, two come.

If I invite 1 and 3, then friend 1 has p_1=2 not invited, so friend 1 doesn't come. Friend 3 has p_3=4 invited, so friend 3 comes. Only one comes.

Wait, but earlier I thought that inviting 1 and 2 would make both come, but according to the program, for n=4, it prints 3.

Wait, maybe I need to check again.

Wait, in the example given in the problem, for n=4, p=[2,3,4,1], the output is 3.

But according to my earlier reasoning, inviting 1 and 2 should make both come.

Wait, maybe I'm missing something.

Let me check again.

If I invite 1 and 2, then:

- Friend 1 has p_1=2 invited, so friend 1 comes.

- Friend 2 has p_2=3 invited, so friend 2 comes.

- Friend 3 has p_3=4 invited, but friend 3 wasn't invited, so friend 3 doesn't come.

- Friend 4 has p_4=1 invited, but friend 4 wasn't invited, so friend 4 doesn't come.

So, only friends 1 and 2 come.

But according to the program, for this case, it prints 3.

Wait, maybe inviting three is better.

If I invite 1, 2, and 3:

- Friend 1 has p_1=2 invited, so friend 1 comes.

- Friend 2 has p_2=3 invited, so friend 2 comes.

- Friend 3 has p_3=4 invited, so friend 3 comes.

- Friend 4 has p_4=1 invited, but friend 4 wasn't invited, so friend 4 doesn't come.

So, friends 1, 2, and 3 come.

But the problem says that for this case, the minimal number is 3, but in my earlier example, inviting 1 and 2 makes two come, which is at least two.

But according to the problem's example output, it's 3.

Wait, perhaps I misunderstood the problem.

Let me read the problem again.

"The i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation."

Wait, so friend i comes if both i and p_i are invited.

So, in the n=4, p=[2,3,4,1] case:

- If I invite 1 and 2:

- Friend 1 comes if both 1 and 2 are invited. Yes, so friend 1 comes.

- Friend 2 comes if both 2 and 3 are invited. 2 is invited, but 3 is not, so friend 2 does not come.

- Friend 3 comes if both 3 and 4 are invited. 3 is not invited, so friend 3 does not come.

- Friend 4 comes if both 4 and 1 are invited. 4 is not invited, so friend 4 does not come.

So, only friend 1 comes.

Wait, that's different from what I thought earlier.

Wait, I misread the condition.

It says: "the i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation."

So, for friend i to come, both i and p_i must be invited.

So, in the n=4, p=[2,3,4,1] case:

- If I invite 1 and 2:

- Friend 1 comes if both 1 and p_1=2 are invited. Yes, so friend 1 comes.

- Friend 2 comes if both 2 and p_2=3 are invited. 2 is invited, but 3 is not, so friend 2 does not come.

- Friend 3 is not invited, so doesn't come.

- Friend 4 is not invited, so doesn't come.

So, only friend 1 comes.

If I invite 1, 2, and 3:

- Friend 1 comes if both 1 and 2 are invited. Yes.

- Friend 2 comes if both 2 and 3 are invited. Yes.

- Friend 3 comes if both 3 and 4 are invited. 3 and 4 are invited, so friend 3 comes.

- Friend 4 is invited, but p_4=1 is invited, so friend 4 would come, but wait, the problem says "each invitation is sent to exactly one of the friends." So, if I invite 1, 2, and 3, friend 4 is not invited, even though p_4=1 is invited.

Wait, no, the problem says "each invitation is sent to exactly one of the friends." But in the explanation, it's "the i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation."

So, for friend i to come, both i and p_i must be invited.

In the earlier example, if I invite 1, 2, and 3:

- Friend 1 comes (1 and 2 invited).

- Friend 2 comes (2 and 3 invited).

- Friend 3 comes (3 and 4 invited, but 4 is not invited, so friend 3 does not come).

Wait, p_3=4, and 4 is not invited, so friend 3 does not come.

Wait, but I thought I invited 1, 2, and 3.

Wait, but p_3=4, and 4 is not invited, so friend 3 does not come.

Wait, but in the earlier reasoning, friend 3 comes if both 3 and 4 are invited. But 4 is not invited, so friend 3 does not come.

So, only friends 1 and 2 come.

But according to the problem's example output for n=4, p=[2,3,4,1], the output is 3.

Wait, perhaps inviting 1, 2, and 4:

- Friend 1 comes (1 and 2 invited).

- Friend 2 comes (2 and 3 invited, but 3 is not invited, so friend 2 does not come).

- Friend 3 is not invited, so doesn't come.

- Friend 4 comes (4 and 1 invited).

So, friends 1 and 4 come.

That's two friends.

So, with three invitations (1,2,4), two friends come.

But according to the problem's example, the output is 3.

Wait, but in this case, it seems that inviting 1,2,4 makes two friends come, which should be sufficient.

But in the problem's example, it says:

"Monocarp can send invitations to friends [1,2,4], then friends [1 and 4] will come to the party."

So, with three invitations, two friends come.

But the problem says it's impossible to send invitations to fewer than 3 friends in such a way that at least 2 come.

Wait, but maybe there is no way to have two friends come with only two invitations.

Let me try inviting 1 and 3:

- Friend 1 comes (1 and p_1=2; but 2 is not invited, so friend 1 does not come).

- Friend 3 comes (3 and p_3=4; 4 is not invited, so friend 3 does not come).

- Friend 2 is not invited, so doesn't come.

- Friend 4 is not invited, so doesn't come.

So, no one comes.

Inviting 1 and 4:

- Friend 1 comes (1 and p_1=2; 2 is not invited, so friend 1 does not come).

- Friend 4 comes (4 and p_4=1; both invited, so friend 4 comes).

- Friend 2 is not invited, so doesn't come.

- Friend 3 is not invited, so doesn't come.

So, only friend 4 comes.

Inviting 2 and 3:

- Friend 2 comes (2 and p_2=3; both invited, so friend 2 comes).

- Friend 3 comes (3 and p_3=4; 4 is not invited, so friend 3 does not come).

- Friend 1 is not invited, so doesn't come.

- Friend 4 is not invited, so doesn't come.

So, only friend 2 comes.

Inviting 2 and 4:

- Friend 2 comes (2 and p_2=3; 3 is not invited, so friend 2 does not come).

- Friend 4 comes (4 and p_4=1; 1 is not invited, so friend 4 does not come).

- Friend 1 is not invited, so doesn't come.

- Friend 3 is not invited, so doesn't come.

So, no one comes.

Inviting 3 and 4:

- Friend 3 comes (3 and p_3=4; both invited, so friend 3 comes).

- Friend 4 comes (4 and p_4=1; 1 is not invited, so friend 4 does not come).

- Friend 1 is not invited, so doesn't come.

- Friend 2 is not invited, so doesn't come.

So, only friend 3 comes.

So, with two invitations, only one friend comes.

With three invitations, two friends come.

Hence, the minimal number is 3.

So, in this case, the program outputs 3, which matches the example.

Another example: n=5, p=[3,1,2,5,4]

Let's see the cycles:

1 -> 3 -> 2 ->1

4 ->5 ->4

So, two cycles: one of length 3 and one of length 2.

If I invite 4 and 5:

- Friend 4 comes (4 and p_4=5 invited).

- Friend 5 comes (5 and p_5=4 invited).

- Friend 1 is not invited, so doesn't come.

- Friend 2 is not invited, so doesn't come.

- Friend 3 is not invited, so doesn't come.

So, friends 4 and 5 come.

So, with two invitations, two friends come.

Hence, the minimal number is 2.

Another example: n=2, p=[2,1]

If I invite both 1 and 2:

- Friend 1 comes (1 and p_1=2 invited).

- Friend 2 comes (2 and p_2=1 invited).

So, both come.

Hence, minimal number is 2.

So, in this case, the program outputs 2, which matches.

Now, looking at the program:

def func_1():

n = int(input())

v = [0] * (n + 1)

v = [0] + list(map(int, input().split()))

if n == 2:

print(2)

else:

for i in range(1, n + 1):

if v[v[v[i]]] == i:

print(2)

return

print(3)

So, for n=2, it directly prints 2.

For n >=3, it checks if v[v[v[i]]] == i for any i.

If yes, prints 2, else prints 3.

In the first example, n=5, p=[3,1,2,5,4]

v = [0,3,1,2,5,4]

v[v[v[1]]] = v[v[3]] = v[2] =1, which matches i=1.

So, prints 2.

In the second example, n=4, p=[2,3,4,1]

v = [0,2,3,4,1]

v[v[v[1]]] = v[v[2]] = v[3]=4 !=1

v[v[v[2]]] = v[v[3]]=v[4]=1 !=2

v[v[v[3]]] = v[v[4]]=v[1]=2 !=3

v[v[v[4]]] = v[v[1]]=v[2]=3 !=4

So, no i satisfies v[v[v[i]]]==i, so prints 3.

In the third example, n=2, p=[2,1], prints 2 directly.

So, it seems to work for these cases.

But is this logic general?

Let me think about other cases.

Consider n=3, p=[2,3,1], which forms a cycle of length 3.

v = [0,2,3,1]

v[v[v[1]]] = v[v[2]] = v[3]=1 ==i=1

So, prints 2, which is correct.

Another n=3, p=[2,1,3]

v = [0,2,1,3]

v[v[v[1]]] = v[v[2]]=v[1]=2 !=1

v[v[v[2]]] = v[v[1]]=v[2]=1 !=2

v[v[v[3]]] = v[v[3]]=v[3]=3 ==i=3

So, prints 2.

But in this case, p=[2,1,3], which is cycle 1->2->1 and 3->3.

Wait, p_i !=i, so p_i are distinct and p_i !=i.

Wait, in p=[2,1,3], p_3=3, which violates p_i !=i.

But the problem says p_i !=i and all p_i are distinct.

Wait, p=[2,1,3] has p_3=3, which is invalid.

So, in reality, p_i !=i and all p_i are distinct, so no fixed points.

So, in n=3, possible p are cycles of length 3 or two cycles: one of length 1 and one of length 2, but since p_i !=i, only cycles of length >=2.

Hence, in n=3, only cycles of length 3 are allowed.

Hence, v[v[v[i]]]==i for all i.

Hence, prints 2, which is correct.

Now, consider n=5, p=[2,3,4,5,1]

v = [0,2,3,4,5,1]

v[v[v[1]]] = v[v[3]]=v[4]=5 !=1

v[v[v[2]]] = v[v[4]]=v[5]=1 !=2

v[v[v[3]]] = v[v[5]]=v[1]=2 !=3

v[v[v[4]]] = v[v[1]]=v[2]=3 !=4

v[v[v[5]]] = v[v[1]]=v[2]=3 !=5

So, no i satisfies v[v[v[i]]]==i, so prints 3.

But in this case, the cycle is 1->2->3->4->5->1, a single cycle of length 5.

If I invite 1 and 2:

- Friend 1 comes (1 and 2 invited).

- Friend 2 comes (2 and 3 invited).

- Friend 3 comes (3 and 4 invited).

- Friend 4 comes (4 and 5 invited).

- Friend 5 comes (5 and 1 invited).

So, all friends come.

But minimal number is 2.

Wait, but according to the program, it would print 3 because v[v[v[i]]] !=i for any i.

So, in this case, the program would be incorrect.

Wait, but according to the problem's example, for n=5, p=[3,1,2,5,4], it prints 2 because there is a cycle of length 3 and a cycle of length 2.

In that case, v[v[v[i]]]==i for some i.

But in this new example, n=5, p=[2,3,4,5,1], v[v[v[i]]] !=i for all i.

But in reality, inviting 1 and 2 makes all friends come, which is better than needed.

But according to the program, it would print 3, which is higher than necessary.

So, perhaps the program is not always correct.

Wait, but in the problem's example, for n=5, p=[3,1,2,5,4], which has cycles of length 3 and 2, it prints 2, which is correct.

In n=4, p=[2,3,4,1], which is a single cycle of length 4, it prints 3, which matches the example.

In n=2, p=[2,1], it prints 2, which is correct.

So, perhaps for cycles of length 3 or cycles of length 2, it's 2, and for cycles of length 4 or higher, it's 3.

Wait, but in n=5, p=[2,3,4,5,1], which is a single cycle of length 5, the program prints 3, which is more than necessary, as inviting 1 and 2 makes all come.

So, perhaps the program is not always correct.

Wait, but maybe the program assumes that in cycles of length 3, it's 2, and in other cycles, it's 3.

But in reality, for cycles of length greater than 3, sometimes 2 invitations are enough.

Hence, perhaps the program is incorrect.

But in the problem's example, for n=4, p=[2,3,4,1], it's 3, which matches the example's output.

Similarly, for n=5, p=[3,1,2,5,4], it's 2, which matches.

But in my earlier example of n=5, p=[2,3,4,5,1], which is a single cycle of length 5, the program prints 3, but in reality, inviting 1 and 2 makes two friends come.

So, perhaps in such cases, 2 invitations are enough, but the program prints 3.

Hence, the program might be incorrect.

Wait, but perhaps I'm misunderstanding the condition.

Let me think again.

In n=5, p=[2,3,4,5,1], if I invite 1 and 2:

- Friend 1 comes (1 and 2 invited).

- Friend 2 comes (2 and 3 invited).

- Friend 3 comes (3 and 4 invited).

- Friend 4 comes (4 and 5 invited).

- Friend 5 comes (5 and 1 invited).

So, all come.

But the problem requires at least 2 friends to come, so inviting 1 and 2 is sufficient.

Hence, minimal number is 2.

But the program would print 3 for this case.

Hence, the program is incorrect.

So, Correctness: **False**

**Final Answer**

\[ \boxed{\text{False}} \]