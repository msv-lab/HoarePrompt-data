Alright, I've got this problem to solve. Let's see what it's asking for. So, Jay created a problem of difficulty x and wants to make it the second problem for a Codeforces round. But Yash is worried that it might make the contest unbalanced, so he decides to break it down into n sub-problems. Each sub-problem should have a positive integer difficulty, and the sum of all these sub-problems should equal x.

Now, the coordinator, Aleksey, defines the balance of a problem set as the greatest common divisor (GCD) of the difficulties of all the sub-problems. Yash wants to maximize this balance by choosing the difficulties optimally.

Okay, so I need to find the maximum GCD possible when x is divided into n sub-problems with positive integer difficulties summing up to x.

First, I need to understand what GCD is. GCD of a set of numbers is the largest number that divides all of them without leaving a remainder. So, if all sub-problems have difficulties that are multiples of some number d, then d is a candidate for the GCD.

My goal is to maximize d, given that the sum of n such difficulties is x.

Let me think about the constraints:

- x can be up to 10^8, which is 100,000,000.

- n can be up to x, which means n can be up to 100,000,000.

- t, the number of test cases, is up to 10^3, which is 1,000.

So, I need an efficient solution, preferably O(t * sqrt(x)) or better, because otherwise, it might be too slow.

Let me consider what the maximum possible GCD can be.

If I choose all sub-problems to have the same difficulty, say d, then the sum would be n * d. For this sum to equal x, d must be x / n. But x / n might not be an integer. So, this only works if x is divisible by n.

Wait, but the sub-problems can have different difficulties, as long as their GCD is maximized.

So, maybe choosing d such that d is a divisor of x and n * d <= x, but I need to maximize d.

Wait, no. Because the sum of n numbers each at least d is at least n * d, but it could be more.

Wait, actually, to maximize the GCD, I need to find the largest d such that d divides x and n <= x / d.

Because if d is the GCD, then each sub-problem's difficulty is a multiple of d, so the minimum sum is n * d. For the sum to be exactly x, n * d <= x, and x must be divisible by d.

Wait, no. x must be divisible by d, and n <= x / d.

But I need to maximize d, given that d divides x and n <= x / d.

So, the largest d that divides x and x / d >= n.

Wait, that makes sense.

So, to find the maximum d such that d divides x and x / d >= n.

In other words, d <= x / n.

But d must be a divisor of x, and as large as possible, but not exceeding x / n.

Wait, but x / n might not be an integer, so d should be the largest divisor of x that is less than or equal to floor(x / n).

So, the approach is:

1. Compute floor(x / n).

2. Find the largest divisor of x that is less than or equal to floor(x / n).

But, I need to make sure that there are at least n divisors or something like that.

Wait, no. I need to select n sub-problems with difficulties that are multiples of d, and their sum is x.

Wait, but to maximize d, I need to find the largest d that divides x and n <= x / d.

Because if d divides x, then x = k * d for some integer k.

And to have n sub-problems, each at least d, their sum would be at least n * d.

For the sum to be exactly x, n * d <= x, and x must be divisible by d.

So, d must be a divisor of x, and n <= x / d.

To maximize d, I need the largest d that divides x and n <= x / d.

Which is equivalent to d <= floor(x / n).

So, I need the largest divisor of x that is less than or equal to floor(x / n).

So, the algorithm is:

- For each test case, given x and n:

- Compute floor(x / n).

- Find all divisors of x.

- Select the largest divisor that is <= floor(x / n).

- If no such divisor exists, the answer is 1 (since d=1 always divides x).

Wait, but d=1 might not always be possible. Wait, actually, d=1 always divides x, and n <= x / 1 = x, which is always true since n <= x.

So, the answer is always at least 1.

Hence, the algorithm is correct.

Now, to implement this efficiently, I need to find all divisors of x up to floor(x / n).

But finding all divisors of x can be done in O(sqrt(x)) time, which is acceptable since x can be up to 10^8 and t is up to 10^3, so total time should be around 10^3 * 10^4 = 10^7 operations, which is acceptable.

Let me think about how to implement this.

I can write a function to find all divisors of x by iterating from 1 to sqrt(x), and for each i that divides x, add both i and x/i to the list of divisors.

Then, find the largest divisor that is <= floor(x / n).

But since I only need the largest one, I don't have to store all divisors, just keep track of the maximum d that is <= floor(x / n).

So, I can iterate from 1 to sqrt(x), check if i divides x.

If i divides x, then:

- If i <= floor(x / n), then candidate d = i.

- If x / i <= floor(x / n), then candidate d = x / i.

Wait, no.

If i <= floor(x / n), then d can be i.

Similarly, if x / i <= floor(x / n), then d can be x / i.

But I need to choose the maximum d among these.

So, I can keep a variable 'ans' initialized to 0, and update it with the maximum d that satisfies d <= floor(x / n).

Wait, but d must also divide x.

But since I'm only considering divisors of x, that's already satisfied.

Hence, the algorithm is correct.

Let me look at the example in the problem.

First test case: x=10, n=3.

floor(10 / 3) = 3.

Find divisors of 10: 1, 2, 5, 10.

Among these, 1 <= 3, 2 <= 3, 5 > 3, 10 > 3.

So, possible d are 1 and 2.

Maximum is 2.

Which matches the sample output.

Second test case: x=5, n=5.

floor(5 / 5) = 1.

Divisors of 5: 1, 5.

Among these, 1 <=1, 5>1.

So, d=1.

Which matches the sample output.

Third test case: x=420, n=69.

floor(420 / 69) = 6.

Divisors of 420: 1, 2, 3, 4, 5, 6, 7, 10, 12, 14, 15, 20, 21, 28, 30, 35, 42, 60, 70, 84, 105, 140, 210, 420.

Among these, the largest d <=6 is d=6.

Which matches the sample output.

Seems correct.

Now, in the given code:

from math import *

tc = int(input())

for _ in range(tc):

func_1()

def func_1():

(x, n) = list(map(int, input().split()))

ans = 0

for i in range(1, isqrt(x) + 1):

if x % i == 0:

if n <= x // i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x // i)

print(ans)

Let's analyze this.

It reads the number of test cases, then for each test case, calls func_1().

func_1 reads x and n, initializes ans to 0.

Then loops from i=1 to sqrt(x) inclusive.

For each i, if i divides x (x % i == 0), then:

- If n <= x // i, set ans = max(ans, i)

- If n <= i, set ans = max(ans, x // i)

Then prints ans.

Wait, this seems similar to what I thought, but let's verify.

In my approach, I need to find the largest d that divides x and d <= floor(x / n).

In the code:

- Loop i from 1 to sqrt(x)

- If i divides x:

- If n <= x // i, ans = max(ans, i)

- If n <= i, ans = max(ans, x // i)

Wait, let's see.

For each i where i divides x:

- i is a divisor, and x // i is also a divisor.

- If n <= x // i, then ans = max(ans, i)

- If n <= i, then ans = max(ans, x // i)

Wait, is this correctly capturing d <= floor(x / n)?

Let me think.

Given that d <= floor(x / n), and d divides x.

In the code, for each i where i divides x:

- If n <= x // i, ans = max(ans, i)

- If n <= i, ans = max(ans, x // i)

Wait, perhaps it's better to think in terms of d.

If d is a divisor, then d = i or d = x // i.

So, for d = i:

- Need d <= floor(x / n), which is i <= floor(x / n)

- So, if i <= floor(x / n), then ans = max(ans, i)

But in the code, it's if n <= x // i, which is equivalent to n <= x / i.

Wait, n <= x // i is the same as n <= floor(x / i)

But I need d <= floor(x / n), where d is i or x // i.

Wait, perhaps there's confusion.

Let me clarify.

I need d <= floor(x / n), where d divides x.

In the code:

- For each i where i divides x:

- If n <= x // i, set ans = max(ans, i)

- If n <= i, set ans = max(ans, x // i)

Wait, perhaps the conditions are flipped.

Wait, let's see for d = i:

- d <= floor(x / n) => i <= floor(x / n)

- So, if i <= floor(x / n), then ans = max(ans, i)

Similarly, for d = x // i:

- d <= floor(x / n) => x // i <= floor(x / n)

- So, if x // i <= floor(x / n), then ans = max(ans, x // i)

But in the code, it's:

- if n <= x // i, ans = max(ans, i)

- if n <= i, ans = max(ans, x // i)

Wait, that seems incorrect.

Wait, perhaps the condition is misstated.

Wait, let's see.

If d = i, then d <= floor(x / n) => i <= floor(x / n)

Similarly, for d = x // i, d <= floor(x / n) => x // i <= floor(x / n)

But in the code, it's checking if n <= x // i, which is equivalent to n <= floor(x / i)

Wait, that doesn't seem directly related.

Wait, maybe I need to think differently.

Suppose d is a divisor of x.

Then, d <= floor(x / n) is required.

Now, in the code, for each i where i divides x:

- If n <= x // i, ans = max(ans, i)

- If n <= i, ans = max(ans, x // i)

Wait, perhaps the logic is to ensure that n <= x / d.

Wait, in terms of d.

Wait, if d = i, then n <= x / d => n <= x / i.

But we need d <= floor(x / n), not n <= x / d.

Wait, I'm getting confused.

Let me think again.

Given that d divides x, and d <= floor(x / n), we need to maximize d.

So, among all divisors d of x, find the maximum d such that d <= floor(x / n).

Hence, for each divisor d, if d <= floor(x / n), keep it as a candidate.

Then, take the maximum among such d.

So, in the code, it seems to be trying to do this.

But the conditions in the code don't directly reflect this.

Wait, perhaps it's a mistake in the code.

Wait, perhaps the code is trying to find d <= floor(x / n), but implementing it incorrectly.

Wait, in the code:

for i in range(1, isqrt(x) + 1):

if x % i == 0:

if n <= x // i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x // i)

Wait, let's see with the first sample input: x=10, n=3.

floor(x / n) = 3.

Divisors:

i=1, x//i=10

check if 3 <= 10//1=10, set ans=max(0,1)=1

check if 3<=1, which is false, so skip.

i=2, x//2=5

check if 3 <= 5, set ans=max(1,2)=2

check if 3<=2, which is false, so skip.

i=3, x//3=3

check if 3 <= 3, set ans=max(2,3)=3

But 3 is not a divisor of 10, so this is incorrect.

Wait, but in the sample, the answer should be 2, not 3.

Wait, but 3 is not a divisor of 10, so it shouldn't consider d=3.

But in the code, it seems to consider d=3, even though 3 doesn't divide 10.

Wait, perhaps there is a mistake in the code.

Wait, no, in the loop, it only considers i if x % i == 0, which means i is a divisor.

But for i=3, x=10, 10 % 3 !=0, so it doesn't consider i=3.

Wait, sqrt(10) is approximately 3.16, so i goes up to 3.

But 10 % 3 !=0, so it doesn't consider i=3.

Hence, in this case, it only considers i=1 and i=2.

For i=1:

n=3 <= x//1=10, set ans=max(0,1)=1

n=3 <=i=1? No.

For i=2:

n=3 <=x//2=5, set ans=max(1,2)=2

n=3 <=i=2? No.

Hence, ans=2, which is correct.

Another sample: x=5, n=5.

floor(5/5)=1.

Divisors:1 and 5.

i=1:

n=5 <=x//1=5, set ans=max(0,1)=1

n=5 <=i=1? Yes, set ans=max(1,5//1)=5

But 5 >1, which is floor(x/n)=1, so it shouldn't consider d=5.

But in this case, it sets ans=max(1,5)=5, which is incorrect, as d=5 is not <=1.

Wait, but according to the code, it would set ans=max(1,5)=5, but the correct answer is 1.

So, in this case, the code would output 5, which is wrong, but the correct answer is 1.

Hence, the code is incorrect.

Wait, but in the sample output, it's 1 for x=5, n=5.

Wait, let's see.

In the code, for i=1:

n=5 <=x//1=5, set ans=max(0,1)=1

n=5 <=i=1? Yes, set ans=max(1,5)=5

But d=5 is not <= floor(x/n)=1, so it should not consider d=5.

Hence, the code is wrong here.

Wait, perhaps I need to adjust the conditions.

Wait, in the code, it's:

if n <= x // i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x // i)

In the second condition, it should probably be checking if x // i <= floor(x / n), but it's checking if n <= i.

Wait, that doesn't make sense.

Wait, perhaps it should be:

if i <= floor(x / n):

ans = max(ans, i)

if x // i <= floor(x / n):

ans = max(ans, x // i)

But in the code, it's using n <= x // i and n <= i.

Wait, perhaps it's a mistake in the conditions.

Let me correct it.

It should be:

for i in range(1, isqrt(x) + 1):

if x % i == 0:

if i <= floor(x / n):

ans = max(ans, i)

if x // i <= floor(x / n):

ans = max(ans, x // i)

But in the code, it's using n <= x // i and n <= i, which is incorrect.

Hence, the given code is wrong.

So, the correctness is False.

Wait, but in the first sample, it gave the correct answer, but in the second sample, it would give wrong answer.

Wait, in the second sample, x=5, n=5.

floor(x / n)=1

Divisors:1 and 5.

i=1:

n=5 <=x//1=5, set ans=max(0,1)=1

n=5 <=i=1? Yes, set ans=max(1,5)=5

But d=5 is greater than floor(x / n)=1, which is invalid.

Hence, the code is incorrect.

So, the answer is Correctness: False

## Final Solution
To solve this problem, we need to maximize the balance (GCD) of a set of sub-problems derived from a given problem of difficulty `x`, divided into `n` sub-problems.

### Approach

1. **Understanding the Problem**:
    - We need to split `x` into `n` sub-problems with positive integer difficulties summing up to `x`.
    - The balance is defined as the GCD of these sub-problems' difficulties.
    - Our goal is to maximize this GCD.

2. **Key Insight**:
    - If the GCD of the sub-problems is `d`, then each sub-problem's difficulty is a multiple of `d`.
    - Hence, the sum `x` must be divisible by `d`.
    - Additionally, since there are `n` sub-problems, each at least `d`, the sum should be at least `n * d`, i.e., `x >= n * d`.

3. **Optimal Strategy**:
    - Find the largest divisor `d` of `x` such that `d <= floor(x / n)`.

4. **Algorithm**:
    - For each test case, compute `floor(x / n)`.
    - Iterate through all possible divisors of `x` up to `sqrt(x)`.
    - Track the largest divisor of `x` that is less than or equal to `floor(x / n)`.

### Solution Code

```python
import math

def max_balance():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    t = int(data[0])
    index = 1
    for _ in range(t):
        x = int(data[index])
        n = int(data[index + 1])
        index += 2
        ans = 0
        sqrt_x = int(math.isqrt(x))
        for i in range(1, sqrt_x + 1):
            if x % i == 0:
                if i <= x // n:
                    ans = max(ans, i)
                counterpart = x // i
                if counterpart <= x // n:
                    ans = max(ans, counterpart)
        print(ans)

if __name__ == "__main__":
    max_balance()
```

### Explanation

1. **Reading Input**:
    - Read all input data at once for efficiency.
    - Parse the number of test cases `t`.
    - For each test case, read `x` and `n`.

2. **Finding Divisors**:
    - Compute the floor division `x // n`.
    - Iterate from `1` to `sqrt(x)` to find divisors of `x`.
    - For each divisor `i`, check if it is less than or equal to `x // n`. If so, consider it for the maximum balance.
    - Also, consider the counterpart divisor `x // i` if it is less than or equal to `x // n`.

3. **Output the Result**:
    - For each test case, print the largest divisor that satisfies the conditions.

This approach ensures that we efficiently find the maximum possible GCD for the given constraints, iterating through potential divisors in O(sqrt(x)) time per test case.