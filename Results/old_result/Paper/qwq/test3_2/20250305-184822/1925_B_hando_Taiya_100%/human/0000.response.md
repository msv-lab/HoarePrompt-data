Alright, I have this problem to solve. Let's understand what's being asked here.

We have a problem with difficulty level x, and we need to break it down into n sub-problems. Each sub-problem should have a positive integer difficulty, and the sum of all these sub-problems should equal x. Now, the balance of this problem set is defined as the GCD (Greatest Common Divisor) of the difficulties of all the sub-problems.

Our goal is to maximize this balance by choosing the difficulties optimally.

First, let's make sure I understand the terms:

- Positive integer difficulty: each sub-problem has a difficulty of at least 1.

- Sum equals x: the total difficulty of all sub-problems adds up to x.

- GCD of all sub-problems: the greatest number that divides all of the sub-problems' difficulties.

- Maximize this GCD.

So, given x and n, we need to find the highest possible GCD for a set of n positive integers that sum up to x.

Let's consider an example to grasp this better.

Take the first example from the problem:

Input:

3

10 3

5 5

420 69

Output:

2

1

6

For the first test case, x=10 and n=3.

Possible ways to split 10 into 3 positive integers:

- 1, 1, 8 → GCD is 1

- 2, 2, 6 → GCD is 2

- 2, 3, 5 → GCD is 1

- 3, 3, 4 → GCD is 1

- 4, 4, 2 → GCD is 2

- etc.

The maximum GCD here is 2.

Similarly, for x=5 and n=5:

Only possible way is 1,1,1,1,1 → GCD is 1.

For x=420 and n=69:

We need to find a way to split 420 into 69 positive integers summing to 420, with the maximum possible GCD.

Now, how to generalize this?

I need to find the largest possible G that divides x and for which x/G >= n.

Wait, why?

Because if the GCD is G, then each sub-problem's difficulty is a multiple of G. So, if there are n sub-problems, the minimal sum is n*G (if all sub-problems have difficulty G). So, x must be at least n*G.

Therefore, G <= x/n.

So, the largest possible G is the largest integer G such that G divides x and G <= x/n.

But, G has to be an integer, and it has to be a divisor of x.

So, essentially, among all divisors of x, find the largest one that is <= x/n.

Wait, but in the first example, x=10, n=3, x/n ≈ 3.333, so G <=3.

Divisors of 10: 1,2,5,10.

Among these, 1,2 <=3.

So, the largest is 2, which matches the example.

In the second example, x=5, n=5, x/n=1.

Divisors of 5:1,5.

Only 1 <=1.

So, G=1.

Third example, x=420, n=69, x/n ≈ 6.087.

Divisors of 420: 1,2,3,4,5,6,7,10,12,14,15,20,21,28,30,35,42,60,70,84,105,140,210,420.

Among these, the largest <=6 is 6.

So, G=6.

Seems correct.

So, the approach is:

- Find all divisors of x.

- Find the largest divisor that is <= x/n.

But, in the code provided, it's doing something similar.

Let's look at the code:

from math import *

tc = int(input())

for _ in range(tc):

func_1()

def func_1():

(x, n) = list(map(int, input().split()))

ans = 0

for i in range(1, isqrt(x) + 1):

if x % i == 0:

if n <= x // i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x // i)

print(ans)

So, it's iterating from 1 to sqrt(x), checking if i is a divisor of x.

If i is a divisor, it checks if n <= x // i, and if so, updates ans to max of ans and i.

Also, checks if n <= i, and if so, updates ans to max of ans and x // i.

Wait, this seems a bit confusing.

Let me think.

In the first part, if i is a divisor, and n <= x // i, then ans = max(ans, i)

Similarly, if n <= i, then ans = max(ans, x // i)

Wait, in the first condition, n <= x // i.

But x // i is x divided by i, which is the sum divided by the divisor.

Wait, no, x // i is the multiple.

Wait, perhaps I need to think differently.

Let me consider that for each divisor i of x, we can set all sub-problems to be multiples of i.

But I need to ensure that the sum is x and there are n sub-problems.

Wait, perhaps it's better to think in terms of scaling.

If G is the GCD, then each sub-problem is G * k, where k is an integer >=1.

So, the sum would be G * (k1 + k2 + ... + kn) = x.

So, G divides x.

Also, since each ki >=1, the minimal sum is G * n.

So, G * n <= x.

Thus, G <= x / n.

So, G has to be a divisor of x, and G <= x / n.

Hence, the largest such G is the answer.

So, in the code, it's iterating through all possible divisors i of x, and checking if i <= x // n.

Wait, but in the code, it's checking if n <= x // i.

Wait, that's equivalent to checking if n <= x / i.

But x / i is x divided by i, which is the multiple.

Wait, perhaps it's better to think in terms of multiples.

Wait, I'm getting confused.

Let me try to rephrase.

Given x and n, find the largest G such that:

- G divides x

- n <= x / G

Wait, the second condition is because the sum of n sub-problems, each at least G, should be <= x.

Wait, no, it should be exactly x.

But since each sub-problem is >= G, the minimal sum is n*G <= x.

So, G <= x / n.

But, in the code, it's checking if n <= x // i.

Wait, perhaps there's a mistake in interpretation.

Wait, let's consider:

For a given divisor i of x, if n <= x // i, then it's possible to have G = i.

Because x // i is the number of sub-problems that can have difficulty i, summing up to x.

Wait, no.

Wait, if G = i, then the sum would be G * (k1 + k2 + ... + kn) = x.

Where each ki >=1.

So, minimal sum is G * n.

So, G <= x / n.

So, to have G = i, we need i <= x / n.

So, in the code, it's checking if n <= x // i.

Wait, that's equivalent to i <= x // n.

But x // n might be less than x / n if x is not divisible by n.

Wait, for example, x=10, n=3, x//n=3, but x/n≈3.333.

So, i <=3.

So, in the code, it's checking if n <= x // i.

Wait, for i=2, x//i=5, and n=3, so 3 <=5 is true, so ans=max(ans,2)

Also, for i=5, x//i=2, n=3, 3<=2 is false, so skip.

Then, ans=2.

Seems correct.

Wait, but in the code, it's also checking if n <=i, then ans=max(ans,x//i)

Wait, for i=1, x//i=10, n=3 <=10, so ans=max(ans,10)=10

Then, for i=2, x//i=5, n=3<=5, so ans=max(10,2)=10

Then, for i=5, x//i=2, n=3<=2? false

Then, ans=10, but it should be 2.

Wait, but in the example, it's 2.

Wait, perhaps there's a mistake in the code.

Wait, no, in the first iteration, i=1, ans=10

Then i=2, ans=10

Then i=5, skipped

Then, prints ans=10, but in the example, it's 2.

Wait, perhaps I'm misunderstanding.

Wait, perhaps it's taking the minimal ans.

Wait, no, it's taking max.

Wait, but in the first example, it should output 2, but according to this, it's 10.

Wait, perhaps I need to re-examine.

Wait, perhaps the logic is different.

Wait, perhaps it's finding the minimal G.

Wait, no, it's supposed to find the maximal G.

Wait, perhaps I need to think differently.

Let me look at the code again.

def func_1():

(x, n) = list(map(int, input().split()))

ans = 0

for i in range(1, isqrt(x) + 1):

if x % i == 0:

if n <= x // i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x // i)

print(ans)

So, for x=10, n=3

i=1, x%1==0, n=3 <= x//1=10, so ans=max(0,1)=1

Then, n=3 <=1? false, so no change

i=2, x%2==0, n=3 <= x//2=5, so ans=max(1,2)=2

Then, n=3 <=2? false

i=3, x%3!=0, skip

i=4, x%4!=0, skip

i=5, x%5==0, n=3 <= x//5=2? false

Then, ans=2, which is correct.

Wait, in my earlier calculation, I thought ans was 10, but no.

Wait, for i=1, ans=max(0,1)=1

i=2, ans=max(1,2)=2

i=5, skipped

So, ans=2, which matches the example.

Wait, perhaps I miscalculated earlier.

Yes, I see now.

So, in the first iteration, i=1, ans=1

i=2, ans=2

i=5, skipped

So, ans=2.

Got it.

So, the logic seems correct.

Let me verify with the second example.

x=5, n=5

i=1, x%1==0, n=5 <= x//1=5, ans=max(0,1)=1

i=2, x%2!=0, skip

i=3, x%3!=0, skip

i=4, x%4!=0, skip

i=5, x%5==0, n=5 <=5, ans=max(1,5)=5

Wait, but in the example, it's 1.

Wait, but according to this, it's 5.

Wait, but in the explanation, it's 1.

Wait, perhaps there's a mistake in the code.

Wait, in the code, it's:

if n <= x // i:

ans = max(ans, i)

if n <= i:

ans = max(ans, x // i)

So, for i=5, x//i=1, n=5 <=i=5, so ans=max(2, x//5=1)=5

Wait, but in the problem, it's 1.

Wait, but in the problem, it's 1.

Wait, perhaps I need to think differently.

Wait, in the problem, when x=5 and n=5, the only way is to have all sub-problems of difficulty 1, hence GCD=1.

But according to the code, it's choosing 5.

Wait, but 5 is a divisor of x=5, and n=5 <= x//5=1, which is false.

Wait, in the code, for i=5, x//i=1, n=5 <=i=5, so ans=max(ans, x//i)=1

Wait, no, it's ans=max(ans, x//i)=1

Wait, but in my earlier calculation, I thought ans=max(2,1)=1

Wait, perhaps I need to re-examine.

Wait, perhaps there's a mistake in my earlier calculation.

Let's see.

For x=5, n=5

i=1, x%1==0, n=5 <= x//1=5, ans=max(0,1)=1

i=2, x%2!=0, skip

i=3, x%3!=0, skip

i=4, x%4!=0, skip

i=5, x%5==0, n=5 <=5, so ans=max(1,1)=1 (since x//5=1)

Hence, ans=1, which matches the example.

Wait, perhaps I misremembered.

Yes, x//5=1, so ans=max(ans, x//i)=1

So, it's correct.

Another example, x=420, n=69

We saw earlier that the answer should be 6.

Let's see what the code does.

i from 1 to sqrt(420)≈20.49, so i up to 20

i=1, x%1==0, n=69 <= x//1=420, ans=max(0,1)=1

i=2, x%2==0, n=69 <= x//2=210, ans=max(1,2)=2

i=3, x%3==0, n=69 <= x//3=140, ans=max(2,3)=3

i=4, x%4==0, n=69 <= x//4=105, ans=max(3,4)=4

i=5, x%5==0, n=69 <= x//5=84, ans=max(4,5)=5

i=6, x%6==0, n=69 <= x//6=70, ans=max(5,6)=6

i=7, x%7==0, n=69 <= x//7≈5. something, which is false

So, x//7=60, wait, 420//7=60, n=69 <=60? false

So, no update

Similarly, i=14, x//14=30, n=69 >30, skip

i=20, x//20=21, n=69 >21, skip

So, ans=6, which matches the example.

Hence, the code seems correct.

But earlier I thought there was a mistake, but actually, it's correct.

So, the logic is:

- Iterate through all possible divisors i from 1 to sqrt(x)

- For each i that divides x:

- If n <= x // i, then update ans = max(ans, i)

- If n <= i, then update ans = max(ans, x // i)

- Finally, print ans

This correctly finds the largest divisor G of x such that G <= x / n.

Hence, the program is correct.

**Final Answer**

\[ \boxed{2} \]