Alright, I've got this problem to solve. Let's see what it's about. So, there are two players, Alice and Bob, playing a game on an array of integers. Alice starts with an empty array c. In each turn, Alice picks an element from the original array a, appends it to c, and deletes it from a. Bob, on his turn, picks an element from a, and just deletes it from a. The game ends when a is empty, and the score is the MEX of c, which is the smallest non-negative integer not present in c. Alice wants to maximize the score, while Bob wants to minimize it. I need to find out what the final score will be if both play optimally.

First, I need to understand what MEX is. From the description, MEX of an array is the smallest non-negative integer not present in it. For example, MEX of [2,2,1] is 0, since 0 is the smallest non-negative integer not in the array. MEX of [3,1,0,1] is 2, because 0 and 1 are present, but 2 is not. And MEX of [0,3,1,2] is 4, as 0,1,2,3 are present, but 4 is not.

So, the goal is to find the MEX of array c, where c is built by Alice picking elements and adding them to c, and Bob trying to interfere by deleting elements without adding to c.

Let me think about how Alice and Bob will play.

Alice wants to maximize the MEX, which means she wants c to contain as many small non-negative integers as possible, in order to make the MEX as large as possible.

Bob, on the other hand, wants to minimize the MEX, so he wants to prevent Alice from including certain elements in c, specifically smaller integers, to make the MEX smaller.

Since Alice starts first and they alternate turns, Alice gets to choose elements to add to c, and Bob gets to delete elements.

Wait, no, actually, Bob also picks elements from a and deletes them, but he doesn't add them to c. So, in each turn:

- Alice picks an element from a, appends it to c, and deletes it from a.

- Bob picks an element from a, deletes it from a.

They alternate, with Alice starting first.

The game ends when a is empty, and the score is MEX of c.

I need to find the final score when both play optimally.

I need to consider that both players are playing optimally, meaning Alice will try to maximize the MEX, and Bob will try to minimize it.

I need to find a way to simulate their moves or find a pattern that allows me to determine the MEX without simulating every move.

Let me consider some examples to understand the pattern.

Take the first example from the problem:

n = 4

a = [0,0,1,1]

One possible game is:

1. Alice picks 1, a becomes [0,0,1], c = [1]

2. Bob picks 0, a becomes [0,1], c = [1]

3. Alice picks 0, a becomes [1], c = [1,0]

4. Bob picks 1, a becomes empty, c = [1,0]

MEX of c is 2, since 0 and 1 are present.

But is this the optimal play? Let's see.

Another possible game:

1. Alice picks 0, a becomes [0,1,1], c = [0]

2. Bob picks 1, a becomes [0,1], c = [0]

3. Alice picks 1, a becomes [0], c = [0,1]

4. Bob picks 0, a becomes empty, c = [0,1]

MEX is still 2.

Is there a way for Bob to make MEX smaller? Let's try.

1. Alice picks 0, a becomes [0,1,1], c = [0]

2. Bob picks 0, a becomes [1,1], c = [0]

3. Alice picks 1, a becomes [1], c = [0,1]

4. Bob picks 1, a becomes empty, c = [0,1]

Again, MEX is 2.

Another try:

1. Alice picks 1, a becomes [0,0,1], c = [1]

2. Bob picks 1, a becomes [0,0], c = [1]

3. Alice picks 0, a becomes [0], c = [1,0]

4. Bob picks 0, a becomes empty, c = [1,0]

MEX is 2.

Seems like no matter how they play, MEX is 2.

Another test case:

n = 4

a = [0,1,2,3]

Possible game:

1. Alice picks 0, a becomes [1,2,3], c = [0]

2. Bob picks 1, a becomes [2,3], c = [0]

3. Alice picks 2, a becomes [3], c = [0,2]

4. Bob picks 3, a becomes empty, c = [0,2]

MEX is 1, since 0 is present, 1 is missing.

Another possible game:

1. Alice picks 1, a becomes [0,2,3], c = [1]

2. Bob picks 0, a becomes [2,3], c = [1]

3. Alice picks 2, a becomes [3], c = [1,2]

4. Bob picks 3, a becomes empty, c = [1,2]

MEX is 0, since 0 is missing.

Wait, but in this case, Alice could have picked 0 in her first turn to include 0 in c, but she picked 1. If she picks 0 first:

1. Alice picks 0, a becomes [1,2,3], c = [0]

2. Bob picks 1, a becomes [2,3], c = [0]

3. Alice picks 2, a becomes [3], c = [0,2]

4. Bob picks 3, a becomes empty, c = [0,2]

MEX is 1.

But if Alice picks 0 first, MEX is 1, and if she picks 1 first, MEX is 0.

So, Alice would prefer to pick 0 first to make MEX 1, since 1 is larger than 0.

So, in this case, if Alice plays optimally, MEX is 1.

But Bob can force MEX to be 0 by allowing Alice to pick 1 first, but Alice, being optimal, would choose to pick 0 first to maximize MEX.

So, in this case, the output is 1.

Another test case:

n = 2

a = [1,1]

Possible game:

1. Alice picks 1, a becomes [1], c = [1]

2. Bob picks 1, a becomes empty, c = [1]

MEX is 0, since 0 is missing.

Another possible game:

Same steps, no other choices.

So, MEX is 0.

Now, I need to find a general way to compute this for any given n and a.

Let me think about the problem differently.

The MEX of c depends on which elements Alice includes in c.

Bob can influence this by deleting elements that Alice might want to include in c.

Since Alice and Bob are playing optimally, Alice will try to include the smallest possible integers in c, and Bob will try to prevent that.

Wait, but Alice wants to maximize the MEX, which means she wants c to contain as many small integers as possible.

Wait, actually, to maximize MEX, she wants c to contain as many small integers as possible, so that the smallest missing integer is as large as possible.

Wait, actually, to maximize MEX, she wants to have c containing as many small integers as possible, so that the smallest missing integer is larger.

Wait, actually, to maximize MEX, she wants to have c containing as many small integers as possible, so that the smallest missing integer is larger.

Wait, no, to maximize MEX, she wants c to contain as many small integers as possible, so that the smallest integer not in c is larger.

But in the example, when n=4 and a=[0,0,1,1], MEX is 2.

When n=4 and a=[0,1,2,3], MEX is 1.

When n=2 and a=[1,1], MEX is 0.

I need to find a way to compute this efficiently, considering that there are up to 2e5 test cases with n up to 2e5, and the total sum of n over all test cases is up to 2e5.

So, I need an efficient algorithm, probably O(n) per test case.

Let me think about the frequency of each number in a.

Let me count the frequency of each number from 0 to n.

Since a_i can be from 0 to n-1, and n can be up to 2e5, I can create a count array of size n+1.

Wait, a_i can be up to n-1, so in the count array of size n+1, indices 0 to n-1 correspond to a_i values, and index n can be used for any numbers >=n, but since a_i < n, index n in count array will always be 0.

Wait, no, a_i can be from 0 to n-1, so count array of size n would suffice, but to make it easier, I'll use size n+1.

So, I'll have cnt = [0] * (n+1)

Then, for each a_i in a, cnt[a_i] +=1

Now, Alice and Bob will take turns picking elements from a.

Alice picks an element and appends it to c, then deletes it from a.

Bob picks an element and deletes it from a.

They alternate, with Alice starting first.

The game ends when a is empty, and the score is MEX of c.

I need to find the MEX of c when both play optimally.

I need to find the smallest integer j >=0 such that in c, j is not present.

Given that Alice wants to maximize j, and Bob wants to minimize j.

So, Alice will try to include as many small integers in c as possible, and Bob will try to prevent that.

I need to find out, for each j from 0 to n, whether j will be in c or not, considering both play optimally.

Wait, perhaps I can think in terms of the number of times each j appears in a, and how many times Alice can include them in c.

Wait, but Bob can delete elements, so he can prevent Alice from including certain elements.

Wait, perhaps I can think in terms of the number of times each j appears in a, and how many times Alice can include them in c before Bob deletes them.

Wait, perhaps I can think in terms of the number of times each j appears, and the number of times Alice can pick them before Bob deletes them.

Wait, let's think about the total number of turns.

Total number of turns is n, since they delete one element each turn.

Alice plays first, so she has (n+1)//2 turns, and Bob has n//2 turns.

Wait, no, total number of turns is n, with Alice playing first.

So, Alice plays on turns 1,3,5,... and Bob plays on turns 2,4,6,...

So, number of turns for Alice is ceil(n/2), and for Bob is floor(n/2).

Wait, in Python, // is floor division.

So, Alice's turns: (n + 1) // 2

Bob's turns: n // 2

Yes.

So, Alice can pick up to (n + 1) // 2 elements to include in c, and Bob can delete up to n // 2 elements.

But Bob can delete any element, including those that Alice wants to include.

Wait, but Bob deletes elements from a, but he doesn't add them to c.

So, Bob can delete elements that Alice might want to include in c, thereby preventing Alice from including them in c.

Wait, but Alice picks first, and appends to c, then deletes it from a.

Then Bob picks and deletes from a.

Then Alice picks and appends to c and deletes from a, and so on.

So, in each of Alice's turns, she picks an element from a, appends it to c, and deletes it from a.

In each of Bob's turns, he picks an element from a, deletes it from a.

So, in total, Alice includes (n + 1) // 2 elements in c, because she has ceil(n/2) turns.

But Bob can delete elements that Alice might have wanted to include in c.

Wait, but Bob deletes elements from a, which are the elements available for Alice to include in c.

So, Bob can delete elements that Alice wants, but Alice gets to choose first.

Wait, but in each turn, Alice picks first, then Bob picks, and so on.

So, in the first turn, Alice picks an element to include in c and deletes it from a.

Then, Bob picks an element to delete from a.

Then, Alice picks another element to include in c and deletes it from a.

And so on, until a is empty.

So, in total, Alice includes (n + 1) // 2 elements in c.

But Bob can influence which elements are available for Alice to pick.

So, Bob can delete elements that Alice might want to include in c.

Therefore, Bob can try to delete elements that Alice would prefer to include in c, forcing Alice to include other elements.

Alice, being optimal, will try to include the smallest possible integers to maximize the MEX.

Wait, no, to maximize the MEX, Alice wants c to contain as many small integers as possible, so that the smallest missing integer is as large as possible.

Wait, actually, to maximize the MEX, Alice wants c to contain all integers from 0 to some j-1, and j is not in c.

So, the MEX would be j.

So, Alice wants to include as many small integers in c as possible.

Bob wants to minimize the MEX, so he wants to prevent Alice from including certain small integers in c.

So, Bob will try to delete elements that Alice wants to include in c.

Given that, I need to find out which small integers Alice can include in c despite Bob's attempts to delete them.

Let me consider the frequency of each integer in a.

For each integer j from 0 to n, cnt[j] is the number of times j appears in a.

Alice wants to include as many j's as possible in c, especially the smaller j's.

Bob wants to prevent that by deleting j's from a.

So, for each j, the number of times Alice can include j in c is cnt[j], minus the number of times Bob deletes j.

But Bob has n//2 deletions.

I need to find out, for each j, how many times Alice can include j in c, considering Bob's deletions.

Wait, perhaps I can think in terms of the number of times Alice can include j in c before Bob deletes all instances of j.

Wait, but Bob can delete any elements, not necessarily j's.

So, Bob can choose to delete elements that Alice wants, but he doesn't have to.

Wait, to minimize the MEX, Bob would want to prevent Alice from including smaller j's in c.

So, Bob would prioritize deleting elements that Alice wants to include, i.e., smaller j's.

Therefore, for each j, the number of times Alice can include j in c is cnt[j], minus the number of times Bob deletes j.

But Bob has n//2 deletions to use.

So, perhaps I can think of it as Alice trying to include j's, and Bob trying to block them.

Wait, maybe I can think in terms of the number of times Alice can include j in c, given that Bob can delete up to n//2 elements.

Wait, perhaps it's better to think in terms of the number of times Alice can include j in c, considering the total number of turns and deletions.

This seems complicated.

Let me look for a different approach.

I recall that in some games where one player wants to maximize and the other to minimize, the outcome can be determined by some kind of balance between their abilities.

Perhaps I can think in terms of the number of times each j appears, and how many times Alice can include them in c before Bob deletes them.

Wait, perhaps I can consider that for each j, Alice can include cnt[j] elements in c, but Bob can delete up to n//2 elements.

But Bob can choose to delete elements that Alice wants to include.

Wait, maybe I need to think in terms of the minimal number of j's that Alice can include in c, considering Bob's deletions.

Wait, perhaps it's better to iterate through j from 0 to n, and for each j, check if Alice can include at least one j in c, despite Bob's deletions.

If Alice can include j, then MEX is the first j where she cannot include any more.

Wait, perhaps.

Let me try to formalize this.

Let me sort j in increasing order, and for each j, check if Alice can include at least one j in c, given that Bob is trying to prevent it.

If Alice can include j, then MEX is the smallest j where she cannot include any j in c.

Wait, but how do I determine if Alice can include at least one j in c?

Given that Bob has n//2 deletions, and Alice has (n+1)//2 inclusions.

Wait, perhaps I need to look at the cumulative counts.

Wait, maybe I can think in terms of the number of times j appears, and how many deletions Bob can make.

Wait, perhaps I need to consider the frequency of j and the number of deletions Bob can make to prevent Alice from including j.

For a given j, if cnt[j] > 0, Alice can include it in c, unless Bob deletes all instances of j.

But Bob has n//2 deletions to use.

So, for each j, Alice can include cnt[j] - floor(cnt[j] / (1 + (Bob's deletions)))

Wait, that seems too vague.

Let me think differently.

Suppose I try to maximize the MEX.

To maximize the MEX, Alice needs to include as many small j's as possible in c.

Bob wants to minimize the MEX, so he wants to prevent Alice from including some small j's.

So, for each j, starting from 0, I need to check if Alice can include at least one j in c, even if Bob tries to delete it.

If Alice can include j, then MEX is at least j+1.

If Alice cannot include j, then MEX is j.

So, I need to find the smallest j where Alice cannot include any j in c.

To determine if Alice can include at least one j in c, considering Bob's deletions.

Let me consider that Alice has (n + 1) // 2 inclusions, and Bob has n // 2 deletions.

Total operations: n, with Alice doing ceil(n/2) operations, Bob doing floor(n/2).

Each Alice's operation: pick an element to include in c and delete it.

Each Bob's operation: delete an element.

So, total deletions: Alice's ceil(n/2) deletions + Bob's floor(n/2) deletions = n deletions, which matches the total number of elements.

Wait, but in Alice's turn, she picks an element, appends it to c, and then deletes it.

So, effectively, she is including one element in c and deleting it from a.

Bob just deletes one element from a.

So, total deletions: Alice's ceil(n/2) deletions + Bob's floor(n/2) deletions = n deletions.

So, all elements are deleted by the end.

But c contains only the elements that Alice included, which is ceil(n/2) elements.

Now, I need to see which elements are included in c.

Bob can choose which elements to delete, but Alice chooses which elements to include in c.

So, Bob can delete elements that Alice wants to include in c.

Wait, but Alice picks first, and chooses which element to include in c.

Then Bob deletes another element.

Then Alice picks another element to include in c, and so on.

So, Bob cannot directly prevent Alice from including a specific element, because Alice chooses first.

But Bob can choose to delete elements that Alice might want to include later.

Wait, perhaps I need to think in terms of the availability of elements.

Let me consider that Alice wants to include small j's in c to maximize MEX.

Bob wants to minimize MEX by preventing Alice from including small j's.

So, Alice will try to include as many small j's as possible in her turns.

Bob will try to delete small j's to prevent Alice from including them.

But since Alice picks first, she can include a small j, and then Bob can delete another small j.

Then Alice includes another small j, and Bob deletes another small j, and so on.

So, effectively, for each small j, Alice can include ceil(cnt[j] / 2) of them in c, because for every two instances, Alice can include one, and Bob can delete one.

Wait, perhaps.

Let me consider that for each j, if cnt[j] is the frequency, then the number of times Alice can include j in c is ceil(cnt[j] / 2), because for every two, Alice can include one, and Bob can delete one.

Wait, but this might not be accurate, because the turns are alternating, and Alice picks first.

Wait, perhaps it's floor((cnt[j] + 1) / 2).

Wait, let's think about it.

Suppose cnt[j] = 1:

- Alice picks it, includes in c, deletes it.

- Bob cannot delete it anymore.

So, Alice includes 1 instance.

So, floor((1 + 1)/2) = 1.

Which matches.

Suppose cnt[j] = 2:

- Alice picks one, includes in c, deletes it.

- Bob picks the other, deletes it.

So, Alice includes 1 instance.

floor((2 + 1)/2) = 1.

Matches.

cnt[j] = 3:

- Alice picks one, includes in c, deletes it.

- Bob picks one, deletes it.

- Alice picks one, includes in c, deletes it.

So, Alice includes 2 instances.

floor((3 + 1)/2) = 2.

Matches.

cnt[j] = 4:

- Alice picks one, includes in c, deletes it.

- Bob picks one, deletes it.

- Alice picks one, includes in c, deletes it.

- Bob picks one, deletes it.

So, Alice includes 2 instances.

floor((4 + 1)/2) = 2.

Matches.

Seems like floor((cnt[j] + 1)/2) is the number of times Alice can include j in c.

Wait, but in the first test case:

n = 4

a = [0,0,1,1]

So, cnt[0] = 2, cnt[1] = 2.

Alice can include floor((2+1)/2) = 1 for 0, and 1 for 1.

So, c will have one 0 and one 1.

MEX is 2.

Which matches the sample output.

Another test case:

n = 4

a = [0,1,2,3]

cnt[0] = 1, cnt[1] =1, cnt[2]=1, cnt[3]=1.

Alice can include floor((1+1)/2)=1 for each.

So, c = [0,1,2], MEX is 3.

But in the sample output, it's 1.

Wait, that doesn't match.

Wait, perhaps I'm missing something.

Wait, in the second test case:

n=4

a=[0,1,2,3]

According to the sample output, the MEX is 1.

But according to my calculation, Alice can include one of each, so c=[0,1,2], MEX is 3.

But sample output is 1, which suggests that in this case, c=[0,2], MEX=1.

Wait, perhaps I need to consider that Alice can include only up to (n+1)//2 elements.

In this case, n=4, Alice can include 2 elements.

So, she can include 0 and 2, hence MEX is 1.

Wait, but according to my earlier logic, floor((cnt[j]+1)/2) for each j.

But in this case, for j=0,1,2,3, floor((1+1)/2)=1.

So, Alice can include one of each, but she can only choose two elements in total.

So, she has to choose which two to include.

To maximize MEX, she should choose the smallest possible j's.

So, she would choose to include 0 and 1, or 0 and 2, etc.

If she includes 0 and 1, c=[0,1], MEX=2.

If she includes 0 and 2, c=[0,2], MEX=1.

If she includes 1 and 2, c=[1,2], MEX=0.

So, to maximize MEX, she would choose to include 0 and 1, getting MEX=2.

But the sample output is 1.

Wait, perhaps I'm misunderstanding something.

Looking back at the sample explanation, in the second test case, it's explained that MEX is 1.

But according to my earlier logic, it should be 2.

Wait, perhaps there's a mistake in my reasoning.

Wait, perhaps Bob can influence which elements Alice includes.

Wait, in the second test case:

n=4

a=[0,1,2,3]

Possible game:

1. Alice picks 0, a becomes [1,2,3], c=[0]

2. Bob picks 1, a becomes [2,3], c=[0]

3. Alice picks 2, a becomes [3], c=[0,2]

4. Bob picks 3, a becomes empty, c=[0,2]

MEX is 1.

Another possible game:

1. Alice picks 1, a becomes [0,2,3], c=[1]

2. Bob picks 0, a becomes [2,3], c=[1]

3. Alice picks 2, a becomes [3], c=[1,2]

4. Bob picks 3, a becomes empty, c=[1,2]

MEX is 0.

Another possible game:

1. Alice picks 2, a becomes [0,1,3], c=[2]

2. Bob picks 0, a becomes [1,3], c=[2]

3. Alice picks 1, a becomes [3], c=[2,1]

4. Bob picks 3, a becomes empty, c=[2,1]

MEX is 0.

Another possible game:

1. Alice picks 3, a becomes [0,1,2], c=[3]

2. Bob picks 0, a becomes [1,2], c=[3]

3. Alice picks 1, a becomes [2], c=[3,1]

4. Bob picks 2, a becomes empty, c=[3,1]

MEX is 0.

So, in this case, the best Alice can do is to include 0 and 2, getting MEX=1.

Wait, but in my earlier calculation, I thought she could include 0 and 1, getting MEX=2.

But according to the possible game, if she includes 0 and 1, MEX is 2.

But in the sample output, it's 1.

Wait, perhaps there's a mistake in the sample explanation.

Wait, in the sample explanation, for the second test case, it says:

"Another possible game:

1. Alice picks 1, a becomes [0,2,3], c=[1]

2. Bob picks 0, a becomes [2,3], c=[1]

3. Alice picks 2, a becomes [3], c=[1,2]

4. Bob picks 3, a becomes empty, c=[1,2]

At the end, c=[1,2], which has a MEX of 0."

But according to the sample output, it's 1.

Wait, perhaps I'm missing something.

Wait, in the sample explanation, it says:

"In the first test case, a possible game with a score of 2 is as follows:

...

Note that this is an example game and does not necessarily represent the optimal strategy for both players.

In the second test case, a possible game with a score of 1 is:

...

Hence, the answer is 1."

So, in the second test case, the answer is 1.

But according to my earlier logic, if Alice includes 0 and 1, MEX is 2.

But the sample says 1.

Wait, perhaps I need to consider that Alice can only include certain elements based on Bob's deletions.

Wait, perhaps Bob can force the MEX to be 1 by deleting certain elements.

Let me think about it.

Suppose Alice picks 0 first:

1. Alice picks 0, a becomes [1,2,3], c=[0]

2. Bob picks 1, a becomes [2,3], c=[0]

3. Alice picks 2, a becomes [3], c=[0,2]

4. Bob picks 3, a becomes empty, c=[0,2]

MEX is 1.

Alternatively, Alice picks 0 and 3:

1. Alice picks 0, a becomes [1,2,3], c=[0]

2. Bob picks 1, a becomes [2,3], c=[0]

3. Alice picks 2, a becomes [3], c=[0,2]

4. Bob picks 3, a becomes empty, c=[0,2]

MEX is 1.

Alternatively, Alice picks 0 and 2:

Same as above.

Alternatively, Alice picks 0 and 1:

1. Alice picks 0, a becomes [1,2,3], c=[0]

2. Bob picks 2, a becomes [1,3], c=[0]

3. Alice picks 1, a becomes [3], c=[0,1]

4. Bob picks 3, a becomes empty, c=[0,1]

MEX is 2.

But Bob could choose to pick 1 instead of 2:

1. Alice picks 0, a becomes [1,2,3], c=[0]

2. Bob picks 1, a becomes [2,3], c=[0]

3. Alice picks 2, a becomes [3], c=[0,2]

4. Bob picks 3, a becomes empty, c=[0,2]

MEX is 1.

So, Bob can force MEX to be 1 by picking 1 in his first turn.

Hence, the optimal play results in MEX=1.

Similarly, in the third test case:

n=2

a=[1,1]

Possible game:

1. Alice picks 1, a becomes [1], c=[1]

2. Bob picks 1, a becomes empty, c=[1]

MEX is 0.

No other possibilities.

Hence, MEX is 0.

So, in general, for each j, Alice can include floor((cnt[j] + 1)/2) instances in c.

But in the second test case, for j=0,1,2,3, cnt[j]=1, so floor((1+1)/2)=1 for each.

But Alice can only include two elements in c, so she includes two of them, say 0 and 1, getting MEX=2.

But according to the sample, it's 1.

Wait, perhaps I need to consider that Bob can delete elements in a way that forces Alice to include certain elements.

Wait, perhaps the general formula is not just floor((cnt[j]+1)/2), but needs to consider the total number of elements Alice can include.

Wait, perhaps I need to think in terms of the total number of elements Alice can include, which is (n+1)//2, and see which j's she can include at least one of, considering Bob's deletions.

Wait, perhaps I should iterate through j from 0 to n, and for each j, check if cnt[j] - floor(total_deletions) >=1.

But it's getting complicated.

Let me look for a different approach.

I recall that in some games, the outcome can be determined by the parity of the number of elements.

Wait, perhaps I can think in terms of the number of times each j appears, and how many times Alice can include them, considering Bob's deletions.

Wait, perhaps I can consider that for each j, Alice can include ceil(cnt[j] / 2) instances in c.

Wait, in the first test case, cnt[0]=2, cnt[1]=2.

ceil(2/2)=1 for each, so Alice can include one 0 and one 1, getting MEX=2.

In the second test case, cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1.

ceil(1/2)=1 for each, but Alice can only include two elements, so she includes two of them, say 0 and 1, getting MEX=2.

But according to the sample, it's 1.

Wait, perhaps I need to consider that Bob can delete elements in a way that reduces the number of elements Alice can include.

Wait, perhaps the formula is floor((cnt[j] + 1)/2), but the total number of elements Alice can include is limited by (n+1)//2.

So, in the second test case, floor((1+1)/2)=1 for each j.

Alice can include up to two elements.

So, she includes 0 and 1, getting MEX=2.

But sample output is 1.

Wait, perhaps I need to consider that Bob can delete elements in a way that forces Alice to include higher j's.

Wait, perhaps the correct approach is:

- For each j from 0 to n:

- Calculate the number of times Alice can include j in c, which is ceil((cnt[j] - deletions_by_Bob)/1)

- But deletions_by_Bob can be up to n//2.

Wait, perhaps it's better to iterate j from 0 to n, and try to see if Alice can include at least one j in c.

To include at least one j, Alice needs to pick it before Bob deletes all cnt[j] instances.

Given that Bob has n//2 deletions, and Alice has (n+1)//2 picks.

So, for each j, if cnt[j] > floor(n/2), then Alice can include at least one j, because even if Bob deletes floor(n/2) instances, there are still some left.

Wait, but in the second test case, cnt[j]=1 for each j, and floor(n/2)=2, so cnt[j]=1 <=2, so Alice cannot include j.

Wait, but that doesn't match.

Wait, perhaps it's cnt[j] > floor(n/2), but in this case, cnt[j]=1 <=2, so Alice cannot include j.

But in the first test case, cnt[0]=2, cnt[1]=2, floor(n/2)=2.

So, cnt[j]=2 <=2, so Alice cannot include j.

But in the first test case, MEX is 2.

Wait, that doesn't make sense.

Wait, perhaps it's cnt[j] > floor(n/2), then Alice can include at least one j.

In the first test case, cnt[0]=2 <= floor(n/2)=2, so cannot include.

cnt[1]=2 <=2, cannot include.

So, c would be empty, MEX=0.

But in the sample, MEX is 2.

This is confusing.

Wait, perhaps I need to consider that Alice can include floor((cnt[j]+1)/2) instances of j.

So, in the first test case, floor((2+1)/2)=1 for j=0 and j=1.

So, Alice can include one 0 and one 1, c=[0,1], MEX=2.

In the second test case, floor((1+1)/2)=1 for j=0,1,2,3.

But Alice can only include two elements, so she includes two of them, say 0 and 1, c=[0,1], MEX=2.

But sample output is 1.

Wait, perhaps I need to find the smallest j where floor((cnt[j]+1)/2) ==0.

Wait, but in the first test case, floor((2+1)/2)=1 for j=0,1.

In the second test case, floor((1+1)/2)=1 for j=0,1,2,3.

So, Alice can include at least one of each, but in reality, she can only include up to (n+1)//2 elements.

So, in the second test case, n=4, Alice can include 2 elements.

So, she includes two of the j's, say 0 and 1, c=[0,1], MEX=2.

But sample output is 1.

Wait, perhaps the MEX is the smallest j where the number of times Alice can include j in c is less than what's needed.

Wait, perhaps I need to iterate j from 0 to n, and for each j, subtract floor((cnt[j]+1)/2) from the available inclusion slots Alice has.

So, starting with available slots = (n+1)//2.

For each j in increasing order:

if available_slots >= floor((cnt[j]+1)/2):

available_slots -= floor((cnt[j]+1)/2)

else:

answer is j

Wait, perhaps.

Let's try with the first test case:

n=4

cnt[0]=2, floor((2+1)/2)=1

cnt[1]=2, floor((3+1)/2)=1

available_slots = 2

For j=0: available_slots -=1, available_slots=1

For j=1: available_slots -=1, available_slots=0

So, all j's from 0 to 1 can be included.

Hence, MEX is 2.

Matches the sample.

Second test case:

n=4

cnt[0]=1, floor((1+1)/2)=1

cnt[1]=1, floor((1+1)/2)=1

cnt[2]=1, floor((1+1)/2)=1

cnt[3]=1, floor((1+1)/2)=1

available_slots =2

For j=0: available_slots -=1, available_slots=1

For j=1: available_slots -=1, available_slots=0

For j=2: available_slots <1, so MEX is 2.

But sample output is 1.

Wait, doesn't match.

Wait, perhaps I need to adjust the formula.

Wait, perhaps it's ceil(cnt[j]/2).

So, for cnt[j]=1, ceil(1/2)=1

For cnt[j]=2, ceil(2/2)=1

Wait, same as before.

Wait, perhaps the available_slots should be reduced by ceil(cnt[j]/2).

Wait, let's try.

In the first test case:

cnt[0]=2, ceil(2/2)=1

cnt[1]=2, ceil(2/2)=1

available_slots=2

For j=0: available_slots -=1, available_slots=1

For j=1: available_slots -=1, available_slots=0

So, MEX is 2.

In the second test case:

cnt[0]=1, ceil(1/2)=1

cnt[1]=1, ceil(1/2)=1

cnt[2]=1, ceil(1/2)=1

cnt[3]=1, ceil(1/2)=1

available_slots=2

For j=0: available_slots -=1, available_slots=1

For j=1: available_slots -=1, available_slots=0

For j=2: available_slots <1, so MEX is 2.

But sample output is 1.

Hmm.

Wait, perhaps I need to consider that Alice can only include floor((cnt[j]+1)/2) instances of j.

So, for j=0, floor((1+1)/2)=1

Similarly for j=1,2,3.

So, available_slots=2

Include j=0: include 1, available_slots -=1, available_slots=1

Include j=1: include 1, available_slots -=1, available_slots=0

Now, for j=2: cannot include, since available_slots=0, so MEX is 2.

But sample output is 1.

Wait, perhaps I need to consider that for j=0, Alice can include floor((cnt[0]+1)/2)=1, but if she includes it, it reduces the available_slots by 1.

But in the second test case, she can include j=0 and j=1, getting c=[0,1], MEX=2.

But sample output is 1.

Wait, perhaps the formula is different.

Wait, perhaps the number of times Alice can include j is cnt[j] - floor(cnt[j]/2).

Wait, no, that's just ceil(cnt[j]/2).

Wait, perhaps I need to look for a different approach.

Let me think about it differently.

Suppose I sort the j's in increasing order.

Then, for each j, I check if Alice can include at least one j in c, considering Bob's deletions.

If she can, then MEX is higher, else, current j is the MEX.

To include at least one j, Alice needs to pick it before Bob deletes all cnt[j] instances.

Given that Bob has n//2 deletions, and Alice has (n+1)//2 picks.

So, for a given j, if cnt[j] > floor(n/2), then Alice can include at least one j.

Because even if Bob deletes floor(n/2) elements, there are still some j's left for Alice to pick.

But in the second test case, cnt[j]=1, and floor(n/2)=2, so cnt[j]=1 <=2, so Alice cannot include j.

Hence, MEX is 0.

But sample output is 1.

Wait, doesn't match.

Wait, perhaps it's cnt[j] > floor((n-1)/2).

In the second test case, floor((4-1)/2)=1.

cnt[j]=1 >1 is false, so cannot include j.

Hence, MEX is 0.

But sample output is 1.

Still not matching.

Wait, perhaps it's cnt[j] > floor(n/2) - floor(cnt[j]/2).

Wait, need to think differently.

Wait, perhaps the condition is cnt[j] - floor(n/2) >0, then Alice can include at least one j.

In the second test case, cnt[j]=1 -2 =-1 <0, so cannot include.

Hence, MEX is 0.

But sample is 1.

Wait, perhaps it's cnt[j] - floor((n -1)/2) >0.

In second test case, cnt[j]=1 -1=0 <=0, so cannot include.

Hence, MEX is 0.

But sample is 1.

Still not matching.

Wait, perhaps I need to consider that Alice can include floor(cnt[j]/2 + 0.5), which is ceil(cnt[j]/2).

Wait, same as before.

Wait, perhaps I need to look for a different strategy.

Let me consider that Alice wants to include as many small j's as possible, and Bob wants to prevent that.

So, perhaps I can sort the j's in increasing order, and try to include as many as possible, up to the number of available_slots.

available_slots = (n+1)//2

Then, iterate through j from 0 to n, and for each j, include floor((cnt[j]+1)/2), and subtract from available_slots.

When available_slots < floor((cnt[j]+1)/2), then MEX is j.

In the first test case:

j=0: floor(3/2)=1, available_slots=2-1=1

j=1: floor(3/2)=1, available_slots=1-1=0

j=2: floor(1/2)=1, available_slots=0-1=-1 -> MEX=2

Matches sample.

Wait, but in the second test case:

j=0: floor(1/2)=1, available_slots=2-1=1

j=1: floor(1/2)=1, available_slots=1-1=0

j=2: floor(1/2)=1, available_slots=0-1=-1 -> MEX=2

But sample output is 1.

Hmm.

Wait, perhaps I need to adjust the formula for floor((cnt[j]+1)/2).

Wait, in the second test case, cnt[j]=1 for all j, so floor((1+1)/2)=1 for each j.

available_slots=2

Include j=0: 1, available_slots=1

Include j=1:1, available_slots=0

Cannot include j=2: MEX=2

But sample output is 1.

Wait, perhaps I need to consider that MEX is the smallest j where the number of times Alice can include j in c is less than what's needed.

Wait, perhaps I need to iterate j from 0 to n, and keep track of the required includes.

Wait, maybe I need to accumulate the floor((cnt[j]+1)/2) and see when it exceeds available_slots.

In the first