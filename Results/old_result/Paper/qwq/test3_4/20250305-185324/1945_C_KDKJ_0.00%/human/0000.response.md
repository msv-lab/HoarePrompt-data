Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n houses in a village, and the villagers want to build a big road that divides the village into left and right sides. Each resident has a preference: they want to live either on the left side (0) or the right side (1). The road can be built between any two houses, or before the first house or after the last house.

The goal is to place the road such that at least half of the residents on each side are satisfied with their side. In other words, for the left side, at least ceil(x/2) residents want to be on the left, and for the right side, at least ceil((n-x)/2) residents want to be on the right, where x is the number of houses on the left.

Additionally, among all possible positions that satisfy this condition, we need to choose the one that is as close as possible to the middle of the village, minimizing the absolute difference between the number of houses to the left and right of the road.

First, I need to understand the problem fully. Let's consider an example to grasp what's being asked.

Take the first example from the input:

n = 3

a = 101

Possible road positions:

- Before the first house: entire village is on the right. So, right side has 3 houses, with preferences [1,0,1]. Among them, two want to be on the right (positions 1 and 3). So, ceil(3/2) = 2, and we have exactly 2 satisfied, which meets the condition.

- Between house 1 and 2: left side has [1], right side has [0,1]. Left side: 1 house, preference 1 wants right, so 0 satisfied, which is less than ceil(1/2)=1. Right side: 2 houses, 1 wants right, 1 wants left, so 1 satisfied, which is ceil(2/2)=1. The left side doesn't meet the condition.

- Between house 2 and 3: left side [1,0], right side [1]. Left side: 2 houses, preferences [1,0], 1 wants left (position 2), which is ceil(2/2)=1. Right side: 1 house, preference 1 wants right, which is ceil(1/2)=1. Both sides meet the condition.

- After the last house: entire village is on the left. Left side: [1,0,1], among them, 1 wants left, which is less than ceil(3/2)=2. So, doesn't meet the condition.

So, positions 0 and 2 meet the condition, but position 2 is closer to the middle (n=3, middle is at house 2), so the answer is 2.

Another example:

n=6

a=010111

Possible positions:

- 0: all on right. Right has 6 houses, preferences [0,1,0,1,1,1]. Number wanting right: 4. ceil(6/2)=3, so 4 >=3, meets condition.

- 1: left=[0], right=[1,0,1,1,1]. Left: 1 house, wants left, ceil(1/2)=1, meets. Right: 5 houses, 4 want right, ceil(5/2)=3, meets.

- 2: left=[0,1], right=[0,1,1,1]. Left: 2 houses, 1 wants left, ceil(2/2)=1, meets. Right: 4 houses, 3 want right, ceil(4/2)=2, meets.

- 3: left=[0,1,0], right=[1,1,1]. Left: 3 houses, 1 wants left, ceil(3/2)=2, doesn't meet.

- 4: left=[0,1,0,1], right=[1,1]. Left: 4 houses, 2 want left, ceil(4/2)=2, meets. Right: 2 houses, 2 want right, ceil(2/2)=1, meets.

- 5: left=[0,1,0,1,1], right=[1]. Left: 5 houses, 2 want left, ceil(5/2)=3, doesn't meet. Right: 1 house, wants right, ceil(1/2)=1, meets.

- 6: all on left. Left: 6 houses, 3 want left, ceil(6/2)=3, meets.

So positions 0,1,2,4,6 meet the condition. Among these, position 2 is closest to the middle (n=6, middle at 3), so position 2 is chosen.

Wait, but according to the sample input, for n=6 and a=010111, the output is 3. Wait, maybe I miscalculated.

Wait, let's check position 3:

left=[0,1,0], right=[1,1,1]

Left: 3 houses, 1 wants left (index 1), which is less than ceil(3/2)=2. So, doesn't meet.

Position 4:

left=[0,1,0,1], right=[1,1]

Left: 4 houses, 2 want left, ceil(4/2)=2, meets. Right: 2 houses, both want right, ceil(2/2)=1, meets.

Position 2:

left=[0,1], right=[0,1,1,1]

Left: 2 houses, 1 wants left, ceil(2/2)=1, meets. Right: 4 houses, 3 want right, ceil(4/2)=2, meets.

Position 1:

left=[0], right=[1,0,1,1,1]

Left: 1 house, wants left, ceil(1/2)=1, meets. Right: 5 houses, 3 want right, ceil(5/2)=3, meets.

Position 0:

all on right: 6 houses, 4 want right, ceil(6/2)=3, meets.

Position 6:

all on left: 6 houses, 3 want left, ceil(6/2)=3, meets.

So positions 0,1,2,4,6 meet the condition. Now, we need to choose the one closest to the middle, which is position 3 (since n=6, middle is at 3). Among the valid positions, position 3 is not valid, so we choose the closest valid one, which is position 2 and position 4, both at distance 1 from the middle. Since we need to choose the smaller one, it's position 2.

But according to the sample input, for n=6 and a=010111, the output is 3. Wait, maybe I misunderstood the problem.

Wait, perhaps the road is built after the house i, so positions are 0 to n.

In the first sample, n=3, positions are 0,1,2,3.

- position 0: all on right: [1,0,1], right wants at least ceil(3/2)=2 to want right. In [1,0,1], two want right, so meets.

- position 1: left=[1], right=[0,1], left: 1 wants right, which is less than ceil(1/2)=1 (but wants right, which is not left), so doesn't meet.

Wait, in the left side, residents want left, in the right side, they want right.

Wait, a_j=0 means wants left, a_j=1 wants right.

So, for position 1:

left=[1], which is a_j=1, wants right, but is on left side, which is not satisfied. So, 0 out of 1 want left, which is less than ceil(1/2)=1.

right=[0,1], which has a_j=0 wants left, but is on right side, not satisfied; a_j=1 wants right, which is satisfied. So, 1 out of 2 want right, which is ceil(2/2)=1, meets.

So, position 1 doesn't meet because left side doesn't meet.

position 2:

left=[1,0], which has a_j=1 wants right (not satisfied), a_j=0 wants left (satisfied). So, 1 out of 2 want left, ceil(2/2)=1, meets.

right=[1], which has a_j=1 wants right, 1 out of 1 want right, ceil(1/2)=1, meets.

So, position 2 is valid.

position 3:

left=[1,0,1], which has a_j=1 wants right (not satisfied), a_j=0 wants left (satisfied), a_j=1 wants right (not satisfied). So, 1 out of 3 want left, which is less than ceil(3/2)=2. Doesn't meet.

So, positions 0 and 2 meet the condition.

Now, which one is closer to the middle? Middle is at position floor(n/2)=1.5, so positions 1 or 2.

Position 0: distance |0 - 1.5| = 1.5

Position 2: distance |2 - 1.5| = 0.5

So, position 2 is closer to the middle.

Hence, the answer is 2.

In the second sample, n=6, a=010111.

positions 0 to 6.

- position 0: right=[0,1,0,1,1,1], which has 4 wants right, ceil(6/2)=3, meets.

- position 1: left=[0], right=[1,0,1,1,1], left: 1 wants left, ceil(1/2)=1, meets. Right: 3 wants right, ceil(5/2)=3, meets.

- position 2: left=[0,1], right=[0,1,1,1], left: 1 wants left, ceil(2/2)=1, meets. Right: 3 wants right, ceil(4/2)=2, meets.

- position 3: left=[0,1,0], right=[1,1,1], left: 1 wants left, ceil(3/2)=2, doesn't meet.

- position 4: left=[0,1,0,1], right=[1,1], left: 2 wants left, ceil(4/2)=2, meets. Right: 2 wants right, ceil(2/2)=1, meets.

- position 5: left=[0,1,0,1,1], right=[1], left: 2 wants left, ceil(5/2)=3, doesn't meet.

- position 6: left=[0,1,0,1,1,1], right=[], left: 3 wants left, ceil(6/2)=3, meets.

So positions 0,1,2,4,6 meet the condition.

Now, middle is at position floor(n/2)=3.

Among positions 0,1,2,4,6, the one closest to 3 is positions 2 and 4, both at distance 1.

We choose the smaller one, which is 2.

But according to the sample input, for n=6, a=010111, the output is 3.

Wait, perhaps I miscounted.

Wait, in the sample input, for n=6, a=010111, the output is 3.

Wait, perhaps I misunderstood the problem.

Wait, perhaps the road is built between houses i and i+1, with positions from 0 to n.

In the first sample, n=3, positions 0,1,2,3.

- position 0: all on right.

- position 1: left=[1], right=[0,1].

- position 2: left=[1,0], right=[1].

- position 3: left=[1,0,1], right=[].

In this case, position 2 is valid and closest to the middle.

In the second sample, n=6, a=010111, positions 0 to 6.

- position 0: right=[0,1,0,1,1,1], which has 4 wants right, ceil(6/2)=3, meets.

- position 1: left=[0], right=[1,0,1,1,1], left: 1 wants left, ceil(1/2)=1, meets. Right: 3 wants right, ceil(5/2)=3, meets.

- position 2: left=[0,1], right=[0,1,1,1], left: 1 wants left, ceil(2/2)=1, meets. Right: 3 wants right, ceil(4/2)=2, meets.

- position 3: left=[0,1,0], right=[1,1,1], left: 1 wants left, ceil(3/2)=2, doesn't meet.

- position 4: left=[0,1,0,1], right=[1,1], left: 2 wants left, ceil(4/2)=2, meets. Right: 2 wants right, ceil(2/2)=1, meets.

- position 5: left=[0,1,0,1,1], right=[1], left: 2 wants left, ceil(5/2)=3, doesn't meet.

- position 6: left=[0,1,0,1,1,1], right=[], left: 3 wants left, ceil(6/2)=3, meets.

So positions 0,1,2,4,6 meet the condition.

Now, positions 0: distance |0 - 3|=3

position 1: |1-3|=2

position 2: |2-3|=1

position 4: |4-3|=1

position 6: |6-3|=3

So positions 2 and 4 have the smallest distance of 1.

We need to choose the smallest one, which is position 2.

But according to the sample input, for n=6, a=010111, the output is 3.

Wait, perhaps I'm missing something.

Wait, perhaps the road is built after the house i, meaning position i is after house i.

So, position 0: before house 1, all on right.

position 1: after house 1, left=[1], right=[0,1,1,1]

position 2: after house 2, left=[1,0], right=[1,1,1]

position 3: after house 3, left=[1,0,1], right=[1,1]

position 4: after house 4, left=[1,0,1,1], right=[1,1]

position 5: after house 5, left=[1,0,1,1,1], right=[1]

position 6: after house 6, left=[1,0,1,1,1,1], right=[]

Wait, perhaps I miscounted the indices.

Wait, in the second sample, n=6, a=010111.

Wait, a=010111, so houses:

house 1: 0

house 2: 1

house 3: 0

house 4: 1

house 5: 1

house 6: 1

So, position 0: all on right: houses 1 to 6: [0,1,0,1,1,1], right wants at least ceil(6/2)=3 to want right. Number wanting right: positions 2,4,5,6 → 4, which is >=3. Meets.

position 1: left=[0], right=[1,0,1,1,1]. Left: 1 house, wants left, ceil(1/2)=1, meets. Right: 5 houses, positions 2,4,5,6 want right → 4, ceil(5/2)=3, meets.

position 2: left=[0,1], right=[0,1,1,1]. Left: 2 houses, position 1 wants left, position 2 wants right → 1 wants left, ceil(2/2)=1, meets. Right: 4 houses, positions 3 wants left, positions 4,5,6 want right → 3 wants right, ceil(4/2)=2, meets.

position 3: left=[0,1,0], right=[1,1,1]. Left: 3 houses, positions 1 and 3 want left, position 2 wants right → 2 wants left, ceil(3/2)=2, meets. Right: 3 houses, all want right, ceil(3/2)=2, meets.

position 4: left=[0,1,0,1], right=[1,1]. Left: 4 houses, positions 1 and 3 want left, positions 2 and 4 want right → 2 wants left, ceil(4/2)=2, meets. Right: 2 houses, both want right, ceil(2/2)=1, meets.

position 5: left=[0,1,0,1,1], right=[1]. Left: 5 houses, positions 1 and 3 want left, positions 2,4,5 want right → 2 wants left, ceil(5/2)=3, doesn't meet.

position 6: left=[0,1,0,1,1,1], right=[]. Left: 6 houses, positions 1 and 3 want left, positions 2,4,5,6 want right → 2 wants left, ceil(6/2)=3, doesn't meet.

Wait, so positions 0,1,2,3,4 meet the condition.

Among these, positions 3 and 4 have distances |3-3|=0 and |4-3|=1.

So, position 3 is the closest to the middle.

Hence, the answer is 3.

I must have miscalculated earlier.

So, in this case, position 3 is valid and closest to the middle.

Hence, the answer is 3.

Okay, now I need to think about how to implement this efficiently.

Constraints are t test cases, sum of n over all test cases <= 3*10^5, n <= 3*10^5 per test case.

So, per test case, time complexity should be O(n).

I need an efficient way to compute the number of satisfied residents on each side for each possible position.

Let me think about prefix sums.

I can compute prefix sums for the number of residents wanting left and right.

Let's define:

- prefix_left[i]: number of residents wanting left in houses 1 to i.

- prefix_right[i]: number of residents wanting right in houses i to n.

Then, for each position i (0 to n):

- left side: houses 1 to i.

- right side: houses i+1 to n.

Compute:

- left_satisfied = prefix_left[i]

- right_satisfied = prefix_right[i+1]

- left_total = i

- right_total = n - i

Check if:

- left_satisfied >= ceil(left_total / 2)

- right_satisfied >= ceil(right_total / 2)

To compute ceil(x / 2), it's equivalent to (x + 1) // 2 in integer arithmetic.

But need to handle the case when left_total or right_total is 0.

For example, if i=0, left_total=0, which is fine as there's no left side.

Similarly, if i=n, right_total=0, which is fine.

So, need to handle these edge cases.

Now, to find the position i that minimizes |i - n/2|, and if there are multiple, choose the smallest i.

I can iterate through all possible i from 0 to n, check the condition, and keep track of the i with the smallest |i - n/2|.

Among those, choose the smallest i.

But since n can be up to 3e5, and t up to 2e4, but sum of n over all test cases is 3e5, it should be fine.

But need to optimize it to O(n) per test case.

Now, in the code provided, it seems to be implementing something similar.

Let me look at the code.

The code defines two functions: func_1 and func_2.

func_2 reads the number of test cases and calls func_1 t times.

func_1 reads n and a, then computes prefix sums.

It initializes S = [[0,0]], then for each house, it adds [x,y], where x is cumulative count of 0's and y is cumulative count of 1's.

Then, it iterates through i from 0 to n-1.

For each i, it computes:

- left = S[i][0] (number of 0's in houses 1 to i)

- lsum = S[i][0] + S[i][1] (total houses on left)

- right = S[-1][1] - S[i][1] (number of 1's in houses i+1 to n)

- rsum = n - lsum (total houses on right)

Then, it checks if left * 2 < lsum or right * 2 < rsum.

If not, it checks if abs(n / 2 - i) <= abs(n / 2 - ans), and updates ans accordingly.

Finally, it prints ans.

Wait, but in the code, it's using S[i][0] and S[i][1], which are cumulative counts of 0's and 1's up to house i.

So, left_satisfied = S[i][0]

left_total = S[i][0] + S[i][1] = i

right_satisfied = S[-1][1] - S[i][1]

right_total = n - i

Then, it checks if left_satisfied * 2 < lsum or right_satisfied * 2 < rsum.

If neither is true, it checks if the current i is closer to n/2 than the current ans, and updates ans.

This seems correct.

But in the first example, n=3, a=101.

S = [[0,0], [0,1], [1,1], [1,2]]

Iterate i from 0 to 2:

i=0:

left_satisfied = S[0][0] = 0

lsum = S[0][0] + S[0][1] = 0 + 0 = 0

right_satisfied = S[3][1] - S[0][1] = 2 - 0 = 2

rsum = 3 - 0 = 3

Check if 0*2 < 0 or 2*2 < 3, which is 0 < 0 or 4 < 3, which is False or False, so continue.

Check if |3/2 - 0| <= |3/2 - ans|, where ans=0 initially. |1.5| <= |1.5|, so ans=0.

i=1:

left_satisfied = S[1][0] = 0

lsum = 0 + 1 = 1

right_satisfied = 2 - 1 = 1

rsum = 3 - 1 = 2

Check if 0*2 < 1 or 1*2 < 2, which is 0 < 1 or 2 < 2, which is True or False. Since left*2 < lsum, skip.

i=2:

left_satisfied = S[2][0] = 1

lsum = 1 + 1 = 2

right_satisfied = 2 - 1 = 1

rsum = 3 - 2 = 1

Check if 1*2 < 2 or 1*2 < 1, which is 2 < 2 or 2 < 1, which is False or False, so continue.

Check if |1.5 - 2| <= |1.5 - 0|, which is 0.5 <= 1.5, so ans=2.

Hence, ans=2, which matches the sample.

In the second sample, n=6, a=010111.

S = [[0,0], [1,0], [1,1], [2,1], [2,2], [2,3], [2,4]]

Iterate i from 0 to 5:

i=0:

left_satisfied = 0

lsum = 0 + 0 = 0

right_satisfied = 4 - 0 = 4

rsum = 6 - 0 = 6

Check 0*2 < 0 or 4*2 < 6, which is 0 < 0 or 8 < 6, False or False, so ans=0.

i=1:

left_satisfied = 1

lsum = 1 + 0 = 1

right_satisfied = 4 - 0 = 4

rsum = 6 - 1 = 5

Check 1*2 < 1 or 4*2 < 5, which is 2 < 1 or 8 < 5, False or False, so check |3 - 1| <= |3 - 0|, which is 2 <= 3, so ans=1.

i=2:

left_satisfied = 1

lsum = 1 + 1 = 2

right_satisfied = 4 - 1 = 3

rsum = 6 - 2 = 4

Check 1*2 < 2 or 3*2 < 4, which is 2 < 2 or 6 < 4, False or False, so check |3 - 2| <= |3 - 1|, which is 1 <= 2, so ans=2.

i=3:

left_satisfied = 2

lsum = 2 + 1 = 3

right_satisfied = 4 - 1 = 3

rsum = 6 - 3 = 3

Check 2*2 < 3 or 3*2 < 3, which is 4 < 3 or 6 < 3, False or False, so check |3 - 3| <= |3 - 2|, which is 0 <= 1, so ans=3.

i=4:

left_satisfied = 2

lsum = 2 + 2 = 4

right_satisfied = 4 - 2 = 2

rsum = 6 - 4 = 2

Check 2*2 < 4 or 2*2 < 2, which is 4 < 4 or 4 < 2, False