Alright, I've got this problem to solve. Let's see what it's asking for. So, Polycarp has two favorite integers, x and y, and he has an array of numbers. He considers a pair of indices <i, j> (where i < j) beautiful if two conditions are met:

1. The sum of the elements at positions i and j is divisible by x.

2. The difference of the elements at positions i and j is divisible by y.

My task is to find out how many such beautiful pairs exist in the array for each test case.

First, I need to understand what it means for a sum or difference to be divisible by a number. For two numbers a and b:

- Their sum (a + b) is divisible by x if (a + b) % x == 0.

- Their difference (a - b) is divisible by y if (a - b) % y == 0.

I need to find pairs where both these conditions hold true.

Let's think about how to approach this efficiently, especially since the array can be quite large (up to 2*10^5 elements per test case), and there can be up to 10^4 test cases. However, it's guaranteed that the sum of n over all test cases doesn't exceed 2*10^5, which is important for the time complexity.

I need an approach that can handle this within reasonable time limits.

Let me consider the properties of modulo operations. If I look at the elements of the array modulo x and modulo y, maybe I can find some patterns or relationships that will help me count the pairs efficiently.

Let's denote:

- a_i_x = a_i % x

- a_i_y = a_i % y

For the sum a_i + a_j to be divisible by x, we need (a_i % x + a_j % x) % x == 0, which simplifies to (a_i_x + a_j_x) % x == 0.

Similarly, for the difference a_i - a_j to be divisible by y, we need (a_i % y - a_j % y) % y == 0, which simplifies to (a_i_y - a_j_y) % y == 0.

So, I need pairs where:

1. (a_i_x + a_j_x) % x == 0

2. (a_i_y - a_j_y) % y == 0

Hmm, these conditions involve the residues of the elements modulo x and y.

I need to find a way to group the elements based on their residues in a way that makes it easy to count the pairs that satisfy both conditions.

One idea is to iterate through the array and keep track of the frequency of certain residue pairs (a_i_x, a_i_y). Then, for each element, determine how many other elements can pair with it to satisfy both conditions.

But I need to think carefully about how to relate these residues.

Let me try to express the conditions in terms of a_i_x and a_j_x, and a_i_y and a_j_y.

From condition 1:

(a_i_x + a_j_x) % x == 0

This implies that a_j_x ≡ -a_i_x mod x

So, for a given a_i_x, the a_j_x that satisfy this are those that are congruent to -a_i_x modulo x.

From condition 2:

(a_i_y - a_j_y) % y == 0

This implies that a_j_y ≡ a_i_y mod y

So, for a given a_i_y, the a_j_y that satisfy this are those that have the same residue modulo y.

Therefore, for a pair to be beautiful, a_j must satisfy:

- a_j_x ≡ -a_i_x mod x

- a_j_y ≡ a_i_y mod y

So, if I can group the elements based on their (a_i_x, a_i_y), I can figure out how many elements have the required ( -a_i_x mod x, a_i_y ) for each element.

Wait, but negative residues can be tricky. In Python, the modulo operation for negative numbers returns a positive remainder, so -a_i_x mod x is equivalent to (x - a_i_x) mod x.

So, a_j_x should be equal to (x - a_i_x) mod x.

Therefore, for each element, I need to find others that have:

- a_j_x == (x - a_i_x) mod x

- a_j_y == a_i_y

Given that, I can think of creating a dictionary or a frequency map where the keys are pairs of (residue_x, residue_y), and the values are the counts of elements that have those residues.

Then, for each element, I can look up the count of elements that have:

- residue_x = (x - a_i_x) mod x

- residue_y = a_i_y

And add that count to the total number of beautiful pairs.

However, I need to be careful to avoid counting pairs where i == j, and since the problem specifies i < j, I need to ensure that each pair is only counted once.

Also, since the array can be large, I need an efficient way to do this, preferably in O(n) time per test case.

Let me outline the steps:

1. For each test case, read n, x, y, and the array a.

2. Initialize a frequency map, probably a dictionary where keys are tuples (residue_x, residue_y), and values are counts.

3. Iterate through the array, for each element:

a. Compute a_i_x = a_i % x

b. Compute a_i_y = a_i % y

c. Determine the required residue for a_j_x: (x - a_i_x) % x

d. Look up the frequency of elements that have a_j_x == (x - a_i_x) % x and a_j_y == a_i_y

e. Add that frequency to the total count of beautiful pairs

f. Increment the frequency count for the current (a_i_x, a_i_y)

4. Since each pair is counted twice (once for each element), but because we're iterating and adding counts correctly, we need to ensure we're not double-counting. In this approach, since we're adding the frequency of matching pairs for each element, and each pair is only counted once (as we're considering i < j), we need to make sure that when we add the frequency, it's the count of elements that come after the current element.

Wait, actually, in the way I described it, if I'm iterating through the array and for each element, I look up the frequency of elements that satisfy the conditions and come after it, then I can add that frequency directly to the count.

The key is to update the frequency map only after processing the current element, to ensure that we're only counting pairs where i < j.

So, in code, it would look like:

- Initialize count = 0

- Initialize an empty frequency map

- For each element in the array:

- Compute a_i_x and a_i_y

- Compute required_a_j_x = (x - a_i_x) % x

- Look up the frequency of (required_a_j_x, a_i_y)

- Add that frequency to count

- Increment the frequency count for (a_i_x, a_i_y)

This way, when we process an element, we've already looked up how many elements before it satisfy the conditions, but since we update the frequency map after processing the current element, we don't count pairs where j <= i.

Wait, actually, in this approach, the frequency map will contain counts of elements that have been processed so far, i.e., elements before the current one. So, for each element, we look up how many elements before it can form a beautiful pair with it, and since we're iterating from the beginning, this ensures that i < j.

Yes, that makes sense.

Let me try to verify this with the sample input.

Sample Input:

7

6 5 2

1 2 7 4 9 6

...

Sample Output:

2

So, for n=6, x=5, y=2, arr=[1,2,7,4,9,6]

Let's compute the beautiful pairs:

- <1,5>: 1+9=10 divisible by 5, 1-9=-8 divisible by 2

- <4,6>: 4+6=10 divisible by 5, 4-6=-2 divisible by 2

So, there are 2 beautiful pairs.

Let's simulate the algorithm:

Initialize count=0, frequency_map={}

Process element 1:

a_i_x = 1 % 5 = 1

a_i_y = 1 % 2 = 1

required_a_j_x = (5 - 1) % 5 = 4

Look up frequency of (4,1): 0

Add 0 to count

Update frequency_map: (1,1) => 1

count=0

frequency_map={(1,1):1}

Process element 2:

a_i_x = 2 % 5 = 2

a_i_y = 2 % 2 = 0

required_a_j_x = (5 - 2) % 5 = 3

Look up frequency of (3,0): 0

Add 0 to count

Update frequency_map: (2,0) => 1

count=0

frequency_map={(1,1):1, (2,0):1}

Process element 7:

a_i_x = 7 % 5 = 2

a_i_y = 7 % 2 = 1

required_a_j_x = (5 - 2) % 5 = 3

Look up frequency of (3,1): 0

Add 0 to count

Update frequency_map: (2,1) => 1

count=0

frequency_map={(1,1):1, (2,0):1, (2,1):1}

Process element 4:

a_i_x = 4 % 5 = 4

a_i_y = 4 % 2 = 0

required_a_j_x = (5 - 4) % 5 = 1

Look up frequency of (1,0): 0

Add 0 to count

Update frequency_map: (4,0) => 1

count=0

frequency_map={(1,1):1, (2,0):1, (2,1):1, (4,0):1}

Process element 9:

a_i_x = 9 % 5 = 4

a_i_y = 9 % 2 = 1

required_a_j_x = (5 - 4) % 5 = 1

Look up frequency of (1,1): 1 (from element 1)

Add 1 to count, now count=1

Update frequency_map: (4,1) => 1

count=1

frequency_map={(1,1):1, (2,0):1, (2,1):1, (4,0):1, (4,1):1}

Process element 6:

a_i_x = 6 % 5 = 1

a_i_y = 6 % 2 = 0

required_a_j_x = (5 - 1) % 5 = 4

Look up frequency of (4,0): 1 (from element 4)

Add 1 to count, now count=2

Update frequency_map: (1,0) => 1

count=2

frequency_map={(1,1):1, (2,0):1, (2,1):1, (4,0):1, (4,1):1, (1,0):1}

Total beautiful pairs: 2, which matches the sample output.

Great, so this approach seems correct.

Now, I need to make sure that this is implemented efficiently. Since n can be up to 2*10^5 and t up to 10^4, but the sum of n over all test cases is <= 2*10^5, the total time should be acceptable.

In Python, using a dictionary to store frequencies should be fine, as dictionary lookups and updates are O(1) on average.

I need to read the input efficiently, as reading input in Python can be a bottleneck for large inputs. The code provided reads all input at once using sys.stdin.read(), splits it into tokens, and processes them accordingly, which is efficient.

The function func_1 processes each test case by iterating through the array once, maintaining the frequency map, and counting the beautiful pairs.

So, overall, this seems like a correct and efficient solution.

Therefore, the given program is correct.

**Final Answer**

\[\boxed{\text{Correct}}\]

