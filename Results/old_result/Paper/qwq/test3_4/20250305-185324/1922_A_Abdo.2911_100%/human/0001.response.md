Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an integer n and three strings a, b, and c, each of length n. I need to determine if there exists a template t, which is also a string of length n, consisting of lowercase and/or uppercase Latin letters, such that strings a and b match the template t, while string c does not match it.

First, I need to understand what it means for a string to match the template t. The problem explains that:

- If the i-th letter of the template is lowercase, then the i-th letter of the string must be exactly the same as the template's i-th letter.

- If the i-th letter of the template is uppercase, then the i-th letter of the string must be different from the lowercase version of the template's i-th letter.

Also, for string c, it should not match the template t, meaning that at least one position i violates one of the above conditions.

My task is to find if such a template t exists for the given a, b, and c.

Let me think about how to approach this.

I need to find a template t such that:

1. For each position i, if t[i] is lowercase, then a[i] and b[i] must be equal to t[i], and c[i] must not be equal to t[i].

2. If t[i] is uppercase, then a[i] and b[i] must be different from the lowercase version of t[i], and c[i] must be equal to the lowercase version of t[i].

Wait, no. Actually, for c to not match the template, there must be at least one position where:

- If t[i] is lowercase, c[i] != t[i].

- If t[i] is uppercase, c[i] == lowercase(t[i]).

But for a and b to match the template, for all positions i:

- If t[i] is lowercase, a[i] == t[i] and b[i] == t[i].

- If t[i] is uppercase, a[i] != lowercase(t[i]) and b[i] != lowercase(t[i]).

So, I need to choose t in such a way that a and b satisfy these conditions, and c does not.

This seems a bit tricky. Maybe I can look at each position independently and decide whether to make t[i] lowercase or uppercase.

Let's consider position i:

- If I make t[i] lowercase, then a[i] must equal t[i], b[i] must equal t[i], and c[i] must not equal t[i].

- If I make t[i] uppercase, then a[i] must not equal lowercase(t[i]), b[i] must not equal lowercase(t[i]), and c[i] must equal lowercase(t[i]).

Wait, but t[i] is uppercase, so lowercase(t[i]) is the lowercase version of t[i].

So, for t[i] uppercase:

- a[i] != lowercase(t[i])

- b[i] != lowercase(t[i])

- c[i] == lowercase(t[i])

And for t[i] lowercase:

- a[i] == t[i]

- b[i] == t[i]

- c[i] != t[i]

I need to choose for each position i whether to make t[i] lowercase or uppercase, such that all these conditions are satisfied.

Let me consider the possibilities for each position.

Case 1: a[i] == b[i]

- If a[i] == b[i], then for t[i] lowercase, t[i] must be equal to a[i] and b[i], and c[i] != a[i].

- If c[i] != a[i], then I can set t[i] to be lowercase a[i], and all conditions are satisfied for this position.

- If c[i] == a[i], then I cannot set t[i] to be lowercase a[i], because c[i] would equal t[i], which violates the condition for c.

- Alternatively, if I set t[i] to be uppercase, then t[i] must be such that lowercase(t[i]) != a[i] and != b[i], but c[i] == lowercase(t[i]).

- But since a[i] == b[i], I need lowercase(t[i]) != a[i], and c[i] == lowercase(t[i]).

- So, lowercase(t[i]) must be different from a[i], but equal to c[i].

- Therefore, c[i] != a[i], which is the same condition as above.

Wait, so if a[i] == b[i]:

- If c[i] != a[i], then I can set t[i] to be lowercase a[i], and all is good.

- If c[i] == a[i], then I cannot set t[i] to be lowercase a[i], because c[i] would equal t[i].

- In this case, I need to set t[i] to be uppercase, with lowercase(t[i]) != a[i], and c[i] == lowercase(t[i]).

- But c[i] == a[i], and lowercase(t[i]) != a[i], and c[i] == lowercase(t[i]), which implies a[i] == lowercase(t[i]) != a[i], which is impossible.

- Therefore, if a[i] == b[i] and c[i] == a[i], it's impossible to find such a template for this position.

So, in summary for case 1:

- If a[i] == b[i] and c[i] != a[i], then I can set t[i] to be lowercase a[i].

- If a[i] == b[i] and c[i] == a[i], it's impossible to satisfy the conditions for this position.

Case 2: a[i] != b[i]

- In this case, a[i] and b[i] are different.

- I need to choose t[i] such that both a[i] and b[i] match the template, but c[i] does not.

Let's consider the possibilities:

Option 1: set t[i] to be lowercase.

- Then, a[i] must equal t[i], and b[i] must equal t[i], but a[i] != b[i], which is impossible.

- Therefore, I cannot set t[i] to be lowercase.

Option 2: set t[i] to be uppercase.

- Then, a[i] != lowercase(t[i]), b[i] != lowercase(t[i]), and c[i] == lowercase(t[i]).

- So, I need to choose lowercase(t[i]) such that it's different from both a[i] and b[i], and c[i] equals lowercase(t[i]).

- Therefore, lowercase(t[i]) must be different from a[i] and b[i], and equal to c[i].

- So, c[i] must be different from both a[i] and b[i].

- If c[i] != a[i] and c[i] != b[i], then I can set lowercase(t[i]) to be c[i], and set t[i] to be uppercase version of c[i].

- If c[i] == a[i] or c[i] == b[i], then it's impossible because lowercase(t[i]) must be different from both a[i] and b[i].

So, for case 2:

- If a[i] != b[i], and c[i] != a[i] and c[i] != b[i], then I can set t[i] to be uppercase with lowercase(t[i]) = c[i].

- If a[i] != b[i], but c[i] == a[i] or c[i] == b[i], it's impossible to satisfy the conditions for this position.

In summary:

- For each position i:

- If a[i] == b[i]:

- If c[i] != a[i], then it's possible to set t[i] to be lowercase a[i].

- If c[i] == a[i], it's impossible.

- If a[i] != b[i]:

- If c[i] != a[i] and c[i] != b[i], then it's possible to set t[i] to be uppercase with lowercase(t[i]) = c[i].

- If c[i] == a[i] or c[i] == b[i], it's impossible.

Therefore, to have a valid template t, for all positions i, one of the above possible scenarios must hold.

Moreover, for the template to exist, there must be at least one position where c does not match t, while a and b do match t.

Given that, I need to ensure that:

- For all positions where a[i] == b[i] and c[i] != a[i], I can set t[i] to be lowercase a[i].

- For positions where a[i] == b[i] and c[i] == a[i], it's impossible.

- For positions where a[i] != b[i] and c[i] != a[i] and c[i] != b[i], I can set t[i] to be uppercase with lowercase(t[i]) = c[i].

- For positions where a[i] != b[i] and c[i] == a[i] or c[i] == b[i], it's impossible.

Furthermore, I need to make sure that there is at least one position where c does not match t, while a and b do match t.

Wait, actually, the condition is that a and b match t, and c does not match t.

So, for c to not match t, there must be at least one position where c does not satisfy the template condition, while a and b do satisfy it at all positions.

Therefore, for the template to exist, I need to choose t such that:

- For all positions i:

- If t[i] is lowercase:

- a[i] == t[i]

- b[i] == t[i]

- c[i] != t[i]

- If t[i] is uppercase:

- a[i] != lowercase(t[i])

- b[i] != lowercase(t[i])

- c[i] == lowercase(t[i])

Additionally, there must be at least one position where c does not match t, meaning:

- At least one position where:

- If t[i] is lowercase, c[i] != t[i]

- If t[i] is uppercase, c[i] == lowercase(t[i])

But given that for a and b to match t, and c to not match t, the conditions above must hold.

From the earlier analysis, I can see that:

- For positions where a[i] == b[i]:

- If c[i] != a[i], I can set t[i] to be lowercase a[i], and c[i] != t[i], which is good.

- If c[i] == a[i], it's impossible to find such a t[i].

- For positions where a[i] != b[i]:

- If c[i] != a[i] and c[i] != b[i], I can set t[i] to be uppercase with lowercase(t[i]) = c[i], and c[i] == lowercase(t[i]), which makes c not match t.

- If c[i] == a[i] or c[i] == b[i], it's impossible to find such a t[i].

Therefore, for the template to exist, I need to ensure that:

- For all positions where a[i] == b[i], c[i] != a[i].

- For all positions where a[i] != b[i], c[i] != a[i] and c[i] != b[i].

Moreover, there must be at least one position where c does not match t, which is already ensured by the above conditions.

Wait, but in the case where a[i] == b[i] and c[i] != a[i], setting t[i] to be lowercase a[i] makes c[i] != t[i], which is good.

In the case where a[i] != b[i] and c[i] != a[i] and c[i] != b[i], setting t[i] to be uppercase with lowercase(t[i]) = c[i], makes c[i] == lowercase(t[i]), which violates the condition for c not matching t.

Wait, no. If t[i] is uppercase, and c[i] == lowercase(t[i]), then c does not match t, as per the problem's condition.

Wait, no. Let's re-read the problem.

The problem says:

- If t[i] is uppercase, then s_i must be different from the lowercase version of t_i.

- For c to not match t, at least one position where:

- If t[i] is lowercase, c[i] != t[i]

- If t[i] is uppercase, c[i] == lowercase(t[i])

Wait, no, actually, the problem says:

- The string s matches the template t if for all i:

- If t[i] is lowercase, then s_i == t[i]

- If t[i] is uppercase, then s_i != lowercase(t[i])

- The string does not match the template if there exists at least one i where:

- If t[i] is lowercase, then s_i != t[i]

- If t[i] is uppercase, then s_i == lowercase(t[i])

So, for c to not match t, there must be at least one position i where:

- If t[i] is lowercase, then c[i] != t[i]

- If t[i] is uppercase, then c[i] == lowercase(t[i])

Meanwhile, a and b must match t at all positions.

So, in the case where a[i] == b[i] and c[i] != a[i], I can set t[i] to be lowercase a[i], and then c[i] != t[i], which is good.

In the case where a[i] != b[i] and c[i] != a[i] and c[i] != b[i], I can set t[i] to be uppercase with lowercase(t[i]) = c[i], and then c[i] == lowercase(t[i]), which means c does not match t at that position.

Wait, but according to the problem, if t[i] is uppercase, then for c to not match t, c[i] == lowercase(t[i]).

So, in this case, setting t[i] to be uppercase with lowercase(t[i]) = c[i] would make c[i] == lowercase(t[i]), which means c does not match t at that position, which is what we want.

Similarly, a[i] != lowercase(t[i]) and b[i] != lowercase(t[i]), which is true because lowercase(t[i]) = c[i], and c[i] != a[i] and c[i] != b[i] in this case.

Wait, but earlier I thought that if a[i] != b[i] and c[i] != a[i] and c[i] != b[i], then I can set t[i] to be uppercase with lowercase(t[i]) = c[i], and then a[i] != c[i], b[i] != c[i], which is good.

Yes, that seems correct.

So, to summarize:

- For positions where a[i] == b[i]:

- If c[i] != a[i], then set t[i] to be lowercase a[i].

- If c[i] == a[i], it's impossible.

- For positions where a[i] != b[i]:

- If c[i] != a[i] and c[i] != b[i], then set t[i] to be uppercase with lowercase(t[i]) = c[i].

- If c[i] == a[i] or c[i] == b[i], it's impossible.

Therefore, the template exists if and only if for all positions i:

- If a[i] == b[i], then c[i] != a[i]

- If a[i] != b[i], then c[i] != a[i] and c[i] != b[i]

Moreover, there must be at least one position where c does not match t, but since we're setting t such that c does not match at some position, this should be automatically satisfied if the above conditions hold for all positions.

Wait, but actually, I need to ensure that there is at least one position where c does not match t, while a and b match t at all positions.

Given that, if for all positions, c does not match t, that's still fine, as long as there is at least one such position.

But in practice, in the cases where a[i] == b[i] and c[i] != a[i], setting t[i] to be lowercase a[i] makes c[i] != t[i], which is good.

In positions where a[i] != b[i] and c[i] != a[i] and c[i] != b[i], setting t[i] to be uppercase with lowercase(t[i]) = c[i] makes c[i] == lowercase(t[i]), which means c does not match t at that position.

So, in both cases, c does not match t at those positions.

Therefore, if all positions satisfy either of the two possible scenarios, then there exists such a template t.

Hence, I can implement this logic:

- For each test case:

- Read n, a, b, c

- Iterate through each position i from 0 to n-1:

- If a[i] == b[i]:

- If c[i] != a[i], continue

- Else, impossible

- Else (a[i] != b[i]):

- If c[i] != a[i] and c[i] != b[i], continue

- Else, impossible

- After checking all positions, if all positions are valid, then print "YES"

- Else, print "NO"

Wait, but I need to ensure that there is at least one position where c does not match t.

But given that in all positions where we set t[i], c does not match t, as per the above settings, then as long as all positions satisfy the conditions, there will be at least one position where c does not match t (in fact, all positions where the conditions are satisfied will have c not matching t).

Unless all positions are impossible, or some positions are impossible.

Wait, no. If for all positions, the conditions are satisfied, then in all positions, c does not match t, which satisfies the requirement of having at least one position where c does not match t.

If in some positions, the conditions cannot be satisfied, then it's impossible.

Therefore, the above logic seems correct.

Let me verify it with the example provided.

Example Input:

4

1

a

b

c

2

aa

bb

aa

10

mathforces

luckforces

adhoccoder

3

acc

abd

abc

Output:

YES

NO

YES

NO

Let's analyze the first test case:

n=1

a=a

b=b

c=c

Position 0:

a[0]=a, b[0]=b => a[0] != b[0]

c[0]=c != a[0] and c[0] != b[0] (c != a and c != b), so it's possible to set t[0] to be uppercase with lowercase(t[0])=c, i.e., 'C'

Then:

- a[0]=a != lowercase(t[0])=c

- b[0]=b != lowercase(t[0])=c

- c[0]=c == lowercase(t[0])=c, so c does not match t at this position.

Hence, "YES"

Second test case:

n=2

a=aa

b=bb

c=aa

Position 0:

a[0]=a, b[0]=b => a[0] != b[0]

c[0]=a == a[0], so c[0] == a[0], which is not allowed.

Hence, impossible, "NO"

Third test case:

n=10

a=mathforces

b=luckforces

c=adhoccoder

Let's compare position by position:

For each i from 0 to 9:

- If a[i] == b[i]:

- Check if c[i] != a[i]

- Else, impossible

- Else (a[i] != b[i]):

- Check if c[i] != a[i] and c[i] != b[i]

- Else, impossible

Looking at the strings:

a: m a t h f o r c e s

b: l u c k f o r c e s

c: a d h o c c o d e r

Compare position by position:

0: m != l, c=a -> c != m and c != l (a != m and a != l), OK

1: a == u -> a != u, but c=d != a, but since a != u, this is invalid.

Wait, a[i] == b[i] only when a[i] == b[i].

Wait, in position 1:

a[1]=a, b[1]=u => a != u

c[1]=d != a and d != u, so OK

Position 2:

a=t, b=c => t != c

c[h]=h != t and h != c, OK

Position 3:

a=h, b=k => h != k

c[o]=o != h and o != k, OK

Position 4:

a=f, b=f => a == b

c[c]=c != f, OK

Position 5:

a=o, b=r => o != r

c[d]=d != o and d != r, OK

Position 6:

a=r, b=c => r != c

c[o]=o != r and o != c, OK

Position 7:

a=c, b=e => c != e

c[d]=d != c and d != e, OK

Position 8:

a=e, b=s => e != s

c[e]=e != e and e != s -> e == e, which is not allowed.

Wait, c[e]=e == e, which is a problem.

Wait, a[8]=e, b[8]=s => a != b

c[8]=e == a[8], which is not allowed.

So, for position 8:

a[8]=e, b[8]=s, c[8]=e

Since a[8] != b[8], but c[8] == a[8], which is not allowed.

Hence, impossible, should be "NO"

But in the example output, it's "YES"

Wait, perhaps I made a mistake in analyzing position 8.

Wait, a[8]=e, b[8]=s, c[8]=e

So, a[8] != b[8], but c[8] == a[8], which is not allowed.

Hence, it should be "NO", but the example output is "YES"

Wait, maybe I misread the strings.

Wait, a=mathforces

b=luckforces

c=adhoccoder

Let's list them:

a: m a t h f o r c e s

b: l u c k f o r c e s

c: a d h o c c o d e r

Position 8:

a[8]=e, b[8]=e, c[8]=e

Wait, a[8]=e, b[8]=e, which is a == b

Then, c[8]=e == a[8], which is not allowed.

Hence, impossible, should be "NO", but the example output is "YES"

Wait, perhaps I made a mistake in understanding the positions.

Wait, a=mathforces

b=luckforces

c=adhoccoder

Position 4:

a[4]=f, b[4]=f, c[4]=c

a[4] == b[4], and c[4]=c != f, OK

Position 5:

a[5]=o, b[5]=r, c[5]=c

a[5] != b[5], c[5]=c != o and c != r, OK

Position 6:

a[6]=r, b[6]=c, c[6]=o

a[6] != b[6], c[6]=o != r and o != c, OK

Position 7:

a[7]=c, b[7]=e, c[7]=d

a[7] != b[7], c[7]=d != c and d != e, OK

Position 8:

a[8]=e, b[8]=s, c[8]=e

a[8] != b[8], but c[8]=e == a[8], which is not allowed.

Hence, impossible, should be "NO", but the example output is "YES"

Wait, perhaps I misread the strings.

Wait, b=luckforces

So, b: l u c k f o r c e s

So, b[7]=c, b[8]=e, b[9]=s

a: m a t h f o r c e s

c: a d h o c c o d e r

So, position 7:

a[7]=c, b[7]=c, c[7]=d

a[7]==b[7], c[7]=d != c, OK

Position 8:

a[8]=e, b[8]=e, c[8]=e

a[8]==b[8], c[8]=e == a[8], which is not allowed.

Hence, impossible, should be "NO", but the example output is "YES"

Wait, perhaps I'm miscounting the positions.

Let's count positions from 0 to 9:

a: m a t h f o r c e s

b: l u c k f o r c e s

c: a d h o c c o d e r

Position 0:

a[m], b[l], c[a]

a != b, c != m and c != l (a != m and a != l), OK

Position 1:

a[a], b[u], c[d]

a != b, c != a and c != u (d != a and d != u), OK

Position 2:

a[t], b[c], c[h]

a != b, c != t and c != c (h != t and h != c), OK

Position 3:

a[h], b[k], c[o]

a != b, c != h and c != k (o != h and o != k), OK

Position 4:

a[f], b[f], c[c]

a == b, c != f (c != f), OK

Position 5:

a[o], b[r], c[c]

a != b, c != o and c != r (c != o and c != r), OK

Position 6:

a[r], b[c], c[o]

a != b, c != r and c != c (o != r and o != c), OK

Position 7:

a[c], b[c], c[d]

a == b, c != c (d != c), OK

Position 8:

a[e], b[e], c[e]

a == b, c != e (e != e)? No, c[e]==a[e], which is not allowed.

Hence, impossible, should be "NO", but the example output is "YES"

Wait, perhaps I'm misunderstanding the problem.

Wait, the problem says that the string c does not match the template t, which means that there exists at least one position where:

- If t[i] is lowercase, c[i] != t[i]

- If t[i] is uppercase, c[i] == lowercase(t[i])

But in the positions where a[i] == b[i] and c[i] == a[i], I cannot set t[i] to be lowercase a[i], because then c[i] == t[i], which would make c match t at that position.

But if I have such a position, and in other positions, c does not match t, it might still be possible.

Wait, but in the analysis above, for position 8, a[8]==b[8]==e, c[8]==e.

If I set t[8] to be lowercase e, then c[8]==e==t[8], which means c matches t at this position.

But for c to not match t, there must be at least one position where c does not match t.

So, if in other positions, c does not match t, then overall, c does not match t.

But in this case, for position 8, c matches t, but in other positions, c does not match t, so overall, c does not match t.

Wait, no. The problem says that c does not match t, which means that there exists at least one position where c does not match t.

But in positions where a[i]==b[i] and c[i]==a[i], if I set t[i] to be something that makes c not match t, but in this case, I cannot set t[i] to lowercase a[i], because c[i]==a[i].

Wait, perhaps I need to set t[i] in such a way that for positions where a[i]==b[i] and c[i]==a[i], I set t[i] to be uppercase with lowercase(t[i]) != a[i], and c[i] != lowercase(t[i]).

Wait, but according to the problem, if t[i] is uppercase, then c[i] must be equal to lowercase(t[i]) for c not to match t.

Wait, no, if t[i] is uppercase, then for c not to match t, c[i] == lowercase(t[i]).

So, in positions where a[i]==b[i] and c[i]==a[i], I cannot set t[i] to be lowercase a[i], because c[i]==a[i], which would make c match t at that position.

Alternatively, if I set t[i] to be uppercase with lowercase(t[i]) != a[i], then c[i] == lowercase(t[i]), which would require c[i]==lowercase(t[i]) != a[i], but c[i]==a[i], which is a contradiction.

Wait, no.

Wait, if t[i] is uppercase, then:

- a[i] != lowercase(t[i])

- b[i] != lowercase(t[i])

- c[i] == lowercase(t[i])

But a[i]==b[i]==c[i], so lowercase(t[i]) != a[i] and lowercase(t[i]) == c[i]==a[i], which is impossible.

Hence, in positions where a[i]==b[i]==c[i], it's impossible to find such a t[i].

But in the third test case, position 8 has a[8]==b[8]==c[8]==e, which should make it impossible, but the example output is "YES".

Wait, perhaps I made a mistake in counting the positions.

Let me check the strings again:

a: m a t h f o r c e s

b: l u c k f o r c e s

c: a d h o c c o d e r

Position 8:

a[8]=e, b[8]=e, c[8]=e

So, a[8]==b[8]==c[8], which should make it impossible.

But the example output is "YES", so perhaps my earlier reasoning is incorrect.

Wait, maybe I need to choose t[i] in such a way that for positions where a[i]==b[i]==c[i], I set t[i] to be uppercase with lowercase(t[i]) != a[i], and c[i] == lowercase(t[i]), which would require lowercase(t[i]) == c[i] != a[i], but a[i]==c[i], so it's impossible.

Hence, in this case, it should be "NO", but the example output is "YES", which suggests that my reasoning is flawed.

Perhaps I missed something.

Wait, maybe I need to consider that c must not match t, but a and b must match t.

So, even if in some positions where a[i]==b[i]==c[i], I set t[i] to be uppercase with lowercase(t[i]) != a[i], and c[i] == lowercase(t[i]), which would make c match t at that position, but since there are other positions where c does not match t, overall, c does not match t.

Wait, but according to the problem, c does not match t if there exists at least one position where c does not match t.

However, for a and b to match t, they must match t at all positions.

So, in positions where a[i]==b[i]==c[i], if I set t[i] to be uppercase with lowercase(t[i]) == c[i], then:

- a[i] != lowercase(t[i]) because a[i] == c[i] == lowercase(t[i]), which is not allowed.

Wait, no, if t[i] is uppercase, then for a to match t, a[i] != lowercase(t[i]).

But if a[i] == c[i] == lowercase(t[i]), then a[i] == lowercase(t[i]), which violates the condition for a matching t.

Hence, it's impossible in this case.

But the example output is "YES", which contradicts my earlier conclusion.

Perhaps I need to look for a different approach.

Let me consider that for positions where a[i]==b[i]==c[i], it's impossible to find such a t[i], because:

- If t[i] is lowercase, then c[i]==t[i], which makes c match t at that position.

- If t[i] is uppercase, then c[i]==lowercase(t[i]), which makes c not match t at that position, but a[i]==lowercase(t[i]), which violates a[i] != lowercase(t[i]).

Hence, in such positions, it's impossible to find t[i] that satisfies the conditions.

But in the third test case, position 8 has a[8]==b[8]==c[8]==e, which should make it impossible, but the example output is "YES".

Wait, perhaps I miscounted the positions.

Let me re-examine the strings:

a: m a t h f o r c e s

b: l u c k f o r c e s

c: a d h o c c o d e r

Position 8:

a[8]=e, b[8]=e, c[8]=e

So, a[8]==b[8]==c[8], which should be impossible, but the example output is "YES".

Wait, maybe in the example, position 8 is not an issue because there are other positions where c does not match t.

Wait, but according to my earlier reasoning, it's impossible in position 8.

Perhaps I need to reconsider the problem statement.

Wait, the problem says that c does not match t, meaning that there exists at least one position where c does not match t.

However, for a and b to match t, they must match t at all positions.

In positions where a[i]==b[i]==c[i], it's impossible to set t[i] such that a and b match t, and c does not match t.

Hence, in such cases, it should be "NO".

But according to the example, it's "YES", which suggests that my reasoning is incorrect.

Wait, perhaps I need to choose t[i] in such a way that for positions where a[i]==b[i]==c[i], I set t[i] to be uppercase with lowercase(t[i]) != c[i], and in positions where a[i]==b[i] and c[i] != a[i], I set t[i] to be lowercase a[i].

But in positions where a[i]==b[i]==c[i], setting t[i] to uppercase with lowercase(t[i]) != c[i], would make:

- a[i] != lowercase(t[i])

- b[i] != lowercase(t[i])

- c[i] == lowercase(t[i])

Which would satisfy the conditions.

Wait, but a[i]==c[i], and c[i]==lowercase(t[i]), so a[i]==lowercase(t[i]), but the condition is a[i] != lowercase(t[i]), which is violated.

Hence, it's impossible.

But the example suggests "YES", so perhaps there's a way around this.

Wait, maybe I need to set t[i] to be uppercase with lowercase(t[i]) != a[i] and != c[i].

But a[i]==b[i]==c[i], so if I set lowercase(t[i]) != a[i], then c[i]==lowercase(t[i]) != a[i], but a[i]==c[i], which is a contradiction.

Hence, it's impossible.

But the example output is "YES", which suggests that my reasoning is wrong.

Perhaps I need to look for a different approach.

Let me consider that for positions where a[i]==b[i]==c[i], I cannot set t[i] in a way that satisfies the conditions, hence it should be "NO".

But the example shows "YES", which contradicts this.

Wait, perhaps I misread the strings.

Let me check the third test case again.

n=10

a=mathforces

b=luckforces

c=adhoccoder

Wait, perhaps position 8 is not a problem.

Wait, a[8]=e, b[8]=e, c[8]=e

As discussed, it's impossible.

But the example output is "YES", which suggests that my earlier conclusion is wrong.

Perhaps I need to consider that for positions where a[i]==b[i]==c[i], I can set t[i] to be uppercase with lowercase(t[i]) != a[i], and choose lowercase(t[i]) != c[i], but c[i]==a[i], so c[i]==lowercase(t[i]) != a[i], which is impossible.

Hence, it's impossible, but the example output is "YES".

Wait, perhaps there's a mistake in the problem statement or the example.

Alternatively, maybe I need to consider that in positions where a[i]==b[i] and c[i] != a[i], I set t[i] to be lowercase a[i], and in positions where a[i]!=b[i] and c[i] != a[i] and c[i] != b[i], I set t[i] to be uppercase with lowercase(t[i])=c[i].

And in positions where a[i]==b[i]==c[i], I set t[i] to be uppercase with lowercase(t[i]) != a[i], and choose lowercase(t[i]) != c[i], but that's impossible.

Hence, in such cases, it's impossible.

But the example output is "YES", which suggests that in the third test case, it's possible.

Wait, perhaps in the third test case, position 8 is not a problem because a[8]==b[8]==c[8]==e, but if I set t[8] to be uppercase with lowercase(t[i]) != e, say t[i]='f', then:

- a[8]=e != 'f'

- b[8]=e != 'f'

- c[8]=e == 'f'

Which is not possible because e != f.

Wait, lowercase('F')='f', so c[8]=e != f, which would mean c matches t at this position.

Wait, no, if t[i]='F', then lowercase(t[i])='f'

- a[i]=e != f

- b[i]=e != f

- c[i]=e != f, so c matches t at this position.

But in other positions, c does not match t, so overall, c does not match t.

Hence, it's possible.

I see, so in positions where a[i]==b[i]==c[i], I can set t[i] to be uppercase with lowercase(t[i]) != a[i], and c[i] != lowercase(t[i]), which makes c match t at that position, but as long as there is at least one position where c does not match t, overall, c does not match t.

So, in such cases, it's possible.

Hence, my earlier reasoning was incorrect.

Therefore, the correct approach is:

- For positions where a[i]==b[i]:

- If c[i] != a[i], set t[i] to be lowercase a[i]

- If c[i] == a[i], set t[i] to be uppercase with lowercase(t[i]) != a[i], and choose lowercase(t[i]) != c[i], which is possible as there are 25 other choices (assuming c[i]==a[i]).

- For positions where a[i]!=b[i]:

- If c[i] != a[i] and c[i] != b[i], set t[i] to be uppercase with lowercase(t[i])=c[i]

- If c[i] == a[i] or c[i] == b[i], it's impossible.

But wait, in positions where a[i]==b[i]==c[i], setting t[i] to be uppercase with lowercase(t[i]) != a[i], and c[i] != lowercase(t[i]), makes c match t at that position, but in other positions, c does not match t, ensuring that c does not match t overall.

Hence, in such cases, it's possible.

Therefore, the condition should be:

- For all positions where a[i]==b[i], c[i] != a[i] is not necessarily required; instead, even if c[i]==a[i], I can set t[i] to be uppercase with lowercase(t[i]) != a[i], and c[i] != lowercase(t[i]), making c match t at that position.

- But I need to ensure that there is at least one position where c does not match t.

- So, if in some positions where a[i]==b[i] and c[i]==a[i], I set t[i] to be uppercase with lowercase(t[i]) != a[i], making c match t at those positions, and in other positions where a[i]!=b[i] and c[i] != a[i] and c[i] != b[i], set t[i] to be uppercase with lowercase(t[i])=c[i], making c not match t at those positions, then overall, c does not match t because there is at least one position where c does not match t.

- Hence, it's possible as long as there exists at least one position where a[i]!=b[i] and c[i] != a[i] and c[i] != b[i].

- Additionally, for positions where a[i]==b[i] and c[i]==a[i], I can still set t[i] to be uppercase with lowercase(t[i]) != a[i], making c match t at that position.

- Therefore, as long as there is at least one position where a[i]!=b[i] and c[i] != a[i] and c[i] != b[i], it's possible.

- If all positions have a[i]==b[i] and c[i]==a[i], then it's impossible because there is no position where c does not match t.

Wait, but in that case, if all positions have a[i]==b[i]==c[i], and I set t[i] to be uppercase with lowercase(t[i]) != a[i], making c match t at all positions, then c matches t, which violates the condition that c does not match t.

Hence, in such a case, it's impossible.

Therefore, the correct condition is:

- For all positions where a[i]==b[i] and c[i]==a[i], I can set t[i] to be uppercase with lowercase(t[i]) != a[i], making c match t at those positions.

- For positions where a[i]!=b[i]:

- If c[i] != a[i] and c[i] != b[i], set t[i] to be uppercase with lowercase(t[i])=c[i], making c not match t at that position.

- If c[i] == a[i] or c[i] == b[i], it's impossible.

- Additionally, there must be at least one position where c does not match t, which can be ensured by having at least one position where a[i]!=b[i] and c[i] != a[i] and c[i] != b[i].

Hence, the template exists if and only if:

- For all positions where a[i]==b[i] and c[i]==a[i], it's acceptable to set t[i] appropriately.

- For positions where a[i]!=b[i]:

- If c[i] != a[i] and c[i] != b[i], it's acceptable.

- If c[i] == a[i] or c[i] == b[i], it's impossible.

- Moreover, there must be at least one position where a[i]!=b[i] and c[i] != a[i] and c[i] != b[i].

Wait, no. The condition is that c does not match t, which requires that there exists at least one position where c does not match t.

If in some positions, a[i]==b[i] and c[i]==a[i], and I set t[i] to be uppercase with lowercase(t[i]) != a[i], making c match t at that position, and in other positions, a[i]!=b[i] and c[i] != a[i] and c[i] != b[i], and I set t[i] to be uppercase with lowercase(t[i])=c[i], making c not match t at those positions, then overall, c does not match t because there is at least one position where c does not match t.

Hence, it's possible as long as there exists at least one position where a[i]!=b[i] and c[i] != a[i] and c[i] != b[i].

In positions where a[i]==b[i] and c[i]==a[i], I can set t[i] to be uppercase with lowercase(t[i]) != a[i], making c match t at that position.

Therefore, the condition is:

- For all positions where a[i]==b[i], it's acceptable regardless of c[i].

- For positions where a[i]!=b[i]:

- If c[i] != a[i] and c[i] != b[i], it's acceptable.

- If c[i] == a[i] or c[i] == b[i], it's impossible.

- Additionally, there must be at least one position where a[i]!=b[i] and c[i] != a[i] and c[i] != b[i].

Wait, no. Actually, in positions where a[i]==b[i], if c[i]==a[i], I can still set t[i] to be uppercase with lowercase(t[i]) != a[i], making c match t at that position.

And in positions where a[i]!=b[i] and c[i] != a[i] and c[i] != b[i], I can set t[i] to be uppercase with lowercase(t[i])=c[i], making c not match t at that position.

Hence, as long as there exists at least one position where a[i]!=b[i] and c[i] != a[i] and c[i] != b[i], it's possible.

Otherwise, if all positions where a[i]!=b[i], c[i]==a[i] or c[i]==b[i], it's impossible.

Wait, but in the third test case:

a=mathforces

b=luckforces

c=adhoccoder

Comparing position by position:

Position 0: m != l, c=a != m and c != l -> acceptable

Position 1: a != u, c=d != a and d != u -> acceptable

Position 2: t != c, c=h != t and h != c