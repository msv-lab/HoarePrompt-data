Alright, I've got this problem to solve. Let's see what it's asking for. So, Polycarp has two favorite integers, x and y, and he has an array of numbers. He considers a pair of indices beautiful if two conditions are met: the sum of the elements at those indices is divisible by x, and the difference of the elements is divisible by y. I need to find out how many such beautiful pairs exist in the array.

First, I need to understand what it means for a sum or difference to be divisible by a number. If a + b is divisible by x, that means (a + b) % x == 0. Similarly, if a - b is divisible by y, then (a - b) % y == 0.

Given that, I need to find all pairs (i, j) where i < j, and both these conditions hold.

Let's think about how to approach this efficiently, especially since the array can be quite large, up to 2*10^5 elements, and there can be up to 10^4 test cases. But the problem mentions that the sum of n over all test cases doesn't exceed 2*10^5, which is good for overall time complexity.

Brute force approach would be to check every possible pair, but that would be O(n^2), which is too slow for n up to 2*10^5. So, I need a smarter way.

I recall that in problems involving sums and counts, frequency maps are often useful. Maybe I can use that here.

Let me think about the conditions again:

1. (a_i + a_j) % x == 0

2. (a_i - a_j) % y == 0

Maybe I can rewrite these conditions in terms of modulo.

Let's consider the first condition:

(a_i + a_j) % x == 0

This can be rewritten as:

(a_i % x + a_j % x) % x == 0

Similarly, the second condition:

(a_i - a_j) % y == 0

Which is equivalent to:

(a_i % y - a_j % y) % y == 0

Hmm, not sure if that directly helps.

Perhaps I can think in terms of a_i and a_j satisfying certain properties regarding their remainders when divided by x and y.

Let me consider the remainders of a_i when divided by x and y.

Let’s define for each a_i:

- r_x_i = a_i % x

- r_y_i = a_i % y

Then, for a pair (i, j):

(a_i + a_j) % x = (r_x_i + r_x_j) % x

We need this to be 0.

Similarly,

(a_i - a_j) % y = (r_y_i - r_y_j) % y

This also needs to be 0.

So, we need:

1. (r_x_i + r_x_j) % x == 0

2. (r_y_i - r_y_j) % y == 0

Let’s think about the first condition:

(r_x_i + r_x_j) % x == 0

This implies that r_x_j == (-r_x_i) % x

Similarly, the second condition:

(r_y_i - r_y_j) % y == 0

This implies that r_y_j == r_y_i

So, for two elements a_i and a_j to form a beautiful pair, they must satisfy:

- a_j % y == a_i % y

- a_j % x == (-a_i % x) % x

This is a crucial observation.

So, for each a_i, I can compute its r_x_i = a_i % x and r_y_i = a_i % y.

Then, for it to pair with a_j, a_j must have:

- r_x_j == (-r_x_i) % x

- r_y_j == r_y_i

This means that for each a_i, I can look for other elements that have specific remainders based on a_i's remainders.

This seems like a good approach for counting the pairs efficiently.

Let me think about how to implement this.

I can iterate through the array and for each element, calculate its r_x and r_y.

Then, for each element, I can look up how many elements have r_x equal to (-r_x_i) % x and r_y equal to r_y_i.

But if I do this naively, it would still be O(n^2).

To optimize, I can use a frequency map that maps pairs of (r_x, r_y) to their frequencies.

Then, for each element, I can compute the required (r_x', r_y') for potential pairs, which is ( (-r_x_i) % x, r_y_i ), and look up how many such elements are in the frequency map.

But I need to be careful about counting pairs correctly, ensuring that i < j.

So, I should iterate through the array, and for each element, look up the number of elements that can pair with it (i.e., those with r_x' and r_y' as defined), and then add that count to the total number of beautiful pairs.

Then, to avoid double-counting, I need to ensure that for each pair, I count it only once.

Wait, actually, since I'm iterating in order and looking for elements that come after the current element, I don't need to worry about double-counting.

Let me try to outline the steps:

1. Initialize a frequency map, which is a dictionary that maps tuples (r_x, r_y) to their counts.

2. Initialize a counter for beautiful pairs to zero.

3. Iterate through the array from index 0 to n-1:

a. For each element a_i, compute r_x_i = a_i % x and r_y_i = a_i % y.

b. Compute the required r_x' = (-r_x_i) % x and r_y' = r_y_i.

c. Look up the frequency of (r_x', r_y') in the frequency map and add that to the beautiful pairs counter.

d. Increment the frequency of (r_x_i, r_y_i) in the frequency map.

4. After iterating through the array, the beautiful pairs counter should have the total number of beautiful pairs.

Wait a minute, is this correct?

Let me verify with the example given.

Example:

n = 6, x = 5, y = 2

a = [1, 2, 7, 4, 9, 6]

Compute r_x and r_y for each element:

a1: 1 % 5 = 1, 1 % 2 = 1 → (1, 1)

a2: 2 % 5 = 2, 2 % 2 = 0 → (2, 0)

a3: 7 % 5 = 2, 7 % 2 = 1 → (2, 1)

a4: 4 % 5 = 4, 4 % 2 = 0 → (4, 0)

a5: 9 % 5 = 4, 9 % 2 = 1 → (4, 1)

a6: 6 % 5 = 1, 6 % 2 = 0 → (1, 0)

So, frequency map starts empty.

Iterate through the array:

- a1: (1, 1)

Required pair: ( (-1) % 5, 1 ) = (4, 1)

Frequency of (4,1) is 0. So, beautiful pairs += 0

Add (1,1):1 to frequency map.

- a2: (2, 0)

Required pair: ( (-2) % 5, 0 ) = (3, 0)

Frequency of (3,0) is 0. So, beautiful pairs += 0

Add (2,0):1 to frequency map.

- a3: (2, 1)

Required pair: ( (-2) % 5, 1 ) = (3, 1)

Frequency of (3,1) is 0. So, beautiful pairs += 0

Add (2,1):1 to frequency map.

- a4: (4, 0)

Required pair: ( (-4) % 5, 0 ) = (1, 0)

Frequency of (1,0) is 1 (from a6). So, beautiful pairs += 1

Add (4,0):1 to frequency map.

- a5: (4, 1)

Required pair: ( (-4) % 5, 1 ) = (1, 1)

Frequency of (1,1) is 1 (from a1). So, beautiful pairs += 1

Add (4,1):1 to frequency map.

- a6: (1, 0)

Required pair: ( (-1) % 5, 0 ) = (4, 0)

Frequency of (4,0) is 1 (from a4). So, beautiful pairs += 1

Add (1,0):1 to frequency map.

Total beautiful pairs: 0 + 0 + 0 + 1 + 1 + 1 = 3

But according to the example, there are only 2 beautiful pairs: (1,5) and (4,6).

Wait, that doesn't match. So, there must be a mistake in my approach.

Let me check which pairs are being counted.

From the above, it seems that (1,5), (4,6), and (5,6) are being counted.

But according to the example, only (1,5) and (4,6) are beautiful.

Wait, is (5,6) a beautiful pair?

a5: 9, a6:6

sum: 15, which is divisible by 5 (15 % 5 == 0)

difference: 3, which is not divisible by 2 (3 % 2 != 0)

So, (5,6) should not be a beautiful pair.

Therefore, my approach is counting an extra pair that doesn't satisfy both conditions.

What's wrong here?

Ah, I think the issue is that when I look up the frequency of the required pair, I'm not ensuring that the pair is with elements that come after the current element.

Wait, no, in the iteration above, when I process a5, I look for (1,0), which is a6, which is after a5. Similarly, when processing a6, I look for (4,0), which is a4, but since a4 comes before a6, I should not count it.

Wait, but in my earlier step, when processing a6, I'm adding (1,0) to the frequency map, but I should only consider elements that come after the current element.

I think I need to add the frequency after processing the current element.

Let me try adjusting the steps:

1. Initialize a frequency map, empty.

2. Initialize a counter for beautiful pairs to zero.

3. Iterate through the array from index 0 to n-1:

a. For each element a_i, compute r_x_i = a_i % x and r_y_i = a_i % y.

b. Compute the required r_x' = (-r_x_i) % x and r_y' = r_y_i.

c. Look up the frequency of (r_x', r_y') in the frequency map and add that to the beautiful pairs counter.

d. Increment the frequency of (r_x_i, r_y_i) in the frequency map.

But in the above example, this would still count (5,6) and (6,4), which is incorrect.

Wait, maybe I need to ensure that I only count pairs where i < j, meaning that when processing a6, I look for elements with (4,0), which is a4, but since a4 comes before a6, should I not count it?

Wait, no. In the iteration, when processing a6, the frequency map contains entries for a1 to a5. So, when looking for (4,0), which is a4, which is before a6, it should be counted as a valid pair because i < j (i=4, j=6).

But according to the problem, only pairs where i < j should be considered, so (4,6) is valid, but (6,4) is not.

Wait, but in the example, (5,6) is not a beautiful pair because although a5 % x = 4, a6 % x = 1, (-4) % 5 = 1, and a6 % x = 1, so that matches. And a5 % y = 1, a6 % y = 0, which does not match since required r_y' = r_y_i = 1, but a6 % y = 0 ≠ 1. So, it should not be counted.

Wait, in my earlier calculation, for a5: (4,1), required pair is (1,1), frequency of (1,1) is 1 (from a1), so beautiful pairs +=1.

For a6: (1,0), required pair is (4,0), frequency of (4,0) is 1 (from a4), so beautiful pairs +=1.

Total beautiful pairs: 0 + 0 + 0 +1 +1 +1 = 3, but according to the example, it should be 2.

Wait, perhaps there's a mistake in the example or in my understanding.

Let me check the conditions again for each pair:

- (1,5): a1=1, a5=9

sum: 10 % 5 == 0

difference: -8 % 2 == 0 → valid

- (4,6): a4=4, a6=6

sum: 10 % 5 == 0

difference: -2 % 2 == 0 → valid

- (5,6): a5=9, a6=6

sum: 15 % 5 == 0

difference: 3 % 2 == 1 ≠ 0 → invalid

So, indeed, (5,6) should not be counted, but according to my approach, it is being counted.

Why is that?

Because when processing a5: required pair is (1,1), which is a1, but a1 comes before a5, so it should not be counted.

Wait, no, in my earlier step, when processing a5, the frequency map contains entries for a1 to a4.

Looking for (1,1), which is a1, which is before a5, so it should be counted as a beautiful pair (1,5).

Similarly, when processing a6: looking for (4,0), which is a4, which is before a6, so it's counted as (4,6).

But in the earlier calculation, I thought it was counting (5,6), but actually, for a5, it's looking for (1,1), which is a1, not a6.

Wait, perhaps I miscalculated the frequency map.

Let me try to simulate it again.

Start with empty frequency map.

- a1: (1,1)

Look for (4,1): frequency is 0.

Add (1,1):1 to frequency map.

- a2: (2,0)

Look for (3,0): frequency is 0.

Add (2,0):1 to frequency map.

- a3: (2,1)

Look for (3,1): frequency is 0.

Add (2,1):1 to frequency map.

- a4: (4,0)

Look for (1,0): frequency is 1 (from a6). Wait, a6 hasn't been processed yet, so frequency of (1,0) is 0.

Add (4,0):1 to frequency map.

- a5: (4,1)

Look for (1,1): frequency is 1 (from a1).

Add (4,1):1 to frequency map.

- a6: (1,0)

Look for (4,0): frequency is 1 (from a4).

Add (1,0):1 to frequency map.

Total beautiful pairs: 0 + 0 + 0 + 0 + 1 + 1 = 2, which matches the example.

Wait, in my earlier simulation, I mistakenly thought that when processing a6, frequency of (4,0) is 1 from a4, but actually, a4 has been processed before a6, so it should be counted.

But according to the correct simulation, it's only counting (4,6) and (5,1), which are the two valid pairs.

So, perhaps my initial approach is correct, and the mistake was in my simulation.

Let me try another test case to verify.

Take the second test case from the example:

7 9 5

1 10 15 3 8 12 15

Compute r_x and r_y:

a1: 1 % 9 = 1, 1 % 5 = 1 → (1,1)

a2: 10 % 9 = 1, 10 % 5 = 0 → (1,0)

a3: 15 % 9 = 6, 15 % 5 = 0 → (6,0)

a4: 3 % 9 = 3, 3 % 5 = 3 → (3,3)

a5: 8 % 9 = 8, 8 % 5 = 3 → (8,3)

a6: 12 % 9 = 3, 12 % 5 = 2 → (3,2)

a7: 15 % 9 = 6, 15 % 5 = 0 → (6,0)

Frequency map starts empty.

- a1: (1,1)

Look for (8,1): frequency is 0.

Add (1,1):1

- a2: (1,0)

Look for (8,0): frequency is 0.

Add (1,0):1

- a3: (6,0)

Look for (3,0): frequency is 0.

Add (6,0):1

- a4: (3,3)

Look for (6,3): frequency is 0.

Add (3,3):1

- a5: (8,3)

Look for (1,3): frequency is 0.

Add (8,3):1

- a6: (3,2)

Look for (6,2): frequency is 0.

Add (3,2):1

- a7: (6,0)

Look for (3,0): frequency is 1 (from a4).

Add (6,0):2

Total beautiful pairs: 0 + 0 + 0 + 0 + 0 + 0 + 1 = 1

But according to the example, the output is 0 for this test case.

So, there's a discrepancy.

Wait, perhaps the pair (4,7) is being counted, but let's check if it's a valid beautiful pair.

a4: 3, a7:15

sum: 18 % 9 == 0

difference: -12 % 5 == 3 ≠ 0

So, it's not a valid beautiful pair.

Therefore, my approach is incorrectly counting this pair.

So, there must be a mistake in the logic.

Let me think again.

I need to ensure that both conditions are satisfied:

(a_i + a_j) % x == 0 and (a_i - a_j) % y == 0

In terms of remainders:

a_j % x == (-a_i % x) % x and a_j % y == a_i % y

So, for each a_i, I look for a_j such that:

- a_j % x == (-a_i % x) % x

- a_j % y == a_i % y

In the frequency map, I should look for ( (-a_i % x) % x, a_i % y )

But in the simulation above, for a7: (6,0), it looks for (3,0), and finds a4: (3,3), but a4 has r_y = 3 ≠ 0, so it shouldn't be counted.

Wait, no. The required pair for a7 is (3,0), and a4 is (3,3), which does not match. So, why is it being counted?

Wait, in my earlier simulation, I said frequency of (3,0) is 1, but in reality, a4 is (3,3), not (3,0). So, frequency of (3,0) should be 0.

Wait, perhaps I made a mistake in the frequency map.

Let's simulate again carefully.

Start with empty frequency map.

- a1: (1,1)

Look for (8,1): frequency is 0.

Add (1,1):1

- a2: (1,0)

Look for (8,0): frequency is 0.

Add (1,0):1

- a3: (6,0)

Look for (3,0): frequency is 0.

Add (6,0):1

- a4: (3,3)

Look for (6,3): frequency is 0.

Add (3,3):1

- a5: (8,3)

Look for (1,3): frequency is 0.

Add (8,3):1

- a6: (3,2)

Look for (6,2): frequency is 0.

Add (3,2):1

- a7: (6,0)

Look for (3,0): frequency is 0.

Add (6,0):2

Wait, in this simulation, for a7: (6,0), looking for (3,0), which is not present in the frequency map (a4 is (3,3)), so frequency should be 0.

But earlier I thought frequency of (3,0) is 1, which was incorrect.

So, in this corrected simulation, the total beautiful pairs are 0, which matches the example.

So, perhaps my initial approach is correct, and the mistake was in the simulation.

Let me check another test case.

Take the third test case:

9 4 10

14 10 2 2 11 11 13 5 6

Compute r_x and r_y:

a1:14%4=2,14%10=4 → (2,4)

a2:10%4=2,10%10=0 → (2,0)

a3:2%4=2,2%10=2 → (2,2)

a4:2%4=2,2%10=2 → (2,2)

a5:11%4=3,11%10=1 → (3,1)

a6:11%4=3,11%10=1 → (3,1)

a7:13%4=1,13%10=3 → (1,3)

a8:5%4=1,5%10=5 → (1,5)

a9:6%4=2,6%10=6 → (2,6)

Frequency map starts empty.

- a1: (2,4)

Look for ( (-2)%4,4 ) = (2,4): frequency is 0.

Add (2,4):1

- a2: (2,0)

Look for ( (-2)%4,0 ) = (2,0): frequency is 0.

Add (2,0):1

- a3: (2,2)

Look for ( (-2)%4,2 ) = (2,2): frequency is 0.

Add (2,2):1

- a4: (2,2)

Look for ( (-2)%4,2 ) = (2,2): frequency is 1 (from a3).

Add (2,2):2

- a5: (3,1)

Look for ( (-3)%4,1 ) = (1,1): frequency is 0.

Add (3,1):1

- a6: (3,1)

Look for ( (-3)%4,1 ) = (1,1): frequency is 0.

Add (3,1):2

- a7: (1,3)

Look for ( (-1)%4,3 ) = (3,3): frequency is 0.

Add (1,3):1

- a8: (1,5)

Look for ( (-1)%4,5 ) = (3,5): frequency is 0.

Add (1,5):1

- a9: (2,6)

Look for ( (-2)%4,6 ) = (2,6): frequency is 0.

Add (2,6):1

Total beautiful pairs: 0 + 0 + 0 +1 + 0 + 0 + 0 + 0 + 0 = 1

According to the example, the output is 1 for this test case, so it matches.

Another test case:

9 5 6

10 7 6 7 9 7 7 10 10

Compute r_x and r_y:

a1:10%5=0,10%6=4 → (0,4)

a2:7%5=2,7%6=1 → (2,1)

a3:6%5=1,6%6=0 → (1,0)

a4:7%5=2,7%6=1 → (2,1)

a5:9%5=4,9%6=3 → (4,3)

a6:7%5=2,7%6=1 → (2,1)

a7:7%5=2,7%6=1 → (2,1)

a8:10%5=0,10%6=4 → (0,4)

a9:10%5=0,10%6=4 → (0,4)

Frequency map starts empty.

- a1: (0,4)

Look for ( (-0)%5,4 ) = (0,4): frequency is 0.

Add (0,4):1

- a2: (2,1)

Look for ( (-2)%5,1 ) = (3,1): frequency is 0.

Add (2,1):1

- a3: (1,0)

Look for ( (-1)%5,0 ) = (4,0): frequency is 0.

Add (1,0):1

- a4: (2,1)

Look for (3,1): frequency is 0.

Add (2,1):2

- a5: (4,3)

Look for ( (-4)%5,3 ) = (1,3): frequency is 0.

Add (4,3):1

- a6: (2,1)

Look for (3,1): frequency is 0.

Add (2,1):3

- a7: (2,1)

Look for (3,1): frequency is 0.

Add (2,1):4

- a8: (0,4)

Look for (0,4): frequency is 1 (from a1).

Add (0,4):2

- a9: (0,4)

Look for (0,4): frequency is 2 (from a1 and a8).

Add (0,4):3

Total beautiful pairs: 0 + 0 + 0 + 0 + 0 + 0 + 0 +1 +2 = 3

According to the example, the output is 3 for this test case, which matches.

Another test case:

9 6 2

4 9 7 1 2 2 13 3 15

Compute r_x and r_y:

a1:4%6=4,4%2=0 → (4,0)

a2:9%6=3,9%2=1 → (3,1)

a3:7%6=1,7%2=1 → (1,1)

a4:1%6=1,1%2=1 → (1,1)

a5:2%6=2,2%2=0 → (2,0)

a6:2%6=2,2%2=0 → (2,0)

a7:13%6=1,13%2=1 → (1,1)

a8:3%6=3,3%2=1 → (3,1)

a9:15%6=3,15%2=1 → (3,1)

Frequency map starts empty.

- a1: (4,0)

Look for ( (-4)%6,0 ) = (2,0): frequency is 0.

Add (4,0):1

- a2: (3,1)

Look for ( (-3)%6,1 ) = (3,1): frequency is 0.

Add (3,1):1

- a3: (1,1)

Look for ( (-1)%6,1 ) = (5,1): frequency is 0.

Add (1,1):1

- a4: (1,1)

Look for (5,1): frequency is 0.

Add (1,1):2

- a5: (2,0)

Look for ( (-2)%6,0 ) = (4,0): frequency is 1 (from a1).

Add (2,0):1

- a6: (2,0)

Look for (4,0): frequency is 1 (from a1).

Add (2,0):2

- a7: (1,1)

Look for (5,1): frequency is 0.

Add (1,1):3

- a8: (3,1)

Look for (3,1): frequency is 2 (from a2 and a8).

Add (3,1):2

- a9: (3,1)

Look for (3,1): frequency is 3 (from a2, a8, a9).

Add (3,1):3

Total beautiful pairs: 0 + 0 + 0 + 0 +1 +1 +0 +2 +3 = 7

According to the example, the output is 5 for this test case, but my approach counts 7, which doesn't match.

So, there's an inconsistency here.

Let me check which pairs are being counted.

From a5: (2,0), looks for (4,0): frequency is 1 (a1), so counts (1,5)

From a6: (2,0), looks for (4,0): frequency is 1 (a1), so counts (1,6)

From a8: (3,1), looks for (3,1): frequency is 1 (a2), so counts (2,8)

From a9: (3,1), looks for (3,1): frequency is 2 (a2 and a8), so counts (2,9) and (8,9)

Total beautiful pairs: (1,5), (1,6), (2,8), (2,9), (8,9) → 5 pairs, which matches the example.

But according to my earlier calculation, I had 7. Must have miscounted.

So, perhaps my approach is correct, and the mistake was in counting.

Let me try another test case to confirm.

Take the last test case:

10 5 7

13 3 3 2 12 11 3 7 13 14

Compute r_x and r_y:

a1:13%5=3,13%7=6 → (3,6)

a2:3%5=3,3%7=3 → (3,3)

a3:3%5=3,3%7=3 → (3,3)

a4:2%5=2,2%7=2 → (2,2)

a5:12%5=2,12%7=5 → (2,5)

a6:11%5=1,11%7=4 → (1,4)

a7:3%5=3,3%7=3 → (3,3)

a8:7%5=2,7%7=0 → (2,0)

a9:13%5=3,13%7=6 → (3,6)

a10:14%5=4,14%7=0 → (4,0)

Frequency map starts empty.

- a1: (3,6)

Look for ( (-3)%5,6 ) = (2,6): frequency is 0.

Add (3,6):1

- a2: (3,3)

Look for (2,3): frequency is 0.

Add (3,3):1

- a3: (3,3)

Look for (2,3): frequency is 0.

Add (3,3):2

- a4: (2,2)

Look for (3,2): frequency is 0.

Add (2,2):1

- a5: (2,5)

Look for (3,5): frequency is 0.

Add (2,5):1

- a6: (1,4)

Look for (4,4): frequency is 0.

Add (1,4):1

- a7: (3,3)

Look for (2,3): frequency is 0.

Add (3,3):3

- a8: (2,0)

Look for (3,0): frequency is 0.

Add (2,0):1

- a9: (3,6)

Look for (2,6): frequency is 0.

Add (3,6):2

- a10: (4,0)

Look for (1,0): frequency is 1 (from a6).

Add (4,0):1

Total beautiful pairs: 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 +1 = 1

But according to the example, the output is 0 for this test case.

So, there's a discrepancy again.

Let me check if (6,10) is a beautiful pair.

a6:11, a10:14

sum: 25 % 5 == 0

difference: -3 % 7 == 4 ≠ 0 → not a beautiful pair.

So, why is it being counted?

Wait, in my simulation, for a10: (4,0), looking for (1,0): frequency is 1 (from a6: (1,4)), but a6 has r_y = 4 ≠ 0, so it shouldn't be counted.

Wait, perhaps I made a mistake in the frequency map.

Let's check the frequency map at a10:

- (3,6):2 (from a1 and a9)

- (3,3):3 (from a2, a3, a7)

- (2,2):1 (from a4)

- (2,5):1 (from a5)

- (1,4):1 (from a6)

- (2,0):1 (from a8)

- (4,0):1 (from a10)

So, for a10: (4,0), looking for (1,0), which is not present in the frequency map. So, frequency should be 0.

But earlier, I thought frequency of (1,0) is 1 from a6: (1,4), which is incorrect because a6 has r_y = 4 ≠ 0.

So, frequency of (1,0) is actually 0.

Thus, beautiful pairs should be 0, matching the example.

So, perhaps my initial approach is correct, and the mistake was in the simulation.

I think the approach is correct, and the program implements this logic.

Therefore, the given program is correct.

**Final Answer**

\[ \boxed{\text{Correctness: True}} \]