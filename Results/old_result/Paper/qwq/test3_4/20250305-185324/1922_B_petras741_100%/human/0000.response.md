Alright, I've got this problem to solve. Let's see what it's asking for. So, I have n sticks, each with a length of 2 raised to the power of a certain number, specifically 2^{a_i} for each stick i. I need to choose exactly 3 sticks and form a non-degenerate triangle with them. A non-degenerate triangle means that the area is greater than 0, which in terms of stick lengths translates to the triangle inequality holding: the sum of any two sides must be greater than the third side.

So, my task is to count how many ways I can choose 3 sticks such that they satisfy the triangle inequality.

First, I need to understand the input and output formats. The input consists of multiple test cases, starting with an integer t indicating the number of test cases. For each test case, there's an integer n representing the number of sticks, followed by n integers a_1 to a_n, where each a_i corresponds to the exponent in the length of the stick (since length is 2^{a_i}).

Constraints are given: t is up to 10^4, n is up to 3*10^5, and a_i ranges from 0 to n. Also, the sum of n over all test cases doesn't exceed 3*10^5, which is important for time complexity considerations.

In the example provided, there are 4 test cases. In the first one, n=7 and all a_i are 1, meaning all sticks have length 2^1 = 2. For any three sticks of length 2, they can form a triangle because 2 + 2 > 2. The number of ways to choose 3 sticks out of 7 is C(7,3) = 35, which matches the first output.

In the second test case, n=4 with a_i = 3,2,1,3. So the lengths are 2^3=8, 2^2=4, 2^1=2, and 2^3=8. The possible triangles are (8,8,4) and (8,4,8), but since the order doesn't matter, it's just 2 unique ways.

The third and fourth test cases have n=3 and n=1 respectively, and in both cases, it's impossible to form a triangle.

Looking at the problem, I need an efficient way to count the number of valid triplets (i,j,k) where i < j < k, and the lengths 2^{a_i}, 2^{a_j}, 2^{a_k} satisfy the triangle inequality.

Given that the lengths are powers of 2, I should consider properties of exponents and powers of 2 to optimize the solution.

First, note that 2^{a_i} is strictly increasing with a_i since 2 > 1. Therefore, if a_i <= a_j <= a_k, then 2^{a_i} <= 2^{a_j} <= 2^{a_k}.

For these three lengths to form a triangle, they must satisfy:

2^{a_i} + 2^{a_j} > 2^{a_k}

Since a_i <= a_j <= a_k, we can analyze this inequality.

Given that 2^{a_i} <= 2^{a_j} <= 2^{a_k}, the sum 2^{a_i} + 2^{a_j} can only be greater than 2^{a_k} under certain conditions.

Considering that 2^{a_i} + 2^{a_j} is at most 2^{a_j} + 2^{a_j} = 2^{a_j + 1} if a_i = a_j.

But since a_i <= a_j, 2^{a_i} + 2^{a_j} is less than or equal to 2^{a_j + 1}.

Comparing this to 2^{a_k}, for the sum to be greater than 2^{a_k}, we need 2^{a_j + 1} > 2^{a_k}, which implies a_j + 1 > a_k, or a_k < a_j + 1.

So, the condition for forming a triangle is a_k < a_j + 1.

Given that a_i <= a_j <= a_k, and a_k < a_j + 1, this means that a_k can be either a_j or a_j + 1 - but wait, since a_k < a_j + 1, a_k <= a_j.

But a_i <= a_j <= a_k and a_k < a_j + 1 implies a_k <= a_j.

Wait, but if a_k <= a_j, then 2^{a_i} + 2^{a_j} >= 2^{a_j} + 2^{a_j} = 2^{a_j + 1} > 2^{a_k}, since a_k <= a_j.

Wait, this seems confusing. Let's think differently.

Given a_i <= a_j <= a_k and a_k < a_j + 1, then a_k <= a_j.

But if a_k <= a_j, then 2^{a_i} + 2^{a_j} >= 2^{a_j} + 2^{a_j} = 2^{a_j + 1}.

But 2^{a_j + 1} > 2^{a_k} since a_k <= a_j.

Wait, no: if a_k <= a_j, then 2^{a_k} <= 2^{a_j}, but 2^{a_j + 1} is greater than 2^{a_j}, so yes, 2^{a_j + 1} > 2^{a_k}.

Therefore, as long as a_k < a_j + 1, the sum 2^{a_i} + 2^{a_j} > 2^{a_k}.

So, the condition for forming a triangle is a_k < a_j + 1.

Given that, I need to count the number of triplets (i,j,k) with i < j < k, a_i <= a_j <= a_k, and a_k < a_j + 1.

Given that a_i are integers, a_k < a_j + 1 implies a_k <= a_j.

But wait, if a_k <= a_j, then since a_i <= a_j, and a_k <= a_j, then for any such triplet where a_i <= a_j and a_k <= a_j, it satisfies the triangle inequality.

Wait, but in the example, when all a_i are equal, it's C(n,3), which is correct.

In the second example, with a_i = 1,2,3,3, we have n=4.

Sorted a_i: 1,2,3,3.

Possible triplets:

(1,2,3): a_k=3 <= a_j=2? No, 3 > 2, so doesn't satisfy a_k <= a_j.

(1,2,3): same as above.

(1,3,3): a_k=3 <= a_j=3? Yes.

(2,3,3): a_k=3 <= a_j=3? Yes.

So, only two valid triplets, which matches the sample output.

Therefore, the condition is that a_k <= a_j.

Given that, I need to count the number of triplets where a_i <= a_j and a_k <= a_j.

But in the sorted list, since a_i <= a_j <= a_k, and a_k <= a_j, it implies a_k <= a_j, which means a_k = a_j.

So, in other words, a_k = a_j.

Wait, but in the first sample, all a_i are 1, so a_j = a_k =1, which is fine.

In the second sample, we have a_i =1,2,3,3.

Sorted:1,2,3,3.

Possible triplets where a_k = a_j:

(1,3,3): a_j=3, a_k=3.

(2,3,3): a_j=3, a_k=3.

These are the only two valid triplets.

So, generalizing, for each a_j, the number of ways is the number of a_i <= a_j (which is j in the sorted list) times the number of a_k == a_j.

Wait, in the sorted list, for each a_j, the number of a_k == a_j is the frequency of a_j.

But we have to choose a_i from the first j-1 elements (since i < j), and a_k from the elements where a_k == a_j.

Wait, more carefully:

Suppose we fix a_j, and count the number of a_i < j with a_i <= a_j (which is j-1, since the list is sorted), and the number of a_k > j with a_k == a_j.

Wait, but in the sorted list, for a fixed j, a_k >= a_j, and we need a_k == a_j.

So, for each j, the number of a_k == a_j to the right of j.

Then, for each j, the number of ways is (number of a_i <= a_j to the left) * (number of a_k == a_j to the right).

But in the sorted list, the number of a_i <= a_j to the left is j.

The number of a_k == a_j to the right is frequency of a_j minus the number of a_j's up to j.

Wait, perhaps it's better to group the a_i's by their value.

Since a_i can be up to n, and n can be up to 3*10^5, and t up to 10^4, but sum of n over t is up to 3*10^5, we need an efficient way.

Let me think about the frequency approach.

Let's sort the a_i's for each test case.

Then, count the frequency of each a_i.

Let freq[x] be the number of sticks with a_i = x.

Then, for each a_j, the number of ways is:

number of a_i <= a_j choose 2 * freq[a_j]

But wait, no.

Wait, perhaps inclusion-exclusion.

Alternatively, iterate through sorted a_i's, and for each a_j, count the number of a_i < j with a_i <= a_j, and a_k > j with a_k == a_j.

Wait, it's getting messy.

Let me look for a better approach.

Given that a_k <= a_j, and a_i <= a_j, and i < j < k.

Given that, perhaps it's better to group the a_i's by their value.

Let me consider that the sticks are sorted by their a_i's.

Then, for each a_j, the number of valid a_i's is j (since a_i <= a_j), and the number of valid a_k's is the number of sticks with a_k <= a_j to the right of j.

Wait, but in the sorted list, all a_k's to the right of j are >= a_j, but we need a_k <= a_j, which implies a_k == a_j.

So, only a_k's with a_k == a_j to the right of j are valid.

Therefore, for each j, the number of ways is j * (freq[a_j] - number of a_j's up to j).

Wait, more precisely, for each j, the number of a_k == a_j to the right of j is freq[a_j] - number of a_j's up to and including j.

Wait, let's think differently.

Let me group all sticks with the same a_i together.

Suppose I have freq[a] for each a.

Then, for each group a_j, the number of ways is:

number of ways to choose a_i < j (which is sum of freq[a] for a <= a_j) choose 1, times freq[a_j] choose 2.

Wait, no.

Wait, perhaps cumulative frequencies.

Let me sort the a_i's in non-decreasing order.

Then, compute prefix sums.

Let prefix[a] be the number of sticks with a_i <= a.

Then, for each a_j, the number of a_i <= a_j is prefix[a_j].

The number of a_k <= a_j to the right of j is prefix[a_j] - (j's position in the sorted list).

Wait, more precisely, in the sorted list, for each j, the number of a_k <= a_j to the right of j is the number of sticks with a_k <= a_j minus the number of sticks with a_k <= a_j up to j.

Wait, no.

Wait, in the sorted list, all sticks to the right of j have a_k >= a_j.

So, the only sticks to the right of j that have a_k <= a_j are those with a_k == a_j.

Therefore, the number of a_k == a_j to the right of j is freq[a_j] - number of a_j's up to j.

So, for each j where a_j == x, the number of a_k == x to the right is freq[x] - number of x's up to j.

Then, the number of ways for each j is (number of a_i <= x) * (freq[x] - number of x's up to j).

But this seems inefficient for large n.

I need a better way.

Let me consider that for any three sticks with a_i <= a_j <= a_k and a_k <= a_j, which implies a_k <= a_j.

But a_k >= a_j since the list is sorted, so a_k == a_j.

Therefore, the only way to form a triangle is to have a_k == a_j.

Therefore, for each group of sticks with the same a_i = x, the number of ways is C(freq[x], 3).

Additionally, for different groups, if a_i <= a_j and a_k == a_j, then for each pair (a_i, a_j) where a_i <= a_j, and a_k == a_j, the number of ways is freq[a_i] * freq[a_j] choose 2.

Wait, perhaps it's better to compute the total number of triplets where a_k == a_j, and a_i <= a_j.

So, for each a_j, the number of a_i <= a_j is prefix[a_j], and the number of a_k == a_j is freq[a_j] - 1 (since k > j).

But this seems tricky.

Let me think about it differently.

Suppose I sort the a_i's in non-decreasing order.

Then, for each a_j, the number of valid a_i's is j (since a_i <= a_j), and the number of valid a_k's is the number of a_k == a_j to the right of j.

Since the list is sorted, the number of a_k == a_j to the right of j is freq[a_j] - number of a_j's up to j.

So, for each j where a_j == x, letâ€™s say the total freq[x], and the number of a_j's up to j is the position in the group.

Wait, perhaps it's better to iterate through the sorted a_i's and for each a_j, keep track of how many a_j's have been seen so far.

Let me try to formalize this.

Letâ€™s sort the a_i's in non-decreasing order.

Let freq[x] be the frequency of x in a_i's.

For each x, the number of ways to choose a_j == x, a_i <= x, and a_k == x to the right of j.

So, for each x, the number of ways is freq[x] * (prefix[x] - 1) * (freq[x] - 1) / 2.

Wait, perhaps not.

Let me think about it differently.

Total number of valid triplets is the sum over j of (number of a_i <= a_j) * (number of a_k == a_j to the right of j).

Which is sum over j of j * (freq[a_j] - number of a_j's up to j).

Wait, this seems complicated.

Let me consider that for each group of a_j == x, the number of ways is C(freq[x], 3) + sum over y < x of freq[y] * C(freq[x], 2).

Because for each triplet where a_i <= a_j and a_k == a_j, it's either all three have a_j == x, or a_i has a different value less than x, and a_k has a_j == x.

Wait, perhaps inclusion.

Let me see.

Total number of valid triplets is sum over x of [C(freq[x], 3) + sum over y < x of freq[y] * C(freq[x], 2)].

This seems correct.

Because for each x, we can choose three sticks with a_i = a_j = a_k = x, which is C(freq[x], 3).

Plus, for each y < x, we can choose a_i with a_i = y, and a_j = a_k = x.

The number of such triplets is freq[y] * C(freq[x], 2).

So, the total number of valid triplets is sum over x of [C(freq[x], 3) + sum over y < x of freq[y] * C(freq[x], 2)].

This seems correct based on the sample input.

In the first sample, all a_i are 1, so freq[1] = 7.

Then, C(7,3) = 35, which matches the sample output.

In the second sample, a_i =1,2,3,3.

Sorted:1,2,3,3.

freq[1]=1, freq[2]=1, freq[3]=2.

So, C(1,3) = 0.

C(2,3) = 1.

Sum over y < 3 of freq[y] * C(2,2) = (freq[1] + freq[2]) * 1 = (1 + 1) * 1 = 2.

Total: 0 + 1 + 2 = 3.

But the sample output is 2.

Wait, perhaps I miscounted.

Wait, C(3,3) = 1 for x=3.

Sum over y < 3 of freq[y] * C(2,2) = (freq[1] + freq[2]) * 1 = 2.

Total: 1 + 2 = 3.

But sample output is 2.

Hmm, discrepancy here.

Wait, perhaps I miscounted C(freq[x],3).

Wait, freq[3]=2, so C(2,3)=0, not 1.

Wait, yes, C(2,3)=0.

So, total is sum over x of [C(freq[x],3) + sum over y < x of freq[y] * C(freq[x],2)].

For x=1: C(1,3)=0.

For x=2: C(1,3)=0 + freq[1] * C(1,2)=1*0=0.

For x=3: C(2,3)=0 + (freq[1] + freq[2]) * C(2,2)=(1+1)*1=2.

Total: 0 + 0 + 2 = 2, which matches the sample.

Great, so the formula is:

Total = sum over x of [C(freq[x],3) + sum over y < x of freq[y] * C(freq[x],2)].

Now, I need to implement this efficiently.

Given that n can be up to 3*10^5 and t up to 10^4, but sum of n over t is up to 3*10^5, I need an O(n log n) solution per test case.

First, sort the a_i's.

Then, compute freq[x] for each x.

Then, for each x, compute C(freq[x],3).

Also, compute sum over y < x of freq[y] * C(freq[x],2).

To do this efficiently, I can compute a prefix sum of freq[y] up to x.

Wait, more precisely, compute a cumulative sum of freq[y] up to x-1, and multiply by C(freq[x],2).

But C(freq[x],2) is freq[x]*(freq[x]-1)/2.

So, for each x, add C(freq[x],3) to the total.

Then, add (prefix_sum[x-1]) * C(freq[x],2) to the total.

Where prefix_sum[x-1] is the sum of freq[y] for y < x.

To compute this efficiently, I can iterate through x in sorted order, keeping a running sum of freq[y].

Given that a_i can be up to n, which is up to 3*10^5, I can use a list of size n+1 to store freq[x].

So, in code, I can do:

- Read t.

- For each test case:

- Read n.

- Read a_1 to a_n.

- If n < 3, output 0.

- Else:

- Sort a_i's.

- Compute freq[x] for x from 0 to n.

- Initialize prefix_sum = 0.

- Initialize total = 0.

- For x from min_a to max_a:

- total += C(freq[x],3).

- total += prefix_sum * C(freq[x],2).

- prefix_sum += freq[x].

- Print total.

But need to make sure that x starts from the minimum a_i.

Wait, in the code, it's better to iterate x from 0 to n, and keep track of freq[x].

But to optimize, since a_i can be up to n, which is up to 3*10^5, using a list of size n+1 is acceptable.

Also, since sum of n over t is 3*10^5, this should be efficient enough.

Now, implement C(freq[x],3) and C(freq[x],2).

C(m,3) = m*(m-1)*(m-2)/6.

C(m,2) = m*(m-1)/2.

Implement these using integer division to avoid floating points.

Edge cases to consider:

- n < 3: output 0.

- All a_i are equal: C(freq[x],3).

- freq[x] < 3: C(freq[x],3) = 0.

- x with freq[x] == 0: skip.

- x with freq[x] == 1: C(1,3)=0, C(1,2)=0.

Implement prefix_sum correctly, starting from x=min_a.

Wait, no, iterate x from 0 to n, and accumulate prefix_sum.

But to optimize, start from the minimum x where freq[x] > 0.

In the code, to save time, iterate x from 0 to n, but only process x with freq[x] > 0.

But since n can be up to 3*10^5, and sum of n over t is 3*10^5, it's acceptable.

Now, look at the given code and see if it implements this logic.

Looking at the given code:

def func():

t = int(input())

buffer = []

for i in range(t):

n = int(input())

w = [int(k) for k in input().split()]

if n >= 3:

q = [0 for j in range(n + 1)]

for j in range(n):

q[w[j]] += 1

eta = []

for j in range(n + 1):

if q[j] > 0:

eta.append(j)

eta_ln = len(eta)

rho = q[eta[0]]

if eta_ln == 1:

print(n * (n - 1) * (n - 2) // 6)

else:

res = q[eta[0]] * (q[eta[0]] - 1) * (q[eta[0]] - 2) // 6

for j in range(1, eta_ln):

res += q[eta[j]] * (q[eta[j]] - 1) * (q[eta[j]] - 2) // 6

res += q[eta[j]] * (q[eta[j]] - 1) // 2 * rho

rho += q[eta[j]]

print(res)

else:

print(0)

So, in this code:

- It reads t, then for each test case, reads n and the list w.

- If n >= 3:

- It counts frequency of each a_i in q[0 to n].

- It creates a list eta of x where freq[x] > 0.

- If there's only one x, it's C(n,3).

- Else, it initializes res with C(freq[eta[0]],3).

- Then, for each x in eta[1:], it adds C(freq[x],3) plus (freq[x]*(freq[x]-1)//2) * rho.

- Where rho accumulates freq[eta[j]] for j from 0 to current.

Wait, rho starts with q[eta[0]], and then in the loop, rho += q[eta[j]] for j from 1 to eta_ln-1.

So, rho is the cumulative sum of freq[eta[j]] up to the current j.

Wait, but in our earlier reasoning, prefix_sum is the sum of freq[y] for y < x.

In this code, rho seems to be the cumulative sum up to the current x.

Wait, let's see.

In the loop:

for j in range(1, eta_ln):

res += q[eta[j]] * (q[eta[j]] - 1) * (q[eta[j]] - 2) // 6

res += q[eta[j]] * (q[eta[j]] - 1) // 2 * rho

rho += q[eta[j]]

So, rho starts with q[eta[0]], which is freq[eta[0]].

Then, for each j starting from 1:

res += C(freq[eta[j]],3)

res += (freq[eta[j]] choose 2) * rho

rho += freq[eta[j]]

So, rho is accumulating freq[eta[0]] + freq[eta[1]] + ... up to eta[j].

But in our earlier reasoning, prefix_sum should be the sum of freq[y] for y < x.

In this code, rho includes freq[eta[j]] itself, because it's added before using it in the res += ... * rho.

Wait, perhaps it's including freq[eta[j]] in rho, which shouldn't be the case because a_k should be to the right of j, meaning a_k > j, but in sorted list, a_k >= a_j.

Wait, perhaps I'm misunderstanding.

Wait, perhaps rho is supposed to represent the sum of freq[y] for y < x.

In the code, rho starts with q[eta[0]], and then for each subsequent eta[j], rho is incremented by q[eta[j]].

But in the res += ... * rho, rho includes q[eta[j]], which might not be correct.

Wait, in our earlier reasoning, prefix_sum[x-1] is the sum of freq[y] for y < x.

So, for each x, res += C(freq[x],3) + prefix_sum[x-1] * C(freq[x],2).

In the code, for j starting from 1:

res += C(q[eta[j]],3)

res += C(q[eta[j]],2) * rho

where rho is the sum of q[eta[k]] for k from 0 to j-1.

Which matches prefix_sum[x-1].

Wait, but in the code, rho starts with q[eta[0]], and then for each j from 1 to eta_ln-1, rho += q[eta[j]].

Wait, no, in the loop, rho is incremented after adding to res.

So, initially, rho = q[eta[0]]

for j from 1 to eta_ln-1:

res += C(q[eta[j]],3)

res += C(q[eta[j]],2) * rho

rho += q[eta[j]]

So, for j=1:

res += C(q[eta[1]],3)

res += C(q[eta[1]],2) * q[eta[0]]

rho += q[eta[1]]

for j=2:

res += C(q[eta[2]],3)

res += C(q[eta[2]],2) * (q[eta[0]] + q[eta[1]])

rho += q[eta[2]]

and so on.

Which matches our formula:

Total = sum over x of [C(freq[x],3) + sum over y < x of freq[y] * C(freq[x],2)]

Because for each x, sum over y < x of freq[y] * C(freq[x],2) is prefix_sum[x-1] * C(freq[x],2).

And prefix_sum[x] is the sum of freq[y] for y < x.

So, yes, the code correctly implements this.

In the special case where eta_ln == 1, meaning all a_i are the same, it's simply C(n,3).

Otherwise, it iterates through eta and accumulates the result as described.

Therefore, the given program is correct.

**Final Answer**

\[ \boxed{\text{See explanation for correctness.}} \]

**Correctness: True**