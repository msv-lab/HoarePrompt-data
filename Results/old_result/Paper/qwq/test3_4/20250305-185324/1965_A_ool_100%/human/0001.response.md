Alright, I've got this problem to solve. It's about a game that Alice and Bob are playing with piles of stones. The rules are a bit unusual. Instead of just taking stones from one pile, they have to choose a number k and remove k stones from every non-empty pile at once. The player who can't make a move because all piles are empty loses. Alice goes first, and both play optimally. I need to figure out who wins each game based on the initial configuration of the piles.

First, I need to understand the game mechanics properly. So, in each turn, a player chooses a positive integer k, which has to be at most the size of the smallest non-empty pile. Then, they remove k stones from each non-empty pile. This is different from standard Nim games where you take stones from just one pile.

Let me think about what this operation does. If I have piles of sizes say, 3, 3, 3, and I choose k=1, then all piles become 2,2,2. If I choose k=2, they become 1,1,1. If I choose k=3, they all become empty. So, choosing a larger k affects all piles simultaneously.

I need to see what the possible moves are and how the game progresses. It seems like the game state changes in a way that's similar to subtracting the same amount from multiple variables simultaneously.

I recall that in game theory, such games can often be analyzed using the concept of Nimbers or the mex function, but I'm not sure if that directly applies here.

Let me consider some small examples to see if I can find a pattern.

Take the first test case: 5 piles, each with 3 stones.

So, piles: 3,3,3,3,3.

Alice can choose k from 1 to 3.

If she chooses k=1, all piles become 2,2,2,2,2.

Then Bob can choose k=1 again, making them 1,1,1,1,1.

Alice then chooses k=1, making them all empty. So Alice wins.

Wait, but according to the example, Alice can win immediately by choosing k=3, emptying all piles at once. So she wins in one move.

Okay, that's straightforward when all piles are equal.

Second test case: 2 piles, 1 and 7.

Alice must choose k=1 (since the smallest pile has 1 stone).

After she removes 1 stone from each pile, the piles become 0 and 6.

Now, Bob chooses k up to 6 (the smallest non-empty pile is 6).

He chooses k=6, removes 6 stones from the pile of 6, making it 0.

Now, all piles are empty, so Bob wins.

So, in this case, Alice is forced into a position where Bob can win.

Third test case: 7 piles with sizes 1,3,9,7,4,2,100.

This seems more complex. Let's see.

Alice can choose k up to 1 (the smallest pile is 1).

So, she has to choose k=1.

After removing 1 from each non-empty pile, the piles become: 0,2,8,6,3,1,99.

Now, Bob looks at the non-empty piles: 2,8,6,3,1,99.

Smallest is 1, so he chooses k=1.

Piles become: 1,7,5,2,0,98.

Alice looks at 1,7,5,2,98.

Smallest is 1, chooses k=1.

Piles become: 0,6,4,1,97.

Bob looks at 6,4,1,97.

Smallest is 1, chooses k=1.

Piles become: 5,3,0,96.

Alice looks at 5,3,96.

Smallest is 3, can choose k=1 or 2 or 3.

If she chooses k=3, piles become 2,0,93.

Bob looks at 2 and 93.

Chooses k=2, removes 2 from both, making them 0 and 91.

Alice then chooses k up to 91, removes 91 from the remaining pile, making it empty.

So, Alice wins again.

Wait, but according to the example output, Alice wins this game.

But in the second test case, Bob wins.

I need to find a general strategy that can be applied to any configuration of piles.

Let me think about the game in terms of the number of stones in the piles.

I notice that in the first test case, all piles are equal, and Alice can win by choosing k equal to the pile size.

In the second test case, piles are different, and Alice is forced to make a move that allows Bob to win.

In the third test case, it's a bit more involved, but Alice eventually wins.

I need to find a way to generalize this.

Perhaps I can think about the minimal excludant (mex) or the maximum value that cannot be chosen.

Wait, maybe I should think in terms of the mex of the possible moves.

But I'm not sure.

Let me consider the game as a subtraction game where the subtraction is applied to all piles simultaneously.

This seems similar to a variant of Nim where all piles are reduced by the same amount.

Wait, this is reminiscent of the game of Nim with a twist.

In standard Nim, players choose one pile and remove any number of stones from it.

Here, the move is to choose k and remove k stones from all non-empty piles.

I need to find the Grundy number or Nimber for this game to determine who has a winning strategy.

But calculating Grundy numbers for large pile sizes (up to 1e9) is not feasible directly.

I need a smarter approach.

Let me consider the sequence of moves.

Each move reduces all non-empty piles by the same amount k.

This is similar to cutting the same amount from all piles and seeing when piles become empty.

This seems like the game progresses in steps where the piles are being reduced uniformly.

I recall something about the mex in impartial games.

Wait, perhaps I can think of the game as equivalent to a single pile of a certain size.

But I'm not sure.

Let me think differently.

Suppose I sort the piles in ascending order.

Let's say the piles are a1 <= a2 <= ... <= an.

Each move consists of choosing k <= a1 and subtracting k from all ai > 0.

I need to see what the game tree looks like and find a way to determine the winner without simulating the entire game.

This seems too slow for n up to 2e5 per test case and t up to 1e4.

I need a mathematical insight here.

Let me think about the minimal pile.

Since k cannot exceed the smallest pile, the smallest pile imposes a limit on k.

If the smallest pile is 1, then k=1 is the only choice for the first move.

After removing k=1 from all piles, all piles are reduced by 1, and any pile that was 1 becomes empty.

So, the remaining piles are those that were greater than 1, each reduced by 1.

This process repeats until all piles are empty.

I need to see if there is a pattern or a mathematical formula that can determine the winner based on the initial pile sizes.

Let me consider the number of piles and their sizes.

Suppose all piles have the same size. Then, the first player can choose k equal to the pile size and win immediately.

But in the general case, piles have different sizes.

I need to find a way to handle different pile sizes.

Wait, maybe I can think about the number of times we can reduce the piles before they all become empty.

But it's not that simple because the choice of k affects all piles at once.

Let me consider the minimal excludant concept.

In standard Nim, the XOR of pile sizes determines the winner.

But here, since moves affect all piles simultaneously, it's different.

I need to find the Grundy function for this game.

Let me try to compute the Grundy number for small configurations.

Consider a single pile:

- Pile of size 1: Alice chooses k=1, removes 1 stone, piles become empty. Alice wins.

- Pile of size 2: Alice chooses k=1, piles become 1. Bob chooses k=1, piles become empty. Bob wins.

- Pile of size 3: Alice chooses k=1, piles become 2. Bob chooses k=1, piles become 1. Alice chooses k=1, piles become empty. Alice wins.

- Pile of size 4: Alice chooses k=1, piles become 3. Bob chooses k=1, piles become 2. Alice chooses k=1, piles become 1. Bob chooses k=1, piles become empty. Bob wins.

So, for single piles:

- Size 1: Alice wins

- Size 2: Bob wins

- Size 3: Alice wins

- Size 4: Bob wins

It seems like for odd sizes, Alice wins; for even sizes, Bob wins.

Wait, but in the second test case, with two piles of 1 and 7, Bob wins, which doesn't fit this pattern.

Wait, perhaps this only applies to single piles.

Let me consider two piles.

Two piles: 1 and 7.

Alice must choose k=1, making piles 0 and 6.

Then Bob chooses k=6, making piles 0 and 0. Bob wins.

Another example: two piles of 2 and 2.

Alice can choose k=2, making both piles 0. Alice wins.

Two piles: 1 and 2.

Alice chooses k=1, making piles 0 and 1.

Bob chooses k=1, making piles 0 and 0. Bob wins.

So, for two piles:

- Both even: Alice wins by choosing k equal to the smaller pile.

- One odd, one even: Bob wins.

- Both odd: ?

Wait, in the first example, 1 and 7: both odd, Bob wins.

In the third test case: piles 1,3,9,7,4,2,100: mixed odd and even, Alice wins.

This is getting complicated.

Maybe I need to think differently.

I recall that in games where moves affect multiple independent components, the game can be decomposed into its components, and the overall game is the XOR of the individual games.

But in this case, moves affect all piles simultaneously, so the piles are not independent.

This makes it different from standard Nim.

I need to find a way to model this dependency.

Wait, perhaps I can think of the game as equivalent to a single pile of a certain size.

But I'm not sure.

Let me consider the sorted list of pile sizes.

Suppose I sort the piles in ascending order: a1 <= a2 <= ... <= an.

Each move consists of subtracting k from a1, a2, ..., an until some ai becomes zero.

This seems similar to the game of Euclidean algorithm, where you subtract the smaller number from the larger one.

Wait, perhaps there's a connection there.

But I'm not sure.

Let me think about the number of moves required to empty all piles.

Each move reduces all non-empty piles by k.

So, the total number of moves is equal to the number of times you can subtract the smallest non-empty pile from all non-empty piles until all are empty.

This seems related to the mex or something similar.

But I need a way to compute who wins based on this.

Let me consider the parity of the number of moves.

If the number of moves is odd, Alice wins; if even, Bob wins.

Wait, in the single pile case:

- Size 1: 1 move (Alice wins)

- Size 2: 2 moves (Bob wins)

- Size 3: 3 moves (Alice wins)

- Size 4: 4 moves (Bob wins)

This matches the earlier observation.

In the two piles case:

- 1 and 7: Alice chooses k=1, then Bob chooses k=6. Total moves: 2 (Bob wins)

- 2 and 2: Alice chooses k=2. Total moves: 1 (Alice wins)

- 1 and 2: Alice chooses k=1, then Bob chooses k=1. Total moves: 2 (Bob wins)

This seems consistent.

So, perhaps the total number of moves determines the winner.

If the total number of moves is odd, Alice wins; if even, Bob wins.

But I need to confirm this with the third test case.

Third test case: 1,3,9,7,4,2,100.

Total moves: let's see.

First move: k=1, piles become 0,2,8,6,3,1,99.

Second move: k=1, piles become 0,1,7,5,2,0,98.

Third move: k=1, piles become 0,0,6,4,1,0,97.

Fourth move: k=1, piles become 0,0,5,3,0,0,96.

Fifth move: k=1, piles become 0,0,4,2,0,0,95.

Sixth move: k=1, piles become 0,0,3,1,0,0,94.

Seventh move: k=1, piles become 0,0,2,0,0,0,93.

Eighth move: k=1, piles become 0,0,1,0,0,0,92.

Ninth move: k=1, piles become 0,0,0,0,0,0,91.

Total moves: 9, which is odd, so Alice wins.

This matches the sample output where Alice wins.

Similarly, in the second test case, total moves: 2 (even), Bob wins.

So, this seems to hold.

Therefore, the strategy is to determine the total number of moves required to empty all piles. If this number is odd, Alice wins; if even, Bob wins.

Now, I need to find an efficient way to compute the total number of moves for each test case, given that n can be up to 2e5 and t up to 1e4, with the sum of n over all test cases up to 2e5.

Time constraints are tight, so I need an O(n log n) solution per test case, or better.

Let me see how to compute the total number of moves.

Each move consists of choosing k equal to the current smallest non-empty pile and subtracting k from all non-empty piles.

This is similar to removing layers of stones where each layer is of thickness k, equal to the smallest pile's current size.

The total number of such layers is equal to the number of distinct non-zero pile sizes.

Wait, is that correct?

Wait, no.

Wait, consider piles: 1,2,3.

First move: k=1, piles become 0,1,2.

Second move: k=1, piles become 0,0,1.

Third move: k=1, piles become 0,0,0.

Total moves: 3.

But the number of distinct non-zero pile sizes is 3 (1,2,3).

Similarly, piles: 1,1,2.

First move: k=1, piles become 0,0,1.

Second move: k=1, piles become 0,0,0.

Total moves: 2.

Number of distinct non-zero pile sizes is 2 (1,2).

Wait, this seems to hold.

Piles: 1,3,9,7,4,2,100.

Distinct non-zero pile sizes: 1,2,3,4,7,9,100. That's 7, which matches the earlier simulation where total moves were 9, but that doesn't match.

Wait, in the simulation, total moves were 9, but distinct pile sizes are 7.

So, my hypothesis is wrong.

Wait, perhaps it's the number of times the minimal pile changes.

Let me think again.

In the first test case: 3,3,3.

Distinct pile sizes: 3.

Moves: 1 (Alice chooses k=3, all piles empty).

So, number of distinct pile sizes is 1, and total moves are 1.

Second test case: 1,7.

Distinct pile sizes: 2.

Moves: 2 (Alice chooses k=1, then Bob chooses k=6).

Third test case: 1,3,9,7,4,2,100.

Distinct pile sizes: 1,2,3,4,7,9,100. That's 7.

But in simulation, total moves were 9.

So, it's not equal to the number of distinct pile sizes.

Wait, perhaps it's the sum of differences between consecutive distinct pile sizes.

Wait, in the third test case, sorted distinct pile sizes: 1,2,3,4,7,9,100.

Differences: 1,1,1,3,2,91.

Sum of differences: 1+1+1+3+2+91=99.

But total moves were 9, so that doesn't match.

Wait, perhaps it's the number of times the minimal pile changes.

In the third test case:

Move 1: k=1, piles become 0,2,8,6,3,1,99.

Minimal non-zero pile is 1.

Move 2: k=1, piles become 0,1,7,5,2,0,98.

Minimal non-zero pile is 1.

Move 3: k=1, piles become 0,0,6,4,1,0,97.

Minimal non-zero pile is 1.

Move 4: k=1, piles become 0,0,5,3,0,0,96.

Minimal non-zero pile is 3.

Move 5: k=3, piles become 0,0,2,0,0,0,93.

Minimal non-zero pile is 2.

Move 6: k=2, piles become 0,0,0,0,0,0,91.

Minimal non-zero pile is 91.

Move 7: k=91, piles become all zeros.

Total moves: 7.

Wait, but earlier I simulated 9 moves. Maybe I made a mistake in the simulation.

Wait, let's try simulating again.

Initial piles: 1,3,9,7,4,2,100.

Move 1: k=1, piles become 0,2,8,6,3,1,99.

Move 2: k=1, piles become 0,1,7,5,2,0,98.

Move 3: k=1, piles become 0,0,6,4,1,0,97.

Move 4: k=1, piles become 0,0,5,3,0,0,96.

Move 5: k=1, piles become 0,0,4,2,0,0,95.

Move 6: k=1, piles become 0,0,3,1,0,0,94.

Move 7: k=1, piles become 0,0,2,0,0,0,93.

Move 8: k=1, piles become 0,0,1,0,0,0,92.

Move 9: k=1, piles become 0,0,0,0,0,0,91.

So, total moves: 9.

But according to the distinct pile sizes, there are 7 distinct sizes: 1,2,3,4,7,9,100.

But total moves are 9, which is more than 7.

So, my hypothesis is incorrect.

Wait, perhaps it's the sum of the differences between consecutive distinct pile sizes.

In the third test case:

Distinct pile sizes: 1,2,3,4,7,9,100.

Differences: 1,1,1,3,2,91.

Sum of differences: 1+1+1+3+2+91=99.

But total moves are 9, which doesn't match.

This is confusing.

Let me think differently.

Each move reduces all non-empty piles by k.

So, the total number of moves is equal to the number of times we can subtract the smallest non-empty pile until all piles are empty.

This seems similar to the number of elements in the sorted list minus the number of times consecutive elements are equal.

Wait, perhaps it's the number of times the minimal pile changes.

In the third test case:

- Piles: 1,3,9,7,4,2,100

- Sorted: 1,2,3,4,7,9,100

- Minimal pile changes at each distinct value.

- But total moves are 9, which is more than the number of distinct values.

Wait, maybe it's the sum of ceiling(ai / k) for some k.

But I'm lost.

Let me look for a different approach.

I found that in such games, the total number of moves is equal to the number of stones in the smallest pile plus the number of piles that are larger than the smallest pile.

But that doesn't seem to fit.

Wait, perhaps it's the sum of the pile sizes minus the minimum pile size times the number of piles.

But in the first test case, piles are all 3, so sum is 15, minus 3*5=15, so 0 moves, which is wrong.

No.

I need to think differently.

Let me consider that each move reduces all non-empty piles by k.

So, the total number of moves is equal to the sum of pile sizes divided by the sum of k's chosen, but that doesn't help.

Wait, perhaps I can think of the game as a sequence of moves where in each move, k is chosen based on the current smallest pile.

So, if I sort the piles in ascending order: a1 <= a2 <= ... <= an.

Then, the first move is k=a1, reduces all piles by a1.

The second move is k=a2 - a1, reduces all remaining piles by that amount.

And so on.

Wait, let's see.

In the third test case:

Sorted piles: 1,2,3,4,7,9,100.

First move: k=1, piles become 0,1,2,3,6,8,99.

Second move: k=1, piles become 0,0,1,2,5,7,98.

Third move: k=1, piles become 0,0,0,1,4,6,97.

Fourth move: k=1, piles become 0,0,0,0,3,5,96.

Fifth move: k=3, piles become 0,0,0,0,0,2,93.

Sixth move: k=2, piles become 0,0,0,0,0,0,91.

Seventh move: k=91, piles become all zeros.

Total moves: 7.

Wait, earlier I simulated 9 moves, but now it's 7.

I must have made a mistake in the initial simulation.

Let me try again.

Starting with sorted piles: 1,2,3,4,7,9,100.

Move 1: k=1, piles become 0,1,2,3,6,8,99.

Move 2: k=1, piles become 0,0,1,2,5,7,98.

Move 3: k=1, piles become 0,0,0,1,4,6,97.

Move 4: k=1, piles become 0,0,0,0,3,5,96.

Move 5: k=3, piles become 0,0,0,0,0,2,93.

Move 6: k=2, piles become 0,0,0,0,0,0,91.

Move 7: k=91, piles become all zeros.

Total moves: 7.

Wait, earlier I thought it was 9 moves, but actually it's 7.

So, perhaps the total number of moves is equal to the number of distinct non-zero pile sizes.

In this case, distinct sizes are 1,2,3,4,7,9,100: 7 sizes, 7 moves.

In the first test case: all piles are 3, distinct sizes: 1 (only 3), moves:1.

Second test case: 1 and 7, distinct sizes:2 (1 and 7), moves:2.

Another example: piles 1,1,2.

Distinct sizes:2 (1 and 2), moves:2.

Yes, this seems consistent.

So, the total number of moves is equal to the number of distinct non-zero pile sizes.

Therefore, to determine the winner, we just need to find the number of distinct non-zero pile sizes after sorting and removing duplicates.

If this number is odd, Alice wins; if even, Bob wins.

This seems to be a efficient way to compute the winner.

Now, I need to implement this logic.

Given that t can be up to 1e4 and n up to 2e5 per test case, with the sum of n over all test cases up to 2e5, I need an efficient solution.

For each test case, I can read n and the pile sizes, sort them, remove duplicates, count the number of distinct non-zero pile sizes, and determine the winner based on the parity of this count.

Wait, but I need to be careful because pile sizes can be up to 1e9, but since I'm only interested in the distinct values, I can sort and remove duplicates efficiently.

Let me outline the steps:

1. Read the number of test cases t.

2. For each test case:

a. Read n.

b. Read the array of n pile sizes.

c. Sort the array.

d. Remove duplicates.

e. Count the number of distinct non-zero pile sizes.

f. If the count is odd, Alice wins; if even, Bob wins.

This should be efficient enough, as sorting 2e5 elements is feasible, and removing duplicates is straightforward.

I can optimize it further by noting that sorting and removing duplicates can be done in one step using a set, but since piles can be large, using a set might not be efficient in terms of time.

Wait, in Python, converting a list to a set is O(n), but sorting is O(n log n).

Given that n can be up to 2e5, I need an efficient implementation.

But since the problem constraints allow it, this should be acceptable.

Let me think about edge cases.

Edge case 1: n=1, pile size=1.

- Distinct non-zero pile sizes:1

- Odd, Alice wins.

Edge case 2: n=1, pile size=2.

- Distinct non-zero pile sizes:1

- Odd, Alice wins.

Edge case 3: n=2, pile sizes=1,1.

- Distinct non-zero pile sizes:1

- Odd, Alice wins.

Edge case 4: n=2, pile sizes=1,2.

- Distinct non-zero pile sizes:2

- Even, Bob wins.

Edge case 5: n=3, pile sizes=0,0,0.

- Distinct non-zero pile sizes:0

- Even, Bob wins.

Wait, but piles are initially with at least 1 stone, so no zeros initially.

But if piles become zero, that's fine.

Wait, in the input, a_i >=1, as per the problem statement.

So, no need to worry about initial zeros.

Another edge case: n=1, a1=1e9.

- Distinct non-zero pile sizes:1

- Odd, Alice wins.

Another edge case: n=2, a1=1, a2=1e9.

- Distinct non-zero pile sizes:2

- Even, Bob wins.

Seems consistent.

So, I can proceed with this approach.

Now, I need to implement this in code.

I need to read t test cases, each consisting of n and then n pile sizes.

For each test case, sort the pile sizes, remove duplicates, count the number of distinct non-zero pile sizes, and determine the winner based on the parity of this count.

Given that t can be up to 1e4 and n up to 2e5, with sum of n over all test cases up to 2e5, I need to read input efficiently.

In Python, reading input using sys.stdin.readline is faster.

I can read all input at once and process it.

But for simplicity, I can read each test case one by one.

Let me sketch the code structure.

From the given code:

import heapq

import sys

input = sys.stdin.readline

t = int(input())

c = 1

while t > 0:

n = list(map(int, input().rstrip().split()))

arr = list(map(int, input().rstrip().split()))

r = func_1(arr)

print(r)

t -= 1

def func_1(arr):

A = False

set_ = list(set(arr))

set_.sort()

if set_[0] != 1:

return 'Alice'

not_c = True

for i in range(1, len(set_)):

if set_[i] - set_[i - 1] > 1:

not_c = False

break

A = not A

if not_c:

A = not A

return 'Alice' if A else 'Bob'

This code seems to be attempting something similar, but it's not entirely correct.

In the func_1 function, it checks if the smallest pile is not 1, and if so, returns 'Alice'.

Otherwise, it checks if the pile sizes form a consecutive sequence.

If they do, it toggles A based on the number of elements.

This seems incorrect based on my earlier reasoning.

I think the correct approach is to sort the pile sizes, remove duplicates, count the number of distinct non-zero pile sizes, and determine the winner based on the parity of this count.

So, I need to adjust the func_1 function accordingly.

Here's the corrected func_1 function:

def func_1(arr):

distinct_piles = sorted(set(arr))

count = len(distinct_piles)

if count % 2 == 1:

return 'Alice'

else:

return 'Bob'

This should work.

Let me test it with the sample input.

Sample Input:

7

5

3 3 3 3 3

2

1 7

7

1 3 9 7 4 2 100

3

1 2 3

6

2 1 3 4 2 4

8

5 7 2 9 6 3 3 2

1

1000000000

Sample Output:

Alice

Bob

Alice

Alice

Bob

Alice

Alice

Let's verify with my function.

First test case: 5 piles of 3.

Distinct piles: 1 (3)

Count:1 (odd) -> Alice

Second test case: 2 piles, 1 and 7.

Distinct piles:2 (1,7)

Count:2 (even) -> Bob

Third test case:7 piles, 1,3,9,7,4,2,100

Distinct piles:7 (1,2,3,4,7,9,100)

Count:7 (odd) -> Alice

Fourth test case:3 piles,1,2,3

Distinct piles:3 (1,2,3)

Count:3 (odd) -> Alice

Fifth test case:6 piles,2,1,3,4,2,4

Distinct piles:4 (1,2,3,4)

Count:4 (even) -> Bob

Sixth test case:8 piles,5,7,2,9,6,3,3,2

Distinct piles:6 (2,3,5,6,7,9)

Count:6 (even) -> Bob

Seventh test case:1 pile,1000000000

Distinct piles:1 (1000000000)

Count:1 (odd) -> Alice

Wait, in the sample output, the sixth test case is "Alice", but according to my function, it should be "Bob".

Wait, perhaps I made a mistake in determining the number of distinct piles.

Wait, for the sixth test case: piles=5,7,2,9,6,3,3,2

Sorted unique piles:2,3,5,6,7,9 -> 6 distinct piles

6 is even -> Bob wins

But in the sample output, it's "Alice".

So, there's a discrepancy.

Wait, perhaps my earlier assumption is wrong.

Let me re-simulate the sixth test case.

Piles:5,7,2,9,6,3,3,2

Sorted:2,2,3,3,5,6,7,9

Distinct:2,3,5,6,7,9

Total distinct:6

According to my function, Bob wins, but sample output is "Alice".

So, my function is incorrect for this test case.

Wait, perhaps I need to consider the number of moves more carefully.

Let me simulate the sixth test case.

Piles:2,2,3,3,5,6,7,9

Move 1: k=2, piles become 0,0,1,1,3,4,5,7

Move 2: k=1, piles become 0,0,0,0,2,3,4,6

Move 3: k=2, piles become 0,0,0,0,0,1,2,4

Move 4: k=1, piles become 0,0,0,0,0,0,1,3

Move 5: k=1, piles become 0,0,0,0,0,0,0,2

Move 6: k=2, piles become all zeros.

Total moves:6, which is even, so Bob wins.

But according to the sample output, Alice wins.

So, there's a mistake in my earlier assumption.

Wait, in my simulation, total moves are 6, which is even, so Bob wins.

But sample output says "Alice".

So, either the sample output is incorrect, or my simulation is wrong.

Wait, perhaps I missed something in the simulation.

Let's simulate again.

Piles:2,2,3,3,5,6,7,9

Move 1: k=2, piles become 0,0,1,1,3,4,5,7

Move 2: k=1, piles become 0,0,0,0,2,3,4,6

Move 3: k=2, piles become 0,0,0,0,0,1,2,4

Move 4: k=1, piles become 0,0,0,0,0,0,1,3

Move 5: k=1, piles become 0,0,0,0,0,0,0,2

Move 6: k=2, piles become all zeros.

Total moves:6, even, Bob wins.

But sample output says "Alice".

So, perhaps my assumption is wrong.

Wait, maybe the number of distinct pile sizes isn't equal to the number of moves.

Wait, in the third test case, distinct pile sizes are 7, but in my simulation, moves are 7.

In the sixth test case, distinct pile sizes are 6, moves are 6.

So, perhaps the number of moves is equal to the number of distinct pile sizes.

But in the simulation, moves are equal to the number of distinct pile sizes.

So, in the sixth test case, moves=6, which is even, Bob wins, but sample output says "Alice".

So, perhaps my simulation is wrong.

Wait, maybe I miscounted the moves.

Let's try again.

Piles:2,2,3,3,5,6,7,9

Move 1: k=2, piles become 0,0,1,1,3,4,5,7

Move 2: k=1, piles become 0,0,0,0,2,3,4,6

Move 3: k=2, piles become 0,0,0,0,0,1,2,4

Move 4: k=1, piles become 0,0,0,0,0,0,1,3

Move 5: k=1, piles become 0,0,0,0,0,0,0,2

Move 6: k=2, piles become all zeros.

Total moves:6, even, Bob wins.

But sample output is "Alice", so perhaps my assumption is incorrect.

Wait, maybe the number of moves isn't equal to the number of distinct pile sizes.

Perhaps I need to consider something else.

Wait, perhaps it's the number of times the minimal non-zero pile changes.

In the sixth test case:

Move 1: k=2, minimal non-zero pile was 2, now 0's and piles starting from 1.

Move 2: k=1, minimal non-zero pile was 1, now 0's and piles starting from 1.

Move 3: k=1, minimal non-zero pile was 1, now 0's and piles starting from 2.

Move 4: k=2, minimal non-zero pile was 2, now 0's and piles starting from 1.

Move 5: k=1, minimal non-zero pile was 1, now 0's and piles starting from 1.

Move 6: k=1, minimal non-zero pile was 1,