Alright, I have this problem to solve. It's about determining who wins in a game between Anna and Sasha based on their moves on a list of integers. Let's try to understand the problem step by step.

First, I need to grasp what the game is about. There are two players: Anna and Sasha. They take turns, and Anna goes first. The game involves a list of integers, and each player has specific actions they can take on their turn.

Anna's move: She chooses one element from the list and reverses its digits, removing any leading zeros. So, for example, if there's a number 42, she can reverse it to 24. If there's 1580, it becomes 851 after reversing.

Sasha's move: He chooses two different elements from the list, concatenates them in any order, and inserts the result back into the list. For instance, if he picks 2007 and 19, he can create either 200719 or 192007 and put that back into the list.

The game continues until there's only one number left in the list, and at that point, Sasha can't make a move because he needs two numbers to concatenate. Then, we check if the final number is at least 10^m. If it is, Sasha wins; otherwise, Anna wins.

My task is to determine, for multiple test cases, who will win if both players play optimally.

Okay, let's think about how to approach this.

First, I need to understand the game mechanics and how the players can influence the outcome.

Anna goes first and can reverse any one number in the list each time. Reversing a number can change its value, potentially making it smaller or larger.

Sasha, on his turn, combines two numbers into one by concatenating them, which usually makes a much larger number, depending on the order.

The game ends when there's only one number left, and based on its value, we decide the winner.

I need to find a way to simulate this game or find a pattern that can help determine the winner without simulating every possible move, as that would be inefficient, especially given the constraints (up to 10^4 test cases with up to 2*10^5 elements each).

Let me consider the game's properties.

The game always ends because with each of Sasha's moves, the number of elements in the list decreases by one (since he removes two and adds one). Anna's moves don't change the number of elements.

The game continues until there's only one element left.

Both players play optimally, meaning they make the best possible move to ensure their victory.

I need to find a way to determine the winner based on the initial list and the parameters given.

Let me consider some small examples to see if I can find a pattern.

Example 1:

n=2, m=2

a=[14, 2]

Anna can reverse 14 to 41 or reverse 2 to 2.

If she reverses 14 to 41, then Sasha can concatenate 41 and 2 to get 412 or 241, both greater than 100 (which is 10^2). So Sasha wins.

If she reverses 2 to 2, which is the same, Sasha can concatenate 2 and 14 to get 214 or 142, both greater than 100. So again, Sasha wins.

So in this case, Sasha wins.

Example 2:

n=3, m=5

a=[9,56,1]

Anna can choose to reverse any one of them.

Let's say she reverses 56 to 65.

Now the list is [9,65,1]

Sasha can choose to concatenate 9 and 65 to get 965 or 659, and add it back, making the list [659,1] or [965,1].

Then Anna reverses one of them.

This seems complicated. Maybe there's a better way.

Another approach: Think in terms of the number of moves.

Each of Sasha's moves reduces the number of elements by one because he removes two and adds one.

Anna's moves don't change the number of elements.

The game ends when there's only one element left, which means Sasha can't make a move.

So, the total number of Sasha's moves is (n-1), since starting from n elements, each Sasha's move reduces the count by one, until only one is left.

But Anna moves first, and then they alternate turns.

Wait, no. According to the problem, Anna moves first, then Sasha, then Anna, and so on.

But, I need to confirm the sequence.

"Players take turns. Sasha is a gentleman, so he gives Anna the right to make the first move."

So, Anna moves first.

Then Sasha, then Anna, and so on.

Wait, but in the first test case, Anna reverses one number, then Sasha concatenates two numbers, reducing the list by one.

Then, Anna reverses one number again, and so on, until only one element is left.

Wait, but in the first test case, after Anna's move, Sasha makes one move and the game ends.

Wait, with n=2, Anna reverses one number, then Sasha concatenates the two numbers, and that's the end.

So, with n=2, there are two moves: Anna's and Sasha's.

With n=3, there would be Anna, Sasha, Anna, Sasha, ending with one element after Sasha's move.

Wait, no.

Wait, with n=3:

- Anna reverses one number.

- Sasha concatenates two numbers, reducing the list to 2 elements.

- Anna reverses one number.

- Sasha concatenates the two numbers, reducing to 1 element.

So, total moves: Anna, Sasha, Anna, Sasha.

But according to the rules, the game ends when there's only one element left, at which point Sasha can't make a move.

Wait, but in this sequence, after Sasha's second move, there's one element left, so Sasha can't make a move, and the game ends.

Then, we check if the final number is at least 10^m.

So, in terms of the number of moves:

- The total number of Sasha's moves is (n-1), since each of his moves reduces the number of elements by one.

- Anna's moves are in between.

- The total number of moves is 2*(n-1), but interleaved.

Wait, no.

Wait, for n elements:

- Sasha can make (n-1) moves, each reducing the list by one element.

- Anna can make (n-1) moves as well, since she moves first and then alternates with Sasha.

Wait, but in the first test case with n=2:

- Anna reverses one number (first move).

- Sasha concatenates the two numbers (second move).

- Game ends with one number.

So, total moves: two moves, Anna and Sasha.

With n=3:

- Anna reverses one number.

- Sasha concatenates two numbers, reducing to 2 elements.

- Anna reverses one number.

- Sasha concatenates the two numbers, reducing to 1 element.

- Game ends.

Total moves: four moves, two Anna and two Sasha.

So, in general, for n elements, there are 2*(n-1) moves: Anna and Sasha each make (n-1) moves.

Wait, but in the first test case with n=2, Anna makes one move and Sasha makes one move, totaling two moves.

In n=3, Anna makes two moves and Sasha makes two moves, totaling four moves.

Wait, but in general, for n elements, Sasha makes (n-1) moves, each reducing the list by one, and Anna makes (n-1) moves, one before each of Sasha's moves and possibly one more if n is odd.

Wait, no.

Wait, with n elements, Anna makes n moves, and Sasha makes (n-1) moves.

Wait, let's think again.

Wait, perhaps it's better to think in terms of whose turn it is when the game ends.

The game ends when there's one element left, at which point Sasha can't make a move.

So, the last move is Anna's move, reversing one number.

Then, the final number is that one number left after Anna's move.

So, perhaps the winner depends on who makes the last move.

Wait, but in the first test case, with n=2, Anna reverses one number, then Sasha concatenates the two numbers, leaving one number.

So, in this case, Sasha makes the last move.

Wait, but according to the problem, the game ends when there's one number left, at which point Sasha can't make a move.

So, after Anna's move, if there's only one number left, the game ends.

But in the first test case, after Sasha's move, there's one number left.

Wait, perhaps I need to think differently.

Maybe I need to think in terms of the parity of n.

If n is even, then Sasha makes the last move.

If n is odd, Anna makes the last move.

Wait, in the first test case, n=2 (even), Anna first, then Sasha, so Sasha makes the last move.

In n=3 (odd), Anna first, then Sasha, Anna, Sasha, so Sasha makes the last move.

Wait, but with n=1, the game ends immediately, as there are no moves to be made.

Wait, but n >=1.

Wait, perhaps I need to consider the total number of moves.

Each Sasha's move reduces the number of elements by one.

So, starting from n elements, Sasha can make (n-1) moves.

Anna can make up to n moves, but since the game ends after Sasha's (n-1) moves, Anna can make n moves in total.

Wait, perhaps it's better to think recursively or in terms of game theory, determining who can force a win.

But given the time constraints, I need a more efficient way.

Let me consider the final number's value.

The final number is determined by a series of reverses by Anna and concatenations by Sasha.

Anna can reverse any one number per move, and Sasha can concatenate any two numbers in any order.

I need to find a way to maximize or minimize the final number based on who's making the moves.

Sasha wants the final number to be as large as possible to win, while Anna wants it to be as small as possible.

Wait, no.

Actually, Sasha wins if the final number is at least 10^m, otherwise Anna wins.

So, Sasha wants the final number to be at least 10^m, while Anna wants it to be less than 10^m.

So, Sasha tries to maximize the final number, while Anna tries to minimize it.

Given that, I can think of the game as both players trying to influence the final number's value.

But it's still complex to simulate.

Maybe I can think about sorting the numbers and considering the reverses.

Wait, perhaps I can consider that Anna can reverse any number to its reverse, and Sasha can concatenate any two numbers in any order.

I need to find a way to arrange these operations to maximize or minimize the final number.

Wait, perhaps I can think of the sequence of operations in a way that allows me to compute the minimal or maximal possible final number.

But it's still too vague.

Let me consider that Anna can choose to reverse any subset of the numbers, and Sasha can arrange them in any order.

Wait, but Anna can only reverse one number per move, and Sasha concatenates two at a time.

But perhaps, in the end, it's equivalent to Anna choosing to reverse any subset of the numbers, and then Sasha arranging them in the best possible order to maximize the final number.

But Anna wants to minimize the final number.

Wait, perhaps I can think of Anna reversing all the numbers she wants, and then Sasha arranging them to form the largest possible number.

But Anna wants to minimize that final number.

Wait, but Anna doesn't choose all reverses at once; she chooses one per move, and Sasha concatenates two at a time.

This seems too intertwined to separate easily.

Maybe I need to consider the game in terms of the number of Sasha's moves.

Wait, perhaps I can consider that Sasha makes (n-1) moves, each time concatenating two numbers, and Anna reverses one number after each of Sasha's moves.

But I'm getting confused.

Let me look at the sample input and output to see if I can find a pattern.

Sample Input:

9

2 2

14 2

3 5

9 56 1

4 10

1 2007 800 1580

4 5

5000 123 30 4

10 10

6 4 6 2 3 1 10 9 10 7

1 1

6

1 1

10

8 9

1 2 9 10 10 2 10 2

4 5

10 10 10 10

Sample Output:

Sasha

Anna

Anna

Sasha

Sasha

Anna

Anna

Anna

Sasha

Looking at the first test case:

n=2, m=2

a=[14,2]

Possible reverses:

14 -> 41

2 -> 2

Then Sasha concatenates 41 and 2 to get 412 or 241, both greater than 100.

So Sasha wins.

Second test case:

n=3, m=5

a=[9,56,1]

Reverses:

9 -> 9

56 -> 65

1 ->1

Possible sequences:

Anna reverses 56 to 65.

Sasha concatenates 65 and 9 to get 659 or 965.

Anna reverses 1 to 1.

Sasha concatenates 659 and 1 to get 6591 or 1659, both less than 100000.

So Anna wins.

Another possible sequence:

Anna reverses 9 to 9.

Sasha concatenates 9 and 56 to get 956 or 569.

Anna reverses 1 to 1.

Sasha concatenates 956 and 1 to get 9561 or 1956, both less than 100000.

Similarly, Anna wins.

Third test case:

n=4, m=10

a=[1,2007,800,1580]

Reverses:

1 ->1

2007 ->7002

800 ->8

1580 ->851

Possible sequences:

Anna reverses 2007 to 7002.

Sasha concatenates 7002 and 1 to get 70021 or 17002.

Anna reverses 800 to 8.

Sasha concatenates 70021 and 8 to get 700218 or 870021.

Then Anna reverses 1580 to 851.

Sasha concatenates 700218 and 851 to get 700218851 or 851700218, both less than 10^10.

So Anna wins.

Wait, but the sample output says "Anna", but according to the explanation, it should be "Anna".

Wait, no, sample output for the third test case is "Anna", which matches.

Wait, but in the explanation, it's said "Anna wins".

Wait, but according to the sample output, it's "Anna".

Wait, but in the problem statement, it's "Anna" for the third test case.

Wait, perhaps I misread.

Wait, in the sample input, the third test case is:

4 10

1 2007 800 1580

Sample output: Anna

So, Anna wins.

Wait, but in the explanation, it's said "Anna wins".

Wait, but according to the problem, if the final number is less than 10^m, Anna wins.

So, in this case, m=10, and the final number is less than 10^10, so Anna wins.

Wait, but in the sample output, it's "Anna", which matches.

Wait, but in the fourth test case:

4 5

5000 123 30 4

Sample output: Sasha

So, in this case, Sasha wins.

I need to find a pattern or a strategy that determines the winner based on n, m, and the list a.

Let me consider the parity of n.

In the first test case, n=2 (even), Sasha wins.

Second test case, n=3 (odd), Anna wins.

Third test case, n=4 (even), Anna wins.

Fourth test case, n=4 (even), Sasha wins.

Wait, this doesn't seem consistent.

So, perhaps it's not just about the parity of n.

Maybe it's about the minimal or maximal possible final number.

Wait, perhaps I can consider that Anna can choose to reverse numbers in a way that minimizes the final number, and Sasha concatenates them to maximize it.

So, Anna wants the final number to be as small as possible, while Sasha wants it to be as large as possible.

Given that, I can think of Anna choosing reverses to minimize the final number, and Sasha arranging the concatenations to maximize it.

But it's still complex.

Let me think differently.

Suppose Anna reverses some numbers, and Sasha concatenates them in the best possible order.

So, Anna chooses which numbers to reverse, and in what order, but since she can only reverse one per move, and Sasha can choose which two to concatenate and in what order.

This seems too involved.

Maybe I can consider that Anna can choose to reverse any subset of the numbers, and Sasha can arrange them in any order.

Then, Anna wants to choose which numbers to reverse to minimize the final number, and Sasha arranges them to maximize it.

But I need to think about the game's structure.

Wait, perhaps I can think in terms of sorting the numbers after reverses and concatenating them in a certain order.

Let me consider that Anna reverses some numbers, and then Sasha arranges them to form the largest possible number.

But Anna wants to minimize that largest possible number.

So, Anna chooses which numbers to reverse to minimize the maximum number Sasha can form.

This seems like a minimax problem.

Anna minimizes the maximum number Sasha can make.

So, to find if Anna can make sure that the final number is less than 10^m, regardless of Sasha's arrangement.

Alternatively, Sasha tries to make the number at least 10^m, and Anna tries to prevent it.

Given that, perhaps I can sort the numbers after reverses and arrange them in a way that the final number is as small as possible for Anna, and see if it's less than 10^m.

But I need to model Anna's and Sasha's moves properly.

Wait, perhaps I can think of the game as Anna reversing some numbers, and Sasha concatenating them in a way that maximizes the final number.

Anna wants to choose which numbers to reverse to minimize this maximum possible final number.

But simulating all possible moves is not feasible due to time constraints.

I need a smarter way.

Let me consider that Anna can choose to reverse any subset of the numbers, and Sasha arranges them in descending order to maximize the final number.

But Anna wants to minimize that final number.

So, perhaps Anna should choose to reverse numbers that, when reversed, are as small as possible.

Wait, but she can only reverse one per move.

Wait, maybe I can consider that Anna can reverse any number of numbers, up to n.

But in reality, she reverses one per move, and Sasha concatenates two per move.

It's still too complicated.

Let me consider that the final number is determined by the sequence of reverses and concatenations.

Perhaps I can think of the final number as the concatenation of all the numbers after some of them have been reversed.

But the order of concatenation matters.

Wait, perhaps I can think of the final number as the concatenation of all the numbers in some order, with some of them reversed.

But Anna chooses which ones to reverse, and Sasha chooses the order.

So, Anna chooses a subset of numbers to reverse, and Sasha arranges them to form the largest possible number.

Anna wants to choose the subset to minimize this maximum number.

This is still complex.

Maybe I can consider that Anna can choose to reverse any subset of the numbers, and then Sasha arranges them in descending order.

So, to minimize the final number, Anna should choose to reverse numbers that, when reversed, are as small as possible.

Wait, but reversing a number can make it smaller or larger, depending on the number.

For example, reversing 123 gives 321, which is larger, while reversing 321 gives 123, which is smaller.

So, for each number, Anna has the option to reverse it or leave it as is.

Then, Sasha arranges them in the best possible order to maximize the final number.

So, Anna chooses which numbers to reverse to minimize the maximum number Sasha can make by arranging them.

This seems like a minimax problem.

In game theory, this can be solved using the minimax algorithm, but that's not practical for large n.

I need a better approach.

Let me consider that the final number is the concatenation of all the numbers after reverses, in some order.

So, the final number is the largest possible arrangement of the reversed or original numbers.

Anna wants this number to be as small as possible, so she chooses which numbers to reverse to minimize the maximum arrangement Sasha can make.

Wait, perhaps I can sort the numbers after reverses in descending order and concatenate them to get the largest possible number.

Then, Anna chooses which numbers to reverse to minimize this largest possible number.

Given that, perhaps I can find, for each number, whether reversing it makes it smaller or larger, and choose accordingly.

Wait, perhaps I can sort the numbers after reverses in descending order and see if the concatenated number is less than 10^m.

But Anna can choose which numbers to reverse.

Wait, perhaps I can consider that Anna can choose to reverse any subset of the numbers, and then Sasha arranges them in descending order.

So, Anna wants to choose the subset to minimize the concatenated number.

But this is still tricky.

Wait, perhaps I can think of it as Anna choosing to reverse numbers that, when reversed, are as small as possible, and then arranging them in descending order.

Wait, but she can't control the arrangement; Sasha does that.

So, Anna wants to choose which numbers to reverse so that, when Sasha arranges them in descending order, the concatenated number is as small as possible.

Wait, perhaps I can consider that Anna should choose to reverse numbers that, when reversed, are as small as possible, and leave others as is.

Then, Sasha arranges them in descending order.

So, Anna wants as many small numbers as possible in the list.

Wait, perhaps I need to sort the numbers after potential reverses and then arrange them to form the smallest possible number.

But Anna wants to minimize the final number, and Sasha wants to maximize it.

This is getting too complicated.

Let me try to think differently.

Suppose Anna reverses some numbers, and Sasha concatenates them in the best order to maximize the final number.

I need to find if Anna can choose her reverses such that, no matter how Sasha arranges them, the final number is less than 10^m.

Alternatively, Sasha can always make the final number at least 10^m.

This seems like I need to find the minimal possible maximal number.

Wait, perhaps I can consider that Anna can choose to reverse numbers to minimize the maximum possible concatenation.

But I need a more concrete approach.

Let me consider that Anna can choose to reverse any subset of the numbers, and Sasha arranges them to maximize the concatenated number.

So, the minimal maximal number is the smallest number that Anna can achieve by choosing which numbers to reverse, assuming Sasha will arrange them optimally to maximize the number.

I need to check if this minimal maximal number is less than 10^m.

If it is, Anna wins; otherwise, Sasha wins.

But how do I compute this minimal maximal number efficiently?

Wait, perhaps I can consider that Anna should choose to reverse numbers that, when reversed, are smaller than the original, to minimize the numbers.

But it's not that straightforward because reversing a number can make it larger or smaller.

Wait, for example, 123 reverses to 321, which is larger.

While 321 reverses to 123, which is smaller.

So, for each number, Anna has to choose whether to reverse it or not, to get the smallest possible set of numbers.

Then, Sasha arranges them in descending order to form the largest possible number.

Anna wants this number to be as small as possible.

So, she needs to choose which numbers to reverse to minimize this maximal number.

This seems like a difficult optimization problem.

Perhaps I can think of it in terms of comparing the original and reversed numbers and choosing the smaller one for each.

Then, sort these chosen numbers in descending order and concatenate them.

If this concatenated number is less than 10^m, Anna wins; otherwise, Sasha wins.

Wait, but is this correct?

Let me see.

For each number, Anna can choose to