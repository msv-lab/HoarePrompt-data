Alright, I've got this problem to solve. Let's see what it's asking for. So, Alice has n coins and wants to buy exactly k jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel that's an integer between 1 and 10^18 coins. Alice buys jewels greedily: she goes to each stall in order and buys as many jewels as she can with her remaining coins.

My task is to determine if Bob can set up the stalls and set their prices in such a way that Alice ends up buying exactly k jewels. If it's possible, I need to output "YES", followed by the number of stalls and their prices. If it's not possible, I should output "NO".

First, I need to understand the constraints and what exactly is being asked. The inputs are t test cases, each with n coins and k jewels. Both n and k can be up to 10^18, which is a huge number, so I have to be careful with efficiency.

The key point is that Alice buys jewels greedily, meaning she spends as much as she can at each stall before moving to the next one. So, the order of the stalls matters, and the prices need to be set in a way that she buys exactly k jewels in total.

I need to find a way to distribute the k jewels across at most 60 stalls, each with a price that Alice can afford, and ensure that she buys exactly k jewels by following her greedy approach.

Let me think about how Alice's buying process works. At each stall, she buys as many jewels as she can with her current coins, and then moves to the next stall with the remaining coins.

So, if I have stalls with prices p1, p2, ..., ps, then at stall 1, she buys floor(n / p1) jewels, spends that many p1 coins, and moves to stall 2 with the remaining coins, and so on.

My goal is to choose s <= 60, and prices p1, p2, ..., ps such that the total number of jewels she buys is exactly k.

This seems like a problem that can be approached by simulating the process in reverse or by trying to find appropriate prices that fit the constraints.

One idea is to start with the smallest possible prices and see how many jewels Alice can buy, but with the constraint of at most 60 stalls, I need a more efficient approach.

Let me consider the maximum number of stalls, which is 60. If I can find a way to distribute k jewels across 60 stalls, each with a price that allows Alice to buy a certain number of jewels, that would be ideal.

I need to make sure that the sum of jewels bought at each stall equals exactly k, and that the total cost does not exceed n coins.

Also, since Alice buys as many as possible at each stall, the prices should be set in a way that she doesn't buy more than needed at any stall.

Maybe I can start by allocating as many jewels as possible to the first stall, then adjust the remaining stalls accordingly.

Wait, but that might not work because if I allocate too many jewels at the first stall, Alice might buy more than k jewels in total.

Alternatively, perhaps I can think of it as partitioning k jewels into up to 60 parts, where each part corresponds to the number of jewels bought at a stall, and the price at each stall is such that Alice buys exactly that number of jewels with her remaining coins.

This sounds a bit tricky. Let's consider an example to get a better understanding.

Take the first example from the problem:

n = 7, k = 3

One possible solution is to set up 10 stalls with prices 2 through 11.

At stall 1 with p1=2, Alice can buy 3 jewels (since 3*2=6 <=7), leaving her with 1 coin.

At stall 2 with p2=3, she can't buy any jewels since 1 < 3.

Similarly, at the remaining stalls, she can't buy any more jewels.

So, she buys exactly 3 jewels in total.

Another example:

n=255, k=8

Solution: 8 stalls with prices 128,64,32,16,8,4,2,1

At each stall, Alice buys 1 jewel, spending the respective price, and is left with decreasing amounts of coins until 0.

This seems like a binary approach, where each stall corresponds to a bit in the binary representation of n.

Wait, 255 is 2^8 -1, and the prices are powers of 2 descending from 128 down to 1.

In this case, Alice buys one jewel at each stall, spending exactly the price of that stall, and is left with 0 coins at the end.

This seems similar to the binary representation of n, where each stall corresponds to a bit.

Maybe I can generalize this approach.

If I set up stalls with prices that are powers of 2, starting from the largest possible that is less than or equal to n, and allocate jewels accordingly, I can control exactly how many jewels Alice buys.

This way, I can make sure that she buys exactly k jewels by adjusting the number of stalls and their prices.

But I need to ensure that the total number of jewels bought is k, and that I don't exceed 60 stalls.

Wait, but in the first example, they used 10 stalls for k=3, which seems unnecessary. Maybe there are multiple ways to achieve the goal.

I need to find a way that works and is efficient in terms of the number of stalls used.

Let me think about the constraints again.

Each test case can have n and k up to 10^18, and t up to 1000, so I need an efficient solution.

Using up to 60 stalls per test case should be manageable.

I need to find a way to distribute k jewels across these stalls, each with a price that allows Alice to buy a certain number of jewels.

Perhaps I can iterate from the first stall to the last, deciding how many jewels Alice should buy at each stall, and setting the price accordingly.

Let me try to formalize this.

Letâ€™s denote:

- s: number of stalls (1 <= s <= 60)

- p_i: price per jewel at stall i (1 <= p_i <= 10^18)

- a_i: number of jewels Alice buys at stall i

Then, the total number of jewels bought is sum of a_i from i=1 to s, and this sum should be equal to k.

Also, for each stall i, a_i = floor(n_i / p_i), where n_i is the remaining coins before visiting stall i.

The remaining coins after stall i is n_{i+1} = n_i - a_i * p_i.

My task is to choose s, p1, p2, ..., ps such that sum of a_i = k, and n >= sum of a_i * p_i.

Moreover, I need to make sure that Alice buys exactly k jewels, not more or less.

This seems a bit tricky. Maybe there's a smarter way to approach this.

Let me consider the following strategy:

- Start with s=1 stall.

- Set p1 such that floor(n / p1) = k.

- This would mean that p1 = floor(n / k).

But wait, floor(n / p1) = k implies that p1 = floor(n / k).

But this might not be precise, because floor(n / p1) could be greater than k if p1 is less than n / k.

Wait, no.

Actually, floor(n / p1) >= k if p1 <= floor(n / k).

I need to be careful here.

Let me think differently.

Suppose I set p1 such that floor(n / p1) = m1, where m1 is the number of jewels bought at stall 1.

Then, I need to set p2 such that floor((n - m1 * p1) / p2) = m2, and so on, until the total sum of m_i = k.

This seems too vague.

Maybe I need to find a way to decompose k into up to 60 parts, each corresponding to the number of jewels bought at a stall.

But with the constraint that the sum of m_i * p_i <= n, and sum of m_i = k.

This is getting complicated.

Let me look back at the examples.

In the first example:

n=7, k=3

Stalls with prices 2 through 11.

At stall 1: buy 3 jewels, spend 6 coins, left with 1 coin.

At stalls 2 through 10: can't buy any more jewels.

Total jewels bought: 3.

In the third example:

n=255, k=8

Stalls with prices 128,64,32,16,8,4,2,1

At each stall, buy 1 jewel, spend the price, left with decreasing coins until 0.

Total jewels bought: 8.

So, in the first example, they used many stalls but only the first one is actually used to buy jewels.

In the third example, all eight stalls are used, each contributing one jewel.

This suggests that the number of stalls used can vary, but it's acceptable to have more stalls than needed, as long as Alice buys exactly k jewels.

But in the second test case, with n=6 and k=4, it's impossible to set up stalls to make Alice buy exactly 4 jewels.

Let me see why.

If n=6 and k=4, possible stall setups:

- One stall: set p1 such that floor(6 / p1) = 4.

This would require p1 = floor(6 / 4) = 1.

But if p1=1, Alice buys 6 jewels, which is more than 4.

So, that doesn't work.

- Two stalls: set p1 and p2.

For example, p1=2, p2=3.

At stall 1: buy 3 jewels, spend 6 coins, left with 0 coins.

At stall 2: can't buy any more.

Total jewels: 3, which is less than 4.

Another try: p1=1.5, but prices must be integers.

Wait, prices must be integers, so p1=1 or p1=2, etc.

Wait, p_i must be integers between 1 and 10^18.

So, p1=1: buy 6 jewels, total 6 > 4.

p1=2: buy 3 jewels, spend 6 coins, left with 0 coins.

Total jewels: 3 < 4.

p1=3: buy 2 jewels, spend 6 coins, left with 0 coins.

Total jewels: 2 < 4.

p1=4: buy 1 jewel, spend 4 coins, left with 2 coins.

Then p2=3: can't buy any more.

Total jewels: 1 < 4.

p1=5: buy 1 jewel, spend 5 coins, left with 1 coin.

p2=1: buy 1 jewel, spend 1 coin, left with 0 coins.

Total jewels: 2 < 4.

No combination seems to reach exactly 4 jewels.

Hence, "NO" is the correct answer for this case.

So, in cases where it's impossible to set up stalls to make Alice buy exactly k jewels, the answer is "NO".

Now, I need a general approach to determine for any n and k whether it's possible or not, and if possible, provide a setup with at most 60 stalls and their prices.

Looking back at the first and third examples, it seems that using a decreasing sequence of prices, starting from a higher price and decreasing, can work.

In the first example, prices from 2 to 11 are used, but only the first stall is actually used to buy jewels.

In the third example, prices are powers of 2, decreasing, and Alice buys one jewel at each stall.

Maybe I can generalize this approach.

Let me consider setting up stalls with decreasing prices, starting from the highest possible price that Alice can afford, and allocate jewels accordingly.

But I need to ensure that the total number of jewels bought is exactly k.

Alternatively, perhaps I can think of it in terms of the binary representation of k.

Wait, but k is the number of jewels, not directly related to binary representation.

Wait, in the third example, by setting prices as powers of 2, descending, Alice buys one jewel at each stall, totaling 8 jewels.

Similarly, if I set up s stalls with prices p_i such that p_i > n - sum_{j=1}^{i-1} a_j * p_j, then Alice can't buy any more jewels at subsequent stalls.

But this seems too vague.

Let me think differently.

Suppose I fix the number of stalls s, and try to find prices p1, p2, ..., ps such that sum of floor(n_i / p_i) = k, where n_i is the remaining coins at each step.

This seems too general.

Maybe I need to find a way to force Alice to buy a specific number of jewels at each stall.

Let me consider that at each stall, I can set the price such that Alice buys a certain number of jewels, and then move to the next stall with the remaining coins.

If I can control the number of jewels bought at each stall, I can make sure that the total is exactly k.

But how do I set the prices to achieve this?

Let me consider that for each stall, the number of jewels bought is floor(n_i / p_i), where n_i is the remaining coins before visiting stall i.

I need to choose p_i such that sum of floor(n_i / p_i) over all s stalls equals k.

This seems tricky because floor functions are involved, and the remaining coins depend on previous choices.

Maybe I can use an greedy approach, where at each step, I choose p_i to be as large as possible, while still allowing Alice to buy at least one jewel.

Wait, but in the first example, they chose p_i starting from 2 and increasing, but in the third example, p_i are decreasing.

I'm getting confused.

Let me try to think of it in terms of the remaining coins and how many jewels are left to buy.

Suppose I have k jewels to buy, and n coins.

I need to distribute these k jewels across up to 60 stalls, with prices set such that Alice buys the required number at each stall.

Wait, perhaps I can iterate from the last stall to the first.

Let me consider that at the last stall, Alice buys some number of jewels, and before that, at the previous stall, she buys some more, and so on.

But I'm not sure.

Let me consider that the last stall can have a price that allows Alice to buy a certain number of jewels with her remaining coins, and so on.

This seems too vague.

Maybe I need to look for a different approach.

Let me consider that if I set up s stalls with prices p1, p2, ..., ps, then the total number of jewels Alice buys is sum of floor(n_i / p_i), where n_i is the remaining coins after previous stalls.

This is recursive, and it's getting complicated.

Perhaps I can look for a way to partition n coins into k jewels across up to 60 stalls.

Wait, but the jewels are bought in groups at each stall, with each group having a certain price.

This is confusing.

Let me try to think about the minimal number of stalls needed.

In the third example, they used 8 stalls for k=8, but it's also possible to use fewer stalls.

For example, with k=8 and n=255, I could set up one stall with p1=31, so Alice buys 8 jewels (since 31*8=248 <=255), leaving 7 coins.

But that would make Alice buy 8 jewels at the first stall itself, which is acceptable.

So, in this case, s=1 is possible.

But in the first example, they used s=10, but only the first stall is actually used.

Wait, but in the first example, n=7 and k=3.

If I set p1=2, Alice buys 3 jewels (since 3*2=6 <=7), leaving 1 coin.

Then, at p2=3, she can't buy any more, and so on.

So, with s=10, only the first stall is used for buying jewels.

But is there a way to use fewer stalls?

Yes, for example, with s=1 and p1=2, same as above.

Or with s=2, p1=2 and p2=3.

At p1=2, buys 3 jewels, spends 6 coins, left with 1 coin.

At p2=3, can't buy any more.

Total jewels: 3.

So, s=2 is also possible.

But in this case, s=1 would suffice.

So, why did they use s=10 in the sample input?

Maybe to show that it's possible with more stalls, even if fewer would suffice.

So, I need to find any setup with s <=60 that allows Alice to buy exactly k jewels.

Now, I need to find a general method to achieve this.

Let me consider the following approach:

- Start with s=1.

- Set p1 such that floor(n / p1) = k.

- This would require p1 = floor(n / k).

- Check if floor(n / p1) equals k.

- If yes, output s=1 and p1.

- If not, increase s and try to distribute the remaining jewels across additional stalls.

But in the case where floor(n / p1) != k, this approach might not work.

Wait, in the first example, n=7 and k=3.

If I set p1=2, floor(7/2)=3, which matches k.

So, s=1 would work.

In the second example, n=6 and k=4.

If I set p1= floor(6/4)=1.

Then floor(6/1)=6, which is greater than k.

So, s=1 doesn't work.

Then, try s=2.

Set p1=2, floor(6/2)=3, then p2=3, floor(0/3)=0, total jewels=3 <4.

Not enough.

Try p1=1, floor(6/1)=6, p2=2, floor(0/2)=0, total=6 >4.

Not good.

Try p1=3, floor(6/3)=2, p2=2, floor(0/2)=0, total=2 <4.

Still not enough.

Try p1=1, floor(6/1)=6, p2=1, floor(0/1)=0, total=6 >4.

No good.

Try p1=2, floor(6/2)=3, p2=3, floor(0/3)=0, total=3 <4.

Still not enough.

Seems like it's impossible to make Alice buy exactly 4 jewels with n=6.

Hence, "NO" is the correct answer.

So, in cases where it's impossible to find such a setup, the answer is "NO".

Now, I need a general method to determine if it's possible and, if so, provide a setup with s <=60.

Let me consider another approach.

Suppose I set up stalls with decreasing prices, starting from the highest possible price that Alice can afford, and at each stall, make her buy as few jewels as possible.

Wait, but she buys as many as possible given the price.

So, that might not work.

Alternatively, I can set up stalls with increasing prices, but again, it's not clear.

Let me consider that if I set up stalls with prices that are factors of n, I can control the number of jewels bought.

But factors might not be sufficient, given the large range of n and k.

Another idea: use the greedy algorithm to allocate as many jewels as possible at each stall, and see if the total can be adjusted to k.

But again, it's not straightforward.

Let me think about the minimal and maximal number of jewels Alice can buy.

With s=1, she can buy floor(n / p1) jewels, for some p1.

With s=2, she can buy floor(n / p1) + floor((n - floor(n / p1) * p1) / p2) jewels, and so on.

This seems too recursive to handle directly.

Maybe I need to find a way to make the sum of floor(n_i / p_i) equal to k, where n_i depends on previous p_i's.

This seems too interdependent.

Let me consider that for s=1, it's possible only if floor(n / p1) = k, which requires p1 = floor(n / k).

But as seen in the second example, this might not work if floor(n / p1) != k.

Wait, in the first example, p1=2, n=7, k=3: floor(7/2)=3, which matches k.

In the third example, with s=8, p_i=128,64,32,16,8,4,2,1, and Alice buys one jewel at each stall, totaling 8 jewels.

So, in that case, s=8 works.

But with s=1, p1=31, floor(255/31)=8, which also works.

So, s=1 is sufficient for k=8 and n=255.

But in the second example, n=6 and k=4, no setup seems to work.

So, I need a way to determine if it's possible and provide a setup if it is.

Let me consider that for s=1, it's possible only if floor(n / p1) = k, which requires p1 = floor(n / k).

But in the second example, floor(6 / floor(6 / 4)) = floor(6 / 1) = 6, which is greater than k.

So, s=1 doesn't work.

Then, for s=2, I need to choose p1 and p2 such that floor(n / p1) + floor((n - floor(n / p1) * p1) / p2) = k.

This seems too involved to solve directly.

Maybe I need to look for a different strategy.

Let me consider that if n < k, it's impossible because Alice can't buy more jewels than she has coins.

But in the first example, n=7 and k=3, which is fine since n >=k.

Wait, in the second example, n=6 and k=4, n >=k, but it's impossible.

So, n >=k is necessary but not sufficient.

I need a better condition.

Let me think about the minimal and maximal number of jewels Alice can buy.

With s=1, the minimal number of jewels is floor(n / p1), for p1 between 1 and n.

The maximal number is floor(n /1)=n, and minimal is floor(n /n)=1.

Similarly, with s=2, the range of possible jewels bought increases.

But it's not clear what the exact range is.

Maybe I need to find a way to make the sum equal to k by choosing appropriate p_i's.

Let me consider that for each stall, p_i >=1, and the number of jewels bought at each stall is at least 1 if p_i <= remaining coins.

But it's still too vague.

Let me consider that if I set p_i = ceil(n / k), then Alice buys floor(n / p_i) jewels.

But I need to adjust p_i to make sum of floor(n_i / p_i) equal to k.

This seems too involved.

Wait, maybe I can use induction on the number of stalls.

Start with s=1, see if it's possible.

If not, try s=2, and so on, up to s=60.

But this would be too time-consuming for large n and k.

I need a smarter way.

Let me consider that if I set up stalls with prices that are divisors of n, I can control the number of jewels bought more easily.

But again, with large n, this might not be practical.

Wait, perhaps I can think in terms of the binary representation of n.

In the third example, they used prices that are powers of 2, decreasing, and Alice bought one jewel at each stall.

This seems similar to the binary representation, where each bit corresponds to a power of 2.

Maybe I can generalize this approach.

Suppose I set up stalls with prices that are powers of some base, say 2, and adjust the number of jewels bought at each stall accordingly.

This way, I can control the number of jewels bought at each stall to sum up to k.

But I need to make sure that the remaining coins after each stall are sufficient for the next stalls, if needed.

Let me try to formalize this.

Let me set up stalls with prices p_i = 2^a_i, where a_i are decreasing integers.

Then, at each stall, Alice buys floor(n / p_i) jewels, spends that many p_i coins, and moves to the next stall with the remaining coins.

If I choose the prices appropriately, I can make her buy exactly one jewel at each stall, up to k stalls.

In the third example, this is what happened: s=8, p_i=128,64,32,16,8,4,2,1, and Alice buys one jewel at each stall.

This works because n=255, which is 2^8 -1, and the prices are 2^7 down to 2^0.

So, at each stall, she can buy one jewel, spending p_i coins, and is left with n - p_i coins, which is still sufficient to buy one jewel at the next stall, until the last stall.

This seems like a general approach: set up s stalls with prices that are decreasing powers of 2, starting from the highest possible power of 2 that is less than or equal to n.

Then, at each stall, Alice buys one jewel, spends that stall's price, and moves to the next stall with the remaining coins.

This way, she buys exactly s jewels, as long as s <= floor(n / p1), and the remaining coins are sufficient for the next stalls.

Wait, but in the first example, they used s=10 stalls for k=3, but only the first stall is used to buy jewels.

So, perhaps I can set up s stalls, but only make Alice buy jewels at the first few stalls, and set the remaining stalls with prices that are higher than her remaining coins.

This way, she only buys jewels at the first few stalls, and the total is exactly k.

In the first example, they set up 10 stalls with p_i from 2 to 11, and Alice only buys at the first stall.

Similarly, I can set up s stalls, with the first stall having p1 such that floor(n / p1) = m1, and the remaining stalls have prices higher than the remaining coins after the first stall.

This way, Alice only buys jewels at the first stall and doesn't buy any at the remaining stalls.

In this case, m1 = k, and s can be up to 60.

But in the first example, they set m1 =3, and s=10, with p_i from 2 to 11.

At p1=2, she buys 3 jewels, spends 6 coins, left with 1 coin.

At p2=3, can't buy any more, and so on.

So, this works.

Hence, for any k, I can set up s=60 stalls, with p1 such that floor(n / p1) = k, and p2, p3, ..., p60 set to any value higher than the remaining coins, so that Alice doesn't buy any more jewels.

This would ensure that she buys exactly k jewels.

But wait, in practice, setting p1 = floor(n / k), but I need to ensure that floor(n / p1) =k.

Actually, floor(n / p1) >=k, but I need it to be exactly k.

Wait, no, floor(n / p1) can be greater than k, but in the first example, with n=7, k=3, p1=2, floor(7/2)=3, which matches k.

But in the second example, n=6, k=4, p1= floor(6 /4)=1, floor(6 /1)=6 >4, which is more than k.

So, in that case, it's not possible to make floor(n / p1) =k.

Hence, perhaps I need to adjust p1 to make floor(n / p1) =k.

But in the second example, there is no p1 that satisfies floor(6 / p1) =4.

Because floor(6 / p1) =4 requires that 4 <= 6 / p1 <5, which implies that 6/5 < p1 <=6/4, which is 1.2 < p1 <=1.5.

But p_i must be integers, so p1=2.

But floor(6 /2)=3 !=4.

Hence, it's impossible for s=1.

Then, for s=2, perhaps I can set p1 and p2 such that floor(6 / p1) + floor((6 - floor(6 / p1)*p1)/p2) =4.

But as I tried earlier, it doesn't seem possible.

Hence, "NO" is the correct answer.

So, perhaps the general approach is:

- Try to set up s stalls with p1, p2, ..., ps such that the sum of floor(n_i / p_i) =k, where n_i is the remaining coins before stall i.

- To make it manageable, set up s stalls, with the first t stalls having prices such that Alice buys exactly one jewel at each of these t stalls, and the remaining s -t stalls have prices higher than the remaining coins, so Alice doesn't buy any jewels there.

- In this way, Alice buys exactly t jewels, and we can set t=k.

- To make this work, set p1=n - (k-1)*p1, but it's getting too complicated.

Wait, maybe I can set p_i= n - (k -1), for i=1, and p2= a large number, so Alice doesn't buy any at p2.

But I need to generalize this.

Let me consider that for s=k, set p_i= n - (k -i), for i from 1 to k.

But this seems arbitrary.

I need a better way.

Let me consider that for s=k, set p_i= n - (k -1), for i=1, and p2= n - (k -2), and so on, up to p_k= n.

But I'm not sure.

This is getting too convoluted.

Maybe I need to look for a different approach.

Let me consider that if k <=n, and k <= sum of floor(n / p_i) for s<=60, with p_i >=1.

But this is too vague.

Wait, perhaps I can think in terms of the minimal and maximal possible jewels bought.

With s=1, minimal jewels bought is 1 (p1=n), maximal is n (p1=1).

With s=2, minimal is 1 +0, maximal is n + floor((n -n*p1)/p2), which is complex.

This seems too involved.

Let me consider that for s=k, set p_i= n - (k -1), for i=1, and p2= n - (k -2), and so on, but this doesn't seem right.

Wait, perhaps I can set p_i= n /k for all i, but p_i need to be integers, and n /k may not be integer.

This is getting too messy.

Let me try to think differently.

Suppose I set up s=k stalls, each with p_i= ceil(n /k), but p_i need to be integers, and I need to adjust them so that the sum of floor(n_i / p_i) =k.

This seems too involved.

Let me consider that if I set p_i= n /k for i=1 to k, but again, n /k may not be integer.

Wait, perhaps I can set p_i= floor(n /k) for some stalls and p_i= floor(n /k) +1 for others.

But I need to ensure that the sum of floor(n_i / p_i) equals k.

This is getting too complicated.

Maybe I need to accept that finding an exact setup is difficult and look for a condition that determines if it's possible or not.

Looking back at the second example, n=6 and k=4, it's impossible to make Alice buy exactly 4 jewels.

In this case, n=6, k=4.

If I set p1=2, Alice buys 3 jewels, spends 6 coins, left with 0 coins.

Total jewels:3 <4.

If I set p1=1, Alice buys 6 jewels, which is more than 4.

Hence, "NO".

So, perhaps the condition is that k must be less than or equal to floor(n / p1), for some p1, and adjust the remaining stalls accordingly.

But in this case, floor(n / p1) is either 3 or 6, neither of which equals 4.

Hence, "NO".

In the first example, n=7, k=3.

Set p1=2, floor(7 /2)=3, which equals k.

Hence, "YES".

In the third example, n=255, k=8.

Set p_i=128,64,32,16,8,4,2,1, and Alice buys one at each, totaling 8.

Hence, "YES".

So, perhaps the general condition is that if k <=n, and there exists a setup with s<=60 stalls, then "YES", else "NO".

But in the second example, k=4 <=n=6, but it's "NO".

Hence, there must be a better condition.

Let me consider that k <= sum of floor(n / p_i) for s<=60.

But I need sum to be exactly k.

This is too vague.

Wait, perhaps I can think in terms of the minimal and maximal number of jewels Alice can buy with s stalls.

With s=1, minimal is 1, maximal is n.

With s=2, minimal is 1+0, maximal is n + floor((n -n)/p2)=n.

With s=3, minimal is 1+0+0, maximal is n + floor((n -n)/p2) + floor((n -n)/p3)=n.

It seems that with multiple stalls, the maximal number of jewels remains n, but the minimal increases.

This isn't helping.

Let me consider that the total number of jewels bought is the sum of floor(n_i / p_i), where n_i is the remaining coins before stall i.

This is recursive and depends on previous choices.

This seems too complex to handle directly.

Maybe I need to look for a different approach.

Let me consider that if k <=n, and k <= sum of p_i, but that's not directly applicable.

Wait, perhaps I need to consider that the sum of p_i * m_i <=n, where m_i is the number of jewels bought at stall i, and sum of m_i =k.

But this is similar to the original problem.

This seems too circular.

Let me consider that for s=k, set p_i= n - (k -1), but this doesn't make sense.

Wait, perhaps I can set p_i= n /k for all i, but again, n /k may not be integer.

This isn't working.

Let me consider that if k <=n, and k <= floor(n / p1), for some p1, then "YES".

But in the second example, k=4 <=n=6, but floor(n / p1) can't be 4 for any p1, as shown earlier.

Hence, this condition is insufficient.

Maybe I need to consider that k <= sum of floor(n / p_i) for s<=60, but I need sum to be exactly k.

This is too vague.

Let me consider that for s=k, set p_i= n - (k -1),