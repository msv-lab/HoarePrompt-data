Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a string consisting of lowercase Latin letters, and I need to partition this string into some substrings such that none of these substrings is a palindrome. If it's possible to do that, I should output "YES", followed by the number of parts and the parts themselves. If it's not possible, I should output "NO".

First, I need to understand what a palindrome is. A palindrome is a string that reads the same forwards and backwards. For example, "racecar" is a palindrome because whether you read it left to right or right to left, it's the same. On the other hand, "hello" is not a palindrome because "hello" backwards is "olleh", which is different.

So, the task is to split the string into substrings where none of them is a palindrome. I need to do this for multiple test cases, and each test case has a string of lowercase letters. The length of the string can be up to 1,000,000, and the total sum of all string lengths across test cases is up to 1,000,000. That means I need an efficient solution, probably linear time for each string.

Let me think about how to approach this.

First, if the entire string is not a palindrome, then I can just take it as one substring and output "YES", followed by 1 and the string itself. That's straightforward.

But if the entire string is a palindrome, I need to see if I can partition it into smaller substrings, each of which is not a palindrome.

For example, consider the string "aaa". This is a palindrome, and any substring of it, like "aa" or "a", is also a palindrome. So, I can't partition it in a way that all parts are non-palindromic. Hence, for such strings, the answer should be "NO".

Another example is "abba". This is a palindrome, but if I partition it into "ab" and "ba", neither of them is a palindrome because "ab" backwards is "ba", which is different, and "ba" backwards is "ab", which is different. So, in this case, I can output "YES", 2, "ab" "ba".

Wait, but "abba" is a palindrome, and I was able to partition it into two non-palindrome substrings. So, maybe for palindromic strings, I can always partition them into two non-palindrome substrings.

But hold on, consider "aaa". It's a palindrome, and if I try to partition it into "aa" and "a", both are palindromes. So, that doesn't work. Or "aabbaa", which is a palindrome, and if I partition it into "aab" and "baa", neither is a palindrome because "aab" backwards is "baa", which is different, and "baa" backwards is "aab", which is different. So, it works in this case.

Wait, but "aab" and "baa" are different strings, but they are not palindromes because "aab" reversed is "baa", which is not the same as "aab", and "baa" reversed is "aab", which is not the same as "baa". So, they are both non-palindromic.

So, maybe for palindromic strings, if their length is even, I can always partition them into two equal halves, and as long as the two halves are not equal to their reverse, it should work.

But in the case of "abba", partitioning into "ab" and "ba" works because "ab" != "ba". But in "aaa", partitioning into "aa" and "a" doesn't work because "aa" == "aa" reversed and "a" == "a" reversed.

So, perhaps for palindromic strings, if the length is greater than 1 and the string is not composed of the same character repeated, I can find a way to partition it into non-palindromic substrings.

Wait, but "abba" is a palindrome and I can partition it into "ab" and "ba", which are both non-palindromic.

Similarly, for "racecar", which is "racecar", I can partition it into "rac" and "ecar", and check if both are non-palindromic.

"rac" reversed is "car", which is different from "rac", and "ecar" reversed is "race", which is different from "ecar". So, both are non-palindromic.

Similarly, for "level", I can partition it into "lev" and "el", where "lev" reversed is "vel", which is different, and "el" reversed is "le", which is different.

So, it seems like for palindromic strings, if I can find a partition where neither part is a palindrome, that should work.

But how to generalize this?

Let me think about the conditions under which a palindromic string can be partitioned into non-palindromic substrings.

First, if the string is of length 1, it's a palindrome, and I can't partition it into non-palindromic substrings, so "NO".

If the string is of length 2 and both characters are the same, like "aa", it's a palindrome, and any partition would include "a", which is a palindrome, so "NO".

If the string is of length 2 and characters are different, like "ab", it's not a palindrome, so I can take it as one substring and output "YES", 1, "ab".

If the string is longer, say length 3, like "aba", which is a palindrome, I can partition it into "ab" and "a", but "a" is a palindrome, so that doesn't work. Or "ab" and "a", same issue. Or "a" and "ba", again "a" is a palindrome.

So, for "aba", it seems like I can't partition it into non-palindromic substrings.

Similarly, "abcba" is a palindrome. If I partition it into "abc" and "ba", "abc" reversed is "cba", which is different, and "ba" reversed is "ab", which is different. So, both are non-palindromic.

Wait, but "abcba" is a palindrome, and "abc" and "ba" are both non-palindromic. So, in this case, it's possible.

So, perhaps for palindromic strings of length greater than 2, if they contain at least one character that breaks the palindrome in a way that allows partitioning into non-palindromic substrings.

Wait, but in "aba", I can't find such a partition.

Wait, "aba" is a palindrome, and any partition would include single characters or "ab" and "a", but "a" is a palindrome, or "aba" and "" which is invalid.

So, perhaps for palindromic strings where all characters are the same, like "aaa", "bb", etc., it's impossible to partition them into non-palindromic substrings.

Because any substring of them would still be composed of the same character, hence palindromic.

On the other hand, for palindromic strings that have different characters, like "abba", "abcba", etc., it's possible to partition them into non-palindromic substrings.

So, perhaps the key is to check if the string is composed of the same character repeated.

If it is, then it's impossible to partition it into non-palindromic substrings, so "NO".

If it's not, then it's possible to partition it into non-palindromic substrings.

Wait, but in the example, "lllllllll" is all 'l's, so it should be "NO", which matches this.

Another example, "uwuowouwu", which is not entirely the same character, so it's "YES".

In the first example, "sinktheyacht" is not a palindrome, so it's "YES" with one partition.

So, perhaps the rule is:

- If the string is not a palindrome, output "YES" with one partition.

- If the string is a palindrome:

- If all characters are the same, output "NO".

- Else, output "YES" with a suitable partition into non-palindromic substrings.

But wait, in "abba", which is a palindrome, I can partition it into "ab" and "ba", both non-palindromic.

In "aaa", which is a palindrome, partitioning into "aa" and "a" all are palindromes.

In "abcba", I can partition into "abc" and "ba", both non-palindromic.

In "aba", I can't find such a partition.

So, perhaps for palindromic strings, if they have an odd length and the middle character is different, it's still impossible to partition into non-palindromic substrings.

Wait, but "abcba" is a palindrome with odd length, and I can partition it into "abc" and "ba", both non-palindromic.

In "aba", I can try partitioning into "ab" and "a", but "a" is a palindrome.

Or "a" and "ba", again "a" is a palindrome.

Or "aba" and "", invalid.

So, for "aba", it seems impossible.

So, perhaps for palindromic strings where all characters are the same, or for strings like "aba" where the middle character is the same as the others in certain ways, it's impossible to partition into non-palindromic substrings.

Wait, but "abba" is possible because "ab" and "ba" are different and non-palindromic.

Wait, perhaps the key is that in palindromic strings where the first half and the second half are not identical when reversed.

Wait, but "abba" the first half is "ab" and the second half is "ba", which are reverses of each other.

Wait, but "ab" reversed is "ba", which is different from "ab", so "ab" is not a palindrome.

Wait, but in this context, "ab" is not a palindrome because "ab" != "ba".

Wait, but "ab" is not a palindrome because its reverse is "ba", which is different from "ab".

Similarly, "ba" is not a palindrome because its reverse is "ab", which is different.

So, both "ab" and "ba" are non-palindromic.

Hence, for palindromic strings where I can partition them into two halves that are reverses of each other and not equal to their reverses, it's possible.

But in "aba", "ab" and "a", "ba", etc., don't work.

Wait, "aba" is a palindrome, and any partition includes "a" which is a palindrome.

So, perhaps for palindromic strings with length greater than 2, if they are composed of repeating the same character, or if they have a structure like "aba", it's impossible to partition into non-palindromic substrings.

Wait, but in "abcba", I can partition it into "abc" and "ba", both non-palindromic.

Similarly, in "abccba", I can partition it into "abc" and "cba", both non-palindromic.

Wait, but "cba" reversed is "abc", which is different from "cba", so "cba" is not a palindrome.

Hence, it seems like for palindromic strings that are not composed of the same character repeated, it's possible to partition them into non-palindromic substrings.

But in "aba", it's impossible because any partition includes "a", which is a palindrome.

Similarly, in "aaa", it's impossible because any substring is a palindrome.

Hence, perhaps the rule is:

- If the string is not a palindrome, output "YES" with one partition.

- If the string is a palindrome:

- If all characters are the same, output "NO".

- Else, output "YES" with a suitable partition into non-palindromic substrings.

But wait, in "abba", which is a palindrome, and not all characters are the same, it's possible to partition into "ab" and "ba", both non-palindromic.

In "aba", which is a palindrome, and not all characters are the same, but it's impossible to partition into non-palindromic substrings.

So, perhaps there's another condition.

Wait, in "aba", the middle character is 'b', which is different from 'a', but the string is palindromic.

If I try to partition "aba" into "ab" and "a", "ab" is not a palindrome, but "a" is a palindrome.

Alternatively, "a" and "ba", same issue.

Or "aba" and "", invalid.

Hence, it seems like for palindromic strings where the string is of the form where the middle character is different, and the rest are the same, it's impossible to partition into non-palindromic substrings.

Wait, but in "abccba", which is a palindrome, and not all characters are the same, I can partition it into "abc" and "cba", both non-palindromic.

Similarly, in "abcba", partition into "abc" and "ba".

So, perhaps for palindromic strings that are not all the same character, and their length is even, or their length is odd but the middle character is not causing issues, it's possible to partition them into non-palindromic substrings.

But I need a clearer rule.

Let me think differently.

Suppose I have a palindromic string s.

If s is a palindrome, then s = reverse(s).

Now, if I partition s into two parts, t1 and t2, such that t1 + t2 = s.

For t1 and t2 to both be non-palindromic, t1 != reverse(t1), and t2 != reverse(t2).

In the case where s is a palindrome, and t1 is some prefix, and t2 is the remaining suffix.

Given that s is a palindrome, the prefix t1 should not be equal to its reverse, and t2 should not be equal to its reverse.

In "abba", t1 = "ab", t2 = "ba".

"ab" != "ba", so "ab" is not a palindrome.

"ba" != "ab", so "ba" is not a palindrome.

Hence, both are non-palindromic.

In "aba", t1 = "ab", t2 = "a".

"ab" != "ba", so "ab" is not a palindrome.

But "a" == "a", so "a" is a palindrome.

Hence, this partition is invalid.

Alternatively, t1 = "a", t2 = "ba".

" a" is a palindrome, "ba" is not.

Still, t1 is a palindrome.

Hence, invalid.

Hence, for "aba", it's impossible to partition into non-palindromic substrings.

Similarly, for "aaa", any partition includes single characters or substrings of 'a's, all of which are palindromic.

Hence, "NO".

For "abba", it's possible.

For "abcba", it's possible.

So, perhaps the general rule is:

- If the string is not a palindrome, output "YES" with one partition.

- If the string is a palindrome:

- If all characters are the same, output "NO".

- Else, output "YES" with a partition into two parts where neither part is a palindrome.

But in "aba", it's a palindrome, not all characters are the same, but it's impossible to partition into non-palindromic substrings.

So, perhaps I need a better condition.

Wait, perhaps if the string is a palindrome and its length is odd, and the middle character is the same as the others, then "NO".

Else, "YES".

Wait, in "aba", it's a palindrome, length is odd, middle character is 'b', which is different from 'a's.

But in "abba", it's a palindrome, length is even, and partitions into "ab" and "ba", both non-palindromic.

In "abcba", it's a palindrome, length is odd, middle character is 'c', which is different from 'a's, but I can still partition it into "abc" and "ba", both non-palindromic.

Wait, but in "aba", if I partition it into "ab" and "a", "ab" is not a palindrome, but "a" is a palindrome.

Alternatively, "a" and "ba", same issue.

"aba" and "", invalid.

Hence, it seems like for palindromic strings where the string is of the form where the middle character is different, but the rest forces me to have single character palindromes in the partition.

So, perhaps for palindromic strings, if they are not composed of the same character, and their length is even, or their length is odd but the middle character is not causing issues, I can partition them into non-palindromic substrings.

But I need a clear condition.

Let me consider that for a palindromic string, if there exists at least one character that breaks the uniformity, then it's possible to partition it into non-palindromic substrings.

But in "aba", even though there's a different middle character, it's still impossible to partition into non-palindromic substrings.

Hence, perhaps the correct condition is:

- If the string is not a palindrome, output "YES" with one partition.

- If the string is a palindrome:

- If all characters are the same, output "NO".

- Else, output "YES" with a partition into two parts, where neither part is a palindrome.

But in "aba", it's a palindrome, not all characters are the same, but any partition includes a single character, which is a palindrome.

Hence, perhaps I need to consider longer partitions.

Wait, maybe partitioning into more than two parts.

But according to the problem, I can partition into some substrings, not necessarily just two.

But in the example, for "uwuowouwu", they partitioned into three parts: "uw", "uow", "ouwu".

Let's check if these are non-palindromic.

"uw" != "wu", so "uw" is not a palindrome.

"uow" != "wou", so "uow" is not a palindrome.

"ouwu" != "uwwo", so "ouwu" is not a palindrome.

Hence, it's a valid partition.

But in "aba", if I try partitioning into "a", "b", "a", all of which are palindromes.

Alternatively, "ab", "a", but "a" is a palindrome.

Or "a", "ba", but "a" is a palindrome.

Hence, it seems like for "aba", it's impossible to partition into non-palindromic substrings.

Hence, perhaps the rule is:

- If the string is not a palindrome, output "YES" with one partition.

- If the string is a palindrome:

- If all characters are the same, output "NO".

- Else, if the string can be partitioned into at least two parts, each of which is not a palindrome, output "YES" with such a partition.

- Else, output "NO".

But I need a way to check if a palindromic string can be partitioned into non-palindromic substrings.

One approach could be to find a partition where no part is a palindrome.

To do that, I can try to find two substrings that are not palindromes.

But checking if a substring is a palindrome takes O(length of substring) time, which could be too slow for the constraints.

I need a more efficient way.

Wait, perhaps I can use the fact that if a string is not a palindrome, then some of its prefixes are not palindromic.

For example, in "abba", "ab" is not a palindrome.

Similarly, in "abcba", "abc" is not a palindrome.

Hence, perhaps I can always partition a non-all-same-character palindromic string into two parts, where at least one of them is not a palindrome.

Wait, but in "aba", both "ab" and "ba" are not palindromic, but in the partition, one part is "a", which is a palindrome.

Hence, that doesn't help.

Wait, maybe I need to partition into more than two parts.

But according to the problem, partitioning into any number of parts is allowed, as long as each part is not a palindrome.

Hence, for "aba", no matter how I partition it, I can't avoid having at least one palindrome.

Hence, perhaps the general rule is:

- If the string is not a palindrome, output "YES" with one partition.

- If the string is a palindrome:

- If all characters are the same, output "NO".

- Else, try to partition it into two parts, where neither part is a palindrome.

- If that's possible, output "YES" with that partition.

- Else, try partitioning into more parts.

But checking for multiple partitions would be time-consuming.

Is there a better way?

Wait, perhaps I can check if there exists any substring that is not a palindrome.

If there is at least one substring that is not a palindrome, then I can partition the string such that this substring is one part, and the rest is another part.

But I need to ensure that both parts are not palindromes.

Wait, perhaps I can find a substring that is not a palindrome, and partition the string such that this substring is one part, and the remaining part is also not a palindrome.

But this seems complicated.

Alternatively, perhaps I can always partition the string into two parts, where one part is not a palindrome, and the other part is also not a palindrome.

But in "aba", if I partition it into "ab" and "a", "ab" is not a palindrome, but "a" is a palindrome.

Similarly, "a" and "ba", same issue.

Hence, it's not always possible.

Wait, perhaps for palindromic strings that are not all the same character, and their length is greater than 2, it's possible to partition them into non-palindromic substrings.

But in "aba", it's length 3, not all same characters, but it's impossible.

Hence, that's not correct.

Wait, maybe for palindromic strings where the first character is different from the last character, it's impossible.

Wait, but in "abba", the first and last characters are 'a', which are the same.

Wait, no, in "abba", the first and last are 'a', and the middle part is 'bb'.

Wait, but "abba" is a palindrome, and I can partition it into "ab" and "ba", both not palindromic.

Similarly, in "abcba", the first and last are 'a', and I can partition it into "abc" and "ba", both not palindromic.

In "aba", the first and last are 'a', and middle is 'b'.

If I partition it into "ab" and "a", "ab" is not a palindrome, but "a" is a palindrome.

Alternatively, "a" and "ba", same issue.

Hence, perhaps for palindromic strings where the first character is the same as the last character, and the string is not composed of the same character, it's possible to partition into two parts, each not a palindrome.

But in "aba", the first and last are the same, but it's impossible.

Wait, maybe it depends on the length.

In "abba", length 4, even, can be partitioned into two parts of length 2 each: "ab" and "ba".

Both are not palindromic.

In "abcba", length 5, odd, partitioned into "abc" and "ba".

"abc" is not a palindrome, "ba" is not a palindrome.

In "aba", length 3, odd, partitioning into "ab" and "a", but "a" is a palindrome.

Hence, perhaps for palindromic strings with even length, it's always possible to partition them into two parts, each not a palindrome, by taking two halves.

But in "aa", which is a palindrome, all characters same, so "NO".

In "abba", which is a palindrome, not all characters same, length even, can be partitioned into "ab" and "ba", both not palindromic.

In "abcba", palindrome, not all characters same, length odd, can be partitioned into "abc" and "ba", both not palindromic.

In "aba", palindrome, not all characters same, length odd, cannot be partitioned into non-palindromic substrings.

Hence, perhaps for palindromic strings that are not composed of the same character, and have even length, or have a certain structure that allows partitioning into non-palindromic substrings, it's possible.

But I need a general rule.

Let me consider that for palindromic strings that are not composed of the same character, and have at least one substring that is not a palindrome, which seems always true except for strings like "aaa".

Wait, but "aba" is a palindrome, not all same characters, and has substrings like "ab" that are not palindromic, but still, it's impossible to partition it into non-palindromic substrings.

Hence, perhaps the only time it's impossible is when the string is a palindrome and all characters are the same, or the string is a palindrome with a certain structure like "aba" where any partition includes a single character or a smaller palindrome.

Wait, maybe I should think in terms of the minimal number of palindromic substrings needed to cover the string.

But that might be too complicated.

Alternatively, perhaps I can look for a way to split the string such that neither part is a palindrome.

To check if a string is a palindrome, I can compare it with its reverse