Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array `a` of length `n`, a positive integer `m`, and a string `s` of commands consisting of 'L's and 'R's. For each command in the string `s`, I need to output the remainder of the product of all elements in the array `a` when divided by `m`, and then remove either the leftmost or the rightmost element from `a`, depending on whether the command is 'L' or 'R'.

First, I need to understand the process step by step. For each command in the string `s`, I have to:

1. Calculate the product of all elements in the current array `a`.

2. Take the remainder of that product when divided by `m`.

3. Output that remainder.

4. Remove the leftmost element if the command is 'L', or the rightmost element if the command is 'R'.

5. Repeat this process until all commands are processed, and the array becomes empty.

Given that the array can be up to 2*10^5 elements long and there are up to 10^4 test cases, efficiency is crucial. Calculating the product of the array for each command directly would be too slow because multiplying all elements each time would be O(n^2) in the worst case, which is not feasible for n up to 2*10^5.

I need a smarter way to handle this. Let's think about how the product changes with each removal.

If I remove an element from the left or the right, the product for the next step will be the current product divided by that removed element. However, since we're dealing with remainders, I need to be careful with how division is handled in modular arithmetic.

In modular arithmetic, division isn't straightforward. Instead of dividing, we can multiply by the modular inverse. But for that to work, the element we're "dividing by" needs to have an inverse modulo `m`, which requires that the element and `m` are coprime.

Wait, but in the problem statement, `m` can be up to 10^4, and the elements of the array `a` are up to 10^4 as well. There's no guarantee that the elements and `m` are coprime, so I can't always compute the modular inverse.

Hmm, maybe there's another approach. Let's consider precomputing the product of the entire array and then, for each step, dividing by the element being removed, but in a way that works with modular arithmetic.

Alternatively, perhaps I can maintain two products: one from the left and one from the right, and use them to quickly compute the product after each removal.

Wait, but maintaining two products might not help directly because the removals are specified by the string `s`, which can be a mix of 'L's and 'R's.

Let me think differently. Since the sequence of removals is given by `s`, I can determine in advance the order in which elements are removed. Once I know the order of removal, I can determine the product at each step.

Let's consider that the first output is the product of the entire array modulo `m`. Then, after removing an element, the next product is the product of the remaining elements modulo `m`, and so on, until the array is empty.

So, if I can compute the sequence of products corresponding to the array after each removal, that would solve the problem.

One way to do this is to simulate the process:

- Start with the full array.

- Output the product modulo `m`.

- Remove the element specified by the first command in `s`.

- Repeat until the array is empty.

But, as I thought earlier, this is too slow for the given constraints.

I need a way to compute the product modulo `m` efficiently at each step.

Wait a minute, perhaps I can precompute the product of the entire array, and then, for each removal, adjust the product by dividing by the removed element (if possible), or find another way to update the product.

But again, division in modular arithmetic is tricky.

Another idea: since we're dealing with remainders, maybe I can compute the product modulo `m` incrementally, keeping track of the product so far and updating it as elements are removed.

But I still need a way to efficiently update the product modulo `m` after each removal.

Let me consider the following approach:

1. Compute the product of all elements in the array, modulo `m`. Let's call this `p`.

2. Output `p`.

3. Remove the element specified by the first command in `s`.

4. To get the new product, I need to divide `p` by the removed element, but as mentioned, division is not straightforward in modular arithmetic.

5. If the removed element and `m` are coprime, I can compute the modular inverse of the removed element and multiply `p` by that inverse to get the new product.

6. However, if they are not coprime, I'm stuck because I can't compute the inverse.

Given that, this approach won't work reliably for all cases.

I need another strategy.

Let's consider that for each step, I need to compute the product of the current array modulo `m`. Since the array is being reduced by one element at each step, following the sequence specified by `s`, perhaps I can compute the product for each state of the array directly.

But that still seems too slow.

Wait, perhaps I can precompute the order in which elements are removed and then compute the product for each prefix of that order.

Let me try to formalize this.

If I reverse the process, imagine building the array back from empty to full, reversing the sequence of removals.

So, if the removal sequence is given by `s`, the addition sequence would be the reverse of `s`, adding elements in the order they were removed, but in reverse.

Wait, perhaps that can help.

Let me think about it differently.

Suppose I know the order in which elements are removed, which is specified by `s`. Then, the order in which elements are removed is from position `l` or `r`, depending on whether `s[i]` is 'L' or 'R'.

So, I can simulate the process to determine which element is removed at each step.

But again, simulating this step by step would be too slow for n up to 2*10^5.

I need a way to determine, for each step, which elements are still in the array.

Wait, maybe using a deque (double-ended queue) would help, since I can efficiently remove elements from both ends.

But even with a deque, if I perform n removals, it would be O(n), which for n up to 2*10^5 and t up to 10^4, would result in up to 2*10^9 operations, which is too slow.

So, that's not feasible.

I need a smarter approach.

Let me consider that the product for each step depends on the current state of the array.

If I can find a way to compute the product of the current array modulo `m` without recalculating it from scratch each time, that would be ideal.

Wait, perhaps I can keep track of the product and update it as elements are removed.

But again, removing an element requires dividing the product by that element, which is problematic in modular arithmetic unless the element and `m` are coprime.

Hmm.

Maybe I need to accept that calculating the product modulo `m` directly is too slow and find an alternative approach.

Let me consider the properties of modular arithmetic.

Since we're dealing with remainders, perhaps there are patterns or properties I can exploit to compute the sequence of remainders efficiently.

Wait, perhaps I can precompute the product of all elements and then, for each removal, adjust the product by removing the contribution of the removed element.

But again, removing the contribution is equivalent to division, which is tricky.

Another idea: since we're dealing with remainders, perhaps the sequence of remainders follows a certain pattern based on the elements being removed.

Wait, maybe I can compute the product of all elements, then for each removal, compute the product of the remaining elements modulo `m`.

But this seems similar to the initial approach and would still be too slow.

I need to find a way to compute the product of the current array modulo `m` in less than O(n) time per step.

Wait, perhaps I can precompute prefix products and suffix products, and then use them to compute the product of the remaining array after each removal.

For example, if I have prefix products from the left and from the right, I can determine the product of the remaining array after some elements have been removed from either end.

But given that the removals can be from either end in any order, it's not clear how to apply prefix and suffix products directly.

Wait, perhaps I can determine, for each step, the range of elements that remain in the array after previous removals, and then compute the product of those elements.

But that still seems too slow.

Let me consider a different perspective.

Suppose I collect all the removals and keep track of which elements have been removed.

Then, for each step, the product would be the product of the elements that haven't been removed yet.

But keeping track of which elements are removed in a way that allows fast product updates is still problematic.

Wait, perhaps I can model this as maintaining a product of a subarray defined by the current left and right boundaries.

Given that, if I can keep track of the current left and right pointers, and compute the product of the subarray from left to right, that would solve the problem.

But computing the product of a subarray efficiently requires a way to calculate the product of elements between two indices quickly.

In standard arrays, this would typically require O(n) time per query, which is too slow.

However, if I precompute prefix products, I can compute the product of any subarray in O(1) time.

But in this problem, the subarrays are changing as we remove elements from either end, so the subarrays are not arbitrary but are prefixes or suffixes.

Wait, but with removals from either end, the remaining array is always a subarray, but its position changes based on the removals.

Still, if I precompute prefix products, I can compute the product of the subarray between the current left and right pointers.

Wait, perhaps I can precompute the prefix products and then, for each step, compute the product of the current subarray using the prefix products.

Let me try to formalize this.

Let's define prefix[i] as the product of a[0] to a[i], modulo m.

Similarly, define suffix[i] as the product of a[i] to a[n-1], modulo m.

Then, at any step, if I have left pointer `l` and right pointer `r`, the product of the subarray from `l` to `r` would be suffix[l] * prefix[r] / (a[l] * a[r]), but this is problematic because of the division and potential double-counting.

Actually, that might not work directly.

Wait, perhaps I need to think differently.

If I have prefix products, prefix[i] = a[0] * a[1] * ... * a[i], and suffix[i] = a[i] * a[i+1] * ... * a[n-1], then the product from l to r would be prefix[r] / prefix[l-1], but again, division is tricky in modular arithmetic.

Moreover, if l > r, which can happen if we remove elements from both ends, this approach breaks down.

This seems complicated.

I need another strategy.

Let me consider that, since m can be up to 10^4, which is relatively small, perhaps I can exploit the Chinese Remainder Theorem or factor m into its prime factors to simplify the computations.

But this seems like overkill and might not necessarily lead to a significant speedup.

Alternatively, perhaps I can compute the product modulo m directly for each step, but in a way that's efficient enough.

Wait, perhaps I can precompute the product of all elements and then, for each removal, divide by the removed element if possible, or handle cases where division isn't possible separately.

But again, this runs into the issue of division in modular arithmetic.

Another idea: since m is up to 10^4, which is small, perhaps I can compute the product modulo m for small m efficiently.

But I still need to handle the removals in an efficient manner.

Wait, perhaps I can compute the product of all elements, and then, for each removal, adjust the product by removing the contribution of the removed element.

But again, this comes back to division in modular arithmetic.

I'm going in circles here.

Let me look at the sample input and output to see if there's a pattern I can exploit.

Sample Input:

4

4 6

3 1 4 2

LRRL

5 1

1 1 1 1 1

LLLLL

6 8

1 2 3 4 5 6

RLLLRR

1 10000

10000

R

Sample Output:

0 2 4 1

0 0 0 0 0

0 0 0 4 4 4

0

Looking at the first test case:

n=4, m=6, a=[3,1,4,2], s=LRRL

- First, product of all elements: 3*1*4*2=24, 24 mod 6=0

- Then, s[0]='L', remove leftmost element 3, a becomes [1,4,2]

- Product: 1*4*2=8, 8 mod 6=2

- s[1]='R', remove rightmost element 2, a becomes [1,4]

- Product:1*4=4, 4 mod 6=4

- s[2]='R', remove rightmost element 4, a becomes [1]

- Product:1, 1 mod 6=1

- s[3]='L', remove leftmost element 1, a becomes empty

So the outputs are: 0,2,4,1

This matches the sample output.

Looking at the second test case:

n=5, m=1, a=[1,1,1,1,1], s=LLLLL

- Product:1*1*1*1*1=1, 1 mod 1=0

- Remove leftmost 1, a=[1,1,1,1]

- Product:1*1*1*1=1,1 mod 1=0

- And so on, all outputs are 0

Again, matches the sample output.

From these examples, I can see that the product modulo m is computed at each step before removal.

Given that, I need to find an efficient way to compute the product of the current array modulo m at each step.

Given the constraints, I need an approach that is O(n) per test case or better.

Wait, perhaps I can precompute the product of all elements, and then, for each removal, divide by the removed element if possible, or set the product to 0 if the removed element divides the current product.

But this seems error-prone.

Another idea: since m can be small, perhaps I can compute the product modulo m directly in a way that avoids large intermediate products.

But I still need to handle the removals efficiently.

Wait, perhaps I can keep track of the exponents of each prime factor in m, and maintain a count of each prime factor in the current product.

Then, for each removal, I can adjust the counts based on the removed element's prime factors.

This way, I can compute the product modulo m by combining the remaining prime factors.

But this sounds complicated and might not be worth the effort, especially given time constraints.

Let me consider that m can be up to 10^4, which is 10000, and n can be up to 2*10^5 per test case, with t up to 10^4.

Total n across all test cases is up to 2*10^5.

So, I need an approach that is O(n) in total.

Wait, perhaps I can compute the product of all elements, and then, for each removal, adjust the product by removing the contribution of the removed element, but do this in a way that avoids division.

Let me think about it.

Suppose I have the product of all elements, p.

Then, if I remove an element x, the new product would be p / x, but again, division is tricky.

But if x and m are coprime, I can compute p * inv(x) mod m, where inv(x) is the modular inverse of x modulo m.

If x and m are not coprime, then x divides p, so p / x is an integer, but I can't compute the inverse.

In this case, I can compute p / x mod m directly.

Wait, but how?

Actually, if x divides p, then p / x is an integer, and I can compute (p / x) mod m.

But to compute this efficiently, I can precompute p / x and then take modulo m.

But p can be very large, up to (10^4)^n, which is way beyond standard integer types.

So, that's not feasible.

I need another way.

Wait, perhaps I can compute p modulo m * x, and then use that to compute (p / x) mod m.

Let me see.

If I compute p mod (m * x), then p / x mod m would be (p mod (m * x)) / x mod m.

But I need to ensure that p is divisible by x, which it should be, since x is a factor of p.

This might work, but it's getting complicated.

Moreover, m * x can be up to 10^4 * 10^4 = 10^8, which is manageable.

But I'm not sure if this is the best approach.

Let me consider that for each removal, I need to compute the product of the remaining elements modulo m.

An alternative approach is to compute the product of the remaining elements directly for each step.

But again, this seems too slow.

Wait, perhaps I can precompute the product of all elements, and then, for each removal, keep track of the product of the removed elements, and use that to adjust the current product.

But I'm not sure.

Let me think differently.

Suppose I collect all the removals in order and keep track of the product of the removed elements.

Then, the product of the remaining elements would be the product of all elements divided by the product of the removed elements.

But again, division is problematic.

Wait, perhaps I can keep track of the product of the removed elements and their modular inverses, but only if they are coprime with m.

This seems too convoluted.

Let me consider that m is small, up to 10^4, and n is up to 2*10^5.

Perhaps I can compute the product modulo m directly in a way that avoids large intermediate products.

Wait, perhaps I can compute the logarithm of the product and then take the exponent modulo m, but that doesn't make sense because logarithms and exponents don't directly translate to modular arithmetic.

Another idea: perhaps I can represent the product as a list of exponents of its prime factors, and then compute the product modulo m using these exponents.

But this seems too involved for the time constraints.

I need a simpler approach.

Let me consider that, since m is small, I can compute the product modulo m directly by multiplying the elements one by one, taking modulo m at each step to prevent overflow.

But in this problem, the array changes with each removal, so I need to compute the product of the current array at each step.

Wait, perhaps I can precompute the product of all elements, and then, for each removal, adjust the product by removing the contribution of the removed element.

But again, removing the contribution is equivalent to division, which is tricky.

I'm stuck.

Let me look back at the problem statement to see if there's any hint I'm missing.

"Process all n commands in the order they are written in the string s.

Processing a command is done as follows:

First, output the remainder of the product of all elements of the array a when divided by m.

Then, if the command is 'L', remove the leftmost element from the array a, if the command is 'R', remove the rightmost element from the array a."

Given that, I need to output the product modulo m at each step, and then remove the specified element.

Given the constraints, I need an efficient way to compute the product modulo m at each step.

Wait, perhaps I can compute the product of all elements, and then, for each removal, divide the product by the removed element and take modulo m.

But as we've established, division is tricky in modular arithmetic.

Wait, perhaps I can compute the product of all elements, and then, for each removal, compute (p // x) mod m, where x is the removed element.

Given that p is divisible by x (since x is part of the product), p // x should be an integer, and I can compute that modulo m.

But p can be very large, so I need a way to compute p // x mod m efficiently.

Let me think about how to compute (p / x) mod m when p is divisible by x.

One way is to find y such that (y * x) mod m = p mod m.

Since p is divisible by x, such a y exists, and y = p / x.

But I need to find y mod m.

Wait, but p can be larger than m, so y might be larger than m.

I need a way to compute y mod m directly.

Another way is to use the fact that (p / x) mod m = (p * inv(x)) mod m, provided that x and m are coprime.

But if x and m are not coprime, inv(x) doesn't exist.

In that case, I can factor out the greatest common divisor (gcd) of x and m, and adjust p and m accordingly.

This is getting complicated.

Let me consider that m is small, so I can afford to compute p mod (x * m), and then divide by x to get (p / x) mod m.

Wait, let's see.

If I compute p mod (x * m), then p = k * x * m + r, where r < x * m.

Then, p / x = k * m + r / x.

Since p is divisible by x, r must be divisible by x, so p / x = k * m + (r / x).

Then, p / x mod m = (k * m + (r / x)) mod m = (r / x) mod m, since k * m mod m = 0.

So, p / x mod m = (p mod (x * m)) / x mod m.

This seems promising.

Let me formalize this.

Define q = p / x, which is an integer since p is divisible by x.

We want to compute q mod m.

We have p = q * x.

Take p mod (x * m):

p mod (x * m) = q * x mod (x * m).

Since q * x is less than x * m (because q < m, as q = p / x and p < x * m), then q * x mod (x * m) = q * x.

Then, q = (p mod (x * m)) / x.

Therefore, q mod m = ((p mod (x * m)) / x) mod m.

This gives me a way to compute q mod m without directly dividing or using inverses.

I can implement this as:

q = (p % (x * m)) // x

Then, q mod m = q % m

This should work as long as p is divisible by x, which it is.

Let me test this with the first sample input.

First step:

a = [3,1,4,2], p = 3*1*4*2 = 24, m=6, p mod m = 24 mod 6 = 0

Output: 0

Then, remove 'L', which is 3.

Compute q = (24 % (3 * 6)) // 3 = (24 % 18) // 3 = 6 // 3 = 2

Then, q mod m = 2 mod 6 = 2

Which matches the sample output.

Next step:

a = [1,4,2], p = 1*4*2 = 8, m=6, p mod m = 8 mod 6 = 2

Output: 2

Remove 'R', which is 2.

Compute q = (8 % (2 * 6)) // 2 = (8 % 12) // 2 = 8 // 2 = 4

Then, q mod m = 4 mod 6 = 4

Which matches the sample output.

Next step:

a = [1,4], p = 1*4 = 4, m=6, p mod m = 4 mod 6 = 4

Output: 4

Remove 'R', which is 4.

Compute q = (4 % (4 * 6)) // 4 = (4 % 24) // 4 = 4 // 4 = 1

Then, q mod m = 1 mod 6 = 1

Which matches the sample output.

Final step:

a = [1], p = 1, m=6, p mod m = 1 mod 6 = 1

Output: 1

Remove 'L', which is 1.

Compute q = (1 % (1 * 6)) // 1 = (1 % 6) // 1 = 1 // 1 = 1

Then, q mod m = 1 mod 6 = 1

But in the sample, after removing the last element, the array is empty, and no output is produced for that step.

Wait, in the sample output, for n=4, there are 4 outputs, corresponding to each command.

So, in the last step, after removing the last element, the array is empty, and no further output is produced.

So, in code, I need to ensure that after removing the last element, I don't try to compute the product of an empty array.

This seems to work.

Therefore, I can implement this approach:

- Compute the product of all elements modulo (x * m), where x is the removed element.

- Then, compute q = (p % (x * m)) // x

- Then, q mod m is the new product modulo m.

- Repeat this for each removal.

But, there's a catch.

Computing the product of all elements modulo (x * m) could be problematic because x can be up to 10^4, and m is up to 10^4, so x * m can be up to 10^8, which is manageable, but p can be up to (10^4)^n, which is way too big to handle directly.

In Python, integers can be arbitrarily large, so I can compute p directly, but it's inefficient for large n.

Given that n can be up to 2*10^5, computing p directly is not feasible due to time constraints.

I need a better way.

Wait, perhaps I can maintain p as the product of the current array, and update it at each step by dividing by the removed element using the above method.

But to do this efficiently, I need a way to compute p mod (x * m) without computing p directly.

This seems challenging.

Let me consider another approach.

Since the removals are specified by the string s, I can determine in advance the sequence in which elements are removed.

Then, I can compute the product of the array at each state, corresponding to the elements that haven't been removed yet.

Wait, but this seems similar to simulating the process, which is too slow.

Wait, perhaps I can compute the product of the array in its initial state, then, for each removal, adjust the product by removing the contribution of the removed element.

But again, this comes back to the division problem.

I need to find a way to efficiently compute the product of the remaining array at each step.

Let me consider that, since m is small, I can compute the product modulo m directly in a way that avoids large intermediate products.

Wait, perhaps I can compute the logarithm of the product, but that doesn't help with modular arithmetic.

Another idea: perhaps I can represent the product as a list of its prime factors and their exponents, and then, for each removal, adjust the exponents based on the prime factors of the removed element.

Then, to compute the product modulo m, I can combine the prime factors accordingly.

But this seems too time-consuming to implement, and may not be efficient enough for the time constraints.

I need to think differently.

Let me consider that, for each step, the product of the remaining array is equal to the product of all elements divided by the product of the removed elements up to that point.

So, if I keep track of the product of all removed elements, then the product of the remaining array is p / prod_removed.

But again, division is tricky.

Wait, perhaps I can compute the product of removed elements, and then compute p / prod_removed mod m.

But this brings me back to the same problem of dividing by prod_removed.

Alternatively, perhaps I can compute p / prod_removed mod m by multiplying p by the inverse of prod_removed modulo m.

But this requires that prod_removed and m are coprime, which may not be the case.

This seems like a dead end.

Let me consider that m is small, and n is large, so perhaps I can iterate through the removals and compute the product modulo m incrementally.

Wait, perhaps I can keep track of the product of the current array, updating it by dividing by the removed element using the method I described earlier.

Let me try to implement this in code and see if it works.

Define a function to compute (p / x) mod m without actually dividing.

def safe_divide(p, x, m):

# Compute q = (p % (x * m)) // x

q = (p % (x * m)) // x

# Return q mod m

return q % m

Then, in the main function, for each removal, compute the new product modulo m using this function.

But I need to compute p, the product of the current array, which changes with each removal.

This seems circular.

Wait, perhaps I can maintain the current product p, and update it after each removal.

Initialize p as the product of all elements modulo (x * m), where x is the first removed element.

Then, update p by dividing by x using safe_divide, and take p mod m.

But I'm getting tangled up here.

Let me think about the time constraints.

Given that n can be up to 2*10^5 and t up to 10^4, with the total n across all test cases up to 2*10^5, I need an O(n) per test case solution.

Perhaps I can reverse the process.

Instead of removing elements one by one and computing the product each time, perhaps I can add elements in the reverse order of removal and compute the product incrementally.

Wait, let's think about it.

If I reverse the sequence of removals, I can build the array back from empty to full, computing the product at each step.

Then, to get the sequence of products corresponding to the removals, I can reverse the sequence of computed products.

Let me try this with the first sample input.

Sample Input:

4

4 6

3 1 4 2

LRRL

Reversed s: LRRR

Start with empty array, p = 1

Add 1 (original a[1]), p = 1 * 1 = 1, output 1 mod 6 = 1

Add 4 (original a[2]), p = 1 * 4 = 4, output 4 mod 6 = 4

Add 4 (original a[3]), p = 4 * 4 = 16, output 16 mod 6 = 4

Add 3 (original a[0]), p = 16 * 3 = 48, output 48 mod 6 = 0

Then, reverse the outputs: 0, 4, 4, 1

But the sample output is 0,2,4,1

This doesn't match.

Wait, perhaps I made a mistake in the addition sequence.

Wait, no, this approach seems flawed.

Let me try again.

If I reverse the removal sequence, I need to add elements in the order they were removed.

In the first test case, s = LRRL

Removal sequence:

1. Remove L (3)

2. Remove R (2)

3. Remove R (4)

4. Remove L (1)

So, addition sequence in reverse would be:

1. Add 1 (a[