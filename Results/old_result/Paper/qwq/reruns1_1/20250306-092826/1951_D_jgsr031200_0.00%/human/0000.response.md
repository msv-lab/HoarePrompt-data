Alright, I've got this problem to solve. Let's see what it's asking for. So, Alice has n coins and wants to buy exactly k jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel that's an integer between 1 and 10^18 coins. Alice buys jewels greedily: she goes to each stall in order, buys as many jewels as she can with her remaining coins, and moves on to the next stall.

My task is to determine if Bob can set up the stalls and set the prices in such a way that Alice ends up buying exactly k jewels. If it's possible, I need to output "YES" followed by the number of stalls and the prices for each stall. If it's not possible, I should output "NO".

First, I need to understand the constraints and what exactly is being asked. The input consists of multiple test cases, each with two integers n and k, where n is the number of coins Alice has and k is the number of jewels Bob wants her to buy. Both n and k can be as large as 10^18, which means I have to be careful with how I handle large numbers.

Looking at the example provided:

In the first test case, n=7 and k=3. The output is "YES" with 10 stalls, each with prices from 2 to 11 coins. The explanation says that Alice buys 3 jewels at the first stall and doesn't have enough coins for the rest.

In the third test case, n=255 and k=8. The output is "YES" with 8 stalls, each with prices being powers of 2 from 128 down to 1. The explanation shows how Alice buys one jewel at each stall, spending all her coins in the process.

From these examples, it seems that the key is to control how many jewels Alice buys at each stall by setting the prices appropriately.

Let me think about the general approach.

I need to set up s stalls (where s ≤ 60) with prices p1, p2, ..., ps such that when Alice buys jewels at these stalls in order, she buys exactly k jewels.

One way to approach this is to maximize the number of jewels bought at lower-priced stalls and minimize at higher-priced ones, but that might not directly help. Instead, perhaps I can think in terms of how many jewels are bought at each stall based on the price set.

Let's consider that at each stall, the number of jewels Alice can buy is floor(n / pi), where pi is the price at stall i, and n is the remaining coins she has at that point.

After buying floor(n / pi) jewels, she will have n - (floor(n / pi) * pi) coins left to proceed to the next stall.

My goal is to choose pi's such that the total number of jewels bought across all stalls is exactly k.

Given that s ≤ 60, and pi can be up to 10^18, I need an efficient way to determine the prices.

Let me consider some edge cases:

1. If k = n, then Alice needs to buy one jewel per coin, which seems impossible unless pi = 1 for all stalls, but that would make her buy n jewels at the first stall itself. So, perhaps setting multiple stalls with pi = 1 won't help. Wait, no. If I set s stalls with pi = 1 for all, then she would buy n jewels at the first stall only, which is more than k if n > k. So, that doesn't work.

2. If k = 1, then Alice should buy exactly one jewel. To do this, I can set pi = n for the first stall. Then she buys one jewel and has 0 coins left, so she doesn't go to any other stalls.

3. If k > n, it's impossible because she can't buy more jewels than the number of coins she has.

Wait, no. Actually, if k > n, it might still be possible if some stalls have pi < 1, but since pi must be at least 1, then indeed, it's impossible because the minimum cost per jewel is 1 coin, so she can't buy more jewels than she has coins.

So, in that case, the answer is "NO".

Wait, but in the problem statement, it says 1 ≤ pi ≤ 10^18, so pi cannot be less than 1.

Hence, if k > n, it's impossible.

Similarly, if k = 0, which isn't allowed since k is at least 1, according to the constraints.

So, in summary:

- If k > n, output "NO"

- Else, try to find a way to set up s ≤ 60 stalls with prices pi ≤ 10^18 such that Alice buys exactly k jewels.

Now, I need to find a strategy to set up these stalls.

One straightforward way is to set up stalls with decreasing prices, starting from a high price and going down to 1.

For example, in the third test case, they set up stalls with prices 128, 64, 32, 16, 8, 4, 2, 1, which are powers of 2.

This seems similar to binary representation.

In fact, in that case, Alice buys one jewel at each stall where her remaining coins are greater than or equal to the price.

Given that, it seems that by setting prices as powers of 2, we can control exactly how many jewels she buys.

Wait, but in the first test case, they set up 10 stalls with prices from 2 to 11, and Alice buys 3 jewels at the first stall.

Wait, but according to the explanation, she buys 3 jewels at the first stall and has 1 coin left, which is not enough for any other stall.

So, in that case, it's not about buying one jewel per stall, but rather buying multiple jewels at lower-priced stalls.

So, perhaps there are different strategies depending on the values of n and k.

Let me think about a general approach.

I need to make sure that the total number of jewels bought is exactly k.

One way to ensure this is to have the first s-1 stalls set up in such a way that Alice buys a certain number of jewels, and the last stall is set to adjust the total to exactly k.

But I need to make sure that the number of stalls doesn't exceed 60.

Given that s can be up to 60, which is a relatively small number, perhaps it's feasible to set up stalls with specific prices to control the jewel buying process.

Another idea is to use the fact that the number of jewels bought at each stall is floor(n / pi), and then update n to n - floor(n / pi) * pi for the next stall.

I need to choose pi's such that the sum of floor(n / pi) over all stalls is exactly k.

This seems tricky because floor functions are involved, and pi's can be very large.

Let me consider a simpler case first.

Suppose s = 1. Then, Alice buys floor(n / p1) jewels. To have this equal to k, p1 must be ceil(n / k). Because floor(n / p1) = k implies that p1 is the smallest integer such that n / p1 >= k, which is p1 = ceil(n / k).

But, if p1 = ceil(n / k), then floor(n / p1) might be less than k in some cases due to rounding.

Wait, let's check.

Let p1 = ceil(n / k). Then, floor(n / p1) = floor(n / ceil(n / k)).

We need to see if this equals k.

Consider n = 10, k = 3.

Then, ceil(10 / 3) = 4.

Then, floor(10 / 4) = 2, which is less than 3.

So, in this case, with s = 1, it's not possible to make Alice buy exactly 3 jewels.

Hence, s = 1 is insufficient in some cases.

Therefore, we need to consider multiple stalls.

Let me try s = 2.

With s = 2, I can set p1 and p2.

I need floor(n / p1) + floor((n - floor(n / p1) * p1) / p2) = k.

This seems complicated to solve directly.

Maybe I can think recursively.

First, choose p1 such that floor(n / p1) = k1, and then the remaining coins are n - k1 * p1, and then choose p2 such that floor((n - k1 * p1) / p2) = k2, and so on, until the total jewels bought is k.

But this seems too vague.

Perhaps I need a better approach.

Looking back at the examples, in the first test case, with n=7 and k=3, they set up 10 stalls with prices from 2 to 11.

Alice buys 3 jewels at the first stall (7 // 2 = 3, spends 6 coins, left with 1 coin), which is not enough for any other stall, so total jewels bought is 3.

In the third test case, n=255 and k=8, with 8 stalls priced at 128,64,32,16,8,4,2,1.

Alice buys one jewel at each stall, spending 128, then 64, then 32, etc., until all coins are spent, buying a total of 8 jewels.

So, in this case, by setting prices as powers of 2, we can control the number of jewels bought at each stall.

Wait a minute, in the first test case, they set up multiple stalls but Alice only buys from the first stall.

So, perhaps the idea is to set the first stall with a price such that she buys as many jewels as possible without exceeding k, and then adjust the remaining stalls for the remaining jewels.

But this seems too vague.

Let me think differently.

Suppose I set up s stalls with prices p1, p2, ..., ps.

I need to choose p1, p2, ..., ps such that sum over i of floor(ni / pi) = k, where ni is the remaining coins after stall i-1.

This seems too general. Maybe I need to find a way to minimize s.

But s can be up to 60, so it's not a big issue.

Another idea: since s can be up to 60, and pi can be up to 10^18, perhaps I can set up stalls with decreasing prices, starting from a high price and going down, to control the number of jewels bought at each stall.

For example, set p1 = ceil(n / k), but as we saw earlier, this might not work directly.

Wait, perhaps I can use the greedy approach: set p1 as high as possible without exceeding the number of jewels needed.

Wait, maybe it's better to set p1 as low as possible to maximize the number of jewels bought at the first stall.

But in the first test case, they set p1=2, which is not the lowest possible, but it results in buying 3 jewels.

Wait, perhaps I need to set p1 such that floor(n / p1) is as close as possible to some value.

This is getting too vague.

Let me look at the provided program and see what it's doing.

The program defines a function func_1(n, k):

- If n == k, it prints "YES", followed by 1 and then 1.

- If n < k, it prints "NO".

- Otherwise, it sets costs = [n - k + 1, 1] and calculates h, the total number of jewels bought with these two prices.

- If h < k, it prints "NO"; else, it prints "YES", followed by 2 and then the two prices.

Wait, this seems too simplistic. In the first test case, n=7 and k=3.

So, costs = [7 - 3 + 1 = 5, 1].

Then, h is calculated:

- With p1=5, Alice buys floor(7/5)=1 jewel, spends 5 coins, left with 2 coins.

- With p2=1, buys floor(2/1)=2 jewels, spends 2 coins, left with 0 coins.

- Total jewels bought: 1 + 2 = 3, which matches k=3.

Hence, it should output "YES" followed by 2 and then 5 1.

But in the example, it uses 10 stalls with prices from 2 to 11, which also results in buying 3 jewels.

So, both are valid, but the program only uses 2 stalls in this case.

Similarly, in the third test case, n=255 and k=8.

According to the program, costs = [255 - 8 + 1 = 248, 1].

Then, h is:

- With p1=248, buys floor(255/248)=1 jewel, spends 248 coins, left with 7 coins.

- With p2=1, buys floor(7/1)=7 jewels, spends 7 coins, left with 0 coins.

- Total jewels: 1 + 7 = 8, which matches k=8.

Hence, the program seems to work for these cases.

But in the first test case, the example uses 10 stalls, while the program uses only 2.

Both are valid since s can be up to 60.

So, the program seems correct for these cases.

But is it always correct?

Let me consider another test case.

Suppose n=5 and k=2.

Then, costs = [5 - 2 + 1 = 4, 1].

- With p1=4, buys floor(5/4)=1 jewel, spends 4 coins, left with 1 coin.

- With p2=1, buys floor(1/1)=1 jewel, spends 1 coin, left with 0 coins.

- Total jewels: 1 + 1 = 2, which matches k=2.

Good.

Another test case: n=10, k=3.

costs = [10 - 3 + 1 = 8, 1].

- p1=8: buys floor(10/8)=1 jewel, spends 8 coins, left with 2 coins.

- p2=1: buys floor(2/1)=2 jewels, spends 2 coins, left with 0 coins.

- Total jewels: 1 + 2 = 3, which matches k=3.

Good.

Another test case: n=1, k=1.

costs = [1 - 1 + 1 = 1, 1].

- p1=1: buys floor(1/1)=1 jewel, spends 1 coin, left with 0 coins.

- p2=1: no coins left, buys 0 jewels.

- Total jewels: 1 + 0 = 1, which matches k=1.

Good.

Another test case: n=1, k=2.

Since n < k, output "NO", which is correct.

Another test case: n=2, k=1.

costs = [2 - 1 + 1 = 2, 1].

- p1=2: buys floor(2/2)=1 jewel, spends 2 coins, left with 0 coins.

- p2=1: no coins left, buys 0 jewels.

- Total jewels: 1 + 0 = 1, which matches k=1.

Good.

Another test case: n=1000000000000000000, k=1.

costs = [10^18 - 1 + 1 = 10^18, 1].

- p1=10^18: buys floor(n / 10^18)=1 jewel, spends n coins, left with 0 coins.

- p2=1: no coins left, buys 0 jewels.

- Total jewels: 1 + 0 = 1, which matches k=1.

Good.

Another test case: n=10, k=5.

costs = [10 - 5 + 1 = 6, 1].

- p1=6: buys floor(10/6)=1 jewel, spends 6 coins, left with 4 coins.

- p2=1: buys floor(4/1)=4 jewels, spends 4 coins, left with 0 coins.

- Total jewels: 1 + 4 = 5, which matches k=5.

Good.

Seems like this approach works for various cases.

But is there any case where h < k?

Let me think.

Suppose n=10, k=4.

costs = [10 - 4 + 1 = 7, 1].

- p1=7: buys floor(10/7)=1 jewel, spends 7 coins, left with 3 coins.

- p2=1: buys floor(3/1)=3 jewels, spends 3 coins, left with 0 coins.

- Total jewels: 1 + 3 = 4, which matches k=4.

Good.

Another case: n=10, k=3.

costs = [10 - 3 + 1 = 8, 1].

- p1=8: buys floor(10/8)=1 jewel, spends 8 coins, left with 2 coins.

- p2=1: buys floor(2/1)=2 jewels, spends 2 coins, left with 0 coins.

- Total jewels: 1 + 2 = 3, which matches k=3.

Good.

Wait, what if n=10, k=2.

costs = [10 - 2 + 1 = 9, 1].

- p1=9: buys floor(10/9)=1 jewel, spends 9 coins, left with 1 coin.

- p2=1: buys floor(1/1)=1 jewel, spends 1 coin, left with 0 coins.

- Total jewels: 1 + 1 = 2, which matches k=2.

Good.

Another case: n=10, k=1.

costs = [10 - 1 + 1 = 10, 1].

- p1=10: buys floor(10/10)=1 jewel, spends 10 coins, left with 0 coins.

- p2=1: no coins left, buys 0 jewels.

- Total jewels: 1 + 0 = 1, which matches k=1.

Good.

Seems consistent.

But what if n=10, k=6.

costs = [10 - 6 + 1 = 5, 1].

- p1=5: buys floor(10/5)=2 jewels, spends 10 coins, left with 0 coins.

- p2=1: no coins left, buys 0 jewels.

- Total jewels: 2 + 0 = 2, which is less than k=6.

Hence, h = 2 < 6, so it would output "NO".

But is there a way to set up stalls to make Alice buy exactly 6 jewels with n=10 coins?

Let's see.

If s=1: p1=ceil(10/6)=2, floor(10/2)=5 jewels, which is more than 6.

Not useful.

s=2: Let's try p1=3, p2=2.

- p1=3: buys floor(10/3)=3 jewels, spends 9 coins, left with 1 coin.

- p2=2: cannot buy any jewels with 1 coin.

- Total jewels: 3 + 0 = 3 < 6.

Not enough.

Try p1=2, p2=1.

- p1=2: buys floor(10/2)=5 jewels, spends 10 coins, left with 0 coins.

- p2=1: no jewels.

- Total jewels: 5 + 0 = 5 < 6.

Still not enough.

Try p1=4, p2=1.

- p1=4: buys floor(10/4)=2 jewels, spends 8 coins, left with 2 coins.

- p2=1: buys floor(2/1)=2 jewels, spends 2 coins, left with 0 coins.

- Total jewels: 2 + 2 = 4 < 6.

Still not enough.

Try p1=3, p2=2, p3=1.

- p1=3: buys floor(10/3)=3 jewels, spends 9 coins, left with 1 coin.

- p2=2: cannot buy any jewels with 1 coin.

- p3=1: buys floor(1/1)=1 jewel, spends 1 coin, left with 0 coins.

- Total jewels: 3 + 0 + 1 = 4 < 6.

Still not enough.

It seems impossible to make Alice buy exactly 6 jewels with 10 coins using at most 60 stalls.

Hence, in this case, "NO" is the correct output.

So, the program seems to be working correctly for this case as well.

Another test case: n=15, k=5.

costs = [15 - 5 + 1 = 11, 1].

- p1=11: buys floor(15/11)=1 jewel, spends 11 coins, left with 4 coins.

- p2=1: buys floor(4/1)=4 jewels, spends 4 coins, left with 0 coins.

- Total jewels: 1 + 4 = 5, which matches k=5.

Good.

Another test case: n=20, k=4.

costs = [20 - 4 + 1 = 17, 1].

- p1=17: buys floor(20/17)=1 jewel, spends 17 coins, left with 3 coins.

- p2=1: buys floor(3/1)=3 jewels, spends 3 coins, left with 0 coins.

- Total jewels: 1 + 3 = 4, which matches k=4.

Good.

Seems consistent.

Wait, but in the first test case, n=7 and k=3, the program would set costs=[7-3+1=5,1].

- p1=5: buys floor(7/5)=1 jewel, spends 5 coins, left with 2 coins.

- p2=1: buys floor(2/1)=2 jewels, spends 2 coins, left with 0 coins.

- Total jewels: 1 + 2 = 3, which matches k=3.

But in the example, they set up 10 stalls with prices from 2 to 11, resulting in buying 3 jewels.

So, both approaches are valid.

Hence, the program seems correct.

But to be thorough, let's consider a case where k > n.

For example, n=5, k=6.

Since n < k, output "NO", which is correct.

Another case: n=5, k=5.

costs = [5 - 5 + 1 = 1, 1].

- p1=1: buys floor(5/1)=5 jewels, spends 5 coins, left with 0 coins.

- p2=1: no coins left, buys 0 jewels.

- Total jewels: 5 + 0 = 5, which matches k=5.

Good.

Another case: n=5, k=1.

costs = [5 - 1 + 1 = 5, 1].

- p1=5: buys floor(5/5)=1 jewel, spends 5 coins, left with 0 coins.

- p2=1: no coins left, buys 0 jewels.

- Total jewels: 1 + 0 = 1, which matches k=1.

Good.

Seems like the program is correct for these cases.

Hence, Correctness: **True**