Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I need to perform exactly K operations on it. In each operation, I can select any contiguous subarray (which could even be empty) and insert the sum of that subarray anywhere in the array. My goal is to maximize the sum of the array after K operations, and since the sum can be very large, I need to output it modulo 10^9 + 7.

First, I need to understand what exactly an operation does. So, in one operation, I choose a contiguous subarray, compute its sum, and then insert that sum into the array at any position I like. This means that the array can grow with each operation because I'm adding a new element (the sum) to it.

My task is to perform exactly K such operations and maximize the sum of the array after these operations. The sum of the array is just the sum of all its elements, and since I'm adding new elements (which are sums of subarrays), I need to strategically choose which subarrays to sum and where to insert them to maximize the total sum.

Let me consider a simple example to get a better understanding. Suppose I have an array [1, 2, 3] and K=1. If I choose the entire array as the subarray, its sum is 6, and I can insert 6 anywhere in the array. If I insert it at the end, the new array becomes [1, 2, 3, 6], and the sum is 12. Alternatively, if I choose a different subarray, say [2, 3], sum is 5, and insert it somewhere, say at the beginning, the new array is [5, 1, 2, 3], with sum 11, which is less than 12. So, in this case, choosing the entire array seems optimal.

Another example: array [-1, -2], K=1. If I choose the entire array, sum is -3, and inserting it into the array would give [-1, -2, -3], sum is -6, which is worse than the original sum of -3. If I choose an empty subarray, sum is 0, and insert it anywhere, the array becomes [-1, 0, -2] or [-1, -2, 0], with sum -3, which is better than -6. So, in this case, choosing an empty subarray is better.

From this, I can see that choosing the subarray with the maximum possible sum would be beneficial, but in cases where all elements are negative, choosing an empty subarray might be better.

Wait, in the first example of the problem, they have n=2, k=2, array [-4, -7]. They say that taking empty subarrays twice and inserting their sum (which is 0) anywhere results in a sum of -11, which modulo 10^9 + 7 is 999,999,996. So, in this case, choosing empty subarrays seems to be the way to go.

In the second example, n=3, k=3, array [2,2,8]. They perform three operations by choosing the entire array each time and inserting its sum, which is 12, and the final array sum is 96.

So, it seems that choosing the subarray with the maximum sum and inserting it is the way to go. But I need to generalize this.

Let me think about what happens in each operation. I choose a subarray, compute its sum, and insert it into the array. The sum of the array increases by the sum I insert. So, if I insert S, the sum becomes sum_a + S, where sum_a is the current sum of the array.

If I choose the same subarray each time and insert its sum, the sum of the array would increase by S in each operation. But I can choose different subarrays in different operations.

Wait, but the problem allows me to insert the sum of the subarray anywhere in the array. So, in each operation, I can choose any subarray, compute its sum, and insert it at any position in the array.

But, since I'm allowed to insert anywhere, and the sum of the array is just the total of all elements, the position where I insert the sum doesn't matter for the total sum. So, I can think of each operation as adding S to the sum of the array, where S is the sum of the subarray I choose.

Therefore, the total sum after K operations would be the original sum plus the sum of the K inserted sums.

My goal is to maximize this total sum.

So, I need to choose K subarrays, compute their sums, and add those sums to the original sum.

But there's a dependency because after inserting a sum, the array changes, and subsequent operations can choose subarrays that include previously inserted sums.

This seems a bit tricky. Let me see if there's a better way to approach this.

Wait a minute. Suppose I fix the subarray whose sum I will insert in each operation. If I choose the same subarray each time, then in each operation, I'm adding the same sum to the array.

But the array is changing because I'm inserting new elements, which affects future operations.

This seems messy. Maybe I need to think differently.

Let me consider the maximum possible sum I can achieve.

In each operation, I can choose any contiguous subarray, compute its sum, and insert it anywhere.

I can think of it as, in each operation, I'm adding to the array a new element which is equal to the sum of some contiguous subarray.

I need to choose which subarrays to sum and insert in order to maximize the total sum after K operations.

An important observation is that the sum of the array after K operations is the original sum plus the sum of the K inserted sums.

So, to maximize the total sum, I need to maximize the sum of the K inserted sums.

Therefore, the problem reduces to selecting K subarrays, computing their sums, and choosing those K sums such that their total is maximized.

But there's a catch: each time I insert a sum, the array changes, which affects the possible subarrays for future operations.

This seems complicated. Is there a way to simplify this?

Let me consider that the position where I insert the sum doesn't matter for the total sum, as discussed earlier. So, I can focus solely on choosing K subarrays whose sums I will add to the original sum.

But the array changes after each insertion, so the possible subarrays change.

Wait, but since the position where I insert the sum affects future subarrays, this is getting too tangled.

Maybe I need to find a different perspective.

Let me consider that each time I insert a sum, I'm effectively adding that sum to the total, and that sum can be part of future subarrays.

But this seems too vague.

Perhaps I should look for a pattern or a mathematical formula that can express the total sum after K operations.

Let me denote S as the original sum of the array.

In the first operation, I choose a subarray with sum S1 and insert it, so the new sum is S + S1.

In the second operation, I choose a subarray with sum S2 and insert it, so the new sum is S + S1 + S2.

And so on, up to K operations.

Therefore, the total sum after K operations is S + S1 + S2 + ... + SK.

My goal is to maximize this sum, which means I need to maximize the sum of S1 to SK.

Now, what is the best choice for S1 to SK?

If I choose the subarray with the maximum possible sum in each operation, that would seem optimal.

But is that always the case?

Let me consider an example.

Suppose I have an array [1, 2, 3], K=2.

Option 1:

Operation 1: choose [1,2,3], sum=6, insert at end: [1,2,3,6], sum=12

Operation 2: choose [6], sum=6, insert at end: [1,2,3,6,6], sum=18

Total sum: 18

Option 2:

Operation 1: choose [1,2,3], sum=6, insert at end: [1,2,3,6], sum=12

Operation 2: choose [1,2,3,6], sum=12, insert at end: [1,2,3,6,12], sum=24

Total sum: 24

Option 3:

Operation 1: choose [3], sum=3, insert at beginning: [3,1,2,3], sum=9

Operation 2: choose [3,1,2,3], sum=9, insert at end: [3,1,2,3,9], sum=18

Total sum: 18

So, in this case, choosing the maximum sum subarray in each operation leads to a higher sum.

Another example: array [-1, -2], K=1.

Option 1:

Operation 1: choose empty subarray, sum=0, insert at end: [-1, -2, 0], sum=-3

Total sum: -3

Option 2:

Operation 1: choose [-1, -2], sum=-3, insert at end: [-1, -2, -3], sum=-6

Total sum: -6

So, in this case, choosing the empty subarray is better.

Wait, but in the first example provided in the problem, with n=2, k=2, array [-4, -7], they choose empty subarrays twice, resulting in a sum of -11.

If they had chosen the entire array as the subarray, sum would be -11 after the first operation, and then choosing an empty subarray in the second operation would insert 0, making the sum still -11. But according to the problem, choosing empty subarrays twice results in sum -11, which modulo 10^9 + 7 is 999,999,996.

So, in this case, choosing empty subarrays is better than choosing the entire array.

From these examples, it seems that in each operation, choosing the subarray with the maximum sum is the way to go, and in cases where all elements are negative, choosing the empty subarray (sum=0) is better.

In standard array problems, the maximum sum subarray is found using Kadane's algorithm, which can handle both positive and negative numbers and finds the subarray with the largest sum.

Moreover, Kadane's algorithm can also handle the case where the maximum sum is 0, which corresponds to choosing an empty subarray.

So, perhaps in each operation, I should find the maximum sum subarray (which could be empty, sum=0), and insert that sum into the array.

But wait, in the second example, they chose the entire array in each operation, which seems contradictory.

Wait, in that example, the array is [2,2,8], and choosing the entire array sum=12, and inserting it multiple times increases the sum significantly.

But according to my earlier reasoning, in each operation, choosing the maximum sum subarray (which is the entire array in this case) is indeed optimal.

So, perhaps the strategy is to find the maximum sum subarray in the original array, and then in each operation, choose that subarray and insert its sum into the array.

But there's a catch: after inserting the sum, the array changes, and potentially, new subarrays with higher sums can be formed.

In the second example, after inserting 12, the array becomes [2,2,8,12], and the maximum sum subarray is now [12], sum=12, which is better than the original [2,2,8], sum=12. So, in the next operation, choosing [12] and inserting 12 again increases the sum by 12.

Wait, but in the first operation, choosing the entire array [2,2,8], sum=12, and inserting it makes the array [2,2,8,12], sum=24.

In the second operation, choosing [12], sum=12, and inserting it makes the array [2,2,8,12,12], sum=36.

In the third operation, choosing [12], sum=12, and inserting it makes the array [2,2,8,12,12,12], sum=48.

But according to the problem's output, the sum is 96, which suggests that perhaps they are choosing the entire array each time.

Wait, if you choose the entire array in each operation, sum=24, then insert 24, making the array [2,2,8,24], sum=36.

Then choose the entire array again, sum=36, insert 36, making [2,2,8,24,36], sum=72.

Then choose the entire array again, sum=72, insert 72, making [2,2,8,24,36,72], sum=144.

But according to the problem, the sum is 96, which doesn't match.

Wait, perhaps I misread the operations.

Let me look back at the note in the example.

In the second test case, it says: "take the sum of the entire array three times and place it anywhere in the array, then one of the possible sequences of actions: [2,2,8] -> [2,2,8,12] -> [2,2,8,12,24] -> [2,2,8,12,24,48], the sum of the final array is 2+2+8+12+24+48=96."

Ah, I see. So, in each operation, they are choosing the entire array, summing it, and inserting the sum at the end.

So, operation 1: sum=[2,2,8]=12, insert 12, array becomes [2,2,8,12], sum=24.

Operation 2: sum=[2,2,8,12]=24, insert 24, array becomes [2,2,8,12,24], sum=48.

Operation 3: sum=[2,2,8,12,24]=48, insert 48, array becomes [2,2,8,12,24,48], sum=96.

So, in each operation, they are choosing the entire array, summing it, and inserting the sum at the end.

This seems different from what I thought earlier, where I was considering choosing the maximum sum subarray, which in this case is the entire array, but the sum increases exponentially.

Wait, but in my earlier calculation, I also chose the entire array each time, but the sum was increasing differently.

Wait, no, in my earlier calculation, after inserting 12, the array is [2,2,8,12], sum=24.

Then, choosing the entire array again, sum=24, insert 24, array becomes [2,2,8,12,24], sum=48.

Then, choosing the entire array again, sum=48, insert 48, array becomes [2,2,8,12,24,48], sum=96.

Yes, now I see that it matches the problem's example.

So, in each operation, choosing the entire array, summing it, and inserting the sum at the end leads to the sum doubling plus the original sum.

Wait, no. Wait, in the first operation, sum=12, insert 12, sum becomes 24.

Second operation, sum=24, insert 24, sum becomes 48.

Third operation, sum=48, insert 48, sum becomes 96.

So, each operation doubles the sum.

Wait, but 12 + 12 = 24, 24 + 24 = 48, 48 + 48 = 96.

So, each operation is adding the current sum to itself.

Therefore, the sum after K operations is S + S*2 + S*4 + ... + S*2^{K-1}.

Wait, no.

Wait, in the first operation, sum is S, choose subarray with sum S, insert S, new sum is S + S = 2S.

In the second operation, sum is 2S, choose subarray with sum 2S, insert 2S, new sum is 2S + 2S = 4S.

In the third operation, sum is 4S, choose subarray with sum 4S, insert 4S, new sum is 4S + 4S = 8S.

So, it's doubling the sum in each operation.

Hence, after K operations, the sum is S * 2^K.

But in the first test case, S = -4 + (-7) = -11.

After K=2 operations, sum should be -11 * 4 = -44, but the problem says it's -11, which modulo 10^9 + 7 is 999,999,996.

Wait, that doesn't match.

Wait, in the first test case, they choose empty subarrays, sum=0, and insert 0 twice, so sum remains -11.

But according to my earlier reasoning, if I choose the entire array each time, sum would be -11 * 2^K.

But in the first test case, choosing the entire array would lead to sum=-11 * 2^K, which is worse than choosing empty subarrays.

So, in cases where S is negative, choosing empty subarrays (sum=0) is better.

Hence, perhaps the strategy is:

- If S > 0, choose the entire array in each operation, sum=S, insert S, and the sum doubles each time.

- If S <= 0, choose the maximum sum subarray in each operation, which could be empty (sum=0), and insert 0.

But in the second test case, S=2+2+8=12, which is positive, so choosing the entire array leads to sum=12 * 2^K.

But in the problem's explanation, they perform K=3 operations, and sum=96, which is 12 * 8 = 96, which matches 12 * 2^3 = 96.

Hence, for S > 0, choosing the entire array in each operation is optimal.

For S <= 0, choosing the maximum sum subarray, which could be empty (sum=0), is better.

Wait, but in the fourth test case, n=5, k=1, array [4,-2,8,-12,9], sum=4-2+8-12+9=7.

They choose a subarray [4,-2,8], sum=10, insert 10 at the beginning, making the array [10,4,-2,8,-12,9], sum=17.

But according to my earlier strategy, since S=7 > 0, choosing the entire array would lead to sum=7*2=14, which is less than 17.

So, in this case, choosing a different subarray leads to a higher sum.

Hence, my earlier strategy is not always optimal.

Therefore, I need to refine my approach.

Let me think differently.

In each operation, I can choose any contiguous subarray, sum it, and insert the sum into the array.

I need to maximize the sum after K operations.

I need to choose K subarrays, sum them, and add those sums to the original sum.

But because the array changes after each insertion, it's not straightforward.

An alternative approach is to realize that each inserted sum can be treated as an independent addition to the total sum, but with dependencies based on how the subarrays are chosen.

Wait, perhaps I can model this as the original sum plus K times the sum of the chosen subarrays.

But the chosen subarrays can overlap or be in different parts of the array.

This seems complicated.

Let me consider that after each insertion, the array changes, and future operations can choose subarrays that include previously inserted sums.

This suggests that the inserted sums can be part of future subarrays, potentially allowing their sums to be added multiple times.

In the second test case, by choosing the entire array each time and inserting the sum, the inserted sum becomes part of the array and can be chosen again in the next operation, leading to exponential growth in the sum.

But in the fourth test case, choosing a specific subarray leads to a higher sum than choosing the entire array.

Hence, perhaps the optimal strategy is to choose the subarray with the maximum possible sum in each operation and insert it.

But how do I find the subarray with the maximum sum in each operation, especially since the array changes after each insertion?

This seems too time-consuming, especially given the constraints (n and k up to 2e5).

I need a smarter way to compute this.

Let me consider that after each insertion, the array changes, but the inserted sum is just an additional element in the array.

So, if I insert S, the array now has an extra element S, and in the next operation, I can choose any subarray including or excluding this new element.

But keeping track of all these insertions seems too involved.

Perhaps I can find a mathematical formula that allows me to compute the total sum after K operations without simulating each operation.

Let me denote:

- S: original sum of the array.

- M: maximum sum of any subarray in the original array.

Then, in each operation, I can choose a subarray with sum up to M and insert it, adding M to the sum.

So, naively, it seems that the total sum after K operations could be S + K*M.

But in reality, it's possible to do better by choosing subarrays that include previously inserted sums.

Wait, for example, in the second test case, choosing the entire array each time and inserting its sum leads to a sum of S * 2^K.

But in the fourth test case, choosing a specific subarray leads to a higher sum than S * 2^K.

Wait, in the fourth test case, S=7, K=1, choosing [4,-2,8], sum=10, insert 10, total sum=17, which is higher than S + M, where M=10, which would be 17.

But since K=1, it's the same.

Wait, perhaps for K=1, S + M is the maximum sum.

But in the second test case, with K=3, S=12, M=12, S + 3*M = 48, but the actual sum is 96, which is higher.

So, choosing the entire array each time leads to S * 2^K, which is better than S + K*M.

Hence, perhaps the optimal strategy is:

- If S > 0, choose the entire array in each operation, sum=S, insert S, and the sum becomes S * (2^K).

- If S <= 0, choose the maximum sum subarray, which could be empty (sum=0), and insert 0 in each operation, so the sum remains S + 0*K = S.

But in the fourth test case, S=7, M=10, and choosing a subarray with sum M=10 and inserting it leads to sum=S + M =17, which is better than S * 2^K =14.

Hence, in this case, choosing a subarray with sum M and inserting it once gives a better sum than choosing the entire array.

Wait, but in this case, K=1, so S + M =17, which is better than S * 2 =14.

Hence, perhaps for K=1, choosing the subarray with the maximum sum M and inserting it once gives S + M, which is better than S * 2.

Wait, but for K >1, choosing the entire array and inserting S each time leads to S * 2^K, which might be better or worse than choosing M each time.

Wait, in the second test case, S=12, M=12, so S + K*M =12 + 3*12=48, but choosing S each time gives S * 2^K =12*8=96, which is better.

Wait, but M is equal to S in this case, so S + K*M =12 + 3*12=48, while S*2^K=96.

Hence, choosing S each time is better.

In the fourth test case, S=7, M=10, K=1, choosing M gives S + M =17, which is better than S * 2 =14.

Hence, for K=1, choosing M is better.

For K=2, choosing S each time would give S * 4 =28, while choosing M each time would give S + 2*M =7 + 2*10=27, which is worse than choosing S each time.

Wait, but in the first operation, choosing M=10 and inserting it makes the sum S + M =17.

In the second operation, choosing the entire array sum=17 and inserting it makes the sum 17 +17=34, which is better than 27.

Hence, for K=2, choosing S each time gives S * 4 =28, choosing M each time gives S + 2*M=27, and choosing S in the second operation gives 34, which is better.

Hence, it seems that choosing S in each operation is better when S > M, which is not the case here since M=10 > S=7.

Wait, in this case, choosing S in the second operation gives a better sum than choosing M.

Hence, perhaps the optimal strategy is:

- In the first operation, choose the subarray with sum M and insert it, adding M to the sum.

- In the subsequent operations, choose the entire array and insert its sum, which would be S + M, and double it each time.

Wait, in the fourth test case, with K=2:

Operation 1: choose [4,-2,8], sum=10, insert 10, sum=17.

Operation 2: choose the entire array [4,-2,8,-12,9,10], sum=17, insert 17, sum=34.

Total sum: 34.

Alternatively, choosing M=10 in both operations: S + 2*M =7 + 2*10=27, which is worse.

Choosing S each time: S * 4 =28, which is worse than 34.

Hence, in this case, choosing M in the first operation and S in the subsequent operations is better.

Hence, perhaps the optimal strategy is:

- In the first operation, choose the subarray with sum M and insert it.

- In the remaining K-1 operations, choose the entire array and insert its sum, which is S + M, and double it each time.

Hence, the total sum would be S + M + (S + M) * (2^{K-1} - 1).

Wait, let's see.

Wait, in the fourth test case, S=7, M=10, K=1: sum=7 +10=17.

For K=2: sum=7 +10 + (7 +10)=27, but according to earlier calculation, it should be 34.

Wait, no, in the second operation, choosing the entire array sum=17 and inserting 17, so sum becomes 17 +17=34.

Hence, the formula should be: sum after K operations = S + M + (S + M) * (2^{K-1} - 1).

Wait, in this case, S + M + (S + M) * (2^{1} -1) =17 +17*1=34, which matches.

For K=3: sum=7 +10 +17 +17*2=7 +10 +17 +34=68.

But according to the earlier pattern, it should be S + M + (S + M) * (2^{K-1} -1) =7 +10 + (17)*(2^{2}-1)=7 +10 +17*3=7 +10 +51=68.

Hence, it seems consistent.

Hence, the general formula is:

Sum after K operations = S + M + (S + M) * (2^{K-1} -1)

Simplify this:

Sum = S + M + (S + M) * (2^{K-1} -1)

     = S + M + (S + M) * 2^{K-1} - (S + M)

     = (S + M) * 2^{K-1} - (S + M) + S + M

     = (S + M) * 2^{K-1}

Hence, sum after K operations = (S + M) * 2^{K-1}

Wait, but in the fourth test case, S=7, M=10, K=1: sum=7 +10=17, which is equal to (7 +10)*2^{0}=17*1=17.

For K=2: (7 +10)*2^{1}=17*2=34.

For K=3: (7 +10)*2^{2}=17*4=68.

Which matches the earlier calculations.

Hence, the general formula seems to be sum after K operations = (S + M) * 2^{K-1}

But in the second test case, S=12, M=12, K=3: sum=(12 +12)*2^{2}=24*4=96, which matches the problem's example.

In the first test case, S=-11, M=0 (since choosing empty subarray), K=2: sum=( -11 +0 )*2^{1}=-11*2=-22, but according to the problem, it's -11.

Wait, that doesn't match.

Wait, in the first test case, they choose empty subarrays twice, sum=-11.

So, according to my formula, sum=(S + M)*2^{K-1}=(-11 +0)*2^{1}=-22, which doesn't match the problem's sum of -11.

Hence, my formula seems incorrect in this case.

Wait, perhaps I need to adjust the formula.

Wait, in the first operation, choosing empty subarray, sum=0, insert 0, sum becomes -11 +0=-11.

In the second operation, choosing empty subarray again, sum=0, insert 0, sum remains -11.

Hence, total sum is -11.

But according to my formula, (S + M)*2^{K-1}=(-11 +0)*2^{1}=-22, which is wrong.

Hence, my formula is not accurate.

I need to find a better way.

Let me think differently.

Let me consider that in the first operation, I can choose any subarray, sum it, and insert it.

In the subsequent operations, I can choose the entire array, which includes the previously inserted sum, and insert the sum of the entire array.

Hence, in the first operation, choose a subarray with sum X, insert X, sum becomes S + X.

In the second operation, choose the entire array, sum is S + X, insert S + X, sum becomes S + X + (S + X)=2*(S + X).

In the third operation, choose the entire array, sum is 2*(S + X), insert it, sum becomes 2*(S + X) + 2*(S + X)=4*(S + X).

And so on, up to K operations.

Hence, after K operations, sum is (S + X) * 2^{K-1}.

My goal is to choose X to maximize this sum.

But X is the sum of some subarray in the original array.

Hence, to maximize (S + X) * 2^{K-1}, I need to maximize S + X.

Since 2^{K-1} is positive, maximizing S + X is equivalent to maximizing X.

Hence, the optimal choice is to choose X = M, where M is the maximum sum of any subarray in the original array.

Hence, the sum after K operations is (S + M) * 2^{K-1}.

In the first test case, S=-11, M=0, so sum=( -11 +0 ) * 2^{1}=-22, but according to the problem, it's -11.

Hence, my formula is still not matching.

Wait, perhaps I need to consider that choosing X=M in the first operation leads to sum S + M, and then in the subsequent operations, choosing the entire array leads to sum (S + M) * 2^{K-1}.

But in the first test case, choosing X=0 in the first operation leads to sum S +0=-11, and in the second operation, choosing the entire array sum=-11, insert -11, sum becomes -11 + (-11)=-22, which is worse than choosing X=0 again, leading to sum=-11 +0=-11.

Hence, to maximize the sum, in each operation, I should choose X=M, but in the first operation, choosing X=M may not be optimal if S + M is negative.

Hence, perhaps the strategy should be:

- If S + M > 0, then choose X=M in the first operation, and then in the remaining K-1 operations, choose the entire array and insert its sum, leading to sum=(S + M) * 2^{K-1}.

- If S + M <=0, then choose X=0 in each operation, leading to sum=S +0*K=S.

Wait, but in the first test case, S=-11, M=0, S + M=-11 <=0, so choose X=0 in each operation, leading to sum=S +0*K=-11, which matches the problem's output of -11 modulo 10^9 +7.

In the second test case, S=12, M=12, S + M=24 >0, so sum=(12 +12)*2^{2}=24*4=96, which matches the problem's output.

In the fourth test case, S=7, M=10, S + M=17 >0, so sum=17*2^{0}=17 for K=1, which matches their operation.

Hence, the formula seems correct.

Hence, the general formula is:

If S + M >0, sum=(S + M)*2^{K-1}

Else, sum=S

But in the first test case, S + M = -11 +0 = -11 <=0, so sum=S=-11.

In the second test case, S + M=12 +12=24 >0, so sum=24*2^{2}=96.

In the fourth test case, S + M=7 +10=17 >0, so sum=17*2^{0}=17 for K=1.

This seems consistent.

Hence, the strategy is:

- Compute S: sum of the original array.

- Compute M: maximum sum of any subarray in the original array (which could be 0 if all elements are negative).

- If S + M >0, then sum=(S + M)*2^{K-1}

- Else, sum=S

Moreover, since the sum can be very large, we need to output it modulo 10^9 +7.

Also, we need to handle negative sums correctly, especially when dealing with the modulo operation.

Hence, the steps are:

1. Read T, the number of test cases.

2. For each test case:

a. Read n and k.

b. Read the array a.

c. Compute S: sum of a.

d. Compute M: maximum sum of any subarray in a (using Kadane's algorithm).

e. If S + M >0, then sum=(S + M)*2^{K-1}

f. Else, sum=S

g. Output sum modulo 10^9 +7.

But wait, in the first test case, sum is -11, which is negative, but modulo operation with negative numbers needs to be handled carefully.

In Python, a%MOD gives a result in the range [0, MOD-1], even for negative a.

But in some programming languages, a%MOD for a <0 may give a result in the range [-MOD+1, 0], so we need to adjust it to be in [0, MOD-1].

Hence, in Python, (-11) % (10^9 +7) = 999,999,996, which matches the problem's output.

Hence, in code, we can simply compute sum % MOD.

Also, for large K, 2^{K-1} can be computed using modular exponentiation to avoid overflow.

But since MOD=10^9 +7, and 2^{K-1} can be large, we can compute 2^{K-1} % MOD.

In Python, pow(2, K-1, MOD) computes 2^{K-1} modulo MOD efficiently.

Hence, the formula in code would be:

If S + M >0:

sum = (S + M) * pow(2, K-1, MOD) % MOD

Else:

sum = S % MOD

Hence, the solution seems straightforward now.

Let me verify it with another example.

Consider array [1, -2, 3], K=2.

S=1 + (-2) +3=2

M=3 (subarray [3])

Since S + M=5 >0, sum=5 * 2^{1}=10

Indeed, operation 1: choose [3], sum=3, insert 3, array becomes [1,-2,3,3], sum=6

Operation 2: choose entire array, sum=6, insert 6, array becomes [1,-2,3,3,6], sum=12

Wait, but according to the formula, it should be 10.

Hmm, discrepancy here.

Wait, perhaps I missed something.

Wait, with K=2, sum=(S + M)*2^{1}= (2 +3)*2=10, but according to the operations, sum=12.

Hence, my formula is not accurate.

Hence, perhaps my earlier assumption is incorrect.

Wait, perhaps the formula is sum=(S + M)*2^{K-1} - M.

In this case, (2 +3)*2 -3=10 -3=7, which is not matching.

Alternatively, perhaps sum=S + M * (2^{K} -1)

In this case, S + M*(2^{2} -1)=2 +3*3=11, which is still not 12.

Hence, my formula is incorrect.

Hence, I need to find a better approach.

Let me think differently.

Let me consider that in the first operation, I choose a subarray with sum X, insert X, so the new sum is S + X.

In the second operation, I choose the entire array, which now has sum S + X, insert S + X, so the new sum is S + X + (S + X)=2*(S + X).

In the third operation, choose the entire array, sum=2*(S + X), insert it, new sum=2*(S + X) +2*(S + X)=4*(S + X).

And so on, up to K operations.

Hence, after K operations, sum=(S + X)*2^{K-1}

To maximize this, I need to choose X as large as possible.

Hence, X should be M, the maximum sum of any subarray in the original array.

Hence, sum=(S + M)*2^{K-1}

In the earlier example, S=2, M=3, K=2, sum=(2 +3)*2=10, but according to the operations, sum=12.

Hence, there is a discrepancy.

Wait, perhaps I need to choose X differently in each operation.

But that seems too involved.

Alternatively, perhaps the formula is sum=S + K*M.

But in this case, S + K*M=2 +2*3=8, which is less than 10 or 12.

Hence, still not matching.

Wait, perhaps I need to choose different X in each operation to maximize the sum.

For example, in the first operation, choose X=M=3, insert 3, sum becomes 5.

In the second operation, choose X=S + M=5, insert 5, sum becomes 10.

Hence, sum=10, which matches the formula.

But earlier, I thought of choosing X=M in the first operation and then choosing X=S + M in the subsequent operations.

Wait, but in the second operation, S + M=5, but in reality, after inserting 3, the array is [1,-2,3,3], and the maximum subarray sum is 6 (subarray [3,3]).

Hence, choosing X=6 in the second operation would lead to sum=5 +6=11.

But according to my formula, it's 10.

Hence, my formula is still not accurate.

Hence, perhaps I need to adjust the formula.

Wait, perhaps the formula is sum=S + M * (2^{K} -1)

In this case