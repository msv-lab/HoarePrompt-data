Alright, I have this problem to solve. It's about a game played by Alice and Bob on an array of integers. The array is of size n, and they take turns playing, with Alice starting first. The game ends when the array is empty, and the score is defined as the MEX of the array c that Alice builds.

First, I need to understand what MEX is. MEX stands for Minimum EXcludant, which is the smallest non-negative integer not present in the array. For example, the MEX of [0, 1, 1] is 2 because 0 and 1 are present, but 2 is not.

Alice wants to maximize the MEX, and Bob wants to minimize it. Both play optimally, meaning they make the best possible moves to achieve their goals.

So, in each turn:

- Alice picks an element from the array a, appends it to c, and deletes it from a.

- Bob picks an element from the array a and deletes it from a.

The game ends when a is empty, and the score is the MEX of c.

I need to find the final score if both play optimally.

Let's consider the example provided:

Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Output:

2

1

0

Let's analyze the first test case:

n = 4

a = [0, 0, 1, 1]

Possible moves:

- Alice picks 1, a becomes [0, 0, 1], c = [1]

- Bob picks 0, a becomes [0, 1], c = [1]

- Alice picks 0, a becomes [1], c = [1, 0]

- Bob picks 1, a becomes empty, c = [1, 0]

MEX of [1, 0] is 2.

Is this the optimal play? Let's see if Alice can force a higher MEX or if Bob can force a lower MEX.

Another possible sequence:

- Alice picks 0, a becomes [0, 1, 1], c = [0]

- Bob picks 1, a becomes [0, 1], c = [0]

- Alice picks 1, a becomes [0], c = [0, 1]

- Bob picks 0, a becomes empty, c = [0, 1]

MEX is still 2.

Another sequence:

- Alice picks 1, a becomes [0, 0, 1], c = [1]

- Bob picks 1, a becomes [0, 0], c = [1]

- Alice picks 0, a becomes [0], c = [1, 0]

- Bob picks 0, a becomes empty, c = [1, 0]

MEX is 2 again.

It seems like MEX 2 is the best Alice can achieve against Bob's optimal play.

Second test case:

n = 4

a = [0, 1, 2, 3]

Possible moves:

- Alice picks 0, a becomes [1, 2, 3], c = [0]

- Bob picks 1, a becomes [2, 3], c = [0]

- Alice picks 2, a becomes [3], c = [0, 2]

- Bob picks 3, a becomes empty, c = [0, 2]

MEX of [0, 2] is 1.

But according to the output, it's 1.

Is there a way for Alice to achieve a higher MEX? Let's see:

- Alice picks 1, a becomes [0, 2, 3], c = [1]

- Bob picks 0, a becomes [2, 3], c = [1]

- Alice picks 2, a becomes [3], c = [1, 2]

- Bob picks 3, a becomes empty, c = [1, 2]

MEX is 0.

Worse for Alice.

Another sequence:

- Alice picks 3, a becomes [0, 1, 2], c = [3]

- Bob picks 0, a becomes [1, 2], c = [3]

- Alice picks 1, a becomes [2], c = [3, 1]

- Bob picks 2, a becomes empty, c = [3, 1]

MEX is 0.

Worse for Alice.

So, the first sequence gives the highest MEX of 1, which matches the sample output.

Third test case:

n = 2

a = [1, 1]

Possible moves:

- Alice picks 1, a becomes [1], c = [1]

- Bob picks 1, a becomes empty, c = [1]

MEX of [1] is 0.

Which matches the sample output.

From these examples, it seems that the MEX depends on the numbers Alice manages to pick, considering that Bob is trying to hinder her.

I need to find a general strategy for Alice and Bob.

Let me think about the game in terms of who has more control over the final content of c.

Since Alice picks elements for c and Bob just deletes elements from a, Bob can influence which elements Alice can pick in future turns.

Alice wants to collect as many small non-negative integers as possible to maximize the MEX.

Bob wants to minimize the MEX by preventing Alice from collecting a complete sequence of small integers.

Let me consider the frequency of each number in the array.

Suppose we have counts of each number from 0 to n-1.

Alice and Bob will be picking elements from this array, with Alice also adding them to c.

I need to model their moves optimally.

Let me consider that Alice and Bob will play for roughly n/2 turns each, but the exact number depends on n being even or odd.

Wait, actually, since Alice picks and Bob picks alternately, with Alice starting, the number of turns for Alice is ceil(n/2), and for Bob is floor(n/2).

But this might not be directly helpful.

Let me think differently.

I need to maximize the MEX of c, which is the smallest missing integer in c.

So, to maximize MEX, Alice wants to include as many small integers as possible in c.

Bob, on the other hand, wants to minimize MEX, which means he wants to prevent Alice from including small integers in c.

Wait, but Bob can only delete elements from a; he doesn't choose what Alice picks.

Wait, no, Bob picks an element from a and deletes it, but he doesn't add it to c.

So, Bob can choose to delete elements that Alice might want to pick for c.

So, Bob can remove elements that Alice could use to build c, thereby forcing Alice to pick less desirable elements.

So, Bob can try to remove elements that Alice needs to maximize the MEX.

This seems like a game where Alice tries to collect a sequence of small integers, and Bob tries to disrupt this by removing elements that Alice might need.

I need to find a way to model this.

Let me consider that Alice wants to include as many of the smaller numbers in c as possible, while Bob wants to prevent that by removing those numbers.

So, perhaps, I can think in terms of the availability of numbers and who gets to pick them.

Let me consider counting the frequency of each number in the array.

Let's say I have a frequency count of each number from 0 to n-1.

Alice will try to pick the smallest available numbers for c, while Bob will try to remove those small numbers to prevent Alice from having them.

Wait, but Bob can only remove one element per turn, and Alice picks one element per turn and adds it to c.

So, it's not straightforward.

Let me think about it in terms of turns.

Suppose we have n elements.

Total turns: n turns, Alice plays ceil(n/2) times, Bob plays floor(n/2) times.

Wait, no. Since Alice starts and both take turns alternately, Alice will have ceil(n/2) turns, and Bob will have floor(n/2) turns.

In each of Alice's turns, she picks an element and adds it to c.

In each of Bob's turns, he picks an element and removes it from a.

The goal is to maximize the MEX of c for Alice and minimize it for Bob.

I need to find the final MEX when both play optimally.

Let me consider that Alice wants to include as many small numbers as possible in c, while Bob wants to prevent that by removing those small numbers from a.

So, perhaps, I can model this as follows:

- Sort the unique numbers in a, and for each number, see how many times it appears.

- Alice will try to include as many of the smaller numbers as possible in c.

- Bob will try to remove those smaller numbers from a to make them unavailable for Alice.

Let me consider the frequency of each number.

Let's say I have counts = [count of 0, count of 1, count of 2, ..., count of k], where k is the maximum number in a.

Alice and Bob will be playing with these counts.

I need to simulate their moves.

Wait, maybe I can think in terms of the number of available copies of each number.

Initially, counts = frequency of each number.

In each turn:

- Alice picks a number and adds it to c, and removes one copy from a.

- Bob picks a number and removes one copy from a.

They do this until a is empty.

I need to find the MEX of c when both play optimally.

This seems similar to a game where Alice is trying to collect a complete sequence, and Bob is trying to disrupt it.

I need to find a way to determine the highest possible MEX that Alice can achieve against Bob's optimal strategy.

Let me consider greedy approaches.

Suppose Alice always tries to pick the smallest available number that can help her maximize the MEX.

Bob, on the other hand, tries to minimize the MEX by removing numbers that Alice needs.

So, perhaps, Alice will try to pick numbers in order starting from 0, and Bob will try to block her by removing those numbers.

Let me consider that.

Initialize a counter for each number.

Alice wants to have all numbers from 0 to m in c to achieve MEX m+1.

Bob wants to prevent this by removing those numbers.

So, for each number m that Alice needs to achieve MEX m+1, Bob can try to remove those numbers.

Wait, perhaps I need to think in terms of the number of times each number appears and how many times Alice can pick them before Bob removes them.

This is getting complicated.

Let me look for a pattern or a mathematical way to compute this.

Looking back at the sample inputs:

First test case:

n=4

a=[0,0,1,1]

Possible c=[1,0] or [0,1], MEX=2

Second test case:

n=4

a=[0,1,2,3]

Possible c=[0,2], MEX=1

Third test case:

n=2

a=[1,1]

c=[1], MEX=0

From these, it seems that the MEX depends on how many small numbers Alice can collect, considering Bob's interference.

Let me consider that Alice and Bob are playing optimally, and try to find a way to compute the MEX directly.

Perhaps I can iterate through the possible MEX values starting from 0 upwards, and check if Alice can collect all numbers less than MEX, given Bob's interference.

But this might be too slow, especially since n can be up to 2e5 and t up to 2e4.

I need a faster way.

Let me consider the frequency of each number.

Suppose I sort the unique numbers in a, and for each number, I have its frequency.

Then, I can try to see how many times Alice can pick each number before Bob removes them.

Wait, perhaps I can think in terms of the number of times Alice can pick a number before it's removed by Bob.

For example, if a number appears only once, Alice can pick it only if she picks it before Bob removes it.

If a number appears twice, Alice can pick one and Bob removes one, or Bob removes one and Alice picks the remaining one.

Similarly for higher frequencies.

Wait, perhaps I can compute for each number how many times Alice can pick it.

Then, the MEX would be the smallest number for which Alice hasn't picked it as many times as it appears.

Wait, I need to think differently.

Let me consider that Alice wants to collect as many unique small numbers as possible.

So, I need to find the smallest number that Alice cannot collect, considering Bob's interference.

Let me try to model this.

Suppose I have counts of each number in a dictionary.

I sort the unique numbers in ascending order.

Then, for each number in this order, I see how many times it appears.

Alice wants to collect as many of these numbers as possible.

Bob wants to prevent that.

In each of Alice's turns, she can pick one number and add it to c.

In each of Bob's turns, he can remove one number from a.

I need to see how many of these numbers Alice can collect before Bob removes them.

Wait, perhaps I can think in terms of the difference between the frequency of a number and the number of times Bob can remove it.

For a number x, if it appears freq[x] times, and Bob can remove up to floor(n/2) elements, but not necessarily x.

Wait, this seems too vague.

Let me consider that the total number of turns is n.

Alice has ceil(n/2) turns, Bob has floor(n/2) turns.

Alice wants to collect as many unique small numbers as possible in her ceil(n/2) turns.

Bob wants to prevent that by removing those numbers.

So, perhaps, for each number x, the number of times Alice can collect x is max(freq[x] - floor(n/2), 0), because Bob can remove up to floor(n/2) elements.

Wait, but Bob can remove any elements, not necessarily the ones Alice wants.

So, Bob can choose to remove elements that Alice needs.

So, for each number x that Alice needs, Bob can choose to remove it to prevent Alice from collecting it.

So, for each x, the number of times Alice can collect x is freq[x] - the number of times Bob removes x.

Bob will try to minimize the number of times Alice collects x.

So, for each x, Bob will remove x as much as possible to prevent Alice from collecting it.

Therefore, the number of times Alice can collect x is freq[x] - the number of times Bob removes x.

But Bob can remove up to floor(n/2) elements in total.

So, Bob can distribute his removals to minimize the number of x that Alice can collect.

Wait, perhaps I need to think in terms of the total number of times Alice can collect numbers.

But this seems too vague.

Let me look for a different approach.

I recall that in some games, the MEX is related to the number of available moves or the state of the game.

But here, it's about collecting numbers and their frequencies.

Wait, perhaps I can think in terms of the number of times each number is available for Alice to pick.

Let me consider that Alice has ceil(n/2) turns to pick elements.

Bob has floor(n/2) turns to remove elements.

Alice wants to pick as many unique small numbers as possible.

Bob wants to prevent that by removing those small numbers.

So, for each number x, the number of times Alice can pick x is freq[x] minus the number of times Bob removes x.

But Bob can choose to remove any elements, not necessarily x.

So, perhaps, Bob can choose to remove elements that Alice needs.

Wait, maybe I can model this as a selection game where Alice tries to select certain elements, and Bob tries to block them.

This seems similar to the game where Alice is trying to collect a set of elements, and Bob is trying to disrupt that.

I need to find a way to compute the minimal MEX that Alice can achieve, considering Bob's interference.

Let me consider that Alice can collect a number x only if freq[x] > number of times Bob removes x.

But Bob can remove up to floor(n/2) elements in total.

So, Bob can choose to remove elements strategically to minimize the number of unique numbers Alice can collect.

This seems complex.

Let me try to think differently.

Suppose I sort the unique numbers in ascending order.

Then, I can try to find the smallest number for which Alice cannot collect at least one copy, considering Bob's removals.

But this might not be accurate, because Bob can remove elements in a way that affects multiple numbers.

Wait, perhaps I can iterate through the numbers in order and see if Alice can collect at least one of each up to that number.

Let me try that.

Initialize a counter for the number of times Alice has collected each number.

Initialize the total number of Alice's turns as ceil(n/2).

Then, for each number x in ascending order:

- If freq[x] > 0, Alice can collect it if she has turns left.

- But Bob can remove it to prevent Alice from collecting it.

So, for each x, the number of times Alice can collect x is max(freq[x] - removals by Bob, 0).

But Bob can distribute his removals to minimize the number of x that Alice collects.

This is getting too complicated.

Let me look for a pattern in the sample inputs.

First test case:

a = [0,0,1,1]

Alice can collect one 1 and one 0, so c = [1,0], MEX=2.

Second test case:

a = [0,1,2,3]

Alice can collect one 0 and one 2, so MEX=1.

Third test case:

a = [1,1]

Alice collects one 1, c=[1], MEX=0.

So, in the first case, Alice can collect both 0 and 1, so MEX is 2.

In the second case, Alice can collect 0 and 2, but not 1 and 3, so MEX is 1.

In the third case, Alice can only collect one 1, so MEX is 0.

It seems that the MEX is determined by the smallest integer that Alice cannot collect at least one of.

So, perhaps, the MEX is the smallest x for which freq[x] <= number of times Bob can remove x.

Wait, let's think about it.

Bob can remove up to floor(n/2) elements in total.

He can choose to remove elements that Alice needs, i.e., the small numbers.

So, for each x from 0 to max(a):

- If freq[x] > 0, Alice can collect it unless Bob removes all freq[x] copies.

But Bob has floor(n/2) removals to distribute among all x.

So, Bob can choose to remove copies of x to prevent Alice from collecting them.

Alice needs at least one copy of x to include x in c.

So, for each x, Alice needs at least one copy remaining after Bob's removals.

So, for each x, if freq[x] - removals_by_Bob >=1, then Alice can collect x.

Bob will try to minimize the number of x for which this is true.

So, Bob will distribute his removals to reduce freq[x] below 1 for as many x as possible.

Alice wants as many x as possible to have freq[x] - removals_by_Bob >=1.

So, Bob will prioritize removing copies of x with the smallest freq[x].

Wait, no.

Wait, Bob wants to minimize the number of x for which freq[x] - removals_by_Bob >=1.

So, Bob wants to reduce freq[x] below 1 for as many x as possible.

Therefore, Bob should target x with the smallest freq[x].

Wait, no.

Wait, if Bob removes copies from x with higher freq, he can reduce more freq[x] per removal.

Wait, but he can only remove one per turn.

Wait, perhaps it's better for Bob to remove from x with the smallest freq[x].

Wait, let's think.

Suppose Bob removes from x with freq[x]=1.

Then, freq[x] becomes 0, and Alice cannot collect x.

If Bob removes from x with freq[x]>1, freq[x] decreases by 1, but Alice can still collect x if freq[x]-removals >=1.

So, Bob should prioritize removing from x with freq[x]=1 to directly eliminate x from Alice's possible collections.

Yes, that makes sense.

So, Bob should remove from x with freq[x]=1 first to eliminate them, then from x with freq[x]=2, and so on.

Alice wants to maximize the number of x with freq[x] - removals_by_Bob >=1.

So, to find the minimal MEX that Alice can achieve, I need to find the smallest x for which freq[x] - removals_by_Bob <1, meaning Bob has removed all copies of x.

Wait, no.

Wait, if freq[x] - removals_by_Bob >=1, Alice can collect x.

Otherwise, she cannot.

So, the MEX is the smallest x for which freq[x] - removals_by_Bob <1.

But Bob wants to minimize the MEX, so he will try to make freq[x] - removals_by_Bob <1 for the smallest possible x.

Therefore, Bob will prioritize removing from x with the smallest freq[x].

Wait, but as I thought earlier, Bob should remove from x with freq[x]=1 first to eliminate them.

Wait, but he can only remove one element per turn.

So, perhaps I can model this as follows:

- Sort the unique x in ascending order.

- For each x, compute the number of removals needed by Bob to prevent Alice from collecting x, which is freq[x].

- Bob will allocate his removals to maximize the number of x for which freq[x] - removals <1.

Wait, this seems too vague.

Let me think in terms of maximizing the number of x for which freq[x] - removals >=1.

Alice wants this number to be as large as possible.

Bob wants it to be as small as possible.

So, Bob will allocate his removals to minimize the number of x with freq[x] - removals >=1.

This seems like an optimization problem.

Wait, perhaps I can iterate through x in order and allocate Bob's removals accordingly.

Let me try to implement this idea.

First, sort the unique x in ascending order.

Initialize the total removals by Bob, which is floor(n/2).

Then, for each x in ascending order:

- If freq[x] > 0:

- If freq[x] > removals, then Alice can collect at least one x.

- Set a counter for collected x.

- Else, Bob can remove all freq[x] copies, so Alice cannot collect x.

- Subtract freq[x] from removals.

- Continue to the next x.

- The MEX is the smallest x for which Alice cannot collect at least one x.

Wait, perhaps I need to iterate and see how many x Alice can collect at least one of.

Let me try to formalize this.

Letâ€™s say we have x sorted in ascending order.

For each x, if freq[x] > 0 and freq[x] > removals, then Alice can collect at least one x.

Otherwise, Bob can remove all freq[x], and Alice cannot collect x.

So, the MEX is the smallest x for which freq[x] <= removals.

Wait, but removals decrease as Bob removes elements.

Wait, perhaps I need to accumulate the removals.

Wait, maybe I need to iterate through x in order and keep track of the remaining removals.

Initialize removals = floor(n/2)

For x from 0 to max(a):

if freq[x] > 0:

if freq[x] > removals:

Alice can collect at least one x.

else:

MEX = x

break

removals -= freq[x]

Wait, but this doesn't make sense because if freq[x] <= removals, Bob can remove all freq[x], preventing Alice from collecting x.

So, MEX would be x.

But in the first test case:

x=0, freq[0]=2, removals=floor(4/2)=2

2 <= 2, so MEX=0

But in the sample, MEX is 2.

Wait, that can't be.

Wait, perhaps I need to adjust the logic.

Wait, perhaps MEX is the smallest x for which freq[x] <= removals.

But in the first test case:

x=0, freq[0]=2, removals=2

2 <= 2, so MEX=0, but sample output is 2.

This contradicts.

Wait, perhaps I need to think differently.

Wait, perhaps Alice can choose to pick x even if Bob removes some copies.

Wait, perhaps I need to see how many copies Alice can get for each x.

For each x, the number of copies available for Alice is freq[x] minus the number of times Bob removes it.

Bob will try to minimize the number of x that Alice can collect.

So, Bob will allocate his removals to minimize the number of x with freq[x] - removals >=1.

This seems like an assignment problem, but it's too slow for the constraints.

Let me look for a better approach.

I recall that in some games, the outcome can be determined by the number of available moves or resources.

Here, Alice has ceil(n/2) turns to pick elements, and Bob has floor(n/2) turns to remove elements.

So, the total number of elements Alice can pick is ceil(n/2).

Bob can remove floor(n/2) elements.

I need to see how these actions affect the MEX of c.

Wait, perhaps I can consider that Alice can pick ceil(n/2) elements, and Bob can remove floor(n/2) elements.

But Bob removes first, then Alice picks.

Wait, no, they alternate turns, Alice starting first.

Wait, perhaps I can think in terms of the number of elements Alice can control.

Wait, maybe I should look for a different approach altogether.

Let me consider that the MEX depends on the numbers Alice has in c.

Alice wants the highest possible MEX, which means she wants to have as many small numbers as possible in c.

Bob wants to minimize the MEX, so he wants to prevent Alice from having small numbers in c.

So, perhaps, I can think in terms of the availability of small numbers after the game.

