Alright, I have this problem to solve. It's about a game between Alice and Bob on an array of integers. Alice wants to maximize the MEX of her array c, while Bob wants to minimize it. They take turns, with Alice going first, and in each turn, Alice picks an element from the array a, appends it to her array c, and deletes it from a. Bob just picks and deletes an element from a. The game ends when a is empty, and the score is the MEX of c.

First, I need to understand what MEX is. MEX stands for "minimum excludant," which is the smallest non-negative integer not present in the array. For example, the MEX of [0, 1, 1] is 2 because 0 and 1 are present, but 2 is not.

So, the goal is to find the final score, which is the MEX of c, assuming both players play optimally.

Let me look at the example provided:

Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Output:

2

1

0

Let's see what's happening in the first test case:

n = 4

a = [0, 0, 1, 1]

One possible game is:

1. Alice picks 1 → c = [1], a = [0, 0, 1]

2. Bob picks 0 → a = [0, 1]

3. Alice picks 0 → c = [1, 0], a = [1]

4. Bob picks 1 → a = []

Final c = [1, 0], MEX is 2.

But is this the optimal outcome for both players?

Alice wants to maximize MEX, which would mean making c have as many small non-negative integers as possible. Bob wants to minimize MEX, which might involve preventing Alice from getting certain numbers.

In this case, MEX is 2, but can it be higher or lower depending on their moves?

Let me think about the general strategy.

Since Alice goes first and picks elements for c, she can choose which elements to include in c. Bob, on his turn, can remove elements that might help Alice or disrupt her strategy.

Given that Alice wants to maximize MEX, she would ideally want to collect all the smallest non-negative integers possible. Bob, wanting to minimize MEX, would try to prevent Alice from getting certain numbers or force her to pick higher numbers.

Given that Alice can choose which elements to put in c, and Bob can remove elements, the game seems to be about Alice trying to collect the necessary numbers to maximize the MEX, while Bob tries to hinder her.

Let me consider the second test case:

n = 4

a = [0, 1, 2, 3]

Possible game:

1. Alice picks 0 → c = [0], a = [1, 2, 3]

2. Bob picks 1 → a = [2, 3]

3. Alice picks 2 → c = [0, 2], a = [3]

4. Bob picks 3 → a = []

Final c = [0, 2], MEX is 1.

So, MEX is 1, which is the output given.

In this case, Alice couldn't get 1 into c, so MEX is 1.

Third test case:

n = 2

a = [1, 1]

Possible game:

1. Alice picks 1 → c = [1], a = [1]

2. Bob picks 1 → a = []

Final c = [1], MEX is 0.

Since 0 is not in c, MEX is 0.

Okay, now I need to find a general strategy for both players.

Let me think about the MEX value.

The MEX of c is the smallest non-negative integer not in c.

To maximize MEX, Alice wants c to contain as many small integers as possible.

To minimize MEX, Bob wants to ensure that some small integer is missing from c.

So, in each game, they're fighting over which small integers end up in c.

Given that Alice picks elements for c and Bob can remove elements from a, Bob can influence which elements are available for Alice in future turns.

I need to model their optimal play.

Let me consider that both players play optimally, meaning they make the best possible move to achieve their goal.

I need to find the final MEX when both play optimally.

Looking at the provided code, it seems to be trying to simulate this process.

Let me look at the code:

def func_1(arr):

nums = c.Counter(arr)

start = 0

vis = set()

while nums.get(start, 0):

vis.add(start)

nums[start] -= 1

if nums.get(start + 1, 0):

nums[start + 1] -= 1

start += 1

else:

print(start + 1)

return

print(start)

So, it's using a counter to count the frequency of each number in arr.

Then, it initializes start to 0 and an empty set vis to track visited numbers.

It enters a loop where it checks if nums[start] exists (i.e., frequency is greater than 0).

It adds start to vis, decrements nums[start], and then checks if nums[start + 1] exists.

If it does, it decrements nums[start + 1] and increments start by 1.

Otherwise, it prints start + 1 and returns.

If the loop ends without hitting the else clause, it prints start.

Let me see how this works with the first test case:

arr = [0, 0, 1, 1]

nums = {0: 2, 1: 2}

start = 0

First iteration:

- nums[0] = 2 > 0

- add 0 to vis

- nums[0] = 1

- nums[1] = 2 > 0

- nums[1] = 1

- start = 1

Second iteration:

- nums[1] = 1 > 0

- add 1 to vis

- nums[1] = 0

- nums[2] = 0 (doesn't exist)

- print(start + 1) = 2

Which matches the first output.

Second test case:

arr = [0, 1, 2, 3]

nums = {0:1, 1:1, 2:1, 3:1}

start = 0

First iteration:

- nums[0] = 1 > 0

- add 0 to vis

- nums[0] = 0

- nums[1] = 1 > 0

- nums[1] = 0

- start = 1

Second iteration:

- nums[1] = 0 (doesn't exist)

- print(start + 1) = 2

Wait, but the output should be 1.

Hmm, maybe I'm misunderstanding the simulation.

Wait, in the code, it's checking if nums.get(start, 0):

which is true if nums[start] > 0

then it adds start to vis, decrements nums[start]

then checks if nums.get(start + 1, 0):

if true, decrements nums[start + 1], increments start

else, prints start + 1

In the second test case:

First iteration:

- nums[0] = 1 > 0

- add 0 to vis

- nums[0] = 0

- nums[1] = 1 > 0

- nums[1] = 0

- start = 1

Second iteration:

- nums[1] = 0 (which is not > 0)

- so, print(start + 1) = 2

But the expected output is 1.

Wait, maybe there's a mistake in the code or my understanding.

Wait, perhaps the function is not correctly simulating the game.

Let me think differently.

Maybe I need to model the game more accurately.

Let's consider that Alice and Bob are playing optimally.

Alice wants to maximize MEX, which is counterintuitive because MEX is the smallest missing number. So, to maximize MEX, Alice would want to have as many small numbers as possible in her array c.

Bob wants to minimize MEX, so he wants to prevent Alice from having certain small numbers.

The game proceeds with Alice picking a number to add to c and Bob picking a number to remove.

The game ends when a is empty, and the MEX of c is calculated.

I need to find the MEX when both play optimally.

Let me consider that Alice can choose which number to add to c, and Bob can choose which number to remove.

So, in each turn:

- Alice picks a number from a, adds it to c, and removes it from a.

- Bob picks a number from a and removes it.

They alternate until a is empty.

I need to find the MEX of c at the end.

To solve this, perhaps I can think in terms of the availability of numbers and who can control which numbers end up in c.

Let me consider that Alice can choose to add any number available in a to c, and Bob can remove any number from a.

Bob's goal is to minimize MEX, which means he wants to help Alice miss some small numbers in c.

Alice's goal is to maximize MEX, which means she wants to include as many small numbers as possible in c.

Given that Alice picks first, she can strategically choose which numbers to include in c.

I need to find a way to determine the smallest number that Alice cannot guarantee to have in c, considering Bob's interference.

This seems like a game theory problem where I need to find the optimal outcome for both players.

Let me try to think of it in terms of the frequency of each number.

Suppose I have the count of each number in the array a.

For each number i, if Alice wants to have i in c, she can pick it, but Bob can also remove it or other numbers to interfere.

I need to find which numbers Alice can guarantee to have in c, and which ones she cannot, assuming Bob plays optimally to prevent her from having certain numbers.

Perhaps I can think in terms of the number of times a number appears and how many times it can be picked by Alice or removed by Bob.

Let me consider that each number can be either picked by Alice into c, removed by Alice (when she picks it but doesn't add it to c), or removed by Bob.

Wait, but in the problem, Alice always adds the picked number to c and then deletes it from a, while Bob just deletes a number from a.

So, for each turn, Alice picks a number to add to c and remove from a, and Bob removes a number from a.

So, for n elements, there will be n turns: Alice and Bob alternate, with Alice starting.

If n is even, there are n/2 moves each; if n is odd, Alice has one more move.

Wait, no. Since Alice picks first, and then Bob, and so on, until a is empty.

So, if n is odd, Alice makes (n + 1) / 2 moves, and Bob makes (n - 1) / 2 moves.

If n is even, Alice and Bob each make n / 2 moves.

Wait, but in each turn, two elements are removed from a: one by Alice and one by Bob, except perhaps when n is odd, the last move is Alice's.

Wait, no. Let's think carefully.

Each turn consists of:

- Alice picks one element, adds it to c, and deletes it from a.

- Then, Bob picks one element and deletes it from a.

So, in each full turn (Alice and Bob), two elements are removed from a.

If n is even, there are exactly n/2 full turns.

If n is odd, there are (n-1)/2 full turns, and one additional move by Alice.

So, total moves:

- Alice: ceil(n/2)

- Bob: floor(n/2)

Now, I need to think about how to maximize the MEX for Alice and minimize it for Bob.

Let me consider that Alice wants as many small numbers as possible in c, and Bob wants to prevent that.

So, for each small number i, Alice needs to ensure that she can get at least one copy of i into c, despite Bob trying to prevent it.

Bob can try to remove copies of i from a to make it harder for Alice to pick them.

So, for each i, starting from 0 upwards, Alice needs to have at least one copy of i in c at the end.

Bob will try to make sure that for some i, Alice cannot have any copy in c.

I need to find the smallest i where Alice cannot guarantee having at least one copy in c, given optimal play from both sides.

In other words, for each i, starting from 0, Alice needs to have at least one copy in c.

Bob will try to prevent Alice from having some i.

I need to find the smallest i where Bob can prevent Alice from having it in c.

To do this, I need to see, for each i, whether Alice can guarantee to have at least one in c.

Let me think in terms of the frequency of each number.

Let's count the frequency of each number in a.

Let freq[i] be the number of times i appears in a.

Now, for each i from 0 to some maximum value, Alice needs to have at least one copy in c.

Bob will try to prevent this.

Given that Alice has ceil(n/2) moves to pick elements for c, and Bob has floor(n/2) moves to remove elements.

But Bob can remove any element from a, not necessarily the one Alice wants.

Wait, no. Bob removes any element from a, but it's not necessarily the one Alice wants.

But Bob can choose to remove elements that are critical for Alice.

So, for each i, the number of times i appears in a is freq[i].

Alice needs at least one copy of i in c.

To achieve this, she needs to pick at least one copy of i into c.

But Bob can remove some copies of i.

So, the number of copies of i that are available for Alice to pick is freq[i] minus the number of times Bob removes i.

Bob can remove up to floor(n/2) elements in total, but he can choose which ones to remove.

So, Bob can choose to remove copies of i to make it harder for Alice to pick them.

Therefore, for each i, the number of copies available for Alice to pick is freq[i] minus the number of times Bob removes i.

Bob will try to minimize the number of copies available for Alice to pick for each i.

Alice needs at least one copy for as many i as possible.

So, for each i, the condition is that freq[i] minus the number of times Bob removes i is at least one.

Alice can pick one copy of i into c.

But Bob can choose to remove copies of i to prevent this.

So, for each i, the number of copies Bob can remove is floor(n/2), but he has to distribute his removals across all i.

Wait, but Bob can choose which elements to remove.

So, perhaps it's better to think in terms of the total number of critical removals Bob can make for each i.

Wait, maybe I need to think in terms of the number of copies Alice needs to secure for each i.

Let me consider that for each i, Alice needs at least one copy in c.

To have at least one copy in c, she needs to pick at least one copy of i into c.

Bob can remove some copies of i from a, making them unavailable for Alice.

So, for each i, the number of copies available for Alice to pick is freq[i] minus the number of times Bob removes i.

Bob will try to minimize this value for each i that Alice needs.

But Bob has floor(n/2) removals to use.

He can distribute his removals to target the i's that Alice needs.

Alice needs to secure at least one copy for each i from 0 up to some point.

So, perhaps I can think of it as a game where Alice needs to reserve one copy of each i, and Bob tries to block them.

Let me try to formalize this.

Let k be the largest integer such that for all i from 0 to k-1, Alice can guarantee to have at least one copy of i in c, despite Bob's attempts to block them.

Then, the MEX would be k.

But I need to find the smallest k where Alice cannot guarantee to have at least one copy of k in c.

This would be the MEX.

So, for each i from 0 upwards, I need to check if Alice can guarantee to have at least one copy in c.

If she can't, that's the MEX.

Now, to determine for each i, whether Alice can guarantee to have at least one copy in c.

Given that Bob is trying to prevent this.

Let me consider the frequency of i, freq[i].

Alice needs to pick one copy of i into c.

Bob can remove some copies of i to make it harder.

But Alice has ceil(n/2) moves to pick elements for c.

Bob has floor(n/2) moves to remove elements.

Wait, perhaps I need to think in terms of the total number of available copies and the number of moves.

Wait, maybe a better approach is to consider that Alice has ceil(n/2) picks for c, and Bob has floor(n/2) removals.

But Bob can remove any elements, not necessarily the ones Alice wants.

So, perhaps I need to think about the minimal number of copies of i that Bob can remove to prevent Alice from picking at least one into c.

For a given i, to prevent Alice from having it in c, Bob needs to remove all copies of i that Alice could have picked.

But Alice has ceil(n/2) picks.

So, perhaps I need to see if, for a given i, freq[i] > number of times Bob can remove it.

But Bob can choose to remove any elements, not just i.

So, perhaps I need to think in terms of the total number of removals Bob can make to block Alice from picking i.

Wait, maybe it's better to think in terms of the number of copies of i available after Bob's removals.

Alice needs at least one copy of i in c.

To have it in c, she needs to pick it into c.

But Bob can remove some copies of i, reducing the number available for Alice to pick.

So, if freq[i] - number of times Bob removes i >=1, then Alice can pick one into c.

But Bob will try to minimize freq[i] - number of times he removes i.

Wait, but Bob can choose which elements to remove.

So, for each i, Bob can choose to remove copies of i to prevent Alice from picking them.

But he has a limited number of removals.

He has to distribute his removals across all the i's that Alice needs.

Alice needs to secure as many i's as possible.

So, perhaps this is similar to a game where Alice needs to reserve one copy of each i, and Bob tries to block them by removing copies.

I need to find the smallest i where Bob can successfully block Alice from having any copy in c.

Let me try to simulate this.

First, sort the numbers in a in ascending order.

Then, for each i from 0 upwards, check if Alice can secure at least one copy in c.

To do this, see if there's at least one copy of i that Alice can pick into c, even when Bob tries to prevent it.

Given that Bob can remove floor(n/2) elements, he can try to remove copies of i to make them unavailable for Alice.

But Alice has ceil(n/2) picks.

Wait, perhaps I need to think in terms of the total number of available copies and the number of removals.

Wait, maybe I should think in terms of the minimal number of copies Alice needs to secure for each i.

For each i, Alice needs at least one copy in c.

Bob can remove up to floor(n/2) elements, but he has to choose which ones to remove.

So, for each i, the number of copies available for Alice is freq[i] - number of times Bob removes i.

Bob will try to minimize this for each i.

But Bob has to distribute his removals across all i's.

Wait, perhaps it's better to think in terms of the total number of removals Bob can make and how he can target specific i's.

Let me consider that Bob can choose to remove copies of i to prevent Alice from picking them.

So, for each i, if freq[i] <= number of Bob's removals, then Bob can remove all copies of i, making it impossible for Alice to have any in c.

But Bob has floor(n/2) removals to use.

So, for each i, if freq[i] <= floor(n/2), Bob can remove all copies of i.

Therefore, if freq[i] <= floor(n/2), Bob can prevent Alice from having any copies of i in c.

Otherwise, if freq[i] > floor(n/2), then Alice can pick at least one copy into c, because Bob can't remove all copies.

So, for each i from 0 upwards, check if freq[i] > floor(n/2).

If freq[i] > floor(n/2), Alice can have at least one copy in c.

Otherwise, Bob can prevent Alice from having any copies of i in c.

Therefore, the smallest i where freq[i] <= floor(n/2) is the MEX.

Wait, but this seems too simplistic.

In the first test case:

n = 4

a = [0, 0, 1, 1]

freq[0] = 2

freq[1] = 2

floor(n/2) = 2

So, for i=0: freq[0] = 2 > 2? No, 2 <= 2.

So, Bob can prevent Alice from having any 0 in c.

Therefore, MEX should be 0.

But in the example, the output is 2.

So, this approach is incorrect.

Wait, maybe I need to consider the total removals and picks.

Wait, perhaps I need to consider the number of times Alice can pick i compared to Bob's removals.

Let me think differently.

Let me consider that Alice has ceil(n/2) picks for c, and Bob has floor(n/2) removals.

Alice needs to have at least one copy of i in c.

So, for each i, the number of copies available for Alice to pick is freq[i] minus the number of times Bob removes i.

Bob will try to minimize this.

So, for each i, the minimal number of copies available for Alice is freq[i] - floor(n/2).

If freq[i] - floor(n/2) >=1, then Alice can pick at least one into c.

Otherwise, Bob can prevent Alice from having any copies of i in c.

So, for i from 0 upwards, find the smallest i where freq[i] - floor(n/2) < 1.

That is, freq[i] <= floor(n/2).

This seems similar to what I thought before.

But in the first test case, n=4, floor(n/2)=2, freq[0]=2, freq[1]=2.

So, for i=0: 2 - 2 = 0 < 1, so Bob can prevent Alice from having 0 in c.

But in the example, the output is 2, which suggests that c=[1,0], MEX=2.

Wait, there's inconsistency here.

So, perhaps my approach is incorrect.

Let me think differently.

Let me consider that Alice and Bob are playing optimally, and I need to simulate their moves.

Let's simulate the game step by step.

Initialize c as empty.

Simulate turns until a is empty.

At each turn:

- Alice picks an element from a, adds it to c, and deletes it from a.

- Bob picks an element from a and deletes it.

They alternate, with Alice starting first.

At the end, compute MEX of c.

But simulating each game for up to 2e5 elements per test case is too slow, as t can be up to 2e4.

So, I need a smarter way.

Perhaps I can think in terms of which elements Alice should pick to maximize MEX, and Bob will pick elements to minimize MEX.

Wait, no. Alice wants to maximize MEX, which means she wants c to have as many small numbers as possible.

Bob wants to minimize MEX, meaning he wants c to miss some small numbers.

So, Alice should try to pick the smallest available numbers, and Bob should try to prevent her from picking certain small numbers.

Let me consider that Alice always picks the smallest available number that is not yet in c, and Bob tries to block her from getting higher numbers.

Wait, but Alice wants to maximize MEX, which is counterintuitive.

Wait, no.

Wait, MEX is the smallest missing number in c.

So, to maximize MEX, Alice wants c to contain as many small numbers as possible, up to a certain point.

Bob wants to minimize MEX, meaning he wants to make sure that some small number is missing from c.

So, Alice should try to collect as many small numbers as possible, and Bob should try to prevent her from collecting certain small numbers.

Perhaps I can think in terms of the frequency of each number.

Let me sort the unique numbers in a in ascending order.

Then, for each number starting from 0 upwards, check if Alice can guarantee to have at least one copy in c.

If she can't, that's the MEX.

To determine if Alice can have at least one copy of i in c, given that Bob can remove elements.

Wait, perhaps I need to see if