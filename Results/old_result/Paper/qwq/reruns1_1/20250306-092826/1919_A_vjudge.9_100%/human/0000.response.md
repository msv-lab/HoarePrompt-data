Alright, I have this problem here about Alice and Bob playing a game with their wallets. Alice starts with 'a' coins and Bob with 'b' coins. They take turns, with Alice going first. In each turn, the player can choose to exchange wallets with the opponent or keep their current wallet, and then remove one coin from their current wallet. The player who can't make a valid move loses. We need to determine who wins if both play optimally.

First, I need to understand the game mechanics clearly. Each turn consists of two steps:

1. Choose to exchange wallets or keep the current one.

2. Remove one coin from the current wallet.

Also, the wallet can't have zero coins before removing a coin. So, if a player's wallet has zero coins, they can't remove a coin and thus lose.

Now, the problem is to determine the winner based on the initial number of coins each has, and both play optimally.

Let's look at the example provided:

Input:

10

1 1

1 4

5 3

4 5

11 9

83 91

1032 9307

839204 7281

1000000000 1000000000

53110 2024

Output:

Bob

Alice

Bob

Alice

Bob

Bob

Alice

Alice

Bob

Bob

In the first test case, a=1, b=1. According to the output, Bob wins.

In the second, a=1, b=4, Alice wins.

I need to find a pattern or a general rule that determines the winner based on the values of a and b.

Looking at the program provided:

def func():

t = int(input())

for i in range(t):

(a, b) = list(map(int, input().split(' ')))

if abs(a - b) % 2 == 0:

print('Bob')

else:

print('Alice')

It seems to check if the absolute difference between a and b is even. If it is, Bob wins; otherwise, Alice wins.

Is this correct?

Let me test this with the first test case: a=1, b=1. abs(1-1)=0, which is even. So Bob wins, which matches the example.

Second test case: a=1, b=4. abs(1-4)=3, which is odd. So Alice wins, matching the example.

Third test case: a=5, b=3. abs(5-3)=2, even. Bob wins.

Fourth: a=4, b=5. abs(4-5)=1, odd. Alice wins.

Fifth: a=11, b=9. abs(11-9)=2, even. Bob wins.

Sixth: a=83, b=91. abs(83-91)=8, even. Bob wins.

Seventh: a=1032, b=9307. abs(1032-9307)=8275, which is odd. Alice wins.

Eighth: a=839204, b=7281. abs(839204-7281)=831923, which is odd. Alice wins.

Ninth: a=1000000000, b=1000000000. abs(0)=0, even. Bob wins.

Tenth: a=53110, b=2024. abs(53110-2024)=51086, which is even. Bob wins.

All these match the provided output.

But is this logic correct in general?

I need to think about the game more deeply.

Let me consider some small values and see who wins.

Case 1: a=1, b=1.

As in the first test case, Bob wins.

Case 2: a=1, b=2.

Let's simulate:

- Alice's turn: chooses to swap or not.

If she swaps: a=2, b=1. Then removes 1 from a: a=1, b=1.

Now Bob's turn: chooses to swap or not.

If he swaps: a=1, b=1. Removes 1 from a: a=0, b=1.

Now Alice's turn: a=0, b=1. She must not swap. Removes 1 from a, but a=0, can't remove. So Bob wins.

Wait, but according to the program, abs(1-2)=1, which is odd, so Alice wins. But in this simulation, Bob wins.

Contradiction.

Wait, maybe I did something wrong.

Let me try again.

Alice starts with a=1, b=2.

Alice's turn:

Option 1: swap, a=2, b=1. Then remove 1 from a: a=1, b=1.

Now Bob's turn: a=1, b=1.

Bob can choose to swap or not.

If he swaps: a=1, b=1. Remove 1 from a: a=0, b=1.

Alice's turn: a=0, b=1. She must not swap. Can't remove from a, since a=0. So Bob wins.

Option 2: Alice does not swap. a=1, b=2. Remove 1 from a: a=0, b=2.

Now Bob's turn: a=0, b=2. He must not swap. Remove 1 from b: a=0, b=1.

Alice's turn: a=0, b=1. She must swap to a=1, b=0.

Bob's turn: a=1, b=0. He must not swap. Remove 1 from a: a=0, b=0.

Alice's turn: a=0, b=0. Can't remove. Bob wins.

So in both options, Bob wins, which contradicts the program's output for a=1, b=2, since abs(1-2)=1, which is odd, so it would print 'Alice', but in reality, Bob wins.

Wait, but a=1, b=2 is not in the provided test cases. Maybe the program is still correct for the given test cases, but incorrect in general.

Alternatively, maybe there's a different logic.

Let me think about the game more carefully.

The key is that players can choose to swap wallets or not, and then remove one coin from their current wallet.

The game continues until a player cannot make a move, which is when their wallet has zero coins and they can't remove one.

This seems similar to Nim game or other impartial games, where we can analyze the positions based on the number of coins.

Let me consider the concept of "Nimbers" or "xor" in game theory.

But perhaps there's a simpler way.

Let me consider the difference between a and b.

In the program, it checks if the absolute difference is even or odd.

In the case where a = b, difference is 0, which is even, Bob wins.

In the second test case, a=1, b=4, difference=3, odd, Alice wins.

Wait, but in my earlier simulation with a=1, b=2, difference=1, odd, but Bob wins, which contradicts the program.

Hmm.

Maybe I need to find a general formula.

Let me consider that the game is symmetric in some way.

If a = b, then Bob wins.

Because whatever Alice does, Bob can mirror her action.

Wait, in a=1, b=1.

Alice swaps: a=1, b=1. Remove 1 from a: a=0, b=1.

Bob doesn't swap: a=0, b=0. Alice can't move, Bob wins.

Or Alice doesn't swap: a=0, b=1. Bob doesn't swap: a=0, b=0. Alice loses.

So Bob wins when a = b.

Similarly, in a=2, b=2.

Alice can swap or not.

If she swaps: a=2, b=2. Remove 1: a=1, b=2.

Bob can swap: a=2, b=1. Alice can swap back, etc., but eventually, Bob can force a position where Alice has no move.

Seems like when a = b, Bob wins.

Now, when a != b, perhaps Alice can force a win.

Wait, but in the second test case, a=1, b=4, Alice wins.

In a=1, b=2, according to my simulation, Bob wins.

Wait, maybe it's when the difference is even, Bob wins; otherwise, Alice wins.

But in a=1, b=2, difference=1, odd, but Bob wins.

In a=1, b=4, difference=3, odd, Alice wins.

In a=5, b=3, difference=2, even, Bob wins.

In a=4, b=5, difference=1, odd, Alice wins.

Wait, but according to the program, it's based on abs(a - b) % 2 == 0, Bob wins; else Alice wins.

But in a=1, b=2, difference=1, odd, program would say Alice wins, but in simulation, Bob wins.

Contradiction.

So perhaps the program is incorrect.

Alternatively, maybe there's a different pattern.

Let me consider the sum of a and b.

In a=1, b=1, sum=2.

Bob wins.

a=1, b=4, sum=5.

Alice wins.

a=5, b=3, sum=8.

Bob wins.

a=4, b=5, sum=9.

Alice wins.

a=11,9 sum=20. Bob wins.

a=83,91 sum=174. Bob wins.

a=1032,9307 sum=1032+9307=1032+9000=10032+307=10339. Alice wins.

a=839204,7281 sum=839204+7281=846485. Alice wins.

a=1000000000,1000000000 sum=2000000000. Bob wins.

a=53110,2024 sum=53110+2024=55134. Bob wins.

Looking at sum parity:

sum even: a=1,1 sum=2 even Bob wins.

a=5,3 sum=8 even Bob wins.

a=11,9 sum=20 even Bob wins.

a=83,91 sum=174 even Bob wins.

a=1000000000,1000000000 sum=2000000000 even Bob wins.

a=53110,2024 sum=55134 even Bob wins.

sum odd: a=1,4 sum=5 odd Alice wins.

a=4,5 sum=9 odd Alice wins.

a=1032,9307 sum=10339 odd Alice wins.

a=839204,7281 sum=846485 odd Alice wins.

So, when sum is even, Bob wins; when sum is odd, Alice wins.

But in my earlier simulation with a=1, b=2, sum=3 odd, Bob wins, which contradicts this pattern.

Wait, but according to the program, difference even: Bob wins; difference odd: Alice wins.

But in this case, difference=1, odd, program says Alice wins, but simulation shows Bob wins.

So perhaps the program is incorrect.

Alternatively, maybe there's a different way to look at it.

Let me consider the binary operations or some other game theory concept.

Alternatively, maybe it's based on the parity of the number of coins each has.

Wait, perhaps it's about the parity of a and b.

If a and b are both even, or both odd, then Bob wins; else Alice wins.

In a=1, b=1 both odd, Bob wins.

a=1, b=4 one odd, one even, Alice wins.

a=5,3 both odd, Bob wins.

a=4,5 one even, one odd, Alice wins.

a=11,9 both odd, Bob wins.

a=83,91 both odd, Bob wins.

a=1032 even, 9307 odd, Alice wins.

a=839204 even, 7281 odd, Alice wins.

a=1000000000 even, 1000000000 even, Bob wins.

a=53110 even, 2024 even, Bob wins.

This seems consistent.

So, if both a and b have the same parity (both even or both odd), Bob wins; else Alice wins.

But in my simulation of a=1, b=2: both odd and even, Alice wins.

Wait, a=1 odd, b=2 even, Alice wins, which matches this pattern.

So perhaps the correct condition is: if a and b have the same parity, Bob wins; else Alice wins.

But according to this, in a=1, b=2, they have different parity, so Alice wins, which matches the simulation where Bob wins.

Wait, contradiction again.

Wait, a=1 odd, b=2 even, different parity, so Alice wins, but in simulation, Bob wins.

So perhaps this is not the correct condition.

Wait, maybe it's about the difference being even or odd.

In a=1, b=1, difference 0 even, Bob wins.

a=1, b=4 difference 3 odd, Alice wins.

a=5,3 difference 2 even, Bob wins.

a=4,5 difference 1 odd, Alice wins.

a=1,2 difference 1 odd, according to this, Alice wins, but in simulation, Bob wins.

Wait, maybe the program is incorrect.

Alternatively, perhaps it's about the number of moves possible.

Each move reduces the total number of coins by one, since one coin is removed each turn.

The game ends when a player cannot remove a coin, which is when their current wallet has zero coins.

So, the total number of moves possible is equal to the minimum of a and b, since each player must have at least one coin to make a move.

Wait, no. They can swap wallets, so it's more complicated.

Wait, each move reduces the current player's wallet by one coin.

If they choose to swap, they can change their wallet before removing a coin.

This makes it tricky to count the total number of moves.

Maybe I should think in terms of who makes the last move.

The player who cannot make a move loses, so the player who makes the last valid move wins.

Given that Alice moves first.

So, if the total number of moves is even, Bob wins; if odd, Alice wins.

But it's not that simple because of the swapping option.

Let me try to find a strategy for Alice.

If Alice can force Bob into a position where his wallet has zero coins, she wins.

Similarly, Bob tries to force Alice into such a position.

Given that they can swap wallets, it adds complexity.

Perhaps I should consider the game in terms of the number of coins in each wallet and the parity.

Alternatively, maybe there's a mathematical formula based on a and b.

Given the constraints (a and b up to 1e9), it's probably not intended to have a simulation, but rather a formula based on a and b.

Given that the program provided uses abs(a - b) % 2 == 0 to decide Bob's win, but my simulation suggests that it might be incorrect.

Alternatively, perhaps it's about the parity of a and b.

Wait, maybe it's about the parity of the sum of a and b.

In a=1, b=1, sum=2 even, Bob wins.

a=1, b=4 sum=5 odd, Alice wins.

a=5,3 sum=8 even, Bob wins.

a=4,5 sum=9 odd, Alice wins.

a=1032,9307 sum=10339 odd, Alice wins.

a=839204,7281 sum=846485 odd, Alice wins.

a=1000000000,1000000000 sum=2000000000 even, Bob wins.

a=53110,2024 sum=55134 even, Bob wins.

This seems consistent with the program's output.

But in my simulation of a=1, b=2 sum=3 odd, Alice should win, but according to the program, sum=3 odd, Alice wins, which contradicts my earlier simulation where Bob wins.

Wait, perhaps my simulation was wrong.

Let me try again.

a=1, b=2.

Alice's turn:

Option 1: Swap, a=2, b=1. Remove 1 from a: a=1, b=1.

Bob's turn: Swap to a=1, b=1. Remove 1 from a: a=0, b=1.

Alice's turn: a=0, b=1. Can't swap (since swapping wouldn't help), removes from a but a=0, can't remove. So Bob wins.

Option 2: Don't swap. a=1, b=2. Remove 1 from a: a=0, b=2.

Bob's turn: a=0, b=2. Can't swap (since swapping wouldn't help), removes from b: a=0, b=1.

Alice's turn: a=0, b=1. Can't remove from a, can't swap effectively. Loses. Bob wins.

So, in both options, Bob wins, which contradicts the program's output for a=1, b=2 (sum=3 odd, program says Alice wins).

Hence, the program seems to be incorrect.

Alternatively, perhaps there's a different pattern.

Wait, maybe it's about the difference being odd or even.

In a=1, b=1, difference=0 even, Bob wins.

a=1, b=4 difference=3 odd, Alice wins.

a=5,3 difference=2 even, Bob wins.

a=4,5 difference=1 odd, Alice wins.

a=1,2 difference=1 odd, Alice wins, but in simulation, Bob wins.

Contradiction again.

Wait, perhaps the program is incorrect, or maybe I'm missing something in the simulation.

Let me try another approach.

Let me think in terms of game theory and find the winning and losing positions.

Define a position as a pair (a, b), where a and b are the number of coins in Alice's and Bob's wallets, respectively.

A position is a winning position if the player whose turn it is can force a win from that position.

Otherwise, it's a losing position.

Base case: if a=0 and b=0, the player whose turn it is loses.

If a=0 and b>0, the player can choose not to swap and remove a coin from b, leading to a=0 and b=b-1. Eventually, b becomes 0, and the player loses.

Similarly, if a>0 and b=0, the player can choose not to swap and remove a coin from a, leading to a=a-1 and b=0. Eventually, a becomes 0, and the player loses.

So, positions where a=0 or b=0 are losing positions for the player whose turn it is.

Now, for positions where a>0 and b>0, the player can choose to swap or not swap.

If they choose to swap, the wallets are exchanged, and then they remove one coin from their current wallet.

If they choose not to swap, they remove one coin from their current wallet.

So, from position (a, b), the possible next positions are:

1. If they choose to swap: new a = b, new b = a. Then remove 1 from a: (b-1, a).

2. If they choose not to swap: remove 1 from a: (a-1, b).

So, the possible moves from (a, b) are:

- (b-1, a)

- (a-1, b)

We need to find out if there's at least one move that leads to a losing position for the opponent.

In other words, a position is winning if there exists at least one move to a losing position for the opponent.

Otherwise, it's a losing position.

This seems like the standard approach in impartial game theory.

But given the large constraints (a and b up to 1e9), we need an efficient way to compute the winner.

Perhaps there's a mathematical formula based on a and b.

Looking back at the program, it seems to check if the absolute difference between a and b is even or odd.

If it's even, Bob wins; else, Alice wins.

But as seen in the a=1, b=2 case, this seems incorrect.

Alternatively, perhaps it's based on the sum being even or odd.

But in the a=1, b=2 case, sum is 3, which is odd, and according to the program's logic (difference is odd), Alice wins, but in reality, Bob wins.

So, perhaps the program is incorrect.

Alternatively, maybe there's a different pattern.

Let me consider more examples.

Case 1: a=1, b=1.

As per the example, Bob wins.

Case 2: a=1, b=4.

As per the example, Alice wins.

Case 3: a=2, b=2.

Alice's turn: swap to b=2, a=2. Remove 1 from a: a=1, b=2.

Bob's turn: swap to a=2, b=1. Remove 1 from a: a=1, b=1.

Alice's turn: swap to a=1, b=1. Remove 1 from a: a=0, b=1.

Bob's turn: a=0, b=1. Can't remove from a, so Alice loses. Bob wins.

So, a=2, b=2, Bob wins.

a=3, b=3.

Alice's turn: swap to b=3, a=3. Remove 1 from a: a=2, b=3.

Bob's turn: swap to a=3, b=2. Remove 1 from a: a=2, b=2.

Alice's turn: swap to a=2, b=2. Remove 1 from a: a=1, b=2.

Bob's turn: swap to a=2, b=1. Remove 1 from a: a=1, b=1.

Alice's turn: swap to a=1, b=1. Remove 1 from a: a=0, b=1.

Bob's turn: a=0, b=1. Can't remove from a, so Alice loses. Bob wins.

So, a=3, b=3, Bob wins.

a=1, b=2.

As simulated earlier, Bob wins.

a=1, b=3.

Alice's turn: swap to a=3, b=1. Remove 1 from a: a=2, b=1.

Bob's turn: swap to a=1, b=2. Remove 1 from a: a=0, b=2.

Alice's turn: a=0, b=2. Can't swap effectively. Loses. Bob wins.

a=2, b=3.

Alice's turn: swap to a=3, b=2. Remove 1 from a: a=2, b=2.

Bob's turn: swap to a=2, b=2. Remove 1 from a: a=1, b=2.

Alice's turn: swap to a=2, b=1. Remove 1 from a: a=1, b=1.

Bob's turn: swap to a=1, b=1. Remove 1 from a: a=0, b=1.

Alice's turn: a=0, b=1. Can't move. Bob wins.

So, in all these cases where a and b are both even or both odd, Bob wins.

When a and b have different parities, Alice wins.

Wait, a=1, b=2: different parities, Alice wins, but in simulation, Bob wins.

Contradiction.

Wait, perhaps I need to consider a different approach.

Let me consider the mex function or the grundy numbers for each position.

But that might be too time-consuming given the large constraints.

Alternatively, perhaps there's a pattern based on the binary representation.

Wait, maybe it's about the number of coins being equal or differing by a certain amount.

Looking back at the program, it checks if abs(a - b) is even or odd.

In the test cases provided, this seems to work, but in my simulation of a=1, b=2, it fails.

So perhaps the program is incorrect.

Alternatively, perhaps there's a mathematical formula that I'm missing.

Let me consider that the game is equivalent to some known impartial game.

Alternatively, maybe it's better to accept the program as correct since it matches the provided test cases, even though it doesn't match my simulation for a=1, b=2.

But in the interest of correctness, if my simulation is accurate, then the program is incorrect.

However, given that the program matches all the provided test cases, perhaps my simulation is flawed.

Alternatively, maybe the game's outcome depends on the parity of the sum, as I