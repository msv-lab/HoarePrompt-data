Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n signs of the apocalypse, and each sign occurs every a_i years. The signs have to occur sequentially, meaning that after the first sign occurs, we start waiting for the second sign in the next year, and so on.

First, I need to understand how the signs occur. Each sign i occurs in years that are multiples of a_i, like a_i, 2*a_i, 3*a_i, and so on. But according to the problem, the tribe waits for each sign to occur one after the other, in sequence.

So, for example, if n=3 and a=[2,3,4], here's how it should work:

1. Start waiting for the first sign. It occurs in years 2, 4, 6, etc. So the first occurrence is in year 2.

2. After the first sign occurs in year 2, we start waiting for the second sign from year 3 onwards. The second sign occurs in years 3, 6, 9, etc. So the next available occurrence after year 2 is in year 3.

3. After the second sign occurs in year 3, we start waiting for the third sign from year 4 onwards. The third sign occurs in years 4, 8, 12, etc. So the next available occurrence after year 3 is in year 4.

Therefore, the third sign occurs in year 4, and that's when the apocalypse happens.

Wait, but in this sequence, the signs occur in years 2, 3, 4 respectively. So the apocalypse would happen in year 4.

Another example from the problem:

Input:

6

3 2 4 5 9 18

Output:

36

Let's see why it's 36.

Start with year 0.

1. First sign occurs in years 3, 6, 9, etc. So the first occurrence is in year 3.

2. Start waiting for the second sign from year 4 onwards. The second sign occurs in years 2, 4, 6, etc. The first available is year 4.

3. Start waiting for the third sign from year 5 onwards. The third sign occurs in years 4, 8, 12, etc. The next available after year 4 is year 8.

Wait, but according to the note in the problem, it seems different.

In the first set of input data:

- First sign in year 3.

- Second sign in year 4.

- Third sign in year 8.

- Fourth sign in year 10.

- Fifth sign in year 18.

- Sixth sign in year 36.

So, it seems like for each sign, we're waiting for its occurrence in the first available year after the previous sign.

So, in code, for each sign, we need to find the smallest year that is greater than the previous year and is a multiple of a_i.

Wait, but in the first step, for the first sign, the smallest year that is a multiple of a1 is a1 itself. So year = a1.

Then, for the second sign, we need the smallest year greater than year that is a multiple of a2.

Similarly, for the third sign, the smallest year greater than the year of the second sign that is a multiple of a3, and so on.

So, in code, we can initialize year to 0, and then for each sign, set year to the smallest multiple of a_i that is greater than year.

Wait, no. Actually, for the first sign, it occurs in year a1, then for the second sign, it occurs in the smallest year greater than year a1 that is a multiple of a2, and so on.

So, more precisely, for each sign, we need to find the smallest year that is greater than the year the previous sign occurred and is a multiple of a_i.

So, for sign i, year_i = smallest year >= year_{i-1} + 1 such that year_i % a_i == 0.

Wait, the problem says: "starting from the year x+1", where x is the year the previous sign occurred.

So, for sign i, we need the smallest year > year_{i-1} that is a multiple of a_i.

How do we find that?

If year_{i-1} is given, then the next multiple of a_i after year_{i-1} is ceil((year_{i-1} + 1)/a_i) * a_i.

Alternatively, year_i = ((year_{i-1} + 1 + a_i - 1) // a_i) * a_i.

This formula gives the smallest multiple of a_i that is greater than year_{i-1}.

So, we can iterate through the signs, updating the year each time to this next multiple.

Let's test this with the first example:

n=6, a=[3,2,4,5,9,18]

Start with year=0.

1. For a1=3, year = ((0 + 1 + 3 - 1)//3)*3 = (3//3)*3 = 1*3=3.

2. For a2=2, year = ((3 + 1 + 2 -1)//2)*2 = (5//2)*2 = 3*2=6.

Wait, but according to the note, it should be year=4 for the second sign.

Hmm, discrepancy here.

Wait, maybe I misread the problem.

Let me read the problem again.

"the i-th sign occurs every a_i years (in years a_i, 2*a_i, 3*a_i, ...)."

"the signs must occur sequentially. That is, first they wait for the first sign to occur, then strictly after it, the second sign will occur, and so on. If the i-th sign occurred in year x, the tribe starts waiting for the (i+1)-th sign starting from year x+1."

So, for each sign i, after it occurs in year x, the next sign i+1 should occur in the smallest year y >= x+1 where y is a multiple of a_{i+1}.

So, for sign 1, occurs in year a1.

Then for sign 2, occurs in the smallest year y >= a1 + 1 where y % a2 == 0.

Similarly, sign 3 occurs in the smallest year y >= year_of_sign2 + 1 where y % a3 == 0.

And so on.

So, in the first example:

n=6, a=[3,2,4,5,9,18]

1. Sign 1: year=3 (first multiple of 3).

2. Sign 2: smallest y >= 4 (3+1) where y%2==0. y=4.

3. Sign 3: smallest y >=5 where y%4==0. y=8.

4. Sign 4: smallest y >=9 where y%5==0. y=10.

5. Sign 5: smallest y >=11 where y%9==0. y=18.

6. Sign 6: smallest y >=19 where y%18==0. y=36.

So, final year is 36.

Another example:

n=5, a=[1,2,3,4,5]

1. Sign 1: year=1.

2. Sign 2: smallest y >=2 where y%2==0. y=2.

3. Sign 3: smallest y >=3 where y%3==0. y=3.

4. Sign 4: smallest y >=4 where y%4==0. y=4.

5. Sign 5: smallest y >=5 where y%5==0. y=5.

So, final year is 5.

Another example:

n=5, a=[1,1,1,1,1]

Similarly, year=1 for all signs, so final year is 5.

Last example:

n=6, a=[50,30,711,200,503,1006]

1. Sign 1: year=50.

2. Sign 2: smallest y >=51 where y%30==0. y=60.

3. Sign 3: smallest y >=61 where y%711==0. y=711.

4. Sign 4: smallest y >=712 where y%200==0. y=800.

5. Sign 5: smallest y >=801 where y%503==0. y=1006.

6. Sign 6: smallest y >=1007 where y%1006==0. y=2012.

So, final year is 2012.

Now, how to implement this efficiently.

We need to process each test case, for each test case process n signs, and for each sign find the smallest year >= previous_year +1 where year % a_i ==0.

Given that t can be up to 1000 and n up to 100, and a_i up to 10^6, we need an efficient way to compute this.

A straightforward way is to keep track of the current year, and for each sign, compute the smallest multiple of a_i greater than the current year.

The formula for the smallest y >= current_year +1 where y%a_i==0 is:

y = ((current_year +1 + a_i -1) // a_i) * a_i

This is a standard way to compute the smallest multiple of a_i greater than or equal to current_year +1.

So, we can iterate through the signs, and for each sign, update the current year to this y.

Finally, output the year after processing all n signs.

Let's see if this matches the examples.

First test case:

n=6, a=[3,2,4,5,9,18]

Start with year=0.

1. y = ((0+1 +3-1)//3)*3 = (3//3)*3=1*3=3.

2. y = ((3+1 +2-1)//2)*2 = (4//2)*2=2*2=4.

3. y = ((4+1 +4-1)//4)*4 = (8//4)*4=2*4=8.

4. y = ((8+1 +5-1)//5)*5 = (13//5)*5=3*5=15.

Wait, but according to the note, it should be 10 for the fourth sign.

Wait, discrepancy here. Maybe I miscalculated.

Wait, in the note, it says:

- First sign in year 3.

- Second sign in year 4.

- Third sign in year 8.

- Fourth sign in year 10.

- Fifth sign in year 18.

- Sixth sign in year 36.

So, according to my calculation:

1. year=0 -> y=3.

2. year=3 -> y=4.

3. year=4 -> y=8.

4. year=8 -> y=10.

5. year=10 -> y=18.

6. year=18 -> y=36.

Yes, it matches.

I must have misread earlier.

So, the formula y = ((year +1 + a_i -1)//a_i)*a_i works.

Now, in code, we need to implement this for each test case.

Given that t can be up to 1000 and n up to 100, and a_i up to 1e6, this should be efficient enough.

Now, looking at the provided program:

def func():

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().split()))

year = 0

for ai in a:

year += year % ai or ai

print(year)

Wait, this seems different from what I thought.

It initializes year=0, then for each ai, it adds year % ai or ai to year.

Wait, "year % ai or ai"

In Python, "or" returns the first truthy value or the last value if all are falsy.

So, year % ai is 0 if year is divisible by ai, else it's year % ai.

So, if year % ai == 0, then year % ai is 0, so it adds ai instead.

Else, it adds year % ai.

Wait, let's see with the first example.

n=6, a=[3,2,4,5,9,18]

Start with year=0.

1. year % 3 == 0, so add 3. year = 0 + 3 = 3.

2. year % 2 == 1, so add 1. year = 3 +1 =4.

3. year % 4 ==0, so add 4. year=4+4=8.

Wait, but according to the note, after year=8, the next sign should be in year=10, not year=8+4=12.

Wait, it's not matching.

Wait, perhaps I misread.

Wait, in the note, after year=8, the next sign is in year=10.

But according to the code, year =8, year %5 ==3, so add 3. year=8+3=11.

But according to the note, it's 10.

Hmm, discrepancy.

Wait, maybe I'm misunderstanding the "year % ai or ai".

Wait, "or" in Python returns the first truthy value.

In Python, 0 is falsy, any non-zero integer is truthy.

So, year % ai is 0 if year is divisible by ai, else it's truthy.

So, year % ai or ai is:

- if year % ai !=0, then year % ai

- else, ai

So, in the first step:

year=0, ai=3, year%3=0, so add ai=3. year=3.

Second step:

year=3, ai=2, year%2=1, so add 1. year=4.

Third step:

year=4, ai=4, year%4=0, so add ai=4. year=8.

Fourth step:

year=8, ai=5, year%5=3, so add 3. year=11.

Fifth step:

year=11, ai=9, year%9=2, so add 2. year=13.

Sixth step:

year=13, ai=18, year%18=13, so add 13. year=26.

But according to the note, it should be 36.

So, this doesn't match.

Wait, perhaps I made a mistake in the calculation.

Wait, in the note, it's:

- First sign in year 3.

- Second sign in year 4.

- Third sign in year 8.

- Fourth sign in year 10.

- Fifth sign in year 18.

- Sixth sign in year 36.

But according to the code:

1. year=0 +3=3.

2. year=3 +1=4.

3. year=4 +0=8.

4. year=8 +3=11.

5. year=11 +2=13.

6. year=13 +13=26.

Wait, not matching.

Wait, perhaps the "year += year%ai or ai" is not correct.

Wait, maybe I need to re-examine this.

Looking back, the correct way is to compute the smallest multiple of ai greater than year.

Which is y = ((year +1 +ai -1)//ai)*ai.

But in the code, it's doing year += year%ai or ai.

Which seems like a shortcut.

Wait, let's see:

In the first step, year=0, ai=3.

0%3=0, so add ai=3. year=3.

In the second step, year=3, ai=2.

3%2=1, so add 1. year=4.

Third step, year=4, ai=4.

4%4=0, so add 4. year=8.

Fourth step, year=8, ai=5.

8%5=3, so add 3. year=11.

Fifth step, year=11, ai=9.

11%9=2, so add 2. year=13.

Sixth step, year=13, ai=18.

13%18=13, so add 13. year=26.

But according to the note, it should be 36.

So, this seems incorrect.

Wait, perhaps there's a mistake in my understanding.

Wait, in the note, after year=18, the next sign should be in year=36.

But according to the code, year=13 +13=26, which is not matching.

So, perhaps the code is wrong.

Wait, but maybe I misread the problem.

Wait, perhaps the formula in the code is correct, and I miscalculated.

Let's see for the second example.

n=5, a=[1,2,3,4,5]

1. year=0 +1=1.

2. year=1 +1=2.

3. year=2 +1=3.

4. year=3 +0=3.

Wait, but according to the note, it should be 5.

Hmm, another discrepancy.

Wait, perhaps I need to re-examine the formula.

Wait, in the code, year += year%ai or ai.

Which is equivalent to:

if year % ai != 0:

year += year % ai

else:

year += ai

Wait, no. In Python, "or" returns the first truthy value or the last value.

So, year += year%ai or ai is equivalent to:

year += year%ai if year%ai else ai

Which is:

if year % ai !=0:

year += year % ai

else:

year += ai

So, it's adding the remainder if there is one, else adding ai.

Wait, but in the first example, it adds ai when year is divisible by ai, else adds year%ai.

Wait, but in the note, for a_i=5, year=10 is chosen, which is the smallest multiple of 5 greater than 8.

But according to the code, year=8, 8%5=3, so year +=3 -> year=11, which is not matching.

So, the code seems incorrect.

Wait, but maybe I need to think differently.

Wait, perhaps the code is trying to implement the smallest multiple of ai greater than year.

Which is y = ((year +1 +ai -1)//ai)*ai.

But in a more optimized way.

But it seems not matching the expected output.

Wait, perhaps there's a mathematical equivalence I'm missing.

Let me try to see.

Given year, ai.

We want y = smallest multiple of ai greater than year.

Which is y = ceil((year +1)/ai) * ai.

Now, in the code, year += year%ai or ai.

Which is:

if year % ai !=0:

year += year % ai

else:

year += ai

So, year becomes year + (year % ai if year % ai !=0 else ai)

Wait, but ceil((year +1)/ai) * ai is equivalent to ((year +1 +ai -1)//ai)*ai.

Which is the formula I mentioned earlier.

Let me see if this is equal to year + (ai - year % ai) if year % ai !=0 else year + ai.

Wait, year % ai is the remainder.

So, if year % ai ==0, then y = year + ai.

Else, y = year + (ai - year % ai).

Which is equivalent to y = ceil((year +1)/ai) * ai.

Wait a minute, yes.

So, y = year + (ai - year % ai) if year % ai !=0 else year + ai.

But in the code, it's year += year % ai if year % ai !=0 else ai.

Which is adding year % ai to year if year % ai !=0, else adding ai.

Wait, that's not the same.

Wait, that would make y = year + (year % ai if year % ai !=0 else ai)

Which is y = year + year % ai if year % ai !=0 else year + ai.

But what we need is y = year + (ai - year % ai) if year % ai !=0 else year + ai.

Wait, that's different.

So, the code is incorrect.

It should be year += ai - (year % ai) if year % ai !=0 else ai.

Wait, but that would be y = year + ai - (year % ai) if year % ai !=0 else year + ai.

Which simplifies to y = year + ai - year % ai if year % ai !=0 else year + ai.

But since year % ai is the remainder, ai - year % ai is the amount needed to reach the next multiple.

Yes, that's the correct formula.

So, the code should be:

year += ai - (year % ai) if year % ai !=0 else ai

Which can be written more concisely using the or operator.

Wait, in Python, year += ai - year % ai or ai

But in Python, "or" has lower precedence than "+=", so it would be year += (ai - year % ai or ai)

Which is equivalent to year += (ai - year % ai if year % ai !=0 else ai)

Which is correct.

Wait, but in the given code, it's year += year % ai or ai.

Which is year += (year % ai if year % ai !=0 else ai)

Which is different from what we need.

So, the given code is incorrect.

It should be year += ai - year % ai or ai.

Wait, but even better, y = ((year +1 + ai -1) // ai) * ai.

But to optimize, we can compute it as y = year + ai - (year % ai) if year % ai !=0 else year + ai.

Which is equivalent to y = ((year +1 + ai -1) // ai) * ai.

So, the given code is incorrect.

Hence, Correctness: **False**

## Final Solution
To solve this problem, we need to determine the year in which the nth sign occurs, given that each sign occurs periodically and sequentially. The key is to calculate the smallest year for each sign that is greater than the year the previous sign occurred.

### Approach

1. **Initialization**: Start from year 0.
2. **Iterate through each sign**: For each sign, calculate the smallest year that is greater than the current year and is a multiple of the sign's periodicity.
3. **Update the year**: Update the current year to this calculated year for each sign.
4. **Output the final year**: After processing all signs, the current year will be the year when the nth sign occurs.

### Solution Code

```python
def func():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    t = int(data[0])
    index = 1
    for _ in range(t):
        n = int(data[index])
        a = list(map(int, data[index+1:index+1+n]))
        index += n + 1
        year = 0
        for ai in a:
            if year % ai == 0:
                year += ai
            else:
                year += (ai - (year % ai))
        print(year)

if __name__ == "__main__":
    func()
```

### Explanation

1. **Reading Input**: Read the input in one go and split it into a list for easier access.
2. **Processing Each Test Case**:
   - Read the number of signs `n`.
   - Read the periodicities of the signs into list `a`.
3. **Calculating the Year for Each Sign**:
   - Initialize `year` to 0.
   - For each sign's periodicity `ai`:
     - If `year` is already a multiple of `ai`, add `ai` to `year`.
     - Otherwise, add the difference between `ai` and the remainder of `year` divided by `ai` to make `year` a multiple of `ai`.
4. **Output the Result**: Print the final `year` for each test case.

This approach ensures that we correctly calculate the year when all n signs occur sequentially, adhering to their periodicities.