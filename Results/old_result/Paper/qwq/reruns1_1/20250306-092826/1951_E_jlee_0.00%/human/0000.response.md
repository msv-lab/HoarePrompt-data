Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a string consisting of lowercase Latin letters, and I need to partition this string into substrings where none of these substrings is a palindrome. A palindrome is a string that reads the same forwards and backwards, like "racecar" or "abccba".

First, I need to understand what a partition is. It's an ordered sequence of strings that, when concatenated, form the original string. So, for example, if I have the string "abc", possible partitions could be ["a", "b", "c"], ["ab", "c"], or ["a", "bc"], etc.

My task is to find at least one way to partition the string such that none of the substrings is a palindrome. If such a partition exists, I should print "YES", followed by the number of parts in the partition and the parts themselves. If no such partition exists, I should print "NO".

Okay, let's think about when such a partition would not exist. If every possible substring of the string is a palindrome, then I couldn't partition it in a way that none of the parts is a palindrome. But wait, that doesn't sound right. Even if the entire string is a palindrome, I can still partition it into smaller substrings that might not be palindromes.

For example, take "aaa". The whole string is a palindrome, but if I partition it into ["a", "a", "a"], each part is a palindrome. So that doesn't work. Or if I partition it into ["aa", "a"], both parts are palindromes. So in this case, no matter how I partition it, every part is a palindrome. So, for strings where all substrings are palindromes, the answer should be "NO".

But in general, for most strings, I should be able to find a partition where none of the parts is a palindrome.

Let me think about how to approach this.

One straightforward way is to check if the entire string is a palindrome. If it's not, then I can just take the whole string as one part and that's a valid partition. If it is a palindrome, then I need to try partitioning it into smaller substrings and check if those are palindromes.

But checking every possible partition is inefficient, especially since the string can be up to 10^6 characters long, and there are multiple test cases.

I need a more efficient way to determine if such a partition exists.

Let me consider the properties of palindromes. A palindrome reads the same forwards and backwards. So, for a string to not be a palindrome, there must be at least one pair of characters that don't match when compared from the start and the end.

Given that, perhaps I can find a way to partition the string such that at least one of the parts has mismatched characters.

Wait, actually, I need to ensure that each part is not a palindrome. So, I need to make sure that in each part, there's at least one pair of characters that don't match when compared from the start and the end of that part.

This seems a bit tricky. Maybe instead of thinking about palindromes, I can think about non-palindromic substrings.

Let me consider the following approach:

- If the entire string is not a palindrome, then I can just take the whole string as one part.

- If the entire string is a palindrome, then I need to split it into smaller parts, each of which is not a palindrome.

- But, if the entire string is a palindrome, and it's composed of identical characters, like "aaa...", then any partition will have parts that are also palindromes, since all their characters are the same and they read the same forwards and backwards.

- However, if the string is a palindrome but has at least one character that differs, then maybe I can find a way to partition it such that the parts are not palindromes.

Wait, no. If the string is a palindrome and composed of identical characters, like "aaa", then any partition will have parts that are also palindromes, because "a" is a palindrome, "aa" is a palindrome, and "aaa" is a palindrome.

But if the string is a palindrome and has different characters, like "abba", then I can partition it into "ab" and "ba", neither of which is a palindrome.

Wait, "ab" is not a palindrome, and "ba" is not a palindrome. So, in this case, I can partition it into non-palindromic substrings.

Similarly, for "racecar", I could partition it into "rac", "e", and "car", where "rac" is not a palindrome, "e" is a palindrome, so that doesn't work. So, I need to find a different partition.

Wait, "racecar" can be partitioned into "rac", "e", "car". "rac" is not a palindrome, "e" is a palindrome, "car" is not a palindrome. So, this partition has one part that is a palindrome, which is not allowed.

So, I need to find a partition where all parts are non-palindromic.

In the case of "racecar", perhaps partitioning it into "r", "aceca", "r" wouldn't work because "r" is a palindrome. Or "ra", "cec", "ar". "ra" is not a palindrome, "cec" is a palindrome, "ar" is not a palindrome. So, that doesn't work.

Another partition could be "rac", "e", "car". As before, "e" is a palindrome.

Hmm, maybe "race", "car". "race" is not a palindrome, "car" is not a palindrome. Wait, "race" reversed is "ecar", which is different from "race", so it's not a palindrome. "car" reversed is "rac", which is different from "car", so it's not a palindrome. So, this partition works.

So, for "racecar", partitioning into "race" and "car" gives me two non-palindromic substrings.

So, in this case, it's possible.

Wait, but "racecar" is a palindrome, and I was able to partition it into non-palindromic substrings.

So, perhaps the only case where it's impossible is when the string is composed entirely of repeated identical characters, like "aaa...a".

Because in that case, any substring is also composed of identical characters and hence is a palindrome.

So, perhaps the only impossible case is when all characters in the string are the same.

Let me test this idea.

Take "aaa". Any partition will have parts that are "a", "aa", or "aaa", all of which are palindromes.

Take "aab". This is not entirely composed of the same characters. So, I should be able to partition it into non-palindromic substrings.

For example, "aab" can be partitioned into "aab", which is not a palindrome.

Alternatively, "aa", "b", where "aa" is a palindrome, "b" is a palindrome.

Or "a", "ab", where "a" is a palindrome, "ab" is not a palindrome.

So, in this case, partitioning into "aab" works, since "aab" is not a palindrome.

Wait, is "aab" a palindrome? Let's check: "aab" reversed is "baa", which is different from "aab", so it's not a palindrome.

So, in this case, partitioning into "aab" is valid.

Another example: "abba".

Possible partitions:

- "abba" itself, which is a palindrome, so not valid.

- "ab", "ba": "ab" is not a palindrome, "ba" is not a palindrome. Wait, "ab" reversed is "ba", which is different from "ab", so "ab" is not a palindrome. Similarly, "ba" is not a palindrome.

Wait, but "ab" is not a palindrome because "ab" != "ba". So, this partition is valid.

Wait, but in the earlier example with "racecar", partitioning into "race" and "car" worked.

So, perhaps for any string that is not composed entirely of the same character, it's possible to partition it into non-palindromic substrings.

Is that always true?

Let's consider "abc".

Partitioning into "abc": "abc" is not a palindrome.

So, that works.

Or "ab"c: "ab" and "c": "ab" is not a palindrome, "c" is a palindrome. So, this doesn't work.

Or "a"bc: "a" and "bc": "a" is a palindrome, "bc" is not a palindrome.

So, this doesn't work.

Or "abc": "ab" and "c": "ab" is not a palindrome, "c" is a palindrome.

Not valid.

Wait, but "abc" can be partitioned into "abc", which is not a palindrome.

So, that works.

Another example: "abba".

As I thought earlier, partitioning into "ab" and "ba" works.

So, perhaps the only case where it's impossible is when the string consists of all identical characters.

Let me consider "aaab".

This is not all identical characters. So, I should be able to partition it into non-palindromic substrings.

For example, "aaab": partition into "aaa" and "b": "aaa" is a palindrome, "b" is a palindrome.

Not good.

Or "aa", "ab": "aa" is a palindrome, "ab" is not a palindrome.

Not valid.

Or "a", "aab": "a" is a palindrome, "aab" is not a palindrome.

So, this works.

Wait, "aab" is not a palindrome, as we saw earlier.

So, in this case, partitioning into "a" and "aab" works, because "aab" is not a palindrome.

Wait, but "a" is a palindrome, so it's invalid.

Wait, no, in this partition, "a" is a palindrome, so it's invalid.

Wait, I need all parts to not be palindromes.

So, in this case, partitioning into "a" and "aab" is invalid because "a" is a palindrome.

So, I need to find another partition.

How about "aa", "ab": "aa" is a palindrome, "ab" is not a palindrome.

Again, "aa" is a palindrome.

Or "aaa", "b": "aaa" is a palindrome, "b" is a palindrome.

Not good.

Or "a", "a", "ab": all of these have palindromic parts.

So, in this case, is there a way to partition "aaab" into non-palindromic substrings?

Let's see: "aaa" is a palindrome, "b" is a palindrome.

Wait, but "aaab" as a whole is not a palindrome.

"aaab" reversed is "baaa", which is different from "aaab".

So, partitioning into "aaab" works.

So, in this case, partitioning into the entire string works.

Wait, but in the earlier case with "abba", partitioning into "abba" doesn't work because "abba" is a palindrome.

Wait, "abba" is a palindrome, so partitioning into "abba" is invalid.

So, I need to consider whether the entire string is a palindrome or not.

If it's not a palindrome, then partitioning into the entire string works.

If it is a palindrome, then I need to try partitioning it into smaller parts, each of which is not a palindrome.

But, as seen in "aaab", even if the entire string is not a palindrome, some partitions may have palindromic parts.

So, perhaps the general rule is:

- If the entire string is not a palindrome, partition it into the entire string.

- If the entire string is a palindrome, try to partition it into two parts, and check if both parts are not palindromes.

- If both parts are not palindromes, then it's valid.

- If one or both parts are palindromes, try a different partition.

- If no such partition exists, then output "NO".

But, in practice, for strings that are palindromes, if I can partition it into two non-palindromic parts, that should work.

For example, "abba" can be partitioned into "ab" and "ba", both of which are not palindromes.

Another example, "racecar" can be partitioned into "race" and "car", both of which are not palindromes.

What about "level"?

"level" is a palindrome.

Partitioning into "lev" and "el": "lev" is not a palindrome, "el" is not a palindrome.

So, this works.

What about "rotator"?

"rotator" is a palindrome.

Partitioning into "rot" and "ator": "rot" is not a palindrome, "ator" is not a palindrome.

So, this works.

What about "a"?

"a" is a palindrome.

Any partition of "a" would just be "a", which is a palindrome.

So, "a" should return "NO".

What about "ab"?

"ab" is not a palindrome.

So, partitioning into "ab" works.

What about "aa"?

"aa" is a palindrome.

Partitioning into "a" and "a": both are palindromes.

So, no valid partition.

So, in this case, "NO".

What about "aba"?

"aba" is a palindrome.

Partitioning into "ab" and "a": "ab" is not a palindrome, "a" is a palindrome.

Not valid.

Or "a", "ba": "a" is a palindrome, "ba" is not a palindrome.

Still, "a" is a palindrome.

Or "aba" as one part: "aba" is a palindrome.

So, no valid partition.

Wait, but "aba" can be partitioned into "ab" and "a".

But "a" is a palindrome, so it's invalid.

Is there any other partition?

"ab", "a".

No.

So, in this case, "NO".

Wait, but according to my earlier idea, if the string consists of all identical characters, like "aaa", then "NO".

But in "aba", the characters are not all identical, but still, there's no valid partition.

So, my earlier idea that only strings with all identical characters have no valid partition is incorrect.

There are other strings, like "aba", where even though characters are not all identical, there's no valid partition.

So, I need a better way to determine when a valid partition exists.

Let me think differently.

Suppose I have a string that is a palindrome and has an odd length, like "aba".

In this case, no matter how I partition it, if I have any single character part, it's a palindrome.

If I have "ab" and "a", "ab" is not a palindrome, but "a" is a palindrome.

If I have "aba" as one part, it's a palindrome.

So, no valid partition.

Similarly, "aa" is a palindrome and any partition has palindromic parts.

So, in this case, "NO".

What about "abc"?

"abc" is not a palindrome.

So, partitioning into "abc" works.

What about "abba"?

"abba" is a palindrome.

But partitioning into "ab" and "ba" works, as neither is a palindrome.

So, in this case, "YES".

What about "abccba"?

"abccba" is a palindrome.

Partitioning into "abc" and "cba": "abc" is not a palindrome, "cba" is not a palindrome.

So, this works.

Another partition could be "ab", "cc", "ba": "ab" is not a palindrome, "cc" is a palindrome, which makes it invalid.

So, in this case, choosing "abc" and "cba" works.

So, seems like for some palindromic strings, partitioning into two parts works, as long as neither part is a palindrome.

So, perhaps the general rule is:

- If the string is not a palindrome, partition it into the entire string.

- If the string is a palindrome, try partitioning it into two parts in such a way that neither part is a palindrome.

- If such a partition exists, output "YES" and the partition.

- If no such partition exists, output "NO".

But, I need to ensure that both parts are not palindromes.

How do I efficiently check if a string is a palindrome?

I can compare the string with its reverse.

To check if a substring is a palindrome, I can do the same.

But for efficiency, since the string can be up to 10^6 characters, I need an efficient way to check for palindromes.

Maybe I can precompute some properties of the string to speed up the checks.

Alternatively, I can look for specific patterns.

Let me think about the cases where a palindromic string can be partitioned into non-palindromic substrings.

Suppose the string is a palindrome and has length greater than 1.

If I can find a partition where both parts are not palindromes, then "YES".

Otherwise, "NO".

So, for each possible partition point, check if both parts are not palindromes.

If at least one such partition exists, then "YES".

Else, "NO".

But with strings up to 10^6 characters, iterating over all possible partition points is not efficient.

I need a smarter way.

Let's consider that for a palindromic string, if I can find a partition point such that neither part is a palindrome, then "YES".

Otherwise, "NO".

For example, in "abba", partitioning into "ab" and "ba" works.

In "aa", partitioning into "a" and "a" doesn't work.

In "aba", partitioning into "ab" and "a" has "a" as a palindrome.

Partitioning into "a" and "ba" has "a" as a palindrome.

Partitioning into "aba" has "aba" as a palindrome.

So, no valid partition.

Similarly, in "abccba", partitioning into "abc" and "cba" works.

In "a", only partition is "a", which is a palindrome.

In "ab", since "ab" is not a palindrome, partitioning into "ab" works.

In "abc", since "abc" is not a palindrome, partitioning into "abc" works.

So, the general rule seems to be:

- If the string is not a palindrome, partition it into the entire string.

- If the string is a palindrome, try partitioning it into two parts, and check if both parts are not palindromes.

- If such a partition exists, output "YES" and the partition.

- If no such partition exists, output "NO".

Now, for strings that are palindromes, I need to find if there exists at least one partition point where both parts are not palindromes.

To do this efficiently, I need a way to check for palindromes quickly.

One way is to precompute the palindromic properties of the string.

Alternatively, I can look for specific positions where partitioning would result in non-palindromic parts.

Let me consider that for a palindromic string, if I can find a partition point such that at least one of the parts has a pair of characters that don't match when compared from the start and end, then it's not a palindrome.

Wait, but since the whole string is a palindrome, any substring might still be a palindrome.

This is getting complicated.

Maybe I can look at the first and last characters.

If the first and last characters are different, then the string itself is not a palindrome.

But in our case, since the string is a palindrome, all corresponding characters from the start and end are equal.

Wait, no, that's the definition of a palindrome.

So, for a palindromic string, s[0] == s[-1], s[1] == s[-2], and so on.

So, in a palindromic string, all corresponding characters are equal.

Now, when I partition it into two parts, say at position k, I get s1 = s[0..k-1] and s2 = s[k..n-1].

I need to check if neither s1 nor s2 is a palindrome.

For s1 to not be a palindrome, there must be at least one pair of characters in s1 that don't match when compared from the start and end of s1.

Similarly for s2.

But since the whole string is a palindrome, s1 and s2 have certain symmetries.

Let me consider an example.

Take "abba", which is a palindrome.

Partitioning at position 2: s1 = "ab", s2 = "ba".

Check if "ab" is a palindrome: "ab" != "ba", so "ab" is not a palindrome.

Check if "ba" is a palindrome: "ba" != "ab", so "ba" is not a palindrome.

So, this partition works.

Another example: "racecar".

Partitioning at position 4: s1 = "race", s2 = "car".

Check if "race" is a palindrome: "race" != "ecar", so not a palindrome.

Check if "car" is a palindrome: "car" != "rac", so not a palindrome.

So, this works.

Now, take "aaa".

Partitioning at position 1: s1 = "a", s2 = "aa".

Both are palindromes.

Partitioning at position 2: s1 = "aa", s2 = "a".

Both are palindromes.

No valid partition.

Another example: "aba".

Partitioning at position 1: s1 = "a", s2 = "ba".

"s1" is a palindrome.

Partitioning at position 2: s1 = "ab", s2 = "a".

"s2" is a palindrome.

Partitioning as the whole string: "aba" is a palindrome.

No valid partition.

So, in this case, "NO".

Wait, but "ab" is not a palindrome, and "a" is a palindrome.

So, the partition "ab" and "a" has "a" as a palindrome, which is invalid.

So, no valid partition.

So, seems like for strings that are palindromes and have repeating characters, no valid partition exists.

For strings that are palindromes but have varying characters, I can find a partition where both parts are not palindromes.

Wait, but in "abba", which is a palindrome and has varying characters, I can partition it into "ab" and "ba", both not palindromes.

In "aaa", which is a palindrome with repeating characters, any partition has palindromic parts.

So, perhaps the rule is:

- If the string is not a palindrome, partition it into the entire string.

- If the string is a palindrome and all characters are the same, output "NO".

- If the string is a palindrome and not all characters are the same, try partitioning it into two parts where neither part is a palindrome.

- To check if such a partition exists, look for a partition point where both parts are not palindromes.

But, I need to ensure that for palindromic strings with not all identical characters, such a partition exists.

Let me consider "abccba".

Partitioning into "ab" and "cba": "ab" is not a palindrome, "cba" is not a palindrome.

So, this works.

Another partition: "abc" and "cba".

"abc" is not a palindrome, "cba" is not a palindrome.

So, this works.

What about "abcba"?

This is a palindrome.

Partitioning into "abc" and "ba".

"abc" is not a palindrome, "ba" is not a palindrome.

So, this works.

Another example: "abcdcba".

Partitioning into "abcd" and "cba".

"abcd" is not a palindrome, "cba" is not a palindrome.

So, this works.

Seems like for palindromic strings with varying characters, partitioning into two parts where each part has more than one character works, as neither part is a palindrome.

Wait, but in "aba", which is a palindrome with varying characters, partitioning into "ab" and "a" has "a" as a palindrome.

Partitioning into "a" and "ba" has "a" as a palindrome.

So, in this case, no valid partition.

Wait, why is that?

Is "aba" an exception?

Wait, "aba" has length 3.

In general, for palindromic strings with length greater than 2, if the middle character is different, perhaps partitioning around the middle works.

But in "aba", the middle character is "b", which is different from "a".

But still, no valid partition.

So, perhaps my earlier idea is still flawed.

Let me think differently.

Suppose the string is a palindrome.

If I can find a partition point such that neither part is a palindrome, then "YES".

Otherwise, "NO".

To check this efficiently, I need to find if there exists at least one partition point where both parts are not palindromes.

Given that the string is a palindrome, I can iterate through possible partition points and check for each partition if both parts are not palindromes.

But with n partition points for a string of length n, and n up to 10^6, this would be too slow.

I need a smarter way.

Let me consider that for a palindromic string, if I partition it into two parts of lengths l and n-l, then s1 = s[0..l-1] and s2 = s[l..n-1].

Since the string is a palindrome, s1 is a palindrome if and only if s2 is a palindrome.

Wait, no.

Wait, s1 is a palindrome if s[0] == s[l-1], s[1] == s[l-2], etc.

Similarly, s2 is a palindrome if s[l] == s[n-1], s[l+1] == s[n-2], etc.

But since the whole string is a palindrome, s[0] == s[n-1], s[1] == s[n-2], and so on.

So, for s1 to be a palindrome, s[0] == s[l-1], s[1] == s[l-2], etc.

Similarly for s2.

But I'm not sure if there's a direct relationship between the palindromicity of s1 and s2 given that s is a palindrome.

Maybe I need to consider specific cases.

Let me consider that for a palindromic string, if I partition it into two parts of lengths l and n-l, then:

- If l < n-l, then s1 is a palindrome only if s1 is equal to its reverse.

- Similarly, s2 is a palindrome only if s2 is equal to its reverse.

But since s is a palindrome, s1 and s2 have certain symmetries.

Wait, perhaps I can consider that for s1 to not be a palindrome, there exists at least one pair of characters in s1 that don't match when compared from the start and end of s1.

Similarly for s2.

Given that s is a palindrome, s1 and s2 must satisfy certain conditions.

This is getting too complicated.

Maybe I should look for a different approach.

Let me consider that for a palindromic string, if I can find a partition point l such that s1 and s2 are both not palindromes.

To ensure that s1 is not a palindrome, I need that s[0] != s[l-1], or s[1] != s[l-2], etc.

But since s is a palindrome, s[0] == s[n-1], s[1] == s[n-2], and so on.

So, for s1 to not be a palindrome, I need that s[0] != s[l-1], which contradicts the fact that s[0] == s[n-1].

Wait, no.

Since s is a palindrome, s[0] == s[n-1], s[1] == s[n-2], and so on.

So, for s1, which is s[0..l-1], to be a palindrome, s[0] == s[l-1], s[1] == s[l-2], etc.

But s[0] == s[n-1], s[1] == s[n-2], and so on.

So, if l <= n-l, then s[l-1] == s[n-l], but s[n-l] == s[l-1], which is already true because s is a palindrome.

Wait, I'm getting stuck here.

Maybe I need to consider specific lengths.

Let me consider that for a palindromic string, if I partition it into two parts of lengths l and n-l, then:

- s1 is a palindrome if and only if s[0..l-1] is a palindrome.

- s2 is a palindrome if and only if s[l..n-1] is a palindrome.

Given that s is a palindrome, s[0..l-1] being a palindrome depends on the internal symmetry of s1.

Similarly for s2.

But I need a way to determine if there exists at least one l where both s1 and s2 are not palindromes.

This seems tricky.

Perhaps I can consider that if the string has more than one unique character, and it's a palindrome, then there exists a partition point where both parts are not palindromes.

But earlier examples show that this is not always true, like "aba".

So, I need a better way.

Let me consider the frequency of characters in the string.

If the string is a palindrome and has all identical characters, then any partition will have parts that are palindromes.

If the string is a palindrome and has more than one unique character, then perhaps I can find a partition where both parts are not palindromes.

But as seen in "aba", this is not always possible.

Wait, in "aba", it's a palindrome with more than one unique character, but no valid partition exists.

So, my earlier idea is still flawed.

Let me think differently.

Suppose that for a palindromic string, if its length is greater than 2 and it's not all identical characters, then a valid partition exists.

But in "aba", which is palindromic with length 3 and not all identical characters, no valid partition exists.

So, that's not correct.

Wait, in "abba", which is palindromic with length 4 and not all identical characters, a valid partition exists.

In "abcba", which is palindromic with length 5 and not all identical characters, a valid partition exists.

In "aba", which is palindromic with length 3 and not all identical characters, no valid partition exists.

So, perhaps for palindromic strings with length greater than 3 and not all identical characters, a valid partition exists.

But in "aba", which has length 3, no valid partition exists.

Similarly, in "aa", which has length 2, no valid partition exists.

In "a", which has length 1, no valid partition exists.

In "ab", which has length 2, it's not a palindrome, so partitioning into "ab" works.

In "abc", which has length 3 and is not a palindrome, partitioning into "abc" works.

In "abba", which has length 4 and is a palindrome, partitioning into "ab" and "ba" works.

In "abcba", which has length 5 and is a palindrome, partitioning into "abc" and "ba" works.

So, perhaps the rule is:

- If the string is not a palindrome, partition it into the entire string.

- If the string is a palindrome and its length is greater than 3, try partitioning it into two parts, each of length at least 2.

- Check if both parts are not palindromes.

- If such a partition exists, output "YES" and the partition.

- If the string is a palindrome and its length is 2 or 3, and it's composed of all identical characters, output "NO".

- If it's a palindrome with length 2 or 3 and not all identical characters, check if a valid partition exists.

Wait, in "abba" (length 4, palindrome, not all identical characters), partitioning into "ab" and "ba" works.

In "abcba" (length 5, palindrome, not all identical characters), partitioning into "abc" and "ba" works.

In "aba" (length 3, palindrome, not all identical characters), no valid partition exists.

In "aa" (length 2, palindrome, all identical characters), no valid partition exists.

In "ab" (length 2, not a palindrome), partitioning into "ab" works.

In "a" (length 1, palindrome), no valid partition exists.

So, perhaps the rule is:

- If the string is not a palindrome, partition it into the entire string.

- If the string is a palindrome and its length is greater than 3, try partitioning it into two parts, each of length at least 2.

- Check if both parts are not palindromes.

- If such a partition exists, output "YES" and the partition.

- If the string is a palindrome with length 2 or 3, and all characters are identical, output "NO".

- If the string is a palindrome with length 2 or 3 and not all identical characters, output "NO", since no valid partition exists.

Wait, but in "abba" (length 4, palindrome, not all identical characters), partitioning into "ab" and "ba" works.

In "abcba" (length 5, palindrome, not all identical characters), partitioning into "abc" and "ba" works.

In "aba" (length 3, palindrome, not all identical characters), no valid partition exists.

So, perhaps for palindromic strings with length greater than 3 and not all identical characters, a valid partition exists by partitioning into two parts, each of length at least 2.

For palindromic strings with length 2 or 3, if all characters are identical, "NO"; if not all identical, still "NO", as seen in "aba".

Wait, but "ab" (length 2, not a palindrome) can be partitioned into "ab", which is valid.

So, perhaps the rule is:

- If the string is not a palindrome, partition it into the entire string.

- If the string is a palindrome:

- If all characters are identical, output "NO".

- If not all characters are identical and the length is greater than 3, output "YES" by partitioning into two parts, each of length at least 2.

- If the length is 2 or 3 and not all characters are identical, output "NO".

Wait, but in "abba" (length 4, palindrome, not all identical characters), partitioning into "ab" and "ba" works.

In "abcba" (length 5, palindrome, not all identical characters), partitioning into "abc" and "ba" works.

In "aba" (length 3, palindrome, not all identical characters), no valid partition exists.

So, perhaps for palindromic strings with length greater than 3 and not all identical characters, a valid partition exists.

For palindromic strings with length 2 or 3, even if not all characters are identical, no valid partition exists.

Wait, but "aa" (length 2, palindrome, all identical characters) -> "NO"

"ab" (length 2, not a palindrome) -> "YES"

"aba" (length 3, palindrome, not all identical characters) -> "NO"

"abc" (length 3, not a palindrome) -> "YES"

So, perhaps for palindromic strings:

- If the length is 2 and all characters are identical, "NO"

- If the length is 3 and all characters are identical, "NO"

- If the length is greater than 3 and not all characters are identical, "YES"

- If the length is greater than 3 and all characters are identical, "NO"

Wait, but in "abba" (length 4, palindrome, not all identical characters), valid partition exists.

In "abcba" (length 5, palindrome, not all identical characters), valid partition exists.

In "aaa" (length 3, palindrome, all identical characters), "NO"

In "aa" (length 2, palindrome, all identical characters), "NO"

In "a" (length 1, palindrome), "NO"

In "ab" (length 2, not a palindrome), "YES"

In "abc" (length 3, not a palindrome), "YES"

So, perhaps the rule is:

- If the string is not a palindrome, "YES"

- If the string is a palindrome:

- If all characters are identical, "NO"

- If not all characters are identical and length > 3, "YES"

- If length == 2 or 3 and not all characters are identical, "NO"

Wait, but in "abba" (length 4, palindrome, not all identical characters), "YES"

In "abcba" (length 5, palindrome, not all identical characters), "YES"

In "aba" (length 3, palindrome, not all identical characters), "NO"

In "ab" (length 2, not a palindrome), "YES"

In "abc" (length 3, not a palindrome), "YES"

In "aa" (length 2, palindrome, all identical characters), "NO"

In "a" (length 1, palindrome), "NO"

So, perhaps:

- If the string is not a palindrome, "YES"

- If the string is a palindrome:

- If all characters are identical, "NO"

- Else if length > 3, "YES"

- Else, "NO"

But in "aba" (length 3, palindrome, not all identical characters), "NO"

In "abba" (length 4, palindrome, not all identical characters), "YES"

In "abcba" (length 5, palindrome, not all identical characters), "YES"

So, this seems to hold.

Hence, the strategy is:

- Check if the string is a palindrome.

- If it's not a palindrome, output "YES" and partition it into the entire string.

- If it's a palindrome:

- Check if all characters are identical.

- If they are, output "NO"

- If they are not and the length > 3, output "YES" and partition it into two parts, each of length at least 2.

- Else, output "NO"

This seems efficient and should work within the time constraints.

Now, to implement this efficiently, I need to:

- Check if the string is a palindrome in O(n) time.

- Check if all characters are identical in O(n) time.

- For strings that are palindromes and have not all identical characters and length > 3, partition it into two parts, each of which is not a palindrome.

- To ensure that the parts are not palindromes, I can choose partition points such that the parts are not palindromes.

- For example, in "abba", partitioning into "ab" and "ba" works.

- In "abcba", partitioning into "abc" and "ba" works.

- I need to ensure that the parts are not palindromes.

- Since the whole string is a palindrome, and I'm partitioning it into two parts that are not palindromes, I need to choose the partition point carefully.

- Perhaps partitioning at position l, where l is from 1 to n-1, and check if neither s1 nor s2 is a palindrome.

- But to do this efficiently, I need a way to quickly determine if s1 and s2 are palindromes.

- Given that n can be up to 10^6, I need an O(1) way to check if s1 and s2 are palindromes for a given l.

- This is not straightforward, so perhaps I can find a general rule for choosing l.

- For example, in "abba", partitioning at l=2 gives s1="ab" and s2="ba", both not palindromes.

- In "abcba", partitioning at l=3 gives s1="abc" and s2="ba", both not palindromes.

- So, perhaps partitioning at l = n//2 works.

- But in "aba" (n=3), partitioning at l=2 gives s1="ab" and s2="a", where "a" is a palindrome.

- Partitioning at l=1 gives s1="a" and s2="ba", where "a" is a palindrome.

- So, in this case, no valid partition exists.

- Similarly, in "abccba" (n=6), partitioning at l=3 gives s1="abc" and s2="cba", both not palindromes.

- In "abba", l=2 gives s1="ab" and s2="ba", both not palindromes.

- In "abcba", l=3 gives s1="abc" and s2="ba", both not palindromes.

So, perhaps choosing l = n//2 works for strings where n > 3 and the string is a palindrome with not all identical characters.

Wait, in "aba" (n=3), l=2 gives s1="ab" and s2="a", where "a" is a palindrome.

So, it doesn't work.

In "abba" (n=4), l=2 gives s1="ab" and s2="ba", both not palindromes.

In "abcba" (n=5), l=3 gives s1="abc" and s2="ba", both not palindromes.

In "abccba" (n=6), l=3 gives s1="abc" and s2="cba", both not palindromes.

So, perhaps for n > 3, partitioning at l = n//2 works.

But for n = 3, it doesn't work.

So, perhaps for n > 3, I can choose l = n//2, and check if s1 and s2 are not palindromes.

If they are not, then output "YES" and the partition.

If they are, then try another l.

But I need to ensure that such an l exists.

Given the constraints, I think that for n > 3, partitioning at l = n//2 works.

For n = 2 or 3, if the string is a palindrome and not all characters are identical, it's still "NO", as seen in "aba".

Hence, the final strategy is:

- If the string is not a palindrome, output "YES" and partition it into the entire string.

- If the string is a palindrome:

- If all characters are identical, output "NO"

- Else if n > 3, output "YES" and partition it into two parts at l = n//2.

- Else, output "NO"

Now, I need to implement this efficiently.

To check if a string is a palindrome, I can compare it with its reverse in O(n) time.

To check if all characters are identical, I can check if the set of characters has only one unique character.

Given that t can be up to 10^4 and n up to 10^6 with sum of all n <= 10^6, this should be efficient enough.

I need to handle multiple test cases efficiently, so I should read all inputs first and process them one by one.

In Python, reading input efficiently is important for large inputs.

I can read all input at once using sys.stdin.read() and split it into tokens.

Then, process the tokens for each test case.

Now, let's think about edge cases.

- Single character: "a" -> "NO"

- Two identical characters: "aa" -> "NO"

- Two different characters: "ab" -> "YES", partition into "ab"

- Three identical characters: "aaa" -> "NO"

- Three different characters: "abc" -> "YES", partition into "abc"

- Palindromic strings with length > 3 and not all identical characters: "abba" -> "YES", partition into "ab" and "ba"

- Non-palindromic strings: "sinktheyacht" -> "