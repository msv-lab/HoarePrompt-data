Alright, I have this problem to solve. Let's see what it's asking for. So, Mocha has an array of positive integers, and she can perform this specific operation on it: split the array into a prefix and a suffix, and swap them. She can do this operation any number of times, including zero, and the goal is to check if the array can become sorted in non-decreasing order after these operations.

First, I need to understand what exactly the operation is. The operation is to split the array into two parts: a prefix and a suffix, and then swap them. For example, if the array is [3,1,4,1,5], she can choose x=[3,1] and y=[4,1,5], and swap them to get [4,1,5,3,1]. Another example is choosing x=[3,1,4,1,5] and y=[] , which results in the same array since swapping doesn't change anything.

So, the key here is that the split must satisfy a = x + y, meaning that x and y are contiguous parts of the array, and then swapping them gives y + x.

The task is to determine whether, after performing this operation some number of times, the array can be sorted in non-decreasing order.

Looking at the constraints, n can be from 2 to 50, and t can be up to 1000. So, efficiency is somewhat important, but since n is small, even O(n^2) solutions should be acceptable.

Let me look at the example provided:

Test case 1:

n = 6

a = [1,1,4,5,1,4]

Output: No

Test case 2:

n = 5

a = [7,9,2,2,3]

Operations:

- Split x=[7], y=[9,2,2,3] → swap to get [9,2,2,3,7]

- Split x=[9], y=[2,2,3,7] → swap to get [2,2,3,7,9]

Which is sorted in non-decreasing order.

Test case 3:

n = 3

a = [1,2,3]

Already sorted, so "YES"

From this, I can see that sometimes multiple operations are needed to sort the array.

Now, I need to find a general way to determine if it's possible to sort the array with such operations.

First thought: since each operation is a swap of prefix and suffix, and can be performed multiple times, maybe there's a way to model this as rotations or some kind of circular shift.

But it's not exactly a rotation because in a rotation, elements are shifted circularly, whereas here, we're swapping prefix and suffix.

Wait, in the operation, splitting into x and y and swapping them is equivalent to reversing the order of the two parts.

So, it's like reversing a partition of the array into two contiguous parts.

I need to see if, by doing this operation multiple times, I can sort the array.

Let me think about what sequences of operations can achieve.

Suppose I have array a = [a1, a2, ..., an]

An operation consists of choosing an index k (0 ≤ k ≤ n), splitting into x = [a1, a2, ..., ak] and y = [ak+1, ..., an], and swapping them to get y + x.

So, the new array becomes [ak+1, ..., an, a1, a2, ..., ak]

So, it's like rotating the array by -k positions.

Wait, but rotation is different because in rotation, elements are shifted in a circular manner, whereas here, it's just swapping the two parts.

But in terms of the positions, it's similar to reversing the order of the two parts.

Wait, no. Swapping prefix and suffix doesn't reverse the order of elements, just their positions.

Wait, let's take an example:

a = [1,2,3,4,5]

Choose k=2, x=[1,2], y=[3,4,5], swap to get [3,4,5,1,2]

Choose k=1, x=[3], y=[4,5,1,2], swap to get [4,5,1,2,3]

Choose k=3, x=[4,5,1], y=[2,3], swap to get [2,3,4,5,1]

And so on.

I need to see if, by performing such operations, I can sort the array.

An important observation is that each operation is reversible. If I swap x and y to get y+x, I can perform the same operation again to get back to x+y.

Wait, in the first operation, if I have a = x + y, and I swap to get y + x, then if I perform the operation again with the same k, I get x + y back.

So, each operation is its own inverse.

Moreover, the set of arrays reachable from a by performing these operations forms a group under composition.

But perhaps that's too abstract for now.

Another way to think about it is to consider all possible arrays that can be obtained by performing these operations.

Given that n is small (up to 50), but t is up to 1000, I need an efficient way to check for each test case if it's possible to sort the array.

But n is up to 50, which is manageable.

Wait, but performing operations multiple times could lead to a large number of possible arrays, but perhaps there's a smarter way.

Let me consider that each operation corresponds to a rotation of the array by a certain amount.

Wait, but it's not exactly a rotation.

Wait, in the example given:

a = [7,9,2,2,3]

First operation: split x=[7], y=[9,2,2,3], swap to get [9,2,2,3,7]

Second operation: split x=[9], y=[2,2,3,7], swap to get [2,2,3,7,9]

Which is sorted.

So, in two operations, it's sorted.

I need to find a sequence of such operations that can sort the array.

Alternatively, perhaps there's a way to check directly if it's possible without simulating all possible operations.

Let me think differently.

Suppose I have the array a, and I want to sort it in non-decreasing order.

I can think of the sorted array as the target, and see if I can reach it from a by performing these operations.

But performing these operations can be seen as rearranging the elements in a certain way.

Wait, perhaps I can model this as permutations.

Each operation corresponds to a specific permutation of the array.

But with n up to 50, considering all possible permutations is not feasible.

I need a better approach.

Let me consider the effect of performing multiple operations.

Suppose I perform operation with k1, then with k2, and so on.

Each operation is swapping the prefix of length k with the suffix.

But maybe there's a pattern or a mathematical property that can help determine if sorting is possible.

Wait, perhaps the array can be sorted if and only if it consists of a suffix sorted in non-decreasing order and a prefix that is also sorted in non-decreasing order, and the last element of the suffix is less than or equal to the first element of the prefix.

Wait, that might not be precise.

Let me look at the first test case:

n=6, a=[1,1,4,5,1,4]

Output: No

Is there a way to perform operations to sort this?

Let's try:

Original: [1,1,4,5,1,4]

Possible operations:

- Split at k=1: x=[1], y=[1,4,5,1,4] → swap to [1,4,5,1,4,1]

- Split at k=2: x=[1,1], y=[4,5,1,4] → swap to [4,5,1,4,1,1]

- Split at k=3: x=[1,1,4], y=[5,1,4] → swap to [5,1,4,1,1,4]

- Split at k=4: x=[1,1,4,5], y=[1,4] → swap to [1,4,1,1,4,5]

- Split at k=5: x=[1,1,4,5,1], y=[4] → swap to [4,1,1,4,5,1]

None of these look sorted.

Is there a sequence of operations that can sort it?

Let's try with the second test case:

n=5, a=[7,9,2,2,3]

First operation: split at k=1, x=[7], y=[9,2,2,3], swap to [9,2,2,3,7]

Second operation: split at k=1, x=[9], y=[2,2,3,7], swap to [2,2,3,7,9]

Which is sorted.

So, in two operations, it's sorted.

Is there a general way to check this?

Let me consider that after some operations, the array becomes sorted.

Each operation is a specific kind of permutation.

Maybe I can think in terms of rotations.

In standard rotation, you shift elements circularly.

But here, it's swapping prefix and suffix.

Is there a connection?

Wait, in standard rotation by k positions to the left, it's like taking x=[a1,a2,...,ak] and y=[ak+1,...,an], then setting a:= y + x.

But in this problem, it's swapping prefix and suffix, which is similar.

Wait, actually, in rotation, you take x and y and set a:= y + x, which is the same as swapping prefix and suffix.

So, in a way, this operation is equivalent to rotating the array to the left by k positions, where k is the length of the prefix.

So, performing this operation is equivalent to rotating the array to the left by k positions.

Then, performing this operation multiple times allows us to perform any number of left rotations by various amounts.

But, in the example, they performed two operations:

First: rotate left by 1 → [9,2,2,3,7]

Second: rotate left by 1 → [2,2,3,7,9]

So, effectively, two left rotations by 1 position each.

But, in general, k can be any from 0 to n.

Wait, but rotation by k positions is equivalent to rotating left by k positions.

But in this problem, k can be from 0 to n.

Wait, but in the operation, k can be from 0 to n, where k is the length of the prefix.

So, swapping prefix of length k and suffix of length n-k is equivalent to rotating the array to the left by k positions.

Wait, let's see:

Original: [a1,a2,...,ak,ak+1,...,an]

After swapping: [ak+1,ak+2,...,an,a1,a2,...,ak]

Which is the same as rotating left by k positions.

Yes, that's correct.

So, this operation is equivalent to rotating the array to the left by k positions.

Then, performing this operation multiple times allows us to perform any rotation that is a multiple of the greatest common divisor (gcd) of the rotation amounts used.

But in this problem, since k can be any value from 0 to n, we can perform rotations by any k positions.

Wait, but k can be any value from 0 to n, so we can rotate left by any k positions in a single operation.

Therefore, we can reach any array that is a rotation of the original array.

Wait, but in the example, they performed two rotations: first by k=1, then again by k=1, resulting in a rotation by 2 positions.

But since each operation allows rotating by any k, including different k for each operation, does that mean we can reach any permutation of the array?

Wait, no. Because rotation by k positions multiple times can be equivalent to rotation by k modulo n positions.

But actually, with the ability to rotate by any k, we can generate any cyclic shift of the array.

But is that enough to sort the array?

Wait, in the second test case, they performed two rotations by k=1 to sort the array.

But in the first test case, it's not possible to sort it by any sequence of rotations.

So, perhaps the problem reduces to checking if the array is a rotation of a sorted array.

Wait, but in the second test case, [7,9,2,2,3] is not a rotation of a sorted array, but by performing rotations, we can sort it.

Wait, let's think differently.

If we can perform rotations by any k, then we can generate any cyclic shift of the array.

But sorting requires arranging the elements in non-decreasing order.

So, perhaps the array can be sorted if and only if it's already sorted or it's a rotation of a sorted array.

But in the second test case, [7,9,2,2,3] is not a rotation of a sorted array, because no matter how you rotate it, you can't get a sorted array.

Wait, let's check:

Original: [7,9,2,2,3]

Possible rotations:

k=0: [7,9,2,2,3]

k=1: [9,2,2,3,7]

k=2: [2,2,3,7,9]

k=3: [2,3,7,9,2]

k=4: [3,7,9,2,2]

None of these are sorted in non-decreasing order except for k=2: [2,2,3,7,9]

But in the example, they performed two rotations by k=1 to reach [2,2,3,7,9]

So, even though it's not directly a rotation of the sorted array, by performing multiple rotations, they reached the sorted array.

So, perhaps the array can be sorted if and only if it's possible to reach a sorted array through a sequence of rotations.

But in this case, it seems that by performing rotations, we can rearrange the array in a way that allows sorting.

Wait, but rotations don't allow us to change the relative order of elements beyond cyclic shifts.

But in this case, multiple rotations can achieve more permutations.

Wait, but actually, rotations generate the cyclic group of rotations, which means that we can only reach permutations that are cyclic shifts of the original array.

But in the second test case, [2,2,3,7,9] is a rotation of the original array [7,9,2,2,3], specifically rotating left by 2 positions.

So, perhaps I was mistaken earlier.

Wait, but in the example, they performed two rotations by k=1 to achieve the same effect as rotating left by 2 positions.

So, in essence, multiple rotations can achieve larger rotation amounts.

Therefore, as long as the sorted array is a rotation of the original array, the answer is "Yes".

But in the first test case, [1,1,4,5,1,4], the sorted array is [1,1,1,4,4,5], which is not a rotation of the original array.

Hence, "No".

In the second test case, [2,2,3,7,9] is a rotation of the original array [7,9,2,2,3], so "Yes".

In the third test case, [1,2,3] is already sorted, so "Yes".

Therefore, the general solution seems to be: check if the sorted array is a rotation of the original array.

If yes, then "Yes", else "No".

Wait, but in the second test case, [2,2,3,7,9] is the sorted version of a rotation of the original array, but is it a rotation of the sorted original array?

Wait, no.

Wait, perhaps I need to think differently.

Let me consider that for the array to be sortable via these operations, the sorted array must be a rotation of a permutation of the original array where the elements are in non-decreasing order.

But that seems convoluted.

Wait, perhaps a better way is to check if the sorted array is a subarray when the original array is concatenated twice.

Wait, that's a standard way to check if one array is a rotation of another.

Given two arrays, to check if one is a rotation of the other, you can check if one array is a subarray of the other array concatenated with itself.

So, in this problem, for each test case, I can sort the array and check if it's a subarray of the original array concatenated with itself.

If yes, then "Yes", else "No".

Wait, but in the first test case, sorted array is [1,1,1,4,4,5], and original array is [1,1,4,5,1,4].

Concatenated original: [1,1,4,5,1,4,1,1,4,5,1,4]

Is [1,1,1,4,4,5] a subarray of this? Let's see:

Looking for [1,1,1,4,4,5] in [1,1,4,5,1,4,1,1,4,5,1,4]

No matches.

In the second test case, sorted array is [2,2,3,7,9], original is [7,9,2,2,3], concatenated: [7,9,2,2,3,7,9,2,2,3]

Looking for [2,2,3,7,9] in this: yes, it's a subarray starting from the third element.

In the third test case, sorted array is [1,2,3], original is [1,2,3], concatenated: [1,2,3,1,2,3]

Looking for [1,2,3] in this: yes, it's a subarray starting from the first element.

So, this seems to work.

Therefore, the approach is:

- For each test case, sort the array to get the target sorted array.

- Concatenate the original array with itself.

- Check if the sorted array is a subarray of this concatenated array.

- If yes, print "Yes", else "No".

This should be efficient enough since n is up to 50.

Now, let's look at the provided program and see if it implements this correctly.

The program is:

def func():

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().split()))

check_all = all([a[i - 1] <= a[i] for i in range(1, n)])

if check_all:

print('YES')

else:

for i in range(1, n):

if a[i - 1] > a[i]:

new = a[i:]

check_all_new = all([a[0] >= new[i] for i in range(len(new))])

new_all = all([new[i - 1] <= new[i] for i in range(1, len(new))])

if check_all_new and new_all:

print('YES')

break

else:

print('NO')

break

So, it first checks if the array is already sorted. If yes, prints "YES".

If not, it looks for the first position where a[i-1] > a[i], then takes the suffix starting from a[i], and checks two conditions:

1. All elements in this suffix are in non-decreasing order.

2. The first element of the array is greater than or equal to all elements in this suffix.

If both conditions are satisfied, it prints "YES", else "NO".

Wait, this seems different from the approach I thought of.

Is this equivalent to checking if the sorted array is a rotation of the original array?

Let me check with the second test case:

a = [7,9,2,2,3]

First, check if it's already sorted: 7 <= 9, 9 > 2 → not sorted.

Then, look for the first position where a[i-1] > a[i]: i=2, a[1]=9 > a[2]=2.

Then, take the suffix new = a[2:] = [2,2,3]

Check:

- check_all_new: a[0] >= all in new: 7 >= 2, 7 >= 2, 7 >= 3 → true

- new_all: [2,2,3] is sorted in non-decreasing order → true

So, it prints "YES".

Which matches the expected output.

Now, let's check the first test case:

a = [1,1,4,5,1,4]

Check if sorted: 1 <=1 <=4 <=5 >=1 >=4 → not sorted.

Find first i where a[i-1] > a[i]: i=4, a[3]=5 > a[4]=1.

Then, new = a[4:] = [1,4]

Check:

- check_all_new: a[0] >= all in new: 1 >=1, 1>=4 → false (since 1 < 4)

- new_all: [1,4] is sorted → true

Since check_all_new is false, it prints "NO".

Which matches the expected output.

Third test case:

a = [1,2,3]

Already sorted → "YES".

Seems correct.

But is this logic equivalent to checking if the sorted array is a rotation of the original array?

In the program, for each test case, it checks if the array is already sorted. If not, it looks for the first descent, takes the suffix starting from there, and checks two conditions:

1. This suffix is sorted in non-decreasing order.

2. The first element of the array is greater than or equal to all elements in this suffix.

If both are true, it concludes that the array can be sorted via the operations.

I need to see if this is a correct way to determine if the sorted array is a rotation of the original array.

Let me consider another example:

Suppose a = [3,4,5,1,2]

Sorted array: [1,2,3,4,5]

Is [1,2,3,4,5] a rotation of [3,4,5,1,2]? Yes, rotate left by 3 positions.

Now, applying the program's logic:

Check if sorted: 3 <=4 <=5 >=1 >=2 → not sorted.

Find first i where a[i-1] > a[i]: i=3, a[2]=5 > a[3]=1.

Then, new = a[3:] = [1,2]

Check:

- check_all_new: a[0] >= all in new: 3 >=1, 3>=2 → true

- new_all: [1,2] is sorted → true

So, it would print "YES", which is correct.

Another test case:

a = [2,1]

Sorted: [1,2]

Is [1,2] a rotation of [2,1]? Rotations of [2,1] are [2,1] and [1,2].

Yes, [1,2] is a rotation.

Applying the program's logic:

Check if sorted: 2 >=1 → not sorted.

Find first i where a[i-1] > a[i]: i=1,