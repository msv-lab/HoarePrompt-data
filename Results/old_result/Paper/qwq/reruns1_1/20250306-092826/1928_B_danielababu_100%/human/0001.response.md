Alright, I have this problem to solve. Let's see what it's asking for. So, Vasya has an array A and he wants to add a permutation P of length N to it. The goal is to maximize the number of elements in the array that become equal after this addition.

First, I need to understand what a permutation is. A permutation of length N is just a rearrangement of the numbers from 1 to N. So, for example, if N is 3, possible permutations are [1,2,3], [1,3,2], [2,1,3], etc.

The operation is to add the permutation P to the array A element-wise, meaning A_i becomes A_i + P_i for each i from 1 to N.

After this addition, I need to find out the maximum number of elements in the new array that are equal to the same number.

My task is to determine, for each test case, what the maximum possible frequency of any number in the modified array can be.

Looking at the constraints, T can be up to 2*10^4, and N can be up to 2*10^5, with the sum of N over all test cases not exceeding 2*10^5. So, I need an efficient solution, probably O(N log N) per test case.

Let me think about how to approach this.

If I add a permutation P to A, I'm essentially adding each P_i to A_i. Since P is a permutation from 1 to N, P_i can be any integer from 1 to N, each exactly once.

I need to choose P such that as many A_i + P_i as possible become equal.

Let me consider that for two elements A_i and A_j, I want A_i + P_i = A_j + P_j. That implies P_j - P_i = A_i - A_j.

So, for two elements, the difference in their permutation values should be equal to the negative difference in their original values.

This seems a bit tricky. Maybe there's another way to look at it.

Another approach: since P is a permutation from 1 to N, the values P_i are distinct and cover all integers from 1 to N.

So, for each A_i, I'm adding a unique value from 1 to N to it, but each value is used only once.

I need to maximize the number of A_i + P_i that are equal.

Wait a minute, if I fix a target value T, and try to see how many A_i + P_i can be equal to T, that would mean P_i = T - A_i.

But P_i has to be a permutation from 1 to N, so T - A_i must be unique and within 1 to N.

So, for a fixed T, the number of A_i such that T - A_i is between 1 and N, and all T - A_i are distinct, is the maximum number of elements that can be made equal to T.

To maximize the frequency, I need to choose T such that as many A_i as possible have T - A_i in 1 to N, and these T - A_i are all distinct.

But iterating over all possible T seems inefficient, since T can be as large as 10^9 + N.

Is there a smarter way to choose T?

Let me think differently. Since P is a permutation from 1 to N, the smallest possible P_i is 1 and the largest is N.

So, for each A_i, A_i + P_i can range from A_i + 1 to A_i + N.

Different A_i's have different ranges for A_i + P_i.

I need to find overlapping points in these ranges where multiple A_i + P_i can be equal.

To maximize the number of overlapping points, I need to find a value that can be achieved by as many A_i + P_i as possible, given that P_i are distinct.

This seems similar to finding the maximum number of lines that overlap at a single point, but in this case, the lines are the ranges A_i + 1 to A_i + N.

Wait, maybe I can think in terms of frequency counts.

Suppose I sort the A_i's. Then, I can try to assign P_i's in a way that maximizes the frequency of a particular sum.

But I need to ensure that P_i's are distinct and form a permutation.

Let me consider sorting A in ascending order.

Let's sort A: A[1] <= A[2] <= ... <= A[N].

Now, I need to assign P_i's from 1 to N to A_i's such that A_i + P_i are maximally equal.

To maximize the number of equal sums, I should try to make as many A_i + P_i as possible equal to some target T.

Given that P_i's are distinct and range from 1 to N, I need to choose P_i's such that T - A_i are distinct and within 1 to N.

So, for each A_i, T - A_i should be unique and in 1 to N.

This means that for a fixed T, the number of A_i such that T - A_i is in 1 to N, and all T - A_i are distinct, is the maximum number of A_i's that can be made equal to T.

To maximize this over all possible T, I need to find the T that allows the maximum such A_i's.

But iterating over all possible T is not feasible due to the large range.

Is there a better way?

Let me consider the differences between A_i's.

Suppose I fix A_i and think about possible P_i's.

But that seems too vague.

Wait, perhaps I can look at the differences A_i - P_i.

Wait, no, because we have A_i + P_i.

Let me consider sorting A.

Suppose I sort A in ascending order.

Let's say A[1] <= A[2] <= ... <= A[N].

Now, if I assign P_i's in some order, I need to maximize the number of times A_i + P_i equals some T.

Suppose I try to make A_i + P_i equal to T for as many i as possible.

Then, for each i, P_i = T - A_i.

But P_i must be a permutation of 1 to N, so T - A_i must be unique and in 1 to N.

So, for a fixed T, the number of valid i's is the number of unique T - A_i that are in 1 to N.

I need to choose T such that as many T - A_i as possible are distinct and in 1 to N.

Alternatively, for each A_i, T - A_i must be in 1 to N, and all T - A_i must be distinct.

So, for a fixed T, the number of valid i's is the number of unique T - A_i that are within 1 to N.

To maximize this, I need to choose T such that as many T - A_i as possible are distinct and within 1 to N.

This sounds like choosing T such that A_i + P_i = T, with P_i being distinct and from 1 to N.

Wait, maybe I can look at it differently.

Let me consider that P is a permutation of 1 to N.

So, P is some ordering of 1 to N.

I need to assign P_i to A_i such that A_i + P_i are as equal as possible.

This is equivalent to minimizing the variance of A_i + P_i, but specifically maximizing the frequency of the most frequent sum.

I need to maximize the frequency of the most common sum after adding P to A.

Another way to think about it is to maximize the size of the largest multiset intersection of A + P.

But that seems too abstract.

Let me try to think about it in terms of frequency counts.

Suppose I fix T and try to see how many A_i can have P_i such that A_i + P_i = T.

P_i must be T - A_i, and T - A_i must be unique and in 1 to N.

So, for each T, the number of valid A_i's is the number of unique T - A_i that are in 1 to N.

I need to maximize this over all T.

But iterating over all possible T is not efficient.

Is there a smarter way?

Let me consider the sorted A.

Suppose I sort A in ascending order.

A[1] <= A[2] <= ... <= A[N].

Now, P is a permutation of 1 to N, so P[i] are distinct and cover 1 to N.

I need to assign P[i] to A[i] such that as many A[i] + P[i] as possible are equal.

Suppose I try to make A[i] + P[i] = T for as many i as possible.

Then, P[i] = T - A[i].

For P[i] to be a permutation of 1 to N, T - A[i] must be distinct and in 1 to N.

So, for a fixed T, the number of valid i's is the number of unique T - A[i] that are in 1 to N.

To maximize this, I need to choose T such that as many T - A[i] as possible are distinct and within 1 to N.

But this still seems inefficient to compute directly.

Is there a better approach?

Let me consider the minimal and maximal possible T.

The minimal possible T is A[1] + 1.

The maximal possible T is A[N] + N.

So, T can range from A[1] + 1 to A[N] + N.

Within this range, I need to find the T that allows the maximum number of valid i's.

But even iterating over this range might be too slow if A[N] + N is large.

Wait, but since N can be up to 2*10^5 and A_i up to 10^9, iterating over the range A[1]+1 to A[N]+N is not feasible.

I need a smarter way.

Let me think about the differences.

Suppose I sort A.

Let me sort A in ascending order.

Now, I need to assign P_i's to A_i's such that A_i + P_i are as equal as possible.

Suppose I assign the smallest P_i to the largest A_i, i.e., P[1] = 1 with A[N], P[2] = 2 with A[N-1], and so on.

Wait, but P is a permutation of 1 to N, so P_i's are distinct.

Wait, perhaps I can sort A and assign P_i's in a way that minimizes the variation in A_i + P_i.

But I'm not sure.

Let me consider the following approach.

Sort A in ascending order.

Now, assign P_i's such that A_i + P_i are as close as possible.

Perhaps assign the smallest P_i to the largest A_i, so that A[N] + 1, A[N-1] + 2, etc., are as close as possible.

Wait, but P_i's must be a permutation of 1 to N.

Alternatively, maybe assign P_i's in a way that A_i + P_i is as equal as possible.

But I need a concrete plan.

Let me consider the difference between A_i + P_i and A_j + P_j for i != j.

I want as many A_i + P_i equal as possible.

So, I need to maximize the frequency of the most frequent sum.

This seems tricky.

Wait, perhaps I can look at it from the perspective of frequency counts.

Suppose I fix T and compute how many A_i's satisfy T - A_i is in 1 to N, and all T - A_i are distinct.

To maximize this, I need to choose T such that as many T - A_i as possible are distinct and within 1 to N.

But again, iterating over all T is not efficient.

Is there a way to find the T that maximizes this count efficiently?

Let me consider the frequency of T - A_i.

Wait, perhaps I can sort the A_i's and see the possible overlaps.

Wait, maybe I can sort the A_i's and see the differences between A_i and A_j.

But I'm getting stuck.

Let me look at the sample input and output to get some intuition.

Sample Input:

7

2

1 2

4

7 1 4 1

3

103 102 104

5

1 101 1 100 1

5

1 10 100 1000 1

2

3 1

3

1000000000 999999997 999999999

Sample Output:

2

2

3

2

1

1

2

Looking at the first test case:

N=2

A=[1,2]

One possible permutation P=[2,1]

Then A becomes [3,3], so both elements are 3.

Hence, the output is 2.

In the second test case:

N=4

A=[7,1,4,1]

One possible P=[2,3,1,4]

Then A becomes [9,4,5,5], so two 5's.

Output is 2.

In the third test case:

N=3

A=[103,102,104]

One possible P=[2,3,1]

A becomes [105,105,105], so three 105's.

Output is 3.

Wait, that's interesting.

In this case, all three elements can be made equal.

But in other cases, only two or one.

Wait, but according to the problem, it's possible to make all elements equal sometimes.

But in the explanation, for N=2, A=[1,2], P=[2,1] makes both elements 3.

Similarly, for N=3, A=[103,102,104], P=[2,3,1] makes all elements 105.

So, in some cases, it's possible to make all elements equal.

But in other cases, only a subset can be made equal.

I need to find, for each test case, the maximum number of elements that can be made equal after adding a permutation P.

How can I do that efficiently?

Let me think about the condition for multiple A_i + P_i to be equal.

Suppose I have A_i + P_i = A_j + P_j = T for some T.

Then, P_j - P_i = A_i - A_j.

Since P_i and P_j are distinct integers between 1 and N, P_j - P_i is a non-zero integer between -N+1 and N-1.

So, for A_i + P_i to equal A_j + P_j, the difference P_j - P_i must equal A_i - A_j.

Given that P_j - P_i is unique for each pair (i,j), I need to find how many A_i's can have unique differences to satisfy A_i + P_i = T.

This seems complicated.

Is there a better way?

Let me consider that P is a permutation of 1 to N.

So, P is some ordering of 1 to N.

I need to assign P_i's to A_i's such that A_i + P_i are as equal as possible.

Wait, perhaps I can sort A and assign P_i's in a way that minimizes the variation in A_i + P_i.

For example, assign the smallest P_i to the largest A_i, so that their sums are more likely to be equal.

Wait, in the third test case, N=3, A=[103,102,104], P=[2,3,1], which seems like assigning P_i's in a specific order to make all sums equal to 105.

Similarly, in the first test case, N=2, A=[1,2], P=[2,1], making both sums equal to 3.

So, perhaps sorting A and assigning P_i's in a specific order can help.

Let me try to sort A in ascending order and assign P_i's in descending order.

For N=3, A=[102,103,104], P=[3,2,1], which would make sums [105,105,105].

Similarly, for N=2, A=[1,2], P=[2,1], sums [3,3].

So, in both cases, sorting A in ascending order and assigning P in descending order achieves the goal.

Is this always the case?

Let me try another example.

Suppose N=3, A=[1,1,1].

If I sort A as [1,1,1] and assign P=[3,2,1], sums become [4,3,2].

All sums are different.

But according to the problem, I should be able to make at least two elements equal.

Wait, maybe this approach doesn't always work.

Wait, in this case, it's impossible to make more than one element equal because all A_i are the same, and P_i are distinct.

Wait, no, actually, if A_i are all the same, then A_i + P_i will be distinct because P_i are distinct.

So, in this case, the maximum frequency is 1.

Looking back at the sample input, in some cases, all elements can be made equal, in others, only some subset.

I need a general approach.

Let me think about the difference between the maximum and minimum possible sums.

For each A_i, the smallest possible A_i + P_i is A_i + 1, and the largest is A_i + N.

So, the range for each A_i is [A_i + 1, A_i + N].

The overall range of possible sums is from min(A) + 1 to max(A) + N.

I need to find a value T in this range that can be achieved by as many A_i + P_i as possible, with P_i being distinct and from 1 to N.

This sounds like finding the maximum number of non-overlapping intervals that contain a particular T.

Wait, but P_i's are distinct, so T - A_i must be distinct and in 1 to N.

So, for each A_i, T - A_i must be unique and in 1 to N.

This is equivalent to choosing T such that as many T - A_i as possible are distinct and within 1 to N.

To maximize this, I need to choose T where the number of A_i's such that T - A_i is in 1 to N, and all T - A_i are distinct.

This seems similar to finding how many A_i's can have unique T - A_i within 1 to N.

But iterating over all possible T is not efficient.

Is there a better way?

Let me consider that T - A_i must be in 1 to N, and all T - A_i must be distinct.

So, for a fixed T, the number of valid A_i's is the number of unique T - A_i that are in 1 to N.

I need to maximize this over T.

This sounds like finding T such that as many T - A_i as possible are distinct and within 1 to N.

Wait, perhaps I can sort A and then find the maximum number of A_i's that can have unique T - A_i within 1 to N.

But I still don't see a direct way to compute this efficiently.

Let me try to think differently.

Suppose I sort A in ascending order.

A[1] <= A[2] <= ... <= A[N].

Now, I need to choose P_i's from 1 to N such that A_i + P_i are as equal as possible.

Let me try to assign P_i's in a way that minimizes the variation in A_i + P_i.

One way to do this is to assign the smallest P_i to the largest A_i, the second smallest P_i to the second largest A_i, and so on.

This is similar to assigning P_i = N - i + 1 to A_i sorted in descending order.

Wait, in the third test case, N=3, A=[103,102,104], sorted as [102,103,104], P=[3,2,1], sums [105,105,105].

This works.

In the first test case, N=2, A=[1,2], sorted as [1,2], P=[2,1], sums [3,3].

This also works.

So, in general, sorting A in ascending order and assigning P_i = N - i + 1 seems to maximize the number of equal sums.

Is this always the case?

Let me try another example.

Suppose N=3, A=[1,2,3].

Sort A as [1,2,3], assign P=[3,2,1], sums [4,4,4].

All sums are equal.

Another example: N=4, A=[1,2,3,4], P=[4,3,2,1], sums [5,5,5,5].

Again, all sums are equal.

Seems promising.

But what if A has duplicates?

Suppose N=3, A=[1,1,2].

Sort A as [1,1,2], assign P=[3,2,1], sums [4,3,3].

Here, two sums are 3 and one is 4.

So, maximum frequency is 2.

Is this the maximum possible?

Alternatively, assign P=[2,3,1], sums [3,4,3].

Again, two sums are 3.

So, maximum frequency is 2.

Is there a way to make all three sums equal?

Suppose I try P=[1,2,3], sums [2,3,5].

Only one sum is equal.

So, P=[2,3,1] and P=[3,2,1] both give two sums equal, which seems to be the maximum.

So, in this case, the answer is 2.

Another example: N=4, A=[1,1,1,1], assign P=[4,3,2,1], sums [5,4,3,2].

All sums are unique, so maximum frequency is 1.

Which makes sense.

So, in general, sorting A in ascending order and assigning P in descending order seems to maximize the number of equal sums.

Is this always the case?

Let me try another example.

N=5, A=[1,2,2,3,3].

Sort A as [1,2,2,3,3], assign P=[5,4,3,2,1], sums [6,6,5,5,4].

Here, two sums are 6, two are 5, and one is 4.

So, maximum frequency is 2.

Is there a way to get a higher frequency?

Try P=[4,5,3,2,1], sums [5,7,5,5,2].

Here, three sums are 5.

Is this better?

Yes, maximum frequency is 3.

So, in this case, assigning P differently gives a higher frequency.

So, my initial approach of assigning P in descending order doesn't always give the maximum frequency.

Hmm.

So, perhaps sorting A and assigning P in a different way could give a better result.

In this case, sorting A as [1,2,2,3,3], assigning P=[4,5,3,2,1], gives sums [5,7,5,5,2], with three 5's.

Alternatively, assigning P=[5,3,4,2,1], sums [6,5,6,5,2], which also has two 5's and two 6's.

So, maximum frequency is still 3.

Is there a way to get four equal sums?

Let's see.

If I assign P=[3,4,5,2,1], sums [4,6,7,5,2].

No equal sums.

So, seems like 3 is the maximum.

So, in this case, assigning P in a specific order can give a higher frequency than just assigning P in descending order.

So, my initial approach might not always give the correct answer.

I need a better way.

Let me think about it differently.

Suppose I sort A in ascending order.

Now, I need to assign P_i's from 1 to N to A_i's such that A_i + P_i are as equal as possible.

Let me consider that I want to make as many A_i + P_i equal to some T.

For each A_i, P_i = T - A_i.

But P_i must be unique and in 1 to N.

So, for a fixed T, the number of valid A_i's is the number of unique T - A_i that are in 1 to N.

I need to choose T to maximize this number.

To find the best T, I need to find T such that T - A_i is unique