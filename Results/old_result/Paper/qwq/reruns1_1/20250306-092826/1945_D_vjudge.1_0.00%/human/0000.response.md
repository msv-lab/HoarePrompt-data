Alright, I've got this problem to solve. Let's see what it's asking for. So, there's this queue of n people, and Kirill comes in and stands at the end, making it n+1 people in line. But Kirill doesn't want to wait too long, so he wants to be among the first m people in the queue after some operations.

He can perform operations where he pays some people to swap places with him. Specifically, if he's at position i, he can choose any position j where j < i, pay a_j to the person at position j, and also pay b_k to everyone between j and i (excluding j).

He can do this any number of times, and he wants to spend as little as possible to ensure he's within the first m positions.

First, I need to understand the operations clearly. So, Kirill starts at position n+1. He can choose any position j < n+1 and swap with j, paying a_j to that person and b_k to everyone between j and n+1.

Wait, but in the problem statement, it says he's at position i and chooses j < i, then pays a_j to the person at position j, and for each k where j < k < i, pays b_k to the person at position k.

So, in terms of indices, if we consider the queue starting from position 1 to n+1, with n+1 being Kirill's position.

But maybe it's easier to reverse the queue, so that Kirill starts at position 0, and positions decrease as we move forward.

Wait, in the code provided, the lists a and b are reversed. So, lista_A and lista_B are reversed, meaning that the first element in the reversed list corresponds to the last person in the queue, which is Kirill.

Hmm, I need to make sure I understand the indexing.

Let me try to rephrase the problem.

We have n people in the queue, positions 1 to n, with person 1 at the front.

Kirill arrives and stands at position n+1.

He wants to be within the first m positions, i.e., positions 1 to m.

He can perform operations where he chooses some j < i, swaps with j, and pays a_j plus b_k for each k between j and i.

He can do this any number of times, and we need to find the minimum cost to achieve his goal.

I need to find the minimum cost for Kirill to reach a position between 1 and m.

Let me think about how to model this.

One way to think about this is that Kirill is moving forward in the queue by swapping with people ahead of him (who are actually behind him in the queue).

But wait, in the operation, he chooses j < i, meaning he's swapping with someone who is ahead of him in the queue.

So, effectively, he's moving forward in the queue by swapping with people ahead of him, but paying a_j to the person he's swapping with and b_k to everyone between them.

I need to find the minimal cost to move from position n+1 to some position between 1 and m.

This sounds like a path-finding problem, where each position is a node, and there are edges from position i to j < i with cost a_j plus sum of b_k from k = j+1 to i-1.

I need to find the minimal cost path from n+1 to any of the positions from 1 to m.

But with n up to 2e5, I need an efficient way to compute this.

Let me see what the provided code is doing.

It defines func_1 to handle one test case.

It reads n and m, then list a and list b, reverses them.

Then it initializes soma_b to 0 and pref to 0.

Then it loops from 0 to n - k - 1 (since lists are reversed, indices are from 0 to n-1).

In this loop, it checks if lista_A[i] < lista_B[i].

If so, it adds soma_b to pref and adds lista_A[i], and sets soma_b to 0.

Else, it adds lista_B[i] to soma_b.

Then, it sets resultado to infinity.

Then, loops from n - k to n, and for each i, computes pref + soma_b + lista_A[i], takes the minimum, and adds lista_B[i] to soma_b.

Finally, prints the resultado.

Wait, I need to understand what this code is doing.

First, it reverses lista_A and lista_B, so now position 0 corresponds to the original position n+1 (Kirill's position).

Then, it has a loop from 0 to n - k - 1, which corresponds to positions from n+1 down to k+2, assuming k = m-1.

Wait, k is input as m, but in code, it's n - k, so perhaps k is m.

Wait, in the code, it's n - k, so maybe k = n - m or something.

I need to clarify the variables.

In the code, it reads n and m, then lista_A and lista_B are reversed.

So, position 0 in reversed lista_A is original position n+1 (Kirill).

Position 1 is original position n, and so on.

He wants to reach position m or better, which is positions 1 to m.

So, in the reversed list, positions n - m to n correspond to positions 1 to m in the original queue.

Wait, position 1 in original is position n in reversed list.

Position m in original is position n - m + 1 in reversed list.

Wait, maybe I need to think differently.

Let me try to think of the queue in the original order.

Positions 1 to n are the queue, with 1 being the front.

Kirill is at position n+1.

He wants to be in positions 1 to m.

So, in terms of the reversed list, position 0 is n+1, position 1 is n, ..., position n is 1.

He wants to move from position 0 to positions n - m to n.

So, in the reversed list, he wants to reach positions n - m to n.

Wait, maybe it's better to think in terms of the original positions.

Let me try to model the problem without reversing the lists.

Let's consider the queue in original order: positions 1 (front) to n (back), with Kirill at position n+1.

He can choose any j < i, where i is his current position, swap with j, paying a_j and sum of b_k for k between j and i.

Our goal is to minimize the cost to reach a position <= m.

One way to approach this is to consider dynamic programming.

Define dp[i] as the minimal cost to reach position i from position n+1.

We need to compute dp[1] to dp[m], and take the minimal among them.

But with n up to 2e5, we need an efficient way to compute this.

First, let's think about how to compute dp[i].

To reach position i, Kirill can come from any position j where j > i, by swapping with person at position j.

The cost of such a swap is a_i (since j > i, in the original ordering, j is behind i).

Wait, no.

Wait, in the operation, Kirill is at position i, chooses j < i, swaps with j, paying a_j and sum of b_k for j < k < i.

In terms of moving forward, Kirill is moving from i to j.

So, to reach position i, he can come from any position j where j > i.

Wait, but in the operation as described, he's choosing j < i, meaning he's swapping with someone ahead of him in the queue, which allows him to move forward to position j.

So, to reach position i, he needs to consider all positions j where j < i, and compute the cost of swapping from i to j.

But actually, in terms of dp, to reach position i, he can come from any position j where j > i, by performing a swap from j to i.

Wait, I'm getting confused.

Let me think differently.

Let's consider that Kirill starts at position n+1.

He can choose to swap with anyone in positions 1 to n, but only if that person is ahead of him in the queue, meaning positions 1 to n.

Wait, no, in the operation, he chooses j < i, where i is his current position.

Initially, i = n+1.

So, he can choose any j < n+1, meaning any j from 1 to n.

He pays a_j to the person at position j, and for each k between j and n+1, he pays b_k.

Wait, more precisely, for each k such that j < k < i, he pays b_k to the person at position k.

So, in this case, k goes from j+1 to n+1.

But position n+1 is Kirill.

So, sum of b_k for k from j+1 to n+1 is sum of b_{j+1} to b_n.

Because position n+1 is Kirill, and b_{n+1} doesn't exist.

Wait, in the input, lista_B has n elements, from position 1 to n.

So, in the code, lista_B is reversed, so position 0 is original position n+1, but b_{n+1} doesn't exist, so probably b_{n+1} = 0.

So, when he swaps from i to j, he pays a_j and sum of b_k from k = j+1 to i-1.

In this case, i = n+1, j from 1 to n.

So, sum of b_k from k = j+1 to n.

So, cost to swap from i = n+1 to j is a_j + sum_{k=j+1 to n} b_k.

After swapping, Kirill is at position j.

From position j, he can again choose to swap with any position j' < j, paying a_{j'} + sum_{k=j'+1 to j} b_k.

He can do this repeatedly until he reaches a position <= m.

So, in dp terms, dp[j] = minimal cost to reach position <= m from position j.

Then, dp[j] = a_j + sum_{k=j+1 to n} b_k + min over j' < j of (a_{j'} + sum_{k=j'+1 to j} b_k) + dp[j']

Wait, this seems complicated.

Maybe there's a smarter way to model this.

Let me consider that the total cost to go directly from i to j is a_j + sum_{k=j+1 to i-1} b_k.

If I can find the minimal cost to go from n+1 to some position <=m, considering all possible sequences of swaps.

This seems like a shortest path problem, where positions are nodes, and there is an edge from i to j < i with cost a_j + sum_{k=j+1 to i-1} b_k.

But with n up to 2e5, I need something more efficient than a graph traversal.

Maybe I can find a way to compute dp[i] efficiently.

Let me consider computing dp[i] for i from n down to 1.

Initialize dp[i] as a_j + sum_{k=j+1 to i} b_k for some j > i.

Wait, perhaps inclusion-exclusion.

Wait, perhaps prefix sums.

Let me consider defining prefix sums of b.

Let me define sum_b[j] = sum of b_k from k=j to n.

So, sum_b[j] = b_j + b_{j+1} + ... + b_n.

Then, the cost to swap from i to j is a_j + sum_b[j+1].

Wait, sum_{k=j+1 to i-1} b_k.

Wait, in the initial case from i = n+1 to j, it's sum_{k=j+1 to n} b_k.

So, sum_b[j+1].

Therefore, cost from i to j is a_j + sum_b[j+1].

So, in general, cost from i to j < i is a_j + sum_b[j+1] - sum_b[i].

Wait, no.

Wait, sum_{k=j+1 to i-1} b_k = sum_b[j+1] - sum_b[i].

Wait, no.

Wait, sum_b[j+1] = sum from j+1 to n.

sum_b[i] = sum from i to n.

So, sum from j+1 to i-1 is sum_b[j+1] - sum_b[i].

But in the initial case, from i = n+1 to j, it's sum from j+1 to n.

So, sum_b[j+1].

But in general, from i to j, it's sum from j+1 to i-1.

Wait, but in the operation, it's j < i, and sum_{k=j+1 to i-1} b_k.

Yes.

So, cost from i to j is a_j + (sum_b[j+1] - sum_b[i]).

Wait, but sum_b[j+1] - sum_b[i] is sum from j+1 to i-1.

So, the cost from i to j is a_j + sum_{k=j+1 to i-1} b_k.

In particular, from n+1 to j, it's a_j + sum_{k=j+1 to n} b_k.

Because sum_b[j+1] - sum_b[n+1], but sum_b[n+1] = 0.

Assuming sum_b[n+1] = 0.

Yes.

So, sum_b[j+1] - sum_b[n+1] = sum_b[j+1].

Hence, cost from n+1 to j is a_j + sum_b[j+1].

Similarly, from i to j, it's a_j + sum_b[j+1] - sum_b[i].

Wait, but sum_{k=j+1 to i-1} b_k = sum_b[j+1] - sum_b[i].

Yes.

So, cost from i to j is a_j + sum_b[j+1] - sum_b[i].

Now, in dp terms, dp[j] = a_j + sum_b[j+1] - sum_b[i] + dp[i].

But I need to find the minimal dp[j] for j < i.

Wait, perhaps I need to think differently.

Let me consider dp[i] as the minimal cost to reach position i from n+1.

Then, dp[i] = a_j + sum_{k=j+1 to i} b_k for some j > i.

Wait, no.

Wait, to reach i, Kirill can come from some position j > i, swap from j to i, paying a_j + sum_{k=i+1 to j-1} b_k.

Wait, no.

Wait, in the operation, he's at position j > i, and swaps with position i, paying a_i and sum_{k=i+1 to j-1} b_k.

Wait, I'm getting confused.

Wait, in the operation, he's at position j, chooses k < j, swaps with k, paying a_k and sum_{l=k+1 to j-1} b_l.

In our case, he's at position n+1, chooses j < n+1, swaps with j, paying a_j and sum_{l=j+1 to n} b_l.

Then, he's now at position j.

From position j, he can choose any j' < j, swap with j', paying a_{j'} and sum_{l=j'+1 to j-1} b_l.

And so on, until he reaches a position <= m.

I need to model this recursively.

Define dp[j] as the minimal cost to reach from position j to a position <= m.

Then, dp[j] = a_j + sum_{k=j+1 to n} b_k + min_{j' < j} dp[j']

Wait, no.

Wait, from position j, he can choose any j' < j, swap with j', paying a_{j'} + sum_{k=j'+1 to j} b_k.

Then, dp[j] = min_{j' < j} (a_{j'} + sum_{k=j'+1 to j} b_k + dp[j'])

This looks like a dynamic programming problem.

But with n up to 2e5, I need an efficient way to compute this.

Let me see if I can find a way to compute dp[j] in O(1) or O(log n) time.

Let me consider that sum_{k=j'+1 to j} b_k = sum_b[j'+1] - sum_b[j]

Wait, no.

sum_b[j'+1] = sum from j'+1 to n.

sum_b[j] = sum from j to n.

So, sum_{k=j'+1 to j} b_k = sum_b[j'+1] - sum_b[j]

But in the operation, sum_{k=j'+1 to j-1} b_k = sum_b[j'+1] - sum_b[j]

Because sum from j'+1 to j-1 is sum_b[j'+1] - sum_b[j]

Yes.

So, the cost to swap from j to j' is a_{j'} + sum_b[j'+1] - sum_b[j]

Then, dp[j] = min_{j' < j} (a_{j'} + sum_b[j'+1] - sum_b[j] + dp[j'])

Let's rearrange this:

dp[j] = min_{j' < j} (a_{j'} - sum_b[j'] + sum_b[j'+1] - sum_b[j] + dp[j'])

Wait, sum_b[j'+1] - sum_b[j'] = -b_{j'}

Wait, no.

sum_b[j'+1] = sum_b[j'] - b_{j'}

So, sum_b[j'+1] - sum_b[j] = (sum_b[j'] - b_{j'}) - sum_b[j]

Wait, but sum_b[j] = sum_b[j'+1] + sum_{k=j'+1 to j-1} b_k

Wait, perhaps I'm complicating this.

Let me try to define sum_b[j] as sum from j to n of b_k.

So, sum_b[j] = sum_{k=j to n} b_k

Then, sum_{k=j'+1 to j-1} b_k = sum_b[j'+1] - sum_b[j]

Yes, that's correct.

So, the cost to swap from j to j' is a_{j'} + sum_b[j'+1] - sum_b[j]

Then, dp[j] = min_{j' < j} (a_{j'} + sum_b[j'+1] - sum_b[j] + dp[j'])

Let me rearrange this:

dp[j] = min_{j' < j} (a_{j'} + sum_b[j'+1] + dp[j']) - sum_b[j]

Let me define temp[j'] = a_{j'} + sum_b[j'+1] + dp[j']

Then, dp[j] = min_{j' < j} temp[j'] - sum_b[j]

So, dp[j] = min_temp[j] - sum_b[j], where min_temp[j] is the minimum temp[j'] for j' < j.

So, to compute dp[j], I need to know the minimum of (a_{j'} + sum_b[j'+1] + dp[j']) for j' < j.

This suggests that I can maintain a minimum value of temp[j'] as I iterate j from 1 to n.

Wait, but dp[j'] depends on j', so I need to be careful about the order.

Wait, perhaps I can iterate j from 1 to n, computing dp[j] based on dp[j'] for j' < j.

But with n up to 2e5, I need this to be efficient.

Let me consider iterating j from 1 to n, and maintaining the minimum of (a_{j'} + sum_b[j'+1] + dp[j']).

Wait, but dp[j'] depends on j', so I need to compute dp[j] before using it for dp[j'].

Wait, perhaps I need to find a way to compute dp[j] in a single pass.

Let me consider that dp[j] = min_{j' < j} (a_{j'} + sum_b[j'+1] - sum_b[j] + dp[j'])

I need to minimize over j' < j the expression a_{j'} + sum_b[j'+1] + dp[j'] - sum_b[j]

So, dp[j] = (min over j' < j of (a_{j'} + sum_b[j'+1] + dp[j'])) - sum_b[j]

Let me define min_temp = min over j' < j of (a_{j'} + sum_b[j'+1] + dp[j'])

Then dp[j] = min_temp - sum_b[j]

So, to compute dp[j], I need to know min_temp, which depends on j' < j.

This suggests that I can keep track of min_temp as I iterate j from 1 to n.

Initialize min_temp to a very large value.

Then, for each j from 1 to n:

dp[j] = min_temp - sum_b[j]

Then, update min_temp = min(min_temp, a_j + sum_b[j+1] + dp[j])

Wait, but dp[j] depends on min_temp, and min_temp depends on dp[j].

This seems circular.

Wait, no.

Actually, min_temp for j+1 is min over j' < j+1 of (a_{j'} + sum_b[j'+1] + dp[j'])

Which includes min_temp for j and also a_j + sum_b[j+1] + dp[j]

So, I can iterate j from 1 to n, keeping track of min_temp, and computing dp[j] based on the current min_temp.

Then, update min_temp with a_j + sum_b[j+1] + dp[j]

Yes, this seems feasible.

So, here's the plan:

- Compute sum_b[j] for j from 1 to n, where sum_b[j] = sum of b_k from k=j to n.

- Initialize min_temp to a very large value.

- Initialize dp[j] for all j.

- Iterate j from 1 to n:

- dp[j] = min_temp - sum_b[j]

- min_temp = min(min_temp, a_j + sum_b[j+1] + dp[j])

Wait, but for j=1, sum_b[j+1] = sum_b[2], and dp[j] is just min_temp - sum_b[1]

But I need to handle j=1 carefully.

Wait, sum_b[j+1] for j=1 is sum_b[2], which is sum from 2 to n.

Also, sum_b[1] = sum from 1 to n.

So, dp[1] = min_temp - sum_b[1]

But min_temp is initially very large, so dp[1] will be very negative.

Wait, perhaps I need to set min_temp initially to a meaningful value.

Wait, perhaps I need to initialize min_temp based on some initial condition.

Wait, maybe I need to think differently.

Let me consider that Kirill can perform any number of operations.

He starts at position n+1.

He can choose to swap directly to some position j < n+1, paying a_j + sum_{k=j+1 to n} b_k.

Then, from position j, he can choose to swap to some position j' < j, paying a_{j'} + sum_{k=j'+1 to j} b_k.

And so on, until he reaches a position <= m.

So, the total cost is sum of a_j for each swap, plus sum of b_k for each k between the positions involved.

Wait, perhaps it's better to think of this as a graph where positions are nodes, and there are directed edges from i to j < i with cost a_j + sum_{k=j+1 to i-1} b_k.

Then, the problem reduces to finding the shortest path from n+1 to any position <= m.

But with n up to 2e5, a graph approach is too slow.

I need a better way.

Let me consider that sum_b[j+1] - sum_b[i] = sum_{k=j+1 to i-1} b_k.

So, the cost from i to j is a_j + sum_{k=j+1 to i-1} b_k.

In particular, from n+1 to j, it's a_j + sum_{k=j+1 to n} b_k.

Let me try to find a way to compute dp[j] efficiently.

Let me consider that dp[j] = a_j + sum_{k=j+1 to n} b_k, if j <= m.

Otherwise, dp[j] = a_j + sum_{k=j+1 to n} b_k + dp[j']

Where j' is some position < j.

Wait, no.

Wait, dp[j] should be the minimal cost to reach from j to some position <= m.

So, dp[j] = min over j' < j of (a_{j'} + sum_{k=j'+1 to j} b_k + dp[j'])

Wait, sum_{k=j'+1 to j} b_k = sum_b[j'+1] - sum_b[j]

So, dp[j] = min over j' < j of (a_{j'} + sum_b[j'+1] - sum_b[j] + dp[j'])

Rearranged: dp[j] = min over j' < j of (a_{j'} + sum_b[j'+1] + dp[j']) - sum_b[j]

Let me define temp = a_{j'} + sum_b[j'+1] + dp[j']

Then dp[j] = min_temp - sum_b[j]

Where min_temp is the minimum temp over j' < j.

So, I can iterate j from 1 to n, keeping track of min_temp.

Initialize min_temp to a large value.

For j from 1 to n:

dp[j] = min_temp - sum_b[j]

Then, temp_j = a_j + sum_b[j+1] + dp[j]

min_temp = min(min_temp, temp_j)

Wait, but for j = n, sum_b[j+1] = sum_b[n+1] = 0.

So, dp[n] = min_temp - sum_b[n]

But min_temp is initially large, so I need to initialize it properly.

Wait, perhaps I need to start from j = n and go down to j = 1.

Let me try that.

Initialize dp[j] for j from 1 to m as some initial value.

Then, for j from n down to 1:

temp_j = a_j + sum_b[j+1] + dp[j]

min_temp = min(min_temp, temp_j)

dp[j] = min_temp - sum_b[j]

Wait, but dp[j] depends on dp[j'], which are positions less than j.

Wait, perhaps it's better to iterate from j = n down to 1, and compute dp[j] based on dp[j'] for j' < j.

But with n up to 2e5, I need an efficient way.

Wait, perhaps I can iterate from j = n down to 1, and keep track of the minimal temp_j.

Wait, perhaps I can iterate from j = n down to 1, and maintain the minimal (a_j + sum_b[j+1] + dp[j])

Then, dp[j] = min_temp - sum_b[j]

Wait, but dp[j] depends on min_temp, which includes dp[j].

This seems circular.

Wait, perhaps I need to think of it as a recurrence relation.

Let me consider that dp[j] = min over j' < j of (a_{j'} + sum_{k=j'+1 to j} b_k + dp[j'])

I need to minimize this expression.

Let me see if I can find a way to compute dp[j] efficiently.

Wait, perhaps I can iterate j from 1 to n, and maintain a sliding window of some sort.

Wait, perhaps I can keep track of the minimal (a_j + sum_b[j+1] + dp[j]) as I go.

Let me try to define sum_b[j] as the sum of b_k from k=j to n.

So, sum_b[j] = b_j + sum_b[j+1]

Then, sum_{k=j'+1 to j} b_k = sum_b[j'+1] - sum_b[j]

So, dp[j] = min over j' < j of (a_{j'} + sum