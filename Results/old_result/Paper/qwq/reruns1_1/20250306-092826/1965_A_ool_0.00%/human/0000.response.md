Alright, I have this problem to solve. It's about a game that Alice and Bob are playing with piles of stones. The rules are a bit unusual compared to standard stone-removing games. Let's try to understand the problem step by step.

First, the game setup: There are n piles of stones, and each pile has a certain number of stones, given by a_1, a_2, ..., a_n. Players take turns, and on each turn, a player chooses a positive integer k that is less than or equal to the size of the smallest non-empty pile and removes k stones from each non-empty pile at once. The player who can't make a move because all piles are empty loses.

Alice goes first, and both players play optimally. I need to determine who wins each game for multiple test cases.

Looking at the input format: The first line is t, the number of test cases. Then, for each test case, there's n, the number of piles, followed by n integers representing the number of stones in each pile.

Constraints are important here: t can be up to 10^4, and n can be up to 2*10^5 per test case, with a_i up to 10^9. Also, the sum of n over all test cases doesn't exceed 2*10^5. So, efficiency is key to handle large inputs within time limits.

Let me think about the game mechanics. The interesting part is that in each move, the player removes k stones from every non-empty pile, where k is at most the smallest pile's size. This is different from standard Nim or other stone-removal games where stones are removed from one pile at a time.

I need to find a way to determine the winner without simulating the entire game, which would be too slow given the constraints.

Maybe I can find some mathematical pattern or symmetry in the pile sizes that决定谁会赢。

Let me look at the example provided:

Test case 1:

n = 5

a = [3, 3, 3, 3, 3]

Alice can choose k=3 and remove 3 stones from each pile, emptying all piles at once and winning immediately.

Test case 2:

n = 2

a = [1, 7]

Alice must choose k=1 (since the smallest pile has 1 stone), removing 1 stone from both piles, resulting in [0,6]. Now, Bob chooses k up to 6 (the smallest non-empty pile is 6), but he has to remove k stones from both piles. If he chooses k=6, he removes 6 stones from the second pile, making it empty, and the first pile is already empty. So, after Bob's move, all piles are empty, and Alice can't make a move, so Bob wins.

Wait, but in the output, it says "Bob" for this test case, which matches my reasoning.

Test case 3:

n=7

a=[1,3,9,7,4,2,100]

Not sure off the top of my head who wins here, but the output is "Alice".

I need to find a general strategy.

Perhaps I should think in terms of the number of moves possible.

Each move consists of choosing a k and removing k stones from all non-empty piles.

The game ends when all piles are empty.

The player who makes the last move wins, since the next player can't make a move.

So, it's like determining whether the total number of moves is odd or even.

If it's odd, Alice wins; if even, Bob wins.

But is that the case?

Wait, in test case 1, Alice makes one move and wins, which is odd.

In test case 2, Alice makes one move, then Bob makes one move, total two moves, which is even, so Bob wins.

Yes, that seems consistent.

So, if the total number of moves is odd, Alice wins; if even, Bob wins.

Now, the question is, how to calculate the total number of moves efficiently.

Given that n can be up to 2*10^5 per test case, and t up to 10^4, but sum of n over all test cases is up to 2*10^5, I need an O(n log n) per test case solution or better.

Let me think about how to calculate the number of moves.

Each move consists of choosing a k and removing k stones from all non-empty piles.

The game continues until all piles are empty.

I need to find the sequence of k's that can be chosen.

An important observation: The possible values of k are limited by the smallest non-empty pile.

In each move, k can be at most the smallest non-empty pile.

So, the sequence of k's is non-increasing.

Wait, no, k can be any positive integer less than or equal to the smallest non-empty pile at each step.

But the choice of k affects the remaining piles.

This seems similar to the concept of the mex in impartial games, but I'm not sure.

Maybe I can sort the piles and think about them in order.

Wait, perhaps I can think of the game in terms of the number of times each pile can be reduced.

But with a_i up to 10^9, I need something smarter.

Another way: Think of the game as a selection of k's such that the sum of k's over all moves equals the sum of the piles.

But that doesn't directly help.

Wait, perhaps I can think of the game in terms of the mex of the exponents in the binary representation, like in Nim games.

But that might not be directly applicable here.

Let me try to find a pattern or a mathematical formula.

Suppose there is only one pile: The first player can choose k equal to the number of stones in the pile and remove them all in one move. So, if there's one pile, Alice wins.

Wait, but according to the problem, if there's one pile, Alice can always remove all stones in one move and win. So, Alice wins.

Wait, but in the example, there's a test case with n=1 and a_1=1000000000, and the output is "Alice", which matches this.

What if there are two piles?

If both piles have the same number of stones, say a and a, then Alice can choose k=a and remove a stones from both piles, emptying them both and winning in one move.

So, if n is even and all piles have the same number of stones, Alice can win in one move.

But in the second test case, n=2, a=[1,7], Alice chooses k=1, removing 1 from both, resulting in [0,6]. Then Bob chooses k=6, removing 6 from the second pile, making it [0,0], and Alice can't move, so Bob wins.

So, in this case, with two piles of different sizes, the number of moves is two, which is even, so Bob wins.

Wait, so perhaps the number of moves is equal to the number of distinct smallest non-empty piles.

Wait, let's think differently.

Let me consider the sorted list of pile sizes.

Sort the piles in ascending order.

Then, in each move, choose k equal to the smallest non-empty pile.

This will remove k stones from all piles, including the smallest one, which will become empty.

Then, the next smallest pile becomes the new smallest non-empty pile.

Repeat until all piles are empty.

The number of moves in this case would be equal to the number of distinct pile sizes.

Wait, is that true?

Let me take an example.

Test case 3: n=7, a=[1,3,9,7,4,2,100]

Sort them: [1,2,3,4,7,9,100]

First move: choose k=1, remove 1 from all, resulting in [0,1,2,3,6,8,99]

Now, the smallest non-empty pile is 1.

Second move: choose k=1, remove 1 from all non-empty piles: [0,0,1,2,5,7,98]

Third move: choose k=1, remove 1 from [1,2,5,7,98] -> [0,1,4,6,97]

Fourth move: choose k=1, remove 1 from [1,4,6,97] -> [0,3,5,96]

Fifth move: choose k=3, remove 3 from [3,5,96] -> [0,2,93]

Sixth move: choose k=2, remove 2 from [2,93] -> [0,91]

Seventh move: choose k=91, remove 91 from [91] -> [0]

So, total moves are 7, which is odd, so Alice wins.

But according to the output, it's "Alice", which matches.

Another test case: n=2, a=[1,7]

Sorted: [1,7]

First move: choose k=1, remove 1 from both -> [0,6]

Second move: choose k=6, remove 6 from [6] -> [0]

Total moves: 2, which is even, so Bob wins.

This seems consistent.

So, perhaps the number of moves is equal to the number of times we can remove the smallest non-zero pile size from all piles, and this number of moves is equal to the number of distinct pile sizes in the sorted list.

Wait, in the first test case, n=5, a=[3,3,3,3,3]

Sorted: [3,3,3,3,3]

First move: choose k=3, remove 3 from all -> [0,0,0,0,0]

Total moves: 1, which is odd, Alice wins.

In the second test case, n=2, a=[1,7]

Sorted: [1,7]

First move: choose k=1, remove 1 from both -> [0,6]

Second move: choose k=6, remove 6 from [6] -> [0]

Total moves: 2, even, Bob wins.

In the third test case, n=7, a=[1,3,9,7,4,2,100]

Sorted: [1,2,3,4,7,9,100]

Moves:

1. Choose k=1, remove from all, set becomes [0,1,2,3,6,8,99]

2. Choose k=1, remove from non-zeros, set becomes [0,0,1,2,5,7,98]

3. Choose k=1, remove from non-zeros, set becomes [0,0,0,1,4,6,97]

4. Choose k=1, remove from non-zeros, set becomes [0,0,0,0,3,5,96]

5. Choose k=3, remove from non-zeros, set becomes [0,0,0,0,0,2,93]

6. Choose k=2, remove from non-zeros, set becomes [0,0,0,0,0,0,91]

7. Choose k=91, remove from last pile, set becomes [0,0,0,0,0,0,0]

Total moves: 7, which is odd, Alice wins.

Wait, in this process, the number of moves seems to be equal to the number of distinct non-zero pile sizes in the sorted list.

Wait, in the first test case, all piles are 3, so only one distinct size, moves=1.

Second test case: [1,7], two distinct sizes, moves=2.

Third test case: [1,2,3,4,7,9,100], seven distinct sizes, moves=7.

Is this always the case?

Let me check another test case.

Test case: n=3, a=[1,2,3]

Sorted: [1,2,3]

Moves:

1. Choose k=1, remove from all, set becomes [0,1,2]

2. Choose k=1, remove from non-zeros, set becomes [0,0,1]

3. Choose k=1, remove from last pile, set becomes [0,0,0]

Total moves: 3, which is odd, Alice wins.

According to my hypothesis, there are three distinct sizes, so moves=3, which matches.

Another test case: n=4, a=[2,2,3,3]

Sorted: [2,2,3,3]

Moves:

1. Choose k=2, remove from all, set becomes [0,0,1,1]

2. Choose k=1, remove from non-zeros, set becomes [0,0,0,0]

Total moves: 2, which is even, Bob wins.

According to the number of distinct sizes, there are two: 2 and 3.

Moves=2, which matches.

Another test case: n=4, a=[1,1,1,1]

Sorted: [1,1,1,1]

Moves:

1. Choose k=1, remove from all, set becomes [0,0,0,0]

Moves=1, which is odd, Alice wins.

Distinct sizes: only 1, moves=1, matches.

Seems like this hypothesis holds.

So, the number of moves is equal to the number of distinct pile sizes in the sorted list.

Therefore, if the number of distinct pile sizes is odd, Alice wins; if even, Bob wins.

Wait, but let me verify one more time.

Test case: n=4, a=[1,1,2,2]

Sorted: [1,1,2,2]

Moves:

1. Choose k=1, remove from all, set becomes [0,0,1,1]

2. Choose k=1, remove from non-zeros, set becomes [0,0,0,0]

Moves=2, which is even, Bob wins.

Distinct sizes: 1 and 2, count=2, matches.

Another test case: n=4, a=[1,1,1,2]

Sorted: [1,1,1,2]

Moves:

1. Choose k=1, remove from all, set becomes [0,0,0,1]

2. Choose k=1, remove from last pile, set becomes [0,0,0,0]

Moves=2, even, Bob wins.

Distinct sizes: 1 and 2, count=2, matches.

Seems consistent.

So, the strategy is to find the number of distinct pile sizes, and if that number is odd, Alice wins; if even, Bob wins.

This seems efficient, as I can sort the array and count the number of distinct elements, which can be done in O(n log n) time per test case, acceptable given the constraints.

But wait, in the provided code, it doesn't seem to do that.

Let me look at the given program.

Given program:

import heapq

import sys

input = sys.stdin.readline

t = int(input())

c = 1

while t > 0:

n = list(map(int, input().rstrip().split()))

arr = list(map(int, input().rstrip().split()))

r = func_1(arr)

print(r)

t -= 1

def func_1(arr):

A = False

if arr[0] != 1:

return 'Alice'

set_ = list(set(arr))

set_.sort()

not_c = True

for i in range(1, len(set_)):

if set_[i] - set_[i - 1] > 1:

not_c = False

break

A = not A

if not_c:

A = not A

return 'Alice' if A else 'Bob'

This code first reads t, the number of test cases, then for each test case, it reads n (number of piles) and then the pile sizes arr.

It then calls func_1(arr) to determine the winner.

In func_1:

- It initializes A to False.

- If the first element of arr is not 1, it returns 'Alice'.

- It creates a sorted list of unique pile sizes.

- It iterates through this list to check if the difference between consecutive sizes is greater than 1.

- If any difference is greater than 1, it sets not_c to False and breaks.

- It toggles A based on some condition.

- If not_c is True, it toggles A again.

- Finally, it returns 'Alice' if A is True, else 'Bob'.

This seems overly complicated and not aligned with the simple strategy I derived.

According to my strategy, I just need to count the number of distinct pile sizes and check if it's odd or even.

In the given code, it sorts the unique pile sizes and checks if the differences between consecutive sizes are greater than 1, which seems unrelated.

Also, it checks if the first element is not 1, and if so, returns 'Alice', which might be a part of the logic but seems incomplete.

Let me test this code with the sample inputs to see if it produces the correct outputs.

Sample Input:

7

5

3 3 3 3 3

2

1 7

7

1 3 9 7 4 2 100

3

1 2 3

6

2 1 3 4 2 4

8

5 7 2 9 6 3 3 2

1

1000000000

Sample Output:

Alice

Bob

Alice

Alice

Bob

Alice

Alice

Now, let's see what the given code would output for these inputs.

Test case 1:

n=5, arr=[3,3,3,3,3]

Unique sorted pile sizes: [3]

Number of distinct sizes: 1 (odd), so Alice wins. Correct.

Test case 2:

n=2, arr=[1,7]

Unique sorted pile sizes: [1,7]

Number of distinct sizes: 2 (even), so Bob wins. Correct.

Test case 3:

n=7, arr=[1,3,9,7,4,2,100]

Unique sorted pile sizes: [1,2,3,4,7,9,100]

Number of distinct sizes: 7 (odd), Alice wins. Correct.

Test case 4:

n=3, arr=[1,2,3]

Unique sorted pile sizes: [1,2,3]

Number of distinct sizes: 3 (odd), Alice wins. Correct.

Test case 5:

n=6, arr=[2,1,3,4,2,4]

Unique sorted pile sizes: [1,2,3,4]

Number of distinct sizes: 4 (even), Bob wins. Correct.

Test case 6:

n=8, arr=[5,7,2,9,6,3,3,2]

Unique sorted pile sizes: [2,3,5,6,7,9]

Number of distinct sizes: 6 (even), Bob wins. But sample output is "Alice", which is inconsistent with my strategy.

Wait, there's a discrepancy here.

According to my strategy, in test case 6, there are 6 distinct pile sizes, which is even, so Bob should win. But the sample output is "Alice".

Hmm, perhaps my strategy is incomplete or incorrect.

Let me re-examine this test case.

Test case 6:

n=8, a=[5,7,2,9,6,3,3,2]

Sorted: [2,2,3,3,5,6,7,9]

Moves:

1. Choose k=2, remove from all, set becomes [0,0,1,1,3,4,5,7]

2. Choose k=1, remove from non-zeros, set becomes [0,0,0,0,2,3,4,6]

3. Choose k=2, remove from non-zeros, set becomes [0,0,0,0,0,1,2,4]

4. Choose k=1, remove from non-zeros, set becomes [0,0,0,0,0,0,1,3]

5. Choose k=1, remove from last two piles, set becomes [0,0,0,0,0,0,0,2]

6. Choose k=2, remove from the last pile, set becomes [0,0,0,0,0,0,0,0]

Total moves: 6, which is even, so Bob wins.

But the sample output is "Alice", which contradicts my earlier assumption.

Wait, perhaps I made a mistake in counting the moves.

Let me simulate again.

Starting: [2,2,3,3,5,6,7,9]

Move 1: k=2 -> [0,0,1,1,3,4,5,7]

Move 2: k=1 -> [0,0,0,0,2,3,4,6]

Move 3: k=2 -> [0,0,0,0,0,1,2,4]

Move 4: k=1 -> [0,0,0,0,0,0,1,3]

Move 5: k=1 -> [0,0,0,0,0,0,0,2]

Move 6: k=2 -> [0,0,0,0,0,0,0,0]

Total moves: 6, even, Bob wins.

But sample output is "Alice", so my strategy is incorrect.

Apparently, just counting the number of distinct pile sizes doesn't work in all cases.

I need to rethink this.

Maybe I need to consider the sequence of moves more carefully.

Alternatively, perhaps there's a way to model this game using Nimbers or game theory concepts, but I'm not experienced enough in that area.

Let me consider the game as a subtraction game where in each move, the same amount is subtracted from all piles.

This is similar to a game where the mex (minimum excludant) can be used to determine the Grundy number.

Wait, in impartial game theory, the XOR of the Grundy numbers of the independent subgames determines the overall game's winner.

But in this game, the moves are interdependent across all piles, so it's not a straightforward Nim game.

Alternatively, perhaps I can think of the game in terms of the number of times we can subtract the smallest non-zero pile size from all piles.

Wait, perhaps I can think of it in terms of the number of times we can choose k equal to the smallest non-zero pile.

In other words, the number of times we can remove the smallest non-zero pile size from all piles until all piles are empty.

But in the earlier test case, that seemed to correspond to the number of distinct pile sizes, but as we saw, that doesn't hold in all cases.

Let me try to think differently.

Suppose I sort the pile sizes in ascending order: a1 <= a2 <= ... <= an.

In each move, I choose k <= a1 (the smallest non-zero pile), remove k from all piles.

After removing k, the new pile sizes are a1 - k, a2 - k, ..., an - k, but only if ai - k >= 0.

So, the new non-empty piles are those with ai - k > 0.

I need to choose k such that k <= a1, and then the game continues with the new piles.

This seems similar to dividing the pile sizes by k, but it's not exactly that.

Wait, perhaps I can think of the game in terms of the number of times I can subtract the smallest non-zero pile size.

But this seems too vague.

Let me consider the game as equivalent to another known game.

Alternatively, perhaps I can think of it in terms of the mex of the possible moves.

But I'm getting stuck.

Let me look back at the provided code and see what it's doing.

In func_1:

- If the first element of arr is not 1, return 'Alice'.

- Else, create a sorted list of unique pile sizes.

- Check if the differences between consecutive sizes are all 1; if so, set not_c to True, else False.

- Toggle A based on some condition.

- If not_c is True, toggle A again.

- Return 'Alice' if A is True, else 'Bob'.

This seems convoluted and not clearly aligned with any standard game theory strategy.

Perhaps the author tried to implement something based on the number of distinct pile sizes or sequences of pile sizes, but it's not clear.

Given that in my earlier analysis, just counting the number of distinct pile sizes didn't hold for all cases, the provided code might be incorrect.

But in the sample input, it seems to produce the correct output, except for test case 6, where according to my earlier simulation, Bob should win, but the sample output says "Alice".

Wait, perhaps I made a mistake in my simulation.

Let me simulate again.

Test case 6:

n=8, a=[5,7,2,9,6,3,3,2]

Sorted: [2,2,3,3,5,6,7,