Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a binary string, which means it only contains '0's and '1's. I need to find the minimum number of pieces to cut this string into such that I can rearrange these pieces and get a sorted binary string. A sorted binary string is one where all '0's come before any '1's. Make sense.

First, I need to understand what a "piece" is. A piece is a contiguous substring of the original string. So, if I have the string "11010", and I decide to cut it into pieces "11", "0", "10", these are contiguous parts of the string. Then, I can rearrange these pieces in any order to try to form a sorted binary string.

The goal is to do this with as few pieces as possible. So, I need to minimize the number of cuts.

Let me think about how to approach this.

I should consider the properties of the sorted binary string. In the sorted string, all '0's come before any '1's. So, if I can group the '0's and '1's in a way that allows me to arrange the pieces to satisfy this condition, I'm good.

Maybe I can look for sections of the string that are already sorted and try to minimize the number of times I need to switch from '0's to '1's or vice versa.

Wait, let's consider some examples to get a better understanding.

Take the first test case: "11010"

According to the sample output, it should be cut into 3 pieces.

Let me see:

One possible way is to cut it into "11", "0", and "10". Then, rearrange them as "0", "11", "10". But "10" has a '1' before a '0', which doesn't fit the sorted string requirement. Hmm, maybe that's not the right way.

Alternatively, cut it into "110", "1", "0". Then rearrange as "0", "1", "110". But again, "110" has a '0' at the end, which might not fit.

Wait, maybe "11", "0", and "10" can be rearranged as "0", "10", "11". Wait, "10" has a '0' after a '1', which isn't allowed in the final sorted string. So, perhaps that's not correct.

I must be misunderstanding something.

Wait, perhaps I need to cut the string into pieces where each piece is either all '0's or all '1's, and then arrange these pieces to form a sorted binary string.

But in the first test case, "11010", if I try to cut it into pieces of consecutive '1's and '0's:

First piece: "11" (all '1's)

Next piece: "0" (all '0's)

Next piece: "1" (all '1's)

Next piece: "0" (all '0's)

So, four pieces: "11", "0", "1", "0". Then, arrange them as "0", "0", "1", "11", which is "00111", which is sorted. But according to the sample output, it's 3 pieces. So, maybe there's a way to do it with fewer pieces.

Wait, perhaps I can have overlapping '0's and '1's in pieces.

Wait, no, the pieces are contiguous substrings, but they must be cut without overlapping.

Wait, maybe I can cut it differently.

Let's see:

If I cut "110", "1", "0"

Then, rearrange as "0", "1", "110". But "110" has a '0' at the end, which would make the entire string "01110", which is not sorted because there's a '0' after '1's.

Hmm.

Alternatively, cut "11", "01", "0"

Rearrange as "0", "0", "11". But "01" has a '1' after '0', which doesn't fit into the sorted string.

Wait, perhaps I need to ensure that each piece, when arranged, doesn't have '1's before '0's.

Wait, but pieces can contain '1's and '0's as long as when arranged in order, the entire string is sorted.

Wait, maybe I need to think differently.

Let me consider that in the final sorted string, all '0's come before any '1's. So, if I can group the '0's and '1's in such a way that all '0's from the original string are placed before any '1's, but I have to keep the pieces contiguous.

Wait, but I can rearrange the pieces, but within each piece, the order of characters must remain the same.

Wait, perhaps another approach: the minimum number of pieces needed is equal to the number of times the string changes from '0' to '1' or '1' to '0', plus one.

Wait, similar to the number of runs in the string.

Wait, let's think about runs in the string.

In "11010", the runs are:

"11" (two '1's)

"0" (one '0')

"1" (one '1')

"0" (one '0')

So, four runs.

In the sorted string, there are two runs: all '0's followed by all '1's.

So, maybe the number of pieces needed is equal to the number of runs minus the number of times the runs alternate between '0's and '1's in a way that requires separation.

Wait, I'm getting confused.

Let me look at another test case.

Second test case: "00000000"

The output is 1, which makes sense because it's already sorted, so no need to cut it at all.

Third test case: "1"

Already sorted, so 1 piece.

Fourth test case: "10"

To make it sorted, I need to rearrange it to "01", which requires cutting it into two pieces: "1" and "0", then arrange them as "0" and "1".

Fifth test case: "0001111"

Already sorted, so 1 piece.

Sixth test case: "0110"

Needs to be rearranged to "0011", so I can cut it into "011", "0" and arrange them as "0", "011". But "011" has '1's after '0's, which is fine in the arranged position.

Alternatively, cut it into "0", "11", "0" and arrange as "0", "0", "11".

So, in this case, 3 pieces are sufficient, but maybe it can be done with fewer.

Wait, the sample output for this is 2, so it must be possible with 2 pieces.

Wait, maybe cut it into "01", "10" and arrange as "01", "10"? But that gives "0110", which is not sorted.

Alternatively, cut into "0", "110" and arrange as "0", "110". But "110" has '0' after '1's, which violates the sorted order.

Wait, perhaps cut into "011", "0" and arrange as "0", "110". But again, "110" has '0' after '1's.

Wait, maybe cut into "01", "1", "0" and arrange as "0", "0", "1", "1". But that's 3 pieces, which matches the sample output of 2, but the sample output is 2, so perhaps there's a better way.

Wait, maybe cut into "0110" as one piece and then " " (no other pieces). But "0110" isn't sorted.

Wait, perhaps I need to think differently.

Maybe the number of pieces needed is equal to the number of times the string changes from '0' to '1' or '1' to '0', plus one.

Wait, similar to the number of runs.

In "11010", there are four runs: "11", "0", "1", "0". So, number of pieces would be 4.

But the sample output is 3, so that doesn't match.

Wait, perhaps it's the number of times the string switches from '1' to '0' or vice versa, plus one, minus something.

Wait, in "11010", the switches are:

From "1" to "0", then "0" to "1", then "1" to "0". So, three switches.

Number of pieces is 3.

Wait, in "10", there is one switch, and the number of pieces is 2.

In "00000000", no switches, number of pieces is 1.

In "0001111", one switch from '0' to '1', number of pieces is 1.

Wait, that seems inconsistent.

Wait, in "0001111", there is one switch from '0' to '1', but the number of pieces is 1, because it's already sorted.

In "11010", there are three switches, and the number of pieces is 3.

In "10", one switch, number of pieces is 2.

In "0110", there are two switches: '0' to '1' and '1' to '0', and the number of pieces is 2.

Wait, perhaps the number of pieces is equal to the number of switches plus one, divided by something.

Wait, in "11010":

Switches: 3

Pieces: 3

In "10":

Switches: 1

Pieces: 2

In "0110":

Switches: 2

Pieces: 2

In "0001111":

Switches: 1

Pieces: 1

Wait, that seems inconsistent.

Wait, maybe it's the number of switches when the switch is from '1' to '0', specifically.

In "11010", switches from '1' to '0': positions 2 and 4.

So, two switches, but sample output is 3.

Wait, perhaps not.

Wait, maybe it's the number of times '1's appear before '0's in the string.

In "11010", '1's before '0's in positions 1-2, 3-4, etc.

Wait, getting confused.

Let me think differently.

Suppose I want to rearrange the pieces to have all '0's before '1's.

Each piece can be a substring of the original string, and I can arrange these pieces in any order.

I need to minimize the number of pieces.

So, I need to find a way to group the '0's and '1's such that when I arrange the pieces, all '0's come before '1's.

One way to think about it is to find the minimum number of cuts such that the concatenation of the pieces in some order forms a sorted string.

Wait, perhaps I can find the number of times the current running count of '1's is less than the final required count.

Wait, maybe I need to look at the prefix sums or something.

Wait, perhaps I can iterate through the string and count the number of times I need to start a new piece because the current character can't be placed in the current piece without violating the sorted order.

Wait, that might work.

Let me try that.

Initialize with one piece.

Start with the first character, say it's '1'.

Then, the next character is '1', can be in the same piece.

Next is '0', which is less than '1', so I need to start a new piece.

Then, '1' again, start another new piece.

Wait, in this way, for "11010", pieces would be "11", "0", "1", "0", which is 4 pieces.

But the sample output is 3, so that's not right.

Wait, maybe I can merge some pieces.

Wait, perhaps if I have a '0' after a '1', I start a new piece, but if it's a '1' after a '0', I can add it to the previous piece.

Wait, let's try that.

Start with "11", then '0' requires a new piece, so "0", then '1' can be added to the previous piece "01", then '0' can be added to the previous piece "010".

So, pieces are "11" and "010".

Then, arrange them as "010", "11", which is "01011", which is sorted.

Yes, that works, and it's 2 pieces.

But the sample output is 3, so maybe that's not correct.

Wait, perhaps I need to ensure that each piece is either all '0's or all '1's.

Wait, no, the pieces can have both '0's and '1's, but when arranged, the entire string should be sorted.

Wait, in the above example, "11" and "010" arranged as "010" + "11" = "01011", which is sorted.

So, why is the sample output 3?

Wait, maybe I'm missing something.

Looking back at the problem, it says "the resulting pieces can be rearranged into a sorted binary string."

So, perhaps there are multiple ways to cut the string, but I need to find the minimum number of pieces.

In the above example, I found a way to do it with 2 pieces, but the sample output is 3.

Wait, maybe I need to consider that the pieces can't overlap or something.

Wait, no, pieces are contiguous substrings, non-overlapping.

Wait, perhaps the pieces must be arranged in the order they appear in the original string.

No, it says "rearranged", so I can arrange them in any order.

So, in my earlier approach, I cut "11" and "010", then arranged them as "010" and "11", which is sorted.

So, why is the sample output 3?

Wait, maybe there's a constraint I'm missing.

Wait, perhaps the pieces must be arranged in a way that all '0's come before any '1's, and within each piece, the order is preserved.

Wait, but in my earlier arrangement, "010" followed by "11" is "01011", which has all '0's before '1's.

So, it should be acceptable.

But according to the sample output, it should be 3 pieces.

So, maybe my approach is missing something.

Let me look at another test case.

Take "0110".

If I cut it into "01", "10", and arrange as "01" + "10" = "0110", which is not sorted.

Wait, but the sample output is 2.

So, perhaps I need to cut it into "011", "0", and arrange as "0" + "011" = "0011", which is sorted.

So, that's 2 pieces, matching the sample output.

Wait, but earlier I thought "11010" can be done with 2 pieces, but sample output is 3.

Wait, maybe I need to consider that in the arranged string, each piece should not have '1's before '0's.

Wait, in "0110", cutting into "011" and "0", then arranging as "0" + "011" = "0011", which is sorted.

So, 2 pieces.

But in "11010", if I cut into "110", "1", "0", and arrange as "0" + "1" + "110" = "01110", which is not sorted.

Wait, "110" has '0' at the end, which would cause issue.

Wait, perhaps I need to ensure that in the arranged string, no piece has '1's followed by '0's, unless all '1's are after all '0's.

Wait, I'm getting tangled up.

Let me try to think of a general approach.

Suppose I have the entire string, and I want to rearrange pieces to have all '0's before '1's.

Each piece can be thought of as a block that maintains its internal order.

So, I need to arrange these blocks such that when concatenated, the entire string is sorted.

This sounds similar to merging sorted arrays.

Wait, perhaps I can treat each piece as a sorted subarray and merge them.

But in this case, the pieces don't have to be sorted; they just need to be arranged in a way that the entire string is sorted.

Wait, maybe I need to find the minimum number of runs where each run is either all '0's or all '1's, and then arrange these runs accordingly.

Wait, but that's similar to my earlier approach.

In "11010", if I have runs:

"11" (all '1's), "0" (all '0's), "1" (all '1's), "0" (all '0's).

Then, arrange them as "0", "0", "1", "11", which is sorted.

That's 4 pieces.

But the sample output is 3, so maybe there's a way to group some runs together.

Perhaps I can merge adjacent runs of the same type.

Wait, but in this case, all runs are alternating.

Wait, maybe I need to consider that in the arranged string, the transition from '0's to '1's should be smooth, i.e., no '1's before '0's.

So, perhaps the number of pieces needed is equal to the number of times the string switches from '1' to '0' after the first run.

Wait, let's try that.

In "11010":

Runs: "11", "0", "1", "0"

Number of switches from '1' to '0' or '0' to '1':

From "11" to "0": switch from '1' to '0'

From "0" to "1": switch from '0' to '1'

From "1" to "0": switch from '1' to '0'

So, three switches.

But the sample output is 3, but wait, in the arranged string, I only need to ensure that all '0's are before '1's.

So, perhaps the number of pieces is equal to the number of times the string switches from '1' to '0' after the first run.

Wait, I'm getting confused.

Let me look at the differences between the number of '0's and '1's in the prefix sums.

Wait, maybe that's overcomplicating.

Let me consider that in the final sorted string, all '0's are before '1's.

So, if I can group the '0's and '1's in such a way that when I arrange the pieces, all '0's are placed before any '1's.

So, the pieces containing '0's should be placed before pieces containing '1's.

But pieces containing both '0's and '1's need to be arranged such that no '1's come before '0's in the final string.

Wait, perhaps I need to ensure that any piece that contains '1's is placed after all pieces that contain '0's.

But pieces can contain both '0's and '1's, as long as in the arranged string, '0's come before '1's.

This is getting tricky.

Let me think about the minimal number of pieces needed.

I need to minimize the number of pieces, so I need to maximize the size of each piece.

So, I should try to make each piece as large as possible before needing to make a cut.

Wait, perhaps I can iterate through the string and make a cut every time I encounter a '1' followed by a '0'.

Because if I have a '1' followed by a '0', in the sorted string, that '0' should come before that '1', so I need to separate them into different pieces.

Wait, that sounds promising.

Let me formalize this.

Initialize with one piece.

Start iterating through the string.

Whenever I see a '1' followed by a '0', make a cut and start a new piece.

Because in the sorted string, that '0' should come before that '1', so they can't be in the same piece unless I arrange the piece accordingly.

Wait, but pieces are arranged in any order, but within each piece, the characters remain in their original order.

So, if I have "11010", and I make a cut between '1' and '0', so pieces are "11", "010".

Then, arrange them as "010" + "11" = "01011", which is sorted.

Similarly, in "0110", make a cut between '1' and '0', so pieces are "011", "0", arrange as "0" + "011" = "0011", which is sorted.

In "10", make a cut between '1' and '0', so pieces are "1", "0", arrange as "0" + "1" = "01", which is sorted.

In "11010", there are two '1's followed by '0's: between position 2 and 3 ('1' followed by '0'), and between position 4 and 5 ('1' followed by '0').

So, according to this, number of cuts needed is 2, which should result in 3 pieces.

Wait, but in my earlier example, I could do it with 2 pieces.

Wait, perhaps I miscalculated.

Wait, in "11010", if I make one cut between '1' and '0' at position 2 and 3, I get "11" and "010".

Then, arrange them as "010" + "11" = "01011", which is sorted.

So, that's 2 pieces.

But according to the sample output, it should be 3.

So, maybe I need to make another cut.

Wait, perhaps I need to make a cut every time there is a '1' followed by a '0', and also consider the positions where '0's are followed by '1's.

Wait, in "11010", there are two '1's followed by '0's.

So, number of cuts is 2, resulting in 3 pieces.

Wait, but in practice, making one cut seems sufficient.

Wait, perhaps I need to make a cut every time there is a '1' followed by a '0', and potentially additional cuts for multiple occurrences.

Wait, maybe the number of pieces is equal to the number of times '1' is followed by '0', plus one.

In "11010", '1' followed by '0' occurs twice, so number of pieces is 3.

In "0110", '0' followed by '1', and then '1' followed by '0'.

But in this case, sample output is 2.

Wait, perhaps it's the number of times '1' is followed by '0'.

In "11010", it's twice, so number of pieces is number of cuts plus one, which is 3.

In "0110", it's once, so number of pieces is 2.

In "10", it's once, number of pieces is 2.

In "11010", sample output is 3, which matches.

In "0110", sample output is 2, which matches.

In "10", sample output is 2, which matches.

In "00000000", no '1' followed by '0', so number of pieces is 1.

In "11111111", no '1' followed by '0', so number of pieces is 1.

In "0001111", only one '0' followed by '1', but in this case, it's already sorted, so number of pieces is 1.

Wait, according to my earlier logic, '1' followed by '0' is the condition for making a cut.

Wait, but in "0001111", there are '0's followed by '1's, but no '1' followed by '0's, so no cuts needed, which matches the sample output of 1.

Similarly, in "11111111", no '1' followed by '0', so one piece.

In "00000000", one piece.

In "10", one cut, so two pieces.

In "01", no '1' followed by '0', so one piece.

Wait, "01" should be one piece because it's already sorted.

Wait, according to my earlier logic, '1' followed by '0' is the condition for making a cut.

In "01", no '1' followed by '0', so one piece.

In "10", one '1' followed by '0', so one cut, resulting in two pieces.

In "11010", two '1's followed by '0's, so two cuts, resulting in three pieces.

This seems consistent with the sample outputs.

So, the general approach is:

- Initialize with one piece.

- Iterate through the string and count the number of times '1' is followed by '0'.

- Each time '1' is followed by '0', make a cut, increasing the number of pieces by one.

- The minimum number of pieces needed is the number of such cuts plus one.

This seems to work for the sample inputs.

Let me test this logic with the sixth test case: "0110"

In "0110", there is one '1' followed by '0' (positions 3 and 4).

So, number of cuts is one, resulting in two pieces, which matches the sample output.

Another test case: "11010"

Two '1's followed by '0's (positions 2-3 and 4-5), so two cuts, resulting in three pieces, matching the sample output.

Seems correct.

Wait, but earlier I thought I could do it with fewer pieces in some cases, but according to this logic, it's giving the correct sample outputs.

So, perhaps this is the way to go.

Let me formalize this.

Algorithm:

1. Initialize a counter for the number of cuts to zero.

2. Iterate through the string from the first character to the second last character.

3. For each pair of consecutive characters, if the first is '1' and the next is '0', increment the cut counter.

4. The minimum number of pieces needed is the number of cuts plus one.

5. For each test case, output this number.

This seems straightforward and matches the sample outputs.

Let me verify with some additional test cases.

Test case: "101010"

Number of '1' followed by '0': three times.

So, number of cuts is three, number of pieces is four.

Is that correct?

Arranging pieces:

Possible cuts: after each '10', so pieces are "10", "10", "10".

Arrange them as "10" + "10" + "10" = "101010", which is not sorted.

Wait, that's not helpful.

Alternatively, cut after each '1', so pieces are "1", "01", "01", "0".

Arrange as "0", "01", "01", "1" = "001011", which is sorted.

So, four pieces.

But perhaps it can be done with fewer pieces.

Wait, maybe cut into "101010" as one piece, arrange it as is, but it's not sorted.

Alternatively, cut into "1010", "10", arrange as "10" + "1010" = "101010", which is not sorted.

Wait, seems like four pieces is necessary here.

So, according to my algorithm, cuts = 3, pieces = 4, which seems correct.

Another test case: "000111"

No '1' followed by '0', so cuts = 0, pieces = 1, which is correct.

Test case: "111000"

Number of '1' followed by '0': three times.

So, cuts = 3, pieces = 4.

Arranging pieces:

Possible cuts: after each '10', but need to make sure the arrangement is sorted.

Cut into "111", "000": two pieces, arrange as "000" + "111" = "000111", which is sorted.

Wait, according to the algorithm, cuts should be three, but in practice, only one cut is needed.

So, perhaps the algorithm is overestimating the number of pieces needed in some cases.

Wait, in "111000", '1' followed by '0' occurs twice (positions 3-4 and 4-5).

So, according to the algorithm, cuts = 2, pieces = 3.

But in reality, only one cut is needed.

So, perhaps the algorithm is not always giving the minimal number of pieces.

Wait, but according to the sample inputs, it's working correctly.

Maybe in this case, it's not.

Wait, perhaps I need to adjust the algorithm.

Let me think differently.

Maybe the minimal number of pieces is equal to the number of times the string switches from '1' to '0' after the first run of '1's.

Wait, I need a better way.

Wait, perhaps I can think of it as the maximum number of '1's that are before some '0's, requiring separate pieces for those '1's.

Wait, I'm getting stuck.

Let me look at the provided program and see what it's doing.

The program:

def func():

t = int(input())

for i in range(t):

s = input()

count = 1

flag = False

j = 0

while j < len(s) - 1:

if s[j] !=