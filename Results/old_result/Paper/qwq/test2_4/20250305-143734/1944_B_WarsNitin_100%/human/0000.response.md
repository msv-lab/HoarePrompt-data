Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array `a` of length `2n`, and it contains each integer from `1` to `n` exactly twice. Then there's an integer `k` (between `1` and `n/2`), and I need to find two arrays `l` and `r`, each of length `2k`, with specific properties.

First, `l` should be a subset of the first `n` elements of `a`, and `r` should be a subset of the last `n` elements of `a`. Moreover, the bitwise XOR of elements in `l` should be equal to the bitwise XOR of elements in `r`.

The problem also mentions that at least one pair of `l` and `r` always exists, and if there are multiple solutions, I can output any one of them.

Alright, let's try to understand what's being asked here. I need to select some elements from the first half of the array and some from the second half such that the XOR of the selected elements from the first half equals the XOR of the selected elements from the second half. And the number of elements selected from each half should be `2k`.

Given that each number from `1` to `n` appears exactly twice in the entire array, it means that each number appears exactly once in the first half and once in the second half, or possibly both in the first half or both in the second half.

Wait, no. Actually, since the array is of length `2n` and contains each integer from `1` to `n` exactly twice, it's possible for both occurrences of a number to be in the first half or both in the second half, or one in each.

But according to the problem, it's just split into two halves, first `n` elements and last `n` elements, and I need to choose subsets from these halves with equal XOR.

I need to find a way to select `2k` elements from the first half and `2k` elements from the second half such that their XORs are equal.

First, I need to understand the properties of XOR. XOR is commutative and associative, meaning the order in which we XOR numbers doesn't matter. Also, XOR-ing a number with itself results in zero.

Given that, if I have pairs of identical numbers, their XOR would be zero, which might be useful.

Let me think about the constraints. `n` can be up to 50,000, and the total number of test cases is up to 5,000, with the sum of `n` over all test cases not exceeding 50,000. So, I need an efficient solution, probably linear time per test case.

Let me look at the example to get some intuition.

In the first test case:

n = 2, k = 1

a = [1, 2, 2, 1]

So, first half: [1, 2], second half: [2, 1]

Choose l = [2, 1], r = [2, 1]

XOR of l: 2 XOR 1 = 3

XOR of r: 2 XOR 1 = 3

They are equal.

Another test case:

n = 6, k = 1

a = [6,4,2,1,2,3,1,6,3,5,5,4]

First half: [6,4,2,1,2,3]

Second half: [1,6,3,5,5,4]

Choose l = [6,4], r = [1,3]

XOR of l: 6 XOR 4 = 2

XOR of r: 1 XOR 3 = 2

They are equal.

So, in both examples, they chose subsets such that their XOR matches.

Now, I need a general approach to find such subsets for any given `a`, `n`, and `k`.

Let me think about the properties of XOR and how I can make the XOR of selected elements in `l` equal to the XOR of selected elements in `r`.

One idea is to select elements in such a way that the XOR difference between `l` and `r` is zero. That is, XOR of `l` and the XOR of `r` should be equal, which means XOR of `l` XOR XOR of `r` should be zero.

Wait, that's interesting. If I consider the XOR of `l` and `r` together, their combined XOR should be zero.

But actually, I need XOR of `l` to equal XOR of `r`, which means XOR of `l` XOR XOR of `r` equals zero.

So, overall XOR of `l` and `r` should be zero.

But I need to select `2k` elements from each half such that their XORs are equal.

Given that, perhaps I can select some elements from the first half and some from the second half to balance the XOR.

But I need to ensure that the subsets are of size `2k` each.

Another thought: since each number from `1` to `n` appears exactly twice in the entire array, some numbers might appear in both halves, while others might appear only in one half.

I need to consider the distribution of numbers in the two halves.

Wait, perhaps I can look at the XOR of all elements in the first half and the XOR of all elements in the second half.

Let me denote:

X = XOR of all elements in the first half.

Y = XOR of all elements in the second half.

Since each number from `1` to `n` appears twice in total, the overall XOR of the entire array is zero (because XOR of any number with itself is zero).

Therefore, X XOR Y = 0, which implies X = Y.

That's an important observation: the XOR of the first half is equal to the XOR of the second half.

Now, I need to select subsets `l` from the first half and `r` from the second half, each of size `2k`, such that XOR of `l` equals XOR of `r`.

Given that X = Y, maybe I can use this property to find such subsets.

Let me consider that I select some elements for `l` and the remaining elements in the first half will have a certain XOR.

Similarly, for `r`, selecting some elements will lead to a certain XOR.

But I'm not sure if that directly helps.

Perhaps I can think in terms of linear algebra over GF(2), where XOR corresponds to addition modulo 2.

Each number can be represented as a vector in a binary space, and selecting elements corresponds to adding their vectors.

But that might be too slow for the given constraints.

Let me think differently.

Since I need to select `2k` elements from each half with equal XOR, and given that X = Y, maybe I can select elements such that the XOR of selected elements in the first half is equal to the XOR of selected elements in the second half.

Wait, that's essentially what's required.

But I need an efficient way to select these elements.

Another idea: since I need to select `2k` elements from each half, and k can be up to n/2, which is up to 25,000, but n can be up to 50,000, and t is up to 5,000, I need a solution that is linear or near-linear in n.

I need something efficient.

Let me consider that for each number from 1 to n, it appears exactly twice in the entire array, once in the first half and once in the second half, or both in the first half, or both in the second half.

Wait, actually, it's possible for both occurrences to be in the first half or both in the second half.

But given that, I need to find a way to select `2k` elements from each half such that their XORs match.

Let me try to categorize the numbers based on their positions:

- Numbers that appear once in the first half and once in the second half.

- Numbers that appear twice in the first half.

- Numbers that appear twice in the second half.

For numbers that appear once in each half, their XOR contributions can be paired together.

But I need to think more carefully.

Let me consider that if I select both copies of a number in the first half for `l`, their XOR contribution is zero (since a number XOR itself is zero). Similarly for the second half.

So, selecting both copies of a number effectively removes their contribution to the XOR.

Similarly, if I select one copy from the first half and one from the second half, their XOR contributions would be zero.

But I need to select `2k` elements from each half, so I need to choose elements in such a way that the total XOR from `l` equals the total XOR from `r`.

This seems a bit tricky.

Let me think about the total number of elements to select: `2k` from each half.

Given that `k` can be up to n/2, and n can be up to 50,000, I need an efficient approach.

Perhaps I can look for numbers that appear in both halves and try to select them in a way that balances the XOR.

Wait, maybe I can group the numbers into those that appear in both halves and those that appear only in one half.

For numbers that appear in both halves, selecting one from the first half and one from the second half would give me zero XOR contribution for that number.

For numbers that appear only in one half, I need to handle them differently.

Wait, perhaps I can select pairs of identical numbers, one from each half, which would give me zero XOR, and then adjust the remaining selections to match the required XOR.

But I need to select `2k` elements from each half, so I need to make sure that the total number of elements selected from each half is `2k`.

This seems complicated.

Let me consider that since X = Y, and I need XOR(l) = XOR(r), perhaps I can select elements for `l` and `r` such that the XOR of the remaining elements in each half is also equal.

But I'm not sure.

Maybe I can think in terms of the XOR of the entire first half and the selected `l`, which would be XOR of the remaining elements in the first half.

Similarly for the second half.

But I'm getting confused.

Let me try to think of a simpler approach.

Given that X = Y, and I need XOR(l) = XOR(r), perhaps I can select elements for `l` and `r` such that XOR(l) = X and XOR(r) = X, since X = Y.

Wait, no. X is the XOR of the entire first half, and Y is the XOR of the entire second half, and X = Y.

But I need XOR(l) = XOR(r), and l is a subset of the first half, r is a subset of the second half.

Wait, perhaps I can select `l` such that XOR(l) = some value, and then select `r` such that XOR(r) equals the same value.

But I need to select exactly `2k` elements for each.

This seems tricky.

Let me consider that since X = Y, and I need XOR(l) = XOR(r), perhaps I can select `l` to be any subset of `2k` elements from the first half, compute its XOR, and then try to find a subset `r` of `2k` elements from the second half with the same XOR.

But this seems inefficient, especially with n up to 50,000.

I need a better way.

Let me consider that I need to select `2k` elements from each half with equal XOR.

Given that, perhaps I can find a way to pair elements or group them to ensure that their XORs match.

Alternatively, maybe I can select certain elements to balance the XOR.

Wait, perhaps I can look at the numbers that appear in both halves and use them to adjust the XOR.

Let me try to think differently.

Suppose I select both copies of a number that appears in both halves, one from each half.

Then, their XOR contributions would be zero.

So, if I select such pairs, their XOR would be zero.

But I need to select `2k` elements from each half, which is an even number.

Maybe I can select pairs of identical numbers, one from each half, to make their XOR contributions zero.

But I need to select `2k` elements from each half, which might not directly help.

Wait, perhaps I can select `k` such pairs, each consisting of one element from the first half and one from the second half, and select both elements in the pair.

Then, for each pair, selecting both elements would give me zero XOR for that pair.

So, if I select `k` such pairs, I would select `k` elements from the first half and `k` elements from the second half, each pair contributing zero XOR.

But I need to select `2k` elements from each half.

Wait, that would only select `k` elements from each half, not `2k`.

So, that doesn't help directly.

Maybe I need to select `2k` elements from each half by selecting `k` pairs, each pair consisting of two identical elements, one from each half.

But that would only select `k` elements from each half, not `2k`.

Wait, perhaps I need to select elements in a different way.

Let me think about the properties of XOR again.

Since XOR is associative and commutative, the order doesn't matter, and I can group elements in any way.

Given that, perhaps I can select elements such that the overall XOR of selected elements from both halves is zero.

Wait, but I need XOR(l) = XOR(r), which implies that XOR(l) XOR XOR(r) = 0, which is equivalent to XOR(l + r) = 0, where l + r is the combined selection.

But I need to select `2k` elements from each half, so the total number of selected elements is `4k`.

Given that, perhaps I can look for a combination of `4k` elements across both halves with total XOR zero, with exactly `2k` from each half.

But I need to ensure that the selected elements are divided into `l` and `r` correctly.

This seems too vague.

Let me consider another approach.

Since X = Y, and I need XOR(l) = XOR(r), perhaps I can select `l` to be a subset of the first half and `r` to be a subset of the second half such that XOR(l) = X and XOR(r) = X.

Because X = Y, this would satisfy XOR(l) = XOR(r).

But I'm not sure if this is always possible.

Wait, let's think about it.

If I select `l` such that XOR(l) = X, then the XOR of the remaining elements in the first half would be X XOR X = 0.

Similarly, if I select `r` such that XOR(r) = X, the XOR of the remaining elements in the second half would be X XOR X = 0.

But I need to select exactly `2k` elements for each.

This might not always be possible, especially since `k` can be up to n/2.

I need a different strategy.

Let me consider that I need to select `2k` elements from each half such that XOR(l) = XOR(r).

Let me denote S1 as the set of elements in the first half, and S2 as the set of elements in the second half.

I need to choose subsets l ⊆ S1 and r ⊆ S2, each of size `2k`, such that XOR(l) = XOR(r).

Given that, perhaps I can iterate through the elements and make choices based on their values.

But with n up to 50,000 and t up to 5,000, I need an efficient solution.

Let me consider that for each number from 1 to n, it appears exactly twice in the entire array.

So, for each number, I can have zero, one, or two occurrences in the first half, and accordingly, zero, one, or two occurrences in the second half.

Wait, no. Since each number appears exactly twice in total, if it appears `x` times in the first half, it must appear `2 - x` times in the second half.

So, for each number, it can be:

- Both copies in the first half.

- Both copies in the second half.

- One copy in the first half and one in the second half.

Given that, perhaps I can group the numbers based on where their copies are located.

Let me define:

- Group A: numbers that have both copies in the first half.

- Group B: numbers that have both copies in the second half.

- Group C: numbers that have one copy in the first half and one in the second half.

Now, for Group A, selecting both copies for `l` would give XOR zero.

Similarly, for Group B, selecting both copies for `r` would give XOR zero.

For Group C, selecting one copy from the first half for `l` and one copy from the second half for `r` would give XOR equal to the number itself in both `l` and `r`, so their XORs would be equal.

But I need to select `2k` elements from each half.

Let me think about the total number of elements available in each group.

Let me denote:

- `a`: number of numbers in Group A.

- `b`: number of numbers in Group B.

- `c`: number of numbers in Group C.

Then, total elements in the first half:

Each number in Group A contributes 2 elements in the first half.

Each number in Group C contributes 1 element in the first half.

Similarly, in the second half:

Each number in Group B contributes 2 elements in the second half.

Each number in Group C contributes 1 element in the second half.

Wait, no.

Actually, for Group A, both copies are in the first half, so they contribute 2 elements to the first half.

For Group B, both copies are in the second half, so they contribute 2 elements to the second half.

For Group C, one copy is in the first half and one in the second half, so they contribute 1 element to the first half and 1 to the second half.

Therefore, total elements in the first half: 2a + c.

Total elements in the second half: 2b + c.

But we know that both halves have n elements, so:

2a + c = n

2b + c = n

Subtracting these two equations:

2a + c - (2b + c) = 0 => a = b

So, a = b.

That's an interesting observation: the number of numbers with both copies in the first half is equal to the number of numbers with both copies in the second half.

Now, I need to select `2k` elements from each half.

Given that a = b, perhaps I can use this fact to construct the subsets.

Let me think about selecting elements from Group A, Group B, and Group C to form `l` and `r`.

I need to select `2k` elements from the first half (which has 2a + c elements) and `2k` elements from the second half (which has 2b + c elements).

Given that a = b, and n = 2a + c, I can denote a = (n - c)/2.

But I need to find a way to select `2k` elements from each half such that their XORs are equal.

This seems complicated.

Let me consider a simpler case where c = n, meaning all numbers are in Group C, i.e., each number appears once in the first half and once in the second half.

In this case, selecting any `2k` elements from the first half and the corresponding `2k` elements from the second half would ensure that their XORs are equal, because each selected number in `l` has a corresponding number in `r`.

But in general, c might be less than n.

Wait, but in this case, selecting `2k` elements from the first half and their corresponding elements from the second half would give me XOR(l) = XOR(r), because each pair contributes the same XOR.

But in reality, some numbers might not have a counterpart in the other half.

Wait, for Group C, each number has one copy in the first half and one in the second half.

For Group A, both copies are in the first half.

For Group B, both copies are in the second half.

So, perhaps I can select pairs from Group C and select both copies for `l` and `r` accordingly.

But I need to ensure that the total number of elements selected from each half is `2k`.

This is getting too tangled.

Let me try to think of a different approach.

Given that X = Y, and I need XOR(l) = XOR(r), perhaps I can fix `l` and find `r` accordingly.

But that might not be efficient.

Wait, perhaps I can select `l` to be any subset of `2k` elements from the first half, compute its XOR, and then try to find a subset `r` of `2k` elements from the second half with the same XOR.

But with n up to 50,000 and t up to 5,000, this approach would be too slow because finding subsets with a specific XOR is not efficient.

I need a smarter way.

Let me consider that since X = Y, and I need XOR(l) = XOR(r), perhaps I can select `l` and `r` such that the XOR of the remaining elements in both halves is equal.

But I'm not sure.

Wait, perhaps I can look at the XOR of the entire first half and the XOR of `l`, which gives me the XOR of the remaining elements in the first half.

Similarly, the XOR of the entire second half and the XOR of `r` gives me the XOR of the remaining elements in the second half.

Since X = Y, and I need XOR(l) = XOR(r), then the XOR of the remaining elements in both halves would also be equal.

But I'm not sure if that helps.

Let me consider that XOR(l) = XOR(r), and X = Y.

Then, XOR(l) = XOR(r), and XOR(l) = X XOR (XOR of remaining elements in the first half).

Similarly, XOR(r) = Y XOR (XOR of remaining elements in the second half).

But since X = Y, and XOR(l) = XOR(r), then X XOR (XOR of remaining in first half) = X XOR (XOR of remaining in second half), which implies that the XOR of remaining elements in the first half equals the XOR of remaining elements in the second half.

So, to have XOR(l) = XOR(r), I need the XOR of remaining elements in both halves to be equal.

This seems like a necessary condition.

But I'm not sure how to use this to construct the subsets.

This is getting too complicated.

Let me look at the provided program and see what it's doing.

Looking at the code:

def func():

t = int(input())

for q in range(t):

(n, k) = list(map(int, input().split(' ')))

a = list(map(int, input().split(' ')))

b = a[:n]

c = a[n:]

b.sort()

c.sort()

ans1 = []

ans2 = []

k = 2 * k

req = k

l = []

if b[0] != b[1]:

l.append(b[0])

if b[n - 2] != b[n - 1]:

l.append(b[n - 1])

else:

ans1.append(b[n - 1])

ans1.append(b[n - 1])

k -= 2

for i in range(1, n - 1):

if k == 0:

break

if b[i] == b[i - 1]:

ans1.append(b[i])

ans1.append(b[i])

k -= 2

elif b[i] != b[i + 1]:

l.append(b[i])

k = req

for i in range(1, n):

if k == 0:

break

if c[i] == c[i - 1]:

ans2.append(c[i])

ans2.append(c[i])

k -= 2

for i in range(len(l)):

if k == 0:

break

ans1.append(l[i])

ans2.append(l[i])

k -= 1

print(*ans1)

print(*ans2)

So, the program sorts both halves, then tries to build `ans1` and `ans2` by selecting pairs of identical elements from each half when possible, and using some remaining elements from `l` to balance the selections.

This seems like an attempt to select pairs of identical elements to cancel out their XOR contributions.

But I need to verify if this approach is correct.

Let me walk through the first test case:

n = 2, k = 1

a = [1, 2, 2, 1]

b = [1, 2]

c = [2, 1]

After sorting:

b = [1, 2]

c = [1, 2]

Initialize ans1 and ans2 as empty lists.

k = 2 * 1 = 2

req = 2

l = []

Check if b[0] != b[1]: 1 != 2, so append b[0] = 1 to l.

Check if b[n-2] != b[n-1]: b[0] != b[1]: 1 != 2, so append b[1] = 2 to l.

Now l = [1, 2]

Since b[0] != b[1], don't execute the else clause.

Loop from i=1 to n-2=0 (no iteration)

So, ans1 remains empty.

Then, loop from i=1 to n-1=1:

i=1:

c[1] == c[0]: 2 == 1? No, so skip.

So, ans2 remains empty.

Then, loop through l:

for i in 0 and 1:

append l[0]=1 to ans1, append l[0]=1 to ans2, k -=1 to 1

append l[1]=2 to ans1, append l[1]=2 to ans2, k -=1 to 0

So, ans1 = [1,2]

ans2 = [1,2]

Which matches the first test case.

Good.

Let's look at the second test case:

n=6, k=1

a=[6,4,2,1,2,3,1,6,3,5,5,4]

b=[6,4,2,1,2,3]

c=[1,6,3,5,5,4]

After sorting:

b=[1,2,2,3,4,6]

c=[1,3,4,5,5,6]

Initialize ans1 and ans2 as empty lists.

k=2*1=2

req=2

l=[]

Check if b[0] != b[1]: 1 != 2, append b[0]=1 to l.

Check if b[4] != b[5]: 4 != 6, append b[5]=6 to l.

Now l=[1,6]

No else clause executed.

Then, loop from i=1 to n-2=4:

i=1: b[1]=2 == b[0]=1? No, and b[1] != b[2]=2? No, so skip.

i=2: b[2]=2 == b[1]=2, append 2 and 2 to ans1, k=0

So, ans1=[2,2]

Then, loop from i=1 to n-1=5:

i=1: c[1]=3 == c[0]=1? No, skip.

i=2: c[2]=4 == c[1]=3? No, skip.

i=3: c[3]=5 == c[2]=4? No, skip.

i=4: c[4]=5 == c[3]=5, append 5 and 5 to ans2, k=0

So, ans2=[5,5]

Then, loop through l:

k=0, so break.

But k was reset to req=2 after the first loop, but in the code, k is set to req inside the loop, which might be a mistake.

Wait, in the code, after the first loop, k is set back to req.

But in this case, k was set to 0 in the first loop, then set back to req=2 before the second loop.

But in the second loop, k is set to 0 by selecting [5,5].

Then, loop through l:

k=0, so break.

So, ans1=[2,2], ans2=[5,5]

But in the example output, it's l=[6,4], r=[1,3]

So, the code's output doesn't match the example output in this case.

Wait, perhaps the code is incorrect.

Wait, in the first loop, it selects pairs from b where elements are equal, and appends them to ans1.

In the second loop, it selects pairs from c where elements are equal, and appends them to ans2.

But in the example, it selected [6,4] from b and [1,3] from c, which are not pairs of equal elements.

So, the code's approach seems flawed because it doesn't always select pairs of equal elements, but sometimes selects single elements.

Wait, in the code, it seems to select pairs of equal elements when possible, and uses remaining elements in `l` to fill up the required `2k` elements.

But in the second test case, the code selected [2,2] from b and [5,5] from c, but the example selected [6,4] and [1,3].

So, the code's approach might not be general enough.

Let me check another test case.

Third test case:

n=4, k=1

a=[1,2,3,4,1,2,3,4]

b=[1,2,3,4]

c=[1,2,3,4]

After sorting:

b=[1,2,3,4]

c=[1,2,3,4]

k=2*1=2

req=2

l=[]

Check if b[0] != b[1]: 1 != 2, append b[0]=1 to l.

Check if b[2] != b[3]: 3 != 4, append b[3]=4 to l.

So, l=[1,4]

Then, loop from i=1 to n-2=2:

i=1: b[1]=2 == b[0]=1? No, and b[1] != b[2]=3? Yes, append 2 to l.

i=2: b[2]=3 == b[1]=2? No, and b[2] != b[3]=4? Yes, append 3 to l.

So, l=[1,4,2,3]

Then, set k back to req=2

Then, loop from i=1 to n-1=3:

i=1: c[1]=2 == c[0]=1? No, skip.

i=2: c[2]=3 == c[1]=2? No, skip.

i=3: c[3]=4 == c[2]=3? No, skip.

So, ans2 remains empty.

Then, loop through l:

append l[0]=1 to ans1 and ans2, k=1

append l[1]=4 to ans1 and ans2, k=0

So, ans1=[1,4]

ans2=[1,4]

But in the example output, it's [1,2] and [1,2]

So, again, the code's output doesn't match the example.

Hence, the code seems incorrect.

Wait, perhaps I misread the code.

Looking back, after selecting pairs from b and c, it then appends elements from l to both ans1 and ans2.

But in the example, different elements are selected.

So, the code's approach is to select pairs of identical elements from b and c when possible, and use remaining unique elements to pair them up in l and r.

But this doesn't seem to guarantee that XOR(l) == XOR(r).

In the first test case, it worked because it selected [1,2] and [1,2], whose XOR is equal.

In the second test case, it selected [2,2] and [5,5], which have XOR 0 and 0, which are equal, but the example selected [6,4] and [1,3], which have XOR 6^4=2 and 1^3=2, which are equal.

So, multiple solutions exist.

But in the third test case, the code selected [1,4] and [1,4], which have XOR 1^4=5 and 1^4=5, which are equal, matching the required condition.

But in the example, [1,2] and [1,2] were selected, which also have XOR 1^2=3 and 1^2=3, which are equal.

So, in this case, the code's output is correct, but different from the example.

But since multiple solutions are possible, that's acceptable.

Wait, but in the second test case, the code selected [2,2] and [5,5], which have XOR 0 and 0, which are equal, but the example selected [6,4] and [1,3], which have XOR 2 and 2.

So, both are valid solutions.

Hence, perhaps the code's approach is correct, even though it selects different subsets from the example.

Let me check another test case.

Fourth test case:

n=6, k=2

a=[5,1,3,3,5,1,2,6,4,6,4,2]

b=[5,1,3,3,5,1]

c=[2,6,4,6,4,2]

After sorting:

b=[1,1,3,3,5,5]

c=[2,2,4,4,6,6]

Initialize ans1 and ans2 as empty lists.

k=2*2=4

req=4

l=[]

Check if b[0] != b[1]: 1 == 1, so no append.

Check if b[4] != b[5]: 5 == 5, so no append.

So, l=[]

Then, since b[4] == b[5], append b[5]=5 and b[5]=5 to ans1, k=2

Then, loop from i=1 to n-2=4:

i=1: b[1]=1 == b[0]=1, append 1 and 1 to ans1, k=0

So, ans1=[5,5,1,1]

Then, set k back to req=4

Then, loop from i=1 to n-1=5:

i=1: c[1]=2 == c[0]=2, append 2 and 2 to ans2, k=2

i=2: c[2]=4 == c[1]=2? No, skip.

i=3: c[3]=4 == c[2]=4, append 4 and 4 to ans2, k=0

So, ans2=[2,2,4,4]

Then, loop through l:

k=0, so break.

So, ans1=[5,5,1,1], ans2=[2,2,4,4]

XOR of ans1: 5^5^1^1=0, XOR of ans2:2^2^4^4=0, which are equal.

Hence, it's a valid solution.

In the example output, it's [5,1,3,3] and [6,4,2,4], whose XOR are both 5^1^3^3=5^1=4 and 6^4^2^4=6^4^2^4=6^4=2, which are not equal.

Wait, in the example output, it's [5,1,3,3] and [6,4,2,4], which have XOR 5^1^3^3=5^1=4 and 6^4^2^4=6^4^2^4=6^4=2, which are not equal.

Wait, that doesn't match.

But in the example, it says:

Output:

5 1 3 3

6 4 2 4

But according to XOR:

5^1^3^3 = 5^1 = 4

6^4^2^4 = 6^4^2^4 = 6^4=2, 2^2=0, 0^4=4

Wait, 6^4=2, 2^4=6

Wait, 6^4=2, 2^4=6

So, 6^4^2^4 = 6^4^2^4 = (6^4)^ (2^4) = 2 ^ 6 = 4

So, both XOR to 4, which matches.

Hence, the example selected [5,1,3,3] and [6,4,2,4], both XOR to 4.

The code selected [5,5,1,1] and [2,2,4,4], both XOR to 0, which is also correct.

So, multiple solutions exist, and both are valid.

Hence, the code seems to be producing correct outputs for the test cases.

Now, I need to verify if the approach is correct in general.

Looking back at the code:

- It sorts both halves.

- It initializes `l` with unique elements from the ends of the first half.

- It selects pairs of identical elements from the first half and appends them to `ans1`.

- It selects pairs of identical elements from the second half and appends them to `ans2`.

- It then appends remaining elements from `l` to both `ans1` and `ans2` until `k` is satisfied.

This approach seems to work because:

- Selecting pairs of identical elements contributes XOR zero to `ans1` and `ans2`.

- Appending unique elements from `l` to both `ans1` and `ans2` ensures that their XOR contributions are equal.

Hence, the total XOR of `ans1` and `ans2` remains equal.

Given that, and considering that it works for the provided test cases, I can conclude that the program is correct.

**Final Solution**

To solve this problem, we need to find two subsets, `l` and `r`, from the two halves of a given array `a` such that the bitwise XOR of elements in each subset is equal.

### Approach

1. **Problem Understanding**:
    - We are given an array `a` of length `2n`, containing integers from `1` to `n` exactly twice.
    - We need to select subsets `l` (from the first `n` elements) and `r` (from the last `n` elements) each of size `2k`, such that the XOR of elements in `l` equals the XOR of elements in `r`.

2. **Insight**:
    - The XOR of the first half (`b`) and the second half (`c`) are equal because each number appears twice in total.
    - To make subsets `l` and `r` with equal XOR, we can select pairs of identical elements from each half to contribute XOR zero and handle unique elements appropriately.

3. **Steps**:
    - Sort both halves to easily identify pairs of identical elements.
    - Collect unique elements from the ends of the first half.
    - Select pairs of identical elements from both halves to contribute zero XOR.
    - Use unique elements to balance the XOR values of `l` and `r`.

### Solution Code

```python
def func():
    t = int(input())
    for q in range(t):
        (n, k) = list(map(int, input().split(' ')))
        a = list(map(int, input().split(' ')))
        b = a[:n]
        c = a[n:]
        b.sort()
        c.sort()
        ans1 = []
        ans2 = []
        k = 2 * k
        req = k
        l = []
        if b[0] != b[1]:
            l.append(b[0])
        if b[n - 2] != b[n - 1]:
            l.append(b[n - 1])
        else:
            ans1.append(b[n - 1])
            ans1.append(b[n - 1])
            k -= 2
        for i in range(1, n - 1):
            if k == 0:
                break
            if b[i] == b[i - 1]:
                ans1.append(b[i])
                ans1.append(b[i])
                k -= 2
            elif b[i] != b[i + 1]:
                l.append(b[i])
        k = req
        for i in range(1, n):
            if k == 0:
                break
            if c[i] == c[i - 1]:
                ans2.append(c[i])
                ans2.append(c[i])
                k -= 2
        for i in range(len(l)):
            if k == 0:
                break
            ans1.append(l[i])
            ans2.append(l[i])
            k -= 1
        print(*ans1)
        print(*ans2)

# To use this function, simply call func() after input has been provided.
```

### Explanation

1. **Initialization**:
    - Read the number of test cases `t`.
    - For each test case, read `n` and `k`, and the array `a`.

2. **Sorting**:
    - Split `a` into two halves, `b` and `c`, and sort both.

3. **Collect Unique Elements**:
    - Check the first and last elements of `b` for uniqueness and collect them in list `l`.

4. **Select Pairs for Zero XOR Contribution**:
    - Select pairs of identical elements from `b` and `c` to contribute zero XOR to `ans1` and `ans2`.

5. **Balance with Unique Elements**:
    - Use unique elements collected earlier to balance the subsets `l` and `r` ensuring their XOR values match.

6. **Output the Subsets**:
    - Print the subsets `ans1` and `ans2`.

This approach ensures that the subsets `l` and `r` have equal XOR values by carefully selecting pairs and unique elements from the sorted halves of the array.