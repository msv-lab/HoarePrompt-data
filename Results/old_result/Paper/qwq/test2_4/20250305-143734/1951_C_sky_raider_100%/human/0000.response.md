Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm the CEO of a startup, and I need to buy tickets for my employees to a concert. There are n days to buy tickets, and each day has a certain price per ticket, given by the array a_i. There are some constraints:

1. I can't buy more than m tickets per day.

2. If I buy x tickets on day i, then from day i+1 onwards, the price per ticket increases by x.

My goal is to buy exactly k tickets at the minimum total cost.

First, I need to understand the problem fully. Let's look at the example to get a better grasp.

In the first test case:

n = 4, m = 2, k = 3

a = [8, 6, 4, 2]

The optimal way is:

- Buy 0 on day 1: prices become [6, 4, 2]

- Buy 0 on day 2: prices become [4, 2]

- Buy 1 on day 3: cost = 4, prices become [3]

- Buy 2 on day 4: cost = 6

Total cost = 10

Wait, but according to the problem, if you buy x tickets on day i, the prices from day i+1 onwards increase by x. In the first step, buying 0 on day 1 shouldn't change the prices. So, prices remain [6, 4, 2]. Then buying 0 on day 2, prices remain [4, 2]. Then buying 1 on day 3, prices for day 4 become [2 + 1] = [3]. Then buying 2 on day 4: cost = 2 * 3 = 6. Total cost = 4 + 6 = 10.

Another way could be:

- Buy 2 on day 1: cost = 2 * 8 = 16, prices become [6, 4, 2]

- Buy 1 on day 2: cost = 1 * (6 + 2) = 8, total cost = 16 + 8 = 24

That's worse.

Or:

- Buy 1 on day 1: cost = 8, prices become [7, 5, 3]

- Buy 1 on day 2: cost = 7, prices become [8, 6]

- Buy 1 on day 3: cost = 8, total cost = 8 + 7 + 8 = 23

Still worse than 10.

So, the optimal strategy seems to be buying later when the prices are lower due to the increases from previous purchases.

But how to generalize this?

Let's think about what's happening.

Each time you buy x tickets on day i, it increases the price for all subsequent days by x.

So, the cost of buying a ticket on day i is a_i plus the sum of all x_j for j < i.

Wait, no. The price increase is cumulative for all previous days' purchases.

Wait, more carefully:

- Initially, prices are a_i for each day i.

- If you buy x tickets on day i, then for all days j > i, the price per ticket becomes a_j + x.

- Moreover, you can't buy more than m tickets per day.

- You need to buy exactly k tickets in total.

So, the total cost would be sum over i from 1 to n of (number of tickets bought on day i) * (a_i plus the sum of all x_j for j < i).

Because each previous day's purchase increases the price for subsequent days.

So, if I denote x_i as the number of tickets bought on day i, then the total cost is:

sum_{i=1 to n} x_i * (a_i + sum_{j=1 to i-1} x_j)

And we have constraints:

- sum_{i=1 to n} x_i = k

- 0 <= x_i <= m for each i

Our goal is to minimize the total cost.

This looks like an optimization problem with constraints.

How to approach this?

One way is to consider dynamic programming, where we keep track of the number of tickets bought so far and the current price increment.

But with n up to 3e5 and k up to 1e9, a standard DP approach would be too slow.

So, perhaps there's a smarter way.

Let's consider that the price on day i is a_i plus the sum of all x_j for j < i.

So, if we fix the order of days, the price for each day depends on how many tickets we've already bought on previous days.

But maybe there's a way to sort the days in a certain order to minimize the total cost.

Let's think about it differently.

Suppose we fix the number of tickets bought on each day, x_i.

Then, the total cost is sum_{i=1 to n} x_i * (a_i + sum_{j=1 to i-1} x_j)

This can be rewritten as:

sum_{i=1 to n} x_i * a_i + sum_{i=1 to n} x_i * sum_{j=1 to i-1} x_j

= sum_{i=1 to n} x_i * a_i + sum_{i=1 to n} sum_{j=1 to i-1} x_i * x_j

This seems complicated.

Maybe there's another way.

Let me try to think about the incremental cost.

Suppose I have already bought s tickets up to day i-1.

Then, on day i, the price per ticket is a_i + s.

I can buy up to m tickets on day i.

So, the cost for buying x tickets on day i is x * (a_i + s).

Similarly, for day i+1, the price would be a_{i+1} + s + x.

So, it seems that buying more on earlier days increases the prices for later days.

Given that, perhaps it's better to buy on days when a_i is small, but considering the cumulative effect on future prices.

Wait, in the first example, buying on day 3 and day 4 was better than buying on day 1 and day 2.

Because the prices on day 3 and 4 are lower after accounting for the increases.

So, maybe I should sort the days in increasing order of a_i.

But I need to consider that buying on earlier days increases the prices for later days.

Wait, perhaps I should sort the days in increasing order of a_i minus the sum of x_j for j < i.

But that seems tricky.

Alternatively, perhaps I can sort the days based on a_i minus the number of tickets I'll buy on previous days.

Wait, this is getting complicated.

Let me try to think of a greedy approach.

Suppose I sort the days in increasing order of a_i.

Then, I try to buy as many tickets as possible on the days with the smallest a_i.

But, since buying on earlier days increases the prices for later days, I need to be careful.

Wait, perhaps I should sort the days in increasing order of a_i, and then buy as many tickets as possible on the days with the smallest a_i, considering the price increases.

But, actually, since the price on later days increases based on the number of tickets bought on previous days, it might not be straightforward.

Let me try to model this.

Suppose I sort the days in increasing order of a_i.

Let's say the sorted array is b_1 <= b_2 <= ... <= b_n.

But, I need to assign the number of tickets to buy on each day, considering the price increases.

This seems tricky.

Maybe I need to consider the days in sorted order and decide how many tickets to buy on each, keeping track of the cumulative sum.

Wait, perhaps I can think of it as a priority queue, where I always buy on the day with the smallest current price.

But, the current price changes based on previous purchases.

Wait, maybe I can model this with prefix sums.

Let me think differently.

Suppose I fix the days on which I buy tickets, and the number of tickets per day, respecting the constraints.

Then, the total cost is sum over i of x_i * (a_i + sum over j < i of x_j)

I need to minimize this.

This seems complex.

Maybe I can rearrange the terms.

Let me denote s_i = sum_{j=1 to i} x_j

Then, the total cost is sum_{i=1 to n} x_i * (a_i + s_{i-1})

Where s_0 = 0.

Given that s_i = s_{i-1} + x_i, so s_{i-1} = s_i - x_i

Wait, not helpful.

Alternatively, s_i is the cumulative sum up to day i.

So, the total cost is sum_{i=1 to n} x_i * (a_i + s_{i-1})

With s_0 = 0, and s_i = s_{i-1} + x_i

This is similar to sum_{i=1 to n} x_i * a_i + sum_{i=1 to n} x_i * s_{i-1}

This still seems tricky.

Maybe I can consider the Lagrange multipliers or some mathematical optimization technique, but that might be overkill.

Given the constraints, I need an efficient algorithm.

Let me consider that the price per ticket on day i is a_i plus the total number of tickets bought on previous days.

So, if I buy x_i tickets on day i, the cost is x_i * (a_i + sum_{j=1 to i-1} x_j)

I need to minimize the sum of these costs, given that sum_{i=1 to n} x_i = k and 0 <= x_i <= m for each i.

This looks like a linear assignment problem, but with a cumulative dependency.

Perhaps I can model this with prefix sums.

Let me try to think of it in terms of prefix sums.

Let s_i = sum_{j=1 to i} x_j

Then, s_i <= i*m

And s_n = k

Then, the cost is sum_{i=1 to n} x_i * (a_i + s_{i-1})

With s_0 = 0

I need to minimize this.

Wait, perhaps I can express s_{i-1} = s_i - x_i

Then, the cost becomes sum_{i=1 to n} x_i * (a_i + s_i - x_i) = sum_{i=1 to n} x_i * a_i + x_i * s_i - x_i^2

This seems even more complicated.

Maybe I need to consider the derivative with respect to x_i, but since x_i are integers, that might not help.

Alternatively, perhaps I can model this as a minimum cost flow problem, where each day is a node, and I have edges with capacities and costs.

But that might be too slow for n up to 3e5.

Wait, perhaps there's a way to sort the days and decide how many tickets to buy on each day in a greedy manner.

Let me consider sorting the days in increasing order of a_i.

Then, I can try to buy as many tickets as possible on the days with the smallest a_i, considering the price increases due to previous purchases.

But I need to be careful because buying on earlier days increases the prices for later days.

Wait, maybe I should consider buying on the days with the smallest a_i last, so that the price increases happen on days with higher a_i.

Wait, that might not make sense.

Let me think differently.

Suppose I have to buy k tickets in total.

Each ticket bought on day i costs a_i plus the number of tickets already bought on previous days.

So, the cost of the first ticket bought on any day is a_i, the second is a_i + x, where x is the number of tickets bought on previous days, and so on.

But this seems too vague.

Wait, perhaps I can think of it in terms of assigning tickets to days.

Each ticket has a cost based on the day it's bought and the number of tickets bought on previous days.

So, I need to assign k tickets to n days, with at most m tickets per day, minimizing the total cost.

This sounds like assigning tickets to days with certain costs.

Maybe I can model this as assigning tickets one by one, always choosing the day with the smallest current price.

But, since the price increases based on the number of tickets already bought on previous days, it's not straightforward.

Wait, perhaps I can use a priority queue to keep track of the current smallest price per ticket, considering the number of tickets already bought on each day.

But with n up to 3e5 and k up to 1e9, that might be too slow.

I need a smarter approach.

Let me consider that the price per ticket on day i is a_i plus the number of tickets bought on previous days.

So, if I buy x_i tickets on day i, their individual costs are a_i + s_{i-1}, a_i + s_{i-1} + 1, ..., a_i + s_{i-1} + x_i - 1, where s_{i-1} is the total tickets bought on previous days.

Wait, is that correct?

Actually, the problem says that buying x tickets on day i increases the price for subsequent days by x.

So, the price per ticket for day j > i is a_j + x.

It doesn't specify that each ticket bought on day i has a different price; it seems that all tickets bought on day i are at the same price of a_i plus the sum of x_j for j < i.

So, if s_{i-1} = sum_{j=1 to i-1} x_j, then the price per ticket on day i is a_i + s_{i-1}, and the cost for buying x_i tickets on day i is x_i * (a_i + s_{i-1}).

So, the total cost is sum_{i=1 to n} x_i * (a_i + s_{i-1})

With s_0 = 0 and s_i = s_{i-1} + x_i.

Given that, perhaps I can rearrange the terms.

Let me expand the total cost:

sum_{i=1 to n} x_i * a_i + sum_{i=1 to n} x_i * s_{i-1}

But s_{i-1} = sum_{j=1 to i-1} x_j

So, the total cost is sum_{i=1 to n} x_i * a_i + sum_{i=1 to n} x_i * sum_{j=1 to i-1} x_j

This seems difficult to optimize directly.

Maybe I can consider the dual problem or find some invariant.

Wait, perhaps I can consider the total cost in terms of the overall sum and the interactions between the variables.

Let me consider that sum_{i=1 to n} x_i * s_{i-1} = sum_{i=1 to n} x_i * sum_{j=1 to i-1} x_j

This can be rewritten as 1/2 * (sum_{i=1 to n} sum_{j=1 to i-1} x_i * x_j + sum_{i=1 to n} sum_{j=i to n} x_i * x_j) but that might not help.

Alternatively, perhaps I can consider that sum_{i=1 to n} x_i * s_{i-1} = sum_{i=1 to n} x_i * (s_i - x_i) = sum_{i=1 to n} x_i * s_i - sum_{i=1 to n} x_i^2

But s_i = sum_{j=1 to i} x_j

This seems messy.

Maybe I need to consider a different approach.

Let me consider that the total cost is sum_{i=1 to n} x_i * (a_i + sum_{j=1 to i-1} x_j)

I need to minimize this, given sum_{i=1 to n} x_i = k and 0 <= x_i <= m

Perhaps I can model this as a linear programming problem, but that's not practical for such large n and k.

Wait, maybe I can consider that the price per ticket on day i is a_i plus the total number of tickets bought on previous days, which is s_{i-1}.

So, the cost for day i is x_i * (a_i + s_{i-1})

I need to choose x_i for each i to minimize the total cost, with sum x_i = k and 0 <= x_i <= m

This seems similar to minimizing a quadratic function with linear constraints.

But I need an efficient algorithm.

Let me think about the greedy approach again.

Suppose I sort the days in increasing order of a_i.

Then, I can try to buy as many tickets as possible on the days with the smallest a_i, considering the price increases for later days.

But I need to be careful because buying on earlier days increases the prices for later days.

Wait, maybe I should sort the days in increasing order of a_i and buy as many tickets as possible on the days with the smallest a_i, but only after considering the price increases from previous purchases.

This is getting complicated.

Let me try to think differently.

Suppose I fix the number of tickets bought on each day, x_i.

Then, the total cost is sum_{i=1 to n} x_i * (a_i + sum_{j=1 to i-1} x_j)

I can think of this as sum_{i=1 to n} x_i * a_i + sum_{i=1 to n} x_i * sum_{j=1 to i-1} x_j

= sum_{i=1 to n} x_i * a_i + sum_{i=1 to n} sum_{j=1 to i-1} x_i * x_j

This seems like a quadratic form.

Maybe I can represent it as x^T A x, where x is the vector of x_i's and A is some matrix.

But I'm not sure if that helps.

Alternatively, perhaps I can consider the dual problem or use some optimization technique to find the minimum.

But that might be too time-consuming for the constraints.

Let me consider a different perspective.

Suppose I fix the total number of tickets bought up to each day, s_i.

Then, s_i = sum_{j=1 to i} x_j, with s_0 = 0 and s_n = k.

The cost is sum_{i=1 to n} x_i * (a_i + s_{i-1})

= sum_{i=1 to n} (s_i - s_{i-1}) * (a_i + s_{i-1})

= sum_{i=1 to n} (s_i * a_i + s_i * s_{i-1} - s_{i-1} * a_i - s_{i-1}^2)

This seems even more complicated.

Wait, perhaps I can think of this as a dynamic programming problem, where I keep track of the number of tickets bought up to each day and the corresponding cost.

But with n up to 3e5 and k up to 1e9, a standard DP approach would be too slow.

I need a more efficient way.

Let me consider that the price per ticket on day i is a_i plus the number of tickets bought on previous days, which is s_{i-1}.

So, the cost for day i is x_i * (a_i + s_{i-1})

I need to choose x_i for each i, with 0 <= x_i <= m and sum x_i = k, to minimize the total cost.

Perhaps I can sort the days in increasing order of a_i and prioritize buying on days with smaller a_i, but considering the price increases.

Wait, maybe I should sort the days in increasing order of a_i and buy as many tickets as possible on the days with the smallest a_i, but only after accounting for the price increases due to previous purchases.

Let me try this with the first example.

n = 4, m = 2, k = 3

a = [8, 6, 4, 2]

Sort a: [2, 4, 6, 8]

So, the days are ordered as day4, day3, day2, day1.

Now, I can try to buy tickets starting from the day with the smallest a_i.

Start with day4: a4 = 2

I can buy up to m = 2 tickets on day4.

But, if I buy x tickets on day4, then the price for day4 is x * (2 + s_{3}), where s_3 is the total tickets bought on days 1 to 3.

Wait, but in this ordering, day4 is last, so s_3 would include tickets bought on days1 to3.

This seems messy.

Alternatively, perhaps I can iterate through the sorted days and decide how many tickets to buy on each, keeping track of the cumulative sum.

Wait, perhaps I can think of it as assigning tickets to days in a way that minimizes the total cost, considering the price increases.

This is getting too vague.

Let me look for a different approach.

Suppose I fix the number of tickets bought on each day, x_i.

Then, the total cost is sum_{i=1 to n} x_i * (a_i + sum_{j=1 to i-1} x_j)

= sum_{i=1 to n} x_i * a_i + sum_{i=1 to n} x_i * sum_{j=1 to i-1} x_j

= sum_{i=1 to n} x_i * a_i + sum_{i=1 to n} sum_{j=1 to i-1} x_i * x_j

This seems difficult to minimize directly.

Maybe I can consider that the cost is a quadratic function in terms of x_i's, and try to find a way to minimize it efficiently.

But, given time constraints, I need a smarter way.

Let me consider that the problem can be transformed into selecting x_i's such that the total cost is minimized, with the constraints on x_i's.

Perhaps I can sort the days in increasing order of a_i and prioritize buying on days with smaller a_i, but considering the price increases due to previous purchases.

Wait, maybe I can use a priority queue to always buy tickets on the day with the smallest current price.

Initialize a priority queue with days sorted by a_i.

Then, repeatedly extract the day with the smallest a_i, buy as many tickets as possible on that day, update the prices for remaining days, and reinsert them into the queue.

But with n up to 3e5, this would be too slow.

I need a better way.

Let me consider that the price per ticket on day i is a_i plus the number of tickets already bought on previous days.

So, if I buy x_i tickets on day i, the cost is x_i * (a_i + number of tickets bought on days 1 to i-1).

I need to minimize the sum of these costs.

This seems similar to minimizing the sum of products of variables with their prefix sums.

Wait, perhaps I can model this using prefix sums.

Let me denote s_i = sum_{j=1 to i} x_j

Then, the cost is sum_{i=1 to n} x_i * (a_i + s_{i-1})

= sum_{i=1 to n} x_i * a_i + sum_{i=1 to n} x_i * s_{i-1}

This is the same as before.

I need to find a way to compute this efficiently.

Wait, perhaps I can consider that s_{i-1} is known when deciding x_i.

So, perhaps I can iterate through the days in a certain order and make decisions based on the current s_{i-1}.

But I'm stuck.

Let me look back at the example.

In the first test case:

n = 4, m = 2, k = 3

a = [8,6,4,2]

Optimal way:

- Day1: buy 0, s0 = 0, price = 8 + 0 = 8, but buy 0, so cost = 0

- Day2: buy 0, s1 = 0, price = 6 + 0 = 6, buy 0, cost = 0

- Day3: buy 1, s2 = 0, price = 4 + 0 = 4, cost = 4

- Day4: buy 2, s3 = 1, price = 2 + 1 = 3, cost = 6

Total cost = 10

Another way:

- Day1: buy 2, s0 = 0, price = 8 + 0 = 8, cost = 16

- Day2: buy 2, s1 = 2, price = 6 + 2 = 8, cost = 16

- Day3: buy 2, s2 = 4, price = 4 + 4 = 8, cost = 16

- Day4: buy 2, s3 = 6, price = 2 + 6 = 8, cost = 16

But we need to buy only 3 tickets, so this is invalid.

Wait, in this approach, buying on days with higher a_i can be more expensive, but buying on days with lower a_i can also be expensive due to the price increases.

I need to find a balance.

Wait, perhaps I can sort the days in increasing order of a_i and buy as few tickets as possible on the days with the smallest a_i, to minimize the price increases for later days.

Wait, that seems counterintuitive.

Wait, in the optimal solution, buying on the days with smaller a_i after accumulating s_{i-1}.

Wait, maybe I can sort the days in increasing order of a_i and buy as many tickets as possible on the days with the smallest a_i, but considering the price increases.

This is getting too tangled.

Let me try to think differently.

Suppose I fix the number of tickets bought on each day, x_i.

Then, the total cost is sum_{i=1 to n} x_i * (a_i + sum_{j=1 to i-1} x_j)

= sum_{i=1 to n} x_i * a_i + sum_{i=1 to n} x_i * sum_{j=1 to i-1} x_j

= sum_{i=1 to n} x_i * a_i + sum_{i=1 to n} sum_{j=1 to i-1} x_i * x_j

This seems difficult to minimize directly.

Maybe I can consider that the second term is the interaction between the number of tickets