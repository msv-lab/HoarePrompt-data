Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n possible outcomes in a game, and for each outcome, there's a multiplier k_i. I need to bet some integer amount x_i on each outcome. The goal is to set these bets such that no matter which outcome wins, the total coins I get back are more than the total coins I bet.

First, I need to understand the constraints. There are multiple test cases, each with a different number of outcomes, n, ranging from 1 to 50. Each outcome has a multiplier k_i, which is at least 2 and up to 20. The sum of n across all test cases doesn't exceed 200,000, but since n is up to 50 per test case, and t is up to 10,000, that sums up to 500,000, but the problem says it's guaranteed not to exceed 200,000.

So, for each test case, I have to either find a set of bets x_1 to x_n that are integers, at least 1, and up to 10^9, such that the sum of all x_i is less than k_i * x_i for each i. In other words, for every possible winning outcome, the amount I get back is more than what I bet in total.

Let me rephrase that condition. For each i from 1 to n, the sum of all x_j for j from 1 to n should be less than k_i * x_i.

Mathematically, for each i:

sum_{j=1 to n} x_j < k_i * x_i

I need to find x_i's that satisfy this for all i.

Hmm, this seems like a system of inequalities. I need to find integer values for x_i that make all these inequalities hold.

Let me consider what this means. For each i, the total sum of bets is less than k_i times the bet on i.

I can rearrange this inequality:

sum_{j=1 to n} x_j < k_i * x_i

which can be written as:

sum_{j ≠ i} x_j < (k_i - 1) * x_i

This seems useful. It shows that the sum of bets on all other outcomes should be less than (k_i - 1) times the bet on outcome i.

I need this to hold for every i.

This seems tricky. How can I choose x_i's such that for each i, the sum of the other bets is less than (k_i - 1)*x_i?

One approach might be to express x_i in terms of the other x_j's for each inequality and see if I can find a consistent set of values.

Alternatively, maybe there's a way to set up weights or use the least common multiple or something like that.

Let me think about the example given in the problem.

In the first test case:

n = 3

k = [3, 2, 7]

The solution provided is x = [27, 41, 12]

Let's check if this satisfies the conditions:

Total sum S = 27 + 41 + 12 = 80

For outcome 1:

k_1 * x_1 = 3 * 27 = 81 > 80

For outcome 2:

k_2 * x_2 = 2 * 41 = 82 > 80

For outcome 3:

k_3 * x_3 = 7 * 12 = 84 > 80

All conditions are satisfied.

Now, how did they arrive at 27, 41, and 12?

Is there a general method to find such x_i's?

Let me consider the inequalities again:

For each i:

sum_{j ≠ i} x_j < (k_i - 1) * x_i

I can write sum_{j ≠ i} x_j = S - x_i

So, S - x_i < (k_i - 1) * x_i

Which simplifies to:

S < k_i * x_i

But S is the sum of all x_j's, including x_i.

So, S = sum_{j=1 to n} x_j

So, S < k_i * x_i for all i.

I need to find x_i's such that for every i, S < k_i * x_i.

I can rearrange this to:

x_i > S / k_i

But since S = sum_{j=1 to n} x_j, this seems circular.

Wait, maybe I can use the idea of setting x_i proportional to some function of k_i.

Let me think about it differently.

Suppose I fix x_i's and compute S.

Then, for each i, I need S < k_i * x_i.

Which implies x_i > S / k_i

But x_i has to be an integer, so x_i >= ceil(S / k_i)

But S is the sum of all x_j's, which includes x_i.

This seems tricky because it's interdependent.

Maybe I can use the idea of setting x_i to be ceil(S / k_i), but since S depends on x_i, it's not straightforward.

Alternatively, perhaps I can use the idea of setting x_i to be a multiple of some base value.

Wait, maybe I can consider the product of all k_i's and set x_i proportional to the product divided by k_i.

Let me try that.

Let prod = product of all k_i's.

Then, set x_i = prod / k_i

Then, S = sum_{j=1 to n} (prod / k_j)

Now, for each i, S < k_i * x_i = k_i * (prod / k_i) = prod

So, S < prod

But S = sum_{j=1 to n} (prod / k_j)

So, sum_{j=1 to n} (prod / k_j) < prod

This seems promising.

Wait, does this hold?

Let's see:

sum_{j=1 to n} (prod / k_j) < prod

Divide both sides by prod:

sum_{j=1 to n} (1 / k_j) < 1

So, the condition is that the sum of reciprocals of k_i's is less than 1.

Is this always true for the given constraints?

Wait, no. For example, if n=1, k_1=2, then sum of reciprocals is 1/2 < 1.

If n=2, k1=2, k2=2, sum=1/2 + 1/2 = 1, which is not less than 1.

Wait, but in the problem, n can be from 1 to 50, and k_i from 2 to 20.

So, it's possible that sum of 1/k_j is greater than or equal to 1.

Looking back at the problem, in the second test case:

n=2, k=[3,3]

sum of reciprocals is 1/3 + 1/3 = 2/3 < 1

And indeed, they provided a solution: 1,1

Total sum S=2

Check conditions:

For outcome 1: 3*1=3 > 2

For outcome 2: 3*1=3 > 2

Which satisfies the condition.

In the third test case:

n=5, k=[5,5,5,5,5]

sum of reciprocals is 5*(1/5)=1, which is not less than 1.

And indeed, the output is -1, meaning no solution exists.

Ah, so the condition sum_{j=1 to n} (1 / k_j) < 1 seems to be necessary.

Wait, but in the first test case, k=[3,2,7]

sum of reciprocals: 1/3 + 1/2 + 1/7 = (14 + 21 + 6)/42 = 41/42 < 1

Which matches the solution provided.

In the second test case, k=[3,3]

sum: 1/3 + 1/3 = 2/3 < 1

Solution exists.

In the third test case, k=[5,5,5,5,5]

sum: 5*(1/5)=1, which is not less than 1

No solution exists.

In the fourth test case, k=[7,9,3,17,9,13]

sum: 1/7 + 1/9 + 1/3 + 1/17 + 1/9 + 1/13

Let's calculate:

1/3 ≈ 0.3333

1/7 ≈ 0.1429

1/9 ≈ 0.1111

1/13 ≈ 0.0769

1/17 ≈ 0.0588

Total sum: 0.3333 + 0.1429 + 0.1111 + 0.0769 + 0.1111 + 0.0588 ≈ 0.8341 < 1

Solution exists.

In the fifth test case, k=[6,3,2]

sum: 1/6 + 1/3 + 1/2 = 1/6 + 2/6 + 3/6 = 6/6 = 1

No solution exists.

In the sixth test case, k=[9,4,6,8,3]

sum: 1/9 + 1/4 + 1/6 + 1/8 + 1/3

Calculate:

1/3 ≈ 0.3333

1/4 = 0.25

1/6 ≈ 0.1667

1/8 = 0.125

1/9 ≈ 0.1111

Total sum: 0.3333 + 0.25 + 0.1667 + 0.125 + 0.1111 ≈ 0.9861 < 1

Solution exists.

So, it seems that the condition sum_{j=1 to n} (1 / k_j) < 1 is necessary for a solution to exist.

Moreover, the approach of setting x_i = prod / k_i seems to work when this condition holds.

In the first test case:

k=[3,2,7]

prod = 3*2*7=42

x1=42/3=14

x2=42/2=21

x3=42/7=6

Total sum S=14+21+6=41

Check conditions:

3*14=42 > 41

2*21=42 > 41

7*6=42 > 41

Which works.

But in the sample output, they have x=[27,41,12], which also works, but my calculation gives x=[14,21,6]. Both are valid as long as they satisfy the conditions.

So, the general approach seems to be:

- Compute sum of 1/k_j for all j.

- If this sum is greater than or equal to 1, output -1.

- Else, compute prod = product of all k_j.

- Set x_i = prod / k_i for each i.

- Output the x_i's.

This seems to be what the given program does.

Looking at the program:

def func():

t = int(input())

for T in range(t):

bets = int(input())

a = [int(x) for x in input().split()]

prod = 1

for i in range(bets):

prod *= a[i]

sumo = 0

for i in range(bets):

a[i] = prod // a[i]

sumo += int(a[i])

if sumo >= prod:

print(-1)

else:

ans = ''

for i in range(bets):

ans += str(a[i]) + ' '

print(ans)

Yes, it computes the product of all k_i's, sets x_i = prod // k_i, computes sumo = sum of x_i's, and checks if sumo >= prod. If it is, output -1; else, output the x_i's.

Wait, but according to my earlier reasoning, sumo should be less than prod for the condition to hold.

Wait, in the first test case, with k=[3,2,7], prod=42, x=[14,21,6], sumo=41, which is less than prod=42, and 41 < 42, which satisfies the condition.

In the second test case, k=[3,3], prod=9, x=[3,3], sumo=6 < 9, which is fine.

In the fourth test case, k=[7,9,3,17,9,13], prod=7*9*3*17*9*13 = huge number, but according to the sample output, x=[1989,1547,4641,819,1547,1071], which are prod//k_i for each k_i.

Wait, but in the third test case, k=[5,5,5,5,5], prod=5^5=3125, x_i=3125/5=625 for each, sumo=5*625=3125, which is equal to prod=3125, so sumo >= prod, so output -1, which matches the sample output.

Similarly, in the fifth test case, k=[6,3,2], prod=6*3*2=36, x=[6,12,18], sumo=6+12+18=36, which is equal to prod=36, so output -1.

In the sixth test case, k=[9,4,6,8,3], prod=9*4*6*8*3=5184, x=[576,1296,864,648,1728], sumo=576+1296+864+648+1728=5112 < 5184, which is fine.

So, the program seems to be correctly implementing this approach.

But is this the only possible solution? No, as shown in the first test case, [27,41,12] also works, but the program outputs [14,21,6], which also works. Since the problem allows any valid solution, this is acceptable.

Moreover, the program ensures that x_i's are integers, and within the constraints 1 <= x_i <= 10^9.

Given that prod can be up to 20^50, which is way beyond standard integer types, but since n is up to 50 and k_i up to 20, prod can be up to 20^50, which is approximately 3.7e64, but Python's integers can handle arbitrary sizes, so it's fine.

However, in practice, prod can be very large, but since the problem constraints ensure that n is up to 50 and k_i up to 20, and t is up to 10^4, but with the sum of n over all test cases up to 2e5, which seems contradictory because 10^4 test cases with n up to 50 would sum to 5e5, but the problem says it's guaranteed not to exceed 2e5.

Anyway, assuming valid inputs as per the problem description, the program should work correctly.

Edge cases to consider:

- n=1, k1=2

Then sum of reciprocals is 1/2 < 1, so solution exists.

x1 = prod / k1 = 2 / 2 = 1

Sumo=1 < prod=2, which is fine.

- n=1, k1=20

x1=20/20=1

Sumo=1 < prod=20, which is fine.

- n=2, k1=2, k2=2

sum of reciprocals=1/2 + 1/2=1, which is not less than 1, so output -1

- n=3, k=[2,3,7]

sum=1/2 + 1/3 + 1/7 ≈ 0.5 + 0.333 + 0.1429 ≈ 0.9759 < 1, solution exists.

prod=2*3*7=42

x=[21,14,6]

sumo=21+14+6=41 < 42, which is fine.

- n=4, k=[2,3,4,5]

sum=1/2 + 1/3 + 1/4 + 1/5 = 0.5 + 0.333 + 0.25 + 0.2 = 1.283, which is >1, so output -1

Wait, but according to the problem, if sum of reciprocals >=1, output -1.

In this case, sum>1, so output -1.

Wait, but according to my earlier reasoning, sum of reciprocals needs to be <1 for solution to exist.

Yes, in this case, sum>1, so no solution exists.

Wait, but in the problem, for n=5, k=[5,5,5,5,5], sum=1, which is not less than 1, so output -1.

Similarly, for n=3, k=[6,3,2], sum=1/6 + 1/3 + 1/2 =1, output -1.

So, the condition is sum of reciprocals <1 for solution to exist.

Hence, the program correctly implements this by checking if sumo >= prod.

Because sumo = sum_{j=1 to n} (prod / k_j)

And we need sumo < prod

Which is equivalent to sum_{j=1 to n} (1 / k_j) <1

Since sumo / prod = sum_{j=1 to n} (1 / k_j)

Therefore, sumo < prod iff sum_{j=1 to n} (1 / k_j) <1

Hence, the program correctly checks this condition.

Therefore, the program is correct.

**Final Answer**

\[ \boxed{\text{True}} \]