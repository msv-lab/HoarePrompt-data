Alright, I've got this interactive problem to solve. Let's see what it's asking for.

So, there's a secret permutation of numbers from 0 to n-1, and I need to find two indices i and j such that the XOR of p_i and p_j is maximized. I can ask up to 3n queries where I compare the OR of two elements with the OR of another two elements.

First, I need to understand what XOR and OR operations do. XOR gives me the bits that are different between two numbers, and OR gives me the bits that are set in either of the two numbers.

My goal is to maximize p_i XOR p_j. To maximize XOR, I want p_i and p_j to differ in the highest possible bit positions.

Given that p is a permutation of 0 to n-1, all values are unique, and I need to find which two values differ the most in terms of XOR.

Now, I need to figure out how to use the queries effectively to find this pair.

Let's think about the properties of OR and XOR.

If I have two numbers, a and b, their OR will have all bits set that are set in either a or b. Their XOR will have bits set where a and b differ.

To maximize XOR, I need a and b to differ in as many high-order bits as possible.

Perhaps I can find the maximum and minimum values in the permutation, or something like that.

Wait, but it's a permutation, so all values from 0 to n-1 are present, and n can be up to 10^4, with t up to 10^3, and the total sum of n over all test cases is up to 10^4.

I need an efficient way to find the pair with maximum XOR.

Let me think about the properties of XOR in a permutation from 0 to n-1.

For example, if n is a power of two, the maximum XOR might be n-1, but I need a general solution.

Wait, actually, for any n, the maximum possible XOR between any two numbers in 0 to n-1 is achieved by two numbers that differ in the highest set bit of n-1.

For instance, if n=4 (binary 100), the maximum XOR is between 011 (3) and 100 (4), which is 111 (7).

Wait, but n=4 includes numbers 0,1,2,3. So, 2 and 3 XOR to 1, 1 and 3 XOR to 2, 0 and 3 XOR to 3, which is the maximum.

So, in this case, the maximum XOR is 3.

Wait, but 1 and 2 XOR to 3, which is higher.

So, in general, to maximize XOR, I need to select two numbers that differ in the highest possible bit positions.

Given that, perhaps I can find the highest bit where not all numbers in the permutation have the same bit value.

Start from the most significant bit and find the first bit where there are numbers with that bit set and not set.

Then, select one number with that bit set and one with that bit not set.

Wait, but I don't have direct access to the numbers, only through queries.

I need to find a way to identify such numbers through comparisons of ORs.

This seems tricky.

Let's look at the reference solution provided.

In the reference solution, there's a function func() that seems to handle multiple test cases.

For each test case, it reads n, then proceeds to find a 'mak' index through a series of queries.

First, it initializes mak to 0.

Then, for each i from 1 to n-1, it asks a query comparing (mak OR mak) with (i OR i).

Wait, but (mak OR mak) is just p_mak, and (i OR i) is p_i.

So, it's essentially comparing p_mak with p_i.

By doing this, it's trying to find the maximum p_i, because if p_i > p_mak, it sets mak to i.

So, after this loop, mak should be the index of the maximum value in p.

Then, it sets mak2 to mak, which is the index of the maximum p_i.

Next, it initializes pans as an empty list.

Then, for each i from 0 to n-1, it asks a query comparing (mak OR mak2) with (i OR mak2).

But mak and mak2 are both the index of the maximum p_i, so (mak OR mak2) is p_mak | p_mak2, which is p_mak | p_mak, which is p_mak.

Similarly, (i OR mak2) is p_i | p_mak.

So, it's comparing p_mak with p_i | p_mak.

If p_mak < p_i | p_mak, it sets mak to i and sets pans to [i].

Else if p_mak == p_i | p_mak, it appends i to pans.

Wait, what does p_mak < p_i | p_mak mean?

Let's think about p_i | p_mak.

If p_i has any bit not set in p_mak, it will set that bit in p_mak.

So, p_i | p_mak >= p_mak.

If p_i | p_mak > p_mak, it means that p_i has some bit not set in p_mak.

Otherwise, p_i | p_mak == p_mak, which means p_i is a subset of p_mak in terms of bits.

So, in this loop, it's finding all i where p_i | p_mak == p_mak, which are the ones where p_i is a subset of p_mak's bits.

And it's setting mak to i where p_i | p_mak > p_mak, which are the ones that add new bits to p_mak.

Wait, but in the code, if s == '<', it sets mak = i and pans = [i].

But p_mak < p_i | p_mak.

But p_i | p_mak >= p_mak, so p_mak < p_i | p_mak means p_i | p_mak > p_mak.

Similarly, if p_mak == p_i | p_mak, it appends i to pans.

After this loop, pans should contain all i where p_i | p_mak == p_mak, meaning p_i is a subset of p_mak's bits.

And mak is set to the last i where p_i | p_mak > p_mak.

Wait, but in the code, it sets mak to i and pans = [i] only when p_mak < p_i | p_mak.

Wait, but p_i | p_mak >= p_mak, so p_mak < p_i | p_mak means p_i | p_mak > p_mak.

So, it's finding i where p_i | p_mak > p_mak.

Then, it seems like it's trying to find i where p_i has some bit not present in p_mak.

After that, it seems to find the maximum among pans, which are the i where p_i | p_mak == p_mak.

Wait, but pans are the ones where p_i is a subset of p_mak's bits.

Then, it finds the maximum among pans, which are the ones that don't add any new bits to p_mak.

Finally, it prints '! mak2 pans[mak]', which is the pair of indices mak2 and the one with the maximum value among pans.

Wait, but mak2 is the index of the maximum p_i, and pans are the ones where p_i is a subset of p_mak's bits.

I'm a bit confused about the logic here.

Let me try to understand what the reference solution is doing.

First, it finds mak, which is the index of the maximum p_i.

Then, it finds all i where p_i | p_mak == p_mak, meaning p_i <= p_mak.

Among these, it selects the one with the maximum p_i.

Finally, it outputs the pair (mak2, pans[mak]), where mak2 is the index of the maximum p_i, and pans[mak] is the index of the maximum p_i among those that are <= p_mak.

Wait, but p_mak is already the maximum p_i, so p_i <= p_mak for all i.

Therefore, pans should include all i, because p_i | p_mak == p_mak for all i.

Wait, no, only those i where p_i <= p_mak will have p_i | p_mak == p_mak.

But since p_mak is the maximum, p_i <= p_mak for all i, so pans should include all i.

Wait, but in the first loop, mak is set to the index of the maximum p_i.

Then, in the second loop, for each i, it compares p_mak with p_i | p_mak.

Since p_mak is the maximum, p_i | p_mak >= p_mak.

If p_i | p_mak > p_mak, it means p_i has some bit not in p_mak, but since p_mak is the maximum, this should not happen, because p_i <= p_mak.

Wait, but p_i | p_mak > p_mak would imply p_i has some bit not in p_mak, which would make p_i | p_mak > p_mak.

But since p_mak is the maximum, p_i <= p_mak, so p_i | p_mak should be equal to p_mak.

Therefore, in this case, pans should include all i, because p_i | p_mak == p_mak for all i.

Then, in the next loop, it finds the maximum among pans, which is just finding the maximum p_i among all i, which is p_mak.

So, it's essentially outputting (! mak2 mak), where mak2 and mak are both the index of the maximum p_i.

But this doesn't make sense, because p_mak XOR p_mak is 0, which is not the maximum possible XOR.

Wait, maybe I'm misunderstanding something.

Let me look back at the example in the problem statement.

In the first test case, n=4, and the hidden permutation is [0,3,1,2].

So, p_0=0, p_1=3, p_2=1, p_3=2.

The maximum p_i is 3, at index 1.

So, mak=1.

Then, for each i from 0 to 3, it compares p_mak=3 with p_i | p_mak.

For i=0: p_0 | p_mak = 0 | 3 = 3 == p_mak, so pans=[0]

For i=1: p_1 | p_mak = 3 | 3 = 3 == p_mak, so pans=[0,1]

For i=2: p_2 | p_mak = 1 | 3 = 3 == p_mak, so pans=[0,1,2]

For i=3: p_3 | p_mak = 2 | 3 = 3 == p_mak, so pans=[0,1,2,3]

Then, it finds the maximum among pans, which is index 3 (p_3=2).

Finally, it outputs ! 1 3, which corresponds to p_1=3 and p_3=2, whose XOR is 3 XOR 2 = 1.

But in the explanation, it says that (p_3 XOR p_2) = (2 XOR 1) = 3 is the maximum.

Wait, 2 XOR 1 is actually 3.

Yes, 2 (binary 10) XOR 1 (binary 01) = 11 (3).

So, in this case, it's correct.

But according to my earlier reasoning, pans should include all i, and it selects mak=3, and outputs ! 1 3, which is correct.

Wait, but earlier I thought that p_mak XOR p_mak is 0, but in this case, p_mak is 3, and pans[mak] is 2, so 3 XOR 2 = 3, which is correct.

So, perhaps the logic is correct in this specific case, but is it generally correct?

Let me think about another example.

Suppose n=3, and p=[0,1,2].

The maximum p_i is 2, at index 2.

Then, for each i:

i=0: p_0 | p_2 = 0 | 2 = 2 == p_2, so pans=[0]

i=1: p_1 | p_2 = 1 | 2 = 3 > p_2, so mak=1, pans=[1]

i=2: p_2 | p_2 = 2 | 2 = 2 == p_2, so pans=[1,2]

Then, it finds the maximum among pans=[1,2].

It compares p_1 and p_2.

It asks ? 1 1 2 2.

It gets p_1 | p_1 =1 < p_2 | p_2 =2, so '<', so mak=1.

Then, it outputs ! 2 1, which is p_2=2 and p_1=1, XOR is 3, which is correct.

Another example: n=2, p=[0,1].

mak=1.

For i=0: p_0 | p_1 =0 |1=1 == p_1, so pans=[0,1]

Then, find the maximum among pans=[0,1].

Ask ? 0 1 1 1.

p_0 | p_1 =0 |1=1 == p_1 | p_1=1, so '=', mak remains 0.

So, outputs ! 1 0, which is correct, since 1 XOR 0=1.

Seems correct.

Another test: n=5, p=[0,1,2,3,4].

mak=4.

For i=0: p_0 | p_4 =0|4=4 == p_4, pans=[0]

i=1: p_1 | p_4 =1|4=5 >4, mak=1, pans=[1]

i=2: p_2 | p_4 =2|4=6 >4, mak=2, pans=[2]

i=3: p_3 | p_4 =3|4=7 >4, mak=3, pans=[3]

i=4: p_4 | p_4 =4|4=4 == p_4, pans=[3,4]

Then, find the maximum among pans=[3,4].

Ask ? 3 3 4 4.

p_3 | p_3=3 < p_4 | p_4=4, so '<', mak=4.

Output ! 4 4, which is p_4=4 XOR p_4=4=0, which is incorrect.

Wait, but the maximum XOR should be between p_3=3 and p_4=4, which is 7.

But the code outputs ! 4 4, which is incorrect.

Wait, according to the code, it should output ! mak2 pans[mak], where mak2=4, and pans=[3,4], and mak=4 (since p_4 > p_3 in the comparison).

But in this case, p_4 | p_4 =4 == p_4, and p_3 | p_4=3|4=7 >4, but in the loop, p_3 | p_4 > p_4, so mak=3, pans=[3]

Then, for i=4: p_4 | p_4=4 == p_4, so pans=[3,4]

Then, in the next loop, it compares p_3 and p_4.

Ask ? 3 3 4 4.

p_3 | p_3=3 < p_4 | p_4=4, so '<', so mak=4.

So, pans[mak]=pans[4], but pans has only indices 3 and 4, so pans[4] is p_4.

But in the list pans=[3,4], mak=1 (since pans[1]=4), assuming mak is set to 1.

Wait, I'm getting confused.

Let me look at the code again.

After the loop, mak is set to the index of the maximum in pans.

But pans is a list of indices, and mak is set based on comparisons within pans.

Wait, perhaps I need to trace the code more carefully.

In the second loop, for each i, it compares ? mak mak i mak2

Wait, no, it's ? mak mak2 i mak2

Wait, mak and mak2 are both the index of the maximum p_i initially.

Wait, in the first test case, mak=3, mak2=3, but in the explanation, mak2=2.

Wait, no, in the first test case in the explanation, mak=3, mak2=2.

Wait, perhaps there's a mistake in the explanation or in my understanding.

Looking back at the code:

mak2 = mak

Then, for i in range(n):

print('? mak mak2 i mak2')

Wait, but in the first test case, mak=3, mak2=3.

Then, for i=0: ? 3 3 0 3 -> (p_3 | p_3)=2 | 2=2 vs (p_0 | p_3)=0 | 2=2 -> '='

i=1: ? 3 3 1 3 -> 2 | 2=2 vs p_1 | p_3=3 | 2=3 -> '<'

So, p_1 | p_3=3 > p_3 | p_3=2, so mak=1, pans=[1]

i=2: ? 3 1 2 1 -> (p_3 | p_1)=2 | 3=3 vs (p_2 | p_1)=1 | 3=3 -> '=' pans=[1,2]

i=3: ? 3 1 3 1 -> (p_3 | p_1)=3 vs (p_3 | p_1)=3 -> '=' pans=[1,2,3]

Then, find the maximum among pans=[1,2,3]

Ask ? 1 1 2 2 -> (p_1 | p_1)=3 vs (p_2 | p_2)=1 -> '>' so mak=1

Ask ? 1 1 3 3 -> (p_1 | p_1)=3 vs (p_3 | p_3)=2 -> '>' so mak=1

So, outputs ! 3 1, which is correct.

Wait, but in my earlier n=5 example, it seemed to go wrong, but maybe I messed up the tracing.

Let me try n=5, p=[0,1,2,3,4]

First, find mak:

Start with mak=0, p_mak=0

i=1: ? 0 0 1 1 -> p_0 | p_0=0 < p_1 | p_1=1 -> '<', mak=1

i=2: ? 1 1 2 2 -> 1 < 2 -> '<', mak=2

i=3: ? 2 2 3 3 -> 2 < 3 -> '<', mak=3

i=4: ? 3 3 4 4 -> 3 < 4 -> '<', mak=4

So, mak=4, p_mak=4

Then, mak2=4

Now, for each i:

i=0: ? 4 4 0 4 -> p_4 | p_4=4 vs p_0 | p_4=0|4=4 -> '=' pans=[0]

i=1: ? 4 4 1 4 -> 4 vs 1|4=5 -> '<' mak=1, pans=[1]

i=2: ? 1 4 2 4 -> p_1 | p_4=1|4=5 vs p_2 | p_4=2|4=6 -> '<' mak=2, pans=[2]

i=3: ? 2 4 3 4 -> p_2 | p_4=6 vs p_3 | p_4=3|4=7 -> '<' mak=3, pans=[3]

i=4: ? 3 4 4 4 -> p_3 | p_4=7 vs p_4 | p_4=4 -> '>' pans=[3,4]

Then, find the maximum among pans=[3,4]

Ask ? 3 3 4 4 -> p_3 | p_3=3 vs p_4 | p_4=4 -> '<' so mak=4

Ask ? 3 4 4 4 -> p_3 | p_4=7 vs p_4 | p_4=4 -> '>' so mak=3

Wait, I'm getting confused.

In the code, after setting pans, it finds the maximum among pans by comparing p_pans[mak] with p_pans[i].

But in this tracing, it seems to set mak=4 initially, then compare p_3 and p_4.

If p_3 | p_3 =3 < p_4 | p_4=4, so '<', set mak=4.

Then, output ! 4 4, which is incorrect, since p_4 XOR p_4=0, but the maximum XOR is p_3 XOR p_4=7.

So, perhaps the code is incorrect in this case.

Wait, but according to the earlier examples, it worked.

Maybe there's a flaw in this approach.

Let me think differently.

I need to find two numbers with maximum XOR.

In a permutation of 0 to n-1, the maximum XOR is achieved by two numbers that differ in the highest possible bits.

One way to find this is to find the two numbers that have the highest values, but that's not always correct.

Wait, in binary numbers, to maximize XOR, you want the numbers to differ in the most significant bit possible.

So, find the highest bit where not all numbers have the same bit value.

Then, select one number with that bit set and one with it not set.

But in this problem, I don't have direct access to the numbers, only through comparisons.

Alternatively, since n can be up to 10^4 and t up to 10^3, with sum of n over all test cases up to 10^4, I need an efficient solution.

Perhaps I can find the position of the highest set bit in any of the p_i and use that to partition the numbers.

But again, without direct access, it's tricky.

Looking back at the reference solution, it seems to find the maximum p_i and then find another p_i that, when OR'ed with p_mak, gives a value greater than p_mak.

Wait, but in the n=5 example, p_mak=4.

Then, p_i | p_mak > p_mak means p_i has some bit not in p_mak.

In p_mak=4 (100 in binary), p_i needs to have a bit not in p_mak to make p_i | p_mak > p_mak.

For example, p_i=1 (001), p_i | p_mak=1|4=5 (>4)

p_i=2 (010), p_i | p_mak=2|4=6 (>4)

p_i=3 (011), p_i | p_mak=3|4=7 (>4)

p_i=0 (000), p_i | p_mak=0|4=4 (=4)

So, pans would include i=0 and i=4, since p_0 | p_mak=4= p_mak, and p_4 | p_mak=4= p_mak.

Then, among pans=[0,4], it finds the maximum p_i, which is p_4=4.

Then, it outputs ! mak2 pans[mak], which is ! 4 4, which is incorrect.

But in the earlier examples, it worked.

So, perhaps it's just luck in those cases.

In the first test case, n=4, p=[0,3,1,2], mak=1 (p_1=3), mak2=1.

Then, for i=0: ? 1 1 0 1 -> p_1 | p_1=3 vs p_0 | p_1=0|3=3 -> '=' pans=[0]

i=1: ? 1 1 1 1 -> 3 == 3 -> '=' pans=[0,1]

i=2: ? 1 1 2 1 -> 3 vs 1|3=3 -> '=' pans=[0,1,2]

i=3: ? 1 1 3 1 -> 3 vs 2|3=3 -> '=' pans=[0,1,2,3]

Then, find the maximum among pans=[0,1,2,3]

Ask ? 1 1 2 2 -> p_1 | p_1=3 > p_2 | p_2=1 -> '>' mak=1

Ask ? 1 1 3 3 -> p_1 | p_1=3 > p_3 | p_3=2 -> '>' mak=1

So, outputs ! 1 1, which is p_1=3 XOR p_1=3=0, which is incorrect.

But in the explanation, it outputs !3 2, which is correct.

Wait, perhaps there's a mistake in the reference solution.

Looking back, in the first test case, the explanation says output is !3 2, but according to the code, it should output ! mak2