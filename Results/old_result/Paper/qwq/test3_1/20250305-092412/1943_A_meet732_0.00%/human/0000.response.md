Alright, I have this problem to solve. It involves a game between Alice and Bob on an array of integers, and I need to determine the final score of the game based on their optimal plays. Let's break down the problem step by step.

First, understanding the game mechanics:

1. There's an array `a` of size `n`, and Alice starts with an empty array `c`.

2. Players take turns, with Alice going first.

3. On Alice's turn, she picks one element from `a`, appends it to `c`, and deletes it from `a`.

4. On Bob's turn, he picks one element from `a`, deletes it from `a`, but does not add it to `c`.

5. The game ends when `a` is empty, and the score is the MEX of `c`, which is the smallest non-negative integer not present in `c`.

6. Alice wants to maximize the MEX, while Bob wants to minimize it.

Given that, I need to find out what the final MEX will be if both play optimally.

Let's consider what MEX actually means. MEX is the smallest missing non-negative integer in the array `c`. So, if `c` contains all numbers from 0 to k, except for some number m, then MEX would be m if m < k, or k if all numbers up to k are present.

Given that Alice wants to maximize MEX and Bob wants to minimize it, their strategies will be opposed. Alice will try to include numbers in `c` that help achieve a higher MEX, while Bob will try to prevent that by removing elements that could help Alice.

I need to think about how the game progresses. Since Alice can choose which elements to include in `c`, and Bob can choose which to remove, their choices will affect the final composition of `c`.

Let me consider some examples to get a better understanding.

Example 1:

Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Output:

2

1

0

Let's analyze the first test case:

n = 4

a = [0, 0, 1, 1]

Possible moves:

- Alice chooses 1, a becomes [0,0,1], c = [1]

- Bob chooses 0, a becomes [0,1], c = [1]

- Alice chooses 0, a becomes [1], c = [1,0]

- Bob chooses 1, a becomes empty, c = [1,0]

MEX of [1,0] is 2, which matches the sample output.

Another possible sequence:

- Alice chooses 0, a becomes [0,1,1], c = [0]

- Bob chooses 0, a becomes [1,1], c = [0]

- Alice chooses 1, a becomes [1], c = [0,1]

- Bob chooses 1, a becomes empty, c = [0,1]

MEX is still 2.

Seems like regardless of their choices, MEX is 2.

Wait, but Bob could try to minimize MEX. Let's see:

- Alice chooses 0, a = [0,1,1], c = [0]

- Bob chooses 1, a = [0,1], c = [0]

- Alice chooses 1, a = [0], c = [0,1]

- Bob chooses 0, a = empty, c = [0,1]

Again, MEX is 2.

Is there a way for Bob to force a lower MEX? Let's see:

- Alice chooses 1, a = [0,0,1], c = [1]

- Bob chooses 1, a = [0,0], c = [1]

- Alice chooses 0, a = [0], c = [1,0]

- Bob chooses 0, a = empty, c = [1,0]

Still MEX 2.

It seems hard for Bob to get a lower MEX than 2 in this case.

Let's look at the second test case:

n = 4

a = [0,1,2,3]

Possible moves:

- Alice chooses 0, a = [1,2,3], c = [0]

- Bob chooses 1, a = [2,3], c = [0]

- Alice chooses 2, a = [3], c = [0,2]

- Bob chooses 3, a = empty, c = [0,2]

MEX of [0,2] is 1.

Alternatively:

- Alice chooses 3, a = [0,1,2], c = [3]

- Bob chooses 0, a = [1,2], c = [3]

- Alice chooses 1, a = [2], c = [3,1]

- Bob chooses 2, a = empty, c = [3,1]

MEX of [3,1] is 0.

Wait, but the sample output is 1. So perhaps the first sequence is the one that happens.

It seems that depending on the choices, different MEX can be achieved. Since both play optimally, we need to find the equilibrium where Alice maximizes and Bob minimizes.

I need a better approach than just trying out sequences.

Let's think in terms of available moves and what each player can control.

Key points:

- Alice can choose which elements go into `c`.

- Bob can remove elements from `a`, potentially preventing Alice from getting certain numbers into `c`.

- The game alternates between Alice and Bob, with Alice starting.

- The total number of moves is `n`, with Alice making ceil(n/2) moves (since she starts and they alternate).

- Bob makes floor(n/2) moves.

Wait, no. Since Alice starts and they alternate, if `n` is even, both make `n/2` moves. If `n` is odd, Alice makes (n+1)/2 moves, Bob makes (n-1)/2 moves.

But more importantly, Alice chooses elements to add to `c`, and Bob chooses elements to remove from `a`.

Wait, but Bob doesn't add to `c`; he just removes from `a`.

So, the elements in `c` are solely decided by Alice's choices.

Wait, but in the process, Bob is also removing elements, so Alice has to choose which elements to include in `c` considering that Bob can remove some elements.

Wait, but Bob can remove any element, including those that Alice hasn't chosen yet.

This seems tricky.

Let me think differently.

Suppose we have to find the minimal MEX that Alice can achieve against Bob's opposition.

Wait, no. Alice wants to maximize MEX, Bob wants to minimize it.

Wait, actually, the problem says Alice wants to maximize the MEX, Bob wants to minimize it.

But MEX is determined by the final content of `c`, which is built by Alice's choices.

Wait, but Bob can influence which elements are available for Alice to choose.

Wait, no. Bob can remove elements from `a`, which reduces the pool of elements Alice can choose from.

So, Bob can prevent Alice from having certain elements in `c` by removing them before Alice can choose them.

So, it's a game where Alice tries to select elements to maximize MEX, and Bob tries to hinder her by removing elements that could help her achieve a higher MEX.

I need to model this game to find out the final MEX when both play optimally.

Let me consider that MEX is the smallest non-negative integer not present in `c`.

So, to maximize MEX, Alice wants `c` to contain as many low numbers as possible.

Conversely, Bob wants to minimize MEX, so he wants to ensure that some low numbers are missing from `c`.

Given that, Bob can try to remove elements that Alice needs to achieve a higher MEX.

Let me consider that the game is about selecting a subset `c` of size ceil(n/2), since Alice makes ceil(n/2) choices.

But it's not just about the size; it's about which elements she chooses.

Wait, perhaps I can think in terms of available counts of each number.

Let's count how many times each number appears in `a`.

Let’s denote cnt[i] as the count of number i in `a`.

Now, Alice and Bob will be picking elements from `a` turn by turn.

Alice wants to include elements in `c` to maximize MEX, while Bob wants to disrupt this by removing elements that could help Alice.

I need to find out which numbers will be in `c` at the end and then compute the MEX.

This seems complex. Maybe there's a smarter way.

Let me consider that Alice can choose which elements go into `c`, and Bob can prevent some elements from being chosen by removing them.

So, for each number that Alice wants in `c`, Bob can try to remove it before Alice can choose it.

But if Alice has multiple turns, she can choose different elements.

I need to think in terms of the availability of elements over the course of the game.

Wait, perhaps it's better to think in terms of the minimal set of numbers that Alice needs to include in `c` to achieve a certain MEX.

For example, to achieve MEX = k, Alice needs to have all numbers from 0 to k-1 in `c`.

So, to maximize MEX, Alice needs to collect as many low numbers as possible.

Bob, to minimize MEX, will try to prevent Alice from collecting some low numbers.

So, for each number from 0 to some k, Bob will try to make sure that Alice doesn't get all of them.

Alice needs to ensure that she can get enough of them despite Bob's interference.

This sounds like a game where I need to calculate the minimal MEX that Alice can achieve given Bob's opposition.

Wait, but Alice wants to maximize MEX, Bob wants to minimize it.

Wait, actually, the final score is the MEX of `c`, Alice wants to maximize it, Bob wants to minimize it.

Given that, I need to find the equilibrium where both play optimally.

Let me consider that the game is a zero-sum game, and I can use some game theory to find the optimal outcome.

But that might be too involved for this problem.

Let me think differently.

Suppose I try to find out which numbers Alice can include in `c` no matter how Bob plays.

If Alice can guarantee that she can include certain numbers in `c`, then she can aim for a higher MEX.

Conversely, Bob can try to prevent Alice from including certain numbers.

So, for each number i, I need to determine if Alice can include it in `c` despite Bob's attempts to remove it.

If Alice can include all numbers from 0 to k-1 in `c`, then MEX would be k.

She wants to maximize k, Bob wants to minimize it.

So, I need to find the maximal k such that Alice can include all numbers from 0 to k-1 in `c`, even when Bob tries to prevent it.

Alternatively, Bob wins if he can ensure that at least one number from 0 to k-1 is missing from `c`.

So, for a given k, if Alice can collect all numbers from 0 to k-1 in `c`, then MEX is at least k.

Bob needs to prevent that.

To model this, perhaps I can think in terms of the number of turns Alice needs to collect all numbers from 0 to k-1.

Given that, for each number i from 0 to k-1, the number of times it appears in `a` is cnt[i].

Alice needs to collect one of each of these numbers.

Bob can try to remove these numbers to make it harder for Alice.

I need to find out if Alice can collect all of them given that Bob is trying to prevent her.

Let’s think in terms of the minimal number of turns Alice needs to collect all required numbers.

Wait, perhaps it's better to think in terms of the number of times Alice can pick elements before Bob can remove enough to stop her.

This seems complicated.

Let me look for a pattern or a mathematical way to compute this.

Looking back at the sample inputs:

First test case:

n=4

a=[0,0,1,1]

Output:2

Second test case:

n=4

a=[0,1,2,3]

Output:1

Third test case:

n=2

a=[1,1]

Output:0

Let's see if I can find a pattern.

In the first test case, counts:

0:2, 1:2

To achieve MEX=2, Alice needs to have 0 and 1 in `c`.

Given that both appear twice, even if Bob removes one of each, Alice can still choose one of each.

Hence, MEX=2.

In the second test case:

counts:

0:1,1:1,2:1,3:1

To achieve MEX=1, Alice needs to have 0 in `c`.

Bob can try to prevent this by removing 0, but since Alice goes first, she can choose 0 and add it to `c`.

If Alice chooses 0 first, c=[0], a=[1,2,3]

Then Bob removes one, say 1, a=[2,3]

Alice chooses 2, c=[0,2], a=[3]

Bob removes 3, a=[]

MEX of [0,2] is 1.

Alternatively, if Alice chooses 1 first, c=[1], a=[0,2,3]

Bob removes 0, a=[2,3]

Alice chooses 2, c=[1,2], a=[3]

Bob removes 3, a=[]

MEX of [1,2] is 0.

So, depending on Alice's choices, MEX can be 0 or 1.

Since Alice wants to maximize, she would choose to make MEX=1.

Hence, the output is 1.

In the third test case:

n=2

a=[1,1]

counts:

1:2

To achieve MEX=0, Alice needs to have 0 in `c`, but there is no 0 in `a`.

Hence, MEX=0.

Wait, but according to the definition, MEX is the smallest non-negative integer not in `c`.

If c contains 1, then MEX is 0.

If c contains nothing, MEX is 0.

Wait, in this case, Alice starts and chooses one 1, c=[1], a=[1]

Bob removes one, a=[]

So, c=[1], MEX=0.

Hence, output is 0.

Ok, that makes sense.

From these examples, it seems that the MEX depends on whether Alice can include certain numbers in `c` based on their frequencies and the number of turns.

Let me try to generalize this.

Suppose I have counts for each number from 0 to n.

Alice wants to include as many low numbers as possible in `c`.

Bob wants to prevent that.

Given that, for each number i, the number of times it appears in `a` is cnt[i].

Alice needs to collect at least one of each i from 0 to k-1 to achieve MEX=k.

Bob can try to remove these i's to prevent Alice from collecting them.

I need to find the maximal k such that, for all i from 0 to k-1, the number of times i appears in `a` is more than what Bob can remove.

In other words, for each i from 0 to k-1, cnt[i] > floor((n - cnt[i])/2)

Wait, that might not be accurate.

Let me think differently.

Total number of turns: n

Alice's turns: ceil(n/2)

Bob's turns: floor(n/2)

Alice needs to collect k numbers (from 0 to k-1), each at least once.

Bob can remove elements, trying to prevent Alice from collecting all of them.

For each number i from 0 to k-1, the number of times it appears in `a` is cnt[i].

Bob can remove up to floor(n/2) elements.

But he can choose which elements to remove.

He will try to remove elements that are critical for Alice, i.e., the ones she needs to achieve MEX=k.

So, for each i from 0 to k-1, if cnt[i] == 1, Bob can remove it, and Alice cannot collect it.

If cnt[i] >= 2, then Alice can ensure to collect at least one, because even if Bob removes one, there's still one left for Alice to choose.

Wait, but Bob can remove elements in his turns, and Alice chooses elements in her turns.

So, if cnt[i] >= 2, Alice can choose one, and even if Bob removes one, Alice has already chosen one.

Wait, no. The sequence of moves matters.

Suppose cnt[i] = 2.

Alice chooses one, c = [i], a = [i]

Bob removes one, a = []

So, c = [i]

Alice successfully includes i in c.

Similarly, if cnt[i] = 1:

Alice chooses it, c = [i], a = []

Bob has no move.

MEX is determined by c.

Wait, but if Bob can remove it before Alice chooses it, then it doesn't go to c.

Wait, no, Bob removes after Alice's choice.

Wait, let's clarify the sequence:

- Alice chooses an element from a, appends it to c, and deletes it from a.

- Bob chooses an element from a, deletes it from a.

They alternate, with Alice starting.

So, in each turn, Alice chooses and adds to c, then Bob removes one.

Unless a becomes empty before both have moved.

Wait, with n elements, Alice makes ceil(n/2) choices, Bob makes floor(n/2) removals.

The sequence is:

- Alice chooses and adds to c.

- Bob removes one.

- Repeat until a is empty.

So, for each element Alice adds to c, Bob can remove one.

But Alice chooses first.

Given that, for Alice to include a particular i in c, she needs to choose it before Bob can remove it.

But Bob can remove any element, not necessarily the one Alice chose.

Wait, but Bob removes after Alice chooses and removes the chosen element.

Wait, let's think carefully.

Initial array a.

Turn 1: Alice chooses an element from a, appends it to c, deletes it from a.

Turn 2: Bob chooses an element from a, deletes it from a.

Turn 3: Alice chooses an element from a, appends it to c, deletes it from a.

And so on, until a is empty.

So, in each of Alice's turns, she adds one element to c.

Bob, in his turns, removes one element from a.

The crucial point is that Bob can remove any element from a, not necessarily the one Alice just chose.

So, Bob can choose to remove elements that Alice might need in the future.

Given that, if Alice wants to include a particular i in c, she needs to choose it in one of her turns before Bob removes all instances of it.

So, for each i from 0 to k-1, the number of times i appears in a must be greater than the number of times Bob can remove it.

Given that Bob has floor(n/2) removals, and Alice has ceil(n/2) choices.

But it's not that straightforward because Bob can choose which elements to remove.

Wait, perhaps I can think in terms of the minimal number of times Alice needs to choose elements to include all required i's.

Let me try to model it.

Suppose Alice needs to include all i from 0 to k-1 in c.

For each i, the number of times it appears in a is cnt[i].

Bob can remove floor(n/2) elements from a.

Alice needs to choose ceil(n/2) elements, including all i from 0 to k-1.

But Bob can remove elements strategically to prevent Alice from getting all i's.

I need to find the maximal k such that, even after Bob removes floor(n/2) elements, Alice can still choose ceil(n/2) elements including all i from 0 to k-1.

This seems complex.

Let me consider a simpler approach.

Let's consider that Alice can include in c all elements that appear at least ceil(cnt[i]/2).

Wait, perhaps not.

Wait, if cnt[i] is the count of i in a, and Alice can choose ceil(cnt[i]/2) of them, unless Bob removes them.

But Bob can remove floor(n/2) elements in total, not necessarily targeting specific i's.

This is getting too tangled.

Let me look for a different strategy.

Perhaps I can think in terms of the number of times each number appears and how many turns Alice has.

Let me consider that Alice has ceil(n/2) choices.

She needs to include in c all numbers from 0 to k-1 at least once.

So, for each i from 0 to k-1, cnt[i] must be at least 1, because if cnt[i] == 0, Alice cannot include it in c.

But in the third test case, n=2, a=[1,1], which has cnt[1]=2, cnt[0]=0.

Alice cannot include 0 in c because it doesn't exist in a.

Hence, MEX is 0.

In the second test case, n=4, a=[0,1,2,3], cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1.

Alice has ceil(4/2)=2 choices.

She can choose 0 and 2, c=[0,2], MEX=1.

Or choose 0 and 1, c=[0,1], MEX=2.

Wait, but in the sample output, it's 1.

Wait, perhaps I'm missing something.

Wait, in the second test case, Alice has 2 choices.

If she chooses 0 and 1, c=[0,1], MEX=2.

But the sample output is 1.

Wait, maybe I need to consider that Bob can influence the choices.

Wait, perhaps Bob can remove elements that Alice hasn't chosen yet, making them unavailable.

Let me think carefully.

In the second test case:

n=4

a=[0,1,2,3]

Alice's first choice: chooses 0, c=[0], a=[1,2,3]

Bob's removal: removes 1, a=[2,3]

Alice's second choice: chooses 2, c=[0,2], a=[3]

Bob's removal: removes 3, a=[]

Final c=[0,2], MEX=1

Alternatively:

Alice's first choice: chooses 1, c=[1], a=[0,2,3]

Bob's removal: removes 0, a=[2,3]

Alice's second choice: chooses 2, c=[1,2], a=[3]

Bob's removal: removes 3, a=[]

Final c=[1,2], MEX=0

So, depending on Alice's choices, MEX can be 0 or 1.

Since Alice wants to maximize, she would choose the path that leads to MEX=1.

Hence, the output is 1.

In the third test case:

n=2

a=[1,1]

Alice's first choice: chooses 1, c=[1], a=[1]

Bob's removal: removes 1, a=[]

Final c=[1], MEX=0

Hence, output is 0.

In the first test case:

n=4

a=[0,0,1,1]

Alice's first choice: chooses 0, c=[0], a=[0,1,1]

Bob's removal: removes 0, a=[1,1]

Alice's second choice: chooses 1, c=[0,1], a=[1]

Bob's removal: removes 1, a=[]

Final c=[0,1], MEX=2

Alternatively:

Alice's first choice: chooses 1, c=[1], a=[0,0,1]

Bob's removal: removes 1, a=[0,0]

Alice's second choice: chooses 0, c=[1,0], a=[0]

Bob's removal: removes 0, a=[]

Final c=[1,0], MEX=2

So, in both cases, MEX is 2.

Hence, output is 2.

From these observations, it seems that the MEX depends on whether Alice can include all numbers from 0 to k-1 in c, given the frequencies and the sequence of moves.

Let me try to generalize this.

Suppose I have counts for each number.

I need to find the smallest k such that the sum of floor((cnt[i]+1)/2) for i from 0 to k-1 is greater than Alice's available choices.

Wait, perhaps not.

Let me think differently.

Alice has ceil(n/2) choices.

She needs to include as many low numbers as possible in c.

Bob can remove floor(n/2) elements.

I need to see which numbers Alice can guarantee to include in c.

For each number i, if cnt[i] > floor(n/2), then Alice can include at least one in c, because Bob can't remove all of them.

Wait, if cnt[i] > floor(n/2), then even if Bob removes floor(n/2) elements, there will still be some instances of i left for Alice to choose.

Similarly, if cnt[i] <= floor(n/2), Bob can potentially remove all instances of i.

Hence, Alice can guarantee to include in c all i where cnt[i] > floor(n/2).

Additionally, for i where cnt[i] == floor(n/2) + 1, she can include at least one, because even if Bob removes floor(n/2), one remains.

Wait, more precisely, for cnt[i] > floor(n/2), Alice can include at least one in c.

Because the total number of removals by Bob is floor(n/2).

Hence, if cnt[i] > floor(n/2), at least one remains for Alice to choose.

For cnt[i] <= floor(n/2), Bob can remove all instances of i, making it impossible for Alice to include i in c.

Given that, Alice can include in c all i where cnt[i] > floor(n/2).

Hence, the MEX would be the smallest k such that cnt[k] <= floor(n/2).

Wait, but in the second test case, n=4, floor(n/2)=2.

cnt[0]=1 <=2, cnt[1]=1 <=2, cnt[2]=1 <=2, cnt[3]=1 <=2.

Hence, the smallest k where cnt[k] <=2 is k=0.

But the sample output is 1, not 0.

Wait, perhaps I need to consider that Alice can include all i where cnt[i] > floor(n/2), and the MEX is the smallest k not in that set.

In the second test case, floor(n/2)=2.

For i=0, cnt[0]=1 <=2, so not guaranteed.

For i=1, cnt[1]=1 <=2, not guaranteed.

For i=2, cnt[2]=1 <=2, not guaranteed.

For i=3, cnt[3]=1 <=2, not guaranteed.

Hence, Alice cannot guarantee to include any i in c.

But in reality, she can include some numbers, but not necessarily all up to some k.

Wait, perhaps my earlier assumption is incorrect.

Let me try another approach.

Let me consider that Alice can include in c all i where cnt[i] > floor(n/2).

But in the second test case, cnt[i]=1 for i=0,1,2,3, and floor(n/2)=2.

Hence, cnt[i] <=2, so Alice cannot guarantee to include any specific i.

But in practice, she can include some i's depending on the sequence of choices.

Wait, perhaps I need to think in terms of the minimal MEX that Alice can achieve.

Given that, perhaps I can iterate through k from 0 to n, and check if Alice can include all i from 0 to k-1 in c.

To do that, the sum of cnt[i] for i from 0 to k-1 must be greater than floor(n/2), so that even after Bob removes floor(n/2) elements, at least one of each i remains.

Wait, perhaps more precisely, the minimal number of choices Alice needs to include one of each i from 0 to k-1 is the maximal number among the minimal times she needs to choose each i.

Given that, for each i, if cnt[i] > floor(n/2), she can include it.

If cnt[i] <= floor(n/2), she cannot guarantee to include it.

Hence, the minimal k where cnt[k] <= floor(n/2) is the MEX.

But in the second test case, cnt[0]=1 <=2, so k=0 should be MEX, but sample output is 1.

Wait, perhaps I need to adjust this.

Wait, maybe the condition is sum of ceil(cnt[i]/2) for i from 0 to k-1 <= floor(n/2).

Wait, perhaps not.

This is getting too complicated.

Let me look at the provided code and see if I can understand its logic.

Given code:

def func():

for _ in range(int(input())):

n = int(input())

a = list(map(int, input().split()))

cntl = [0 for _ in range(n + 1)]

for i in a:

cntl[i] += 1

if cntl[0] == 0:

print(0)

else:

c = min(2, cntl[0])

for j in range(1, n + 1):

if cntl[j] < 2:

c -= 1

if not c or j == n:

print(j)

break

Let's see what this code is doing.

It reads the number of test cases, then for each test case:

- Reads n and the array a.

- Counts the frequency of each number from 0 to n in a.

- If cntl[0] == 0, prints 0.

- Else, sets c to min(2, cntl[0]).

- Then, for j from 1 to n:

- If cntl[j] < 2, decrement c.

- If c == 0 or j == n, print j and break.

Wait, this seems arbitrary.

Why is it checking cntl[0] and setting c to min(2, cntl[0])?

And then iterating from j=1 to n, checking if cntl[j] < 2.

This doesn't align with any logic I've thought of so far.

Perhaps there's a different way to approach this problem.

Let me consider that Alice can include in c all numbers that appear more than floor(n/2) times.

Because if cnt[i] > floor(n/2), even after Bob removes floor(n/2) elements, at least one remains for Alice to choose.

Hence, Alice can include in c all such i.

Then, the MEX would be the smallest k such that cnt[k] <= floor(n/2).

But in the second test case, cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1, and floor(n/2)=2.

Hence, cnt[0] <=2, cnt[1]<=2, etc.

So, according to this, MEX should be 0, but the sample output is 1.

Hence, this approach is incorrect.

Wait, perhaps I need to consider that Alice can choose ceil(n/2) elements, and she needs to include as many low numbers as possible.

So, she should prioritize choosing low numbers.

Bob, to minimize MEX, would try to remove low numbers that Alice needs.

Given that, perhaps the MEX is the smallest k such that cnt[k] < ceil((k+1)/2).

Wait, that seems off.

Let me think differently.

Suppose I sort the numbers from 0 to n-1 and see how many of each are needed in c.

But I'm getting stuck.

Let me consider binary search on the possible MEX values.

I can perform a binary search on k from 0 to n.

For each k, I check if Alice can include all numbers from 0 to k-1 in c, even when Bob is trying to prevent it.

If she can, then MEX can be at least k, and I can try a higher k.

If not, I need to try a lower k.

This way, I can find the maximal k for which Alice can include all numbers from 0 to k-1 in c.

To implement this efficiently, I need a way to check for a given k whether Alice can include all numbers from 0 to k-1 in c.

Given that, perhaps I can calculate the minimal number of choices Alice needs to include one of each from 0 to k-1, considering Bob's removals.

But I need a better way.

Let me consider that Alice has ceil(n/2) choices.

She needs to include all numbers from 0 to k-1, each at least once.

For each number i from 0 to k-1, the number of times it appears in a is cnt[i].

Alice needs to choose one of each, but Bob can remove some of them.

If cnt[i] > floor(n/2), then Alice can guarantee to include at least one in c.

Because even if Bob removes floor(n/2) elements, there will still be some left for Alice to choose.

Hence, for each i from 0 to k-1, if cnt[i] > floor(n/2), it's safe.

Otherwise, Alice cannot guarantee to include it.

Hence, the maximal k where for all i from 0 to k-1, cnt[i] > floor(n/2), is the desired MEX.

Wait, but in the second test case, floor(n/2)=2, and cnt[i]=1 for all i, which is <=2.

Hence, for k=1, i=0, cnt[0]=1 <=2, so Alice cannot guarantee to include 0 in c.

Hence, MEX should be 1, which matches the sample output.

In the first test case, floor(n/2)=2.

For k=2, i=0 and 1.

cnt[0]=2 >2? No, cnt[0]=2 ==2, so Alice cannot guarantee to include 0.

Hence, MEX should be 1.

But in the sample output, it's 2.

Contradiction.

Wait, perhaps my condition is incorrect.

Wait, in the first test case, cnt[0]=2 and cnt[1]=2.

For k=2, i from 0 to 1.

cnt[0]=2 > floor(n/2)=2? No, cnt[0]=2 ==2.

Hence, Alice cannot guarantee to include 0.

Hence, MEX should be 1, but sample output is 2.

Hence, my earlier assumption is wrong.

Wait, perhaps the condition should be cnt[i] >= ceil((n+1)/2).

Wait, let's check.

In the first test case, n=4, ceil((4+1)/2)=3.

cnt[0]=2 <3, cnt[1]=2 <3.

Hence, Alice cannot guarantee to include any i.

Hence, MEX should be 0, but sample output is 2.

Still not matching.

I need to find a better condition.

Let me consider that for each i from 0 to k-1, the number of times it appears, cnt[i], should be more than the number of times Bob can remove it.

Bob can remove floor(n/2) elements.

Hence, if cnt[i] > floor(n/2), Alice can include at least one in c.

Hence, for MEX=k, for all i from 0 to k-1, cnt[i] > floor(n/2).

In the first test case, floor(n/2)=2.

cnt[0]=2 ==2, which is not greater.

Hence, Alice cannot guarantee to include 0.

Hence, MEX should be 1.

But sample output is 2.

Contradiction.

Wait, perhaps the condition is cnt[i] >=1, and n is large enough.

Wait, in the first test case, cnt[0]=2, cnt[1]=2.

Alice has ceil(4/2)=2 choices.

She can choose 0 and 1, c=[0,1], MEX=2.

Even if Bob removes elements, Alice can still include both 0 and 1.

Wait, in the first test case:

Alice chooses 0, c=[0], a=[0,1,1]

Bob removes 0, a=[1,1]

Alice chooses 1, c=[0,1], a=[1]

Bob removes 1, a=[]

Final c=[0,1], MEX=2.

Alternatively:

Alice chooses 1, c=[1], a=[0,0,1]

Bob removes 1, a=[0,0]

Alice chooses 0, c=[1,0], a=[0]

Bob removes 0, a=[]

Final c=[1,0], MEX=2.

Hence, MEX is 2.

So, even though cnt[0]=2 == floor(n/2)=2, Alice can still include 0.

Hence, my earlier condition is not accurate.

Wait, perhaps the condition is that the sum of cnt[i] for i from 0 to k-1 > floor(n/2).

Because Alice needs to choose one of each, and Bob can remove floor(n/2) elements.

Hence, if sum of cnt[i] > floor(n/2), Alice can include all of them.

Wait, but cnt[i] are individual counts, not to be summed.

Wait, perhaps I need to consider the minimal number of choices Alice needs to include one of each.

For each i from 0 to k-1, Alice needs at least one choice where that i is still available.

Given that, if cnt[i] > floor(n/2), she can include it.

Else, she cannot.

Hence, for MEX=k, all i from 0 to k-1 must satisfy cnt[i] > floor(n/2).

In the first test case, floor(n/2)=2.

cnt[0]=2 ==2, which is not greater.

Hence, Alice cannot guarantee to include 0.

Hence, MEX should be 1.

But sample output is 2.

Hence, my condition is wrong.

I need to find another way.

Let me consider that Alice can include in c all i where cnt[i] > floor(n/2).

In the first test case, cnt[0]=2 == floor(n/2)=2, which is not greater.

Hence, Alice cannot guarantee to include 0.

But in practice, she can include 0 and 1, as shown in the sequence.

Hence, perhaps the condition is cnt[i] >= floor(n/2) +1 - something.

Wait, in the first test case, cnt[0]=2 == floor(n/2)=2.

But Alice can still include 0.

Wait, perhaps the condition is cnt[i] > floor((n - cnt[i])/2).

Wait, that seems more involved.

Let me think differently.

Perhaps I can consider that for each i, the number of times it appears, cnt[i], and the number of times Bob can remove it.

Bob can remove floor(n/2) elements in total.

Hence, for Alice to include i in c, she needs to choose it before Bob removes all instances of it.

Hence, for each i, the minimal number of Alice's choices needed to include it is ceil((cnt[i] +1)/2).

Because if cnt[i] is odd, Alice can choose the last one after Bob removes floor(cnt[i]/2).

If cnt[i] is even, Bob can remove floor(cnt[i]/2), leaving one for Alice to choose.

Wait, perhaps it's ceil(cnt[i]/2).

Wait, for cnt[i]=1, ceil(1/2)=1, meaning Alice needs to choose it once before Bob can remove it.

For cnt[i]=2, ceil(2/2)=1, meaning Alice needs to choose it once before Bob removes one.

Similarly, for cnt[i]=3, ceil(3/2)=2, meaning Alice needs to choose it twice before Bob removes one.

Wait, perhaps not.

Let me think carefully.

For cnt[i]=1:

- Alice chooses it, c=[i], a=[]

- Bob has no move.

- c contains i.

Hence, Alice can include it with one choice.

For cnt[i]=2:

- Alice chooses one, c=[i], a=[i]

- Bob removes one, a=[]

- c contains i.

Hence, Alice can include it with one choice.

For cnt[i]=3:

- Alice chooses one, c=[i], a=[i,i]

- Bob removes one, a=[i,i]

- Alice chooses another, c=[i,i], a=[i]

- Bob removes one, a=[]

- c contains i twice.

Hence, Alice can include it with two choices.

Similarly, for cnt[i]=4:

- Alice chooses one, c=[i], a=[i,i,i]

- Bob removes one, a=[i,i]

- Alice chooses another, c=[i,i], a=[i,i]

- Bob removes one, a=[i,i]

- Alice chooses another, c=[i,i,i], a=[i]

- Bob removes one, a=[]

- c contains i three times.

Hence, to include at least one i, Alice needs ceil(cnt[i]/2) choices.

Wait, in cnt[i]=1, ceil(1/2)=1, which matches.

Cnt[i]=2, ceil(2/2)=1, which matches.

Cnt[i]=3, ceil(3/2)=2, which matches.

Cnt[i]=4, ceil(4/2)=2, but in the sequence above, Alice made three choices.

Wait, perhaps I miscalculated.

Wait, with cnt[i]=4:

- Alice chooses one, c=[i], a=[i,i,i]

- Bob removes one, a=[i,i]

- Alice chooses another, c=[i,i], a=[i,i]

- Bob removes one, a=[i]

- Alice chooses the last one, c=[i,i,i], a=[]

Hence, Alice made three choices.

But ceil(4/2)=2, which doesn't match.

Hence, perhaps it's not ceil(cnt[i]/2).

Wait, maybe it's cnt[i] - floor((cnt[i]-1)/2).

Wait, for cnt[i]=1: 1 - floor(0/2)=1, which is the number of choices Alice needs.

For cnt[i]=2: 2 - floor(1/2)=2 -0=2, but in practice, Alice needs only one choice.

Hence, still not matching.

This is getting complicated.

Let me try to find another way.

Perhaps I can consider that for Alice to include at least one i in c, she needs to choose it before Bob can remove all instances of it.

Hence, the number of choices Alice needs is cnt[i] - (number of Bob's removals).

But Bob can remove floor(n/2) elements in total, not necessarily targeting i.

Hence, to include at least one i, Alice needs to choose it at least once before Bob removes all cnt[i] instances.

But Bob can remove up to floor(n/2) elements.

Hence, if cnt[i] > floor(n/2), Alice can include it.

Because even if Bob removes floor(n/2) elements, at least one remains for Alice to choose.

If cnt[i] <= floor(n/2), Bob can remove all instances of i, preventing Alice from including it in c.

Hence, Alice can include all i where cnt[i] > floor(n/2).

Hence, the MEX is the smallest k where cnt[k] <= floor(n/2).

In the first test case, floor(n/2)=2, cnt[0]=2 <=2, hence MEX=0.

But sample output is 2.

Hence, this is incorrect.

Wait, perhaps the condition is cnt[k] < ceil(n/2).

In the first test case, ceil(4/2)=2, cnt[0]=2 >=2, so k=0 is included.

cnt[1]=2 >=2, so k=1 is included.

cnt[2]=0 <2, so k=2 is not included.

Hence, MEX=2.

This matches the sample.

Similarly, in the second test case, ceil(4/2)=2, cnt[0]=1 <2, so k=0 is not included.

Hence, MEX=0.

But sample output is 1.

Wait, no.

Wait, cnt[0]=1 <2, but in the second test case, n=4, ceil(n/2)=2.

cnt[0]=1 <2, cnt[1]=1 <2, cnt[2]=1 <2, cnt[3]=1 <2.

Hence, according to this, MEX=0.

But sample output is 1.

Hence, this condition is still incorrect.

I need to adjust it.

Wait, perhaps the condition is cnt[k] < ceil((k+1)/2).

Wait, in the second test case, for k=0, ceil(1/2)=1, cnt[0]=1 >=1, so included.

k=1, ceil(2/2)=1, cnt[1]=1 >=1, included.

k=2, ceil(3/2)=2, cnt[2]=1 <2, not included.

Hence, MEX=2.

But sample output is 1.

Still not matching.

Wait, perhaps it's cnt[k] < ceil((n+1)/2).

In the second test case, ceil(5/2)=3, cnt[2]=1 <3, so MEX=2.

But sample output is 1.

Still not matching.

I need to find the right condition.

Let me think differently.

Let me