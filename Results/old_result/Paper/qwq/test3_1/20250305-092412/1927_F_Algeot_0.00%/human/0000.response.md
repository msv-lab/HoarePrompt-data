Alright, I've got this problem to solve. Let's see what it's asking for. So, we have an undirected weighted graph, and I need to find a simple cycle where the lightest edge is as minimal as possible. A simple cycle means no repeated vertices or edges in the cycle.

First, I need to understand what a cycle is in a graph. A cycle is a path that starts and ends at the same vertex, and in an undirected graph, it's a bit simpler because edges don't have directions.

The problem says there are multiple test cases, and for each test case, I have the number of vertices (n) and the number of edges (m). Then, for each edge, I have the two vertices it connects and the weight of that edge.

I need to output, for each test case, the weight of the lightest edge in the found cycle and the number of vertices in that cycle, followed by the list of vertices in the cycle in traversal order.

Looking at the constraints:

- t (number of test cases) is up to 10^4, which is 10,000.

- n (number of vertices) is at least 3 and up to some value, and m (number of edges) is at least n and up to min(n*(n-1)/2, 2*10^5). So, m can be up to 200,000 per test case, but the sum of m across all test cases doesn't exceed 2*10^5.

Given that t can be up to 10,000, but the total sum of m is 2*10^5, that means on average, m per test case is 2*10^5 / 10^4 = 20. So, relatively small graphs per test case.

But wait, the constraints say n <= m <= min(n*(n-1)/2, 2*10^5). Given that n >= 3, and m >= n, it's a dense graph.

Wait, m >= n? Actually, the problem says m >= n, but in graph theory, a graph with n vertices can have up to n*(n-1)/2 edges, and m can be from n to that maximum.

But in this problem, it's specified that m >= n, which means the graph is at least connected (if it's a single component), but since the problem says the graph is not necessarily connected, m can be as low as n, meaning it could be a forest with trees, but since m >= n, it's likely to have cycles.

Wait, no, a tree has n-1 edges, so m >= n means there's at least one cycle in the graph.

The problem also guarantees that there is always at least one simple cycle in the graph, given the constraints.

So, my task is, for each test case, find a simple cycle where the lightest edge has the minimal possible weight.

I need to output the weight of that lightest edge, the number of vertices in the cycle, and the list of vertices in the cycle.

Looking at the example:

Input:

5

6 6

1 2 1

2 3 1

3 1 1

4 5 1

5 6 1

6 4 1

6 6

1 2 10

2 3 8

3 1 5

4 5 100

5 6 40

6 4 3

...

Output:

1 3

1 2 3

3 3

6 4 5

...

So, for the first test case, n=6, m=6, and the edges are forming two separate triangles, each with edge weight 1. So, the lightest edge in both cycles is 1, and the cycle size is 3.

In the second test case, it seems like there are multiple cycles, and the one with the minimal lightest edge is 3, and the cycle is 6-4-5.

Okay, so I need to find any cycle in the graph where the minimum edge weight is as small as possible.

One way to approach this is to iterate through the edges in order of increasing weight, and look for cycles that include edges with that weight.

But considering the constraints, with t up to 10^4 and m up to 2*10^5 in total, I need an efficient algorithm.

Wait, but for each test case, m can be up to 2*10^5, and t is up to 10^4, but the total sum of m is up to 2*10^5. So, per test case, m is on average 20 edges.

Wait, no, total sum of m across all test cases is up to 2*10^5, with t up to 10^4, so average m per test case is 2*10^5 / 10^4 = 20 edges per test case.

So, per test case, n is up to m, which is up to 2*10^5 / t, but t is up to 10^4, so n is up to 2*10^5 / 10^4 = 20, but actually, n can be up to m, which is up to 2*10^5, but the total sum of m is 2*10^5 across all test cases.

Wait, I need to re-read the constraints carefully.

The problem says: "It is guaranteed that the sum of the values of m for all test cases does not exceed 2*10^5."

And m for each test case is up to min(n*(n-1)/2, 2*10^5), and n is at least 3 and up to m.

But with t up to 10^4 and sum of m up to 2*10^5, it implies that per test case, m is on average 2*10^5 / 10^4 = 20 edges.

So, per test case, n is at least 3 and up to some value, but since m is up to 2*10^5 in total across all test cases, and t is up to 10^4, it's feasible to have n up to, say, 10^3 per test case, but likely much smaller on average.

Given that, I need an algorithm that can handle up to, say, n=10^3 per test case, with m up to n*(n-1)/2, which for n=10^3 is about 5*10^5 edges, but considering the sum of m across all test cases is 2*10^5, it's manageable.

But to optimize, I should aim for an algorithm that is efficient per test case, considering the number of test cases.

One approach is to sort the edges by weight in ascending order and then iterate through them, keeping track of the cycles formed.

But since the graph is undirected and can have multiple components, I need to handle each component separately.

Wait, no, the problem allows the graph to be disconnected, but guarantees that there is at least one simple cycle in the graph.

So, I can iterate through the edges in order of increasing weight and look for the first cycle that includes an edge of that weight.

But that might not be the most efficient way.

An alternative approach is to use a Union-Find structure to detect cycles.

I can sort the edges in descending order of weight and add them one by one, keeping track of the components.

When adding an edge, if both vertices are already in the same component, adding this edge would form a cycle.

So, I can find such cycles and keep track of the lightest edge in them.

Wait, but I need the lightest edge in the cycle to be as small as possible.

So, if I sort the edges in descending order of weight and add them one by one, the first time I encounter a cycle, that cycle will have the heaviest possible edges, which might not help me find the minimal lightest edge.

Wait, maybe I need to sort in ascending order.

Let me think again.

If I sort the edges in ascending order of weight, and add them one by one, using a Union-Find structure, when I add an edge that connects two vertices already in the same component, that edge forms a cycle with some path in the component.

So, the lightest edge in that cycle would be at least as light as the current edge I'm adding.

Wait, no, the current edge I'm adding is being compared to the existing edges in the component.

Actually, in Kruskal's algorithm, when building a Minimum Spanning Tree (MST), we sort edges in ascending order and add them if they don't form a cycle.

Here, I need to find cycles, specifically cycles with the minimal lightest edge.

So, perhaps I can iterate through the edges in ascending order of weight, and for each edge, if adding it would create a cycle, I can record that cycle and its lightest edge.

But I need to find the cycle where the lightest edge is minimal, meaning I need the cycle with the smallest possible minimum edge weight.

So, I should iterate through the edges in ascending order of weight, and for each edge, check if adding it forms a cycle.

If it does, and the lightest edge in that cycle is smaller than any previously found, I can record this cycle.

But I need to find any cycle where the lightest edge is minimal.

Wait, actually, I need to find a cycle where the lightest edge is as small as possible.

So, I can iterate through the edges in ascending order of weight, and for each edge, if adding it forms a cycle, I can output that cycle's lightest edge, which is the current edge's weight, since it's the smallest in the cycle.

Wait, but that might not be correct, because in the cycle, there might be edges with smaller weights already present.

Wait, no, if I add an edge (u,v,w) and it forms a cycle, then in that cycle, all edges must have weight at least w, because I'm adding edges in ascending order.

Wait, no, that's not necessarily true.

In Kruskal's algorithm, when you add an edge that forms a cycle, the cycle includes the new edge and some path between u and v in the current forest.

But the edges in that path may have weights that are higher or lower than the current edge.

Wait, actually, in the MST context, when you add an edge that forms a cycle, the cycle includes the new edge and the path between the two vertices in the current tree.

In that cycle, if there's an edge with weight higher than the new edge, you can replace it with the new edge to get a smaller total weight.

But here, I'm not building an MST; I need to find a cycle with the minimal lightest edge.

So, perhaps I can iterate through the edges in ascending order of weight, and for each edge, if adding it forms a cycle, I can find the lightest edge in that cycle.

But to find the lightest edge in the cycle, I need to know all the edges in the cycle.

Alternatively, since I'm adding edges in order, the lightest edge in the cycle would be the minimum weight among the edges in the cycle.

But in Kruskal's, when you add an edge that forms a cycle, the cycle is formed by the new edge and the path connecting the two vertices in the current forest.

So, in that case, the lightest edge in the cycle would be the minimum of the new edge's weight and the maximum weight along the path from u to v in the current forest.

Wait, no.

Actually, in the cycle, the lightest edge would be the minimum weight among all edges in the cycle.

But in the path from u to v in the current forest, the edges have weights that are less than or equal to the new edge's weight, since we're adding edges in ascending order.

Wait, no, in Kruskal's, when adding edges in ascending order, the path from u to v, if it exists, consists of edges that have been added before the current edge, so their weights are less than or equal to the current edge's weight.

Therefore, in the cycle formed by adding the current edge, the lightest edge would be at most the weight of the current edge.

But I need to find the cycle where this lightest edge is minimized.

So, perhaps I can iterate through the edges in ascending order of weight, and for each edge, if adding it forms a cycle, I can record the lightest edge in that cycle, which would be the minimum of the current edge's weight and the lightest edge in the path from u to v.

Wait, but how do I find the lightest edge in the path from u to v?

That seems non-trivial.

Alternatively, perhaps I can use a different approach.

Let me consider that I need to find any simple cycle where the lightest edge is minimized.

So, I can try to find cycles in the graph and keep track of the lightest edge in each cycle, then choose the cycle with the smallest lightest edge.

But with n up to 10^3 and m up to 10^5 per test case, and t up to 10^4, I need an efficient algorithm.

Wait, but earlier I thought that per test case, m is on average 20, but the constraints say that the sum of m across all test cases is up to 2*10^5, with t up to 10^4.

So, per test case, m is on average 2*10^5 / 10^4 = 20 edges.

But n can be up to m, which is up to 2*10^5, but with t=10^4, and sum of m=2*10^5, per test case, m is small, so n is also small.

Wait, no, n can be up to m, which is up to 2*10^5, but with t=10^4 and sum of m=2*10^5, it's likely that n is small per test case.

Wait, let's see: if t=10^4 and sum of m=2*10^5, then on average, m per test case is 20.

But n is at least 3 and up to m, so likely n is small per test case.

So, perhaps it's feasible to use a DFS or BFS to find cycles per test case.

But I need to make sure that the algorithm is efficient enough considering the number of test cases.

Another idea is to sort the edges by weight and try to build a forest where no cycle is formed with a lighter edge than necessary.

But I'm getting confused.

Let me look at the provided program and understand what it's doing.

Looking at the code:

- It reads t, the number of test cases.

- For each test case:

- Reads n and m.

- Reads m edges, each with u, v, and w.

- Sorts the edges in descending order of weight.

- Initializes a graph adjacency list and a Union-Find structure.

- Initializes variables ans, v0, v1.

- Iterates through the sorted edges (from highest to lowest weight):

- Adds edges to the graph.

- If adding an edge forms a cycle (checked using Union-Find), updates ans and records v0 and v1.

- Then, it performs a DFS starting from v1 to find the cycle involving v0 and v1.

- Outputs ans, the length of the cycle, and the cycle itself.

So, the approach is:

1. Sort edges in descending order of weight.

2. Use Union-Find to detect cycles.

3. When a cycle is detected, record the edge's weight and the vertices involved.

4. Perform a DFS to find the actual cycle.

5. Output the lightest edge's weight in the cycle, the cycle's length, and the cycle.

But wait, sorting edges in descending order of weight seems counterintuitive for finding the minimal lightest edge in a cycle.

Because if we sort in descending order, the first cycle we find would have the heaviest possible edges, but we need the cycle with the lightest possible edge.

So, perhaps this approach is incorrect.

Wait, maybe I'm missing something.

Let's see: by sorting edges in descending order and using Union-Find, the ans is set to the minimum of the current edge's weight whenever a cycle is found.

But since we're sorting in descending order, the ans would be the smallest weight among the cycles found, which seems correct.

Wait, but in the cycle, there might be edges with weights smaller than the current edge's weight.

But in this approach, ans is set to the current edge's weight when a cycle is found.

So, it might not correctly capture the lightest edge in the cycle.

Wait, perhaps I need to think differently.

Suppose we sort edges in descending order and add them to the graph using Union-Find.

When we add an edge that forms a cycle, the cycle includes the newly added edge and some path between the two vertices.

Since we're adding edges in descending order, the path between the two vertices in the current forest would consist of edges with higher or equal weights compared to the newly added edge.

Wait, no, in Union-Find, when we add edges in descending order, the path between u and v would consist of edges that have been added before, which have higher or equal weights.

Therefore, in the cycle formed by adding the current edge, the lightest edge would be the minimum between the current edge's weight and the lightest edge in the path from u to v.

But in this approach, ans is set to the minimum of ans and the current edge's weight when a cycle is found.

So, it's assuming that the lightest edge in the cycle is the current edge's weight.

But that might not be accurate, because there could be edges in the path from u to v that have smaller weights.

Wait, but in this approach, ans is set to the current edge's weight when a cycle is found, and then it's taking the minimum of ans and the current edge's weight.

Wait, no, in the code, ans is initialized to 10^6, and then for each edge that forms a cycle, ans is set to the minimum of ans and the current edge's weight.

So, it's trying to find the smallest weight among all edges that form cycles.

But as I thought earlier, in the cycle, there might be edges with smaller weights than the current edge's weight.

So, this approach might not be correct.

Looking back at the example:

Input:

6 6

1 2 1

2 3 1

3 1 1

4 5 1

5 6 1

6 4 1

Output:

1 3

1 2 3

In this case, all edges have weight 1, so the lightest edge in any cycle is 1.

Another input:

6 6

1 2 10

2 3 8

3 1 5

4 5 100

5 6 40

6 4 3

Output:

3 3

6 4 5

In this case, the lightest edge in the cycle 6-4-5 is 3, which is correct.

But according to the approach in the code, it sorts edges in descending order of weight.

So, in the first test case, edges are sorted as:

3 1 5

2 3 8

1 2 10

4 5 100

5 6 40

6 4 3

Wait, no, sorted in descending order of weight:

4 5 100

5 6 40

1 2 10

2 3 8

6 4 3

3 1 5

So, when processing 4-5 with weight 100, it unites them.

Then 5-6 with 40, unites them.

Then 1-2 with 10, unites them.

Then 2-3 with 8, unites them.

Then 6-4 with 3: 6 and 4 are already connected (through 5), so it forms a cycle.

So, ans is set to min(ans, 3), which is 3.

Then, it performs a DFS from v1 (which is 4) to find a cycle involving v0 (which is 6).

But in reality, the minimal lightest edge is 3, which is correct in this case.

But in the first test case, all edges have weight 1, so it's correct.

But consider another example:

Suppose we have:

n=4, m=4

Edges:

1-2:1

2-3:2

3-4:3

4-1:1

In this graph, there is a cycle 1-2-3-4-1 with lightest edge 1.

But if I sort edges in descending order: 3-4:3, 2-3:2, 1-2:1, 4-1:1

Processing 3-4: unite 3 and 4.

Processing 2-3: unite 2 and 3.

Processing 1-2: unite 1 and 2.

Processing 4-1: unite 4 and 1 (forms a cycle).

So, ans is set to min(ans, 1), which is 1.

Which is correct.

But in this case, it works.

But consider another graph:

n=4, m=4

Edges:

1-2:1

2-3:2

3-1:2

4-1:3

Here, there is a cycle 1-2-3-1 with lightest edge 1.

According to the algorithm:

Sort edges: 4-1:3, 1-2:1, 2-3:2, 3-1:2

Processing 4-1: unite 4 and 1.

Processing 1-2: unite 1 and 2.

Processing 2-3: unite 2 and 3.

Processing 3-1: unite 3 and 1 (forms a cycle).

So, ans is set to min(ans, 2), which is 2.

But the actual lightest edge in the cycle is 1, but the algorithm outputs 2.

Wait, but according to the problem statement, it's okay to output any cycle where the lightest edge is minimal.

So, in this case, there is a cycle with lightest edge 1, but the algorithm outputs a cycle with lightest edge 2.

Is this acceptable?

Wait, no, the problem says to find a cycle where the lightest edge is minimal.

So, in this case, the algorithm is not finding the cycle with the minimal lightest edge.

Hence, the algorithm is incorrect.

Wait, but in the problem's example, it seems to work.

Wait, in the problem's first test case, all edges have weight 1, so it's fine.

In the second test case, the lightest edge in the cycle is 3, which seems correct.

But in my example above, it outputs 2, while there is a cycle with lightest edge 1.

So, the algorithm is incorrect.

Hence, Correctness: False

**Final Answer**

\[ \boxed{\text{False}} \]