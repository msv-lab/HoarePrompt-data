Alright, I've got this problem to solve. Let's see what it's asking for.

So, the problem is about determining the minimum number of elements to remove from an array to make it no longer "beautiful." A beautiful array is one where you can make all its elements the same by repeatedly choosing an index i (where 2 ≤ i ≤ |a| - 1) such that a[i - 1] equals a[i + 1], and then replacing a[i] with a[i - 1].

First, I need to understand what makes an array beautiful. The operation allowed is to replace a[i] with a[i - 1] if a[i - 1] equals a[i + 1]. This can be done any number of times, including zero.

Given that the array is beautiful, meaning it's possible to make all elements equal through these operations, I need to find the minimum number of elements to remove so that it's no longer possible to make all elements equal using these operations.

The problem also states that if it's impossible to make the array not beautiful by removing elements, I should output -1.

Looking at the examples:

1. For n=3 and a=[2,2,2], it's impossible to make it not beautiful by removing elements, so output -1.

2. For n=5 and a=[1,2,1,2,1], removing one element can make it not beautiful.

3. For n=1 and a=[1], it's already not beautiful because there are no indices i where 2 ≤ i ≤ |a| - 1, so output -1.

4. For n=7 and a=[3,3,3,5,3,3,3], removing the first three elements makes it not beautiful.

From these examples, I need to find a general approach.

Let me try to understand the operation more deeply. The operation allows changing a[i] to a[i - 1] if a[i - 1] == a[i + 1]. This suggests that elements in the array can be changed to match their neighbors under certain conditions.

Given that the array is beautiful, it means that through these operations, all elements can be made equal.

My goal is to disrupt this property by removing the least number of elements possible.

I need to think about what makes an array not beautiful. If after removal, it's impossible to make all elements equal using the allowed operations, then it's not beautiful.

Let me consider the structure of the array.

Suppose the array has all elements equal. Then, no matter how many elements I remove, it remains beautiful because all elements are already equal.

Wait, but in the first example, [2,2,2], removing any element still leaves all elements equal, so it remains beautiful. Hence, output -1.

In the second example, [1,2,1,2,1], removing one element can break the ability to make all elements equal.

I need to find a pattern or property that allows me to determine the minimum removals.

Let me consider that in a beautiful array, there exists a sequence where elements can be changed to make them all equal.

I need to find a way to break this sequence with minimal removals.

Wait, perhaps I can look for the smallest subset of elements that, when removed, disrupt the ability to make all elements equal.

Another way to think about it is to find parts of the array that are forced to change to a certain value, and remove elements to prevent that.

Wait, maybe I should consider the array as a sequence where certain elements are fixed, and others can be changed based on their neighbors.

Let me try to think differently.

Given that the array is beautiful, and I need to make it not beautiful by removing elements.

What if I try to remove elements such that the remaining array cannot be made all equal through the operations?

One approach could be to remove elements that are crucial for connecting different parts of the array that need to be equalized.

Wait, perhaps I can think of the array as a graph where elements are nodes, and there are edges between elements that can be made equal through operations.

Then, removing certain nodes (elements) could disconnect the graph, making it impossible to make all elements equal.

But I'm not sure if that's the most straightforward way.

Let me consider the fact that in the operation, a[i] is replaced with a[i - 1] if a[i - 1] == a[i + 1].

This suggests that elements can be changed to match their neighbors, provided their neighbors are equal.

So, if I have a sequence like a, b, a, b, a, I can change the b's to a's step by step.

Similarly, in [3,3,3,5,3,3,3], I can change the 5 to 3, making the array all 3's.

Now, to make the array not beautiful, I need to prevent this from happening.

One way to do that is to ensure that after removal, it's impossible to make all remaining elements equal through these operations.

Looking back at the examples:

- In [2,2,2], removing any element still leaves all elements equal, so it remains beautiful.

- In [1,2,1,2,1], removing the last element makes it [1,2,1,2], which cannot be made all equal.

- In [1], it's already not beautiful because there are no indices i where 2 ≤ i ≤ |a| - 1.

- In [3,3,3,5,3,3,3], removing the first three elements makes it [5,3,3,3], which cannot be made all equal because the 5 cannot be changed to 3 without a neighboring 3 on both sides, which isn't present.

So, in some cases, removing elements that are different from the majority can disrupt the beauty.

Wait, but in [1,2,1,2,1], removing one element can make it not beautiful.

In this case, removing any '2' seems to work.

Let me try:

- Remove a[1]: [1,1,2,1] → Can I make all elements 1?

- Starting with [1,1,2,1], since a[2] = 2 and a[1] = a[3] = 1, I can replace a[2] with 1, making it [1,1,1,1]. So, it's still beautiful.

- Wait, so removing a[1] doesn't work.

- Remove a[2]: [1,2,1,2] → Can I make all elements equal?

- In [1,2,1,2], let's see:

- Option 1: Replace a[2] with a[1] = 1, since a[1] = a[3] = 1, making [1,1,1,2].

- Then, replace a[4] with a[3] = 1, making [1,1,1,1].

- So, it's still beautiful.

- Option 2: Replace a[3] with a[2] = 2, but a[2] != a[4], so cannot replace a[3].

- Wait, a[3] =1, a[2]=2, a[4]=2, so a[3] != a[4], so cannot replace a[3].

- Wait, I'm getting confused.

- Wait, in [1,2,1,2], let's see possible operations:

- Choose i=2: a[1]=1, a[3]=1, so replace a[2]=1, making [1,1,1,2].

- Then choose i=4: a[3]=1, a[5]= doesn't exist, so cannot replace a[4].

- So, after one operation, it becomes [1,1,1,2], and no more operations can be performed because there's no i where a[i-1] == a[i+1].

- But in this case, all elements are not equal, so it's not beautiful.

- Wait, but according to the problem, an array is beautiful if you can make all elements equal through operations.

- In [1,1,1,2], you cannot make all elements equal, so it's not beautiful.

- So, removing a[5] makes it [1,2,1,2], which is not beautiful.

- Similarly, removing a[4] makes [1,2,1,2,1] → [1,2,1,2], which is not beautiful.

- Wait, but in the explanation, it says removing the number at index 5.

- Wait, indices are 1-based, so a[5] is the last element.

- Removing a[5] makes it [1,2,1,2], which is not beautiful.

- So, in this case, removing one element is sufficient.

In the fourth example, [3,3,3,5,3,3,3], removing the first three elements makes it [5,3,3,3], which cannot be made all equal.

In [5,3,3,3], the only possible operation is to replace a[2] with a[1]=5, since a[1]=a[3]=3, but a[1] != a[3], which is not true because a[1]=5 and a[3]=3, so a[1] != a[3]. Therefore, no operations can be performed, and it's not beautiful.

So, in this case, removing three elements is sufficient.

Now, I need a general approach.

Let me consider that if the array is already not beautiful, the answer is 0.

But according to the problem, all given arrays are beautiful, so I don't need to handle that case.

Wait, but in the third example, n=1, a=[1], it's already not beautiful because there are no indices i where 2 ≤ i ≤ |a| - 1.

So, in general, for n < 3, the array is not beautiful.

Wait, but in the first test case, n=3, and it's beautiful.

Wait, no, n=3 can be beautiful or not, depending on the array.

Wait, according to the problem, all given arrays are beautiful, so I don't need to check if it's beautiful or not, just assume it is and find the minimum removals to make it not beautiful.

But if it's impossible to make it not beautiful by removals, output -1.

Now, I need to think about when it's impossible to make it not beautiful.

Like in the first test case, [2,2,2], removing any element still leaves all elements equal, so it remains beautiful.

Similarly, if the array has all elements equal, removing any subset will still leave all elements equal, so it remains beautiful.

Hence, in such cases, output -1.

Otherwise, find the minimum number of removals to make it not beautiful.

So, the problem reduces to checking if all elements are equal. If yes, output -1. Else, find the minimum removals to make it not beautiful.

But what's the minimum removals in the general case?

Looking back at the second example, [1,2,1,2,1], removing one element is sufficient.

In the fourth example, [3,3,3,5,3,3,3], removing three elements is sufficient.

I need to find a way to generalize this.

Let me consider that the array is beautiful, meaning that through operations, all elements can be made equal.

I need to disrupt this property by removing elements.

One way to think about it is to remove elements that are different from the target value.

But in the second example, [1,2,1,2,1], the target seems to be 1, and there are 2's that can be changed to 1's.

But removing one 1 makes it [1,2,1,2], which cannot be made all equal.

Wait, but in the explanation, it says that after removing a[5], it's [1,2,1,2], which is not beautiful.

Wait, but in [1,2,1,2], it's possible to make all elements 1 by replacing a[2] and a[4].

Wait, but according to the note, it's not beautiful, meaning it's impossible to make all elements equal.

I need to understand why [1,2,1,2] is not beautiful.

In [1,2,1,2], possible operations:

- Choose i=2: a[1]=1, a[3]=1, so replace a[2]=1, making [1,1,1,2].

- Now, choose i=4: a[3]=1, a[5] doesn't exist, so cannot replace a[4].

- So, the array becomes [1,1,1,2], which is not all equal, hence not beautiful.

Wait, but according to the problem, a beautiful array is one where you can make all elements the same by using the operations.

In [1,1,1,2], you cannot make all elements equal because you cannot change a[4] to 1 since a[3]=1 and a[5] doesn't exist.

Hence, it's not beautiful.

So, removing one element can make the array not beautiful.

Now, in the fourth example, [3,3,3,5,3,3,3], removing the first three elements makes it [5,3,3,3].

In [5,3,3,3], you cannot change a[1]=5 to 3 because a[2]=3 != a[1], so no operations can be performed, and it's not beautiful.

So, in this case, removing three elements is sufficient.

But is there a way to make it not beautiful by removing fewer elements?

Let's see:

- Removing two elements: for example, remove a[1] and a[2], making it [3,3,5,3,3,3].

- In [3,3,5,3,3,3], you can replace a[3]=5 with a[2]=3, since a[2]=3 and a[4]=3, making [3,3,3,3,3,3], which is beautiful.

- So, removing two elements is not sufficient.

- Removing three elements, as in the example, makes it not beautiful.

Hence, the minimum removals are three.

So, in general, I need to find the smallest number of elements to remove so that after removal, it's impossible to make all elements equal through the operations.

Now, how to approach this?

Let me consider that in a beautiful array, all elements can be made equal to a specific value by replacing elements under the given constraints.

To make the array not beautiful, I need to ensure that after removal, it's impossible to make all elements equal.

One way to think about it is to break the connectivity of elements that can be equalized.

But I need a more concrete approach.

Let me consider that if all elements are equal, then removing any subset still leaves all elements equal, so it remains beautiful. Hence, output -1.

If not all elements are equal, then there must be at least two different values.

In such a case, I need to find the minimum number of removals to prevent the array from being made all equal.

I need to find the value that appears the most frequently, and remove elements that are not equal to that value, but in a way that disrupts the operations needed to make all elements equal.

Wait, perhaps I should think in terms of the frequency of the most frequent value.

Let me denote:

- Let m be the maximum frequency of any value in the array.

- Then, the minimum number of removals needed to make the array not beautiful is n - m, unless all elements are equal, in which case it's -1.

Wait, but in the second example, n=5, m=3 (for value 1), n - m = 2, but the answer is 1.

So, that approach is incorrect.

Wait, perhaps I need to consider runs of the most frequent value.

Let me think differently.

Suppose I have a array where the most frequent value forms a single run.

Then, removing elements outside that run might not be sufficient to disrupt the beauty.

Wait, I'm getting confused.

Let me look at another example.

Consider a=[1,2,1,2,1,2,1], n=7.

Here, 1 appears 4 times, 2 appears 3 times.

If I remove one 1, making it [2,1,2,1,2,1], then can I make all elements equal?

In [2,1,2,1,2,1], trying to make all elements 2:

- Choose i=2: a[1]=2, a[3]=2, so replace a[2]=2, making [2,2,2,1,2,1].

- Then choose i=4: a[3]=2, a[5]=2, replace a[4]=2, making [2,2,2,2,2,1].

- Then choose i=6: a[5]=2, but a[7] doesn't exist, so cannot replace a[6].

- So, the array is [2,2,2,2,2,1], which is not all equal, hence not beautiful.

So, removing one element is sufficient.

But according to my earlier thought, m=4 (for 1), n - m = 3, but actually removing one element suffices.

Hence, my earlier approach is incorrect.

So, I need a different strategy.

Let me consider that the array is beautiful, meaning that through operations, all elements can be made equal to a certain value.

I need to find the minimum number of removals to prevent this from happening.

Alternatively, find the smallest subset of elements whose removal prevents the array from being made all equal.

I need to find the value to which the array can be equalized and find the minimum removals to prevent that.

Wait, but in the second example, the array can be equalized to 1, but removing one element is sufficient to prevent that.

Wait, perhaps I need to find the minimum number of removals to break the connectivity required for the operations.

Wait, perhaps I should think in terms of the minimal number of removals to prevent the array from being transformed into a uniform array.

Let me consider that in order to make all elements equal to a particular value, say x, I need to be able to change all elements to x through the operations.

To prevent this, I need to remove elements in such a way that it's impossible to change all remaining elements to x.

But this seems too vague.

Let me consider that for a value x to be achievable, there must be a way to change all elements to x using the operations.

The operations allow changing a[i] to a[i-1] if a[i-1] == a[i+1].

So, if a[i-1] and a[i+1] are both x, then a[i] can be changed to x.

Hence, to make all elements x, there must be a sequence of operations that propagates x through the array.

To prevent this, I need to break the propagation paths.

This sounds like I need to break the array into sections where x cannot propagate across certain points.

In graph terms, it's like disconnecting parts of the graph.

But I need a more concrete approach.

Let me consider that the array can be divided into segments where elements are equal to x or can be changed to x.

I need to remove elements that act as bridges for this propagation.

Wait, perhaps I should look for elements that are not equal to the most frequent value and remove them.

But in the second example, removing one such element is sufficient.

Wait, but in [1,2,1,2,1], the most frequent value is 1 (3 times), and removing one 1 makes it [1,2,1,2], which cannot be made all equal.

Wait, but removing a 1 seems counterintuitive because I thought I should remove elements that are not equal to the most frequent value.

But in this case, removing a 1 makes it not beautiful.

Wait, perhaps I need to remove elements that are different from the target value, but in this case, removing a 1 still makes it not beautiful.

I'm getting confused.

Let me think differently.

Suppose I fix a target value x, and I want to make all elements equal to x.

I can do this by changing elements to x if their neighbors are x.

To prevent this, I need to ensure that there are elements that cannot be changed to x, no matter the operations.

But this seems too vague.

Let me consider that in order to make all elements x, there must be a way to propagate x through the entire array using the operations.

To prevent this, I need to break the propagation paths.

In other words, I need to remove elements such that there are sections of the array that cannot be influenced by x.

In graph terms, it's like removing nodes to disconnect the graph.

In array terms, it's like removing elements to create segments where x cannot spread.

But I need a more concrete plan.

Let me consider that for x to spread, there need to be sequences where x's are connected, allowing the operations to change neighboring elements to x.

To break this, I need to remove elements that are critical for these connections.

This sounds similar to finding cut vertices in a graph.

But how to apply this to the array?

Let me consider that in the array, runs of x's act as connected components.

Removing elements that separate these runs could break the connections.

But I need to formalize this.

Let me try to model the array as a graph where elements are nodes, and there are edges between a[i-1] and a[i+1] if a[i-1] == a[i+1], allowing a[i] to be changed to a[i-1].

Wait, perhaps I need to consider the array as a sequence where certain elements can influence others based on their values.

This is getting too complicated.

Let me look for a different approach.

I recall that in the problem, it's given that the array is beautiful, meaning that it's possible to make all elements equal through the operations.

I need to make it not beautiful by removing the least number of elements.

Perhaps I can find the minimal number of removals to ensure that no single value can be propagated to all positions.

Alternatively, find the minimal number of removals such that the remaining array cannot be made uniform.

Wait, perhaps I can think in terms of the minimal number of removals to make the array not uniform, and ensure that no operations can make it uniform.

But I need a more concrete strategy.

Let me consider that if I have a value x that appears in multiple disjoint segments, removing elements between these segments could prevent x from spreading between them.

Hence, the minimal number of removals would be the number of such segments minus one.

Wait, perhaps it's the number of times the most frequent value changes in the array.

But I need to think more carefully.

Let me consider the following approach:

- Find the most frequent value, say x.

- Find the runs of x in the array.

- The minimal number of removals would be the number of gaps between these runs minus one.

Wait, perhaps it's the number of times the run of x breaks minus one.

But I need to formalize this.

Let me consider that if x appears in several connected runs, to prevent connecting them all, I need to remove elements that connect these runs.

Hence, the minimal number of removals would be the number of connections between the runs minus one.

But I need to define what a connection is.

Wait, perhaps I should think in terms of the number of times the value changes from x to non-x.

For example, in [1,2,1,2,1], x=1 appears in three runs: positions 1, positions 3, positions 5.

To prevent connecting them, I need to remove elements between them.

In this case, removing one element between any two runs would suffice.

Hence, the minimal number of removals is 1.

In [3,3,3,5,3,3,3], x=3 appears in two runs: positions 1-3 and 5-7.

To prevent connecting them, I need to remove elements between them.

Hence, removing the elements at positions 4 would suffice, which is one element.

But in the example, it removes three elements to make it [5,3,3,3], which is not beautiful.

Wait, but according to this, removing one element should suffice.

Wait, but in [3,3,3,5,3,3,3], removing a[4]=5 makes it [3,3,3,3,3,3], which is still beautiful.

So, removing one element is not sufficient.

Wait, perhaps I need to remove all elements that connect the runs.

In this case, removing a[4] makes it [3,3,3] and [3,3,3], which are separate runs.

But in this case, both runs are already all 3's, so the array remains beautiful.

Wait, no, after removing a[4], it's [3,3,3,3,3,3], which is beautiful.

So, removing one element doesn't suffice.

Wait, perhaps I need to remove elements from one of the runs to break it.

In the example, removing the first three elements makes it [5,3,3,3], which is not beautiful.

But according to my earlier thought, removing one element isn't sufficient.

So, perhaps I need to remove elements from one of the runs.

Wait, perhaps the minimal number of removals is the size of the smallest run.

In [3,3,3,5,3,3,3], the run [3,3,