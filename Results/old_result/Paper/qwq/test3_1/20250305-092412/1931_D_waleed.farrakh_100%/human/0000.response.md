Alright, I've got this problem to solve. Let's see what it's asking for. So, Polycarp has two favorite integers, x and y, and he has an array of numbers. He considers a pair of indices <i, j> beautiful if two conditions are met: first, the sum of the elements at those indices is divisible by x, and second, the difference between those elements is divisible by y. My task is to find out how many such beautiful pairs exist in the array for each test case.

First, I need to understand what it means for a sum or difference to be divisible by a number. If a + b is divisible by x, that means (a + b) % x == 0. Similarly, if a - b is divisible by y, then (a - b) % y == 0. So, these are the conditions I need to check for each pair of elements in the array.

Given that n can be up to 2*10^5 and t up to 10^4, but the total sum of n across all test cases is 2*10^5, I need an efficient solution, probably O(n) per test case to avoid timeouts.

Let me think about how to approach this. A brute-force way would be to check every possible pair <i, j> where i < j, and check both conditions. But with n up to 2*10^5 per test case, that would be O(n^2), which is too slow.

I need a smarter way. Maybe I can look at the remainders when a_i is divided by x and y, since that's what divisibility checks depend on.

Let's denote:

- Let’s say a_i ≡ p (mod x)

- And a_i ≡ q (mod y)

Similarly, for a_j:

- a_j ≡ r (mod x)

- a_j ≡ s (mod y)

Now, a_i + a_j ≡ (p + r) (mod x), and for this to be divisible by x, p + r ≡ 0 (mod x). So, r ≡ -p (mod x).

Similarly, a_i - a_j ≡ (p - r) (mod x), but actually, for y, it's a_i - a_j ≡ (q - s) (mod y), and for this to be divisible by y, q - s ≡ 0 (mod y), so s ≡ q (mod y).

Wait, I think I'm complicating it. Maybe I should consider the properties separately.

Given that a_i + a_j is divisible by x, that means a_j ≡ -a_i (mod x).

And a_i - a_j is divisible by y, which means a_j ≡ a_i (mod y).

So, for a pair to be beautiful, a_j must satisfy two conditions based on a_i:

1. a_j ≡ -a_i (mod x)

2. a_j ≡ a_i (mod y)

This seems like a system of congruences. I need to find a_j that satisfies both of these simultaneously.

This reminds me of the Chinese Remainder Theorem, but x and y may not be coprime, so I need to be careful.

But perhaps I can combine these conditions into a single condition modulo the least common multiple (LCM) of x and y, but I'm not sure.

Let me see an example to get a better understanding.

Take the first example:

n = 6, x = 5, y = 2

a = [1, 2, 7, 4, 9, 6]

Beautiful pairs are <1,5> and <4,6>, which correspond to elements (1,9) and (4,6).

Check for <1,5>:

1 + 9 = 10, which is divisible by 5.

1 - 9 = -8, which is divisible by 2.

Similarly for <4,6>:

4 + 6 = 10, divisible by 5.

4 - 6 = -2, divisible by 2.

Okay, now, for each a_i, I need to find a_j such that a_j ≡ -a_i (mod x) and a_j ≡ a_i (mod y).

So, for a_i = 1, I need a_j ≡ -1 ≡ 4 (mod 5) and ≡ 1 (mod 2).

Looking at the array, a_5 = 9. 9 % 5 = 4, and 9 % 2 = 1. So, it matches.

Similarly, for a_i = 4, a_j ≡ -4 ≡ 1 (mod 5) and ≡ 4 (mod 2).

a_6 = 6. 6 % 5 = 1, and 6 % 2 = 0, but wait, 6 % 2 = 0, not 4 % 2 = 0, but 4 % 2 = 0, so 6 % 2 = 0 matches with a_i % y = 4 % 2 = 0.

Wait, 4 % 2 = 0, and 6 % 2 = 0, so they match.

Wait, I think I made a mistake earlier. a_i = 4, y = 2, so a_i % y = 0.

So, I need a_j ≡ 0 (mod 2), which 6 satisfies.

And -4 ≡ 1 (mod 5), which 6 % 5 = 1, so it matches.

Okay, that makes sense.

So, generalizing, for each a_i, I need to find a_j where:

a_j ≡ -a_i (mod x)

and

a_j ≡ a_i (mod y)

Now, how do I efficiently find the number of such a_j for each a_i?

If I can group the elements based on their (remainder modulo x, remainder modulo y), I can precompute frequencies and then for each a_i, look up how many a_j satisfy the required conditions.

Wait, but I need to ensure that i < j, so I have to be careful about counting pairs without double-counting.

Let me think differently.

Suppose I group elements based on their remainders when divided by x and y.

Let me define for each element a_i, compute (a_i % x, a_i % y), which is a pair (p, q).

Now, for each a_i, I need to find a_j such that:

a_j ≡ -a_i (mod x) → a_j % x ≡ (-a_i % x) mod x

and

a_j ≡ a_i (mod y) → a_j % y ≡ a_i % y

So, for each a_i, compute target_p = (-a_i % x) mod x

and target_q = (a_i % y)

Then, look for elements where a_j % x == target_p and a_j % y == target_q.

So, if I group elements by their (p, q), I can precompute a frequency map.

Then, for each a_i, compute the target (p, q), look up how many elements have that (p, q), and add that frequency to the count.

Wait, but this would count pairs where i <= j, but we need i < j.

So, perhaps I need to ensure that I count pairs where j comes after i in the array.

Alternatively, since the problem doesn't specify any ordering besides i < j, and since we're dealing with frequencies, I can use a frequency map and adjust counts accordingly.

Let me try to formalize this.

Let me compute for each element a_i:

target_p = (-a_i % x) mod x

target_q = (a_i % y)

Then, look up how many elements have (p, q) == (target_p, target_q).

But, since I'm iterating through the array, I need to make sure that I don't count pairs where j <= i.

So, perhaps I can maintain a frequency map that accumulates elements as I iterate.

For example, iterate through the array, and for each a_i, compute its target (p, q), look up how many elements before it (j < i) have (p, q), and add that to the count.

But the problem specifies i < j, so perhaps it's better to iterate from the beginning and keep track of frequencies as I go.

Wait, no. If I iterate from i=0 to n-1, and for each i, look for j > i that satisfy the conditions, then I can maintain a frequency map of (p, q) for elements seen so far.

Wait, but in the code provided, it seems to be doing something similar.

Let me look at the given program.

The main function reads input and calls func_2, which reads input and prepares test cases, then calls func_1 to process them.

In func_1, it takes test_cases, which are tuples of (n, x, y, arr).

It initializes a freq dictionary to keep track of frequencies of certain properties of arr elements.

Then, it iterates through each a in arr:

It computes rx = (-a % x + x) % x

ry = a % y

Then, it checks if (rx, ry) is in freq, and if so, adds freq[rx, ry] to count.

Then, it computes current_pair = (a % x, a % y)

And increments the frequency of current_pair in freq.

Finally, it appends the count to results.

Wait, this seems similar to what I was thinking.

Let me understand this.

So, for each a_i, it computes rx = (-a_i % x + x) % x

Which is equivalent to (-a_i) mod x.

And ry = a_i % y.

Then, it looks up how many elements have (rx, ry) in the frequency map so far.

Wait, but it's not considering j > i, because it's updating the frequency map after checking.

So, it's counting pairs where j < i, which is opposite to i < j.

Wait, maybe I need to think differently.

Actually, in the code, it's iterating through the array, and for each a_i, it's looking up how many previous elements a_j (j < i) satisfy the conditions.

But in the problem, i < j, so it should be looking for elements a_j where j > i.

But in terms of counting, as long as I ensure that each pair is counted only once, it should be fine.

Alternatively, perhaps it's correct because it's considering j < i, but since the problem is symmetric in terms of indices, it should be okay.

Wait, maybe I'm overcomplicating it.

Let me verify with the first test case.

n=6, x=5, y=2, arr=[1,2,7,4,9,6]

Beautiful pairs are <1,5> and <4,6>, as given.

Let's see how the code processes this.

Initialize freq = {}, count = 0

For a=1:

rx = (-1 % 5 + 5) % 5 = (4 + 5) % 5 = 9 % 5 = 4

ry = 1 % 2 = 1

Check if (4,1) in freq: no, so count remains 0

current_pair = (1 % 5, 1 % 2) = (1,1)

freq[(1,1)] = 1

For a=2:

rx = (-2 % 5 + 5) % 5 = (3 + 5) % 5 = 8 % 5 = 3

ry = 2 % 2 = 0

Check if (3,0) in freq: no, count remains 0

current_pair = (2 % 5, 0) = (2,0)

freq[(2,0)] = 1

For a=7:

rx = (-7 % 5 + 5) % 5 = (3 + 5) % 5 = 8 % 5 = 3

ry = 7 % 2 = 1

Check if (3,1) in freq: no, count remains 0

current_pair = (7 % 5, 1) = (2,1)

freq[(2,1)] = 1

For a=4:

rx = (-4 % 5 + 5) % 5 = (1 + 5) % 5 = 6 % 5 = 1

ry = 4 % 2 = 0

Check if (1,0) in freq: no, count remains 0

current_pair = (4 % 5, 0) = (4,0)

freq[(4,0)] = 1

For a=9:

rx = (-9 % 5 + 5) % 5 = (1 + 5) % 5 = 6 % 5 = 1

ry = 9 % 2 = 1

Check if (1,1) in freq: yes, freq[(1,1)] = 1, so count += 1 → count=1

current_pair = (9 % 5, 1) = (4,1)

freq[(4,1)] = 1

For a=6:

rx = (-6 % 5 + 5) % 5 = (4 + 5) % 5 = 9 % 5 = 4

ry = 6 % 2 = 0

Check if (4,0) in freq: yes, freq[(4,0)] = 1, so count += 1 → count=2

current_pair = (6 % 5, 0) = (1,0)

freq[(1,0)] = 1

So, total count is 2, which matches the expected output.

Okay, that seems correct for this test case.

Let me check another test case to be sure.

Take the second test case:

n=7, x=9, y=5, arr=[1,10,15,3,8,12,15]

Expected output: 0

Let's simulate the code:

Initialize freq = {}, count=0

a=1:

rx = (-1 % 9 + 9) % 9 = (8 + 9) % 9 = 17 % 9 = 8

ry = 1 % 5 = 1

Check if (8,1) in freq: no

current_pair = (1 % 9, 1 % 5) = (1,1)

freq[(1,1)] = 1

a=10:

rx = (-10 % 9 + 9) % 9 = (8 + 9) % 9 = 17 % 9 = 8

ry = 10 % 5 = 0

Check if (8,0) in freq: no

current_pair = (10 % 9, 0) = (1,0)

freq[(1,0)] = 1

a=15:

rx = (-15 % 9 + 9) % 9 = (3 + 9) % 9 = 12 % 9 = 3

ry = 15 % 5 = 0

Check if (3,0) in freq: no

current_pair = (15 % 9, 0) = (6,0)

freq[(6,0)] = 1

a=3:

rx = (-3 % 9 + 9) % 9 = (6 + 9) % 9 = 15 % 9 = 6

ry = 3 % 5 = 3

Check if (6,3) in freq: no

current_pair = (3 % 9, 3) = (3,3)

freq[(3,3)] = 1

a=8:

rx = (-8 % 9 + 9) % 9 = (1 + 9) % 9 = 10 % 9 = 1

ry = 8 % 5 = 3

Check if (1,3) in freq: no

current_pair = (8 % 9, 3) = (8,3)

freq[(8,3)] = 1

a=12:

rx = (-12 % 9 + 9) % 9 = (6 + 9) % 9 = 15 % 9 = 6

ry = 12 % 5 = 2

Check if (6,2) in freq: no

current_pair = (12 % 9, 2) = (3,2)

freq[(3,2)] = 1

a=15:

rx = (-15 % 9 + 9) % 9 = (3 + 9) % 9 = 12 % 9 = 3

ry = 15 % 5 = 0

Check if (3,0) in freq: yes, freq[(3,0)] = 1, so count +=1 → count=1

current_pair = (15 % 9, 0) = (6,0)

freq[(6,0)] +=1 → freq[(6,0)] = 2

Wait, but the expected output is 0, but according to this simulation, count=1.

Wait, maybe I made a mistake.

Wait, let's check the problem statement again.

In the example, for the second test case, output is 0.

But according to this simulation, count=1.

Hmm, maybe there's something wrong with the approach.

Wait, perhaps we need to ensure that both conditions are satisfied simultaneously.

Wait, in the code, it's checking for (rx, ry) in freq, where rx = (-a_i % x + x) % x and ry = a_i % y.

But in the problem, we need both a_j ≡ -a_i (mod x) and a_j ≡ a_i (mod y).

So, in the frequency map, we should have elements grouped by (a_j % x, a_j % y).

But in the code, it's using (a_j % x, a_j % y) for freq, which seems correct.

Wait, in the second test case, when a=15 is processed, it looks for (3,0) in freq.

Looking back, a=15:

rx = (-15 % 9 + 9) % 9 = 3

ry = 15 % 5 = 0

Looking for (3,0) in freq.

At this point, freq has:

(1,1):1, (1,0):1, (6,0):1, (3,3):1, (8,3):1, (3,2):1

So, (3,0) is not in freq, because no previous a_j had (3,0).

Wait, but in my earlier simulation, I thought freq[(3,0)] =1, but actually, freq[(3,0)] was not set yet.

Wait, perhaps I miscounted.

Let's list the freq after each step:

a=1:

freq[(1,1)] =1

a=10:

freq[(1,0)] =1

a=15:

freq[(6,0)] =1

a=3:

freq[(3,3)] =1

a=8:

freq[(8,3)] =1

a=12:

freq[(3,2)] =1

a=15:

freq[(6,0)] +=1 → freq[(6,0)] =2

So, when a=15 is processed, it looks for (3,0), which is not in freq, because only (3,3) and (3,2) are present.

So, count +=0.

Wait, but in my earlier simulation, I mistakenly thought freq[(3,0)] =1, but it's not.

So, count remains 0, which matches the expected output.

Okay, so my earlier mistake was incorrect simulation.

The code seems correct.

Another test case:

n=9, x=4, y=10, arr=[14,10,2,2,11,11,13,5,6]

Expected output:1

Let's simulate:

Initialize freq={}, count=0

a=14:

rx = (-14 % 4 +4)%4 = (2+4)%4=6%4=2

ry=14%10=4

Look for (2,4) in freq: no

current_pair=(14%4,14%10)=(2,4)

freq[(2,4)]=1

a=10:

rx=(-10%4 +4)%4=2

ry=10%10=0

Look for (2,0) in freq: no

current_pair=(2,0)

freq[(2,0)]=1

a=2:

rx=(-2%4 +4)%4=2

ry=2%10=2

Look for (2,2) in freq: no

current_pair=(2,2)

freq[(2,2)]=1

a=2:

rx=(-2%4 +4)%4=2

ry=2%10=2

Look for (2,2) in freq: yes, freq[(2,2)]=1, so count+=1 → count=1

current_pair=(2,2)

freq[(2,2)]=2

a=11:

rx=(-11%4 +4)%4=1

ry=11%10=1

Look for (1,1) in freq: no

current_pair=(3,1)

freq[(3,1)]=1

a=11:

rx=(-11%4 +4)%4=1

ry=11%10=1

Look for (1,1) in freq: no

current_pair=(3,1)

freq[(3,1)]=2

a=13:

rx=(-13%4 +4)%4=3

ry=13%10=3

Look for (3,3) in freq: no

current_pair=(1,3)

freq[(1,3)]=1

a=5:

rx=(-5%4 +4)%4=3

ry=5%10=5

Look for (3,5) in freq: no

current_pair=(1,5)

freq[(1,5)]=1

a=6:

rx=(-6%4 +4)%4=2

ry=6%10=6

Look for (2,6) in freq: no

current_pair=(2,6)

freq[(2,6)]=1

So, total count=1, which matches the expected output.

Seems correct.

Another test case:

n=9, x=5, y=6, arr=[10,7,6,7,9,7,7,10,10]

Expected output:3

Simulate:

Initialize freq={}, count=0

a=10:

rx=(-10%5 +5)%5=0

ry=10%6=4

Look for (0,4) in freq: no

current_pair=(0,4)

freq[(0,4)]=1

a=7:

rx=(-7%5 +5)%5=3

ry=7%6=1

Look for (3,1) in freq: no

current_pair=(2,1)

freq[(2,1)]=1

a=6:

rx=(-6%5 +5)%5=4

ry=6%6=0

Look for (4,0) in freq: no

current_pair=(1,0)

freq[(1,0)]=1

a=7:

rx=3

ry=1

Look for (3,1) in freq: no

current_pair=(2,1)

freq[(2,1)]=2

a=9:

rx=(-9%5 +5)%5=1

ry=9%6=3

Look for (1,3) in freq: no

current_pair=(4,3)

freq[(4,3)]=1

a=7:

rx=3

ry=1

Look for (3,1) in freq: no

current_pair=(2,1)

freq[(2,1)]=3

a=7:

rx=3

ry=1

Look for (3,1) in freq: no

current_pair=(2,1)

freq[(2,1)]=4

a=10:

rx=0

ry=4

Look for (0,4) in freq: yes, freq[(0,4)]=1, so count+=1 → count=1

current_pair=(0,4)

freq[(0,4)]=2

a=10:

rx=0

ry=4

Look for (0,4) in freq: yes, freq[(0,4)]=2, so count+=2 → count=3

current_pair=(0,4)

freq[(0,4)]=3

Total count=3, which matches the expected output.

Good.

Another test case:

n=9, x=6, y=2, arr=[4,9,7,1,2,2,13,3,15]

Expected output:5

Simulate:

Initialize freq={}, count=0

a=4:

rx=(-4%6 +6)%6=2

ry=4%2=0

Look for (2,0) in freq: no

current_pair=(4,0)

freq[(4,0)]=1

a=9:

rx=(-9%6 +6)%6=3

ry=9%2=1

Look for (3,1) in freq: no

current_pair=(3,1)

freq[(3,1)]=1

a=7:

rx=(-7%6 +6)%6=5

ry=7%2=1

Look for (5,1) in freq: no

current_pair=(1,1)

freq[(1,1)]=1

a=1:

rx=(-1%6 +6)%6=5

ry=1%2=1

Look for (5,1) in freq: no

current_pair=(1,1)

freq[(1,1)]=2

a=2:

rx=(-2%6 +6)%6=4

ry=2%2=0

Look for (4,0) in freq: yes, freq[(4,0)]=1, so count+=1 → count=1

current_pair=(2,0)

freq[(2,0)]=1

a=2:

rx=4

ry=0

Look for (4,0) in freq: yes, freq[(4,0)]=1, so count+=1 → count=2

current_pair=(2,0)

freq[(2,0)]=2

a=13:

rx=(-13%6 +6)%6=5

ry=13%2=1

Look for (5,1) in freq: no

current_pair=(1,1)

freq[(1,1)]=3

a=3:

rx=(-3%6 +6)%6=3

ry=3%2=1

Look for (3,1) in freq: yes, freq[(3,1)]=1, so count+=1 → count=3

current_pair=(3,1)

freq[(3,1)]=2

a=15:

rx=(-15%6 +6)%6=3

ry=15%2=1

Look for (3,1) in freq: yes, freq[(3,1)]=2, so count+=2 → count=5

current_pair=(3,1)

freq[(3,1)]=3

Total count=5, which matches the expected output.

Great.

Another test case:

n=9, x=2, y=3, arr=[14,6,1,15,12,15,8,2,15]

Expected output:7

Simulate:

Initialize freq={}, count=0

a=14:

rx=(-14%2 +2)%2=0

ry=14%3=2

Look for (0,2) in freq: no

current_pair=(0,2)

freq[(0,2)]=1

a=6:

rx=(-6%2 +2)%2=0

ry=6%3=0

Look for (0,0) in freq: no

current_pair=(0,0)

freq[(0,0)]=1

a=1:

rx=(-1%2 +2)%2=1

ry=1%3=1

Look for (1,1) in freq: no

current_pair=(1,1)

freq[(1,1)]=1

a=15:

rx=(-15%2 +2)%2=1

ry=15%3=0

Look for (1,0) in freq: no

current_pair=(1,0)

freq[(1,0)]=1

a=12:

rx=(-12%2 +2)%2=0

ry=12%3=0

Look for (0,0) in freq: yes, freq[(0,0)]=1, so count+=1 → count=1

current_pair=(0,0)

freq[(0,0)]=2

a=15:

rx=1

ry=0

Look for (1,0) in freq: yes, freq[(1,0)]=1, so count+=1 → count=2

current_pair=(1,0)

freq[(1,0)]=2

a=8:

rx=(-8%2 +2)%2=0

ry=8%3=2

Look for (0,2) in freq: yes, freq[(0,2)]=1, so count+=1 → count=3

current_pair=(0,2)

freq[(0,2)]=2

a=2:

rx=(-2%2 +2)%2=0

ry=2%3=2

Look for (0,2) in freq: yes, freq[(0,2)]=2, so count+=2 → count=5

current_pair=(0,2)

freq[(0,2)]=3

a=15:

rx=1

ry=0

Look for (1,0) in freq: yes, freq[(1,0)]=2, so count+=2 → count=7

current_pair=(1,0)

freq[(1,0)]=3

Total count=7, which matches the expected output.

Perfect.

Last test case:

n=10, x=5, y=7, arr=[13,3,3,2,12,11,3,7,13,14]

Expected output:0

Simulate:

Initialize freq={}, count=0

a=13:

rx=(-13%5 +5)%5=2

ry=13%7=6

Look for (2,6) in freq: no

current_pair=(3,6)

freq[(3,6)]=1

a=3:

rx=(-3%5 +5)%5=2

ry=3%7=3

Look for (2,3) in freq: no

current_pair=(3,3)

freq[(3,3)]=1

a=3:

rx=2

ry=3

Look for (2,3) in freq: yes, freq[(2,3)]=1, so count+=1 → count=1

current_pair=(3,3)

freq[(3,3)]=2

a=2:

rx=(-2%5 +5)%5=3

ry=2%7=2

Look for (3,2) in freq: no

current_pair=(2,2)

freq[(2,2)]=1

a=12:

rx=(-12%5 +5)%5=3

ry=12%7=5

Look for (3,5) in freq: no

current_pair=(2,5)

freq[(2,5)]=1

a=11:

rx=(-11%5 +5)%5=4

ry=11%7=4

Look for (4,4) in freq: no

current_pair=(1,4)

freq[(1,4)]=1

a=3:

rx=2

ry=3

Look for (2,3) in freq: yes, freq[(2,3)]=1, so count+=1 → count=2

current_pair=(3,3)

freq[(3,3)]=3

a=7:

rx=(-7%5 +5)%5=3

ry=7%7=0

Look for (3,0) in freq: no

current_pair=(2,0)

freq[(2,0)]=1

a=13:

rx=2

ry=6

Look for (2,6) in freq: no

current_pair=(3,6)

freq[(3,6)]=2

a=14:

rx=(-14%5 +5)%5=1

ry=14%7=0

Look for (1,0) in freq: no

current_pair=(4,0)

freq[(4,0)]=1

Total count=2, but expected output is 0.

Wait, discrepancy.

According to the simulation, count=2, but expected is 0.

So, perhaps the code is incorrect.

Wait, maybe I made a mistake in simulating.

Let's re-examine.

Looking back at the test case:

n=10, x=5, y=7, arr=[13,3,3,2,12,11,3,7,13,14]

Expected output:0

Simulate again carefully:

Initialize freq={}, count=0

a=13:

rx=(-13%5 +5)%5=2

ry=13%7=6

Look for (2,6) in freq: no

current_pair=(13%5,13%7)=(3,6)

freq[(3,6)]=1

a=3:

rx=(-3%5 +5)%5=2

ry=3%7=3

Look for (2,3) in freq: no

current_pair=(3,3)

freq[(3,3)]=1

a=3:

rx=2

ry=3

Look for (2,3) in freq: yes, freq[(2,3)]=1, so count+=1 → count=1

current_pair=(3,3)

freq[(3,3)]=2

a=2:

rx=(-2%5 +5)%5=3

ry=2%7=2

Look for (3,2) in freq: no

current_pair=(2,2)

freq[(2,2)]=1

a=12:

rx=(-12%5 +5)%5=3

ry=12%7=5

Look for (3,5) in freq: no

current_pair=(2,5)

freq[(2,5)]=1

a=11:

rx=(-11%5 +5)%5=4

ry=11%7=4

Look for (4,4) in freq: no

current_pair=(1,4)

freq[(1,4)]=1

a=3:

rx=2

ry=3

Look for (2,3) in freq: yes, freq[(2,3)]=2, so count+=2 → count=3

current_pair=(3,3)

freq[(3,3)]=3

a=7:

rx=(-7%5 +5)%5=3

ry=7%7=0

Look for (3,0) in freq: no

current_pair=(2,0)

freq[(2,0)]=1

a=13:

rx=2

ry=6

Look for (2,6) in freq: no

current_pair=(3,6)

freq[(3,6)]=2

a=14:

rx=(-14%5 +5)%5=1

ry=14%7=0

Look for (1,0) in freq: no

current_pair=(4,0)

freq[(4,0)]=1

Total count=3, but expected output is 0.

Wait, earlier I had count=2, now it's 3.

But in any case, it's not matching the expected output of 0.

So, perhaps there's an error in the code's logic.

Wait, maybe I need to consider that the pairs are being overcounted.

Wait, perhaps the conditions are not being satisfied simultaneously for some pairs.

Let me check the conditions for the pairs that the code is counting.

In this test case, expected output is 0, meaning there are no beautiful pairs.

But according to the code's simulation, it's counting 3 pairs, which is incorrect.

So, there must be a flaw in the code's logic.

Wait, perhaps the way rx is calculated is incorrect.

Let me double-check how to compute the negative modulo.

In Python, (-a % x) might not always return a positive number less than x.

Wait, in Python, the sign of the result of modulo operation follows the divisor.

So, -a % x will give a result from 0 to x-1 if x is positive.

So, (-a % x + x) % x is actually redundant, because -a % x already gives a positive result between 0 and x-1.

So, rx = (-a % x + x) % x is equivalent to rx = (-a) % x.

In Python, (-a) % x is the same as (x - a % x) % x.

Wait, no.

In Python, (-a) % x is equivalent to x - (a % x) if a % x != 0, else 0.

So, (-a % x + x) % x is indeed equal to (-a) % x.

But perhaps there's a better way to compute it.

Wait, perhaps the issue is that the conditions are not being met simultaneously.

Wait, perhaps I need to ensure that the system of congruences has a solution.

That is, a_j ≡ -a_i (mod x) and a_j ≡ a_i (mod y).

This is a system of congruences:

a_j ≡ -a_i (mod x)

a_j ≡ a_i (mod y)

For this system to have a solution, the following must hold:

-a_i ≡ a_i (mod gcd(x, y))

Because for the system to have a solution, the intersection of the two congruence classes must not be empty.

Which implies that -a_i ≡ a_i (mod gcd(x, y))

Which simplifies to 2*a_i ≡ 0 (mod gcd(x, y))

So, 2*a_i is divisible by gcd(x, y).

But since a_i can be any integer, this might not always hold.

Wait, in the test case where expected output is 0, perhaps this condition fails.

Wait, in the last test case, n=10, x=5, y=7, arr=[13,3,3,2,12,11,3,7,13,14]

Let's check for each pair if they satisfy the conditions.

Take a_i=13, a_j=3:

13 + 3 =16, which is not divisible by 5.

13 - 3=10, which is divisible by 7.

Doesn't satisfy both.

a_i=13, a_j=3:

Same as above.

a_i=3, a_j=3:

3 + 3=6, not divisible by 5.

3 - 3=0, which is divisible by 7.

Doesn't satisfy both.

a_i=3, a_j=2:

3 + 2=5, which is divisible by 5.

3 - 2=1, which is not divisible by 7.

Doesn't satisfy both.

a_i=2, a_j=12:

2 + 12=14, not divisible by 5.

2 - 12=-10, divisible by 7.

Doesn't satisfy both.

a_i=12, a_j=11:

12 + 11=23, not divisible by 5.

12 - 11=1, not divisible by 7.

Doesn't satisfy.

a_i=11, a_j=3:

11 + 3=14, not divisible by 5.

11 - 3=8, not divisible by 7.

Doesn't satisfy.

a_i=3, a_j=7:

3 + 7=10, divisible by 5.

3 - 7=-4, not divisible by 7.

Doesn't satisfy.

a_i=7, a_j=13:

7 + 13=20, divisible by 5.

7 - 13=-6, not divisible by 7.

Doesn't satisfy.

a_i=13, a_j=14:

13 + 14=27, not divisible by 5.

13 - 14=-1, not divisible by 7.

Doesn't satisfy.

So, indeed, there are no beautiful pairs in this test case, but according to the code's simulation, it's counting 3 pairs, which means the code is incorrect for this test case.

Therefore, the given program is incorrect.

Wait, but in my simulation, I think I made a mistake.

Wait, in the simulation, I had count=3, but according to the problem, it should be 0.

So, the code is producing incorrect output for this test case.

Hence, the program is incorrect.

Therefore, the answer is "False".

**Final Answer**

\[\boxed{\text{False}}\]