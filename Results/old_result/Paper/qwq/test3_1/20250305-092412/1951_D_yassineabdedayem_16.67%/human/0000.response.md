Alright, I have this problem to solve. Let's understand what's being asked here.

So, Alice has n coins and wants to buy exactly k jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel ranging from 1 to 10^18 coins. Alice buys jewels greedily: she goes to each stall in order and buys as many jewels as she can with her remaining coins.

My task is to determine if it's possible for Bob to set up the stalls and set the prices in such a way that Alice ends up buying exactly k jewels. If it's possible, I need to output "YES", followed by the number of stalls and the prices for each stall. If it's not possible, I should output "NO".

First, I need to think about how Alice's buying behavior works. She goes to each stall in sequence and buys as many jewels as she can with her current coins. So, at each stall, she buys floor(n / p) jewels, where n is her current number of coins and p is the price per jewel at that stall. Then, she proceeds to the next stall with the remaining coins.

I need to find a sequence of at most 60 prices such that the total number of jewels she buys is exactly k.

Let me consider some examples to understand this better.

Example 1:

Input:

7 3

Output:

YES

10

2 3 4 5 6 7 8 9 10 11

Explanation:

- Stall 1: p=2, Alice buys 3 jewels (7//2=3), remaining coins: 7-3*2=1

- Stall 2 to 10: p=3 to 11, Alice can't buy any jewels since she has only 1 coin left.

Total jewels bought: 3

This matches the required k=3.

Example 2:

Input:

6 4

Output:

NO

Example 3:

Input:

255 8

Output:

YES

8

128 64 32 16 8 4 2 1

Explanation:

- Stall 1: p=128, buys 1 jewel, remaining: 255-128=127

- Stall 2: p=64, buys 1 jewel, remaining: 127-64=63

- Stall 3: p=32, buys 1 jewel, remaining: 63-32=31

- Stall 4: p=16, buys 1 jewel, remaining: 31-16=15

- Stall 5: p=8, buys 1 jewel, remaining: 15-8=7

- Stall 6: p=4, buys 1 jewel, remaining: 7-4=3

- Stall 7: p=2, buys 1 jewel, remaining: 3-2=1

- Stall 8: p=1, buys 1 jewel, remaining: 1-1=0

Total jewels bought: 8

This matches k=8.

From these examples, it seems that in the first case, Bob set up 10 stalls with increasing prices, and Alice bought all her jewels from the first stall. In the third case, Bob set up 8 stalls with decreasing prices, and Alice bought one jewel from each stall.

I need to find a general strategy for Bob to set up the stalls such that Alice buys exactly k jewels.

Let me think about the constraints:

- Bob can set up at most 60 stalls.

- Each stall has a price between 1 and 10^18.

- Alice must buy exactly k jewels.

- Alice buys greedily, always buying as many jewels as possible from the current stall.

I need to ensure that the total number of jewels bought is exactly k.

I should consider the minimal and maximal number of jewels Alice can buy.

- Minimal: If Bob sets up stalls with very high prices, Alice might buy fewer jewels.

- Maximal: If Bob sets up stalls with price 1, Alice can buy up to n jewels.

So, for k > n, it's impossible because Alice can't buy more jewels than the number of coins she has.

Similarly, for k = 1, Bob can set up a single stall with p = ceil(n / k) = n.

Wait, but p must be an integer, so p = ceil(n / k) is valid.

But in the problem, p must be between 1 and 10^18.

Given that n and k can be up to 10^18, p can be up to 10^18.

But in the problem, p can be up to 10^18, so that's fine.

But I need to ensure that Alice buys exactly k jewels across all stalls.

This seems tricky because the way she buys is sequential and greedy.

I need to think about how to distribute the jewels across the stalls.

One approach is to consider that each stall can contribute a certain number of jewels, and the sum should be exactly k.

But it's not that simple because the number of jewels bought at each stall depends on the remaining coins.

So, it's interdependent.

I need a way to control the number of jewels bought at each stall.

Let me consider the minimal number of stalls required.

If Bob sets up only one stall, then Alice will buy floor(n / p) jewels.

To make this equal to k, p should be floor(n / k).

But what if n is not divisible by k? Then floor(n / k) * k might be less than n, but Alice might still have some coins left, which could allow her to buy more jewels from additional stalls.

Wait, but in this case, since there are no more stalls, she stops.

So, if Bob sets up only one stall with p = floor(n / k), then the number of jewels bought is floor(n / p) = floor(n / floor(n / k)).

This might be greater than or equal to k, but not necessarily exactly k.

For example, n=7, k=3:

floor(7 / 2)=3, but 2*3=6 <=7, so it's possible with one stall.

But in the example, they used 10 stalls.

So, perhaps using multiple stalls allows more control.

Wait, but in the first example, they used 10 stalls to make Alice buy exactly 3 jewels.

But as shown, with one stall, it's possible to make Alice buy exactly 3 jewels.

So why use 10 stalls?

Maybe to have more flexibility or to handle more complex cases.

But in this problem, we need to make Alice buy exactly k jewels, using at most 60 stalls.

I need to find a general method to achieve this.

Let me consider the following approach:

- Start with s=1 stall.

- Set p1 such that floor(n / p1) = m1 jewels.

- Then, remaining coins: n - m1 * p1.

- Then, for the next stall, set p2 such that floor(remaining / p2) = m2 jewels.

- And so on, until the total jewels bought is k.

But this seems too vague.

I need a better way to control the number of jewels bought at each stall.

Another idea: binary search.

But I'm not sure what to binary search on.

Wait, perhaps I can think in terms of binary representation.

In the third example, Bob set up stalls with prices that are powers of 2: 128, 64, 32, 16, 8, 4, 2, 1.

This is similar to binary representation.

In binary, each position represents a power of 2, and the number of jewels bought at each stall corresponds to whether that bit is set in the binary representation of k.

Wait, but in the third example, k=8, which is 1000 in binary, but they set up 8 stalls.

Wait, perhaps I'm misunderstanding.

Wait, in the third example, k=8, and they set up 8 stalls, each with prices that are powers of 2 decreasing from 128 to 1.

Alice buys one jewel from each stall, totaling 8 jewels.

But 8 stalls are used, which is within the limit of 60.

But in this case, it's possible to set up fewer stalls.

For example, with one stall priced at floor(255 / 8)=31, Alice would buy floor(255 / 31)=8 jewels.

So, why use 8 stalls?

Maybe to have more flexibility or to ensure that Alice buys exactly k jewels in a controlled manner.

But in terms of minimality, it's possible with one stall, but the problem allows up to 60 stalls.

So, perhaps using multiple stalls can handle more complex cases where n and k have specific relationships.

I need to find a general method that works for any n and k within the constraints.

Let me consider the following algorithm:

- Initialize remaining_jewels = k

- Initialize remaining_coins = n

- Initialize an empty list for stall prices

- While remaining_jewels > 0 and number of stalls < 60:

- Choose a price p for the next stall

- Calculate the number of jewels Alice can buy: m = floor(remaining_coins / p)

- If m > remaining_jewels:

- Set m = remaining_jewels

- Add m to the total jewels bought

- Update remaining_coins -= m * p

- remaining_jewels -= m

- Else:

- Add m to the total jewels bought

- Update remaining_coins -= m * p

- remaining_jewels -= m

- If after setting up 60 stalls, remaining_jewels == 0, output YES and the list of prices

- Else, output NO

But I need to decide how to choose p at each step.

If I choose p too small, Alice might buy too many jewels at that stall.

If I choose p too large, Alice might buy fewer jewels than needed.

I need a strategy to choose p such that the total jewels bought is exactly k.

One possible strategy is to choose p such that Alice buys as many jewels as possible without exceeding the remaining_jewels.

But this seems similar to the greedy approach, which might not always lead to the correct solution.

Alternatively, I can think of this problem as partitioning k jewels into at most 60 groups, where each group corresponds to a stall, and the number of jewels bought from each stall is floor(remaining_coins / p), with p being the price set by Bob.

This seems complex because the number of jewels bought from each stall depends on the remaining coins, which in turn depends on the previous stalls.

This is interdependent, and it's not straightforward to find a sequence of p's that sum up to exactly k jewels.

Let me consider another approach.

Suppose Bob sets up s stalls with prices p1, p2, ..., ps.

Alice buys floor(n / p1) jewels from the first stall, then floor((n - floor(n / p1) * p1) / p2) from the second, and so on.

The goal is to have the sum of jewels bought from all stalls equal to k.

This seems like a system of equations, but it's not clear how to solve it directly.

Perhaps I can try to find a sequence of p's that forces Alice to buy a specific number of jewels at each stall.

For example, if I set p1 such that floor(n / p1) = m1, then set p2 such that floor((n - m1 * p1) / p2) = m2, and so on, with m1 + m2 + ... + ms = k.

But determining each p_i based on the remaining coins and the required m_i is tricky.

I need a better way to control the number of jewels bought at each stall.

Let me consider the minimal number of stalls required.

If Bob sets up only one stall, he can set p = floor(n / k), and Alice will buy floor(n / p) jewels.

But floor(n / floor(n / k)) might be greater than or equal to k, but not necessarily exactly k.

For example, n=7, k=3:

floor(7 / 3)=2, so p=floor(7 / 3)=2

Then, floor(7 / 2)=3, which is equal to k=3.

Another example: n=6, k=4

floor(6 / 4)=1

Then, floor(6 / 1)=6, which is greater than k=4.

So, in this case, Alice buys 6 jewels, which is more than k=4.

Hence, it's impossible with one stall.

But the problem allows up to 60 stalls.

So, perhaps by using multiple stalls, Bob can control the number of jewels bought.

In the second example, n=6, k=4, it's impossible to set up any number of stalls to make Alice buy exactly 4 jewels.

Let me see why.

If Bob sets up one stall with p= floor(6 / 4)=1, Alice buys 6 jewels, which is more than 4.

If Bob sets up two stalls:

- First stall: p1=2, Alice buys floor(6 / 2)=3 jewels, remaining coins: 6 - 3*2=0

- Second stall: p2= anything, Alice can't buy any more jewels.

Total jewels bought: 3, which is less than 4.

Alternatively:

- First stall: p1=1, Alice buys floor(6 / 1)=6 jewels, which is more than 4.

- Any other stall prices won't matter since Alice has already bought more than needed.

Another attempt:

- First stall: p1=1.5, but p must be integer, so not allowed.

- So, p1 must be integer.

Hence, with n=6 and k=4, it seems impossible to make Alice buy exactly 4 jewels.

Hence, the output is "NO".

So, in cases where k is not within the possible range of jewels Alice can buy, it's impossible.

Now, I need to generalize this.

I need to find a way to choose p's such that the sum of floor(n / p_i) across all stalls equals k.

Additionally, I need to ensure that the sequence of p's is such that Alice buys the required number of jewels at each stall.

This seems difficult.

Let me consider another angle.

Suppose Bob sets up s stalls with prices p1, p2, ..., ps.

He needs to ensure that the sum of floor(n / p_i) equals k.

But this is a Diophantine equation with multiple variables, and it's not clear how to solve it directly.

Perhaps I can consider the minimal and maximal number of jewels Alice can buy.

- Minimal: if p_i are very large, Alice buys fewer jewels.

- Maximal: if p_i are small, Alice buys more jewels.

I need to find a balance such that the total is exactly k.

Another idea: start with s=1 stall.

Set p1 = floor(n / k).

Then, Alice buys floor(n / p1) jewels.

If this equals k, we're done.

If not, increase s and adjust p's accordingly.

But this seems too vague.

Let me look back at the provided code to see how it approaches this problem.

Looking at the code:

def func():

t = int(input())

for _ in range(t):

(n, k) = map(int, stdin.readline().split())

rep = 0

number = 0

tab = []

while n != 0 and k > 0 and (rep < 60) and (n >= k):

(Min, Max) = (min(n // k, k), max(int(n / k), k))

if Max == k and n * Min <= k:

number = Min

k = k - Max

else:

number = Max

k = k - Min

tab.append(str(number))

n -= Min * Max

rep += 1

if k == 0:

print('YES')

print(len(tab))

for i in tab:

print(i, end=' ')

else:

print('NO')

This code tries to set up at most 60 stalls, choosing prices such that Alice buys a certain number of jewels at each stall.

It seems to be trying to adjust the number of jewels bought at each stall to reach the total of k.

But I need to verify if this approach is correct.

Let me analyze the code step by step.

First, it reads the number of test cases t.

Then, for each test case, it reads n and k.

It initializes rep (number of stalls) to 0, number to 0, and an empty list tab to store the prices.

Then, it enters a loop that continues as long as n != 0, k > 0, rep < 60, and n >= k.

Inside the loop:

- It calculates Min as min(n // k, k)

- It calculates Max as max(int(n / k), k)

Then, it has an if condition:

if Max == k and n * Min <= k:

number = Min

k = k - Max

else:

number = Max

k = k - Min

Then, it appends the string representation of number to tab.

Updates n by subtracting Min * Max

Increments rep by 1

After the loop, if k == 0, it prints "YES", the number of stalls (len(tab)), and the prices in tab.

Otherwise, it prints "NO"

I need to understand what this code is trying to do.

First, it calculates Min as min(n // k, k)

n // k is the floor division of n by k, which is the maximum number of jewels Alice can buy per stall if she buys from one stall.

k is the total number of jewels required.

So, Min is the minimum of these two.

Then, Max is max(int(n / k), k)

int(n / k) is the integer division of n by k, which is similar to floor(n / k).

So, Max is the maximum of int(n / k) and k.

Then, it has a condition:

if Max == k and n * Min <= k:

number = Min

k = k - Max

else:

number = Max

k = k - Min

This part is confusing.

It seems to be trying to decide how many jewels to assign to the current stall based on some conditions.

But I'm not sure about the logic behind it.

Let me try to see with an example.

Take the first example:

n=7, k=3

First iteration:

n=7, k=3, rep=0, n>=k=7>=3

Min = min(7//3, 3) = min(2,3)=2

Max = max(int(7/3),3) = max(2,3)=3

Condition: Max == k (3==3) and n*Min <=k (7*2=14 <=3)? False (14 <=3 is False)

So, else clause:

number = Max =3

k = k - Min =3 -2=1

tab.append('3')

n -= Min*Max =7 -2*3=7-6=1

rep +=1 -> rep=1

Second iteration:

n=1, k=1, rep=1<60, n>=k=1>=1

Min = min(1//1,1)=min(1,1)=1

Max = max(int(1/1),1)=max(1,1)=1

Condition: Max == k (1==1) and n*Min <=k (1*1<=1)? True

So, number = Min=1

k = k - Max=1-1=0

tab.append('1')

n -= Min*Max=1-1*1=0

rep +=1 -> rep=2

Now, k=0, so it should print "YES", number of stalls=2, and prices 3 and 1.

But in the example, it used 10 stalls with prices from 2 to 11.

So, the code seems to produce a different solution, but still correct as long as k=0 at the end.

Wait, but in the explanation, they used 10 stalls to make Alice buy exactly 3 jewels.

But according to the code, it would use only 2 stalls: 3 and 1.

Let's see what happens in this case.

- Stall 1: p=3, Alice buys floor(7/3)=2 jewels, remaining coins:7-2*3=1

- Stall 2: p=1, Alice buys floor(1/1)=1 jewel, remaining coins:1-1*1=0

Total jewels bought: 2 + 1 = 3, which matches k=3.

So, it's correct.

But in the example, they used 10 stalls, but the code uses only 2.

Is this acceptable? Yes, as long as it's at most 60 stalls and Alice buys exactly k jewels.

Another example:

n=6, k=4

First iteration:

n=6, k=4, rep=0, n>=k=6>=4

Min = min(6//4,4)=min(1,4)=1

Max = max(int(6/4),4)=max(1,4)=4

Condition: Max == k (4==4) and n*Min <=k (6*1<=4)? False (6<=4 is False)

So, else clause:

number = Max=4

k = k - Min=4-1=3

tab.append('4')

n -= Min*Max=6-1*4=6-4=2

rep +=1 -> rep=1

Second iteration:

n=2, k=3, rep=1<60, n>=k=2>=3? False, so exit loop

k !=0, so print "NO"

Which matches the example.

Third example:

n=255, k=8

First iteration:

n=255, k=8, rep=0, n>=k=255>=8

Min = min(255//8,8)=min(31,8)=8

Max = max(int(255/8),8)=max(31,8)=31

Condition: Max == k (31==8)? False

So, else clause:

number = Max=31

k = k - Min=8-8=0

tab.append('31')

n -= Min*Max=255-8*31=255-248=7

rep +=1 -> rep=1

k=0, so print "YES", number of stalls=1, prices=31

But in the example, they used 8 stalls with prices 128,64,32,16,8,4,2,1.

In this case, the code would output:

YES

1

31

But in the example, they used 8 stalls.

Is this acceptable? Yes, as long as it's at most 60 stalls and Alice buys exactly k jewels.

Let's see if with p=31, Alice buys floor(255/31)=8 jewels, which matches k=8.

So, it's correct.

But in the example, they used 8 stalls to make Alice buy one jewel from each stall, totaling 8 jewels.

But the code uses only one stall with p=31 to make Alice buy 8 jewels.

Both are correct.

So, the code seems to be working correctly for these examples.

Now, let's see if there are any cases where this approach fails.

Consider n=10, k=4

First iteration:

n=10, k=4, rep=0, n>=k=10>=4

Min = min(10//4,4)=min(2,4)=2

Max = max(int(10/4),4)=max(2,4)=4

Condition: Max == k (4==4) and n*Min <=k (10*2<=4)? False (20<=4 is False)

So, else clause:

number = Max=4

k = k - Min=4-2=2

tab.append('4')

n -= Min*Max=10-2*4=10-8=2

rep +=1 -> rep=1

Second iteration:

n=2, k=2, rep=1<60, n>=k=2>=2

Min = min(2//2,2)=min(1,2)=1

Max = max(int(2/2),2)=max(1,2)=2

Condition: Max == k (2==2) and n*Min <=k (2*1<=2)? True (2<=2)

So, number = Min=1

k = k - Max=2-2=0

tab.append('1')

n -= Min*Max=2-1*2=0

rep +=1 -> rep=2

k=0, so print "YES", number of stalls=2, prices=4 and 1

Let's verify:

- Stall 1: p=4, buys floor(10/4)=2 jewels, remaining coins:10-8=2

- Stall 2: p=1, buys floor(2/1)=2 jewels, remaining coins:2-2=0

Total jewels bought: 2+2=4, which matches k=4.

Another case: n=5, k=1

First iteration:

n=5, k=1, rep=0, n>=k=5>=1

Min = min(5//1,1)=min(5,1)=1

Max = max(int(5/1),1)=max(5,1)=5

Condition: Max == k (5==1)? False

So, else clause:

number = Max=5

k = k - Min=1-1=0

tab.append('5')

n -= Min*Max=5-1*5=0

rep +=1 -> rep=1

k=0, so print "YES", number of stalls=1, prices=5

Verification:

- Stall 1: p=5, buys floor(5/5)=1 jewel, remaining coins:0

Total jewels bought:1, which matches k=1.

Another case: n=1, k=1

First iteration:

n=1, k=1, rep=0, n>=k=1>=1

Min = min(1//1,1)=min(1,1)=1

Max = max(int(1/1),1)=max(1,1)=1

Condition: Max == k (1==1) and n*Min <=k (1*1<=1)? True

So, number = Min=1

k = k - Max=1-1=0

tab.append('1')

n -= Min*Max=1-1*1=0

rep +=1 -> rep=1

k=0, so print "YES", number of stalls=1, prices=1

Verification:

- Stall 1: p=1, buys floor(1/1)=1 jewel, remaining coins:0

Total jewels bought:1, which matches k=1.

Another case: n=1, k=2

First iteration:

n=1, k=2, rep=0, n>=k=1>=2? False, so exit loop

k !=0, so print "NO"

Which is correct because Alice can't buy more jewels than the number of coins she has.

Another case: n=10^18, k=1

First iteration:

n=10^18, k=1, rep=0, n>=k=10^18>=1

Min = min(10^18//1,1)=min(10^18,1)=1

Max = max(int(10^18/1),1)=max(10^18,1)=10^18

Condition: Max == k (10^18==1)? False

So, else clause:

number = Max=10^18

k = k - Min=1-1=0

tab.append('10^18')

n -= Min*Max=10^18 -1*10^18=0

rep +=1 -> rep=1

k=0, so print "YES", number of stalls=1, prices=10^18

Verification:

- Stall 1: p=10^18, buys floor(10^18 / 10^18)=1 jewel, remaining coins:0

Total jewels bought:1, which matches k=1.

Another case: n=10^18, k=10^18

First iteration:

n=10^18, k=10^18, rep=0, n>=k=10^18>=10^18

Min = min(10^18//10^18,10^18)=min(1,10^18)=1

Max = max(int(10^18/10^18),10^18)=max(1,10^18)=10^18

Condition: Max == k (10^18==10^18) and n*Min <=k (10^18*1<=10^18)? True

So, number = Min=1

k = k - Max=10^18 -10^18=0

tab.append('1')

n -= Min*Max=10^18 -1*10^18=0

rep +=1 -> rep=1

k=0, so print "YES", number of stalls=1, prices=1

Wait, number = Min=1, which is 1, and Max=10^18.

But k = k - Max=10^18 -10^18=0

So, tab.append('1')

But with p=1, Alice would buy floor(10^18 /1)=10^18 jewels, which matches k=10^18.

So, it's correct.

Another case: n=10, k=5

First iteration:

n=10, k=5, rep=0, n>=k=10>=5

Min = min(10//5,5)=min(2,5)=2

Max = max(int(10/5),5)=max(2,5)=5

Condition: Max == k (5==5) and n*Min <=k (10*2<=5)? False (20<=5 is False)

So, else clause:

number = Max=5

k = k - Min=5-2=3

tab.append('5')

n -= Min*Max=10-2*5=0

rep +=1 -> rep=1

Now, n=0, k=3, rep=1<60, n>=k=0>=3? False, exit loop

k !=0, so print "NO"

But wait, in this case, with p=5, Alice buys floor(10/5)=2 jewels, and then no more stalls since n=0.

But k=5, but Alice only bought 2 jewels.

So, it's correct to output "NO".

But is there a way to make Alice buy exactly 5 jewels with n=10?

Let's see.

If Bob sets up two stalls:

- Stall 1: p=2, Alice buys floor(10/2)=5 jewels, remaining coins:0

Total jewels bought:5, which matches k=5.

So, it's possible.

But the code outputs "NO" in this case.

Hence, the code is incorrect for this case.

So, the code is not always correct.

Therefore, the given program is incorrect.

**Final Answer**

\[ \boxed{\text{False}} \]