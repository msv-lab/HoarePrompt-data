Alright, I've got this problem to solve. Let's see what it's asking for. So, Monocarp wants to throw a party and invite some of his friends, but there are some conditions. He has n friends, and each friend has a best friend, which is represented by p_i. The key points are:

1. All p_i are distinct and p_i ≠ i, so no one is their own best friend, and everyone has a unique best friend.

2. For a friend to come to the party, both the friend and their best friend must receive an invitation.

3. Monocarp wants at least 2 friends to come to the party.

4. He needs to send the minimum number of invitations to achieve this.

First, I need to understand the relationship between the friends and their best friends. Since p_i is the best friend of friend i, and all p_i are distinct, this forms a permutation of the friends. In other words, it's like a mapping where each friend is mapped to another unique friend.

For example, if n=5 and p=[3,1,2,5,4], then:

- Friend 1's best friend is 3

- Friend 2's best friend is 1

- Friend 3's best friend is 2

- Friend 4's best friend is 5

- Friend 5's best friend is 4

So, this forms some kind of cycles among the friends. In this case, friends 1,3,2 form a cycle, and friends 4 and 5 form another cycle.

I need to think about how these cycles affect who comes to the party.

Given that a friend comes only if both they and their best friend are invited, I need to figure out the minimal set of invitations that ensures at least two friends come.

Let me consider the example where n=5 and p=[3,1,2,5,4]. According to the sample input, sending invitations to friends 4 and 5 makes both come because they are each other's best friends and both are invited. So, in this case, inviting 2 people is enough to make 2 come.

Another example is n=4 and p=[2,3,4,1]. Here, inviting friends 1,2,3 makes friends 1 and 2 come, since 1 and his best friend 2 are invited, and 2 and his best friend 3 are invited. Friend 3 doesn't come because his best friend 4 isn't invited. So, with 3 invitations, at least 2 friends come.

The third example is n=2 and p=[2,1]. Inviting both makes both come, which is the only way since inviting just one wouldn't make anyone come.

From these examples, it seems that the minimal number of invitations needed depends on the structure of the cycles formed by the best friend relationships.

Let me think about cycles in more detail. If there is a cycle of length k, what is the minimal number of invitations needed to make at least one pair come?

For a cycle of length 2, like friends 4 and 5 in the first example, inviting both makes both come. So, for a cycle of length 2, inviting both is necessary to make them come.

For a cycle of length 3, like friends 1,3,2, inviting any two makes one pair come. For example, inviting 1 and 2 makes friend 2 come because he and his best friend 3 are invited. Similarly, inviting 1 and 3 makes friend 1 come because he and his best friend 3 are invited.

For cycles longer than 3, it's a bit more complicated. But in the second example, with a cycle of length 4: 1->2->3->4->1, inviting 1,2,3 makes friends 1 and 2 come.

Wait, but in that case, is there a way to make at least 2 friends come with fewer than 3 invitations?

Let's see:

- If I invite only 1 and 2: friend 1 will come because he and his best friend 2 are invited. Friend 2 will come because he and his best friend 3 are invited. But friend 3 isn't invited, so friend 2 doesn't come. Wait, no: friend 2 needs both himself and his best friend 3 to be invited. Since 3 isn't invited, friend 2 doesn't come. So, only friend 1 comes.

- If I invite 1,2,3: friend 1 and friend 2 come.

- If I invite 1,3,4: friend 1 and friend 3 come.

- If I invite 2,3,4: friend 2 and friend 3 come.

So, it seems that for a cycle of length 4, inviting any 3 consecutive friends makes at least 2 come.

Is there a way to make at least 2 come with only 2 invitations?

- Invite 1 and 3: friend 1 needs 2 to be invited, which isn't the case, so friend 1 doesn't come. Friend 3 needs 4 to be invited, which isn't the case, so friend 3 doesn't come. So, no one comes.

- Invite 1 and 4: friend 1 needs 2 to be invited, which isn't the case, so friend 1 doesn't come. Friend 4 needs 1 to be invited, which is the case, but friend 4's best friend is 1, who is invited, so friend 4 comes. But friend 1 doesn't come because his best friend 2 isn't invited. So, only friend 4 comes.

- Invite 2 and 4: friend 2 needs 3 to be invited, which isn't the case, so friend 2 doesn't come. Friend 4 needs 1 to be invited, which isn't the case, so friend 4 doesn't come. So, no one comes.

Thus, it's impossible to make at least 2 friends come with fewer than 3 invitations in this scenario.

So, for cycles of length 3, inviting any 2 makes at least one come, but we need at least 2 to come.

Wait, in the cycle of 3, inviting 2 makes 1 come, but we need at least 2 to come.

Wait, no, in the cycle of 3, inviting any 2 makes both of them come.

Wait, let's think again.

In cycle of 3: 1->3->2->1

If I invite 1 and 2:

- Friend 1 has best friend 3, who isn't invited, so friend 1 doesn't come.

- Friend 2 has best friend 3, who isn't invited, so friend 2 doesn't come.

- Friend 3 has best friend 2, who is invited, but friend 3 isn't invited, so friend 3 doesn't come.

Wait, so no one comes in this case.

Wait, that contradicts my earlier thought.

Wait, maybe I messed up.

Let me re-examine.

Given that a friend comes only if both they and their best friend are invited.

So, in the cycle of 3: 1->3->2->1

If I invite 1 and 2:

- Friend 1: invited, best friend 3 is not invited -> doesn't come.

- Friend 2: invited, best friend 3 is not invited -> doesn't come.

- Friend 3: not invited -> doesn't come.

So, no one comes.

Wait, but earlier I thought that inviting any 2 in a cycle of 3 makes at least one come. But according to this, no one comes.

Wait, maybe I was wrong.

Let me try inviting 1 and 3:

- Friend 1: invited, best friend 3 is invited -> comes.

- Friend 3: invited, best friend 2 is not invited -> doesn't come.

- Friend 2: not invited -> doesn't come.

So, only friend 1 comes.

Similarly, inviting 2 and 3:

- Friend 2: invited, best friend 3 is invited -> comes.

- Friend 3: invited, best friend 2 is invited -> comes.

So, both friends 2 and 3 come.

Ah, so in a cycle of 3, inviting any two adjacent friends makes both come, but inviting two non-adjacent doesn't make both come.

Wait, in cycle of 3, all friends are adjacent to each other in the cycle.

Wait, no, in a cycle of 3, each friend is connected to two others.

Wait, perhaps I need to think in terms of selecting friends such that their best friends are also invited.

In cycle of 3:

- Friends: 1->3, 3->2, 2->1

If I invite 1 and 2:

- Friend 1: invited, best friend 3 is invited -> comes.

- Friend 2: invited, best friend 3 is invited -> comes.

- Friend 3: not invited -> doesn't come.

Wait, but friend 3 is not invited, but friend 2's best friend is 3, who is invited, and friend 2 is invited, so friend 2 should come. Similarly, friend 1's best friend is 3, who is invited, and friend 1 is invited, so friend 1 comes.

Wait, but friend 3 is not invited, so friend 3 doesn't come.

So, friends 1 and 2 come.

Wait, but in the earlier thought, I had that friend 2 needs his best friend 3 to be invited, which is the case, and friend 2 is invited, so friend 2 comes. Similarly, friend 1 comes.

So, in this case, inviting 1 and 2 makes both 1 and 2 come.

Similarly, inviting 2 and 3 makes both 2 and 3 come.

Inviting 1 and 3 makes both 1 and 3 come.

Wait, but in the earlier example, when n=3 and p=[3,1,2], inviting 1 and 2 makes both 1 and 2 come.

Wait, but according to the condition, friend 3's best friend is 2, who is invited, but friend 3 isn't invited, so friend 3 doesn't come.

So, only friends 1 and 2 come.

Similarly, inviting 1 and 3 makes both 1 and 3 come, since friend 2's best friend is 3, who is invited, and friend 2 isn't invited, so friend 2 doesn't come.

Wait, no, friend 2 needs to be invited and his best friend invited to come.

So, friend 2 isn't invited, so doesn't come.

So, only friends 1 and 3 come.

Similarly, inviting 2 and 3 makes both come.

So, in a cycle of 3, inviting any 2 makes 2 come.

Therefore, for a cycle of 3, the minimal number of invitations to make at least 2 come is 2.

In a cycle of 4, as in the second example, inviting any 3 makes at least 2 come, but inviting only 2 doesn't guarantee that at least 2 come.

So, for cycle of 4, minimal invitations needed are 3.

Similarly, for a cycle of 2, inviting both makes both come.

So, for cycle of 2, minimal invitations needed are 2.

For cycle of 3, minimal invitations needed are 2.

For cycle of 4, minimal invitations needed are 3.

Wait, but in the first test case, there are two cycles: one of length 3 and one of length 2. And the answer is 2.

In the second test case, there is one cycle of length 4, and the answer is 3.

In the third test case, there is one cycle of length 2, and the answer is 2.

So, it seems that the minimal number of invitations needed is the minimum over the cycles' requirements.

Wait, but in the first test case, there are two separate cycles: one of length 3 and one of length 2. So, to make at least 2 friends come, we can choose to invite in one of the cycles.

In this case, inviting 2 in the cycle of 2 makes both come, which is 2 friends coming, so minimal invitations are 2.

Alternatively, in the cycle of 3, inviting any 2 makes 2 come, which is also 2 invitations.

So, overall, the minimal number is 2.

In the second test case, there is only one cycle of length 4, and the minimal invitations needed are 3.

In the third test case, there is only one cycle of length 2, and the minimal invitations needed are 2.

So, it seems that for disjoint cycles, the minimal invitations needed is the minimal over the minimal invitations needed for each cycle.

But in the first test case, there are two cycles: one requires 2 invitations, the other requires 2 invitations, so overall minimal is 2.

In the second test case, only one cycle of length 4, requires 3 invitations.

In the third test case, only one cycle of length 2, requires 2 invitations.

So, the general approach seems to be:

- Decompose the permutation into its cycles.

- For each cycle, determine the minimal number of invitations needed to make at least 2 friends come.

- Then, the overall minimal invitations needed is the minimal among these values.

But wait, in the first test case, there are two cycles: one of length 3 and one of length 2, both requiring 2 invitations, so overall minimal is 2.

In the second test case, only one cycle of length 4, requiring 3 invitations.

In the third test case, only one cycle of length 2, requiring 2 invitations.

So, this seems consistent.

Now, to generalize:

- For a cycle of length 2, minimal invitations needed are 2.

- For a cycle of length 3, minimal invitations needed are 2.

- For a cycle of length 4, minimal invitations needed are 3.

- For a cycle of length k, what is the minimal invitations needed to make at least 2 friends come?

Let me try to find a pattern.

For cycle of 2: invitations=2, friends coming=2.

For cycle of 3: invitations=2, friends coming=2.

For cycle of 4: invitations=3, friends coming=2.

For cycle of 5: what would it be?

Let's consider n=5 with a cycle of 5: 1->2->3->4->5->1.

If I invite 1,2,3:

- Friend 1: invited, best friend 2 is invited -> comes.

- Friend 2: invited, best friend 3 is invited -> comes.

- Friend 3: invited, best friend 4 is invited -> comes.

- Friend 4: invited, best friend 5 is invited -> comes.

- Friend 5: invited, best friend 1 is invited -> comes.

So, inviting 3 makes 3 come.

But we only need at least 2 to come.

Is there a way to make at least 2 come with fewer invitations?

Let's try inviting 1 and 2:

- Friend 1: invited, best friend 2 is invited -> comes.

- Friend 2: invited, best friend 3 is not invited -> doesn't come.

- Friend 3: not invited -> doesn't come.

- Friend 4: not invited -> doesn't come.

- Friend 5: not invited -> doesn't come.

So, only friend 1 comes.

Inviting 1 and 3:

- Friend 1: invited, best friend 2 is not invited -> doesn't come.

- Friend 3: invited, best friend 4 is not invited -> doesn't come.

- Friend 2: not invited -> doesn't come.

- Friend 4: not invited -> doesn't come.

- Friend 5: not invited -> doesn't come.

So, no one comes.

Inviting 1,2,3: makes friends 1,2,3 come.

Inviting 1,2,4: friend 1 comes, friend 2 doesn't (since best friend 3 isn't invited), friend 3 doesn't come, friend 4 comes (if best friend 5 is invited), but 5 isn't invited, so friend 4 doesn't come.

Wait, in inviting 1,2,4:

- Friend 1: invited, best friend 2 is invited -> comes.

- Friend 2: invited, best friend 3 is not invited -> doesn't come.

- Friend 4: invited, best friend 5 is not invited -> doesn't come.

- Friend 3: not invited -> doesn't come.

- Friend 5: not invited -> doesn't come.

So, only friend 1 comes.

Wait, that doesn't make sense. Maybe I'm missing something.

Wait, perhaps in cycle of 5, inviting 3 consecutive friends makes 3 come.

Wait, earlier with n=4, inviting 3 makes 2 come.

Wait, maybe for cycle of k, inviting ceil(k/2) makes floor(k/2) come.

But I need to make at least 2 come with minimal invitations.

Alternatively, perhaps for any cycle of length k, the minimal invitations needed to make at least 2 come is min{ invitations needed to make any 2 specific friends come }.

But that seems too vague.

Wait, perhaps I need to look for cycles where p_i forms a derangement with no fixed points, since p_i ≠ i and all p_i are distinct.

Given that, the permutation is a derangement consisting of disjoint cycles.

In such a case, to make at least 2 friends come, I need to find a way to invite a subset of friends such that at least 2 friends have both themselves and their best friends invited.

Given that, perhaps the minimal number of invitations is 2 for cycles of length 2 and 3, and for longer cycles, it's the ceiling of k/2.

Wait, in cycle of 4, inviting 3 makes 2 come, which is ceil(4/2)=2, but earlier I thought it's 3.

Wait, maybe I need to rethink.

Wait, perhaps in cycle of 4, inviting 2 specific friends doesn't make 2 come, but inviting 3 does.

Wait, but maybe there's a better way.

Let me consider cycle of 4: 1->2->3->4->1

If I invite 1,3,4:

- Friend 1: invited, best friend 2 is not invited -> doesn't come.

- Friend 3: invited, best friend 4 is invited -> comes.

- Friend 4: invited, best friend 1 is invited -> comes.

- Friend 2: not invited -> doesn't come.

So, friends 3 and 4 come.

Similarly, inviting 1,2,3:

- Friend 1: invited, best friend 2 is invited -> comes.

- Friend 2: invited, best friend 3 is invited -> comes.

- Friend 3: invited, best friend 4 is not invited -> doesn't come.

- Friend 4: not invited -> doesn't come.

So, friends 1 and 2 come.

Inviting 1,2,4:

- Friend 1: invited, best friend 2 is invited -> comes.

- Friend 2: invited, best friend 3 is not invited -> doesn't come.

- Friend 4: invited, best friend 1 is invited -> comes.

- Friend 3: not invited -> doesn't come.

So, friends 1 and 4 come.

Inviting 2,3,4:

- Friend 2: invited, best friend 3 is invited -> comes.

- Friend 3: invited, best friend 4 is invited -> comes.

- Friend 4: invited, best friend 1 is not invited -> doesn't come.

- Friend 1: not invited -> doesn't come.

So, friends 2 and 3 come.

So, in all these cases, inviting 3 makes at least 2 come.

Is there a way to make at least 2 come with only 2 invitations?

Earlier attempts showed that inviting only 2 doesn't make at least 2 come.

So, for cycle of 4, minimal invitations needed are 3.

Similarly, for cycle of 5, inviting 3 makes at least 2 come, but inviting only 2 doesn't.

Wait, let's check cycle of 5:

Friends: 1->2->3->4->5->1

Invite 1 and 2:

- Friend 1: invited, best friend 2 is invited -> comes.

- Friend 2: invited, best friend 3 is not invited -> doesn't come.

- Friend 3: not invited -> doesn't come.

- Friend 4: not invited -> doesn't come.

- Friend 5: not invited -> doesn't come.

So, only friend 1 comes.

Invite 1 and 3:

- Friend 1: invited, best friend 2 is not invited -> doesn't come.

- Friend 3: invited, best friend 4 is not invited -> doesn't come.

- Friend 2: not invited -> doesn't come.

- Friend 4: not invited -> doesn't come.

- Friend 5: not invited -> doesn't come.

So, no one comes.

Invite 1,2,3:

- Friend 1: invited, best friend 2 is invited -> comes.

- Friend 2: invited, best friend 3 is invited -> comes.

- Friend 3: invited, best friend 4 is not invited -> doesn't come.

- Friend 4: not invited -> doesn't come.

- Friend 5: not invited -> doesn't come.

So, friends 1 and 2 come.

Invite 1,3,4:

- Friend 1: invited, best friend 2 is not invited -> doesn't come.

- Friend 3: invited, best friend 4 is invited -> comes.

- Friend 4: invited, best friend 1 is invited -> comes.

- Friend 2: not invited -> doesn't come.

- Friend 5: not invited -> doesn't come.

So, friends 3 and 4 come.

So, in both cases, inviting 3 makes at least 2 come.

Is there a way to make at least 2 come with only 2 invitations?

From above, no.

So, for cycle of 5, minimal invitations needed are 3.

Similarly, for cycle of 4, minimal invitations needed are 3.

For cycle of 3, minimal invitations needed are 2.

For cycle of 2, minimal invitations needed are 2.

So, perhaps for cycles of length k >= 3, the minimal invitations needed are ceil(k/2).

Wait, for k=3, ceil(3/2)=2, which matches.

For k=4, ceil(4/2)=2, but earlier I thought it's 3.

Wait, maybe I need to adjust this.

Alternatively, perhaps it's floor((k+1)/2).

For k=3: floor(4/2)=2

For k=4: floor(5/2)=2, but earlier it seems 3 are needed.

Wait, maybe not.

Alternatively, perhaps it's k - floor(k/3).

Wait, that doesn't seem to fit.

Alternatively, perhaps for k >= 3, minimal invitations needed are k - floor(k/2).

Wait, for k=3: 3 - 1 = 2

For k=4: 4 - 2 = 2, but earlier it seems 3 are needed.

Wait, not matching.

Alternatively, perhaps k - ceil(k/2) + 1.

For k=3: 3 - 2 +1 =2

For k=4: 4 - 2 +1=3, which matches earlier observation.

For k=5: 5 - 3 +1=3, which also matches.

So, perhaps for cycle of length k >=3, minimal invitations needed are k - ceil(k/2) +1.

Which simplifies to floor((k+1)/2).

Wait, let's check:

For k=3: floor(4/2)=2

For k=4: floor(5/2)=2, but earlier we saw that 3 are needed.

Wait, doesn't match.

Alternatively, perhaps ceil(k/2).

For k=3: ceil(1.5)=2, matches.

For k=4: ceil(2)=2, but earlier we saw needing 3.

Wait, doesn't match.

Alternatively, maybe it's ceil(k/2) +1 - something.

Wait, perhaps I'm overcomplicating.

Looking back at the examples:

- k=2: invitations=2

- k=3: invitations=2

- k=4: invitations=3

- k=5: invitations=3

So, for k=2: 2

For k=3: 2

For k>=4: k-1

Wait, no, for k=4: 3, which is k-1=3

For k=5: 3, which is k-2=3

Wait, not consistent.

Alternatively, for k>=3: floor((k+1)/2)

For k=3: 2

For k=4: 2

For k=5: 3

But earlier, for k=4, we saw that inviting 3 makes at least 2 come, and inviting 2 doesn't.

Similarly, for k=5, inviting 3 makes at least 2 come, and inviting 2 doesn't.

So, perhaps minimal invitations needed for cycle of length k is ceil(k/2).

For k=2: ceil(1)=1, but in reality, need 2.

Wait, doesn't match.

Wait, perhaps it's ceil(k/2) when k>=3, and for k=2, it's 2.

But in k=3, ceil(1.5)=2, matches.

For k=4, ceil(2)=2, but needs 3.

Doesn't match.

Alternatively, maybe it's floor((k+1)/2).

For k=3: 2, matches.

For k=4: 2, but needs 3.

Doesn't match.

Wait, perhaps it's floor((k+2)/3) or something.

Wait, perhaps I should look for a different approach.

Let me consider that in a cycle of length k, the minimal number of invitations to make at least 2 friends come is the minimal number such that there are at least 2 friends who are both invited and their best friends are invited.

Given that, in a cycle of length k, to make a friend come, both the friend and their best friend must be invited.

So, to make at least 2 friends come, we need at least 2 pairs of friends and their best friends to be invited.

Wait, but friends' best friends are already determined by the permutation.

Wait, perhaps I need to model this as a graph where friends are nodes, and best friends are edges.

So, it's a graph where each node has exactly one outgoing edge (to their best friend), and since p_i are distinct and p_i ≠ i, it's a union of disjoint cycles.

Given that, I can consider each cycle separately.

In each cycle, I need to select a subset of friends to invite such that at least 2 friends have both themselves and their best friends invited.

I need to minimize the number of invitations.

This sounds like a graph problem where I need to select a subset of nodes to activate, such that certain conditions are met.

Alternatively, perhaps I can think in terms of selecting edges.

Wait, perhaps it's better to think in terms of selecting friends to invite, and ensuring that for at least 2 friends, both they and their best friends are invited.

Given that, perhaps I can model this as a set cover problem, but that might be too complicated.

Alternatively, perhaps I can look for a pattern in the minimal invitations needed for different cycle lengths.

From earlier observations:

- k=2: invitations=2

- k=3: invitations=2

- k=4: invitations=3

- k=5: invitations=3

Is there a general formula for cycle of length k?

Looking at the pattern:

For k=2: 2

For k=3: 2

For k=4: 3

For k=5: 3

For k=6: ?

Let's consider k=6.

Suppose we have a cycle: 1->2->3->4->5->6->1

What's the minimal number of invitations to make at least 2 come?

Let's try inviting 1,3,5:

- Friend 1: invited, best friend 2 is not invited -> doesn't come.

- Friend 3: invited, best friend 4 is not invited -> doesn't come.

- Friend 5: invited, best friend 6 is not invited -> doesn't come.

- Friend 2: not invited -> doesn't come.

- Friend 4: not invited -> doesn't come.

- Friend 6: not invited -> doesn't come.

So, no one comes.

Invite 1,2,4,5:

- Friend 1: invited, best friend 2 is invited -> comes.

- Friend 2: invited, best friend 3 is not invited -> doesn't come.

- Friend 4: invited, best friend 5 is invited -> comes.

- Friend 5: invited, best friend 6 is not invited -> doesn't come.

- Friend 3: not invited -> doesn't come.

- Friend 6: not invited -> doesn't come.

So, friends 1 and 4 come.

Is there a way to make at least 2 come with fewer than 4 invitations?

Invite 1,2,4:

- Friend 1: invited, best friend 2 is invited -> comes.

- Friend 2: invited, best friend 3 is not invited -> doesn't come.

- Friend 4: invited, best friend 5 is not invited -> doesn't come.

- Friend 3: not invited -> doesn't come.

- Friend 5: not invited -> doesn't come.

- Friend 6: not invited -> doesn't come.

So, only friend 1 comes.

Invite 1,2,5:

- Friend 1: invited, best friend 2 is invited -> comes.

- Friend 2: invited, best friend 3 is not invited -> doesn't come.

- Friend 5: invited, best friend 6 is not invited -> doesn't come.

- Friend 3: not invited -> doesn't come.

- Friend 4: not invited -> doesn't come.

- Friend 6: not invited -> doesn't come.

So, only friend 1 comes.

Invite 1,3,5:

As before, no one comes.

Invite 1,3,4:

- Friend 1: invited, best friend 2 is not invited -> doesn't come.

- Friend 3: invited, best friend 4 is invited -> comes.

- Friend 4: invited, best friend 5 is not invited -> doesn't come.

- Friend 2: not invited -> doesn't come.

- Friend 5: not invited -> doesn't come.

- Friend 6: not invited -> doesn't come.

So, only friend 3 comes.

Invite 1,2,3:

- Friend 1: invited, best friend 2 is invited -> comes.

- Friend 2: invited, best friend 3 is invited -> comes.

- Friend 3: invited, best friend 4 is not invited -> doesn't come.

- Friend 4: not invited -> doesn't come.

- Friend 5: not invited -> doesn't come.

- Friend 6: not invited -> doesn't come.

So, friends 1 and 2 come.

So, with 3 invitations, we can make 2 come.

Is this the minimal?

It seems that for k=6, inviting 3 makes 2 come.

Wait, but earlier with k=4, inviting 3 makes 2 come.

Similarly, for k=5, inviting 3 makes 2 come.

For k=3, inviting 2 makes 2 come.

For k=2, inviting 2 makes 2 come.

So, perhaps for any k >=2, the minimal invitations needed to make at least 2 come is ceil(k/2).

For k=2: ceil(1)=1, but need to invite both, which is 2. So, doesn't match.

Wait, perhaps it's floor((k+1)/2).

For k=2: floor(1.5)=1, but need 2.

Still doesn't match.

Alternatively, perhaps it's k - floor(k/3).

For k=3: 3-1=2, matches.

For k=4: 4-1=3, matches.

For k=5: 5-1=4, but needs 3.

Doesn't match.

Alternatively, perhaps it's floor((k+1)/2) when k>=2.

For k=2: floor(1.5)=1, but needs 2.

Doesn't match.

Alternatively, perhaps it's k - ceil(k/3).

For k=3: 3-1=2, matches.

For k=4: 4-2=2, but needs 3.

Doesn't match.

This is getting too complicated. Maybe I should look for another approach.

Let me consider that in any cycle, to make at least 2 friends come, I need to select a subset of friends to invite such that at least 2 friends have both themselves and their best friends invited.

Given that, perhaps I can think in terms of selecting friends in such a way that their best friends are also invited, and similarly for their best friends.

This seems recursive.

Alternatively, perhaps I can model this as selecting edges in the cycle graph where each edge represents a friend and their best friend.

Wait, perhaps I should think in terms of selecting pairs of friends who are each other's best friends, but given that p_i ≠ i and all p_i are distinct, no two friends can be each other's best friends, unless n is even and it's a perfect matching, but even then, in cycles, it's not the case.

Wait, in a cycle of even length, it's possible to have pairs where each pair consists of friends who are each other's best friends, but in cycles, it's not the case.

Wait, in a cycle, the best friend of a friend is another specific friend, forming a circular chain.

So, perhaps in cycles of even length, it's possible to select every other friend.

Wait, but earlier examples don't support that.

Perhaps I need to abandon trying to find a general formula based on cycle length and think differently.

Let me look at the sample inputs and outputs again.

Sample Input:

3

5

3 1 2 5 4

4

2 3 4 1

2

2 1

Sample Output:

2

3

2

Looking at the first test case: n=5, p=[3,1,2,5,4]

This forms two cycles: 1->3->2->1 and 4->5->4.

To make at least 2 friends come, we can focus on the cycle of 3 (1,3,2) and invite any 2 to make 2 come, or focus on the cycle of 2 (4,5) and invite both to make both come.

So, minimal invitations are 2.

Second test case: n=4, p=[2,3,4,1]

This is a single cycle: 1->2->3->4->1

To make at least 2 come, need to invite 3 friends.

Third test case: n=2, p=[2,1]

Single cycle of 2: inviting both makes both come.

So, minimal invitations are 2.

So, overall, it seems that for each cycle, I need to determine the minimal invitations needed to make at least 2 come, and then take the minimal among all cycles.

But in the first test case, there are two cycles: one of length 3 and one of length 2, both requiring 2 invitations, so overall minimal is 2.

In the second test case, only one cycle of length 4, requiring 3 invitations.

In the third test case, only one cycle of length 2, requiring 2 invitations.

So, the general approach is:

- Decompose the permutation into disjoint cycles.

- For each cycle, determine the minimal number of invitations needed to make at least 2 friends come.

- The overall minimal number of invitations is the minimal among these values.

But earlier, I saw that for cycle of 3, minimal invitations are 2, and for cycle of 4, it's 3.

But perhaps there's a smarter way to compute this.

Looking back at the provided program:

def func_1():

n = int(input())

v = [0] * (n + 1)

v = [0] + list(map(int, input().split()))

if n == 2:

print(2)

else:

for i in range(1, n + 1):

if v[v[v[i]]] == i:

print(2)

return

print(3)

So, for n=2, it directly prints 2.

For n >=3, it checks if there exists any i such that v[v[v[i]]] == i, meaning that applying the permutation three times brings us back to i.

In other words, there exists a cycle of length 3 involving i.

If such a cycle exists, it prints 2, else it prints 3.

Wait, but in the second test case, n=4 with p=[2,3,4,1], which is a cycle of length 4, and there are no cycles of length 3, so it prints 3, which matches the sample output.

In the first test case, n=5 with p=[3,1,2,5,4], which has a cycle of length 3 (1,3,2), so it prints 2, matching the sample output.

In the third test case, n=2 with p=[2,1], which has only a cycle of length 2, so it prints 2, matching the sample output.

So, this seems to be a correct approach.

But why does this work?

Because if there exists a cycle of length 3, then inviting any 2 in that cycle makes 2 come, so minimal invitations are 2.

If there are only cycles of length >=4, then the minimal invitations needed are 3.

Wait, but in the cycle of 3, inviting any 2 makes both come, as we saw earlier.

In cycles of length >=4, inviting 3 makes at least 2 come, and inviting fewer doesn't.

So, the program checks if there is any cycle of length 3, and if so, prints 2, else prints 3.

This seems to be correct based on the sample inputs and my earlier analysis.

Therefore, the program is correct.

**Final Answer**

\boxed{\text{See explanation for the program's correctness.}}