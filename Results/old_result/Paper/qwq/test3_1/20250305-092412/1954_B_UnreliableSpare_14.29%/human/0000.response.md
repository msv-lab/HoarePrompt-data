Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a beautiful array, and I need to find the minimum number of elements to remove so that it's no longer beautiful. Or output -1 if it's impossible.

First, I need to understand what makes an array beautiful. According to the problem, an array is beautiful if you can make all its elements the same by using a specific operation any number of times. The operation is: choose an index i (where 2 ≤ i ≤ |a| - 1) such that a[i-1] equals a[i+1], and then replace a[i] with a[i-1].

So, in other words, if the elements on both sides of an element are the same, I can change that element to match them. This operation can be repeated as many times as I want.

My task is to make the array not beautiful by removing the fewest possible elements. If it's impossible to make it not beautiful, I should output -1.

Let me look at the examples to understand better.

In the first test case:

3

2 2 2

It's already all elements the same. No matter how many elements I remove, it will still be possible to make all elements the same using the operation, right? Because if I remove one 2, I'm left with two 2's, which are already the same. Even if I remove two 2's, I'm left with one 2, which is trivially all the same. So, it's impossible to make it not beautiful, hence -1.

In the second test case:

5

1 2 1 2 1

Here, it's not all elements the same. Let's see if it's beautiful. Can I make all elements the same using the operation?

Looking at index 2 (value 1), a[1]=1 and a[3]=1, so I can replace a[2] with 1. Then the array becomes [1,1,1,2,1]. Now, looking at index 3 (value 2), a[2]=1 and a[4]=1, so I can replace a[3] with 1. Now the array is [1,1,1,1,1]. So, it's beautiful.

Now, I need to remove the minimum number of elements to make it not beautiful. In the explanation, it says removing the element at index 5, for example, gives [1,2,1,2]. They show that this new array isn't beautiful because no matter which operations I apply, I can't make all elements the same.

So, in this case, removing one element is sufficient to make it not beautiful.

In the third test case:

1

1

It's a single element, which is already all the same. Removing the only element leaves an empty array, which, according to the problem, is not considered beautiful. So, removing one element is enough, but the output is -1. Wait, that seems contradictory.

Wait, the problem says: "the given array a is beautiful. What is the minimum number of elements you have to remove from it in order for it to stop being beautiful. Swapping elements is prohibited. If it is impossible, then output -1."

In the third test case, n=1, a=[1]. It's already beautiful. If I remove the single element, I get an empty array. Is an empty array considered not beautiful? Probably yes, because there are no elements to apply the operation. So, removing one element makes it not beautiful. But the output is -1. Hmm.

Wait, maybe the problem considers that removing elements leads to a non-beautiful array only if the remaining array is non-empty and not beautiful. If the array becomes empty, it's considered beautiful or not? The problem might consider an empty array as not beautiful, but the output is -1, so maybe it's impossible to make it not beautiful in this case.

I need to clarify this.

Looking back at the first test case, with n=3 and all elements 2, removing any number of elements still leaves a beautiful array, including the empty array. So, -1 is output.

In the third test case, n=1, a=[1], removing the element gives an empty array, which might be considered still beautiful, hence -1.

In the fourth test case, n=7, a=[3,3,3,5,3,3,3]. It's beautiful because I can make all elements 3 by replacing the 5 with 3. If I remove the first three elements, I'm left with [5,3,3,3], which is not beautiful because I can't make all elements the same using the operation.

So, the key seems to be: if the array has all elements the same, it's always beautiful, and removing elements won't make it not beautiful, hence -1.

If the array has different elements, I need to find a way to remove elements to prevent making all elements the same using the operation.

Looking at the provided program, it seems to handle these cases.

Let me analyze the program step by step.

First, it reads the number of test cases and iterates through each one.

In func_1:

- Read n and the array arr.

- Check if all elements in arr are the same by iterating through the array and seeing if any element differs from the first one. If they all are the same, set flag to True; otherwise, False.

- If flag is True, meaning all elements are the same, print -1.

- Else, find the minimum frequency of any element in arr and print that.

Wait, no. Looking closely:

- It initializes val to arr[0] and cnt to 0.

- Then iterates through arr, incrementing cnt if arr[i] == val, otherwise takes the minimum of ans and cnt, and resets cnt to 1 if arr[i] == val.

- Finally, takes the minimum of ans and cnt.

This seems incorrect for finding the minimum number of elements to remove.

Wait, perhaps it's trying to find the minimum frequency of any element.

But the code seems flawed.

Let me think differently.

From the problem, I need to make sure that after removal, the array is not beautiful.

A array is not beautiful if it's impossible to make all elements the same using the given operation.

Given that the array is initially beautiful, I need to disrupt its structure by removing elements.

One approach is to ensure that after removal, there are at least two different elements that cannot be made the same using the operation.

But this seems too vague.

Another way is to consider that if all elements are the same, it's impossible to make it not beautiful by removing elements, which aligns with the first and third test cases.

If not all elements are the same, I need to remove elements such that the remaining array cannot be made all the same.

Considering the operation allows changing a[i] to a[i-1] or a[i+1] if they are equal.

So, to make it not beautiful, I need to ensure that after removal, there is no way to make all elements equal by applying such operations.

One strategy is to remove elements such that the remaining array has at least two different elements that cannot be made the same through the operation.

But this is still unclear.

Looking back at the second test case:

Original array: [1,2,1,2,1]

After removing a[5], we get [1,2,1,2]

Now, trying to make all elements the same:

- Can I change any a[i] where a[i-1] == a[i+1]?

Looking at index 2 (1), a[1]=1 and a[3]=2, which are not equal, so no operation can be applied.

Similarly, index 3 (2), a[2]=1 and a[4]=2, which are not equal, so no operation can be applied.

Hence, the array cannot be made beautiful.

So, in this case, removing one element is sufficient.

In the fourth test case:

Original array: [3,3,3,5,3,3,3]

After removing the first three elements, we get [5,3,3,3]

Now, trying to make all elements the same:

- Look for indices where a[i-1] == a[i+1].

- Index 2: a[1]=5, a[3]=3 → different, no operation.

- Index 3: a[2]=3, a[4]=3 → equal, so can replace a[3] with 3 (but it's already 3).

- No changes can be made, and since there's a 5 and 3's, it's not possible to make all elements the same.

Hence, it's not beautiful after removal.

So, the strategy seems to be: remove elements such that there are at least two different elements that cannot be made the same through the operation.

But I need a more concrete approach.

Perhaps, find the minimum number of elements to remove so that the remaining array does not have all elements the same, and no sequence of operations can make them all the same.

Given that the array is initially beautiful, meaning that it's possible to make all elements the same through operations.

So, to make it not beautiful, I need to ensure that after removal, it's impossible to make all elements the same.

One way to think about it is: find the smallest set of elements to remove such that the remaining array has at least two different elements, and these elements cannot be made the same through the operations.

But I need a better way to compute this.

Let me consider the frequency of the most frequent element.

If I remove all elements that are not the most frequent element, the remaining array will have all elements equal to the most frequent element.

But I need to prevent this.

Wait, but in the second test case, the most frequent element is 1, appearing three times.

If I remove one element, say the last one, I get [1,2,1,2], which has two 1's and two 2's.

This is not beautiful, as shown.

So, in this case, removing one element is sufficient.

In the fourth test case, the most frequent element is 3, appearing six times.

If I remove three elements, specifically the three 3's at the beginning, I'm left with [5,3,3,3], which has one 5 and three 3's.

Since there's a 5 present, and no way to change it to 3 using the operation (because its neighbors are 3 and 3, so I can replace it with 3, but in this case, it's already 5), it's not beautiful.

So, perhaps the minimum number of elements to remove is the total number of elements minus the frequency of the most frequent element.

Because if I remove all elements except the most frequent one, the remaining array will have all elements equal to the most frequent element, which is beautiful.

But I need to make it not beautiful, so I need to remove one less than that.

Wait, no.

Wait, let's think differently.

Suppose the frequency of the most frequent element is freq_max.

Total elements are n.

If I remove n - freq_max elements, I'm left with freq_max elements, all equal to the most frequent element, which is still beautiful.

So, I need to leave at least one element that is not the most frequent element, so that the array cannot be made beautiful.

Wait, but in the second test case, freq_max is 3 (for 1), and n=5.

So, n - freq_max = 2.

But in the explanation, removing one element is sufficient.

So, my previous thought is incorrect.

Wait, perhaps I need to remove elements such that the remaining array does not allow all elements to be made the same.

This seems tricky.

Let me consider that in a beautiful array, it's possible to make all elements equal by replacing a[i] with a[i-1] or a[i+1] when a[i-1] == a[i+1].

This operation can be seen as propagating the values from the ends towards the center, provided that the ends are equal.

In other words, if the array has sections where elements are the same at the ends, I can propagate those values inward.

Given that, to make the array not beautiful, I need to ensure that after removal, there are sections where elements are different and cannot be made equal through propagation.

This is still vague.

Looking back at the provided program, it seems to handle two cases:

1. If all elements are the same, output -1.

2. Otherwise, find the minimum frequency of any element and print that.

But in the second test case, the minimum frequency is 2 (for 2), and the program would print 2, but the correct answer is 1.

So, the program is incorrect.

Wait, the program seems to calculate the minimum frequency of the most frequent element, but it's not clear.

Looking at the code:

It initializes val to arr[0] and cnt to 0.

Then iterates through arr:

- If arr[i] == val, increment cnt.

- Else, set ans to min(ans, cnt) and reset cnt to 1 if arr[i] == val.

Finally, set ans to min(ans, cnt).

This seems like an attempt to find the minimum frequency of any element.

But in the second test case, frequencies are:

1:3, 2:2.

So, minimum frequency is 2.

But the program should output 1, according to the example.

Hence, the program is incorrect.

Wait, perhaps it's finding the minimum number of consecutive elements that are the same.

But in the second test case, the minimum number of consecutive 1's or 2's is 1.

Wait, let's simulate the program for the second test case.

arr = [1,2,1,2,1]

val = 1, cnt=0

i=0: arr[0]=1 == val -> cnt=1

i=1: arr[1]=2 != val -> ans = min(Infinity,1) =1, cnt=0

i=2: arr[2]=1 == val -> cnt=1

i=3: arr[3]=2 != val -> ans = min(1,1)=1, cnt=0

i=4: arr[4]=1 == val -> cnt=1

ans = min(1,1)=1

So, it would print 1, which matches the example.

Wait, but according to my earlier thought, if all elements are the same, it should print -1, which it does.

In the fourth test case:

arr = [3,3,3,5,3,3,3]

val=3, cnt=0

i=0: 3 == val -> cnt=1

i=1: 3 == val -> cnt=2

i=2: 3 == val -> cnt=3

i=3: 5 != val -> ans = min(Infinity,3)=3, cnt=0

i=4: 3 == val -> cnt=1

i=5: 3 == val -> cnt=2

i=6: 3 == val -> cnt=3

ans = min(3,3)=3

So, it would print 3, which matches the example.

Seems correct.

But wait, in the second test case, it prints 1, which matches the example.

And in the first test case:

arr = [2,2,2]

All elements are the same, so flag=True, print -1.

Seems correct.

And in the third test case:

arr = [1]

All elements are the same, flag=True, print -1.

Seems correct.

So, perhaps the program is correct.

But earlier I thought that in the second test case, the minimum frequency is 2, but the program prints 1, which seems incorrect.

Wait, no.

In the second test case, the program prints 1, which matches the expected output.

But according to my earlier reasoning, if I remove one element, it's possible to make it not beautiful, as shown in the explanation.

So, perhaps the program is correct.

Maybe the logic is different.

Perhaps the program is finding the minimum number of consecutive elements that are the same.

In the second test case, the minimum number of consecutive 1's or 2's is 1.

Hence, printing 1.

In the fourth test case, the minimum number of consecutive 3's is 1 (at position 3), so it should print 1, but according to the example, it's printing 3.

Wait, in the fourth test case, the array is [3,3,3,5,3,3,3], so the minimum number of consecutive 3's is 1 (at position 3), but the program is printing 3.

Wait, perhaps I misread the code.

Looking back at the code:

(ans, val, cnt) = (Decimal('Infinity'), arr[0], 0)

for i in range(n):

if arr[i] == val:

cnt +=1

else:

ans = min(ans, cnt)

if arr[i] == val:

cnt =1

ans = min(ans, cnt)

Wait, this seems flawed.

In the fourth test case, arr = [3,3,3,5,3,3,3]

val =3, cnt=0

i=0: 3==3 -> cnt=1

i=1: 3==3 -> cnt=2

i=2: 3==3 -> cnt=3

i=3: 5!=3 -> ans = min(Infinity,3)=3, cnt=0

i=4: 3==3 -> cnt=1

i=5: 3==3 -> cnt=2

i=6: 3==3 -> cnt=3

ans = min(3,3)=3

Hence, prints 3.

But according to the explanation, removing the first three elements is sufficient, which is 3 elements, matching the program's output.

In the second test case, arr=[1,2,1,2,1]

val=1, cnt=0

i=0:1==1 -> cnt=1

i=1:2!=1 -> ans=min(Infinity,1)=1, cnt=0

i=2:1==1 -> cnt=1

i=3:2!=1 -> ans=min(1,1)=1, cnt=0

i=4:1==1 -> cnt=1

ans=min(1,1)=1

Hence, prints 1, which matches the example.

So, perhaps the logic is to find the minimum run of consecutive elements that are the same.

In the first test case, all elements are the same, so flag=True, print -1.

In the second test case, the minimum run of consecutive same elements is 1.

In the fourth test case, the minimum run is 1 (for 5), but since 5 appears only once, removing one 3 won't make the array not beautiful.

Wait, but according to the program, it's printing 3, which matches the example.

But in the explanation, removing the first three elements is sufficient, which is 3 removals.

So, perhaps the program is finding the minimum number of consecutive elements that are the same, and in the fourth test case, the minimum is 3.

Wait, but earlier I thought it should be 1, but according to the code, it's 3.

Wait, perhaps I misread the code.

Looking back:

(ans, val, cnt) = (Decimal('Infinity'), arr[0], 0)

for i in range(n):

if arr[i] == val:

cnt +=1

else:

ans = min(ans, cnt)

if arr[i] == val:

cnt =1

ans = min(ans, cnt)

Wait, there's an issue here.

In the else clause, after ans = min(ans, cnt), it sets cnt=1 if arr[i]==val.

But in the fourth test case, at i=4, arr[4]=3==val, so cnt=1.

Then i=5: arr[5]=3==val -> cnt=2

i=6: arr[6]=3==val -> cnt=3

Then ans = min(3,3)=3

Hence, prints 3.

So, it's finding the minimum length of runs of the initial value.

In the second test case, the runs of 1's are of length 1 and 2, so minimum is 1.

Hence, prints 1.

In the fourth test case, the runs of 3's are of length 3 and 3, so minimum is 3.

Hence, prints 3.

Seems consistent with the examples.

But is this logic correct in general?

Let me think about another test case.

Suppose n=4, arr=[1,1,2,2]

All elements are not the same, so flag=False.

The runs are:

1's: length 2

2's: length 2

So, minimum run length is 2.

Hence, program would print 2.

Is this correct?

To check if removing 2 elements can make it not beautiful.

Let's see:

Original array: [1,1,2,2]

If I remove two elements, for example, remove the first two: [2,2], which is beautiful.

Remove the first and the last: [1,2], which is not beautiful.

Hence, removing two elements can make it not beautiful.

So, in this case, the program's output of 2 is correct.

Another test case: n=6, arr=[1,2,1,2,1,2]

All elements are not the same.

Check if it's beautiful.

Can I make all elements the same?

Starting with [1,2,1,2,1,2]

Look for indices where a[i-1]==a[i+1].

Index 2: a[1]=1, a[3]=2 != a[2]=1, so can't replace.

Index 3: a[2]=1, a[4]=1 == a[3]=2, so can replace a[3] with 1.

Now array is [1,2,1,1,1,2]

Now, index 2: a[1]=2, a[3]=1 != a[2]=1, no operation.

Index 3: a[2]=1, a[4]=1 == a[3]=1, no change needed.

Index 4: a[3]=1, a[5]=1 == a[4]=1, no change needed.

So, after one operation, the array becomes [1,2,1,1,1,2].

No more operations can be applied.

This array is not beautiful because I cannot make all elements the same.

Wait, but according to the problem, the given array is beautiful, meaning that it's possible to make all elements the same.

But in this case, it seems not possible.

Hence, this might not be a valid test case, as per the problem's guarantee that the array is beautiful.

Assuming the array is beautiful, meaning that it's possible to make all elements the same.

So, in this test case, I must be wrong somewhere.

Wait, perhaps I can choose different indices.

Starting with [1,2,1,2,1,2]

Choose index 4 (a[3]=2), a[2]=1, a[4]=1 == a[3]=2, so replace a[3] with 1.

Now array is [1,2,1,1,1,2]

Now, choose index 2 (a[1]=2, a[3]=1 == a[2]=1), no operation.

Choose index 5 (a[4]=1, a[6]=2 != a[5]=1), no operation.

So, it's stuck with [1,2,1,1,1,2], which is not beautiful because I can't make all elements the same.

Hence, my assumption is wrong; this array is not beautiful.

Therefore, this test case is invalid because the problem states that the array is beautiful.

Hence, I need to consider only arrays that are beautiful.

Let me think of another test case where the array is beautiful.

n=4, arr=[1,1,1,2]

This is beautiful because I can replace a[4]=2 with a[3]=1, making the array [1,1,1,1].

So, it's beautiful.

According to the program, val=1, cnt=0

i=0:1==1 -> cnt=1

i=1:1==1 -> cnt=2

i=2:1==1 -> cnt=3

i=3:2!=1 -> ans=min(Infinity,3)=3, cnt=0

Then, ans=3

So, program would print 3.

Is removing three elements sufficient to make it not beautiful?

Yes, removing the first three elements leaves [2], which is trivially beautiful.

Wait, but according to the problem, an array with all elements the same is beautiful.

So, removing three elements leaves [2], which is beautiful.

Wait, perhaps I need to remove different elements.

If I remove the first, second, and fourth elements, left with [1], which is beautiful.

If I remove first, third, and fourth elements, left with [1], which is beautiful.

If I remove second, third, and fourth elements, left with [1], which is beautiful.

If I remove any three elements, I'm left with one element, which is beautiful.

So, actually, I need to remove more elements to make it not beautiful.

Wait, but according to the program, it prints 3, but in this case, removing three elements still leaves a beautiful array.

Hence, perhaps the program is incorrect.

Wait, but in the fourth test case, the program prints 3, and in the explanation, removing the first three elements leaves [5,3,3,3], which is not beautiful.

Wait, in my test case, removing three elements leaves [2], which is beautiful.

So, perhaps in the fourth test case, removing three elements leaves a non-beautiful array, while in my test case, removing three elements leaves a beautiful array.

What's the difference?

In the fourth test case, after removing the first three elements, we have [5,3,3,3].

Is this array beautiful?

Let's check.

Can I make all elements the same?

Original array: [5,3,3,3]

Index 1: 5, a[0]=5, a[2]=3 != a[1]=5, no operation.

Index 2: a[1]=5, a[3]=3 != a[2]=3, no operation.

Hence, no operations can be applied, and since there's a 5 and 3's, it's not possible to make all elements the same.

Hence, it's not beautiful.

In my test case, after removing three elements, I'm left with [2], which is beautiful.

So, perhaps the program is correct in the fourth test case but incorrect in my test case.

Wait, in my test case, n=4, arr=[1,1,1,2], program prints 3, but removing three elements leaves a beautiful array, so the program is incorrect.

Hence, the program is flawed.

So, the program is incorrect.

Hence, Correctness: **False**

**Final Answer**

\[ \boxed{\text{False}} \]