Alright, I've got this problem to solve. Let's see what it's asking for. So, Bob has a bakery, and on the opening day, he baked n buns that he wants to sell. The usual price for each bun is a coins. But to attract customers, he's running a promotion where he can choose some integer k (between 0 and the minimum of n and b) and sell the first k buns at a modified price. The price for the i-th bun (where i ranges from 1 to k) is (b - i + 1) coins. The remaining (n - k) buns are sold at the usual price a coins each.

My task is to help Bob determine the maximum profit he can obtain by selling all n buns.

First, I need to understand the promotion clearly. So, if Bob chooses k = 0, he sells all n buns at price a coins each. If he chooses k = 1, he sells the first bun at b coins and the remaining (n - 1) buns at a coins each. If k = 2, the first bun is sold at b coins, the second at (b - 1) coins, and the remaining (n - 2) buns at a coins each. This pattern continues up to k = min(n, b), where the first k buns are sold at prices decreasing from b down to (b - k + 1) coins, and the remaining (n - k) buns at a coins each.

The goal is to maximize the total profit, which is the sum of the prices of all buns sold.

I need to consider different values of k and find which one gives the maximum profit.

Let me think about the possible scenarios:

1. If b <= a, then selling any bun at the modified price would be less profitable than selling it at the usual price a. So, in this case, it's better to choose k = 0 and sell all n buns at price a coins each.

2. If b > a, then there might be some benefit in choosing k > 0, because the first few buns can be sold at a higher price than a, but eventually, the modified price will drop below a, making it less profitable.

So, I need to find the optimal k where the modified prices are as high as possible, but not so many that the decreasing prices pull the total profit down.

Let me try to formalize this.

The total profit for a given k is:

Sum of the first k buns: sum from i=1 to k of (b - i + 1)

Sum of the remaining (n - k) buns: a * (n - k)

So, total profit P(k) = sum from i=1 to k of (b - i + 1) + a * (n - k)

I need to maximize P(k) over k from 0 to min(n, b).

First, let's find a formula for sum from i=1 to k of (b - i + 1).

This is equivalent to sum from i=1 to k of (b + 1 - i) = sum from i=1 to k of (b + 1) - sum from i=1 to k of i = k*(b + 1) - k*(k + 1)/2

So, sum from i=1 to k of (b - i + 1) = k*(b + 1) - k*(k + 1)/2 = k*b + k - k^2/2 - k/2 = (k*b + k - k^2/2 - k/2)

Simplify: k*b + k - k^2/2 - k/2 = k*b + (1 - 1/2)*k - k^2/2 = k*b + (1/2)*k - k^2/2

But perhaps it's better to keep it as k*(b + 1) - k*(k + 1)/2

Similarly, the sum of an arithmetic series from 1 to k is k*(k + 1)/2, so sum from i=1 to k of (b - i + 1) = k*b - k*(k + 1)/2 + k*1 = k*b - k*(k + 1)/2 + k

Wait, let's double-check:

Actually, sum from i=1 to k of (b - i + 1) = sum from i=1 to k of (b + 1 - i) = sum from j=1 to k of j, where j = b + 1 - i.

Wait, perhaps a better way is to recognize that (b - i + 1) for i from 1 to k is an arithmetic series starting at b for i=1, b-1 for i=2, ..., down to (b - k + 1) for i=k.

So, sum from i=1 to k of (b - i + 1) = sum from j=0 to k-1 of (b - j) = k*b - sum from j=0 to k-1 of j = k*b - (k-1)*k/2

Wait, sum from j=0 to k-1 of j is (k-1)*k/2.

So, sum from i=1 to k of (b - i + 1) = k*b - (k-1)*k/2

Therefore, P(k) = k*b - (k-1)*k/2 + a*(n - k)

I need to maximize P(k) over k from 0 to min(n, b).

This seems a bit messy. Maybe there's a smarter way to approach this.

Let me consider the difference in profit between choosing k and k-1.

Let's compute P(k) - P(k-1):

= [k*b - (k-1)*k/2 + a*(n - k)] - [(k-1)*b - (k-2)*(k-1)/2 + a*(n - k + 1)]

Simplify:

= k*b - (k-1)*k/2 + a*n - a*k - (k-1)*b + (k-2)*(k-1)/2 - a*n + a*(k - 1)

= k*b - (k-1)*k/2 - a*k - (k-1)*b + (k-2)*(k-1)/2 + a*(k - 1)

= (k*b - (k-1)*b) - ( (k-1)*k/2 - (k-2)*(k-1)/2 ) - a*k + a*(k - 1)

= b*(k - (k-1)) - (k-1)/2 * (k - (k-2)) ) - a*k + a*(k - 1)

= b*(1) - (k-1)/2 * (2) ) - a*k + a*(k - 1)

= b - (k-1) - a*k + a*(k - 1)

= b - (k-1) - a*k + a*k - a

= b - k + 1 - a

So, P(k) - P(k-1) = b - k + 1 - a

This is useful. It tells me when to increase k.

If P(k) - P(k-1) > 0, then P(k) > P(k-1), so increasing k increases the profit.

Set P(k) - P(k-1) > 0:

b - k + 1 - a > 0

b - a + 1 > k

So, as long as k < b - a + 1, P(k) > P(k-1), meaning that increasing k increases the profit.

When k = b - a + 1, P(k) - P(k-1) = 0, so it's equal.

And when k > b - a + 1, P(k) - P(k-1) < 0, so increasing k decreases the profit.

Therefore, the maximum profit occurs at k = b - a + 1, as long as b - a + 1 <= min(n, b). If b - a + 1 > min(n, b), then the maximum is at k = min(n, b).

Wait, but k cannot exceed min(n, b). So, the optimal k is the minimum of (b - a + 1) and min(n, b).

Wait, but k can be 0 as well. So, I need to consider k from 0 to min(n, b), and choose the k that maximizes P(k).

Given the above, P(k) increases up to k = b - a + 1, then decreases. So, if b - a + 1 <= min(n, b), then the maximum is at k = b - a + 1. Otherwise, it's at k = min(n, b).

But I need to verify this.

Let me consider the case when b - a + 1 <= min(n, b):

Then, the maximum is at k = b - a + 1.

But wait, from P(k) - P(k-1) = b - k + 1 - a

Set P(k) - P(k-1) = 0:

k = b - a + 1

So, at k = b - a + 1, P(k) = P(k-1)

So, the maximum is at k from 0 to b - a + 1, all giving the same profit.

Wait, no. From P(k) - P(k-1) = b - k + 1 - a

For k < b - a + 1, P(k) - P(k-1) > 0, so P(k) increases.

At k = b - a + 1, P(k) - P(k-1) = 0, so P(k) remains the same.

For k > b - a + 1, P(k) - P(k-1) < 0, so P(k) decreases.

Therefore, the maximum is achieved for k from 0 to b - a + 1, and then decreases.

But I need to consider the constraints on k: k <= min(n, b)

So, if b - a + 1 <= min(n, b), then the maximum is at k = b - a + 1.

Otherwise, if b - a + 1 > min(n, b), then the maximum is at k = min(n, b).

Wait, but in the case where b - a + 1 > min(n, b), then the maximum is at k = min(n, b), because P(k) is still increasing up to k = b - a + 1, but k cannot exceed min(n, b).

So, the optimal k is min(b - a + 1, min(n, b)).

Wait, but min(b - a + 1, min(n, b)) is the same as min(b - a + 1, n, b).

But since b - a + 1 could be larger than b, but k cannot exceed b, so it's min(b - a + 1, b, n).

But b - a + 1 <= b only if a >=1, which is given since a >=1.

Wait, no, a can be 0 according to the constraints, but in the problem, a is at least 1.

Wait, looking back at the problem, it says 1 <= n, a, b <= 10^9.

So, a >=1.

Therefore, b - a +1 <= b.

So, min(b - a +1, b, n) = min(b - a +1, n)

Therefore, the optimal k is min(b - a +1, n)

So, in code, k = min(b - a +1, n)

Then, compute P(k) = sum of first k buns at modified price + a*(n -k)

Sum of first k buns: sum from i=1 to k of (b - i +1)

Which is k*b - sum from i=1 to k of i + sum from i=1 to k of 1 = k*b - k*(k+1)/2 + k*1 = k*b - k*(k+1)/2 + k

So, P(k) = k*b - k*(k+1)/2 + k + a*(n -k)

Simplify: k*b - k*(k+1)/2 + k + a*n - a*k

Combine like terms: a*n + k*b - a*k - k*(k+1)/2 + k

Wait, perhaps it's better to keep it as is.

Alternatively, since sum from i=1 to k of (b - i +1) is equal to sum from i=b to b - k +1 of i, which is the sum of k consecutive integers starting from b down to b - k +1.

The formula for the sum of an arithmetic series is (first term + last term)*number of terms /2

So, sum from i=b to b - k +1 of i = (b + (b - k +1))*k /2 = (2b - k +1)*k /2

Therefore, P(k) = (2b - k +1)*k /2 + a*(n -k)

So, P(k) = (2b - k +1)*k /2 + a*(n -k)

This seems a bit cleaner.

Now, in code, I need to compute this for k = min(b - a +1, n)

But I need to handle the case when b <= a separately.

Wait, in the first scenario, if b <= a, then it's better to set k=0 and sell all buns at price a.

So, in code, if b <= a, then P = a*n

Else, set k = min(b - a +1, n), then P = (2b - k +1)*k /2 + a*(n -k)

Wait, but in the earlier analysis, the optimal k is k = b - a +1, but only up to min(n, b).

But in the problem, k can be up to min(n, b), so k = min(b - a +1, n)

But I need to make sure that k does not exceed min(n, b).

Wait, but b - a +1 could be greater than b, but since k <= min(n, b), it's already capped.

Wait, no, b - a +1 <= b because a >=1.

Wait, if a >=1, then b - a +1 <= b.

Wait, suppose a=1, b=5, then b - a +1 =5, which is <= b.

If a=2, b=5, then b - a +1=4 <=5.

If a=5, b=5, then b - a +1=1 <=5.

If a=6, b=5, then b - a +1=0, which is allowed, k>=0.

So, k = min(b - a +1, n)

Then, P = (2b - k +1)*k /2 + a*(n -k)

But I need to make sure that this formula is correct.

Let me verify with an example.

Take the first test case:

n=4, a=4, b=5

So, b - a +1=5-4+1=2

So, k = min(2,4)=2

Then, P = (2*5 -2 +1)*2 /2 +4*(4-2) = (10 -2 +1)*2 /2 +4*2 = 9*2 /2 +8 = 9 +8 =17

Which matches the first test case.

Another test case:

n=5, a=5, b=9

b - a +1=9-5+1=5

k = min(5,5)=5

P = (18 -5 +1)*5 /2 +5*(5-5)=14*5/2 +0=35, which matches the second test case.

Third test case:

n=10, a=10, b=5

Since b <=a, P=10*10=100, which matches the third test case.

Fourth test case:

n=5, a=5, b=11

b - a +1=11-5+1=7

k = min(7,5)=5

P=(22 -5 +1)*5 /2 +5*(5-5)=18*5/2 +0=45, which matches the fourth test case.

Fifth test case:

n=1000000000, a=1000000000, b=1000000000

b - a +1=1000000000-1000000000+1=1

k = min(1,1000000000)=1

P=(2*1000000000 -1 +1)*1 /2 +1000000000*(1000000000 -1)=2000000000*1 /2 +1000000000*999999999=1000000000 +999999999000000000=1000000000000000000, which matches the fifth test case.

Sixth test case:

n=1000000000, a=1000000000, b=1

Since b <=a, P=1000000000*1000000000=1000000000000000000, which matches the sixth test case.

Seventh test case:

n=1000, a=1, b=1000

b - a +1=1000-1+1=1000

k = min(1000,1000)=1000

P=(2*1000 -1000 +1)*1000 /2 +1*(1000-1000)=1001*1000 /2 +0=500500, which matches the seventh test case.

So, the formula seems correct.

Now, let's look at the provided code:

def func():

t = int(input())

for _ in range(t):

(n, a, b) = map(int, input().split())

if b <= a:

print(n * a)

elif b - a >= n:

print(int((2 * b - n + 1) * n // 2))

else:

print(int((b - a) * (b - a + 1) // 2 + a * n))

Wait, this seems different from what I derived.

In my analysis, for b <= a, P = n*a

For b > a, k = min(b - a +1, n)

Then, P = (2b - k +1)*k /2 + a*(n -k)

But in the code:

if b <= a:

print(n * a)

elif b - a >= n:

print(int((2 * b - n + 1) * n // 2))

else:

print(int((b - a) * (b - a + 1) // 2 + a * n))

So, in the elif clause, when b - a >= n, it prints (2*b - n +1)*n //2

And in the else clause, it prints (b - a)*(b - a +1)//2 + a*n

I need to check if this matches the formula I derived.

First, consider b <= a:

P = n*a

Which matches.

Now, consider b > a:

If b - a >= n, then k = min(b - a +1, n) = n (since b - a +1 >=n)

Then, P = (2b - n +1)*n /2 + a*(n -n) = (2b - n +1)*n /2

Which matches the code's elif clause.

Else, if b - a < n, then k = b - a +1

Then, P = (2b - (b - a +1) +1)*(b - a +1)/2 + a*(n - (b - a +1)) = (2b - b + a -1 +1)*(b - a +1)/2 + a*(n - b + a -1) = (b + a)*(b - a +1)/2 + a*(n - b + a -1)

Wait, this seems different from the code's else clause, which is (b - a)*(b - a +1)//2 + a*n

So, there might be a mistake here.

Let me recalculate P for k = b - a +1.

P(k) = (2b - k +1)*k /2 + a*(n -k)

With k = b - a +1

So, P = (2b - (b - a +1) +1)*(b - a +1)/2 + a*(n - (b - a +1)) = (2b - b + a -1 +1)*(b - a +1)/2 + a*(n - b + a -1) = (b + a)*(b - a +1)/2 + a*(n - b + a -1)

But the code has (b - a)*(b - a +1)//2 + a*n

So, it seems different.

Wait, perhaps I made a mistake in calculating P.

Let me double-check.

Given k = b - a +1

P(k) = sum of first k buns at modified price + a*(n -k)

Sum of first k buns: sum from i=1 to k of (b - i +1) = (2b - k +1)*k /2

So, P(k) = (2b - k +1)*k /2 + a*(n -k)

With k = b - a +1

So, P(k) = (2b - (b - a +1) +1)*(b - a +1)/2 + a*(n - (b - a +1)) = (2b - b + a -1 +1)*(b - a +1)/2 + a*(n - b + a -1) = (b + a)*(b - a +1)/2 + a*(n - b + a -1)

But the code has (b - a)*(b - a +1)//2 + a*n

So, it seems different.

Wait, perhaps there is a simplification I'm missing.

Let me expand both expressions.

First, code's expression: (b - a)*(b - a +1)/2 + a*n

Second, my expression: (b + a)*(b - a +1)/2 + a*(n - b + a -1)

Let me compute the difference:

My expression - code's expression = [(b + a)*(b - a +1)/2 + a*(n - b + a -1)] - [(b - a)*(b - a +1)/2 + a*n]

= [(b + a)*(b - a +1) - (b - a)*(b - a +1)] /2 + a*(n - b + a -1) - a*n

= [ (b + a - b + a)* (b - a +1) ] /2 + a*(n - b + a -1) - a*n

= [ (2a)* (b - a +1) ] /2 + a*(n - b + a -1) - a*n

= a*(b - a +1) + a*(n - b + a -1) - a*n

= a*(b - a +1 + n - b + a -1 - n)

= a*(b - a +1 + n - b + a -1 - n)

= a*(b - a +1 + n - b + a -1 - n)

= a*(0) = 0

So, my expression and the code's expression are equal.

Therefore, the code is correct.

Wait, but in the else clause, the code has (b - a)*(b - a +1)//2 + a*n, which seems different from my derivation, but algebraically, they are equal.

So, the code is correct.

Hence, Correctness: True

**Final Solution**

To solve this problem, we need to maximize Bob's profit from selling his buns under a promotional pricing scheme. The key is to choose the optimal number of buns, \( k \), to sell at a modified price sequence and the remaining at the usual price.

### Approach

1. **Understanding the Promotion:**
   - For a chosen \( k \), the first \( k \) buns are sold at prices starting from \( b \) coins down to \( b - k + 1 \) coins.
   - The remaining \( n - k \) buns are sold at the usual price \( a \) coins each.

2. **Determine the Optimal \( k \):**
   - If \( b \leq a \), it's more profitable to sell all buns at the usual price \( a \).
   - If \( b > a \), we calculate the optimal \( k \) as \( \min(b - a + 1, n) \).

3. **Calculate the Total Profit:**
   - Use the formula for the sum of an arithmetic series to compute the total profit for the first \( k \) buns.
   - Add the profit from the remaining \( n - k \) buns sold at price \( a \).

### Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        (n, a, b) = map(int, input().split())
        if b <= a:
            print(n * a)
        elif b - a >= n:
            print(int((2 * b - n + 1) * n // 2))
        else:
            k = b - a + 1
            sum_promo = (k * (2 * b - k + 1)) // 2
            sum_usual = a * (n - k)
            print(sum_promo + sum_usual)

# To run the function, uncomment the following line
# func()
```

### Explanation

1. **Input Handling:**
   - Read the number of test cases \( t \).
   - For each test case, read the values \( n \), \( a \), and \( b \).

2. **Condition Checks:**
   - If \( b \leq a \), set \( k = 0 \) and calculate profit as \( n \times a \).
   - If \( b - a \geq n \), set \( k = n \) and calculate profit using the sum of the arithmetic series formula.
   - Otherwise, set \( k = b - a + 1 \), calculate the sum of the modified prices for \( k \) buns and the usual price for the remaining \( n - k \) buns.

3. **Profit Calculation:**
   - For the modified prices, use the formula for the sum of an arithmetic series: \( \text{sum} = \frac{k \times (\text{first term} + \text{last term})}{2} \).
   - Add the profit from the usual prices: \( a \times (n - k) \).

By following these steps, we ensure that Bob maximizes his profit based on the given pricing strategy.