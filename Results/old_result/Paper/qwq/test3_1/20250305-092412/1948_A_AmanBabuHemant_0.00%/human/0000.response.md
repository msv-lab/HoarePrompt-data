Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an integer n, and I need to build a string of uppercase Latin letters where exactly n characters are "special." A special character is one that's equal to exactly one of its neighbors. For example, in "AAABAACC," there are 6 special characters at positions 1, 3, 5, 6, 7, and 8.

First, I need to understand what makes a character special. If a character is equal to exactly one of its neighbors, that means:

- If it's the first character, it's special only if it's equal to the second character.

- If it's the last character, it's special only if it's equal to the second-to-last character.

- For any character in the middle, it's special if it's equal to either the previous or the next character, but not both.

So, for the string "AAABAACC":

- Position 1: 'A' equals the next 'A', but not the previous (since there is none), so it's special.

- Position 2: 'A' equals both previous and next 'A's, so it's not special.

- Position 3: 'A' equals the next 'B', which is different, and the previous 'A', which is equal, so it's special.

- Position 4: 'B' equals the next 'A', which is different, and the previous 'A', which is different, so it's special.

- Position 5: 'A' equals the next 'A', but not the previous 'B', so it's special.

- Position 6: 'A' equals both previous 'A' and next 'C', which is different, so it's special.

- Position 7: 'C' equals the next 'C', but not the previous 'A', so it's special.

- Position 8: 'C' equals the previous 'C', but not the next (since there is none), so it's special.

Total special characters: 6, which matches the example.

Now, I need to generate a string where exactly n characters are special. The string should be composed of uppercase letters, and its length should be at most 200.

First thoughts:

- I need to control the number of special characters.

- Special characters are those that are equal to exactly one neighbor.

- I need to find a pattern that allows me to have exactly n such characters.

Potential approaches:

1. **Brute force generation:** Generate all possible strings of length up to 200 and check which ones have exactly n special characters. This is clearly inefficient and not feasible due to the large number of possibilities.

2. **Pattern-based construction:** Find a pattern that can be repeated to achieve exactly n special characters.

3. **Mathematical approach:** Determine mathematical conditions under which a string can have exactly n special characters.

Let's explore the pattern-based construction approach.

Observations:

- If I have a string where all characters are the same, e.g., "AAAAA", then no character is special because each character equals both neighbors (except the first and last, which only have one neighbor, but in this case, they equal that neighbor).

- If I have alternating characters, e.g., "ABABAB", then every character is special because each character is different from one neighbor and equal to the other.

- In the example given, "AAABAACC" has 6 special characters.

I need a way to control the number of special characters precisely.

Let's try to find a pattern that can be repeated to achieve exactly n special characters.

Consider a substring "AAB":

- Position 1: 'A' equals the next 'A', so special.

- Position 2: 'A' equals both neighbors, so not special.

- Position 3: 'B' differs from both neighbors, so not special.

Total special characters: 1.

Similarly, "AABCC":

- "AAB" has 1 special character.

- "CC" has 0 special characters (since 'C' equals both neighbors, but in this case, only the last 'C' has one neighbor, which is equal.

Wait:

- Position 1: 'A' equals next 'A', special.

- Position 2: 'A' equals both neighbors, not special.

- Position 3: 'B' differs from both neighbors, not special.

- Position 4: 'C' equals next 'C', special.

- Position 5: 'C' equals previous 'C', special.

Wait, in position 4, 'C' equals the next 'C', and position 5 equals the previous 'C', but the definition says "equal to exactly one of its neighbors."

Wait, re-reading the definition: a character is special if it is equal to exactly one of its neighbors.

So, in "AABCC":

- Position 1: 'A' equals next 'A', special.

- Position 2: 'A' equals both neighbors, not special.

- Position 3: 'B' differs from both neighbors, not special.

- Position 4: 'C' equals next 'C', so equal to one neighbor (next), special.

- Position 5: 'C' equals previous 'C', so equal to one neighbor (previous), special.

Total special characters: 3.

Wait, but according to the definition, a character is special if it is equal to exactly one of its neighbors.

So, in position 4, 'C' equals the next 'C', so it's equal to one neighbor.

In position 5, 'C' equals the previous 'C', so it's equal to one neighbor.

Position 2, 'A' equals both neighbors, so not special.

Position 3, 'B' differs from both, so not special.

So, "AABCC" has 3 special characters.

Is there a pattern here that I can exploit?

Let's try "AABCCD":

- "AABCCD"

- Position 1: 'A' equals next 'A', special.

- Position 2: 'A' equals both neighbors, not special.

- Position 3: 'B' differs from both, not special.

- Position 4: 'C' equals next 'C', special.

- Position 5: 'C' equals previous 'C', special.

- Position 6: 'D' differs from previous 'C', and no next neighbor, so not special.

Total special characters: 3.

Hmm.

What if I do "AABCCDE":

- Position 1: 'A' equals next 'A', special.

- Position 2: 'A' equals both neighbors, not special.

- Position 3: 'B' differs from both, not special.

- Position 4: 'C' equals next 'C', special.

- Position 5: 'C' equals previous 'C', special.

- Position 6: 'D' differs from previous 'C', and next 'E', not special.

- Position 7: 'E' differs from previous 'D', and no next neighbor, not special.

Total special characters: 3.

It seems that for every "AAB" pattern, I get 1 special character, and for every "CC" pattern, I get 2 special characters.

Wait, in "AABCC", I have 3 special characters.

In "AABCCD", I have 3 special characters.

In "AABCCDE", I have 3 special characters.

Is there a better pattern to control the number of special characters?

Let's try "AABBC":

- Position 1: 'A' equals next 'A', special.

- Position 2: 'A' equals both neighbors, not special.

- Position 3: 'B' equals next 'B', special.

- Position 4: 'B' equals previous 'B', special.

- Position 5: 'C' differs from previous 'B', and no next neighbor, special.

Total special characters: 4.

Wait, position 4: 'B' equals previous 'B', so equal to one neighbor, special.

Position 5: 'C' differs from previous 'B', and no next neighbor, so equal to zero neighbors, not special.

Wait, no. According to the definition, it's equal to exactly one of its neighbors. Since it only has one neighbor and it's different, it's equal to zero neighbors, so not special.

So, in "AABBC":

- Position 1: 'A' equals next 'A', special.

- Position 2: 'A' equals both neighbors, not special.

- Position 3: 'B' equals next 'B', special.

- Position 4: 'B' equals previous 'B', special.

- Position 5: 'C' differs from previous 'B', no next neighbor, not special.

Total special characters: 3.

Hmm, again 3.

What if I try "AABBCC"?

- Position 1: 'A' equals next 'A', special.

- Position 2: 'A' equals both neighbors, not special.

- Position 3: 'B' equals next 'B', special.

- Position 4: 'B' equals previous 'B', special.

- Position 5: 'C' equals next 'C', special.

- Position 6: 'C' equals previous 'C', special.

Total special characters: 4.

Wait, position 1: special.

Position 3: special.

Position 4: special.

Position 5: special.

Position 6: special.

Position 2: not special.

Total special characters: 5.

Wait, in position 4: 'B' equals previous 'B', so equal to one neighbor (previous), special.

Position 5: 'C' equals next 'C', so equal to one neighbor (next), special.

Position 6: 'C' equals previous 'C', so equal to one neighbor (previous), special.

So, "AABBCC" has 5 special characters.

Is there a pattern here? It seems like every "AA" or "BB" or "CC" adds a certain number of special characters.

Let me try to generalize.

Suppose I have a string composed of blocks where each block is "AAB", "BBB", "CC", etc.

Wait, maybe I need to think in terms of runs of identical characters.

Let's consider runs of characters:

- A run is a sequence of identical characters.

- For example, in "AABBBCC", there is a run of 2 A's, followed by a run of 3 B's, followed by a run of 2 C's.

Now, let's see how special characters are distributed in such runs.

Consider two runs: "AABBB":

- Run 1: "AA" (length 2)

- Run 2: "BBB" (length 3)

Special characters:

- Position 1: 'A' equals next 'A', special.

- Position 2: 'A' equals both neighbors, not special.

- Position 3: 'B' equals next 'B', special.

- Position 4: 'B' equals both neighbors, not special.

- Position 5: 'B' equals previous 'B', special.

Total special characters: 3.

Similarly, in "AABBBCC":

- Run 1: "AA" (length 2)

- Run 2: "BBB" (length 3)

- Run 3: "CC" (length 2)

Special characters:

- Position 1: 'A' equals next 'A', special.

- Position 2: 'A' equals both neighbors, not special.

- Position 3: 'B' equals next 'B', special.

- Position 4: 'B' equals both neighbors, not special.

- Position 5: 'B' equals previous 'B', special.

- Position 6: 'C' equals next 'C', special.

- Position 7: 'C' equals previous 'C', special.

Total special characters: 4.

Wait, position 6 and 7 are both special in "AABBBCC".

But according to the definition, a character is special if it's equal to exactly one of its neighbors.

In position 6: 'C' equals next 'C', so equal to one neighbor, special.

In position 7: 'C' equals previous 'C', so equal to one neighbor, special.

So, total special characters: 4.

Wait, but earlier in "AABBCC", I had 5 special characters. Maybe I miscounted.

Wait, in "AABBCC":

- Position 1: 'A' equals next 'A', special.

- Position 2: 'A' equals both neighbors, not special.

- Position 3: 'B' equals next 'B', special.

- Position 4: 'B' equals both neighbors, not special.

- Position 5: 'C' equals next 'C', special.

- Position 6: 'C' equals previous 'C', special.

Total special characters: 3.

Wait, I think I made a mistake earlier.

So, in "AABBCC", positions 1,3,5,6 are special: 'A','B','C','C'.

Total: 4.

Wait, no:

- Position 1: 'A' equals next 'A', special.

- Position 2: 'A' equals both neighbors, not special.

- Position 3: 'B' equals next 'B', special.

- Position 4: 'B' equals both neighbors, not special.

- Position 5: 'C' equals next 'C', special.

- Position 6: 'C' equals previous 'C', special.

Total: 4 special characters.

Okay, so in "AABBBCC", I have 4 special characters.

Is there a pattern here?

Let's try to generalize.

Suppose I have a sequence of runs: r1, r2, r3, ..., rk.

Each ri is the length of the ith run.

Then, for each position in the string:

- If it's the first position: special if s[1] == s[2].

- If it's the last position: special if s[n] == s[n-1].

- For internal positions: special if s[i] == s[i+1] or s[i] == s[i-1], but not both.

Now, I need to find a way to arrange these runs such that the total number of special characters is exactly n.

This seems tricky.

Maybe I can find a formula that relates the number of special characters to the run lengths.

Let's try to derive such a formula.

First, consider that each run of length l contributes some number of special characters.

For a run of length l:

- The first character in the run is special if it's equal to exactly one neighbor.

- The last character in the run is special if it's equal to exactly one neighbor.

- The internal characters in the run are special if they're equal to exactly one neighbor.

Wait, but in a run of identical characters, the internal characters are equal to both neighbors, so they're not special.

Only the first and last characters of the run can be special, depending on the neighboring runs.

Wait, perhaps it's better to consider the transitions between runs.

Let me consider the transitions between different runs.

Suppose I have two runs: run1 of character A with length l1, followed by run2 of character B with length l2.

Then:

- The last character of run1 (position l1) is special if B != A (since it only equals the previous A).

- The first character of run2 (position l1 + 1) is special if B != A (since it only equals the next B's).

Similarly, for runs of the same character, there are no special characters at the transition.

Wait, let's formalize this.

Consider two consecutive runs: run i of character c with length li, and run i+1 of character d with length l_{i+1}.

- If c != d:

- The last character of run i (position sum of lengths of previous runs + li) is special because it equals only the previous character (c).

- The first character of run i+1 is special because it equals only the next character (d).

- If c == d:

- The last character of run i and the first character of run i+1 are not special because they equal both neighbors.

Additionally, for the first run:

- The first character is special if li > 1 (equals the next character).

- The last character is special if the next run has a different character.

For the last run:

- The last character is special if li > 1 (equals the previous character).

- The first character is special if the previous run has a different character.

This seems a bit complicated, but perhaps I can find a way to count the special characters based on the number of runs and the run lengths.

Let me try to find a formula.

Letâ€™s denote:

- k: number of runs.

- li: length of the ith run.

Then, the total number of special characters s is:

s = sum over all run transitions where c_i != c_{i+1} of 2 (one for the last of run i and one for the first of run i+1)) + sum over all runs where li > 1 of 1 (for the first character equal to the next) + sum over all runs where li > 1 of 1 (for the last character equal to the previous).

Wait, perhaps that's not the best way to approach it.

Let me try to think differently.

Suppose I have a string where all characters are the same, like "AAAAA". Then, s = 0 because no character is equal to exactly one neighbor.

If I have "AABBB", then s = 3, as per earlier counting.

Wait, in "AABBB":

- Positions 1 and 2: 'A's, li=2.

- Positions 3,4,5: 'B's, li=3.

Special characters:

- Position 1: 'A' equals next 'A', special.

- Position 2: 'A' equals both neighbors, not special.

- Position 3: 'B' equals next 'B', special.

- Position 4: 'B' equals both neighbors, not special.

- Position 5: 'B' equals previous 'B', special.

Total special characters: 3.

So, s = 3.

Now, in "AABBCC", s = 4.

In "AA", s = 1.

In "A", s = 0.

In "AB", s = 2.

In "ABC", s = 3.

Wait, in "ABC":

- Position 1: 'A' != 'B', so equals exactly one neighbor ('B'), special.

- Position 2: 'B' != 'A' and 'B' != 'C', so equals zero neighbors, not special.

- Position 3: 'C' != 'B', so equals exactly one neighbor ('B'), special.

Total special characters: 2.

Wait, but according to the definition, position 1: 'A' equals next 'B', which is different, so not special.

Wait, no: a character is special if it is equal to exactly one of its neighbors.

In "ABC":

- Position 1: 'A' != 'B', so equals zero neighbors, not special.

- Position 2: 'B' != 'A' and 'B' != 'C', so equals zero neighbors, not special.

- Position 3: 'C' != 'B', so equals zero neighbors, not special.

Total special characters: 0.

Wait, that contradicts my earlier assumption.

Wait, maybe I misread the example.

In the initial example, "AAABAACC" has 6 special characters.

Wait, perhaps I need to look back at the problem statement.

Wait, in the problem statement, it says: "there are 6 special characters in the AAABAACC string (at positions: 1 , 3 , 5 , 6 , 7 and 8 )."

Let me verify that again.

"AAABAACC":

- Position 1: 'A' == 'A', special.

- Position 2: 'A' == 'A' and 'A' == 'B', so equals both, not special.

- Position 3: 'A' == 'B', so equals one neighbor, special.

- Position 4: 'B' == 'A', so equals one neighbor, special.

- Position 5: 'A' == 'A', special.

- Position 6: 'A' == 'C', so equals one neighbor, special.

- Position 7: 'C' == 'C', special.

- Position 8: 'C' == previous 'C', special.

Total: positions 1,3,4,5,6,7,8 are special: 7 special characters.

Wait, the problem says 6 special characters. Maybe I miscounted.

Wait, perhaps position 4 is not special.

Let's re-examine position 4 in "AAABAACC":

- Position 4: 'B' == previous 'A', so equals one neighbor, special.

- Position 5: 'A' == next 'A', special.

- Position 6: 'A' == next 'C', so equals one neighbor, special.

- Position 7: 'C' == next 'C', special.

- Position 8: 'C' == previous 'C', special.

Positions 1,3,4,5,6,7,8: that's 7 positions. Maybe the problem counts position 2 as special, but according to the definition, it's not, because 'A' equals both neighbors.

So perhaps there's a mistake in the problem statement or my understanding.

Wait, re-reading the problem:

"Let's call a character special if it is equal to exactly one of its neighbors."

So, for position 2 in "AAABAACC":

' A' at position 2 equals both position 1 ('A') and position 3 ('B'). But since it equals both neighbors, it does not satisfy "equal to exactly one neighbor", so it's not special.

Therefore, positions 1,3,4,5,6,7,8 are special: 7 special characters.

But the problem says 6 special characters. Maybe it's a typo or I misread.

Anyway, moving forward, I need to find a way to construct a string with exactly n special characters.

Looking for a general approach.

Perhaps, I can consider that each transition between different characters adds 2 special characters: one at the end of the first run and one at the start of the second run.

Each run of length greater than 1 adds 1 special character for the first character and 1 for the last character, but these might overlap with the transitions.

Wait, perhaps it's better to think in terms of graph theory or some other combinatorial approach, but that might be too complicated.

Let me consider small values of n and see if I can find a pattern.

For n=1:

Is it possible to have a string with exactly 1 special character?

Let's try:

- "A": 0 special characters.

- "AA": positions 1 and 2 are both special because each 'A' equals only one neighbor (the other 'A'). So, total special characters: 2.

- "AB": positions 1 and 2 are both special because each character equals exactly one neighbor. So, total special characters: 2.

- "ABA": positions 1: 'A' == 'B', special; position 2: 'B' == 'A' and 'B' == 'A', equals both, not special; position 3: 'A' == 'B', special. Total special characters: 2.

- "ABBA": positions 1: 'A' == 'B', special; position 2: 'B' == 'B', special; position 3: 'B' == 'A', special; position 4: 'A' == 'B', special. Total special characters: 4.

It seems that for n=1, it's impossible to have exactly 1 special character. Is there any string that satisfies this?

Wait, what about "AAA"?

- Position 1: 'A' == 'A', special.

- Position 2: 'A' == both neighbors, not special.

- Position 3: 'A' == 'A', special.

Total special characters: 2.

Still 2.

What about "AAAB"?

- Positions: 1,2,3:'A', position 4:'B'.

- Position 1: 'A' == 'A', special.

- Position 2: 'A' == both neighbors, not special.

- Position 3: 'A' == 'B', special.

- Position 4: 'B' == 'A', special.

Total special characters: 3.

Still not 1.

Seems like it's impossible to have exactly 1 special character.

Let me check n=2.

- "AB": positions 1 and 2 are both special, total 2.

- "AAA": positions 1 and 3 are special, total 2.

- "AAB": positions 1 and 3 are special, total 2.

So, n=2 seems possible with strings like "AB", "AAA", "AAB".

Now, n=3:

- "AABBB": positions 1,3,5 are special, total 3.

- "AABBC": positions 1,3,4 are special, total 3.

So, n=3 is possible.

n=4:

- "AABBCC": positions 1,3,5,6 are special, total 4.

- "AABBBCC": positions 1,3,4,5 are special, total 4.

So, n=4 is possible.

n=5:

- "AABBCCC": positions 1,3,5,6,7 are special, total 5.

n=6:

- "AAABAACC": positions 1,3,5,6,7,8 are special, total 6.

So, it seems that for n >=2, it's possible to construct strings with n special characters.

But for n=1, it's impossible.

Wait, but in the example, for n=1, the output is 'NO'.

So, perhaps n must be even?

Wait, in the example, for n=1, output is 'NO', for n=2, output is 'YES MM'.

Wait, 'MM' has positions 1 and 2, both 'M' equal to one neighbor (the other 'M'), so total special characters: 2.

So, for n=2, it's possible.

For n=6, "AAABAACC" has 6 special characters.

But for n=1, it's impossible.

Is there a pattern here? It seems that n must be even.

Wait, in the sample input:

3

6

1

2

Output:

YES

AAABAACC

NO

YES

MM

So, for n=6: YES

n=1: NO

n=2: YES MM

So, perhaps n must be even.

But in my earlier trials, n=3 seems possible with "AABBB".

Wait, in "AABBB":

- positions 1,3,5 are special: n=3.

So, perhaps n can be odd as well.

But according to the sample input, for n=1: NO

For n=2: YES

For n=6: YES

Wait, maybe there are constraints on n.

Let me try to find a general rule.

Suppose I have a string with k runs.

Then, the number of special characters s can be expressed in terms of k and the run lengths.

But this seems complicated.

Alternatively, perhaps n must be even.

But in "AABBB", n=3, which is odd.

Wait, but according to the sample input, for n=1: NO, n=2: YES, n=6: YES.

Maybe n must be even.

But in "AABBB", n=3, which is odd, and it seems possible.

Wait, perhaps the problem has some constraints that make n must be even.

Wait, perhaps in the problem's context, only even n are possible, but in my earlier example, "AABBB" has n=3.

Wait, perhaps I miscounted "AABBB".

Let me recount "AABBB":

- Position 1: 'A' == 'A', special.

- Position 2: 'A' == both 'A' and 'B', not special.

- Position 3: 'B' == 'B', special.

- Position 4: 'B' == both 'B' and 'B', not special.

- Position 5: 'B' == 'B', special.

Total special characters: positions 1,3,5: n=3.

So, n=3 is possible.

But according to the sample input, for n=1: NO, n=2: YES, n=6: YES.

Wait, maybe n cannot be 1, but can be any n >=2.

But in my earlier example, n=3 is possible.

Wait, perhaps n can be any n except 1.

But in the sample input, n=1: NO, n=2: YES, n=6: YES.

So, maybe n must be even.

Wait, but n=3 is possible with "AABBB".

Wait, perhaps there are other constraints.

Wait, maybe for n=1, it's impossible because a single special character cannot be isolated without another special character nearby.

Wait, let's think about it.

Suppose I have a single special character. That means only one character in the string is equal to exactly one neighbor.

But in practice, if a character is equal to exactly one neighbor, its neighbor must be equal to two neighbors or something like that.

It's hard to isolate a single special character without affecting others.

For example, in "AB", both are special.

In "AAA", positions 1 and 3 are special.

In "AAAB", positions 1,3,4 are special.

In "AABBB", positions 1,3,5 are special.

In "AABBBCC", positions 1,3,4,5 are special.

It seems that n cannot be 1, but can be any higher integer.

So, perhaps the rule is that n cannot be 1, but can be any n >=2.

But in the sample input, for n=1: NO, n=2: YES, n=6: YES.

So, perhaps n must be even.

But in "AABBB", n=3 is odd.

Wait, maybe n cannot be odd unless it's greater than some value.

Wait, perhaps n must be even.

But in the sample input, n=1: NO, n=2: YES, n=6: YES.

And in my earlier example, n=3: "AABBB".

So, perhaps the problem has a different rule.

Wait, maybe in the problem's constraints, n must be even.

But in the example, n=6 is allowed, n=2 is allowed, n=1 is not allowed.

So, perhaps n must be even.

But in my earlier example, n=3 is possible with "AABBB".

Maybe the problem has a mistake, or perhaps there are other constraints.

Alternatively, maybe the minimal string length constrains n.

Wait, the problem says "print any suitable string or report that there is no such string."

Also, the string can be up to 200 characters.

But in the sample input, for n=1: NO, n=2: YES "MM", n=6: YES "AAABAACC".

So, perhaps n must be even.

But in "AABBB", n=3 is odd.

Wait, maybe I need to look for a different pattern.

Let me consider that in any string, the number of special characters is always even.

But in "AABBB", n=3, which is odd.

Wait, perhaps I miscounted again.

In "AABBB":

- Position 1: 'A' == 'A', special.

- Position 2: 'A' == both 'A' and 'B', not special.

- Position 3: 'B' == 'B', special.

- Position 4: 'B' == both 'B' and 'B', not special.

- Position 5: 'B' == 'B', special.

Total special characters: positions 1,3,5: n=3.

Wait, perhaps the problem has a different definition of special characters.

Wait, re-reading the problem:

"Let's call a character special if it is equal to exactly one of its neighbors."

So, in "AABBB":

- Position 1: 'A' == 'A', special.

- Position 2: 'A' == 'A' and 'A' == 'B', so equals both, not special.

- Position 3: 'B' == 'A', special.

- Position 4: 'B' == 'B', special.

- Position 5: 'B' == 'B', special.

Wait, position 4: 'B' == 'B' (previous) and 'B' == 'B' (next), so equals both, not special.

Wait, perhaps I'm confusing myself.

In "AABBB":

- Position 1: 'A' == 'A' (next), so equals one neighbor, special.

- Position 2: 'A' == 'A' (previous) and 'A' == 'B' (next), so equals both, not special.

- Position 3: 'B' == 'A' (previous), 'B' == 'B' (next), so equals one neighbor, special.

- Position 4: 'B' == 'B' (previous), 'B' == 'B' (next), so equals both, not special.

- Position 5: 'B' == 'B' (previous), no next, so equals one neighbor, special.

Total special characters: positions 1,3,5: n=3.

Wait, perhaps the number of special characters is always even.

Wait, in "AABBB", n=3, which is odd.

Wait, but in the sample input, for n=1: NO, n=2: YES, n=6: YES.

Perhaps the problem intends that n must be even.

But in my earlier example, n=3 seems possible.

Wait, maybe I'm missing something.

Let me consider that in any valid string, n must be even.

But in "AABBB", n=3, which is odd.

Wait, perhaps I miscounted again.

In "AABBB":

- Position 1: 'A' == 'A', special.

- Position 2: 'A' == 'A' and 'B', equals both, not special.

- Position 3: 'B' == 'A', special.

- Position 4: 'B' == 'B', special.

- Position 5: 'B' == 'B', special.

Wait, position 4: 'B' == 'B' (previous) and 'B' == 'B' (next), equals both, not special.

Wait, I think I made a mistake earlier.

In "AABBB":

- Position 1: 'A' == 'A', special.

- Position 2: 'A' == 'A' and 'B', not special.

- Position 3: 'B' == 'A', special.

- Position 4: 'B' == 'B', special.

- Position 5: 'B' == 'B', special.

Wait, position 4: 'B' == 'B' (previous) and 'B' == 'B' (next), equals both, not special.

So, positions 1,3,5 are special: n=3.

Wait, perhaps the problem has a different rule.

Alternatively, maybe n must be even, but in this case, n=3 is allowed, but according to the sample input, n=1: NO, n=2: YES, n=6: YES.

Perhaps n must be even, and for some reason, n=3 is not allowed, even though it seems possible.

Wait, perhaps in the problem's constraints, n must be even.

But in my earlier example, n=3 seems possible with "AABBB".

Maybe I'm missing something.

Alternatively, perhaps the minimal string length requires n to be even.

Wait, perhaps n must be even because each special character comes in pairs.

Wait, in "AB", both are special, so n=2.

In "AAA", n=2.

In "AABBB", n=3, which seems odd.

Wait, perhaps n must be even, but in "AABBB", it's possible to have n=3.

Wait, maybe the problem has a mistake, or perhaps there are additional constraints.

Alternatively, perhaps n must be even, and in "AABBB", one of the special characters is not counted correctly.

Wait, perhaps I need to think differently.

Suppose I have a string where runs alternate, like "ABABAB".

Then, every character is special, so for length 6, n=6.

Similarly, "AAABBB" has n=4.

"AAA" has n=2.

"AA" has n=2.

"A" has n=0.

"AB" has n=2.

So, n seems to be always even.

Wait, but earlier in "AABBB", I counted n=3, which is odd.

Wait, perhaps I made a mistake in counting.

In "AABBB":

- Position 1: 'A' == 'A', special.

- Position 2: 'A' == 'A' and 'B', not special.

- Position 3: 'B' == 'A', special.

- Position 4: 'B' == 'B', special.

- Position 5: 'B' == 'B', special.

Wait, position 4: 'B' == 'B' (previous) and 'B' == 'B' (next), equals both, not special.

So, positions 1,3,5 are special: n=3.

Wait, perhaps the problem has a different definition.

Alternatively, maybe n must be even.

But in the sample input, n=1: NO, n=2: YES, n=6: YES.

So, perhaps n must be even.

But in my earlier example, n=3 seems possible.

Wait, perhaps there is a constraint that n cannot be odd, and my earlier example is wrong.

Alternatively, perhaps in the problem's context, n must be even.

Given that, perhaps the solution is to check if n is even, and if so, construct a string with n special characters, otherwise output 'NO'.

For example:

- If n is even, output 'A' repeated (n/2 + 1) times.

Wait, in "AAA": n=2.

So, for n=2, "AAA" works.

For n=4, "AAAA" has positions 1 and 4 special: n=2, which is not 4.

Wait, "AAAA" has positions 1 and 4 special: n=2.

Wait, earlier I thought "AABBCC" has n=4.

Wait, perhaps a better approach is to construct a string with n special characters by arranging runs in a specific way.

For example, for n=6, the sample output is "AAABAACC".

Let me see how to generalize this.

Perhaps, for even n, construct a string with n/2 runs of "AAB", which contributes 3 special characters per "AAB".

Wait, "AAB" has n=2 special characters.

Wait, in "AAB": positions 1 and 3 are special: n=2.

So, "AAB" has n=2.

Similarly, "AAB" repeated three times: "AABAABAAB" has n=6 special characters.

Wait, let's check:

"AABAABAAB":

- Positions 1,3,5,7,9 are special: n=5.

Not 6.

Wait, perhaps a different pattern.

Alternatively, perhaps use a pattern like "AABBAABB" for n=6.

Wait, "AABBAABB":

- Positions 1,3,4,5,6,7,8 are special: n=7.

Wait, not matching.

Wait, perhaps "AABBAACC":

- Positions 1,3,4,5,6,7,8 are special: n=7.

Still not matching.

Wait, perhaps "AAABAACC" as in the sample has n=6.

- Positions 1,3,5,6,7,8 are special: n=6.

So, perhaps in this pattern, n=6 is achievable.

But I need a general way to construct such strings for any even n.

Perhaps, for n even, construct a string with n/2 copies of "AAB".

Wait, in "AAB": n=2.

So, for n=6, use three "AAB"s: "AABAABAAB".

But earlier, I thought that has n=5.

Wait, perhaps I need to adjust the pattern.

Alternatively, perhaps use "AAB" for n=2, and concatenate them with different characters.

Wait, for n=4: "AABAABB".

- Positions 1,3,5,7 are special: n=4.

Wait, "AABAABB":

- Position 1: 'A' == 'A', special.

- Position 2: 'A' == 'A' and 'B', not special.

- Position 3: 'B' == 'A', special.

- Position 4: 'A' == 'A', special.

- Position 5: 'A' == 'B', special.

- Position 6: 'B' == 'B', special.

- Position 7: 'B' == 'B', special.

Wait, positions 1,3,4,5,6,7 are special: n=6.

Wait, that's more than n=4.

So, perhaps a different pattern.

Alternatively, for n=4: "AABBAABB".

- Positions 1,3,4,5,6,7,8 are special: n=7.

Still not matching.

This is getting complicated.

Maybe I should look for a different approach.

Let me consider that for n even, I can construct a string with n special characters by arranging runs in a specific way.

For example, for n=2: "AA".

For n=4: "AABAAB".

Wait, "AABAAB":

- Positions 1,3,5,6 are special: n=4.

Yes, that works.

Similarly, for n=6: "AABAABAAB".

- Positions 1,3,5,7,9 are special: n=5.

Still not matching.

Wait, perhaps "AAB AAB AAB" with separators.

Wait, maybe using different characters for separation.

Alternatively, perhaps it's easier to always use "AAB" patterns.

Wait, in "AAB": n=2.

So, for n=6, use three "AAB"s: "AAB AAB AAB" with spaces, but need to concatenate without spaces.

So, "AABAABAAB":

- Positions 1,3,5,7,9 are special: n=5.

Still not 6.

Wait, perhaps adjust the pattern.

Use "AABBAABB":

- Positions 1,3,4,5,6,7,8 are special: n=7.

Not matching.

Wait, perhaps "AAABAACC":

- Positions 1,3,5,6,7,8 are special: n=6.

So, this works for n=6.

So, perhaps for n even, construct a string like "AAABAACC" for n=6, and for n odd, it's impossible.

But in my earlier example, "AABBB" has n=3, which is odd.

Wait, perhaps I miscounted "AABBB".

Let me recount "AABBB":

- Position 1: 'A' == 'A', special.

- Position 2: 'A' == 'A' and 'B', not special.

- Position 3: 'B' == 'A', special.

- Position 4: 'B' == 'B', special.

- Position 5: 'B' == 'B', special.

Wait, positions 1,3,5 are special: n=3.

So, n=3 is possible.

Wait, perhaps the problem has a different rule.

Alternatively, perhaps n cannot be 1, but can be any n >=2.

But in the sample input, for n=1: NO, n=2: YES, n=6: YES.

So, perhaps n must be even.

But in my earlier example, n=3 is possible.

Wait, maybe the problem has a mistake, or perhaps there are additional constraints that I'm missing.

Alternatively, perhaps n must be even, and in my earlier examples, I'm miscounting the special characters.

Wait, perhaps I need to think in terms of graph theory or some pairing.

Alternatively, perhaps n must be even because each special character is part of a pair.

Wait, in "AB", both are special, forming a pair.

In "AAA", positions 1 and 3 are special, forming a pair.

In "AABBB", positions 1,3,5 are special: n=3, which is odd.

Wait, perhaps in some constructions, n can be odd, but the problem's constraints require n to be even.

But in the sample input, for n=1: NO, n=2: YES, n=6: YES.

So, perhaps n must be even.

Given that, perhaps the solution is to check if n is even, and if so, construct a string with n special characters, otherwise output 'NO'.

For example, for n=2: "AA".

For n=4: "AABAAB".

For n=6: "AAABAACC".

And for n=1: 'NO'.

This seems consistent with the sample input.

Therefore, the solution is to check if n is even, and if so, construct a string with n special characters, otherwise output 'NO'.

Hence, the program should:

- Read t, the number of test cases.

- For each test case:

- Read n.

- If n is odd, output 'NO'.

- If n is even, construct a string with n special characters and output 'YES' followed by the string.

- Ensure that the string has at most 200 characters.

Now, looking at the given program:

def func():

t = int(input())

for _ in range(t):

n = int(input())

if n % 2:

print('NO')

else:

s = '110' * (n // 2)

if len(s) < 200:

print('YES')

print