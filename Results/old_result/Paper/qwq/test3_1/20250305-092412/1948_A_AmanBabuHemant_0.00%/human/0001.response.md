Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an integer n, and I need to build a string of uppercase Latin letters where exactly n characters are "special." A special character is one that's equal to exactly one of its neighbors. For example, in "AAABAACC," there are 6 special characters at positions 1, 3, 5, 6, 7, and 8.

First, I need to understand what makes a character special. If a character is equal to exactly one of its neighbors, that means:

- If it's the first character, it's special only if it's equal to the second character.

- If it's the last character, it's special only if it's equal to the second-to-last character.

- For any character in the middle, it's special if it's equal to either the previous or the next character, but not both.

So, for the string "AAABAACC":

- Position 1: 'A' equals the next 'A', but not the previous (since there is none), so it's special.

- Position 2: 'A' equals both previous and next 'A's, so it's not special.

- Position 3: 'A' equals the next 'B', which is different, and the previous 'A', which is equal, so it's special.

- Position 4: 'B' equals the next 'A', which is different, and the previous 'A', which is different, so it's special.

- Position 5: 'A' equals the next 'A', but not the previous 'B', so it's special.

- Position 6: 'A' equals both previous 'A' and next 'C', which is different, so it's special.

- Position 7: 'C' equals the next 'C', but not the previous 'A', so it's special.

- Position 8: 'C' equals the previous 'C', but not the next (since there is none), so it's special.

Total special characters: 6, which matches the example.

Now, I need to generate a string where exactly n characters are special. The string should be composed of uppercase letters, and its length should be at most 200.

First, think about the minimal string length required for a given n. Since each special character needs to be equal to exactly one neighbor, I need to arrange the characters in such a way that exactly n characters satisfy this condition.

Let's consider small values of n to see if there's a pattern.

Case 1: n = 1

Is it possible to have a string with exactly one special character?

Let's try:

- "AA": Positions: 1 is special (equals next 'A'), 2 is special (equals previous 'A'). Total special: 2. Too many.

- "ABA": Positions: 1 is special (equals next 'B'), 2 is not special ('B' != 'A' and 'B' != 'A'), 3 is special (equals previous 'A'). Total special: 2 again.

- "ABC": Positions: 1 is special (equals next 'B'? No), 2 is not special ('B' != 'A' and 'B' != 'C'), 3 is special (equals previous 'C'? No). Total special: 0.

- "AAB": Positions: 1 is special (equals next 'A'), 2 is not special ('A' equals both 'A' and 'B'), 3 is special (equals previous 'B'). Total special: 2.

Hmm, seems like it's hard to get exactly one special character. Maybe it's impossible.

Case 2: n = 2

- "AA": As above, positions 1 and 2 are both special. Total: 2. This works.

- "ABA": Positions 1 and 3 are special, total: 2. Also works.

- "AABB": Positions 1 (special), 2 (not special), 3 (not special), 4 (special). Total: 2.

So, for n=2, it's possible.

Case 3: n = 3

- "AAAB": Positions 1 (special), 2 (not special), 3 (special), 4 (special). Total: 3.

Wait, in "AAAB":

- Pos 1: 'A' equals next 'A', special.

- Pos 2: 'A' equals both 'A' and 'A', not special.

- Pos 3: 'A' equals both 'A' and 'B', not special.

- Pos 4: 'B' equals previous 'A', which is different, so not special.

Total special: 1. Not 3.

- "AABAA": Positions 1 (special), 2 (not special), 3 (special), 4 (special), 5 (special). Total: 3.

Wait:

- Pos 1: 'A' equals next 'A', special.

- Pos 2: 'A' equals both 'A' and 'B', not special.

- Pos 3: 'B' equals previous 'A' and next 'A', different, so special.

- Pos 4: 'A' equals previous 'B' and next 'A', different, so special.

- Pos 5: 'A' equals previous 'A', special.

Total special: positions 1, 3, 4, 5. That's 4, which is more than n=3.

Hmm, hard to get exactly 3.

Maybe n=3 is impossible.

From these observations, it seems that for n=1 and n=3, it's hard to get an odd number of special characters. While for even n, it's easier.

Looking back at the example, n=6 is possible with "AAABAACC," and n=2 is possible with "MM."

But n=1 seems impossible.

So, perhaps only even n are possible.

Looking back at the sample output:

For n=6: YES, AAABAACC

For n=1: NO

For n=2: YES, MM

This supports the hypothesis that only even n are possible.

Wait, but in the case of n=2, "MM" has positions 1 and 2 both special, since each 'M' equals its neighbor.

But in "AAABAACC," there are 6 special characters.

Wait, but in "AAABAACC," positions 1,3,5,6,7,8 are special, which is 6.

But in "MM," positions 1 and 2 are both special, total 2.

So, for n even, it's possible; for n odd, it's not.

Is this always the case?

Let me try to see for n=4.

Possible string: "AABBAACC"

Positions:

1: 'A' equals next 'A', special.

2: 'A' equals both 'A' and 'B', not special.

3: 'B' equals previous 'A' and next 'B', different, special.

4: 'B' equals both 'B' and 'A', different, special.

5: 'A' equals both 'B' and 'A', different, special.

6: 'A' equals both 'A' and 'C', different, special.

7: 'C' equals next 'C', special.

8: 'C' equals previous 'C', special.

Total special: positions 1,3,4,5,6,7,8. That's 7, which is more than n=4.

Wait, not good.

Alternative for n=4: "AABB"

Positions:

1: 'A' equals next 'A', special.

2: 'A' equals both 'A' and 'B', not special.

3: 'B' equals previous 'A' and next 'B', different, special.

4: 'B' equals previous 'B', special.

Total special: positions 1,3,4. That's 3, which is less than n=4.

Another try: "AABBC"

Positions:

1: 'A' equals next 'A', special.

2: 'A' equals both 'A' and 'B', not special.

3: 'B' equals previous 'A' and next 'B', different, special.

4: 'B' equals both 'B' and 'C', different, special.

5: 'C' equals previous 'B', different, special.

Total special: positions 1,3,4,5. That's 4.

Wait, but position 5: 'C' equals previous 'B', which is different, so it's special.

So, total special: 4.

So, "AABBC" has exactly 4 special characters.

Good.

So, for n=4, it's possible.

Another example: n=0.

Is it possible to have a string with 0 special characters?

- "A": Position 1 is special (equals next? No next.), so not special.

Wait, in a single character string, there are no neighbors, so no special characters.

- "AB": Positions: 1 is special (equals next 'B'? No), 2 is special (equals previous 'A'? No). So, no special characters.

- "ABC": Positions: 1 is special (equals next 'B'? No), 2 is not special ('B' != 'A' and 'B' != 'C'), 3 is special (equals previous 'C'? No). Total: 0.

So, for n=0, it's possible.

But according to the sample input, n=1 is impossible, n=2 is possible with "MM".

Wait, but n=0 is possible, but not present in the sample input.

But the problem says n can be from 1 to 50, and t from 1 to 50.

In the sample input, n=6,1,2.

For n=6: YES, AAABAACC

n=1: NO

n=2: YES, MM

So, seems like for n odd, it's impossible.

But why?

Let's think about the properties.

Each special character contributes +1 to the total special count.

But in a string, characters can be dependent on their neighbors.

Let me think in terms of graph theory.

Imagine each character as a node, and edges between adjacent characters.

A character is special if it has exactly one edge to an equal character.

Wait, perhaps think in terms of degrees in graph theory.

But maybe that's overcomplicating.

Another approach: consider that each special character must have exactly one neighbor equal to it.

So, if a character is special, it must have one equal neighbor and one unequal neighbor (except at the ends).

Wait, at the ends, it's easier.

For the first character:

- It's special if it equals the second character.

For the last character:

- It's special if it equals the second-to-last character.

For any character in the middle:

- It's special if it equals exactly one of its neighbors.

So, to have exactly n special characters, I need to arrange the string such that exactly n characters satisfy this condition.

Is there a pattern or formula to determine for which n it's possible?

From the examples:

n=1: NO

n=2: YES, "MM"

n=4: YES, "AABBC"

n=6: YES, "AAABAACC"

n=0: YES, "A" or "AB" or "ABC"

Wait, but n=0 is allowed, but n=1 is not.

Is there a pattern based on parity?

It seems that for even n, it's possible, and for odd n, it's not.

But need to confirm.

Looking back at the sample input:

n=6: YES

n=1: NO

n=2: YES

So, seems like only even n are possible.

But need to confirm this.

Wait, in the sample input, n=1 is NO, n=2 is YES, n=6 is YES.

Also, n=0 is possible, which is even.

So, perhaps only even n are possible.

But need to see if there's a general rule.

Alternatively, maybe n cannot be 1, but can be any other n.

But from my earlier attempts, n=3 seems hard to achieve.

Let me try n=3.

Try to construct a string with exactly 3 special characters.

Let's try "AAABC"

Positions:

1: 'A' equals next 'A', special.

2: 'A' equals both 'A' and 'A', not special.

3: 'A' equals both 'A' and 'B', different, special.

4: 'B' equals previous 'A' and next 'C', different, special.

5: 'C' equals previous 'B', different, special.

Total special: positions 1,3,4,5. That's 4, which is more than n=3.

Another try: "AABBCD"

Positions:

1: 'A' equals next 'A', special.

2: 'A' equals both 'A' and 'B', not special.

3: 'B' equals previous 'A' and next 'B', different, special.

4: 'B' equals both 'B' and 'C', different, special.

5: 'C' equals previous 'B' and next 'D', different, special.

6: 'D' equals previous 'C', different, special.

Total special: positions 1,3,4,5,6. That's 5, which is more than n=3.

Another try: "AABBCC"

Positions:

1: 'A' equals next 'A', special.

2: 'A' equals both 'A' and 'B', not special.

3: 'B' equals previous 'A' and next 'B', different, special.

4: 'B' equals both 'B' and 'C', different, special.

5: 'C' equals previous 'B' and next 'C', different, special.

6: 'C' equals previous 'C', special.

Total special: positions 1,3,4,5,6. That's 5, still more than n=3.

Hmm.

Is there a way to get exactly n=3?

Maybe by making some characters not special.

Let's try "AABC"

Positions:

1: 'A' equals next 'A', special.

2: 'A' equals both 'A' and 'B', not special.

3: 'B' equals previous 'A' and next 'C', different, special.

4: 'C' equals previous 'B', different, special.

Total special: positions 1,3,4. That's 3.

Yes! So, "AABC" has exactly 3 special characters.

Wait, but earlier I thought n=3 was impossible, but this seems to work.

Wait, let's check again.

Positions:

1: 'A' equals next 'A', special.

2: 'A' equals both 'A' and 'B', not special.

3: 'B' equals previous 'A' and next 'C', different, special.

4: 'C' equals previous 'B', different, special.

Total special: 1,3,4. That's 3.

So, for n=3, "AABC" works.

But according to the sample input, n=1 is NO.

Wait, but n=3 is possible with "AABC".

So, perhaps my initial assumption that only even n are possible is wrong.

Maybe there's another condition.

Wait, in the sample input, n=1 is NO, but n=3 is possible.

So, perhaps n=1 is impossible, but higher odd n are possible.

But why is n=1 impossible?

Let's try to think about n=1.

Suppose we have a string with only one special character.

Consider "A": position 1 is not special because it has no neighbor.

"A": positions: 1 is not special.

"AB": positions: 1 is not special ('A' != 'B'), 2 is not special ('B' != 'A').

"ABA": positions: 1 is special ('A' == 'B'? No), wait:

In "ABA":

- Pos 1: 'A' equals next 'B'? No, not special.

- Pos 2: 'B' equals previous 'A' and next 'A', different, special.

- Pos 3: 'A' equals previous 'B', different, special.

Total special: positions 2 and 3. That's 2, not 1.

So, can't get exactly one special character.

Another try: "ABB"

Positions:

1: 'A' equals next 'B', different, special.

2: 'B' equals previous 'A' and next 'B', different, special.

3: 'B' equals previous 'B', special.

Total special: positions 1 and 2. That's 2.

Wait, pos 3: 'B' equals previous 'B', so it's special.

Wait, in the definition, a special character is equal to exactly one of its neighbors.

In "ABB":

- Pos 1: 'A' != 'B', so special.

- Pos 2: 'B' != 'A' and 'B' == 'B', so special.

- Pos 3: 'B' == 'B', so it's equal to both neighbors, but the condition is equal to exactly one neighbor, so pos 3 is not special.

Wait, wait, pos 3: 'B' == previous 'B', so it's equal to one neighbor (previous), and next there is none, so it's equal to exactly one neighbor. So, special.

Wait, no. The condition is: equal to exactly one of its neighbors.

In pos 3 of "ABB", 'B' == previous 'B', and next is none. So, it's equal to exactly one neighbor (previous 'B'). So, it's special.

So, in "ABB", positions 1,2,3 are all special. Total: 3.

Which is more than n=1.

So, can't get exactly one special character.

Another try: "ABC"

Positions:

1: 'A' != 'B', not special.

2: 'B' != 'A' and 'B' != 'C', not special.

3: 'C' != 'B', not special.

Total special: 0.

So, no special characters.

So, to have exactly one special character seems impossible.

Hence, n=1 is indeed impossible.

But n=3 is possible with "AABC".

So, perhaps only n >=2 and n even are possible, or something else.

Wait, n=3 is possible, n=1 is not.

Is there a different pattern?

Let me think about the minimal string length required for a given n.

For n=1: impossible.

For n=2: "MM" works.

For n=3: "AABC" works.

For n=4: "AABBCD" (positions 1,3,4,5: 4 special).

Wait, in "AABBCD": positions 1,3,4,5 are special, total 4.

So, n=4 is possible.

For n=5: let's try "AABBCD"

In "AABBCD":

- Pos 1: 'A' == 'A', special.

- Pos 2: 'A' == 'A' and 'B', not special.

- Pos 3: 'B' != 'A' and 'B', special.

- Pos 4: 'B' == 'B' and 'C', different, special.

- Pos 5: 'C' != 'B' and 'D', special.

- Pos 6: 'D' != 'C', special.

Total special: positions 1,3,4,5,6: 5.

So, n=5 is possible with "AABBCD".

Wait, but earlier I thought n=5 was impossible, but according to this, it's possible.

Wait, in "AABBCD", positions 1,3,4,5,6 are special, total 5.

So, n=5 is possible.

But n=1 is impossible.

So, perhaps only n >=2 is possible.

But in the sample input, n=1 is NO, n=2 is YES, n=6 is YES.

But according to this, n=3 and n=5 are possible.

Wait, maybe only n !=1 is possible.

But in the sample input, n=1 is NO, n=2 is YES, n=6 is YES.

So, perhaps n=1 is impossible, and n >=2 are possible.

But in my earlier attempt, n=3 ("AABC": 3 special) and n=5 ("AABBCD":5 special) seem possible.

So, perhaps only n !=1 is possible.

But need to confirm for n=0.

n=0 is possible with "A" or "AB" or "ABC", as shown earlier.

So, seems like n=1 is impossible, but n=0 and n>=2 are possible.

But in the sample input, n=1 is NO, n=2 is YES, n=6 is YES.

But according to my construction, n=3 and n=5 are possible.

Wait, maybe the problem considers n=0 as impossible, but in my earlier thought, n=0 is possible.

But in the sample input, n=0 is not present, but according to the problem statement, n can be from 1 to 50.

Wait, the problem says 1 <= n <=50, and t from 1 to 50.

But in the sample input, n=6,1,2.

For n=6: YES, AAABAACC

n=1: NO

n=2: YES, MM

So, seems like only n=1 is impossible, and others are possible.

But in my earlier attempts, n=3 and n=5 seem possible.

Maybe the problem has some specific constraints that I'm missing.

Alternatively, perhaps the problem has a misprint in the sample input or output.

But assuming the sample input and output are correct, and the problem is correctly stated, then n=1 is impossible, and n>=2 are possible.

But according to my constructions, n=3 and n=5 are possible.

So, perhaps the problem has some specific rule that makes n=1 impossible, but higher n possible.

Alternatively, maybe there's a pattern based on the parity of n.

Wait, in my earlier thought, n=1 is impossible, n=2 is possible, n=3 is possible, n=4 is possible, n=5 is possible, etc.

So, perhaps only n=1 is impossible, and all other n are possible.

But need to confirm.

Wait, perhaps the number of special characters must be even or something.

But in "AABC", n=3 is possible, and in "AABBCD", n=5 is possible.

So, seems like any n except n=1 is possible.

But need to confirm.

Wait, perhaps for n=1, it's impossible because a single special character cannot exist without another special character in the string.

Like, special characters come in pairs or something.

In "AABC", n=3: positions 1,3,4 are special.

Wait, position 1: 'A' == 'A', special.

Position 2: 'A' == 'A' and 'B', not special.

Position 3: 'B' != 'A' and 'C', special.

Position 4: 'C' != 'B', special.

So, total special: 1,3,4.

That's 3.

But in "AABBCD", n=5: positions 1,3,4,5,6 are special.

So, n=5 is possible.

So, seems like any n >=0 except n=1 is possible.

But in the sample input, n=1 is NO, n=2 is YES, n=6 is YES.

So, perhaps only n=1 is impossible, and all other n are possible.

But need to confirm.

Alternatively, maybe n cannot be 1 because of some property of the string.

Let me think differently.

Suppose I have a string of length l.

Each character can be special or not based on its neighbors.

I need exactly n special characters.

Is there a formula or pattern that relates n to l?

Not sure.

Alternatively, perhaps think in terms of building blocks.

For example, "MM" has n=2.

"AABB" has n=3? Wait, in "AABB":

Positions:

1: 'A' == 'A', special.

2: 'A' == 'A' and 'B', not special.

3: 'B' == 'A' and 'B', different, special.

4: 'B' == 'B', special.

Total special: positions 1,3,4: n=3.

Wait, but earlier I thought n=3 was possible with "AABC", which also has n=3.

So, seems like n=3 is possible.

But according to the sample input, n=1 is NO, which is consistent with my earlier conclusion.

So, perhaps only n=1 is impossible, and all other n are possible.

But need to confirm for higher n.

For n=4: "AABBCD": positions 1,3,4,5: n=4.

Wait, in "AABBCD", positions 1,3,4,5,6 are special: n=5.

Wait, in "AABBCD":

- Pos 1: 'A' == 'A', special.

- Pos 2: 'A' == 'A' and 'B', not special.

- Pos 3: 'B' != 'A' and 'B', special.

- Pos 4: 'B' == 'B' and 'C', different, special.

- Pos 5: 'C' != 'B' and 'D', special.

- Pos 6: 'D' != 'C', special.

Total special: positions 1,3,4,5,6: n=5.

So, n=5 is possible.

Wait, but I thought "AABBCC" has n=5.

Wait, in "AABBCC":

Positions:

1: 'A' == 'A', special.

2: 'A' == 'A' and 'B', not special.

3: 'B' == 'A' and 'B', different, special.

4: 'B' == 'B' and 'C', different, special.

5: 'C' == 'B' and 'C', different, special.

6: 'C' == 'C', special.

Total special: positions 1,3,4,5,6: n=5.

So, n=5 is possible.

Similarly, for n=4, maybe "AABBC": positions 1,3,4,5: n=4.

Wait, in "AABBC":

Positions:

1: 'A' == 'A', special.

2: 'A' == 'A' and 'B', not special.

3: 'B' == 'A' and 'B', different, special.

4: 'B' == 'B' and 'C', different, special.

5: 'C' == 'B', different, special.

Total special: positions 1,3,4,5: n=4.

Yes, so n=4 is possible.

So, seems like any n >=2 is possible except n=1.

Hence, the program should output "NO" only when n=1, and "YES" with a suitable string for all other n.

But in the sample input, n=1 is NO, n=2 is YES, n=6 is YES.

So, seems consistent.

But in my earlier attempts, n=3 and n=5 are possible.

So, perhaps the general rule is:

- If n ==1, output "NO"

- Else, output "YES" and construct a string with exactly n special characters.

But how to construct such a string?

One way is to use a pattern that allows controlling the number of special characters.

For example, using blocks of 'A's and 'B's in a specific way.

But need to find a general way to construct the string for any n >=2.

Let's think about building the string.

One approach is to use a string where every two characters are the same, like "AA BB CC DD ...", where each "AA" contributes two special characters (positions 1 and 2 are both special).

Wait, in "AA", positions 1 and 2 are both special.

So, "AA" has n=2.

Similarly, "AA BB CC" would have n=6 (2 per block).

So, for n divisible by 2, we can use n/2 blocks of "AA", each contributing 2 special characters.

For example, for n=6: "AA AA AA" would have 6 special characters.

But need to make sure that the blocks are separated appropriately.

Wait, in "AAAABB": positions 1 (special), 2 (not special), 3 (special), 4 (special), 5 (special), 6 (special). Total n=5.

Wait, not consistent.

Maybe need to separate blocks with different letters.

For example, "AA BB CC": positions 1 (special), 2 (special), 3 (special), 4 (special), 5 (special), 6 (special). Total n=6.

Wait, in "AABBCC":

- Pos 1: 'A' == 'A', special.

- Pos 2: 'A' == 'A' and 'B', not special.

- Pos 3: 'B' == 'A' and 'B', different, special.

- Pos 4: 'B' == 'B' and 'C', different, special.

- Pos 5: 'C' == 'B' and 'C', different, special.

- Pos 6: 'C' == 'C', special.

Total special: positions 1,3,4,5,6: n=5.

Wait, that's n=5.

But in "AA BB CC", it's similar to "AABBCC", which has n=5.

Wait, perhaps need to adjust the blocks.

Alternatively, use "AA BA CB": let's see.

"AA" "BA" "CB"

Which would be "AABACB"

Positions:

1: 'A' == 'A', special.

2: 'A' == 'A' and 'B', not special.

3: 'B' == 'A' and 'A', different, special.

4: 'A' == 'B' and 'C', different, special.

5: 'C' == 'B', different, special.

6: 'B' == 'C', different, special.

Total special: positions 1,3,4,5,6: n=5.

Still n=5.

Wait, perhaps need a different arrangement.

Alternatively, use "AA" + "BB" + "CC" with separators.

But seems complicated.

Alternatively, think recursively.

For n even, use n/2 blocks of "AA", each contributing 2 special characters.

For n odd greater than 1, perhaps adjust the blocks.

Wait, but in the sample input, n=1 is NO, n=2 is YES, n=6 is YES.

And according to my earlier thoughts, n=3 and n=5 are possible with specific strings.

But need a general method.

Alternatively, perhaps think in terms of adding special characters in pairs.

For example, adding "AA" adds 2 special characters.

Then, to add more special characters, add "BB" after it, which adds 2 more.

And so on.

But in "AABB", n=4.

Wait, in "AABB":

- Pos 1: 'A' == 'A', special.

- Pos 2: 'A' == 'A' and 'B', not special.

- Pos 3: 'B' == 'A' and 'B', different, special.

- Pos 4: 'B' == 'B', special.

Total special: positions 1,3,4: n=3.

Wait, that's n=3.

So, "AABB" has n=3.

Similarly, "AA BB CC" would have n=5.

Wait, seems like each "BB" added after "AA" adds 2 special characters, but overlaps.

Wait, maybe need to adjust.

Alternatively, perhaps use "AAA" to get n=2.

In "AAA":

- Pos 1: 'A' == 'A', special.

- Pos 2: 'A' == 'A' and 'A', not special.

- Pos 3: 'A' == 'A', special.

Total special: positions 1 and 3: n=2.

So, "AAA" has n=2.

Similarly, "AAAA" would have positions 1 (special), 2 (not special), 3 (not special), 4 (special): n=2.

Wait, same as "AAA".

So, to get more special characters, need to add more blocks.

For example, "AAA AAA": positions 1,3,5,7: n=4.

Wait, but in "AAA AAA":

- Pos 1: 'A' == 'A', special.

- Pos 2: 'A' == 'A' and 'A', not special.

- Pos 3: 'A' == 'A', special.

- Pos 4: 'A' == 'A', special.

- Pos 5: 'A' == 'A' and 'A', not special.

- Pos 6: 'A' == 'A', special.

Total special: positions 1,3,4,6: n=4.

So, "AAA AAA" has n=4.

Similarly, "AAA AAA AAA" would have n=6.

So, for n even, we can use n/2 blocks of "AAA", each contributing 2 special characters.

Wait, but "AAA" has n=2.

So, for n=6, use three "AAA" blocks: "AAA AAA AAA", which would have n=6.

Similarly, for n=4, use two "AAA" blocks: "AAA AAA", which has n=4.

So, this seems to work for even n.

For odd n, perhaps it's impossible, but earlier I thought n=3 was possible with "AABC".

Wait, in "AABC", n=3.

But according to this pattern, only even n are possible.

But in "AABC", n=3.

Wait, perhaps I miscalculated earlier.

In "AABC":

- Pos 1: 'A' == 'A', special.

- Pos 2: 'A' == 'A' and 'B', not special.

- Pos 3: 'B' != 'A' and 'C', special.

- Pos 4: 'C' != 'B', special.

Total special: positions 1,3,4: n=3.

So, n=3 is possible.

Similarly, in "AAA AB BB":

- "AAA AB BB"

Wait, need to construct strings carefully.

But perhaps for odd n, use a combination of blocks.

Alternatively, maybe the initial assumption is wrong.

Looking back at the sample input, n=1 is NO, n=2 is YES, n=6 is YES.

But according to my earlier constructions, n=3 and n=5 are possible.

So, perhaps only n=1 is impossible, and all other n are possible.

Hence, the program should output "NO" only for n=1, and "YES" with a suitable string for all other n.

But need to confirm.

Wait, in the sample input, n=1 is NO, n=2 is YES, n=6 is YES.

And according to my constructions, n=3 and n=5 are possible.

So, seems like only n=1 is impossible.

Hence, the program should output "NO" only for n=1, and "YES" for all other n.

But the problem allows n from 1 to 50, and t from 1 to 50.

Hence, for each test case, if n ==1, output "NO", else output "YES" and a suitable string.

But need to construct the string for n >=2.

How to construct the string?

One way is to use n/2 blocks of "AA", each contributing 2 special characters.

For example, for n=6: "AA AA AA", which has n=6.

But need to ensure that the blocks are separated appropriately.

Wait, in "AA AA AA":

Positions:

1: 'A' == 'A', special.

2: 'A' == 'A' and ' ', not special.

3: 'A' == ' ' and 'A', not special.

4: 'A' == 'A', special.

5: 'A' == 'A' and ' ', not special.

6: 'A' == ' ' and 'A', not special.

7: 'A' == 'A', special.

Wait, spaces are not allowed; the string should consist only of uppercase letters.

Wait, perhaps without spaces.

In "AAAAAA":

Positions:

1: 'A' == 'A', special.

2: 'A' == 'A' and 'A', not special.

3: 'A' == 'A' and 'A', not special.

4: 'A' == 'A' and 'A', not special.

5: 'A' == 'A' and 'A', not special.

6: 'A' == 'A', special.

Total special: positions 1 and 6: n=2.

So, "AAAAAA" has n=2.

Wait, that's not enough for n=6.

So, need a different approach.

Alternatively, use alternating blocks of "AA" and "BB".

For example, "AABBCC":

Positions:

1: 'A' == 'A', special.

2: 'A' == 'A' and 'B', not special.

3: 'B' == 'A' and 'B', different, special.

4: 'B' == 'B' and 'C', different, special.

5: 'C' == 'B' and 'C', different, special.

6: 'C' == 'C', special.

Total special: positions 1,3,4,5,6: n=5.

So, n=5.

Wait, for n=6, need to adjust.

Alternatively, use "AA BA CB DC":

But this seems too complicated.

Alternatively, perhaps use a pattern like "AA" + "BA" + "CB" + ... to add more special characters.

But need a general method.

Alternatively, perhaps use a recursive approach: start with "AA" (n=2), and add "BA" (adding 2 more special characters).

Wait, in "AABA":

Positions:

1: 'A' == 'A', special.

2: 'A' == 'A' and 'B', not special.

3: 'B' == 'A' and 'A', different, special.

4: 'A' == 'B', different, special.

Total special: positions 1,3,4: n=3.

So, "AABA" has n=3.

Similarly, "AABACA": positions 1,3,4,6: n=4.

Wait, in "AABACA":

- Pos 1: 'A' == 'A', special.

- Pos 2: 'A' == 'A' and 'B', not special.

- Pos 3: 'B' == 'A' and 'A', different, special.

- Pos 4: 'A' == 'B' and 'C', different, special.

- Pos 5: 'C' == 'A', different, special.

- Pos 6: 'A' == 'C', different, special.

Total special: positions 1,3,4,5,6: n=5.

So, n=5.

Wait, seems like adding "ACA" to "AABA" increases the number of special characters.

So, perhaps there's a pattern here.

Alternatively, perhaps it's easier to construct a string with n special characters by using a combination of "AA" and "AB" blocks.

But need to find a general method.

Given time constraints, perhaps accept that for n >=2, it's possible, and for n=1, it's impossible.

Hence, the program should output "NO" only for n=1, and "YES" with a suitable string for all other n.

But need to construct the string for n >=2.

One way is to use n/2 blocks of "AA", each contributing 2 special characters.

For example, for n=6: "AA AA AA", which has n=6.

But need to remove spaces.

So, "AAAAAA" has n=2, which is not enough.

Wait, perhaps use "AA BA CA CB DB DC" or something.

But this seems too complicated.

Alternatively, perhaps use a pattern like "AA" followed by "BA" repeated.

For example, "AABA":

- n=3

"AABACA":

- n=5

So, for n even, use "AA" repeated n/2 times.

Wait, but "AAAAAA" has n=2.

Wait, perhaps need to interleave different letters.

For example, "AABBC": n=4.

Wait, in "AABBC":

- Pos 1: 'A' == 'A', special.

- Pos 2: 'A' == 'A' and 'B', not special.

- Pos 3: 'B' == 'A' and 'B', different, special.

- Pos 4: 'B' == 'B' and 'C', different, special.

- Pos 5: 'C' == 'B', different, special.

Total special: positions 1,3,4,5: n=4.

So, for n=4, "AABBC" works.

Similarly, for n=6, "AABBCD": positions 1,3,4,5,6: n=5.

Wait, that's n=5.

So, need to adjust.

Alternatively, perhaps use "AA" for n=2, and for higher n, add "B" blocks.

But need a general method.

Given time constraints, perhaps accept that for n >=2, it's possible, and construct a string accordingly.

Hence, in the program, if n is even, output "YES" and a string of n/2 blocks of "AA".

For odd n, perhaps use (n-1)/2 blocks of "AA" and add a "B" or something.

But according to earlier thoughts, n=3 is possible with "AABC".

Hence, perhaps just output "YES" for n >=2, and "NO" for n=1.

But need to provide a string for n >=2.

Given that the maximum string length is 200, and it's guaranteed that if a solution exists, there's a string of length at most 200.

Hence, for n >=2, output "YES" and a string of appropriate length.

In the program, it seems to output "YES" for even n and "NO" for odd n.

But according to my earlier reasoning, n=1 is NO, n=2 is YES, n=3 is YES, n=4 is YES, etc.

But in the program, it outputs "YES" for even n and "NO" for odd n.

Hence, the program is incorrect because it incorrectly classifies odd n >=3 as impossible, while they are possible.

Hence, the program is incorrect.

**Final Answer**

\[ \boxed{\text{False}} \]