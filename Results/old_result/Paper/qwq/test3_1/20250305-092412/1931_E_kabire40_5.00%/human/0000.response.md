Alright, I've got this problem to solve. It's about determining who wins in a game between Anna and Sasha based on their moves on a list of integers. Let's break this down step by step.

First, I need to understand the game rules:

1. Anna goes first, and she reverses the digits of one number in the list each turn. For example, 42 becomes 24, and 1580 becomes 851. Leading zeros are removed.

2. Sasha, on his turn, picks two numbers from the list, concatenates them in any order, and puts the result back into the list. So, if he picks 2007 and 19, he can add either 200719 or 192007 to the list.

3. The game continues until there's only one number left in the list. At that point, if this number is greater than or equal to 10^m, Sasha wins; otherwise, Anna wins.

I need to determine, for multiple test cases, who wins if both play optimally.

Okay, let's think about how to approach this.

First, I need to understand the sequence of moves and how the list evolves.

- The game alternates between Anna and Sasha.

- Anna reverses one number each turn.

- Sasha concatenates two numbers and puts one back.

The game ends when there's only one number left, and based on its value, we decide the winner.

I need to model this game in a way that allows me to determine the winner without simulating every possible move, which would be inefficient given the constraints.

Given that n can be up to 2*10^5 and t up to 10^4, I need an efficient algorithm.

Let me consider the parity of the number of elements in the list.

- Initially, there are n elements.

- Each of Sasha's moves reduces the number of elements by 1 (since he removes two and adds one).

- Anna's moves don't change the number of elements.

So, the number of Sasha's moves is (n - 1), assuming he can always make moves until only one element is left.

But wait, Anna can choose which number to reverse each time, which can affect what Sasha can do.

Wait, but in the end, the game will always end after a certain number of moves because Sasha's moves reduce the list size by one each time he plays.

Wait, but Anna can choose to reverse any number each time before Sasha plays.

Wait, no: Anna reverses one number each turn, and then Sasha makes his move.

But actually, looking back at the problem statement:

"Players take turns. Anna makes the first move. On her turn, Anna reverses one number. On his turn, Sasha extracts two numbers, concatenates them in any order, and inserts the result back into the list."

So, the sequence is: Anna reverses one number, then Sasha picks two numbers, concatenates them, and inserts back one number, reducing the list size by one.

This continues until there's only one number left.

Wait, but the problem says: "The game ends when Sasha can't make a move, i.e., after Anna's move there is exactly one number left in the list."

So, the game ends when there's only one number left, and at that point, we check if that number is >= 10^m.

I need to determine, for each test case, who wins if both play optimally.

Given that, I need to find a way to determine the winner based on the initial list and the parameters n and m.

Let me consider small examples to get an intuition.

Take the first sample input:

2 2

14 2

Anna reverses one number. She can choose to reverse 14 to 41 or 2 to 2.

If she reverses 14 to 41, the list becomes [41, 2]. Then Sasha concatenates them to make either 412 or 241. Both are greater than 100, so Sasha wins.

If she reverses 2 to 2, the list remains [14, 2]. Sasha concatenates to make 142 or 214, both greater than 100, so again Sasha wins.

So, no matter what Anna does, Sasha can win in this case.

Another sample input:

1 1

6

Here, there's only one number, so Sasha can't make a move. The number is 6, which is less than 10^1=10, so Anna wins.

Wait, but according to the problem, the game ends after Anna's move when there's one number left. So in this case, Anna wins because the number is less than 10.

Another sample:

1 1

10

Here, Anna can reverse 10 to 01, which is 1. So the number becomes 1, which is less than 10, so Anna wins again.

Wait, but 01 is 1, without leading zeros.

Wait, but 10 reversed is 01, which is 1.

So, Anna can choose to reverse 10 to 1, making the number less than 10, so she wins.

But if she doesn't reverse it, it remains 10, which is >=10, so Sasha wins.

Wait, but in this case, Anna can choose to reverse it to 1, making it less than 10, so she wins.

So, in this case, Anna has a winning strategy.

Looking back at the problem, I need to see who can force the final number to be >=10^m or <10^m.

I need to find a general strategy for both players.

Let me consider the game as a sequence of moves where Anna reverses one number each turn, and Sasha concatenates two numbers and inserts one back, reducing the list size by one each time.

The game ends when there's only one number left, and based on its value, we decide the winner.

I need to think about what Anna can do to minimize the final number, and what Sasha can do to maximize it.

Since Anna goes first, she can choose to reverse any one number in the list each time before Sasha concatenates two numbers.

I need to think about the optimal strategies for both players.

This seems complex, so maybe I can look for some invariant or some way to evaluate the list that can help me determine the winner without simulating all moves.

Let me consider that Anna can reverse any one number each turn, and Sasha can concatenate any two numbers in any order.

I need to consider that Anna wants the final number to be as small as possible, while Sasha wants it to be as large as possible.

Given that, perhaps I can consider the minimal possible final number Anna can achieve versus the maximal Sasha can achieve.

But that seems too vague.

Let me consider the properties of the operations.

First, reversing a number can change its value, sometimes increasing it, sometimes decreasing it.

Concatenating two numbers can create a very large number, depending on the order.

Given that, Sasha, who wants the number to be large, will choose to concatenate in a way that maximizes the number.

Anna, on her turn, wants to minimize the final number, so she will choose to reverse a number in a way that minimizes the final number.

Given that, perhaps I can think of the game as a series of transformations where Anna tries to minimize and Sasha tries to maximize the final number.

This seems like a minimax problem.

But with n up to 2e5 and t up to 1e4, I need an efficient way to compute this.

Let me consider the parity of the number of Sasha's moves.

Each time Sasha moves, he reduces the list size by one.

Starting from n elements, the number of Sasha's moves will be n-1, since each move reduces the list by one, from n to 1.

Anna moves before each of Sasha's moves, so she has n-1 moves as well.

So, there are n-1 Anna moves and n-1 Sasha moves.

Wait, no.

Wait, the game proceeds as follows:

- Anna makes a move (reverses one number).

- Then Sasha makes a move (picks two numbers, concatenates, inserts back one).

- This continues until there's only one number left.

So, the number of Sasha's moves is n-1, since each Sasha move reduces the list by one, from n to 1.

And Anna makes a move before each of Sasha's moves, so she also makes n-1 moves.

Then, after the last Sasha move, the list has one number, and the game ends.

So, total moves: Anna: n-1 times, Sasha: n-1 times.

Now, Anna starts the game, and then they alternate.

Wait, but Anna makes the first move, then Sasha, then Anna, etc., until there's one number left.

Wait, but in reality, since Sasha's move reduces the list size by one each time, and he can't move when there's only one number left, the sequence is:

- Anna reverses one number.

- Sasha picks two numbers, concatenates, and inserts one back.

- Repeat until only one number is left.

So, the number of Sasha's moves is n-1, and Anna has n-1 moves as well.

Given that, perhaps I can think of the game as a sequence of n-1 steps where Anna reverses one number and then Sasha concatenates two.

But this seems too vague.

Let me consider that Anna can choose to reverse any one number each time, and Sasha can choose any two numbers to concatenate.

I need to consider that Anna can strategically reverse numbers to minimize the final number, while Sasha tries to maximize it.

This seems too complex to model directly.

Perhaps I need to find a way to evaluate the list after all possible reverses by Anna and concatenates by Sasha.

Wait, maybe I can consider that Anna can choose to reverse any subset of the numbers, and Sasha concatenates them in a way that maximizes the number.

But I'm not sure.

Let me consider that the final number is determined by the order of concatenation and the reverses applied to individual numbers.

Given that, perhaps I can consider sorting the numbers in a certain way to determine the minimal or maximal possible final number.

Wait, perhaps I can think of the numbers as being sorted in a certain order, and then concatenated in that order, with reverses applied to some of them.

But this seems too vague.

Let me consider that Anna can choose to reverse any number of the numbers, and Sasha concatenates them in an order that maximizes the final number.

Given that, perhaps I can think of Anna choosing to reverse some numbers to minimize the maximal number that Sasha can achieve.

This seems like a minimax problem.

But I need a way to compute this efficiently.

Let me consider that the minimal possible final number is achieved when Anna reverses numbers in a way that minimizes the maximal number Sasha can make.

Wait, perhaps I can consider that Anna reverses numbers to minimize the maximal possible concatenation.

But I need a better approach.

Let me consider that the final number is determined by the sorted order of the numbers after reverses, and then concatenating them in that order.

But I'm not sure.

Wait, perhaps I can consider that Anna reverses numbers to minimize the final number, and Sasha concatenates them in the optimal order to maximize the final number.

Given that, perhaps I can sort the numbers after reverses and concatenation.

Wait, perhaps I can consider that Anna reverses numbers to minimize the lexicographical order of the final concatenated number.

But I'm not sure.

Let me consider that Anna can choose to reverse any number of the numbers, and then Sasha concatenates them in the order that gives the largest possible number.

So, Anna wants to minimize that maximal number.

So, Anna chooses reverses to minimize the maximal number that Sasha can make by ordering the concatenation.

This seems similar to choosing which numbers to reverse to minimize the maximum possible concatenation.

Wait, perhaps I can sort the numbers after reversing some of them, and then concatenate them in a way that minimizes the final number.

But I need to think more carefully.

Let me consider that Anna can choose to reverse any subset of the numbers, and then Sasha concatenates them in the order that maximizes the final number.

So, Anna wants to choose which numbers to reverse to minimize that maximal number.

This seems like a difficult optimization problem.

Perhaps I can think of it in terms of choosing for each number whether to reverse it or not, and then concatenate them in an order that Sasha chooses to maximize the final number.

Anna wants to choose the reverses such that, no matter how Sasha orders the concatenation, the final number is minimized.

Wait, but Sasha gets to choose the order of concatenation after Anna has chosen which numbers to reverse.

This seems too complex to model directly.

Maybe I can think of it in terms of the minimal possible maximum concatenation achievable by choosing which numbers to reverse.

But I need a better strategy.

Let me consider that Anna can choose to reverse any subset of the numbers, and then Sasha concatenates them in the order that gives the largest possible number.

Anna wants to choose which numbers to reverse to minimize that maximal number.

This sounds like a minimax problem, where Anna minimizes over the choice of which numbers to reverse, and Sasha maximizes over the order of concatenation.

This seems too computationally intensive to solve directly, given the constraints.

I need a smarter way to approach this.

Let me consider the properties of the numbers and their reverses.

First, reversing a number can make it larger or smaller, depending on the number.

For example, 123 reversed is 321, which is larger, while 321 reversed is 123, which is smaller.

So, for some numbers, reversing increases their value, for others, it decreases.

Anna can choose to reverse numbers to make them smaller, potentially minimizing the final concatenated number.

But Sasha will try to arrange the order of concatenation to make the final number as large as possible.

Given that, perhaps Anna should reverse numbers that, when reversed, make the numbers as small as possible in terms of their contribution to the final concatenated number.

Wait, perhaps I need to think in terms of comparing numbers in their original and reversed forms and choosing the smaller one for Anna.

Let me consider that Anna can choose, for each number, to reverse it or not, and she chooses the version (original or reversed) that is smaller.

Then, she sorts these chosen numbers in ascending order and concatenates them to get the smallest possible final number.

But I'm not sure if this is correct.

Wait, perhaps Anna should choose, for each number, the smaller one between the original and the reversed, and then arrange them in ascending order to minimize the final concatenated number.

But I need to confirm if this strategy works.

Let me try with the first sample input:

n=2, m=2

Numbers: 14, 2

Anna can choose to reverse one of them.

If she reverses 14 to 41, the list becomes 41 and 2.

Sasha can concatenate them as 241 or 412, both of which are greater than 100.

If she reverses 2 to 2 (no change), the list remains 14 and 2.

Sasha can concatenate them as 142 or 214, both greater than 100.

So, in this case, no matter what Anna does, Sasha can make the final number greater than or equal to 100, so Sasha wins.

Another sample:

n=1, m=1

Number: 6

Anna can reverse it to 6 (no change), and since 6 < 10, Anna wins.

Another sample:

n=1, m=1

Number: 10

Anna can reverse it to 01, which is 1, and since 1 < 10, Anna wins.

Wait, but 10 reversed is 01, which is 1.

So, Anna can choose to reverse it to 1, making the final number 1, which is less than 10, so she wins.

But if she doesn't reverse it, it remains 10, which is >=10, so Sasha wins.

So, Anna can choose to reverse it to win.

Wait, but in this case, Anna has a choice that leads to her winning.

Another sample:

n=4, m=10

Numbers: 1 2007 800 1580

I need to see what Anna can do.

She can choose to reverse one of them each time before Sasha concatenates two.

This seems too involved to simulate step by step.

Perhaps I need to think differently.

Let me consider that Anna can choose to reverse any subset of the numbers, and then Sasha concatenates them in the order that gives the largest possible number.

Anna wants to choose which numbers to reverse to minimize that maximal number.

Wait, but this is still confusing.

Let me consider that the minimal possible final number is achieved when Anna reverses numbers in a way that, when concatenated in Sasha's optimal order, the number is as small as possible.

So, perhaps Anna should choose to reverse numbers so that the largest possible concatenation by Sasha is minimized.

This sounds like choosing which numbers to reverse to minimize the maximum possible concatenation.

This seems similar to choosing for each number the version (original or reversed) that, when sorted and concatenated, results in the smallest possible number.

Wait, perhaps Anna should choose, for each number, the version (original or reversed) that is smaller, and then arrange them in ascending order to minimize the final concatenated number.

Then, compare this minimal possible final number with 10^m to determine the winner.

Let me test this idea with the first sample input:

n=2, m=2

Numbers: 14 and 2

Reversed: 41 and 2

Anna can choose to keep 14 or reverse to 41, and keep 2 or reverse to 2.

So, the possible pairs are:

- (14,2) -> sorted ascending: 142 or 214, both >100

- (14,2) -> sorted ascending: same

- (41,2) -> sorted ascending: 241 or 412, both >100

- (41,2) -> sorted ascending: same

So, in this case, no matter what Anna does, the minimal possible final number is 241, which is still >100, so Sasha wins.

Another sample:

n=1, m=1

Number:6

Reversed:6

Anna can choose to reverse it to 6, which is <10, so Anna wins.

Another sample:

n=1, m=1

Number:10

Reversed:01=1

Anna can choose to reverse it to 1, which is <10, so Anna wins.

Another sample:

n=4, m=10

Numbers:1 2007 800 1580

Reversed:1,7002,008,051 (after removing leading zeros:1,7002,8,51)

If Anna chooses to reverse some numbers:

- 1 reversed is 1

- 2007 reversed is 7002

- 800 reversed is 008=8

- 1580 reversed is 0851=851

So, the numbers after reverses:1,7002,8,851

If Anna chooses to reverse 2007 and 1580, for example, the list becomes:1,7002,8,851

If she sorts them in ascending order:1,8,851,7002 -> concatenated:188517002, which is greater than 10^10=10000000000, so Sasha wins.

But according to the sample output, the answer is "Anna", so maybe this strategy is incorrect.

Wait, perhaps Anna can choose to reverse different numbers to get a smaller final number.

For example, if she doesn't reverse 2007 and reverses 1580:

So, numbers:1,2007,800(reversed to 008=8),1580(reversed to 0851=851)

Sorted ascending:1,8,851,2007 -> concatenated:188512007, which is still greater than 10^10.

Wait, but according to the sample, the answer is "Anna", so perhaps there's a better choice.

Wait, maybe Anna can choose to reverse 2007 to 7002, reverse 800 to 8, and reverse 1580 to 851, and keep 1 as is.

Then, the numbers are:1,7002,8,851

Sorted ascending:1,8,851,7002 -> concatenated:188517002, which is greater than 10^10.

But the sample output is "Anna", meaning the final number is less than 10^10.

So, perhaps there's a better way for Anna to choose which numbers to reverse.

Wait, maybe Anna can choose to reverse only some numbers to get a smaller final number.

For example, reverse 2007 to 7002, reverse 800 to 8, but keep 1580 as is.

So, numbers:1,7002,8,1580

Sorted ascending:1,8,1580,7002 -> concatenated:1815807002, which is less than 10^10=10000000000.

So, in this case, Anna can choose to reverse 800 to 8 and keep others as is, resulting in a final number of 1815807002, which is less than 10^10, so Anna wins.

But according to the sample input, the answer is "Anna", so this seems correct.

So, perhaps Anna can choose which numbers to reverse to minimize the final concatenated number, and if that minimal possible final number is less than 10^m, Anna wins; otherwise, Sasha wins.

So, the strategy is:

- For each number, choose the smaller one between the original and the reversed version.

- Sort these chosen numbers in ascending order.

- Concatenate them to form the minimal possible final number.

- If this number is less than 10^m, Anna wins; else, Sasha wins.

Wait, but in the earlier example, choosing to reverse 800 to 8 and keeping others led to a smaller number.

But what if Anna chooses to reverse 1580 to 851, which is larger than 1580.

Wait, 1580 reversed is 851, which is smaller than 1580.

So, in that case, choosing to reverse 1580 would make it smaller.

But in the earlier step, choosing to reverse 800 to 8 makes it smaller, and keeping 2007 as is or reversing to 7002, which is larger.

So, perhaps Anna should choose to reverse a number only if its reversed form is smaller than its original form.

Wait, but in the earlier case, reversing 2007 to 7002 makes it larger, so Anna might choose not to reverse it.

Wait, but in the sample input, Anna can choose to reverse some numbers to get a smaller final concatenated number.

So, perhaps the strategy is:

- For each number, choose the smaller one between the original and the reversed.

- Sort all these chosen numbers in ascending order.

- Concatenate them to form the minimal possible final number.

- If this number is less than 10^m, Anna wins; else, Sasha wins.

But in the earlier case, choosing to reverse 800 to 8 and keeping 2007 as is, leads to a smaller number.

Wait, but 2007 reversed is 7002, which is larger, so Anna might choose to keep 2007 as is.

Similarly, 1580 reversed is 851, which is smaller, so she might choose to reverse it.

So, the numbers chosen would be:

1 (unchanged), 2007 (unchanged), 8 (reversed from 800), 851 (reversed from 1580)

Sorted ascending:1,8,851,2007 -> concatenated:188512007, which is less than 10^10.

Wait, but earlier I thought of 1815807002, which is different.

Wait, perhaps I made a mistake in sorting.

Let me sort:1,8,851,2007 in ascending order:1,8,851,2007 -> concatenated:188512007.

But 188512007 is less than 10^10=10000000000, which is incorrect because 188512007 is greater than 10000000000.

Wait, no, 188512007 is less than 10000000000.

Wait, 188512007 is less than 10000000000? No, 188512007 is greater than 10000000000.

Wait, 10^10 is 10000000000, and 188512007 is less than that.

Wait, no, 188512007 is 18 million vs. 10 billion, so yes, 188512007 < 10000000000 is false.

Wait, that can't be right.

Wait, 188512007 is 18 million, and 10^10 is 10 billion.

Wait, no, 10^10 is 10 billion, and 188512007 is about 188 million, which is still less than 10 billion.

Wait, no, 10^10 is 10,000,000,000, and 188,512,007 is less than that.

Wait, but according to the sample, the answer is "Anna", meaning the final number is less than 10^10.

But according to the sample output, it's "Anna", so perhaps this strategy is correct.

Wait, but in the earlier step, I thought that Anna can choose to reverse some numbers to get a final number less than 10^10, hence Anna wins.

But according to the sample, the answer is "Anna", so this seems consistent.

So, perhaps the strategy is:

- For each number, choose the smaller one between the original and the reversed.

- Sort these chosen numbers in ascending order.

- Concatenate them to form the minimal possible final number.

- If this number is less than 10^m, Anna wins; else, Sasha wins.

But I need to confirm if this is always correct.

Let me consider another example.

Take n=3, m=5

Numbers:9,56,1

Anna can choose to reverse any one of them.

Let's see:

- Reverse 9 to 9

- Reverse 56 to 65

- Reverse 1 to 1

So, the chosen numbers would be:9,65,1

Sorted ascending:1,9,65 -> concatenated:1965, which is less than 10^5=100000, so Anna wins.

But according to the sample, the answer is "Anna", which is consistent.

Another sample:

n=1, m=1

Number:6

Anna can reverse it to 6, which is less than 10, so Anna wins.

Another sample:

n=1, m=1

Number:10

Anna can reverse it to 1, which is less than 10, so Anna wins.

Seems consistent.

Another sample:

n=4, m=5

Numbers:10,10,10,10

Anna can choose to reverse any one of them to 1, but then the list becomes:1,10,10,10

Then, sorting:1,10,10,10 -> concatenated:1101010, which is less than 10^5=100000, so Anna wins.

But according to the sample, the answer is "Sasha", which contradicts this strategy.

Wait, according to the sample, for n=4, m=5, numbers:10,10,10,10, the answer is "Sasha".

But according to my strategy, Anna can choose to reverse one or more of them to 1, making the concatenated number smaller.

Wait, let's see.

If Anna chooses to reverse one of them to 1, the list becomes:1,10,10,10

Sorted ascending:1,10,10,10 -> concatenated:1101010, which is less than 10^5=100000.

But according to the sample, the answer is "Sasha", meaning the final number is >=10^5.

So, perhaps my strategy is incomplete.

Wait, perhaps I need to consider that Anna chooses to reverse numbers to minimize the final number, but Sasha can arrange the concatenation order to maximize it.

In this case, perhaps Sasha can arrange the concatenation order to make the number larger.

Wait, but in my strategy, Anna chooses the reverses to minimize the maximal concatenation that Sasha can achieve.

So, perhaps in this case, even if Anna chooses to reverse one number to 1, Sasha can arrange the concatenation order to make the number larger.

Wait, but in the earlier example, concatenating 1,10,10,10 as 1101010 is less than 100000.

But according to the sample, Sasha wins, so perhaps there's another way.

Wait, maybe Anna has to choose which numbers to reverse, and Sasha concatenates in an order that maximizes the number.

So, perhaps in this case, no matter how Anna chooses to reverse some numbers, Sasha can arrange the concatenation order to make the final number >=10^5.

Wait, but in my earlier example, Anna chooses to reverse one 10 to 1, resulting in [1,10,10,10], and concatenating in ascending order gives 1101010, which is less than 100000.

But according to the sample, Sasha wins, so perhaps I'm missing something.

Wait, maybe I need to consider that Anna chooses to reverse any subset of the numbers, and Sasha concatenates them in the order that gives the largest possible number.

So, perhaps Anna needs to choose which numbers to reverse to minimize the maximal possible concatenation.

In this case, perhaps the minimal maximal concatenation is still >=10^5, hence Sasha wins.

Wait, but I need to think differently.

Let me consider that Anna chooses to reverse some numbers, and Sasha concatenates them in the order that makes the number as large as possible.

Anna wants to choose which numbers to reverse to minimize that maximal possible concatenation.

So, perhaps Anna should choose to reverse numbers in such a way that, even when Sasha concatenates them in the optimal order, the final number is as small as possible.

Given that, perhaps Anna should choose to reverse numbers so that the largest possible concatenation is minimized.

This sounds like choosing which numbers to reverse to minimize the maximal possible concatenation.

But this is still too vague.

Let me consider that Anna can choose to reverse any subset of the numbers, and then Sasha concatenates them in the order that gives the largest possible number.

Anna wants to choose which numbers to reverse to minimize that maximal number.

So, perhaps Anna should choose to reverse numbers that, when concatenated with others, don't lead to very large numbers.

But I need a better approach.

Let me consider that the final concatenated number is determined by the order of concatenation, which Sasha chooses to maximize the number.

So, to minimize the maximal possible concatenation, Anna should choose the reverses such that, when the numbers are sorted in descending order (since Sasha wants to maximize), the concatenated number is as small as possible.

Wait, perhaps Anna should choose for each number the version (original or reversed) that is smaller, and then Sasha sorts them in descending order to maximize the concatenation.

So, Anna wants to minimize the concatenated number when Sasha sorts them in descending order.

Hence, Anna should choose, for each number, the version (original or reversed) that is smaller, and then Sasha sorts them in descending order and concatenates them.

So, the minimal possible maximal concatenation is achieved by choosing, for each number, the smaller one between original and reversed, and then sorting them in descending order to concatenate.

Wait, but in the earlier example, with n=4, m=5, numbers:10,10,10,10

Anna can choose to reverse one 10 to 1, so the list becomes:1,10,10,10

Sasha sorts them in descending order:10,10,10,1 -> concatenated:1010101, which is greater than 10^5=100000, so Sasha wins.

If Anna reverses two 10's to 1, the list becomes:1,1,10,10

Sasha sorts them in descending order:10,10,1,1 -> concatenated:101011, which is still greater than 100000.

If Anna reverses three 10's to 1, the list becomes:1,1,1,10

Sasha sorts them:10,1,1,1 -> concatenated:10111, which is less than 100000.

So, in this case, Anna can choose to reverse three 10's to 1, resulting in a final number of 10111, which is less than 100000, so Anna wins.

But according to the sample, the answer is "Sasha", meaning the final number is >=10^5.

Wait, but according to my calculation, Anna can make the final number less than 100000 by reversing three 10's to 1.

So, perhaps I'm missing something.

Wait, perhaps I need to consider that Anna can only reverse one number per turn, and Sasha concatenates two numbers per turn.

But in the overall game, Anna has n-1 moves to reverse one number each time.

Wait, but in the game description, Anna reverses one number each turn before Sasha concatenates two.

But in the end, it's equivalent to Anna choosing which numbers to reverse (up to n-1 of them), but in reality, she can reverse all of them if n-1 allows.

Wait, but in each turn, Anna reverses one number, and then Sasha concatenates two and inserts one back, reducing the list by one.

This continues until only one number is left.

Given that, Anna can reverse n-1 numbers if n-1 <= n.

But I need to think differently.

Perhaps I need to consider that Anna can choose to reverse any subset of the numbers, and Sasha concatenates them in an order that maximizes the final number.

Then, Anna wants to choose which numbers to reverse to minimize that maximal number.

Given that, perhaps Anna should choose to reverse numbers that, when reversed, make them smaller, and keep others as is.

Then, Sasha concatenates them in descending order to maximize the final number.

So, Anna should choose for each number the smaller one between original and reversed, and then arrange them in descending order to see the maximal number Sasha can achieve.

If that number is less than 10^m, Anna wins; else, Sasha wins.

Let me test this with the earlier example:

n=4, m=5

Numbers:10,10,10,10

Anna can choose to reverse some of them to 1.

If she reverses three 10's to 1, the list becomes:1,1,1,10

Sasha sorts them in descending order:10,1,1,1 -> concatenated:10111, which is less than 100000, so Anna wins.

But according to the sample, the answer is "Sasha", meaning the final number is >=10^5.

So, perhaps my strategy is incorrect.

Wait, maybe I need to consider that Anna can only reverse one number per turn, and Sasha concatenates two numbers per turn.

Given that, perhaps the sequence of moves affects the final number in a way that Anna can't choose which specific numbers to reverse.

This seems too involved.

Let me consider that Anna can choose to reverse any subset of the numbers, and Sasha concatenates them in the order that gives the largest possible number.

So, Anna wants to choose which numbers to reverse to minimize that maximal possible concatenation.

Given that, perhaps Anna should choose to reverse numbers that, when reversed, make them as small as possible, and keep others as is.

Then, arrange them in descending order to see the maximal concatenation.

So, for each number, choose the smaller one between original and reversed, and then sort them in descending order to concatenate.

If this concatenated number is less than 10^m, Anna wins; else, Sasha wins.

Let me test this with the earlier example:

n=4, m=5

Numbers:10,10,10,10

Choose to reverse three 10's to 1, so the list becomes:1,1,1,10

Sort descending:10,1,1,1 -> concatenated:10111, which is less than 100000, so Anna wins.

But according to the sample, the answer is "Sasha", meaning the final number is >=10^5.

So, perhaps my strategy is incorrect.

Wait, maybe I need to consider that Anna can only reverse n-1 numbers, not all n.

Wait, no, Anna has n-1 moves, but she can choose which number to reverse each time.

But in the end, she can reverse up to n-1 numbers.

In the earlier example with n=4, she can reverse up to 3 numbers.

So, in that case, she can reverse three 10's to 1, leaving one 10, resulting in 1,1,1,10, which concatenates to 10111, which is less than 100000.

But according to the sample, the answer is "Sasha", meaning the final number is >=10^5.

So, perhaps there's a misunderstanding.

Wait, perhaps I need to consider that Anna chooses to reverse numbers to minimize the final number, but Sasha can arrange the concatenation order to maximize it.

So, perhaps in this case, even if Anna reverses three 10's to 1, Sasha can arrange them in a way that the final number is larger.

But in the earlier step, if Anna chooses to reverse three 10's to 1, and the list becomes 1,1,1,10, and Sasha sorts them descending to 10,1,1,1 and concatenates to 10111, which is less than 100000.

But according to the sample, the answer is "Sasha", so perhaps I'm missing something.

Wait, perhaps I need to consider that Anna can only reverse numbers one by one, and Sasha concatenates two at a time, so the sequence of moves matters.

This seems too involved to simulate directly.

Given time constraints, perhaps I need to accept that this strategy isn't working and look for another approach.

Let me consider that the minimal possible final number is achieved when Anna reverses numbers to minimize the maximal concatenation that Sasha can achieve.

So, perhaps Anna should choose, for each number, the smaller one between original and reversed, and then arrange them in ascending order to minimize the final concatenated number.

Then, compare this minimal possible final number with 10^m to determine the winner.

Given that, in the earlier example, Anna can choose to reverse three 10's to 1, resulting in 1,1,1,10, sorted ascending:1,1,1,10 -> concatenated:11110, which is less than 100000, so Anna wins.

But according to the sample, the answer is "Sasha", meaning the final number is >=10^5.

So, perhaps this strategy is incorrect.

Wait, maybe I need to sort the chosen numbers in descending order before concatenating to simulate Sasha's maximizing behavior.

So, Anna chooses which numbers to reverse to minimize the maximal possible concatenation that Sasha can achieve by sorting in descending order.

Hence, for each number, choose the smaller one between original and reversed, and then sort them in descending order to see the maximal possible concatenation.

If this number is less than 10^m, Anna wins; else, Sasha wins.

In the earlier example:

n=4, m=5

Numbers:10,10,10,10

Anna can choose to reverse three 10's to 1, so the list becomes:1,1,1,10

Sort descending:10,1,1,1 -> concatenated:10111, which is less than 100000, so Anna wins.

But according to the sample, the answer is "Sasha", meaning the final number is >=10^5.

Wait, perhaps I need to consider that Anna can only reverse n-1 numbers, not more.

Wait, n=4, so Anna can make n-1=3 reverses.

So, she can reverse up to 3 numbers.

In this case, she can reverse three 10's to 1, leaving one 10, resulting in 1,1,1,10, which concatenates to 10111, which is less than 100000.

But according to the sample, the answer is "Sasha", meaning the final number is >=10^5.

Wait, perhaps I need to consider that Anna must reverse exactly n-1 numbers, not up to n-1.

But in the game, Anna makes n-1 moves, each time reversing one number.

So, in this case, she reverses 3 numbers.

So, she can reverse three 10's to 1, leaving one 10, resulting in 1,1,1,10, which concatenates to 10111, which is less than 100000.

But according to the sample, the answer is "Sasha", meaning the final number is >=10^5.

So, perhaps my strategy is incorrect.

Wait, maybe I need to consider that Anna can choose which specific numbers to reverse in her n-1 moves.

But it's getting too complicated.

Given time constraints, perhaps I need to accept that this strategy isn't working and look for another approach.

Let me consider that Anna can choose to reverse any subset of the numbers, and Sasha concatenates them in the order that gives the largest possible number.

So, Anna wants to choose which numbers to reverse to minimize that maximal possible concatenation.

Given that, perhaps I can sort the numbers after choosing their original or reversed forms to minimize the maximal concatenation.

But I need a better way to compute this.

Let me consider that Anna can choose to reverse any number of the numbers, and then arrange them in a way that minimizes the final concatenated number.

Then, compare this minimal possible final number with 10^m to determine the winner.

Given that, perhaps I can implement this strategy in code.

So, for each test case:

- For each number, choose the smaller one between original and reversed.

- Sort these chosen numbers in ascending order.

- Concatenate them to form the minimal possible final number.

- If this number is less than 10^m, Anna wins; else, Sasha wins.

Given that, perhaps the initial code is implementing this strategy.

Looking back at the provided program:

def func():

for y in range(int(input())):

rev_val = []

rev_res = ''

(list_len, max_power) = input().split()

operational_list = input().split()

for x in operational_list:

x_rev = int(x[::-1])

if len(str(x_rev)) == len(x):

rev_res = rev_res + x

else:

rev_val.append(x[::-1])

rev_val.sort()

for x in range(len(rev_val)):

if x % 2 == 0:

val_in = int(rev_val[x])

rev_res