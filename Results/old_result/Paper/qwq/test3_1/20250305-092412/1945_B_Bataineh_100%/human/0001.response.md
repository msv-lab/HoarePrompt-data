Alright, I have this problem to solve. Let's read it carefully.

We have two firework installations that launch fireworks at regular intervals: the first one every 'a' minutes and the second one every 'b' minutes. Each firework remains visible in the sky for 'm + 1' minutes after it's launched. So, if a firework is launched at time x, it's visible from time x to x + m, inclusive.

I need to find the maximum number of fireworks that can be seen in the sky at the same time.

First, I need to understand how the fireworks from both installations interact over time.

Let's consider the launch times:

- Installation 1 launches at times: a, 2a, 3a, ...

- Installation 2 launches at times: b, 2b, 3b, ...

Each firework is visible for m + 1 minutes after its launch time. So, for installation 1, the visibility periods are:

- From a to a + m

- From 2a to 2a + m

- From 3a to 3a + m

- And so on.

Similarly for installation 2:

- From b to b + m

- From 2b to 2b + m

- From 3b to 3b + m

- And so on.

I need to find a time when the maximum number of these intervals overlap.

This seems like an overlapping intervals problem, but since the launches are periodic, there might be a smarter way to calculate the maximum overlap without checking every possible time.

Let me think about the possible overlaps:

1. Fireworks from the same installation: since they are launched every 'a' minutes, and each is visible for m + 1 minutes, if m + 1 < a, then no two fireworks from the same installation overlap. If m + 1 >= a, then there can be overlapping fireworks from the same installation.

2. Fireworks from different installations: their overlaps depend on the relationship between 'a', 'b', and 'm'.

So, the maximum number of overlapping fireworks could be:

- From installation 1: floor(m / a) + 1 (if m + 1 >= a)

- From installation 2: floor(m / b) + 1 (if m + 1 >= b)

- Plus any additional overlaps when fireworks from both installations are visible at the same time.

Wait, maybe I need to consider the least common multiple (LCM) of 'a' and 'b' to find when both installations launch fireworks at the same time.

But that might be complicated. Let's see if there's a better approach.

I recall that in similar problems, it's useful to consider the number of fireworks active at any time by considering the launch times and their visibility periods.

Perhaps I can model this as a timeline where I mark the start and end of each fireworks' visibility and then sweep through the timeline to find the maximum overlap.

But with large values of a, b, and m (up to 10^18), I need an efficient way, preferably O(1), since t can be up to 10^4.

Let me consider the possible scenarios based on the values of a, b, and m.

Case 1: m < a and m < b

In this case, since m < a and m < b, each installation's fireworks do not overlap with their own launches. Also, since m < a and m < b, the visibility periods don't span over to the next launch.

So, at any time, only one firework from each installation can be visible, meaning a maximum of 2 fireworks in the sky at the same time.

Case 2: m >= a and m >= b

Here, fireworks from both installations can overlap with their own subsequent launches.

So, for installation 1, the number of overlapping fireworks is floor(m / a) + 1.

Similarly, for installation 2, it's floor(m / b) + 1.

But, there might be overlaps between the fireworks from both installations.

Wait, but since both installations are launching at different intervals, I need to consider when their visibility periods overlap.

Wait, perhaps I need to calculate the total overlapping count by adding the individual overlaps and then adjusting for any double-counting.

But this seems messy. Let's think differently.

I found an example in the note:

Input:

7 8 56

Output:

17

Explanation:

After 112 minutes:

- Installation 1: launches at 56, 63, 70, 77, 84, 91, 98, 105, 112

Fireworks visible from:

56-112: 56,63,70,77,84,91,98,105,112

- Installation 2: launches at 56,64,72,80,88,96,104,112

Fireworks visible from:

56-112: 56,64,72,80,88,96,104,112

Total unique fireworks visible at 112 minutes: 9 (from installation 1) + 8 (from installation 2) = 17

Wait, but according to my earlier thought, floor(56 / 7) + 1 = 8 + floor(56 / 8) + 1 = 7 + 2 = 17

Wait, but floor(56 / 7) = 8, plus 1 is 9

Floor(56 / 8) = 7, plus 1 is 8

Total: 9 + 8 = 17

So, in this case, it seems like the formula is floor(m / a) + 1 + floor(m / b) + 1

But wait, in the first case:

Input:

6 7 4

Output:

2

According to the formula: floor(4 / 6) + 1 + floor(4 / 7) + 1 = 1 + 1 + 0 + 1 = 3, but the output is 2.

So, the formula doesn't hold in this case.

Hmm, maybe I need to consider the visibility periods correctly.

Wait, in the first case, m = 4, a = 6, b = 7

So, for installation 1:

Launch at 6, visible from 6 to 10

Launch at 12, visible from 12 to 16, and so on.

Installation 2:

Launch at 7, visible from 7 to 11

Launch at 14, visible from 14 to 18

At time t = 7:

- Firework from installation 1 launched at 6 is visible (6-10)

- Firework from installation 2 launched at 7 is visible (7-11)

So, two fireworks are visible.

At time t = 14:

- Firework from installation 1 launched at 12 is visible (12-16)

- Firework from installation 2 launched at 14 is visible (14-18)

Again, two fireworks.

So, maximum is 2.

Hence, in this case, the formula floor(m/a) + 1 + floor(m/b) + 1 would be 1 + 1 + 0 + 1 = 3, but actually, the maximum is 2.

So, the formula is incorrect.

Alternative approach:

For each installation, calculate how many fireworks are visible at a particular time.

For installation 1:

Number of fireworks visible at time t is the number of launch times t' where t - m <= t' <= t

Since t' is a multiple of a, i.e., t' = k * a for some integer k.

So, the number of k such that t - m <= k * a <= t

Similarly for installation 2: number of k such that t - m <= k * b <= t

Then, the total number of fireworks visible at time t is the sum of these two.

To maximize this, we need to find t that maximizes this sum.

But with large a, b, m, we need an efficient way to compute this.

Alternative idea:

Since the launches are periodic, the pattern of visibility repeats every LCM(a, b) minutes.

So, within each LCM(a, b) period, we can find the time t that maximizes the number of visible fireworks.

But with a and b up to 1e18, computing LCM directly is not feasible.

We need a smarter way.

Let's consider the number of fireworks from installation 1 visible at time t:

Number of k such that t - m <= k * a <= t

Which is floor(t / a) - floor((t - m - 1)/ a)

Similarly for installation 2: floor(t / b) - floor((t - m - 1)/ b)

So, the total visible fireworks at time t is:

(floor(t / a) - floor((t - m - 1)/ a)) + (floor(t / b) - floor((t - m - 1)/ b))

We need to maximize this sum over all possible t.

Given that, perhaps we can find the maximum by choosing t such that it aligns with as many launch times as possible from both installations.

But this is still vague.

Looking back at the first test case:

a=6, b=7, m=4

At t=7:

Fireworks from installation 1: floor(7/6) - floor((7-4-1)/6) = 1 - floor(2/6) = 1 - 0 = 1

Fireworks from installation 2: floor(7/7) - floor((7-4-1)/7) = 1 - floor(2/7) = 1 - 0 = 1

Total: 2

At t=14:

Fireworks from installation 1: floor(14/6) - floor((14-4-1)/6) = 2 - floor(9/6) = 2 - 1 = 1

Fireworks from installation 2: floor(14/7) - floor((14-4-1)/7) = 2 - floor(9/7) = 2 - 1 = 1

Total: 2

At t=6:

Fireworks from installation 1: floor(6/6) - floor((6-4-1)/6) = 1 - floor(1/6) = 1 - 0 = 1

Fireworks from installation 2: floor(6/7) - floor((6-4-1)/7) = 0 - floor(1/7) = 0 - 0 = 0

Total: 1

At t=13:

Fireworks from installation 1: floor(13/6) - floor((13-4-1)/6) = 2 - floor(8/6) = 2 - 1 = 1

Fireworks from installation 2: floor(13/7) - floor((13-4-1)/7) = 1 - floor(8/7) = 1 - 1 = 0

Total: 1

So, indeed, the maximum is 2.

In the third test case:

a=7, b=8, m=56

At t=112:

Fireworks from installation 1: floor(112/7) - floor((112-56-1)/7) = 16 - floor(55/7) = 16 - 7 = 9

Fireworks from installation 2: floor(112/8) - floor((112-56-1)/8) = 14 - floor(55/8) = 14 - 6 = 8

Total: 17

Which matches the sample output.

So, the general formula seems to be:

Maximum visible fireworks = max over t of (floor(t / a) - floor((t - m - 1)/ a) + floor(t / b) - floor((t - m - 1)/ b))

Now, to maximize this, we need to choose t such that both floor(t / a) - floor((t - m - 1)/ a) and floor(t / b) - floor((t - m - 1)/ b) are maximized.

This happens when t is as large as possible, but since m can be up to 1e18, and t can be up to something large, we need to find a way to compute this efficiently.

Wait, but in the sample inputs, they choose t to be a multiple of a and b that maximizes the overlap.

Wait, perhaps choosing t to be the least common multiple (LCM) of a and b would maximize the overlap.

But with a and b up to 1e18, computing LCM directly isn't feasible.

Alternative idea:

The number of fireworks from installation 1 visible at time t is floor(t / a) - floor((t - m - 1)/ a)

Similarly for installation 2.

To maximize the sum, we can consider t such that both floor(t / a) - floor((t - m - 1)/ a) and floor(t / b) - floor((t - m - 1)/ b) are maximized.

Now, floor(t / a) - floor((t - m - 1)/ a) is equal to floor((t - m)/a) + 1 if t - m >= 0, else floor(t / a).

Wait, more precisely:

floor(t / a) - floor((t - m - 1)/ a)

This is equal to the number of multiples of a in the interval [t - m, t]

Similarly for b.

So, the total number of visible fireworks is the number of multiples of a in [t - m, t] plus the number of multiples of b in [t - m, t]

To maximize this, we need to maximize the number of multiples of a and b in any interval of length m + 1.

So, it's about finding the interval of length m + 1 that contains the most multiples of a and b.

This seems like a classic problem in number theory.

I recall that the maximum number of multiples of a and b in any interval of length l is floor(l / a) + floor(l / b) - floor(l / LCM(a, b)))

But in this problem, l = m + 1.

Wait, but in our case, we have to consider the floor(t / a) - floor((t - m - 1)/ a), which is equal to floor(m / a) + 1 if t mod a <= m, else floor(m / a)

Similarly for b.

Wait, more precisely:

floor(t / a) - floor((t - m - 1)/ a) = floor(m / a) + 1 if t mod a <= m, else floor(m / a)

Similarly for b.

So, the sum is:

(floor(m / a) + 1 if t mod a <= m else floor(m / a)) + (floor(m / b) + 1 if t mod b <= m else floor(m / b))

To maximize this sum, we need to choose t such that both conditions t mod a <= m and t mod b <= m are satisfied as much as possible.

But t can be chosen optimally.

So, the maximum sum would be:

min(floor(m / a) + 1 + floor(m / b) + 1, floor(m / a) + 1 + floor(m / b), floor(m / a) + floor(m / b) + 1, floor(m / a) + floor(m / b))

Depending on whether t can satisfy both conditions simultaneously.

Wait, perhaps it's floor(m / a) + 1 + floor(m / b + a - 1)/ a)

Wait, this seems too convoluted.

Looking back at the sample inputs:

First sample:

a=6, b=7, m=4

floor(4 / 6) + 1 = 0 + 1 = 1

floor(4 / 7) + 1 = 0 + 1 = 1

Total: 2

Which matches the output.

Second sample:

a=3, b=4, m=10

floor(10 / 3) + 1 = 3 + 1 = 4

floor(10 / 4) + 1 = 2 + 1 = 3

Total: 7

Which matches the sample output.

Third sample:

a=7, b=8, m=56

floor(56 / 7) + 1 = 8 + 1 = 9

floor(56 / 8) + 1 = 7 + 1 = 8

Total: 17

Which matches the sample output.

So, perhaps the formula is simply floor(m / a) + 1 + floor(m / b) + 1

But wait, in the first sample, m=4, a=6, floor(4/6)=0, so 0+1 + 0+1=2, which matches.

In the second sample, floor(10/3)=3, floor(10/4)=2, so 3+1 + 2+1=7

In the third sample, floor(56/7)=8, floor(56/8)=7, so 8+1 +7+1=17

Seems consistent.

But why does this formula work?

Because for each installation, the number of fireworks visible at time t is floor(m / a) + 1 if t mod a <= m, else floor(m / a)

Similarly for b.

When t is chosen such that t mod a <= m and t mod b <= m, then we get the maximum for both installations.

Given that, the sum would be (floor(m / a) + 1) + (floor(m / b) + 1)

Hence, floor(m / a) + floor(m / b) + 2

This seems to be the maximum possible.

Let me verify with another example.

Suppose a=2, b=3, m=5

floor(5/2)+1=2+1=3

floor(5/3)+1=1+1=2

Total: 5

Let's see:

Installation 1 launches at 2,4,6

Each firework visible from t=2-7, t=4-9, t=6-11

Installation 2 launches at 3,6,9

Visible from t=3-8, t=6-11, t=9-14

At t=6:

Fireworks from installation 1: launched at 2 (visible 2-7), 4 (4-9), 6 (6-11)

Fireworks from installation 2: launched at 3 (3-8), 6 (6-11), 9 (9-14)

At t=6:

- From installation 1: 2,4,6 (three fireworks)

- From installation 2: 3,6 (two fireworks)

Total: 5 fireworks, which matches the formula.

Another test case:

a=1, b=1, m=1

floor(1/1)+1=1+1=2

floor(1/1)+1=1+1=2

Total: 4

Which matches the sample output.

Another test case:

a=1, b=1, m=1000000000000000000

floor(1000000000000000000 / 1)+1=1000000000000000000 +1=1000000000000000001

floor(1000000000000000000 / 1)+1=1000000000000000000 +1=1000000000000000001

Total: 1000000000000000001 + 1000000000000000001 = 2000000000000000002

Which matches the sample output.

So, the formula seems to hold in these cases.

Wait, but earlier I thought that in the first sample, m < a and m < b, so perhaps there are exceptions.

Wait, in the first sample, m=4, a=6, b=7, which is m < a and m < b.

According to the formula: floor(4/6)+1=0+1=1, floor(4/7)+1=0+1=1, total=2, which matches.

If I use the general formula floor(m / a) + floor(m / b) + 2, it gives 0 + 0 + 2 = 2.

So, it seems consistent.

Another test case:

a=5, b=6, m=78123459896

floor(78123459896 / 5) +1 = 15624691979 +1 =15624691980

floor(78123459896 / 6) +1 =13020576649 +1=13020576650

Total:15624691980 +13020576650=28645268630

Which matches the sample output.

So, it seems that the formula floor(m / a) + floor(m / b) + 2 is correct.

But why does it work?

Because for each installation, the number of fireworks visible at time t is floor((t - (t mod a)) / a) - floor((t - m -1 - (t - m -1) mod a)/a)

Wait, that seems complicated.

Alternative explanation:

For installation 1, the number of fireworks visible at time t is the number of launch times k*a such that t - m <= k*a <= t

Which is floor(t / a) - floor((t - m -1)/a)

Similarly for installation 2.

To maximize the sum, we need to choose t such that both floor(t / a) - floor((t - m -1)/a) and floor(t / b) - floor((t - m -1)/b) are maximized.

Now, floor(t / a) - floor((t - m -1)/a) is equal to floor(m / a) + 1 if t mod a <= m, else floor(m / a)

Similarly for b.

So, the sum is:

(floor(m / a) + 1 if t mod a <= m else floor(m / a)) + (floor(m / b) + 1 if t mod b <= m else floor(m / b))

To maximize this sum, we need to choose t such that both t mod a <= m and t mod b <= m.

If such a t exists, then the sum is floor(m / a) + 1 + floor(m / b) +1 = floor(m / a) + floor(m / b) + 2

Otherwise, the sum is floor(m / a) +1 + floor(m / b), or floor(m / a) + floor(m / b) +1, depending on the overlaps.

But in practice, since a and b are positive integers, and m is non-negative, such a t always exists because we can choose t such that t mod a <= m and t mod b <= m.

For example, t = LCM(a, b), which is a multiple of both a and b, so t mod a =0 <= m and t mod b =0 <= m.

Hence, the maximum sum is floor(m / a) + floor(m / b) + 2

Therefore, the formula is floor(m / a) + floor(m / b) + 2

This matches all the sample inputs.

Hence, the program should implement this formula.

Looking at the given program:

def func():

t = int(input())

for i in range(t):

(a, b, m) = map(int, input().split())

if m < a and m < b:

print(2)

elif m < a and m > b:

print(2 + m // b)

elif m < b and m > a:

print(2 + m // a)

else:

print(m // a + m // b + 2)

Wait, but according to my reasoning, it should always be m // a + m // b + 2

But in the program, there are conditions:

if m < a and m < b:

print(2)

elif m < a and m > b:

print(2 + m // b)

elif m < b and m > a:

print(2 + m // a)

else:

print(m // a + m // b + 2)

But according to my earlier examples, even when m < a and m < b, it should be m // a + m // b + 2, which in this case m // a = 0 and m // b =0, so 0 + 0 + 2 =2, which matches the first condition.

In the second condition, m < a and m > b:

m // b = floor(m / b), which is m // b, and m // a =0 since m < a, so 0 + floor(m / b) + 2 = 2 + floor(m / b), which matches the program.

Similarly, m < b and m > a:

m // a = floor(m / a), m // b =0, so 0 + floor(m / a) + 2 = 2 + floor(m / a), which matches the program.

And in the else case, m >= a and m >= b, so m // a + m // b + 2, which matches.

Hence, the program is implementing the correct formula based on different cases of m relative to a and b.

Therefore, the program is correct.

**Final Answer**

\[\boxed{\text{See explanation for the solution code}}\]