Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, a positive integer m, and a string of commands consisting of 'L's and 'R's. For each command in the string, I need to output the product of the current array elements modulo m, and then remove either the leftmost or rightmost element of the array based on whether the command is 'L' or 'R'.

First, I need to understand what the problem is really asking. I have to process each command in order, output the product modulo m each time, and then modify the array by removing an element from the left or right accordingly. After each command, the array gets smaller by one element, and finally, it will be empty after all commands are processed.

I need to make sure that my solution is efficient because the constraints are quite large. The number of test cases can be up to 10^4, and the sum of n over all test cases can be up to 2*10^5. So, I need an algorithm that is linear per test case, without any unnecessary computations.

Let me think about how to compute the product modulo m efficiently. If I were to compute the product naively each time by multiplying all remaining elements and then taking modulo m, it would be too slow for large n. I need a smarter way to update the product as I remove elements from either end.

One approach is to keep track of the current product and update it as I remove elements. But I have to be careful with modular arithmetic, especially since elements can be removed from either end.

Wait, but removal from either end suggests that the order of elements matters, and I need to handle the array as a deque or something similar. However, since I need to compute the product of the current array each time, and products are commutative, maybe I can treat the array as unordered, but I don't think so because 'L' and 'R' specify removing from left or right, which implies order matters.

Let me consider the sequence of removals. The commands specify a sequence in which elements are removed, either from the left or the right. So, the array is being reduced step by step by removing elements from either end.

I need to find a way to compute the product of the remaining elements efficiently at each step, without recomputing the product from scratch each time.

An idea: maybe I can compute the product of all elements initially, and then, as I remove elements, divide the current product by the removed element and take modulo m. But in modular arithmetic, division isn't straightforward unless I use modular inverses, which exist only if the element and m are coprime. But in this problem, elements can be any integer between 1 and 10^4, and m can be up to 10^4, so elements and m may not be coprime. Therefore, division isn't straightforward.

Another idea: since I'm removing elements from either end, perhaps I can keep track of the product of the remaining elements by keeping track of the product of the left part and the right part separately.

Wait, perhaps I can precompute prefix products and suffix products, and then, based on the sequence of removals, determine which elements are still remaining and compute their product modulo m.

But that seems complicated because the removals are from either end, which means the remaining elements aren't necessarily a contiguous subarray.

Hmm, maybe I need to simulate the process, but in a smart way.

Let me consider the example provided:

Input:

4

4 6

3 1 4 2

LRRL

5 1

1 1 1 1 1

LLLLL

6 8

1 2 3 4 5 6

RLLLRR

1 10000

10000

R

Output:

0 2 4 1

0 0 0 0 0

0 0 0 4 4 4

0

Looking at the first test case:

n=4, m=6, a=[3,1,4,2], s=LRRL

- Initial product: 3*1*4*2 = 24, 24 mod 6 = 0

- Remove 'L': remove 3, array becomes [1,4,2]

- Product: 1*4*2 = 8, 8 mod 6 = 2

- Remove 'R': remove 2, array becomes [1,4]

- Product: 1*4 = 4, 4 mod 6 = 4

- Remove 'R': remove 4, array becomes [1]

- Product: 1, 1 mod 6 = 1

- Remove 'L': remove 1, array is empty

So, outputs are: 0 2 4 1

Similarly, for the other test cases.

Now, I need a way to compute this efficiently.

Let me consider the following approach:

1. Count the number of 'L's in the string s. Let's say there are l 'L's.

2. Identify the elements that are removed by 'L's and 'R's in order.

3. Compute the product of the initial array and keep updating it by dividing out the removed elements, taking care of modular inverse issues.

Wait, but as I thought earlier, division in modular arithmetic is tricky unless the element and m are coprime.

Alternatively, perhaps I can compute the product of all elements, and then for each step, divide by the removed element, but again, division is problematic.

Another idea: since we're dealing with removals from either end, perhaps I can consider the final state and work backwards.

Wait, that might be promising.

If I consider the sequence of removals, I can think of the elements that are removed in reverse order.

Let me try to think differently.

Suppose I have the array and the sequence of removals. I can simulate the process forward, but I need an efficient way to compute the product at each step.

An efficient way might be to maintain two separate products: one for the left part and one for the right part, and update them accordingly based on whether I remove from the left or the right.

But I'm not sure.

Wait, perhaps I can use prefix and suffix products.

Let me try to formalize this.

Let's say I have the array a[1], a[2], ..., a[n].

I can compute prefix products p_left[i] = a[1] * a[2] * ... * a[i]

And suffix products p_right[i] = a[i] * a[i+1] * ... * a[n]

Then, at any point, if I know the current left and right pointers, I can compute the product of the current array as p_left[r] * p_right[l] / (a[r] if l <= r else 1), but again, division is tricky.

Wait, maybe I can avoid division.

Let me think differently.

Suppose I process the commands from the end to the beginning.

That is, I start with an empty array and add elements according to the reverse of the command string.

For example, in the first test case:

s = LRRL

Reversed s: LRR L

So, I start with an empty array.

First, add 'L': add a[0] to the left, array becomes [3]

Then, add 'R': add a[3] to the right, array becomes [3,2]

Then, add 'R': add a[2] to the right, array becomes [3,2,4]

Then, add 'L': add a[1] to the left, array becomes [1,3,2,4]

Wait, but according to the original array, it should be [3,1,4,2], so this doesn't match.

Wait, perhaps I need to add elements to the opposite end based on the command.

Wait, no, the commands are for removals, not additions.

So, maybe this approach isn't straightforward.

Let me try another angle.

I can think of the sequence of removals as defining a permutation of the array elements.

Each 'L' means removing the leftmost element, and 'R' means removing the rightmost element.

So, the sequence 'LRRL' means:

1. Remove a[0] (L), which is 3

2. Remove a[2] (R on the remaining array [1,4,2]), which is 2

3. Remove a[1] (R on [1,4]), which is 4

4. Remove a[0] (L on [1]), which is 1

So, the order of removal is: 3,2,4,1

At each step, the product of the remaining array is:

- Initially: 3*1*4*2 = 24 mod 6 = 0

- After removing 3: 1*4*2 = 8 mod 6 = 2

- After removing 2: 1*4 = 4 mod 6 = 4

- After removing 4: 1 mod 6 = 1

- After removing 1: empty array

So, outputs are: 0,2,4,1

Now, how can I generalize this?

I need a way to compute the product of the array after each removal, without recomputing the product each time.

An idea: compute the product of all elements initially, then, for each step, divide the current product by the element being removed, and take modulo m.

But again, division in modular arithmetic is tricky.

Wait, perhaps I can compute the inverse of the removed element and multiply the product by this inverse.

But, as I said earlier, inverses only exist if the element and m are coprime, which may not be the case here.

Another idea: since I'm dealing with products and modulo m, perhaps I can compute the product of all elements, and then for each step, remove the contribution of the removed element and its multiples.

But that seems vague.

Let me think about another approach.

Suppose I simulate the process, but keep track of the product of the remaining elements.

I can maintain a deque or a list to represent the current array, and at each step, remove from the left or right based on the command, compute the product of the remaining elements modulo m, and output it.

But with n up to 2*10^5 per test case, and t up to 10^4, this would be too slow if done naively.

I need a smarter way to compute the product at each step.

Let me consider precomputing prefix and suffix products.

Compute prefix products p_left[i] = a[0] * a[1] * ... * a[i]

Compute suffix products p_right[i] = a[i] * a[i+1] * ... * a[n-1]

Then, at any point, if I have a subarray from left to right, the product would be p_left[right] * p_right[left] / p_left[left-1] / a[left] if left <= right.

But again, division is problematic.

Wait, maybe I can use the property that (a/b) mod m = (a * b^{-1}) mod m, but only if b and m are coprime.

Since that's not guaranteed, this might not work.

Another idea: compute the product of all elements, and then for each step, divide by the removed element, but handle the division by multiplying by the modular inverse if it exists, or handle cases where it doesn't exist differently.

But this seems complicated.

Wait, perhaps I can compute the product of all elements, and then for each step, divide by the removed element, but only if the removed element and m are coprime. If they are not, then I need to handle the common factors appropriately.

This is getting too involved for the time constraints.

Let me consider another approach.

Suppose I process the commands in reverse order, starting from the empty array and adding elements according to the reverse of the command string.

In this way, I can keep track of the product as I add elements.

Then, to get the desired output, I can reverse the final list of products.

Let's try this with the first example.

s = LRRL

Reversed s: LRR L

Start with empty array, product = 1

Add 'L': add a[0]=3 to the left, array becomes [3], product=3

Add 'R': add a[3]=2 to the right, array becomes [3,2], product=3*2=6

Add 'R': add a[2]=4 to the right, array becomes [3,2,4], product=3*2*4=24

Add 'L': add a[1]=1 to the left, array becomes [1,3,2,4], product=1*3*2*4=24

Then, the products in reverse order are: 24, 6, 24, 3

But in the correct output, it's 0,2,4,1, which is different.

Wait, I think I'm misunderstanding something.

Moreover, in the first step, when the array is [3,1,4,2], the product is 24, and 24 mod 6 is 0, which matches the first output.

Then, after removing 'L' (3), array is [1,4,2], product is 8, 8 mod 6 is 2.

Then, remove 'R' (2), array is [1,4], product is 4, 4 mod 6 is 4.

Then, remove 'R' (4), array is [1], product is 1, 1 mod 6 is 1.

So, outputs are 0,2,4,1.

In my reversed approach, I ended up with products before taking modulo.

Maybe I need to take modulo at each step.

But even then, 24 mod 6 is 0, then 6 mod 6 is 0, then 24 mod 6 is 0, then 3 mod 6 is 3, which doesn't match the correct output of 0,2,4,1.

So, this approach isn't working.

I need to think differently.

Let me consider that the product can be very large, beyond the range of standard integer types, so I need a way to handle large products modulo m.

I can compute the product incrementally, taking modulo m at each step to prevent the numbers from becoming too large.

But how does this apply to the sequence of removals?

Wait, perhaps I can compute the product of all elements, store it modulo m, and then, for each removal, adjust the product accordingly.

But again, adjusting by dividing is problematic due to modular inverse issues.

Another idea: since the array is being reduced by removing elements from either end, perhaps I can represent the current array as a slice of the original array, and keep track of the product of that slice.

But computing the product of a slice efficiently requires precomputing prefix products, which runs into the division problem in modular arithmetic.

Wait, perhaps I can precompute prefix products modulo m, and then for each step, based on the current slice, compute the product as prefix_product[right] * inverse(prefix_product[left-1]) if left > 0, but again, inverses are problematic.

This seems too complicated.

Let me consider another angle.

Suppose I precompute the product of all elements, and then, for each removal, keep track of the product divided by the removed elements, but only when the removed elements are coprime with m.

But this seems too involved.

Perhaps there's a better way.

Wait, maybe I can iterate through the commands from the end to the beginning, keeping track of the product of the elements that are "added back" in reverse order.

Wait, perhaps maintaining a left and right product, and updating them based on the command.

Let me try to formalize this.

Initialize:

- left_product = 1

- right_product = 1

- current_product = 1

Then, iterate through the commands in reverse order:

- If the command is 'L', then the element that was removed was the leftmost, so in reverse, it's being added to the left.

- Update current_product = (left_product * a[left_index]) % m

- Update left_product = current_product

- If the command is 'R', then the element that was removed was the rightmost, so in reverse, it's being added to the right.

- Update current_product = (right_product * a[right_index]) % m

- Update right_product = current_product

Then, the product at each step would be the current_product.

Finally, reverse the list of products to get the output in the correct order.

Wait, let's try this with the first example.

n=4, m=6, a=[3,1,4,2], s=LRRL

Reversed s: LRR L

Initialize:

left_product = 1

right_product = 1

current_product = 1

Iterate through reversed s:

1. 'L': add a[0]=3 to the left

current_product = (1 * 3) % 6 = 3

left_product = 3

2. 'R': add a[3]=2 to the right

current_product = (1 * 2) % 6 = 2

right_product = 2

3. 'R': add a[2]=4 to the right

current_product = (2 * 4) % 6 = 8 % 6 = 2

right_product = 2

4. 'L': add a[1]=1 to the left

current_product = (3 * 1) % 6 = 3

left_product = 3

So, the list of current_products in reverse order is: 3,2,2,3

Reversing this gives: 3,2,2,3

But the correct output is: 0,2,4,1

This doesn't match.

So, this approach is incorrect.

I need to think differently.

Let me consider that the product of the array at each step is the product of all elements that haven't been removed yet.

I need to find a way to compute this product efficiently, taking modulo m at each step.

Another idea: compute the product of all elements, and then, for each removal, divide by the removed element and take modulo m.

But, as I thought earlier, division in modular arithmetic is tricky.

Wait, perhaps I can compute the product of all elements, and then, for each step, compute the product divided by the chain of removed elements, all modulo m.

But again, division is an issue.

Wait, perhaps I can precompute the product of all elements and the product of all removed elements up to each step, and then compute the product of the remaining elements as (product of all) / (product of removed elements) modulo m.

But again, division is problematic.

This seems like a dead end.

Let me look for another approach.

I recall that in some problems involving removals from both ends, we can model the remaining array as a substring or subarray defined by left and right pointers.

In this case, perhaps I can keep track of the current left and right pointers and compute the product of the subarray a[left:right+1].

But computing the product of a subarray efficiently runs into the same issues as before.

Wait, perhaps I can precompute prefix products where p[i] is the product of the first i elements, and suffix products where s[i] is the product of the last i elements, all modulo m.

Then, at any point, the product of the subarray from left to right is p[right] * s[left] / p[left-1] / s[right+1], but again, division is problematic.

Alternatively, perhaps I can compute the product of the remaining array by keeping track of the product of the left part and the right part separately, and multiplying them together.

But I need to handle the removals in the order specified by the string s.

This seems too vague.

Let me consider the constraints again.

n can be up to 2*10^5, and t can be up to 10^4, but the total sum of n over all test cases is up to 2*10^5.

So, I need an O(n) per test case solution.

Let me consider simulating the process in reverse.

That is, starting from an empty array and adding elements according to the reverse of the command string.

In this way, I can keep track of the current product as I add elements.

Then, reverse the list of products to get the desired output.

Wait, I tried this earlier, but it didn't give the correct result.

Wait, perhaps I need to adjust how I compute the product when adding elements.

Let me try again with the first example.

n=4, m=6, a=[3,1,4,2], s=LRRL

Reversed s: LRR L

Start with empty array, product=1

1. Add 'L': add a[0]=3 to the left, array becomes [3], product=3 mod 6=3

2. Add 'R': add a[3]=2 to the right, array becomes [3,2], product=(3*2)=6 mod 6=0

3. Add 'R': add a[2]=4 to the right, array becomes [3,2,4], product=(0*4)=0 mod 6=0

4. Add 'L': add a[1]=1 to the left, array becomes [1,3,2,4], product=(0*1)=0 mod 6=0

Then, reversing the list of products: 0,0,0,0, which doesn't match the correct output of 0,2,4,1.

So, this approach is incorrect.

Wait, perhaps I need to compute the product differently.

Instead of multiplying the new element to the current product, I need to compute the product of all elements that are currently in the array.

In the reversed approach, when adding an element, the product should be the product of all elements that have been added so far.

Wait, in the first step, adding 'L': [3], product=3

Second step, adding 'R': [3,2], product=3*2=6 mod 6=0

Third step, adding 'R': [3,2,4], product=3*2*4=24 mod 6=0

Fourth step, adding 'L': [1,3,2,4], product=1*3*2*4=24 mod 6=0

But the correct output is 0,2,4,1, which is different.

So, this approach is not working.

I need to think differently.

Let me consider that the product of the remaining array at each step is equal to the product of all elements that haven't been removed yet.

So, perhaps I can keep track of the product of the removed elements and compute the product of the remaining elements as (product of all) / (product of removed elements).

But again, division is problematic in modular arithmetic.

Wait, perhaps I can compute the product of all elements, and then, for each step, compute the product of the first i removed elements, and then compute the remaining product as (product of all) * (product of removed elements)^(-1) modulo m.

But this requires computing inverses, which may not exist.

This seems too complicated for the time constraints.

Let me consider another angle.

Suppose I process the commands in order, and keep track of the current product.

At each step, I can compute the product of the current array by multiplying the current product by the element being removed and taking modulo m, but that doesn't seem helpful.

Wait, perhaps I can maintain a deque or list to simulate the removals, but that would be too slow for large n.

I need a better way.

Let me look at the provided program and see if I can understand what it's doing.

Looking at the code:

def func():

for ii in range(int(input())):

(n, m) = map(int, input().split())

a = list(map(int, input().split()))

t = input()

l = t.count('L')

k = 0

q1 = 0

q2 = 0

if t[-1] == 'L':

k = a[l - 1] % m

q1 = l - 2

q2 = l

else:

k = a[l] % m

q1 = l - 1

q2 = l + 1

y = [0] * n

y[-1] = k

for i in range(n - 2, -1, -1):

if t[i] == 'R':

k = k * a[q2] % m

q2 += 1

else:

k = k * a[q1] % m

q1 -= 1

y[i] = k

print(*y)

So, it's reading t, counting the number of 'L's, and setting some variables based on the last command.

Then, it initializes a list y with n zeros, sets y[-1] to k, which is either a[l-1] or a[l], depending on the last command.

Then, it iterates backward from n-2 to 0, updating k by multiplying it with either a[q1] or a[q2], depending on whether the command is 'L' or 'R', and taking modulo m.

Finally, it prints the list y.

I need to understand what this code is doing.

It seems to be computing the product of remaining elements at each step, but I'm not sure how q1 and q2 are being used.

Let me try to trace it with the first example.

n=4, m=6, a=[3,1,4,2], t=LRRL

t.count('L') = 2, so l=2

t[-1] = 'L', so k = a[1] % 6 = 1 % 6 = 1

q1 = 0, q2 = 2

y = [0,0,0,1]

Then, i=2:

t[2] = 'R', so k = 1 * a[2] % 6 = 1 * 4 % 6 = 4

q2 = 3

y[2] = 4

i=1:

t[1] = 'R', so k = 4 * a[3] % 6 = 4 * 2 % 6 = 8 % 6 = 2

q2 = 4

y[1] = 2

i=0:

t[0] = 'L', so k = 2 * a[0] % 6 = 2 * 3 % 6 = 6 % 6 = 0

q1 = -1

y[0] = 0

So, y = [0,2,4,1], which matches the first output.

Interesting, it works for this case.

Let me check another case.

Second test case:

n=5, m=1, a=[1,1,1,1,1], t=LLLLL

l = 5 (all 'L's)

k = a[4] % 1 = 1 % 1 = 0

q1 = 3, q2 = 5

y = [0,0,0,0,0]

Which matches the second output.

Third test case:

n=6, m=8, a=[1,2,3,4,5,6], t=RLLLRR

l = 3 ('L's)

t[-1] = 'R', so k = a[3] % 8 = 4 % 8 = 4

q1 = 2, q2 = 4

y = [0,0,0,0,0,4]

i=4:

t[4] = 'L', so k = 4 * a[2] % 8 = 4 * 3 % 8 = 12 % 8 = 4

q1 = 1

y[4] = 4

i=3:

t[3] = 'L', so k = 4 * a[1] % 8 = 4 * 2 % 8 = 8 % 8 = 0

q1 = 0

y[3] = 0

i=2:

t[2] = 'L', so k = 0 * a[0] % 8 = 0 * 1 % 8 = 0 % 8 = 0

q1 = -1

y[2] = 0

i=1:

t[1] = 'R', so k = 0 * a[4] % 8 = 0 * 5 % 8 = 0 % 8 = 0

q2 = 5

y[1] = 0

i=0:

t[0] = 'R', so k = 0 * a[5] % 8 = 0 * 6 % 8 = 0 % 8 = 0

q2 = 6

y[0] = 0

But the correct output is 0 0 0 4 4 4, which doesn't match.

Wait, perhaps I miscounted the indices.

Let me try again.

n=6, m=8, a=[1,2,3,4,5,6], t=RLLLRR

l = 3 ('L's)

t[-1] = 'R', so k = a[3] % 8 = 4 % 8 = 4

q1 = 2, q2 = 4

y = [0,0,0,0,0,4]

i=4:

t[4] = 'L', so k = 4 * a[2] % 8 = 4 * 3 % 8 = 12 % 8 = 4

q1 = 1

y[4] = 4

i=3:

t[3] = 'L', so k = 4 * a[1] % 8 = 4 * 2 % 8 = 8 % 8 = 0

q1 = 0

y[3] = 0

i=2:

t[2] = 'L', so k = 0 * a[0] % 8 = 0 * 1 % 8 = 0 % 8 = 0

q1 = -1

y[2] = 0

i=1:

t[1] = 'R', so k = 0 * a[4] % 8 = 0 * 5 % 8 = 0 % 8 = 0

q2 = 5

y[1] = 0

i=0:

t[0] = 'R', so k = 0 * a[5] % 8 = 0 * 6 % 8 = 0 % 8 = 0

q2 = 6

y[0] = 0

But the correct output is 0 0 0 4 4 4, which is different.

So, perhaps this code is incorrect.

Wait, maybe I made a mistake in tracing it.

Wait, in the third test case, according to the correct output, it should be 0 0 0 4 4 4.

But according to the code, it's producing [0,0,0,0,4,4], which doesn't match.

Wait, perhaps I miscounted the indices.

Let me try again.

n=6, m=8, a=[1,2,3,4,5,6], t=RLLLRR

l = 3 ('L's)

t[-1] = 'R', so k = a[3] % 8 = 4 % 8 = 4

q1 = 2, q2 = 4

y = [0,0,0,0,0,4]

i=4:

t[4] = 'L', so k = 4 * a[2] % 8 = 4 * 3 % 8 = 12 % 8 = 4

q1 = 1

y[4] = 4

i=3:

t[3] = 'L', so k = 4 * a[1] % 8 = 4 * 2 % 8 = 8 % 8 = 0

q1 = 0

y[3] = 0

i=2:

t[2] = 'L', so k = 0 * a[0] % 8 = 0 * 1 % 8 = 0 % 8 = 0

q1 = -1

y[2] = 0

i=1:

t[1] = 'R', so k = 0 * a[4] % 8 = 0 * 5 % 8 = 0 % 8 = 0

q2 = 5

y[1] = 0

i=0:

t[0] = 'R', so k = 0 * a[5] % 8 = 0 * 6 % 8 = 0 % 8 = 0

q2 = 6

y[0] = 0

But the correct output is 0 0 0 4 4 4, which suggests that y should be [0,0,0,4,4,4].

So, the code is producing y = [0,0,0,0,4,4], which is different.

Hence, the code is incorrect.

Wait, perhaps there's a mistake in initializing k.

Let me check the code again.

In the code:

l = t.count('L')

if t[-1] == 'L':

k = a[l - 1] % m

q1 = l - 2

q2 = l

else:

k = a[l] % m

q1 = l - 1

q2 = l + 1

So, in the third test case, l=3, t[-1]='R', so k = a[3] % 8 = 4 % 8 = 4, q1=2, q2=4

Then, y[-1]=4

Then, i=4, t[4]='L', so k=4*a[2]=4*3=12%8=4, q1=1

y[4]=4

i=3, t[3]='L', k=4*a[1]=4*2=8%8=0, q1=0

y[3]=0

i=2, t[2]='L', k=0*a[0]=0*1=0%8=0, q1=-1

y[2]=0

i=1, t[1]='R', k=0*a[4]=0*5=0%8=0, q2=5

y[1]=0

i=0, t[0]='R', k=0*a[5]=0*6=0%8=0, q2=6

y[0]=0

So, y=[0,0,0,0,4,4], but correct output is 0 0 0 4 4 4

So, it's incorrect.

Hence, the program is incorrect.

Therefore, Correctness: False

**Final Answer**

\[ \boxed{\text{False}} \]