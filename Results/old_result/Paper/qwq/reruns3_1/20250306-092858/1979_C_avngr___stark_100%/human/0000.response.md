Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n possible outcomes in a game, and for each outcome, there's a multiplier k_i. I need to bet some integer amount of coins on each outcome such that, no matter which outcome wins, the money I get back is more than the total amount I bet.

First, I need to understand the constraints. For each test case, I have n outcomes, each with its own k_i, which is at least 2. I need to assign bets x_i to each outcome such that the sum of all x_i is less than k_i * x_i for every i.

In other words, for every outcome i, the condition sum(x) < k_i * x_i must hold.

This seems like a system of inequalities that I need to satisfy simultaneously.

Let me think about what this means. For each i, sum(x) < k_i * x_i.

I can rearrange this inequality:

sum(x) < k_i * x_i

which is equivalent to sum(x) - k_i * x_i < 0.

But sum(x) is the sum of all x_j from j=1 to n.

So, sum(x_j for j=1 to n) - k_i * x_i < 0.

I can rewrite this as sum(x_j for j ≠ i) + x_i - k_i * x_i < 0.

Which simplifies to sum(x_j for j ≠ i) < (k_i - 1) * x_i.

This needs to hold for all i.

This seems a bit tricky. Maybe there's another way to approach this.

I recall that in similar problems, finding a common multiple or using the least common multiple (LCM) helps. But I'm not sure how it applies here.

Let me look at the example provided.

In the first test case:

n=3

k=[3,2,7]

And the solution is x=[27,41,12]

Let's check if this satisfies the conditions.

Total sum: 27 + 41 + 12 = 80

For outcome 1: 3*27 = 81 > 80

For outcome 2: 2*41 = 82 > 80

For outcome 3: 7*12 = 84 > 80

Perfect, it works.

Another test case:

n=2

k=[3,3]

x=[1,1]

Sum: 1 + 1 = 2

For outcome 1: 3*1 = 3 > 2

For outcome 2: 3*1 = 3 > 2

Good.

But in the third test case:

n=5

k=[5,5,5,5,5]

And the output is -1, meaning no solution exists.

Wait, why is that? If all k_i are equal to 5, shouldn't I be able to find some x_i?

Let me try.

Suppose x=[x,x,x,x,x]

Sum: 5x

Condition for each outcome: 5x < 5*x, which is 5x < 5x, which is not possible.

Wait, that's 5x < 5x, which is never true. So indeed, no solution exists in this case.

So, when all k_i are equal, it's impossible to satisfy the condition because sum(x) cannot be less than k_i * x_i for all i.

Got it.

So, the condition sum(x) < min over i of (k_i * x_i)

But since x_i are positive integers, sum(x) < min_k (k_i * x_i)

But sum(x) includes x_i, so it's a bit tricky.

I need to find x_i such that for all i, sum(x) < k_i * x_i.

Let me try to express x_i in terms of sum(x).

Let s = sum(x)

Then, s < k_i * x_i for all i.

So, x_i > s / k_i for all i.

But x_i are integers, so x_i >= ceil(s / k_i)

But also, s = sum(x_i)

So, s >= sum(ceil(s / k_i) for all i)

This seems like a non-linear inequality in terms of s.

This is getting complicated.

Maybe there's a better way.

I noticed in the code provided, it defines two functions: func_1 and func_2.

Func_1 seems to compute the least common multiple (LCM) of two numbers, since it's abs(a*b) // gcd(a,b).

And func_2 computes the LCM of the list of k_i's.

Then, it sets m to be the LCM of all k_i's.

Then, it sets c_i = m // k_i for each i.

Then, it checks if sum(c) >= m.

If it is, it prints -1; else, it prints c.

Let me see what's happening here.

First, it computes the LCM of all k_i's, which is m.

Then, it sets x_i = m / k_i.

Wait, but in the first test case:

k=[3,2,7]

LCM of 3,2,7 is 42.

Then, c_i = 42 / 3 = 14, 42 / 2 = 21, 42 / 7 = 6.

Sum(c) = 14 + 21 + 6 = 41, which is less than m=42.

But in the example, it's using 27,41,12, which sums to 80.

Hmm, why is it not using 14,21,6?

Because 14,21,6 sums to 41, which is less than 42, but in the example, it's using 27,41,12, which sums to 80.

Wait, maybe I need to scale up the bets.

If I multiply all x_i by the same factor, the conditions should still hold.

Wait, but in the first test case, 14,21,6 sums to 41 < 42, which satisfies the condition.

So why is the example using 27,41,12 summing to 80?

Maybe there are multiple solutions.

But according to the problem, if there's a solution, there's always a solution with x_i <= 10^9.

In this case, 14,21,6 works and sums to 41 < 42.

So, it's acceptable.

But the example used different numbers.

Maybe there are multiple solutions, and any valid one is acceptable.

Alright, back to the approach in the code.

It computes m as LCM of all k_i's.

Then sets x_i = m // k_i.

Then checks if sum(x_i) >= m.

If it is, outputs -1; else, outputs x_i.

Wait, in the first test case, sum(x_i)=41 < m=42, so it should output 14,21,6.

But the example outputs 27,41,12 summing to 80.

Why is that?

Maybe the code is not following this approach exactly.

Wait, perhaps the code is scaling up the x_i to satisfy the condition.

But in the first test case, 14,21,6 works.

Let me check:

For outcome 1: k=3, x=14, 3*14=42 > 41

For outcome 2: k=2, x=21, 2*21=42 > 41

For outcome 3: k=7, x=6, 7*6=42 > 41

Wait, 42 > 41 is true for all.

So, it works.

But in the third test case:

n=5

k=[5,5,5,5,5]

LCM of all k_i is 5.

Then, c_i = 5 // 5 =1 for all i.

Sum(c)=5 >= m=5, so it outputs -1, which matches the example.

Good.

Another test case:

n=6

k=[7,9,3,17,9,13]

LCM of 7,9,3,17,9,13.

First, LCM of 7 and 9 is 63.

Then, LCM of 63 and 3 is 63.

Then, LCM of 63 and 17 is 63*17=1071.

Then, LCM of 1071 and 9 is still 1071.

Then, LCM of 1071 and 13 is 1071*13=13923.

Wait, but in the example, it outputs 1989,1547,4641,819,1547,1071.

Sum is 1989+1547+4641+819+1547+1071 = let's calculate:

1989 + 1547 = 3536

3536 + 4641 = 8177

8177 + 819 = 9096

9096 + 1547 = 10643

10643 + 1071 = 11714

And m = LCM of [7,9,3,17,9,13].

Wait, 7 and 9: LCM=63

63 and 3: 63

63 and 17: 1071

1071 and 9: 1071

1071 and 13: 13923

But in the solution, it's using 1989,1547,4641,819,1547,1071.

Let's check if these are multiples of m//k_i.

m=13923

x1 = m//7 = 13923//7=1989

x2 = m//9=13923//9=1547

x3 = m//3=13923//3=4641

x4 = m//17=13923//17=819

x5 = m//9=13923//9=1547

x6 = m//13=13923//13=1071

Yes, that matches the output.

Now, sum(x)=11714 < m=13923? Wait, 11714 < 13923 is true.

So, it works.

But according to the code, it sets c_i = m // k_i.

Then checks if sum(c) >= m.

If sum(c) >= m, output -1; else, output c.

In this case, sum(c)=11714 < m=13923, so it outputs c.

Wait, but in the first test case, sum(c)=41 < m=42, which is fine.

But in the example, they used different numbers.

Maybe the code is not exactly as in the example.

Wait, perhaps the code is scaling up the x_i to make sum(x) < k_i * x_i for all i.

But in the first test case, sum(c)=41 < m=42, which is fine.

But in the example, they used higher numbers.

Maybe to maximize the sum or something.

But according to the problem, any valid solution is acceptable.

So, the approach in the code seems to work.

But I need to make sure it's correct.

Let me think about why this approach works.

We set x_i = m // k_i, where m is LCM of all k_i's.

Then, sum(x_i) < m.

We need to verify that for each i, sum(x) < k_i * x_i.

Given that sum(x) < m and k_i * x_i = k_i * (m // k_i).

Now, m // k_i is floor division, so m // k_i <= m / k_i.

Wait, m is divisible by k_i because m is LCM of all k_i's, so m is a multiple of k_i.

Therefore, m // k_i = m / k_i.

So, k_i * x_i = k_i * (m // k_i) = k_i * (m / k_i) = m.

Therefore, sum(x) < m = k_i * x_i for each i.

Hence, the condition is satisfied.

But in the code, it checks if sum(c) >= m, and if so, outputs -1.

Otherwise, outputs c.

Wait, in the first test case, sum(c)=41 < m=42, which is fine.

In the third test case, sum(c)=5 >= m=5, so outputs -1.

Perfect.

So, this seems correct.

But in the example, for the first test case, it outputs different numbers.

Maybe the code is scaling up the x_i.

Wait, perhaps the code is more general.

Let me check.

In the code, it defines func_1 as LCM of two numbers.

Func_2 computes LCM of the list k.

Then, c_i = m // k_i.

Then, if sum(c) >= m, output -1; else, output c.

In the first test case, sum(c)=41 < m=42, so it outputs c=[14,21,6].

But in the example, it outputs [27,41,12], which sums to 80 < m=42*2=84.

Wait, 42*2=84, but actually, m=42, and sum(x)=80 < 84.

Wait, no, the condition is sum(x) < k_i * x_i for each i.

For i=1: k=3, x=27, 3*27=81 > 80

For i=2: k=2, x=41, 2*41=82 > 80

For i=3: k=7, x=12, 7*12=84 > 80

So, it works.

But according to the code, it should output [14,21,6].

Why does the example use different numbers?

Maybe because the problem allows any valid solution.

The code's approach is correct, but perhaps there are multiple solutions.

So, the code's approach is valid, and it finds one possible solution.

Hence, the code is correct.

Wait, but in the first test case, sum(c)=41 < m=42, which satisfies sum(x) < m.

And for each i, k_i * x_i = m, which is 42.

So, sum(x)=41 < 42, which is fine.

But in the example, sum(x)=80, which is greater than m=42.

Wait, but in the explanation, it says that sum(x)=80 < k_i * x_i for each i.

Wait, for i=1: k=3, x=27, 3*27=81 > 80

For i=2: k=2, x=41, 2*41=82 > 80

For i=3: k=7, x=12, 7*12=84 > 80

So, even though sum(x)=80 > m=42, it still satisfies sum(x) < k_i * x_i for each i.

But according to the code, it checks if sum(c) >= m, and if not, outputs c.

So, in this case, sum(c)=41 < m=42, so it outputs c=[14,21,6], which also satisfies sum(x)=41 < k_i * x_i for each i.

Hence, both [14,21,6] and [27,41,12] are valid solutions.

So, the code's approach is correct.

Therefore, the answer is Correctness: **True**

**Final Solution**

To solve this problem, we need to determine how to distribute coins among different outcomes in a game such that, regardless of which outcome wins, the total coins returned are strictly greater than the total coins bet. This requires careful calculation to ensure that the sum of the bets is less than the return for each possible winning outcome.

## Approach

1. **Understanding the Requirements**:
    - For each outcome `i`, there is a multiplier `k_i`. If outcome `i` wins, we get back `k_i * x_i` coins, where `x_i` is the amount bet on outcome `i`.
    - We need to ensure that for every outcome `i`, the total sum of all bets is less than `k_i * x_i`.

2. **Key Insight**:
    - We need to find bets `x_i` such that for every `i`, `sum(x) < k_i * x_i`.
    - This can be achieved by setting `x_i` proportional to the least common multiple (LCM) of the multipliers.

3. **Algorithm**:
    - Calculate the LCM of all `k_i`s.
    - For each `i`, set `x_i` to be `LCM // k_i`.
    - Check if the sum of all `x_i`s is less than the LCM. If it is, this distribution is valid; otherwise, no solution exists.

4. **Helper Functions**:
    - `func_1(a, b)`: Computes the LCM of two numbers.
    - `func_2(numbers)`: Computes the LCM of a list of numbers.

## Solution Code

```python
from math import gcd

def func_1(a, b):
    return abs(a * b) // gcd(a, b)

def func_2(numbers):
    result = numbers[0]
    for num in numbers[1:]:
        result = func_1(result, num)
    return result

t = int(input())
for _ in range(t):
    n = int(input())
    k = list(map(int, input().split()))
    m = func_2(k)
    c = []
    for i in range(n):
        c.append(m // k[i])
    if sum(c) >= m:
        print(-1)
        continue
    for i in range(n):
        print(c[i], end=' ')
    print('\n', end='')
```

## Explanation

1. **LCM Calculation**:
    - We compute the LCM of all `k_i`s to ensure that `k_i * x_i` is equal to the LCM for each `i` when `x_i` is set to `LCM // k_i`.

2. **Setting Bets**:
    - For each outcome `i`, set `x_i` to `LCM // k_i`. This ensures that `k_i * x_i` equals the LCM.

3. **Validation**:
    - Sum all `x_i`s and check if this sum is less than the LCM. If it is, this sum is less than `k_i * x_i` for each `i`, satisfying the problem's condition.
    - If the sum of `x_i`s is greater than or equal to the LCM, no valid distribution exists, and we output `-1`.

This approach guarantees that if a solution exists, it will be found efficiently within the given constraints.