Alright, I have this problem to solve. Let's read it carefully.

So, I have a hand of n cards, each with a number on it, and a fixed integer k. I can perform an operation any number of times, where I choose k cards that all have the same number and exchange them for k-1 cards, each of which can have any number I choose. The goal is to find the minimum number of cards I can have in the end.

First, I need to understand the operation clearly. If I have k cards with the same number, I can replace them with k-1 cards of any numbers I choose. So, essentially, I'm reducing the number of cards by 1 each time I perform this operation.

I need to minimize the number of cards I have in the end. So, I should perform this operation as many times as possible.

Let me think about how to maximize the number of operations I can perform. Since each operation reduces the total number of cards by 1, the more operations I can perform, the fewer cards I'll have in the end.

To perform an operation, I need to have k cards with the same number. So, I should look at the frequency of each number in my hand and see how many operations I can perform for each.

Let's consider the frequency of each number. If a number appears f times, then the number of operations I can perform with this number is f // k. Each operation reduces the count of this number by k and adds k-1 cards of any number, but since I can choose the numbers of the new cards, I can potentially use them in future operations if needed.

Wait, but the new cards can have any number, so I can choose numbers that are already present or new numbers. But since I can choose any number, maybe I can strategically choose numbers that will allow me to perform more operations in the future.

But this seems a bit complicated. Maybe there's a simpler way to approach this.

Let me consider the total number of operations I can perform. Each operation reduces the total number of cards by 1, as I replace k cards with k-1 cards.

So, if I can perform o operations, then the final number of cards will be n - o.

My goal is to maximize o, so that n - o is minimized.

Now, to perform an operation, I need to have at least k cards with the same number.

So, I need to find the maximum number of operations I can perform given the frequencies of the numbers.

But I need to consider that when I perform an operation on one number, it reduces the count of that number, which might affect the number of operations I can perform with other numbers.

Wait, but in this problem, since I can choose any number for the new cards, perhaps I can optimize by choosing numbers that still allow me to perform more operations.

This seems tricky. Maybe I need to look at it differently.

Let me consider the frequencies of the numbers. For each number, I can perform freq // k operations, where freq is the frequency of that number.

Each such operation reduces the frequency by k and adds k-1 new cards of any number.

But since the new cards can have any number, perhaps I can choose to make them have a number that still has a high frequency, allowing me to perform more operations.

But this seems too vague. Maybe I need to find a way to model this more formally.

Let me think about the constraints.

n can be up to 100, and k can be up to 100.

t, the number of test cases, is up to 500.

So, I need an efficient solution, but since n and k are small, maybe a simple approach will work.

Let me consider the example given.

First example:

n = 5, k = 3

nums = [4, 1, 1, 4, 4]

So, frequencies:

4: 3

1: 2

I can perform one operation on the three 4's, replacing them with two cards of any number. Let's say I choose to make them two 1's.

Now, my hand is [1, 1, 1]

Now, I can perform another operation on these three 1's, replacing them with two cards of any number. Let's say two 2's.

So, now my hand is [2, 2]

I can't perform any more operations because I don't have three cards with the same number.

So, the final number of cards is 2.

Another sequence:

Original hand: [4,1,1,4,4]

Perform operation on three 4's, replace with two 1's.

Now hand is [1,1,1,1]

Perform operation on three 1's, replace with two 1's.

Now hand is [1,1,1]

Perform operation on three 1's, replace with two 1's.

Now hand is [1,1]

But wait, in the first step, after replacing three 4's with two 1's, I have [1,1,1,1]

Then, I can perform operation on three 1's, replacing them with two 1's, resulting in [1,1,1]

Then, again perform operation on three 1's, replacing them with two 1's, resulting in [1,1]

But I can't perform any more operations because I don't have three cards with the same number.

So, final number of cards is 2.

But the problem says that the minimum number of cards is 2 for this example.

Another example:

n = 1, k = 10

nums = [7]

Here, n < k, so no operation can be performed. So, the final number of cards is 1.

Another example:

n = 7, k = 2

nums = [4,2,1,100,5,2,3]

Frequencies:

2:2

1:1

4:1

100:1

5:1

3:1

I can perform operations on the two 2's, replacing them with one card of any number. Say, replace them with one 2.

Now, hand is [4,1,100,5,2,3,2]

Now, I have two 2's again, so I can perform another operation, replacing them with one 2.

Now, hand is [4,1,100,5,2,3]

Again, I have one 2, but I need two to perform an operation.

So, no more operations can be performed.

Final number of cards is 6.

But the expected output for this test case is 1, so maybe my sequence is not optimal.

Wait, perhaps there's a better way.

Original hand: [4,2,1,100,5,2,3]

Frequencies: 2:2, others:1

Perform operation on two 2's, replace with one 2.

Now, hand is [4,1,100,5,2,3]

Now, only one 2, can't perform any more operations.

Final number of cards is 6.

But the expected output is 1, so clearly there's a better strategy.

Wait, maybe I should choose to replace the two 2's with two different numbers that I can use to perform more operations later.

But in this case, since all other numbers appear only once, it's not clear how to proceed.

Hmm.

Wait, perhaps I need to think differently.

Maybe I need to consider the frequencies in a collective way, rather than focusing on individual numbers.

Let me think about the total number of operations I can perform.

Each operation reduces the total number of cards by 1, as I replace k cards with k-1 cards.

So, if I can perform o operations, the final number of cards will be n - o.

I need to maximize o to minimize n - o.

But to perform an operation, I need to have at least k cards with the same number.

So, perhaps I need to find the maximum number of groups of k cards that have the same number.

But I can choose to perform operations on different numbers in sequence.

Wait, perhaps I need to find the maximum number of operations I can perform by always choosing the number with the current highest frequency that has at least k cards.

But this seems too vague.

Maybe I need a better approach.

Let me look at the frequency of each number.

Suppose I have a frequency f for some number.

Each operation on this number can reduce f by k and add k-1 cards of any number.

But since I can choose the numbers of the new cards, perhaps I can strategically choose numbers that will allow me to perform more operations.

But this seems too convoluted.

Maybe I need to model this as a greedy algorithm.

I can sort the frequencies in descending order and try to perform operations on the highest frequencies first.

But I'm not sure.

Let me consider the frequencies.

Suppose I have frequencies f1, f2, ..., fm for m different numbers.

Each operation reduces one of the frequencies by k and adds k-1 cards of any chosen number.

I can choose to add k-1 cards of a number that already exists or a new number.

If I choose to add k-1 cards of a number that already exists, say a number with frequency f, then f becomes f + k -1.

Alternatively, I can create a new number with frequency k-1.

I need to choose in a way that allows me to perform as many operations as possible.

This seems tricky.

Maybe I need to think in terms of the number of operations I can perform for each frequency.

For a frequency f, the number of operations I can perform is f // k.

Each operation reduces f by k and adds k-1 cards of a chosen number.

But since I can choose the numbers of the new cards, perhaps I can feed those back into the system to perform more operations.

Wait, maybe I can model this recursively.

Let's define a function that, given a list of frequencies, computes the maximum number of operations possible.

But with n up to 100 and t up to 500, this might be too slow.

I need a smarter approach.

Let me consider that each operation reduces the total number of cards by 1, regardless of which number I choose.

So, if I can perform o operations, the final number of cards is n - o.

I need to maximize o.

Each operation requires k cards of the same number.

So, the maximum o is limited by the total number of groups of k cards with the same number I can form.

But since I can perform operations sequentially, reducing frequencies and potentially creating new cards that can be used in future operations, it's not straightforward.

Maybe I need to consider the frequencies in a collective way.

Let me consider that for each frequency f, I can perform f // k operations directly on that frequency.

Each such operation reduces f by k and adds k-1 cards of a chosen number.

But since I can choose the number for the new cards, perhaps I can optimize by choosing numbers that still have high frequencies.

Wait, maybe I can think of it as a整体, where I sum up all the frequencies, and see how many operations I can perform in total.

But that might not be accurate because the new cards created can be used in future operations.

This is getting complicated.

Let me look for a pattern or a formula.

Suppose I have a frequency f for a number.

Each operation on this frequency reduces f by k and adds k-1 cards of a chosen number.

So, the net reduction in the total number of cards is 1 per operation.

If I perform o operations, the total reduction is o.

So, the final number of cards is n - o.

I need to maximize o.

But o is limited by the number of groups of k cards with the same number I can form, considering that new cards can be created and potentially used in future operations.

This seems like a recursive process, but perhaps there's a mathematical way to compute o.

Wait, maybe I can think in terms of the ceiling division.

For each frequency f, the number of operations I can perform directly on that frequency is f // k.

But this doesn't account for the new cards created, which can be used in future operations.

Wait, perhaps I can model this as follows:

For each frequency f, the number of operations I can perform is f // k.

Each such operation produces k-1 new cards, which can be considered as adding to the frequency of some other number.

But since I can choose the numbers of the new cards, perhaps I can assign them to numbers that still have high frequencies.

This seems too vague.

Maybe I need to think of it in terms of the total number of operations possible.

Let me consider that each operation reduces the total number of cards by 1, as I replace k cards with k-1 cards.

So, the maximum number of operations o is n - m, where m is the minimum number of cards left.

But this seems circular.

Wait, perhaps I can think in terms of the maximum number of operations I can perform, given the constraints on the frequencies.

Let me consider that for each frequency f, the maximum number of operations I can perform directly on that frequency is f // k.

After performing these operations, I'll have f % k cards left for that number.

But meanwhile, each operation produces k-1 new cards, which can be assigned to any numbers.

These new cards can be used to perform more operations, either on existing numbers or on new numbers.

This seems recursive.

Maybe I can model this by iteratively performing operations on the frequencies that have at least k cards, and adding the new cards to other frequencies, until no frequency has k or more cards.

But with n up to 100 and t up to 500, this might be too slow.

I need a smarter approach.

Let me consider the extreme case where all cards have the same number.

In this case, I can perform operations repeatedly until the frequency is less than k.

Specifically, if I have f cards of the same number, the number of operations I can perform is floor division f // k, and the remaining cards are f % k.

But each operation also adds k-1 new cards, which can be assigned to any number.

So, in this case, I can choose to assign them back to the same number, effectively allowing me to perform more operations.

Wait, let's see.

Suppose I have f cards of the same number.

I perform f // k operations on them.

Each operation reduces f by k and adds k-1 cards of a chosen number.

So, after o operations, f becomes f - o*k + o*(k-1) = f - o.

Wait, f - o*k + o*(k-1) = f - o*k + o*k - o = f - o.

So, f decreases by o.

But o can be up to f // k.

Wait, but f // k is the integer division of f by k, which is the number of times I can perform the operation before f drops below k.

Wait, but in reality, each operation reduces f by k and adds k-1 cards, so f becomes f - k + (k-1) = f - 1.

So, each operation reduces f by 1.

Therefore, I can perform operations until f < k.

Hence, the number of operations is f - f % k.

Wait, no.

Wait, if f = 5, k = 3.

First operation: f = 5 - 3 + 2 = 4

Second operation: f = 4 - 3 + 2 = 3

Third operation: f = 3 - 3 + 2 = 2

Now, f < k, can't perform any more operations.

Total operations: 3

But 5 - 5 % 3 = 5 - 2 = 3, which matches.

Similarly, for f = 3, k = 3.

First operation: f = 3 - 3 + 2 = 2

Can't perform any more operations.

Operations: 1

Which is 3 - 3 % 3 = 3 - 0 = 3, but operations are 1.

Wait, this doesn't match.

Wait, perhaps my earlier assumption is wrong.

Wait, for f = 3, k = 3.

After first operation: f = 3 - 3 + 2 = 2

Now, f < k, can't perform any more operations.

So, total operations: 1

But f - f % k = 3 - 0 = 3, which is not equal to 1.

So, my earlier assumption is incorrect.

Hence, the number of operations is not f - f % k.

Wait, perhaps it's f // k.

For f = 5, k = 3: 5 // 3 = 1 (but earlier sequence had 3 operations)

Wait, that doesn't match.

Wait, perhaps I need to consider that each operation reduces f by 1, as f becomes f - k + (k-1) = f -1.

So, the number of operations is f - (f % k)

Wait, for f=5, k=3: 5 - (5%3) = 5 - 2 = 3, which matches the earlier count.

For f=3, k=3: 3 - 0 = 3, but in reality, only one operation can be performed.

So, this is inconsistent.

Wait, perhaps I need to think differently.

Let me consider that for each operation, f decreases by 1, as f becomes f - k + (k-1) = f -1.

So, the number of operations is f - m, where m is the final number of cards for that frequency.

But m must be less than k.

So, operations = f - m, where m = f % k.

Hence, operations = f - (f % k)

But in the f=3, k=3 case, operations = 3 - 0 = 3, but in reality, only one operation can be performed.

Wait, that doesn't make sense.

Wait, perhaps I need to consider that after each operation, the new cards added can be used in future operations.

In the f=3, k=3 case:

Operation 1: f = 3 - 3 + 2 = 2

Now, f = 2 < 3, can't perform any more operations.

Total operations: 1

But f - (f % k) = 3 - 0 = 3, which doesn't match.

So, perhaps the formula is operations = floor(f / k)

For f=5, k=3: floor(5/3) = 1, but earlier sequence had 3 operations.

Wait, no, in the earlier sequence for f=5, k=3, operations = 5 - 5%3 = 5 - 2 = 3, but in reality, only floor(5/3) = 1 operation can be performed.

Wait, perhaps I made a mistake.

Wait, no, in the earlier example for f=5, k=3:

Operation 1: f = 5 - 3 + 2 = 4

Operation 2: f = 4 - 3 + 2 = 3

Operation 3: f = 3 - 3 + 2 = 2

Now, f < k, can't perform more operations.

So, total operations: 3

But floor(5/3) = 1, which doesn't match.

Wait, perhaps it's not floor(f/k), but something else.

Wait, perhaps it's f - f%k, divided by (k-1).

Wait, for f=5, k=3: 5 - 2 = 3, 3 / 2 = 1.5, which is not integer.

Wait, perhaps it's more complex.

This seems too tangled.

Maybe I need to consider the problem differently.

Let me consider that each operation reduces the total number of cards by 1.

So, the maximum number of operations is n - m, where m is the minimum number of cards left.

I need to find m.

But I need to find the smallest m such that no frequency in m is >= k.

Because if any frequency is >=k, I can perform another operation, reducing m by 1.

Hence, m should be such that all frequencies are less than k.

So, I need to distribute m cards among the numbers in such a way that no number has frequency >=k.

The minimal m is the smallest number such that if the cards are distributed optimally, no number has frequency >=k.

This sounds like finding the smallest m where m <= (number of distinct numbers) * (k-1)

Wait, but that might not be accurate.

Wait, perhaps m is the ceiling of n divided by the maximum frequency allowed per number, which is k-1.

Wait, if each number can have at most k-1 cards, then the minimal m is ceil(n / (k-1))

But let's test this with the first example:

n=5, k=3

ceil(5 / 2) = 3, but the answer is 2.

So, doesn't match.

Wait, perhaps it's floor(n / (k-1)) if n % (k-1) ==0 else floor(n / (k-1)) +1

For n=5, k=3: 5 / 2 = 2.5, which is 3, but answer is 2.

Wait, doesn't match.

Another example:

n=1, k=10

ceil(1 / 9) = 1, which matches the answer.

n=7, k=2

ceil(7 /1) =7, but answer is 1.

Doesn't match.

Wait, perhaps it's different.

Maybe m is the minimal number such that m >= n - floor(n / (k-1))

Wait, that doesn't seem right.

This is getting too confusing.

Perhaps I need to look for a different approach.

Let me consider that the minimal number of cards left is n - o, where o is the maximal number of operations I can perform.

Each operation requires k cards of the same number, and produces k-1 new cards.

But since I can choose the numbers of the new cards, perhaps I can optimize the distribution.

This seems too vague.

Maybe I need to consider the problem in terms of graph theory or some other mathematical model, but that might be overkill for this problem.

Given time constraints, perhaps I should look for a pattern in the sample inputs and outputs.

First sample:

n=5, k=3, frequencies: 4:3, 1:2

Answer:2

Second sample:

n=1, k=10

Answer:1

Third sample:

n=7, k=2, frequencies: 2:2,1:1,4:1,100:1,5:1,3:1

Answer:1

Wait, in this case, with k=2, I can perform operations on the two 2's, replacing them with one 2.

Then, I have one 2 left, and other numbers appearing once.

No more operations can be performed, so m=6, but the answer is 1.

This suggests that there's a better strategy.

Wait, perhaps I can choose to create new numbers with the new cards.

For example, in the third sample, with n=7, k=2:

Original: [4,2,1,100,5,2,3]

Perform operation on two 2's, replace with one 3.

Now, hand is [4,1,100,5,3,3]

Perform operation on two 3's, replace with one 3.

Now, hand is [4,1,100,5,3]

Perform operation on two's: but only one 3 left, can't perform.

So, m=5, but answer is 1.

This is not matching.

Wait, perhaps I can choose to create new numbers that