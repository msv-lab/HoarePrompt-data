Alright, I've got this problem to figure out. Let's see what it's asking for. So, Alice has n coins and wants to buy exactly k jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel that's an integer between 1 and 10^18 coins. Alice buys jewels greedily: she goes to each stall in order and buys as many jewels as she can with her remaining coins.

My task is to determine if Bob can set up the stalls and set the prices in such a way that Alice ends up buying exactly k jewels. If it's possible, I need to output "YES" along with the number of stalls and their prices. If not, I should output "NO".

First, I need to understand how Alice's buying behavior works. She goes to each stall in sequence and buys as many jewels as she can with her current coins. So, at each stall, she divides her remaining coins by the price per jewel at that stall and buys the integer division amount, updating her coin count accordingly.

I need to design stall prices such that the total jewels bought is exactly k.

Let me think about the simplest case. If k = n, meaning Alice should buy one jewel per coin, I can just set up one stall with price 1. That way, she buys n jewels, each costing 1 coin. So, "YES" with 1 stall and price 1.

Another simple case: if k = 1, Alice should buy only one jewel. To ensure she buys only one jewel, the first stall should have a price such that she can buy one jewel and doesn't have enough for a second one at any other stall. So, setting the first stall's price to ceil(n/k) might work, but I need to think carefully.

Wait, in the first test case in the example:

n = 7, k = 3

The solution provided is 10 stalls with prices 2 through 11.

Let's verify this:

- Stall 1: price = 2, jewels bought = 7 // 2 = 3, coins left = 7 - 3*2 = 1

- Since she has only 1 coin left, she can't buy anything from the remaining stalls, so total jewels bought = 3, which matches k.

But why 10 stalls? Could it be done with fewer? Maybe, but the problem allows up to 60 stalls, so it's acceptable.

In the third test case:

n = 255, k = 8

Solution: 8 stalls with prices 128, 64, 32, 16, 8, 4, 2, 1

Let's see:

- Stall 1: price = 128, jewels bought = 255 // 128 = 1, coins left = 255 - 128 = 127

- Stall 2: price = 64, jewels bought = 127 // 64 = 1, coins left = 127 - 64 = 63

- Stall 3: price = 32, jewels bought = 63 // 32 = 1, coins left = 63 - 32 = 31

- Stall 4: price = 16, jewels bought = 31 // 16 = 1, coins left = 31 - 16 = 15

- Stall 5: price = 8, jewels bought = 15 // 8 = 1, coins left = 15 - 8 = 7

- Stall 6: price = 4, jewels bought = 7 // 4 = 1, coins left = 7 - 4 = 3

- Stall 7: price = 2, jewels bought = 3 // 2 = 1, coins left = 3 - 2 = 1

- Stall 8: price = 1, jewels bought = 1 // 1 = 1, coins left = 0

Total jewels bought: 8, which matches k.

This seems like a binary search approach, where each stall's price is half of the previous one, ensuring that Alice buys exactly one jewel per stall until her coins are exhausted.

Now, looking at the provided program:

def func():

t = int(input())

for _ in range(t):

(n, k) = map(int, stdin.readline().split())

if n == k:

print('YES')

print(1)

print(1)

elif n + 2 > k * 2:

print('YES')

print(2)

print(n - k + 1, end=' ')

print(1)

else:

print('NO')

It handles two cases:

1. When n == k: output "YES", 1 stall with price 1.

2. When n + 2 > k * 2: output "YES", 2 stalls with prices n - k + 1 and 1.

Otherwise, output "NO".

Wait, but in the first test case, n = 7, k = 3:

7 + 2 = 9 > 3 * 2 = 6, which is true, so it should output "YES" with 2 stalls.

But in the example, it's shown with 10 stalls. So, perhaps there are multiple ways to achieve the goal, and the program is choosing a different approach.

Let me verify the second case:

n = 7, k = 3

According to the program:

prices = [n - k + 1, 1] = [7 - 3 + 1, 1] = [5, 1]

Let's see:

- Stall 1: price = 5, jewels bought = 7 // 5 = 1, coins left = 7 - 5 = 2

- Stall 2: price = 1, jewels bought = 2 // 1 = 2, coins left = 0

Total jewels bought: 1 + 2 = 3, which matches k.

So, it works with 2 stalls in this case.

But in the first test case in the example, it used 10 stalls, but the program uses only 2. So, the program's approach is different from the example's solution, but still correct.

Now, let's see the second test case in the input:

n = 6, k = 4

According to the program:

6 + 2 = 8 > 4 * 2 = 8? 8 > 8 is False, so output "NO"

Is this correct?

Let's think: can we set up stalls such that Alice buys exactly 4 jewels with 6 coins?

Let's try:

- If we set up one stall with price 1, she buys 6 jewels, which is more than 4.

- If we set up two stalls: [3, 1]

- Stall 1: 6 // 3 = 2 jewels, coins left = 6 - 6 = 0

- Stall 2: 0 coins, can't buy anything

- Total jewels: 2, which is less than 4.

- Another try: [2, 1]

- Stall 1: 6 // 2 = 3 jewels, coins left = 6 - 6 = 0

- Stall 2: 0 coins, can't buy anything

- Total jewels: 3, which is less than 4.

- Another try: [1, 1]

- Stall 1: 6 // 1 = 6 jewels, coins left = 0

- Stall 2: 0 coins, can't buy anything

- Total jewels: 6, which is more than 4.

- Another try: [4, 1]

- Stall 1: 6 // 4 = 1 jewel, coins left = 6 - 4 = 2

- Stall 2: 2 // 1 = 2 jewels, total jewels: 3, which is less than 4.

- Another try: [5, 1]

- Stall 1: 6 // 5 = 1 jewel, coins left = 6 - 5 = 1

- Stall 2: 1 // 1 = 1 jewel, total jewels: 2, which is less than 4.

- Another try with three stalls: [2, 2, 1]

- Stall 1: 6 // 2 = 3 jewels, coins left = 0

- Stall 2 and 3: can't buy anything

- Total jewels: 3, which is less than 4.

- Another try: [3, 2, 1]

- Stall 1: 6 // 3 = 2 jewels, coins left = 0

- Stall 2 and 3: can't buy anything

- Total jewels: 2, which is less than 4.

- Another try: [4, 2, 1]

- Stall 1: 6 // 4 = 1 jewel, coins left = 2

- Stall 2: 2 // 2 = 1 jewel, coins left = 0

- Stall 3: can't buy anything

- Total jewels: 2, which is less than 4.

- Another try: [5, 2, 1]

- Stall 1: 6 // 5 = 1 jewel, coins left = 1

- Stall 2: 1 // 2 = 0 jewels

- Stall 3: 1 // 1 = 1 jewel

- Total jewels: 2, which is less than 4.

- Another try: [2, 1, 1]

- Stall 1: 6 // 2 = 3 jewels, coins left = 0

- Stall 2 and 3: can't buy anything

- Total jewels: 3, which is less than 4.

It seems no matter how I set up the stalls, I can't get exactly 4 jewels with 6 coins. So, the program's output "NO" seems correct in this case.

Now, the third test case:

n = 255, k = 8

The example shows it's possible with 8 stalls, which the program would handle differently, but as long as it's possible with at most 60 stalls, it's acceptable.

Looking back at the program's logic:

- If n == k, output "YES" with one stall of price 1.

- Else if n + 2 > k * 2, output "YES" with two stalls: [n - k + 1, 1]

- Else, output "NO"

I need to verify if this logic is correct.

First case: n == k

As explained earlier, setting one stall with price 1 allows Alice to buy exactly k jewels, which is correct.

Second case: n + 2 > k * 2

This seems a bit arbitrary. Let's see what this condition means.

n + 2 > 2k

Which is equivalent to n > 2k - 2

So, when n > 2k - 2, the program says "YES" with two stalls: [n - k + 1, 1]

Let's see why this works.

With two stalls:

- First stall: price p1 = n - k + 1

- Second stall: price p2 = 1

Alice will buy as many jewels as possible from the first stall, then from the second stall with the remaining coins.

Jewels bought from first stall: floor(n / p1)

Coins left: n - (floor(n / p1)) * p1

Jewels bought from second stall: floor(coins left / p2)

Total jewels: floor(n / p1) + floor(coins left / p2)

We need this to be equal to k.

Given p2 = 1, floor(coins left / p2) = coins left

So, total jewels = floor(n / p1) + (n - floor(n / p1) * p1)

Let me denote q = floor(n / p1), then total jewels = q + (n - q * p1)

So, total jewels = q + n - q * p1 = n - q * (p1 - 1)

We need n - q * (p1 - 1) = k

But p1 = n - k + 1

Substituting p1:

n - q * ((n - k + 1) - 1) = k => n - q * (n - k) = k

Rearranging:

n - q(n - k) = k => n - k = q(n - k)

So, q = (n - k) / (n - k) = 1, provided n != k

But n != k in this case, since we have n > 2k - 2 and n != k

Wait, but if n = k, it's handled separately. So, n != k here.

So, q = 1

Then, total jewels = q + (n - q * p1) = 1 + (n - 1 * (n - k + 1)) = 1 + (n - n + k - 1) = 1 + (k - 1) = k

So, it works out correctly.

Therefore, the program's logic for the second case is correct.

Now, what about the else case: when n + 2 <= 2k, the program outputs "NO"

Is this always correct?

In other words, if n <= 2k - 2, is it impossible to set up at most 60 stalls such that Alice buys exactly k jewels?

Wait, no. The example shows that for n = 255 and k = 8, which satisfies 255 > 2*8 - 2 = 14, so n + 2 > 2k is true, but the program only handles n + 2 > 2k with two stalls, but in the example, it's handled with 8 stalls.

So, perhaps the program is not considering other possibilities.

Wait, but the problem allows up to 60 stalls, so multiple configurations are possible.

In the example, with n = 255 and k = 8, using 8 stalls with prices 128, 64, 32, 16, 8, 4, 2, 1, which is a binary approach, works.

But in the program, for n + 2 > 2k, it uses only two stalls.

So, is it always possible to achieve exactly k jewels with at most two stalls when n + 2 > 2k?

From the earlier analysis, yes, with p1 = n - k + 1 and p2 = 1.

But perhaps there are cases where n + 2 > 2k, but this specific two-stall configuration doesn't work.

Wait, in the earlier analysis, it does work for n + 2 > 2k.

But maybe there are cases where n + 2 > 2k, but Alice still can't buy exactly k jewels with any configuration of at most 60 stalls.

Wait, but in the earlier analysis, the two-stall configuration works for n + 2 > 2k.

So, perhaps in that case, it's always possible to achieve exactly k jewels with at most two stalls.

Therefore, the program's logic seems correct.

But let's check another example.

Suppose n = 5, k = 2

Check condition: 5 + 2 = 7 > 2*2 = 4, which is true.

So, program outputs "YES" with two stalls: [5 - 2 + 1, 1] = [4, 1]

Let's see:

- Stall 1: 5 // 4 = 1 jewel, coins left = 5 - 4 = 1

- Stall 2: 1 // 1 = 1 jewel, total jewels = 2

Which matches k = 2.

Another example: n = 10, k = 4

10 + 2 = 12 > 8, so "YES" with [10 - 4 + 1, 1] = [7, 1]

- Stall 1: 10 // 7 = 1 jewel, coins left = 10 - 7 = 3

- Stall 2: 3 // 1 = 3 jewels, total jewels = 4

Which is correct.

Another example: n = 1, k = 1

Condition: 1 + 2 = 3 > 2*1 = 2, so "YES" with [1 - 1 + 1, 1] = [1, 1]

- Stall 1: 1 // 1 = 1 jewel, coins left = 0

- Stall 2: 0 // 1 = 0 jewels, total jewels = 1

Correct.

Another example: n = 2, k = 1

Condition: 2 + 2 = 4 > 2, so "YES" with [2 - 1 + 1, 1] = [2, 1]

- Stall 1: 2 // 2 = 1 jewel, coins left = 0

- Stall 2: 0 // 1 = 0 jewels, total jewels = 1

Correct.

Now, for n = 1, k = 2

Condition: 1 + 2 = 3 > 4? 3 > 4 is False, so "NO"

Is this correct?

Trying to find a configuration:

- With one stall: price p, jewels bought = floor(1 / p)

To get floor(1 / p) = 2, p must be floor(1 / p) = 2, which is impossible for any p.

- With two stalls: [p1, p2]

First stall: floor(1 / p1) jewels, coins left = 1 - floor(1 / p1) * p1

Second stall: floor(remaining / p2) jewels

To have total jewels = 2

Possible options:

- Stall 1: p1 = 1, floor(1 / 1) = 1 jewel, coins left = 0

- Stall 2: 0 // p2 = 0 jewels, total jewels = 1 < 2

- Stall 1: p1 = 2, floor(1 / 2) = 0 jewels, coins left = 1

- Stall 2: 1 // p2, if p2 = 1, floor(1 / 1) = 1 jewel, total jewels = 1 < 2

- If p2 = 2, floor(1 / 2) = 0 jewels, total jewels = 0 < 2

- Stall 1: p1 = 3, floor(1 / 3) = 0 jewels, coins left = 1

- Stall 2: 1 // p2, similar to above, can't get 2 jewels

So, it's impossible to get exactly 2 jewels with n = 1, hence "NO" is correct.

Another test case: n = 3, k = 2

Condition: 3 + 2 = 5 > 4, so "YES" with [3 - 2 + 1, 1] = [2, 1]

- Stall 1: 3 // 2 = 1 jewel, coins left = 1

- Stall 2: 1 // 1 = 1 jewel, total jewels = 2

Correct.

Another test case: n = 4, k = 3

Condition: 4 + 2 = 6 > 6, which is 6 > 6 is False, so "NO"

Is this correct?

Trying to find a configuration:

- One stall: p = 1, jewels = 4, which is more than 3

- Two stalls: [p1, p2]

- [3,1]: 4 // 3 = 1 jewel, coins left = 1; 1 // 1 = 1 jewel, total = 2 < 3

- [2,1]: 4 // 2 = 2 jewels, coins left = 0; total = 2 < 3

- [1,1]: 4 // 1 = 4 jewels, coins left = 0; total = 4 > 3

- [4,1]: 4 // 4 = 1 jewel, coins left = 0; total = 1 < 3

- [5,1]: 4 // 5 = 0 jewels, coins left = 4; 4 // 1 = 4 jewels, total = 4 > 3

- [3,2]: 4 // 3 = 1 jewel, coins left = 1; 1 // 2 = 0 jewels, total = 1 < 3

- [2,2]: 4 // 2 = 2 jewels, coins left = 0; total = 2 < 3

- [1,2]: 4 // 1 = 4 jewels, coins left = 0; total = 4 > 3

Seems impossible to get exactly 3 jewels, so "NO" is correct.

Another test case: n = 5, k = 3

Condition: 5 + 2 = 7 > 6, so "YES" with [5 - 3 + 1, 1] = [3,1]

- Stall 1: 5 // 3 = 1 jewel, coins left = 2

- Stall 2: 2 // 1 = 2 jewels, total jewels = 3

Correct.

Seems like the program's logic holds for these cases.

Now, considering the general case, is it always possible to achieve exactly k jewels with at most two stalls when n + 2 > 2k?

From the earlier analysis, yes, using p1 = n - k + 1 and p2 = 1.

But is there any case where n + 2 > 2k, but this configuration doesn't work?

Let me check.

Suppose n = 2k - 1

Condition: (2k - 1) + 2 = 2k + 1 > 2k, which is true.

Then p1 = (2k - 1) - k + 1 = k, p2 = 1

- Stall 1: (2k - 1) // k = floor((2k - 1)/k) = 1 (since 2k - 1 < 2k), so 1 jewel, coins left = (2k - 1) - k = k - 1

- Stall 2: (k - 1) // 1 = k - 1 jewels, total jewels = 1 + (k - 1) = k

So, it works.

Another case: n = 2k - 2

Condition: (2k - 2) + 2 = 2k > 2k is False, so "NO"

Indeed, with n = 2k - 2, using the two-stall configuration:

p1 = (2k - 2) - k + 1 = k - 1, p2 = 1

- Stall 1: (2k - 2) // (k - 1) = floor((2k - 2)/(k - 1)) = 2 jewels, coins left = (2k - 2) - 2*(k - 1) = 0

- Stall 2: 0 // 1 = 0 jewels, total jewels = 2 < k

So, it's impossible to get exactly k jewels, hence "NO" is correct.

Therefore, the program's logic seems sound.

Now, considering the example with n = 255 and k = 8, which satisfies n + 2 > 2k (255 + 2 = 257 > 16), so the program would output "YES" with two stalls [255 - 8 + 1, 1] = [248,1]

Let's see:

- Stall 1: 255 // 248 = 1 jewel, coins left = 255 - 248 = 7

- Stall 2: 7 // 1 = 7 jewels, total jewels = 8

Which is correct.

But in the example, it's shown with 8 stalls, but the program uses only two. Both are acceptable since the problem allows up to 60 stalls.

Therefore, the program seems correct.

**Final Solution**

To solve this problem, we need to determine if Bob can set up at most 60 stalls with integer prices per jewel such that Alice buys exactly k jewels using her n coins. Alice buys jewels greedily, purchasing as many jewels as possible from each stall in sequence.

### Approach

1. **Base Case:**
   - If `n == k`, set up one stall with price 1. Alice will buy one jewel per coin, totaling k jewels.

2. **Two Stall Configuration:**
   - If `n + 2 > 2k`, set up two stalls:
     - First stall with price `p1 = n - k + 1`.
     - Second stall with price `p2 = 1`.
   - Alice will buy jewels from the first stall and any remaining coins will be used to buy jewels from the second stall, ensuring she buys exactly k jewels.

3. **Impossible Case:**
   - If neither of the above conditions is met, it is impossible to set up the stalls such that Alice buys exactly k jewels.

### Solution Code

```python
from sys import stdin

def func():
    t = int(input())
    for _ in range(t):
        n, k = map(int, stdin.readline().split())
        if n == k:
            print('YES')
            print(1)
            print(1)
        elif n + 2 > 2 * k:
            print('YES')
            print(2)
            p1 = n - k + 1
            p2 = 1
            print(p1, p2)
        else:
            print('NO')

if __name__ == "__main__":
    func()
```

### Explanation

- **Base Case (`n == k`):**
  - By setting one stall with price 1, Alice buys one jewel per coin, totaling k jewels.

- **Two Stall Configuration (`n + 2 > 2k`):**
  - The first stall is priced at `p1 = n - k + 1`. Alice buys `floor(n / p1)` jewels from this stall.
  - The remaining coins are then used to buy jewels from the second stall priced at 1 coin per jewel.
  - This ensures that the total jewels bought sum up to exactly k.

- **Impossible Case (else):**
  - If neither condition is satisfied, it is impossible to set up the stalls to make Alice buy exactly k jewels.

This approach ensures that we handle the problem efficiently within the constraints provided.