Alright, I've got this problem to solve. Let's see what it's asking for. So, there's this concept of a "good" array. An array A is considered good if there exists another array B of the same length such that:

1. The sum of elements in A is equal to the sum of elements in B.

2. For every index i, A[i] is not equal to B[i].

3. All elements in B are positive integers.

And I'm given an array C of length N, where each element is a positive integer. Then, there are Q queries, each asking whether a subarray from index L to R is good or not.

First, I need to understand what makes a subarray "good." So, for a subarray C[L..R], I need to check if there's another array B of the same length such that:

- Sum of B equals sum of C[L..R].

- For every index in B, B[i] != C[i].

- All B[i] > 0.

I need to process multiple queries efficiently since N and Q can be up to 3*10^5, and the total sum of N and Q across all test cases doesn't exceed that.

Let me try to find a condition that determines whether a subarray is good or not without having to construct B every time.

Let's think about the constraints:

1. Sum of B equals sum of C[L..R].

2. B[i] != C[i] for all i.

3. B[i] > 0 for all i.

Given that B[i] has to be a positive integer and not equal to C[i], the smallest possible value for B[i] is either C[i]-1 (if C[i]>1) or C[i]+1 (if C[i]==1).

Wait, no. Since B[i] has to be positive and not equal to C[i], if C[i]==1, B[i] can be 2 or more. If C[i]>1, B[i] can be C[i]-1 or C[i]+1 or any other positive integer except C[i].

But choosing the smallest possible B[i] would be either C[i]-1 (if C[i]>1) or C[i]+1 (if C[i]==1). This way, we can minimize the sum of B.

If the sum of the smallest possible B is less than or equal to the sum of C[L..R], then it's possible to have such a B.

Wait, but the sum of B has to be exactly equal to the sum of C[L..R]. So, I need to make sure that the sum of the smallest possible B is less than or equal to the sum of C[L..R], and also that the sum of the smallest possible B doesn't exceed the sum of C[L..R].

Actually, I need to ensure that the sum of the minimal possible B is less than or equal to the sum of C[L..R], and that the sum of B can be adjusted to match the sum of C[L..R] by increasing some B[i]s beyond their minimal values.

But this seems a bit messy. Maybe there's a better way.

Let me consider the difference between sum of B and sum of C[L..R]. Since sum(B) = sum(C[L..R]), and B[i] != C[i], I need to adjust each B[i] by some amount away from C[i].

Wait, perhaps I can think in terms of the number of ones in the subarray.

Wait, maybe I need to consider how many ones are there in the subarray.

Let me look at the reference solution to understand their approach.

In the given program, they maintain two arrays:

- ones: which counts the number of ones up to index i.

- sum: which seems to be the cumulative sum of (C[i] - 1).

Then, for each query, they calculate:

- onesInRange = ones[R] - ones[L-1]

- sumInRange = sum[R] - sum[L-1]

And then check if 2 * onesInRange + (R - L + 1) - onesInRange <= sumInRange.

Wait, let's break this down.

First, ones[i] is the count of ones up to index i.

sum[i] is the cumulative sum of (C[j] - 1) for j from 1 to i.

So, sum[i] = sum_{j=1 to i} (C[j] - 1)

Then, for a query from L to R:

onesInRange = ones[R] - ones[L-1] → number of ones in the subarray.

sumInRange = sum[R] - sum[L-1] → sum of (C[j] - 1) for j from L to R.

Now, the condition they're checking is:

if 2 * onesInRange + (R - L + 1) - onesInRange <= sumInRange:

print('YES')

else:

print('NO')

Simplify the left side:

2 * onesInRange + (R - L + 1) - onesInRange = onesInRange + (R - L + 1)

So, it's checking if onesInRange + (R - L + 1) <= sumInRange.

Wait, what's the reasoning behind this?

Let me try to derive what this condition means.

First, sumInRange = sum_{j=L to R} (C[j] - 1) = sum_{j=L to R} C[j] - (R - L + 1)

Let me denote Sum_C = sum_{j=L to R} C[j]

Then, sumInRange = Sum_C - (R - L + 1)

The condition is:

onesInRange + (R - L + 1) <= sumInRange

Substitute sumInRange:

onesInRange + (R - L + 1) <= Sum_C - (R - L + 1)

Which simplifies to:

onesInRange + (R - L + 1) <= Sum_C - (R - L + 1)

=> onesInRange + 2*(R - L + 1) <= Sum_C

So, the condition is:

onesInRange + 2*(R - L + 1) <= Sum_C

Wait, that seems a bit arbitrary. Let me think differently.

Perhaps I need to consider constructing B.

For each C[i], B[i] can be either C[i] - 1 (if C[i] > 1) or C[i] + 1 (if C[i] == 1).

So, the minimal possible B[i] is:

- C[i] - 1, if C[i] > 1

- C[i] + 1, if C[i] == 1

So, for C[i] == 1, minimal B[i] is 2.

For C[i] > 1, minimal B[i] is C[i] - 1.

So, the minimal sum of B is sum_{i=L to R} (C[i] - 1 if C[i] > 1 else 2)

Now, sum_{i=L to R} (C[i] - 1 if C[i] > 1 else 2) = sum_{i=L to R} C[i] - (number of C[i] > 1) + (number of C[i] == 1)

Because for C[i] > 1, it's C[i] - 1, and for C[i] == 1, it's 2.

So, sum_B_min = Sum_C - (number of C[i] > 1) + (number of C[i] == 1)

But number of C[i] > 1 is (R - L + 1) - onesInRange

And number of C[i] == 1 is onesInRange

So, sum_B_min = Sum_C - [(R - L + 1) - onesInRange] + onesInRange

= Sum_C - (R - L + 1) + 2 * onesInRange

Now, for B to have the same sum as A, sum_B_min must be <= Sum_C, and since sum_B_min <= Sum_C, and sum_B_min <= sum_B <= sum_C, but we need sum_B = sum_C.

So, sum_B_min <= sum_C is always true, since sum_B_min is the minimal possible sum of B.

Wait, but in the code, they're checking if onesInRange + (R - L + 1) <= sumInRange

Which, as we saw, simplifies to onesInRange + 2*(R - L + 1) <= Sum_C

Wait, perhaps I made a mistake in the earlier step.

Let me recast this.

Given that sum_B_min = Sum_C - (number of C[i] > 1) + (number of C[i] == 1)

And number of C[i] > 1 is (R - L + 1) - onesInRange

So, sum_B_min = Sum_C - [(R - L + 1) - onesInRange] + onesInRange

= Sum_C - R + L - 1 + onesInRange + onesInRange

= Sum_C - (R - L + 1) + 2 * onesInRange

Now, for B to have the same sum as A, sum_B_min must be <= Sum_C, and since sum_B_min is Sum_C - (R - L + 1) + 2 * onesInRange, and we need sum_B = Sum_C.

So, sum_B_min <= Sum_C, which is Sum_C - (R - L + 1) + 2 * onesInRange <= Sum_C

Which simplifies to - (R - L + 1) + 2 * onesInRange <= 0

Or, 2 * onesInRange <= R - L + 1

Wait, that seems off.

Wait, Sum_C - (R - L + 1) + 2 * onesInRange <= Sum_C

Subtract Sum_C from both sides:

- (R - L + 1) + 2 * onesInRange <= 0

Which is equivalent to 2 * onesInRange <= R - L + 1

So, if 2 * onesInRange <= R - L + 1, then sum_B_min <= Sum_C, which is always true, since sum_B can be adjusted to Sum_C by increasing some B[i]s.

But actually, sum_B_min is less than or equal to Sum_C, but we need sum_B to be exactly equal to Sum_C.

Wait, but in the code, they're checking if onesInRange + (R - L + 1) <= sumInRange

Which, as we saw, is equivalent to onesInRange + 2*(R - L + 1) <= Sum_C

Wait, perhaps I need to relate sumInRange to Sum_C.

sumInRange = Sum_C - (R - L + 1)

So, onesInRange + (R - L + 1) <= Sum_C - (R - L + 1)

Which simplifies to onesInRange + 2*(R - L + 1) <= Sum_C

Which further simplifies to onesInRange + 2*(R - L + 1) <= Sum_C

But I'm still not sure about the logic behind this.

Let me think differently.

Suppose I have a subarray from L to R.

I need to construct B such that:

- B[i] != C[i] for all i

- B[i] > 0 for all i

- Sum of B equals sum of C[L..R]

To minimize sum of B, set B[i] to be the smallest possible value not equal to C[i].

If C[i] == 1, B[i] >= 2

If C[i] > 1, B[i] >= C[i] - 1

So, sum_B_min = sum_{i=L to R} (C[i] - 1 if C[i] > 1 else 2)

As we calculated earlier.

Now, to make sum(B) equal to sum(C[L..R]), we need sum_B_min <= Sum_C, which is always true because:

sum_B_min = Sum_C - number of C[i] > 1 + number of C[i] == 1

= Sum_C - (R - L + 1) + 2 * onesInRange

Wait, hold on.

Wait, earlier I had:

sum_B_min = Sum_C - (R - L + 1) + 2 * onesInRange

And we need sum_B_min <= Sum_C

Which simplifies to:

Sum_C - (R - L + 1) + 2 * onesInRange <= Sum_C

Which further simplifies to:

- (R - L + 1) + 2 * onesInRange <= 0

Which is equivalent to:

2 * onesInRange <= R - L + 1

So, if 2 * onesInRange <= R - L + 1, then sum_B_min <= Sum_C, which is always true.

But actually, sum_B_min can be less than Sum_C, but we need sum_B to be exactly Sum_C.

So, as long as sum_B_min <= Sum_C, we can adjust B[i]s to make sum(B) = Sum_C.

Hence, the condition should be sum_B_min <= Sum_C.

But sum_B_min = Sum_C - (R - L + 1) + 2 * onesInRange

So, sum_B_min <= Sum_C is equivalent to:

Sum_C - (R - L + 1) + 2 * onesInRange <= Sum_C

Which simplifies to:

- (R - L + 1) + 2 * onesInRange <= 0

Which is:

2 * onesInRange <= R - L + 1

So, the condition is 2 * onesInRange <= R - L + 1

But in the code, they're checking:

if 2 * onesInRange + (R - L + 1) - onesInRange <= sumInRange:

Which simplifies to:

if onesInRange + (R - L + 1) <= sumInRange:

But sumInRange = Sum_C - (R - L + 1)

So, onesInRange + (R - L + 1) <= Sum_C - (R - L + 1)

Which simplifies to:

onesInRange + 2*(R - L + 1) <= Sum_C

Wait, but earlier I derived that the condition should be 2 * onesInRange <= R - L + 1

So, there's a discrepancy here.

Perhaps I made a mistake in relating sum_B_min to Sum_C.

Let me try to recast this.

sum_B_min = Sum_C - [(R - L + 1) - onesInRange] + onesInRange

= Sum_C - R + L - 1 + 2 * onesInRange

Now, for sum_B_min <= Sum_C, we have:

Sum_C - R + L - 1 + 2 * onesInRange <= Sum_C

Which simplifies to:

- (R - L + 1) + 2 * onesInRange <= 0

Which is:

2 * onesInRange <= R - L + 1

So, the condition is 2 * onesInRange <= R - L + 1

But in the code, they're checking:

onesInRange + (R - L + 1) <= sumInRange

Where sumInRange = Sum_C - (R - L + 1)

So, onesInRange + (R - L + 1) <= Sum_C - (R - L + 1)

Which simplifies to:

onesInRange + 2*(R - L + 1) <= Sum_C

Wait, but according to my earlier derivation, the condition should be 2 * onesInRange <= R - L + 1

So, there's a mismatch here.

Perhaps I need to think differently.

Let me consider that for the subarray to be good, the minimal sum of B should be less than or equal to Sum_C, and that the difference between Sum_C and sum_B_min should be less than or equal to the number of elements where B can be increased beyond minimal values.

Wait, perhaps I need to ensure that the difference between Sum_C and sum_B_min can be distributed among the elements where B[i] can be increased.

But this seems complicated.

Let me look at the example provided:

Input:

1

5 4

1 2 1 4 5

1 5

4 4

3 4

1 3

Output:

YES

NO

YES

NO

For the entire array 1 2 1 4 5, sum is 13.

Minimal B sum: (1-1) + (2-1) + (1-1) + (4-1) + (5-1) = 0 + 1 + 0 + 3 + 4 = 8

But sum_C is 13, which is greater than 8, so it's possible to adjust B to make sum(B) = 13.

Hence, YES.

For subarray 4 4: [4], sum_C = 4.

Minimal B sum: 4 - 1 = 3.

3 <= 4, but we need to check if we can adjust B to make sum(B) = 4.

Since there's only one element, B[4] must be 3, but 3 != 4, and 3 > 0.

But sum(B) = 3 != 4, so no adjustment can make it equal.

Hence, NO.

For subarray 3 4: [1,4], sum_C = 5.

Minimal B sum: (1+1) + (4-1) = 2 + 3 = 5.

Which equals sum_C, so YES.

For subarray 1 3: [1,2,1], sum_C = 4.

Minimal B sum: (1+1) + (2-1) + (1+1) = 2 + 1 + 2 = 5.

Wait, but according to the earlier formula, sum_B_min = Sum_C - (R - L + 1) + 2 * onesInRange.

For L=1, R=3:

Sum_C = 4

sum_B_min = 4 - 3 + 2*2 = 4 - 3 + 4 = 5

Which is greater than Sum_C, but according to the earlier condition, it should be sum_B_min <= Sum_C, which is 5 <= 4, which is false, so NO.

But in the code, they're checking onesInRange + (R - L + 1) <= sumInRange

Which is 2 + 3 <= 4 - 3 = 1

2 + 3 <= 1, which is false, so NO.

Hence, the code is consistent with the example.

But according to my earlier derivation, the condition should be 2 * onesInRange <= R - L + 1

For L=1, R=3:

2 * 2 <= 3 → 4 <= 3, which is false, so NO.

But in the code, they're checking onesInRange + (R - L + 1) <= sumInRange

Which is 2 + 3 <= 4 - 3 → 5 <= 1, which is false, so NO.

Both conditions seem to lead to the same conclusion in this case.

But according to my earlier derivation, the correct condition should be 2 * onesInRange <= R - L + 1

But in the code, they're checking onesInRange + (R - L + 1) <= sumInRange, which is equivalent to onesInRange + (R - L + 1) <= Sum_C - (R - L + 1)

Which simplifies to onesInRange + 2*(R - L + 1) <= Sum_C

But according to my derivation, it should be 2 * onesInRange <= R - L + 1

So, there's a discrepancy here.

Perhaps my derivation is incorrect.

Let me try to think differently.

Suppose I have a subarray from L to R.

Let me denote:

- k = number of ones in the subarray (onesInRange)

- m = length of the subarray (R - L + 1)

- S = sum of the subarray (Sum_C)

Now, the minimal sum of B is:

sum_B_min = sum_{i=L to R} (C[i] - 1 if C[i] > 1 else 2)

Which is sum_{i=L to R} (C[i] - 1) + 2 * number of C[i] == 1 - number of C[i] == 1

Wait, that seems off.

Wait, for C[i] > 1, B[i] = C[i] - 1

For C[i] == 1, B[i] = 2

So, sum_B_min = sum_{i=L to R} (C[i] - 1 if C[i] > 1 else 2)

Which is sum_{i=L to R} C[i] - number of C[i] > 1 + 2 * number of C[i] == 1

= S - (m - k) + 2k = S - m + 3k

Wait, m = number of elements, k = number of ones.

So, sum_B_min = S - m + 3k

Now, we need sum_B_min <= S, which simplifies to S - m + 3k <= S, which is -m + 3k <= 0, or 3k <= m.

But earlier I had 2k <= m.

Wait, perhaps I made a mistake.

Wait, sum_B_min = S - m + 3k

We need sum_B_min <= S, which is S - m + 3k <= S, which simplifies to -m + 3k <= 0, or 3k <= m.

But according to the code, they're checking k + m <= S - m, which is k + m <= S - m, or S >= k + 2m.

Wait, this is getting confusing.

Let me think about the necessary and sufficient condition for the subarray to be good.

We need to construct B such that:

- B[i] != C[i] for all i

- B[i] > 0

- sum(B) = sum(C[L..R])

Let me consider that for each C[i], B[i] can be any positive integer except C[i].

So, for each C[i], the possible values for B[i] are all positive integers except C[i].

To make sum(B) = sum(C[L..R]), we need to adjust B[i]s such that their sum equals sum(C[L..R]).

This is similar to finding a set of integers B[i] != C[i], B[i] > 0, such that their sum is sum(C[L..R]).

This seems like a classic problem of achieving a target sum with certain constraints on each term.

A standard approach is to find the minimal and maximal possible sums of B, and check if sum(C[L..R]) lies within that range.

But in this problem, since B[i] can be any positive integer except C[i], and we need sum(B) = sum(C[L..R]), we need to ensure that sum(C[L..R]) is achievable within the constraints.

However, in this problem, since B[i] can be any positive integer except C[i], and we can choose B[i] to be C[i]-1 or C[i]+1 or any other positive integer except C[i], the minimal sum of B is sum_{i=L to R} min(C[i]-1, C[i]+1), but since C[i]-1 could be less than 1 if C[i]=1, we have to set B[i]=2 when C[i]=1.

Hence, sum_B_min = sum_{i=L to R} (C[i]-1 if C[i]>1 else 2)

Similarly, there's