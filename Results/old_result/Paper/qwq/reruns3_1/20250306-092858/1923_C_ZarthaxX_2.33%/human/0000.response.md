Alright, I've got this problem to solve. Let's see what it's asking for. So, there's this concept of a "good" array, which is defined based on certain conditions involving another array. Let me try to wrap my head around it.

First, the problem defines an array `a` of length `m` as good if there exists another integer array `b` of the same length such that:

1. The sum of elements in `a` is equal to the sum of elements in `b`.

2. For every index `i`, `a_i` is not equal to `b_i`.

3. Every element in `b` is greater than 0.

So, given an array `c` of length `n`, and a set of queries, each query specifies a subarray of `c`, and I need to determine if that subarray is "good" based on the above conditions.

Alright, let's break this down. I need to find out for each query whether there exists an array `b` that satisfies those three conditions for the given subarray.

First, let's consider the sum condition. The sum of `a` should equal the sum of `b`. So, if I have a subarray `c[l_i]` to `c[r_i]`, which is my `a`, I need to find a `b` with the same sum.

Second, `a_i` should not equal `b_i` for any `i`. So, `b` must differ from `a` in every position.

Third, all elements in `b` must be positive integers greater than 0.

Okay, so how can I approach this? Maybe I can think about constructing such a `b` for a given `a`.

Let me consider a simple case. Suppose `a` has all elements greater than 1. Then, I can set `b_i = a_i - 1`, which is still positive since `a_i > 1`, and `b_i != a_i`. The sum of `b` would be the sum of `a` minus the number of elements, which is different from the sum of `a`. Hmm, that doesn't satisfy the first condition.

Wait, maybe I need to adjust `b` in a different way. Let's think about it differently. I need the sum of `b` to equal the sum of `a`, and `b_i != a_i` for all `i`, and `b_i > 0`.

One way to approach this is to try to minimize the changes I make to `a` to get `b`, while ensuring `b_i != a_i` and `b_i > 0`.

Let me consider that for each `a_i`, I can set `b_i` to be `a_i - 1` if `a_i - 1 > 0`, otherwise, I need to set `b_i` to some value greater than 0 and not equal to `a_i`.

Wait, but I need the sum to remain the same. So, if I decrease some `a_i` by 1, I need to increase others by some amount to compensate.

This seems tricky. Maybe there's a better way to look at it.

Let me consider the minimal possible `b` that satisfies the conditions. If I set `b_i = a_i - 1` for all `i` where `a_i > 1`, and for `a_i = 1`, I have to set `b_i` to something else greater than 0 and not equal to 1, say `b_i = 2`.

But then, the sum of `b` would be sum of `(a_i - 1)` for `a_i > 1` and `2` for `a_i = 1`.

Wait, let's formalize this.

Letâ€™s denote:

- Let `k` be the number of elements in `a` that are equal to 1.

- For these `k` elements, if I set `b_i = 2`, then each contributes `1` more to the sum compared to `a_i`.

- For the remaining `(m - k)` elements, where `a_i > 1`, if I set `b_i = a_i - 1`, then each contributes `1` less to the sum compared to `a_i`.

So, the total sum of `b` would be:

sum of `a` minus `(m - k)` plus `k`.

So, sum_b = sum_a - (m - k) + k = sum_a - m + 2k.

But I need sum_b to equal sum_a.

So, sum_a - m + 2k = sum_a.

Simplifying, -m + 2k = 0 => 2k = m => k = m / 2.

So, only if the number of 1's in `a` is exactly half the length of `a`, then sum_b equals sum_a.

Wait, that can't be right. Because in the example provided, that's not the case.

Wait, perhaps I made a mistake in calculating sum_b.

Let me recalculate.

For each `a_i = 1`, set `b_i = 2`, so b_i - a_i = 1.

For each `a_i > 1`, set `b_i = a_i - 1`, so b_i - a_i = -1.

Total difference: k * 1 + (m - k) * (-1) = k - (m - k) = 2k - m.

So, sum_b = sum_a + (2k - m).

I need sum_b = sum_a, so 2k - m = 0 => k = m / 2.

But in the example, this doesn't hold.

Wait, in the example:

Take subarray from l=1 to r=5: [1,2,1,4,5]. Here, m=5, k=2 (number of 1's). So, k=2, m=5, 2k - m = 4 - 5 = -1, which is not zero. But according to the output, it's YES.

Wait, so my earlier reasoning must be flawed.

Hmm.

Perhaps I need to adjust the values of `b_i` in a smarter way.

Let me think differently.

Suppose I set `b_i = a_i - 1` for all `a_i > 1`, and for `a_i = 1`, set `b_i = 2`.

Then, as calculated, sum_b = sum_a + (2k - m).

But I need sum_b = sum_a, so I need to adjust the `b_i` values to make up for the difference.

If sum_b = sum_a + (2k - m), and I need sum_b = sum_a, then I need to adjust the `b_i` values such that the total adjustment is -(2k - m).

So, I need to find a way to adjust the `b_i` values by some amounts to make the total sum adjust by -(2k - m).

But how?

Let's consider that for the elements where `a_i > 1`, I can choose `b_i` to be `a_i - 1` or `a_i + x`, where x is a positive integer.

Wait, but `b_i` must be positive and not equal to `a_i`.

So, for `a_i > 1`, I can set `b_i = a_i - 1` (if a_i - 1 >=1), or `b_i = a_i + x` for some x >=1.

Similarly, for `a_i =1`, `b_i` can be any integer >0 except 1.

Wait, but I need to make sure that `b_i >0` and `b_i != a_i`.

So, for `a_i =1`, `b_i` must be >=2.

For `a_i >1`, `b_i` can be anything >=1 except `a_i`.

So, I have some flexibility in choosing `b_i`.

Now, to make sum_b equal to sum_a, I need to adjust the `b_i` values such that the total adjustment cancels out the initial difference of (2k - m).

So, if sum_b = sum_a + (2k - m), I need to adjust sum_b by -(2k - m).

I can do this by adjusting some of the `b_i` values.

For example, for elements where `a_i >1`, instead of setting `b_i = a_i -1`, I can set `b_i = a_i -1 + y`, where y is a non-negative integer.

Similarly, for elements where `a_i =1`, instead of setting `b_i =2`, I can set `b_i =2 + z`, where z is a non-negative integer.

Then, the total adjustment would be the sum of y over all `a_i >1` and z over all `a_i =1`.

I need this total adjustment to be equal to -(2k - m).

But I need to ensure that all `b_i >0` and `b_i != a_i`.

Given that, I need to find non-negative integers y and z for the respective elements such that the total adjustment equals -(2k - m).

Wait, but I need to make sure that for each element, the adjustment doesn't violate the constraints.

This seems a bit complicated.

Maybe there's a better way to approach this.

Let me think about the necessary and sufficient conditions for the subarray to be "good".

From the earlier calculation, sum_b = sum_a + (2k - m), and I need sum_b = sum_a, so effectively, I need (2k - m) = 0, which implies k = m / 2.

But in the example, k=2 and m=5, which doesn't satisfy k=m/2, but the output is YES.

So, my earlier reasoning must be incorrect.

Perhaps I need to consider that I can adjust the `b_i` values beyond just `a_i -1` or `2`.

Wait, perhaps there's a different way to look at it.

Let me consider the difference between `b_i` and `a_i`.

We have `b_i - a_i` for each i.

The sum of these differences should be zero, since sum_b = sum_a.

Also, `b_i != a_i` for all i.

Moreover, `b_i >0` for all i.

So, I need to assign values to `b_i` such that:

- `b_i - a_i != 0` for all i.

- `b_i >0` for all i.

- The sum of `(b_i - a_i)` over all i is zero.

This seems like a problem of assigning non-zero adjustments to each `a_i`, with the constraints that `b_i >0`, and the total adjustment sums to zero.

This is similar to finding a set of integers y_i (where y_i = b_i - a_i), such that:

- y_i !=0 for all i.

- a_i + y_i >0 for all i.

- sum of y_i over all i is zero.

This seems familiar; it's akin to finding a flow that balances out.

But maybe there's a simpler way to check for the existence of such a `b`.

Let me consider the minimal and maximal possible sums for `b`.

Given that `b_i >0` and `b_i != a_i`, the minimal `b_i` for `a_i =1` is 2, and for `a_i >1`, it's either `a_i -1` (if `a_i -1 >=1`) or `a_i +1`.

Wait, for `a_i >1`, `b_i` can be `a_i -1` (if `a_i -1 >=1`), or `a_i +1`, or any other value >0 and != `a_i`.

Similarly, for `a_i =1`, `b_i` can be any integer >=2.

So, the minimal `b_i` for `a_i =1` is 2, and for `a_i >1` is `a_i -1` (if `a_i -1 >=1`), else `a_i +1`.

Wait, but `a_i >1`, so `a_i -1 >=1`, so minimal `b_i` is `a_i -1`.

Similarly, for `a_i =1`, minimal `b_i` is 2.

So, the minimal sum for `b` is sum of (`a_i -1` for `a_i >1`) and 2 for `a_i =1`.

As calculated earlier, this minimal sum is sum_a - (m - k) + 2k = sum_a + k - m.

I need sum_b = sum_a, so I need sum_b - sum_a =0.

But sum_b - sum_a = (sum_a + k - m) - sum_a = k - m.

So, k - m needs to be adjusted to zero.

Wait, that's similar to what I had earlier.

But in the example, k=2, m=5, so k - m = -3, which is not zero.

But the output is YES, meaning it's possible.

So, perhaps I need to adjust some `b_i` above their minimal values to make up for the difference.

In other words, if I set some `b_i` higher than their minimal values, I can increase sum_b to compensate for the difference.

So, the question is whether I can adjust the `b_i` values upwards enough to make sum_b equal to sum_a.

Given that I can set `b_i` to be as large as I want (as long as `b_i != a_i` and `b_i >0`), I can make sum_b as large as desired.

But in this case, since I need sum_b = sum_a, and the minimal sum_b is sum_a + k - m, I need to adjust sum_b by (sum_a - (sum_a + k - m)) = -(k - m).

So, I need to decrease sum_b by (k - m).

But in the example, k - m = -3, so I need to increase sum_b by 3 to make it equal to sum_a.

Wait, no.

Wait, k - m = -3, so sum_b - sum_a = -3.

I need sum_b - sum_a =0, so I need to adjust sum_b by +3.

But how?

Wait, in the earlier minimal sum_b, I have sum_b = sum_a + k - m = sum_a -3.

But I need sum_b = sum_a, so I need to increase sum_b by 3.

How can I do that?

I can increase some of the `b_i` values beyond their minimal values.

Each time I increase a `b_i` by 1, I increase sum_b by 1.

So, I need to increase sum_b by 3.

But I need to make sure that I don't violate the constraints.

For example, for `a_i =1`, `b_i` can be 2,3,4,... etc.

For `a_i >1`, `b_i` can be `a_i -1`, `a_i +1`, `a_i +2`, etc., as long as `b_i != a_i`.

So, I can increase `b_i` by any positive integer, as long as it doesn't equal `a_i`.

Therefore, in theory, I can increase sum_b by as much as needed.

But in practice, I need to make sure that I can reach the required sum.

In this case, I need to increase sum_b by 3.

But I need to ensure that I have enough "room" to do so.

Wait, but in the minimal sum_b, I already have sum_b = sum_a -3.

I can increase any of the `b_i` values beyond their minimal values to increase sum_b.

So, as long as I have at least 3 to distribute among the `b_i` values, I can make sum_b equal to sum_a.

But I need to make sure that I don't set `b_i` equal to `a_i` in the process.

Wait, but if I increase `b_i` beyond `a_i -1` or `a_i +1`, I can set `b_i` to any value as long as it's not equal to `a_i`.

So, in this case, it seems possible to increase sum_b by 3.

Therefore, the subarray is "good".

But wait, in the example, for l=1 to r=5, it's YES.

For l=4 to r=4, it's NO.

For l=3 to r=4, it's YES.

For l=1 to r=3, it's NO.

Looking at the subarrays:

[1,2,1,4,5]: k=2, m=5, sum_a=13, minimal sum_b=13 +2 -5=10.

Need to increase sum_b by 3 to make it 13.

Seems possible.

[4]: k=0, m=1, sum_a=4, minimal sum_b=4 +0 -1=3.

Need to increase sum_b by 1 to make it 4.

But m=1, so only one element.

Set b_i=4 is not allowed since b_i != a_i.

Set b_i=3 or b_i=5, etc.

But in this case, sum_b would be 3 or 5, not 4.

So, can't make sum_b equal to sum_a.

Hence, NO.

[1,4]: k=1, m=2, sum_a=5, minimal sum_b=5 +1 -2=4.

Need to increase sum_b by 1.

Can I do that?

Set b_i for a_i=1 to 2 (minimal), and for a_i=4 to 3.

Sum_b=2+3=5, which matches sum_a=5.

Yes, possible.

[1,2,1]: k=2, m=3, sum_a=4, minimal sum_b=4 +2 -3=3.

Need to increase sum_b by 1.

Set b_i for a_i=1 to 2, and for a_i=2 to 1.

Sum_b=2+1+2=5, which is more than sum_a=4.

Wait, but I need sum_b=4.

So, set b_i for a_i=1 to 2, and for a_i=2 to 1, and for a_i=1 to 2.

Sum_b=2+1+2=5, which is more than sum_a=4.

So, I need to adjust it to sum_b=4.

But I can't set any b_i lower than their minimal values.

Wait, maybe I need to set one b_i higher.

Wait, perhaps I need to set one b_i higher to compensate for the difference.

But in this case, I need to decrease sum_b by 1 to make it 4 from 5.

But I can't decrease any b_i below their minimal values.

So, it's impossible.

Hence, NO.

So, from this, it seems that the condition is:

If sum_a >= minimal sum_b + (number of elements where a_i >1), then it's possible.

Wait, in the first subarray, sum_a=13, minimal sum_b=10, and m -k=3.

sum_a >= minimal sum_b + (m -k), which is 10 +3=13, which holds.

In the second subarray, sum_a=4, minimal sum_b=3, m -k=1.

sum_a >= minimal sum_b + (m -k), which is 3 +1=4, which holds with equality.

In the third subarray, sum_a=5, minimal sum_b=4, m -k=1.

sum_a >= minimal sum_b + (m -k), which is 4 +1=5, holds with equality.

In the fourth subarray, sum_a=4, minimal sum_b=3, m -k=1.

sum_a >= minimal sum_b + (m -k), which is 3 +1=4, holds with equality.

But in the second subarray, it's NO, even though the condition holds.

Wait, perhaps I need to consider something else.

Wait, in the second subarray, m=2, k=1.

sum_a=3, minimal sum_b=3 +1 -2=2.

Need to increase sum_b by 1 to make it 3.

But in this case, set b_i for a_i=1 to 2, and for a_i=2 to 1.

Sum_b=2+1=3, which matches sum_a=3.

So, why is the output NO?

Wait, in the example, for l=4 to r=4, which is [4], it's NO.

Wait, perhaps I misread the queries.

Let me check the example again.

Input:

1

5 4

1 2 1 4 5

1 5

4 4

3 4

1 3

Output:

YES

NO

YES

NO

So, queries are:

1. l=1 to r=5: subarray [1,2,1,4,5]: YES

2. l=4 to r=4: subarray [4]: NO

3. l=3 to r=4: subarray [1,4]: YES

4. l=1 to r=3: subarray [1,2,1]: NO

So, in the second query, subarray [4], which is m=1, k=0 (since a_i=4 !=1).

minimal sum_b=4 +0 -1=3.

Need to increase sum_b by 1 to make it 4.

Set b_i=5, sum_b=5, which is more than sum_a=4.

But I can't set b_i=3, because 3 !=4 and >0.

But sum_b=3 !=4.

So, it's impossible.

Hence, NO.

In the fourth query, subarray [1,2,1], sum_a=4, minimal sum_b=3.

Set b_i for a_i=1 to 2, and for a_i=2 to 1, and for a_i=1 to 2.

Sum_b=2+1+2=5, which is more than sum_a=4.

But I can't set any b_i lower than their minimal values.

Hence, NO.

In the third query, subarray [1,4], sum_a=5, minimal sum_b=4.

Set b_i for a_i=1 to 2, and for a_i=4 to 3.

Sum_b=2+3=5, which matches sum_a=5.

Hence, YES.

In the first query, subarray [1,2,1,4,5], sum_a=13, minimal sum_b=10.

Need to increase sum_b by 3.

Can set some b_i higher to achieve sum_b=13.

Hence, YES.

So, from this, it seems that the condition is:

If sum_a >= minimal sum_b + (m - k), then it's possible.

In the first subarray, sum_a=13, minimal sum_b=10, m -k=3, 10 +3=13.

In the third subarray, sum_a=5, minimal sum_b=4, m -k=1, 4 +1=5.

In the fourth subarray, sum_a=4, minimal sum_b=3, m -k=1, 3 +1=4.

But in the second subarray, sum_a=4, minimal sum_b=3, m -k=1, 3 +1=4.

But in this case, m=1, which is a special case.

Wait, perhaps the condition needs to be adjusted for m=1.

Because when m=1, it's impossible to have sum_b = sum_a, since b_i != a_i.

Hence, for m=1, it's always NO, unless sum_a cannot be matched, which in this case, it's NO.

So, perhaps the general condition is:

If m >1 and sum_a >= minimal sum_b + (m - k), then YES, else NO.

But in the third subarray, m=2 >1, sum_a >= minimal sum_b + (m -k), which holds, hence YES.

In the fourth subarray, m=3 >1, sum_a >= minimal sum_b + (m -k), which holds, but output is NO.

Wait, perhaps I need to consider something else.

Wait, in the fourth subarray, [1,2,1], sum_a=4, minimal sum_b=3.

To make sum_b=4, I need to increase sum_b by 1.

But in this subarray, I have m=3, k=2.

sum_a >= minimal sum_b + (m -k) => 4 >= 3 +1 => 4 >=4, which holds.

But in practice, I can't achieve sum_b=4 because the minimal sum_b is 3, and increasing any b_i would make sum_b larger than 4, but I have m -k=1, which seems to indicate that I can adjust by 1.

But in reality, setting one b_i higher by 1 would make sum_b=4, but in this case, with m=3, k=2, I need to adjust by 1, but it's not possible.

Wait, perhaps I need to consider that the adjustment needs to be exactly equal to the difference, not just >=.

In other words, sum_a - minimal sum_b should be <= (m -k), and sum_a - minimal sum_b >=0.

Wait, in the first subarray, sum_a - minimal sum_b=13-10=3, and m -k=3, so 3 <=3.

In the third subarray, 5-4=1 <=1.

In the fourth subarray, 4-3=1 <=1.

But in the fourth subarray, it's NO.

So, perhaps there's another condition.

Wait, perhaps it's also necessary that sum_a - minimal sum_b is <= (m -k), and sum_a - minimal sum_b >=0.

In the fourth subarray, sum_a - minimal sum_b=1, and m -k=1, so 1<=1, but it's NO.

Hence, there must be another condition.

Wait, perhaps it's necessary that sum_a - minimal sum_b <= (m -k), and sum_a - minimal sum_b >= (something else).

Wait, maybe I need to consider that the difference must be <= (m -k), and >=0, and also that m >=2.

In the fourth subarray, m=3 >=2, sum_a - minimal sum_b=1 <= (m -k)=1, but it's NO.

So, perhaps there's an additional condition related to the number of ones.

Wait, perhaps it's necessary that sum_a - minimal sum_b <= (m -k), and sum_a - minimal sum_b >= (something positive based on k).

Wait, perhaps it's necessary that sum_a - minimal sum_b <= (m -k), and sum_a - minimal sum_b >= (m -k).

Wait, that would mean sum_a - minimal sum_b == (m -k).

In the first subarray, sum_a - minimal sum_b=3 == m -k=3.

In the third subarray, 5-4=1 == m -k=1.

In the fourth subarray, 4-3=1 == m -k=1, but it's NO.

Wait, but in the fourth subarray, it's NO.

So, perhaps there's another condition.

Wait, perhaps it's necessary that sum_a - minimal sum_b == (m -k), and m >=2.

In the first subarray, 3==3, m=5>=2, YES.

Third subarray, 1==1, m=2>=2, YES.

Fourth subarray, 1==1, m=3>=2, but NO.

Hmm.

Wait, perhaps it's necessary that sum_a - minimal sum_b == (m -k), and that k >= (something).

Wait, perhaps k >=1.

In the fourth subarray, k=2 >=1, but it's NO.

Wait, perhaps there's a condition on the values in the array.

Wait, maybe I need to consider that for the subarray to be "good", it must satisfy sum_a - minimal sum_b == (m -k), and m >=2, and that there exists at least one element a_i >1.

Wait, in the fourth subarray, m=3, k=2, sum_a - minimal sum_b=1 == m -k=1.

But there is one element a_i=2 >1.

So, that shouldn't be the condition.

Wait, perhaps it's necessary that sum_a - minimal sum_b == (m -k), and m >=2, and that k < m.

In the fourth subarray, k=2 < m=3, but it's NO.

So, that's not it.

Wait, perhaps it's necessary that sum_a - minimal sum_b == (m -k), and m >=2, and that sum_a - minimal sum_b <= (something related to k).

Wait, perhaps sum_a - minimal sum_b <= (m -k), and >=0, and m >=2.

In the fourth subarray, sum_a - minimal sum_b=1 <= m -k=1, and m >=2, but it's NO.

So, perhaps there's another condition.

Wait, maybe I need to consider that the difference sum_a - minimal sum_b must be less than or equal to the number of elements where a_i >1.

In the fourth subarray, number of elements where a_i >1 is m -k=1, sum_a - minimal sum_b=1 <=1, but it's NO.

Wait, but in the first subarray, m -k=3, sum_a - minimal sum_b=3 <=3, YES.

In the third subarray, m -k=1, sum_a - minimal sum_b=1 <=1, YES.

In the fourth subarray, m -k=1, sum_a - minimal sum_b=1 <=1, NO.

So, perhaps there's an additional condition.

Wait, perhaps it's necessary that sum_a - minimal sum_b <= (m -k), and that k <= (m -1).

In the fourth subarray, k=2 <= m -1=2, but it's NO.

So, that's not it.

Wait, perhaps it's necessary that sum_a - minimal sum_b <= (m -k), and that k < (m -k).

Wait, in the fourth subarray, k=2 < m -k=1? No, 2 >1.

Wait, that would be k < (m -k), which is 2 <1, which is not true.

So, in that case, it's NO.

Wait, that might be it.

Perhaps it's necessary that sum_a - minimal sum_b <= (m -k), and k <= (m -k).

In the first subarray, k=2 <= m -k=3, YES.

Third subarray, k=1 <= m -k=1, YES.

Fourth subarray, k=2 > m -k=1, NO.

Yes, that seems to make sense.

So, the condition for the subarray to be "good" is:

- m >=2

- sum_a - minimal sum_b <= (m -k)

- k <= (m -k)

In the first subarray, m=5 >=2, sum_a - minimal sum_b=3 <=3, and k=2 <=3.

YES.

Third subarray, m=2 >=2, sum_a - minimal sum_b=1 <=1, and k=1 <=1.

YES.

Fourth subarray, m=3 >=2, sum_a - minimal sum_b=1 <=1, but k=2 > m -k=1.

NO.

Second subarray, m=1, which is <2, so NO.

Hence, the condition is:

If m >=2, and sum_a - minimal sum_b <= (m -k), and k <= (m -k), then YES, else NO.

In terms of the variables, minimal sum_b = sum_a + k - m.

So, sum_a - minimal sum_b = sum_a - (sum_a + k - m) = -k + m.

So, sum_a - minimal sum_b = m - k.

Therefore, sum_a - minimal sum_b <= m - k is always true, since m - k = m - k.

So, that condition always holds.

Wait, that can't be right.

Wait, sum_a - minimal sum_b = m - k.

So, sum_a - (sum_a + k - m) = -k + m.

So, sum_a - minimal sum_b = m - k.

Therefore, sum_a - minimal sum_b <= m - k is equivalent to m - k <= m - k, which is always true.

Hence, the condition sum_a - minimal sum_b <= m - k is always satisfied.

So, the only additional condition is that k <= m -k, which is k <= floor(m /2).

Therefore, the subarray is "good" if:

- m >=2

- k <= floor(m /2)

Otherwise, NO.

In the first subarray, m=5, floor(5/2)=2, k=2 <=2, YES.

Third subarray, m=2, floor(2/2)=1, k=1 <=1, YES.

Fourth subarray, m=3, floor(3/2)=1, k=2 >1, NO.

Second subarray, m=1, which is <2, NO.

Hence, the condition simplifies to:

If m >=2 and k <= floor(m /2), then YES, else NO.

This seems to fit the example.

So, in code, for each query, I need to check:

- If m <2, then NO.

- Else, compute k (number of 1's in the subarray).

- If k <= floor(m /2), then YES, else NO.

This seems much simpler than I was making it.

I need to compute for each query, the number of 1's in the subarray from l to r.

And check if the number of 1's <= floor((r -l +1)/2).

If yes, then YES, else NO.

Except when m=1, always NO.

Wait, but in the third subarray, m=2, floor(2/2)=1, k=1 <=1, YES.

First subarray, m=5, floor(5/2)=2, k=2 <=2, YES.

Fourth subarray, m=3, floor(3/2)=1, k=2 >1, NO.

Second subarray, m=1, always NO.

Hence, this seems correct.

Therefore, the program needs to:

- For each test case, read n and q.

- Read the array c of length n.

- For each query, read l and r (1-based indices).

- Compute m = r - l +1.

- If m <2, then NO.

- Else, compute k = number of 1's in c[l-1] to c[r-1] (0-based indexing).

- If k <= floor(m /2), then YES, else NO.

Now, given that n and q can be up to 3e5, and t up to 1e4, but sum of n and q over all test cases doesn't exceed 3e5, I need an efficient way to compute the number of 1's in the subarray for each query.

To do this efficiently, I can precompute a prefix sum array for the number of 1's up to each index.

So, ones[i] = number of 1's in c[0 to i-1].

Then, for a query from l to r, number of 1's is ones[r] - ones[l-1].

Similarly, I can precompute the prefix sum of the array values.

But in this problem, I only need the count of 1's, and the length of the subarray, which I can compute as m = r -l +1.

Hence, I don't need the sum of the subarray, just the count of 1's and the length.

Looking at the provided code:

It seems to be implementing something similar.

Let me analyze it.

The function `func_1` is defined to handle each test case.

It reads n and q, then reads the array nums.

Then, it initializes two arrays: ones and sum, both of size n+1.

It populates ones with the cumulative count of 1's up to each index.

And sum with the cumulative sum of (nums[i] -1).

Wait, sum[i] = sum[i-1] + nums[i-1] -1.

Then, for each query, it reads l and r (1-based), computes onesInRange = ones[r] - ones[l-1], which is correct for the count of 1's in the subarray.

sumInRange = sum[r] - sum[l-1], which is the sum of (nums[i] -1) for i from l-1 to r-1.

Wait, but in the earlier analysis, I didn't need the sum of nums, just the count of 1's and the length of the subarray.

In the earlier simplified condition, I only needed m and k.

But in the code, it's checking some condition involving sumInRange and onesInRange.

Specifically, it's checking if 2 * onesInRange + (r - l +1) - onesInRange <= sumInRange.

Simplify the left side: 2*k + m -k = k + m.

So, it's checking if k + m <= sumInRange.

But sumInRange is sum of (nums[i] -1) from l to r.

Wait, sum of (nums[i] -1) is sum(nums[l-1 to r-1]) - (r -l +1).

So, sumInRange = sum(nums[l-1 to r-1]) - (r -l +1).

So, the condition is k + m <= sum(nums[l-1 to r-1]) - (r -l +1).

But m = r -l +1, so it's k + (r -l +1) <= sum(nums[l-1 to r-1]) - (r -l +1).

Which simplifies to k + m <= sum(nums[l-1 to r-1]) - m.

Which further simplifies to k + 2m <= sum(nums[l-1 to r-1]).

But in my earlier analysis, I only needed to check k <= floor(m /2), provided m >=2.

This seems different.

So, perhaps the condition in the code is more precise.

But based on my analysis, it seems that the condition should be m >=2 and k <= floor(m /2).

But maybe I missed something.

Let me consider some examples.

Take the first subarray [1,2,1,4,5]:

m=5, k=2.

sum(nums)=13.

sum(nums) - m =13 -5=8.

Condition: k + m <= sum(nums) -m => 2 +5 <=13 -5 =>7 <=8, which holds.

Hence, YES.

Third subarray [1,4]:

m=2, k=1.

sum(nums)=5.

sum(nums) -m=5-2=3.

Condition:1 +2 <=5 -2 =>3 <=3, holds. YES.

Fourth subarray [1,2,1]:

m=3, k=2.

sum(nums)=4.

