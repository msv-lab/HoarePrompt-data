Alright, I've got this problem to solve. Let's see what it's asking for. So, Monocarp wants to throw a party and invite some of his friends, but there are some conditions. He has n friends, and each friend has a best friend, which is specified by p_i. The key points are:

1. All p_i are distinct and p_i ≠ i. So, no one is their own best friend, and everyone has a unique best friend.

2. For a friend to come to the party, both the friend and their best friend must receive an invitation.

3. Monocarp wants at least 2 friends to come to the party.

4. He needs to send the minimum number of invitations to achieve this.

My task is to determine the minimum number of invitations needed for each test case.

First, I need to understand the relationship between the friends and their best friends. Since p_i is the best friend of friend i, and all p_i are distinct, this forms a permutation of the friends. In other words, it's like matching each friend to another unique friend as their best friend.

Given that, I can think of this as a graph where friends are nodes, and there's an edge between two friends if they are each other's best friends. Since p_i is the best friend of i, and p_{p_i} should be i (because best friends are mutual), this means the graph consists of cycles and possibly some paths.

Wait, actually, since p_i is the best friend of i, and p_{p_i} should be i, this means that the relationship is symmetric. So, the graph should consist of cycles where each cycle is of even length because the relationships are pairwise.

But hold on, in the example given:

n = 5

p = [3, 1, 2, 5, 4]

So, friend 1's best friend is 3, friend 2's best friend is 1, friend 3's best friend is 2, friend 4's best friend is 5, and friend 5's best friend is 4.

This forms two cycles: 1-3-2-1 and 4-5-4.

Wait, actually, 1 is connected to 3, 3 is connected to 2, and 2 is connected to 1, which seems like a cycle of length 3. But according to the problem, all p_i are distinct and p_i ≠ i, and all p_i are distinct, so this should not happen. Wait, in this cycle, 1 -> 3 -> 2 -> 1, which is a cycle of length 3, but the problem says that all p_i are distinct, which is true here, and p_i ≠ i, which is also true.

But in general, does this mean that cycles can be of any length, or only even lengths? Wait, in the example, we have a cycle of length 3, which is odd.

Wait, but in the problem statement, it says that all p_i are distinct and p_i ≠ i. So, this can form cycles of any length, not necessarily even.

Wait, but in the example, p = [3,1,2,5,4], so friend 1's best friend is 3, friend 3's best friend is 2, and friend 2's best friend is 1, forming a cycle of length 3. Friend 4's best friend is 5, and friend 5's best friend is 4, forming a cycle of length 2.

So, cycles can be of any length, not necessarily even.

Now, the condition for a friend to come to the party is that both the friend and their best friend receive an invitation. So, for friend i to come, both i and p_i must receive invitations.

But note that friend i coming to the party only requires that i and p_i receive invitations, regardless of whether p_i comes or not. So, it's possible that some friends come to the party without their best friends coming, as long as both received invitations.

Wait, but the problem says: "the i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation". So, it's sufficient for both to receive invitations for friend i to come, but it's not necessary for p_i to come to the party, just that p_i received an invitation.

So, in other words, for friend i to attend, both i and p_i must be invited, but p_i may or may not attend, depending on whether p_i and p_{p_i} are invited.

Wait, but p_{p_i} is i, since p_i is the best friend of i, so p_{p_i} = i.

So, for p_i to attend, both p_i and i must be invited.

So, in summary, for friend i to attend, both i and p_i must be invited, and similarly for p_i to attend, both p_i and i must be invited.

So, in essence, if you invite both i and p_i, then both will attend, provided that their best friends are invited, which in this case, since p_i is invited, and p_{p_i} = i is invited, so both will attend.

Wait, but actually, the condition is only about receiving invitations, not about whether their best friends are attending.

Wait, re-reading the problem: "the i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation".

So, it's only about receiving invitations, not about whether their best friends are attending.

So, if both i and p_i are invited, then i will come, regardless of whether p_i comes or not.

Wait, but p_i will come if both p_i and p_{p_i} are invited, which is p_i and i are invited.

So, in this case, if you invite both i and p_i, then both will come.

But in the example, when invitations are sent to friends [1,2,4,5], friends [2,4,5] come.

Wait, friend 1 is invited, and their best friend is 3, who is not invited, so friend 1 does not come.

Friend 2 is invited, and their best friend is 1, who is invited, so friend 2 comes.

Friend 4 is invited, and their best friend is 5, who is invited, so friend 4 comes.

Friend 5 is invited, and their best friend is 4, who is invited, so friend 5 comes.

But according to the example, friends [2,4,5] come to the party.

Wait, but according to my reasoning, friends 2,4,5 should come, which matches the example.

So, in this case, sending invitations to [1,2,4,5], friends 2,4,5 come.

Now, the task is to find the minimum number of invitations such that at least 2 friends come.

So, I need to select a subset of friends to invite, and the number of friends who will come is the number of friends i for which both i and p_i are invited.

And I need at least 2 friends to come, and I need to minimize the number of invitations.

So, this seems like an optimization problem.

I need to minimize the number of invitations, subject to at least 2 friends coming.

I need to find the smallest subset S of friends to invite, such that the number of friends i in S where both i and p_i are in S, is at least 2.

Wait, more precisely, the number of friends i for which both i and p_i are in S, should be at least 2.

So, I need to maximize the number of such pairs, while minimizing the size of S.

This seems similar to covering problems in graph theory.

Given that the relationships form a graph where edges connect friends and their best friends, and I need to select a subset of nodes (friends to invite) such that at least 2 edges are "covered" in the sense that both endpoints are in S.

But considering that the graph is made up of disjoint cycles and paths, but given that p_i is the best friend of i and p_{p_i} = i, it's actually a matching, meaning the graph consists of disjoint cycles and paths of length 2.

Wait, actually, since p_i is the best friend of i and p_{p_i} = i, it's a perfect matching, so the graph consists of disjoint edges (since cycles would require more than 2 steps to return).

Wait, in the first example, there's a cycle of length 3, which seems to contradict this.

Wait, no, in the first example, p = [3,1,2,5,4], so friend 1's best friend is 3, friend 3's best friend is 2, and friend 2's best friend is 1, forming a cycle of length 3.

Similarly, friends 4 and 5 form a cycle of length 2.

So, cycles can be of any length, not just even lengths.

Wait, but in this case, p_{p_i} = i, which should hold for all i, but in the cycle of length 3, p_{p_1} = p_3 = 2, which is not equal to 1.

Wait, that seems inconsistent.

Wait, no, in the first example, p = [3,1,2,5,4], so:

- p_1 = 3

- p_2 = 1

- p_3 = 2

- p_4 = 5

- p_5 = 4

So, p_{p_1} = p_3 = 2, which is not equal to 1.

Wait, but according to the problem, p_{p_i} should be i, since p_i is the best friend of i, and p_i's best friend should be i.

Wait, but in this example, p_{p_1} = p_3 = 2 ≠ 1.

Is this a mistake in the example or in my understanding?

Wait, perhaps the problem doesn't enforce that p_{p_i} = i. Maybe it's possible that p_{p_i} ≠ i.

Wait, re-reading the problem: "all p_i are distinct, and for every i ∈ [1,n], p_i ≠ i."

It doesn't say that p_{p_i} = i.

So, perhaps p_i is just the best friend of i, without the necessity that p_{p_i} = i.

But in the example, it seems that p_{p_i} = i, but maybe it's not always the case.

Wait, perhaps I misread that.

Looking back, the problem says: "the i-th friend's best friend is p_i. All p_i are distinct, and for every i ∈ [1,n], p_i ≠ i."

It doesn't say that the best friend of p_i is i.

So, perhaps the best friend relationship isn't necessarily mutual.

Wait, but in the example, p = [3,1,2,5,4], so friend 1's best friend is 3, friend 2's best friend is 1, friend 3's best friend is 2, friend 4's best friend is 5, and friend 5's best friend is 4.

So, in this case, friends 1,2,3 form a cycle of length 3, and friends 4 and 5 form a cycle of length 2.

But in general, p_{p_i} doesn't have to be i.

Wait, but in the problem statement, it says "all p_i are distinct, and for every i ∈ [1,n], p_i ≠ i."

So, p_i is just a permutation of [1,n] without fixed points.

Wait, but in the example, p = [3,1,2,5,4], which is a permutation of [1,2,3,4,5], with no fixed points.

But p_{p_1} = p_3 = 2 ≠ 1.

So, it's possible that p_{p_i} ≠ i.

Therefore, the best friend relationship isn't necessarily mutual.

Wait, but in the example, friend 1's best friend is 3, and friend 3's best friend is 2, who is not 1.

So, best friends aren't necessarily mutual.

Therefore, the graph can have cycles of any length, not just even lengths.

So, in terms of graph theory, this is a directed graph where each node has out-degree 1, and in-degree possibly more than 1.

Wait, actually, since p_i is the best friend of i, and p_i is unique for each i, and p_i ≠ i, it's a permutation without fixed points.

So, in graph terms, it's a directed graph where each node has exactly one outgoing edge to another node, and no self-loops.

Therefore, the graph consists of disjoint cycles.

In the first example, there's a cycle of length 3 (1->3->2->1) and a cycle of length 2 (4->5->4).

So, in general, the graph is a disjoint union of cycles.

Wait, but in the problem, p_i is just the best friend of i, and there's no requirement that p_{p_i} = i.

But in practice, since p_i is a permutation without fixed points, the graph is indeed a disjoint union of cycles.

In the first example, the cycles are 1->3->2->1 and 4->5->4.

So, in general, cycles can be of any length.

Now, the condition for friend i to come to the party is that both i and p_i are invited.

So, for each friend i in S (the set of invited friends), if p_i is also in S, then friend i comes to the party.

Our goal is to choose S such that at least 2 friends come to the party, and |S| is minimized.

So, for each cycle, how do we choose S to minimize |S| while maximizing the number of friends who come?

Let's consider a cycle of length k.

Suppose we have a cycle: i1 -> i2 -> ... -> ik -> i1.

We need to choose a subset S of these friends to invite, such that as many friends as possible come, given that a friend comes only if both they and their best friend are in S.

In other words, for each friend in the cycle, if both they and their best friend are in S, they come.

Our aim is to have at least 2 friends coming from the entire set, with minimal S.

First, consider a cycle of length 2: a->b->a.

In this case, if we invite both a and b, then both come, so total of 2 friends coming, with 2 invitations.

If we invite only one of them, say a, then neither comes, because b is not invited.

So, for a cycle of length 2, to have at least 2 friends come, we need to invite both, totaling 2 invitations.

Now, consider a cycle of length 3: a->b->c->a.

If we invite a and b, then:

- a's best friend is b, who is invited, so a comes.

- b's best friend is c, who is not invited, so b does not come.

- c's best friend is a, who is invited, but c is not invited, so c does not come.

So, only a comes, which is less than 2.

If we invite a and c:

- a's best friend is b, who is not invited, so a does not come.

- c's best friend is a, who is invited, but c is invited, so c comes.

- b's best friend is c, who is invited, but b is not invited, so b does not come.

So, only c comes, which is less than 2.

If we invite b and c:

- b's best friend is c, who is invited, so b comes.

- c's best friend is a, who is invited, so c comes.

- a's best friend is b, who is invited, so a comes.

Wait, but a is not invited, so a does not come.

Wait, no, a's best friend b is invited, but a is not invited, so a does not come.

So, only b and c come, which is 2 friends, with 2 invitations.

Wait, but in this case, inviting b and c makes both b and c come, since both and their best friends are invited.

Wait, b's best friend is c, who is invited, and c's best friend is a, who is invited, but a is not invited, so a does not come.

Wait, but since a is not invited, c's best friend is invited, but c is invited, so c comes.

Similarly, b's best friend c is invited, and b is invited, so b comes.

So, both b and c come, which is at least 2 friends, with only 2 invitations.

So, in a cycle of length 3, inviting 2 friends is sufficient to have at least 2 friends come.

Similarly, in a cycle of length 2, inviting 2 friends is necessary to have at least 2 friends come.

So, in general, for any cycle of length k ≥ 2, inviting k friends in such a way that at least 2 friends come seems achievable with k invitations, but perhaps with fewer.

Wait, in the cycle of length 3, inviting 2 friends was sufficient to have 2 friends come.

Is there a cycle where inviting 2 friends doesn't lead to at least 2 friends coming?

In the cycle of length 2, inviting only 1 friend doesn't lead to any friends coming, as both need to be invited for both to come.

In the cycle of length 3, inviting 2 friends leads to 2 friends coming.

In a cycle of length 4: a->b->c->d->a.

If we invite a and b:

- a's best friend is b, who is invited, so a comes.

- b's best friend is c, who is not invited, so b does not come.

- c's best friend is d, who is not invited, so c does not come.

- d's best friend is a, who is invited, but d is not invited, so d does not come.

So, only a comes, which is less than 2.

If we invite a and c:

- a's best friend is b, who is not invited, so a does not come.

- c's best friend is d, who is not invited, so c does not come.

- b's best friend is c, who is invited, but b is not invited, so b does not come.

- d's best friend is a, who is invited, but d is not invited, so d does not come.

So, no one comes.

If we invite a, b, and c:

- a's best friend is b, who is invited, so a comes.

- b's best friend is c, who is invited, so b comes.

- c's best friend is d, who is not invited, so c does not come.

- d's best friend is a, who is invited, but d is not invited, so d does not come.

So, a and b come, which is at least 2 friends, with 3 invitations.

Alternatively, inviting a, d:

- a's best friend is b, who is not invited, so a does not come.

- d's best friend is a, who is invited, but d is invited, so d comes.

- b's best friend is c, who is not invited, so b does not come.

- c's best friend is d, who is invited, but c is not invited, so c does not come.

So, only d comes, which is less than 2.

Inviting a, c, d:

- a's best friend is b, who is not invited, so a does not come.

- c's best friend is d, who is invited, so c comes.

- d's best friend is a, who is invited, so d comes.

- b's best friend is c, who is invited, but b is not invited, so b does not come.

So, c and d come, which is at least 2 friends, with 3 invitations.

So, in a cycle of length 4, inviting 3 friends is sufficient to have at least 2 friends come.

Is there a way to have at least 2 friends come with only 2 invitations?

From above, no, because any pair of invitations results in at most 1 friend coming.

Therefore, for cycle lengths ≥3, inviting 2 friends can sometimes be sufficient to have at least 2 friends come, but for cycle lengths =2, inviting 2 friends is necessary.

In the case of multiple cycles, we need to consider the combined effect.

For example, if there are two separate cycles: one of length 2 and one of length 3.

In the first test case, n=5, p=[3,1,2,5,4], which is cycles 1-3-2 and 4-5.

To have at least 2 friends come, we can invite 2 friends from the cycle of length 3, resulting in 2 friends coming, or invite 2 friends from the cycle of length 2, resulting in 2 friends coming.

Alternatively, inviting 1 friend from each cycle won't lead to at least 2 friends coming.

Wait, let's see:

Invite friend 1 and friend 4:

- Friend 1's best friend is 3, who is not invited, so friend 1 does not come.

- Friend 4's best friend is 5, who is invited, so friend 4 comes.

- Friend 3's best friend is 2, who is not invited, so friend 3 does not come.

- Friend 5's best friend is 4, who is invited, so friend 5 comes.

- Friend 2's best friend is 1, who is invited, but friend 2 is not invited, so friend 2 does not come.

So, friends 4 and 5 come, which is at least 2 friends, with only 2 invitations.

Wait, but in this case, inviting friends 4 and 5 results in both coming, which is at least 2 friends.

But according to the program, it prints 2 for this test case.

Wait, but in the example, Monocarp sends invitations to friends [1,2,4,5], and friends [2,4,5] come.

But according to my above reasoning, inviting only friends 4 and 5 would result in both coming, which satisfies the condition.

So, why doesn't the program reflect that?

Looking at the program:

def func():

for _ in range(int(input())):

n = int(input())

l = list(map(int, input().split()))

i = 0

j = 0

while i <= n - 1:

if l[i] == i + 2 and l[i + 1] == i + 1:

print(2)

j = 1

break

i += 1

if j == 0:

print(3)

So, the program iterates through the list l, and checks if there exists consecutive pairs where l[i] == i + 2 and l[i + 1] == i + 1.

If such a pair is found, it prints 2 and breaks.

Otherwise, it prints 3.

But in the first test case:

n=5

p=[3,1,2,5,4]

So, l = [3,1,2,5,4]

Iterate i from 0 to 3:

i=0: l[0]==2 (which is 3 != 2) and l[1]==1 (which is 1==1). Doesn't satisfy both conditions.

i=1: l[1]==2 (which is 1 != 2) and l[2]==3 (which is 2 == 2). Doesn't satisfy both.

i=2: l[2]==3 (which is 2 != 3) and l[3]==4 (which is 5 == 4?). No.

i=3: l[3]==4 (which is 5 != 4) and l[4]==5 (which is 4 == 5?). No.

So, j remains 0, and it prints 3.

But according to the example, sending invitations to [1,2,4,5] results in [2,4,5] coming, which is at least 2 friends, with 4 invitations.

But actually, sending invitations to only [4,5] would result in [4,5] coming, which is at least 2 friends.

So, the minimal number of invitations should be 2.

But the program prints 3.

So, in this case, the program is incorrect.

Wait, but according to the example output, it's 2 for this test case.

So, perhaps the program is incorrect.

Wait, perhaps I misread the program.

Looking again:

The program checks if l[i] == i + 2 and l[i + 1] == i + 1.

In the first test case, l=[3,1,2,5,4]

For i=0: l[0]=3 != 0+2=2, and l[1]=1 == 1.

Doesn't satisfy both.

i=1: l[1]=1 != 1+2=3, and l[2]=2 == 3? No.

i=2: l[2]=2 != 2+2=4, and l[3]=5 == 4? No.

i=3: l[3]=5 != 3+2=5, and l[4]=4 == 5? No.

So, j remains 0, and it prints 3.

But according to the example, the minimal number is 2.

So, the program is incorrect.

Wait, perhaps the program is trying to check for cycles of length 2.

Wait, perhaps the author assumed that all cycles are of length 2.

But in the first test case, there's a cycle of length 3 and a cycle of length 2.

So, perhaps the program is incorrect.

Looking at the second test case:

n=4

p=[2,3,4,1]

So, l=[2,3,4,1]

Iterate i from 0 to 2:

i=0: l[0]=2 == 0+2=2, and l[1]=3 == 1+1=2? 3 != 2. Doesn't satisfy.

i=1: l[1]=3 ==1+2=3, and l[2]=4 ==2+1=3? 4 !=3. No.

i=2: l[2]=4 ==2+2=4, and l[3]=1 ==3+1=4? 1 !=4. No.

So, j remains 0, and it prints 3.

But according to the example, the minimal number is 3.

So, in this case, it's correct.

Third test case:

n=2

p=[2,1]

l=[2,1]

i=0: l[0]=2 ==0+2=2, and l[1]=1 ==1+1=2? 1 !=2. No.

So, prints 3.

But according to the example, the minimal number is 2.

So, again, incorrect.

Hence, the program is incorrect.

So, Correctness: **False**

**Final Answer**

\[ \boxed{\text{False}} \]