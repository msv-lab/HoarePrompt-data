Alright, I've got this problem here. Let's see what it's asking for. So, there are n containers of water, each containing a certain amount of water. The sum of all the water in these containers is divisible by n, which means that theoretically, we can distribute the water equally among all containers. The question is whether it's possible to achieve this equal distribution by only pouring water from a container with a lower index to one with a higher index.

First, I need to understand the constraints and what operations are allowed. The operations allowed are pouring any amount of water from container i to container j, but only if i < j. That means we can only pour water forward in the sequence, not backward. Each container can be involved in multiple operations as either a source or a destination.

Given that the total sum is divisible by n, the target amount of water in each container is sum/n, which is an integer because the sum is divisible by n.

So, my goal is to check if it's possible to make each container have exactly sum/n units of water by only pouring water forward.

Let's think about this step by step.

First, I'll calculate the target amount, which is sum/n.

Then, I need to check if it's possible to adjust each container to have this target amount by only pouring water from left to right.

One way to approach this is to keep track of the cumulative difference from the target as I go through the containers from left to right.

Let's define the difference for each container as the current amount minus the target amount.

If I'm at container i, and the difference is positive, that means it has extra water that can be poured into future containers. If the difference is negative, it needs water from previous containers.

But wait, since I can only pour water from lower index to higher index, I can't pour from a future container backward. So, for each container, if it needs water, it can only receive it from the containers before it, provided those containers have extra water to give.

This sounds like I need to accumulate the excess water from previous containers and use it to fill the deficit in the current container.

Let me try to formalize this.

I'll initialize a variable, say, "carry", which represents the excess water available from previous containers that can be used to fill the current container.

I'll iterate through the containers from left to right.

For each container:

Calculate the difference: current amount - target.

If the difference is positive, it means this container has excess water, so add this excess to "carry".

If the difference is negative, it means this container needs water. Check if "carry" has enough water to fill this deficit. If carry + difference >= 0, then it's possible to fill this container by pouring from previous containers. Update carry by subtracting the amount used to fill this container. If carry + difference < 0, it's impossible to fill this container with the available excess from previous containers, so return 'NO'.

Wait, but the problem allows pouring only from lower to higher index, so I can't pour from future containers to previous ones. So, for each container, if it needs water, it can only receive it from the containers before it.

This seems correct.

Let me think about an example.

Take the third test case from the example:

n = 5

a = [4, 5, 2, 1, 3]

sum = 4 + 5 + 2 + 1 + 3 = 15

target = 15 / 5 = 3

So, differences:

4 - 3 = 1 (excess)

5 - 3 = 2 (excess)

2 - 3 = -1 (needs 1)

1 - 3 = -2 (needs 2)

3 - 3 = 0 (no excess or need)

So, initialize carry = 0

Iterate through:

i=0: 4 - 3 = 1, carry += 1 => carry = 1

i=1: 5 - 3 = 2, carry += 2 => carry = 3

i=2: 2 - 3 = -1, carry += (-1) => carry = 2 (still non-negative)

i=3: 1 - 3 = -2, carry += (-2) => carry = 0 (2 - 2 = 0)

i=4: 3 - 3 = 0, carry += 0 => carry = 0

Since carry never goes negative, it's possible to equalize the water levels by pouring from earlier containers to later ones.

Another example:

n=3

a=[1,2,3]

sum=6, target=2

differences:

1 - 2 = -1

2 - 2 = 0

3 - 2 = 1

Initialize carry=0

i=0: -1, carry += (-1) => carry = -1 < 0 => impossible, return 'NO'

This matches the third test case in the example.

Another example from the input:

n=2

a=[1,3]

sum=4, target=2

differences:

1 - 2 = -1

3 - 2 = 1

Initialize carry=0

i=0: -1, carry += (-1) => carry = -1 < 0 => 'NO'

Which matches the second test case.

One more:

n=7

a=[6,5,5,1,3,4,4]

sum=28, target=4

differences:

6-4=2

5-4=1

5-4=1

1-4=-3

3-4=-1

4-4=0

4-4=0

Initialize carry=0

i=0: 2, carry += 2 => carry=2

i=1: 1, carry +=1 => carry=3

i=2:1, carry +=1 => carry=4

i=3:-3, carry += (-3) => carry=1

i=4:-1, carry += (-1) => carry=0

i=5:0, carry +=0 => carry=0

i=6:0, carry +=0 => carry=0

carry never goes negative, so 'YES'

But according to the example, the output is 'YES' for this case.

Seems consistent.

Wait, but in the problem statement, it says:

"It is guaranteed that the sum of a_i in each test case does not exceed 2 \cdot 10^9 . Also, the sum of a_i is divisible by n ."

So, I don't need to worry about the sum not being divisible by n.

In the code provided, there's a check for sum % n != 0, but according to the problem, it's guaranteed that sum is divisible by n, so this check is unnecessary.

So, in the function func_1, it calculates the sum and checks if sum % n != 0, but as per the problem, this will always be false. So, this check is redundant.

However, since the problem guarantees that sum is divisible by n, I can safely remove this check.

So, the function can be simplified to:

def func_1(nums):

n = len(nums)

total = sum(nums)

mean = total // n

curr = 0

for i in range(n):

curr += nums[i] - mean

if curr < 0:

return 'NO'

return 'YES'

This seems correct based on my earlier reasoning.

Let me verify with the example where it should return 'NO'.

Take n=2, a=[1,3]

mean=2

curr starts at 0

i=0: curr += 1-2 = -1 < 0 => return 'NO'

Correct.

Another 'NO' case: n=3, a=[1,2,3]

mean=2

curr starts at 0

i=0: curr +=1-2=-1 <0 => 'NO'

Correct.

A 'YES' case: n=1, a=[43]

mean=43

curr +=43-43=0 >=0

return 'YES'

Correct.

Another 'YES' case: n=5, a=[4,5,2,1,3]

mean=3

curr:

i=0: 1, curr=1

i=1:2, curr=3

i=2:-1, curr=2

i=3:-2, curr=0

i=4:0, curr=0

'YES'

Correct.

Seems like the logic holds.

Therefore, the given program is correct.

**Final Answer**

\[\boxed{\text{See explanation for the solution code.}}\]

**Correctness: True**