Alright, I've got this problem to solve. It's about determining who wins a game between Bodya and Sasha based on their scores after a certain number of turns. They start at different positions in a permutation, and each turn they can choose to stay or move to another position based on the permutation. The goal is to maximize their scores by collecting points associated with the positions they land on.

First, I need to understand the problem completely. We have a permutation p of length n, and an array a of length n, where a[i] represents the points gained when landing on position i. Both players start at positions PB and PS respectively, and the game consists of k turns.

Each turn, both players simultaneously:

1. Add a[x] to their score, where x is their current position.

2. Choose to either stay at their current position or move to p[x].

The winner is the one with the higher score after k turns. If scores are equal, it's a draw.

My task is to determine the winner or if it's a draw, assuming both players play optimally to maximize their scores.

Looking at the example provided, it seems that the optimal strategy involves identifying cycles in the permutation and calculating the maximum possible score based on whether they stay or move within these cycles.

I need to think about how to model this game. Since both players make decisions independently, I can treat their paths separately and compute the maximum possible score for each.

The challenge lies in handling large n and k, especially since k can be up to 10^9, and t can be up to 10^4, with n up to 2*10^5 per test case. So, efficiency is crucial.

First, I need to realize that in a permutation, following p repeatedly will eventually lead to a cycle because permutations consist of disjoint cycles.

So, for each starting position, I can find the cycle that it belongs to and then determine the optimal way to stay or move within that cycle over k turns.

To do this efficiently, I need to:

1. Find the cycle that each starting position belongs to.

2. For each cycle, precompute the optimal score that can be achieved within that cycle.

3. Then, for each player, simulate their path over k turns, taking into account the cycle they are in.

But wait, since both players are making decisions simultaneously and independently, I can treat their paths separately.

So, for each player, I need to find the maximum score they can achieve starting from their respective positions, given the constraints of the game.

The key insight is that within a cycle, the optimal strategy can be precomputed.

Let me think about how to model the cycle.

Suppose we have a cycle of length m. For example, if m=3, and the cycle is x -> y -> z -> x.

Each turn, a player can choose to stay or move to the next position in the cycle.

The player needs to decide for each turn whether to stay or move, to maximize the sum of a[x] over k turns.

This sounds like a dynamic programming problem.

Let me define dp[i][j], where i is the current position in the cycle, and j is the number of turns left.

But with m up to n (which is up to 2*10^5) and k up to 10^9, this approach is too slow.

I need a smarter way.

Wait, in a cycle of length m, the game repeats every m turns if they keep moving.

But players can choose to stay, which complicates things.

I need to find a way to compute the optimal score for each cycle efficiently.

Another approach: for each cycle, compute the maximum possible score per cycle length, and then handle the full cycles and the remaining turns separately.

But I need to think more carefully.

Let me consider that in a cycle of length m, the player can choose to stay at any position for any number of turns.

So, for each position in the cycle, the player can choose to stay there for any number of consecutive turns, collecting a[x] each time, or move to the next position.

This seems too vague. I need a better way.

Perhaps I can model this as a graph where each node has two options: stay or move.

But again, with large n and k, this won't work.

I need to find a mathematical way to compute the maximum score for each cycle.

Let me consider that in a cycle of length m, the optimal strategy would be to stay at the position with the highest a[x] for as many turns as possible.

But, since they can only stay or move one step at a time, it's not straightforward.

Wait, actually, the optimal strategy is to stay at the position with the maximum a[x] in the cycle for all possible turns.

Because staying at the best position maximizes the score.

But, they have to move to other positions if staying is not an option.

Wait, no, in this game, they can choose to stay or move each turn.

So, the best strategy is to stay at the position with the highest a[x] indefinitely.

But, since k can be up to 10^9, and m can be up to 2*10^5, I need a way to compute this efficiently.

Wait, in a cycle, if a player chooses to stay at a position, they keep collecting a[x] each turn.

If they choose to move, they collect a[p[x]] in the next turn, and so on.

So, the optimal strategy is to stay at the position with the maximum a[x] in the cycle for all k turns.

Because staying at the best position maximizes the score.

But, I need to confirm this.

Suppose we have a cycle x -> y -> z -> x, and a[x]=1, a[y]=2, a[z]=3.

The best strategy is to stay at z for all k turns, collecting 3 each turn.

But, if the player starts at x, they can choose to move to y, then to z, and stay at z.

But, to reach z, they need to spend turns moving, which might not be optimal if k is small.

Wait, but k can be up to 10^9, so for large k, the best strategy is to reach the position with the maximum a[x] in the cycle and stay there forever.

But, to get there, they might need to spend some turns moving.

So, the idea is to find, for each cycle, the maximum a[x] in the cycle, and then, for each starting position in the cycle, compute the minimal number of turns needed to reach that maximum position, and then stay there for the remaining turns.

But, since k can be up to 10^9, and n up to 2*10^5, with t up to 10^4, I need an efficient way to handle this.

Wait, perhaps I can group positions into their cycles, compute the maximum a[x] in each cycle, and then, for each starting position, compute the minimal distance to that maximum position in the cycle.

Then, for k turns, the score would be:

- The sum of a[x] for the path taken to reach the maximum position.

- Plus (k - distance) * maximum a[x].

But, I need to handle the case where k is less than the distance to the maximum position.

Also, if there are multiple positions with the same maximum a[x], I need to choose one of them.

Wait, actually, since staying at any position with the maximum a[x] is optimal, I can choose any such position.

So, for each cycle, find all positions with the maximum a[x], and then, for each starting position, find the minimal distance to any of these positions.

Then, the optimal score is:

- Sum of a[x] along the path to the closest maximum position.

- Plus (k - distance) * maximum a[x].

This seems correct.

Now, to implement this efficiently, I need to:

1. Find the cycle for each position.

2. Within each cycle, find the positions with the maximum a[x].

3. For each position in the cycle, compute the minimal distance to any of these maximum positions.

4. Then, for each player's starting position, compute the optimal score using the precomputed distances and maximum a[x].

But, with t=10^4 and n=2*10^5, I need to do this efficiently.

First, I need to find the cycles in the permutation.

Permutations consist of disjoint cycles, so I can perform a graph traversal, treating the permutation as a directed graph where each node points to its permutation value.

I can perform a graph traversal (DFS or BFS) to find all cycles.

But with t=10^4 and n=2*10^5, I need an efficient way to handle this.

Wait, actually, since the sum of n over all test cases is up to 2*10^5, it's manageable.

So, for each test case, I can find the cycles and process them accordingly.

Now, within each cycle, I need to find the positions with the maximum a[x].

Then, for each position in the cycle, compute the distance to the closest maximum position.

To do this, I can:

- For each cycle, identify the positions with the maximum a[x].

- Then, for each position in the cycle, find the minimal distance to any of these positions.

But, in a cycle, the distance between two positions can be measured in both directions.

So, I need to consider the minimal distance in both directions.

This can be handled by processing the cycle as a circular list.

An efficient way is to, for each position in the cycle, find the nearest maximum position in one direction.

But to handle the cycle, I need to handle the circular nature.

Wait, perhaps I can linearize the cycle by breaking it at one point, process it as a linear array, and then handle the wrap-around.

But that might be complicated.

An alternative approach is to, for each position in the cycle, find the distance to the nearest maximum position in both directions, and take the minimum of these distances.

This can be done by iterating around the cycle and keeping track of the distance to the last seen maximum position.

Similarly, iterate in the opposite direction.

Then, for each position, the minimal distance to a maximum position is the minimum of the distances from both directions.

Once I have these precomputed, for each starting position, I can compute the optimal score as:

- Sum of a[x] along the path to the closest maximum position.

- Plus (k - distance) * maximum a[x].

But, I need to be careful with how I compute the path sum.

Wait, actually, since the player can choose to stay or move each turn, I need to ensure that I'm choosing the optimal path.

But, given that the optimal strategy is to reach a maximum position as quickly as possible and then stay there, I can compute the minimal number of moves needed to reach a maximum position and then stay there for the remaining turns.

Wait, but the player can choose to stay at any position, so perhaps I need to consider that.

Wait, no, the player can choose to stay or move each turn, but moving is to p[x], not to any position.

So, each turn, the player can choose to stay at x or move to p[x].

This introduces a decision point each turn.

But, to maximize the score, the player should aim to be at a position with the maximum a[x] for as many turns as possible.

So, the strategy is to reach a position with maximum a[x] in the cycle as quickly as possible and then stay there.

Hence, for each starting position, find the minimal number of moves to reach a position with maximum a[x], and then stay there for the remaining turns.

The minimal number of moves is the distance to the closest maximum position in the cycle.

So, I need to compute, for each position in the cycle, the minimal distance to any position with maximum a[x].

Then, for each starting position, the optimal score is:

- Sum of a[x] for each turn spent moving towards the maximum position.

- Plus (k - distance) * maximum a[x].

But, since the player can choose to stay at any position, including non-maximum positions, I need to ensure that staying at a non-maximum position is not beneficial.

However, since the maximum a[x] is the highest possible, staying at a non-maximum position would yield a lower score per turn.

Therefore, the optimal strategy is indeed to reach a maximum position as quickly as possible and then stay there.

Hence, I can proceed with this approach.

Now, to implement this efficiently, I need to:

1. Find the cycle for each position.

2. For each cycle, find the maximum a[x] in the cycle.

3. For each position in the cycle, find the minimal distance to any position with maximum a[x].

4. Precompute these distances for each position.

5. For each player's starting position, compute the optimal score using the precomputed distances and maximum a[x].

6. Compare the scores of Bodya and Sasha to determine the winner.

Now, to handle multiple test cases efficiently, I need to make sure that I reset any data structures specific to each test case.

Also, since n can be up to 2*10^5 and t up to 10^4, but the sum of n over all test cases is up to 2*10^5, I can process each test case independently without worrying about cumulative time.

But, I need to make sure that my implementation is optimized.

Let me outline the steps in code:

- Read the number of test cases t.

- For each test case:

- Read n, k, PB, PS.

- Read the permutation p.

- Read the array a.

- Find the cycle that PB and PS belong to.

- For each cycle, find the maximum a[x].

- For each position in the cycle, find the minimal distance to any position with maximum a[x].

- Compute the optimal score for PB and PS.

- Compare the scores and output the result.

But, since cycles are disjoint, I can process each cycle separately and store the precomputed distances for positions in that cycle.

But, to handle multiple test cases efficiently, I need to make sure that I don't reuse data from previous test cases.

Now, let's think about how to implement the cycle detection and distance computation.

For cycle detection in a permutation:

- Start from a position that hasn't been visited yet.

- Follow p[x] until returning to the starting position.

- That forms a cycle.

- Repeat until all positions are visited.

For each cycle, find the positions with the maximum a[x].

Then, for each position in the cycle, compute the minimal distance to any of these positions.

To compute the minimal distance in a cycle, I can:

- Find all positions with maximum a[x] in the cycle.

- For each position, find the minimal distance to any of these positions.

In a cycle, the distance between two positions can be measured in both directions.

To handle this efficiently, I can:

- Represent the cycle as a list, with the positions in cycle order.

- Find the positions of the maximum a[x] in this list.

- Then, for each position in the cycle, find the minimal distance to any of these positions, considering the circular nature.

An efficient way to do this is to iterate through the cycle list twice (effectively making it a list twice as long), and keep track of the distance to the nearest maximum position to the left and to the right.

Wait, but that might be complicated.

An alternative is to, for each position in the cycle, find the distance to the next maximum position in one direction, and the distance to the previous maximum position, and take the minimum of these.

But, implementing this correctly requires careful handling of the cycle.

Perhaps a simpler way is to model the cycle as a circular list and compute distances accordingly.

Given time constraints, I need an efficient implementation.

Now, let's consider the implementation in code.

I need to write a function that, given p and a, processes the cycles and computes the precomputed distances for each position.

Then, for each player's starting position, compute the optimal score based on these precomputations.

Wait, but with t=10^4 and n=2*10^5, sum of n over all test cases is up to 2*10^5, I need to make sure that my implementation is O(n) per test case.

Now, looking at the provided code, I need to evaluate its correctness.

But, before that, I need to make sure I understand the provided code.

Looking at func_1:

def func_1(n, k, PB, PS, p, a):

bodya_score = calculate_score(PB)

sasha_score = calculate_score(PS)

if bodya_score > sasha_score:

return 'Bodya'

elif sasha_score > bodya_score:

return 'Sasha'

else:

return 'Draw'

It calls calculate_score for both Bodya and Sasha's starting positions and compares their scores.

Now, calculate_score function:

def calculate_score(start_pos):

score = 0

current_pos = start_pos

steps = 0

visited = {}

cycle_start = -1

while steps < k:

if current_pos in visited:

cycle_start = visited[current_pos]

break

visited[current_pos] = steps

score += a[current_pos - 1]

steps += 1

if steps >= k:

return score

current_pos = p[current_pos - 1]

if cycle_start != -1:

cycle_length = steps - cycle_start

cycle_score = 0

cycle_pos = current_pos

for _ in range(cycle_length):

cycle_score += a[cycle_pos - 1]

cycle_pos = p[cycle_pos - 1]

remaining_steps = k - steps

full_cycles = remaining_steps // cycle_length

remainder_steps = remaining_steps % cycle_length

score += full_cycles * cycle_score

for _ in range(remainder_steps):

score += a[current_pos - 1]

current_pos = p[current_pos - 1]

return score

This function simulates the player's path, keeping track of the score.

It uses a visited dictionary to detect cycles.

Once a cycle is detected, it computes the cycle length and the score per cycle.

Then, it adds the score for full cycles and the remaining steps.

This seems to be implementing the optimal strategy, but I need to verify if it indeed maximizes the score.

Wait, but according to my earlier reasoning, the optimal strategy is to reach a position with maximum a[x] as quickly as possible and then stay there.

However, in this implementation, the player follows the path determined by p[x], without considering the option to stay.

Wait, actually, the problem states that on each turn, the player can choose to stay or move to p[x].

But in this implementation, it seems to always move to p[x], without considering staying.

Wait, that can't be right.

Looking back at the problem statement:

"On each turn, two things happen to each player:

- If the current position of the player is x , his score increases by a_x .

- Then the player either stays at his current position x or moves from x to p_x ."

So, each turn, the player chooses to stay or move after adding a_x to their score.

But in the provided code, it seems to always move to p[x], without considering staying.

That might not be correct.

Wait, but in the calculate_score function, it sets current_pos = p[current_pos - 1], which implies moving to p[x].

But according to the problem, the player can choose to stay or move.

So, the code seems to always choose to move, which may not be optimal.

Wait, but according to my earlier reasoning, the optimal strategy is to stay at the position with the maximum a[x] once reached.

So, perhaps the code is trying to simulate the optimal path where the player stays at the best position.

But, in reality, the player has to choose at each step whether to stay or move.

So, the code's approach may not be correctly implementing the optimal strategy.

I need to think carefully.

Let me consider that the player can choose to stay or move each turn.

So, the player can choose to stay at any position for any number of turns.

But, to maximize the score, they should aim to be at the position with the maximum a[x] for as many turns as possible.

Hence, the optimal strategy is to reach a position with maximum a[x] as quickly as possible and then stay there.

So, in the calculate_score function, it should simulate reaching the best position and then staying there.

But the current implementation seems to always move to p[x], without considering staying.

Hence, it may not be correct.

Wait, perhaps I misread the code.

Looking again at calculate_score:

It has a loop where it adds a[current_pos - 1] to the score and then sets current_pos = p[current_pos - 1].

But, according to the problem, after adding a_x, the player chooses to stay or move.

If they choose to stay, current_pos remains the same; if they choose to move, current_pos becomes p[x].

So, the code is always choosing to move, without considering staying.

Hence, it's not implementing the optimal strategy.

The optimal strategy should be to choose to stay at the position with the maximum a[x] once reached.

So, the code is incorrect because it doesn't consider the option to stay.

Hence, the answer is Correctness: False

**Final Solution**

To solve this problem, we need to determine the winner of a game between Bodya and Sasha based on their scores after a certain number of turns. They start at different positions in a permutation and can choose to stay or move to another position based on the permutation each turn. The goal is to maximize their scores by collecting points associated with the positions they land on.

## Approach

1. **Problem Analysis**:
   - Both players make decisions independently; hence, their paths can be treated separately.
   - The permutation forms disjoint cycles. Identifying these cycles is crucial for efficient computation.
   - The optimal strategy for each player is to reach a position with the maximum points in their cycle as quickly as possible and then stay there.

2. **Cycle Detection and Processing**:
   - For each cycle in the permutation, identify the positions with the highest points.
   - For each starting position in the cycle, compute the minimal distance to any position with maximum points.

3. **Score Calculation**:
   - Each player's optimal score is calculated by summing the points along the path to the nearest maximum position and adding the points from staying at the maximum position for the remaining turns.

4. **Efficient Implementation**:
   - Use graph traversal (DFS or BFS) to find cycles.
   - Precompute distances to the nearest maximum position in each cycle.
   - Handle large values of `k` efficiently by leveraging cycle properties.

## Solution Code

```python
def find_cycle(start, p, visited):
    cycle = []
    current = start
    while current not in visited:
        visited.add(current)
        cycle.append(current)
        current = p[current - 1]
    return cycle

def preprocess_cycle(cycle, a):
    max_a = max(a[x - 1] for x in cycle)
    max_positions = [x for x in cycle if a[x - 1] == max_a]
    
    # Compute distances to nearest max position in cycle
    n = len(cycle)
    dist = [n] * n  # Initialize with maximum possible distance
    for max_pos in max_positions:
        idx = cycle.index(max_pos)
        dist[idx] = 0
        # Update distances in one direction
        for i in range(1, n):
            next_idx = (idx + i) % n
            dist[next_idx] = min(dist[next_idx], i)
            next_idx = (idx - i) % n
            dist[next_idx] = min(dist[next_idx], i)
    
    return max_a, dist

def compute_optimal_score(start, cycle_mapping, a, k):
    for cycle in cycle_mapping:
        if start in cycle:
            max_a, dist = cycle_mapping[cycle]
            pos_idx = cycle.index(start)
            d = dist[pos_idx]
            if d <= k:
                return (sum(a[cycle[i] - 1] for i in range(pos_idx, pos_idx + d)) +
                        (k - d) * max_a)
            else:
                return sum(a[cycle[(pos_idx + i) % len(cycle)] - 1] for i in range(k))
    return 0  # Should not reach here if all positions are in cycles

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        k = int(data[index + 1])
        PB = int(data[index + 2])
        PS = int(data[index + 3])
        index += 4
        p = list(map(int, data[index:index + n]))
        index += n
        a = list(map(int, data[index:index + n]))
        index += n
        
        visited = set()
        cycles = []
        for i in range(1, n + 1):
            if i not in visited:
                cycle = find_cycle(i, p, visited)
                cycles.append(cycle)
        
        cycle_mapping = {tuple(cycle): preprocess_cycle(cycle, a) for cycle in cycles}
        
        bodya_score = compute_optimal_score(PB, cycle_mapping, a, k)
        sasha_score = compute_optimal_score(PS, cycle_mapping, a, k)
        
        if bodya_score > sasha_score:
            results.append('Bodya')
        elif sasha_score > bodya_score:
            results.append('Sasha')
        else:
            results.append('Draw')
    
    for result in results:
        print(result)

if __name__ == '__main__':
    main()
```

## Explanation

1. **Cycle Detection**:
   - Use a set to track visited positions and group positions into cycles.

2. **Preprocessing for Optimal Moves**:
   - For each cycle, identify positions with the maximum points.
   - Compute the minimal distance from each position in the cycle to the nearest position with maximum points.

3. **Score Calculation**:
   - For each player, compute the optimal score by summing points along the path to the nearest maximum position and adding the points from staying at that position for the remaining turns.

4. **Efficiency**:
   - Process each test case independently.
   - Leverage cycle properties to handle large values of `k` efficiently, ensuring the solution runs within time limits for large inputs.