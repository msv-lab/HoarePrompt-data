Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a "beautiful" array, and I need to find the minimum number of elements to remove so that it's no longer beautiful. If it's impossible to make it not beautiful, I should output -1.

First, I need to understand what makes an array beautiful. According to the problem, an array is beautiful if I can make all its elements the same by using a specific operation any number of times. The operation is: choose an index i (where 2 ≤ i ≤ n-1) such that a[i-1] equals a[i+1], and then replace a[i] with a[i-1].

So, in other words, if the elements on both sides of an element are the same, I can change that element to match them. This operation can be repeated as many times as I want.

The goal is to remove the smallest number of elements so that the array is no longer beautiful. Removing elements means deleting them from the array, and I can't swap elements.

Looking at the examples:

1. For n=3 and array [2,2,2], it's already all the same, and no matter how many elements I remove, it remains beautiful. So, output is -1.

2. For n=5 and array [1,2,1,2,1], removing one element can make it not beautiful.

3. For n=1, with a single element, it's already beautiful, and I can't make it not beautiful by removing elements. So, output is -1.

4. For n=7 and array [3,3,3,5,3,3,3], removing the first three elements leaves [5,3,3,3], which is not beautiful.

From these examples, I need to find a pattern or a property that determines whether an array can be made not beautiful by removing a certain number of elements.

Let me think about the operation allowed. The operation allows me to change an element in the middle to match its neighbors if they are the same. This seems like it can be used to propagate a value through the array, making more elements the same.

Given that the array is beautiful, it means that through these operations, I can make all elements equal to some value.

Now, to make the array not beautiful, I need to ensure that it's impossible to make all elements equal using these operations.

One way to think about this is to break the sequence in such a way that the remaining array cannot be made uniform by these operations.

Let me consider the array as sequences of identical elements. For example, in the fourth test case, [3,3,3,5,3,3,3], there are blocks of 3s, then a 5, then again 3s.

If I remove some elements, I'm essentially merging some of these blocks.

The key is to ensure that after removal, the array cannot be made uniform by the given operations.

Wait, maybe I should look at the array in terms of runs of identical elements.

Let's define a "run" as a sequence of consecutive elements that are the same.

In the first test case, [2,2,2], there's only one run of three 2's.

In the second test case, [1,2,1,2,1], there are alternating runs: 1, 2, 1, 2, 1.

In the third test case, [1], there's only one run.

In the fourth test case, [3,3,3,5,3,3,3], there are two runs: 3s, then 5, then 3s.

I need to find a way to remove elements such that the remaining array cannot be made uniform by the operations.

Let me consider that if there is more than one run, and the runs alternate in such a way that I cannot make all elements the same, then I need to remove elements to break the uniformity.

Wait, but in the first test case, all elements are the same, so it's impossible to make it not beautiful by removing elements.

In the second test case, removing one element breaks the pattern.

In the fourth test case, removing the first three elements leaves [5,3,3,3], which is not beautiful.

I need to generalize this.

Maybe, if the array consists of only one run, i.e., all elements are the same, then it's impossible to make it not beautiful by removing elements, so output -1.

Otherwise, the minimum number of elements to remove is the length of the longest run.

Wait, but in the second test case, the longest run is 1 (all elements are singletons except for the two 1's and two 2's), but removing one element makes it not beautiful.

Hmm, maybe that's not the right approach.

Let me think differently.

Suppose I have runs of different values. If there is more than one run, and the values alternate, then removing elements from the longest run could break the beauty.

Wait, perhaps the minimum number of elements to remove is the size of the largest run minus the number of runs minus one.

No, that seems too complicated.

Let me consider that in order for the array to remain beautiful, it must be possible to make all elements equal by applying the operations.

If I can make all elements equal, that means that there is a value that can be propagated through the array using the operations.

To prevent this, I need to ensure that no single value can be propagated to the entire array.

One way to do this is to have at least two different values that cannot be made the same through operations.

But I need to think in terms of removing elements to achieve that.

Wait, perhaps the minimum number of elements to remove is the size of the largest run, because removing those elements would break the uniformity.

But in the first test case, all elements are the same, so the largest run is n, and removing n elements would leave an empty array, which is still beautiful (or not beautiful, depending on the definition). But according to the problem, output should be -1 in such cases.

Wait, the problem says that an empty array is considered not beautiful.

But in the first test case, removing all elements would make it empty, which is not beautiful, but the output is -1, meaning it's impossible to make it not beautiful.

Wait, maybe the problem considers that removing elements to make it not beautiful is only valid if the remaining array is non-empty.

In other words, to make the array not beautiful, while keeping at least one element.

If I remove all elements, making it empty, it's not beautiful, but that's not allowed, I guess.

Wait, no, the problem says: "swap elements is prohibited. If it is impossible, then output -1."

So, probably, removing all elements is allowed only if it's impossible to make it not beautiful otherwise.

Wait, I need to read the problem again carefully.

"what is the minimum number of elements you have to remove from it in order for it to stop being beautiful. Swapping elements is prohibited. If it is impossible, then output -1."

So, if it's impossible to make it not beautiful by removing elements, output -1.

Otherwise, output the minimum number of elements to remove.

In the first test case, removing any elements doesn't make it not beautiful, because the remaining array is still beautiful. So, output -1.

In the second test case, removing one element makes it not beautiful.

In the third test case, with only one element, it's already beautiful, and removing the only element makes it empty, which might be considered not beautiful, but perhaps the problem considers that as invalid.

Wait, in the third test case, output is -1.

Similarly, in the first test case, output is -1.

So, perhaps, if the array consists of only one run, then it's impossible to make it not beautiful by removing elements, so output -1.

Otherwise, the minimum number of elements to remove is the size of the largest run.

Wait, but in the fourth test case, [3,3,3,5,3,3,3], the largest run is 4 (the last four 3's), but the answer is 3.

Wait, maybe it's the size of the largest continuous run of the most frequent value.

Wait, in the fourth test case, removing the first three 3's leaves [5,3,3,3], which is not beautiful.

Alternatively, removing the last three 3's leaves [3,3,3,5,3], which is still beautiful, because you can make all elements 3.

Wait, no, but in the solution, removing the first three makes it [5,3,3,3], which is not beautiful.

So, perhaps the minimum number of elements to remove is the size of the largest run of the most frequent value minus one.

Wait, in the fourth test case, there are runs of 3's and one run of 5.

The largest run of 3's is 4 elements.

Removing 3 elements makes it have a run of 1 element, which cannot be made uniform.

Wait, but I need to think more carefully.

Let me think about the problem differently.

Suppose I have an array that is beautiful. I need to remove the fewest elements so that the remaining array is not beautiful.

An array is beautiful if I can make all elements the same by repeatedly replacing a[i] with a[i-1] where a[i-1] == a[i+1].

This operation can only be performed if a[i-1] == a[i+1].

So, essentially, this operation allows me to change a[i] to a[i-1] if the neighbors are equal.

This seems like it allows me to propagate values through the array under certain conditions.

To make the array not beautiful, I need to ensure that after removing some elements, it's impossible to make all remaining elements equal using these operations.

One way to approach this is to consider the runs of identical elements.

If there is only one run (all elements are the same), then it's impossible to make it not beautiful by removing elements, because any subset will still be uniform.

Hence, output -1.

If there are multiple runs, then I need to remove elements in such a way that I break the ability to propagate a value through the array.

The minimal number of elements to remove would be the size of the largest run.

Wait, but in the fourth test case, the largest run is 4 (the last four 3's), but the answer is 3.

Wait, perhaps it's the size of the largest run minus one.

Wait, but in the fourth test case, removing 3 elements from the first run of 3's makes the remaining array [5,3,3,3], which is not beautiful.

Wait, but 3 is less than the largest run of 4.

Hmm.

Wait, maybe it's the size of the smallest run.

No, in the second test case, the smallest run is 1, but the answer is 1.

Wait, that doesn't help.

Wait, perhaps it's the minimal number of elements to remove so that no run is large enough to make all elements equal.

Wait, perhaps I need to remove elements to ensure that no single value can be propagated to the entire array.

Wait, maybe it's the size of the largest run of the most frequent element.

But in the fourth test case, the largest run is 4, but the answer is 3.

Wait, maybe it's the ceiling of the largest run divided by some factor.

No, that doesn't seem right.

Let me consider that in the fourth test case, removing any three elements from the first run of three 3's makes the remaining array [5,3,3,3], which is not beautiful.

Similarly, in the second test case, removing one element breaks the pattern.

Perhaps, the minimal number of elements to remove is equal to the number of elements in the largest run minus the number of runs.

Wait, in the fourth test case, largest run is 4, number of runs is 3, so 4 - 3 = 1, which is not matching the answer of 3.

No, that doesn't seem right.

Wait, perhaps it's the size of the largest run minus one.

In the fourth test case, 4 - 1 = 3, which matches the answer.

In the second test case, the largest run is 1, so 1 - 1 = 0, but the answer is 1.

Wait, that doesn't match.

Wait, perhaps it's the minimal number of elements to remove is equal to the size of the largest run minus the number of distinct runs where the value is the most frequent value.

Wait, this is getting too complicated.

Let me look for another approach.

Suppose I consider that the array is beautiful if all elements can be made equal by propagating values through the operations.

To make it not beautiful, I need to ensure that after removal, there is no way to make all elements equal.

One way to think about this is to ensure that the remaining array has at least two different values that cannot be made equal through the operations.

But I need to minimize the number of removals.

Wait, perhaps the minimal number of elements to remove is equal to the size of the largest run of the most frequent value minus one.

In the fourth test case, the largest run of 3's is 4, so 4 - 1 = 3, which matches the answer.

In the second test case, the largest run is 1, so 1 - 1 = 0, but the answer is 1.

Wait, that doesn't match.

Wait, perhaps it's the minimal number of elements to remove is equal to the size of the largest run minus one, but if the size is 1, then it's 0, but in the second test case, it's 1.

Hmm.

Wait, maybe it's the size of the largest run.

In the fourth test case, largest run is 4, but answer is 3.

Wait, 4 -1=3.

In the second test case, largest run is 1, so 1 -1=0, but answer is 1.

So, perhaps, it's the minimal number of elements to remove is equal to the size of the largest run minus one, but if that results in zero, then it's one.

Wait, no, in the second test case, if I set it to 1 when the result is zero, it matches the answer.

But that seems arbitrary.

Wait, perhaps, the minimal number of elements to remove is equal to the size of the largest run minus the number of times the most frequent value appears in runs of size one.

Wait, this is getting too convoluted.

Let me look at the problem differently.

Suppose I have an array that is beautiful, meaning that through the operations, I can make all elements equal to some value.

To make it not beautiful, I need to ensure that after removal, it's impossible to make all elements equal.

This seems similar to breaking a connectivity in a graph, where operations allow me to propagate values.

But perhaps a better way is to consider that if there is more than one run of the most frequent value, I need to remove elements to separate them in such a way that they cannot be made uniform.

Wait, I'm getting stuck.

Let me look at the provided program and see what it's doing.

The function `func` reads the number of test cases, then for each test case, reads n and the array a.

It initializes `tmp` to a[0], `cnt` to 0, and `ans` to n.

Then, it iterates through the array:

- If a[i] == tmp, increment cnt.

- Else, set ans to the minimum of ans and cnt, and reset cnt to 0.

After the loop, it sets ans to the minimum of ans and cnt.

Then, if n == 1 or ans == n, it prints -1; else, it prints ans.

So, it seems to be finding the minimum length of runs of the first element's value.

Wait, tmp is set to a[0], and it counts consecutive a[i] == tmp, and keeps track of the minimum such count.

In the first test case, all elements are 2, so cnt would be 3, and ans would be 3. Since n == 3, and ans == n, output -1.

In the second test case, [1,2,1,2,1]:

- tmp = 1

- i=0: a[0]=1 == tmp, cnt=1

- i=1: a[1]=2 != tmp, set ans=min(ans,0)=0, reset cnt=0

- i=2: a[2]=1 == tmp, cnt=1

- i=3: a[3]=2 != tmp, set ans=min(0,1)=0, reset cnt=0

- i=4: a[4]=1 == tmp, cnt=1

- Finally, ans = min(0,1)=0

- Since n !=1 and ans !=n, output ans=0

But in the sample output, it's 1.

Wait, that doesn't match.

Wait, perhaps I misread the sample output.

Looking back, the sample output is:

-1

1

-1

3

So, for the second test case, it's 1, but according to the code, it would output 0, which doesn't match.

Therefore, the code is incorrect.

Wait, but the explanation says that in the second test case, removing one element makes it not beautiful.

So, the code is producing 0, but the correct answer is 1.

Hence, the code is incorrect.

Therefore, Correctness: False

**Final Answer**

\[\boxed{\text{False}}\]