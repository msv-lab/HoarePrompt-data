Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find an array of length n, where each element is between 1 and 10^9, and exactly k out of its n cyclic shifts are sorted. If no such array exists, I should output -1.

First, I need to understand what a cyclic shift is. From the description, the x-th cyclic shift of the array a is a_x, a_{x+1}, ..., a_n, a_1, a_2, ..., a_{x-1}. So, for example, if n=4 and x=2, the shift would be a_2, a_3, a_4, a_1.

I need exactly k of these shifts to be sorted. A sorted array is one where each element is less than or equal to the next one.

Let's look at the examples provided:

1. For n=2 and k=2, the array [1,1] works because both [1,1] and [1,1] are sorted.

2. For n=3 and k=1, the array [69420,69,420] has one sorted cyclic shift: [69,420,69420], while the others [69420,69,420] and [420,69420,69] are not sorted.

3. For n=3 and k=2, the output is -1, meaning no such array exists.

So, I need to find a general way to construct such an array for given n and k, or determine that it's impossible.

Let me think about the properties of the array that would make exactly k cyclic shifts sorted.

First, consider k = n. That means all cyclic shifts must be sorted. What array would satisfy that? Well, if all cyclic shifts are sorted, the array must be constant, i.e., all elements are equal. Because if any two elements are different, rotating the array to make the smaller one come before the larger one would break the sorted order.

Wait, no. Actually, if the array is constant, all shifts are sorted, as you're just repeating the same elements. But is there any other array that can have all shifts sorted? Let's see. Suppose n=3 and a=[1,1,2]. Then the shifts are:

- [1,1,2] (sorted)

- [1,2,1] (not sorted)

- [2,1,1] (not sorted)

So, only one shift is sorted, which matches the second example. But for k=3, if I set all elements to be equal, like [1,1,1], then all shifts are sorted.

So, for k=n, the array must have all elements equal.

Similarly, for k=1, I need exactly one cyclic shift to be sorted. How can I achieve that?

Perhaps by having the array almost sorted, but with a specific twist that only allows one shift to be sorted.

Looking at the second example: [69420,69,420]. The sorted shift is [69,420,69420]. The other shifts are [69420,69,420] and [420,69420,69], neither of which is sorted.

So, how did they construct this array? It seems like they arranged the elements so that only one particular shift is sorted.

Maybe a way to achieve k=1 is to have the array strictly increasing, but with the last element much larger than the first few, so that only one shift is sorted.

Wait, in the example, it's not strictly increasing; it's [69420,69,420]. So, 69 is less than 420, which is less than 69420.

Wait, 69 is less than 420, which is less than 69420, so [69,420,69420] is sorted.

But [420,69420,69] is not sorted because 69 is less than 420.

Similarly, [69420,69,420] is not sorted because 69 is less than 69420.

So, only one shift is sorted.

Maybe for k=1, I can have the array such that it's sorted in a way that only one shift satisfies the sorted condition.

Now, for k=2, in the third example, it's impossible. So, for n=3 and k=2, no such array exists.

Why is that?

Suppose n=3 and k=2. Let's try to construct such an array.

Suppose a=[1,2,3]. Shifts are:

- [1,2,3] (sorted)

- [2,3,1] (not sorted, since 3>1)

- [3,1,2] (not sorted, since 1<3)

So, only one shift is sorted.

What if a=[1,1,2]? Shifts are:

- [1,1,2] (sorted)

- [1,2,1] (not sorted)

- [2,1,1] (not sorted)

Again, only one shift is sorted.

What if a=[1,2,2]? Shifts are:

- [1,2,2] (sorted)

- [2,2,1] (not sorted)

- [2,1,2] (not sorted)

Still, only one shift is sorted.

What if a=[2,1,2]? Shifts are:

- [2,1,2] (not sorted)

- [1,2,2] (sorted)

- [2,2,1] (not sorted)

Only one shift is sorted.

What if a=[1,3,2]? Shifts are:

- [1,3,2] (not sorted)

- [3,2,1] (not sorted)

- [2,1,3] (not sorted)

No shifts are sorted.

What if a=[2,3,1]? Shifts are:

- [2,3,1] (not sorted)

- [3,1,2] (not sorted)

- [1,2,3] (sorted)

Only one shift is sorted.

Seems like for n=3, it's only possible to have k=1 or k=3, but not k=2.

So, the program outputs -1 for n=3 and k=2, which is correct.

Now, generalizing this, for any n, what values of k are possible?

I need to find for which n and k such an array exists.

From the above exploration, for n=3, k can be 1 or 3, but not 2.

Similarly, for n=2, k can be 1 or 2.

Wait, in the first example, n=2 and k=2 is possible with [1,1].

For n=2, k=1 would require an array where only one shift is sorted.

Let's try a=[1,2]. Shifts are [1,2] (sorted) and [2,1] (not sorted). So, only one shift is sorted, which matches k=1.

Another array for n=2 and k=1 could be [2,1]. Shifts are [2,1] (not sorted) and [1,2] (sorted). Again, only one sorted shift.

So, for n=2 and k=1, it's possible.

For n=1 and k=1, it's trivially possible, as there's only one shift.

So, for n>=1, k=1 and k=n seem possible, except for n=1, where only k=1 applies.

But, are there other values of k that are possible for larger n?

Let's try n=4.

For k=4, the array must have all elements equal, as all shifts need to be sorted.

For k=1, perhaps an array like [1,2,3,4], but let's check:

Shifts:

- [1,2,3,4] (sorted)

- [2,3,4,1] (not sorted)

- [3,4,1,2] (not sorted)

- [4,1,2,3] (not sorted)

Only one sorted shift.

What if I arrange it differently? Say [1,2,4,3]:

Shifts:

- [1,2,4,3] (sorted up to 4, then 3 is less than 4, so not sorted)

- [2,4,3,1] (4>3, not sorted)

- [4,3,1,2] (3<4, not sorted)

- [3,1,2,4] (1<3, but 2<4, so not sorted)

Wait, none are sorted.

What about [1,3,2,4]:

Shifts:

- [1,3,2,4] (3>2, not sorted)

- [3,2,4,1] (2<3, not sorted)

- [2,4,1,3] (4>2, not sorted)

- [4,1,3,2] (1<4, not sorted)

Again, none are sorted.

So, for k=1, maybe [1,2,3,4] is the way to go, with only one sorted shift.

Wait, in the earlier attempt, [1,2,3,4] had only one sorted shift, which is [1,2,3,4]. The other shifts have at least one inversion.

So, for n=4 and k=1, [1,2,3,4] seems to work.

What about k=2? Is it possible to have exactly two sorted shifts for n=4?

Let's try [1,2,4,3]. Shifts:

- [1,2,4,3] (2<4, but 4>3, not sorted)

- [2,4,3,1] (4>3, not sorted)

- [4,3,1,2] (3<4, not sorted)

- [3,1,2,4] (1<3, but 2<4, not sorted)

None are sorted.

What if I try [1,2,3,5]? Shifts:

- [1,2,3,5] (sorted)

- [2,3,5,1] (5>1, not sorted)

- [3,5,1,2] (5>1, not sorted)

- [5,1,2,3] (1<5, not sorted)

Only one sorted shift.

Hmm.

What if I try [1,2,4,5,3]? For n=5, k=2.

Wait, maybe I'm getting ahead of myself.

Let's think differently. Maybe there's a pattern or formula to determine for which n and k such an array exists.

First, for k=n, the array must be constant, as all shifts need to be sorted.

For k=1, it seems possible by making the array strictly increasing, so only one shift is sorted.

But in the n=3 case, k=2 is impossible.

Similarly, for n=4, k=2 seems impossible from my earlier attempts.

So, maybe for any n, k cannot be between 1 and n-1; only k=1 or k=n are possible.

Wait, but in the first example, n=2 and k=2 is possible with [1,1].

Similarly, n=2 and k=1 is possible with [1,2].

So, for n=2, both k=1 and k=2 are possible.

For n=3, only k=1 and k=3 are possible, but not k=2.

For n=4, perhaps only k=1 and k=4 are possible.

Is that a general pattern? That for any n, only k=1 and k=n are possible, except when n=1, where only k=1 applies, and when n=2, both k=1 and k=2 are possible?

Wait, but for n=1, k=1 is the only possibility, which matches k=1 and k=n=1.

So, perhaps for n>=2, k=1 and k=n are possible, and for n=2, k=2 is also possible.

But in the first example, n=2 and k=2 is possible with [1,1].

Wait, but for n=2, k=2 requires all shifts to be sorted, which means both [a1,a2] and [a2,a1] must be sorted.

So, [a1,a2] must be a1 <= a2, and [a2,a1] must be a2 <= a1, which implies a1 = a2.

Therefore, for n=2 and k=2, the array must have both elements equal.

For n=2 and k=1, the array can have a1 < a2, giving only one sorted shift.

So, for n=2, k=1 and k=2 are both possible.

For n=3, only k=1 and k=3 are possible, as per the examples and my attempts.

Similarly, for n=4, perhaps only k=1 and k=4 are possible.

So, maybe for n>=3, only k=1 and k=n are possible, while for n=2, both k=1 and k=2 are possible.

Wait, but n=1 is a special case where only k=1 applies.

So, generalizing:

- For n=1, only k=1 is possible.

- For n=2, k=1 and k=2 are possible.

- For n>=3, only k=1 and k=n are possible.

But I need to confirm this.

Let me check for n=4 and k=3.

Suppose I try to construct an array where exactly three shifts are sorted.

Let's see: if n=4, and k=3, then one shift is not sorted.

Is that possible?

Suppose I have an array [1,1,1,2]. Shifts are:

- [1,1,1,2] (sorted)

- [1,1,2,1] (sorted, since 1<=1<=2<=2)

- [1,2,1,1] (not sorted, since 2>1)

- [2,1,1,1] (not sorted, since 1<2)

Wait, in this case, two shifts are sorted.

Not three.

What if I try [1,1,2,2]. Shifts are:

- [1,1,2,2] (sorted)

- [1,2,2,1] (2>1, not sorted)

- [2,2,1,1] (1<2, not sorted)

- [2,1,1,2] (1<2, not sorted)

Only one shift is sorted.

Not three.

What if I try [1,2,2,2]. Shifts are:

- [1,2,2,2] (sorted)

- [2,2,2,1] (2<=2<=2>=1, so sorted if 2<=2 and 2>=1, but 2>=1 is not maintaining sorted order)

Wait, [2,2,2,1] is not sorted because 2<=2<=2>=1, but 2>=1 breaks the sorted order.

Similarly, [2,2,1,2] is not sorted because 2<=2>=1, but 2>=1 breaks.

And [2,1,2,2] is not sorted because 1<2.

So, only one shift is sorted.

Seems like for n=4, it's not possible to have exactly three sorted shifts.

Therefore, for n=4, only k=1 and k=4 are possible.

Similarly, for n=5, only k=1 and k=5 would be possible.

So, in general, for n >= 3, only k=1 and k=n are possible, while for n=2, both k=1 and k=2 are possible, and for n=1, only k=1 is possible.

Given this, the program seems to implement this logic.

Looking at the code:

def func():

t = int(input())

for _ in range(t):

(n, k) = (int(i) for i in input().split())

res = [1] * n if k == n else range(n) if k == 1 else [-1]

print(*res)

So, for each test case:

- If k == n, it outputs an array of n ones.

- If k == 1, it outputs a range from 0 to n-1.

- Otherwise, it outputs [-1].

Wait, but in the first example, for n=2 and k=2, it should output two equal elements, like [1,1].

But in the code, for k == n, it outputs [1]*n, which is correct.

For k == 1, it outputs range(n), which for n=3 would be [0,1,2], but in the example, they used [69420,69,420]. So, it's acceptable to use any values as long as they satisfy the conditions.

But, does range(n) always satisfy k=1?

Let's check for n=3, k=1:

Array: [0,1,2]

Shifts:

- [0,1,2] (sorted)

- [1,2,0] (2>0, not sorted)

- [2,0,1] (0<2, not sorted)

So, only one sorted shift, which is correct.

Similarly, for n=4, k=1:

Array: [0,1,2,3]

Shifts:

- [0,1,2,3] (sorted)

- [1,2,3,0] (3>0, not sorted)

- [2,3,0,1] (0<2, not sorted)

- [3,0,1,2] (0<3, not sorted)

Only one sorted shift.

So, using range(n) works for k=1.

For k=n, outputting all ones works, as all shifts will be sorted.

For other values of k not equal to 1 or n, it outputs [-1], which is correct based on our earlier reasoning.

Therefore, the program seems correct.

But wait, in the example, for n=3 and k=1, they used [69420,69,420], which is fine, but the program uses [0,1,2], which also works. So, it's acceptable.

For n=3 and k=2, it outputs [-1], which is correct.

Hence, the program is correct.

**Final Answer**

\[ \boxed{\text{See explanation for the solution code.}} \]

**Correctness:**

\[ \boxed{\text{True}} \]