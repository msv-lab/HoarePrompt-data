Alright, I have this problem to solve. Let's see what it's asking for. There are n children in a class, and m pairs among them are friends with a certain friendship value. The teacher goes on k excursions, and for each excursion, she randomly chooses a pair of children. If the pair are friends, their friendship value increases by 1 for all subsequent excursions. Pairs who are not friends have a friendship value of 0 that doesn't change.

I need to find the expected value of the sum of friendship values of all k pairs chosen for the excursions, and express it as p/q where p and q are coprime, and then compute p * q^{-1} mod (10^9 + 7).

First, I need to understand the process:

1. There are n children, and m friend pairs with given friendship values.

2. For each of the k excursions, a pair is chosen randomly and equiprobably from all possible pairs.

3. If the chosen pair are friends, their friendship value increases by 1 for all future excursions.

4. The friendship value of non-friend pairs is always 0 and doesn't change.

5. I need the expected sum of the friendship values at the time of choosing each pair over k excursions.

Let me think about how to approach this.

First, I need to model how the friendship values change over time.

Let's consider that there are m friend pairs, each with an initial friendship value f_i.

For each excursion, a pair is chosen uniformly at random from all possible pairs, which is C(n, 2) = n(n-1)/2.

If the chosen pair is a friend pair, their friendship value increases by 1 for all subsequent excursions.

Non-friend pairs have a friendship value of 0 that never changes.

I need to compute the expected sum of the friendship values at the time of choosing each pair over k excursions.

This sounds like an expectation over a stochastic process where the friendship values can increase over time based on which pairs are chosen.

This seems a bit tricky. Maybe I can think in terms of linearity of expectation.

Let me try to model this step by step.

Define X_j as the friendship value of the pair chosen in the j-th excursion.

Then, the total sum S = X_1 + X_2 + ... + X_k.

I need E[S] = E[X_1] + E[X_2] + ... + E[X_k].

So, I need to compute E[X_j] for each j from 1 to k.

But X_j depends on which pair is chosen in the j-th excursion, and the friendship values can change based on previous choices.

This seems complicated because the friendship values can change over time based on previous selections.

Wait, but the problem says to consider the friendship value at the time of being chosen.

So for each excursion, when a pair is chosen, its current friendship value is added to the sum.

And if it's a friend pair, their friendship value increases by 1 for all subsequent excursions.

This seems like a Markov process where the state is the current friendship values of the friend pairs.

But modeling this directly seems too complex, especially given the constraints on n and m.

Maybe there's a smarter way to compute the expected sum using linearity of expectation and considering the contributions of each friend pair separately.

Let me consider each friend pair individually and compute its expected contribution to the total sum S.

Suppose we have a friend pair with initial friendship value f.

Each time this pair is chosen, its friendship value at that time is added to S, and then its value increases by 1 for all subsequent excursions.

So, if this pair is chosen t times, at times j1, j2, ..., jt, then its contributions to S are:

f + (f+1) + (f+2) + ... + (f+t-1)

This is an arithmetic series: t*f + (0 + 1 + 2 + ... + (t-1)) = t*f + t*(t-1)/2

But this seems too involved. Maybe instead of looking at the number of times it's chosen, I can think about the expected value it contributes per excursion.

Wait, perhaps I should think in terms of the probability that this pair is chosen in a particular excursion and its contribution at that time.

Let me try to compute the expected contribution of a single friend pair to S.

Let's denote by I_j be an indicator variable that is 1 if the pair is chosen in the j-th excursion, and 0 otherwise.

Then, the total contribution of this pair to S is sum over j from 1 to k of (f + number of times chosen before j).

Wait, more precisely, the friendship value at time j when chosen is f plus the number of times it was chosen before j.

So, if we let N_j be the number of times the pair is chosen in excursions 1 to j-1, then its contribution at time j is f + N_j, but only if it is chosen at time j.

Wait, perhaps it's better to think recursively.

This seems messy. Maybe there's a better way.

Let me look at the total expected sum S.

S = sum over j from 1 to k of X_j, where X_j is the friendship value of the pair chosen at excursion j.

I need E[S] = sum over j from 1 to k of E[X_j].

Now, E[X_j] is the expected friendship value of the pair chosen at excursion j.

So, E[X_j] = sum over all possible pairs P of Pr(P is chosen at excursion j) * friendship value of P at that time.

But since the pair is chosen uniformly at random each time, Pr(P is chosen) = 1 / C(n,2) for any pair P.

However, the friendship value of P at time j depends on how many times P has been chosen in previous excursions.

This seems tricky because it's a dependent process.

Wait, maybe I can think in terms of the linearity of expectation by considering the contribution of each friend pair separately.

Let me consider one friend pair P with initial friendship value f.

Letâ€™s define S_P as the sum of the friendship values of P over all k excursions, but only when P is chosen.

Then, S = sum over all friend pairs P of S_P.

But since the pairs are chosen independently each time, perhaps I can compute E[S_P] for each P and sum them up.

Wait, but the friendship values increase over time based on how many times P is chosen, so there is dependency across the excursions for each P.

This seems complicated.

Maybe I can model the expected contribution of P to S.

Let me think about it differently.

Suppose I fix a friend pair P with initial friendship value f.

I need to find the expected sum over j from 1 to k of (f + N_{P,j-1}) * I_{P,j},

where N_{P,j-1} is the number of times P has been chosen in excursions 1 to j-1, and I_{P,j} is 1 if P is chosen at excursion j, else 0.

This seems too involved.

Perhaps I need to find a better way to compute E[X_j].

Wait, maybe I can think about the expected friendship value of a randomly chosen pair at time j.

Since the pair is chosen uniformly at random each time, E[X_j] is the average of the friendship values of all possible pairs at time j.

So, E[X_j] = (sum over all pairs P of friendship value of P at time j) / C(n,2).

Then, E[S] = sum over j from 1 to k of E[X_j] = sum over j from 1 to k of (sum over all pairs P of friendship value of P at time j) / C(n,2).

This seems promising.

Now, I need to find sum over j from 1 to k of (sum over all pairs P of friendship value of P at time j)) / C(n,2).

Let me denote the sum over all pairs P of friendship value of P at time j as T_j.

Then, E[S] = (sum over j from 1 to k of T_j) / C(n,2).

Now, I need to find sum over j from 1 to k of T_j.

But T_j depends on j because the friendship values can increase over time.

Let me try to find a way to compute T_j.

Initially, at time j=0, the total sum of friendship values is sum over all friend pairs of their initial friendship values, say S_0.

At each time step j, when a pair P is chosen, if P is a friend pair, its friendship value increases by 1 for all subsequent times.

So, if a friend pair P is chosen at time j, then for all j' > j, its friendship value is increased by 1.

Therefore, the total sum T_j at time j is equal to the initial sum S_0 plus the sum over all friend pairs P of the number of times P has been chosen in previous excursions.

Wait, perhaps I need to think recursively.

Let me define:

- Let S_0 be the initial sum of friendship values: sum over all m friend pairs of their initial f_i.

- For each j from 1 to k, T_j = S_0 + sum over all friend pairs P of N_{P,j-1}, where N_{P,j-1} is the number of times P has been chosen in excursions 1 to j-1.

Wait, but this seems circular because T_j depends on the history of choices.

This is getting complicated.

Maybe I can think in terms of expectation.

Let me consider that at each step j, the expected T_j is S_0 plus the expected sum over all friend pairs P of N_{P,j-1}.

But N_{P,j-1} is the number of times P has been chosen in the first j-1 excursions.

Since each excursion chooses a pair uniformly at random, the probability that P is chosen in any single excursion is 1 / C(n,2).

Therefore, the expected N_{P,j-1} is (j-1) / C(n,2).

Therefore, the expected T_j = S_0 + sum over all m friend pairs P of E[N_{P,j-1}] = S_0 + m * (j-1) / C(n,2).

Therefore, E[T_j] = S_0 + m * (j-1) / C(n,2).

Therefore, sum over j from 1 to k of E[T_j] = sum over j from 1 to k of (S_0 + m * (j-1) / C(n,2)) = k * S_0 + m / C(n,2) * sum over j from 0 to k-1 of j = k * S_0 + m / C(n,2) * (k*(k-1)/2).

Therefore, E[S] = (sum over j from 1 to k of E[T_j]) / C(n,2) = (k * S_0 + m / C(n,2) * (k*(k-1)/2)) / C(n,2) = (k * S_0 + m * (k*(k-1)/2) / C(n,2)) / C(n,2).

Wait, this seems off.

Wait, let's double-check.

I had E[T_j] = S_0 + m * (j-1) / C(n,2).

Then sum over j from 1 to k of E[T_j] = sum over j from 1 to k of (S_0 + m * (j-1) / C(n,2)) = k * S_0 + m / C(n,2) * sum over j from 0 to k-1 of j = k * S_0 + m / C(n,2) * (k*(k-1)/2).

Then, E[S] = (sum over j from 1 to k of E[T_j]) / C(n,2) = (k * S_0 + m * (k*(k-1)/2) / C(n,2)) / C(n,2) = (k * S_0 + m * k*(k-1)/(2 * C(n,2))) / C(n,2).

This seems messy. Maybe there's a better way.

Let me try to think differently.

Perhaps I can consider that for each friend pair P with initial friendship value f, its expected contribution to S is f * p * sum over j from 1 to k of (1 + (j-1) * p),

where p is the probability of choosing P in any excursion.

Wait, I'm not sure.

Let me look at the second sample input to get some intuition.

In the second sample:

n=2, m=1, k=10

The only friend pair is (1,2) with f=1.

According to the explanation, the sum is 1 + 2 + 3 + ... + 10 = 55.

Wait, but according to my earlier formula, S_0 = 1, m=1, C(n,2)=1.

Then sum over j from 1 to 10 of E[T_j] = sum over j of (1 + 1*(j-1)/1) = sum over j of (1 + j -1) ) = sum over j of j = 55.

Then E[S] = sum over j of E[T_j] / C(n,2) = 55 / 1 = 55, which matches the sample.

Wait, but C(n,2) = 1 in this case, so it works.

Let me see for the first sample:

n=100, m=0, k=24

S_0 = 0, m=0, C(n,2)=4950

sum over j from 1 to 24 of E[T_j] = sum over j of (0 + 0*(j-1)/4950) ) = sum over j of 0 = 0

Then E[S] = 0 / 4950 = 0, which matches the first sample.

Ok, so maybe my formula is correct.

So, generalizing, E[S] = (k * S_0 + m * k*(k-1)/2 / C(n,2)) / C(n,2)

Wait, in the second sample, that would be E[S] = (10*1 + 1*10*9/2 /1)/1 = 10 + 45 /1 = 55, which matches.

Wait, but in the first sample, E[S] = (24*0 + 0*24*23/2 /4950)/4950 = 0, which is correct.

So maybe this formula works.

Wait, but in the third sample, n=3, m=1, k=2

Friend pair: 2 1 1

S_0 =1, C(n,2)=3

E[S] = (2*1 + 1*2*1/2 /3)/3 = (2 + 1/3)/3 = (7/3)/3 = 7/9, which matches the sample output of 777777784 mod (10^9+7), since 7/9 mod (10^9+7) is 7*9^{-1} mod (10^9+7), and 9^{-1} = 111111112, so 7*111111112 = 777777784.

So, this seems correct.

Therefore, the formula is:

E[S] = (k * S_0 + m * k*(k-1)/2 / C(n,2)) / C(n,2)

Simplify this:

E[S] = (k * S_0 * C(n,2) + m * k*(k-1)/2) / C(n,2)^2

Wait, no, let's be careful.

From earlier:

sum over j from 1 to k of E[T_j] = k * S_0 + m * k*(k-1)/2 / C(n,2)

Then E[S] = (k * S_0 + m * k*(k-1)/2 / C(n,2)) / C(n,2) = k * S_0 / C(n,2) + m * k*(k-1)/2 / C(n,2)^2

Wait, but in the second sample, that was 10*1 /1 +1*10*9/2 /1^2 =10 +45=55, which matches.

Wait, but in the third sample, it was 2*1 /3 +1*2*1/2 /9 = 2/3 + 1/9 = 6/9 +1/9=7/9, which matches.

Wait, but in general, it's k * S_0 / C(n,2) + m * k*(k-1)/2 / C(n,2)^2

Yes, that seems correct.

So, to compute E[S], it's k * S_0 / C(n,2) + m * k*(k-1)/2 / C(n,2)^2

Now, I need to compute this value and output p * q^{-1} mod (10^9 +7), where p/q is the reduced form of E[S].

To do this efficiently, considering the constraints, I need to handle large numbers and modular inverses.

Let me think about how to implement this.

First, compute C(n,2) = n*(n-1)/2

Then, S_0 = sum of f_i for all m friend pairs.

Then, E[S] = k * S_0 / C(n,2) + m * k*(k-1)/2 / C(n,2)^2

I need to compute this expression as a fraction p/q, reduce it to lowest terms, and then compute p * q^{-1} mod (10^9 +7).

Given the constraints on n and m, and the fact that n can be up to 1e5, and m up to 1e5, I need an efficient way to compute this without overflowing.

Also, considering that the sum of k over all test cases is up to 2e5, I need an O(k) per test case solution, but since k can be up to 2e5 and t up to 5e4, I need to make sure the total time is acceptable.

Wait, but the sum of k over all test cases is up to 2e5, so total time should be acceptable.

I need to compute E[S] as a fraction, reduce it, and then compute p * q^{-1} mod (1e9+7).

To handle this, I can compute the numerator and denominator separately, reduce them, and then compute the modular inverse.

But to avoid fraction arithmetic, perhaps I can compute the entire expression as a single fraction.

Let me try to write E[S] as a single fraction.

Let C = C(n,2) = n*(n-1)/2

Then, E[S] = (k * S_0 / C) + (m * k*(k-1)/2 / C^2)

= (k * S_0 * C + m * k*(k-1)/2) / C^2

Wait, no:

Wait, E[S] = k * S_0 / C + m * k*(k-1)/2 / C^2

= (k * S_0 * C + m * k*(k-1)/2) / C^2

Yes, that's correct.

So, numerator = k * S_0 * C + m * k*(k-1)/2

Denominator = C^2

Then, reduce numerator and denominator by their gcd, and then compute numerator * denominator^{-1} mod (1e9+7).

I need to handle large numbers and modular inverses carefully.

Also, since C could be up to (1e5)*(1e5)/2 = 5e9, and m up to 1e5, and k up to 2e5, the numerator could be very large.

I need to make sure that I handle large integers without overflow.

In Python, integers can be arbitrarily large, so that's fine.

I need to compute numerator = k * S_0 * C + m * k * (k-1) // 2

And denominator = C * C

Then, gcd = gcd(numerator, denominator)

p = numerator // gcd

q = denominator // gcd

Then, compute p * q^{-1} mod (1e9+7), where q^{-1} is the modular inverse of q modulo 1e9+7.

I need to make sure that q and 1e9+7 are coprime, which they should be since we reduce p and q by their gcd.

But 1e9+7 is a prime number, so as long as q is not a multiple of 1e9+7, which it shouldn't be, since C can be up to 5e9 and 1e9+7 is larger.

Wait, but C could be less than 1e9+7, so I need to handle the modular inverse carefully.

Also, since C is n*(n-1)//2, and n can be up to 1e5, C can be up to about 5e9, which is less than 1e18, so no problem.

I need to implement this efficiently.

Let me outline the steps:

1. Read the number of test cases t.

2. For each test case:

a. Read n, m, k.

b. Compute C = n*(n-1)//2

c. Compute S_0 = sum of f_i for all m friend pairs.

d. Compute numerator = k * S_0 * C + m * k * (k-1) // 2

e. Compute denominator = C * C

f. Compute gcd = gcd(numerator, denominator)

g. p = numerator // gcd

h. q = denominator // gcd

i. Compute q_inv = modular_inverse(q, 1e9+7)

j. Compute result = (p * q_inv) % (1e9+7)

k. Print the result.

I need to implement the modular inverse function.

In Python, I can use the built-in pow function with three arguments to compute the modular inverse: pow(q, -1, mod).

But I need to make sure that q and mod are coprime, which they should be since q is C(n,2) squared divided by gcd, and mod is 1e9+7, a prime.

I need to handle the case where q is a multiple of mod, but since C(n,2) is less than mod for n up to 1e5, q should not be a multiple of mod.

Wait, but C(n,2) can be greater than mod, since mod is 1e9+7 and C(n,2) for n=1e5 is about 5e9, which is less than mod.

Wait, no, 1e5 * 99999 /2 = 4999950000, which is less than 1e9+7.

Wait, no, 1e5 * 99999 /2 = 4999950000, which is greater than 1e9+7.

Wait, 1e5 * 99999 = 9999900000, divided by 2 is 4999950000, which is less than 1e10, but greater than 1e9+7.

So, C can be larger than mod.

Therefore, I need to compute C modulo mod, but since C can be larger than mod, I need to handle it carefully.

Wait, but when computing numerator and denominator, I need to compute them as integers and then take modulo mod at the end.

But since numerator and denominator can be very large, I need to handle them carefully to avoid overflow.

In Python, integers can handle large values, so it's fine.

But to optimize, I can compute numerator modulo mod * denominator, but that might not be necessary.

Wait, perhaps I can compute the entire expression modulo mod.

Wait, but I need to compute p * q^{-1} mod mod, where p and q are reduced.

So, I need to compute numerator and denominator, reduce them by their gcd, then compute p * q^{-1} mod mod.

To handle large numbers, I can compute numerator and denominator modulo mod, but then the gcd might not be correct.

Wait, no, I need to compute numerator and denominator as integers, find their gcd, divide numerator and denominator by gcd to get p and q, then compute p * q^{-1} mod mod.

Since p and q are coprime, and q and mod are coprime (as long as q is not a multiple of mod), I can compute q^{-1} mod mod using pow(q, -1, mod).

I need to ensure that q is not a multiple of mod.

Given that C(n,2) can be larger than mod, but since mod is a prime larger than C(n,2), q = denominator // gcd is less than mod, so q and mod are coprime.

Wait, no, mod is 1e9+7, which is larger than C(n,2) for n up to 1e5.

Wait, 1e9+7 is 1000000007, and C(1e5,2) = 4999950000, which is larger than 1e9+7.

Wait, 1e5 * 99999 /2 = 4999950000, which is larger than 1e9+7.

So, C can be larger than mod.

But in this case, C modulo mod would be C % mod.

I need to handle C modulo mod.

Wait, but C is n*(n-1)//2.

I need to compute C modulo mod.

Similarly, denominator is C squared modulo mod.

But I need to compute numerator and denominator as integers, find their gcd, then compute p and q, and finally p * q^{-1} mod mod.

Given that C can be larger than mod, I need to compute C modulo mod.

But when computing numerator and denominator, I need to keep them as integers before reducing by gcd.

Wait, perhaps it's better to compute C as n*(n-1)//2 modulo mod.

But since n can be up to 1e5, n*(n-1) can be up to 1e10, which is larger than mod, so I need to compute (n*(n-1)) % (mod*2) and then divide by 2.

Wait, but division by 2 modulo mod is multiplication by the inverse of 2 modulo mod.

Wait, perhaps I can compute C modulo mod as (n*(n-1)) // 2 modulo mod.

To compute C modulo mod, I can compute (n*(n-1)) // 2 modulo mod.

Since C is an integer, I need to ensure that this division is exact.

Given that mod is odd (1e9+7 is odd), 2 has an inverse modulo mod, which is (mod+1)//2.

Wait, 2 * inverse â‰¡ 1 mod mod.

Since mod is odd, inverse of 2 is (mod+1)//2.

So, to compute C modulo mod, I can compute (n*(n-1) % mod * inverse_of_2 % mod) % mod.

Similarly, for C squared modulo mod, I can compute (C % mod)^2 % mod.

Then, numerator is k * S_0 * C + m * k * (k-1) // 2.

I need to compute this modulo mod.

But S_0 can be up to m * 1e9, and m can be up to 1e5, so S_0 can be up to 1e14.

Multiplying by C, which is up to 5e9, gives numerator up to 5e19, which is manageable in Python.

But to avoid overflow, I can compute k * S_0 % mod, then multiply by C % mod, and so on.

Wait, perhaps I can compute numerator modulo mod * denominator.

But it's getting complicated.

I think the best way is to compute numerator and denominator as integers, find their gcd, reduce them, and then compute p * q^{-1} mod mod.

Given that Python can handle big integers, it should be fine.

I need to implement this carefully, handling the modular inverse only at the end.

Also, I need to make sure that division by gcd is integer division.

Let me outline the steps again:

For each test case:

1. Read n, m, k.

2. Compute C = n*(n-1)//2.

3. Compute S_0 = sum of f_i for all m friend pairs.

4. Compute numerator = k * S_0 * C + m * k * (k-1) // 2.

5. Compute denominator = C * C.

6. Compute gcd = gcd(numerator, denominator).

7. p = numerator // gcd.

8. q = denominator // gcd.

9. q_inv = pow(q, -1, mod).

10. result = (p * q_inv) % mod.

11. Print the result.

I need to implement this efficiently.

Also, to optimize, since t can be up to 5e4 and sum of m over all test cases is up to 1e5, I need to read all test cases efficiently.

In Python, reading input efficiently is important for large t.

I can read all input at once and process it.

Let me think about input reading.

I can read all input at once using sys.stdin.read(), split it into tokens, and process them one by one.

This is faster than reading line by line for large t.

Ok, I'll proceed like that.

Also, for computing gcd, I can use math.gcd.

Let me sketch the code structure.

Import necessary modules:

import sys

import math

Define mod = 10**9 + 7

Define inverse_of_2 = (mod + 1) // 2

Then, read all input at once:

data = sys.stdin.read().split()

Initialize an index to track the current position in data.

Then, read t from data[0], index = 1.

For each test case in range(t):

Read n = int(data[index])

m = int(data[index+1])

k = int(data[index+2])

index += 3

Compute C = n * (n-1) // 2

Compute S_0 = sum of f_i for m friend pairs.

For m times:

a = int(data[index])

b = int(data[index+1])

f = int(data[index+2])

S_0 += f

index += 3

Then, compute numerator = k * S_0 * C + m * k * (k-1) // 2

compute denominator = C * C

compute gcd = math.gcd(numerator, denominator)

p = numerator // gcd

q = denominator // gcd

q_inv = pow(q, -1, mod)

result = (p * q_inv) % mod

print(result)

This should work.

But I need to handle cases where C is 0, which happens when n=1 or n=0, but according to the problem, n >=2, so C >=1.

Also, need to handle m=0, which is fine.

Let me check the sample inputs.

First sample:

4

100 0 24

2 1 10

1 2 1

3 1 2

2 1 1

5 2 4

1 2 25

3 2 24

Output:

0

55

777777784

40000020

Let's verify the first sample.

First test case:

n=100, m=0, k=24

C = 100*99//2 = 4950

S_0 = 0

numerator = 24 * 0 * 4950 + 0 * 24*23//2 = 0

denominator = 4950 * 495