Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of length 2n, and it contains each integer from 1 to n exactly twice. Then there's an integer k, and I need to find two arrays, l and r, each of length 2k, with specific properties.

First, l should be a subset of the first n elements of the array, and r should be a subset of the last n elements. Also, the bitwise XOR of the elements in l should be equal to the bitwise XOR of the elements in r.

The problem says that at least one pair of l and r always exists, so I don't have to worry about cases where it's impossible.

Alright, let's think about how to approach this.

First, I need to understand what a subset means here. It says that a subset can be obtained by deleting several elements from the sequence and rearranging them in any order. So, essentially, l is any selection of 2k elements from the first n elements, and r is any selection of 2k elements from the last n elements.

My goal is to select these subsets such that their XORs are equal.

I need to find a way to select these subsets.

Let me recall some properties of XOR. XOR is associative and commutative, which means the order doesn't matter, and it's its own inverse. So, if a ⊕ b = c, then a ⊕ c = b, and so on.

Given that, maybe I can compute the XOR of all elements in the first n and the last n, and see if they are equal. But wait, since the entire array contains each number from 1 to n exactly twice, the XOR of the entire array would be 0, because each number XORed with itself is 0.

So, the XOR of the first n elements is some value, let's call it XOR_l, and the XOR of the last n elements is XOR_r. Since the XOR of all elements is 0, XOR_l ⊕ XOR_r = 0, which implies XOR_l = XOR_r.

That's interesting. So, the XOR of the first n elements is equal to the XOR of the last n elements.

Now, I need to select subsets l and r from these parts respectively, each of size 2k, such that their XORs are equal.

Given that, maybe I can select subsets such that their XORs are equal to some value, and since XOR_l = XOR_r, there should be some subsets that satisfy this.

But I need a concrete approach to find such subsets.

Let me consider the XOR of the entire first n elements as XOR_l. If I select a subset l from the first n elements, its XOR is some value, say S. Then, I need to select a subset r from the last n elements such that its XOR is also S.

But since the last n elements have XOR XOR_r, and we know XOR_l = XOR_r, maybe I can find a subset of r that achieves XOR S.

Wait, but I need to select exactly 2k elements for both l and r.

This seems a bit tricky.

Let me think differently. Since each number from 1 to n appears exactly twice in the array, once in the first n and once in the last n.

So, for each number from 1 to n, I have two positions: one in the first n and one in the last n.

I need to choose 2k elements from the first n and 2k elements from the last n such that their XORs are equal.

An idea: since each number appears twice, if I choose both copies of some numbers, their XOR would be 0 for that pair.

Wait, but I need to choose 2k elements, which is an even number, but not necessarily in pairs.

Hmm.

Wait, perhaps I can choose k pairs, each consisting of a number and its copy in the other half, but I need to make sure that the XORs match.

Wait, no, because l has to be from the first half and r from the second half.

Wait, perhaps I can choose some elements from the first half and their counterparts in the second half.

But I need to choose subsets of size 2k each.

Wait, maybe I can choose k pairs of elements, where each pair consists of a number and its copy in the other half, and then select them appropriately.

But I'm getting confused.

Let me try to think in terms of linear algebra over GF(2). Since XOR is essentially addition modulo 2, I can model this as finding subsets whose sum is equal in a vector space over GF(2).

But that might be too complicated for this problem.

Wait, perhaps there's a simpler way.

Let me look at the example provided.

In the first test case:

n = 2, k = 1

a = [1, 2, 2, 1]

So, first n elements: [1, 2]

Last n elements: [2, 1]

Choose l = [2, 1], r = [2, 1]

XOR of l: 2 ⊕ 1 = 3

XOR of r: 2 ⊕ 1 = 3

Which matches.

In the second test case:

n = 6, k = 1

a = [6,4,2,1,2,3,1,6,3,5,5,4]

First n: [6,4,2,1,2,3]

Last n: [1,6,3,5,5,4]

Choose l = [6,4], r = [1,3]

XOR of l: 6 ⊕ 4 = 2

XOR of r: 1 ⊕ 3 = 2

Which matches.

So, in this case, they chose two elements from the first half and two from the second half such that their XORs are equal.

Now, I need a general approach.

Here's an idea:

Since each number appears exactly twice, once in the first n and once in the last n.

Let me consider the XOR of all elements in the first n, which is equal to the XOR of all elements in the last n.

Let's denote this common XOR value as XOR.

Now, if I can find a subset of 2k elements in the first n with XOR equal to some value S, and a subset of 2k elements in the last n with XOR equal to S, then I'm done.

But how do I ensure that such subsets exist?

Given that the total XOR of the first n is XOR, and similarly for the last n.

I need to find subsets of size 2k with XOR equal to S in both halves.

Wait, but the problem says that at least one pair always exists, so I don't have to worry about cases where it's impossible.

Alright, so I need an algorithm that can find such subsets.

Another idea: since I need subsets of size 2k, and k can be up to n/2, and n can be up to 5*10^4, I need an efficient algorithm.

Given the constraints, I need something that runs in linear or near-linear time.

Let me consider the following approach:

1. Compute the frequency of each number in the first n and last n.

2. Try to pair numbers in such a way that their XORs match.

But that seems vague.

Wait, perhaps I can select k pairs of numbers, where each pair consists of a number from the first half and its copy in the second half.

But I need to select 2k elements in l and 2k elements in r.

Wait, perhaps I can select some numbers to include in l and their copies in r.

But I need to ensure that the XORs match.

Wait, maybe I can select a subset of numbers from 1 to n to include in l and their copies in r.

But again, I need to ensure that the XORs match.

This is getting complicated.

Let me think differently.

Suppose I select some numbers for l and some for r, and I keep track of the XORs.

I need to make sure that the XOR of l equals the XOR of r.

Which is equivalent to saying that the XOR of l and r is zero.

Wait, that's interesting.

So, if I consider the combined XOR of l and r, it should be zero.

Given that, perhaps I can model this as finding a subset of 2k elements from the first half and 2k elements from the second half such that their combined XOR is zero.

But I need to choose them in pairs, perhaps.

Wait, maybe I can iterate through the numbers and greedily select pairs.

Wait, here's another idea:

Since each number appears exactly twice, once in the first n and once in the last n, I can think of selecting pairs of numbers, one from each half.

Each pair consists of a number and its copy in the other half.

If I select a pair, their XOR would be zero.

If I select multiple pairs, the combined XOR would still be zero.

Wait, but I need to select 2k elements in l and 2k in r, so I need to select k such pairs.

But k can be up to n/2, so in the worst case, I can select up to n/2 pairs.

But the problem allows that.

So, perhaps selecting k pairs, each consisting of a number from the first half and its copy in the second half, and setting l to contain the first half of each pair and r to contain the second half, would give me l and r with XOR equal to zero, which satisfies the condition.

But the problem allows any S, not necessarily zero.

But in this case, selecting such pairs would give me l and r with XOR equal to zero, which is a valid solution.

So, this seems like a valid approach.

But wait, the problem says that l is a subset of the first n elements, and r is a subset of the last n elements, and they should each have 2k elements.

If I select k pairs, each pair consisting of a number from the first half and its copy in the second half, then l would contain one element from each pair (from the first half), and r would contain the other element from each pair (from the second half).

But wait, each pair consists of two elements: one from the first half and one from the second half.

If I select k such pairs, then l would have k elements, and r would have k elements.

But I need l and r each to have 2k elements.

Wait, that's a problem.

So, selecting k pairs would give me l and r each with k elements, but I need 2k elements each.

Wait, maybe I need to select 2k pairs.

But k can be up to n/2, so 2k can be up to n.

But n can be up to 5*10^4, which is acceptable.

But I need to make sure that I can select 2k pairs.

Given that, perhaps I can select 2k pairs, and set l to contain the first half of each pair, and r to contain the second half.

Then, l and r would each have 2k elements, and their XOR would be zero, since each pair has XOR zero.

Thus, l and r would have the same XOR, which is zero.

This seems like a valid solution.

But I need to implement this efficiently.

Given that n can be up to 5*10^4, and t up to 5000, I need an efficient way to find these pairs.

Let me think about how to implement this.

First, for each number from 1 to n, I can find its positions: one in the first n and one in the last n.

Then, for each number, I can pair these two positions: one in l and one in r.

Then, to select 2k such pairs, I can just select any 2k numbers and take their pairs.

But I need to make sure that in l and r, the elements are from the first n and last n respectively.

Wait, but since each number appears exactly twice, once in the first n and once in the last n, this should be straightforward.

So, in code, for each test case, I can do the following:

1. Read n and k.

2. Read the array a of length 2n.

3. Create a mapping from each number to its positions: one in the first n and one in the last n.

4. Select 2k numbers from 1 to n.

5. For each selected number, add its occurrence in the first n to l, and its occurrence in the last n to r.

6. Output l and r.

But I need to make sure that I don't select the same number more times than it appears.

Wait, but since each number appears exactly twice, and I'm selecting pairs, I need to make sure that I don't select the same number more than its frequency allows.

But in this approach, since I'm selecting 2k distinct numbers, and each number is paired with its copy in the other half, I need to ensure that I can select 2k distinct numbers.

But the problem states that k is up to floor(n/2), so 2k is up to n.

Since there are n distinct numbers, I can select up to n distinct numbers.

So, this should be fine.

Wait, but in the problem, k can be up to floor(n/2), which means 2k can be up to n.

So, as long as I can select 2k distinct numbers, this should work.

But in the mapping, each number appears exactly twice, once in the first n and once in the last n.

So, selecting 2k distinct numbers and taking their occurrences in the first n for l and in the last n for r should give me l and r each with 2k elements.

And since each pair has the same number in l and r, their XOR would be equal.

Wait, but actually, since l and r contain the same numbers (but from different halves), their XOR would be equal.

Yes, that makes sense.

So, this seems like a valid approach.

But looking back at the example, in the first test case, they chose l = [2,1] and r = [2,1], which are the same numbers from different halves.

Their XOR is equal, as shown.

In the second test case, they chose l = [6,4] and r = [1,3], which have different numbers but the same XOR.

In my approach, selecting the same numbers from different halves would ensure that l and r have the same XOR.

But in the second example, they have different numbers but the same XOR.

So, their approach might be different.

But my approach still works because even if I select different numbers, as long as their XORs are equal, it's fine.

Wait, no, in my earlier approach, I was thinking of selecting the same numbers from different halves, but in the second example, they selected different numbers with equal XOR.

So, perhaps there are multiple ways to select l and r.

The problem says that if multiple solutions exist, any one is acceptable.

So, my approach of selecting any 2k distinct numbers and taking their occurrences from the first and second halves respectively should work.

But I need to ensure that I don't select more than the available copies.

Wait, but since each number appears exactly twice, and I'm selecting distinct numbers, and taking one occurrence from each half, it should be fine.

I think this approach is correct.

Now, I need to implement this efficiently.

Given that n can be up to 5*10^4 and t up to 5000, I need an efficient way to map numbers to their positions.

But actually, since I don't need the positions, just need to select 2k distinct numbers and take their occurrences from the first and second halves, I can proceed as follows:

- Create a mapping from each number to its positions: one in the first n and one in the last n.

- Select the first 2k distinct numbers from the first n.

- For each selected number, add its occurrence in the first n to l and its occurrence in the last n to r.

- Output l and r.

This should work.

But I need to make sure that I don't select numbers that don't have occurrences in both halves.

Wait, but the problem guarantees that each number appears exactly twice, once in the first n and once in the last n.

So, this should be fine.

Let me think about potential issues.

Edge cases:

- n = 2, k = 1: as in the first example.

- n = 4, k = 1: select any 2 distinct numbers, take their occurrences from the first and second halves.

- n = 5*10^4, k = floor(n/2): select 2k = n distinct numbers, which is possible since there are n distinct numbers.

I think this covers most cases.

Now, in terms of implementation, I need to:

- Read t, the number of test cases.

- For each test case:

- Read n and k.

- Read the array a of length 2n.

- Create a mapping from each number to its positions: one in the first n and one in the last n.

- Select the first 2k distinct numbers from the first n.

- For each selected number, add its occurrence in the first n to l and its occurrence in the last n to r.

- Output l and r.

Wait, but in the mapping, I need to map each number to its positions.

Given that n can be up to 5*10^4, and t up to 5000, I need an efficient way to do this.

In Python, using dictionaries might be slow for such large n.

Wait, but n is up to 5*10^4, which is manageable.

Let me think about how to implement this efficiently.

Perhaps I can use lists or arrays to store the positions.

But maybe a better way is to iterate through the first n elements and store their positions in a dictionary mapping number to position.

Similarly for the last n.

But actually, since each number appears exactly twice, once in the first n and once in the last n, I can create a dictionary that maps each number to its positions in the first and last halves.

Wait, but I don't need the positions per se, just need to select 2k distinct numbers and take their occurrences from the first and second halves.

So, perhaps I can iterate through the first n elements, keep track of the distinct numbers I've seen, and select the first 2k distinct numbers.

Then, for each selected number, find its position in the first n and last n.

But this might be inefficient for large n.

Wait, perhaps I can use sets to keep track of the selected numbers.

Here's a plan:

- Read t.

- For each test case:

- Read n and k.

- Read the array a of length 2n.

- Create a dictionary mapping each number to its positions: one in the first n and one in the last n.

- Iterate through the first n elements, collect the first 2k distinct numbers.

- For each selected number, add its occurrence in the first n to l and its occurrence in the last n to r.

- Output l and r.

In code, this would look like:

from collections import defaultdict

t = int(input())

for _ in range(t):

n, k = map(int, input().split())

a = list(map(int, input().split()))

# Create mapping

mapping = {}

for i in range(2*n):

if a[i] not in mapping:

mapping[a[i]] = [0, 0]

if i < n:

mapping[a[i]][0] = a[i]

else:

mapping[a[i]][1] = a[i]

# Select first 2k distinct numbers from first n

selected = set()

l = []

r = []

for i in range(n):

if a[i] not in selected:

selected.add(a[i])

l.append(a[i])

r.append(mapping[a[i]][1])

if len(selected) == 2*k:

break

# If fewer than 2k distinct numbers in first n, need to handle

# But according to the constraints, n >= 2, k <= floor(n/2), and t <=5000, so should be fine

# Output l and r

print(' '.join(map(str, l)))

print(' '.join(map(str, r)))

Wait, but in this code, I'm adding a[i] to l and mapping[a[i]][1] to r.

But mapping[a[i]][1] is set to a[i], which is the same number.

Wait, no, mapping[a[i]] should store the positions or the values in the first and second halves.

Wait, I think I'm getting confused.

Let me redefine the mapping.

Since each number appears exactly twice, once in the first n and once in the last n.

So, for each number x, mapping[x] = [pos_in_first_n, pos_in_last_n]

But I don't need the positions, just the values.

Wait, but in the array, the values are repeated, once in the first n and once in the last n.

So, for each number x, there is one occurrence in the first n and one in the last n.

So, mapping[x] = [value_in_first_n, value_in_last_n]

But actually, since it's the same number, value_in_first_n and value_in_last_n are both x.

So, in this case, mapping[x] = [x, x]

Therefore, l would contain x from the first n, and r would contain x from the last n.

But in terms of values, they are both x.

So, l and r would contain the same numbers, just from different halves.

Their XOR would be equal, as required.

But in the second example, they have different numbers with equal XOR.

So, my approach would still work, but their solution chose different numbers.

But since the problem allows any valid pair of l and r, my approach is acceptable.

Therefore, this should be a correct solution.

Wait, but in terms of implementation, I need to make sure that I select 2k distinct numbers from the first n, and then take their corresponding occurrences from the first and last n for l and r respectively.

Also, I need to ensure that I don't exceed the available distinct numbers in the first n.

But given that k <= floor(n/2), and I'm selecting 2k distinct numbers, and n >= 2k, this should be fine.

Let me think about a case where n = 2, k =1: distinct numbers in first n are 2, say [1,2]

Then l = [1,2], r = [1,2]

Their XOR is equal, as in the first example.

In the second example, n=6, k=1: select any 2 distinct numbers from first 6 elements, say [6,4], and their corresponding occurrences in the last 6 elements, which are [1,3]

Wait, but in this case, their solution chose [6,4] and [1,3], which have equal XOR.

But in my approach, I would have selected 2 distinct numbers from the first n, say [6,4], and their corresponding copies in the last n, which are [6,4]

But in their solution, they chose [6,4] and [1,3], which also have equal XOR.

So, both are valid.

But in my approach, I would have l = [6,4] and r = [6,4], which is also valid.

So, my approach is correct.

Therefore, I can proceed with this approach.

Now, let's look at the given program and see if it implements this correctly.

Given program:

def func():

for _ in range(int(input())):

(n, k) = [int(i) for i in input().split()]

a = [int(i) for i in input().split()]

l = [0] * n

r = [0] * n

re = ul = ur = 0

res = []

for i in range(n):

l[a[i] - 1] += 1

for i in range(n, 2 * n):

r[a[i] - 1] += 1

for i in range(n):

if l[a[i] - 1] == 2:

print(a[i], a[i], end=' ')

l[a[i] - 1] = 0

ul += 2

if ul == k * 2:

break

k = 2 * k - ul

if k:

for i in range(n):

if l[a[i] - 1] == 1:

print(a[i], end=' ')

re += 1

res.append(a[i])

if re == k:

break

print()

for i in res:

print(i, end=' ')

if ul != ur:

for i in range(n, 2 * n):

if r[a[i] - 1] == 2:

print(a[i], a[i], end=' ')

r[a[i] - 1] = 0

ur += 2

if ul == ur:

break

print()

So, let's analyze this code.

It seems to be trying to select elements for l and r based on their frequencies.

It first counts the frequency of each number in the first n and last n.

Then, it iterates through the first n elements and prints pairs of elements that appear twice in the first n, up to 2k elements.

Then, if more elements are needed, it selects elements that appear once in the first n.

Similarly, for r, it selects elements from the last n that appear twice.

But this seems a bit convoluted.

In my earlier approach, I suggested selecting 2k distinct numbers from the first n and taking their corresponding occurrences from the first and last n for l and r respectively.

This seems simpler and more straightforward.

But let's see if the given program is correct.

Looking back at the examples, in the first test case:

n = 2, k =1

a = [1,2,2,1]

The program would do:

l = [1:2, 2:1]

Wait, no, l is initialized as [0]*n, which is [0,0]

Then, for i in range(n):

l[a[i]-1] +=1

So, a[0]=1, l[0] +=1 → l=[1,0]

a[1]=2, l[1] +=1 → l=[1,1]

Then, for i in range(n,2n):

r[a[i]-1] +=1

a[2]=2, r[1] +=1 → r=[0,1]

a[3]=1, r[0] +=1 → r=[1,1]

Then, iterate through the first n elements:

i=0, a[0]=1, l[0]=1 !=2 → skip

i=1, a[1]=2, l[1]=1 !=2 → skip

ul=0

Then, k=2-0=2

Select elements from l where l[a[i]-1]==1

i=0, a[0]=1, l[0]=1 → print 1, res=[1], re=1

i=1, a[1]=2, l[1]=1 → print 2, res=[1,2], re=2

Print newline

Then, print res: 1 2

Then, check if ul != ur: ul=0, ur=0 → False, so skip the last loop

Print newline

So, output is:

1 2

1 2

But in the example, it's:

2 1

2 1

So, different ordering, but since subsets don't have to preserve order, it's still correct.

In the second test case:

n=6, k=1

a=[6,4,2,1,2,3,1,6,3,5,5,4]

l=[6:1,4:1,2:1,1:1,2:1,3:1] → [1,1,2,1,2,1]

Wait, no, l is initialized as [0]*6

for i in range(6):

l[a[i]-1] +=1

a[0]=6 → l[5] +=1 → l=[0,0,0,0,0,1]

a[1]=4 → l[3] +=1 → l=[0,0,0,1,0,1]

a[2]=2 → l[1] +=1 → l=[0,1,0,1,0,1]

a[3]=1 → l[0] +=1 → l=[1,1,0,1,0,1]

a[4]=2 → l[1] +=1 → l=[1,2,0,1,0,1]

a[5]=3 → l[2] +=1 → l=[1,2,1,1,0,1]

Then, r is:

for i in range(6,12):

r[a[i]-1] +=1

a[6]=1 → r[0] +=1 → r=[1,0,0,0,0,0]

a[7]=6 → r[5] +=1 → r=[1,0,0,0,0,1]

a[8]=3 → r[2] +=1 → r=[1,0,1,0,0,1]

a[9]=5 → r[4] +=1 → r=[1,0,1,0,1,1]

a[10]=5 → r[4] +=1 → r=[1,0,1,0,2,1]

a[11]=4 → r[3] +=1 → r=[1,0,1,1,2,1]

Then, iterate through first n elements:

i=0, a[0]=6, l[5]=1 !=2 → skip

i=1, a[1]=4, l[3]=1 !=2 → skip

i=2, a[2]=2, l[1]=2 ==2 → print 2 2, set l[1]=0, ul +=2

Now, ul=2, which is equal to k*2=2, so break

Then, k=2*k - ul = 2 - 2 =0

So, no need to select more elements

Print newline

Then, print res, which is empty, so just newline

Then, check if ul != ur: ul=2, ur=0 → yes

So, iterate through last n elements:

i=6, a[6]=1, r[0]=1 !=2 → skip

i=7, a=6, r[5]=1 !=2 → skip

i=8, a=3, r[2]=1 !=2 → skip

i=9, a=5, r[4]=2 ==2 → print 5 5, set r[4]=0, ur +=2 → ur=2

Now, ul=2, ur=2 → break

Print newline

So, output is:

2 2

5 5

But in the example, it's:

6 4

1 3

Which has the same XOR, but the given program outputs [2,2] and [5,5], which also have the same XOR (2⊕2=0, 5⊕5=0), so it's correct.

So, in this case, the program outputs a different solution, but it's still correct.

Therefore, the given program seems to be correct.

Wait, but I need to understand how it works.

It seems to prioritize selecting numbers that appear twice in the first n, and if not enough, select numbers that appear once.

Then, for r, it selects numbers that appear twice in the last n.

But I need to verify if this always results in l and r having the same XOR.

Let me consider another example.

Suppose n=4, k=1

a=[1,2,3,4,1,2,3,4]

According to the program:

l=[1:1,2:1,3:1,4:1]

r=[1:1,2:1,3:1,4:1]

Then, iterate through first n elements:

i=0, a[0]=1, l[0]=1 !=2 → skip

i=1, a[1]=2, l[1]=1 !=2 → skip

i=2, a=3, l[2]=1 !=2 → skip

i=3, a=4, l[3]=1 !=2 → skip

ul=0

Then, k=2-0=2

Select elements from l where l[a[i]-1]==1

i=0, a=1, l[0]=1 → print 1, res=[1], re=1

i=1, a=2, l[1]=1 → print 2, res=[1,2], re=2

Print newline

Then, print res: 1 2

Then, ul != ur: ul=0, ur=0 → False, so skip the last loop

Print newline

So, output is:

1 2

1 2

Which is correct, as 1⊕2=3 for both l and r.

Another test case:

n=3, k=1

a=[1,2,3,3,2,1]

Then, l=[1:1,2:1,3:1]

r=[3:1,2:1,1:1]

Iterate through first n:

i=0, a=1, l[0]=1 !=2 → skip

i=1, a=2, l[1]=1 !=2 → skip

i=2, a=3, l[2]=1 !=2 → skip

ul=0

k=2-0=2

Select elements from l where l[a[i]-1]==1

i=0, a=1, l[0]=1 → print 1, res=[1], re=1

i=1, a=2, l[1]=1 → print 2, res=[1,2], re=2

Print newline

Then, print res: 1 2

Then, ul != ur: ul=0, ur=0 → False, skip last loop

Print newline

Output:

1 2

1 2

Which is correct, as 1⊕2=3 for both l and r.

Seems consistent.

Another test case:

n=4, k=2

a=[1,2,3,4,1,2,3,4]

Then, l=[1:1,2:1,3:1,4:1]

r=[1:1,2:1,3:1,4:1]

Iterate through first n:

No elements with l[a[i]-1]==2, so ul=0

k=4-0=4

Select elements from l where l[a[i]-1]==1

i=0, a=1, l[0]=1 → print 1, res=[1], re=1

i=1, a=2, l[1]=1 → print 2, res=[1,2], re=2

i=2, a=3, l[2]=1 → print 3, res=[1,2,3], re=3

i=3, a=4, l[3]=1 → print 4, res=[1,2,3,4], re=4

Print newline

Then, print res: 1 2 3 4

Then, ul != ur: ul=0, ur=0 → False, skip last loop

Print newline

Output:

1 2 3 4

1 2 3 4

Which is correct, as 1⊕2⊕3⊕4=4 for both l and r.

Seems correct.

Another test case:

n=3, k=1

a=[1,2,1,2,3,3]

Then, l=[1:2,2:1,3:0]

r=[2:1,3:2]

Iterate through first n:

i=0, a=1, l[0]=2 ==2 → print 1 1, set l[0]=0, ul=2

Break, since ul == k*2=2

k=2-2=0

No need to select more elements

Print newline

Then, print res (empty), so just newline

Then, ul != ur: ul=2, ur=0 → True

Iterate through last n:

i=3, a=2, r[1]=1 !=2 → skip

i=4, a=3, r[2]=2 ==2 → print 3 3, set r[2]=0, ur +=2 → ur=2

Now, ul=2, ur=2 → break

Print newline

Output:

1 1

3 3

Which is correct, as 1⊕1=0 and 3⊕3=0.

Good.

Seems like the program works correctly for these cases.

Therefore, I conclude that the given program is correct.

**Final Answer**

\[ \boxed{\text{true}} \]