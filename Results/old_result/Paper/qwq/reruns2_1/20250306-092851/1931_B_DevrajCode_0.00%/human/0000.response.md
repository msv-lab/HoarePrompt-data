Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n containers of water, each containing a certain amount of water. The goal is to make sure that all containers have the same amount of water, and I can only pour water from a container with a lower index to one with a higher index. Also, it's given that the total sum of water is divisible by n, so it's possible in theory to have equal amounts in each container.

First, I need to understand the constraints and what operations are allowed. The key point here is that I can only pour water from a container i to a container j if i < j. That means water can only move from left to right, and I can't pour water back from right to left.

Given that, I need to find out if it's possible to make all containers have the same amount of water by only moving water from left to right.

Let me think about what the target amount of water should be in each container. Since the total sum is divisible by n, the target amount is sum(a)/n. Let's call this target.

Now, if I go through the containers from left to right, I need to ensure that at each step, the cumulative water up to that point doesn't exceed what it should be to reach the target.

Wait, maybe I should think in terms of deficits and surpluses. Each container has a certain amount of water. If a container has more than the target, it has a surplus, and if it has less, it has a deficit. Since I can only pour water from left to right, surpluses in earlier containers can be used to fill deficits in later containers.

But there's a catch: I can only pour water from a lower index to a higher index. So, any surplus in a container can only be used to help future containers, not past ones.

Given that, I need to make sure that at any point, the cumulative surplus is enough to cover any deficits that come after.

Wait, maybe I should approach this by iterating through the containers from left to right, keeping track of the cumulative difference from the target.

Let's try that.

Initialize a variable, say, "extra", which represents the extra water I have so far, beyond the target.

Start from the first container:

- If a[0] > target, then extra = a[0] - target

- If a[0] < target, then I have a deficit, but I can't fill it from future containers because I can only pour from left to right. So, if a[0] < target, it's impossible to make up for that deficit because I can't pour water backwards.

Wait, but in the example given, in the third test case, they manage to make all containers equal. Let me check that.

In the third test case:

n = 5

a = [4,5,2,1,3]

sum(a) = 4+5+2+1+3 = 15

target = 15/5 = 3

So, target is 3.

Now, let's see:

- Container 1: 4 > 3, surplus of 1

- Container 2: 5 > 3, surplus of 2

- Container 3: 2 < 3, deficit of 1

- Container 4: 1 < 3, deficit of 2

- Container 5: 3 == 3, no surplus or deficit

Now, can I use the surplus from container 1 and 2 to cover the deficits in 3 and 4?

From container 1, surplus of 1, and from container 2, surplus of 2, total surplus of 3.

Deficits: container 3 needs 1, container 4 needs 2, total deficit of 3.

So, total surplus equals total deficit, which is consistent with the sum being divisible by n.

But the question is whether I can pour the surplus from left to right to cover the deficits.

In this case:

- After container 1: extra = 1

- Move to container 2: a[2] - target = 5 - 3 = 2, so extra += 2 => extra = 3

- Move to container 3: a[3] - target = 2 - 3 = -1, so extra += (-1) = 2

- Move to container 4: a[4] - target = 1 - 3 = -2, so extra += (-2) = 0

- Move to container 5: a[5] - target = 3 - 3 = 0, so extra += 0 = 0

At no point does extra become negative, which means that at every step, the cumulative surplus is enough to cover the cumulative deficit so far.

Therefore, it's possible to make all containers equal.

In contrast, consider the fourth test case:

n = 3

a = [1,2,3]

sum(a) = 6, target = 2

- Container 1: 1 < 2, deficit of 1

- Container 2: 2 == 2, no surplus or deficit

- Container 3: 3 > 2, surplus of 1

Total surplus = 1, total deficit = 1

But in this case, the deficit is in container 1, and the surplus is in container 3.

However, since I can only pour from left to right, I cannot use the surplus in container 3 to fill the deficit in container 1.

Therefore, it's impossible to make all containers equal.

From these observations, it seems that the condition for it being possible is that at no point, when traversing from left to right, does the cumulative sum of (a[i] - target) become negative.

In other words, as I iterate through the containers from left to right, keeping a running sum of (a[i] - target), this running sum should never be negative.

If that's the case, then I can ensure that all deficits are covered by previous surpluses.

Wait, but in the third test case, the running sum is:

After container 1: 1

After container 2: 1 + 2 = 3

After container 3: 3 -1 = 2

After container 4: 2 -2 = 0

After container 5: 0 +0 = 0

Never negative, and it works.

In the fourth test case:

After container 1: -1

Which is negative, so not possible.

Similarly, in the second test case:

n = 2

a = [1,3]

target = 2

After container 1: 1 - 2 = -1, which is negative, so not possible.

In the fifth test case:

n = 7

a = [4,5,5,0,6,4,4]

target = 4

After container 1: 4 - 4 = 0

After container 2: 0 + (5-4) = 1

After container 3: 1 + (5-4) = 2

After container 4: 2 + (0-4) = -2, which is negative, so not possible.

In the sixth test case:

n = 7

a = [6,5,5,1,3,4,4]

target = 4

After container 1: 6 - 4 = 2

After container 2: 2 + (5-4) = 3

After container 3: 3 + (5-4) = 4

After container 4: 4 + (1-4) = 1

After container 5: 1 + (3-4) = 0

After container 6: 0 + (4-4) = 0

After container 7: 0 + (4-4) = 0

Never negative, so possible.

This seems to hold up.

Therefore, the condition is that the cumulative sum of (a[i] - target), from left to right, should never be negative at any step.

If that's the case, then the function provided seems to implement this logic.

Let's look at the code:

def func_1(n, a):

    total_water = sum(a)

    if total_water % n != 0:

        return 'No'

    target = total_water // n

    container = 0

    for water in a:

        container += water - target

        if container < 0:

            return 'No'

    return 'Yes'

Wait, but in the problem statement, it's given that the sum is always divisible by n, so the if total_water % n != 0: return 'No' is redundant.

But it doesn't hurt, I guess.

Anyway, the logic seems to be:

- Calculate the target amount.

- Initialize a variable "container" to keep track of the cumulative sum of (a[i] - target).

- Iterate through each a[i], update container by adding (a[i] - target).

- If at any point container < 0, return 'No'.

- If the loop completes without container being negative, return 'Yes'.

This aligns with the reasoning I had earlier.

So, in the third test case, it would go through without container being negative, and return 'Yes'.

In the fourth test case, container becomes -1 after the first element, so return 'No'.

In the fifth test case, container becomes -2 after the fourth element, so return 'No'.

In the sixth test case, container never goes negative, so return 'Yes'.

Seems correct.

But wait, in the first test case, n=1, a=[43], sum is 43, which is divisible by 1. target=43. container = 43 - 43 = 0. Never negative, so 'Yes', which is correct.

Second test case, n=2, a=[1,3], sum=4, target=2. container = 1-2 = -1 < 0, so 'No', which is correct.

Third test case, as we saw, 'Yes'.

Fourth test case, 'No'.

Fifth test case, 'No'.

Sixth test case, 'Yes'.

Matches the sample output.

So, it seems the function is correct.

But let's think about edge cases.

Edge case 1: n=1, a=[0], which is allowed since a_i can be 0. sum=0, target=0. container=0-0=0, 'Yes'.

Edge case 2: n=2, a=[0,0], sum=0, target=0. container=0-0=0, then 0-0=0, 'Yes'.

Edge case 3: n=2, a=[0,1], sum=1, which is not divisible by 2. But according to the problem, it's guaranteed that sum is divisible by n, so this won't happen.

Wait, in the function, there's a check for sum % n != 0, but according to the problem, it's guaranteed that sum is divisible by n. So, perhaps that check is unnecessary.

But, since it's there, and it's correct, it's fine.

Another edge case: n=2, a=[2,2], target=2. container=2-2=0, then 2-2=0, 'Yes'.

Another edge case: n=3, a=[3,3,3], target=3. container=3-3=0, then 3-3=0, then 3-3=0, 'Yes'.

Another edge case: n=3, a=[2,3,4], target=3. container=2-3=-1 <0, 'No'.

Wait, but in this case, total sum is 9, divisible by 3. But since container becomes negative at the first step, it's 'No'.

But according to our earlier reasoning, it should be 'No' because the first container has less than the target and can't be filled from future containers.

Hence, correct.

Another test case: n=4, a=[1,2,3,4], sum=10, target=2.5, but a_i are integers, so target should be integer. According to the problem, sum is guaranteed to be divisible by n, so target is integer.

Wait, in the problem statement, a_i are integers, and sum is divisible by n, so target is integer.

Hence, no issue.

Another test case: n=4, a=[4,2,3,1], target=2.5? Wait, sum=10, target=2.5, but a_i are integers, so target is integer. Wait, no, 10 / 4 = 2.5, but according to the problem, sum is divisible by n, so perhaps this test case is invalid.

Wait, in the problem statement, it says "the sum of a_i is divisible by n", meaning sum % n == 0, so target is an integer.

Hence, target is always an integer.

Wait, in the sample input, all targets are integers.

Hence, no issue.

Therefore, the function seems correct.

I think the reasoning holds up, and the function implements the correct logic.

Hence, Correctness: **True**

**Final Answer**

\[ \boxed{\text{See explanation}} \]