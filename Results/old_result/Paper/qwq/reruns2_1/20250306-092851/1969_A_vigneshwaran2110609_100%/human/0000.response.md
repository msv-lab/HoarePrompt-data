Alright, I've got this problem to solve. Let's see what it's asking for. Monocarp wants to throw a party and invite some of his friends, but there are some conditions. He has n friends, and each friend has a best friend, which is specified by p_i. The key points are:

1. All p_i are distinct and p_i != i, meaning everyone has exactly one best friend, and no one is their own best friend.

2. A friend i will come to the party only if both i and p_i receive an invitation.

3. Monocarp wants at least 2 friends to come to the party.

4. He needs to send the minimum number of invitations to achieve this.

First, I need to understand the relationship between the friends and their best friends. Since p_i are distinct and p_i != i, this forms a permutation of the friends where no element maps to itself. In other words, it's a derangement.

Let me think about what this means. If I have friend A, and their best friend is B, then B's best friend must be someone else because p_i are distinct and p_i != i. So, it's like a matching or a pairing among the friends.

Wait, but the problem says that p_i are distinct and p_i != i, so it's a permutation without fixed points. That sounds like a derangement, as I thought earlier.

Now, the condition for a friend to come to the party is that both they and their best friend receive an invitation. So, if I invite friend i, but not p_i, friend i won't come. Similarly, if I invite p_i but not i, friend i still won't come. Only if both are invited, friend i will come.

But here's a twist: the problem says "each invitation is sent to exactly one of the friends." Wait, that seems a bit confusing. Does it mean that invitations are sent individually to friends, or that a single invitation can cover multiple friends? I think it means that each invitation is sent to one friend, so I'm sending a set of invitations to a subset of friends, and for each friend in that subset, they receive one invitation.

Wait, no, the problem says: "Each invitation is sent to exactly one of the friends." So, if I send an invitation to friend i, that counts as one invitation, and friend i receives it. Similarly, inviting friend j is another invitation.

So, the total number of invitations is equal to the number of friends I decide to invite.

Now, the condition for friend i to come is that both i and p_i are invited. So, if I invite i and p_i, then friend i will come. Friend p_i might also come if p_p_i (the best friend of p_i) is also invited.

Wait, but the problem says: "the i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation." So, it's only dependent on i and p_i both being invited.

It doesn't matter who p_p_i is in this context, unless p_p_i is also relevant for other friends.

Let me try to think in terms of pairs. Since p_i is a derangement, the structure can be represented as cycles. Because in a derangement, the permutation can be decomposed into cycles of length at least 2.

For example, in the first test case:

n = 5

p = [3, 1, 2, 5, 4]

So, friend 1's best friend is 3, friend 3's best friend is 2, friend 2's best friend is 1, friend 5's best friend is 4, and friend 4's best friend is 5.

So, this forms two cycles: 1-3-2 and 4-5.

In this case, if I invite friends 4 and 5, then friend 4 will come because both 4 and 5 are invited, and friend 5 will come because both 5 and 4 are invited. So, both will come, satisfying the condition of at least 2 friends coming.

Another example:

n = 4

p = [2, 3, 4, 1]

Cycle: 1-2-3-4, a single cycle of length 4.

If I invite 1, 2, and 3, then:

- Friend 1 will come if both 1 and 2 are invited. Yes, both are invited.

- Friend 2 will come if both 2 and 3 are invited. Yes.

- Friend 3 will come if both 3 and 4 are invited. 3 is invited, but 4 is not invited, so friend 3 doesn't come.

- Friend 4 will come if both 4 and 1 are invited. 4 is not invited, so doesn't come.

So, friends 1 and 2 will come.

But the problem mentions that in this case, the minimum number of invitations is 3, which makes sense because to get at least 2 friends to come, I need to invite 1, 2, and 3.

In the third test case:

n = 2

p = [2, 1]

So, friends 1 and 2 are each other's best friends.

If I invite both 1 and 2, then both will come, since each is invited and their best friend is also invited.

So, the minimum number of invitations is 2.

From these examples, I need to find a general approach to determine the minimum number of invitations needed to ensure that at least 2 friends come to the party.

Let me think about the structure of p_i. Since p_i is a derangement (no fixed points and all p_i are distinct), the permutation decomposes into disjoint cycles of length at least 2.

In a cycle of length k, say a1 -> a2 -> ... -> ak -> a1, to have at least one friend from this cycle come to the party, I need to invite two consecutive friends in the cycle.

Wait, no. To have a friend come, I need to invite both the friend and their best friend.

So, in a cycle, if I invite a friend and their best friend, then that friend will come. But perhaps there are ways to cover multiple friends with fewer invitations.

Let me consider a cycle of length 2: a and b are each other's best friends.

If I invite both a and b, then both will come. So, with 2 invitations, I get 2 friends coming.

If I invite only one of them, say a, then a won't come because b isn't invited, and b won't come because a is invited but b isn't invited. So, no one comes.

Therefore, for a cycle of length 2, I need to invite both to get both to come.

In a cycle of length 3: a -> b -> c -> a.

If I invite a and b, then a will come because a and p_a = b are invited. b will come because b and p_b = c are invited. But c is invited, and p_c = a is invited, so c will also come.

Wait, no. If I invite a and b, then:

- a is invited, p_a = b is invited, so a comes.

- b is invited, p_b = c is invited, so b comes.

- c is invited, p_c = a is invited, so c comes.

So, with 2 invitations, I get all 3 coming.

Is that possible? Wait, but in the second test case, with a cycle of 4, inviting 3 got 2 to come, but inviting 2 didn't get anyone to come.

Wait, in the cycle of 3, if I invite a and b, then a, b, and c all come. So, with 2 invitations, I get 3 friends coming.

Is there a better way? Can I invite fewer than 2? No, because if I invite only one, say a, then p_a = b is not invited, so a doesn't come. Even if I invite c, p_c = a is invited, but p_c's invitation is already covered.

Wait, if I invite a and c, then:

- a is invited, p_a = b is not invited, so a doesn't come.

- c is invited, p_c = a is invited, so c comes.

- b is not invited, so doesn't come.

So, only c comes, which is not enough since I need at least 2 to come.

Therefore, in a cycle of 3, inviting 2 consecutive friends gets all 3 to come, which is better.

Wait, but in a cycle of 3, inviting any 2 consecutive friends will make all 3 come, which is optimal.

In a cycle of 4: a -> b -> c -> d -> a.

If I invite a, b, and c:

- a is invited, p_a = b is invited, so a comes.

- b is invited, p_b = c is invited, so b comes.

- c is invited, p_c = d is invited, so c comes.

- d is invited, p_d = a is invited, so d comes.

So, with 3 invitations, all 4 come.

Is there a way to get at least 2 to come with fewer invitations? Let's see.

If I invite a and b:

- a is invited, p_a = b is invited, so a comes.

- b is invited, p_b = c is not invited, so b doesn't come.

- c is not invited, so doesn't come.

- d is not invited, so doesn't come.

So, only a comes, which is not enough.

If I invite a and c:

- a is invited, p_a = b is not invited, so a doesn't come.

- c is invited, p_c = d is not invited, so c doesn't come.

- b and d don't come.

So, no one comes.

If I invite a and d:

- a is invited, p_a = b is not invited, so a doesn't come.

- d is invited, p_d = a is invited, so d comes.

- b and c don't come.

So, only d comes, which is not enough.

Therefore, in a cycle of 4, I need to invite at least 3 to get at least 2 to come.

Hence, for cycles of even length, it seems I need to invite n/2 friends to get at least 2 to come.

Wait, in the cycle of 4, inviting 3 gets all 4 to come, but inviting 2 doesn't get at least 2 to come.

Wait, but in the cycle of 3, inviting 2 gets all 3 to come.

So, perhaps for cycles of length k, inviting ceil(k/2) friends is sufficient to get at least 2 to come.

Wait, in cycle of 4, inviting 2 doesn't get at least 2 to come, but inviting 3 does.

Wait, maybe it's floor((k+1)/2).

Wait, for k=3, floor((3+1)/2)=2, which matches inviting 2 gets all 3 to come.

For k=4, floor((4+1)/2)=2, but inviting 2 doesn't get at least 2 to come. Wait, that doesn't match.

Wait, perhaps it's different.

Let me think differently. Suppose I select a subset S of friends to invite.

For each friend i:

- If i and p_i are both in S, then i comes.

- Else, i doesn't come.

I need to maximize the number of friends who come, but with minimizing the size of S, but with the constraint that at least 2 come.

Wait, but the problem is to minimize the number of invitations such that at least 2 friends come.

So, it's a minimization problem with a constraint.

This sounds like a set cover problem or something similar, possibly related to graph theory.

Let me try to model this as a graph.

Each friend is a node, and there is an edge between i and p_i, since they are best friends.

Since p_i is a derangement, the graph will consist of disjoint cycles, each of length at least 2.

In this graph, to make friend i come, I need to invite both i and p_i, which means selecting both nodes in the edge corresponding to (i, p_i).

Then, the problem reduces to selecting a subset of nodes such that at least 2 friends (nodes) have both ends of their edges selected.

Wait, more precisely, for each node to come, both it and its neighbor (p_i) must be invited.

So, if I select a node and its neighbor, then that node comes.

I need at least 2 nodes to come, with minimal selection of nodes.

Let me consider that for each node that comes, I need to select it and its neighbor.

But there might be overlaps.

In a cycle of length 3: a-b, b-c, c-a.

If I select a and b, then a comes (since a and b are selected), and b comes (since b and c are selected), and c comes (since c and a are selected). So, all come, with selecting 2.

In a cycle of 4: a-b, b-c, c-d, d-a.

If I select a, b, c, then a comes (a and b selected), b comes (b and c selected), c comes (c and d selected), d does not come (d not selected). So, a, b, c come, with selecting 3.

But is there a way to select fewer than 3 in a cycle of 4 to get at least 2 to come?

From earlier, selecting any 2 doesn't get at least 2 to come.

Hence, in cycle of 4, minimum invitations are 3.

Wait, but in the first test case, with two cycles of length 3 and 2, selecting 2 invitations can get 2 friends to come.

Wait, in the first test case:

n=5, p=[3,1,2,5,4], which is two cycles: 1-3-2 and 4-5.

To get at least 2 friends to come:

Option 1: Select 1 and 3. Then, 1 comes (1 and 3 invited), 3 comes (3 and 2 invited), 2 comes (2 and 1 invited), 4 and 5 don't come. So, 1,2,3 come, with selecting 2.

Option 2: Select 4 and 5. Then, 4 comes (4 and 5 invited), 5 comes (5 and 4 invited). So, 4 and 5 come, with selecting 2.

So, in this case, selecting 2 invitations can get at least 2 friends to come.

In the second test case:

n=4, p=[2,3,4,1], which is one cycle: 1-2-3-4.

From earlier, selecting any 2 doesn't get at least 2 to come, but selecting 3 gets all to come.

Hence, minimum invitations are 3.

In the third test case:

n=2, p=[2,1], which is one cycle of length 2.

Selecting both 1 and 2 gets both to come.

So, minimum invitations are 2.

Hence, the pattern seems to be:

- For cycles of length 2, need to select both to get both to come.

- For cycles of length 3, selecting 2 gets all 3 to come.

- For cycles of length 4, selecting 3 gets all to come.

- In general, for cycles of length k, selecting ceil(k/2) gets all to come.

But in the second test case, with cycle length 4, selecting 3 gets all to come, but selecting 2 doesn't get at least 2 to come.

Wait, but in the first test case, with a cycle of length 3 and a cycle of length 2, selecting 2 gets at least 2 to come.

So, perhaps the strategy is to select the minimal number for each cycle such that the total number of friends coming is at least 2.

Wait, but the invitations are sent across all cycles.

Wait, no, the invitations are sent to specific friends, and the coming is determined per friend based on their best friend also being invited.

Wait, perhaps it's better to think in terms of selecting edges in the cycle graph.

In a cycle, selecting an edge (i, p_i) means inviting both i and p_i, but in this problem, invitations are sent to individual friends, not edges.

Wait, but in this problem, selecting a node requires its best friend also to be selected for it to come.

It's getting a bit tangled. Maybe I need to think differently.

Let me consider that in a cycle of length k, the minimal number of invitations needed to get at least 2 friends to come is:

- For k=2: select both, which is 2 invitations, getting 2 friends.

- For k=3: select 2, getting all 3 to come.

- For k=4: select 3, getting all 4 to come.

- For k=5: select 3, getting all 5 to come.

Wait, for k=5, selecting 3: suppose I select 1,2,3 in a cycle 1-2-3-4-5.

Then:

- 1 comes if 1 and 2 are invited. Yes.

- 2 comes if 2 and 3 are invited. Yes.

- 3 comes if 3 and 4 are invited. 3 is invited, but 4 is not, so 3 doesn't come.

- 4 comes if 4 and 5 are invited. 4 is not invited, so doesn't come.

- 5 comes if 5 and 1 are invited. 5 is not invited, so doesn't come.

So, only 1 and 2 come.

So, with selecting 3 in a cycle of 5, I can get at least 2 to come.

Is there a way to select fewer than 3? Selecting 2:

- Select 1 and 2: 1 comes, 2 comes, 3 comes (since 3 and 4 are invited? Wait, 3 is not invited, so no.

Wait, in this case, selecting 1 and 2:

- 1 comes (1 and 2 invited).

- 2 comes (2 and 3 invited). Wait, 3 is not invited, so 2 doesn't come.

- 3 comes if 3 and 4 are invited. 3 is not invited, so doesn't come.

- 4 and 5 similarly don't come.

So, only 1 comes, which is not enough.

Hence, in a cycle of 5, selecting 3 is minimal to get at least 2 to come.

Hence, perhaps for any cycle of length k, selecting ceil(k/2) is sufficient to get at least 2 to come.

Wait, for k=3, ceil(3/2)=2, which matches.

For k=4, ceil(4/2)=2, but in practice, selecting 2 doesn't get at least 2 to come, so maybe it's floor((k+1)/2).

Wait, floor((4+1)/2)=2, but in practice, need to select 3, which is more than 2.

Hmm, maybe it's more complex.

Alternatively, perhaps in any cycle of length k, the minimal number of invitations to get at least 2 to come is k if k is even, and k-1 if k is odd.

Wait, that seems too high.

Wait, in k=3, selecting 2 gets all to come.

In k=4, selecting 3 gets all to come.

In k=5, selecting 3 gets at least 2 to come.

So, perhaps it's ceil(k/2).

But in k=4, ceil(4/2)=2, but selecting 2 doesn't get at least 2 to come.

Wait, maybe it's floor((k+1)/2).

For k=3, floor((3+1)/2)=2, which matches.

For k=4, floor((4+1)/2)=2, but selecting 2 doesn't get at least 2 to come.

Wait, perhaps it's something else.

Let me look for a pattern:

- k=2: select 2

- k=3: select 2

- k=4: select 3

- k=5: select 3

- k=6: select 4?

Wait, for k=6, selecting 4: select 1,2,3,4.

Then:

- 1 comes (1 and 2 invited)

- 2 comes (2 and 3 invited)

- 3 comes (3 and 4 invited)

- 4 comes (4 and 5 invited). But 5 is not invited, so 4 doesn't come.

- 5 comes if 5 and 6 are invited. 5 is not invited, so doesn't come.

- 6 comes if 6 and 1 are invited. 6 is not invited, so doesn't come.

So, only 1,2,3 come.

With selecting 3 in k=6, for example, selecting 1,2,3:

- 1 comes (1 and 2 invited)

- 2 comes (2 and 3 invited)

- 3 comes (3 and 4 invited). 4 is not invited, so 3 doesn't come.

- 4,5,6 don't come.

So, only 1 and 2 come.

Hence, in k=6, selecting 3 gets at least 2 to come.

But perhaps there's a better way.

Wait, in general, it seems that for any cycle of length k >= 2, selecting ceil(k/2) invitations is enough to get at least 2 friends to come.

Wait, in k=4, ceil(4/2)=2, but selecting 2 doesn't get at least 2 to come, as per the second test case.

Wait, maybe it's actually floor((k+1)/2).

For k=3: floor(4/2)=2, which matches.

For k=4: floor(5/2)=2, but in practice, need to select 3.

Wait, perhaps it's k - floor(k/2).

Wait, for k=3: 3 - 1 = 2, which matches.

For k=4: 4 - 2 = 2, but need to select 3.

No, doesn't match.

Alternatively, perhaps it's floor((k+1)/2).

Wait, in k=4, floor(5/2)=2, but need to select 3.

Still doesn't match.

Alternatively, perhaps it's ceil(k/2).

For k=3: ceil(3/2)=2, which matches.

For k=4: ceil(4/2)=2, but need to select 3.

Doesn't match.

Wait, maybe it's floor((k+1)/2), but in k=4, that's 2, but need to select 3.

Hmm.

Alternatively, perhaps it's k - ceil(k/3) or something similar.

Wait, this is getting too complicated.

Maybe I need to think in terms of selecting a subset of friends to invite such that the number of friends who have both themselves and their best friend invited is at least 2, and minimize the number of invitations.

This sounds like a problem that can be modeled using graph theory, where friends are nodes and best friendships are edges.

In this graph, since p_i are distinct and p_i != i, the graph is a union of disjoint cycles, each of length at least 2.

In such a graph, to have a friend come, we need to select both ends of an edge.

So, selecting an edge means inviting both friends that form that edge.

But in this problem, invitations are sent to individual friends, not edges.

Wait, but selecting both ends of an edge is equivalent to selecting a pair of friends who are best friends.

So, in terms of the cycle, selecting a pair that are consecutive in the cycle.

Now, in a cycle of length k, the number of such pairs is k.

Each pair corresponds to an edge in the cycle.

Now, for each such pair selected (i.e., inviting both i and p_i), the friend i comes.

So, to have at least 2 friends come, we need to select at least 2 such pairs.

But selecting a pair means inviting two friends.

However, in cycles with k >= 3, selecting one pair can cause multiple friends to come.

For example, in k=3, selecting one pair makes all three come.

Wait, no, in k=3, selecting one pair makes all three come, as seen earlier.

In k=4, selecting two pairs can make all four come, but in the second test case, selecting only two pairs doesn't necessarily make two friends come.

Wait, perhaps I need to think in terms of selecting a subset of edges such that the number of friends who have both their invitation and their best friend's invitation is at least 2.

This seems complicated.

Maybe I should look for a different approach.

Let me consider that in any cycle of length k, the minimal number of invitations needed to get at least 2 friends to come is equal to the minimal number of friends to invite such that at least 2 friends have