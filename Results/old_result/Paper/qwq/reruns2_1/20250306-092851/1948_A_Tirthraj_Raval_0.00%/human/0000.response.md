Alright, I have this problem to solve. Let's read it carefully.

So, I'm given an integer n, and I need to build a string of uppercase Latin letters such that there are exactly n "special" characters in this string. A special character is defined as one that is equal to exactly one of its neighbors.

For example, in the string "AAABAACC", there are 6 special characters at positions 1, 3, 5, 6, 7, and 8.

First, I need to understand what makes a character special. A character is special if it is equal to exactly one of its neighbors. That means:

- If it's the first character, it only has a right neighbor.

- If it's the last character, it only has a left neighbor.

- If it's in the middle, it has both left and right neighbors.

So, for the first character, it's special if it equals its immediate right neighbor.

For the last character, it's special if it equals its immediate left neighbor.

For any character in between, it's special if it equals exactly one of its two neighbors (left or right, but not both).

Given that, I need to construct a string where the total number of such special characters is exactly n.

Constraints:

- The string should be composed of uppercase Latin letters.

- The length of the string should be at most 200.

- For each test case (up to 50), I need to either output "YES" followed by a suitable string or "NO" if no such string exists.

Example provided:

Input:

3

6

1

2

Output:

YES

AAABAACC

NO

YES

MM

Wait, in the example, for n=6, the output is "AAABAACC", which has 6 special characters as per the problem statement.

For n=1, it's "NO", meaning no string can be constructed with exactly 1 special character.

For n=2, the output is "YES" with "MM".

Wait, "MM" has two characters, both 'M'. Let's see if they are special.

- First 'M': it equals its right neighbor 'M', so it equals one neighbor (the right one).

- Last 'M': it equals its left neighbor 'M', so it equals one neighbor (the left one).

So, both characters are special. Hence, n=2 is satisfied.

But for n=1, it's "NO". Why is that?

Let's think about n=1.

If I have a string with one character, say "A". Then, that single 'A' equals no neighbor because it has no neighbors. So, number of special characters is 0.

If I have two characters, "AA". Then, both 'A's equal their neighbor, so both are special, n=2.

If I have two characters, "AB". Then, neither 'A' nor 'B' equals their neighbor, so n=0.

If I have three characters, "AAB".

- First 'A': equals the next 'A', so special.

- Second 'A': equals the previous 'A' and the next 'B', so equals both neighbors, not special.

- Third 'B': equals no neighbor, not special.

So, only the first 'A' is special, n=1.

Wait, but according to the example, n=1 is "NO". But in this string "AAB", n=1.

Wait, maybe I miscalculated.

Let's re-examine "AAB".

- Index 1: 'A' equals index 2 'A', so special.

- Index 2: 'A' equals index 1 'A' and index 3 'B', so equals one neighbor ('A'), so special.

- Index 3: 'B' equals no neighbors, not special.

Wait, in this case, n=2, not n=1.

Wait, perhaps I made a mistake.

Wait, in "AAB":

- Index 1: 'A' equals index 2 'A', so special.

- Index 2: 'A' equals index 1 'A' and index 3 'B', so equals one neighbor ('A'), so special.

- Index 3: 'B' equals no neighbors, not special.

So, total special characters: 2.

Wait, but according to the problem, in "AAABAACC", positions 1,3,5,6,7,8 are special, which is 6.

Wait, perhaps my understanding is incorrect.

Wait, let's revisit the definition.

A character is special if it is equal to exactly one of its neighbors.

So, for a character in the middle:

- If it equals the left neighbor but not the right, it's special.

- If it equals the right neighbor but not the left, it's special.

- If it equals both or neither, it's not special.

For the first character:

- It only has a right neighbor, so it's special if it equals the right neighbor.

For the last character:

- It only has a left neighbor, so it's special if it equals the left neighbor.

Given that, in "AAB":

- Index 1: 'A' equals index 2 'A', so special.

- Index 2: 'A' equals index 1 'A' and index 3 'B', so equals one neighbor, special.

- Index 3: 'B' does not equal index 2 'A', so not special.

Hence, n=2.

Wait, but in the problem statement, for n=1, the answer is "NO". So, perhaps there is no string where n=1.

Let me try to find a string with n=1.

Consider "A":

- No neighbors, so n=0.

"A A":

- Both equal each other, so n=2.

"A B":

- Neither equals neighbor, so n=0.

"A A B":

- First 'A' equals second 'A', special.

- Second 'A' equals first 'A' and third 'B', so equals one neighbor, special.

- Third 'B' does not equal second 'A', so not special.

Total n=2.

"A B A":

- First 'A' equals third 'A', special.

- Second 'B' does not equal neighbors, not special.

- Third 'A' equals first 'A', special.

Total n=2.

"A B B":

- First 'A' does not equal second 'B', not special.

- Second 'B' equals third 'B', special.

- Third 'B' equals second 'B', special.

Total n=2.

"A A A":

- First 'A' equals second 'A', special.

- Second 'A' equals both neighbors, not special.

- Third 'A' equals second 'A', special.

Total n=2.

"A B C":

- First 'A' does not equal second 'B', not special.

- Second 'B' does not equal neighbors, not special.

- Third 'C' does not equal second 'B', not special.

Total n=0.

It seems that any string I try either has n=0 or n=2 or more.

Is it possible to have n=1? It seems not.

Hence, for n=1, the answer should be "NO".

Similarly, for n=6, "AAABAACC" has n=6.

Let's verify:

"AAABAACC"

Indices:

1: 'A' equals index 2 'A', special.

2: 'A' equals index 1 'A' and index 3 'A', not special.

3: 'A' equals index 2 'A' and index 4 'B', special.

4: 'B' equals index 3 'A' and index 5 'A', special.

5: 'A' equals index 4 'B' and index 6 'A', special.

6: 'A' equals index 5 'A' and index 7 'C', special.

7: 'C' equals index 6 'A', special.

8: 'C' equals index 7 'C', special.

Wait, but the problem says positions 1,3,5,6,7,8 are special, which is 6.

But according to my analysis, position 2 should not be special, but position 8 should be special because 'C' equals the previous 'C'.

Wait, but in position 8, 'C' equals the previous 'C', so it equals one neighbor (the left one), so it's special.

Similarly, position 2: 'A' equals both neighbors, so not special.

Hence, n=6.

So, the pattern seems to be that in such constructions, n is even.

Looking at the example for n=2: "MM", which is "MM".

- First 'M' equals second 'M', special.

- Second 'M' equals first 'M', special.

Hence, n=2.

Similarly, for n=6: "AAABAACC", which has n=6.

And for n=1: no such string exists.

So, perhaps the general rule is that n must be even.

Because in each pair of characters, we can have two special characters.

For example, "AB" has n=0.

"AA" has n=2.

"AAB" has n=2.

"AAAB" has n=2.

Wait, but "AAB" has n=2, as per earlier analysis.

Wait, but "AAAB":

- Index 1: 'A' equals index 2 'A', special.

- Index 2: 'A' equals index 1 'A' and index 3 'A', not special.

- Index 3: 'A' equals index 2 'A' and index 4 'B', special.

- Index 4: 'B' equals index 3 'A', special.

So, positions 1,3,4 are special, which is n=3.

Wait, but 3 is odd.

Wait, that contradicts the earlier assumption that n must be even.

Wait, perhaps my earlier assumption is wrong.

Let's check "AAAB":

- Position 1: 'A' == 'A' (right), special.

- Position 2: 'A' == 'A' (left) and 'A' (right), not special.

- Position 3: 'A' == 'A' (left) and 'B' (right), special.

- Position 4: 'B' == 'A' (left), not special.

Wait, so positions 1 and 3 are special, n=2.

Wait, in my previous analysis, I thought position 4 was special, but actually, 'B' equals 'A' on the left, but it only equals one neighbor because there is no right neighbor. So, it should be special.

Wait, perhaps I made a mistake.

Let's re-examine:

In "AAAB":

- Position 1: 'A' == 'A' (right), special.

- Position 2: 'A' == 'A' (left) and 'A' (right), not special.

- Position 3: 'A' == 'A' (left) and 'B' (right), special.

- Position 4: 'B' == 'A' (left), special.

So, positions 1,3,4 are special, n=3.

Wait, but according to the definition, a character is special if it equals exactly one of its neighbors.

In position 4: 'B' equals 'A' on the left. It has no right neighbor. So, it equals one neighbor, so it's special.

Hence, n=3.

But in the example, for n=1, it's "NO", but n=3 seems possible.

Wait, perhaps there are constraints I'm missing.

Wait, in the problem statement, it says "exactly n special characters".

In "AAAB", n=3.

But in the example, for n=1, it's "NO", but for n=3, it seems possible.

Wait, maybe n cannot be odd numbers in general, except for n=1.

Wait, but in "AAAB", n=3.

Wait, perhaps I need to think differently.

Let me think about the maximum number of special characters possible in a string of length k.

Each character can be special or not.

But there seems to be some dependency between characters.

Wait, perhaps there's a pattern.

Let's consider alternating patterns.

For example, "ABABABAB...".

In this case, no character equals its neighbors, so n=0.

If I have "AABBAA":

- Position 1: 'A' == 'A' (right), special.

- Position 2: 'A' == 'B' (right), not special.

- Position 3: 'B' == 'B' (right), special.

- Position 4: 'B' == 'A' (right), special.

- Position 5: 'A' == 'A' (left and right?), wait, position 5 is 'A', equals position 4 'B' and position 6 (if exists).

Wait, need to be careful.

Let's consider "AABB":

- Position 1: 'A' == 'A' (right), special.

- Position 2: 'A' == 'A' (left) and 'B' (right), not special.

- Position 3: 'B' == 'B' (right), special.

- Position 4: 'B' == 'B' (left), special.

Wait, positions 1,3,4 are special, n=3.

Wait, but in the earlier example, "AAAB" also had n=3.

Wait, perhaps n can be odd, but not 1.

Wait, but in "AABB", n=3, which is odd.

But in "AAABAACC", n=6, which is even.

Maybe there's no string with n=1, but strings with n=3,5, etc., are possible.

But according to the example, for n=1, it's "NO", and for n=2, it's "YES".

So, perhaps n cannot be 1, but can be any even number greater than or equal to 2, and some odd numbers greater than or equal to 3.

But in "AABB", n=3, which is odd.

Wait, perhaps there's a pattern where n can be any number except 1.

But in the example, n=1 is "NO", but n=3 seems possible with "AAAB".

Wait, perhaps the problem is that for n=1, no string exists, but for n >=2, including odd n, strings exist.

But in that case, why is n=1 impossible?

Because in any string:

- If the string has only one character, n=0.

- If it has two characters:

- If they are equal, n=2.

- If they are different, n=0.

- If it has three characters:

- "AAA": positions 1 and 3 are special, n=2.

- "AAB": positions 1 and 3 are special, n=2.

- "ABB": positions 2 and 3 are special, n=2.

- "ABC": n=0.

- "AAB": positions 1 and 3 are special, n=2.

- "ABA": positions 1 and 3 are special, n=2.

- "ABB": positions 2 and 3 are special, n=2.

- So, n=2 in all cases with three characters.

- With four characters:

- "AABB": positions 1,3,4 are special, n=3.

- "AAAB": positions 1,3,4 are special, n=3.

- "ABAB": positions 2 and 4 are special, n=2.

- "AAAA": positions 1,3,4 are special, n=3.

Wait, so n can be odd (like 3) or even (like 2).

But n=1 seems impossible.

Hence, perhaps the rule is that n cannot be 1, but can be any other number.

But in the problem statement, for n=1, it's "NO", and for n=2, it's "YES".

So, perhaps n must be even, but in the above examples, n can be odd (like 3).

Wait, perhaps there is no string with n=1, but strings with n >=2 exist.

But in "AABB", n=3.

Wait, maybe I need to think differently.

Perhaps n must be even, but in "AABB", n=3, which is odd.

Wait, maybe my earlier analysis is incorrect.

Let me re-examine "AABB":

- Position 1: 'A' == 'A' (right), special.

- Position 2: 'A' == 'A' (left) and 'B' (right), not special.

- Position 3: 'B' == 'B' (right), special.

- Position 4: 'B' == 'B' (left), special.

So, positions 1,3,4 are special, n=3.

Wait, but position 2 is not special because it equals its left neighbor but not its right neighbor.

Wait, no, the condition is "equals exactly one of its neighbors".

Position 2: 'A' equals left neighbor 'A' and right neighbor 'B'.

So, it equals one neighbor ('A'), so it should be special.

Wait, maybe I made a mistake earlier.

In "AABB":

- Position 1: 'A' == 'A' (right), special.

- Position 2: 'A' == 'A' (left) and 'B' (right), equals one neighbor, special.

- Position 3: 'B' == 'B' (right), special.

- Position 4: 'B' == 'B' (left), special.

Wait, so n=4.

Wait, but earlier I thought position 2 was not special, but according to the definition, it equals one neighbor ('A'), so it is special.

Hence, n=4.

Wait, but in my previous analysis, I thought position 2 was not special because it equals both neighbors, but that's incorrect.

Wait, no, the condition is "equals exactly one of its neighbors".

In position 2: 'A' equals left neighbor 'A' and right neighbor 'B', so it equals one neighbor ('A'), hence special.

Similarly, position 3: 'B' equals right neighbor 'B', so special.

Position 4: 'B' equals left neighbor 'B', so special.

Hence, n=4.

Wait, but earlier I thought position 2 was not special, but according to the definition, it is special.

So, in "AABB", n=4.

Similarly, in "AAAB", let's re-examine:

"AAAB":

- Position 1: 'A' == 'A' (right), special.

- Position 2: 'A' == 'A' (left) and 'A' (right), equals both, not special.

- Position 3: 'A' == 'A' (left) and 'B' (right), equals one neighbor, special.

- Position 4: 'B' == 'A' (left), special.

Hence, positions 1,3,4 are special, n=3.

So, n=3 is possible.

Hence, n can be odd (3) or even (4).

But in the example, for n=1, it's "NO", but for n=2 and n=6, it's "YES".

So, perhaps n cannot be 1, but can be any other number.

But in "AAAB", n=3.

Wait, maybe n cannot be 1, but can be any n >=2.

But in "AAAB", n=3.

So, perhaps n can be any n except 1.

Hence, the answer for n=1 is "NO", and for n >=2, it's "YES".

But in the problem statement, for n=1, it's "NO", and for n=2, it's "YES".

Hence, perhaps the rule is that n must be even or n >=2.

Wait, but in "AAAB", n=3, which is odd and greater than 2, seems possible.

Wait, maybe there's no string with n=1, but strings with n >=2 exist.

Hence, perhaps the rule is that n cannot be 1.

So, in the program, it checks if n % 2 == 1, then "NO", else "YES".

But according to my analysis, n=3 is possible, which is odd.

Hence, the program is incorrect.

Wait, but according to the problem statement, for n=1, it's "NO", but n=3 seems possible.

Hence, perhaps the program is incorrect.

Wait, but maybe the program is correct because n=3 is allowed, as it's odd, but in the program, if n % 2 ==1, print "NO", else "YES".

But n=3 is odd, so the program would print "NO", but according to my analysis, n=3 is possible.

Hence, the program is incorrect.

Wait, but in the example, for n=1, it's "NO", and for n=2, it's "YES".

But according to the program, for n=3, it would print "NO", which seems correct based on my analysis.

Wait, but earlier I thought n=3 is possible, but perhaps I'm mistaken.

Let me think again.

In "AAAB", n=3.

- Position 1: 'A' == 'A', special.

- Position 2: 'A' == 'A' (left) and 'A' (right), not special.

- Position 3: 'A' == 'A' (left) and 'B' (right), special.

- Position 4: 'B' == 'A' (left), special.

Hence, n=3.

So, n=3 is possible.

But according to the program, for n=3, it would print "NO".

Hence, the program is incorrect.

Wait, but perhaps I'm miscounting.

Wait, in position 2: 'A' equals both neighbors 'A', so not special.

Hence, only positions 1,3,4 are special, n=3.

Hence, n=3 is possible, but according to the program, it would print "NO" for n=3.

Hence, the program is incorrect.

Wait, but in the problem statement, for n=1, it's "NO", and for n=2, it's "YES".

But n=3 seems possible, so perhaps the program is incorrect.

Wait, perhaps the correct rule is that n cannot be 1, but can be any other n.

Hence, for n=1, "NO", for n >=2, "YES".

Hence, the program should check if n ==1, then "NO", else "YES".

But the program checks if n % 2 ==1, then "NO", else "YES".

Hence, the program is incorrect because, for example, for n=3, it would print "NO", but n=3 is possible.

Wait, but according to my analysis, n=3 is possible.

Hence, the program is incorrect.

Hence, Correctness: False.

But in the problem statement, for n=1, it's "NO", and for n=2, it's "YES".

Hence, perhaps the rule is that n cannot be 1, but can be any other n.

Hence, the program should check if n ==1, then "NO", else "YES".

But the program checks if n is even, then "YES", else "NO".

Hence, it's incorrect for n=3, which should be "YES", but the program would print "NO".

Hence, the program is incorrect.

Hence, Correctness: False.

**Final Answer**

\[ \boxed{\text{False}} \]