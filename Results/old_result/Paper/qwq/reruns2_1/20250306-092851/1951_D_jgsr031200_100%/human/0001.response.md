Alright, I've got this problem to solve. Let's see what it's asking for. So, Alice has n coins and wants to buy exactly k jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel that's an integer between 1 and 10^18 coins. Alice buys jewels greedily: she goes to each stall in order, buys as many jewels as she can with her remaining coins, and moves on to the next stall.

My task is to determine if Bob can set up the stalls and set the prices in such a way that Alice ends up buying exactly k jewels. If it's possible, I need to output "YES" along with the number of stalls and their respective prices. If not, I should output "NO".

First, I need to understand the constraints and what they imply. The problem says there are multiple test cases, up to 1000, and for each test case, n and k can be as large as 10^18. That means I need an efficient solution, probably O(1) or O(log n) per test case, since 1000 * 60 = 60,000 operations should be fine.

Let me think about how Alice buys the jewels. She goes to each stall in order and buys as many jewels as she can with her current coins. So, if a stall has price p, and she has c coins, she buys floor(c / p) jewels and spends floor(c / p) * p coins. Then she moves to the next stall.

Bob needs to set up the stalls in such a way that the total jewels bought across all stalls is exactly k.

I need to find a way to set up at most 60 stalls with prices such that Alice buys exactly k jewels.

Let me consider some examples to get a better understanding.

Example 1:

n = 7, k = 3

One possible solution is to set up 10 stalls with prices 2, 3, 4, 5, 6, 7, 8, 9, 10, 11.

With n = 7 coins:

- Stall 1: price = 2 → buys 3 jewels (7 // 2 = 3), spends 6 coins, left with 1 coin.

- Since she has only 1 coin left, she can't buy anything from the remaining stalls.

- Total jewels bought: 3.

This matches k = 3.

Example 2:

n = 6, k = 4

The output is "NO", meaning it's impossible to set up stalls such that Alice buys exactly 4 jewels.

Example 3:

n = 255, k = 8

One possible solution is to set up 8 stalls with prices 128, 64, 32, 16, 8, 4, 2, 1.

With n = 255 coins:

- Stall 1: price = 128 → buys 1 jewel, spends 128 coins, left with 127 coins.

- Stall 2: price = 64 → buys 1 jewel, spends 64 coins, left with 63 coins.

- Stall 3: price = 32 → buys 1 jewel, spends 32 coins, left with 31 coins.

- Stall 4: price = 16 → buys 1 jewel, spends 16 coins, left with 15 coins.

- Stall 5: price = 8 → buys 1 jewel, spends 8 coins, left with 7 coins.

- Stall 6: price = 4 → buys 1 jewel, spends 4 coins, left with 3 coins.

- Stall 7: price = 2 → buys 1 jewel, spends 2 coins, left with 1 coin.

- Stall 8: price = 1 → buys 1 jewel, spends 1 coin, left with 0 coins.

- Total jewels bought: 8.

This matches k = 8.

From these examples, I can see that using decreasing prices, specifically powers of 2, can help in controlling the number of jewels Alice buys.

But in the first example, the prices are not powers of 2, yet it still works for k = 3.

Wait, in the first example, prices are 2 through 11, which are not powers of 2, but since n = 7 is small, and the first stall allows buying 3 jewels, which sums up to k = 3.

So, perhaps there are multiple ways to set up the stalls to achieve the desired k.

But in the second example, it's impossible to set up any stalls to make Alice buy exactly 4 jewels.

I need to find a general approach to determine if it's possible for any given n and k, and if so, provide a valid setup with at most 60 stalls.

Let me consider the minimal and maximal number of jewels Alice can buy.

- Minimal k: If Bob sets up only one stall with price n, Alice buys 1 jewel.

- Maximal k: If Bob sets up stalls with prices 1, 1, ..., 1 (s times), Alice buys n jewels.

But since s ≤ 60, and prices can be up to 10^18, I need to find a balance.

Wait, but in the first example, with n = 7 and k = 3, using prices 2 through 11, which are more than 60 stalls, but in the problem, it's mentioned that s ≤ 60.

Wait, in the first example, they used 10 stalls, which is less than 60.

Wait, reading again: "at most 60 stalls", so s ≤ 60.

In the first example, s = 10, which is fine.

So, I need to ensure that the number of stalls is ≤ 60.

I need to find a way to set up the stalls such that the total jewels bought is exactly k, with s ≤ 60.

I need to think about how to minimize or maximize the number of jewels bought based on the stall prices.

Let me consider the minimal number of stalls required.

If Bob sets up only one stall with price floor(n / k), does that work?

Wait, no, because Alice will buy floor(n / p) jewels at the first stall, and if floor(n / p) > k, she'll buy more than k jewels, which is not desired.

Wait, no, if p = floor(n / k), then floor(n / p) could be ≥ k or less than k, depending on the values.

This might not be the right approach.

Let me think differently.

Suppose Bob sets up s stalls with prices p1, p2, ..., ps.

Alice buys floor(n / p1) jewels at the first stall, spends floor(n / p1) * p1 coins, then moves to the second stall with remaining n - floor(n / p1) * p1 coins, and so on.

I need the sum of floor(n / pi) over all i from 1 to s to be exactly k.

Also, s ≤ 60.

This seems tricky because floor functions are involved, and I have to deal with large n and k.

Let me consider some corner cases.

Case 1: n = k

In this case, if Bob sets up one stall with price 1, Alice will buy n = k jewels.

So, output "YES" with s = 1 and p1 = 1.

Wait, but in the problem, it's mentioned that in the first test case, n = 7 and k = 3, which is different.

Wait, in the first test case, n = 7 and k = 3, which is n > k.

Wait, no, in the first test case, n = 7 and k = 3.

Wait, in the sample input, t = 3, with test cases (7,3), (6,4), and (255,8).

Outputs are "YES" with s=10 for the first, "NO" for the second, and "YES" with s=8 for the third.

So, in the first case, n = 7 and k = 3, which is n > k.

In the third case, n = 255 and k = 8, which is n > k.

In both cases, n > k, but in the second case, n = 6 and k = 4, which is also n > k, but it's "NO".

Wait, n = 6 and k = 4: n > k, but it's impossible.

So, it's not just about n and k relation, but something more nuanced.

Let me consider another approach.

Suppose Bob sets up stalls with decreasing prices, starting from a high price down to 1.

Like in the first example, prices from 2 to 11.

In the third example, prices are powers of 2 descending.

Maybe using a greedy approach where higher prices are used first to minimize the number of jewels bought at each stall.

Wait, in the first example, prices are increasing from 2 to 11, but Alice buys only at the first stall because with n = 7, she buys 3 jewels at price 2, spending 6 coins, and is left with 1 coin, which is not enough to buy anything from the other stalls.

So, in that case, she only buys from the first stall.

In the third example, prices are decreasing, so she buys one jewel from each stall until her coins run out.

So, the ordering of prices matters in terms of which stalls she visits first.

But in the problem statement, it's specified that she goes to stall 1 first, then stall 2, and so on.

So, Bob needs to set up the stalls in a specific order for Alice to buy from them in that order.

So, the prices need to be set in such a way that she buys from the first few stalls and doesn't have enough for the later ones.

Or perhaps a combination where she buys from some stalls and doesn't from others.

But the problem allows up to 60 stalls, so s ≤ 60.

I need to find a way to partition k jewels into s parts, where each part is floor(n / p_i), and the remaining coins after each purchase is n - floor(n / p_i) * p_i, which is then used for the next stall.

This seems complicated.

Let me think about the minimal number of stalls required.

If Bob sets up one stall with p = floor(n / k), then Alice buys floor(n / p) jewels.

But floor(n / floor(n / k)) could be greater than or equal to k, depending on n and k.

Wait, for example, n = 10, k = 3.

floor(10 / 3) = 3, so p = 3.

Then floor(10 / 3) = 3, which is equal to k.

So, in this case, s = 1, p1 = 3, and Alice buys 3 jewels.

Another example: n = 7, k = 3.

floor(7 / 3) = 2, which is less than k = 3.

So, one stall is not enough.

Need at least two stalls.

Suppose s = 2.

Let me try p1 = 2, p2 = 1.

At stall 1: floor(7 / 2) = 3 jewels, spends 6 coins, left with 1 coin.

At stall 2: floor(1 / 1) = 1 jewel, spends 1 coin, left with 0 coins.

Total jewels: 3 + 1 = 4, which is more than k = 3.

Not good.

Try p1 = 2, p2 = 3.

At stall 1: floor(7 / 2) = 3 jewels, spends 6 coins, left with 1 coin.

At stall 2: floor(1 / 3) = 0 jewels.

Total jewels: 3 + 0 = 3, which matches k = 3.

So, with s = 2, p1 = 2, p2 = 3, it works.

But in the sample input, they used s = 10 with p from 2 to 11, which also works.

So, multiple solutions are possible.

Now, for n = 6 and k = 4.

Try s = 2, p1 = 2, p2 = 3.

At stall 1: floor(6 / 2) = 3 jewels, spends 6 coins, left with 0 coins.

At stall 2: floor(0 / 3) = 0 jewels.

Total jewels: 3 + 0 = 3, which is less than k = 4.

Not enough.

Try p1 = 1, p2 = 2.

At stall 1: floor(6 / 1) = 6 jewels, spends 6 coins, left with 0 coins.

At stall 2: floor(0 / 2) = 0 jewels.

Total jewels: 6 + 0 = 6, which is more than k = 4.

Not good.

Try s = 3, p1 = 2, p2 = 2, p3 = 1.

At stall 1: floor(6 / 2) = 3 jewels, spends 6 coins, left with 0 coins.

At stall 2: floor(0 / 2) = 0 jewels.

At stall 3: floor(0 / 1) = 0 jewels.

Total jewels: 3 + 0 + 0 = 3, which is less than k = 4.

Still not enough.

Try p1 = 1, p2 = 2, p3 = 3.

At stall 1: floor(6 / 1) = 6 jewels, spends 6 coins, left with 0 coins.

At stall 2: floor(0 / 2) = 0 jewels.

At stall 3: floor(0 / 3) = 0 jewels.

Total jewels: 6 + 0 + 0 = 6, which is more than k = 4.

Still not good.

It seems challenging to get exactly k = 4 with n = 6 using multiple stalls.

Maybe it's impossible, which is why the sample output is "NO".

So, I need a general way to determine if it's possible to set up stalls such that the total jewels bought is exactly k.

Let me consider the minimal and maximal possible k for given n and s.

Minimal k: if all p_i are very high, say p_i = n + 1, then floor(n / p_i) = 0 for all i, so total k = 0.

But s ≤ 60, and k is at least 1, so not useful.

Wait, but k can be 0, but the problem says positive integers, so k ≥ 1.

Wait, no, in the problem, k is a positive integer, so k ≥ 1.

Wait, in the input, it's positive integers, but in the problem statement, it says positive integers for n and k, so k ≥ 1.

So, minimal k is 1, by setting one stall with p = n, Alice buys one jewel.

Maximal k is n, by setting s = n stalls with p_i = 1 for all i.

Alice buys one jewel from each stall, total k = n.

But s ≤ 60, so if n > 60, this isn't possible.

Wait, but in the third example, n = 255 and k = 8, with s = 8, which is ≤ 60.

So, it's possible even when n > s.

I need to find a way to achieve any k between 1 and n, given s ≤ 60.

But it's not always possible, as shown in the second example.

So, there must be some constraints based on n and k.

Let me think about the minimal number of stalls required to achieve a given k.

Suppose Bob sets up s stalls with p1, p2, ..., ps.

Alice buys floor(n / p1) + floor(n_remaining / p2) + ... + floor(n_remaining / ps) = k.

This seems complicated due to the floor functions and dependencies between the stalls.

An alternative approach is to think in terms of the remaining coins after each stall.

Let me denote:

- After stall 1: buy floor(n / p1) jewels, spend floor(n / p1) * p1 coins, remaining coins: n - floor(n / p1) * p1.

- After stall 2: buy floor(remaining / p2) jewels, spend floor(remaining / p2) * p2 coins, remaining coins: remaining - floor(remaining / p2) * p2.

- And so on.

I need the sum of floor(n / p1) + floor((n - floor(n / p1)*p1)/p2) + ... to equal k.

This seems too involved to handle directly.

Maybe I can think recursively or iteratively build the solution.

Another idea: since s ≤ 60, and 60 is a small number, perhaps I can find a way to represent k as a sum of floor(n / p_i), with p_i chosen appropriately.

But this still seems tricky.

Let me consider the following approach:

- Start with s = 1.

- Set p1 = floor(n / k).

- Then, floor(n / p1) = floor(n / floor(n / k)).

- If n is divisible by k, then floor(n / floor(n / k)) = k.

- If n is not divisible by k, floor(n / floor(n / k)) might be greater than or equal to k.

Wait, for example, n = 10, k = 3.

floor(10 / 3) = 3, then floor(10 / 3) = 3, which matches k = 3.

Another example: n = 7, k = 3.

floor(7 / 3) = 2, then floor(7 / 2) = 3, which is more than k = 3.

So, in this case, it's not equal to k.

So, s = 1 might not be sufficient in all cases.

In the first example, n = 7, k = 3, s = 10 is used, but s = 2 is also sufficient, as shown earlier.

So, with s = 2, it's possible to achieve k = 3.

Similarly, in the third example, n = 255, k = 8, s = 8 is used.

So, perhaps s = 2 is sufficient in many cases, but sometimes more stalls are needed.

Wait, but in the third example, s = 8 is used, which is more than 2.

So, maybe s = 2 is not always sufficient.

Let me consider a general approach.

Suppose Bob sets up s stalls with prices p1, p2, ..., ps.

He needs to ensure that the sum of floor(n / p_i) over i from 1 to s equals k.

Also, s ≤ 60.

This seems difficult to solve directly.

An alternative approach is to think in terms of the minimal number of stalls required to achieve k.

I can try to maximize the number of jewels bought at each stall to minimize the number of stalls.

But in this problem, since Alice buys greedily from the first stall to the last, and we control the prices, we can arrange the stalls in such a way that she buys a certain number of jewels at each stall.

Wait, perhaps I can think of it as distributing k jewels across s stalls, where each stall contributes a certain number of jewels based on the price set.

But the relationship between the price and the number of jewels bought is not straightforward due to the floor function and the remaining coins.

This is getting complicated.

Let me consider another angle.

Suppose I set up s stalls with prices p1, p2, ..., ps.

I need to ensure that the sum of floor(n / p_i) equals k.

I need to find p1, p2, ..., ps such that this condition holds.

This seems like a Diophantine equation with floor functions, which is hard to solve directly.

Maybe I can find a way to set up the prices such that the sum of floor(n / p_i) equals k.

One idea is to set p1 = ceil(n / k), which would make floor(n / p1) = floor(n / ceil(n / k)).

But I'm not sure what that equals.

Wait, for n = 10 and k = 3, ceil(10 / 3) = 4, floor(10 / 4) = 2.

Then, remaining coins: 10 - 2*4 = 2.

If I set p2 = 2, then floor(2 / 2) = 1, total jewels: 2 + 1 = 3, which matches k = 3.

Similarly, for n = 7 and k = 3:

Set p1 = ceil(7 / 3) = 3, floor(7 / 3) = 2, spend 6 coins, left with 1 coin.

Set p2 = 1, floor(1 / 1) = 1, total jewels: 2 + 1 = 3.

This works.

Another example: n = 255, k = 8.

Set p1 = ceil(255 / 8) = 32, floor(255 / 32) = 7, spend 224 coins, left with 31 coins.

Then set p2 = ceil(31 / (8 - 7)) = 31, floor(31 / 31) = 1, spend 31 coins, left with 0 coins.

Total jewels: 7 + 1 = 8.

This works with s = 2.

But in the sample input, they used s = 8 with prices 128, 64, 32, 16, 8, 4, 2, 1.

That's more stalls than necessary, but still valid.

So, perhaps setting up s = 2 stalls is sufficient in many cases.

But in the second example, n = 6 and k = 4.

Set p1 = ceil(6 / 4) = 2, floor(6 / 2) = 3, spend 6 coins, left with 0 coins.

Then p2 = any value > 0, floor(0 / p2) = 0.

Total jewels: 3 + 0 = 3, which is less than k = 4.

Not sufficient.

Alternatively, set p1 = 1, floor(6 / 1) = 6, which is more than k = 4.

Not good.

Set p1 = 3, floor(6 / 3) = 2, spend 6 coins, left with 0 coins.

Set p2 = any value, floor(0 / p2) = 0.

Total jewels: 2 + 0 = 2, which is less than k = 4.

Still not enough.

Set p1 = 2, floor(6 / 2) = 3, spend 6 coins, left with 0 coins.

Set p2 = any value, floor(0 / p2) = 0.

Total jewels: 3 + 0 = 3, which is less than k = 4.

Still not enough.

Set p1 = 1, floor(6 / 1) = 6, which is more than k = 4.

Not good.

Set p1 = 4, floor(6 / 4) = 1, spend 4 coins, left with 2 coins.

Set p2 = 2, floor(2 / 2) = 1, spend 2 coins, left with 0 coins.

Total jewels: 1 + 1 = 2, which is less than k = 4.

Still not enough.

Set p1 = 5, floor(6 / 5) = 1, spend 5 coins, left with 1 coin.

Set p2 = 1, floor(1 / 1) = 1, spend 1 coin, left with 0 coins.

Total jewels: 1 + 1 = 2, which is less than k = 4.

Still not enough.

Set p1 = 1, floor(6 / 1) = 6, which is more than k = 4.

Not good.

It seems that with s = 2, it's impossible to get exactly k = 4 for n = 6.

Similarly, with s = 3:

Set p1 = 2, floor(6 / 2) = 3, spend 6 coins, left with 0 coins.

Set p2 = any, floor(0 / p2) = 0.

Set p3 = any, floor(0 / p3) = 0.

Total jewels: 3 + 0 + 0 = 3, which is less than k = 4.

Not enough.

Set p1 = 3, floor(6 / 3) = 2, spend 6 coins, left with 0 coins.

Set p2 = any, floor(0 / p2) = 0.

Set p3 = any, floor(0 / p3) = 0.

Total jewels: 2 + 0 + 0 = 2, which is less than k = 4.

Still not enough.

Set p1 = 1, floor(6 / 1) = 6