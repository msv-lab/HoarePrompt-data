Alright, I've got this problem to solve. Let's see what it's asking for. So, Farmer John has a permutation p of numbers from 0 to n-1, and he gives Bessie an array a, where each a_i is calculated as the MEX of the first i elements of p minus p_i. My task is to reconstruct the permutation p from the array a.

First, I need to understand what MEX means. MEX stands for "minimum excluded," which is the smallest non-negative integer not present in a given list. For example, MEX of [1, 2, 3] is 0 because 0 is the smallest non-negative integer not in the list. MEX of [3, 1, 0] is 2, since 0 and 1 are present, but 2 is not.

So, for each position i in the permutation p, a_i is MEX of p_1 to p_i minus p_i. I need to find p given a.

The problem says that there is at least one valid p for the given a, so I don't have to worry about invalid inputs.

Let me think about how to approach this. Since p is a permutation, each number from 0 to n-1 appears exactly once in p. That's important because it means p doesn't have any duplicates.

I need to find a way to determine each p_i based on the corresponding a_i and perhaps some other information I can derive.

Let's consider the MEX calculation. For each prefix of p, the MEX is the smallest non-negative integer not in that prefix.

Given that a_i = MEX(p_1 to p_i) - p_i, I can rearrange this to p_i = MEX(p_1 to p_i) - a_i.

Hmm, that seems useful. So, if I can find MEX(p_1 to p_i), I can compute p_i directly from a_i.

But the problem is that MEX depends on the values of p_1 to p_i, which are partially known.

This seems a bit circular. Maybe I need to find a way to iteratively determine p_i.

Let me consider the sequence step by step.

Suppose I have the first element p_1. The MEX of just p_1 is the smallest non-negative integer not equal to p_1. Since p_1 is from 0 to n-1, MEX(p_1) would be 0 if p_1 is not 0, or 1 if p_1 is 0.

Wait, no. If p_1 is 0, then MEX is 1, because 0 is present. If p_1 is 1, MEX is 0. If p_1 is 2, MEX is 0, and so on.

Wait, no. MEX of [2] is 0, because 0 is not in the list.

Wait, actually, MEX of [2] is 0, since 0 is the smallest non-negative integer not in the list.

Wait, but in the problem statement, MEX(1,2,3)=0, MEX(3,1,0)=2.

Wait, no, MEX(3,1,0) is 2, because 0,1,3 are present, so 2 is the smallest missing.

But MEX(1,2,3) is 0, since 0 is missing.

Wait, but in the example, MEX(0,1,4,2,3)=5, because 0,1,2,3,4 are present, so 5 is missing.

Wait, but in the first case, MEX(0)=1, because 0 is present, so 1 is missing.

Wait, but in the example, MEX(0)=1, which makes sense because 0 is present, so 1 is the smallest missing.

Wait, but according to the definition, MEX is the smallest non-negative integer not in the list.

So, MEX of [0] is 1, because 0 is present, so 1 is missing.

MEX of [0,1] is 2, because 0 and 1 are present.

MEX of [0,1,4] is 2, because 0,1,4 are present, so 2 is missing.

MEX of [0,1,4,2] is 3, because 0,1,2,4 are present, so 3 is missing.

MEX of [0,1,4,2,3] is 5, because 0,1,2,3,4 are present, so 5 is missing.

Okay, got it.

So, in general, MEX(p_1 to p_i) is the smallest non-negative integer not in the set {p_1, p_2, ..., p_i}.

Given that, a_i = MEX(p_1 to p_i) - p_i.

I need to find p_i for each i.

Let me try to find a way to compute p_i.

From a_i = MEX(p_1 to p_i) - p_i, I can write p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) depends on p_i, which I don't know yet.

This seems tricky.

Maybe I need to consider the entire permutation and find a way to reconstruct it step by step.

Let me consider the properties of the permutation and the MEX values.

Since p is a permutation of 0 to n-1, all numbers from 0 to n-1 appear exactly once in p.

Given that, the MEX of the entire permutation is n, because all numbers from 0 to n-1 are present.

But for prefixes, the MEX can vary.

In the example given:

p = [0,1,4,2,3]

a = [1,1,-2,1,2]

Let's verify:

For i=1:

MEX(0) = 1

a_1 = 1 - 0 = 1

For i=2:

MEX(0,1) = 2

a_2 = 2 - 1 = 1

For i=3:

MEX(0,1,4) = 2

a_3 = 2 - 4 = -2

For i=4:

MEX(0,1,4,2) = 3

a_4 = 3 - 2 = 1

For i=5:

MEX(0,1,4,2,3) = 5

a_5 = 5 - 3 = 2

Yes, that matches the example.

Now, I need a general method to reconstruct p from a.

Let me think about the last element.

For i=n:

a_n = MEX(p_1, p_2, ..., p_n) - p_n

But MEX of the entire permutation is n, since all numbers from 0 to n-1 are present.

So, a_n = n - p_n

Therefore, p_n = n - a_n

So, I can directly compute p_n from a_n.

That's useful.

Now, knowing p_n, can I find p_{n-1}?

For i=n-1:

a_{n-1} = MEX(p_1, p_2, ..., p_{n-1}) - p_{n-1}

But MEX(p_1, ..., p_{n-1}) is the smallest non-negative integer not in p_1 to p_{n-1}.

Since p_n is now known, and p is a permutation, the numbers in p_1 to p_{n-1} are all from 0 to n-1 except p_n.

So, MEX(p_1, ..., p_{n-1}) is either n (if all numbers from 0 to n-1 are in p_1 to p_{n-1}), but since p_n is missing, it's not possible, because p_n is from 0 to n-1.

Wait, no, p_n is from 0 to n-1, so p_1 to p_{n-1} are all numbers from 0 to n-1 except p_n.

Therefore, MEX(p_1, ..., p_{n-1}) is p_n, because p_n is the only number from 0 to n-1 missing in p_1 to p_{n-1}.

Wait, is that correct?

Wait, no.

Wait, p is a permutation of 0 to n-1.

So, in p_1 to p_{n-1}, all numbers from 0 to n-1 except p_n are present.

So, the MEX of p_1 to p_{n-1} is the smallest non-negative integer not in p_1 to p_{n-1}.

Since p_n is from 0 to n-1, and it's missing in p_1 to p_{n-1}, and there might be smaller numbers missing as well.

Wait, no.

Wait, suppose p_n is the smallest missing number in p_1 to p_{n-1}.

But that's not necessarily true.

Wait, for example, if p_1 to p_{n-1} are all numbers from 0 to n-1 except p_n, then MEX(p_1 to p_{n-1}) is p_n, provided that p_n is the smallest missing.

But p_n could be any number from 0 to n-1 not in p_1 to p_{n-1}.

Wait, but since p is a permutation, p_n is the only number from 0 to n-1 not in p_1 to p_{n-1}.

Therefore, MEX(p_1 to p_{n-1}) is p_n.

Wait, is that correct?

Wait, no.

Wait, MEX is the smallest non-negative integer not in the list.

So, if p_n is the smallest missing, then MEX is p_n.

But it's possible that smaller numbers are missing as well.

Wait, no, if p_n is the only number missing from 0 to n-1 in p_1 to p_{n-1}, then MEX is p_n only if p_n is the smallest missing.

But in reality, MEX is the smallest non-negative integer not in p_1 to p_{n-1}.

So, it could be less than p_n, depending on the arrangement.

Wait, for example, if p_1 to p_{n-1} are [1,2,3,...,n-1], then MEX is 0, even if p_n is some other number.

Wait, but p is a permutation, so p_n could be 0 in that case.

Wait, no, if p_1 to p_{n-1} are [1,2,3,...,n-1], then p_n must be 0, since it's the only number missing.

So, MEX(p_1 to p_{n-1}) is 0, which is p_n in this case.

Similarly, if p_1 to p_{n-1} are [0,1,2,...,n-2], then p_n is n-1, and MEX is n-1.

Wait, but n-1 is in p_1 to p_{n-1}, so MEX would be n.

Wait, no, p_1 to p_{n-1} are [0,1,2,...,n-2], so MEX is n-1, because n-1 is missing.

Wait, hold on.

Wait, in the permutation p, p_1 to p_{n-1} are [0,1,2,...,n-2], then p_n must be n-1.

MEX(p_1 to p_{n-1}) is n-1, because n-1 is missing from p_1 to p_{n-1}.

So, in this case, MEX(p_1 to p_{n-1}) is n-1, which is p_n.

Another example: p_1 to p_{n-1} are [1,2,3,...,n-1], p_n is 0.

MEX(p_1 to p_{n-1}) is 0, which is p_n.

So, in general, MEX(p_1 to p_{n-1}) is p_n.

Wait, is that always true?

Wait, yes, because p_n is the only number from 0 to n-1 missing in p_1 to p_{n-1}, and MEX is the smallest such number.

But p_n may not be the smallest missing number.

Wait, but since p_n is the only missing number, MEX is p_n.

Wait, no, that's not correct.

Wait, if p_n is the only missing number from 0 to n-1 in p_1 to p_{n-1}, then MEX is the smallest number not in p_1 to p_{n-1}, which is p_n.

But p_n could be larger than some other numbers.

Wait, no, p is a permutation of 0 to n-1, so all numbers are from 0 to n-1.

Wait, but in p_1 to p_{n-1}, p_n is missing, and all other numbers from 0 to n-1 are present.

Therefore, MEX(p_1 to p_{n-1}) is p_n.

Wait, but p_n could be any number from 0 to n-1 not in p_1 to p_{n-1}, but since it's a permutation, it's uniquely determined.

Wait, but in the earlier example, if p_1 to p_{n-1} are [1,2,3,...,n-1], then p_n is 0, and MEX is 0.

If p_1 to p_{n-1} are [0,1,2,...,n-2], then p_n is n-1, and MEX is n-1.

So, in general, MEX(p_1 to p_{n-1}) is p_n.

Wait, but in the first case, p_n is 0, which is the smallest missing.

In the second case, p_n is n-1, which is the smallest missing.

Wait, but what if p_1 to p_{n-1} are [0,1,3,4,...,n-1], then p_n is 2, which is the smallest missing.

So, in general, MEX(p_1 to p_{n-1}) is p_n.

Therefore, MEX(p_1 to p_{n-1}) = p_n.

Wait, but in the problem, a_i = MEX(p_1 to p_i) - p_i.

So, for i=n-1, a_{n-1} = MEX(p_1 to p_{n-1}) - p_{n-1} = p_n - p_{n-1}

Therefore, a_{n-1} = p_n - p_{n-1}

Similarly, a_n = n - p_n

From a_n, I can find p_n = n - a_n

Then, from a_{n-1}, I can find p_{n-1} = p_n - a_{n-1}

Wait, a_{n-1} = p_n - p_{n-1}, so p_{n-1} = p_n - a_{n-1}

Similarly, for i=n-2, a_{n-2} = MEX(p_1 to p_{n-2}) - p_{n-2}

But MEX(p_1 to p_{n-2}) is the smallest number not in p_1 to p_{n-2}

Given that p_1 to p_{n-2} are n-2 distinct numbers from 0 to n-1, excluding p_{n-1} and p_n.

But p_n is already known, and p_{n-1} can be computed.

Wait, perhaps I can generalize this.

Let me try to think recursively.

Starting from the end:

p_n = n - a_n

Then, p_{n-1} = p_n - a_{n-1}

Similarly, p_{n-2} = MEX(p_1 to p_{n-2}) - a_{n-2}

But MEX(p_1 to p_{n-2}) is the smallest number not in p_1 to p_{n-2}

Given that p_1 to p_{n-2} are n-2 distinct numbers from 0 to n-1, excluding p_{n-1} and p_n.

But p_{n-1} and p_n are known now.

Wait, but p_{n-1} might still be unknown at this stage.

Wait, no, p_n is known, and p_{n-1} is known from the previous step.

Wait, perhaps I need to track the MEX as I go backwards.

Let me try to see.

Let me consider the MEX at each step.

At i = n:

MEX(p_1 to p_n) = n

At i = n-1:

MEX(p_1 to p_{n-1}) = p_n

Because p_n is the only number missing from p_1 to p_{n-1}

At i = n-2:

MEX(p_1 to p_{n-2}) is the smallest number not in p_1 to p_{n-2}

Which could be p_{n-1} or p_n, depending on which is smaller.

Wait, but p_{n-1} is known now, as it was computed from the previous step.

Wait, perhaps I need to keep track of the MEX as I go backwards.

Let me try to think differently.

Let me consider that for each i from 1 to n:

a_i = MEX(p_1 to p_i) - p_i

Therefore, p_i = MEX(p_1 to p_i) - a_i

But MEX(p_1 to p_i) is unknown, but perhaps I can find a way to compute it.

Alternatively, perhaps I can iterate from the end to the beginning, keeping track of the MEX.

Wait, in the code provided, it seems to iterate from n-1 down to 0, setting p[i] = mex - a[i], and then updating mex as the minimum of the current mex and p[i].

Let me look at the code again.

The code does:

mex = n

for i in range(n-1, -1, -1):

p[i] = mex - a[i]

mex = min(mex, p[i])

Then, it prints p.

Let me see if this makes sense.

Starting with mex = n

For i = n-1:

p[n-1] = n - a[n-1]

Then, mex = min(mex, p[n-1]) = min(n, p[n-1])

For i = n-2:

p[n-2] = mex - a[n-2]

Then, mex = min(mex, p[n-2])

And so on.

Wait, in the first step, p[n-1] = n - a[n-1]

But from earlier, I know that p[n-1] = p_n - a_{n-1}, and p_n = n - a_n

So, p[n-1] = (n - a_n) - a_{n-1}

But according to the code, p[n-1] = n - a[n-1]

Wait, that's different.

Wait, perhaps I'm confusing the indices.

Wait, the code sets p[i] = mex - a[i], and mex starts at n.

In the first iteration, i = n-1, p[n-1] = n - a[n-1]

But earlier, I thought p_n = n - a_n

Wait, perhaps there is a shift in indices.

Wait, maybe the code is 0-based, so p[0] corresponds to p_1, and p[n-1] corresponds to p_n.

Wait, but in the code, it's p[i], where i goes from 0 to n-1.

But in the problem, p is 1-based, p_1 to p_n.

Wait, no, the problem likely uses 1-based indexing for the permutation, but in code, it's 0-based.

Wait, but in the problem, p is a permutation of 0 to n-1, so it's 0-based values.

Wait, perhaps it's better to think of p as p[0] to p[n-1], corresponding to p_1 to p_n.

Wait, to avoid confusion, let's consider that in code, p[0] is p_1, p[1] is p_2, ..., p[n-1] is p_n.

So, in the code, p[i] corresponds to p_{i+1}.

So, in the first iteration, i = n-1, p[n-1] = mex - a[i] = n - a[n-1]

But p[n-1] corresponds to p_n.

From earlier, p_n = n - a_n.

So, this matches.

Then, mex = min(mex, p[n-1]) = min(n, p_n)

Which is n, since p_n = n - a_n, and a_n can be from -n to n, so p_n can be from 0 to 2n.

But p_n is from 0 to n-1, since it's a permutation, so p_n <= n-1.

Therefore, mex = min(n, p_n) = p_n, since p_n <= n-1.

Then, for i = n-2:

p[n-2] = mex - a[n-2] = p_n - a[n-2]

Then, mex = min(mex, p[n-2]) = min(p_n, p[n-2])

And so on.

Wait, but from earlier, a_{n-1} = p_n - p_{n-1}

Therefore, p_{n-1} = p_n - a_{n-1}

Similarly, a_{n-2} = MEX(p_1 to p_{n-2}) - p_{n-2}

But MEX(p_1 to p_{n-2}) is the smallest number not in p_1 to p_{n-2}

Given that p_{n-1} and p_n are known now, and p_1 to p_{n-2} are all numbers from 0 to n-1 except p_{n-1} and p_n.

Wait, but p_{n-1} is already computed.

Wait, perhaps I need to track the set of used numbers.

Let me try to think differently.

Let me consider that at each step, I have a set of numbers that have been used so far.

Then, MEX is the smallest number not in that set.

So, for i from 1 to n:

MEX(p_1 to p_i) is the smallest number not in {p_1, p_2, ..., p_i}

Given that, a_i = MEX - p_i

Therefore, p_i = MEX - a_i

But MEX depends on p_i, which is unknown.

Wait, but if I can keep track of the MEX as I build the permutation, maybe I can compute p_i.

Looking back at the code, it seems to iterate from the end to the beginning, setting p[i] = mex - a[i], and then updating mex to be the minimum of the current mex and p[i].

This seems to be working backwards, from i = n to i = 1.

Let me try to see with an example.

Take the first test case:

n = 5

a = [1,1,-2,1,2]

So, a = [a1,a2,a3,a4,a5] = [1,1,-2,1,2]

According to the code:

mex = 5

p[4] = 5 - 2 = 3

mex = min(5,3) = 3

p[3] = 3 - 1 = 2

mex = min(3,2) = 2

p[2] = 2 - (-2) = 4

mex = min(2,4) = 2

p[1] = 2 - 1 = 1

mex = min(2,1) = 1

p[0] = 1 - 1 = 0

mex = min(1,0) = 0

So, p = [0,1,4,2,3], which matches the example.

Let me verify if this makes sense.

At each step, when setting p[i] = mex - a[i], and then updating mex to min(mex, p[i]).

In the first step, p[4] = 5 - 2 = 3, and mex = min(5,3) = 3

Then, p[3] = 3 - 1 = 2, mex = min(3,2) = 2

p[2] = 2 - (-2) = 4, mex = min(2,4) = 2

p[1] = 2 - 1 = 1, mex = min(2,1) = 1

p[0] = 1 - 1 = 0, mex = min(1,0) = 0

This seems to work.

Another test case:

n=5

a=[1,1,1,1,1]

p=[0,1,2,3,4]

Let's simulate:

mex=5

p[4]=5-1=4

mex=min(5,4)=4

p[3]=4-1=3

mex=min(4,3)=3

p[2]=3-1=2

mex=min(3,2)=2

p[1]=2-1=1

mex=min(2,1)=1

p[0]=1-1=0

mex=min(1,0)=0

So, p=[0,1,2,3,4], which matches the second test case.

Another test case:

n=3

a=[-2,1,2]

p=[2,0,1]

Simulate:

mex=3

p[2]=3-2=1

mex=min(3,1)=1

p[1]=1-1=0

mex=min(1,0)=0

p[0]=0 - (-2) = 2

mex=min(0,2)=0

So, p=[2,0,1], which matches the third test case.

So, the code seems to be working correctly for the given examples.

Now, I need to understand why this approach works in general.

Let me try to see the logic behind it.

Starting from the end, mex is set to n.

For each i from n-1 down to 0:

p[i] = mex - a[i]

Then, mex = min(mex, p[i])

Why does this work?

From earlier, I know that for i=n:

p[n-1] = n - a[n-1]

Which is correct, since a_n = n - p_n

Similarly, for i=n-1:

a_{n-1} = MEX(p_1 to p_{n-1}) - p_{n-1}

But MEX(p_1 to p_{n-1}) is p_n, as established earlier.

So, a_{n-1} = p_n - p_{n-1}

Therefore, p_{n-1} = p_n - a_{n-1}

Which matches p[i] = mex - a[i], since mex starts at n, and p_n = n - a_n

Then, mex is updated to min(mex, p[i])

Wait, in the first step, p[n-1] = n - a[n-1]

But p_n = n - a_n

So, p_{n-1} = p_n - a_{n-1}

Similarly, for i=n-2:

a_{n-2} = MEX(p_1 to p_{n-2}) - p_{n-2}

MEX(p_1 to p_{n-2}) is the smallest number not in p_1 to p_{n-2}

Given that p_{n-1} and p_n are known, and p_1 to p_{n-2} are all numbers from 0 to n-1 except p_{n-1} and p_n.

Wait, but p_{n-1} and p_n are already determined.

So, MEX(p_1 to p_{n-2}) is the smallest number not in p_1 to p_{n-2}, which is the smallest number not in [p_1 to p_{n-2}]

But p_1 to p_{n-2} are n-2 numbers from 0 to n-1, excluding p_{n-1} and p_n.

Therefore, the MEX is the smaller of p_{n-1} and p_n.

Wait, but p_{n-1} and p_n are both in 0 to n-1.

So, MEX(p_1 to p_{n-2}) is the smallest number not in p_1 to p_{n-2}, which is the smaller of p_{n-1} and p_n.

Wait, but p_{n-1} and p_n are both missing from p_1 to p_{n-2}.

Therefore, MEX(p_1 to p_{n-2}) is the smallest of p_{n-1} and p_n.

But in the code, mex is updated to min(mex, p[i]) at each step.

So, after setting p[n-1], mex becomes min(mex, p[n-1]).

Then, for p[n-2], p[n-2] = mex - a[n-2], where mex is the current mex.

Given that mex is min(mex, p[n-1]), which is min(n, p[n-1])

But p[n-1] = n - a[n-1], which is less than or equal to n-1, since p[n-1] is from 0 to n-1.

Therefore, mex after the first step is p[n-1].

Then, p[n-2] = p[n-1] - a[n-2]

And mex is updated to min(mex, p[n-2])

And so on.

This seems to be recursively setting p[i] based on the previous mex and a[i].

It's a bit confusing, but the examples seem to work out.

Perhaps the key is that mex is being updated to be the smallest possible MEX at each step, considering the previously determined p[i].

Given that the code works for the provided examples and the problem states that there is at least one valid p for the given a, I can conclude that this approach is correct.

Therefore, the given program is correct.

**Final Answer**

\boxed{\text{Correctness: True}}