Alright, I've got this problem to solve. Let's see what it's about. So, there's this game where Bodya and Sasha have a permutation and an array. They start at certain positions in the permutation and make moves for k turns. Each turn, they can either stay at their current position or move to the position indicated by the permutation. Their score increases by the value in the array at their current position each turn. The goal is to determine who wins based on who has the higher score after k turns.

First, I need to understand the inputs and what exactly is being asked. The input consists of multiple test cases. For each test case, I get n (the length of the permutation and array), k (the number of turns), and the starting positions for Bodya and Sasha (P_B and P_S). Then, there's the permutation array p and the score array a.

I need to simulate the game for both players over k turns and see who ends up with a higher score. If their scores are equal, it's a draw.

But simulating each turn for each player individually could be inefficient, especially since n and k can be up to 2*10^5 and 10^9 respectively. So, I need a smarter way to calculate the maximum possible score for each player without simulating each turn step by step.

Let me think about how the game progresses. Each player can choose to stay or move to p[x] at each turn. They aim to maximize their score.

This sounds like a dynamic programming problem, where the state is the current position and the number of turns left. But with k up to 10^9, a standard DP approach won't work due to time constraints.

I need to find a way to compute the maximum score efficiently. Maybe I can analyze the structure of the permutation, since permutations consist of cycles.

If I can identify the cycles in the permutation, I can model the movement of each player as traversing these cycles. Then, for each player, I can compute the maximum score based on their path through the cycle.

Let me recall that in a permutation, every element is part of exactly one cycle. So, for each player, their movement will eventually cycle.

For example, if a player is at position x, and p[x] = y, then moving would take them to y, and so on, until they return to x if the cycle is complete.

Given that, perhaps I can precompute the cycle that each player is in and then compute the maximum score based on how they traverse their respective cycles.

But this seems a bit complicated, and I need to ensure that it's efficient given the constraints.

Looking back at the reference solution, it seems to be trying to simulate the moves up to n steps, but I'm not entirely sure about the logic.

Let me look at the reference solution step by step.

The function func reads the inputs: t (number of test cases), and for each test case, it reads n, k, b, s, the permutation p, and the array a.

It then initializes sp and bp with a[s] and a[b], respectively, which are the initial scores for Sasha and Bodya.

It also initializes bm and sm with a[b] * k and a[s] * k, which are presumably the maximum possible scores if they stay in place for all k turns.

Then, there's a loop that runs up to n times, but it decrements k each time. Inside the loop, it updates b and s to p[b]-1 and p[s]-1, respectively, simulating a move.

Then, it updates bm and sm by adding the maximum of either staying or moving.

Wait, this seems confusing. Let's see.

bm += max(bm, a[b] * k + bp)

sm += max(sm, a[s] * k + sp)

And then it updates sp and bp with the new a[s] and a[b].

This seems incorrect to me. I think there's a mistake in how the scores are being accumulated.

Let me think differently.

Each player has a choice at each turn: stay or move.

If they stay, their score increases by a[x].

If they move, they go to p[x], and their score increases by a[p[x]] in the next turn, and so on.

They can choose differently in each turn to maximize their total score over k turns.

This sounds like a dynamic programming problem where the state is the current position and the number of turns left.

But with k up to 10^9, we need a smarter approach.

An optimization could be to recognize that since the permutation consists of cycles, and once a player enters a cycle, their movement is determined.

So, for each player, I can find the cycle they are in and compute the maximum possible score based on the cycle's structure.

But even that seems too slow for n up to 2*10^5 per test case.

Wait, perhaps I can model this as finding the maximum possible sum of a sequence of choices, where at each step, the player can choose to stay or move.

Given that, maybe I can compute for each player the maximum score by considering the cycle they are in and precomputing the optimal choices.

But I'm not sure.

Let me consider a simpler approach.

Suppose a player is at position x.

They can choose to stay at x for some number of turns, accumulating a[x] each turn, or move to p[x] and accumulate a[p[x]] from there.

This resembles choosing to stay and collect a[x] for some turns, then moving to p[x] and repeating the process.

Given that, perhaps the optimal strategy is to stay at the position with the highest a[x] in their cycle for as many turns as possible.

But I need to formalize this.

Let me consider that in a cycle, the player will eventually loop back to the starting position.

So, for each cycle, I can compute the maximum a[x] in the cycle and multiply it by k, but that might not be accurate because they might need to move through other positions to reach it.

Wait, perhaps not.

Let me think differently.

Suppose I fix a player and their starting position.

I can model their movement as a sequence of positions determined by following the permutation.

Since it's a permutation, this sequence will eventually cycle.

So, for example, starting at x, next is p[x], then p[p[x]], and so on.

Given that, for each player, their sequence of positions is determined in advance, and they can choose at each turn to stay or move to the next position in the sequence.

But this is getting complicated.

An alternative approach is to realize that the problem can be modeled as two separate optimization problems, one for each player, since their moves are independent.

So, I can focus on computing the maximum possible score for Bodya and for Sasha separately, and then compare the two scores.

Now, for one player, starting at position x, with k turns, at each turn, they can choose to stay at x and get a[x], or move to p[x].

This sounds like a tree where each node has two children: one for staying and one for moving.

But with k up to 10^9, building a tree is impossible.

I need a mathematical formula or a cycle-based approach to compute the maximum score.

Let me consider that in the sequence of positions generated by following p[x], there are cycles.

So, for a player, their positions over time will be a sequence that eventually repeats.

Suppose the cycle length is c, and the maximum a[x] in the cycle is m.

Then, in k turns, the player can achieve a score of k * m, but this assumes they can stay at m for all k turns.

However, in reality, they might need to move through other positions to reach m, and once they reach m, they can stay there.

But if m is part of a cycle, they might have to traverse the cycle to get back to m.

Wait, perhaps I need to find, for each player, the maximum a[x] in their cycle and the length of the cycle.

Then, the optimal strategy is to stay at m for as many turns as possible, and move through the necessary positions to reach m when needed.

But I need to formalize this.

Let me consider that in a cycle of length c, with positions x1, x2, ..., xc, and corresponding a[x1], a[x2], ..., a[xc].

The player can choose, at each turn, to stay or move.

To maximize the score, they should try to stay at the position with the highest a[x] as much as possible.

So, find the position with the maximum a[x] in the cycle, say m.

Then, the player should try to stay at m for as many turns as possible.

To do that, they need to reach m, stay there for as many turns as possible, and if they have to move, they have to cycle back to m.

So, the optimal strategy is to reach m, stay there for as many turns as possible, and then, if k is not a multiple of the cycle length, handle the remaining turns.

This seems promising.

So, for each player, I need to:

1. Identify the cycle that their starting position is in.

2. Find the position with the maximum a[x] in that cycle.

3. Compute the maximum score by staying at m for as many turns as possible, considering the cycle length.

Let me formalize this.

Letâ€™s say the cycle length is c, and the maximum a[x] in the cycle is m.

The player can reach m in at most c-1 moves, and then stay at m for the remaining turns.

So, the maximum score would be:

- If k <= c-1: sum of a[x] for the first k positions in the cycle.

- Else: sum of a[x] for the first c-1 positions to reach m, plus m multiplied by floor((k - (c-1)) / c) * c, plus a[x] for the remaining (k - (c-1)) % c positions after reaching m.

Wait, this seems a bit messy.

Maybe there's a better way.

Let me consider that once the player reaches m, they can stay there forever, accumulating m per turn.

But to reach m, it might take some initial moves.

So, the total score would be:

- The sum of a[x] for the path to reach m.

- Plus m multiplied by the number of turns remaining after reaching m.

But I need to handle the case where m is not directly reachable in one move, and the player might have to traverse part of the cycle to reach it.

This is getting complicated.

Perhaps I should look for a different approach.

Let me consider that for each player, their movement can be modeled as a Markov chain on the cycle they are in.

In that case, the optimal strategy would be to stay at the state with the highest reward.

But I'm not sure how to translate that into a formula.

Alternatively, perhaps I can model this as a graph where each node has two outgoing edges: one for staying and one for moving.

Then, finding the maximum score would be finding the maximum path sum of length k in this graph.

But again, with k up to 10^9, this is not feasible.

I need a better way.

Wait, perhaps I can observe that in the long run, the player will end up cycling through the cycle, and the best strategy is to stay at the position with the maximum a[x] as much as possible.

So, the maximum score would be:

(max_a * floor(k / cycle_length)) + (sum of a[x] along the path to reach max_a position) + (sum of a[x] for the remaining turns after completing full cycles).

But I need to make sure that the path to reach max_a position is optimized.

This seems similar to the approach I was thinking earlier.

Let me try to formalize it.

For a given player starting at position x:

1. Find the cycle that x belongs to.

2. Find the position m in the cycle with the maximum a[m].

3. Compute the minimal number of moves t to reach m from x.

4. Then, the maximum score is:

(a[x] * t) + (a[m] * floor((k - t) / cycle_length)) + sum of a[x] for the first (k - t) % cycle_length positions after reaching m.

Wait, I'm getting confused.

Let me try to think differently.

Suppose I fix a player and their starting position x.

I can compute the sequence of positions they visit if they always choose to move: x, p[x], p[p[x]], and so on.

This sequence will eventually cycle.

Now, for each position in this sequence, the player can choose to stay or move.

So, for each position, the player has two choices: stay and get a[x], or move and get a[p[x]] in the next turn.

This resembles a recursive decision tree, but again, with k up to 10^9, this is not practical.

I need a way to compute the maximum score efficiently.

Perhaps I can consider that the optimal strategy is to stay at the position with the maximum a[x] in the cycle for as many turns as possible, and minimize the number of moves needed to reach it.

Given that, I can compute for each player:

- The maximum a[x] in their cycle, say m.

- The minimal number of moves to reach m from their starting position, say t.

Then, the maximum score would be:

(a[x1] + ... + a[x_t]) + m * (k - t)

But this assumes that after reaching m, the player stays there for the remaining k - t turns.

However, this might not be accurate because the cycle might require visiting other positions before returning to m.

So, I need to take into account the cycle length.

Letâ€™s denote:

- m: the maximum a[x] in the cycle.

- t: the number of moves to reach m from the starting position.

- c: the cycle length.

Then, the maximum score would be:

(sum of a[x] for the first t positions to reach m) + m * floor((k - t) / c) * c + (sum of a[x] for the first (k - t) % c positions after reaching m).

This seems more accurate.

So, for each player, I need to:

1. Find the cycle that their starting position is in.

2. Find the position m in the cycle with the maximum a[x].

3. Compute the minimal number of moves t to reach m from the starting position.

4. Compute the sum of a[x] for the path to m.

5. Compute the sum of a[x] for one full cycle.

6. Then, the maximum score is:

(path_sum) + (m * floor((k - t) / c) * c) + (sum of a[x] for the first (k - t) % c positions after reaching m).

But this still seems complicated to implement efficiently, especially since n can be up to 2*10^5 and k up to 10^9.

I need a better way.

Let me consider that in a cycle, the player can choose to stay or move at each step.

But perhaps there's a way to model this as a linear recurrence or something similar.

Alternatively, maybe I can consider that the optimal strategy is to stay at the position with the maximum a[x] whenever possible, and only move when necessary to reach it.

Given that, perhaps the maximum score can be computed by finding the maximum a[x] in the cycle and multiplying it by k, minus some adjustment for the moves needed to reach it.

But I need to formalize this.

Wait, perhaps I can think in terms of the greatest common divisor (GCD) of the cycle lengths or something similar, but I'm not sure.

Let me consider a small example to see if I can find a pattern.

Take the first example from the note:

n=4, k=2, P_B=3, P_S=2

p = [4,1,2,3]

a = [7,2,5,6]

So, Bodya starts at position 3 (0-indexed: 2), Sasha starts at position 2 (0-indexed:1)

Let's see the possible moves for Bodya:

- Turn 1: stay at 2, score += 5; or move to p[3]=3, score +=6

- If stay at 2: turn 2, stay at 2, score +=5; total score=10

- If move to 3: turn 2, stay at 3, score +=6; total score=12

- Or move to p[4]=2, score +=5; total score=11

Similarly for Sasha:

- Turn 1: stay at 1, score +=2; or move to p[2]=1, score +=2

- If stay at 1: turn 2, stay at 1, score +=2; total score=4

- If move to 1: same as staying

So, the maximum score for Bodya is 12, for Sasha is 4.

But according to the explanation in the problem, Bodya's score is 10 and Sasha's is 9, which doesn't match my calculation.

Wait, perhaps I misread the positions.

Wait, in the problem, positions are 1-based, so P_B=3, P_S=2.

In 0-based indexing, b=2, s=1.

p=[4,1,2,3] -> p[0]=4, p[1]=1, p[2]=2, p[3]=3.

Wait, p[0]=4, but in 0-based indexing, p should be 0 to n-1.

Wait, the problem says p_i is from 1 to n, so p=[4,1,2,3] means p[1]=4, p[2]=1, p[3]=2, p[4]=3.

In 0-based indexing, p[0]=undefined (since positions are 1 to n), p[1]=4, p[2]=1, p[3]=2, p[4]=3.

Wait, but in Python, lists are 0-based, so p[0] is not used.

Alternatively, perhaps the code uses 1-based indexing for p.

I need to make sure about the indexing.

Assuming p is 1-based, with p[1] to p[n], and a is 0-based.

Wait, no, in Python, lists are 0-based.

In the code, p is read as list(map(int, input().split())), so p[0] corresponds to p_1.

So, p[0] = p_1, p[1] = p_2, ..., p[n-1] = p_n.

Similarly, a[0] = a_1, a[1] = a_2, ..., a[n-1] = a_n.

But in the problem, positions are 1-based.

So, starting positions P_B and P_S are 1-based.

Hence, in code, b and s are adjusted to 0-based indexing by subtracting 1.

So, b = P_B - 1, s = P_S - 1.

Now, for the example:

n=4, k=2, P_B=3, P_S=2

p = [4,1,2,3] # p[0]=4, p[1]=1, p[2]=2, p[3]=3

a = [7,2,5,6] # a[0]=7, a[1]=2, a[2]=5, a[3]=6

So, Bodya starts at b=2 (position 3), a[b]=5

Sasha starts at s=1 (position 2), a[s]=2

Now, let's see the possible moves:

For Bodya:

- Turn 1: stay at 2, score +=5; or move to p[3]=3, score +=6

- If stay at 2:

- Turn 2: stay at 2, score +=5; total=10

- If move to 3:

- Turn 2: stay at 3, score +=6; total=12

- Or move to p[4]=2, score +=5; total=11

So, maximum for Bodya is 12.

For Sasha:

- Turn 1: stay at 1, score +=2; or move to p[2]=1, score +=2

- If stay at 1:

- Turn 2: stay at 1, score +=2; total=4

- If move to 1:

- Turn 2: stay at 1, score +=2; total=4

So, maximum for Sasha is 4.

But according to the problem's explanation, Bodya's final score is 10 and Sasha's is 9, which doesn't match my calculation.

Wait, perhaps I'm misunderstanding the movement.

Let me look back at the problem statement.

"On each turn, two things happen to each player:

- If the current position of the player is x, his score increases by a_x.

- Then the player either stays at his current position x or moves from x to p_x."

So, the score increases first, based on the current position, and then the player chooses to stay or move.

In my earlier calculation, I might have misordered these steps.

Let me try again.

For Bodya starting at b=2 (position 3), a[b]=5

Turn 1:

- Score +=5 (current position is 2)

- Choose to stay at 2 or move to p[3]=3

If stay:

- Position remains 2

If move:

- Position becomes 3

Turn 2:

- Score += a[current position]

- Choose to stay or move again

So, if Bodya chooses to stay both turns:

- Turn 1: score +=5, stay at 2

- Turn 2: score +=5, stay at 2

- Total: 10

If Bodya chooses to move on turn 1:

- Turn 1: score +=5, move to 3

- Turn 2: score +=6, stay at 3

- Total: 11

Or, move again on turn 2:

- Turn 1: score +=5, move to 3

- Turn 2: score +=6, move to 2

- Total: 11

So, maximum is 11, not 12 as I previously thought.

But according to the problem's explanation, Bodya's score is 10, which is from staying at 2 for both turns.

Wait, perhaps I'm still misunderstanding.

Let me look at the problem's example again.

In the problem's example, Bodya stays at 3 (position 4 in 1-based indexing) for both turns, accumulating a[3] + a[3] = 5 + 5 = 10.

Sasha moves from position 2 to position 1 in the first turn, then stays at 1 in the second turn, accumulating a[2] + a[1] = 2 + 7 = 9.

Wait, in 0-based indexing, a[2]=5, a[1]=2, a[0]=7, a[3]=6.

So, Sasha starts at s=1 (position 2), a[s]=2.

- Turn 1: score +=2, move to p[2]=1 (position 1), which is index 0 in 0-based.

- Turn 2: score +=7, stay at 0.

- Total: 9

Bodya starts at b=2 (position 3), a[b]=5.

- Turn 1: score +=5, stay at 2.

- Turn 2: score +=5, stay at 2.

- Total: 10

So, Bodya wins with 10 vs. Sasha's 9.

But according to my earlier calculation, Bodya could have gotten 11 by moving to 3 in the first turn and staying there in the second turn.

But according to the problem's explanation, Bodya chooses to stay at 3 for both turns to get 10.

I'm confused why Bodya doesn't choose to move to 3 in the first turn and stay there to get 11.

Wait, a[3]=6, so staying at 3 for both turns would give 6 + 6 = 12.

But in the problem's explanation, Bodya stays at 3 (position 4) and gets 5 + 5 = 10.

Is there a mistake in the problem's explanation or in my understanding?

Wait, perhaps there's a misunderstanding in the indexing.

Let me check the permutation p.

p = [4,1,2,3]

So, p[0]=4, p[1]=1, p[2]=2, p[3]=3

In 1-based indexing, p[1]=4, p[2]=1, p[3]=2, p[4]=3

So, from position 3 (index 2), p[3]=3, so p[3]=3 means staying at 3.

Wait, p[3]=3, which in 1-based indexing is p[4]=3, meaning from position 4, move to position 3.

But in 0-based indexing, p[3]=3 means from position 3, move to position 3, i.e., stay at 3.

Similarly, p[2]=2 means from position 3 (since p is 1-based), move to position 2.

Wait, I'm getting tangled in indexing.

Let me clarify:

- Positions are 1-based in the problem.

- p is given as 1-based, but in Python, it's 0-indexed.

So, p[0] = p_1, p[1] = p_2, ..., p[n-1] = p_n.

In the first test case:

n=4, k=2, P_B=3, P_S=2

p = [4,1,2,3]

a = [7,2,5,6]

So, positions:

1 -> 4

2 -> 1

3 -> 2

4 -> 3

So, Bodya starts at position 3, which maps to position 2.

Sasha starts at position 2, which maps to position 1.

Wait, but in the problem's explanation, Bodya stays at position 3 and gets a[3]=5 each turn.

Wait, a[3]=6 in 0-based indexing, but in 1-based indexing, a_3=6.

Wait, a = [7,2,5,6], so a[2]=5, a[3]=6.

Wait, perhaps the problem uses 1-based indexing for a as well.

Wait, no, in the problem statement, a is 1-based.

But in Python, it's 0-based.

So, a[0]=a_1=7, a[1]=a_2=2, a[2]=a_3=5, a[3]=a_4=6.

But in the problem's explanation, Bodya starts at position 3, gets a[3]=5, stays at 3, gets a[3]=5 again, total 10.

Sasha starts at position 2, gets a[2]=5, moves to p[2]=1, gets a[1]=2, total 7.

Wait, but in the problem's explanation, Sasha moves to p[2]=1, gets a[1]=7, stays at 1, gets a[1]=7 again, total 14.

Wait, but in the problem's output, it's "Bodya", with Bodya having 10 and Sasha having 9.

I'm getting confused.

Let me look back at the problem's example.

In the problem's example, it shows:

Turn | Bodya's position | Bodya's score | Bodya's move | Sasha's position | Sasha's score | Sasha's move

first | 3 | 0 + a_3=5 | stays | 2 | 0 + a_2=2 | moves to p_2=1

second | 3 | 5 + a_3=10 | stays | 1 | 2 + a_1=9 | stays

So, Bodya stays at 3, getting a[3]=5 both turns, total 10.

Sasha moves to 1 in the first turn, gets a[1]=7, then stays at 1 in the second turn, gets a[1]=7 again, total 9.

Wait, according to this, Sasha has 2 + 7 = 9, but according to the table, it's 0 + a_2=2, then moves to p_2=1, gets a[1]=7, total 9.

So, Sasha's initial score is 0, first turn gets a[2]=2, moves to 1, second turn gets a[1]=7, stays at 1.

Total: 2 + 7 = 9.

Bodya starts at 3, gets a[3]=5, stays at 3, second turn gets a[3]=5 again, total 10.

So, Bodya wins with 10 vs. Sasha's 9.

But according to my earlier calculation, Sasha could have stayed at 2 and gotten a[2]=2 both turns, total 4, but moving to 1 gives 2 + 7 = 9, which is better.

Bodya can stay at 3 and get 5 + 5 = 10, or move to 3 and stay, same thing.

So, 10 vs. 9, Bodya wins.

Now, in my earlier thought process, I was confused about the indexing, but it seems the problem's explanation is correct.

So, in code, we need to correctly handle 1-based vs. 0-based indexing.

Now, back to the reference solution.

In the reference solution, it seems to be trying to simulate the moves up to n steps, but I'm not sure about the logic.

Looking at the code:

sp = a[s]

bp = a[b]

bm = a[b] * k

sm = a[s] * k

Then, a loop that runs up to n times, decrementing k each time, updating b and s to p[b]-1 and p[s]-1, and updating bm and sm by adding max(bm, a[b]*k + bp) and similarly for sm.

This seems incorrect to me.

I think the approach should be to compute for each player the maximum possible score based on their cycle and the number of turns.

Given time constraints, I need an efficient way to compute this.

Perhaps I can precompute for each player the cycle they are in, find the maximum a[x] in that cycle, and compute the maximum score accordingly.

But I need to make sure it's efficient.

Let me try to outline an efficient algorithm.

For each player:

1. Find the cycle that their starting position is in.

- Traverse the permutation starting from their position until we return to the starting position, keeping track of the positions in the cycle.

2. Find the position m in the cycle with the maximum a[x].

3. Compute the minimal number of moves t to reach m from the starting position.

4. Compute the sum of a[x] for the path to m.

5. Compute the sum of a[x] for one full cycle.

6. Then, the maximum score is:

(path_sum) + (m * floor((k - t) / c) * c) + (sum of a[x] for the first (k - t) % c positions after reaching m).

This seems correct, but I need to implement it efficiently.

Given that n can be up to 2*10^5 and t up to 10^4, I need to make sure that the overall time complexity is acceptable.

If I process all players' cycles in separate traversals, and since the total n across all test cases is up to 2*10^5, it should be manageable.

Let me try to implement this logic.

First, for each test case, I need to:

- Read n, k, b, s.

- Read p and a.

- For Bodya and Sasha, compute their maximum possible scores.

- Compare the scores and decide who wins.

For computing the maximum score for one player:

- Find the cycle containing the starting position.

- Find the maximum a[x] in the cycle.

- Find the minimal number of moves to reach that position.

- Compute the sum of a[x] along the path to reach it.

- Then, compute the remaining turns and the score accordingly.

I need to handle multiple test cases efficiently.

Given time constraints, I need to make sure that my implementation is optimized.

Looking back at the reference solution, it seems to be attempting to simulate up to n steps, but I'm not sure about the correctness.

Given that, and considering time constraints, I think the reference solution might be incorrect.

Therefore, Correctness: False

**Final Answer**

\[\boxed{\text{False}}\]