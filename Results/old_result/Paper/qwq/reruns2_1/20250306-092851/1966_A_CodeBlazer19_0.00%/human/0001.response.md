Alright, I've got this problem to solve. Let's see what it's asking for. So, I have a hand of n cards, each with a number on it, and a fixed integer k. The operation I can perform is to choose any k cards that all have the same number and exchange them for k-1 cards, each with any number I choose. The goal is to find the minimum number of cards I can have in the end after performing this operation any number of times.

First, I need to understand the operation clearly. If I have k cards with the same number, I can replace them with k-1 cards of any numbers I choose. So, essentially, I'm reducing the number of cards by 1 each time I perform this operation on a set of k identical cards.

I need to minimize the number of cards I have in the end. So, I should try to perform this operation as many times as possible, reducing the total number of cards each time.

Let's consider an example to get a better understanding. Take the first example from the problem:

Input:

5 3

4 1 1 4 4

So, n=5, k=3, and the cards are [4,1,1,4,4].

From this, I can see that I have three 4's and two 1's. Since k=3, I can perform the operation on the three 4's: replace them with two cards of any number. Let's say I choose to replace them with two 1's. Now, my hand has [1,1,1]. Now, I have three 1's, so I can again perform the operation: replace three 1's with two cards of any number. Let's say I choose two 2's. Now, I have [2,2]. I can't perform any more operations because I don't have three identical cards. So, the minimum number of cards is 2.

Another example:

Input:

1 10

7

Here, n=1, k=10. I have only one card, which is 7. Since k=10, I need at least 10 identical cards to perform an operation, which I don't have. So, I can't perform any operations, and the minimum number of cards is 1.

Another example:

Input:

7 2

4 2 1 100 5 2 3

Here, n=7, k=2. Pairs of identical cards: two 2's, and the rest are unique. So, I can perform the operation on the two 2's: replace them with one card of any number. Let's say I choose to replace them with one 2. Now, I have [4,1,100,5,2,3]. Now, I have only one pair of 2's again, but since k=2, I can replace them again. Replace two 2's with one card, say 2 again. Now, I have [4,1,100,5,2,3]. Wait, that doesn't make sense because I only have one 2 now. Let me correct that.

Wait, when I replace two 2's with one card, I choose any number for that card. Let's say I choose 2 again. But actually, it's irrelevant what number I choose because I can choose any number. But in terms of minimizing the total number of cards, I need to think strategically.

Let's say I replace the two 2's with one card, say 1. Now, my hand is [4,1,100,5,1,3]. Now, I have two 1's. So, I can perform the operation again: replace two 1's with one card. Choose, say, 1 again. Now, I have [4,100,5,1,3]. No more pairs, so I can't perform any more operations. The minimum number of cards is 5.

But according to the sample input, the output for this case is 1. So, there must be a better sequence of operations.

Wait, maybe I should choose different numbers when replacing. Let's try again.

Start with [4,2,1,100,5,2,3].

Perform operation on the two 2's, replace them with one card, say choose 4. Now, my hand is [4,1,100,5,4,3].

Now, I have two 4's. Perform operation on the two 4's, replace them with one card, say choose 1. Now, my hand is [1,100,5,1,3].

Now, I have two 1's. Perform operation on the two 1's, replace them with one card, say choose 100. Now, my hand is [100,5,100,3].

Now, I have two 100's. Perform operation on the two 100's, replace them with one card, say choose 5. Now, my hand is [5,3,5].

Now, I have two 5's. Perform operation on the two 5's, replace them with one card, say choose 3. Now, my hand is [3,3].

Perform operation on the two 3's, replace them with one card, say choose 3. Now, my hand is [3]. No more operations can be performed. The minimum number of cards is 1.

Ah, so by strategically choosing the numbers to replace with, I can reduce the total number of cards to 1.

Another example:

Input:

10 4

1 1 1 1 1 1 1 1 1 1

So, n=10, k=4, and all cards are 1's.

I can perform the operation on any four 1's, replacing them with three cards of any number. Let's say I choose to replace them with three 1's again. So, after one operation, I have 10 - 4 + 3 = 9 cards, all 1's.

Now, I can perform the operation again on four 1's, replace them with three 1's. Now, I have 9 - 4 + 3 = 8 cards.

Wait, actually, 9 - 4 + 3 = 8.

Wait, but 9 - 4 = 5, plus 3 = 8.

Wait, but I have eight cards now.

Wait, but I need to be careful with the counts.

Wait, perhaps there's a better way to calculate this.

In general, each operation reduces the number of cards by k - (k-1) = 1.

Wait, but in this case, it's more nuanced because it depends on how many identical cards I have.

Wait, perhaps I need to think in terms of the maximum number of operations I can perform.

Each operation requires k identical cards and reduces the total number of cards by k - (k-1) = 1.

So, for each operation, the total number of cards decreases by 1.

Therefore, the minimum number of cards I can have is n - m, where m is the maximum number of operations I can perform.

But what's the maximum number of operations I can perform?

Each operation consumes k cards of the same number and produces k-1 cards of any number.

So, effectively, each operation reduces the total number of cards by 1.

Therefore, the minimum number of cards is n - m, where m is the maximum number of such operations I can perform.

To maximize m, I need to perform as many operations as possible, which means grouping the cards into sets of k identical cards.

So, for a given number that appears x times, the number of operations I can perform on it is floor(x / k).

After performing floor(x / k) operations on that number, I'll be left with x - floor(x / k) * k cards.

But wait, no. Actually, each operation reduces the count of that number by k and adds k-1 cards of a new number.

Wait, but I can choose the new numbers arbitrarily.

Wait, perhaps it's better to think in terms of the total number of cards.

Each operation reduces the total number of cards by 1, as explained earlier.

So, the minimum number of cards is n - m, where m is the maximum number of operations I can perform.

To maximize m, I need to perform operations as long as I have at least k cards of the same number.

But actually, it's a bit more involved because after performing an operation, the new cards added can be of any number, which might allow for more operations if I choose wisely.

In the earlier example, by choosing to replace with a number that already exists or that can be used to form new groups.

This seems a bit tricky. Maybe there's a smarter way to approach this.

Let me consider the frequencies of the numbers.

Let f1, f2, ..., fm be the frequencies of the distinct numbers in the hand.

For each fi, I can perform floor(fi / k) operations directly on that number.

Each such operation reduces the total number of cards by 1.

After performing these operations, I'll have fi - floor(fi / k) * k cards left for each number.

But wait, in each operation, I'm replacing k cards of one number with k-1 cards of possibly another number.

So, the new cards added can be used in future operations.

This complicates things because the new cards can be of any number, which might help in forming new groups.

So, perhaps I need to consider the overall reduction in the number of cards.

Wait, maybe I can model this as a greedy algorithm where I repeatedly perform operations on the numbers with the highest frequencies until no more operations can be performed.

But that might not be efficient.

Looking back at the sample inputs and outputs:

Sample Input:

7

5 3

4 1 1 4 4

1 10

7

7 2

4 2 1 100 5 2 3

10 4

1 1 1 1 1 1 1 1 1 1

5 2

3 8 1 48 7

6 2

10 20 30 10 20 40

6 3

10 20 30 10 20 40

Sample Output:

2

1

1

3

5

1

6

Looking at the first input:

n=5, k=3, cards=[4,1,1,4,4]

As I did earlier, I can reduce it to 2 cards.

Second input:

n=1, k=10, cards=[7]

Can't perform any operations, so minimum is 1.

Third input:

n=7, k=2, cards=[4,2,1,100,5,2,3]

As I did earlier, I can reduce it to 1 card.

Fourth input:

n=10, k=4, cards=[1,1,1,1,1,1,1,1,1,1]

As I did earlier, after performing operations, I'm left with 3 cards.

Fifth input:

n=5, k=2, cards=[3,8,1,48,7]

All unique, can't perform any operations, so minimum is 5.

Sixth input:

n=6, k=2, cards=[10,20,30,10,20,40]

Have two 10's and two 20's.

Perform operation on two 10's, replace with one card, say 10.

Now, cards are [10,20,30,20,40,10].

Now, have two 10's and two 20's again.

Perform operation on two 10's, replace with one card, say 10.

Now, cards are [10,20,30,20,40].

Now, have two 20's.

Perform operation on two 20's, replace with one card, say 20.

Now, cards are [10,30,40,20].

No more pairs, so minimum is 4.

But according to the sample output, it's 1. So, I must be doing something wrong.

Wait, perhaps I need to choose the replacement cards more strategically.

Start with [10,20,30,10,20,40].

Perform operation on two 10's, replace with one 20.

Now, cards are [20,20,30,20,40].

Perform operation on three 20's, replace with two 30's.

Now, cards are [30,30,30,40].

Perform operation on three 30's, replace with two 40's.

Now, cards are [40,40].

Perform operation on two 40's, replace with one 40.

Now, cards are [40]. Minimum is 1.

Okay, so by choosing the replacement cards wisely, I can reduce to 1 card.

Seventh input:

n=6, k=3, cards=[10,20,30,10,20,40]

Have two 10's, two 20's, one 30, one 40.

Perform operation on two 10's, replace with one 10.

Now, cards are [10,20,30,20,40,10].

Perform operation on two 10's, replace with one 10.

Now, cards are [10,20,30,20,40].

Perform operation on two 20's, replace with one 20.

Now, cards are [10,30,20,40].

No more operations can be performed. Minimum is 4.

But according to the sample output, it's 6. Wait, no, sample output is 6 for this case.

Wait, no, sample output is:

2

1

1

3

5

1

6

So, for n=6, k=3, cards=[10,20,30,10,20,40], output is 6.

But in my calculation, I ended up with 4 cards. But according to the sample, it's 6.

Wait, perhaps I misread the sample output. Let me check again.

Wait, the seventh input is:

6 3

10 20 30 10 20 40

Sample output: 6

But in my calculation, I ended up with 4 cards, but sample output is 6.

Wait, maybe I didn't perform operations correctly.

Alternatively, perhaps there are constraints I'm missing.

Wait, perhaps when k=3, I need to have exactly k cards to perform an operation, and I can't perform operations if I have less than k cards, even if I have multiple groups that can be operated on separately.

Wait, in the seventh input, n=6, k=3, cards=[10,20,30,10,20,40]

I have two 10's, two 20's, and two 40's.

Since k=3, I can't perform any operations because I don't have any number that appears at least 3 times.

Therefore, the minimum number of cards is 6.

Ah, I see. I must have made a mistake earlier.

So, in this case, since no number appears at least k times, I can't perform any operations, so the minimum number of cards is n.

Wait, but in the sixth input, n=6, k=2, cards=[10,20,30,10,20,40], I was able to reduce it to 1 card because k=2, and I had pairs.

But in the seventh input, k=3, and no number appears at least 3 times, so I can't perform any operations.

Therefore, the minimum is n=6.

So, in general, if no number appears at least k times, the minimum number of cards is n.

Otherwise, I can perform operations to reduce the total number of cards.

But in the fourth input, n=10, k=4, all cards are 1's.

I can perform operations repeatedly until I can't anymore.

Each operation reduces the number of cards by 1.

So, I can perform floor(10 / 4) = 2 operations initially, reducing the total to 10 - 2 = 8 cards.

Then, floor(8 / 4) = 2 more operations, reducing to 8 - 2 = 6 cards.

Then, floor(6 / 4) = 1 operation, reducing to 6 - 1 = 5 cards.

Then, floor(5 / 4) = 1 operation, reducing to 5 - 1 = 4 cards.

Then, floor(4 / 4) = 1 operation, reducing to 4 - 1 = 3 cards.

So, minimum is 3 cards.

But is there a way to have fewer than that?

Looking at the sample output, it's 3, so apparently not.

But perhaps with strategic replacement, I can do better.

Wait, no. Since all cards are 1's, and k=4, I have to replace four 1's with three cards of any number.

If I choose to replace them with three 1's again, I'm back to the same situation.

Alternatively, I could choose different numbers.

For example, replace four 1's with three 2's.

Now, I have three 2's and the rest are 1's.

But then, I can't perform any more operations because I don't have four identical cards anymore.

So, I'm left with three 2's and the remaining cards.

Wait, no. Wait, I started with 10 ones. After first operation, replace four 1's with three 2's, so now I have three 2's and six 1's.

Now, I can perform another operation on four 1's, replace them with three 2's.

Now, I have three 2's plus three 2's, totaling six 2's.

Now, I can perform floor(6 / 4) = 1 operation, replace four 2's with three 3's.

Now, I have three 3's and two 2's.

No more operations since I don't have four identical cards.

So, I'm left with five cards.

Still, the minimum is three.

Wait, but according to the earlier calculation, it's three.

So, perhaps the general approach is to keep performing operations on the numbers that have at least k cards, choosing to replace them with a number that already has enough cards to allow more operations.

But this seems complicated.

Is there a mathematical formula to compute this?

Looking back at the fourth sample input: n=10, k=4, all cards are 1's.

Perform floor(10 / 4) = 2 operations, reducing to 10 - 2 = 8 cards.

Then floor(8 / 4) = 2 operations, reducing to 8 - 2 = 6 cards.

Then floor(6 / 4) = 1 operation, reducing to 6 - 1 = 5 cards.

Then floor(5 / 4) = 1 operation, reducing to 5 - 1 = 4 cards.

Then floor(4 / 4) = 1 operation, reducing to 4 - 1 = 3 cards.

So, total operations: 2 + 2 + 1 + 1 + 1 = 7 operations, reducing n by 7, so n - m = 10 - 7 = 3.

But is there a better way?

Alternatively, perhaps the minimum number of cards is n mod (k - 1).

Wait, in the fourth sample, n=10, k=4, 10 mod 3 = 1, but the sample output is 3.

Wait, that doesn't match.

Wait, perhaps it's ceil(n / (k - 1)) * (k - 1) - m.

Wait, maybe I need to think differently.

Looking at the operation: replace k cards with k-1 cards.

So, each operation reduces the total number of cards by 1.

The maximum number of operations I can perform is equal to the number of times I can gather k cards of the same number.

But this can be maximized by always choosing the number with the highest frequency.

In the fourth sample, with n=10, k=4, all cards are 1's.

So, I can perform floor(10 / 4) = 2 operations initially, reducing to 10 - 2 = 6 cards.

Then, floor(6 / 4) = 1 operation, reducing to 6 - 1 = 5 cards.

Then, floor(5 / 4) = 1 operation, reducing to 5 - 1 = 4 cards.

Then, floor(4 / 4) = 1 operation, reducing to 4 - 1 = 3 cards.

So, total operations: 2 + 1 + 1 + 1 = 5 operations, reducing n by 5, so minimum cards is 10 - 5 = 5.

But according to the sample, it's 3.

Wait, perhaps I need to perform operations in a way that minimizes the remaining cards.

Wait, maybe it's n - floor(n / k) * (k - 1).

Wait, for n=10, k=4: 10 - floor(10 / 4) * 3 = 10 - 2 * 3 = 10 - 6 = 4.

But sample output is 3.

Wait, not matching.

Alternatively, maybe n - (n - m) where m is the number of operations.

Wait, that doesn't help.

Wait, perhaps it's n - floor(n / k) * (k - 1).

Wait, for n=10, k=4: 10 - floor(10 / 4) * 3 = 10 - 2 * 3 = 4.

But sample output is 3.

Hmm.

Wait, perhaps it's n - (k - 1) * floor(n / (k - 1)).

Wait, for n=10, k=4: 10 - 3 * floor(10 / 3) = 10 - 3 * 3 = 10 - 9 = 1.

But sample output is 3.

Wait, not matching.

Alternatively, perhaps it's n - (k - 1) * (floor(n / k)).

For n=10, k=4: 10 - 3 * 2 = 10 - 6 = 4.

Still not matching.

Wait, perhaps I need to consider the residual after the operations.

Wait, perhaps it's n - (k - 1) * (floor(n / k)).

For n=10, k=4: 10 - 3 * 2 = 4.

But sample output is 3.

Wait, perhaps I need to subtract one more.

Wait, perhaps it's n - (k - 1) * (floor(n / k)) - ceil(n % k, k).

Wait, that seems complicated.

Alternatively, perhaps it's n - (k - 1) * (n // k).

For n=10, k=4: 10 - 3 * 2 = 4.

Still not matching.

Wait, perhaps I need to consider the number of groups I can form.

Each operation consumes k cards and produces k-1 cards.

So, the net reduction is 1 card per operation.

The maximum number of operations is the floor of the sum of floor(fi / k) for all i.

Wait, but in the fourth sample, sum of floor(fi / k) = floor(10 / 4) = 2.

So, n - m = 10 - 2 = 8.

But after one operation, I have 8 cards, all 1's.

Then, floor(8 / 4) = 2 more operations, reducing to 6 cards.

Then floor(6 / 4) = 1 operation, reducing to 5 cards.

Then floor(5 / 4) = 1 operation, reducing to 4 cards.

Then floor(4 / 4) = 1 operation, reducing to 3 cards.

So, total operations: 2 + 2 + 1 + 1 + 1 = 7 operations, n - m = 10 - 7 = 3.

Which matches the sample output.

So, perhaps the general formula is n - m, where m is the maximum number of operations I can perform.

And m is the sum of floor(fi / k) over all i, iteratively until no fi >= k.

But this seems inefficient to compute iteratively for each test case.

Is there a better way to compute m without iterating?

Wait, perhaps m is equal to n - the minimum number of cards left.

But that's circular.

Wait, perhaps m is equal to n - the minimum number of cards left, which is what we're trying to find.

Wait, perhaps I need to think in terms of the maximum number of operations I can perform.

Each operation reduces n by 1, so m is the number of operations performed.

Thus, the minimum number of cards left is n - m.

But m is the maximum number of times I can perform the operation.

To maximize m, I need to perform operations as long as there exists at least one number with at least k cards.

This seems like a process that can be modeled by repeatedly applying floor(fi / k) for each fi and summing them up, then updating fi = fi - floor(fi / k) * k + (k - 1).

But this is similar to repeatedly dividing by k and summing up the quotients.

Wait, actually, it's similar to finding the sum of floor(fi / (k - 1)) for all i.

Wait, perhaps not.

Wait, perhaps it's similar to the greedy algorithm for finding the maximum number of operations.

But I'm getting stuck on finding a direct formula.

Looking back at the problem, perhaps I should consider that each operation reduces the total number of cards by 1, and I can perform operations as long as there's at least one number with at least k cards.

Therefore, the minimum number of cards left is n - m, where m is the maximum number of operations I can perform.

To maximize m, I need to perform operations until no number has at least k cards.

Each operation reduces n by 1.

So, m is the maximum number of times I can reduce n by 1, which is n - s, where s is the minimum number of cards left.

But that's just restating the problem.

I need a way to compute s directly.

Looking at the sample inputs and outputs:

First input: n=5, k=3, frequencies: 3 (for 4), 2 (for 1). floor(3 / 3) = 1 operation, reducing to 5 - 1 = 4 cards.

Then, frequencies: 2 (for 4), 2 (for 1). No number has at least 3 cards, so m=1, s=4.

But sample output is 2.

Wait, that doesn't match.

Wait, perhaps I need to consider that after the first operation, the frequencies change.

Wait, perhaps it's more involved.

Alternatively, perhaps the minimum number of cards left is n mod (k - 1).

Wait, for n=5, k=3, 5 mod 2 = 1, but sample output is 2.

Not matching.

Wait, perhaps it's ceil(n / (k - 1)) * (k - 1) - n.

Wait, for n=5, k=3: ceil(5 / 2) * 2 - 5 = 6 - 5 = 1.

But sample output is 2.

No.

Alternatively, perhaps it's n - floor((n - 1) / (k - 1)).

Wait, for n=5, k=3: 5 - floor(4 / 2) = 5 - 2 = 3.

Still not matching.

Wait, perhaps it's n - (k - 1) * floor(n / k).

For n=5, k=3: 5 - 2 * 1 = 3.

Not matching.

Wait, perhaps I need to consider the maximum number of groups of k - 1 cards that I can have.

Wait, I'm getting confused.

Looking back at the problem, perhaps I need to think in terms of the maximum number of cards I can remove.

Each operation removes k - (k - 1) = 1 card.

So, the maximum number of operations is the number of times I can find k cards of the same number.

This seems similar to the number of times I can divide by k, but it's not exactly the same.

Wait, perhaps it's n - the number of groups of k - 1 cards that can be formed.

Wait, perhaps it's n - (sum of ceil(fi / k) * (k - 1)).

Wait, I'm getting stuck.

Maybe I should look for a different approach.

Let me consider that each operation reduces the total number of cards by 1.

Therefore, the minimum number of cards is n - m, where m is the maximum number of operations I can perform.

To maximize m, I need to perform operations until no number has at least k cards.

This is equivalent to distributing the cards in such a way that no number has at least k cards.

So, the problem reduces to finding the minimal number of cards such that no number appears at least k times.

This is similar to the problem of finding the minimal number of cards where the maximum frequency of any number is at most k - 1.

So, the minimal number of cards s should satisfy that s <= (number of distinct numbers) * (k - 1).

But I don't know the number of distinct numbers in advance.

Wait, perhaps I can think in terms of the total number of cards and the maximum frequency.

But I'm still not sure.

Wait, perhaps the minimal number of cards s is the smallest number such that s <= (total number of distinct numbers) * (k - 1).

But without knowing the number of distinct numbers, this is tricky.

Alternatively, perhaps s is the ceiling of n over (k - 1).

Wait, for the fourth sample, n=10, k=4, ceiling(10 / 3) = 4, but sample output is 3.

Not matching.

Wait, perhaps it's floor(n / (k - 1)).

For n=10, k=4, floor(10 / 3) = 3, which matches the sample.

For n=5, k=3, floor(5 / 2) = 2, which matches the first sample.

For n=1, k=10, floor(1 / 9) = 0, but sample output is 1.

Wait, that doesn't match.

Wait, floor(1 / 9) = 0, so s = n - m = 1 - 0 = 1, which matches.

For n=7, k=2, floor(7 / 1) = 7, so s = 7 - 7 = 0, but sample output is 1.

Wait, that doesn't match.

Wait, perhaps it's ceil(n / (k - 1)).

For n=5, k=3, ceil(5 / 2) = 3, which is higher than the sample output of 2.

Not matching.

Wait, perhaps it's ceil((n - 1) / (k - 1)).

For n=5, k=3, ceil(4 / 2) = 2, which matches the sample.

For n=10, k=4, ceil(9 / 3) = 3, which matches.

For n=1, k=10, ceil(0 / 9) = 0, but sample output is 1.

Not matching.

Wait, perhaps it's max(ceil((n - 1) / (k - 1)), 1).

For n=1, k=10, it would be max(ceil(0 / 9), 1) = 1, which matches.

For n=7, k=2, ceil(6 / 1) = 6, but sample output is 1.

Not matching.

Hmm.

This approach seems flawed.

Perhaps I need to consider that when k=2, it's possible to reduce to 1 card, as shown in the sample.

Wait, perhaps if k=2, the minimal number of cards is 1, regardless of n.

But in the fifth sample, n=5, k=2, output is 5, which contradicts that.

Wait, in the fifth sample, all cards have unique numbers, so no operations can be performed, hence minimal is 5.

In the sixth sample, n=6, k=2, with pairs, minimal is 1.

In the seventh sample, n=6, k=3, no number appears at least 3 times, so minimal is 6.

So, it seems that when there are enough identical cards, I can reduce the total number of cards to k - 1.

Wait, in the fourth sample, k=4, minimal is 3.

In the first sample, k=3, minimal is 2.

In the second sample, k=10, minimal is 1.

Wait, but in the second sample, n=1, k=10, minimal is 1.

Wait, perhaps the minimal number of cards is max(n - (k - 1), 0) + (k - 1).

Wait, that doesn't make sense.

Wait, perhaps it's n % (k - 1).

For n=5, k=3, 5 % 2 = 1, but sample output is 2.

Not matching.

Wait, perhaps it's (n - 1) % (k - 1) + 1.

For n=5, k=3: (5 - 1) % 2 + 1 = 0 + 1 = 1, but sample output is 2.

No.

Wait, perhaps it's ceil((n - (k - 1)) / (k - 1)) * (k - 1).

For n=5, k=3: ceil((5 - 2) / 2) * 2 = ceil(3 / 2) * 2 = 2 * 2 = 4.

Not matching.

Wait, perhaps I need to think differently.

Looking back at the operations, each operation reduces the total number of cards by 1.

Therefore, the minimal number of cards is n - m, where m is the maximum number of operations I can perform.

To maximize m, I need to perform operations until no number has at least k cards.

This seems similar to the greedy algorithm for finding the maximum number of operations.

But I need a direct formula or an efficient way to compute m.

Wait, perhaps m is the sum of floor(fi / k) for all i, iteratively until no fi >= k.

This is similar to the greedy algorithm where in each step, I perform operations on the numbers with the highest frequencies.

But implementing this iteratively for each test case would be inefficient, especially since n can be up to 100 and t up to 500.

I need a smarter way.

Wait, perhaps I can think in terms of the total number of cards that can be reduced.

Each operation reduces n by 1, and I can perform operations as long as there's at least one number with at least k cards.

Therefore, the minimal number of cards is the smallest s such that no number in s cards has at least k cards.

In other words, s <= (number of distinct numbers) * (k - 1).

But I don't know the number of distinct numbers in advance.

Wait, perhaps I can consider that in the final distribution, no number appears more than k - 1 times.

Therefore, s is at least the ceiling of n over (k - 1).

Wait, for n=5, k=3: ceil(5 / 2) = 3, but sample output is 2.

Doesn't match.

Wait, perhaps it's floor(n / (k - 1)).

For n=5, k=3: floor(5 / 2) = 2, which matches the sample.

For n=10, k=4: floor(10 / 3) = 3, which matches the sample.

For n=1, k=10: floor(1 / 9) = 0, but sample output is 1.

Doesn't match.

Wait, perhaps it's max(floor(n / (k - 1)), 1).

For n=1, k=10: max(0, 1) = 1, which matches.

For n=7, k=2: floor(7 / 1) = 7, but sample output is 1.

Doesn't match.

Wait, perhaps it's min(n, floor(n / (k - 1)) * (k - 1)).

For n=5, k=3: min(5, floor(5 / 2) * 2) = min(5, 4) = 4, but sample output is 2.

No.

Wait, perhaps it's n - floor(n / k).

For n=5, k=3: 5 - 1 = 4, doesn't match.

Wait, perhaps it's n - (k - 1) * floor(n / k).

For n=5, k=3: 5 - 2 * 1 = 3, doesn't match.

Wait, perhaps it's n - (k - 1) * floor(n / (k - 1)).

For n=5, k=3: 5 - 2 * 2 = 1, doesn't match.

Wait, perhaps it's n - (k - 1 - 1) * floor(n / k).

Wait, this is getting too convoluted.

Maybe I need to accept that there's no simple formula and that the problem requires a different approach.

Perhaps I should consider that in each operation, I'm effectively reducing the total number of cards by 1, and I can keep doing this until no number has at least k cards.

Therefore, the minimal number of cards is n minus the sum of floor(fi / k) for all i, iteratively until no fi >= k.

But this is time-consuming for large t.

Given that n <= 100 and t <= 500, it should be manageable.

Alternatively, perhaps there's a mathematical formula that can compute this directly.

Looking back at the samples, perhaps the minimal number of cards is n - floor(n / k) * (k - 1).

Wait, for n=10, k=4: 10 - floor(10 / 4) * 3 = 10 - 7 = 3, which matches.

For n=5, k=3: 5 - floor(5 / 3) * 2 = 5 - 3 = 2, which matches.

For n=1, k=10: 1 - floor(1 / 10) * 9 = 1 - 0 = 1, which matches.

For n=7, k=2: 7 - floor(7 / 2) * 1 = 7 - 3 = 4, but sample output is 1.

Doesn't match.

Wait, perhaps I need to apply this formula iteratively.

Wait, perhaps it's n - floor(n / k) * (k - 1), but in the seventh sample, n=6, k=3: 6 - floor(6 / 3) * 2 = 6 - 4 = 2, but sample output is 6.

Doesn't match.

Wait, perhaps when floor(n / k) * (k - 1) >= n, the minimal is n - floor(n / k) * (k - 1).

Wait, for n=6, k=3: floor(6 / 3) * 2 = 4, so 6 - 4 = 2, but sample output is 6.

Doesn't match.

Wait, perhaps it's n - (floor(n / k) * (k - 1)), but with a condition that if floor(n / k) * (k - 1) > n, then minimal is n - (n // k) * (k - 1).

Wait, for n=6, k=3: 6 - 4 = 2, but sample output is 6.

Wait, perhaps only when floor(n / k) * (k - 1) <= n.

Wait, in this case, 4 <= 6, so minimal is 2, but sample output is 6.

Wait, perhaps when floor(n / k) * (k - 1) < n, minimal is n - floor(n / k) * (k - 1), else n.

Wait, for n=6, k=3: floor(6 / 3) * 2 = 4 < 6, so minimal is 6 - 4 = 2, but sample output is 6.

Doesn't match.

Wait, perhaps it's n - (floor(n / k) * (k - 1)), but with a minimum of n - m, where m is the sum of floor(fi / k) for all i.

But without knowing fi, it's tricky.

Wait, perhaps it's n - (floor(n / k) * (k - 1)), but only if n is divisible by k - 1.

Wait, for n=5, k=3: 5 - (1 * 2) = 3, but sample output is 2.

Doesn't match.

Wait, perhaps it's n - (floor((n - 1) / (k - 1)) * (k - 1)).

For n=5, k=3: 5 - (floor(4 / 2) * 2) = 5 - 4 = 1, but sample output is 2.

Doesn't match.

Wait, perhaps it's n - (floor(n / k) * (k - 1)).

For n=5, k=3: 5 - 1 * 2 = 3, doesn't match.

Wait, perhaps it's n - (floor((n - 1) / (k - 1)) * (k - 1)).

For n=5, k=3: 5 - (floor(4 / 2) * 2) = 5 - 4 = 1, doesn't match.

Wait, perhaps it's n - (floor(n / (k - 1)) * (k - 1)).

For n=5, k=3: 5 - floor(5 / 2) * 2 = 5 - 4 = 1, doesn't match.

Wait, perhaps it's n - (floor(n / k) * (k - 1)).

For n=5, k=3: 5 - 1 * 2 = 3, doesn't match.

Wait, perhaps I need to consider that in some cases, I can choose the replacement cards to help in future operations.

But this seems too vague.

Given that I'm struggling to find a direct formula, perhaps I need to accept that the minimal number of cards is n - floor(n / k) * (k - 1), but adjust for cases where no operations can be performed.

Wait, in the seventh sample, n=6, k=3, cards=[10,20,30,10,20,40].

Here, frequencies: two 10's, two 20's, one 30, one 40.

floor(6 / 3) = 2, floor(6 / 3) * 2 = 4, so n - 4 = 2, but sample output is 6.

So, in this case, since no number has at least k=3 cards, no operations can be performed, hence minimal is 6.

So, perhaps the formula needs to be adjusted to consider whether there are any numbers with at least k cards.

Wait, but in the sixth sample, n=6, k=2, cards=[10,20,30,10,20,40], frequencies: two 10's, two 20's, one 40.

Here, k=2, so I can perform operations on the two 10's and two 20's.

floor(6 / 1) = 6, but that doesn't make sense.

Wait, perhaps the formula is n - floor(n / k) * (k - 1), but only if there exists at least one number with at least k cards.

Otherwise, minimal is n.

In the seventh sample, no number has at least k=3 cards, so minimal is n=6.

In the sixth sample, numbers have at least k=2 cards, so minimal is n - floor(n / k) * (k - 1) = 6 - floor(6 / 2) * 1 = 6 - 3 = 3, but sample output is 1.

Wait, that doesn't match.

Wait, perhaps it's more complex.

Alternatively, perhaps the minimal number of cards is n - floor(n / k) * (k - 1), but adjusted to be at least the number of distinct numbers.

But in the sixth sample, number of distinct numbers is 5, but minimal is 1.

Does