Alright, I've got this problem to solve. Let's see what it's asking for. So, Petya has an array of n integers, and Vasya wants to create his own array of n integers from a larger array of m integers, where m is at least n. Vasya wants to make his array as different as possible from Petya's array, measured by the sum of absolute differences between corresponding elements.

So, the goal is to maximize the sum D = Σ |a_i - c_i|, where c is Vasya's array, made from selecting n elements from b and arranging them in some order.

First, I need to understand the constraints:

- There are multiple test cases, up to 100.

- For each test case, 1 ≤ n ≤ m ≤ 2*10^5.

- The sum of m over all test cases doesn't exceed 2*10^5.

- The elements a_i and b_i can be up to 10^9.

Given the constraints, efficiency is key. I need an algorithm that can handle up to 2*10^5 elements per test case, and up to 100 test cases, with the sum of m across all test cases being up to 2*10^5.

Let me think about how to approach this.

I need to select n elements from b and arrange them in a way that maximizes the sum of absolute differences with a.

One way to maximize the difference is to choose elements from b that are as different as possible from the corresponding elements in a.

But since Vasya can arrange the elements in any order, the mapping between a and c matters.

This sounds like a problem where I need to pair each element in a with an element in c in a way that maximizes the sum of absolute differences.

In other words, I need to find a permutation of c that maximizes Σ |a_i - c_pi|, where pi is a permutation of 0 to n-1.

I recall that for minimizing the sum of absolute differences, the optimal arrangement is to sort both arrays and pair them in order. But here, we want to maximize the sum.

So, perhaps pairing the smallest a with the largest b, or something like that.

Let me consider an example to get some intuition.

Take the first example from the input:

n=4, m=6

a = [6,1,2,4]

b = [3,5,1,7,2,3]

Sorted b: [1,2,3,3,5,7]

Now, to maximize the difference, perhaps I should pair the smallest a with the largest b, the next smallest a with the next largest b, and so on.

Let's try pairing:

a=1 with b=7: difference = 6

a=2 with b=5: difference = 3

a=4 with b=3: difference = 1

a=6 with b=3: difference = 3

Total D = 6 + 3 + 1 + 3 = 13

But in the example, the output is 16, so this isn't optimal.

Wait, maybe pairing a=6 with b=1: difference=5

a=1 with b=7: difference=6

a=2 with b=5: difference=3

a=4 with b=2: difference=2

Total D = 5 + 6 + 3 + 2 = 16, which matches the example.

So, in this case, pairing the largest a with the smallest b, and the smallest a with the largest b, and so on, seems to work.

Is this a general strategy?

Let me think about another example.

Second test case:

n=3, m=4

a = [1,1,1]

b = [1,1,1,1]

No matter how I pair them, D = 0 each time, which matches the sample output.

Third test case:

n=5, m=5

a = [1,2,3,4,5]

b = [1,2,3,4,5]

Pairing each a_i with c_i = b_j to maximize |a_i - c_i|.

If I pair a=1 with b=5: difference=4

a=2 with b=4: difference=2

a=3 with b=3: difference=0

a=4 with b=2: difference=2

a=5 with b=1: difference=4

Total D = 4 + 2 + 0 + 2 + 4 = 12, which matches the sample output.

So, it seems that pairing the smallest a with the largest b, the next smallest a with the next largest b, and so on, works in these cases.

Is this always optimal?

Let me try to think of a counterexample.

Suppose n=2, m=3

a = [1,10]

b = [2,9,100]

Sort b: [2,9,100]

Pair a=1 with b=100: difference=99

a=10 with b=9: difference=1

Total D = 100

Alternatively, pair a=1 with b=9: difference=8

a=10 with b=100: difference=90

Total D = 98, which is less than 100.

Another pairing: a=1 with b=2: difference=1

a=10 with b=100: difference=90

Total D = 91, which is less.

So, the first pairing is better.

Another test:

n=2, m=2

a = [4,1]

b = [9,6]

Sort b: [6,9]

Pair a=1 with b=9: difference=8

a=4 with b=6: difference=2

Total D = 10

Alternative pairing: a=1 with b=6: difference=5

a=4 with b=9: difference=5

Total D = 10, same as the first approach.

Seems consistent.

Another test:

n=1, m=6

a = [3]

b = [2,7,10,1,1,5]

Sort b: [1,1,2,5,7,10]

Pair a=3 with b=1: difference=2

a=3 with b=10: difference=7

So, choosing b=10 maximizes D to 7.

This seems correct.

So, the strategy is to sort b in ascending order and then pair the smallest a with the largest b, the next smallest a with the next largest b, and so on.

In other words, sort a and b, and then pair a[i] with b[m-1 - i].

Wait, but in the first example:

a = [6,1,2,4] sorted to [1,2,4,6]

b = [3,5,1,7,2,3] sorted to [1,2,3,3,5,7]

Pair a[0]=1 with b[5]=7: difference=6

a[1]=2 with b[4]=5: difference=3

a[2]=4 with b[3]=3: difference=1

a[3]=6 with b[2]=3: difference=3

Total D=6+3+1+3=13, but in the sample, it's 16.

Wait, in the sample, they chose c=(1,5,7,2):

|6-1| + |1-5| + |2-7| + |4-2| = 5 + 4 + 5 + 2 = 16.

Hmm, so my pairing gives 13, but the sample achieves 16.

So, my strategy isn't optimal.

What's different here?

In the sample, they chose c=(1,5,7,2), which isn't strictly pairing the smallest a with the largest b, etc.

Wait, perhaps I need to consider that the permutation of c doesn't have to correspond to the sorted order of a.

Wait, but a is given and we can't change its order; we just pair each a_i with some c_i.

Wait, but in my approach, I sorted a to pair with b in reverse order, but maybe I shouldn't sort a.

Let me think differently.

Maybe for each a_i, I should choose the b_j that maximizes |a_i - b_j|, but I have to choose n distinct b_j's.

But this seems similar to selecting n elements from b and assigning them to a_i to maximize the sum of differences.

This sounds like an assignment problem, where I need to maximize the sum of |a_i - c_i|.

I know that assignment problems can be solved using hungarian algorithm, but that's O(n^3), which is too slow for n=2e5.

I need a smarter approach.

Looking back at the first example, perhaps I should sort a and sort b, and then pair a_i with b_j in a way that maximizes the difference.

Wait, perhaps pairing the smallest a with the largest unchosen b, and so on.

Let me try that in the first example.

Sort a: [1,2,4,6]

Sort b: [1,2,3,3,5,7]

Pair a=1 with b=7: difference=6

Remaining a: [2,4,6], remaining b: [1,2,3,3,5]

Pair a=2 with b=5: difference=3

Remaining a: [4,6], remaining b: [1,2,3,3]

Pair a=4 with b=3: difference=1

Remaining a: [6], remaining b: [1,2,3]

Pair a=6 with b=3: difference=3

Total D=6+3+1+3=13, but sample output is 16.

So, not optimal.

In the sample, they chose c=(1,5,7,2):

Map a=6 to c=1: difference=5

a=1 to c=5: difference=4

a=2 to c=7: difference=5

a=4 to c=2: difference=2

Total D=5+4+5+2=16.

So, in this case, the mapping is a[i] to c[j], where c is a permutation of some selection from b.

It seems that sorting a and b and pairing a_i to b_j in a certain way isn't sufficient.

Maybe I need to consider matching each a_i to the b_j that maximizes |a_i - b_j|, considering the selections so far.

But that sounds like the assignment problem again, which is too slow.

Let me think about another approach.

Suppose I fix a, and sort b.

Then, for each a_i, I can find the b_j that maximizes |a_i - b_j|, but I need to choose n distinct b_j's.

Wait, maybe I can use a greedy approach: always pick the b_j that maximizes the difference with the current a_i, and mark it as used.

But this might not lead to the optimal solution, as seen in the first example.

Alternatively, perhaps I can consider the differences and select the top n differences.

But I need to ensure that each b_j is used only once.

This is getting complicated.

Let me look at the provided code and see what approach it's taking.

Looking at the code:

- It reads t test cases.

- For each test case, it reads n and m, then reads a and b.

- It sorts b.

- It initializes a max heap to store the negative of differences, along with the a_i and the index in b used.

- For each a_i, it computes the difference with b[0] and b[m-1], and pushes the larger difference into the max heap, with the index being 0 or m-1 accordingly.

- It initializes tp1 to 0 and tp2 to m-1, which seem to be pointers to the smallest and largest elements in b.

- Then, it pops elements from the max heap:

- If the stored index is outside the current tp1 and tp2 range, it computes new differences with the current tp1 or tp2, adds the difference to ans, and moves the pointer accordingly.

- If the stored index is within tp1 and tp2, it adds the stored difference to ans and moves the corresponding pointer.

Wait, this seems a bit convoluted. Let's see if I can understand it.

Essentially, it's trying to select n elements from b, arranged in a way that maximizes the sum of differences with a.

It seems to be using a heap to keep track of the best possible differences for each a_i, and then assigning the corresponding b_j while moving pointers from both ends of b.

This might be an attempt to pair the a_i's with the most distant b_j's available, updating the pointers to ensure that each b_j is used only once.

Let me try to apply this logic to the first example.

a = [6,1,2,4]

b = [1,2,3,3,5,7]

For each a_i:

a=6:

diff with b[0]=1: |6-1|=5

diff with b[5]=7: |6-7|=1

Push (-5, 6, 0)

a=1:

diff with b[0]=1: |1-1|=0

diff with b[5]=7: |1-7|=6

Push (-6, 1, 5)

a=2:

diff with b[0]=1: |2-1|=1

diff with b[5]=7: |2-7|=5

Push (-5, 2, 5)

a=4:

diff with b[0]=1: |4-1|=3

diff with b[5]=7: |4-7|=3

Push (-3, 4, 5) or (-3,4,0)

Assuming it picks the same index, say 5.

Now, tp1=0, tp2=5

Pop from heap: (-6,1,5)

Since index=5 is within tp1 and tp2, add 6 to ans, and set tp2=4.

Now, tp1=0, tp2=4

Next pop: (-5,2,5)

But index=5 is now outside tp2=4, so compute diff with tp2=4 (b[4]=5):

|2-5|=3, add 3 to ans, set tp2=3.

ans=6+3=9

Next pop: (-5,6,0)

Index=0 is within tp1=0 and tp2=3, so add 5 to ans, set tp1=1.

ans=9+5=14

Next pop: (-3,4,5)

Index=5 is outside tp2=3, so compute diff with tp1=1 (b[1]=2):

|4-2|=2, add 2 to ans, set tp1=2.

ans=14+2=16

Which matches the sample output.

Okay, so this approach seems to work for this case.

Let me see if I can generalize this logic.

Steps:

1. Sort b in ascending order.

2. For each a_i, compute the difference with the smallest and largest b_j (b[0] and b[m-1]), and store the larger difference in a max heap, along with a_i and the index used (0 or m-1).

3. Initialize two pointers, tp1=0 and tp2=m-1.

4. For each of the n a_i's:

- Pop the largest difference from the heap.

- If the stored index is outside the current tp1 and tp2 range, compute the difference with the current tp1 or tp2 (whichever is closer to giving a larger difference), add it to the answer, and move the corresponding pointer.

- If the stored index is within tp1 and tp2, add the stored difference to the answer and move the corresponding pointer.

This seems to be the logic implemented in the code.

I need to verify if this always leads to the optimal solution.

Let me try another example.

Take n=3, m=4

a = [1,1,1]

b = [1,1,1,1]

Sort b: [1,1,1,1]

For each a_i=1:

diff with b[0]=1: |1-1|=0

diff with b[3]=1: |1-1|=0

Push (-0,1,0), (-0,1,0), (-0,1,0)

tp1=0, tp2=3

Pop (-0,1,0)

Index=0 is within tp1=0 and tp2=3, add 0 to ans, set tp1=1

ans=0

Pop (-0,1,0)

Index=0 is now outside tp1=1 and tp2=3, compute diff with tp1=1 or tp2=3 (both 0), add 0 to ans, set tp1=2

ans=0

Pop (-0,1,0)

Index=0 is outside tp1=2 and tp2=3, compute diff with tp1=2 (|1-1|=0), add 0 to ans, set tp1=3

ans=0

Which matches the sample output.

Good.

Another example:

n=5, m=5

a = [1,2,3,4,5]

b = [1,2,3,4,5]

Sort b: [1,2,3,4,5]

For each a_i:

a=1: diff with b[0]=1:0, diff with b[4]=5:4 → push (-4,1,4)

a=2: diff with b[0]=1:1, diff with b[4]=5:3 → push (-3,2,4)

a=3: diff with b[0]=1:2, diff with b[4]=5:2 → push (-2,3,4)

a=4: diff with b[0]=1:3, diff with b[4]=5:1 → push (-3,4,4)

a=5: diff with b[0]=1:4, diff with b[4]=5:0 → push (-0,5,4)

tp1=0, tp2=4

Pop (-0,5,4)

Index=4 within tp1=0 and tp2=4, add 0 to ans, set tp2=3

ans=0

Pop (-3,4,4)

Index=4 is now outside tp1=0 and tp2=3, compute diff with tp2=3 (|4-4|=0), add 0 to ans, set tp2=2

ans=0

Pop (-3,2,4)

Index=4 is outside tp1=0 and tp2=2, compute diff with tp2=2 (|2-3|=1), add 1 to ans, set tp2=1

ans=1

Pop (-2,3,4)

Index=4 is outside tp1=0 and tp2=1, compute diff with tp1=0 (|3-1|=2), add 2 to ans, set tp1=1

ans=3

Pop (-4,1,4)

Index=4 is outside tp1=1 and tp2=1, compute diff with tp1=1 (|1-2|=1), add 1 to ans, set tp1=2

ans=4

But according to the sample, it should be 12.

Wait, perhaps I miscalculated.

Wait, in the sample, n=5, m=5

a=[1,2,3,4,5]

b=[1,2,3,4,5]

Output is 12.

But according to this approach, ans=4, which is different from the sample output of 12.

Wait, perhaps I made a mistake in applying the algorithm.

Let me try again.

Initialize heap with:

(-0,5,4), (-3,4,4), (-2,3,4), (-3,2,4), (-4,1,4)

tp1=0, tp2=4

Pop (-0,5,4): index=4 within tp1=0 and tp2=4, add 0 to ans, set tp2=3

ans=0

Pop (-3,4,4): index=4 is now outside tp1=0 and tp2=3, compute diff with tp2=3 (|4-4|=0), add 0 to ans, set tp2=2

ans=0

Pop (-3,2,4): index=4 is outside tp1=0 and tp2=2, compute diff with tp2=2 (|2-3|=1), add 1 to ans, set tp2=1

ans=1

Pop (-2,3,4): index=4 is outside tp1=0 and tp2=1, compute diff with tp1=0 (|3-1|=2), add 2 to ans, set tp1=1

ans=3

Pop (-4,1,4): index=4 is outside tp1=1 and tp2=1, compute diff with tp1=1 (|1-2|=1), add 1 to ans, set tp1=2

ans=4

But sample output is 12, which suggests this approach is incorrect for this case.

Wait, perhaps I need to pair a_i with b_j in a different way.

In the sample explanation, they paired a=(1,2,3,4,5) with c=(5,4,3,2,1), giving differences |1-5|=4, |2-4|=2, |3-3|=0, |4-2|=2, |5-1|=4, total 12.

But according to the algorithm, it's giving 4, which is less than 12.

So, the algorithm seems to fail in this case.

Wait, maybe I misread the algorithm.

Looking back at the code:

When popping from the heap, if the index is within tp1 and tp2, add the stored difference and move the pointer.

Otherwise, compute the difference with the current tp1 or tp2, depending on which is closer to giving a larger difference.

In this case, when popping (-4,1,4), since index=4 is outside tp1=1 and tp2=1, it should compute the difference with tp1=1 (|1-2|=1), add 1 to ans, and set tp1=2.

But perhaps it should consider the best possible difference at that step.

Maybe the algorithm isn't correctly capturing the optimal assignment.

Alternatively, perhaps there's a better way to approach this problem.

Let me consider the problem as an assignment problem where I need to maximize Σ |a_i - c_i|, with c being a permutation of n elements chosen from b.

This is equivalent to finding a maximum weight matching between a and c, where the weight is |a_i - c_j|.

The hungarian algorithm can solve this in O(n^3), but n can be up to 2e5, which is too slow.

I need a more efficient approach.

Another way to think about it is to select n elements from b and arrange them to maximize the sum of differences with a.

Given that b is sorted, perhaps I can select the largest and smallest elements from b to pair with a's elements in a strategic way.

Wait, perhaps it's similar to the problem of maximizing the sum of differences between two arrays, which can be solved by sorting one array and assigning the largest and smallest available elements from b to each a_i.

Let me look for similar problems or known algorithms.

I recall that for maximizing the sum of differences, one can sort both arrays and then assign the smallest a with the largest b, the next smallest a with the next largest b, and so on.

This seems to be the approach used in the code.

But as seen in the second example, it's not giving the correct answer.

Wait, in the second example, n=5, m=5, a=[1,2,3,4,5], b=[1,2,3,4,5], and the correct answer is 12.

Using the approach of pairing a_i with b_{m-1-i}, we get:

a=1 with b=5: diff=4

a=2 with b=4: diff=2

a=3 with b=3: diff=0

a=4 with b=2: diff=2

a=5 with b=1: diff=4

Total D=12, which matches the sample.

But in the first example, pairing a_i with b_{m-1-i} gave D=13, but the sample shows 16.

Wait, perhaps sorting a as well is necessary.

Wait, no. In the first example, sorting a would give [1,2,