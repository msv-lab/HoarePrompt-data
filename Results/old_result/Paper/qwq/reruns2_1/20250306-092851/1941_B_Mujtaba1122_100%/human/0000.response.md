Alright, I've got this problem to solve. Let's see what it's asking for. So, Rudolf has an array of integers, and he can perform a specific operation on it any number of times. The operation involves choosing an index i (which has to be between 2 and n-1, inclusive), and then decrementing a[i-1], a[i], and a[i+1] by 1, 1, and 1 respectively, but a[i] is decremented by 2. The goal is to make all elements of the array zero using these operations.

First, I need to understand what this operation does. It seems like it's a way to reduce the values in the array, particularly targeting the center element more heavily. Since a[i] is reduced by 2, and its neighbors by 1 each time, it might be a way to balance out the values in the array.

I need to figure out if it's possible to apply this operation multiple times (in any order, on any indices that satisfy the constraints) to make the entire array zero.

Let me think about the constraints. The array has at least 3 elements, and n can be up to 2*10^5, which is 200,000. There are up to 10^4 test cases, but the sum of n over all test cases doesn't exceed 2*10^5, so it's manageable.

Each element a_j is between 0 and 10^9, which is a large range, so I have to be careful with data types and potential overflows, but in Python, integers can be arbitrarily large, so that's not an issue.

Now, I need to find a way to determine whether it's possible to make all elements zero with these operations.

Let me consider small examples to get an intuition.

Take n=3, with array [1,2,1]. If I apply the operation on i=2, I get:

a[1] = 1 - 1 = 0

a[2] = 2 - 2 = 0

a[3] = 1 - 1 = 0

So, in one operation, the array becomes [0,0,0]. That's straightforward.

Another example: n=3, array [1,1,0]. If I try to apply the operation on i=2:

a[1] = 1 - 1 = 0

a[2] = 1 - 2 = -1

a[3] = 0 - 1 = -1

Now, the array is [0, -1, -1], which is not all zeros, and I can't apply any more operations because a[i-1] and a[i+1] are negative. So, in this case, it's impossible to make all elements zero.

This suggests that the operations can lead to negative values, which are invalid in this context, so I need to be careful to only apply operations when a[i-1], a[i], and a[i+1] are sufficiently large.

Wait, but according to the problem, the operation can be applied any number of times, and any index i can be used zero or more times, as long as the conditions are met.

So, I need to find a sequence of operations that leads all elements to zero without going negative at any step.

This seems similar to Gaussian elimination or solving a system of linear equations, where each operation affects multiple variables.

Alternatively, perhaps it's related to difference sequences or some kind of discrete differential operation.

Let me think differently. Suppose I model the operations.

Let’s denote the number of times operation is applied on index i as x_i.

Then, for each i from 2 to n-1, applying x_i operations on i would affect:

a[i-1] by -x_i

a[i] by -2x_i

a[i+1] by -x_i

Additionally, we can have some operations applied on other indices.

Wait, but operations are applied sequentially, and each operation affects three consecutive elements.

This seems complex to model directly.

Maybe I need to look for invariants or some properties that remain unchanged by the operations.

Let's see, what remains invariant under these operations?

Each operation decreases a[i-1], a[i], and a[i+1] by 1, 2, and 1 respectively.

So, the total sum of the array decreases by 4 each time an operation is applied.

Wait, a[i-1] -1, a[i] -2, a[i+1] -1, so total decrease is -4 per operation.

Therefore, the sum of the array modulo 4 is an invariant in some way.

Wait, no, the sum decreases by 4 each operation, so if the initial sum is S, after k operations, the sum becomes S - 4k.

To make all elements zero, the final sum is zero, so S - 4k = 0, which implies S must be divisible by 4.

So, a necessary condition is that the sum of the array is divisible by 4.

But is this sufficient?

Wait, in the first example:

n=5, array=[1,3,5,5,2]

Sum is 1+3+5+5+2=16, which is divisible by 4.

And it's possible to make all elements zero.

In the second example:

n=5, array=[2,4,4,5,1]

Sum is 2+4+4+5+1=16, which is divisible by 4, but it's impossible to make all elements zero.

Wait, according to the sample output, it's "NO" for the second case, even though the sum is divisible by 4.

So, the sum being divisible by 4 is not sufficient.

There must be another condition.

Let me look for another invariant.

Perhaps looking at the differences between consecutive elements.

Let's consider the differences between a[i+1] and a[i].

Wait, perhaps it's similar to smoothing out the array, making it more flat with each operation.

Alternatively, maybe I can think of it as reducing peaks in the array.

Each operation reduces a[i] more heavily than its neighbors, which might be a way to flatten peaks.

But I need a more concrete approach.

Let me consider the operations in reverse.

Suppose I have all elements zero, and I apply the inverse operation, which would be:

a[i-1] +=1, a[i] +=2, a[i+1] +=1, for some i.

Then, to reach all zeros, I need to apply operations that undo these increases.

But I'm not sure if that helps directly.

Let me consider the array as a system of equations.

For each position i from 2 to n-1, the operation on i affects a[i-1], a[i], a[i+1].

So, perhaps I can set up a system of equations where the variables are the number of times each operation is applied.

Let’s define x_i as the number of times operation is applied on index i (2 <= i <= n-1).

Then, for each position j from 1 to n, the final value after all operations should be zero.

For position 1: a[1] - x_2 = 0

For position 2: a[2] - 2x_2 - x_3 = 0

For position 3: a[3] - x_2 - 2x_3 - x_4 = 0

...

For position n-1: a[n-1] - x_{n-2} - 2x_{n-1} = 0

For position n: a[n] - x_{n-1} = 0

This seems like a system of linear equations with variables x_2, x_3, ..., x_{n-1}.

The goal is to find non-negative integer solutions for x_i that satisfy all these equations.

This is getting complicated, especially since n can be up to 2*10^5, and t up to 10^4.

I need a more efficient way to solve this.

Maybe there's a smarter way to approach this problem.

Let me consider the differences between consecutive elements.

Let’s define b[i] = a[i] - a[i-1] for i from 1 to n, assuming a[0] = 0.

Wait, but a[0] is not defined. Maybe I need to adjust that.

Alternatively, consider the first difference.

But I'm not sure if that helps directly.

Wait, perhaps cumulative sums or something similar.

Let me think differently.

Suppose I have the array [a1, a2, a3, a4, a5].

And I apply an operation on i=3: a2 -=1, a3 -=2, a4 -=1.

If I apply this operation x times, then a2 -=x, a3 -=2x, a4 -=x.

Similarly, if I apply operation on i=2: a1 -=1, a2 -=2, a3 -=1.

And on i=4: a3 -=1, a4 -=2, a5 -=1.

So, overall, a1 -=x2, a2 -=x2 + 2*x3, a3 -=x2 + 2*x3 + x4, and so on.

This seems like a system of equations, but it's too big to solve directly.

I need a better approach.

Let me consider the prefix sum approach.

Define s[i] = a[1] + a[2] + ... + a[i].

Then, the operation on i affects s[i-1], s[i], and s[i+1].

But I'm not sure.

Alternatively, perhaps I can think of the operations as waves propagating through the array.

But that might be too vague.

Let me look for patterns in the sample inputs.

First sample input:

n=5, a=[1,3,5,5,2]

After operation on i=4: a becomes [1,3,4,3,1]

Then operation on i=3: [1,2,2,2,1]

Then operation on i=2: [0,0,1,2,1]

Then operation on i=4: [0,0,0,0,0]

So, it's possible.

Second sample input:

n=5, a=[2,4,4,5,1]

According to the sample output, it's "NO", meaning it's impossible.

Looking at the sums:

First sample: sum=16, which is divisible by 4.

Second sample: sum=16, also divisible by 4.

So, sum being divisible by 4 is necessary but not sufficient.

There must be another condition.

Let me look at the differences between consecutive elements.

For the first sample:

Differences: 3-1=2, 5-3=2, 5-5=0, 2-5=-3

After operation on i=4: differences become 3-1=2, 5-3=2, 3-5=-2, 1-3=-2

After operation on i=3: 2-1=1, 2-2=0, 2-3=-1, 1-1=0

After operation on i=2: 0-0=0, 0-0=0, 0-0=0, 0-0=0

It's hard to see a pattern here.

Let me consider the prefix sums.

Define s[i] = a[1] + a[2] + ... + a[i]

For the first sample:

s = [1,4,9,14,16]

After operation on i=4: a becomes [1,3,4,3,1], s=[1,4,8,11,12]

After operation on i=3: [1,2,2,2,1], s=[1,3,5,7,8]

After operation on i=2: [0,0,1,2,1], s=[0,0,1,3,4]

After operation on i=4: [0,0,0,0,0], s=[0,0,0,0,0]

Not sure if that helps.

Let me consider the operation in terms of s[i].

Operation on i: s[i-1] -=1, s[i] -=2, s[i+1] -=1.

Wait, s[i] = s[i-1] + a[i]

So, after operation on i:

s[i-1] -=1

s[i] = s[i-1] + a[i] -2

s[i+1] = s[i] + a[i+1] -1

This seems complicated.

Maybe I need to find a different approach.

Let me think about the problem differently.

Suppose I have the array, and I want to make all elements zero.

Each operation reduces a[i-1], a[i], and a[i+1], with a[i] reduced by 2.

So, a[i] needs to be at least 2, and its neighbors need to be at least 1.

Wait, not necessarily, because operations can be applied multiple times.

Wait, actually, in the operation, a[i-1] and a[i+1] are reduced by 1, and a[i] by 2.

So, for the operation to be applicable, a[i-1] >=1, a[i] >=2, a[i+1] >=1.

So, in the loop, the condition is list[i] >1 and list[i-1]>0 and list[i+1]>0.

In the given code, it's:

while list[i] >1 and list[i-1]>0 and list[i+1]>0:

list[i+1] -=1*list[i-1]

list[i] -=2*list[i-1]

list[i-1] -=1*list[i-1]

This seems problematic.

Wait, 1*list[i-1] is just list[i-1], so it's subtracting list[i-1] from list[i+1] and 2*list[i-1] from list[i], and setting list[i-1] to zero.

Is this the right approach?

Let me see.

It seems like it's trying to zero out list[i-1] by repeatedly applying operations on i, subtracting list[i-1] from list[i+1] and 2*list[i-1] from list[i], and then setting list[i-1] to zero.

Then, it moves to the next i.

After this, it checks if the entire list is zero.

But in the first sample input, after processing, it should print "YES", and in the second, "NO".

But is this logic correct?

I'm not sure.

Let me try to simulate it on the first sample input.

First sample:

n=5, a=[1,3,5,5,2]

Processing i=1 (which is a[2] in 1-based indexing):

list[1]=3 >1, list[0]=1>0, list[2]=5>0:

list[2] -=1*list[0]=1, so list[2]=4

list[1] -=2*1=2, so list[1]=1

list[0] -=1*1=1, so list[0]=0

Now, list=[0,1,4,5,2]

Next i=2:

list[2]=4 >1, list[1]=1>0, list[3]=5>0:

list[3] -=1*list[1]=1, so list[3]=4

list[2] -=2*1=2, so list[2]=2

list[1] -=1*1=1, so list[1]=0

Now, list=[0,0,2,4,2]

Next i=3:

list[3]=4 >1, list[2]=2>0, list[4]=2>0:

list[4] -=1*list[2]=2, so list[4]=0

list[3] -=2*2=4, so list[3]=0

list[2] -=1*2=2, so list[2]=0

Now, list=[0,0,0,0,0]

So, it successfully made all elements zero.

Another sample where it's "NO":

n=5, a=[2,4,4,5,1]

Processing i=1:

list[1]=4 >1, list[0]=2>0, list[2]=4>0:

list[2] -=1*list[0]=2, so list[2]=2

list[1] -=2*2=4, so list[1]=0

list[0] -=1*2=2, so list[0]=0

Now, list=[0,0,2,5,1]

Next i=2:

list[2]=2 >1, list[1]=0==0, skip

Next i=3:

list[3]=5 >1, list[2]=2>0, list[4]=1>0:

list[4] -=1*list[2]=2, but list[4]=1 <2, can't subtract 2 from 1.

So, can't apply the operation.

Thus, it's "NO", which matches the sample output.

So, in this approach, for each i from 1 to n-2, it tries to zero out list[i-1] by applying operations on i as much as possible.

Then, moves to the next i.

After processing all i, it checks if the entire list is zero.

This seems to work for the sample inputs.

But is this always correct?

Let me think about another sample where it might fail.

Consider n=4, a=[1,2,1,0]

Processing i=1:

list[1]=2 >1, list[0]=1>0, list[2]=1>0:

list[2] -=1*list[0]=1, so list[2]=0

list[1] -=2*1=2, so list[1]=0

list[0] -=1*1=1, so list[0]=0

Now, list=[0,0,0,0]

So, "YES", which is correct.

Another sample: n=4, a=[1,1,0,0]

Processing i=1:

list[1]=1 ==1, which is not >1, so skip

i=2:

list[2]=0 ==0, skip

So, list remains [1,1,0,0], which is not all zero, so "NO", which is correct.

Seems correct.

But let's think about a tricky case.

n=5, a=[2,2,2,2,2]

Processing i=1:

list[1]=2 >1, list[0]=2>0, list[2]=2>0:

list[2] -=1*list[0]=2, so list[2]=0

list[1] -=2*2=4, but list[1]=2 <4, can't subtract 4 from 2.

So, can't apply the operation.

Thus, "NO", which is correct, because it's impossible to make all elements zero in this case.

Another case: n=3, a=[0,0,0], already zero, "YES".

n=3, a=[1,2,1], as in the first sample, "YES".

n=3, a=[1,1,0], as in one of my earlier examples, "NO".

Seems consistent.

Therefore, I think the given code is correct.

It processes each i from 1 to n-2, and for each i, it tries to zero out list[i-1] by applying operations on i as much as possible.

Then, moves to the next i.

After processing all i, it checks if the entire list is zero.

If yes, "YES"; else, "NO".

This seems to cover all cases correctly.

Hence, the answer is **True**.

**Final Solution**

To solve this problem, we need to determine if it is possible to reduce an array of integers to all zeros using a specific operation any number of times. The operation allows decrementing specific elements in the array in a defined manner.

## Approach

1. **Operation Definition**: The operation allows choosing an index `i` (where `2 <= i <= n-1`), and then performing the following decrements:
   - `a[i-1] -= 1`
   - `a[i] -= 2`
   - `a[i+1] -= 1`

2. **Strategy**:
   - We iterate through the array from the second element to the second-to-last element.
   - For each position `i`, we check if `a[i-1]`, `a[i]`, and `a[i+1]` are sufficient to apply the operation.
   - We repeatedly apply the operation to zero out `a[i-1]` as much as possible.
   - Finally, we check if the entire array is reduced to zero.

3. **Feasibility**:
   - By processing each element in sequence and ensuring that the necessary conditions are met, we can determine if it is possible to reduce the array to zero.

## Solution Code

```python
t = int(input())
for _ in range(t):
    n = int(input())
    l = input()
    lst = list(map(int, l.split()))
    func_2(lst, n)

def func_1(list, n):
    for i in range(n):
        if list[i] != 0:
            return False
    return True

def func_2(list, n):
    for i in range(1, n - 1):
        while list[i] > 1 and list[i - 1] > 0 and list[i + 1] > 0:
            op_count = list[i - 1]
            list[i + 1] -= op_count
            list[i] -= 2 * op_count
            list[i - 1] -= op_count
        if list[i - 1] != 0:
            print('NO')
            return
    if func_1(list, n):
        print('YES')
    else:
        print('NO')
```

## Explanation

- **func_1**: This function checks if all elements in the list are zero.
- **func_2**: This function performs the operations to reduce the array:
  - It iterates from the second element to the second-to-last element.
  - For each element, it repeatedly applies the operation as long as `a[i-1]`, `a[i]`, and `a[i+1]` are sufficient.
  - If after processing, any element is not zero, it prints 'NO'.
  - If all elements are zero, it prints 'YES'.

This approach ensures that we attempt to reduce the array to zero in a systematic way, checking the conditions at each step to ensure feasibility.