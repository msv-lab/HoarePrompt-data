Alright, I've got this problem to solve. Let's see what it's asking for. So, Nene gave me an array of integers, and I can perform a specific operation on it multiple times to maximize the sum of the array. The operation involves choosing a subarray, computing the MEX of that subarray, and then replacing the entire subarray with that MEX value. I need to do this no more than 5*10^5 times to maximize the sum of the array and output the maximum sum along with the sequence of operations I used to achieve it.

First, I need to understand what MEX is. MEX stands for "minimum excludant," which is the smallest non-negative integer not present in a given set. For example, the MEX of [0, 1, 3] is 2, because 0 and 1 are present, but 2 is missing.

So, the operation allows me to choose any subarray, compute its MEX, and then set all elements in that subarray to that MEX value. I can do this up to 5*10^5 times, but I don't have to use all of them. The goal is to maximize the sum of the array.

Given that n can be up to 18, which is relatively small, I might be able to come up with an efficient algorithm without worrying too much about time constraints.

Let me think about how to approach this. One way is to consider that each operation allows me to set a subarray to a certain value, which is the MEX of that subarray before the operation. I need to choose operations in such a way that the final sum is maximized.

I should consider that higher MEX values are better because they are larger numbers, assuming the array doesn't already contain them. For example, if I have a subarray with [0,1], its MEX is 2, which is larger than any element in the subarray. Replacing [0,1] with [2,2] increases the sum from 1 to 4, which is beneficial.

On the other hand, if I have a subarray with [0,1,2], its MEX is 3, which is even larger. So, replacing subarrays with higher MEX values can be advantageous.

But I need to be strategic about which subarrays I choose and in what order, to maximize the sum.

Perhaps I can consider starting with the smallest possible subarrays and work my way up, or maybe look for subarrays whose MEX is larger than any element in the subarray.

Wait, actually, since the MEX is always at least 0, and it's the smallest missing non-negative integer, it will be greater than or equal to the number of unique elements in the subarray.

But I need to maximize the sum, so I should aim to set as many elements as possible to the highest possible MEX values.

Let me consider that performing operations on larger subarrays might be more beneficial because they affect more elements at once.

However, perhaps a better approach is to consider the entire array as one subarray and compute its MEX, then set the entire array to that MEX value. But that might not always be the optimal, because there could be parts of the array that already have high values, and replacing them with a lower MEX value would decrease the sum.

Wait, no. The MEX is the smallest missing non-negative integer in the subarray, so if the subarray already contains all numbers from 0 to k, then the MEX would be k+1.

But in any case, replacing a subarray with its MEX value will set all elements in that subarray to the same value, which is the MEX before the operation.

I need to find a sequence of such operations that leads to the maximum possible sum.

Maybe I can model this as a graph where each possible configuration of the array is a node, and operations are edges connecting configurations. Then, I could search for the configuration with the maximum sum. But with n up to 18 and each element up to 10^7, that's infeasible.

Alternatively, perhaps I can think in terms of dynamic programming, where I keep track of the state of the array and the operations performed.

But n=18 is too large for a DP state that includes the entire array.

Wait, perhaps I can consider that the optimal solution involves performing operations on overlapping or nested subarrays in a specific way.

Let me consider some small examples to get an intuition.

Take the first example from the problem:

n=2

a=[0,1]

If I perform the operation on the entire array, MEX([0,1])=2, and set both elements to 2, resulting in [2,2], sum=4.

Alternatively, if I perform operations on individual elements:

- Operation on a[1]=0: MEX([0])=1, set a[1]=1 -> [1,1], sum=2

- Operation on a[2]=1: MEX([1])=0, set a[2]=0 -> [1,0], sum=1

- Operation on a[2]=0: MEX([0])=1, set a[2]=1 -> [1,1], sum=2

So, in this case, performing the operation on the entire array at once gives a better sum than performing operations on individual elements.

Another example:

n=3

a=[1,3,9]

If I perform the operation on the entire array, MEX([1,3,9])=0, since 0 is missing. Setting all to 0 gives [0,0,0], sum=0, which is worse than the original sum of 13.

If I perform operations on individual elements:

- Operation on a[1]=1: MEX([1])=0, set a[1]=0 -> [0,3,9], sum=12

- Operation on a[2]=3: MEX([3])=0, set a[2]=0 -> [0,0,9], sum=9

- Operation on a[3]=9: MEX([9])=0, set a[3]=0 -> [0,0,0], sum=0

That's worse again.

Alternatively, operations on different subarrays:

- Operation on a[1:2]=[1,3], MEX=0, set to [0,0], resulting in [0,0,9], sum=9

- Operation on a[2:3]=[0,9], MEX=1, set to [1,1], resulting in [0,1,1], sum=2

That's still worse than the original sum.

So, in this case, it's better to do nothing and keep the original array, sum=13.

Another example:

n=4

a=[1,100,2,1]

One possible sequence of operations:

- Operation on a[3:3]=[2], MEX=0, set to [0], resulting in [1,100,0,1]

- Operation on a[3:4]=[0,1], MEX=2, set to [2,2], resulting in [1,100,2,2], sum=105

This is better than the original sum of 1+100+2+1=104.

Another sequence:

- Operation on a[1:4]=[1,100,2,1], MEX=0, set to [0,0,0,0], sum=0

That's worse.

So, choosing smaller subarrays can be beneficial.

From these examples, it seems that choosing the right subarrays to operate on can increase the sum, but it's not always better to operate on the entire array at once.

I need to find a way to identify which subarrays to operate on and in what order to maximize the sum.

One idea is to consider that operating on a subarray can increase its elements to the MEX value, which might be higher than some of the existing values, but it also sets all elements to the same value, which could potentially decrease the sum if the subarray already contains high values.

So, perhaps I should look for subarrays where the MEX is higher than the minimum or average value in the subarray.

Alternatively, maybe I can consider operating on subarrays with missing small numbers, so their MEX is higher.

Wait, but MEX is the smallest missing non-negative integer, so subarrays that are missing 0 will have MEX=0, subarrays missing 1 will have MEX=1, and so on.

I need to think about how to maximize the sum by choosing subarrays whose MEX is higher than possible values in the subarray.

Wait, another way to look at it: since MEX is at least 0, and can be higher if smaller numbers are present, perhaps I can aim to set subarrays to higher values by choosing subarrays that have MEX higher than their current elements.

But I need a systematic way to approach this.

Let me consider that each operation allows me to set a subarray to a value that is higher than any present in the subarray, assuming I choose the subarray appropriately.

Wait, but MEX is the smallest missing number, so it's not necessarily higher than all elements in the subarray. For example, MEX of [0,1,2] is 3, which is higher than any element in the subarray, but MEX of [1,2,3] is 0, which is lower than any element.

So, in some cases, operating on a subarray can decrease its elements.

Therefore, I need to be careful to choose subarrays where the MEX is higher than the current elements, to increase the sum.

In the example [1,100,2,1], operating on [3,3] gives MEX=0, which is less than 2, so setting it to 0 decreases the sum. But in the sequence provided, it's followed by another operation that sets [3,4] to 2, which increases the sum.

So, sometimes decreasing the sum temporarily can lead to a higher sum later on.

This complicates things.

I need a strategy that considers the sequence of operations and their cumulative effect on the sum.

Perhaps I can consider that each operation can potentially increase the sum if the MEX is higher than the average value in the subarray, but I need to maximize the sum, not just increase it in one step.

Wait, maybe I can model this as a graph where each node represents the current state of the array, and edges represent possible operations. Then, I could search for the node with the maximum sum.

But with n=18 and each a_i up to 10^7, that's infeasible due to the large state space.

I need a better approach.

Let me consider that the final array will consist of some blocks of equal values, and I need to choose these blocks in such a way that the sum is maximized.

But how do I determine the optimal blocks?

Another idea: since I can perform operations any number of times (up to 5*10^5), perhaps there is a way to reach a configuration where each element is set to the highest possible value, but I need to ensure that the operations I perform allow for that.

Wait, but the MEX is determined by the current values in the subarray, so it's not straightforward to maximize each element independently.

Perhaps I need to consider the entire array as a whole and find a sequence of operations that leads to the maximum possible sum.

But this seems too vague.

Let me think differently. Suppose I fix the final array and try to see if it's achievable through a sequence of operations.

Given that each operation sets a subarray to a single value (the MEX of that subarray before the operation), the final array must satisfy certain properties.

But what properties?

Well, in the final array, each subarray that was operated on in the last operation would be set to the same value, which is the MEX of what was there before.

This seems too convoluted.

Wait, perhaps I can consider that in the final array, certain elements are set to values that are MEX of some subarrays.

But I'm not making progress this way.

Let me consider that with multiple operations, I can effectively set any subarray to any value that is the MEX of some subarray in some state.

But again, this is too vague.

Maybe I need to look for a different approach.

Let me consider that the MEX of a subarray is determined by the numbers present in it.

If a subarray contains numbers from 0 to k, but misses k+1, then MEX is k+1.

Wait, but MEX is the smallest missing non-negative integer, so it could be less than the maximum number in the subarray.

I need to think about how to maximize the sum by choosing subarrays whose MEX is as high as possible.

But how do I ensure that the MEX is high?

One way is to have subarrays that are missing small numbers.

For example, if a subarray contains only numbers starting from 1, then MEX is 0.

If a subarray contains 0 and 2, but misses 1, then MEX is 1.

So, to have a high MEX, the subarray should contain a consecutive sequence of numbers starting from 0 up to some k, and then missing k+1.

But in that case, the MEX would be k+1.

So, to maximize the MEX, I need subarrays that have a complete sequence from 0 to k, missing k+1.

But in practice, it's not straightforward to arrange that.

Alternatively, perhaps I can consider that after some operations, certain parts of the array are set to higher values.

Wait, maybe I can think in terms of levels or layers, where each operation can potentially increase the values in a subarray to a higher level.

But I need a more concrete plan.

Let me consider that the maximum possible sum is achieved when each element in the array is set to the highest possible value through a sequence of operations.

So, I need to find, for each position in the array, the highest value it can be set to via some sequence of operations.

But how do I determine that?

Perhaps I can consider that operating on a subarray can set its elements to a value that is higher than any present in the subarray, provided that the MEX is higher.

But as we've seen, sometimes operating on a subarray can set it to a lower value.

So, I need to be careful.

Wait, maybe I can consider that the final array should have each element set to the MEX of some subarray that includes that position.

But again, this is too vague.

Let me consider that the MEX of a subarray is determined by the numbers present in it, and that replacing the subarray with its MEX affects future operations.

This seems too dynamic to handle directly.

Perhaps I need to look for a different angle.

Let me consider that the problem allows me to perform up to 5*10^5 operations, which is a lot, considering n is only 18.

So, I can perform a large number of operations, which might allow me to reach a configuration where the sum is maximized.

But what is the maximum possible sum I can achieve?

Well, in theory, if I could set all elements to some high value, the sum would be high.

But I need to see what values are achievable.

Wait, perhaps I can consider that with enough operations, I can set the entire array to the MEX of some subarrays in a way that maximizes the sum.

But I need a better strategy.

Let me think recursively. Suppose I have a subarray, and I can perform operations on it and its sub-subarrays.

But this seems too vague again.

Wait, perhaps I can consider that each operation can be seen as painting a subarray with a certain color (value), and the color is determined by the MEX of the subarray before the operation.

So, I need to choose a sequence of subarrays to "paint" in a way that maximizes the sum.

This is similar to some range updating problems, but with a twist due to the MEX operation.

But I still don't have a clear path forward.

Let me consider that the MEX of a subarray is determined by the sorted unique values in the subarray.

Specifically, if I sort the unique values in the subarray and find the smallest missing non-negative integer, that's the MEX.

So, perhaps I can sort the array or consider sorted subarrays.

But I'm not sure.

Wait, perhaps I can consider that for a subarray, the MEX is the smallest non-negative integer not present in the subarray.

So, if I have a subarray with all numbers from 0 to k except some, the MEX would be the smallest missing one.

But in terms of maximizing the sum, I need to aim for higher MEX values.

Wait, perhaps I can consider that the MEX of a subarray is at least the number of unique elements in the subarray, because if all numbers from 0 to m-1 are present, MEX is m.

So, larger subarrays with more unique elements can have higher MEX values.

But I need to see how to use this.

Let me consider that performing an operation on a subarray sets it to a value that is at least the number of unique elements in that subarray.

But I need to maximize the sum, so perhaps I should aim to set as many elements as possible to high values.

Wait, maybe I can consider that the final array is composed of blocks of equal values, and I need to choose these blocks in a way that maximizes the sum.

But how do I determine the values for these blocks?

Another idea: perhaps I can iterate through possible values and see if I can set subarrays to that value using operations.

For example, can I set some subarrays to 0, some to 1, and so on, in a way that maximizes the sum.

But this seems too vague.

Wait, perhaps I can consider that the final array should have each element set to the maximum possible value that can be achieved through operations.

But how do I determine that?

Let me consider that for a given position in the array, the highest value it can be set to is the MEX of some subarray that includes that position.

But the MEX is determined before the operation, so it's not straightforward.

This is getting too tangled.

Maybe I need to look for a different approach.

Let me consider that with multiple operations, I can effectively set any subarray to any value that is the MEX of some subarray in some state.

But again, this is too vague.

Wait, perhaps I can consider that after performing operations, the array can be divided into segments, each set to a certain value, and I need to maximize the sum of these segments.

But how do I determine the values for these segments?

Another idea: perhaps I can consider that the final array will have some runs of equal values, and I need to choose these values optimally.

But I need a way to compute what values are achievable for each run.

This is still too vague.

Let me consider that with each operation, I can choose any subarray and set it to its MEX, and I can do this multiple times.

Perhaps I can think of this as repeatedly choosing subarrays and setting them to their MEX, and I need to find a sequence of such operations that maximizes the sum.

But without a clear strategy, I'm stuck.

Wait, perhaps I can consider that the MEX of a subarray is related to the minimal value that is not present in the subarray, so setting a subarray to its MEX effectively introduces that minimal missing value into the subarray.

But I need to see how to use this to maximize the sum.

Another angle: perhaps I can consider that the MEX of a subarray is the smallest non-negative integer not present in the subarray, so if I have a subarray with all numbers from 0 to k except some, the MEX would be the smallest missing one.

But again, I need to maximize the sum, so I need to aim for higher MEX values where possible.

Wait, perhaps I can consider that the MEX of a subarray is at least the number of unique elements in the subarray, since if you have m unique elements, the MEX is at least m if all elements from 0 to m-1 are present.

But I'm not sure how to use this.

Let me consider that for a subarray with k unique elements, the MEX is at least k if the subarray contains all numbers from 0 to k-1.

Otherwise, the MEX is the smallest missing number in the sequence.

So, in general, MEX is the smallest non-negative integer not present in the subarray.

Given that, perhaps I can consider that setting a subarray to its MEX introduces a new value that was not present in the subarray before.

But I need to maximize the sum, so I need to choose subarrays whose MEX is as high as possible.

So, perhaps I should aim to operate on subarrays that have high MEX values.

But how do I ensure that?

Wait, perhaps I can sort the array and see what MEX values are possible.

But sorting changes the array, which I don't want.

Wait, perhaps I can consider that the MEX of the entire array is a certain value, and operating on the entire array sets all elements to that MEX.

But as we've seen in the examples, this might not always be the best choice.

In the first example, operating on the entire array [0,1] gives MEX=2, setting both elements to 2, sum=4, which is better than operating on individual elements.

In the second example, operating on the entire array [1,3,9] gives MEX=0, setting all to 0, which is worse than the original sum of 13.

So, in that case, it's better to do nothing.

In the third example, operating on subarrays in a specific way allows achieving a higher sum.

So, I need a way to decide which subarrays to operate on and in what order.

Perhaps I can consider that operating on subarrays with higher MEX values first can lead to better sums.

But how do I determine the order?

Wait, maybe I can consider operating on smaller subarrays first to increase their MEX, and then operate on larger subarrays that include them.

But I need to formalize this.

Another idea: perhaps I can consider that each operation can be used to "fill in" missing values in the subarray, gradually increasing the MEX.

But I'm not sure.

Wait, perhaps I can consider that each operation allows me to set a subarray to a value that is higher than some of its elements, if the MEX is higher.

But again, this is too vague.

Let me consider that with multiple operations, I can effectively set the array to any configuration where each subarray is set to the MEX of some sub-subarray.

But this seems too convoluted.

Another idea: perhaps I can model this as a dynamic programming problem, where the state is the current configuration of the array, and the transitions are the operations I can perform.

But with n=18 and a large number of operations, this is infeasible.

Wait, perhaps I can consider that since n is small, I can represent the array as a bitset or something similar to optimize operations.

But I'm not sure.

Let me consider that for each position in the array, I can track the possible values it can take after a sequence of operations.

But with a large number of operations, this seems impractical.

Wait, perhaps I can consider that after performing operations, the array can be divided into segments, each set to a certain value, and I need to maximize the sum of these segments.

But how do I determine the values for these segments?

Another idea: perhaps I can consider that the final array will have each element set to the MEX of some subarray that includes that position.

But again, this is too vague.

Wait, perhaps I can consider that the MEX of a subarray is determined by the minimal missing value in that subarray, and that by performing operations, I can effectively "fill in" missing values step by step.

But I need a more concrete plan.

Let me consider that with each operation, I can choose a subarray and set it to its MEX, which can potentially introduce a new value that was not present before.

By repeating this process, I can gradually increase the values in the array.

But I need to maximize the sum, so I need to choose operations that set subarrays to as high values as possible.

But how do I ensure that?

Wait, perhaps I can consider that the MEX of a subarray is higher when the subarray contains a sequence of low numbers without gaps.

For example, [0,1,2] has MEX=3, which is higher than [0,1] which has MEX=2.

So, perhaps I should aim to operate on subarrays that have higher MEX values.

But in practice, how do I choose which subarrays to operate on?

Another idea: perhaps I can consider that operating on a subarray with a higher MEX first can allow me to set that subarray to a higher value, and then operate on larger subarrays that include it.

But I need to formalize this.

Wait, perhaps I can consider operating on the smallest possible subarrays first to set them to higher values, and then operate on larger subarrays that include them.

But I need to see if this leads to a higher sum.

Let me consider an example:

n=3

a=[0,1,2]

If I operate on a[1:1]=[0], MEX=1, set to 1 -> [1,1,2]

Then operate on a[1:2]=[1,1], MEX=0, set to 0 -> [0,0,2]

Then operate on a[1:3]=[0,0,2], MEX=1, set to 1 -> [1,1,1], sum=3

But the original sum is 0+1+2=3, which is the same.

Alternatively, if I operate on a[1:3]=[0,1,2], MEX=3, set to 3 -> [3,3,3], sum=9, which is better.

So, in this case, operating on the entire array at once gives a better sum than operating on smaller subarrays first.

Wait, but in the first example, operating on the entire array gave a better sum than operating on individual elements.

In the second example, operating on the entire array gave a worse sum than doing nothing.

So, I need to find a way to decide when to operate on the entire array and when not to.

Perhaps I need to consider the MEX of the entire array and see if setting it to that MEX increases the sum or not.

In the first example, MEX=2 and setting both elements to 2 increases the sum from 1 to 4.

In the second example, MEX=0 and setting all to 0 decreases the sum from 13 to 0.

So, in the first case, operating on the entire array is beneficial, while in the second case, it's not.

Therefore, perhaps I should consider operating on subarrays where the MEX is greater than the average or maximum value in the subarray.

But I need a more concrete strategy.

Another idea: perhaps I can consider that the optimal solution involves operating on the entire array if the MEX is greater than the current average or maximum value, and otherwise operating on smaller subarrays.

But I need to formalize this.

Wait, perhaps I can consider that the optimal solution is to operate on the entire array if the MEX is greater than the maximum value in the array, and otherwise operate on subarrays where the MEX is greater than the maximum value in those subarrays.

But I need to see if this leads to an optimal sum.

Let me consider another example:

n=4

a=[0,1,2,3]

MEX=4, set all to 4, sum=16, which is better than the original sum of 0+1+2+3=6.

So, in this case, operating on the entire array is beneficial.

Another example:

n=3

a=[0,1,3]

MEX=2, set all to 2, sum=6, which is better than the original sum of 0+1+3=4.

So, in this case, operating on the entire array is also beneficial.

Wait, but in the second example provided, a=[1,3,9], MEX=0, which is less than the minimum value, so setting all to 0 decreases the sum.

Therefore, in this case, it's better not to perform any operations.

So, perhaps the rule is: if the MEX of the entire array is greater than the average or maximum value, operate on the entire array; otherwise, don't.

But in the third example, a=[1,100,2,1], operating on the entire array sets all to MEX=0, which is worse than the original sum.

But in the provided sequence of operations, operating on a[3:3]=[2], MEX=0, set to 0 -> [1,100,0,1]

Then operate on a[3:4]=[0,1], MEX=2, set to 2 -> [1,100,2,2], sum=105, which is better than the original sum of 104.

So, in this case, performing operations on smaller subarrays leads to a better sum than operating on the entire array.

Therefore, the strategy of operating on the entire array only if its MEX is greater than the maximum value seems insufficient.

I need a better approach.

Let me consider that with multiple operations, I can perform operations on overlapping subarrays in a way that allows me to set parts of the array to higher values.

But I need to find a systematic way to do this.

Another idea: perhaps I can consider that each operation allows me to set a subarray to a value that is higher than some of its elements, and by chaining operations, I can propagate higher values across the array.

But I need to formalize this.

Wait, perhaps I can consider that the final value of each element is the MEX of some subarray that includes that position in its final state.

But this seems too vague.

Let me consider that with each operation, I can choose any subarray and set it to its MEX, and I can repeat this process multiple times.

Perhaps I can consider that after several operations, certain parts of the array can be set to higher values.

But I need a way to maximize the sum systematically.

Another idea: perhaps I can consider that the final array is composed of segments, each set to a certain value, and I need to choose these segments in a way that maximizes the sum.

But how do I determine the values for these segments?

Wait, perhaps I can consider that the final array should have each segment set to the highest possible MEX value for that segment.

But I need to see how to compute that.

Let me consider that for a given subarray, its MEX is determined by the minimal missing value in that subarray.

So, to maximize the sum, I need to maximize the MEX values for the subarrays I operate on.

But I need a way to choose which subarrays to operate on and in what order.

Another angle: perhaps I can consider that the MEX of a subarray is related to the number of unique elements in it.

Specifically, if a subarray contains all numbers from 0 to k-1, then MEX=k.

Otherwise, MEX is the smallest missing number.

So, perhaps I can aim to operate on subarrays that have all numbers from 0 to k-1 present, and then set them to k, which is higher than any element in the subarray.

But in practice, it's not always possible, especially if the subarray doesn't contain a sequence of low numbers.

Wait, perhaps I can consider that operating on subarrays with missing small numbers can lead to higher MEX values.

But I need a more concrete plan.

Let me consider that with multiple operations, I can effectively set the array to any configuration where each subarray is set to a value that is the MEX of some subarray.

But this seems too broad.

Another idea: perhaps I can consider that the final array should have each element set to the highest possible MEX value that can be achieved through operations.

But again, this is too vague.

Wait, perhaps I can consider that the final array should have each element set to the MEX of some subarray that includes that position.

But I need to see how to compute that.

Another angle: perhaps I can consider that the MEX of a subarray is determined by the minimal missing value in the subarray, and that by operating on subarrays, I can introduce higher values into the array.

But I need a systematic way to maximize the sum.

Let me consider that with each operation, I can choose a subarray and set it to its MEX, and that this operation can be used to propagate higher values across the array.

But I need to see how to sequence these operations to maximize the sum.

Another idea: perhaps I can consider that the MEX of a subarray is the smallest non-negative integer not present in the subarray, so by operating on subarrays with missing small numbers, I can set them to higher values.

But I need to see how to prioritize which subarrays to operate on.

Wait, perhaps I can consider operating on subarrays where the MEX is higher than the current elements, to increase the sum, and avoid operating on subarrays where the MEX is lower than the current elements, to prevent decreasing the sum.

But in some cases, as shown in the third example, operating on a subarray with a lower MEX can lead to a higher sum later on.

So, this approach might not always work.

Let me consider that with multiple operations, I can perform operations in a sequence that allows me to set subarrays to higher values step by step.

But I need a way to formalize this.

Another idea: perhaps I can consider that the final array should have each element set to the highest possible value that can be achieved through operations.

But I need to see how to compute that.

Wait, perhaps I can consider that for each position in the array, I can find the maximum MEX of any subarray that includes that position.

But the MEX is determined before the operation, and the operation sets the subarray to that MEX.

So, it's not directly applicable.

Another angle: perhaps I can consider that the MEX of a subarray is related to the minimal missing value in the subarray, and that by operating on subarrays with higher MEX values, I can set those subarrays to higher values.

But I need a systematic way to choose which subarrays to operate on.

Wait, perhaps I can consider that the optimal solution involves operating on subarrays in a way that maximizes the sum of MEX values used in operations.

But I need to see if that leads to the maximum possible sum.

Another idea: perhaps I can consider that the sum is maximized when the array is set to the highest possible values, which would be the MEX of some subarrays.

But I need to see how to achieve that.

Wait, perhaps I can consider that the highest possible sum is achieved when the entire array is set to the highest possible MEX value.

But in some cases, as shown in the second example, that's not the case.

Therefore, perhaps I need to consider a combination of operating on the entire array and on smaller subarrays to achieve the maximum sum.

But I need a systematic way to decide which operations to perform.

Another angle: perhaps I can consider that the MEX of a subarray is determined by the minimal missing value in the subarray, and that by operating on subarrays with higher MEX values first, I can set those subarrays to higher values, and then operate on larger subarrays that include them.

But I need to see if this leads to an optimal sum.

Wait, perhaps I can consider that the MEX of a subarray is the smallest non-negative integer not present in the subarray, and that by operating on subarrays with higher MEX values, I can introduce higher values into the array.

But I need to see how to prioritize which subarrays to operate on.

Another idea: perhaps I can consider that the MEX of a subarray is related to the number of unique elements in the subarray, and that subarrays with more unique elements have higher MEX values.

But this isn't always true, as [0,1,2] has MEX=3, while [0,1,3] has MEX=2.

So, it's not directly proportional to the number of unique elements.

Wait, perhaps I can consider that the MEX of a subarray is the smallest non-negative integer not present in the subarray, so if a subarray is missing 0, its MEX is 0; if it's missing 1 but has 0, its MEX is 1; and so on.

Therefore, to maximize the MEX of a subarray, I need to have the subarray contain a sequence of low numbers without missing any in between.

But in terms of maximizing the sum, I need to set subarrays to higher MEX values.

So, perhaps I should aim to operate on subarrays that contain a sequence of low numbers, so their MEX is higher.

But in practice, how do I choose which subarrays to operate on?

Another idea: perhaps I can consider that operating on subarrays with higher MEX values first allows me to set those subarrays to higher values, and then operate on larger subarrays that include them.

But I need to formalize this.

Wait, perhaps I can consider that the MEX of a subarray is determined by the minimal missing value in the subarray, and that by operating on subarrays with higher MEX values, I can set those subarrays to higher values, which can then influence the MEX of larger subarrays that include them.

But this seems too vague.

Let me consider that with multiple operations, I can perform operations in a sequence that allows me to set subarrays to higher and higher values step by step.

But I need a systematic way to choose the sequence of operations.

Another angle: perhaps I can consider that the final array should have each element set to the highest possible MEX value that can be achieved through operations.

But I need to see how to compute that.

Wait, perhaps I can consider that for each position in the array, the highest achievable value is the MEX of some subarray that includes that position.

But again, this is too vague.

Let me consider that with each operation, I can choose any subarray and set it to its MEX, and I can repeat this process multiple times.

Perhaps I can consider that after several operations, certain parts of the array can be set to higher values.

But I need a way to maximize the sum systematically.

Another idea: perhaps I can consider that the final array should have each segment set to the highest possible MEX value for that segment.

But I need to see how to determine that.

Wait, perhaps I can consider that the final array should have each element set to the MEX of the entire array, but only if that MEX is higher than the current elements.

But in the second example, that's not the case.

Therefore, perhaps I need to consider operating on different subarrays in a specific order to achieve higher sums.

But I need a more concrete plan.

Let me consider that with multiple operations, I can perform operations on overlapping subarrays in a way that allows me to set parts of the array to higher values.

But I need to see how to sequence these operations optimally.

Another angle: perhaps I can consider that the MEX of a subarray is determined by the minimal missing value in the subarray, and that by operating on subarrays with higher MEX values first, I can set those subarrays to higher values, which can then influence the MEX of larger subarrays that include them.

But I need to formalize this.

Wait, perhaps I can consider that operating on subarrays with higher MEX values first allows me to set those subarrays to higher values, which can then lead to higher MEX values for larger subarrays that include them.

But I need to see if this leads to an optimal sum.

Let me consider an example:

n=4

a=[0,1,2,3]

If I operate on the entire array, MEX=4, set all to 4, sum=16.

Alternatively, if I operate on a[1:3]=[0,1,2], MEX=3, set to [3,3,3], then operate on a[1:4]=[3,3,3,3], MEX=0, set to [0,0,0,0], sum=0, which is worse.

Or, operate on a[1:2]=[0,1], MEX=2, set to [2,2], then operate on a[3:4]=[2,3], MEX=0, set to [0,0], resulting in [2,2,0,0], sum=4, which is worse than operating on the entire array at once.

So, in this case, operating on the entire array at once gives the best sum.

Another example:

n=3

a=[0,1,3]

If I operate on the entire array, MEX=2, set all to 2, sum=6.

Alternatively, operate on a[1:2]=[0,1], MEX=2, set to [2,2], then operate on a[2:3]=[2,3], MEX=0, set to [0,0], resulting in [2,0,0], sum=2, which is worse than operating on the entire array at once.

So, in this case, operating on the entire array is better.

Another example:

n=4

a=[1,100,2,1]

If I operate on a[3:3]=[2], MEX=0, set to 0 -> [1,100,0,1]

Then operate on a[3:4]=[0,1], MEX=2, set to [2,2] -> [1,100,2,2], sum=105.

This is better than operating on the entire array, which would set all to MEX=0, sum=0.

So, in this case, operating on smaller subarrays leads to a better sum.

Therefore, I need a strategy that can handle both scenarios: sometimes operating on the entire array is best, and sometimes operating on smaller subarrays is better.

I need to find a way to decide which approach to take based on the array's contents.

Perhaps I can consider that if the MEX of the entire array is greater than the maximum value in the array, then operating on the entire array is beneficial; otherwise, it's not.

In the first example, MEX=2 > max=1, so operating on the entire array is beneficial.

In the second example, MEX=0 < max=9, so operating on the entire array is not beneficial.

In the third example, MEX=0 < max=100, so operating on the entire array is not beneficial.

But in the third example, operating on smaller subarrays leads to a better sum.

Therefore, perhaps I can consider that if the MEX of the entire array is greater than the maximum value in the array, operate on the entire array; otherwise, operate on smaller subarrays where the MEX is greater than the maximum value in those subarrays.

But I need to see how to apply this systematically.

Another idea: perhaps I can consider that the optimal solution involves operating on subarrays in a way that maximizes the sum of MEX values used in operations.

But I need to see if that leads to the maximum possible sum.

Wait, perhaps I can consider that the sum after all operations is equal to the sum of the MEX values used in the operations, multiplied by the length of the subarrays operated on.

But that's not accurate, because each operation sets the entire subarray to the MEX value.

So, the sum increases by (MEX - original sum of the subarray).

But I need to maximize the total sum after all operations.

This is getting too complicated.

Let me consider that with each operation, I can choose any subarray and set it to its MEX, and I can perform up to 5*10^5 operations.

Given that n is small (n <= 18), perhaps I can consider all possible sequences of operations and choose the one that leads to the maximum sum.

But with n=18 and operations up to 5*10^5, that's computationally infeasible.

Therefore, I need a smarter approach.

Let me consider that the order of operations might not matter, or that some operations are independent and can be performed in any order.

But I need to see if that's the case.

Wait, perhaps I can consider that operations are commutative, meaning that the order in which I perform operations doesn't affect the final array.

But is that true?

Let me consider an example:

n=3

a=[0,1,2]

Option 1:

- Operation on a[1:3]=[0,1,2], MEX=3, set to [3,3,3], sum=9

Option 2:

- Operation on a[1:2]=[0,1], MEX=2, set to