Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n signs of the apocalypse, and each sign occurs every a_i years. The signs have to occur sequentially, meaning that after the first sign occurs, we start waiting for the second sign in the next year after the first one, and so on.

Okay, so I need to find out in which year the nth sign will occur, given that each sign has its own periodicity.

First, I need to understand the problem with an example. Let's take the first example from the input:

6

3 2 4 5 9 18

According to the explanation, the first sign occurs in year 3. Then, starting from year 4, we wait for the second sign, which occurs every 2 years. So, the second sign would occur in year 4, since 4 is a multiple of 2. Then, starting from year 5, we wait for the third sign, which occurs every 4 years. The next multiple of 4 after 4 is 8, so the third sign occurs in year 8. Then, starting from year 9, we wait for the fourth sign, which occurs every 5 years. The next multiple of 5 after 8 is 10, so the fourth sign is in year 10. Next, starting from year 11, we wait for the fifth sign, which occurs every 9 years. The next multiple of 9 after 10 is 18, so the fifth sign is in year 18. Finally, starting from year 19, we wait for the sixth sign, which occurs every 18 years. The next multiple of 18 after 18 is 36, so the sixth sign is in year 36.

So, the answer is 36.

Another example:

5

1 2 3 4 5

First sign in year 1.

Then, starting from year 2, wait for the second sign, which occurs every 2 years. The next multiple of 2 after 1 is 2, so second sign in year 2.

Then, starting from year 3, wait for the third sign, which occurs every 3 years. The next multiple of 3 after 2 is 3, so third sign in year 3.

Then, starting from year 4, wait for the fourth sign, which occurs every 4 years. The next multiple of 4 after 3 is 4, so fourth sign in year 4.

Then, starting from year 5, wait for the fifth sign, which occurs every 5 years. The next multiple of 5 after 4 is 5, so fifth sign in year 5.

So, the answer is 5.

Another one:

5

1 1 1 1 1

Similarly, each sign occurs every 1 year, so they occur in years 1, 2, 3, 4, 5.

So, the answer is 5.

Last one:

6

50 30 711 200 503 1006

First sign in year 50.

Then, starting from year 51, wait for the second sign, which occurs every 30 years. The next multiple of 30 after 50 is 60, so second sign in year 60.

Then, starting from year 61, wait for the third sign, which occurs every 711 years. The next multiple of 711 after 60 is 711, but that's way in the future. Wait, no, I need to find the smallest year greater than 60 that is a multiple of 711. 711 is greater than 60, so the next occurrence is in year 711.

Wait, but according to the problem, the signs must occur sequentially, meaning each sign must occur after the previous one.

Wait, but in this approach, it's not considering that the signs can occur multiple times, but we need the first occurrence after the previous sign.

Wait, maybe I need to find the smallest multiple of a[i] that is greater than the year of the previous sign.

So, for the third sign, it's the smallest multiple of 711 greater than 60, which is 711.

Then, starting from year 712, wait for the fourth sign, which occurs every 200 years. The next multiple of 200 after 711 is 800.

Then, starting from year 801, wait for the fifth sign, which occurs every 503 years. The next multiple of 503 after 801 is 503 * 2 = 1006, which is greater than 801.

Finally, starting from year 1007, wait for the sixth sign, which occurs every 1006 years. The next multiple of 1006 after 1006 is 2012.

So, the answer is 2012.

Okay, now, looking at the code provided:

if __name__ == '__main__':

func_1()

def func_1():

import sys

input = sys.stdin.read

data = input().split()

index = 0

T = int(data[index])

index += 1

results = []

for _ in range(T):

n = int(data[index])

index += 1

a = list(map(int, data[index:index + n]))

index += n

last_year = a[0]

for i in range(1, n):

next_year = (last_year + 1 + a[i] - 1) // a[i] * a[i]

last_year = next_year

results.append(str(last_year))

sys.stdout.write('\n'.join(results) + '\n')

So, it's reading all input at once, splitting it into tokens, and processing each test case one by one.

For each test case, it reads n and then the array a of size n.

It initializes last_year to a[0], which is correct for the first sign.

Then, for each subsequent sign from 1 to n-1, it calculates the next_year as:

next_year = (last_year + 1 + a[i] - 1) // a[i] * a[i]

This seems like it's calculating the smallest multiple of a[i] that is greater than last_year.

Let me verify this formula.

So, to find the smallest year that is a multiple of a[i] and is greater than last_year, we can use the ceiling of (last_year + 1) divided by a[i], and then multiply back by a[i].

Yes, that's correct.

In other words:

next_year = ceil((last_year + 1) / a[i]) * a[i]

And in integer arithmetic, ceil(x/y) can be calculated as (x + y - 1) // y

So, (last_year + 1 + a[i] - 1) // a[i] * a[i] simplifies to:

(next_year) = ceil((last_year + 1) / a[i]) * a[i]

Which is exactly what we need.

So, for each sign, it correctly calculates the year when that sign occurs, based on the previous sign's year.

Finally, it collects all the results and prints them.

Looking back at the examples, this seems to match.

In the first example, a = [3,2,4,5,9,18]

last_year starts at 3.

Then:

i=1: next_year = ceil((3+1)/2)*2 = ceil(4/2)*2 = 2*2=4

i=2: ceil((4+1)/4)*4 = ceil(5/4)*4 = 2*4=8

i=3: ceil((8+1)/5)*5 = ceil(9/5)*5 = 2*5=10

i=4: ceil((10+1)/9)*9 = ceil(11/9)*9 = 2*9=18

i=5: ceil((18+1)/18)*18 = ceil(19/18)*18 = 2*18=36

Which matches the first example.

Second example:

a = [1,2,3,4,5]

last_year=1

i=1: ceil((1+1)/2)*2 = ceil(2/2)*2 = 1*2=2

i=2: ceil((2+1)/3)*3 = ceil(3/3)*3 = 1*3=3

i=3: ceil((3+1)/4)*4 = ceil(4/4)*4 = 1*4=4

i=4: ceil((4+1)/5)*5 = ceil(5/5)*5 = 1*5=5

Matches the second example.

Third example:

a = [1,1,1,1,1]

last_year=1

i=1: ceil((1+1)/1)*1 = ceil(2/1)*1 = 2*1=2

i=2: ceil((2+1)/1)*1 = ceil(3/1)*1 = 3*1=3

i=3: ceil((3+1)/1)*1 = ceil(4/1)*1 = 4*1=4

i=4: ceil((4+1)/1)*1 = ceil(5/1)*1 = 5*1=5

Matches the third example.

Fourth example:

a = [50,30,711,200,503,1006]

last_year=50

i=1: ceil((50+1)/30)*30 = ceil(51/30)*30 = 2*30=60

i=2: ceil((60+1)/711)*711 = ceil(61/711)*711 = 1*711=711

i=3: ceil((711+1)/200)*200 = ceil(712/200)*200 = 4*200=800

i=4: ceil((800+1)/503)*503 = ceil(801/503)*503 = 2*503=1006

i=5: ceil((1006+1)/1006)*1006 = ceil(1007/1006)*1006 = 2*1006=2012

Matches the fourth example.

So, the code seems correct.

It handles multiple test cases, reads the input correctly, processes each test case independently, and outputs the results in the correct format.

Edge cases:

Let's think about some edge cases.

Edge case 1:

n=1

a=[1]

Then, last_year = 1

No further signs, so the answer should be 1.

Which is correct.

Edge case 2:

n=2

a=[1,1]

last_year=1

next_year=ceil((1+1)/1)*1=2

So, answer is 2

Edge case 3:

n=2

a=[2,2]

last_year=2

next_year=ceil((2+1)/2)*2=2

Wait, but ceil(3/2)=2, so next_year=2*2=4

So, answer is 4

But according to the problem, starting from year 3, wait for the second sign, which occurs every 2 years, so next occurrence is year 4.

So, correct.

Edge case 4:

n=2

a=[2,3]

last_year=2

next_year=ceil((2+1)/3)*3=ceil(3/3)*3=1*3=3

So, answer is 3

Wait, but according to the problem, first sign in year 2, then starting from year 3, wait for the second sign which occurs every 3 years. Next multiple of 3 after 2 is 3, so yes, correct.

Another edge case:

n=3

a=[2,3,4]

last_year=2

i=1: ceil((2+1)/3)*3=ceil(3/3)*3=1*3=3

i=2: ceil((3+1)/4)*4=ceil(4/4)*4=1*4=4

So, answer is 4

Which seems correct.

Wait, first sign in year 2.

Then, starting from year 3, wait for the second sign which occurs every 3 years. Next multiple of 3 after 2 is 3, so second sign in year 3.

Then, starting from year 4, wait for the third sign which occurs every 4 years. Next multiple of 4 after 3 is 4, so third sign in year 4.

So, yes, correct.

Another edge case:

n=2

a=[5,3]

last_year=5

next_year=ceil((5+1)/3)*3=ceil(6/3)*3=2*3=6

So, answer is 6

According to the problem, first sign in year 5, then starting from year 6, wait for the second sign which occurs every 3 years. Next multiple of 3 after 5 is 6, so correct.

Seems like the code handles various cases correctly.

Performance consideration:

Given that t <= 1000 and n <= 100, and a_i <= 10^6, the code should run efficiently within time limits, as it's O(t*n), which is acceptable.

So, overall, the code seems correct.

**Final Answer**

\[\boxed{36}\]