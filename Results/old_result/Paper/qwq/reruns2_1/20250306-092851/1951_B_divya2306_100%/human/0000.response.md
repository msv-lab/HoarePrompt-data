Alright, I've got this problem to solve. Let's see what it's about. There are n cows with unique ratings, each in a specific position, and they're going to have a tournament. The tournament is a series of matches where the first match is between the cows in positions 1 and 2. Then, each subsequent match is between the winner of the previous match and the next cow in line. The cow with the higher rating always wins.

I own cow k, and I want to maximize the number of wins this cow gets. I have the option to swap my cow with another cow's position exactly once, or I can choose not to swap at all.

First, I need to understand how the tournament progresses without any swaps. Let's consider the initial setup:

- Cows are in positions 1 to n.

- Match 1: Position 1 vs Position 2.

- Match 2: Winner of Match 1 vs Position 3.

- And so on, until all cows have been included.

Since higher-rated cows always win, the tournament essentially simulates a process where the highest-rated cow among the first i cows reaches the ith match.

Now, I need to think about how swapping my cow k with another cow's position can potentially increase the number of wins.

Let's consider a few scenarios:

1. **Do nothing (no swap):**

- Simulate the tournament as is and count how many times cow k wins.

2. **Swap cow k with another cow:**

- Choose a position to swap with cow k.

- Simulate the tournament again and count the wins for cow k in this new arrangement.

I need to find the maximum number of wins cow k can achieve, either by not swapping or by swapping with one other cow.

First, I need a way to simulate the tournament and count cow k's wins in any given arrangement.

Let's think about how to simulate the tournament efficiently. Since n can be up to 10^5 and t up to 10^4, with the sum of n over all test cases up to 10^5, I need an efficient algorithm.

In each test case, n can be up to 10^5, so I need an O(n) solution per test case.

Let's consider the initial arrangement without any swaps.

In the initial arrangement, the tournament progresses as follows:

- Match 1: Position 1 vs Position 2.

- Match 2: Winner of Match 1 vs Position 3.

- ...

- Match n-1: Winner of Match n-2 vs Position n.

In each match, the higher-rated cow wins and proceeds to the next match.

I need to track when cow k participates and how many matches it wins.

But tracking this directly for each test case would be too slow if done naively.

I need a smarter way to calculate the number of wins for cow k, both in the original arrangement and in the arrangement after swapping with one other cow.

Let me think about the properties of this tournament:

- The winner of each match is the cow with the higher rating.

- Therefore, the tournament can be thought of as a sequence of challenges, where the current winner faces the next cow in line.

- The process continues until all cows have been included.

I need to find a way to determine how many matches cow k can win, potentially by swapping its position.

First, let's consider the scenario without any swaps.

In the initial arrangement, cow k is at position k.

To maximize the number of wins for cow k, I need to position it in such a way that it faces weaker cows as long as possible.

Given that higher-rated cows always win, cow k can keep winning as long as it faces cows with lower ratings.

Therefore, the number of wins cow k can achieve is equal to the number of cows with lower ratings that it faces before encountering a cow with a higher rating.

But in the tournament structure, the cows it faces depend on the path it takes through the matches.

Wait, perhaps I can model this as a tournament bracket.

Given that it's a single-elimination tournament where each match is between the current winner and the next cow in line, I can think of it as a sequence of challenges.

Let me try to simulate this process step by step.

Let's consider an example to understand better.

Take the first example from the problem:

n = 6, k = 1

a = [12, 10, 14, 11, 8, 3]

Match 1: Position 1 (12) vs Position 2 (10). 12 wins.

Match 2: Winner (12) vs Position 3 (14). 14 wins.

Match 3: Winner (14) vs Position 4 (11). 14 wins.

Match 4: Winner (14) vs Position 5 (8). 14 wins.

Match 5: Winner (14) vs Position 6 (3). 14 wins.

So, cow k (cow 1 with rating 12) only wins once.

But if we swap cow k with position 3 (rating 14):

a = [14, 10, 12, 11, 8, 3]

Match 1: 14 vs 10. 14 wins.

Match 2: 14 vs 12. 14 wins.

Match 3: 14 vs 11. 14 wins.

Match 4: 14 vs 8. 14 wins.

Match 5: 14 vs 3. 14 wins.

Cow k (original cow 1 with rating 12, now in position 3) never wins because it's not the highest-rated cow.

Wait, but in the explanation, they swapped cow k (cow 5 with rating 12) to position 3.

Wait, in the second test case:

n = 6, k = 5

a = [7, 2, 727, 10, 12, 13]

Swapping cow k (position 5, rating 12) with position 3 (rating 727):

a = [7, 2, 12, 10, 727, 13]

Match 1: 7 vs 2. 7 wins.

Match 2: 7 vs 12. 12 wins.

Match 3: 12 vs 10. 12 wins.

Match 4: 12 vs 727. 727 wins.

Match 5: 727 vs 13. 727 wins.

So, cow k (original position 5, rating 12) wins twice.

Okay, this makes sense.

So, in this scenario, by swapping cow k to an earlier position, it can participate in more matches and potentially win more before facing stronger cows.

Now, I need to generalize this.

I need to find the maximum number of wins for cow k, either in the original position or in some swapped position.

First, let's think about the number of wins cow k can achieve without any swaps.

In the original arrangement, cow k is at position k.

It will participate in matches starting from position k, facing the winner of the previous matches.

To maximize its wins, I need to see how many cows before it (in positions 1 to k-1) it can defeat.

But actually, it's not that straightforward because the winner of the previous matches might be a cow with a higher rating.

Wait, perhaps I need to find the number of cows before position k that have lower ratings than cow k.

Wait, but it's not just about the cows before it; it's about the path it takes in the tournament.

This is getting complicated.

Let me think differently.

Suppose I fix the position of cow k and see how many matches it can win.

In the tournament, cow k will keep winning as long as it faces cows with lower ratings.

The number of wins is equal to the number of cows with lower ratings that are after it in the sequence, until it faces a cow with a higher rating.

Wait, no.

Actually, in this tournament structure, cow k can only participate in matches after the previous matches have been decided.

It's more like a linked list of matches.

I need a better way to model this.

Perhaps I can think in terms of how many cows with higher ratings are before it.

Because cow k can only keep winning as long as it doesn't face a cow with a higher rating.

So, if there are m cows with higher ratings before position k, then cow k can win k-1 - m matches.

Wait, is that correct?

Let me think.

If there are m cows with higher ratings before position k, then in the matches before reaching cow k, some of these higher-rated cows might have already been eliminated.

But it's not straightforward.

Maybe I need to find the number of cows with lower ratings between position 1 and position k-1 that are weaker than cow k.

Wait, no.

Let me try to simulate the tournament step by step.

Initialize a stack or a variable to keep track of the current winner.

Start with match 1: position 1 vs position 2. The higher-rated cow wins.

Let's say position 1 wins.

Then, match 2: winner of match 1 (position 1) vs position 3.

If position 3 has a higher rating, position 3 wins and proceeds.

Otherwise, position 1 continues.

This continues until all positions have been included.

I need to see when cow k participates and how many wins it can get.

This seems too slow for n up to 10^5.

I need a smarter approach.

Let me consider that the tournament can be represented as a sequence of matches where the current winner faces the next cow.

Essentially, it's like a process where the current champion faces the next challenger.

The champion updates if the challenger has a higher rating.

So, in this process, the champion at any point is the highest-rated cow among the first i cows.

Wait, that seems promising.

Let me formalize this.

Define the champion after match i as the cow with the highest rating among the first i+1 cows.

In other words, the champion after match i is the maximum of a[1] to a[i+1].

Given that, cow k can only win matches as long as it is the champion.

So, cow k can only win matches if it is the highest-rated cow among the first k cows.

Wait, but that might not be entirely accurate because the matches are sequential, not all at once.

Wait, perhaps I need to think in terms of the maximum rating encountered so far.

Let me try to define it.

Initialize champion as the higher of position 1 and position 2.

Then, in each subsequent match, the champion becomes the higher of the current champion and the next position.

But actually, in each match, the winner is the higher-rated between the current champion and the next position.

So, the champion after match i is the maximum of a[1] to a[i+1].

But cow k is at position k.

For cow k to win matches, it needs to be higher than the champion before it.

Wait, perhaps I need to find the number of times cow k is higher than the current champion up to position k-1.

Wait, maybe I need to find the number of times a[k] is higher than the maximum of a[1] to a[k-1].

But that would only give me one win.

Wait, no.

Actually, in this tournament structure, cow k can win multiple times if it is higher than the current champion when it's its turn to play.

Wait, perhaps I need to find the number of cows before k that have lower ratings than a[k], and that a[k] is higher than the current champion.

This is getting messy.

Let me try to think differently.

Suppose I fix the position of cow k and see how many wins it can achieve in that position.

To maximize the number of wins, I should place cow k in a position where it can face as many weaker cows as possible before facing a stronger cow.

In other words, I should place cow k as early as possible, but not before any cow that is stronger than it.

Wait, that might be a way to think about it.

Let me formalize this.

Let me sort the cows in descending order of their ratings.

Then, the highest-rated cow will win all matches until it faces a cow with a higher rating, but since it's the highest, it will win all matches.

Similarly, cow k can win a certain number of matches based on its rating and the ratings of the cows before it.

Wait, perhaps I can find the number of cows with lower ratings than a[k] that are before it.

But again, it's not just about the number of lower-rated cows before it; it's about the sequence in which matches are played.

I need to find a way to calculate the number of wins for cow k in the original arrangement and in any potential swapped arrangement.

Let me consider that in the original arrangement, cow k can win a certain number of matches before it loses to a higher-rated cow.

Similarly, if I swap cow k with another position, say position p, then cow k will be at position p, and the tournament will proceed accordingly.

I need to maximize the number of wins for cow k in any of these scenarios.

I need an efficient way to calculate this.

Let me consider that the number of wins for cow k is equal to the number of cows after its position that have lower ratings than it, until it faces a cow with a higher rating.

Wait, perhaps I need to look at the next higher-rated cow after position k.

Let me think in terms of next greater element.

In programming problems, next greater element can be found using a stack in O(n) time.

Similarly, previous greater element can also be found.

Maybe I can use that here.

Let me define:

- For each cow, find the position of the next cow with a higher rating.

- Similarly, find the position of the previous cow with a higher rating.

Wait, perhaps I can find the range in which cow k is the highest-rated cow.

Within that range, cow k can win all matches against lower-rated cows.

Once it faces a higher-rated cow, it loses.

So, the number of wins is equal to the number of cows with lower ratings within its range minus one (since it's included in its own range).

Wait, I need to think carefully.

Let me try to formalize this.

Define:

- Let L be the position of the nearest cow with a higher rating to the left of position k (previous greater).

- Let R be the position of the nearest cow with a higher rating to the right of position k (next greater).

Then, cow k is the highest-rated cow in the range (L+1, R-1).

Therefore, in this range, cow k will win all matches against the cows in this range.

But in the tournament structure, the matches are sequential, not all at once.

So, perhaps this analogy isn't directly applicable.

Wait, maybe I need to find the number of cows to the right of position k that have lower ratings than a[k], before encountering a cow with a higher rating.

Similarly, to the left.

But again, the tournament structure is sequential, so it's not just about the number of lower-rated cows to the right or left.

I need to think differently.

Let me consider that the tournament can be represented as a sequence of matches where the current champion faces the next cow.

So, the champion starts as the winner between position 1 and position 2.

Then, the champion faces position 3, and so on.

I need to see when cow k gets a chance to play and how many wins it can achieve.

Wait, perhaps I can find the point where the champion's rating is higher than a[k], which would prevent cow k from winning any matches beyond that point.

But I need to think carefully.

Let me try to simulate the tournament with cow k in its original position.

Initialize a variable to keep track of the current champion.

Start with match 1: position 1 vs position 2. The higher-rated cow becomes the current champion.

Then, match 2: current champion vs position 3. The higher-rated cow becomes the new champion.

This continues until match n-1: current champion vs position n.

Cow k wins a match whenever it is the higher-rated cow in a match.

So, to count the number of wins for cow k, I need to count how many times cow k is the higher-rated cow in a match.

Given that higher-rated cows always win, cow k can only win matches when it is facing a lower-rated cow.

Moreover, once cow k faces a higher-rated cow, it loses and cannot win any more matches.

Therefore, the number of wins for cow k is equal to the number of lower-rated cows it faces before encountering a higher-rated cow.

But in the tournament structure, cow k may not get a chance to play if a higher-rated cow eliminates it before it gets a turn.

So, I need to find the path that allows cow k to participate in as many matches as possible.

This is getting quite involved.

Let me consider that the number of wins for cow k is equal to the number of cows with lower ratings that are before it in the sequence, until it faces a cow with a higher rating.

Wait, perhaps I need to find the number of cows with lower ratings that are after the current champion.

This is getting too convoluted.

Maybe I need to look for a different approach.

Let me consider that if I swap cow k with another position p, then cow k is now at position p.

Then, I need to simulate the tournament again to see how many wins it can achieve.

But simulating the tournament for each possible p is too slow, as n can be up to 10^5.

I need a smarter way to calculate this.

Perhaps I can precompute for each position, how many wins cow k would achieve if it were placed at that position.

Then, I can choose the position that maximizes the number of wins for cow k.

But again, precomputing for each position seems too slow.

Wait, maybe I can find a way to calculate the maximum number of wins in O(n) time.

Let me think about the properties of the tournament.

In the tournament, the champion at any point is the highest-rated cow among the first i cows.

So, the champion is non-decreasing as more cows are included.

Wait, actually, the champion can stay the same or increase as more cows are included.

Given that, cow k can only win matches if it is higher than the champion before it.

Wait, perhaps I can find the number of matches cow k can win by finding how many cows before it have lower ratings, and that it is higher than the current champion.

This is still confusing.

Let me try to look for patterns in the example.

Take the first example:

n = 6, k = 1

a = [12, 10, 14, 11, 8, 3]

Champion progression:

- Match 1: 12 vs 10 → 12 wins. Champion = 12.

- Match 2: 12 vs 14 → 14 wins. Champion = 14.

- Match 3: 14 vs 11 → 14 wins. Champion = 14.

- Match 4: 14 vs 8 → 14 wins. Champion = 14.

- Match 5: 14 vs 3 → 14 wins. Champion = 14.

Cow k (position 1, rating 12) only wins once, in match 1.

In the second test case:

n = 6, k = 5

a = [7, 2, 727, 10, 12, 13]

Champion progression:

- Match 1: 7 vs 2 → 7 wins. Champion = 7.

- Match 2: 7 vs 727 → 727 wins. Champion = 727.

- Match 3: 727 vs 10 → 727 wins. Champion = 727.

- Match 4: 727 vs 12 → 727 wins. Champion = 727.

- Match 5: 727 vs 13 → 727 wins. Champion = 727.

Cow k (position 5, rating 12) doesn't win any matches in this arrangement.

But in the explanation, they swapped cow k to position 3.

After swapping:

a = [7, 2, 12, 10, 727, 13]

Champion progression:

- Match 1: 7 vs 2 → 7 wins. Champion = 7.

- Match 2: 7 vs 12 → 12 wins. Champion = 12.

- Match 3: 12 vs 10 → 12 wins. Champion = 12.

- Match 4: 12 vs 727 → 727 wins. Champion = 727.

- Match 5: 727 vs 13 → 727 wins. Champion = 727.

Cow k (original position 5, rating 12, now at position 3) wins two matches.

So, by swapping, cow k can achieve more wins.

I need to find the maximum number of wins cow k can achieve, either by not swapping or by swapping with one other cow.

I need an efficient way to calculate this.

Let me consider that in order for cow k to win as many matches as possible, I need to place it as early as possible in the sequence, but not before any cow that has a higher rating than it.

Because if there is a cow with a higher rating before it, that cow will win against cow k, limiting its wins.

Therefore, the optimal position to place cow k is just after the last cow that has a higher rating than it.

In other words, find the smallest position p such that all cows before p have ratings less than or equal to a[k], and p is greater than or equal to k.

Wait, perhaps I need to find the leftmost position p where a[p] < a[k], and all positions before p have a[i] <= a[k].

Wait, I need to think carefully.

Actually, to maximize the number of wins for cow k, I should place it in a position where it can face as many cows with lower ratings as possible before facing a cow with a higher rating.

So, the optimal position is the earliest position