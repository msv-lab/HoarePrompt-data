Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find an array of integers, with at most 200 elements, such that the number of increasing subsequences in it is exactly equal to a given number X. X can be as large as 10^18, which is a really big number, so I need to think carefully about how to approach this.

First, I need to understand what an increasing subsequence is. From the problem statement, it's a sequence where elements are strictly increasing, and they maintain their relative order in the array. Also, even empty subsequences are considered increasing. That's important to note.

So, for a given array, how do I calculate the number of increasing subsequences? Well, for any array, the total number of increasing subsequences can be tricky to compute directly, especially for large arrays. But maybe there's a pattern or a mathematical formula that can help me here.

I recall that for a sequence of distinct elements, the number of increasing subsequences can be related to the number of ways to choose elements while maintaining the increasing order. But with possible duplicates in the array, it might be more complicated.

Wait, the problem allows duplicates in the array, and considers different positions as distinct subsequences even if the elements are the same. For example, in [2,2], there are two different subsequences of [2]. So, I need to make sure that my approach accounts for that.

Let me think about small examples to get a feel for the problem.

Take X = 2.

If X = 2, that means there should be exactly two increasing subsequences. What could be the smallest array that satisfies this?

Well, an array with one element has two subsequences: the empty subsequence and the element itself, which is increasing. So, [0] would have two increasing subsequences: [] and [0]. That seems to fit. So, for X=2, an array with a single element should work.

Wait, but the sample input shows X=2 with output:

1

0

So, yes, that matches my thinking.

Next, X=5.

The sample output is:

3

0 1 0

Let's verify this.

The array is [0,1,0].

Possible increasing subsequences:

- Empty subsequence

- [0] (first element)

- [0] (third element)

- [1]

- [0,1] (first and second elements)

That's five increasing subsequences. Yes, that matches.

Another sample is X=13 with an array of length 5: [2,2,3,4,2]

Let's list the increasing subsequences:

- Empty

- [2] (first)

- [2] (second)

- [3]

- [4]

- [2,3] (first and third)

- [2,4] (first and fourth)

- [2,3,4] (first, third, and fourth)

- [2] (fifth)

- [2,3] (third and fifth)

- [2,4] (third and fourth)

- [2,3,4] (third, fourth, and fifth)

- [2,4] (fourth and fifth)

Wait, that seems more than 13. Maybe I miscounted.

Wait, perhaps I need a better way to calculate the number of increasing subsequences for a given array.

Let me think differently. Maybe I can consider the structure of the array to maximize or minimize the number of increasing subsequences.

I recall that for a strictly increasing array, the number of increasing subsequences is equal to 2^n, where n is the length of the array, because every subset is an increasing subsequence.

But in this problem, the array doesn't have to be strictly increasing; it can have duplicates and variations.

Wait, but the problem allows duplicates, and considers different positions as distinct subsequences.

So, perhaps I can model the array in a way that controls the number of increasing subsequences.

Let me consider building the array in a specific pattern.

Suppose I have a sequence where each element is smaller than the next, like [1,2,3,4,...]. Then, the number of increasing subsequences is 2^n, because any subset of elements is an increasing subsequence.

But X can be up to 10^18, which is 2^60 approximated, so n could be up to 60 to reach 2^60. But the array length is limited to 200, which is more than enough.

But the problem allows duplicates, and in such cases, the number of increasing subsequences can be less than 2^n.

Wait, but if I have duplicates, as long as their positions are different, they are considered different subsequences as long as the positions are distinct.

So, perhaps I can construct the array with repeated elements to control the number of increasing subsequences.

Let me think about binary representation.

Since X can be up to 10^18, which is within 60 bits, maybe I can represent X in binary and map each bit to a position in the array.

Wait, perhaps I need to think in terms of binary decomposition.

Let me consider that each position in the array contributes to the total number of increasing subsequences in a certain way.

Suppose I build the array in such a way that each new element added contributes a specific number of new increasing subsequences.

For example, if I have an array of length n, and I add a new element that is larger than all existing elements, then the number of new increasing subsequences added is 2^n, because I can append this new element to all existing subsets.

But in this problem, I can add elements that are not necessarily larger than all existing elements, so the contribution would be different.

Wait, maybe I need to think in terms of dynamic programming, where I keep track of the number of increasing subsequences ending at each position.

But that might be too time-consuming for large X.

Let me look back at the sample inputs and see if there's a pattern.

For X=2, array=[0], number of increasing subsequences=2.

For X=5, array=[0,1,0], number of increasing subsequences=5.

For X=13, array=[2,2,3,4,2], number of increasing subsequences=13.

For X=37, array with 7 elements.

It seems like for larger X, the array length increases.

I need to find a general way to construct such arrays.

Let me consider representing X as a sum of powers of 2.

Since any number can be represented as a sum of distinct powers of 2 (binary representation), maybe I can map each power of 2 to a specific pattern in the array.

For example, 2^0 =1 (empty subsequence), 2^1=2, 2^2=4, and so on.

If I can arrange the array such that certain elements contribute specific powers of 2 to the total count, then I can select which powers to include based on the binary representation of X.

Wait, perhaps I can build the array in a way that each new element added doubles the number of increasing subsequences, plus some adjustments for duplicates.

But I need to ensure that the total number of increasing subsequences is exactly X.

This seems tricky.

Let me consider starting with an empty array, which has one subsequence: the empty subsequence.

Then, when I add the first element, it adds one more subsequence: the single element itself. So total is 2.

Then, when I add a second element, if it's larger than the first, it can form new subsequences by appending to the existing ones, doubling the number of subsequences.

Wait, more carefully:

If I have an array of length n with S increasing subsequences, and I add a new element that is larger than all existing elements, then the number of new increasing subsequences is S, because I can append the new element to each existing subsequence to form new ones.

So, the total number of increasing subsequences becomes 2*S.

But in reality, adding a new element that is larger than all existing elements increases the number of subsequences to 2*S, because for each existing subsequence, I can choose to include or exclude the new element.

Wait, but the empty subsequence remains, and including the new element with any subset still maintains the increasing order.

So, yes, adding a larger element doubles the number of increasing subsequences.

But in the sample input, for X=5, which is 101 in binary, the array is [0,1,0].

Let's see:

- Start with empty array: 1 subsequence (empty)

- Add 0: subsequences are [] and [0] -> total 2

- Add 1: since 1 > 0, new subsequences are [1] and [0,1], plus the existing ones [] and [0] -> total 4

- Add 0: new subsequences are [0] (second 0), and [0,0] is not increasing (since duplicates are allowed but [0,0] is not strictly increasing), so only [0] (second 0) is a new increasing subsequence. Total subsequences: [], [0] (first), [0] (second), [1], [0,1] -> total 5

So, in this case, adding the third element 0 only adds one new increasing subsequence, which is [0] (second 0), because [0,0] is not strictly increasing.

So, the total is 5, which matches the sample.

This suggests that by carefully choosing elements that are not larger than all existing elements, I can control the number of new increasing subsequences added.

So, perhaps I can think of building the array step by step, choosing elements such that each new element adds a specific number of new increasing subsequences.

Let me try to formalize this.

Let's say I have an array of length n with S increasing subsequences.

I want to add a new element v. I need to choose v such that the number of new increasing subsequences added is controlled.

If I choose v to be larger than k elements in the current array, then the number of new increasing subsequences will be equal to the number of increasing subsequences ending with those k elements.

Wait, perhaps I need to think in terms of how many increasing subsequences can be extended by adding v.

If v is larger than some elements in the array, then for each increasing subsequence ending with an element smaller than v, I can append v to it to form a new increasing subsequence.

So, the number of new increasing subsequences added is equal to the number of increasing subsequences whose last element is smaller than v.

Moreover, I also have the single-element subsequence [v] itself, which is always increasing.

Therefore, the total number of new increasing subsequences is equal to the number of increasing subsequences ending with elements smaller than v, plus one (for [v] itself).

This seems a bit complicated to manage for large X.

Let me consider another approach.

I know that for a strictly increasing array, the number of increasing subsequences is 2^n.

But I can have duplicates and non-strictly increasing sequences, so perhaps I can build the array in a way that groups of elements contribute specific amounts to the total count.

Wait, perhaps I can use the concept of binary representation.

Since any number X can be represented as a sum of distinct powers of 2, maybe I can design the array such that certain elements contribute specific powers of 2 to the total count of increasing subsequences.

For example, in the sample input X=5, which is 101 in binary, equal to 4 + 1.

Looking back at the array [0,1,0], the number of increasing subsequences is 5.

If I consider that adding the second 0 only adds one new subsequence ([0] itself), and the previous subsequences are [], [0], [1], [0,1], then it matches 5.

So, perhaps I can choose elements such that some of them only add one new subsequence (themselves), while others add more.

Wait, maybe I can build the array by arranging elements in a way that their contributions correspond to the binary digits of X.

But I need to think more carefully about how to do this.

Let me consider starting with an array that has a certain number of increasing subsequences, and then adding elements that contribute specific amounts.

Suppose I have an array with m elements, and I want to add a new element that contributes exactly 2^k new increasing subsequences.

How can I achieve that?

Well, if I can control the number of increasing subsequences that can be extended by adding the new element, then I can control the contribution.

But this seems too vague.

Let me try to think differently.

Suppose I build the array by repeating a pattern that allows me to double the number of increasing subsequences at certain steps, and add one at others.

Wait, perhaps I can use the fact that adding an element smaller than all existing elements only adds one new subsequence (itself), while adding an element larger than all existing elements doubles the number of increasing subsequences.

So, if I have an array with S increasing subsequences, and I add an element larger than all existing elements, the new number of increasing subsequences is 2*S.

If I add an element smaller than or equal to all existing elements, the new number of increasing subsequences is S + 1.

Wait, in the sample input X=5, which is 101 in binary.

So, 5 = 4 + 1, which corresponds to adding elements that contribute 4 and 1.

Looking at the array [0,1,0], let's see:

- Start with empty array: S=1

- Add 0: S=2 (empty and [0])

- Add 1: since 1 > 0, S=4 (empty, [0], [1], [0,1])

- Add 0: since 0 <= existing 0 and 1, S=4 +1=5 (empty, [0], [1], [0,1], [0] second 0)

So, it matches.

Similarly, for X=13, which is 1101 in binary, equal to 8 + 4 + 1.

Looking at the array [2,2,3,4,2], perhaps it follows a similar pattern.

So, maybe I can build the array by choosing elements such that each new element either:

- Doubles the number of increasing subsequences (by being larger than all existing elements), or

- Adds one to the number of increasing subsequences (by being smaller than or equal to all existing elements).

In this way, I can represent X in binary and correspond each '1' bit to adding an element that adds 2^k new subsequences.

But I need to ensure that the contributions don't overlap in a way that causes more subsequences than intended.

Wait, perhaps I can arrange the array in decreasing order, and add elements in a specific pattern.

Wait, no, if I add elements in decreasing order, each new element only adds one new subsequence (itself), because it can't be appended to any existing increasing subsequences.

On the other hand, if I add elements in increasing order, each new element doubles the number of increasing subsequences.

So, maybe I can interleave elements in a way that some elements double the number of subsequences, and others add one.

Let me try to formalize an algorithm based on this idea.

Algorithm Idea:

1. Represent X in binary.

2. For each '1' bit in the binary representation, plan to add an element that contributes 2^k subsequences.

3. To contribute 2^k, add an element larger than all previous elements, which doubles the number of subsequences.

4. To contribute 1, add an element smaller than or equal to all previous elements, which adds only one new subsequence.

5. Arrange the additions based on the positions of '1's in the binary representation of X.

But I need to make sure that the contributions don't interfere with each other.

Wait, perhaps I need to build the array in a specific order based on the binary representation of X.

Let me consider an example.

Take X=5, which is 101 in binary.

So, the '1's are at positions 0 and 2 (0-based from the right).

So, I need to add elements that contribute 2^0=1 and 2^2=4.

How can I arrange the array to achieve this?

Start with an empty array (S=1).

Add an element that contributes 1: add a smallest element, say 0. Now, S=2.

Then, add an element that contributes 4: add an element larger than all existing elements, say 1. Now, S=4.

Then, add another element that contributes 1: add an element smaller than or equal to all existing elements, say 0. Now, S=5.

So, the array is [0,1,0], which matches the sample.

Similarly, for X=13, which is 1101 in binary, positions 0, 2, and 3.

So, contributions of 2^0=1, 2^2=4, and 2^3=8.

Start with empty array (S=1).

Add element contributing 1: add 0, S=2.

Add element contributing 4: add 1, S=4.

Add element contributing 1: add 0, S=5.

Add element contributing 8: add 2, S=10.

Wait, but 10 is not 13. Maybe I need to adjust.

Wait, perhaps I need to add elements in a specific order based on the binary representation.

Alternatively, maybe I should build the array by first adding elements that contribute the higher powers of 2, and then adding elements that contribute lower powers.

Let me try that.

For X=13 (1101 in binary):

- Find the highest '1' bit, which is at position 3 (2^3=8).

- Add an element that contributes 8: add an element larger than all existing elements, say 3. Now, S=2*1 +8=10.

- Next '1' bit at position 2 (2^2=4): add an element larger than all existing elements, say 4. Now, S=2*10 +4=24.

Wait, that's not matching.

Maybe I need to adjust the contributions.

Wait, perhaps I need to ensure that when I add an element that contributes 2^k, it's added in a way that it doubles the existing subsequences up to that point.

This is getting confusing.

Let me look for another approach.

I recall that the number of increasing subsequences in an array is equal to the sum over all L (lengths of subsequences) of the number of increasing subsequences of length L.

But that might not help directly.

Another thought: since the maximum array length is 200, and X can be up to 10^18, which is about 2^60, it's feasible to build an array of length up to 60 or so to reach X.

But the problem allows up to 200 elements, which is more than enough.

So, perhaps I can iteratively build the array by choosing elements that allow me to reach the desired X.

Let me consider that each new element I add can potentially double the number of increasing subsequences, or add one, depending on its value relative to the existing elements.

So, perhaps I can represent X in binary and for each '1' bit, add an element that contributes the corresponding power of 2.

To do this, I need to control how much each new element contributes.

Here's a plan:

- Start with an empty array, which has one subsequence: the empty subsequence.

- Represent X in binary.

- For each bit position k from highest to lowest:

- If the k-th bit is set in X:

- Add an element that is larger than all existing elements if k > 0, to double the number of subsequences and add 2^k subsequences.

- If k == 0, add an element smaller than or equal to all existing elements to add one subsequence.

Wait, but in the sample X=5 (101 in binary), which is bits 0 and 2.

So, for bit 2 (k=2), I need to add an element that contributes 4 subsequences.

How can I make sure that adding one element contributes exactly 4 new subsequences?

Wait, maybe I need to think recursively.

If I have an array with S subsequences, and I add an element larger than all existing elements, the number of new subsequences is S (since I can append the new element to all existing subsequences), plus the new single-element subsequence.

So, total new subsequences: S + 1.

But in the earlier sample, adding 1 to [0] gave 4 subsequences: [], [0], [1], [0,1].

So, from S=2 to S=4.

Wait, that's doubling.

Wait, no, S + (number of subsequences that can be extended by adding the new element).

Wait, perhaps I need to think in terms of the number of increasing subsequences that can be extended by adding the new element.

If the new element is larger than m elements, then it can be appended to m subsequences to form new ones.

Plus, the new single-element subsequence.

So, total new subsequences added: m + 1.

In the sample, adding 1 to [0], m=1 (since 1 > 0), so new subsequences added: 1 +1=2 ([1], [0,1]). Total subsequences: 2 (previous) + 2 =4.

Wait, but in the earlier thought, I had S + m +1, but that seems off.

Wait, perhaps I need to think differently.

Let me denote:

- S: number of increasing subsequences before adding the new element.

- m: number of elements in the current array that are smaller than the new element.

Then, the number of new increasing subsequences added is m +1.

Wait, no, it's more like the number of increasing subsequences that can be extended by adding the new element, which is equal to the number of increasing subsequences ending with elements smaller than the new element, plus the new single-element subsequence.

In the sample, adding 1 to [0], m=1 (only 0 is smaller than 1), so new subsequences: [1] and [0,1].

So, total new subsequences added: m +1 =2, total S=4.

Similarly, adding a new element smaller than or equal to all existing elements would only add one new subsequence: itself.

So, perhaps I can control m to control the number of new subsequences added.

But m is the number of elements smaller than the new element.

Wait, but in the sample, m=1, and new subsequences added=2.

Wait, perhaps it's equal to the number of increasing subsequences ending with elements smaller than the new element.

In the sample, only [0] can be extended to [0,1], so m=1, plus [1], so total new subsequences added=2.

But in the first step, adding 0 to empty array: m=0, new subsequences added=0+1=1 ([0]), total S=2.

Then, adding 1: m=1 ([0] can be extended to [0,1]), plus [1], so new subsequences added=2, total S=4.

Then, adding 0: m=0 (no elements smaller than 0), new subsequences added=0+1=1 ([0]), total S=5.

This matches.

So, in general, when adding a new element v, the number of new increasing subsequences added is equal to the number of increasing subsequences ending with elements smaller than v, plus one (for [v] itself).

Now, to control the number of new subsequences added, I need to control m, the number of increasing subsequences ending with elements smaller than v.

But this seems tricky, because it depends on the distribution of values in the array.

Wait, perhaps I can build the array in stages, where each stage adds a specific number of new subsequences.

Let me consider that for each bit in the binary representation of X, I add an element that contributes exactly 2^k new subsequences.

To do this, I need to arrange the array so that adding a new element at each stage contributes the desired 2^k subsequences.

But how?

Wait, perhaps I can group the array into segments, where each segment contributes a specific power of 2.

For example, the first element contributes 1 (itself), the next element contributes 2, the next contributes 4, and so on.

But I need to ensure that the contributions don't overlap in a way that causes more subsequences than intended.

This is getting complicated.

Let me look for a different approach.

I recall that in binary representation, each bit represents a power of 2, and by adding elements that contribute those specific powers, I can sum up to X.

So, perhaps I can build the array in such a way that certain elements are "independent" in terms of the subsequences they generate.

Wait, maybe I can arrange the array in groups, where each group has elements that are smaller than the elements in the next group, but larger than the elements in the previous group.

For example, group 1 has elements [0], group 2 has elements [1], group 3 has elements [2], and so on.

Then, adding elements in this ordered way allows me to control the contributions.

Wait, but in the sample, they have duplicates, like [0,1,0], which complicates things.

Alternatively, perhaps I can arrange the array in a decreasing order, so that each new element only adds one new subsequence (itself), and then insert elements in increasing order to double the number of subsequences at certain points.

Wait, perhaps I can interleave increasing and decreasing elements to control the contributions.

This is getting too vague.

Let me consider the following plan:

- Start with an empty array, S=1.

- Represent X in binary.

- For each '1' bit in X, from the least significant bit to the most significant bit:

- If it's the 0th bit (contributes 1), add an element smaller than all existing elements.

- If it's the kth bit (contributes 2^k), add an element larger than all existing elements.

Wait, but in the sample X=5 (101 in binary):

- Bits 0 and 2 are set.

- So, add an element contributing 1 (smallest element), S=2.

- Then, add an element contributing 4: add an element larger than all existing elements, which should double the number of subsequences to 4.

- Then, add another element contributing 1: add an element smaller than or equal to all existing elements, S=5.

This matches the sample.

So, perhaps this is a general approach.

Algorithm:

1. Read X.

2. If X == 1, it's impossible since even an empty array has one subsequence. So, print -1.

3. Else, represent X in binary.

4. For each '1' bit in X, starting from the least significant bit:

a. If it's the 0th bit, add an element smaller than all existing elements.

b. If it's the kth bit (k > 0), add an element larger than all existing elements, which doubles the number of subsequences.

5. Output the array.

But wait, in the sample X=5, which is 101 in binary, we have bits 0 and 2 set.

So, contributions are 1 and 4.

Adding an element contributing 1: S=2.

Adding an element contributing 4: S=4.

Adding another element contributing 1: S=5.

But according to the earlier thought, adding an element larger than all existing elements doubles the number of subsequences.

Wait, in the second step, adding an element larger than all existing elements should double the number of subsequences from 2 to 4, which matches.

Then, adding another element smaller than all existing elements adds one new subsequence, making S=5.

This seems to work.

Similarly, for X=13 (1101 in binary), bits 0, 2, and 3 set.

Start with S=1.

Add element contributing 1 (bit 0): S=2.

Add element contributing 4 (bit 2): double S to 4, but we need to add 4, so maybe it's different.

Wait, perhaps my earlier thought is incorrect.

Wait, in the sample X=5, adding the second element (contributing 4) actually doubles the number of subsequences from 2 to 4.

Then, adding the third element (contributing 1) adds one more, making S=5.

Similarly, for X=13 (1101 in binary):

- Start with S=1.

- Add element contributing 1 (bit 0): S=2.

- Add element contributing 4 (bit 2): double S to 4.

- Add element contributing 8 (bit 3): double S to 8.

- Add element contributing 1 (bit 0): add 1, making S=9.

Wait, but 9 is not 13.

I must be missing something.

Wait, perhaps I need to adjust the contributions.

Let me think differently.

Suppose I have a sequence of elements where each new element is larger than all previous ones, then each new element doubles the number of increasing subsequences.

So, starting with S=1 (empty subsequence):

- Add element 0: S=2.

- Add element 1: S=4.

- Add element 2: S=8.

- Add element 3: S=16.

And so on.

But if I add an element that is smaller than or equal to all previous elements, it only adds one new subsequence: itself.

So, for X=13, which is 1101 in binary, equal to 8 + 4 + 1.

I can:

- Add element contributing 8: add an element larger than all existing elements, doubling S from 1 to 2, then to 4, then to 8.

- Add element contributing 4: add another element larger than all existing elements, doubling S from 8 to 16.

- Wait, that's more than 13.

Alternatively, perhaps I need to add elements in a specific order to get the desired contributions.

Wait, perhaps I need to add elements in a way that their contributions sum up to X, not necessarily by doubling.

But earlier, when adding an element larger than all existing elements, it doubles the number of subsequences.

Wait, maybe I need to find a way to add elements such that their contributions sum up to X, where each element's contribution is equal to the number of increasing subsequences that can be extended by adding it, plus one for itself.

From earlier, adding an element v contributes m +1 new subsequences, where m is the number of increasing subsequences ending with elements smaller than v.

This seems too vague to implement directly.

Let me consider another approach.

Suppose I build the array in a way that groups of elements contribute specific amounts to the total number of increasing subsequences.

For example, I can have a group of elements that contribute 1, another group that contributes 2, then 4, and so on, up to the highest power of 2 in X.

Then, based on the binary representation of X, I include the corresponding groups to reach the total X.

But I need to ensure that these groups don't interfere with each other in terms of forming increasing subsequences.

This might be possible by arranging the groups in increasing order, with each group having elements larger than the previous group.

For example:

- Group 1: one element, contributes 1.

- Group 2: one element larger than group 1, contributes 2.

- Group 3: one element larger than group 2, contributes 4.

- And so on.

In this way, each group's contribution is independent of the others, and I can sum their contributions to reach X.

Wait, but in the sample X=5, which is 101 in binary, equal to groups 1 and 3.

So, groups 1 and 3 would be present, and group 2 would be absent.

But in the sample array [0,1,0], it's not clearly divided into groups.

Maybe I need to adjust the values to make the groups distinct.

Let me try to formalize this.

Plan:

- Determine the binary representation of X.

- For each '1' bit in X, prepare a group of elements that contributes 2^k, where k is the bit position.

- Arrange these groups in increasing order, with each group having elements larger than the previous group.

- Construct the array by concatenating these groups.

- Adjust the groups to ensure the total number of increasing subsequences is exactly X.

But I need to verify if this works.

Take X=5 (101 in binary):

- Bit 0: contributes 1.

- Bit 2: contributes 4.

So, prepare two groups:

- Group 1: contributes 1. This can be a single element smaller than all others.

- Group 2: contributes 4. This can be two elements larger than group 1, forming a group that doubles the subsequences.

Wait, how does group 2 contribute 4?

Wait, perhaps I need to think in terms of the number of increasing subsequences added by each group.

Let me try to assign specific values.

- Group 1: element 0.

- Group 2: elements 1 and 2.

Then, the array would be [0,1,2].

Number of increasing subsequences:

- Empty: []

- Single elements: [0], [1], [2]

- Pairs: [0,1], [0,2], [1,2]

- Triple: [0,1,2]

Total: 1 + 3 + 3 + 1 = 8, which is 2^3, not 5.

So, that doesn't match.

Alternatively, perhaps I need to have group 2 contribute only what's needed.

Wait, maybe I need to have group 2 contribute 4 subsequences, and group 1 contribute 1.

So, total X=5.

How can I arrange that?

Let me try:

- Group 1: element 0, contributes 1 subsequence: [0]

- Group 2: element 1, contributes 2 subsequences: [1], [0,1]

- Group 3: element 2, contributes 4 subsequences: [2], [0,2], [1,2], [0,1,2]

But total would be 1 (group 1) + 2 (group 2) + 4 (group 3) = 7, which is not 5.

So, perhaps I need to exclude some groups.

Wait, maybe I need to include only specific groups based on the '1' bits in X.

But this is getting too convoluted.

Let me consider a different strategy.

I recall that in binary representation, each '1' bit can be treated independently, and their contributions sum up.

Similarly, perhaps I can build the array in a way that each '1' bit corresponds to a specific contribution to the total number of increasing subsequences.

To achieve this, I can arrange the array in such a way that certain elements are "isolated" and only contribute their own subsequence, while others are part of increasing sequences that double the count.

Wait, perhaps I can use the concept of binary numbers to arrange the array.

For example, assign each '1' bit to a specific element in the array, and arrange their values so that their contributions sum up to X.

But I need a more concrete plan.

Let me try to implement the earlier idea of adding elements that either double the number of subsequences or add one, based on the '1' bits in X.

Algorithm:

1. Read X.

2. If X == 1, impossible, print -1.

3. Else, represent X in binary.

4. Initialize an empty array.

5. For each '1' bit in X, starting from the least significant bit:

a. If it's the 0th bit, add an element smaller than all existing elements.

b. If it's the kth bit (k > 0), add an element larger than all existing elements.

6. Output the array.

Let's test this with X=5 (101 in binary):

- Bits 0 and 2 are set.

- Add element contributing 1 (bit 0): add smallest element, say 0. S=2.

- Add element contributing 4 (bit 2): add largest element so far, say 1. S=4.

- Add element contributing 1 (bit 0): add smallest element, say 0. S=5.

So, array is [0,1,0], which matches the sample.

Similarly, for X=13 (1101 in binary):

- Bits 0, 2, and 3 are set.

- Add element contributing 1 (bit 0): add 0. S=2.

- Add element contributing 4 (bit 2): add 1. S=4.

- Add element contributing 8 (bit 3): add 2. S=8.

- Add element contributing 1 (bit 0): add 0. S=9.

Wait, but 9 !=13. So, this approach is flawed.

Wait, perhaps I need to adjust how I handle the contributions.

Let me think again.

If I add an element larger than all existing elements, it doubles the number of increasing subsequences.

If I add an element smaller than or equal to all existing elements, it adds one new subsequence.

So, for X=13, which is 1101 in binary:

- Start with S=1.

- Add element contributing 1 (bit 0): S=2.

- Add element contributing 4 (bit 2): double S to 4.

- Add element contributing 8 (bit 3): double S to 8.

- Add element contributing 1 (bit 0): S=9.

This doesn't reach 13.

So, perhaps I need to adjust the order or the way I handle the contributions.

Wait, maybe I need to add elements in a specific order to get the desired sum.

Alternative approach:

- Represent X-1 in binary, since the empty subsequence is always present.

- Build the array to have exactly X-1 non-empty increasing subsequences.

But I'm not sure if that helps directly.

Let me consider that the total number of increasing subsequences is S, including the empty one.

So, S = X.

I need to build an array such that the number of increasing subsequences is X.

Given that, and the way adding elements affects S, perhaps I can use a greedy approach.

Greedy Approach:

- Start with an empty array, S=1.

- While S < X:

- If S * 2 <= X, add an element larger than all existing elements, doubling S.

- Else, add an element smaller than or equal to all existing elements, increasing S by 1.

This seems promising.

Let's test it with X=5.

- Start with S=1.

- 1 * 2 =2 <=5, add largest element, S=2.

- 2 * 2 =4 <=5, add largest element, S=4.

- 4 * 2 =8 >5, add smallest element, S=5.

So, total steps: add two largest elements and one smallest element, totaling 3 elements, matching the sample.

Similarly, for X=13:

- S=1.

- 1*2=2<=13, add largest, S=2.

- 2*2=4<=13, add largest, S=4.

- 4*2=8<=13, add largest, S=8.

- 8*2=16>13, add smallest, S=9.

- 9*2=18>13, add smallest, S=10.

- 10*2=20>13, add smallest, S=11.

- 11*2=22>13, add smallest, S=12.

- 12*2=24>13, add smallest, S=13.

Total elements: 8.

But in the sample, for X=13, the array has 5 elements.

So, my greedy approach gives more elements than necessary.

Wait, perhaps the greedy approach isn't optimal, or perhaps there's a better way to minimize the array length.

Let me see.

In the sample for X=13, they have an array of 5 elements, but my greedy approach gives an array of 8 elements.

So, maybe I need a smarter way to minimize the array length.

Wait, perhaps instead of always adding the smallest element when doubling is not possible, I can add elements that contribute specific amounts.

But this is getting too complicated.

Let me look for a different strategy.

I recall that in binary representation, each '1' bit can be associated with a specific power of 2, and by adding elements that contribute those specific amounts, I can sum up to X.

So, perhaps I can arrange the array in such a way that certain elements contribute exactly 2^k subsequences.

To do this, I can have groups of elements where each group corresponds to a '1' bit in X.

Within each group, the elements are arranged to contribute the desired 2^k subsequences.

But I need to ensure that the contributions don't overlap incorrectly.

Wait, perhaps I can use the concept of binary trees or something similar to structure the array.

This is getting too abstract.

Let me consider that for each '1' bit in X, I need to add elements that contribute the corresponding 2^k subsequences.

To achieve this, perhaps I can have a sequence of elements that are increasing in steps, allowing me to control the contributions.

For example, for X=13 (1101 in binary), which is 2^3 + 2^2 + 2^0 =8 +4 +1.

I can have elements arranged such that:

- Adding an element that contributes 8: perhaps a group of 3 increasing elements, which would have 2^3=8 subsequences.

- Adding an element that contributes 4: a group of 2 increasing elements, which has 2^2=4 subsequences.

- Adding an element that contributes 1: a single element.

But then, how do I combine these groups without interfering with each other?

Perhaps by arranging the groups in a way that elements in one group are incomparable to elements in other groups.

Wait, but in an array, elements have a specific order, so it's hard to make elements incomparable.

Alternatively, perhaps I can arrange the groups in a strictly increasing order, so that elements from different groups are comparable.

But then, the contributions might not add up correctly.

This is tricky.

Let me consider that if I have disjoint groups of elements, each group being strictly increasing, and arranged such that all elements in one group are smaller than all elements in the next group, then the total number of increasing subsequences would be the product of the number of increasing subsequences in each group.

Wait, is that true?

Suppose I have two groups: group A with elements a1<a2<...<am, and group B with elements b1<b2<...<bn, and a_m < b1.

Then, any increasing subsequence can be formed by choosing a subsequence from A and a subsequence from B, and concatenating them.

So, the total number of increasing subsequences would be (number of increasing subsequences in A) * (number of increasing subsequences in B).

Because for each subsequence in A and each subsequence in B, their concatenation forms a valid increasing subsequence.

Also, including the empty subsequences.

So, if group A has S_A subsequences and group B has S_B subsequences, then the total is S_A * S_B.

This is interesting.

So, if I can divide X into a product of factors, each corresponding to a group of increasing elements, then I can build the array as a concatenation of these groups.

But X can be up to 10^18, which is a large number, and factoring it might not be efficient.

Moreover, the maximum array length is 200, so I need to keep the total number of elements within that limit.

Wait, perhaps I can represent X as