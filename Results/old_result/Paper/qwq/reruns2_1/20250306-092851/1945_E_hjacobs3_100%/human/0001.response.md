Alright, I have this problem to solve. Let's read it carefully.

We have a permutation p of size n, and a number x that we need to find. A permutation is just a rearrangement of numbers from 1 to n, with no duplicates.

Now, Anton wants to use binary search on this permutation, but binary search requires the array to be sorted. So, he's going to perform at most two swap operations on the permutation to make it sorted or at least make the binary search find the correct element.

The binary search algorithm is described, and it's a standard binary search that finds the first position where p_m <= x.

The goal is to rearrange the permutation before running the binary search so that after the search, p_l equals x.

It's guaranteed that two operations are always sufficient.

Input:

- t test cases

- For each test case:

- n and x

- Permutation p of size n

Output:

- For each test case:

- k (number of operations, 0 <= k <= 2)

- Then k pairs of indices that were swapped

Note that we don't need to minimize k; any k between 0 and 2 is acceptable as long as it achieves the goal.

Example is provided, and I should make sure my solution matches that.

Now, let's think about how binary search works. Binary search works on sorted arrays by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty.

In this problem, the array is a permutation, which means it's not necessarily sorted. We can perform at most two swaps to make the binary search find the correct element.

Given that n can be up to 2*10^5 and t up to 2*10^4, but the total sum of n across all test cases is up to 2*10^5, we need an efficient solution, preferably O(n) per test case.

First, let's understand what the binary search is doing. It's trying to find the first position where p_m <= x.

Given that the array is not sorted, we need to make sure that after at most two swaps, the binary search will land on the correct position where p_l = x.

Wait, but the binary search is using the mid-point calculation based on l and r, and updating l and r based on whether p_m <= x.

At the end, when r - l = 1, the loop ends, and we expect p_l to be equal to x.

But in a permutation, all elements are unique, so there's only one position where p_i = x.

So, our goal is to adjust the array with at most two swaps so that after the binary search, p_l is x.

It's guaranteed that two operations are sufficient, so we don't have to worry about cases where it's impossible.

Let me think about how to approach this.

Option 1: Make the array sorted, then the binary search will work correctly.

But sorting the entire array would require more than two swaps in general, except maybe for small n.

But the problem allows up to two swaps, not insisting on sorting the entire array.

Option 2: Identify where x is currently located in the array, and where it should be after the binary search.

Then, swap x to the correct position, and if necessary, perform another swap to maintain the array's state for the binary search.

But this seems vague. Let's think more concretely.

Let me simulate the binary search on the given array and see where it ends up.

If the final l points to x, then we're done with 0 swaps.

If not, we need to perform swaps to make it so.

Let's consider the binary search process.

Initialize l = 0, r = n.

While r - l > 1:

m = floor((l + r) / 2)

if p_m <= x:

l = m

else:

r = m

After the loop, check if p_l == x.

If yes, great.

If not, we need to adjust the array.

But since the array is a permutation, all elements are unique.

So, the position where p_l is not x, but some other element y.

We need to move x to this position, i.e., swap x with y.

But wait, there might be cases where just one swap is not enough, hence we're allowed up to two swaps.

Wait, but according to the problem, it's shown that two operations are always sufficient.

So, perhaps there's a way to always achieve the goal with at most two swaps.

Let me think about an example.

Take n=6, x=3, p=[1,2,3,4,5,6]

Binary search:

l=0, r=6

m=3, p[3]=4 >3, so r=3

m=1, p[1]=2 <=3, l=1

m=2, p[2]=3 <=3, l=2

m=2, p[2]=3 <=3, l=2

r - l =1, stop.

p_l = p[2]=3 ==x=3. So, 0 swaps needed.

Another example: n=6, x=5, p=[3,1,6,5,2,4]

Binary search:

l=0, r=6

m=3, p[3]=5 <=5, l=3

m=4, p[4]=2 <=5, l=4

m=5, p[5]=4 <=5, l=5

m=5, p[5]=4 <=5, l=5

r - l =1, stop.

p_l = p[5]=4 !=5.

So, need to perform swaps.

We need to make p_l =5.

Currently, p[5]=4, and x=5 is at p[4]=5.

So, we can swap p[4] and p[5], so that p[5]=5.

Then, binary search would find p[5]=5 ==x=5.

So, one swap: swap 4 and 5.

Which matches the sample output.

Another example: n=5, x=1, p=[3,5,4,2,1]

Binary search:

l=0, r=5

m=2, p[2]=4 >1, r=2

m=1, p[1]=5 >1, r=1

m=0, p[0]=3 >1, r=0

l=0

p_l = p[0]=3 !=1.

Need to make p[0]=1.

Currently, 1 is at p[4]=1.

So, swap p[0] and p[4].

Then, p=[1,5,4,2,3]

Binary search:

l=0, r=5

m=2, p[2]=4 >1, r=2

m=1, p[1]=5 >1, r=1

m=0, p[0]=1 <=1, l=0

m=0, p[0]=1 <=1, l=0

r - l =1, stop.

p_l = p[0]=1 ==x=1.

So, one swap: swap 1 and 5.

Another example: n=6, x=3, p=[4,3,1,5,2,6]

Binary search:

l=0, r=6

m=3, p[3]=5 >3, r=3

m=1, p[1]=3 <=3, l=1

m=2, p[2]=1 <=3, l=2

m=2, p[2]=1 <=3, l=2

r - l =1, stop.

p_l = p[2]=1 !=3.

Need to make p[2]=3.

Currently, p[1]=3.

So, swap p[1] and p[2].

Then, p=[4,1,3,5,2,6]

Binary search:

l=0, r=6

m=3, p[3]=5 >3, r=3

m=1, p[1]=1 <=3, l=1

m=2, p[2]=3 <=3, l=2

m=2, p[2]=3 <=3, l=2

r - l =1, stop.

p_l = p[2]=3 ==x=3.

So, one swap: swap 2 and 3.

Another example: n=3, x=2, p=[3,2,1]

Binary search:

l=0, r=3

m=1, p[1]=2 <=2, l=1

m=2, p[2]=1 <=2, l=2

m=2, p[2]=1 <=2, l=2

r - l =1, stop.

p_l = p[2]=1 !=2.

Need to make p[2]=2.

Currently, p[1]=2.

So, swap p[1] and p[2].

Then, p=[3,1,2]

Binary search:

l=0, r=3

m=1, p[1]=1 <=2, l=1

m=2, p[2]=2 <=2, l=2

m=2, p[2]=2 <=2, l=2

r - l =1, stop.

p_l = p[2]=2 ==x=2.

So, one swap: swap 2 and 3.

From these examples, it seems that one swap is often sufficient.

But the problem allows up to two swaps.

So, the strategy seems to be:

- Perform the binary search on the current array to find the final l.

- If p_l == x, we're done (0 swaps).

- If not, find the current position of x in the array.

- Swap the element at position l with the element at the position where x is currently located.

- This should make p_l = x.

- In the above examples, this approach worked with one swap.

But let's think about whether there could be cases where one swap is not enough.

Suppose we have:

n=4, x=3, p=[1,4,2,3]

Binary search:

l=0, r=4

m=2, p[2]=2 <=3, l=2

m=3, p[3]=3 <=3, l=3

m=3, p[3]=3 <=3, l=3

r - l =1, stop.

p_l = p[3]=3 ==x=3. So, 0 swaps needed.

Another case:

n=4, x=2, p=[4,3,2,1]

Binary search:

l=0, r=4

m=2, p[2]=2 <=2, l=2

m=3, p[3]=1 <=2, l=3

m=3, p[3]=1 <=2, l=3

r - l =1, stop.

p_l = p[3]=1 !=2.

Need to make p[3]=2.

Currently, p[2]=2.

So, swap p[2] and p[3].

Then, p=[4,3,1,2]

Binary search:

l=0, r=4

m=2, p[2]=1 <=2, l=2

m=3, p[3]=2 <=2, l=3

m=3, p[3]=2 <=2, l=3

r - l =1, stop.

p_l = p[3]=2 ==x=2.

Again, one swap suffices.

Wait, but the problem says "it can be shown that two operations are always sufficient". So, perhaps in some cases, one swap is not enough.

Let's try to find such a case.

Consider n=5, x=3, p=[5,1,2,4,3]

Binary search:

l=0, r=5

m=2, p[2]=2 <=3, l=2

m=3, p[3]=4 >3, r=3

m=2, p[2]=2 <=3, l=2

m=2, p[2]=2 <=3, l=2

r - l =1, stop.

p_l = p[2]=2 !=3.

Need to make p[2]=3.

Currently, p[4]=3.

So, swap p[2] and p[4].

Then, p=[5,1,3,4,2]

Binary search:

l=0, r=5

m=2, p[2]=3 <=3, l=2

m=3, p[3]=4 >3, r=3

m=2, p[2]=3 <=3, l=2

m=2, p[2]=3 <=3, l=2

r - l =1, stop.

p_l = p[2]=3 ==x=3.

Again, one swap suffices.

Wait, maybe in some cases, we need to perform two swaps.

Let's consider n=5, x=3, p=[2,4,1,5,3]

Binary search:

l=0, r=5

m=2, p[2]=1 <=3, l=2

m=3, p[3]=5 >3, r=3

m=2, p[2]=1 <=3, l=2

m=2, p[2]=1 <=3, l=2

r - l =1, stop.

p_l = p[2]=1 !=3.

Need to make p[2]=3.

Currently, p[4]=3.

So, swap p[2] and p[4].

Then, p=[2,4,3,5,1]

Binary search:

l=0, r=5

m=2, p[2]=3 <=3, l=2

m=3, p[3]=5 >3, r=3

m=2, p[2]=3 <=3, l=2

m=2, p[2]=3 <=3, l=2

r - l =1, stop.

p_l = p[2]=3 ==x=3.

Again, one swap suffices.

Hmm.

Maybe in all cases, one swap is sufficient.

But the problem allows up to two swaps, just to be safe.

Perhaps in some tricky cases, one swap isn't enough, but I can't find such a case yet.

Let me try another approach.

Suppose we perform the binary search on the original array and see where it ends up.

If p_l == x, we're done.

If not, we need to adjust the array so that p_l = x.

To do this, we can swap the element at position l with x's current position.

This should make p_l = x.

But in all the examples I've tried, this approach works with one swap.

Is there a case where this doesn't work?

Let's consider n=4, x=2, p=[4,1,3,2]

Binary search:

l=0, r=4

m=2, p[2]=3 <=2? No, 3>2, so r=2

m=1, p[1]=1 <=2, l=1

m=1, p[1]=1 <=2, l=1

r - l =1, stop.

p_l = p[1]=1 !=2.

Need to make p[1]=2.

Currently, p[3]=2.

So, swap p[1] and p[3].

Then, p=[4,2,3,1]

Binary search:

l=0, r=4

m=2, p[2]=3 <=2? No, 3>2, r=2

m=1, p[1]=2 <=2, l=1

m=1, p[1]=2 <=2, l=1

r - l =1, stop.

p_l = p[1]=2 ==x=2.

Again, one swap suffices.

Wait, maybe in some cases, after swapping, the binary search path changes.

Is there a case where swapping once doesn't suffice because the binary search path changes after the swap?

Let's think about that.

Suppose we have n=6, x=3, p=[2,4,1,5,3,6]

Binary search:

l=0, r=6

m=3, p[3]=1 <=3, l=3

m=4, p[4]=5 >3, r=4

m=3, p[3]=1 <=3, l=3

m=3, p[3]=1 <=3, l=3

r - l =1, stop.

p_l = p[3]=1 !=3.

Need to make p[3]=3.

Currently, p[4]=5 and p[5]=3.

Swap p[3] and p[5]:

p=[2,4,3,5,1,6]

Binary search:

l=0, r=6

m=3, p[3]=3 <=3, l=3

m=4, p[4]=5 >3, r=4

m=3, p[3]=3 <=3, l=3

m=3, p[3]=3 <=3, l=3

r - l =1, stop.

p_l = p[3]=3 ==x=3.

Again, one swap suffices.

Wait, perhaps in all cases, one swap suffices.

But the problem allows up to two swaps, indicating that there might be cases where one swap isn't enough.

Let me try to find such a case.

Consider n=5, x=2, p=[3,5,1,4,2]

Binary search:

l=0, r=5

m=2, p[2]=1 <=2, l=2

m=3, p[3]=4 >2, r=3

m=2, p[2]=1 <=2, l=2

m=2, p[2]=1 <=2, l=2

r - l =1, stop.

p_l = p[2]=1 !=2.

Need to make p[2]=2.

Currently, p[4]=4 and p[5]=2.

Swap p[2] and p[5]:

p=[3,5,2,4,1]

Binary search:

l=0, r=5

m=2, p[2]=2 <=2, l=2

m=3, p[3]=4 >2, r=3

m=2, p[2]=2 <=2, l=2

m=2, p[2]=2 <=2, l=2

r - l =1, stop.

p_l = p[2]=2 ==x=2.

Again, one swap suffices.

Hmm.

Maybe in all cases, one swap is enough.

But perhaps there's a tricky case where one swap isn't enough.

Let's consider n=4, x=3, p=[1,4,2,3]

Binary search:

l=0, r=4

m=2, p[2]=2 <=3, l=2

m=3, p[3]=3 <=3, l=3

m=3, p[3]=3 <=3, l=3

r - l =1, stop.

p_l = p[3]=3 ==x=3. So, 0 swaps needed.

Another case: n=4, x=1, p=[4,3,2,1]

Binary search:

l=0, r=4

m=2, p[2]=2 >1, r=2

m=1, p[1]=3 >1, r=1

m=0, p[0]=4 >1, r=0

l=0

p_l = p[0]=4 !=1.

Need to make p[0]=1.

Currently, p[3]=1.

Swap p[0] and p[3]:

p=[1,3,2,4]

Binary search:

l=0, r=4

m=2, p[2]=2 <=1? No, 2>1, r=2

m=1, p[1]=3 >1, r=1

m=0, p[0]=1 <=1, l=0

m=0, p[0]=1 <=1, l=0

r - l =1, stop.

p_l = p[0]=1 ==x=1.

Again, one swap suffices.

Wait, maybe there's a case where after swapping once, the binary search path changes, and we need a second swap.

Let me try n=5, x=3, p=[4,1,5,2,3]

Binary search:

l=0, r=5

m=2, p[2]=5 >3, r=2

m=1, p[1]=1 <=3, l=1

m=1, p[1]=1 <=3, l=1

r - l =1, stop.

p_l = p[1]=1 !=3.

Need to make p[1]=3.

Currently, p[5]=3.

Swap p[1] and p[5]:

p=[4,3,5,2,1]

Binary search:

l=0, r=5

m=2, p[2]=5 >3, r=2

m=1, p[1]=3 <=3, l=1

m=1, p[1]=3 <=3, l=1

r - l =1, stop.

p_l = p[1]=3 ==x=3.

Again, one swap suffices.

Wait, maybe in some cases, swapping once doesn't work because the binary search path changes in a way that requires another swap.

Let me try to think differently.

Suppose we have n=5, x=2, p=[3,5,4,1,2]

Binary search:

l=0, r=5

m=2, p[2]=4 >2, r=2

m=1, p[1]=5 >2, r=1

m=0, p[0]=3 >2, r=0

l=0

p_l = p[0]=3 !=2.

Need to make p[0]=2.

Currently, p[4]=2.

Swap p[0] and p[4]:

p=[2,5,4,1,3]

Binary search:

l=0, r=5

m=2, p[2]=4 >2, r=2

m=1, p[1]=5 >2, r=1

m=0, p[0]=2 <=2, l=0

m=0, p[0]=2 <=2, l=0

r - l =1, stop.

p_l = p[0]=2 ==x=2.

Again, one swap suffices.

Wait, maybe in some cases, after swapping once, the binary search ends up in a different position, and we need a second swap.

Let me try n=6, x=3, p=[5,1,4,2,6,3]

Binary search:

l=0, r=6

m=3, p[3]=2 <=3, l=3

m=4, p[4]=6 >3, r=4

m=3, p[3]=2 <=3, l=3

m=3, p[3]=2 <=3, l=3

r - l =1, stop.

p_l = p[3]=2 !=3.

Need to make p[3]=3.

Currently, p[5]=3.

Swap p[3] and p[5]:

p=[5,1,4,3,6,2]

Binary search:

l=0, r=6

m=3, p[3]=3 <=3, l=3

m=4, p[4]=6 >3, r=4

