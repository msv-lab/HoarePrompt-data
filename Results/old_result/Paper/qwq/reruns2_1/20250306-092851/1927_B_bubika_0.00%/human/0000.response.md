Alright, I have this problem to solve. Let's see what it's asking for. So, Polycarp lost a string, but he has its "trace." The trace is an array of integers that represent, for each position in the string, how many previous indices have the same character as the current one.

For example, for the string "abracadabra," the trace is [0,0,0,1,0,2,0,3,1,1,4]. This means that for each position, it's counting how many times the same character has appeared before it in the string.

My task is, given this trace, to reconstruct any possible string that could have produced this trace. The string should only consist of lowercase Latin letters.

First, I need to understand the input and output formats. The input starts with an integer t, representing the number of test cases. For each test case, there's an integer n, which is the length of the string, followed by n integers that make up the trace array.

The output should be, for each test case, a string that corresponds to the given trace.

Constraints:

- 1 ≤ t ≤ 10^4

- 1 ≤ n ≤ 2*10^5

- Sum of n over all test cases does not exceed 2*10^5

Given that t can be up to 10^4 and n up to 2*10^5, with the sum of n over all test cases up to 2*10^5, I need to make sure my solution is efficient.

The problem also states that for the given trace, there exists a suitable string s, so I don't need to worry about invalid inputs.

Now, let's think about how to approach this.

I need to generate a string where for each position i, the number of previous indices j (j < i) with s_i = s_j is equal to a_i.

In other words, a_i represents the number of times the character at position i has appeared before in the string, up to position i-1.

So, for each position i, I need to choose a character that has appeared exactly a_i times before.

One way to approach this is to keep track of the frequency of each character as I build the string.

Let me consider that I have a list of frequencies for each character (a to z), initialized to zero.

For each position i in the string:

- I need to choose a character c such that the current frequency of c is equal to a_i.

- Once I choose c, I add it to the string and increment its frequency.

This seems feasible.

Let me try to formalize this:

Initialize a list freq of size 26, all set to 0, representing the frequency of each character from 'a' to 'z'.

For each test case:

Read n and the trace array s of length n.

Initialize an empty string r.

For each value a_i in s:

Find a character c such that freq[c - 'a'] == a_i.

Append c to r.

Increment freq[c - 'a'] by 1.

Print r.

Wait, but how do I find such a character c?

I need to find a character whose current frequency matches a_i.

Since multiple characters might have the same frequency, I can choose any of them.

To make it efficient, I can iterate through the characters from 'a' to 'z' and select the first one whose frequency matches a_i.

This seems straightforward.

Let me consider the example provided:

n = 11

s = [0,0,0,1,0,2,0,3,1,1,4]

Let's step through this:

Initialize freq = [0,0,0,...,0] (26 zeros)

First a_i = 0

Look for a character c where freq[c - 'a'] == 0.

'a': freq[0] == 0 → choose 'a'

r = 'a'

freq = [1,0,0,...,0]

Next a_i = 0

Look for c where freq[c - 'a'] == 0.

'b': freq[1] == 0 → choose 'b'

r = 'ab'

freq = [1,1,0,...,0]

Next a_i = 0

Look for c where freq[c - 'a'] == 0.

'c': freq[2] == 0 → choose 'c'

r = 'abc'

freq = [1,1,1,...,0]

Next a_i = 1

Look for c where freq[c - 'a'] == 1.

'a': freq[0] == 1 → choose 'a'

r = 'abca'

freq = [2,1,1,...,0]

Next a_i = 0

Look for c where freq[c - 'a'] == 0.

'd': freq[3] == 0 → choose 'd'

r = 'abcad'

freq = [2,1,1,1,...,0]

Next a_i = 2

Look for c where freq[c - 'a'] == 2.

'a': freq[0] == 2 → choose 'a'

r = 'abacad'

freq = [3,1,1,1,...,0]

Next a_i = 0

Look for c where freq[c - 'a'] == 0.

'e': freq[4] == 0 → choose 'e'

r = 'abacade'

freq = [3,1,1,1,1,...,0]

Next a_i = 3

Look for c where freq[c - 'a'] == 3.

'a': freq[0] == 3 → choose 'a'

r = 'abacada'

freq = [4,1,1,1,1,...,0]

Next a_i = 1

Look for c where freq[c - 'a'] == 1.

'b': freq[1] == 1 → choose 'b'

r = 'abacabad'

freq = [4,2,1,1,1,...,0]

Next a_i = 1

Look for c where freq[c - 'a'] == 1.

'c': freq[2] == 1 → choose 'c'

r = 'abacabac'

freq = [4,2,2,1,1,...,0]

Next a_i = 4

Look for c where freq[c - 'a'] == 4.

'a': freq[0] == 4 → choose 'a'

r = 'abacabaca'

freq = [5,2,2,1,1,...,0]

Wait, but the example output is "abracadabra," not "abacabaca." Hmm, maybe I made a mistake.

Wait, let's check the frequencies again.

Wait, in the fourth step, a_i = 1, and freq['a'] = 1, so choose 'a', which is correct.

But in the example, it's "abracadabra," which is different from what I have.

Wait, maybe I need to choose different characters.

Let me try again, being more careful.

Initialize freq = [0]*26

a_i = 0 → choose 'a' → r = 'a' → freq['a'] = 1

a_i = 0 → choose 'b' → r = 'ab' → freq['b'] = 1

a_i = 0 → choose 'r' → r = 'abr' → freq['r'] = 1

a_i = 1 → choose 'a' (since freq['a'] = 1) → r = 'abra' → freq['a'] = 2

a_i = 0 → choose 'c' → r = 'abrac' → freq['c'] = 1

a_i = 2 → choose 'a' (freq['a'] = 2) → r = 'abracaa' → freq['a'] = 3

Wait, but in the example, it's "abracadabra," which has 'd' instead of the second 'a.'

Wait, perhaps I need to choose different characters to match the example.

Wait, maybe I need to choose 'd' for a_i = 2.

But freq['d'] = 0, which is not equal to 2.

Wait, no, freq['d'] = 0, which is not equal to a_i = 2, so I can't choose 'd.'

I need to choose a character whose frequency is exactly 2.

So 'a' has freq = 2, 'b' has freq = 1, 'r' has freq = 1, 'c' has freq = 1.

So I can choose 'a.'

Wait, but in the example, it's 'abracadabra,' which has 'a' at position 5.

Wait, maybe there are multiple possible strings, and the problem accepts any valid one.

Yes, the problem says "output any string s that corresponds to the given trace."

So in this case, both "abracaa" and "abracadabra" could be valid, depending on the trace.

Wait, but in the example, the trace is [0,0,0,1,0,2,0,3,1,1,4], and the corresponding string is "abracadabra."

So perhaps in my earlier attempt, I made a mistake.

Let me try to reconstruct "abracadabra" based on the trace.

Given trace [0,0,0,1,0,2,0,3,1,1,4]

Position 1: a_i = 0 → choose 'a' (freq['a'] = 0) → r = 'a' → freq['a'] = 1

Position 2: a_i = 0 → choose 'b' (freq['b'] = 0) → r = 'ab' → freq['b'] = 1

Position 3: a_i = 0 → choose 'r' (freq['r'] = 0) → r = 'abr' → freq['r'] = 1

Position 4: a_i = 1 → choose 'a' (freq['a'] = 1) → r = 'abra' → freq['a'] = 2

Position 5: a_i = 0 → choose 'c' (freq['c'] = 0) → r = 'abrac' → freq['c'] = 1

Position 6: a_i = 2 → choose 'a' (freq['a'] = 2) → r = 'abracaa' → freq['a'] = 3

Wait, but in "abracadabra," position 6 is 'd,' not 'a.'

But according to the trace, a_i = 2, which would require choosing a character that has appeared twice before, which is 'a.'

So why does the example have 'd' instead?

Wait, maybe I'm misunderstanding something.

Wait, in "abracadabra," let's check the trace:

Position 1: 'a' → no previous 'a' → 0

Position 2: 'b' → no previous 'b' → 0

Position 3: 'r' → no previous 'r' → 0

Position 4: 'a' → one previous 'a' → 1

Position 5: 'c' → no previous 'c' → 0

Position 6: 'a' → two previous 'a's → 2

Position 7: 'd' → no previous 'd' → 0

Position 8: 'a' → three previous 'a's → 3

Position 9: 'b' → one previous 'b' → 1

Position 10: 'r' → one previous 'r' → 1

Position 11: 'a' → four previous 'a's → 4

So the trace is [0,0,0,1,0,2,0,3,1,1,4], which matches the input.

But according to my earlier approach, at position 6, a_i = 2, I would choose 'a,' but in the example, it's 'd.'

Wait, no, in position 7, a_i = 0, which corresponds to 'd.'

Wait, let's map it correctly.

Given the trace [0,0,0,1,0,2,0,3,1,1,4], and the string "abracadabra":

Positions:

1: 'a' → 0

2: 'b' → 0

3: 'r' → 0

4: 'a' → 1

5: 'c' → 0

6: 'a' → 2

7: 'd' → 0

8: 'a' → 3

9: 'b' → 1

10: 'r' → 1

11: 'a' → 4

Yes, that matches.

So in position 7, a_i = 0, which means choose a character that has not appeared before, which is 'd.'

In my earlier attempt, at position 6, a_i = 2, which corresponds to choosing 'a,' which has appeared twice before.

But in the example, position 6 is 'a,' which matches a_i = 2.

Wait, perhaps I miscounted.

Wait, no, in position 6, 'a' has appeared twice before, which matches a_i = 2.

Then in position 7, a_i = 0, so choose 'd,' which hasn't appeared before.

So my earlier mistake was in position 6; I thought 'd' was at position 6, but it's at position 7.

So my approach seems correct.

I need to choose, for each a_i, a character whose current frequency is exactly a_i.

Then, increment that character's frequency.

This should work.

Now, let's consider another example.

Take n=10 and s=[0,0,0,0,0,1,0,1,1,0]

One possible string is "codeforces."

Let's verify:

Position 1: 'c' → 0

Position 2: 'o' → 0

Position 3: 'd' → 0

Position 4: 'e' → 0

Position 5: 'f' → 0

Position 6: 'o' →1 (one previous 'o')

Position 7: 'r' →0

Position 8: 'c' →1 (one previous 'c')

Position 9: 'e' →1 (one previous 'e')

Position 10: 's' →0

This matches the trace [0,0,0,0,0,1,0,1,1,0].

So, my approach seems valid.

Another example: n=1, s=[0] → "a"

n=8, s=[0,1,2,3,4,5,6,7] → "aaaaaaaa"

n=8, s=[0,0,0,0,0,0,0,0] → "dijkstra" (assuming no repetitions)

So, my plan is:

- For each test case:

- Read n and the trace array s.

- Initialize a frequency list for 'a' to 'z', all set to 0.

- For each a_i in s:

- Find the first character c from 'a' to 'z' where freq[c - 'a'] == a_i.

- Append c to the result string.

- Increment freq[c - 'a'] by 1.

- Print the result string.

This should work efficiently since for each character in the string, we perform a linear search among 26 characters, which is acceptable given the constraints.

Now, looking at the provided program:

def func():

a = 'abcdefghijklmnopqrstuvwxyz'

b = [0] * 26

for t in range(int(input())):

n = int(input())

s = list(map(int, input().split()))

r = ''

for i in s:

x = b.index(i)

r += a[x]

b[x] += 1

print(r)

This seems to implement the approach I just described.

It initializes a list b with 26 zeros, corresponding to the frequencies of 'a' to 'z.'

For each test case, it reads n and the trace array s.

Then, for each a_i in s:

- Finds the index x of the first occurrence of a_i in b.

- Appends the corresponding character a[x] to r.

- Increments b[x] by 1.

Finally, it prints the string r.

This should work correctly, as it matches the approach I outlined.

Therefore, the given program is correct.

**Final Solution**

To solve this problem, we need to reconstruct the original string from its trace array. The trace array provides the count of previous occurrences of each character up to that point in the string.

## Approach

1. **Understanding the Trace Array**:
   - The trace array `a_i` for each position `i` in the string indicates how many times the character at position `i` has appeared in the string before position `i`.

2. **Frequency Tracking**:
   - We maintain a frequency list for each lowercase letter from `a` to `z`. This list keeps track of how many times each character has been used so far.

3. **Reconstructing the String**:
   - For each position `i` in the string, we look for the first character that has appeared exactly `a_i` times so far.
   - Once we select the character for position `i`, we increment its frequency count.

4. **Efficient Selection**:
   - By iterating through the characters from `a` to `z` and selecting the first one that matches the required frequency `a_i`, we ensure that we build the string correctly.

## Solution Code

```python
def func():
    a = 'abcdefghijklmnopqrstuvwxyz'
    b = [0] * 26
    for t in range(int(input())):
        n = int(input())
        s = list(map(int, input().split()))
        r = ''
        for i in s:
            x = b.index(i)
            r += a[x]
            b[x] += 1
        print(r)

func()
```

## Explanation

- **Initialization**:
  - We initialize a string `a` containing all lowercase letters and a list `b` of size 26 to track the frequency of each letter, initialized to zero.

- **Processing Each Test Case**:
  - For each test case, read the integer `n` (length of the string) and the trace array `s`.
  
- **Reconstructing the String**:
  - For each value `a_i` in the trace array `s`:
    - Find the first character in `a` whose current frequency matches `a_i`.
    - Append this character to the result string `r`.
    - Increment the frequency count for this character.
  
- **Output**:
  - Print the reconstructed string `r` for each test case.

This method ensures that the reconstructed string matches the given trace array by maintaining and checking the frequency of each character at each step.