Alright, I have this problem to solve. Let's see what it's about. So, Rudolf has an array of integers, and he can perform a specific operation on it any number of times. The operation involves choosing an index i (where 2 ≤ i ≤ n-1) and modifying the elements at positions i-1, i, and i+1 by subtracting 1, 2, and 1 respectively. The goal is to determine whether it's possible to make all elements of the array zero by applying this operation any number of times.

First, I need to understand the operation clearly. For any chosen i, the operation affects three consecutive elements: the one before, the one at i, and the one after. Specifically, a[i-1] decreases by 1, a[i] decreases by 2, and a[i+1] decreases by 1. This seems like a form of localized subtraction that affects a triplet of elements.

My task is to see if, by applying this operation multiple times on various indices, I can reduce the entire array to zeros.

Let me think about the implications of this operation. Since each operation affects three elements, it might be related to solving a system of equations where each equation represents the operation applied at a particular position.

Alternatively, perhaps there's a way to model this as a difference equation or using prefix sums.

Let me consider a smaller example to get a better understanding.

Suppose n=3, and the array is [1, 2, 1].

If I apply the operation at i=2, it becomes:

a[1] = 1 - 1 = 0

a[2] = 2 - 2 = 0

a[3] = 1 - 1 = 0

So, in one operation, I can zero out the entire array. That's straightforward.

Another example: n=4, array [1, 3, 5, 2].

If I apply the operation at i=3:

a[2] = 3 - 1 = 2

a[3] = 5 - 2 = 3

a[4] = 2 - 1 = 1

Now the array is [1, 2, 3, 1].

Then apply at i=2:

a[1] = 1 - 1 = 0

a[2] = 2 - 2 = 0

a[3] = 3 - 1 = 2

Now the array is [0, 0, 2, 1].

Then apply at i=3 again:

a[2] = 0 - 1 = -1 (wait, negative numbers? But the problem says elements are non-negative integers.

Hmm, perhaps I need to be careful about not allowing negative numbers.

But the problem allows operations to be applied any number of times, and indices can be chosen zero or more times.

Wait, but in this case, after the first operation, a[3] is 3, and a[4] is 1.

If I apply at i=3 again:

a[2] = 0 - 1 = -1 (invalid)

So maybe I need a different approach.

Perhaps I should consider the operations in reverse. Imagine starting from all zeros and applying the operations to build up to the given array. But that might not help directly.

Let me think about the constraints.

Given that n is at least 3 and up to 2*10^5, and t is up to 10^4, but the total sum of n over all test cases is up to 2*10^5, I need an efficient solution, probably O(n) per test case.

I need a way to check, for each test case, whether it's possible to reach all zeros from the given array using the allowed operations.

I recall that in linear algebra, operations on arrays can sometimes be represented as matrix operations, and solving for whether a certain state can be reached.

But I need something more intuitive and implementable in code.

Let me consider the differences between consecutive elements.

Suppose I look at the differences between a[i+1] and a[i].

Let me define d[i] = a[i+1] - a[i] for i from 1 to n-1.

Maybe there's a pattern in these differences that can help determine if the array can be zeroed out.

But I'm not sure yet.

Alternatively, perhaps I can model the operations in a way that allows me to cancel out the elements step by step.

Wait, perhaps I can use the operations to eliminate elements from left to right.

Let me try to eliminate a[1] first.

To make a[1] zero, I can apply the operation at i=2, which will subtract 1 from a[1], 2 from a[2], and 1 from a[3].

If a[1] is greater than 0, I can apply the operation a[1] times.

Wait, but a[1] could be larger than the possible subtractions allowed by the operations.

I need to be careful.

Wait, perhaps I can think of it in terms of dependencies.

Let me try to express a[i] in terms of operations applied at positions j.

Each operation at position i affects a[i-1], a[i], and a[i+1].

So, if I let o[i] be the number of times I apply the operation at position i, then:

a[1] - o[2] = 0

a[2] - 2*o[2] - o[3] = 0

a[3] - o[2] - 2*o[3] - o[4] = 0

...

a[n-1] - o[n-2] - 2*o[n-1] - o[n] = 0

a[n] - o[n-1] = 0

Wait, that seems off. Let me double-check.

Actually, for each operation at position i:

a[i-1] -= 1

a[i] -= 2

a[i+1] -= 1

So, in terms of equations:

a[1] - o[2] = 0

a[2] - o[2] - 2*o[3] - o[4] = 0

a[3] - o[3] - 2*o[4] - o[5] = 0

...

a[n-1] - o[n-2] - 2*o[n-1] - o[n] = 0

a[n] - o[n-1] - o[n] = 0

Wait, no, that's not quite right.

Wait, for operation at i=2: a[1]-1, a[2]-2, a[3]-1

Operation at i=3: a[2]-1, a[3]-2, a[4]-1

Operation at i=4: a[3]-1, a[4]-2, a[5]-1

And so on.

So, for each a[i], it is affected by operations at positions i-1, i, and i+1.

Wait, perhaps I need to set up a system of equations and solve for o[i].

But with n up to 2e5, solving a system of equations is not feasible.

I need a smarter way.

Let me consider the operations as a way to reduce the array step by step.

I can try to process the array from left to right, eliminating the leftmost non-zero element.

Let me try an example.

Take the first example from the problem:

n=5, a=[1,3,5,5,2]

I can choose to apply the operation at i=2:

a[1]-1, a[2]-2, a[3]-1 => [0,1,4,5,2]

Then at i=3:

[0,0,2,4,2]

Then at i=4:

[0,0,1,2,1]

Then at i=4 again:

[0,0,0,0,0]

So it works.

Another example:

n=5, a=[2,4,4,5,1]

Try to apply at i=2:

[1,2,3,5,1]

Then at i=3:

[1,1,1,4,1]

Then at i=4:

[1,1,0,2,1]

Then at i=4 again:

[1,1,0,0,0]

But a[1] and a[2] are still 1, so it's not all zeros. So "NO"

Wait, but according to the sample output, it's "NO"

So my manual simulation matches the sample output.

Another example:

n=5, a=[0,1,3,3,1]

Apply at i=3:

[0,0,1,2,1]

Apply at i=4:

[0,0,0,0,0]

So "YES"

Good.

Now, I need a general way to determine this without simulating all possible operations, especially since n can be up to 2e5.

I need a more efficient approach.

Let me consider the operations as a way to subtract specific patterns from the array.

Each operation at position i subtracts [1,2,1] from positions i-1, i, i+1.

I need to see if I can subtract multiples of these patterns to reach all zeros.

This sounds like solving a system of linear equations, but that's not practical for large n.

Is there a way to model this as a difference or prefix sum?

Let me try to think differently.

Suppose I have the final array after all operations have been applied, which should be all zeros.

Each operation affects three elements: subtracts 1 from a[i-1], 2 from a[i], and 1 from a[i+1].

So, the total subtraction from a[i-1] is o[2], from a[i] is o[2] + 2*o[3] + o[4], and so on.

Wait, perhaps I can model this as a system where each o[i] affects a[i-1], a[i], and a[i+1].

But again, solving such a system directly is not feasible for large n.

I need a smarter way.

Let me consider the differences between consecutive elements.

Define d[i] = a[i] - a[i-1] for i from 2 to n.

Maybe there's a pattern in these differences.

Wait, perhaps I can process the array from left to right, keeping track of the required operations.

Let me try to iterate from left to right, and at each step, determine how many operations to apply at that position to make the current element zero.

Start with a[1]. To make a[1] zero, I need to apply some operations that subtract from a[1].

But the only operation that affects a[1] is the operation at i=2, which subtracts 1 from a[1].

So, to make a[1] zero, I need to apply the operation at i=2 exactly a[1] times.

But, applying the operation at i=2 also affects a[2] and a[3].

So, after applying the operation at i=2, a[1] becomes zero, a[2] decreases by 2*a[1], and a[3] decreases by a[1].

Then, I can move to a[2]. Now, a[2] might still be positive after the previous operations, or it might be zero or negative.

If a[2] is still positive, I need to apply operations at i=3 to reduce it.

But applying operations at i=3 affects a[2], a[3], and a[4].

I need to find a way to iteratively apply these operations to zero out each element, one by one.

This seems promising.

Let me formalize this approach.

Initialize an array o of operations, where o[i] represents the number of times operation is applied at position i.

Start with o[i] = 0 for all i.

Iterate from left to right:

For each position i from 1 to n-2:

If a[i] > 0, set o[i+1] = a[i]

Then, update a[i] -= o[i+1]

a[i+1] -= 2*o[i+1]

a[i+2] -= o[i+1]

After processing all positions up to n-2, check if a[n-1] == 0 and a[n] == 0.

If yes, then "YES", else "NO"

This seems similar to the code provided.

Wait, looking back at the provided code:

def func():

numTest = int(input())

for _ in range(0, numTest):

n = int(input())

a = [int(x) for x in input().split()]

stop = False

for i in range(0, n - 2):

if a[i] < 0:

print('NO')

stop = True

break

opNum = a[i]

a[i] -= opNum

a[i + 1] -= 2 * opNum

a[i + 2] -= opNum

if stop == True:

continue

if a[len(a) - 1] != 0 or a[len(a) - 2] != 0:

print('NO')

else:

print('YES')

So, the code iterates from i=0 to n-3, and for each i, it subtracts a[i] times the operation pattern from a[i], a[i+1], and a[i+2].

If at any point a[i] < 0 before performing the operation, it immediately prints "NO" for that test case.

After processing, it checks if the last two elements are zero.

This seems aligned with my thoughts.

But I need to verify if this approach is correct.

Let me consider an example where it should return "YES".

Take the first sample input:

n=5, a=[1,3,5,5,2]

First iteration, i=0:

a[0] = 1 > 0, so opNum = 1

a[0] -= 1 => 0

a[1] -= 2*1 => 3-2=1

a[2] -= 1 => 5-1=4

Now a = [0,1,4,5,2]

Second iteration, i=1:

a[1] =1 >0, opNum=1

a[1] -=1 =>0

a[2] -=2*1 =>4-2=2

a[3] -=1 =>5-1=4

Now a = [0,0,2,4,2]

Third iteration, i=2:

a[2]=2 >0, opNum=2

a[2] -=2 =>0

a[3] -=4 =>4-4=0

a[4] -=2 =>2-2=0

Now a = [0,0,0,0,0]

So, it correctly reaches all zeros.

Another sample where it should return "NO":

n=5, a=[2,4,4,5,1]

First iteration, i=0:

a[0]=2 >0, opNum=2

a[0]-=2 =>0

a[1]-=4 =>4-4=0

a[2]-=2 =>4-2=2

Now a = [0,0,2,5,1]

Second iteration, i=1:

a[1]=0, skip

Third iteration, i=2:

a[2]=2 >0, opNum=2

a[2]-=2 =>0

a[3]-=4 =>5-4=1

a[4]-=2 =>1-2=-1

Now a = [0,0,0,1,-1]

But a[4]=-1, which is negative, so it should print "NO"

Wait, but according to the sample output, it's "NO", but in the code, it only checks a[n-1] and a[n-2] after all operations.

Wait, in the code, it doesn't check for negative numbers during the process, only before performing an operation.

In this case, a[4] becomes -1, but the code only checks a[i] before performing the operation, not after.

Wait, in the code, for each i from 0 to n-3:

if a[i] <0: print 'NO'

else: perform operation

But in this example, a[2]=2 >0, so perform operation, then a[4]=1-2=-1

Then, after all operations, check if a[n-1]==0 and a[n-2]==0

Here, a[n-2]=1 and a[n-1]=-1, so it should print "NO"

Which matches the sample output.

So, seems correct.

Let me check another "YES" case.

n=5, a=[0,1,3,3,1]

First iteration, i=0:

a[0]=0, skip

Second iteration, i=1:

a[1]=1 >0, opNum=1

a[1]-=1 =>0

a[2]-=2 =>3-2=1

a[3]-=1 =>3-1=2

Now a=[0,0,1,2,1]

Third iteration, i=2:

a[2]=1 >0, opNum=1

a[2]-=1 =>0

a[3]-=2 =>2-2=0

a[4]-=1 =>1-1=0

Now a=[0,0,0,0,0], which is "YES"

Good.

Another "NO" case:

n=4, a=[1,2,7,2]

First iteration, i=0:

a[0]=1 >0, opNum=1

a[0]-=1 =>0

a[1]-=2 =>2-2=0

a[2]-=1 =>7-1=6

Now a=[0,0,6,2]

Second iteration, i=1:

a[1]=0, skip

Third iteration, i=2:

a[2]=6 >0, opNum=6

a[2]-=6 =>0

a[3]-=12 =>2-12=-10

Now a=[0,0,0,-10], which is "NO" because a[3]=-10

Correct according to sample output.

Seems the code works for these cases.

But I need to think if there are any edge cases where this approach might fail.

Consider n=3, a=[0,0,0]

No operations needed, should return "YES"

n=3, a=[1,2,1], as in the first example, should return "YES"

n=3, a=[1,1,1]

First iteration, i=0:

a[0]=1 >0, opNum=1

a[0]-=1 =>0

a[1]-=2 =>1-2=-1

a[2]-=1 =>1-1=0

Now a=[0,-1,0]

Since a[1]=-1, which is negative, should return "NO"

But according to the code, it only checks a[i] before performing the operation, not after.

In this case, a[i] before is 1 >0, so perform operation, then a becomes [0,-1,0]

Then, check if a[n-1]==0 and a[n-2]==0, which are a[2]==0 and a[1]==-1

Since a[1]!=0, it should return "NO"

Correct.

Another case: n=4, a=[0,0,0,0], should return "YES"

n=4, a=[0,1,0,0]

First iteration, i=0:

a[0]=0, skip

Second iteration, i=1:

a[1]=1 >0, opNum=1

a[1]-=1 =>0

a[2]-=2 =>0-2=-2

a[3]-=1 =>0-1=-1

Now a=[0,0,-2,-1]

Check a[3]==0 and a[2]==0, which are not, so "NO"

Correct.

Seems consistent.

But I need to think if there's any case where this approach might not work.

Wait, consider n=5, a=[1,3,3,3,1]

First iteration, i=0:

a[0]=1 >0, opNum=1

a[0]-=1 =>0

a[1]-=2 =>3-2=1

a[2]-=1 =>3-1=2

Now a=[0,1,2,3,1]

Second iteration, i=1:

a[1]=1 >0, opNum=1

a[1]-=1 =>0

a[2]-=2 =>2-2=0

a[3]-=1 =>3-1=2

Now a=[0,0,0,2,1]

Third iteration, i=2:

a[2]=0, skip

Check a[3]==0 and a[4]==0, but a[3]=2 !=0, so "NO"

But wait, maybe there's another sequence of operations that could make it all zeros.

Let me try a different sequence.

Apply operation at i=3:

a[2]-1, a[3]-2, a[4]-1 => [0,0,-1,0,1]

But a[2] becomes negative, which is invalid.

Alternatively, apply at i=4:

a[3]-1, a[4]-2, a[5]-1 => [0,0,1,0,0]

Now, apply at i=2:

a[1]-1, a[2]-2, a[3]-1 => [-1,-2,0,0,0]

But negatives are invalid.

Seems like it's not possible to make all zeros, so "NO" is correct.

Another case: n=4, a=[1,1,1,1]

First iteration, i=0:

a[0]=1 >0, opNum=1

a[0]-=1 =>0

a[1]-=2 =>1-2=-1

a[2]-=1 =>1-1=0

Now a=[0,-1,0,1]

Since a[1]=-1 <0, which is invalid, should return "NO"

But according to the code, it only checks a[i] before performing the operation, not after.

In this case, a[i] before is 1 >0, so perform operation, then a=[0,-1,0,1]

Then check a[3]==1 !=0 and a[2]==0, so "NO"

Correct.

Seems the code works.

But to be thorough, let's consider n=6, a=[5,6,0,2,3,0]

First iteration, i=0:

a[0]=5 >0, opNum=5

a[0]-=5 =>0

a[1]-=10 =>6-10=-4

a[2]-=5 =>0-5=-5

Now a=[0,-4,-5,2,3,0]

Since a[1]=-4 <0, invalid, so "NO"

Correct according to sample output.

Another "YES" case: n=4, a=[1,3,3,1]

First iteration, i=0:

a[0]=1 >0, opNum=1

a[0]-=1 =>0

a[1]-=2 =>3-2=1

a[2]-=1 =>3-1=2

Now a=[0,1,2,1]

Second iteration, i=1:

a[1]=1 >0, opNum=1

a[1]-=1 =>0

a[2]-=2 =>2-2=0

a[3]-=1 =>1-1=0

Now a=[0,0,0,0], which is "YES"

Good.

Seems the approach works for these cases.

But I need to think about the correctness in general.

Is this approach guaranteed to work for all possible inputs?

I think so, because it systematically reduces the array from left to right, eliminating elements one by one.

As long as no element becomes negative during the process, and the last two elements are zero after processing, it should be possible to make the entire array zero.

Moreover, since each operation reduces the sum of the array by 4 (1+2+1), and we're making the array sum to zero, the initial sum must be divisible by 4.

Wait, no, actually, the operations subtract 1 + 2 + 1 = 4 per operation, but since operations can be applied multiple times, the total sum can be reduced by multiples of 4.

But in the examples, the sum isn't always divisible by 4.

Wait, in the first sample input: 1+3+5+5+2=16, which is divisible by 4.

Second input: 2+4+4+5+1=16, divisible by 4.

Third input: 0+1+3+3+1=8, divisible by 4.

Fourth input: 5+6+0+2+3+0=16, divisible by 4.

Fifth input: 1+2+7+2=12, divisible by 4.

Sixth input: 7+1+0=8, divisible by 4.

Seventh input: 1+1+1+1=4, divisible by 4.

So, in all sample inputs, the sum is divisible by 4.

But is this a necessary condition?

Wait, if the sum isn't divisible by 4, certainly it's impossible to reach zero, since each operation subtracts 4 from the sum.

But in the approach above, we don't explicitly check if the sum is divisible by 4.

However, in the process of applying operations, if the sum isn't divisible by 4, we won't be able to reach zero.

But in the code provided, it might still reach a point where a[n-1] and a[n-2] are zero, but with a sum not divisible by 4, which shouldn't happen.

Wait, in the code, it subtracts opNum from a[i], 2*opNum from a[i+1], and opNum from a[i+2], where opNum is a[i].

So, in total, it subtracts 4*opNum from the sum.

Therefore, the total sum reduction is always a multiple of 4