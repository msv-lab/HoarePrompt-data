Alright, I've got this problem to solve. Let's read it carefully.

So, Jay created a problem of difficulty x and wants to make it the second problem for a Codeforces round. But Yash is worried that this might make the contest unbalanced, so he decides to break this problem into n sub-problems, each with a positive integer difficulty, and the sum of these sub-problems should be equal to x.

Now, the coordinator, Aleksey, defines the balance of a problemset as the GCD (Greatest Common Divisor) of the difficulties of all the sub-problems.

Our task is to find the maximum balance Yash can achieve by optimally choosing the difficulties of the sub-problems.

Input:

- First line: number of test cases t (1 ≤ t ≤ 10^3)

- For each test case: two integers x (1 ≤ x ≤ 10^8) and n (1 ≤ n ≤ x)

Output:

- For each test case, print a single integer: the maximum balance achievable.

Example:

Input:

3

10 3

5 5

420 69

Output:

2

1

6

Explanation for the first test case:

One possible way is to have sub-problems with difficulties 4, 2, and 4. The GCD is 2.

For the second test case:

Only one way: five sub-problems each with difficulty 1. GCD is 1.

Alright, so I need to maximize the GCD of n positive integers that sum up to x.

First, let's understand what GCD is. The GCD of a set of numbers is the largest number that divides all of them without leaving a remainder.

So, if all sub-problems have difficulties that are multiples of some number d, then d is a common divisor. To maximize d, I need to find the largest possible d such that it's possible to have n positive integers, each a multiple of d, and their sum is x.

Let me think about this.

If each difficulty is a multiple of d, then we can write each difficulty as d * k, where k is a positive integer.

So, the sum of n such difficulties would be d * (k1 + k2 + ... + kn) = x.

Therefore, d must be a divisor of x.

Moreover, since there are n sub-problems, and each has a difficulty of at least 1, the smallest possible sum is n * 1 = n. So, x must be at least n.

If x < n, it's impossible to have n positive integers summing up to x, so in that case, there would be no solution, but according to the problem, inputs are valid, so x >= n.

Now, since d must be a divisor of x, and we want to maximize d, I should look for the largest divisor of x that satisfies the condition that x - n * d is divisible by d.

Wait, let's think again.

Each difficulty is d times some integer ki, and the sum is x.

So, d * (k1 + k2 + ... + kn) = x.

Therefore, d must divide x.

Moreover, k1 + k2 + ... + kn = x / d.

But each ki must be at least 1, so k1 + k2 + ... + kn >= n.

Therefore, x / d >= n, which implies d <= x / n.

So, d can be any divisor of x that is less than or equal to x / n.

But we want the maximum such d.

So, among all divisors of x that are <= x / n, we need to choose the largest one.

Wait, but in the first test case, x=10, n=3.

Divisors of 10: 1, 2, 5, 10.

But d <= x / n = 10 / 3 ≈ 3.333, so d <= 3.

So, possible d: 1, 2, maybe 3?

But 3 is not a divisor of 10, so d=1 and d=2 are possible.

Indeed, in the example, d=2 is achieved with difficulties 4,2,4.

So, in this case, d=2 is the largest possible divisor of x that is <= x / n.

Wait, but in the second test case, x=5, n=5.

Divisors of 5: 1,5.

d <= 5 / 5 =1, so only d=1 is possible.

Which matches the example.

Third test case: x=420, n=69.

We need to find the largest divisor d of 420 that is <= 420 / 69.

420 / 69 ≈ 6.087, so d <=6.

What are the divisors of 420 <=6?

Divisors of 420: 1,2,3,4,5,6,7,10,12,14,15,20,21,28,30,35,42,60,70,84,105,140,210,420.

<=6: 1,2,3,4,5,6.

So, d=6 is possible.

Indeed, the output is 6.

So, the general approach is:

- Find all divisors of x.

- Filter those divisors that are <= x / n.

- Choose the largest one among them.

This seems straightforward.

Now, in the code provided, it seems to implement this logic.

Let's look at the code:

from math import sqrt

def func():

for q in range(int(input())):

(x, n) = list(map(int, input().split(' ')))

ans = 1

for i in range(1, int(sqrt(x)) + 1):

if x % i == 0:

if x - n * i >= 0 and (x - n * i) % i == 0:

ans = max(ans, i)

if x - n * (x // i) >= 0 and x // i > 0 and ((x - n * (x // i)) % (x // i) == 0):

ans = max(ans, x // i)

print(ans)

So, it reads t, then for each test case, reads x and n.

Initialize ans=1.

Then, it loops i from 1 to sqrt(x), checking if i is a divisor of x.

If i is a divisor, it checks two conditions:

1. x - n * i >=0 and (x - n * i) % i ==0

2. x - n * (x // i) >=0 and x // i >0 and (x - n * (x // i)) % (x // i) ==0

And updates ans accordingly.

Wait, why is it checking both i and x//i?

Because for each i that divides x, x//i is also a divisor of x.

So, it's essentially iterating through all divisors of x, but only up to sqrt(x), and checking both i and x//i.

Now, in our earlier reasoning, we concluded that we need to choose the largest divisor d of x that is <= x / n.

So, in this code, it seems to be iterating through all possible divisors and checking certain conditions, then taking the maximum.

But according to our earlier reasoning, it should be sufficient to iterate through all divisors of x and select the largest one that is <= x / n.

So, let's see if this code is doing that.

In the first condition:

if x - n * i >=0 and (x - n * i) % i ==0:

This seems to be checking if x - n * i is divisible by i.

Wait, x - n * i is the remainder after assigning n * i to the sub-problems.

Wait, no.

Wait, if each sub-problem has difficulty at least i, then the total difficulty is at least n * i.

And the remaining difficulty is x - n * i, which should be divisible by i, so that it can be distributed among the sub-problems.

Wait, but in our earlier reasoning, we concluded that d must divide x, and d <= x / n.

So, perhaps this condition is ensuring that.

But, according to our earlier reasoning, it's sufficient to check that d divides x and d <= x / n.

So, why is the code checking (x - n * i) % i == 0?

Well, let's see.

x - n * i must be divisible by i, which is equivalent to saying that x / i - n is an integer divisible by i.

Wait, I'm getting confused.

Let me think differently.

Suppose d is a divisor of x, and d <= x / n.

Then, x / d is an integer, say k.

We need to have n positive integers, each a multiple of d, summing up to x.

That is, d * a1 + d * a2 + ... + d * an = x, where ai >=1.

So, a1 + a2 + ... + an = x / d.

And each ai >=1.

So, the minimal sum is n, and maximal is x - n +1, I think.

But, in this code, it's checking (x - n * i) % i ==0.

Let me see.

x - n * i is the remaining difficulty after assigning i to each sub-problem.

Then, this remaining difficulty should be divisible by i, so that it can be distributed among the sub-problems.

Wait, but if each sub-problem already has i, and the remaining difficulty is distributed among them, then yes, the remaining difficulty should be divisible by i.

So, this seems to be a correct condition.

Similarly, it checks the same for x // i.

So, overall, it seems to be correctly implementing the logic to find the largest divisor d of x that is <= x / n.

Hence, the code should be correct.

Therefore, Correctness: **True**