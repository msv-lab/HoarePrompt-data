Alright, I've got this problem to solve. Let's see what it's about. So, there are two players, Alice and Bob, playing a game on an array of integers. Alice starts with an empty array c. In each turn, Alice picks an element from a, appends it to c, and deletes it from a. Bob, on his turn, picks an element from a, and just deletes it from a. The game ends when a is empty, and the score is the MEX of c, which is the smallest non-negative integer not in c.

Alice wants to maximize the MEX, and Bob wants to minimize it. Both play optimally. I need to find the final score, given that both play their best possible moves.

First, I need to understand what MEX is. MEX of an array is the smallest non-negative integer not present in it. For example, MEX of [0,1,2] is 3, MEX of [0,1,3] is 2, and MEX of [1,2,3] is 0.

So, in this game, Alice is trying to make c have as many small non-negative integers as possible, to maximize the MEX. Bob, however, is trying to hinder Alice by removing elements from a that could potentially be useful to Alice.

Since Alice can both pick and append elements to c, while Bob can only pick and delete, Alice has more control over what ends up in c. But Bob can still strategy his deletions to prevent Alice from achieving a higher MEX.

I need to think about how to model their optimal play.

Let me consider the properties of MEX. It's all about having a complete sequence of non-negative integers starting from 0 up to some number, and the MEX is the first missing one.

So, if c contains all numbers from 0 to k-1, but not k, then MEX is k.

Alice wants to maximize k, and Bob wants to minimize it.

Given that, perhaps I can think in terms of which numbers Alice can guarantee to include in c.

Let me consider the frequency of each number in a. If a number appears multiple times, that might affect strategies.

Since Alice can choose which element to pick and append to c, she can be selective. Bob, however, just deletes an element.

I need to consider the sequence of moves and how they affect the availability of numbers for Alice.

This seems complex. Maybe there's a smarter way to approach this.

Let me consider the total number of moves. There are n elements, and each turn consists of one deletion. Alice moves first, and on her turn, she both picks and appends an element to c, and deletes it from a. Bob just deletes an element.

Wait, no. On Alice's turn, she picks an element from a, appends it to c, and deletes it from a. On Bob's turn, he picks an element from a and deletes it from a.

So, in total, there are n moves, alternating between Alice and Bob, starting with Alice.

If n is odd, Alice makes the last move; if n is even, Bob makes the last move.

But more importantly, I need to think about which elements end up in c.

Alice wants to maximize the MEX of c, which means she wants c to contain as many small non-negative integers as possible.

Bob wants to minimize the MEX of c, which means he wants to prevent Alice from including certain small integers in c.

So, perhaps I can think in terms of which numbers are critical for achieving a higher MEX.

Let's consider that MEX depends on the presence of numbers 0,1,2,... in c.

Alice will try to include as many of these small numbers in c, while Bob will try to remove them from a to make them unavailable to Alice.

Wait, but Alice picks and appends to c, so Bob can't directly prevent Alice from picking a number if it's still in a.

However, Bob can choose to delete numbers that Alice might want to include in c, making them unavailable.

So, it's a strategic game where Alice tries to preserve the numbers she needs, and Bob tries to disrupt that.

This seems like a game where the frequency of numbers matters.

Let's think about the frequency of each number in a.

Suppose a number x appears f(x) times in a.

Alice and Bob will be picking elements in turns, so the order in which they pick elements can affect who gets to pick which elements.

Wait, but since a is being modified each turn, it's dynamic.

This seems complicated to model directly.

Maybe I can think in terms of the minimum number of times each number needs to be included in c to achieve a certain MEX.

For example, to have MEX = k, c must contain all numbers from 0 to k-1.

So, Alice needs to ensure that for each i from 0 to k-1, at least one i is included in c.

But Bob can try to prevent that by deleting i's from a before Alice can pick them.

So, for each i from 0 to k-1, the number of i's in a is f(i).

Alice and Bob will be picking elements in turns, so the number of times Alice can pick an i is ceil(f(i)/2), assuming Bob tries to minimize the number of i's Alice can pick.

Wait, perhaps.

If there are f(i) instances of i in a, and Alice and Bob alternate picking elements, with Alice starting, then the number of i's that Alice can pick is ceil(f(i)/2), because she gets to pick first.

For example, if f(i) = 1, Alice picks it.

If f(i) = 2, Alice picks one, Bob picks one.

If f(i) = 3, Alice picks two, Bob picks one.

And so on.

So, for each i, Alice can get ceil(f(i)/2) instances of i.

Now, since c is the array she builds by appending these picks, the number of i's in c is ceil(f(i)/2).

But MEX depends on whether all i's from 0 to k-1 are present in c at least once.

So, for each i from 0 to k-1, if ceil(f(i)/2) >= 1, then Alice can include at least one i in c.

Otherwise, if ceil(f(i)/2) == 0, which happens only if f(i) = 0, meaning i is not present in a at all.

Wait, but if f(i) >=1, then ceil(1/2) = 1, so Alice can pick at least one i.

Only if f(i) = 0, ceil(0/2) = 0, meaning Alice can't pick any i.

So, for MEX = k, Alice needs to have at least one of each i from 0 to k-1 in c.

Which is possible only if f(i) >=1 for all i from 0 to k-1.

But Bob can try to prevent this by deleting some i's.

Wait, but according to the above, as long as f(i) >=1, Alice can pick at least one i.

Unless Bob can somehow prevent Alice from picking i.

Wait, maybe I need to think differently.

Let me consider that for each i, the number of times Alice can pick i is ceil(f(i)/2).

So, if f(i) >=1, ceil(f(i)/2) >=1, meaning Alice can pick at least one i.

Therefore, as long as f(i) >=1, Alice can include i in c.

Hence, for MEX = k, Alice needs to have all i from 0 to k-1 present in c, which requires f(i) >=1 for each i in 0 to k-1.

Bob, on the other hand, can try to delete some i's to make f(i) =0 for some i, but if f(i) >=1, Alice can always pick at least one i.

Wait, but if Bob deletes an i, f(i) decreases.

But Alice picks first, so if f(i) >=1 initially, Alice can pick it on her first turn, before Bob can delete it.

Wait, but the game progresses with alternating turns.

Wait, no, not quite.

Wait, in each turn:

- Alice picks an element from a, appends it to c, and deletes it from a.

- Bob picks an element from a, deletes it from a.

They alternate, starting with Alice.

The game ends when a is empty.

So, the sequence of moves is:

- Alice picks an element, appends to c, deletes from a.

- Bob picks an element, deletes from a.

- Repeat until a is empty.

So, in each pair of turns (Alice and Bob), two elements are removed from a.

If n is even, there are n/2 such pairs.

If n is odd, there are (n-1)/2 pairs, plus one final turn for Alice.

Now, considering this, Bob can choose to delete any element he wants, trying to minimize the MEX.

Alice wants to maximize the MEX, so she will try to include as many small integers in c as possible.

So, perhaps I can think in terms of which elements Alice can guarantee to include in c.

Given that Alice picks first, and she can choose which element to pick and include in c, while Bob can only delete elements.

But Bob can choose to delete elements that Alice might need.

Wait, but Alice chooses first, so perhaps she can secure the elements she needs.

Let me consider a small example to see.

Take the first test case from the example:

n=4

a=[0,0,1,1]

Possible game:

- Alice picks 1, appends to c=[1], deletes from a, so a=[0,0,1]

- Bob picks 0, deletes from a, so a=[0,1]

- Alice picks 0, appends to c=[1,0], deletes from a, so a=[1]

- Bob picks 1, deletes from a, so a=[]

Final c=[1,0], MEX=2

Another possible game:

- Alice picks 0, appends to c=[0], deletes from a, so a=[0,1,1]

- Bob picks 1, deletes from a, so a=[0,1]

- Alice picks 1, appends to c=[0,1], deletes from a, so a=[0]

- Bob picks 0, deletes from a, so a=[]

Final c=[0,1], MEX=2

Another possible game:

- Alice picks 1, appends to c=[1], deletes from a, so a=[0,0,1]

- Bob picks 1, deletes from a, so a=[0,0]

- Alice picks 0, appends to c=[1,0], deletes from a, so a=[0]

- Bob picks 0, deletes from a, so a=[]

Final c=[1,0], MEX=2

Seems like regardless of how they play, c ends up with [0,1], MEX=2.

Is there a way for Bob to make MEX less than 2? It doesn't seem so, because Alice can always include both 0 and 1 in c, since they are both present multiple times.

Wait, but in this case, f(0)=2, f(1)=2.

Alice can get ceil(2/2)=1 for each, so she can include at least one 0 and one 1 in c.

Hence, MEX=2.

Okay, seems consistent.

Another test case:

n=4

a=[0,1,2,3]

Possible game:

- Alice picks 0, appends to c=[0], deletes from a, so a=[1,2,3]

- Bob picks 1, deletes from a, so a=[2,3]

- Alice picks 2, appends to c=[0,2], deletes from a, so a=[3]

- Bob picks 3, deletes from a, so a=[]

Final c=[0,2], MEX=1

Another possible game:

- Alice picks 1, appends to c=[1], deletes from a, so a=[0,2,3]

- Bob picks 0, deletes from a, so a=[2,3]

- Alice picks 2, appends to c=[1,2], deletes from a, so a=[3]

- Bob picks 3, deletes from a, so a=[]

Final c=[1,2], MEX=0

Another possible game:

- Alice picks 2, appends to c=[2], deletes from a, so a=[0,1,3]

- Bob picks 0, deletes from a, so a=[1,3]

- Alice picks 1, appends to c=[2,1], deletes from a, so a=[3]

- Bob picks 3, deletes from a, so a=[]

Final c=[2,1], MEX=0

In this case, it seems possible for Bob to make MEX=0, by deleting 0, so that Alice doesn't include 0 in c.

Wait, but in the first possible game, MEX=1 is achieved.

So, the optimal play would be to achieve the highest possible MEX, which is 1 in this case.

Wait, but in the first possible game, c=[0,2], MEX=1.

In the other games, c=[1,2] or [2,1], MEX=0.

So, Alice can achieve MEX=1 by including 0 in c.

Bob can try to prevent that by deleting 0, but if Alice picks 0 in her turn, she can include it in c.

Wait, in the first game, Alice picks 0 first, includes it in c, and then Bob can't delete it anymore.

Hence, c will always have 0, and MEX=1.

Wait, but in the other games, Alice picks 1 or 2 first, and then Bob deletes 0, making it unavailable for Alice to include in c.

But Alice can choose to pick 0 first, ensuring that it's included in c.

Hence, the optimal strategy for Alice is to pick 0 first, include it in c, and then Bob can't delete it anymore.

Therefore, MEX=1.

So, in this case, the answer should be 1.

But in the program's output, it's 1, which matches.

Another test case:

n=2

a=[1,1]

Possible game:

- Alice picks 1, appends to c=[1], deletes from a, so a=[1]

- Bob picks 1, deletes from a, so a=[]

Final c=[1], MEX=0

Another possible game:

- Alice picks 1, appends to c=[1], deletes from a, so a=[1]

- Bob picks 1, deletes from a, so a=[]

Final c=[1], MEX=0

Only one possible game, MEX=0.

Which matches the program's output.

So, seems consistent.

Now, looking at the provided program:

def func():

T = int(input())

for _ in range(T):

S = int(input())

N = list(map(int, input().split()))

N.sort()

cur = -1

M = {}

for num in N:

if num > cur:

if num > cur + 1:

cur += 1

break

cur = num

M[cur] = 1

else:

M[cur] += 1

if sum([M[k] for k in M.keys()]) == S:

cur += 1

for i in range(cur):

if M[i] <= i:

cur = i

break

print(cur)

Let's see what this program is doing.

It reads T test cases.

For each test case:

- Read n (S in the code)

- Read the array a (N in the code)

- Sort the array

- Initialize cur = -1 and a dictionary M

- Iterate through the sorted array:

- If num > cur, set cur = num and M[cur] =1

- Else, increment M[cur]

- If the sum of M.values() equals S, increment cur

- Then, iterate from 0 to cur-1:

- If M[i] <= i, set cur = i and break

- Print cur

Wait, this seems a bit convoluted.

Let me try to understand it step by step.

First, it sorts the array.

Then, it iterates through the sorted array, maintaining a current value cur, starting from -1.

For each number in the sorted array:

- If num > cur, set cur to num and start counting occurrences in M[cur]

- Else, increment M[cur]

Then, if the total count of M values equals S, increment cur.

Finally, check for each i from 0 to cur-1 if M[i] <= i, and if so, set cur = i and break.

Print cur.

This seems to be trying to calculate some kind of MEX, but I'm not entirely sure how.

Let me see how it works for the first test case:

n=4

a=[0,0,1,1]

Sorted: [0,0,1,1]

Initialize cur=-1, M={}

First num=0 > cur=-1, so cur=0, M[0]=1

Second num=0 == cur=0, so M[0] +=1 -> M[0]=2

Third num=1 > cur=0, so cur=1, M[1]=1

Fourth num=1 == cur=1, so M[1] +=1 -> M[1]=2

Now, sum of M.values() = 2 + 2 = 4 == S=4, so cur +=1 -> cur=2

Then, for i in range(0,2):

i=0: M[0]=2 > 0, so no change

i=1: M[1]=2 >1, so no change

So, cur=2, which matches the expected output.

Second test case:

n=4

a=[0,1,2,3]

Sorted: [0,1,2,3]

Initialize cur=-1, M={}

First num=0 > cur=-1, cur=0, M[0]=1

Second num=1 > cur=0, cur=1, M[1]=1

Third num=2 > cur=1, cur=2, M[2]=1

Fourth num=3 > cur=2, cur=3, M[3]=1

Sum of M.values()=1+1+1+1=4==S=4, so cur +=1 -> cur=4

Then, for i in range(0,4):

i=0: M[0]=1 >0

i=1: M[1]=1 ==1

Wait, M[1]=1 <=1, so set cur=1 and break

So, cur=1, which matches the expected output.

Third test case:

n=2

a=[1,1]

Sorted: [1,1]

Initialize cur=-1, M={}

First num=1 > cur=-1, cur=1, M[1]=1

Second num=1 == cur=1, M[1]=2

Sum of M.values()=2==S=2, so cur +=1 -> cur=2

Then, for i in range(0,2):

i=0: M[0] is not present, which would be considered as 0, and 0 <=0, so set cur=0 and break

So, cur=0, which matches the expected output.

Okay, so it seems to work for these cases.

But is this logic correct in general?

Let me try to understand what this code is doing.

It's iterating through the sorted array and grouping consecutive numbers that are equal, counting how many times each group appears.

Then, if the total count of these groups equals n, it increments cur.

Then, it checks for each i from 0 to cur-1 if the count of i is greater than i.

If not, it sets cur to i.

Finally, it prints cur.

Wait, I'm still not fully grasping this logic.

Let me think differently.

Earlier, I thought that for MEX = k, Alice needs to have all i from 0 to k-1 in c at least once.

Given that Alice can pick ceil(f(i)/2) instances of each i, she can include at least one i in c if f(i) >=1.

Hence, as long as f(i) >=1, Alice can include i in c.

Bob can try to delete i's to make f(i)=0, but if f(i) >=1 initially, Alice can pick at least one i before Bob can delete all of them.

Wait, but in reality, Bob can delete elements in his turns, but Alice picks first.

So, if f(i)=1, Alice can pick it on her first turn, include it in c, and Bob can't delete it anymore.

If f(i)=2, Alice picks one, Bob picks one, so Alice includes one in c.

If f(i)=3, Alice picks two, Bob picks one, so Alice includes two in c.

And so on.

Hence, for each i, Alice can include ceil(f(i)/2) instances in c.

To achieve MEX =k, Alice needs to have at least one of each i from 0 to k-1 in c.

Which requires that ceil(f(i)/2) >=1 for each i from 0 to k-1.

Which is equivalent to f(i) >=1 for each i from 0 to k-1.

Because ceil(1/2)=1, ceil(2/2)=1, etc.

Hence, as long as each i from 0 to k-1 appears at least once in a, Alice can include at least one in c.

Bob can try to prevent this by deleting some i's, but if f(i) >=1, Alice can pick it before Bob can delete it.

Hence, the MEX is determined by the smallest i that doesn't appear in a at all, or where ceil(f(i)/2)=0, which only happens if f(i)=0.

Wait, but ceil(f(i)/2) is at least 1 if f(i)>=1.

Hence, MEX = the smallest i such that f(i)=0.

Wait, is that correct?

Wait, no.

Because ceil(f(i)/2) >=1 for f(i)>=1.

Hence, Alice can include at least one of each i that has f(i)>=1.

Hence, the MEX is the smallest i such that f(i)=0.

Wait, but in the second test case, f(0)=1, f(1)=1, f(2)=1, f(3)=1.

So, all i from 0 to 3 appear at least once, but the program outputs MEX=1.

Wait, but according to my previous logic, MEX should be 4, but it's 1.

Wait, perhaps I'm missing something.

Wait, in the second test case, n=4, a=[0,1,2,3].

Sorted: [0,1,2,3]

cur=-1, M={}

num=0 > cur=-1 => cur=0, M[0]=1

num=1 > cur=0 => cur=1, M[1]=1

num=2 > cur=1 => cur=2, M[2]=1

num=3 > cur=2 => cur=3, M[3]=1

sum(M.values())=4==S=4 => cur +=1 => cur=4

Then, for i in 0,1,2,3:

M[0]=1 >0

M[1]=1 ==1 => set cur=1 and break

Hence, cur=1

But according to my earlier logic, since all i from 0 to 3 appear at least once, Alice can include all of them in c, so MEX should be 4.

But according to the program, it's 1.

Wait, but in the example, the output is 1 for this test case.

But according to my earlier reasoning, it should be 4.

Wait, perhaps my reasoning is flawed.

Wait, perhaps I need to consider the game play more carefully.

Let me simulate the game again.

n=4, a=[0,1,2,3]

Possible game:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob picks 3, a=[]

Final c=[0,2], MEX=1

Another possible game:

- Alice picks 1, c=[1], a=[0,2,3]

- Bob picks 0, a=[2,3]

- Alice picks 2, c=[1,2], a=[3]

- Bob picks 3, a=[]

Final c=[1,2], MEX=0

Another possible game:

- Alice picks 2, c=[2], a=[0,1,3]

- Bob picks 0, a=[1,3]

- Alice picks 1, c=[2,1], a=[3]

- Bob picks 3, a=[]

Final c=[2,1], MEX=0

So, depending on how Alice and Bob play, MEX can be 0 or 1.

The optimal play for Alice is to pick 0 first, ensuring that 0 is in c, and then不管Bob does, she can achieve MEX=1.

Hence, the answer is 1.

But according to my earlier logic, since all i from 0 to 3 appear at least once, Alice should be able to include all of them in c.

But in reality, Bob can prevent Alice from including some of them.

Wait, but in this specific case, if Alice picks 0 first, Bob can't do anything about it.

Hence, 0 is in c.

Then, regardless of what Bob does, Alice can include one more number in c.

Hence, c will have at least 0 and one other number.

Hence, MEX is at least 1.

But depending on what Alice picks after, MEX can be 1 or 0.

Hence, the optimal MEX is 1.

Wait, but according to my earlier assumption, MEX should be the smallest i not present in a, but that's not accurate.

Wait, perhaps MEX is the smallest i such that the number of times Alice can include i in c is less than or equal to i.

Wait, that might not make sense.

Wait, perhaps MEX is the smallest i such that ceil(f(i)/2) <= i.

Wait, but that doesn't seem right.

Wait, in the second test case, for i=0, ceil(f(0)/2)=1 >0

for i=1, ceil(f(1)/2)=1 >1? Wait, 1 >1 is False.

Wait, perhaps MEX is the smallest i where ceil(f(i)/2) <=i.

Wait, in the second test case, for i=0, ceil(1/2)=1 >0

for i=1, ceil(1/2)=1 >1? 1 >1 is False, so MEX=1

In the first test case, a=[0,0,1,1]

for i=0, ceil(2/2)=1 >0

for i=1, ceil(2/2)=1 >1? 1 >1 False, so MEX=2

In the third test case, a=[1,1]

for i=0, f(0)=0, ceil(0/2)=0 <=0, so MEX=0

This seems to match the outputs.

Hence, the MEX is the smallest i such that ceil(f(i)/2) <=i.

Wait, but in the second test case, ceil(f(1)/2)=1 <=1, so MEX=1

In the first test case, ceil(f(0)/2)=1 >0, ceil(f(1)/2)=1 >1 False, so MEX=2

Wait, but for i=1, ceil(f(1)/2)=1 >1 is False, so MEX=2

Wait, but in the second test case, ceil(f(1)/2)=1 >1 is False, so MEX=1

Wait, perhaps it's the smallest i where ceil(f(i)/2) <=i.

Wait, in the second test case, for i=0, ceil(1/2)=1 >0

for i=1, ceil(1/2)=1 >1 False, so MEX=1

In the first test case, for i=0, ceil(2/2)=1 >0

for i=1, ceil(2/2)=1 >1 False, so MEX=2

In the third test case, for i=0, ceil(0/2)=0 <=0, so MEX=0

This seems consistent with the outputs.

Hence, the MEX is the smallest i where ceil(f(i)/2) <=i.

Hence, to compute this, we can:

- Count the frequency of each i in a.

- For each i starting from 0:

- If ceil(f(i)/2) <=i, then MEX=i

- Else, check the next i

- If all i satisfy ceil(f(i)/2) >i, then MEX is the next i after the maximum i in a.

But in practice, since a contains numbers up to n-1, and n can be up to 2e5, we need an efficient way to compute this.

Hence, in the program, it seems to be implementing something similar.

It sorts the array and groups consecutive equal numbers, counting how many times each group appears.

Then, it checks for each i from 0 to cur if the count is greater than i.

Wait, but in the code, it's summing M.values() and comparing to S.

I think I see now.

The variable M keeps track of how many times each i appears, but in a specific way.

In the loop:

for num in N:

if num > cur:

if num > cur +1:

cur +=1

break

cur = num

M[cur] =1

else:

M[cur] +=1

This seems to be counting the number of times each i appears in a, but only for consecutive numbers.

Wait, but a is sorted, so consecutive numbers are grouped.

Wait, perhaps it's counting the number of times each i appears in a, but considering only the first occurrence of each group.

Wait, I'm getting confused.

Let me look at the first test case again.

n=4

a=[0,0,1,1]

sorted: [0,0,1,1]

cur=-1, M={}

num=0 > cur=-1:

num > cur, and num > cur+1? 0 > -1+1=0? 0 >0? No.

Hence, set cur=0, M[0]=1

next num=0 == cur=0:

M[cur] +=1 -> M[0]=2

next num=1 > cur=0:

num > cur, and num > cur+1? 1 >0+1=1? 1>1? No.

Hence, set cur=1, M[1]=1

next num=1 == cur=1:

M[1] +=1 -> M[1]=2

sum(M.values())=4==S=4, so cur +=1 -> cur=2

then, for i in range(0,2):

i=0: M[0]=2 >0

i=1: M[1]=2 >1? 2>1 is True, so no change

Hence, cur=2, which is correct.

In the second test case:

n=4

a=[0,1,2,3]

sorted: [0,1,2,3]

cur=-1, M={}

num=0 > cur=-1:

num > cur, and num > cur+1? 0 > -1+1=0? 0>0? No.

Hence, set cur=0, M[0]=1

num=1 > cur=0:

num > cur, and num > cur+1? 1>0+1=1? 1>1? No.

Hence, set cur=1, M[1]=1

num=2 > cur=1:

num > cur, and num > cur+1? 2>1+1=2? 2>2? No.

Hence, set cur=2, M[2]=1

num=3 > cur=2:

num > cur, and num > cur+1? 3>2+1=3? 3>3? No.

Hence, set cur=3, M[3]=1

sum(M.values())=4==S=4, so cur +=1 -> cur=4

then, for i in range(0,4):

i=0: M[0]=1 >0

i=1: M[1]=1 >1? 1>1 False, set cur=1 and break

Hence, cur=1, which matches the expected output.

In the third test case:

n=2

a=[1,1]

sorted: [1,1]

cur=-1, M={}

num=1 > cur=-1:

num > cur, and num > cur+1? 1>-1+1=0? 1>0? Yes.

Hence, cur +=1 -> cur=0

But then, cur is still -1, because the if condition is num > cur +1, which is 1>0, so cur +=1 -> cur=0

Then, cur=0

But in the code, it sets cur=num, which is 1.

Wait, no, in the code:

if num > cur:

if num > cur +1:

cur +=1

break

cur = num

M[cur] =1

So, for num=1 > cur=-1:

if 1 > -1 +1=0? 1>0? Yes.

Hence, cur +=1 -> cur=0

then, cur = num -> cur=1

M[1]=1

next num=1 == cur=1:

M[1] +=1 -> M[1]=2

sum(M.values())=2==S=2, so cur +=1 -> cur=2

then, for i in range(0,2):

i=0: M[0] does not exist, considered as 0 <=0, set cur=0 and break

Hence, cur=0, which matches the expected output.

Wait, but in the code, it's checking M[i] <=i for i in range(cur).

In the second test case, cur=4, so i in 0,1,2,3:

i=0: M[0]=1 >0

i=1: M[1]=1 ==1, which is not >1, so set cur=1 and break

Hence, cur=1

Similarly, in the first test case, cur=2, i in 0,1:

i=0: M[0]=2 >0

i=1: M[1]=2 >1, so no change, cur remains 2

Hence, the logic seems to be working.

But what is this logic actually doing?

It seems to be tracking the maximum i such that all previous j (0 to i-1) satisfy M[j] >j.

Wait, in the second test case, M={0:1,1:1,2:1,3:1}

For i=0: M[0]=1 >0

i=1: M[1]=1 ==1, not >1, so set cur=1

Hence, MEX=1

In the first test case, M={0:2,1:2}

For i=0: M[0]=2 >0

i=1: M[1]=2 >1

Hence, cur=2

In the third test case, M={1:2}

For i=0: M[0]=0 <=0, set cur=0

Hence, MEX=0

So, it's setting MEX to the smallest i where M[i] <=i.

Hence, the condition is M[i] <=i.

Hence, MEX is the smallest i where the number of times Alice can include i in c is less than or equal to i.

Given that the number of times Alice can include i in c is ceil(f(i)/2).

Hence, MEX is the smallest i where ceil(f(i)/2) <=i.

Which aligns with the earlier observation.

Hence, the program is correctly implementing this logic.

Hence, the answer is Correctness: **True**

**Final Solution**
To solve this problem, we need to determine the final score of a game where Alice and Bob play optimally on an array of integers, and the score is defined as the MEX of the array constructed by Alice.

## Approach

1. **Understanding MEX**: MEX of an array is the smallest non-negative integer not present in it.
2. **Optimal Play Analysis**:
   - Alice wants to maximize the MEX.
   - Bob wants to minimize the MEX.
   - Alice can select and append elements to her array `c`, while Bob can only delete elements.
3. **Key Insight**:
   - Alice can include at least `ceil(f(i)/2)` instances of each number `i` in her array `c`, where `f(i)` is the frequency of `i` in the original array.
   - To achieve MEX = `k`, Alice needs to have all numbers from 0 to `k-1` in her array `c` at least once.
4. **Algorithm**:
   - Count the frequency of each number in the array.
   - Determine the smallest number `i` where the ceiling of its frequency divided by 2 is less than or equal to `i`. This `i` is the MEX.

## Solution Code

```python
def func():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    idx = 0
    T = int(data[idx])
    idx += 1
    for _ in range(T):
        S = int(data[idx])
        idx += 1
        N = list(map(int, data[idx:idx+S]))
        idx += S
        N.sort()
        cur = -1
        M = {}
        for num in N:
            if num > cur:
                if num > cur + 1:
                    cur += 1
                    break
                cur = num
                M[cur] = 1
            else:
                M[cur] += 1
        if sum(M.values()) == S:
            cur += 1
        for i in range(cur):
            if M.get(i, 0) <= i:
                cur = i
                break
        print(cur)

func()
```

## Explanation

1. **Reading Input**:
   - Read the number of test cases `T`.
   - For each test case, read `n` (the size of the array) and the array `a`.

2. **Processing Each Test Case**:
   - **Sort the array** `a` to handle it in a ordered manner.
   - Initialize `cur` to -1 and an empty dictionary `M` to count occurrences.
   - Traverse the sorted array:
     - If the current number is greater than `cur`:
       - If it is greater than `cur + 1`, increment `cur` and stop.
       - Else, set `cur` to this number and start counting its occurrences.
     - Else, increment the count of `cur` in `M`.
   - If the sum of counts in `M` equals `n`, increment `cur`.
   - Check for each `i` from 0 to `cur - 1`:
     - If the count of `i` in `M` is less than or equal to `i`, set `cur` to `i` and break.

3. **Output the Result**:
   - Print the final value of `cur`, which is the MEX achieved when both players play optimally.