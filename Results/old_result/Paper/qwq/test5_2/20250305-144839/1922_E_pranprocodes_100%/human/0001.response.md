Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find an array of integers, with at most 200 elements, such that the number of increasing subsequences in it is exactly X, where X can be up to 10^18. If it's not possible, I should output -1. There are multiple test cases, up to 1000 of them.

First, I need to understand what an increasing subsequence is. From the problem statement, it's a sequence obtained by removing some elements from the array without changing the order, and the remaining elements are strictly increasing. Also, different positions can have the same values, but they are considered different subsequences if their positions differ.

So, for example, in the array [0, 1, 0], the increasing subsequences are:

- Empty subsequence

- [0] (first element)

- [0] (third element)

- [1]

- [0,1] (first and second elements)

That's 5 subsequences, which matches the second test case in the example.

Another example: [2,2,3,4,2]. The increasing subsequences would include:

- Empty

- [2] (first)

- [2] (second)

- [3]

- [4]

- [2] (fifth)

- [2,3] (first and third)

- [2,4] (first and fourth)

- [2,3] (second and third)

- [2,4] (second and fourth)

- [2,3,4] (first, third, and fourth)

- [2,3,4] (second, third, and fourth)

- And so on.

This seems to total 13, again matching the third test case.

So, my task is to construct such an array for a given X.

First, I need to find a way to calculate the number of increasing subsequences for a given array. Then, I need to find a way to construct an array that has exactly X such subsequences.

Let me think about how to calculate the number of increasing subsequences.

Let's denote dp[i] as the number of increasing subsequences ending with the i-th element.

Then, dp[i] = 1 (the subsequence consisting only of a[i]) plus the sum of dp[j] for all j < i where a[j] < a[i].

So, the total number of increasing subsequences is the sum of dp[i] for all i.

This seems efficient enough for arrays of size up to 200.

But for constructing an array with exactly X increasing subsequences, I need a smarter approach, especially since X can be up to 10^18, which is a very large number.

I need to find a way to maximize the number of increasing subsequences for a given array size.

Let me consider the array where each element is larger than the previous one, i.e., strictly increasing.

In this case, every subset of the array is an increasing subsequence.

The number of subsets of an array of size N is 2^N, including the empty set.

But according to the problem, the empty subsequence is also considered, so for a strictly increasing array, the number of increasing subsequences is 2^N.

Wait, but in the problem statement, it's mentioned that the empty subsequence is also increasing, which aligns with this.

So, for a strictly increasing array of size N, the number of increasing subsequences is 2^N.

But in the examples provided:

- For X=2, the array is [0], which has 2 increasing subsequences: empty and [0].

- For X=5, the array is [0,1,0], which has 5 increasing subsequences, as listed earlier.

- For X=13, the array is [2,2,3,4,2], which has 13 increasing subsequences.

- For X=37, the array is [-1,-1,0,0,2,3,-1], which should have 37 increasing subsequences.

So, in the first case, X=2 corresponds to 2^1=2, which is a strictly increasing array of size 1.

In the second case, X=5 is not a power of 2, so the array isn't strictly increasing.

This suggests that for X not being a power of 2, we need to construct arrays that are not strictly increasing.

I need to find a way to construct arrays that allow for a specific number of increasing subsequences, potentially by combining elements in a way that some elements can be included or excluded in the subsequences.

Let me consider binary representation of X.

Since 2^N gives the number of increasing subsequences for a strictly increasing array of size N, perhaps I can represent X in binary and construct the array accordingly.

Wait, but X can be up to 10^18, which is 60 bits. But the array can have at most 200 elements, which would allow up to 2^200 increasing subsequences, which is way larger than 10^18.

But perhaps there's a smarter way to construct the array to achieve exactly X increasing subsequences without using a large N.

Let me think differently.

Suppose I build the array step by step, and at each step, decide whether to add a new element that is larger than all previous elements or not.

If I add an element larger than all previous ones, it will increase the number of increasing subsequences by doubling the current number, because for each existing subsequence, I can choose to include or exclude this new element.

Wait, that sounds promising.

Let me formalize this.

Let’s say I have an array of size K, and I add a new element that is larger than all previous elements.

Then, for each existing increasing subsequence, I can choose to include this new element or not, which doubles the number of increasing subsequences.

Additionally, the new element itself can form a subsequence, but that's already included in the doubling.

So, adding a new largest element doubles the number of increasing subsequences.

On the other hand, if I add an element that is not larger than all previous elements, say it's smaller than some of them, then it can only be added to those subsequences where the last element is smaller than this new element.

But this seems complicated.

Wait, perhaps I can think in terms of binary representation.

If X is 2^N, then I can just create a strictly increasing array of size N.

If X is not a power of 2, I can represent it as a sum of powers of 2.

But in this problem, since subsequences are counted based on their positions, not just their values, I need to be careful.

Wait, in the array [0,1,0], the number of increasing subsequences is 5, which is 2^2 + 1.

But I need to find a general way to construct the array for any X.

Let me consider the following approach:

Start with an empty array, which has one increasing subsequence: the empty subsequence.

Then, iteratively add elements to the array in such a way that the number of increasing subsequences is built up to X.

At each step, when adding a new element, decide whether to make it larger than all previous elements or not.

If I make it larger than all previous elements, the number of increasing subsequences doubles, because for each existing subsequence, I can choose to include or exclude this new element.

If I make it smaller than or equal to some previous elements, it's more complicated, but perhaps I can control the increase in the number of subsequences.

Wait, maybe I can think in terms of binary representation.

Suppose X is represented in binary as the sum of powers of 2.

For example, X=5 is 101 in binary, which is 4 + 1.

So, perhaps I can construct an array that combines subsequences corresponding to these powers of 2.

But I need to find a way to combine them without overlapping in a way that the total number of increasing subsequences is exactly X.

Alternatively, perhaps I can use the fact that adding a new largest element doubles the number of increasing subsequences, and adding a new smallest element adds one for each position where it can be placed.

Wait, maybe I need to consider the contribution of each element to the total count of increasing subsequences.

Let me try to formalize this.

Let’s denote the array as a sequence of elements a1, a2, ..., an.

Let dp[i] be the number of increasing subsequences ending with ai.

Then, the total number of increasing subsequences is the sum of dp[i] for all i.

Now, if I add a new element ak, which is larger than all previous elements, then dp[k] = sum(dp[1 to k-1]) + 1.

But since it's larger than all previous elements, dp[k] = sum(dp[1 to k-1]) + 1.

And the new total is the previous total plus dp[k].

But sum(dp[1 to k-1]) is the previous total minus the number of subsequences not including any element.

Wait, this seems messy.

Let me try a different approach.

Suppose I build the array by adding elements one by one, and keep track of how the number of increasing subsequences changes.

I can decide, for each new element, whether to make it larger than all previous elements (doubling the number of subsequences) or to make it smaller, adding a certain number of new subsequences.

But managing this precisely to reach exactly X seems tricky.

Wait, perhaps I can build the array in reverse.

Start with an empty array, with one subsequence (the empty one).

Then, decide to add elements in a way that the number of subsequences is multiplied or added accordingly.

Wait, maybe it's better to think in terms of binary representation.

Let’s consider that each time I add a new largest element, the number of subsequences doubles.

So, starting from 1 (the empty subsequence), adding a largest element makes it 2, then adding another largest element makes it 4, and so on.

If I want to reach a number that is not a power of 2, I need to add elements that don't double the number of subsequences.

For example, adding an element that is not larger than all previous ones won't double the count.

But how can I control the addition to reach exactly X?

Wait, perhaps I can think of it as building a binary number, where each bit corresponds to adding a new largest element or not.

Let’s say I start with 1 (the empty subsequence).

If I add a largest element, the count becomes 2.

If I add another largest element, it becomes 4, then 8, and so on.

If, instead of adding a largest element, I add an element that doesn't change the count significantly, I can control the total.

But I need a more concrete plan.

Let me consider the binary representation of X.

Suppose X is 5, which is 101 in binary.

This corresponds to 4 + 1.

So, perhaps I can construct an array that has parts corresponding to these powers of 2.

For example, to get 4, I can have a strictly increasing subarray of size 2 (which gives 2^2=4 subsequences).

Then, to add 1, I can add an element that doesn't increase the number of subsequences beyond what's needed.

But this is still vague.

Let me try to find a pattern or a general method.

Looking back at the examples:

- X=2: array [0] -> subsequences: empty, [0]

- X=5: array [0,1,0] -> subsequences: empty, [0], [1], [0,1], [0] (second 0)

- X=13: array [2,2,3,4,2] -> some 13 subsequences

- X=37: array [-1,-1,0,0,2,3,-1] -> 37 subsequences

I need to find a general way to construct such arrays.

Another idea: perhaps use the fact that the number of increasing subsequences is the sum of combinations of the array elements that are in increasing order.

But that seems too broad.

Wait, perhaps I can think recursively.

Suppose I have already constructed an array with Y increasing subsequences, and I want to reach X.

If X is greater than Y, I can add a new element to the array to increase the number of subsequences.

But how?

If I add an element larger than all previous elements, the number of increasing subsequences doubles, because for each existing subsequence, I can choose to include or exclude this new element.

Wait, but actually, it's not exactly doubling because the new element itself forms a new subsequence.

Wait, let's calculate it properly.

If I have Y increasing subsequences in the current array, and I add a new largest element, then:

- For each existing subsequence, I can choose to include the new element or not, which would suggest 2*Y subsequences.

- However, including the new element always forms a new subsequence, except for the empty subsequence.

- Wait, actually, the total number of increasing subsequences would be Y (excluding the new element) plus Y (including the new element), but subtracting the empty subsequence which is counted twice.

- Wait, no. The correct way is:

- The total number of increasing subsequences in the new array is the sum of:

- All subsequences of the original array (Y)

- All subsequences of the original array with the new element appended (if they are increasing)

- Since the new element is larger than all previous elements, any subsequence of the original array can have the new element appended to it, forming a new increasing subsequence.

- Therefore, the total number of increasing subsequences is Y (original subsequences) + Y (new subsequences with the new element appended), totaling 2*Y.

- But, the empty subsequence doesn't have the new element appended to it, so it's only counted once.

- Wait, actually, the empty subsequence doesn't change; it remains as is.

- So, the total is indeed 2*Y.

Wait, but in the first test case, X=2, array [0], which has 2 subsequences: empty and [0].

Then, if I add another element larger than 0, say 1, the new array [0,1], which should have 4 subsequences: empty, [0], [1], [0,1].

Which is 2*2=4, as expected.

Similarly, if I add another element larger than 1, say 2, the new array [0,1,2], which should have 8 subsequences: empty, [0], [1], [2], [0,1], [0,2], [1,2], [0,1,2].

Which is 2*4=8.

So, adding a largest element doubles the number of increasing subsequences.

Now, if I add an element that is not larger than all previous elements, say I add 0 to [0,1], making it [0,1,0], then:

- Original subsequences: empty, [0], [1], [0,1]

- New possible subsequences including the new 0:

- [0] (second 0)

- [0,0] (first and third elements, but this is not strictly increasing, so it's invalid)

- [1,0] (decreasing, invalid)

- So, only [0] (second 0) is a valid increasing subsequence.

- Therefore, total increasing subsequences are: empty, [0], [1], [0,1], [0] (second 0)

- Total: 5, which matches the second test case.

So, adding an element that is not larger than all previous elements adds only the new element itself as a new subsequence.

Wait, in this case, adding the second 0 adds only one new subsequence: [0] (second 0).

So, the total increases by 1.

Similarly, if I add another element that is smaller than some previous elements, it will add only its own subsequence, not affecting the others.

Wait, but in the third test case, X=13, array [2,2,3,4,2], which has 13 increasing subsequences.

Let's see:

- Start with [2], subsequences: empty, [2]

- Add 2, [2,2], subsequences: empty, [2], [2], [2,2] (but [2,2] is not strictly increasing, so invalid)

- So, only empty, [2], [2]

- Add 3, [2,2,3], subsequences: empty, [2], [2], [3], [2,3], [2,3]

- Total: 6

- Add 4, [2,2,3,4], subsequences: empty, [2], [2], [3], [2,3], [2,3], [4], [2,4], [2,4], [3,4], [2,3,4], [2,3,4]

- Total: 12

- Add 2, [2,2,3,4,2], subsequences: empty, [2], [2], [3], [2,3], [2,3], [4], [2,4], [2,4], [3,4], [2,3,4], [2,3,4], [2]

- Total: 13

So, adding the last 2 adds only one new subsequence: [2] (fifth element).

This matches the earlier observation that adding an element not larger than all previous elements adds only its own subsequence.

So, to summarize:

- Adding a largest element doubles the number of increasing subsequences.

- Adding an element that is not larger than all previous elements adds only one new subsequence: the subsequence consisting only of that element.

Therefore, I can think of building the array by choosing to either double the number of subsequences or add one, at each step.

Wait, but adding one is only possible when adding an element that is not larger than all previous elements.

But to add such an element, it has to be smaller than or equal to at least one previous element.

In practice, to make it simple, I can choose to add elements in a way that they are either larger than all previous ones or smaller than or equal to all previous ones.

If I add an element larger than all previous ones, the number of increasing subsequences doubles.

If I add an element smaller than or equal to all previous ones, the number of increasing subsequences increases by one.

So, I can model the process as:

- Start with an empty array, having one subsequence: the empty subsequence.

- At each step, choose to either:

- Add a largest element, doubling the number of increasing subsequences.

- Add a smallest element, increasing the number of increasing subsequences by one.

My goal is to reach exactly X increasing subsequences by performing these operations, with the array having at most 200 elements.

Given that X can be up to 10^18, which is 2^60, and an array of 200 elements can have up to 2^200 subsequences, which is way larger, it seems feasible.

Now, I need to find a sequence of operations (adding largest or smallest elements) that reaches exactly X.

This sounds similar to representing X in binary, where each bit corresponds to adding a largest element (doubling) or adding a smallest element (adding one).

Let me think about this.

Suppose I represent X in binary.

Each bit set in X corresponds to adding a smallest element or doubling, depending on the bit position.

Wait, perhaps I can think of it in terms of binary representation.

Let’s consider that I start with 1 (the empty subsequence).

Each time I add a largest element, I double the number of subsequences.

Each time I add a smallest element, I add one to the number of subsequences.

So, to reach X, I can consider its binary representation.

For example, if X=5 (101 in binary), I can:

- Start with 1

- Add a largest element: 2

- Add a smallest element: 3

- Add a largest element: 6

Wait, but 5 in binary is 101, which is 4 + 1.

But in this case, starting from 1:

- Add largest (double to 2)

- Add smallest (add one to 3)

- Add largest (double to 6)

But 6 is more than 5.

This suggests that this approach might not directly correspond to the binary representation.

Alternatively, perhaps I should think of it in terms of the binary representation, where each '1' bit corresponds to adding a smallest element, and moving to the next bit corresponds to adding a largest element.

Wait, let's try this.

For X=5 (101 in binary):

- Start with 1

- Add a largest element: double to 2

- Add a smallest element: add one to 3

- Add a largest element: double to 6

But 6 is more than 5, which is not what we want.

Alternatively, perhaps I should adjust the order.

Let’s try:

- Start with 1

- Add a smallest element: add one to 2

- Add a largest element: double to 4

- Add a smallest element: add one to 5

This works: starting from 1, add smallest (2), add largest (4), add smallest (5).

So, in this case, I first add a smallest element to get from 1 to 2, then add a largest element to double to 4, then add another smallest element to get to 5.

This seems promising.

Similarly, for X=13 (1101 in binary):

- Start with 1

- Add a smallest element: 2

- Add a largest element: 4

- Add a smallest element: 5

- Add a largest element: 10

- Add a smallest element: 11

- Add a largest element: 22

- Add a smallest element: 23

Wait, but 13 is 1101 in binary, which is 8 + 4 + 1.

So, perhaps a better way is to consider the binary representation from the highest bit to the lowest.

Let’s try:

- Start with 1

- Add a largest element: double to 2

- Add a largest element: double to 4

- Add a largest element: double to 8

- Add a smallest element: add one to 9

- Add a smallest element: add one to 10

- ...

This won't reach 13 directly.

Wait, perhaps I need to think recursively.

Let’s consider that to reach X, I can:

- If X is even, it can be reached by adding a largest element to an array that has X/2 subsequences.

- If X is odd, it can be reached by adding a smallest element to an array that has X-1 subsequences.

This seems logical based on the earlier observations.

So, I can build the array by starting from X and working backwards:

- If X is even, the previous step must have been adding a largest element, so the previous X is X/2.

- If X is odd, the previous step must have been adding a smallest element, so the previous X is X-1.

I can keep track of the operations needed to reach X by reversing this process.

For example, for X=5:

- 5 is odd: must have come from X=4 (adding a smallest element)

- 4 is even: must have come from X=2 (adding a largest element)

- 2 is even: must have come from X=1 (adding a largest element)

So, the sequence is: add largest, add largest, add smallest.

But earlier, when I tried adding largest, largest, smallest, I got to 4 + 1 = 5, which matches.

Similarly, for X=13:

- 13 is odd: from X=12 (add smallest)

- 12 is even: from X=6 (add largest)

- 6 is even: from X=3 (add largest)

- 3 is odd: from X=2 (add smallest)

- 2 is even: from X=1 (add largest)

So, the sequence is: add largest, add smallest, add largest, add largest, add smallest.

Wait, but in the example, for X=13, the array has 5 elements, which matches the number of operations here (5 operations correspond to 5 elements).

So, this seems to be a general approach.

I can represent the sequence of operations needed to reach X by repeatedly dividing by 2 if even or subtracting 1 if odd.

Then, the number of elements in the array is the total number of operations performed.

Since X can be up to 10^18, the number of operations can be up to 60 (since 2^60 is approximately 1e18), but the problem allows up to 200 elements, which is more than enough.

Wait, but 10^18 is 2^60, so log2(1e18) is about 60 operations in the worst case, which is well below 200.

So, this should work.

Now, I need to implement this logic.

I need to build the array by performing these operations in sequence.

I need to decide how to assign values to the array elements based on whether I'm adding a largest or smallest element.

Let’s consider that I maintain two variables: max_val and min_val.

- Initially, max_val is some large value, and min_val is some small value.

- When adding a largest element, set the element to max_val, then decrease max_val by 1.

- When adding a smallest element, set the element to min_val, then increase min_val by 1.

This ensures that adding a largest element is always larger than all previous elements, and adding a smallest element is always smaller than or equal to all previous elements.

Wait, to make it strictly increasing when adding largest elements, but adding smallest elements should be smaller than or equal to all previous elements.

But in the problem, the array can have duplicates, as long as the subsequences are strictly increasing.

So, when adding a smallest element, it should be smaller than or equal to all previous elements, but to make it strictly increasing, we need to ensure that in the subsequence, elements are strictly increasing.

So, perhaps I should choose values accordingly.

Wait, perhaps it's better to use decreasing values for adding largest elements and increasing for smallest elements.

Wait, maybe I need to think differently.

Let me try to initialize max_val to a large number and min_val to a small number.

- When adding a largest element, set the element to max_val, then decrease max_val by 1.

- When adding a smallest element, set the element to min_val, then increase min_val by 1.

This way, adding a largest element is always larger than any previously added largest elements, and adding a smallest element is always smaller than or equal to any previously added smallest elements.

But I need to ensure that when adding a smallest element, it's smaller than or equal to all previous elements, so that it doesn't create new increasing subsequences beyond its own subsequence.

Wait, but in practice, since the smallest elements are smaller than or equal to all previous elements, any subsequence that includes them would not be strictly increasing unless they are the first element in the subsequence.

But in reality, adding a smallest element should only add one new subsequence: the subsequence consisting only of that element.

This seems to work.

Let me try to construct the array for X=5.

Sequence of operations: add largest, add largest, add smallest.

- Start with max_val = 1000000000, min_val = -1000000000

- Add largest: set element to max_val=1000000000, max_val -=1 -> 999999999

- Add largest: set element to max_val=999999999, max_val -=1 -> 999999998

- Add smallest: set element to min_val=-1000000000, min_val +=1 -> -999999999

So, the array is [1000000000, 999999999, -1000000000]

Let's check the increasing subsequences:

- Empty

- [1000000000]

- [999999999]

- [1000000000,999999999]

- [-1000000000]

Total: 5, which matches X=5.

Good.

Another test case: X=13

Sequence of operations: add largest, add smallest, add largest, add largest, add smallest.

- Start with max_val=1000000000, min_val=-1000000000

- Add largest: 1000000000, max_val=999999999

- Add smallest: -1000000000, min_val=-999999999

- Add largest: 999999999, max_val=999999998

- Add largest: 999999998, max_val=999999997

- Add smallest: -999999999, min_val=-999999998

So, the array is [1000000000, -1000000000, 999999999, 999999998, -999999999]

This should have 13 increasing subsequences.

Let's verify:

- Empty

- [1000000000]

- [-1000000000]

- [999999999]

- [999999998]

- [-999999999]

- [1000000000,999999999]

- [1000000000,999999998]

- [999999999,999999998]

- [1000000000,999999999,999999998]

- [1000000000,-999999999]

- [-1000000000,999999999]

- [-1000000000,999999998]

- [-1000000000,-999999999]

But some of these are not strictly increasing:

- [999999999,999999998] is decreasing.

- [1000000000,-999999999] is decreasing.

- [-1000000000,-999999999] is decreasing.

So, the valid increasing subsequences are:

- Empty

- [1000000000]

- [-1000000000]

- [999999999]

- [999999998]

- [-999999999]

- [1000000000,999999999]

- [1000000000,999999998]

- [-1000000000,999999999]

- [-1000000000,999999998]

- [1000000000,999999999,999999998]

- [-1000000000,999999999,999999998]

Total: 11, which is not 13.

Hmm, seems like a mistake.

Wait, perhaps I miscounted.

Let's recount:

- Empty: 1

- Single elements: 5 (10^9, -10^9, 999999999, 999999998, -999999999)

- Pairs:

- [10^9,999999999]: valid

- [10^9,999999998]: valid

- [-10^9,999999999]: valid

- [-10^9,999999998]: valid

- [999999999,999999998]: invalid

- [10^9,-999999999]: invalid

- [-999999999,-10^9]: invalid

- Triples:

- [10^9,999999999,999999998]: valid

- [-10^9,999999999,999999998]: valid

Total: 1 + 5 + 4 + 2 = 12, still not 13.

Wait, perhaps there's another valid subsequence I'm missing.

Let's check:

- [10^9,999999999,999999998]: valid

- [-10^9,999999999,999999998]: valid

- Also, [-10^9,-999999999]: invalid

- [999999999,-999999999]: invalid

- [999999998,-999999999]: invalid

So, total of 12, but X=13.

There's a discrepancy here.

Wait, perhaps my sequence of operations is incorrect.

Let me re-examine the sequence for X=13.

X=13 is 1101 in binary.

Following the operations:

- X=13 (odd): add smallest, previous X=12

- X=12 (even): add largest, previous X=6

- X=6 (even): add largest, previous X=3

- X=3 (odd): add smallest, previous X=2

- X=2 (even): add largest, previous X=1

So, the sequence is: add largest, add largest, add smallest, add largest, add smallest.

Wait, earlier I thought it was add largest, add smallest, add largest, add largest, add smallest, but maybe the order is different.

Wait, actually, the sequence should be in reverse order.

Starting from X=13:

- X=13 odd: add smallest from X=12

- X=12 even: add largest from X=6

- X=6 even: add largest from X=3

- X=3 odd: add smallest from X=2

- X=2 even: add largest from X=1

So, the operations are: add smallest, add largest, add largest, add smallest, add largest.

Wait, but in the earlier attempt, I had add largest, add smallest, add largest, add largest, add smallest, which is different.

I think I need to be careful about the order.

Let me try constructing the array again with the correct sequence.

Sequence: add smallest, add largest, add largest, add smallest, add largest.

- Start with max_val=1000000000, min_val=-1000000000

- Add smallest: set element to min_val=-1000000000, min_val +=1 -> -999999999

- Add largest: set element to max_val=1000000000, max_val -=1 -> 999999999

- Add largest: set element to max_val=999999999, max_val -=1 -> 999999998

- Add smallest: set element to min_val=-999999999, min_val +=1 -> -999999998

- Add largest: set element to max_val=999999998, max_val -=1 -> 999999997

So, the array is [-1000000000, 1000000000, 999999999, -999999999, 999999998]

Let's check the increasing subsequences:

- Empty

- [-1000000000]

- [1000000000]

- [999999999]

- [-999999999]

- [999999998]

- [-1000000000,1000000000]

- [-1000000000,999999999]

- [-1000000000,-999999999]

- [-1000000000,999999998]

- [1000000000,999999999]

- [1000000000,999999998]

- [999999999,999999998]

- [-999999999,999999998]

Invalid subsequences:

- [-1000000000,-999999999]: decreasing

- [999999999,999999998]: decreasing

Valid subsequences:

- Empty

- [-1000000000]

- [1000000000]

- [999999999]

- [-999999999]

- [999999998]

- [-1000000000,1000000000]

- [-1000000000,999999999]

- [-1000000000,999999998]

- [1000000000,999999999]

- [1000000000,999999998]

- [-999999999,999999998]

Total: 12, still not 13.

Wait, perhaps I need to adjust the values to ensure that the subsequences are strictly increasing.

Maybe using the same max_val and min_val approach isn't working as intended.

Alternatively, perhaps I should use a different strategy for assigning values.

Let me consider that when adding a largest element, I set it to a new maximum value, and when adding a smallest element, I set it to a new minimum value.

But in the earlier approach, I used decreasing max_val and increasing min_val, which might be causing overlaps.

Perhaps I should set max_val to a very large number and decrease it by 1 each time I add a largest element, and set min_val to a very small number and increase it by 1 each time I add a smallest element.

This should ensure that largest elements are strictly decreasing, and smallest elements are strictly increasing.

Wait, but I need the array elements to be in a specific order to control the increasing subsequences.

Maybe I need to ensure that all largest elements are placed before smallest elements, or vice versa.

Wait, perhaps the order in which I add the elements matters.

Let me consider that the array is built by appending elements one by one, and the operations are recorded in the order they were performed.

So, in the sequence of operations, each operation corresponds to appending an element to the array.

Therefore, the array is built by appending elements in the order of the operations.

In the earlier example for X=13, the sequence was add smallest, add largest, add largest, add smallest, add largest, resulting in the array [-1000000000,1000000000,999999999,-999999999,999999998].

But as we saw, this gives 12 subsequences instead of 13.

Wait, perhaps I miscounted again.

Let's recount:

- Empty: 1

- Single elements: 5

- Pairs:

- [-1000000000,1000000000]: valid

- [-1000000000,999999999]: valid

- [-1000000000,-999999999]: invalid

- [-1000000000,999999998]: valid

- [1000000000,999999999]: valid

- [1000000000,999999998]: valid

- [999999999,-999999999]: invalid

- [999999999,999999998]: invalid

- [-999999999,999999998]: valid

Total pairs: 5

- Triples:

- [-1000000000,1000000000,999999999]: valid

- [-1000000000,1000000000,999999998]: valid

- [-1000000000,999999999,999999998]: valid

- [-1000000000,-999999999,999999998]: invalid

- [1000000000,999999999,999999998]: valid

- [-999999999,999999998]: valid

Wait, [-999999999,999999998] is a pair, not a triple.

So, valid triples: 4

Total subsequences: 1 (empty) + 5 (single) + 5 (pairs) + 4 (triples) = 15, which is more than 13.

Wait, but earlier I thought it was 12, but now it's 15.

I must have miscounted earlier.

This suggests that perhaps this array has more than 13 increasing subsequences, which is not desired.

So, perhaps this approach isn't correct.

Alternatively, maybe I need to choose the values more carefully to prevent certain subsequences from being increasing.

Wait, perhaps using the same max_val and min_val isn't working because there are overlaps in the values.

Maybe I should use distinct ranges for max_val and min_val.

Let’s set max_val to a large positive number and min_val to a large negative number, ensuring that they don't overlap.

For example, set max_val to 10^9, and min_val to -10^9.

Then, decrement max_val and increment min_val accordingly.

So, for X=13, with the sequence: add smallest, add largest, add largest, add smallest, add largest.

- Add smallest: set to min_val=-10^9, min_val +=1 -> -999999999

- Add largest: set to max_val=10^9, max