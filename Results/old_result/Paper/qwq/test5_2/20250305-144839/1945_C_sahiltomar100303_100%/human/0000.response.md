Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n houses in a village, and the villagers want to build a big road that divides the village into left and right sides. Each resident has a preference for which side they want to live on, represented by a sequence of 0s and 1s, where 0 means they want to live on the left side and 1 means the right side.

The task is to decide where to build this road so that at least half of the residents on each side are satisfied with their side. Satisfaction means that they get to live on the side they wanted. The road can be built between any two houses, or before the first house, or after the last house.

The goal is to choose the position for the road that is as close as possible to the middle of the village, in terms of minimizing the absolute difference between the chosen position and the middle house. If there are multiple positions that satisfy the conditions and have the same distance to the middle, we should choose the smaller position number.

First, I need to understand the problem clearly. We have a sequence of houses with their preferences, and we need to split this sequence at some point so that:

1. On the left side (houses before the road), at least half of the residents want to be on the left side (i.e., have preference 0).

2. On the right side (houses after the road), at least half of the residents want to be on the right side (i.e., have preference 1).

We need to find the position i where the road should be built after house i, and if the road is built before the first house, i is 0.

The problem guarantees that a solution always exists, which is good to know.

Let me think about how to approach this.

First, I need to consider all possible positions to build the road, which are from position 0 to position n-1 (after the last house).

For each position i, the left side consists of houses 1 to i, and the right side consists of houses i+1 to n.

I need to check for each position whether:

- On the left side, the number of houses with preference 0 is at least ceil(i / 2).

- On the right side, the number of houses with preference 1 is at least ceil((n - i) / 2).

If multiple positions satisfy these conditions, I need to choose the one where the position i is as close as possible to n/2. If there are still multiple options, choose the smaller i.

Given that n can be up to 3*10^5 and t (number of test cases) up to 2*10^4, but the total sum of n over all test cases doesn't exceed 3*10^5, I need an efficient solution, preferably O(n) per test case.

Let me think about how to efficiently calculate the number of 0s on the left and 1s on the right for each possible position i.

One way is to precompute prefix sums for the number of 0s and the number of 1s up to each position.

Let's define:

- prefixZero[i] = number of 0s in houses 1 to i

- prefixOne[i] = number of 1s in houses 1 to i

Then, for a given position i:

- Left side (houses 1 to i):

- Number of 0s: prefixZero[i]

- Total houses: i

- So, condition: prefixZero[i] >= ceil(i / 2)

- Right side (houses i+1 to n):

- Number of 1s: prefixOne[n] - prefixOne[i]

- Total houses: n - i

- So, condition: prefixOne[n] - prefixOne[i] >= ceil((n - i) / 2)

I need to find the position i where both conditions are satisfied, and among all such positions, choose the one where abs(i - n/2) is minimized. If there are multiple, choose the smaller i.

Now, to make it efficient, I need to find a way to find the best i without checking each possible i one by one, which would be O(n) per test case, but with t up to 2*10^4 and n up to 3*10^5 in total, it should be manageable, but let's see if we can optimize it further.

Perhaps I can find the range of i where both conditions are satisfied and then find the i within that range that is closest to n/2.

Let me think about how to find the range of i where both conditions are satisfied.

First, I can iterate from i = 0 to i = n and keep track of prefixZero and prefixOne.

But checking each i individually might be too slow for the time constraints, so I need a smarter way.

Wait, perhaps I can find the minimum i where the left side condition is satisfied and the maximum i where the right side condition is satisfied, and then find the intersection of these ranges.

But actually, the conditions for left and right are separate, but they are interdependent because changing i affects both sides.

Let me consider binary search.

Can I use binary search to find the best i?

Binary search could be an option, but I need to ensure that the conditions are monotonic in i, which they might not be.

Wait, let's think differently.

Let's precompute for each i whether both conditions are satisfied, and then find the i with the smallest abs(i - n/2) among those that satisfy both conditions, and if there are multiple, choose the smallest i.

Given that n can be up to 3*10^5 and t up to 2*10^4, but with the sum of n over all test cases being up to 3*10^5, it should be acceptable.

But maybe there's a smarter way.

Let me consider that as i increases, the left side grows and the right side shrinks.

So, as i increases:

- Left side: adding one house, which could be 0 or 1.

- Right side: removing one house, which could be 0 or 1.

So, perhaps I can maintain the counts for the left and right sides as I move i from 0 to n.

Let me try to think of an example.

Take the first example from the problem:

n = 3

s = "101"

Let's index the houses from 1 to 3.

So, houses:

1: 1

2: 0

3: 1

Possible positions for the road: after house 0, after house 1, after house 2.

Let's check each:

1. After house 0:

- Left side: no houses

- Right side: houses 1 to 3

- For left side: no houses, so condition is trivially satisfied.

- For right side: n - i = 3 houses, number of 1s: 2

- ceil(3/2) = 2, so 2 >= 2, condition satisfied.

- So, position 0 is valid.

2. After house 1:

- Left side: house 1 (1), which is a 1 but wants to be on the right side.

- Number of 0s on left: 0

- Total left houses: 1

- ceil(1/2) = 1

- 0 < 1, so left side condition not satisfied.

- Right side: houses 2 and 3 (0 and 1)

- Number of 1s: 1

- Total right houses: 2

- ceil(2/2) = 1

- 1 >= 1, condition satisfied.

- Since left side condition fails, position 1 is invalid.

3. After house 2:

- Left side: houses 1 and 2 (1 and 0)

- Number of 0s: 1

- Total left houses: 2

- ceil(2/2) = 1

- 1 >= 1, condition satisfied.

- Right side: house 3 (1)

- Number of 1s: 1

- Total right houses: 1

- ceil(1/2) = 1

- 1 >= 1, condition satisfied.

- So, position 2 is valid.

Now, we need to choose the position that is closest to the middle.

For n = 3, middle is at position floor((n-1)/2) = 1.

So, positions 0 and 2 are both distance 1 from the middle position 1.

The problem says to choose the smaller i in case of ties, so position 0.

But according to the sample input, the output is 2.

Wait, perhaps I misinterpreted the middle position.

Wait, the problem says to minimize |i - n/2|.

n = 3, n/2 = 1.5

So, |0 - 1.5| = 1.5

|1 - 1.5| = 0.5

|2 - 1.5| = 0.5

So, positions 1 and 2 are both at 0.5 distance.

The problem says to choose the smaller i in case of ties, so position 1.

But according to the sample, it's position 2.

Wait, perhaps I need to consider i as the number of houses on the left side.

Wait, in the sample explanation, it says:

"If we lay the road after the first house, there will be one house a1=1 on the left side of the street, the resident of which would like to live on the right side of the street. Then 0 out of 1 residents on the even side will be satisfied, which means that the road cannot be laid after house 1."

Wait, that's position 1: after house 1.

But in my earlier calculation, position 1 is invalid because left side condition fails.

So, according to the sample, position 2 is valid.

Wait, but in my calculation, position 2 is valid.

But according to the sample output, it's 2.

Wait, perhaps I miscounted the middle.

n = 3, positions are 0,1,2.

n/2 = 1.5

|0 - 1.5| = 1.5

|1 - 1.5| = 0.5

|2 - 1.5| = 0.5

So, positions 1 and 2 are both at 0.5.

The problem says to choose the smaller i in case of ties, so position 1.

But sample output is 2.

Wait, maybe I need to consider i as the number of houses on the left side.

Wait, in the problem statement, it says:

"Determine after which house i the road should be laid in order to satisfy the described condition and be as close to the middle of the village as possible.

Formally, among all suitable positions i, minimize |n/2 - i|.

If there are multiple suitable positions i with the minimum |n/2 - i|, output the smaller one."

Wait, it says to minimize |n/2 - i|, not |i - (n-1)/2|.

Wait, n/2 for n=3 is 1.5, so positions 1 and 2 are both at 0.5 distance.

Choose the smaller i, which is 1.

But sample output is 2.

Hmm, maybe I misread.

Wait, in the sample input, n=3, s=101, output=2.

But according to the problem's formal definition, it should choose position 1.

But the sample chooses position 2.

Wait, perhaps I need to read the problem again carefully.

Wait, the problem says:

"Determine after which house i the road should be laid in order to satisfy the described condition and be as close to the middle of the village as possible.

Formally, among all suitable positions i, minimize |n/2 - i|.

If there are multiple suitable positions i with the minimum |n/2 - i|, output the smaller one."

Wait, n/2 is 1.5 for n=3.

Position i can be 0,1,2.

|0 - 1.5| = 1.5

|1 - 1.5| = 0.5

|2 - 1.5| = 0.5

So positions 1 and 2 are both at 0.5.

Choose the smaller i, which is 1.

But sample output is 2.

Wait, maybe I need to consider that position 1 is invalid, so only position 2 is valid.

Wait, in my earlier calculation, position 1 is invalid because left side condition fails.

So, only position 2 is valid, so choose position 2.

Wait, but according to the sample explanation, position 2 is chosen.

Wait, perhaps I need to make sure which positions are valid first, and then choose the one closest to n/2 among the valid ones.

In this case, position 1 is invalid, position 2 is valid, so choose position 2.

Wait, but in my earlier calculation, position 0 is valid.

Wait, position 0: left side has no houses, right side has all houses.

For left side: no houses, condition trivially satisfied.

For right side: n houses, need at least ceil(n/2) ones.

In the first sample, n=3, s=101.

Number of ones on right side: 2.

ceil(3/2)=2.

2 >= 2, so position 0 is valid.

Position 1: invalid.

Position 2: valid.

So, valid positions are 0 and 2.

|0 - 1.5| = 1.5

|2 - 1.5| = 0.5

So, position 2 is closer to n/2, so choose position 2.

Got it.

So, in case of multiple valid positions, choose the one closest to n/2, and if there are multiple at the same distance, choose the smallest i.

Hence, in this case, position 2 is better than position 0.

Okay, now I need to think about how to implement this efficiently.

Given that for each test case, n can be up to 3*10^5 and t up to 2*10^4, but sum of n over all test cases is up to 3*10^5, I need an efficient way to process each test case.

I think the best way is to precompute prefix sums for the number of 0s and the number of 1s.

Let me define:

- prefixZero[i] = number of 0s in s[0 to i-1]

- prefixOne[i] = number of 1s in s[0 to i-1]

Note: I'll use 0-based indexing for implementation.

Then, for position i (number of houses on the left side):

- Left side: houses 0 to i-1

- Number of 0s: prefixZero[i]

- Total houses: i

- Condition: prefixZero[i] >= ceil(i / 2)

- Right side: houses i to n-1

- Number of 1s: prefixOne[n] - prefixOne[i]

- Total houses: n - i

- Condition: prefixOne[n] - prefixOne[i] >= ceil((n - i) / 2)

I need to find all i where both conditions are satisfied, and then choose the i with the smallest |i - n/2|, and if ties, choose the smallest i.

To make it efficient, perhaps I can iterate through possible i and keep track of the best i.

But given the constraints, I need to make sure it's optimized.

Alternatively, perhaps I can find the range of i where both conditions are satisfied and then find the i within that range closest to n/2.

But I'm not sure if the range is contiguous.

Let me think about an example.

Take n=6, s=010111

Positions: 0 to 5

s: 0 1 0 1 1 1

Compute prefixZero and prefixOne.

prefixZero:

prefixZero[0] = 0

prefixZero[1] = 1 (s[0]=0)

prefixZero[2] = 1 (s[1]=1)

prefixZero[3] = 2 (s[2]=0)

prefixZero[4] = 2 (s[3]=1)

prefixZero[5] = 3 (s[4]=1)

prefixZero[6] = 3 (s[5]=1)

Wait, no.

Wait, prefixZero[i] is the number of 0s in s[0 to i-1].

s: positions 0 to 5: 0 1 0 1 1 1

prefixZero:

prefixZero[0] = 0

prefixZero[1] = 1 (s[0]=0)

prefixZero[2] = 1 (s[1]=1)

prefixZero[3] = 2 (s[2]=0)

prefixZero[4] = 2 (s[3]=1)

prefixZero[5] = 2 (s[4]=1)

prefixZero[6] = 2 (s[5]=1)

prefixOne:

prefixOne[i] is the number of 1s in s[0 to i-1]

prefixOne[0] = 0

prefixOne[1] = 0 (s[0]=0)

prefixOne[2] = 1 (s[1]=1)

prefixOne[3] = 1 (s[2]=0)

prefixOne[4] = 2 (s[3]=1)

prefixOne[5] = 3 (s[4]=1)

prefixOne[6] = 4 (s[5]=1)

Now, for each position i (from 0 to 5):

i=0:

Left: 0 houses, condition satisfied.

Right: 6 houses, number of 1s: prefixOne[6] - prefixOne[0] = 4 - 0 = 4

ceil(6/2)=3, 4 >=3, condition satisfied.

|0 - 3| = 3

i=1:

Left: 1 house, s[0]=0, number of 0s=1, ceil(1/2)=1, 1>=1, condition satisfied.

Right: 5 houses, number of 1s: prefixOne[6]-prefixOne[1]=4-0=4

ceil(5/2)=3, 4>=3, condition satisfied.

|1 - 3| = 2

i=2:

Left: 2 houses, s[0]=0, s[1]=1, number of 0s=1, ceil(2/2)=1, 1>=1, condition satisfied.

Right: 4 houses, number of 1s: prefixOne[6]-prefixOne[2]=4-1=3

ceil(4/2)=2, 3>=2, condition satisfied.

|2 - 3| =1

i=3:

Left: 3 houses, s[0]=0, s[1]=1, s[2]=0, number of 0s=2, ceil(3/2)=2, 2>=2, condition satisfied.

Right: 3 houses, number of 1s: prefixOne[6]-prefixOne[3]=4-2=2

ceil(3/2)=2, 2>=2, condition satisfied.

|3 - 3| =0

i=4:

Left: 4 houses, s[0]=0, s[1]=1, s[2]=0, s[3]=1, number of 0s=2, ceil(4/2)=2, 2>=2, condition satisfied.

Right: 2 houses, number of 1s: prefixOne[6]-prefixOne[4]=4-3=1

ceil(2/2)=1, 1>=1, condition satisfied.

|4 - 3| =1

i=5:

Left: 5 houses, s[0]=0, s[1]=1, s[2]=0, s[3]=1, s[4]=1, number of 0s=2, ceil(5/2)=3, 2<3, condition not satisfied.

So, position 5 is invalid.

So, valid positions are 0,1,2,3,4.

Among these, position 3 has the smallest |i - n/2| = |3 - 3| =0.

So, the answer should be 3.

But according to the sample input, for n=6, s=010111, the output is 3.

Wait, but according to the sample input, for n=6, s=010111, the output is 3.

Wait, in the sample input, the first test case is n=3, s=101, output=2.

Second test case n=6, s=010111, output=3.

Third test case n=6, s=011001, output=2.

Wait, in my earlier calculation for n=6, s=010111, positions 0,1,2,3,4 are valid, and position 3 has the smallest distance to n/2=3.

So, output should be 3, which matches the sample.

Good.

Now, let's think about how to implement this efficiently.

I need to compute prefix sums for the number of 0s and 1s.

Then, iterate through each possible i from 0 to n, check if both conditions are satisfied, and among those that satisfy, find the one with the smallest |i - n/2|, and if there are multiple, choose the smallest i.

Given that n can be up to 3*10^5 and t up to 2*10^4, but sum of n over t is up to 3*10^5, this should be acceptable in terms of time constraints.

But perhaps I can optimize it further.

Let me think about optimizing the search for the best i.

Since i increases from 0 to n, and |i - n/2| first decreases to the middle and then increases again, the optimal i should be around n/2.

Perhaps I can start from i = floor(n/2) and expand outwards.

But I'm not sure if that would necessarily be faster.

Alternatively, since I need to minimize |i - n/2|, I can iterate i from 0 to n, keep track of the i that satisfy the conditions and have the smallest |i - n/2|.

To make it efficient, perhaps I can calculate the distance for each valid i and keep track of the minimum distance and the corresponding i.

Given that n is up to 3*10^5 and t is up to 2*10^4, but sum of n over t is up to 3*10^5, iterating through all possible i for each test case should be acceptable.

Now, let's think about implementing this.

First, read t, the number of test cases.

Then, for each test case:

- Read n

- Read the string s of length n consisting of 0s and 1s.

- Compute prefixZero and prefixOne arrays.

- Iterate through i from 0 to n:

- Check if left side condition is satisfied: if i == 0, condition is satisfied; else, prefixZero[i] >= ceil(i / 2)

- Check if right side condition is satisfied: if i == n, condition is satisfied; else, prefixOne[n] - prefixOne[i] >= ceil((n - i) / 2)

- If both are satisfied, calculate |i - n/2| and keep track of the minimum distance and the corresponding i.

- Among all such i with the minimum distance, choose the smallest i.

- Output that i.

Now, to implement this efficiently, I need to make sure that the prefix sums are correctly computed.

Also, since n can be up to 3*10^5 and t up to 2*10^4, but sum of n over t is up to 3*10^5, it should be fine.

I need to be careful with integer division and ceiling.

In Python, ceil(x / 2) can be calculated as (x + 1) // 2.

Yes, that's a good way.

Now, let's think about edge cases.

Edge case 1: n=3, s=000

Positions:

0: left=0, right=3

Left: 0 houses, condition satisfied.

Right: number of 1s=0, ceil(3/2)=2, 0 < 2, not satisfied.

Position 0 is invalid.

i=1:

Left: 1 house, s[0]=0, number of 0s=1, ceil(1/2)=1, 1>=1, satisfied.

Right: 2 houses, s[1]=0, s[2]=0, number of 1s=0, ceil(2/2)=1, 0 <1, not satisfied.

Position 1 is invalid.

i=2:

Left: 2 houses, s[0]=0, s[1]=0, number of 0s=2, ceil(2/2)=1, 2>=1, satisfied.

Right: 1 house, s[2]=0, number of 1s=0, ceil(1/2)=1, 0 <1, not satisfied.

Position 2 is invalid.

i=3:

Left: 3 houses, s[0]=0, s[1]=0, s[2]=0, number of 0s=3, ceil(3/2)=2, 3>=2, satisfied.

Right: 0 houses, condition satisfied.

So, position 3 is valid.

n=3, n/2=1.5

|0 -1.5|=1.5

|1 -1.5|=0.5

|2 -1.5|=0.5

|3 -1.5|=1.5

So, positions 1 and 2 are at 0.5 distance.

But position 1 and 2 are invalid, only position 3 is valid.

So, choose position 3.

Wait, but according to the problem, it says that a solution always exists.

So, in this case, position 3 is the only valid position.

Another edge case: n=3, s=110

Positions:

0: left=0, right=3

Left: satisfied.

Right: number of 1s=2, ceil(3/2)=2, 2>=2, satisfied.

i=1:

Left: 1 house, s[0]=1, number of 0s=0, ceil(1/2)=1, 0<1, not satisfied.

i=2:

Left: 2 houses, s[0]=1, s[1]=1, number of 0s=0, ceil(2/2)=1, 0<1, not satisfied.

i=3:

Left: 3 houses, s[0]=1, s[1]=1, s[2]=0, number of 0s=1, ceil(3/2)=2, 1<2, not satisfied.

Wait, according to earlier understanding, position 0 should be valid.

Wait, but in the sample input, for n=3, s=110, output=0.

Wait, in my calculation, position 0 is valid.

But according to the sample input, output is 0.

Wait, but in my earlier calculation, position 0 is valid.

Wait, perhaps I made a mistake.

Wait, for position 0:

Left: 0 houses, condition satisfied.

Right: 3 houses, number of 1s=2, ceil(3/2)=2, 2>=2, satisfied.

So, position 0 is valid.

For position 1:

Left: 1 house, s[0]=1, number of 0s=0, ceil(1/2)=1, 0<1, not satisfied.

Position 2:

Left: 2 houses, s[0]=1, s[1]=1, number of 0s=0, ceil(2/2)=1, 0<1, not satisfied.

Position 3:

Left: 3 houses, s[0]=1, s[1]=1, s[2]=0, number of 0s=1, ceil(3/2)=2, 1<2, not satisfied.

So, only position 0 is valid.

n=3, n/2=1.5

|0 -1.5|=1.5

|1 -1.5|=0.5

|2 -1.5|=0.5

|3 -1.5|=1.5

But only position 0 is valid, so choose position 0.

Got it.

So, in cases where only position 0 is valid, choose position 0.

Another edge case: n=4, s=1100

Positions: 0 to 3

prefixZero:

prefixZero[0]=0

prefixZero[1]=0 (s[0]=1)

prefixZero[2]=0 (s[1]=1)

prefixZero[3]=1 (s[2]=0)

prefixZero[4]=2 (s[3]=0)

prefixOne:

prefixOne[0]=0

prefixOne[1]=1 (s[0]=1)

prefixOne[2]=2 (s[1]=1)

prefixOne[3]=2 (s[2]=0)

prefixOne[4]=2 (s[3]=0)

Now, check each i:

i=0:

Left: 0 houses, satisfied.

Right: 4 houses, number of 1s=2, ceil(4/2)=2, 2>=2, satisfied.

|0 -2|=2

i=1:

Left: 1 house, s[0]=1, number of 0s=0, ceil(1/2)=1, 0<1, not satisfied.

i=2:

Left: 2 houses, s[0]=1, s[1]=1, number of 0s=0, ceil(2/2)=1, 0<1, not satisfied.

i=3:

Left: 3 houses, s[0]=1, s[1]=1, s[2]=0, number of 0s=1, ceil(3/2)=2, 1<2, not satisfied.

i=4:

Left: 4 houses, s[0]=1, s[1]=1, s[2]=0, s[3]=0, number of 0s=2, ceil(4/2)=2, 2>=2, satisfied.

Right: 0 houses, satisfied.

|4 -2|=2

So, positions 0 and 4 are valid, both at distance 2 from n/2=2.

Choose the smaller i, which is 0.

But according to the sample input, for n=4, s=1100, output=0.

Yes, that matches.

Good.

Now, I need to implement this logic.

But before that, let's think about how to compute ceil(x / 2).

In Python, ceil(x / 2) can be computed as (x + 1) // 2.

Similarly, floor(x / 2) is x // 2.

Now, in the code, I need to:

- Read t.

- For each test case:

- Read n.

- Read the string s.

- Compute prefixZero and prefixOne.

- Iterate through i from 0 to n:

- Check if left side condition is satisfied.

- Check if right side condition is satisfied.

- If both are satisfied, calculate |i - n/2| and keep track of the minimum distance and corresponding i.

- After checking all i, output the smallest i among those with the minimum distance.

I need to make sure that I handle i=0 and i=n correctly, where one side has zero houses.

Also, need to make sure that the string is 0-indexed.

Now, think about how to implement this in code.

Define prefixZero and prefixOne as lists of size n+1.

Initialize prefixZero[0] = 0

For i from 1 to n:

if s[i-1] == '0':

prefixZero[i] = prefixZero[i-1] + 1

else:

prefixZero[i] = prefixZero[i-1]

Similarly for prefixOne.

Then, iterate through i from 0 to n:

left_zeros = prefixZero[i]

left_count = i

right_ones = prefixOne[n] - prefixOne[i]

right_count = n - i

if left_count == 0 or left_zeros >= (left_count + 1) // 2:

if right_count == 0 or right_ones >= (right_count + 1) // 2:

distance = abs(i - n / 2)

if distance < min_distance or (distance == min_distance and i < best_i):

best_i = i

min_distance = distance

After checking all i, print(best_i)

Wait, but n/2 might not be an integer, so I need to calculate |i - n/2| as a float.

But since n can be up to 3*10^5, and i is integer, |i - n/2| can be calculated as abs(i - n // 2 - n % 2).

Wait, no, n/2 could be a float, so better to calculate it as abs(i - n / 2).

In Python, it's fine to work with floats.

But need to make sure that floating point precision doesn't cause issues.

Given that n is up to 3*10^5, and i is integer, the difference should be precise.

Now, think about implementing this.

But perhaps to avoid floating point issues, I can minimize the squared distance, i.e., minimize (i - n/2)^2.

But it's not necessary, as Python handles floats accurately for this range.

Now, think about the implementation.

I need to make sure that for each test case, I compute prefixZero and prefixOne correctly.

Also, make sure that the string is read correctly.

Now, think about the sample input and output.

Sample Input:

7

3

101

6

010111

6

011001

3

000

3

110

3

001

4

1100

Sample Output:

2

3

2

3

0

1

0

Now, according to my earlier calculations, for n=3, s=101, output=2

n=6, s=010111, output=3

n=6, s=011001, output=2

n=3, s=000, output=3

n=3, s=110, output=0

n=3, s=001, output=1

n=4, s=1100, output=0

Seems consistent with the sample.

Now, think about how to implement this efficiently in code.

I need to read t test cases, each consisting of n and s.

Compute prefix sums for 0s and 1s.

Then, iterate through i from 0 to n, check conditions, and find the best i.

Implement this for each test case.

Now, think about code optimization.

In Python, list comprehensions and precomputing sums should be efficient enough.

Also, since the sum of n over all test cases is up to 3*10^5, it should be fine.

Now, proceed to write the code accordingly.

## Final Solution
To solve this problem, we need to determine the optimal position to build a road that divides the village into left and right sides such that at least half of the residents on each side are satisfied with their side assignment. The position should also be as close as possible to the middle of the village.

### Approach

1. **Problem Understanding**:
    - We are given a sequence of houses, each wanting to be on the left (0) or right (1) side of the road.
    - We need to place the road such that:
        - At least half of the residents on the left side want to be on the left.
        - At least half of the residents on the right side want to be on the right.
    - The road can be placed between any two houses, before the first house, or after the last house.

2. **Efficient Calculation**:
    - Use prefix sums to efficiently calculate the number of houses wanting left or right on each side.
    - For each possible position `i` (0 to n), compute:
        - Number of houses on the left side that want left (0).
        - Number of houses on the right side that want right (1).
    - Check if these counts meet the required conditions.

3. **Optimal Position Selection**:
    - Among all valid positions, select the one closest to the middle of the village.
    - If multiple positions have the same distance to the middle, choose the smallest position.

4. **Implementation**:
    - Compute prefix sums for the number of 0s and 1s.
    - Iterate through all possible positions and select the best one based on the criteria.

### Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    idx = 0
    t = int(data[idx])
    idx += 1
    for _ in range(t):
        n = int(data[idx])
        idx += 1
        s = data[idx]
        idx += 1
        prefixZero = [0] * (n + 1)
        prefixOne = [0] * (n + 1)
        for i in range(1, n + 1):
            if s[i - 1] == '0':
                prefixZero[i] = prefixZero[i - 1] + 1
                prefixOne[i] = prefixOne[i - 1]
            else:
                prefixZero[i] = prefixZero[i - 1]
                prefixOne[i] = prefixOne[i - 1] + 1
        best_i = -1
        min_distance = float('inf')
        for i in range(n + 1):
            left_zeros = prefixZero[i]
            left_count = i
            right_ones = prefixOne[n] - prefixOne[i]
            right_count = n - i
            if (left_count == 0 or left_zeros >= (left_count + 1) // 2) and \
               (right_count == 0 or right_ones >= (right_count + 1) // 2):
                distance = abs(i - n / 2)
                if distance < min_distance or (distance == min_distance and i < best_i):
                    best_i = i
                    min_distance = distance
        print(best_i)

if __name__ == "__main__":
    main()
```

### Explanation

1. **Reading Input**:
    - Read the number of test cases `t`.
    - For each test case, read `n` (number of houses) and the string `s` (preferences).

2. **Prefix Sum Calculation**:
    - Compute prefix sums for the number of 0s and 1s to quickly determine counts for any subarray.

3. **Checking Conditions**:
    - For each possible position `i` (from 0 to n):
        - Calculate the number of 0s on the left side.
        - Calculate the number of 1s on the right side.
        - Check if these counts meet the required conditions.
        - Track the position `i` that minimizes the distance to `n/2`.

4. **Output the Best Position**:
    - Print the position `i` that is closest to the middle and satisfies the conditions.

This approach ensures that we efficiently find the optimal position for the road while adhering to the problem constraints.