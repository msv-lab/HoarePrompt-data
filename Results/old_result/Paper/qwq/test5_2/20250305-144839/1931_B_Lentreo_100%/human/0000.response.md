Alright, I've got this problem here. Let's see what it's asking for. So, there are n containers of water, each containing a certain amount of water. The sum of all the water in these containers is divisible by n, which means that theoretically, we can distribute the water equally among all containers. The question is whether it's possible to achieve this equal distribution using a specific operation: pouring water from one container to another, but only from a container with a lower index to a higher index.

First, I need to understand the constraints and what's allowed. The operation allows me to pour any amount of water from container i to container j, but only if i < j. That means I can only pour water forward in the sequence, not backward. Each container can be used multiple times as a source or a destination.

Given that, I need to find out if it's possible to make all containers have the same amount of water by only pouring water forward.

Let's think about what this means. If I can only pour water from left to right, then the amount of water in each container depends on the initial amount and any water that's poured into it from the left, minus any water that's poured out to the right.

To make all containers equal, I need to ensure that after all operations, each container has the same amount, which is the total sum divided by n.

Let's denote the target amount as mean = total / n.

Now, for each container, I need to make sure that after all operations, it has mean amount of water.

Given the operation constraints, I need to find a sequence of pours from left to right that achieves this.

Let's consider the cumulative effect of pours. Starting from the leftmost container, it can only pour water to the right, but it can't receive any water since there's no container before it.

Similarly, the second container can receive water from the first but can only pour to the right, and so on.

This seems like a one-way flow, from left to right.

I need to ensure that each container ends up with exactly mean.

Let's think about it step by step.

Suppose I have n containers in order: 1, 2, 3, ..., n.

Container 1 can only pour water to the right, to containers 2 through n.

Container 2 can receive from container 1 and pour to containers 3 through n, and so on.

The last container, n, can only receive water from container n-1; it can't pour anywhere else.

I need to make sure that each container has mean after all operations.

Let me consider the cumulative water up to each container.

Let's define the cumulative water up to container i as the sum of a1 to ai.

If I want each container to have mean, then the cumulative up to container i should be i * mean.

So, for the first container, cumulative is mean.

For the first two containers, cumulative is 2 * mean.

And so on, up to n * mean.

Given that, I can think about the difference between the actual cumulative and the desired cumulative at each step.

Let's define the cumulative sum up to container i as cum_i = a1 + a2 + ... + ai.

The desired cumulative up to container i is i * mean.

So, the difference is cum_i - i * mean.

If this difference is positive, it means that up to container i, there's extra water that needs to be poured forward.

If it's negative, it means that up to container i, there's a deficit that needs to be filled from the left.

But wait, since I can only pour from left to right, I can't fill a deficit from the left; I can only pour forward.

So, if at any point, the cumulative sum up to container i is less than i * mean, it means that I need more water coming from the left to make up for the deficit.

But since I can't pour backward, I can't make up for that deficit.

Therefore, for it to be possible to make all containers equal, the cumulative sum up to each container i must be at least i * mean.

In other words, cum_i >= i * mean for all i from 1 to n.

Moreover, since the total sum is n * mean, and cum_n = sum = n * mean, which is satisfied.

So, the condition is that cum_i >= i * mean for all i from 1 to n.

If this holds, then it's possible to make all containers equal by pouring water forward as needed.

If it doesn't hold for some i, then it's impossible because there's a deficit that can't be filled from the left.

Let me test this logic with the example given.

In the third test case:

n = 5

a = [4, 5, 2, 1, 3]

sum = 4 + 5 + 2 + 1 + 3 = 15

mean = 15 / 5 = 3

Now, let's compute the cumulative sums:

cum_1 = 4 >= 3*1 = 3 → OK

cum_2 = 4 + 5 = 9 >= 3*2 = 6 → OK

cum_3 = 9 + 2 = 11 >= 9 → OK

cum_4 = 11 + 1 = 12 >= 12 → OK

cum_5 = 12 + 3 = 15 >= 15 → OK

Since all cum_i >= i*mean, it's possible, which matches the "YES" in the sample output.

In the second test case:

n = 2

a = [1, 3]

sum = 4

mean = 2

cum_1 = 1 >= 2? No.

So, it's "NO", which matches the sample output.

In the fourth test case:

n = 3

a = [1, 2, 3]

sum = 6

mean = 2

cum_1 = 1 >= 2? No.

So, "NO", matches the sample.

In the fifth test case:

n = 7

a = [4, 5, 5, 0, 6, 4, 4]

sum = 28

mean = 4

cum_1 = 4 >= 4 → OK

cum_2 = 4 + 5 = 9 >= 8 → OK

cum_3 = 9 + 5 = 14 >= 12 → OK

cum_4 = 14 + 0 = 14 >= 16? No.

So, "NO", matches the sample.

In the sixth test case:

n = 7

a = [6, 5, 5, 1, 3, 4, 4]

sum = 28

mean = 4

cum_1 = 6 >= 4 → OK

cum_2 = 6 + 5 = 11 >= 8 → OK

cum_3 = 11 + 5 = 16 >= 12 → OK

cum_4 = 16 + 1 = 17 >= 16 → OK

cum_5 = 17 + 3 = 20 >= 20 → OK

cum_6 = 20 + 4 = 24 >= 24 → OK

cum_7 = 24 + 4 = 28 >= 28 → OK

So, "YES", matches the sample.

This seems consistent.

Now, looking at the provided program:

def func_1(nums):

n = len(nums)

total = sum(nums)

if total % n != 0:

return 'NO'

mean = total // n

curr = 0

for i in range(n):

curr += nums[i] - mean

if curr < 0:

return 'NO'

return 'YES'

It first checks if the total sum is divisible by n, which it is, as per the problem statement.

Then, it calculates the mean.

Then, it iterates through the list, keeping a running sum of (nums[i] - mean).

If at any point this running sum becomes negative, it returns 'NO'; otherwise, 'YES'.

Wait a minute, this seems similar to what I thought earlier.

In my reasoning, I said that the cumulative sum up to each container i should be at least i * mean.

In other words, cum_i >= i * mean.

Rearranging, cum_i - i * mean >= 0.

Now, cum_i is the sum of nums[0] to nums[i-1].

So, cum_i - i * mean >= 0.

But in the code, it's keeping a running sum of nums[i] - mean.

Let's see:

Initialize curr = 0

For i from 0 to n-1:

curr += nums[i] - mean

So, curr after i steps is sum(nums[0..i-1]) - i * mean.

Wait, that's cum_i-1 - i * mean.

But in my earlier condition, I have cum_i >= i * mean.

Wait, there might be an off-by-one issue here.

Wait, let's clarify:

cum_i = sum(nums[0..i-1])

So, cum_i - i * mean >= 0.

In the code, curr = sum(nums[0..i-1]) - mean * i.

If curr < 0 at any step, return 'NO'.

So, it's checking if cum_i - i * mean >= 0 for all i.

Which aligns with my earlier reasoning.

Hence, this seems correct.

But in my earlier reasoning, I had cum_i >= i * mean for all i.

And in the code, curr = cum_i - i * mean >= 0 for all i.

So, it's the same.

Hence, the function seems correct.

But wait, in the problem statement, it's guaranteed that the sum is divisible by n, so total % n == 0, so no need to check that.

But in the code, it's checking if total % n != 0, and returning 'NO' if so.

But since it's guaranteed that sum is divisible by n, this check is redundant.

But it doesn't hurt, so okay.

Moreover, in Python, integer division is floor division, so total // n is fine for mean.

Now, let's consider if there could be any issues.

Given that n can be up to 2e5, and t up to 1e4, but sum of n over all test cases is up to 2e5, so time constraints should be fine, as the function is O(n).

Edge cases:

- n = 1: Only one container, already equal. Should return 'YES'.

- All containers have the same value: Already equal, should return 'YES'.

- Containers have different values, but cumulative sums satisfy the condition.

- Containers have different values, and at some point, cum_i < i * mean.

Let's test with n = 1:

a = [43]

sum = 43

mean = 43

cum_1 = 43 >= 43 → OK → 'YES'

n = 2

a = [1, 3]

sum = 4

mean = 2

cum_1 = 1 >= 2? No → 'NO'

n = 3

a = [1, 2, 3]

sum = 6

mean = 2

cum_1 = 1 >= 2? No → 'NO'

n = 5

a = [4, 5, 2, 1, 3]

sum = 15

mean = 3

cum_1 = 4 >= 3 → OK

cum_2 = 4+5=9 >= 6 → OK

cum_3 = 9+2=11 >= 9 → OK

cum_4 = 11+1=12 >= 12 → OK

cum_5 = 12+3=15 >= 15 → OK → 'YES'

Another test case:

n = 4

a = [1, 1, 1, 1]

sum = 4

mean = 1

cum_1 = 1 >= 1 → OK

cum_2 = 2 >= 2 → OK

cum_3 = 3 >= 3 → OK

cum_4 = 4 >= 4 → OK → 'YES'

Another test case:

n = 3

a = [3, 0, 0]

sum = 3

mean = 1

cum_1 = 3 >= 1 → OK

cum_2 = 3+0=3 >= 2 → OK

cum_3 = 3+0=3 >= 3 → OK → 'YES'

But wait, in this case, can I pour from container 1 to 2 and then to 3 to make them all 1?

Yes:

- Pour 2 units from container 1 to container 2: [1, 2, 0]

- Pour 1 unit from container 2 to container 3: [1, 1, 1]

So, it's possible.

Another test case:

n = 3

a = [0, 0, 3]

sum = 3

mean = 1

cum_1 = 0 >= 1? No → 'NO'

Indeed, since I can only pour forward, I can't pour from container 3 back to 1 or 2; I can only pour from 3 to 4, but there is no container 4. So, it's impossible.

Hence, the condition seems correct.

Another test case:

n = 4

a = [2, 2, 2, 0]

sum = 6

mean = 1.5

Wait, but in the problem, a_i are integers, and n divides sum, so mean is an integer.

Wait, 6 is divisible by 4? 6 / 4 = 1.5, which is not an integer.

But in the problem statement, it says that the sum is divisible by n, so mean is an integer.

Hence, this test case is invalid per the problem constraints.

So, in the code, checking if total % n != 0 and returning 'NO' is redundant, but since per problem constraints sum is always divisible by n, it's okay.

But in reality, it's guaranteed, so that check is unnecessary.

But it doesn't hurt, so it's fine.

I think the function is correct.

Hence, the answer is Correctness: **True**

**Final Answer**

\[ \boxed{\text{True}} \]