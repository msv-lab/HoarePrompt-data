Alright, I have this problem to solve. Let's see what it's about. So, Rudolf has an array of integers, and he can perform a specific operation on it any number of times. The operation involves choosing an index i (between 2 and n-1) and modifying the elements at positions i-1, i, and i+1 by subtracting 1, 2, and 1 respectively. The goal is to make all elements of the array zero using these operations.

First, I need to understand the operation clearly. So, for any index i from 2 to n-1, I can subtract 1 from a[i-1], subtract 2 from a[i], and subtract 1 from a[i+1]. I can do this operation as many times as I want, and each time I can choose any index i within the range.

My task is to determine whether it's possible to turn all elements of the array into zero by applying this operation repeatedly.

Let me think about the implications of this operation. It seems like each operation is affecting three consecutive elements. So, it's a local operation that affects a small window of the array.

I need to find a way to use these operations to zero out the entire array. Maybe I can think of it in terms of solving equations, where each operation corresponds to subtracting a certain pattern from the array.

Let's consider the array as a set of variables, and each operation as subtracting a specific vector from the array. For example, if I have an array of size n, each operation corresponds to subtracting a vector that has -1 at positions i-1, -2 at position i, and -1 at position i+1, and zeros elsewhere.

So, the problem reduces to whether I can find a combination of these operations (vectors) that sum up to the negative of the initial array. In other words, it's like solving a system of linear equations where the unknowns are the number of times each operation is applied.

However, since we're dealing with integers and the operations can be applied any number of times, including zero, this seems like a system of linear Diophantine equations.

But maybe there's a simpler way to approach this problem without delving too deep into linear algebra.

Let me consider the constraints and properties of the operations.

First, the operations can only decrease the values of the array elements, since we're subtracting positive integers each time. So, if any element in the array is negative to start with, it's impossible to make it zero because we can only make it smaller.

Wait, no, the problem states that the elements are non-negative integers, specifically 0 ≤ a_j ≤ 10^9, so I don't have to worry about negative values.

Another thing to note is that the operations affect overlapping triplets of the array. So, operations on different indices can interfere with each other.

I need to find a sequence of operations that will zero out the entire array.

Let me think about smaller examples to get an intuition.

Take n=3, array [a, b, c].

Possible operations:

- Choose i=2: a becomes a-1, b becomes b-2, c becomes c-1.

I need to choose operations such that a-1*k = 0, b-2*k = 0, c-1*k = 0, where k is the number of times I apply the operation at i=2.

This implies that a = c = k and b = 2k. So, for the array to be zero, a should equal c, and b should be twice that value.

If this condition holds, then I can set k = a, and apply the operation k times to zero out the array.

If a != c or b != 2a, then it's impossible.

So, for n=3, the condition is a == c and b == 2a.

Now, let's think about n=4, array [d, e, f, g].

Possible operations:

- Choose i=2: d-1, e-2, f-1

- Choose i=3: e-1, f-2, g-1

I need to find a combination of these operations to zero out the array.

Let’s denote the number of times I apply the operation at i=2 as k, and at i=3 as m.

Then, the changes would be:

d: -k

e: -2k - m

f: -k - 2m

g: -m

So, to zero out the array:

d - k = 0 => k = d

e - 2k - m = 0 => e - 2d - m = 0 => m = e - 2d

f - k - 2m = 0 => f - d - 2(e - 2d) = 0 => f - d - 2e + 4d = 0 => f + 3d - 2e = 0

g - m = 0 => g - (e - 2d) = 0 => g = e - 2d

So, for the array to be zero, the following conditions must hold:

1. k = d

2. m = e - 2d

3. f + 3d - 2e = 0

4. g = e - 2d

Moreover, since k and m must be non-negative integers (as you can't apply an operation a negative number of times), we have:

- k = d >= 0

- m = e - 2d >= 0 => e - 2d >= 0

- From condition 4: g = e - 2d >= 0

- From condition 3: f + 3d - 2e = 0

This seems complicated. Maybe there's a pattern or invariant that I can find for general n.

Let me think differently. Maybe I can model this as a system where each operation affects a window of three elements, and I need to find a way to cancel out all the values.

Another approach could be to consider the differences between consecutive elements or something like that.

Wait, perhaps I can think of this operation as a way to propagate changes through the array.

Let me consider the array as a sequence, and see how operations at different positions affect the sequence.

Alternatively, maybe I can consider the prefix sums or some other cumulative measures.

Let me try to find a pattern or a way to represent the operations that can help me determine if the array can be zeroed out.

Let me consider the operations in reverse. Suppose the array is already zeroed out, and I apply the operations in reverse, which would correspond to adding 1 to a[i-1], 2 to a[i], and 1 to a[i+1]. If I can build up to the given array from all zeros using these reverse operations, then the original array can be zeroed out by applying the operations accordingly.

But this seems similar to the forward approach.

Maybe I need to find a way to express the initial array in terms of the possible operations.

Given that, perhaps I can model this as a system of equations where each equation corresponds to an array position, and the variables are the number of times each operation is applied.

But with n up to 2e5, solving a system of equations directly isn't feasible due to time and space constraints.

I need a smarter way to check if the array can be zeroed out.

Let me consider the constraints again. The operations can only decrease the array elements, and I need to make them all zero.

I need to ensure that the operations can be applied in such a way that all elements are reduced to zero.

Perhaps I can iterate through the array and apply operations greedily where possible.

Let me consider starting from the left and trying to zero out elements one by one.

For example, start with the first element. If it's non-zero, I need to apply operations that affect it. The only operation that affects the first element is i=2, which subtracts 1 from a[1], 2 from a[2], and 1 from a[3].

Wait, but a[1] is only affected by operation at i=2.

Similarly, a[2] is affected by operations at i=2 and i=3, and so on.

This seems a bit messy. Maybe there's a better way.

Let me consider the differences between consecutive elements.

Suppose I look at the differences between a[i+1] and a[i]. Maybe there's a pattern there.

Alternatively, perhaps I can consider the array as a whole and see if the total sum can be reduced to zero by applying the operations.

Wait, each operation reduces the total sum by 1 + 2 + 1 = 4. So, the total sum of the array must be divisible by 4 for it to be possible to zero it out.

But that's not necessarily true, because operations can be applied multiple times, and the reductions are not independent due to overlapping windows.

Wait, for example, in n=3, [1,2,1], sum is 4, and applying one operation at i=2 reduces sum by 4 to 0, which works.

But in n=4, [1,2,1,0], sum is 4, but applying operation at i=2 reduces to [0,0,0,0], which is good.

Wait, but in n=3, [1,3,1], sum is 5, which is not divisible by 4, but maybe it's still possible.

Wait, [1,3,1]: apply operation at i=2: [0,1,0], then apply operation at i=2 again: [-1,-1,-1], which is not allowed since elements can't be negative.

So, it's not possible to zero out [1,3,1], even though the sum is 5, which is not divisible by 4.

Wait, but in the first step, after applying operation at i=2, we get [0,1,0]. Then, I can't apply any more operations because I can't choose i=2 again since a[2]=1 < 2.

So, it's stuck with [0,1,0], which can't be zeroed out.

So, sum being divisible by 4 is not a sufficient condition.

I need a better approach.

Let me look at the example provided in the problem.

Example 1:

n=5

a = [1,3,5,5,2]

Operations:

1. Apply at i=4: [1,3,4,3,1]

2. Apply at i=3: [1,2,2,2,1]

3. Apply at i=2: [1,0,1,2,1]

Wait, the description says:

- apply at i=4: [1,3,4,3,1]

- apply at i=3: [1,2,2,2,1]

- apply at i=2: [1,0,1,2,1]

- apply at i=4: [1,0,0,0,1]

Wait, but according to the operation, applying at i=2 should be:

a[1] -=1, a[2] -=2, a[3] -=1

So, from [1,2,2,2,1]:

- a[1] =1-1=0

- a[2]=2-2=0

- a[3]=2-1=1

So, the array becomes [0,0,1,2,1]

Then, applying at i=4:

a[3] -=1, a[4] -=2, a[5] -=1

So, [0,0,1-1=0,2-2=0,1-1=0] -> [0,0,0,0,0]

Yes, that works.

So, in this case, it's possible to zero out the array.

Another example in the problem is:

n=5

a=[2,4,4,5,1]

Output: NO

I need to understand why it's NO.

Let's try to apply operations.

First, choose i=3: [2,4,2,3,0]

Then, choose i=2: [1,2,1,3,0]

Then, choose i=3: [1,2,1,1,-1]

Can't have negative values, so it's invalid.

Alternatively, choose i=4: [1,2,1,1,-1], same issue.

So, seems like it's not possible to zero it out without negatives.

Another example:

n=5

a=[0,1,3,3,1]

Apply i=3: [0,1,1,1,0]

Apply i=2: [0,0,0,1,0]

Then, can't apply anymore because a[2]=0, and a[4]=1 < 2.

So, stuck with [0,0,0,1,0], can't zero out.

Hence, "NO"

Wait, but according to the problem's sample input, for n=5 a=[0,1,3,3,1], output is "YES"

Wait, but in my simulation, I end up with [0,0,0,1,0], which is not zeroed out.

Wait, maybe I did something wrong.

Let me try again.

Start with [0,1,3,3,1]

Apply operation at i=3: a[2]-1, a[3]-2, a[4]-1 -> [0,0,1,2,1]

Then apply operation at i=3 again: [0,0,0,0,1]

Then, can't apply any more operations, since i=2 requires a[2]>0, which is not true.

So, stuck with [0,0,0,0,1], which is not fully zeroed out.

But according to the sample input, it's "YES", so maybe I made a mistake in simulation.

Wait, perhaps there's another sequence of operations that can zero it out.

Let me try different operations.

Start with [0,1,3,3,1]

Apply operation at i=2: a[1]-1, a[2]-2, a[3]-1 -> [-1,-1,2,3,1], but negative values are invalid.

So, can't apply operation at i=2.

Only option is i=3: [0,1,1,2,1]

Then, apply i=3 again: [0,1,-1,0,1], invalid.

Alternatively, apply i=4: [0,1,1,0,0]

Now, can't apply any more operations, since a[3]=1 < 2 for i=3, and a[2]=1 < 2 for i=2.

So, stuck with [0,1,1,0,0]

Wait, but according to the sample input, it's "YES", so maybe I made a mistake.

Wait, perhaps the operation can be applied only if all the affected elements are >= the required amount.

So, in the first step, starting with [0,1,3,3,1], can I apply i=3?

a[2]=1 >=0, a[3]=3 >=2, a[4]=3 >=1.

So, after operation: a[2]=1-1=0, a[3]=3-2=1, a[4]=3-1=2 -> [0,0,1,2,1]

Then, apply i=3 again: a[2]=0 >=0, a[3]=1 >=2? No, 1 < 2, so can't apply.

So, can't apply i=3.

Can I apply i=4? a[3]=1 >=0, a[4]=2 >=2, a[5]=1 >=0.

After operation: a[3]=1-1=0, a[4]=2-2=0, a[5]=1-1=0 -> [0,0,0,0,0]

Yes, that works.

So, the correct sequence is:

1. Apply at i=3: [0,0,1,2,1]

2. Apply at i=4: [0,0,0,0,0]

Hence, "YES"

I must be careful with the conditions for applying operations.

So, in code, I need to ensure that I only apply operations when the necessary conditions are met for the elements involved.

Now, back to the general problem.

I need a way to determine if such a sequence of operations exists that can zero out the entire array.

Given the constraints on n and t, I need an efficient algorithm, probably O(n) per test case.

Let me think about how to model this.

One idea is to iterate through the array and greedily apply operations where possible.

Start from the left, at i=2, and if a[i-1] > 0 and a[i] >=2 and a[i+1] >0, apply the operation as many times as possible.

But this might not be optimal, as operations can have overlapping effects.

Another approach is to consider the operations as a way to propagate values through the array.

Wait, perhaps I can think of it in terms of differences.

Let me consider the differences between consecutive elements.

Define b[i] = a[i] - a[i-1] for i from 1 to n, assuming a[0] = 0.

Wait, maybe that's not helpful.

Alternatively, perhaps I can consider the array as a system of equations, where each operation corresponds to a specific change in the array.

But with large n, solving the system directly is not feasible.

Let me consider the effect of operations on the array.

Each operation at position i consumes:

- 1 from a[i-1]

- 2 from a[i]

- 1 from a[i+1]

So, it's like consuming a total of 4 units, but with specific distribution.

I need to find a way to distribute the operations such that all elements are zeroed out.

Another way to look at it is to consider the array as a graph where each position is a node, and operations connect three consecutive nodes.

But that might be too complicated.

Let me consider the prefix sum of the array.

Define s[i] = a[1] + a[2] + ... + a[i]

Then, the operation at position i affects s[i-1], s[i], and s[i+1].

But I'm not sure if this helps.

Wait, perhaps I can think in terms of balancing the array.

Each operation reduces the "peak" at position i by 2, while reducing the adjacent positions by 1.

So, it's like smoothing out the array.

Maybe I can think of it as needing to have certain conditions on the array elements for it to be possible.

Let me consider the array as a whole.

Suppose I have the array a[1], a[2], ..., a[n]

I need to apply operations such that after some steps, all a[i] = 0.

Each operation corresponds to subtracting a certain pattern from the array.

Perhaps I can model this as a matrix and see if the initial array is a linear combination of the operation patterns.

But again, with large n, this is not practical.

Let me think differently.

Suppose I fix the number of operations applied at each position.

Let k[i] be the number of times operation is applied at position i (for i from 2 to n-1).

Then, the effect on the array is:

a[1] - k[2]

a[2] - 2k[2] - k[3]

a[3] - 2k[3] - k[4]

...

a[n-1] - 2k[n-1] - k[n]

a[n] - k[n]

Wait, no, more precisely:

a[1] - k[2]

a[2] - 2k[2] - k[3]

a[3] - 2k[3] - k[4]

...

a[n-1] - 2k[n-1] - k[n]

a[n] - k[n]

Wait, that seems off.

Actually, for each k[i], the operation at i affects:

a[i-1] -= k[i]

a[i] -= 2k[i]

a[i+1] -= k[i]

So, for i from 2 to n-1.

So, the equations are:

a[1] - k[2] = 0

a[2] - 2k[2] - k[3] = 0

a[3] - 2k[3] - k[4] = 0

...

a[n-1] - 2k[n-1] - k[n] = 0

a[n] - k[n] = 0

So, we have a system of equations:

1. a[1] - k[2] = 0

2. a[2] - 2k[2] - k[3] = 0

3. a[3] - 2k[3] - k[4] = 0

...

n. a[n-1] - 2k[n-1] - k[n] = 0

n+1. a[n] - k[n] = 0

Wait, but n+1 equations with n-1 variables (k[2] to k[n]).

This seems overconstrained.

Wait, n variables: k[2] to k[n]

n equations:

From equation 1: k[2] = a[1]

From equation n+1: k[n] = a[n]

From equation n: a[n-1] - 2k[n-1] - k[n] = 0 => k[n-1] = (a[n-1] - k[n])/2 = (a[n-1] - a[n])/2

And so on.

Wait, maybe I can solve this system sequentially.

Start from k[2] = a[1]

Then, from equation 2: a[2] - 2k[2] - k[3] = 0 => k[3] = a[2] - 2k[2] = a[2] - 2a[1]

Then, k[4] from equation 3: a[3] - 2k[3] - k[4] = 0 => k[4] = a[3] - 2k[3] = a[3] - 2(a[2] - 2a[1]) = a[3] - 2a[2] + 4a[1]

And so on, recursively.

Finally, k[n] = a[n] - 2k[n-1] - k[n+1], but since there is no k[n+1], and assuming k[n+1]=0, we can solve for k[n].

Wait, but in the last equation, it's a[n] - k[n] = 0 => k[n] = a[n]

So, seems conflicting.

Wait, perhaps I need to set k[n] = a[n], and then work backwards.

Let me try to solve the system step by step.

From equation n+1: k[n] = a[n]

From equation n: k[n-1] = (a[n-1] - k[n])/2 = (a[n-1] - a[n])/2

From equation n-1: k[n-2] = (a[n-2] - 2k[n-1] - k[n])/1, but wait, need to adjust.

Actually, from equation n-1: a[n-2] - 2k[n-2] - k[n-1] = 0 => k[n-2] = (a[n-2] - k[n-1])/2

Wait, it's getting complicated.

Maybe I can iterate from left to right, expressing each k[i] in terms of previous variables.

Start with k[2] = a[1]

Then k[3] = a[2] - 2k[2] = a[2] - 2a[1]

Then k[4] = a[3] - 2k[3] - k[4], wait, need to express k[4] in terms of previous variables.

This seems messy.

Perhaps there's a better way.

Let me consider that the operations can be seen as a way to propagate values through the array, and I need to ensure that the values can be balanced out.

Another idea: maybe I can use dynamic programming to keep track of possible states.

But with n up to 2e5, that's not feasible.

Wait, perhaps I can iterate through the array and keep track of the required operations.

Let me try to iterate from left to right.

Initialize k[2] = a[1]

Then, for each i from 3 to n-1:

k[i] = a[i-1] - 2k[i-1]

Finally, check if a[n] - k[n] = 0

Wait, similar to what I did earlier.

But I need to ensure that all k[i] are non-negative integers.

This seems promising.

Let me try with the first sample input.

n=5, a=[1,3,5,5,2]

Set k[2] = a[1] =1

Then k[3] = a[2] - 2k[2] =3 - 2*1=1

k[4] = a[3] - 2k[3] - k[4], but in my previous step, I only have k[3].

Wait, perhaps I need to adjust the equations.

Actually, in the earlier step, I think I need to express k[i] in terms of k[i-1] and a[i-1].

Wait, perhaps I need to iterate from left to right, expressing each k[i] in terms of previous k's.

Let me try:

Set k[2] = a[1] =1

Then k[3] = a[2] - 2k[2] =3 - 2*1=1

Then k[4] = a[3] - 2k[3] - k[4], but I need another equation to solve for k[4].

Wait, from equation for a[4]: a[4] - 2k[4] - k[5] =0

And from a[5]: a[5] - k[5] =0 => k[5]=a[5]=2

Then, a[4] - 2k[4] - k[5] =0 => 5 - 2k[4] -2=0 => 5 - 2k[4] -2=0 => 3 - 2k[4]=0 => k[4]=1.5

Wait, but k[4] must be an integer, but in this case, it's 1.5, which is not integer.

Wait, but in the sample input, it's possible to zero out the array.

Wait, maybe I made a mistake in my calculation.

Wait, in the sample input, n=5, a=[1,3,5,5,2]

Set k[2]=1

k[3]=3-2*1=1

k[4]=5-2*1-2=5-2-2=1

Wait, a[4] -2k[4] -k[5]=0 => 5 -2*1 -2=1, which is not zero.

Wait, a[4]=5, k[4]=1, k[5]=2 => 5 -2*1 -2=1, which is not zero.

So, seems inconsistent.

Wait, perhaps I need to adjust my approach.

Let me try to set k[5]=a[5]=2

Then, from a[4]: a[4] -2k[4] -k[5]=0 =>5 -2k[4] -2=0 =>2k[4]=3 =>k[4]=1.5

Which is not integer, so invalid.

But in reality, it's possible to zero out the array, so maybe my approach is flawed.

Perhaps I need to ensure that all k[i] are integers and non-negative.

Alternatively, maybe I need to use a different method.

Let me look for an invariant or a property that must hold for the array to be zeroed out.

Suppose that I have the array a[1..n], and I apply operations to zero it out.

Each operation reduces a[i-1], a[i], a[i+1] by 1,2,1 respectively.

I need to find a way to reverse this process, i.e., build up from zero to the given array.

If I think in terms of building up, starting from all zeros, and applying reverse operations (adding 1,2,1 in a window), I need to see if I can build the given array using such operations.

This seems similar to convolution or signal processing, but I'm not sure.

Alternatively, perhaps I can consider the second difference of the array.

In numerical analysis, the second difference is related to the curvature of the sequence.

But I digress.

Let me try to find a pattern or a formula that can determine if the array can be zeroed out.

Another idea: maybe I can subtract the operations in a way that resembles Gaussian elimination, but again, not practical for large n.

Wait, perhaps I can consider the array as a system where each operation affects a specific pattern, and see if the initial array is a linear combination of these patterns.

But with large n, this is not feasible.

Let me consider the problem differently.

Suppose I have the array a[1..n], and I want to zero it out using operations that subtract (1,2,1) from any position.

I can model this as convolving the array with the kernel (-1,-2,-1) or, equivalently, subtracting the kernel from the array at specific positions.

But again, without a clear path to a solution, this seems too vague.

Let me consider the sum of the array.

Each operation reduces the sum by 4.

So, the total sum must be divisible by 4.

But as I saw earlier, this is not sufficient.

In the earlier example, n=3, a=[1,3,1], sum=5, which is not divisible by 4, and indeed, it's not possible to zero it out.

In another case, n=3, a=[1,2,1], sum=4, which is divisible by 4, and it can be zeroed out.

But in the sample input, n=5, a=[1,3,5,5,2], sum=16, which is divisible by 4, and it's possible to zero it out.

So, sum divisible by 4 is a necessary condition but not sufficient.

I need more conditions.

Let me consider the prefix sums.

Define s[i] = a[1] + a[2] + ... + a[i]

Then, after applying an operation at position i, s[i-1] -=1, s[i] -=2, s[i+1] -=1

But I'm not sure if this helps.

Wait, perhaps I can consider the differences between consecutive elements.

Define d[i] = a[i] - a[i-1] for i from 2 to n.

Not sure if that helps.

Let me think about it differently.

Suppose I fix the number of operations at each position, k[2..n-1]

Then, the conditions are:

a[1] - k[2] =0

a[2] -2k[2] -k[3]=0

...

a[n-1] -2k[n-1] -k[n]=0

a[n] -k[n]=0

This is a system of linear equations that I need to solve for k[2..n]

I can represent this system in matrix form and see if it has a solution with non-negative integer values for k[i]

But solving this for large n is not practical.

Alternatively, perhaps I can solve it recursively.

Starting from k[2] = a[1]

Then k[3] = a[2] - 2k[2]

k[4] = a[3] - 2k[3] - k[4], wait, that seems off.

Wait, perhaps I need to express k[i] in terms of a[i] and previous k's.

Let me try to express k[i] in terms of a[i] and k[i-1]

From equation for a[i]:

a[i] -2k[i] -k[i+1] =0

Wait, perhaps I need to rearrange the equations.

Let me try to iterate from left to right.

Set k[2] = a[1]

Then, from equation for a[2]: a[2] -2k[2] -k[3]=0 => k[3] =a[2]-2k[2]

Then, k[4] =a[3]-2k[3]

And so on.

Finally, k[n] =a[n-1]-2k[n-1]

And a[n]-k[n]=0 => k[n]=a[n]

So, set k[n] = a[n]

And k[n-1] = (a[n-1] - k[n])/2

And so on, backwards.

This seems promising.

Let me try this with the sample input.

n=5, a=[1,3,5,5,2]

First, set k[5] = a[5]=2

Then, k[4] = (a[4] - k[5])/2 = (5 - 2)/2 = 1.5, which is not integer.

But in reality, it's possible to zero out the array.

So, perhaps I need to adjust the approach.

Wait, maybe I need to iterate from both ends.

Alternatively, perhaps I need to ensure that at each step, the values are consistent.

This is getting too complicated.

Let me look for a different approach.

I recall that in some problems involving operations on subsequences, there are certain invariants or properties that can be exploited to find a solution without simulating all operations.

Perhaps I can look for such an invariant here.

Wait, let's consider the array as a whole and see if there's a way to represent it in terms of the operations.

Each operation corresponds to subtracting (1,2,1) from three consecutive elements.

So, the array can be zeroed out if it can be expressed as a linear combination of these operation patterns.

But again, solving for this seems too time-consuming for large n.

Let me consider the problem in terms of differences.

Define b[i] = a[i] - a[i-1] for i from 2 to n.

But I'm not sure if that helps directly.

Wait, perhaps I can consider the second difference.

In numerical analysis, the second difference is d[i] = b[i] - b[i-1], where b[i] = a[i] - a[i-1].

But I need to find a way to relate this to the operations.

Alternatively, perhaps I can consider the array as a quadratic function, but that seems too vague.

Let me consider a smaller example again.

Take n=4, a=[1,2,1,0]

Try to zero it out.

Apply operation at i=2: [0,0,0,-1]

Wait, negative values are invalid, so it's not possible.

But according to the earlier approach:

Set k[4]=a[4]=0

k[3]=(a[3]-k[4])/2=(1-0)/2=0.5, which is not integer.

So, it's inconsistent, which matches the simulation.

Another example: n=4, a=[1,2,7,2]

Set k[4]=a[4]=2

k[3]=(a[3]-k[4])/2=(7-2)/2=2.5, which is not integer.

Hence, "NO"

So, perhaps the condition is that all k[i] are integers and non-negative.

In the first sample input, n=5, a=[1,3,5,5,2]

Set k[5]=2

k[4]=(a[4]-k[5])/2=(5-2)/2=1.5, which is not integer.

But according to the sample, it's "YES", so this approach is flawed.

Wait, in the sample, it's possible to zero out the array, but according to this, it should be "NO", which contradicts.

Hence, this approach is incorrect.

I need to find another way.

Let me look for a different invariant.

Suppose I compute the sum a[1] + a[3] + a[5] + ... and a[2] + a[4] + a[6] + ...

And see if they satisfy certain conditions.

But I'm not sure.

Alternatively, perhaps I can consider the array as a system where each operation reduces the sum by 4, but only if certain conditions are met.

But as I saw earlier, sum being divisible by 4 is necessary but not sufficient.

I need more constraints.

Let me consider the problem in terms of linear algebra.

Each operation corresponds to subtracting a vector of the form [0,...,0,1,2,1,0,...,0] from the array.

So, the problem is to find non-negative integers k1, k2, ..., k_{n-2} such that sum over all operations equals the initial array.

But solving this directly is not feasible for large n.

I need a smarter way.

Let me consider the differences between consecutive elements.

Define b[i] = a[i] - a[i-1] for i from 2 to n.

Then, the operation at position j affects b[j] and b[j+1].

Specifically, operation at j subtracts 1 from b[j] and 1 from b[j+1].

Wait, b[j] = a[j] - a[j-1]

After operation at j:

a[j-1] -=1, a[j] -=2, a[j+1] -=1

So, b[j] = (a[j]-2) - (a[j-1]-1) = b[j] -1

Similarly, b[j+1] = (a[j+1]-1) - (a[j]-2) = b[j+1] -1 +2 = b[j+1] +1

Wait, no:

Original b[j] = a[j] - a[j-1]

After operation at j:

b[j] = (a[j] -2) - (a[j-1]-1) = a[j] -2 -a[j-1] +1 = (a[j] - a[j-1]) -1 = b[j] -1

Similarly, b[j+1] = (a[j+1]-1) - (a[j]-2) = a[j+1] -1 -a[j] +2 = (a[j+1] - a[j]) +1 = b[j+1] +1

So, operation at j decreases b[j] by 1 and increases b[j+1] by 1.

Interesting.

So, operations can be seen as shifting values in the differences.

Maybe I can use this to find a way to make all b[j] zero, which would imply that the array is constant, and since we need to zero out the entire array, the constant must be zero.

Wait, if all b[j] =0, then the array is constant.

But we need to zero out the entire array, so the constant must be zero.

But in our operations, we can shift values between b[j] and b[j+1].

So, perhaps I can adjust the differences to make them all zero.

Starting from b[j] = a[j] - a[j-1], and I can perform operations that subtract 1 from b[j] and add 1 to b[j+1].

So, it's like moving values from b[j] to b[j+1].

I need to see if I can make all b[j] zero by such operations.

This seems similar to being able to shift values along the array to balance the differences.

Let me consider that.

If I can make all b[j] =0 by such operations, then the array becomes zero.

Wait, no. If b[j] =0 for all j, then a[j] = a[j-1] for all j, which implies that the array is constant.

But we need to zero out the entire array, so the constant must be zero.

Hence, a[1] must be zero, and hence the entire array must be zero.

But that's not the case in the sample input.

Wait, perhaps I'm misunderstanding something.

In the sample input, it's possible to zero out the array even though the differences are not zero.

Wait, perhaps this approach is not correct.

Let me think again.

If I have b[j] = a[j] - a[j-1], and I can perform operations that decrease b[j] by 1 and increase b[j+1] by 1, it's like moving water from b[j] to b[j+1].

So, to make all b[j] =0, I need to be able to redistribute the differences such that they cancel out.

But in reality, the operations allow me to shift values from b[j] to b[j+1], but I need to make sure that the cumulative shifts allow all b[j] to become zero.

This seems similar to having a system where I can adjust the differences by moving values between adjacent differences.

In other words, I can adjust b[j] and b[j+1] by moving values between them.

So, perhaps if the sum of b[j] from j=2 to m is zero for all m from 2 to n, then it's possible.

Wait, that seems too strong.

Let me think differently.

If I consider the cumulative sum of b[j] from j=2 to m, that would be a[m] - a[1].

So, if a[m] - a[1] can be adjusted to zero for all m, then the array can be zeroed out.

But I'm getting confused.

Let me consider that the operations allow me to adjust b[j] and b[j+1] in a specific way.

Each operation at j decreases b[j] by 1 and increases b[j+1] by 1.

So, it's like moving a value from b[j] to b[j+1].

Therefore, I can shift values along the differences.

To make all b[j] =0, I need to shift values such that any excess in b[j] is moved to higher indices until they balance out.

This seems similar to the concept of distributing loads in a sequence.

Given that, perhaps I can iterate through the differences and accumulate the necessary shifts.

Let me try to formalize this.

Start with b[2] = a[2] - a[1]

To make b[2]=0, I need to perform operations that decrease b[2] by its current value.

Each operation at j=2 decreases b[2] by 1 and increases b[3] by 1.

So, to decrease b[2] by its value, I need to perform that many operations at j=2.

This will make b[2]=0, but will increase b[3] by the same amount.

Then, I need to deal with b[3], which now has its original value plus the amount shifted from b[2].

I can repeat this process: perform operations at j=3 to decrease b[3] by its current value, which will increase b[4] by that amount, and so on.

Finally, for b[n], I need it to be zero after all shifts.

Wait, but b[n] = a[n] - a[n-1]

If I've been shifting values up to b[n], I need b[n] to be zero after all shifts.

So, the condition is that the cumulative shifts up to b[n] must make it zero.

This seems similar to requiring that the sum of shifts equals a certain value.

Let me try to implement this idea.

Initialize shifts[j] for j from 2 to n-1.

Set shifts[j] = b[j]

Then, for each j from 2 to n-1:

k = shifts[j]

shifts[j] -= k

shifts[j+1] += k

This will make shifts[j]=0 and shifts[j+1]+=k

Repeat this for all j.

Finally, check if shifts[n]=0.

Wait, but shifts[n] is b[n], which is a[n] - a[n-1], plus any shifts from previous operations.

This seems too vague.

Let me try with the sample input.

n=5, a=[1,3,5,5,2]

Compute b[j]:

b[2]=3-1=2

b[3]=5-3=2

b[4]=5-5=0

b[5]=2-5=-