Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of length 2n, and it contains each integer from 1 to n exactly twice. Then there's an integer k, and I need to find two arrays, l and r, each of length 2k. 

The conditions are:

1. l is a subset of the first n elements of the array a.

2. r is a subset of the second n elements of the array a.

3. The bitwise XOR of elements in l should be equal to the bitwise XOR of elements in r.

Also, it's guaranteed that at least one solution exists, and I can output any one of them if there are multiple.

First, I need to understand what a subset means here. It says that a subset can be obtained by deleting several elements from the sequence and rearranging them in any order. So, essentially, l and r are any collections of 2k elements from the first n and last n elements of a, respectively.

The key here is that the XOR of elements in l should equal the XOR of elements in r.

I need to find a way to select these subsets such that their XORs are equal.

Let me think about the properties of XOR. XOR is associative and commutative, which means the order in which we XOR elements doesn't matter, and XORing a number with itself cancels out to 0.

Given that each number from 1 to n appears exactly twice in the array, and we're splitting the array into two halves, each number might appear in either half, or one in each half.

I need to select 2k elements from each half such that their XORs are equal.

One approach could be to find pairs of identical elements, since XORing two identical numbers results in 0, which might help in balancing the XOR values.

But I need to select subsets of size exactly 2k, not necessarily pairs.

Wait, k can be up to n/2, and n can be up to 5*10^4, and t can be up to 5000, with the sum of n over all test cases up to 5*10^4.

So, efficiency is important here.

I need an efficient way to find these subsets.

Let me consider the XOR properties more carefully.

If I can find subsets where the XOR of their elements is equal, that would suffice.

But directly finding such subsets seems complicated.

Maybe I can look for subsets where the XOR of l and r together is equal to some value, but I need to think differently.

Wait, another idea: since XOR is involved, maybe I can look at the XOR of all elements in the first half and the second half.

Let me denote XOR_l as the XOR of the first n elements, and XOR_r as the XOR of the second n elements.

Given that each number from 1 to n appears exactly twice, the overall XOR of the entire array would be 0, because each number XORed with itself is 0, and 0 XORed with any number is the number itself.

Wait, but since each number appears twice, and XOR is associative and commutative, the overall XOR of the array is 0.

So, XOR_l XOR XOR_r should be 0, because the XOR of all elements is XOR_l XOR XOR_r, which is 0.

Therefore, XOR_l = XOR_r.

That's an interesting observation.

But I need to find subsets l and r of size 2k each, such that XOR of l equals XOR of r.

Given that, and knowing that XOR_l = XOR_r, maybe I can find subsets that satisfy this.

But I need a way to select these subsets efficiently.

Let me think about the frequencies of the numbers in the first and second halves.

I can count how many times each number appears in the first half and in the second half.

Wait, but since each number appears exactly twice, in one or two halves.

Possible scenarios for each number:

- Appears twice in the first half.

- Appears twice in the second half.

- Appears once in the first half and once in the second half.

But since each number appears exactly twice, and n can be up to 5*10^4, I need an efficient way to handle this.

Wait, the problem says that every integer from 1 to n occurs exactly twice in a.

So, for each number from 1 to n, there are exactly two copies in the array a.

Now, I need to select 2k elements from the first n and 2k elements from the second n, such that their XORs are equal.

Given that, and knowing that the overall XOR of the entire array is 0, maybe I can use this property to find the subsets.

Let me consider selecting elements that appear in both halves.

Wait, perhaps I can select pairs where a number appears in both halves, and select both copies for l and r.

But I need to select 2k elements in total for l and r.

Wait, no, 2k elements for l and 2k elements for r, so total 4k elements.

But the array has 2n elements, and k can be up to n/2, so 4k can be up to 2n.

So, it's possible to select up to all elements.

But I need to ensure that the XOR of l equals the XOR of r.

Another idea: since XOR_l = XOR_r, and I need to select subsets l and r from the first and second halves respectively, with |l| = |r| = 2k, and XOR(l) = XOR(r).

Maybe I can select subsets such that their XOR cancels out appropriately.

Wait, perhaps I can select subsets such that XOR_l' = XOR_r', where l' and r' are the selected subsets.

But I need a systematic way to do this.

Let me consider the following approach:

1. Compute the XOR of the first n elements (XOR_l).

2. Compute the XOR of the second n elements (XOR_r).

As I noted earlier, XOR_l = XOR_r.

2. Now, I need to select subsets l and r such that XOR(l) = XOR(r).

Given that, perhaps I can select subsets such that their XOR equals a certain value, say t, and since XOR_l = XOR_r, it should be possible to find such subsets.

But I need to ensure that the subsets have exactly 2k elements each.

This seems tricky.

Maybe I need to look for differences in frequencies or something.

Wait, perhaps I can look at the numbers that appear in both halves.

Let me think differently.

Let me consider that each number appears exactly twice, once in the first half and once in the second half, or twice in the same half.

Wait, no, that's not necessarily true. Each number can appear twice in the first half, twice in the second half, or once in each.

But since the array is of length 2n and contains each integer from 1 to n exactly twice, it's possible for a number to appear twice in the first half or twice in the second half, or once in each.

I need to consider all possibilities.

Let me try to categorize the numbers based on their positions:

- Type A: appears twice in the first half.

- Type B: appears twice in the second half.

- Type C: appears once in the first half and once in the second half.

For each number from 1 to n, it falls into one of these three categories.

Now, let's think about the XOR values.

Since XOR is associative and commutative, the order doesn't matter.

I need to select 2k elements from the first half and 2k elements from the second half such that their XORs are equal.

One straightforward way is to select the same numbers from both halves, but since the numbers are the same, their XOR would be equal.

Wait, but I need to select subsets of size 2k, which might not be possible if there aren't enough numbers of a certain type.

Wait, perhaps I can prioritize selecting numbers that appear once in each half.

Wait, but I need to select 2k elements, not 2k numbers.

Wait, elements are specific positions in the array, not the numbers themselves.

Wait, no, in programming problems, when we talk about subsets of elements, we usually consider the values.

But in this problem, it's about selecting subsets of elements from the first half and the second half, and considering their XOR.

Wait, perhaps I need to think in terms of selecting specific occurrences of numbers, not just the numbers themselves.

This is getting complicated.

Let me try to think of a simpler approach.

Given that the overall XOR is 0, and XOR_l = XOR_r, maybe I can select subsets such that their XOR is equal to a certain value, but I'm not sure.

Alternatively, perhaps I can iterate through the numbers and greedily select pairs that have the same XOR.

But I need a more concrete plan.

Let me look at the example provided.

In the first test case:

n = 2, k = 1

a = [1, 2, 2, 1]

So, first half: [1, 2]

Second half: [2, 1]

One possible solution is l = [2,1], r = [2,1], and their XOR is 3 in both cases.

Another possible solution could be l = [1,2], r = [1,2], which also has XOR 3 for both.

So, in this case, selecting the entire halves works.

But k can be up to n/2, and n can be up to 5*10^4, so efficiency is key.

Perhaps I can always select the first 2k elements from the first half and the first 2k elements from the second half, but that might not satisfy the XOR condition.

Wait, but in the first test case, selecting [1,2] from both halves works.

In the second test case:

n = 6, k = 1

a = [6,4,2,1,2,3,1,6,3,5,5,4]

First half: [6,4,2,1,2,3]

Second half: [1,6,3,5,5,4]

One possible solution is l = [6,4], r = [1,3], both with XOR 2.

So, in this case, selecting different numbers but with the same XOR.

How did they arrive at this?

Well, 6 XOR 4 = 2, and 1 XOR 3 = 2.

So, they selected two numbers from each half that have the same XOR.

Similarly, in the third test case:

n = 4, k = 1

a = [1,2,3,4,1,2,3,4]

One possible solution is l = [1,2], r = [1,2], both with XOR 3.

Again, selecting the same numbers from both halves.

In the fourth test case:

n = 6, k = 2

a = [5,1,3,3,5,1,2,6,4,6,4,2]

One possible solution is l = [5,1,3,3], r = [6,4,2,4], both with XOR 3.

So, in this case, l has two 3's and a 5 and a 1, and r has a 6, a 4, a 2, and another 4.

Wait, but 4 appears twice in r, but in the array, there are two 4's in the second half.

Wait, let me check:

Second half: [6,4,2,6,4,2]

Wait, no, the array is [5,1,3,3,5,1,2,6,4,6,4,2], so second half is [2,6,4,6,4,2].

So, r = [6,4,2,4], which are from the second half.

Their XOR is 6 XOR 4 XOR 2 XOR 4 = (6 XOR 4 XOR 2 XOR 4) = (6 XOR 2) = 4.

Wait, but in the sample output, it's said to be XOR 3, but according to this, it's 4.

Wait, maybe I miscalculated.

Let me calculate again.

6 XOR 4 = 2, 2 XOR 2 = 0, 0 XOR 4 = 4.

Wait, but the sample explanation says XOR is 3, but according to this, it's 4.

Maybe I made a mistake.

Wait, perhaps the sample explanation has a typo, or maybe I misread the array.

Wait, the array is [5,1,3,3,5,1,2,6,4,6,4,2], so a[7 to 12] is [2,6,4,6,4,2].

Then, r = [6,4,2,4], so 6 XOR 4 XOR 2 XOR 4.

6 XOR 4 = 2, 2 XOR 2 = 0, 0 XOR 4 = 4.

So, XOR should be 4, but the sample output says 5 XOR 1 XOR 3 XOR 3 = 0, and 6 XOR 4 XOR 2 XOR 4 = 4, which are not equal.

Wait, perhaps I misread the sample output.

Wait, no, in the sample output for the fourth test case:

l = [5,1,3,3], r = [6,4,2,4]

XOR of l: 5 XOR 1 XOR 3 XOR 3 = (5 XOR 1) = 4, then 4 XOR 3 = 7, then 7 XOR 3 = 4.

Wait, no, 5 XOR 1 = 4, 4 XOR 3 = 7, 7 XOR 3 = 4.

XOR of r: 6 XOR 4 = 2, 2 XOR 2 = 0, 0 XOR 4 = 4.

So, both have XOR 4.

But in the sample explanation, it says XOR is 3, but according to this, it's 4.

Maybe there's a mistake in the sample explanation.

Anyway, moving on.

I need to find a general approach.

Let me consider the following plan:

1. Count the frequency of each number in the first half and in the second half.

2. Identify numbers that appear in both halves, once in each.

3. For these numbers, selecting one from the first half and one from the second half ensures their XOR is 0, which can be useful.

4. For numbers that appear twice in one half, selecting both cancels out their XOR to 0.

5. Use these observations to build subsets l and r with equal XOR.

But I need to select exactly 2k elements in each subset.

This seems a bit vague.

Let me think about the XOR properties again.

Since XOR is associative and commutative, the order doesn't matter.

Also, XOR of a set of numbers is equal to the XOR of any permutation of those numbers.

Moreover, XOR of a number with itself is 0.

Given that, perhaps I can group numbers into pairs that XOR to a certain value.

Wait, perhaps I can try to select pairs of numbers that have the same XOR value in both subsets.

But this seems too vague.

Let me consider a different approach.

Let me consider that I need to select subsets l and r such that XOR(l) = XOR(r).

This is equivalent to XOR(l) XOR XOR(r) = 0, which is XOR(l XOR r) = 0.

Wait, actually, XOR(l) XOR XOR(r) = XOR(l + r), where + is the concatenation.

But I'm not sure if that helps.

Wait, perhaps I can think in terms of linear algebra over GF(2), where each number represents a vector, and XOR is the addition operation.

But that might be too slow for the given constraints.

I need a faster approach.

Let me consider the following plan:

- Select k pairs of numbers, where each pair consists of the same number appearing in both halves.

- For each such pair, select one instance from the first half for l and one instance from the second half for r.

- Since the numbers are the same, their XOR in l and r will be the same.

- If I can select k such pairs, then l and r will each have 2k elements (since each pair contributes two elements: one from the first half and one from the second half).

- However, each number appears exactly twice, so I need to ensure that I don't overcount.

Wait, no, in this approach, for each pair, I select one from the first half and one from the second half, so for k pairs, l would have k elements and r would have k elements.

But I need 2k elements in each subset.

So, this approach doesn't directly work.

Wait, maybe I need to select 2k such pairs.

But that would be too many, as k can be up to n/2, and n can be up to 5*10^4.

This seems inefficient.

Let me think differently.

Let me consider that I can select numbers that appear twice in the first half or twice in the second half.

- If a number appears twice in the first half, selecting both for l gives XOR 0.

- Similarly, selecting both for r gives XOR 0.

- If a number appears once in each half, selecting one for l and one for r, their XOR would be equal.

Wait, but I need to select 2k elements for l and 2k for r.

I need to find a way to combine these selections to meet the required subset sizes.

Maybe I can categorize the numbers into three groups:

1. Numbers that appear twice in the first half.

2. Numbers that appear twice in the second half.

3. Numbers that appear once in each half.

Then, I can use these groups to build l and r.

Let me denote:

- A: numbers that appear twice in the first half.

- B: numbers that appear twice in the second half.

- C: numbers that appear once in each half.

Now, for group A, selecting both occurrences for l gives XOR 0.

Similarly, for group B, selecting both for r gives XOR 0.

For group C, selecting one for l and one for r gives XOR equal to the number itself in both l and r.

Wait, but since they are the same number, XOR in l and r would be equal.

But I need to select 2k elements for l and r.

Let me try to formalize this.

Let me denote:

- For group A, each number can contribute two elements to l with XOR 0.

- For group B, each number can contribute two elements to r with XOR 0.

- For group C, each number can contribute one element to l and one to r, with XOR equal to the number itself in both subsets.

Now, I need to select subsets from these groups such that the total number of elements in l and r is 2k each, and the XOR of l equals the XOR of r.

Let me consider that the total XOR of l is equal to the XOR of the selected elements from group C, since elements from group A contribute XOR 0 to l, and elements from group B contribute XOR 0 to r.

Wait, no, elements from group A contribute two elements to l with XOR 0, and elements from group B contribute two elements to r with XOR 0.

Elements from group C contribute one element to l and one to r, each with XOR equal to the number itself.

So, the total XOR of l would be the XOR of the numbers selected from group C, and similarly for r.

Since I'm selecting the same numbers from group C for both l and r, the XOR of l and r from group C would be equal.

Additionally, elements from group A and B contribute XOR 0 to l and r, respectively.

Therefore, the total XOR of l would be equal to the XOR of the numbers selected from group C, and the same for r.

Hence, if I select the same numbers from group C for both l and r, their XOR would be equal.

Therefore, a possible approach is:

- Select numbers from group C, and for each selected number, add one occurrence to l and one to r.

- Select numbers from group A and add both occurrences to l.

- Select numbers from group B and add both occurrences to r.

- Ensure that the total number of elements in l and r is 2k each.

Given that, I can maximize the selection from group C, and fill the remaining elements from group A and group B.

Wait, but I need to ensure that the XOR of l equals the XOR of r.

Since the XOR of l is the XOR of the selected numbers from group C, and the XOR of r is also the XOR of the same selected numbers from group C, they will be equal.

Therefore, this approach seems valid.

Now, I need to implement this logic efficiently.

Let me outline the steps:

1. Categorize the numbers into groups A, B, and C.

- Traverse the array and count the positions of each number.

2. For group C, which are numbers that appear once in the first half and once in the second half, select as many as possible without exceeding the required subset sizes.

3. For group A, select numbers to contribute two elements to l.

4. For group B, select numbers to contribute two elements to r.

5. Ensure that the total number of elements in l and r is exactly 2k each.

6. Output the selected elements for l and r accordingly.

Now, let's think about how to implement this efficiently.

Given that n can be up to 5*10^4 and t up to 5000, with the sum of n over all test cases up to 5*10^4, I need an O(n) per test case solution.

Let's think about how to categorize the numbers.

I can create frequency arrays for the first and second halves.

For each number from 1 to n:

- count its occurrences in the first half (positions 1 to n).

- count its occurrences in the second half (positions n+1 to 2n).

Based on these counts:

- If a number appears twice in the first half, it's in group A.

- If it appears twice in the second half, it's in group B.

- If it appears once in each half, it's in group C.

Then, I can proceed to select from these groups.

Now, I need to select 2k elements for l and 2k for r.

Each selection from group C contributes two elements: one to l and one to r.

Each selection from group A contributes two elements to l.

Each selection from group B contributes two elements to r.

So, to reach 2k elements in l and 2k in r, I can:

- Select m numbers from group C, contributing m elements to l and m elements to r.

- Select p numbers from group A, contributing 2p elements to l.

- Select q numbers from group B, contributing 2q elements to r.

And ensure that:

m + 2p = 2k  (for l)

m + 2q = 2k  (for r)

Simplifying:

m + 2p = 2k

m + 2q = 2k

Subtracting the two equations:

2p - 2q = 0 => p = q

So, p = q

Therefore, m + 2p = 2k

And m + 2p = 2k

So, m can be from 0 to 2k, as long as m is even (since p and q are integers).

Wait, m can be from 0 to 2k, but m must be even because p and q must be integers.

Wait, no, m doesn't need to be even; p and q can be adjusted accordingly.

Wait, from m + 2p = 2k, p = (2k - m)/2

Similarly, q = (2k - m)/2

So, 2k - m must be even, meaning m must have the same parity as 2k.

But 2k is always even, since k is an integer, so 2k is even.

Therefore, m must be even.

Wait, no, m can be odd or even, but 2k - m must be even, which is only possible if m is even.

Wait, 2k is even, m must be even as well to make (2k - m) even.

Therefore, m must be even.

Wait, no, if 2k is even, and m is even, then (2k - m) is even, and p = (2k - m)/2 is an integer.

If m is odd, (2k - m) is odd, and p would not be an integer, which is not possible since p must be an integer.

Therefore, m must be even.

So, m can be 0, 2, 4, ..., up to 2k.

Given that, I can select m numbers from group C, and p = q = (2k - m)/2 numbers from group A and B, respectively.

Now, I need to ensure that I have enough numbers in each group to make these selections.

- Let c be the number of numbers in group C.

- Let a be the number of numbers in group A.

- Let b be the number of numbers in group B.

Then, I need to choose m numbers from group C, p numbers from group A, and p numbers from group B, where m + 2p = 2k.

So, p = (2k - m)/2

I need to choose m <= c, p <= a, and p <= b.

I need to find the largest m that satisfies these conditions, with m even, and m <= c, and (2k - m)/2 <= a, and (2k - m)/2 <= b.

Wait, but I need to select exactly 2k elements for l and r.

Given that, I can iterate over possible even m from 0 to 2k, and find the largest m that satisfies m <= c, and (2k - m)/2 <= a, and (2k - m)/2 <= b.

Then, set p = (2k - m)/2

Then, select m numbers from group C, p numbers from group A, and p numbers from group B.

This should give me the required subsets.

Now, I need to implement this efficiently.

Given that n can be up to 5*10^4 and t up to 5000, with sum of n over all test cases up to 5*10^4, I need an O(n) per test case solution.

Let's think about how to categorize the numbers into A, B, and C.

I can create two frequency arrays:

- freq_first[h] : number of times h appears in the first half.

- freq_second[h] : number of times h appears in the second half.

Then:

- If freq_first[h] == 2, h is in group A.

- If freq_second[h] == 2, h is in group B.

- If freq_first[h] == 1 and freq_second[h] == 1, h is in group C.

I can iterate through the array once to compute these frequencies.

Then, I can collect the lists of numbers in each group.

Let me denote:

- list_A: numbers that appear twice in the first half.

- list_B: numbers that appear twice in the second half.

- list_C: numbers that appear once in each half.

Then, I can select m numbers from list_C, p numbers from list_A, and p numbers from list_B, where m + 2p = 2k.

To maximize m, I can set m = min(c, 2k - 2p), where p = min(a, b, floor((2k - m)/2))

Wait, perhaps it's better to iterate m from 0 to 2k with step 2, and find the largest m such that m <= c and (2k - m)/2 <= a and (2k - m)/2 <= b.

Then, set p = (2k - m)/2

Then, select m numbers from list_C, p numbers from list_A, and p numbers from list_B.

This should work.

Now, let's think about constructing the subsets l and r.

For the m numbers selected from list_C:

- For each such number h, select one occurrence from the first half for l, and one occurrence from the second half for r.

For the p numbers selected from list_A:

- For each such number h, select both occurrences from the first half for l.

For the p numbers selected from list_B:

- Select both occurrences from the second half for r.

This way, l will have m + 2p elements, which is 2k.

Similarly, r will have m + 2p elements, which is 2k.

And the XOR of l will be the XOR of the m numbers from list_C, and the XOR of r will also be the XOR of the m numbers from list_C, since each h in list_C contributes h to both l and r.

Therefore, XOR(l) = XOR(r).

Hence, this approach should work.

Now, I need to implement this efficiently.

Let's outline the steps in code:

1. Read t, the number of test cases.

2. For each test case:

a. Read n and k.

b. Read the array a of length 2n.

c. Initialize freq_first and freq_second as arrays of size n+1, initialized to 0.

d. Iterate through the first n elements of a, increment freq_first[a[i]] for each i from 0 to n-1.

e. Iterate through the second n elements of a, increment freq_second[a[i]] for each i from n to 2n-1.

f. Create lists list_A, list_B, list_C.

g. For each h from 1 to n:

i. If freq_first[h] == 2, append h to list_A.

ii. If freq_second[h] == 2, append h to list_B.

iii. If freq_first[h] == 1 and freq_second[h] == 1, append h to list_C.

h. Determine the maximum even m such that m <= c, and (2k - m)/2 <= a, and (2k - m)/2 <= b.

i. Set p = (2k - m)/2

j. Select m numbers from list_C, p numbers from list_A, and p numbers from list_B.

k. Construct l and r as follows:

- For each of the m numbers from list_C:

- Find the position of this number in the first half, add it to l.

- Find the position of this number in the second half, add it to r.

- For each of the p numbers from list_A:

- Add both positions of this number in the first half to l.

- For each of the p numbers from list_B:

- Add both positions of this number in the second half to r.

l. Output l and r.

Now, I need to handle the selection of positions efficiently.

To do this, I can precompute the positions of each number in the first and second halves.

Let's define:

- pos_first[h]: list of positions (indices) of h in the first half.

- pos_second[h]: list of positions (indices) of h in the second half.

Then, for numbers in list_C, I can pick one position from pos_first[h] for l and one from pos_second[h] for r.

For numbers in list_A, I can pick both positions from pos_first[h] for l.

For numbers in list_B, I can pick both positions from pos_second[h] for r.

This way, I can construct l and r efficiently.

Now, let's think about implementing this.

I need to make sure that I handle the indexing correctly.

Given that a is 0-indexed, the first half is a[0] to a[n-1], and the second half is a[n] to a[2n-1].

I need to collect the positions for each number in these halves.

Also, I need to ensure that I select the positions correctly when building l and r.

Let me outline the steps more concretely:

1. Read t.

2. For each test case:

a. Read n and k.

b. Read the array a of length 2n.

c. Initialize pos_first and pos_second as lists of lists, with n+1 empty lists each.

d. For i from 0 to n-1:

- h = a[i]

- pos_first[h].append(a[i])

e. For i from n to 2n-1:

- h = a[i]

- pos_second[h].append(a[i])

Wait, no, I need to store the positions, not the values again.

Wait, actually, since the array contains values from 1 to n, and each value appears exactly twice, I need to store the indices where each value appears.

Let me correct that.

Let me use dictionaries to store the positions.

Define pos_first and pos_second as dictionaries where keys are the numbers from 1 to n, and values are lists of positions where the number appears in the respective halves.

Wait, but since each number appears at most twice in each half, I can store the positions directly.

Let me adjust the approach.

Define pos_first and pos_second as lists of lists, where pos_first[h] contains the positions (indices) in the first half where h appears.

Similarly, pos_second[h] contains the positions (indices) in the second half where h appears.

Given that, I can proceed as follows:

1. Read t.

2. For each test case:

a. Read n and k.

b. Read the array a of length 2n.

c. Initialize pos_first and pos_second as lists of n+1 empty lists each.

d. For i from 0 to n-1:

- h = a[i]

- pos_first[h].append(i)

e. For i from n to 2n-1:

- h = a[i]

- pos_second[h].append(i)

f. Initialize list_A, list_B, list_C as empty lists.

g. For h from 1 to n:

- if len(pos_first[h]) == 2:

- append h to list_A

- elif len(pos_second[h]) == 2:

- append h to list_B

- elif len(pos_first[h]) == 1 and len(pos_second[h]) == 1:

- append h to list_C

h. Determine m, p:

- Find the maximum even m such that m <= len(list_C) and (2k - m)/2 is an integer and (2k - m)/2 <= len(list_A) and (2k - m)/2 <= len(list_B)

- Iterate m from 2k downto 0 in steps of 2, and find the smallest m that satisfies m <= len(list_C) and (2k - m)/2 <= len(list_A) and (2k - m)/2 <= len(list_B)

i. Set p = (2k - m)/2

j. Select m numbers from list_C, p numbers from list_A, and p numbers from list_B.

- For example, take the first m numbers from list_C, first p from list_A, and first p from list_B.

k. Construct l and r:

- For each of the m numbers from list_C:

- Add pos_first[h][0] to l (first occurrence in the first half)

- Add pos_second[h][0] to r (first occurrence in the second half)

- For each of the p numbers from list_A:

- Add pos_first[h][0] and pos_first[h][1] to l

- For each of the p numbers from list_B:

- Add pos_second[h][0] and pos_second[h][1] to r

l. Output l and r.

Wait, but in the output, we need to output the values, not the positions.

Wait, the problem says:

"l is a subset of [a1,a2,…an] and r is a subset of [an+1,…a2n]"

And:

"A sequence x is a subset of a sequence y if x can be obtained by deleting several (possibly none or all) elements of y and rearranging the elements in any order."

So, it's about selecting elements from the first half for l and from the second half for r, and outputting them in any order.

Therefore, I need to output the values, not their positions.

So, in the construction of l and r, I need to collect the values, not the positions.

Wait, but in the earlier step, I thought about collecting positions, but actually, I need to collect the values.

Wait, no, since the values are duplicated, I need to ensure that I select the correct occurrences.

Wait, but since the array is just a list of values, and I need to select specific occurrences from the first half or the second half, but in the output, I just need to output the values, not their positions.

So, perhaps I don't need to track positions, but rather track which occurrences belong to which half.

Wait, but in the output, it's about selecting subsets from the first half and second half, but since the values are duplicated, I need to ensure that I'm selecting the correct occurrences.

But in the output, I just need to output the values, not their positions.

Wait, but in the sample input, for n=2, k=1, a=[1,2,2,1], the output is l=[2,1], r=[2,1].

So, l is selecting the second 2 and the first 1 from the first half, and r is selecting the second 2 and the first 1 from the second half.

But in terms of values, it's [2,1] for both l and r.

So, in the output, it's just the values, not their positions.

Therefore, I can output the values directly, without worrying about their positions.

Hence, in the construction of l and r, I can collect the values based on the groups.

Let me adjust the steps accordingly.

1. Read t.

2. For each test case:

a. Read n and k.

b. Read the array a of length 2n.

c. Initialize freq_first and freq_second as arrays of size n+1, initialized to 0.

d. For i from 0 to n-1:

- h = a[i]

- freq_first[h] += 1

e. For i from n to 2n-1:

- h = a[i]

- freq_second[h] += 1

f. Initialize list_A, list_B, list_C as empty lists.

g. For h from 1 to n:

- if freq_first[h] == 2:

- append h to list_A

- elif freq_second[h] == 2:

- append h to list_B

- elif freq_first[h] == 1 and freq_second[h] == 1:

- append h to list_C

h. Determine m, p:

- Find the maximum even m such that m <= len(list_C) and (2k - m)/2 is an integer and (2k - m)/2 <= len(list_A) and (2k - m)/2 <= len(list_B)

- Iterate m from 0 to 2k in steps of 2, and find the largest m that satisfies m <= len(list_C) and (2k - m)/2 <= len(list_A) and (2k - m)/2 <= len(list_B)

i. Set p = (2k - m)/2

j. Select m numbers from list_C, p numbers from list_A, and p numbers from list_B.

- For example, take the first m numbers from list_C, first p from list_A, and first p from list_B.

k. Construct l and r:

- For each of the m numbers from list_C:

- Add one occurrence from the first half to l (which is the value h)

- Add one occurrence from the second half to r (which is the value h)

- For each of the p numbers from list_A:

- Add both occurrences from the first half to l (which are two h's)

- For each of the p numbers from list_B:

- Add both occurrences from the second half to r (which are two h's)

l. Output l and r.

Wait, but in reality, since I'm adding values, and each h is added once from the first half and once from the second half for list_C, and twice from the first half for list_A, and twice from the second half for list_B, I need to ensure that I'm selecting the correct occurrences.

But in the output, it's just the values, so perhaps it's acceptable to output the values directly, assuming that the subsets are valid.

However, to make sure that I'm selecting the correct occurrences, perhaps I need to track the positions after all.

Wait, but the problem allows any valid selection, so maybe it's acceptable to output the values directly, assuming that the subsets are valid.

Given that, I can proceed with collecting the values as per the groups.

Let me try to implement this logic in code.

But before that, I need to make sure that this approach works.

Let's verify with the sample input.

First test case:

