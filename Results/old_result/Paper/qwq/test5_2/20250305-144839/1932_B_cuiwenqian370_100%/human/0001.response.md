Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n signs of the apocalypse, and each sign occurs every a_i years. The signs have to occur sequentially, meaning that after the first sign occurs, we start waiting for the second sign in the next year, and so on.

First, I need to understand how the signs occur. Each sign i occurs in years that are multiples of a_i, like a_i, 2*a_i, 3*a_i, and so on. But they have to occur one after another in sequence.

So, for example, if n=3 and a=[2,3,4], that means:

- The first sign occurs in years 2, 4, 6, 8, etc.

- After the first sign occurs, we start waiting for the second sign in the next year.

- The second sign occurs in years 3, 6, 9, etc.

- Similarly, after the second sign occurs, we start waiting for the third sign in the next year.

- The third sign occurs in years 4, 8, 12, etc.

I need to find the year when all n signs have occurred in this sequential manner.

Let me try to think step by step.

Start with the first sign. It occurs in year a_1. So, the first sign happens in year a_1.

Now, starting from year a_1 + 1, we wait for the second sign to occur. The second sign occurs in years that are multiples of a_2.

So, I need to find the smallest year y2 >= a1 + 1 such that y2 is a multiple of a2.

Then, starting from y2 + 1, wait for the third sign, which occurs in multiples of a3. Find the smallest year y3 >= y2 + 1 such that y3 is a multiple of a3.

Continue this process until the nth sign.

So, essentially, for each sign after the first, find the smallest multiple of a_i that is greater than the year the previous sign occurred.

That makes sense.

Let me formalize this.

Let y1 = a1.

Then, for i from 2 to n:

yi = smallest year >= y_{i-1} + 1 where yi % ai == 0.

Finally, yn is the year when the nth sign occurs.

So, the answer is yn.

Now, how do I compute this efficiently?

Given that n can be up to 100 and a_i can be up to 10^6, and t can be up to 1000, I need an efficient way to compute this.

Let's think about how to find yi for each i.

Given yi-1, I need yi >= yi-1 + 1 and yi % ai == 0.

This is equivalent to finding the smallest multiple of ai that is greater than or equal to yi-1 + 1.

I know that the smallest multiple of ai greater than or equal to some year x is ceil(x / ai) * ai.

So, yi = ceil(yi-1 + 1 / ai) * ai.

In integer arithmetic, ceil(x / y) can be computed as (x + y - 1) // y.

So, yi = ((yi-1 + 1 + ai - 1) // ai) * ai.

Simplify: yi = ((yi-1 + ai) // ai) * ai.

That's a nice formula.

So, starting with y1 = a1, iterate from i=2 to n:

yi = ((yi-1 + ai) // ai) * ai.

Finally, yn is the answer.

Let me test this with the first example.

Example 1:

n=6

a=[3,2,4,5,9,18]

Compute y1 = 3

Then y2 = ((3 + 2) // 2) * 2 = (5 // 2) * 2 = 2 * 2 = 4

Wait, but according to the explanation, y2 should be 4, which matches.

Then y3 = ((4 + 4) // 4) * 4 = (8 // 4) * 4 = 2 * 4 = 8

Matches the explanation.

y4 = ((8 + 5) // 5) * 5 = (13 // 5) * 5 = 3 * 5 = 15

But in the explanation, it says waiting for the fourth sign in the 10th year. Wait, discrepancy here.

Wait, let's check the explanation again.

In the first set of input data of the example:

- The tribe will wait for the first sign in the 3-rd year;

- the tribe will wait for the second sign in the 4-th year (since year 2 have already passed);

- the tribe will wait for the third sign in the 8-th year (since the second sign has already occurred in the 4-th year);

- the tribe will wait for the fourth sign in the 10-th year (since year 5 have already passed);

- the tribe will wait for the fifth sign in the 18-th year (since year 9 have already passed);

- the tribe will wait for the sixth sign in the 36 -th year (since the fifth sign has already occurred in the 18 -th year).

Wait, in my calculation, y4 came out to be 15, but according to the explanation, they wait for the fourth sign in the 10th year.

Hmm, there's a mismatch here.

Wait, maybe I misunderstood the problem.

Let me read the problem statement again.

"for the apocalypse to happen, the signs must occur sequentially. That is, first they wait for the first sign to occur, then strictly after it, the second sign will occur, and so on. If the i-th sign occurred in year x, the tribe starts waiting for the occurrence of the (i+1)-th sign, starting from year x+1."

So, after the first sign occurs in year y1, they start waiting for the second sign in year y1 + 1.

The second sign occurs in years that are multiples of a2.

So, the second sign will occur in the smallest year >= y1 + 1 that is a multiple of a2.

Similarly, the third sign will occur in the smallest year >= y2 + 1 that is a multiple of a3, and so on.

So, in my earlier calculation, for n=6 and a=[3,2,4,5,9,18]:

y1 = 3

y2 = smallest year >= 4 that is a multiple of 2: which is 4

y3 = smallest year >= 5 that is a multiple of 4: which is 8

y4 = smallest year >= 9 that is a multiple of 5: which is 10

y5 = smallest year >= 11 that is a multiple of 9: which is 18

y6 = smallest year >= 19 that is a multiple of 18: which is 18 * 2 = 36

So, yn = 36, which matches the first sample output.

Earlier, I mistakenly calculated y4 as 15, but according to the problem, it should be 10 because they start waiting for the fourth sign in year y3 + 1 = 9, and the smallest multiple of 5 >=9 is 10.

So, my initial formula is correct: yi = smallest multiple of ai >= yi-1 + 1

Which is yi = ((yi-1 + ai) // ai) * ai

In the case of y4:

yi-1 +1 = 8 +1 =9

ai=5

((9 +5) //5 ) *5 = (14//5)*5 =3*5=15

Wait, that's not matching the earlier manual calculation.

Wait, no, in the manual calculation, the smallest multiple of 5 >=9 is 10, but according to the formula, it's giving 15.

That's inconsistent.

Wait, maybe I'm misapplying the formula.

Let me recast the formula.

The smallest multiple of ai greater than or equal to x is indeed ceil(x / ai) * ai, which in integer arithmetic is ((x + ai -1) // ai) * ai

So, for y4:

x = y3 +1 =8 +1=9

ai=5

((9 +5 -1)//5)*5 = (13//5)*5 =3*5=15

But according to the earlier manual calculation, the smallest multiple of 5 >=9 is 10, not 15.

Wait, that's incorrect. 10 is indeed the smallest multiple of 5 that is >=9.

So, there's a mistake in the formula application.

Wait, perhaps I need to double-check the formula.

ceil(x / ai) * ai should be ((x + ai -1) // ai) * ai

Let's compute it:

x=9, ai=5

((9 +5 -1)//5)*5=(13//5)*5=2*5=10

Wait, no, 13//5 is 2.6, but in integer division, it's 2, so 2*5=10.

Wait, but 13//5 is 2, and 2*5=10, which is correct.

Wait, but earlier I thought (13//5)=3, but actually, 13 divided by 5 is 2 with remainder 3, so 13//5=2.

Wait, perhaps I made a mistake in the earlier calculation.

Wait, in Python, 13//5 is 2.

So, ((9 +5 -1)//5)*5=(13//5)*5=2*5=10

So, y4=10, which matches the manual calculation.

I must have miscalculated earlier.

So, the formula is correct: yi = ((yi-1 +1 + ai -1)//ai)*ai = ((yi-1 + ai)//ai)*ai

Wait, in the earlier step, I saw that ((yi-1 + ai)//ai)*ai gives the smallest multiple of ai greater than or equal to yi-1 +1.

Wait, no, let's see.

Given x = yi-1 +1, and we want the smallest multiple of ai >= x.

That is ceil(x / ai) * ai, which is ((x + ai -1)//ai)*ai

Which is ((yi-1 +1 + ai -1)//ai)*ai = ((yi-1 + ai)//ai)*ai

So, the formula is correct.

In the y4 case:

yi-1=8, ai=5

((8 +5)//5)*5=(13//5)*5=2*5=10

Which matches the manual calculation.

So, earlier I mistakenly thought 13//5=3, but actually, it's 2.

Hence, y4=10, not 15.

So, the formula is correct.

Therefore, the approach is to iterate from i=1 to n:

- y1 = a1

- for each subsequent i from 2 to n:

- yi = ((yi-1 + ai)//ai)*ai

Finally, yn is the answer.

This seems efficient, as it's O(n) per test case, and n<=100, t<=1000, so total time is acceptable.

Now, looking at the given program:

if __name__ == '__main__':

func_1()

def func_1():

import sys

input = sys.stdin.read

data = input().split()

index = 0

T = int(data[index])

index += 1

results = []

for _ in range(T):

n = int(data[index])

index += 1

a = list(map(int, data[index:index + n]))

index += n

last_year = a[0]

for i in range(1, n):

next_year = (last_year + 1 + a[i] - 1) // a[i] * a[i]

last_year = next_year

results.append(str(last_year))

sys.stdout.write('\n'.join(results) + '\n')

This program seems to implement exactly the approach I just described.

It reads all input at once, splits it into tokens, and processes each test case one by one.

For each test case, it reads n and then the array a of size n.

It initializes last_year to a[0], which is y1.

Then, for each i from 1 to n-1, it computes the next_year using the formula:

next_year = (last_year + 1 + a[i] - 1) // a[i] * a[i]

Which matches the formula I derived: ((yi-1 +1 + ai -1)//ai)*ai

After computing yn, it appends it to the results list.

Finally, it prints all results separated by newline.

This seems correct.

Let me verify with the sample input and output.

Sample Input:

4

6

3 2 4 5 9 18

5

1 2 3 4 5

5

1 1 1 1 1

6

50 30 711 200 503 1006

Sample Output:

36

5

5

2012

Let's compute the first one:

n=6, a=[3,2,4,5,9,18]

y1=3

y2=((3+1 +2 -1)//2)*2 = (5//2)*2=2*2=4

y3=((4+1 +4 -1)//4)*4=(8//4)*4=2*4=8

y4=((8+1 +5 -1)//5)*5=(13//5)*5=2*5=10

y5=((10+1 +9 -1)//9)*9=(19//9)*9=2*9=18

y6=((18+1 +18 -1)//18)*18=(36//18)*18=2*18=36

Which matches the first sample output: 36

Second test case:

n=5, a=[1,2,3,4,5]

y1=1

y2=((1+1 +2 -1)//2)*2=(3//2)*2=1*2=2

y3=((2+1 +3 -1)//3)*3=(5//3)*3=1*3=3

y4=((3+1 +4 -1)//4)*4=(7//4)*4=1*4=4

y5=((4+1 +5 -1)//5)*5=(9//5)*5=1*5=5

Which matches the second sample output:5

Third test case:

n=5, a=[1,1,1,1,1]

y1=1

y2=((1+1 +1 -1)//1)*1=(2//1)*1=2*1=2

y3=((2+1 +1 -1)//1)*1=(3//1)*1=3*1=3

y4=((3+1 +1 -1)//1)*1=(4//1)*1=4*1=4

y5=((4+1 +1 -1)//1)*1=(5//1)*1=5*1=5

Which matches the third sample output:5

Fourth test case:

n=6, a=[50,30,711,200,503,1006]

y1=50

y2=((50+1 +30 -1)//30)*30=(80//30)*30=2*30=60

y3=((60+1 +711 -1)//711)*711=(711//711)*711=1*711=711

y4=((711+1 +200 -1)//200)*200=(911//200)*200=4*200=800

y5=((800+1 +503 -1)//503)*503=(1303//503)*503=2*503=1006

y6=((1006+1 +1006 -1)//1006)*1006=(2012//1006)*1006=2*1006=2012

Which matches the fourth sample output:2012

So, all sample inputs give the correct outputs with this approach.

Therefore, the given program is correct.

**Final Answer**

\[ \boxed{ \text{The given program is correct.} } \]