Alright, I have this problem here about Alice and Bob playing a game with their wallets. Each has some coins, and they take turns making moves according to some rules. I need to determine who wins the game if both play optimally.

First, let's understand the problem clearly. Alice starts with 'a' coins and Bob with 'b' coins. In each turn, the player can choose to exchange wallets with the opponent or keep their current wallets. After that, they remove one coin from their current wallet, and the wallet can't have zero coins before removing.

The player who can't make a valid move loses. So, I need to figure out, for given a and b, who will win the game.

I need to think about game theory here, specifically about impartial games where the set of moves available depends only on the position and not on which player's turn it is.

First, let's consider some small values of a and b to see if I can find a pattern.

**Test Case 1:**

a = 1, b = 1

- Alice's turn: She can choose to swap or not.

- If she swaps, she has b=1, removes 1, so a=0, b=0.

- Bob's turn: He can't remove a coin because both wallets are empty. So, Bob loses.

- But according to the sample input, output is "Bob". Wait, that's the first test case in the sample input, but the output is "Bob". Hmm, maybe I'm misunderstanding.

Wait, in the note, it says:

In the first test case, an example of the game is shown below:

- Alice chooses to not swap wallets with Bob in step 1 of her move. Now, a=0 and b=1.

- Since Alice's wallet is empty, Bob must choose to not swap their wallets in step 1 of his move. Now, a=0 and b=0.

- Since both Alice's and Bob's wallets are empty, Alice is unable to make a move. Hence, Bob wins.

So, in this scenario, Alice chooses not to swap, and then removes 1 from her wallet, making a=0 and b=1.

Then, Bob must choose not to swap because swapping wouldn't change anything, and he removes 1 from his wallet, making b=0.

Now, Alice has a=0 and Bob has b=0. Alice can't make a move, so Bob wins.

But if Alice had chosen to swap in the first place, she would have a=1 and b=1, then removes 1 from her wallet, making a=0 and b=1 again.

Same as before.

So, regardless of whether Alice swaps or not, the outcome is the same.

**Test Case 2:**

a = 1, b = 4

- Alice's turn: She can choose to swap or not.

- If she doesn't swap: a=0, b=4.

- Bob's turn: He must choose not to swap (since swapping wouldn't help), removes 1 from his wallet: a=0, b=3.

- Alice's turn: She can't remove from her wallet since it's empty, so she must choose to swap: a=0, b=3 → a=3, b=0.

- Bob's turn: He removes 1 from his wallet: a=3, b=-1. Wait, but negative coins don't make sense. Maybe I need to reconsider.

Wait, the problem says "the current wallet cannot have 0 coins before performing this step." So, if a player has 0 coins, they can't remove a coin.

So, in this case:

- Alice has a=1, b=4.

- Alice chooses to swap: a=4, b=1.

- Removes 1 from her wallet: a=3, b=1.

- Bob's turn: He can choose to swap or not.

- If he doesn't swap: a=3, b=0.

- If he swaps: a=0, b=3.

- Either way, Alice will have to deal with a=0 and b=3 or a=3 and b=0.

- If a=3 and b=0:

- Alice removes 1: a=2, b=0.

- Bob can't remove from his wallet, so he chooses to swap: a=0, b=2.

- Alice can't remove from her wallet, so she chooses to swap: a=2, b=0.

- This continues until a=0 and b=0, and Bob can't make a move, so Alice wins.

- If Bob chooses to swap first: a=0, b=3.

- Alice must choose to not swap: a=0, b=2.

- Bob chooses to not swap: a=0, b=1.

- Alice chooses to swap: a=0, b=0.

- Bob can't make a move, so Alice wins.

So, in this case, Alice wins.

But according to the sample input, for a=1, b=4, the output is "Alice".

Okay, that makes sense.

**Test Case 3:**

a=5, b=3

- Alice's turn: chooses to swap or not.

- If she doesn't swap: a=4, b=3.

- Bob's turn: chooses to swap or not.

- If he doesn't swap: a=4, b=2.

- Alice: a=3, b=2.

- Bob: a=3, b=1.

- Alice: a=2, b=1.

- Bob: a=2, b=0.

- Alice: a=1, b=0.

- Bob: a=0, b=0.

- Alice can't make a move, so Bob wins.

- If Alice chooses to swap initially: a=3, b=5.

- Then, Bob can choose to swap or not.

- If Bob doesn't swap: a=3, b=4.

- Alice: a=2, b=4.

- Bob: a=2, b=3.

- Alice: a=1, b=3.

- Bob: a=1, b=2.

- Alice: a=0, b=2.

- Bob: a=0, b=1.

- Alice: swap to a=0, b=0.

- Bob can't make a move, so Alice wins.

- So, depending on the choices, different outcomes.

Seems complicated.

I need a better approach.

Let me think about the game in terms of game theory.

This seems like an impartial game, but with specific rules.

I need to find the winning and losing positions.

Let me try to find a general rule.

Looking at the sample inputs and outputs:

1. a=1, b=1 → Bob

2. a=1, b=4 → Alice

3. a=5, b=3 → Bob

4. a=4, b=5 → Alice

5. a=11, b=9 → Bob

6. a=83, b=91 → Bob

7. a=1032, b=9307 → Alice

8. a=839204, b=7281 → Alice

9. a=1000000000, b=1000000000 → Bob

10. a=53110, b=2024 → Bob

Looking for patterns:

- When a == b, Bob wins.

- When a == 1, Bob wins if b ==1, Alice wins if b ==4.

- When b ==1, output is Bob.

- When a > b, sometimes Alice wins, sometimes Bob wins.

- When a < b, same.

I need to find a general rule.

Looking at the code provided:

def func():

T = int(input())

for i in range(T):

(a, b) = map(int, input().split())

if a == b:

print('Bob')

elif a == 1:

print('Alice')

elif b == 1:

print('Bob')

elif a % 2 == 1:

print('Bob')

elif a % 2 == 0 and b % 2 == 1:

print('Alice')

elif a > b:

print('Bob')

else:

print('Alice')

Let's check this against the sample inputs.

Test Case 1: a=1, b=1 → a == b → Bob. Correct.

Test Case 2: a=1, b=4 → a ==1 → Alice. Correct.

Test Case 3: a=5, b=3 → a % 2 ==1 → Bob. Correct.

Test Case 4: a=4, b=5 → a % 2 ==0 and b %2 ==1 → Alice. Correct.

Test Case 5: a=11, b=9 → a %2 ==1 → Bob. Correct.

Test Case 6: a=83, b=91 → a %2 ==1 → Bob. Correct.

Test Case 7: a=1032, b=9307 → a %2 ==0 and b %2 ==1 → Alice. Correct.

Test Case 8: a=839204, b=7281 → a %2 ==0 and b %2 ==1 → Alice. Correct.

Test Case 9: a=1000000000, b=1000000000 → a == b → Bob. Correct.

Test Case 10: a=53110, b=2024 → a > b and a %2 ==0 → Bob. Correct.

Seems like the code matches all the sample inputs.

But I need to verify if this is indeed correct.

Let me think about the general strategy.

First, if a == b, then Bob wins. This seems consistent across all cases where a == b.

When a ==1, Alice wins if b !=1.

When b ==1, Bob wins.

When a is odd, Bob wins.

When a is even and b is odd, Alice wins.

Otherwise, it depends on who has more coins.

This seems to be the logic.

But I need to understand why.

Let me think in terms of game states.

Each state can be represented by (a, b), where a and b are the number of coins in Alice's and Bob's wallets, respectively.

Each player, on their turn, can choose to swap or not swap, and then remove one coin from their current wallet.

The game ends when a player cannot make a move, which happens when both wallets are empty or the player has no coins in their current wallet.

I need to find out who has a winning strategy.

This seems complex, so maybe I can look for symmetries or invariant properties.

First, consider the case when a == b.

In this case, whatever move Alice makes, Bob can mirror her move.

For example, if Alice chooses to swap, Bob can choose to swap back.

If Alice chooses not to swap, Bob can choose not to swap.

In this way, Bob can always mimic Alice's action, leading to Alice being the one who finally can't make a move.

Hence, when a == b, Bob wins.

This seems consistent with the code.

Next, consider a ==1.

If a ==1 and b ==1, Bob wins, as shown in the first test case.

If a ==1 and b >1, Alice can choose to swap, making a = b, and then b =1.

Then, Bob is left with a >1 and b=1.

Alice can continue to manipulate the game to force Bob into a losing position.

Hence, when a ==1 and b !=1, Alice wins.

Similarly, when b ==1, Bob wins.

Now, for general a and b, with a != b and a !=1 and b !=1.

The code checks if a is odd.

If a is odd, Bob wins.

If a is even and b is odd, Alice wins.

Otherwise, it checks if a > b, and if so, Bob wins, else Alice wins.

I need to verify if this logic holds.

Let me consider a=5, b=3.

a is odd, so Bob wins. Matches the sample.

a=4, b=5.

a is even and b is odd, so Alice wins. Matches the sample.

a=11, b=9.

a is odd, so Bob wins. Matches the sample.

a=83, b=91.

a is odd, so Bob wins. Matches the sample.

a=1032, b=9307.

a is even and b is odd, so Alice wins. Matches the sample.

a=839204, b=7281.

a is even and b is odd, so Alice wins. Matches the sample.

a=1000000000, b=1000000000.

a == b, so Bob wins. Matches the sample.

a=53110, b=2024.

a is even, b is even.

a > b, so Bob wins. Matches the sample.

Seems consistent.

But I need to think deeper.

Is there a mathematical formula or pattern that determines the winner based on a and b?

Let me consider the binary representations or some other properties.

Alternatively, maybe it's about the parity of a and b and their difference.

Wait, in the code, if a == b, Bob wins.

If a ==1, Alice wins (unless b ==1).

If b ==1, Bob wins.

If a is odd, Bob wins.

If a is even and b is odd, Alice wins.

Else, if a > b, Bob wins, else Alice wins.

I need to see if this covers all cases correctly.

Let me try to find a counterexample.

Suppose a=2, b=2.

a == b, Bob wins. Correct.

a=2, b=1.

According to the code: a is even, b is odd.

So, Alice wins.

But let's simulate:

Alice's turn: chooses to swap or not.

If she doesn't swap: a=1, b=1.

Bob's turn: chooses to swap or not.

If he swaps: a=1, b=1.

Alice's turn: a=0, b=1.

Bob's turn: a=0, b=0.

Alice can't make a move, so Bob wins.

Contradicts the code's logic.

Wait, according to the code, a=2, b=1: a is even and b is odd, so Alice wins.

But in simulation, Bob wins.

So, the code is incorrect in this case.

Hence, Correctness: **False**

**Final Answer**

\[ \boxed{\text{False}} \]