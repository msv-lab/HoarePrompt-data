Alright, I have this problem to solve. It's about a game that Alice and Bob are playing with piles of stones. The rules are a bit unusual compared to standard stone-removal games. Let's try to understand the problem step by step.

First, the game setup: There are n piles of stones, and each pile has a certain number of stones. On each turn, a player chooses a positive integer k that is less than or equal to the smallest number of stones in any non-empty pile and removes k stones from each non-empty pile. The player who can't make a move because all piles are empty loses.

Alice goes first, and both players play optimally. I need to determine who wins each game for multiple test cases.

Looking at the input format: The first line is the number of test cases t. For each test case, there's an integer n (number of piles), followed by n integers representing the number of stones in each pile.

Constraints are:

- t ≤ 10^4

- n ≤ 2*10^5

- a_i ≤ 10^9

And the sum of n over all test cases doesn't exceed 2*10^5.

Given these constraints, efficiency is key. I need an algorithm that's linear or nearly linear in time complexity.

Let me think about the game mechanics. The player chooses a k up to the smallest pile size and removes k stones from each pile. So, the game state changes based on the minimum pile size.

I recall that in standard Nim games, the XOR of pile sizes determines the winner. But here, the moves are different—it's not just removing from one pile; it's removing from all piles simultaneously by a certain amount.

This seems similar to the game of Nim, but with a twist. Maybe I can model it in terms of Nimbers or find some invariant.

Let's consider small examples to see a pattern.

Example 1:

n = 5

Piles: 3 3 3 3 3

Alice can choose k=3 and remove 3 from each pile, making all piles empty. So, Alice wins.

Example 2:

n = 2

Piles: 1 7

Alice must choose k=1 (since the smallest pile has 1 stone), removes 1 from each pile, making piles 0 and 6.

Now, Bob chooses k up to the smallest non-empty pile, which is 6, but since one pile is empty, the smallest non-empty is 6.

Bob chooses k=6, removes 6 from the pile of 6, making it empty. Now all piles are empty, so Bob wins.

Example 3:

n = 7

Piles: 1 3 9 7 4 2 100

Let's see:

Alice chooses k up to the smallest pile, which is 1. So, k=1.

She removes 1 from each pile:

Piles become: 0, 2, 8, 6, 3, 1, 99

Now, Bob chooses k up to the smallest non-zero pile, which is 1.

Bob chooses k=1, removes 1 from each non-empty pile:

Piles: 0,1,7,5,2,0,98

Alice chooses k up to 1, removes 1 from each non-empty pile:

Piles: 0,0,6,4,1,0,97

Bob chooses k=1, removes 1 from each non-empty pile:

Piles: 0,0,5,3,0,0,96

Alice chooses k=1, removes 1 from each non-empty pile:

Piles: 0,0,4,2,0,0,95

Bob chooses k=1, removes 1 from each non-empty pile:

Piles: 0,0,3,1,0,0,94

Alice chooses k=1, removes 1 from each non-empty pile:

Piles: 0,0,2,0,0,0,93

Bob chooses k=2, removes 2 from each non-empty pile:

Piles: 0,0,0,0,0,0,91

Now all piles are empty, so Bob wins.

Wait, but the sample output says Alice wins for this case. Did I make a mistake in the simulation?

Wait, perhaps I did. Let's try again.

Starting piles: 1,3,9,7,4,2,100

Alice chooses k=1, removes 1 from each:

0,2,8,6,3,1,99

Bob chooses k=1, removes 1 from each non-zero pile:

0,1,7,5,2,0,98

Alice chooses k=1, removes 1 from each non-zero pile:

0,0,6,4,1,0,97

Bob chooses k=1, removes 1 from each non-zero pile:

0,0,5,3,0,0,96

Alice chooses k=1, removes 1 from each non-zero pile:

0,0,4,2,0,0,95

Bob chooses k=1, removes 1 from each non-zero pile:

0,0,3,1,0,0,94

Alice chooses k=1, removes 1 from each non-zero pile:

0,0,2,0,0,0,93

Bob chooses k=2, removes 2 from the remaining pile of 93:

0,0,0,0,0,0,91

Bob wins.

But according to the sample output, Alice should win this case. Maybe my simulation is incorrect.

Wait, perhaps there's a better strategy for Alice.

Let's consider that Alice could choose a different k initially.

Wait, no—Alice must choose k up to the smallest pile size, which is 1 in this case. So k=1 is the only choice.

Hmm, perhaps I need to find a different approach altogether.

Maybe I need to think in terms of the number of stones or the number of piles.

Let me consider the game in terms of the number of non-empty piles.

At each step, the player chooses k up to the smallest pile, removes k from each non-empty pile.

This operation reduces the size of each non-empty pile by k.

So, the game progresses by reducing the piles uniformly until some piles become empty.

This seems similar to octal games or Nim games, but with a different move structure.

Perhaps I can model this game by considering the number of non-empty piles and the minimum pile size.

Let me think about the game state.

A game state is defined by the multiset of pile sizes (since the order doesn't matter).

But with large pile sizes (up to 10^9), I need an efficient way to represent the state.

An idea: consider the sorted list of pile sizes.

Let me sort the piles in non-decreasing order.

Then, at each step, the player chooses k up to the smallest pile size, removes k from each pile.

This operation is equivalent to slicing off the smallest k from all piles.

So, if I have piles [a1, a2, ..., an] sorted in non-decreasing order, choosing k minimizes the impact on the smallest piles.

Wait, maybe I can think of it in terms of the differences between piles.

Let me consider the sorted piles: a1 <= a2 <= ... <= an.

The player chooses k <= a1, then subtracts k from each ai.

So, the new piles are [a1 - k, a2 - k, ..., an - k], but any pile that becomes zero is removed.

Wait, no—according to the problem, piles become zero but are still considered (only when all are empty, the game ends).

Wait, the problem says: "remove k stones from each nonempty pile at once. The first player who is unable to make a move (because all piles are empty) loses."

So, even if some piles become zero, as long as there's at least one non-empty pile, the game continues.

Wait, but in my earlier simulation, I thought piles with zero stones are considered empty and don't participate in future moves.

Wait, but the problem says: "remove k stones from each nonempty pile at once."

So, in each move, k is chosen based on the smallest non-empty pile, and k stones are removed from each non-empty pile.

Piles that become empty still exist; it's just that in future moves, k is based on the smallest among the remaining non-empty piles.

So, the game continues until all piles are empty.

This seems similar to the concept of "ground states" in combinatorial game theory.

Alternatively, perhaps I can think of this game as a subtraction game where the subtraction is uniform across all piles.

This seems tricky.

Let me look for a pattern or a mathematical formula that can determine the winner based on the initial pile sizes.

Given the time constraints, I need an O(n log n) solution or better.

Let me consider the minimal pile size.

In each move, k is up to the smallest pile size, and k is subtracted from all non-empty piles.

This operation is similar to "trimming" all piles by k.

So, the game can be modeled as repeatedly trimming the piles by k until all piles are empty.

This seems similar to the concept of the minimal excludant (mex) in Nimber theory.

Wait, perhaps I can think of the game in terms of the mex of the pile sizes.

But I'm not sure.

Let me consider the number of distinct pile sizes.

Wait, pile sizes can be up to 10^9, so that's not practical.

Another idea: consider the sorted list of pile sizes.

Let me sort the piles in descending order: a1 >= a2 >= ... >= an.

Then, the smallest pile is an.

The player chooses k <= an and subtracts k from each ai.

So, the new pile sizes are [a1 - k, a2 - k, ..., an - k].

Any pile that becomes zero or negative is set to zero.

Wait, but according to the problem, piles are set to zero if they become empty, but they still exist.

So, in the next move, k is based on the new smallest non-zero pile.

This seems like a complex game to analyze directly.

Let me think differently.

Suppose I have all piles of the same size. What happens?

If all piles have the same size, say m, then Alice can choose k=m and remove m from each pile, making all piles empty in one move. So, Alice wins.

If there are piles of different sizes, it's more complicated.

Looking back at the sample input:

First test case: 5 piles of 3 each. Alice wins by choosing k=3.

Second test case: 1 and 7. Alice chooses k=1, Bob chooses k=6, Bob wins.

Third test case: 1,3,9,7,4,2,100. According to sample output, Alice wins.

But in my earlier simulation, Bob won, which contradicts the sample output. So, perhaps my simulation had a mistake.

I need a better approach.

Let me consider the game in terms of "Nim heaps." Maybe each pile corresponds to a Nim heap, and the game is equivalent to a standard Nim game.

But in standard Nim, players choose one heap and remove any number of stones from it. Here, players remove the same number of stones from all non-empty piles.

So, it's different from standard Nim.

This seems more similar to the game of "Nim with a pass," but I'm not sure.

Another thought: since the operation is to subtract k from all non-empty piles, it's like decrementing all non-zero piles by k.

This is similar to the concept of "burning" in some games, where you reduce all piles uniformly.

Perhaps I can model this as a single Nim heap with a certain size.

Wait, that might not work because the interaction between piles is complex.

Let me consider the number of non-empty piles.

At each move, the player chooses k up to the smallest non-empty pile and subtracts k from each non-empty pile.

So, the number of non-empty piles decreases as piles are reduced to zero.

This seems like a variant of the game "Nim with a pass," but I need to confirm.

Another idea: consider the minimal pile size as the driving factor.

Let me sort the piles in ascending order: a1 <= a2 <= ... <= an.

Then, the smallest pile is a1.

Alice chooses k <= a1 and subtracts k from each pile.

After that, the new smallest pile is a2 - k (since a1 - k <= a2 - k <= ... <= an - k).

Assuming a2 - k > 0, because if a2 - k <= 0, then a2 becomes zero, and the new smallest is a3 - k, and so on.

This seems recursive.

Wait, perhaps I can think of the game as a sequence of moves where at each step, the minimal non-zero pile size dictates the possible k.

This seems too vague. I need a better approach.

Let me consider the number of times each pile can be reduced before it becomes zero.

For example, a pile of size m can be reduced m times, each time by k=1.

But in this game, k can be up to the smallest pile size, so moves can be larger.

I need to find a way to calculate the total number of moves possible in the game.

If the total number of moves is odd, Alice wins; if even, Bob wins.

But I need to confirm if this is correct.

Wait, in the first sample, Alice makes one move and wins, which is odd.

In the second sample, Alice makes one move, then Bob makes one move and wins, total two moves, which is even, and Bob wins.

In the third sample, according to the sample output, Alice wins, so perhaps total moves are odd.

Wait, but in my earlier simulation, Bob won, which contradicts the sample output.

So, perhaps my simulation was incorrect.

Let me try to find a better way.

I recall that in impartial games, the Grundy number (or Nimber) can determine the winner.

The Grundy number for a game state is the mex (minimal excludant) of the Grundy numbers of the positions reachable in one move.

If the Grundy number of the initial position is non-zero, the first player wins; otherwise, the second player wins.

So, perhaps I can compute the Grundy number for this game.

But given the large constraints, I need an efficient way to compute it.

Let me try to find a pattern or a mathematical formula.

First, consider games with one pile.

If there's only one pile of size m, the player can choose k up to m, and remove k stones from it, making it m - k.

But since there's only one pile, and k must be up to m, the game continues until m is reduced to zero.

In this case, the number of moves is m, and the winner depends on whether m is odd or even.

But in our game, there are multiple piles, and moves affect all piles simultaneously.

So, this is more complex.

Let me consider two piles.

Suppose we have two piles with sizes a and b, where a <= b.

Alice chooses k up to a, say k, and removes k from both piles, making them a - k and b - k.

If a - k = 0, then only one pile remains non-empty, which is b - k.

Then, Bob can choose k up to b - k and removes it from the remaining pile, making it zero.

So, total moves are two: Alice and Bob.

So, Bob wins.

Wait, but if a - k > 0, then both piles are reduced.

Wait, no, if a - k = 0, then one pile becomes zero, and the other is b - k.

Then, Bob chooses k up to b - k and removes it from the remaining non-empty pile, making it zero.

So, total moves: Alice (1 move) + Bob (1 move) = 2 moves, even, Bob wins.

If a - k > 0, then both piles are reduced, and the game continues.

This seems complicated.

Let me think differently.

I recall that in games where moves affect multiple components simultaneously, the game can sometimes be decomposed into simpler games.

But I'm not sure how to apply that here.

Another idea: consider the differences between sorted pile sizes.

Let me sort the piles in ascending order: a1 <= a2 <= ... <= an.

Then, the game can be represented by the differences between consecutive piles.

Wait, not sure.

Let me consider the following:

- The minimal pile size is a1.

- Alice chooses k <= a1, removes k from each pile.

- New pile sizes: a1 - k, a2 - k, ..., an - k.

- If a1 - k = 0, then the first pile is empty, and the game continues with the remaining piles.

This seems similar to the concept of "domino" games, where moves in one pile affect others.

But I need a way to calculate the Grundy number or determine the winner efficiently.

Given time constraints, I need an O(n log n) solution.

Let me consider that the game can be represented by the number of non-empty piles and the minimal pile size.

Wait, perhaps I can think of the game in terms of the number of times the minimal pile size changes.

Each time the minimal pile size changes, it affects the possible moves.

Wait, perhaps not.

Let me consider that the game ends when all piles are empty, which is when the minimal pile size is zero.

Each move reduces the minimal pile size by k.

So, perhaps the number of moves is equal to the number of times we can choose k > 0 until the minimal pile size is zero.

But I need to confirm this.

Wait, suppose we have piles [1,2,3].

Alice chooses k=1, removes 1 from each, piles become [0,1,2].

Bob chooses k=1, removes 1 from each non-zero pile, piles become [0,0,1].

Alice chooses k=1, removes 1 from the last pile, piles become [0,0,0].

Total moves: 3, which is odd, Alice wins.

Sample output says Alice wins, which matches.

Another example: [1,7].

Alice chooses k=1, piles become [0,6].

Bob chooses k=6, piles become [0,0].

Total moves: 2, even, Bob wins.

Matches sample output.

Another example: [1,3,9,7,4,2,100].

From earlier simulation, I thought Bob wins, but sample output says Alice wins.

Total moves: odd number.

So, perhaps the winner depends on whether the total number of moves is odd or even.

If total moves are odd, Alice wins; even, Bob wins.

If that's the case, then I need to find the total number of moves in the game.

But is that always true?

Wait, in the first example, [3,3,3,3,3], Alice chooses k=3, all become zero in one move, which is odd, Alice wins.

Second example, [1,7], two moves, even, Bob wins.

Third example, [1,3,9,7,4,2,100], sample output says Alice wins, which would correspond to an odd number of moves.

So, perhaps the parity of the number of moves determines the winner.

If that's the case, I need to find if the total number of moves is odd or even.

But how do I find the total number of moves efficiently?

Given that n can be up to 2*10^5 and t up to 10^4, with sum of n over all test cases up to 2*10^5, I need an O(n log n) per test case solution.

Let me think about how to calculate the number of moves.

Each move consists of choosing k up to the smallest non-zero pile and subtracting k from each non-zero pile.

This is similar to "trimming" all piles by k.

So, the game can be thought of as a sequence of such trim operations until all piles are zero.

I need to find the number of such trim operations.

Wait, perhaps I can sort the piles in descending order and calculate the number of times the pile size changes.

Wait, let's sort the piles in descending order: a1 >= a2 >= ... >= an.

Initialize count = 0.

While a1 > 0:

    k = a_n (smallest non-zero pile)

    for each ai > 0:

        ai -= k

    count += 1

This is similar to the number of times we can make such a move.

But this is too slow for large n.

I need a smarter way.

Let me consider that each trim operation reduces all non-zero piles by the smallest non-zero pile size.

So, the number of moves is equal to the number of distinct non-zero pile sizes in some order.

Wait, perhaps the number of moves is equal to the number of distinct pile sizes in the sorted list.

Wait, not necessarily.

Let me consider piles [3,2,1].

Sort descending: [3,2,1].

First move: k=1, subtract 1 from each, piles become [2,1,0].

Second move: k=1, subtract 1 from each non-zero pile, piles become [1,0,0].

Third move: k=1, subtract 1 from the remaining pile, piles become [0,0,0].

Total moves: 3, which is odd, Alice wins.

Another example: [4,2,1].

Sort: [4,2,1].

First move: k=1, piles become [3,1,0].

Second move: k=1, piles become [2,0,0].

Third move: k=2, piles become [0,0,0].

Total moves: 3, odd, Alice wins.

Another example: [5,3,1].

Sort: [5,3,1].

First move: k=1, piles become [4,2,0].

Second move: k=2, piles become [2,0,0].

Third move: k=2, piles become [0,0,0].

Total moves: 3, odd, Alice wins.

Wait, in these examples, the number of moves seems to be equal to the number of distinct non-zero pile sizes.

Wait, in [3,2,1], distinct sizes are 1,2,3 – 3 moves.

In [4,2,1], distinct sizes are 1,2,4 – 3 moves.

In [5,3,1], distinct sizes are 1,3,5 – 3 moves.

Seems matching.

Let me check [1,7].

Sorted: [7,1].

Distinct sizes: 1,7 – 2 moves, even, Bob wins.

Another test: [1,1,1].

Sorted: [1,1,1].

Distinct sizes: 1 – 1 move, Alice wins.

Another test: [2,2,1].

Sorted: [2,2,1].

Distinct sizes: 1,2 – 2 moves, Bob wins.

Wait, but according to the earlier simulation:

[2,2,1]

Alice chooses k=1, piles become [1,1,0].

Bob chooses k=1, piles become [0,0,0].

Total moves: 2, Bob wins.

Matches the distinct sizes count of 2.

Another test: [3,3,1].

Sorted: [3,3,1].

Distinct sizes: 1,3 – 2 moves, Bob wins.

Simulation:

Alice chooses k=1, piles become [2,2,0].

Bob chooses k=2, piles become [0,0,0].

Total moves: 2, Bob wins.

Another test: [4,3,2,1].

Sorted: [4,3,2,1].

Distinct sizes: 1,2,3,4 – 4 moves, even, Bob wins.

Simulation:

Alice chooses k=1, piles become [3,2,1,0].

Bob chooses k=1, piles become [2,1,0,0].

Alice chooses k=1, piles become [1,0,0,0].

Bob chooses k=1, piles become [0,0,0,0].

Total moves: 4, even, Bob wins.

Seems consistent.

Another test: [1,1,2,2,3,3].

Sorted: [3,3,2,2,1,1].

Distinct sizes: 1,2,3 – 3 moves, odd, Alice wins.

Simulation:

Alice chooses k=1, piles become [2,2,1,1,0,0].

Bob chooses k=1, piles become [1,1,0,0,0,0].

Alice chooses k=1, piles become [0,0,0,0,0,0].

Total moves: 3, Alice wins.

Perfect.

So, it seems that the number of distinct non-zero pile sizes determines the number of moves, which in turn determines the winner based on parity.

Hence, to solve the problem, I need to find the number of distinct pile sizes in each test case, ignoring zeros.

If the number of distinct pile sizes is odd, Alice wins; if even, Bob wins.

Wait, but in the third sample input, [1,3,9,7,4,2,100], the distinct sizes are 1,2,3,4,7,9,100 – 7, which is odd, so Alice wins.

Sample output matches.

Another test: [2,1,3,4,2,4], distinct sizes are 1,2,3,4 – 4, even, Bob wins.

Sample output matches.

Single pile: [1000000000], distinct sizes: 1 – odd, Alice wins.

Sample output matches.

So, this seems to be a correct approach.

Hence, in the code, for each test case, I need to:

- Read n and the pile sizes.

- Sort the pile sizes in descending order.

- Count the number of distinct pile sizes (ignoring zeros, but since piles start with at least 1, no need to ignore zeros).

- If the count is odd, print "Alice"; else, print "Bob".

Wait, but in the simulation, I saw that sometimes the game can end with fewer moves than the number of distinct sizes.

Wait, in [1,7], distinct sizes are 1 and 7 – 2, which is even, Bob wins.

Which matches the sample.

In [1,3,9,7,4,2,100], distinct sizes are 1,2,3,4,7,9,100 – 7, which is odd, Alice wins.

Again matches the sample.

So, perhaps my initial observation holds.

But I need to confirm this.

Wait, perhaps it's the number of times the minimal pile changes.

Wait, in [1,7], first move k=1, piles become [0,6].

Then, k=6, piles become [0,0].

Two moves, even, Bob wins.

In [1,3,9,7,4,2,100], as per sample output, Alice wins, which would correspond to an odd number of moves.

But in my earlier simulation, I thought Bob won, which was incorrect.

Perhaps I miscalculated the number of moves.

Given that the sample output says Alice wins for this case, and according to my new approach, with 7 distinct sizes, it's odd, Alice wins.

So, perhaps my simulation was wrong.

Hence, I'll proceed with this approach.

Hence, the code should:

- For each test case, read n and the pile sizes.

- Sort the pile sizes in descending order.

- Count the number of distinct pile sizes.

- If the count is odd, print "Alice"; else, print "Bob".

This should be efficient enough, as sorting 2*10^5 elements is feasible, given the time constraints.

Now, looking at the given code:

from collections import *

from math import *

from heapq import *

import sys

from bisect import *

from random import randint

rrr = randint(8888, 88888)

for _ in range(int(input())):

func_1()

def func_1():

N = int(input())

nums = set(input().split())

nums.add('0')

nums = sorted(map(int, nums))

ls = 0

for i in range(len(nums)):

nums[i] -= ls

ls += nums[i]

nw = True

cw = True

for i in range(len(nums) - 2, 0, -1):

if nums[i] == 1:

cw = not nw

else:

cw = True

nw = cw

if cw:

print('Alice')

else:

print('Bob')

This code seems overly complicated for the problem.

It reads the pile sizes, converts them to integers, sorts them, and then performs some operations that are not immediately clear.

Given that my approach is to count the number of distinct pile sizes and determine the parity, this code seems unnecessary complex.

Perhaps it's implementing some game theory concept that I'm not understanding.

But based on my analysis, I think the code is incorrect.

Wait, in the code:

nums = set(input().split())

This reads the pile sizes as strings, converts them to a set to get unique values.

Then, nums.add('0') adds zero to the set.

Then, nums = sorted(map(int, nums)) sorts the unique pile sizes including zero.

Then, it initializes ls = 0.

Then, for each i in range(len(nums)):

nums[i] -= ls

ls += nums[i]

This seems to be accumulating something.

Then, it sets nw = True and cw = True.

Then, for i in range(len(nums) - 2, 0, -1):

if nums[i] == 1:

cw = not nw

else:

cw = True

nw = cw

Finally, if cw is True, print "Alice"; else, print "Bob".

I'm not sure what this code is trying to do.

Given that my approach is simpler and seems correct based on the sample inputs, I would say that this code is incorrect.

Wait, in my approach, I need to count the number of distinct pile sizes and check if it's odd or even.

So, in code, for each test case:

Read n

Read the list of a_i

Sort the list

Count the number of unique a_i

If count % 2 == 1:

print "Alice"

else:

print "Bob"

This would be efficient enough.

But the given code is doing something different.

Hence, I conclude that the given program is incorrect.

## Final Solution
To solve this problem, we need to determine the winner of a game played on piles of stones, where players remove a positive integer k (up to the smallest pile size) from each non-empty pile in their turn. Alice goes first, and both players play optimally.

### Approach
1. **Insight**:
    - The game can be analyzed based on the number of distinct pile sizes.
    - If the number of distinct non-zero pile sizes is odd, Alice wins; otherwise, Bob wins.

2. **Efficient Calculation**:
    - For each test case, read the number of piles and the pile sizes.
    - Use a set to count the number of unique pile sizes (since sets automatically handle uniqueness).
    - Determine the winner based on the parity (odd or even) of the count of unique pile sizes.

### Solution Code
```python
def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    idx = 0
    t = int(data[idx])
    idx += 1
    for _ in range(t):
        n = int(data[idx])
        idx += 1
        a = list(map(int, data[idx].split()))
        idx += 1
        unique_piles = len(set(a))
        if unique_piles % 2 == 1:
            print("Alice")
        else:
            print("Bob")

if __name__ == "__main__":
    main()
```

### Explanation
1. **Reading Input**:
    - Read the number of test cases.
    - For each test case, read the number of piles and the pile sizes.

2. **Counting Unique Pile Sizes**:
    - Use a set to store unique pile sizes, which automatically handles duplicates.

3. **Determine Winner**:
    - If the number of unique pile sizes is odd, Alice wins.
    - If the number is even, Bob wins.

This approach ensures an efficient solution with a time complexity of O(n log n) due to the set operations, which is suitable given the constraints.