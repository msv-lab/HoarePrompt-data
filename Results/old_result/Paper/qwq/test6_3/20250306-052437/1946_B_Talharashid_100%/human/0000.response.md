Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I need to perform exactly k operations on it. In each operation, I can select any contiguous subarray (which could even be empty) and insert the sum of that subarray anywhere in the array. After performing k such operations, I need to find the maximum possible sum of the array, and since it can be very large, I have to output it modulo 10^9 + 7.

First, I need to understand what exactly an operation entails. I can choose any contiguous subarray, calculate its sum, and then insert that sum into the array anywhere I like. This means I can insert the sum at the beginning, end, or anywhere in between existing elements.

Let me think about what effect this operation has on the sum of the array. Initially, the sum is just the sum of the original array. When I perform an operation, I'm adding the sum of a subarray to the array, which increases the total sum by that subarray's sum.

Wait, but actually, when I insert the sum of a subarray into the array, I'm adding that value to the array, so the sum of the array increases by that amount. However, the elements of the subarray itself remain in the array; I'm just adding an extra element with the sum of the subarray.

Wait, no, let's read the problem again: "insert the sum of this subarray anywhere in the array." It seems like I'm inserting the sum as a new element in the array, without removing the original subarray elements. So, the original elements stay, and I'm adding a new element that is the sum of some subarray.

So, if I have an array [a, b, c], and I choose the subarray [b, c] with sum (b + c), I can insert (b + c) anywhere in the array, say at the beginning, making the array [(b + c), a, b, c]. Now, the sum is (b + c) + a + b + c = a + 2b + 2c.

Interesting, so by inserting the sum of a subarray, I'm effectively adding that sum to the total sum of the array.

Wait, but in the first operation, if I insert the sum of the entire array, then in the next operation, I can insert the sum of the new, larger array, and so on. It seems like I can grow the sum exponentially by repeatedly inserting larger and larger sums.

But I need to maximize the sum after exactly k operations. So, perhaps the strategy is to always insert the largest possible sum in each operation.

But how do I find the largest possible sum to insert? Well, the sum of the entire array would be the largest if all elements are positive. But the problem allows negative numbers, so I need to find the maximum subarray sum each time.

Wait, but since I can choose any contiguous subarray, including the entire array, I should always choose the one with the maximum sum.

So, in each operation, I should compute the maximum sum of any contiguous subarray, and insert that sum into the array.

But wait, the problem allows me to choose any contiguous subarray, including empty subarrays. The sum of an empty subarray is zero.

So, if all subarrays have negative sums, I can choose the empty subarray and insert zero.

But, inserting zero won't increase the sum of the array, so in that case, the sum remains the same.

But perhaps there are better strategies.

Wait, let's consider that after each operation, the array changes because I'm inserting a new element, which could be the sum of some subarray. This new element can then be part of future subarrays.

But this seems complicated to handle directly, because the array is growing with each operation.

Wait, but the problem says "insert the sum of this subarray anywhere in the array." So, I'm adding one new element to the array in each operation, which is the sum of some subarray.

So, starting with an array of size n, after k operations, the array will have size n + k.

But n and k can be up to 2*10^5, which is large, so I need an efficient algorithm.

I need to maximize the sum of the array after k operations. Since each operation adds one element, which is the sum of some subarray, I need to choose which subarray to sum in each operation to maximize the total sum.

But choosing different subarrays in each operation could lead to different total sums.

This seems dynamic programming-ish, but with k operations, it might be too slow if not handled carefully.

Wait, maybe I can find a pattern or a formula that allows me to compute the maximum sum after k operations without simulating each operation.

Let me think about the sum after k operations.

Initially, the sum is S0 = sum of the original array.

After the first operation, I insert the sum of some subarray, say S1, so the new sum is S0 + S1.

Then, in the second operation, I can insert the sum of some subarray of the new array, which includes the original elements plus the newly inserted S1.

But this seems too intertwined to handle directly.

Perhaps I need to find the maximum possible sum that can be achieved by inserting the maximum possible subarray sum in each operation.

Wait, perhaps I can find the maximum subarray sum once and keep inserting that in each operation.

But is that optimal?

Let me consider an example.

Suppose the array is [1, 2, 3], and k=2.

The maximum subarray sum is 6 (the entire array).

So, in the first operation, I insert 6, making the array [1,2,3,6], sum=12.

In the second operation, the maximum subarray sum is now 12 (the entire new array), so I insert 12, making the array [1,2,3,6,12], sum=24.

So, total sum after 2 operations is 24.

Alternatively, in the first operation, I could insert a smaller subarray sum, say 3, making the array [1,2,3,3], sum=9.

Then in the second operation, the maximum subarray sum is 9, insert 9, making [1,2,3,3,9], sum=18.

This is less than 24, so inserting the maximum subarray sum each time seems better.

Another example: array [-1, -2], k=1.

The maximum subarray sum is -1 (or choose empty subarray with sum 0).

If I choose the empty subarray, I insert 0, so the array becomes [-1, -2, 0], sum=-3.

If I choose the subarray [-1], sum=-1, insert -1, array becomes [-1, -2, -1], sum=-4.

So, better to choose the empty subarray and insert 0.

Wait, but in this case, inserting the maximum subarray sum (which is -1) would decrease the total sum, so choosing to insert 0 is better.

Wait, but according to the problem, inserting the sum of any contiguous subarray, including empty with sum 0, so in this case, inserting 0 is better than inserting a negative sum.

So, perhaps the strategy is to always insert the maximum possible subarray sum in each operation.

But how do I compute the maximum subarray sum in each step, given that the array grows with each operation?

This seems tricky.

Wait, maybe I can find a way to compute the maximum subarray sum without having to recalculate it from scratch each time.

Wait, perhaps I can find the maximum subarray sum of the original array, and then in each operation, the maximum subarray sum becomes the sum of the current array.

Wait, but the current array changes with each insertion.

Wait, perhaps there's a better way.

Let me consider that in each operation, I can add any subarray sum to the array, and I choose the one that maximizes the total sum.

So, to maximize the total sum, I should choose the largest possible subarray sum each time.

Hence, in each operation, I should insert the maximum subarray sum of the current array.

But computing this repeatedly would be too slow for large n and k.

I need a smarter approach.

Wait, perhaps I can find a formula that allows me to compute the final sum after k operations.

Let me denote:

- S0 = sum of the original array.

- M = maximum subarray sum.

Then, in the first operation, I insert M, so the new sum is S0 + M.

In the second operation, the maximum subarray sum is now S0 + M (if M is positive), so I insert S0 + M, making the new sum S0 + M + (S0 + M) = 2*S0 + 2*M.

Wait, but in reality, the maximum subarray sum after inserting M could be larger than S0 + M, because I can choose subarrays that include the newly inserted elements.

Wait, perhaps I need to think differently.

Let me consider that after each operation, I'm adding M to the sum, where M is the maximum subarray sum.

But M can change after each insertion, so this seems complicated.

Wait, perhaps I can find that M is always the same, or that it grows in a certain way.

Wait, maybe I can find that M is the maximum of the original array's subarray sums, and that inserting M allows future M to be larger.

But I'm getting confused.

Let me try to think recursively.

Let's denote Sk as the sum after k operations.

Then, Sk = Sk-1 + Mk, where Mk is the maximum subarray sum of the array after k-1 operations.

But I need to find a way to express Mk in terms of previous sums.

This seems tricky.

Wait, perhaps I can find that Mk = max(M, Sk-1), where M is the original maximum subarray sum.

But I'm not sure.

Let me consider that after each insertion, the array has new possible subarrays that include the newly inserted sums.

This seems too convoluted.

Maybe I need to look for a pattern or a mathematical formula.

Let me consider some examples.

Example 1:

n=2, k=2, a=[-4,-7]

Possible operations:

- Choose empty subarray, sum=0, insert 0.

- Choose subarray [-4], sum=-4, insert -4.

- Choose subarray [-7], sum=-7, insert -7.

- Choose subarray [-4,-7], sum=-11, insert -11.

To maximize the sum, I should choose to insert 0 in each operation, so the final sum is -4 + (-7) + 0 + 0 = -11, which modulo 10^9+7 is 999,999,996.

That matches the first test case.

Example 2:

n=3, k=3, a=[2,2,8]

Maximum subarray sum is 2+2+8=12.

First operation: insert 12, array becomes [2,2,8,12], sum=24.

Second operation: maximum subarray sum is now 24, insert 24, array becomes [2,2,8,12,24], sum=48.

Third operation: maximum subarray sum is now 48, insert 48, array becomes [2,2,8,12,24,48], sum=96.

This matches the second test case.

So, in this case, inserting the current maximum subarray sum in each operation leads to the sum doubling each time, minus the original sum.

Wait, in the first operation, sum goes from 12 to 24, second to 48, third to 96.

So, it's multiplying by 2 each time.

Wait, but 12*2=24, 24*2=48, 48*2=96.

So, it's like Sk = 2*Sk-1 - M, where M is the original maximum subarray sum.

Wait, in the first operation, S1 = S0 + M = 12 + 12 = 24.

In the second operation, S2 = S1 + M1, where M1 is the maximum subarray sum of the new array [2,2,8,12], which is 24.

But according to the formula Sk = 2*Sk-1 - M, S1 = 2*12 - 12 = 12, but it's actually 24.

Wait, perhaps Sk = 2*Sk-1.

Wait, in the first operation, S1 = S0 + M = 12 + 12 = 24.

In the second operation, S2 = S1 + M1, where M1 is the maximum subarray sum of the new array, which is 24.

So, S2 = 24 + 24 = 48.

Similarly, S3 = 48 + 48 = 96.

So, it's doubling each time.

Wait, but in the first operation, M1 = 24, which is S1.

So, Sk = S_{k-1} + M_{k-1}, and M_k = S_k.

Wait, but M_k is the maximum subarray sum of the current array.

Wait, perhaps M_k = S_{k-1}, because the maximum subarray sum is the sum of the entire array.

Wait, in the second operation, M2 = 24, which is S1.

Wait, perhaps M_k = S_{k-1}.

Then, Sk = S_{k-1} + M_k = S_{k-1} + S_{k-1} = 2*S_{k-1}.

So, Sk = 2^{k} * S0.

But in the first operation, S1 = 2*S0.

In the second operation, S2 = 2*S1 = 4*S0.

But in the example, S2 = 48, which is 4*S0.

Wait, but in the first example with negative numbers, S0 = -4 + (-7) = -11.

Then, S1 = S0 + M = -11 + 0 = -11.

S2 = S1 + M = -11 + 0 = -11.

Which matches the first test case.

Wait, but in this case, M = 0, because inserting the sum of an empty subarray.

So, in general, M is the maximum of the sum of any subarray, which could be zero if all subarrays have negative sums.

Wait, but in the second example, M is the sum of the entire array, which is positive.

So, perhaps M is the maximum subarray sum of the original array.

But in the first operation, M is chosen based on the original array.

In the second operation, M is chosen based on the new array after the first insertion.

But in the second example, M seems to be equal to S_{k-1}.

Wait, perhaps I can generalize that M_k = S_{k-1}, so Sk = S_{k-1} + M_k = 2*S_{k-1}.

Thus, Sk = 2^k * S0.

But in the first example, S0 = -11, and Sk = -11 for any k, because M=0.

Wait, but according to the formula Sk = 2^k * S0, for k=2, Sk = 4*(-11) = -44, but in reality, Sk = -11.

So, the formula doesn't hold in this case.

Wait, perhaps I need to adjust the formula.

Wait, in the first operation, S1 = S0 + M.

In the second operation, S2 = S1 + M1.

But M1 depends on the new array.

In the first example, M=0, so S1 = S0 + 0 = S0.

Then, in the second operation, M1=0 again, so S2 = S1 + 0 = S0.

Which matches the first test case.

In the second example, M=12, S1 = 12 + 12 = 24.

Then, M1=24, S2=24+24=48.

Then, M2=48, S3=48+48=96.

So, in this case, M_k = S_{k-1}, and Sk = 2*S_{k-1}.

So, Sk = 2^k * S0, but only if M_k = S_{k-1}.

But in the first example, M=0, which is not equal to S0=-11.

So, perhaps Sk = S0 + k*M, where M is the maximum subarray sum of the original array.

In the first example, M=0, so Sk = -11 + 2*0 = -11, which matches.

In the second example, M=12, Sk = 12 + 3*12 = 48, which matches.

Wait, in the second example, k=3, M=12, Sk = 12 + 3*12 = 48, which matches the sum after three operations.

Similarly, in the first example, M=0, Sk = -11 + 2*0 = -11, which matches.

Another example: n=1, k=7, a=[7]

Maximum subarray sum M=7.

Then, Sk = 7 + k*7 = 7 + 7*7 = 56.

But, let's see:

Operation 1: insert 7, array becomes [7,7], sum=14.

Operation 2: insert 14, array becomes [7,7,14], sum=28.

Operation 3: insert 28, array becomes [7,7,14,28], sum=56.

Operation 4: insert 56, array becomes [7,7,14,28,56], sum=112.

And so on.

But according to the formula Sk = 7 + k*7, for k=7, Sk=7 + 7*7=56, which matches the third test case.

Wait, but in reality, after k operations, Sk = 7*(2^k -1).

Wait, for k=1: 7 +7 =14 =7*(2^1 -1 +1)=7*2=14.

Wait, perhaps Sk = S0 * (2^k).

In the second example, Sk = 12*(2^3)=96, which matches.

In the first example, Sk = -11*(2^2)=-44, but in reality, it's -11.

Wait, doesn't match.

Wait, perhaps Sk = S0 + M*(2^k -1).

In the second example, S0=12, M=12, Sk=12 +12*(8-1)=12+84=96, which matches.

In the first example, S0=-11, M=0, Sk=-11 +0*(2^2 -1)=-11, which matches.

In the third example, S0=7, M=7, Sk=7 +7*(2^7 -1)=7 +7*127=7 +889=896, which matches the output.

So, the formula seems to be Sk = S0 + M*(2^k -1), where M is the maximum subarray sum of the original array.

Wait, but in the second example, Sk = 12 +12*(8-1)=12 +84=96, which matches.

In the first example, Sk=-11 +0*(4-1)=-11, which matches.

In the third example, Sk=7 +7*(128-1)=7 +889=896, which matches.

Another test: n=2, k=1, a=[1000000000,8]

S0=1000000008, M=1000000000+8=1000000008.

Sk=1000000008 +1000000008*(2^1 -1)=1000000008 +1000000008=2000000016.

But according to the problem, the answer should be 2, which is 2000000016 mod 10^9+7.

Yes, 2000000016 mod 1000000007 = 2000000016 - 1000000007*1 = 1000000009, which is not 2.

Wait, perhaps I'm miscalculating.

Wait, 1000000007 * 1 = 1000000007.

1000000007 * 2 = 2000000014.

2000000016 - 2000000014 = 2.

So, 2000000016 mod 1000000007 = 2, which matches the output.

So, the formula seems to hold.

Wait, but in the first example, Sk = -11 + 0*(3)= -11, which is 999999996 mod 10^9+7.

Indeed, -11 + 10^9+7 = 999999996, which matches.

So, it seems that Sk = S0 + M*(2^k -1), where M is the maximum subarray sum of the original array.

But, is this always true?

Wait, in the second example, M=12, S0=12, Sk=12 +12*(8-1)=12+84=96.

But, if I think about it, in each operation, I'm inserting M, and M is equal to S_{k-1}.

Wait, in the second operation, M1=24, which is S0 + M =12+12=24.

Then, in the third operation, M2=48, which is S1 + M1=24+24=48.

So, M_k = S_{k-1}.

But according to the formula Sk = S0 + M*(2^k -1), it seems to hold.

Wait, perhaps I need to verify it with another example.

Let's take n=1, k=1, a=[-5]

S0=-5, M=0 (since inserting empty subarray sum=0).

Sk=-5 +0*(2-1)=-5, which is correct.

Another example: n=3, k=1, a=[4,-2,8]

S0=4-2+8=10, M=10 (sum of entire array).

Sk=10 +10*(2-1)=20.

But, in reality, after one operation, insert 10, array becomes [4,-2,8,10], sum=22.

Wait, discrepancy here.

According to the formula, Sk=10 +10*(1)=20, but actual sum is 22.

Wait, perhaps I need to adjust the formula.

Wait, perhaps Sk = S0 + M*k.

In this case, Sk=10 +10*1=20, but actual sum is 22.

Wait, doesn't match.

Alternatively, Sk = S0 + M*(2^k -1), predicts Sk=10 +10*(1)=20, but actual is 22.

So, the formula is incorrect.

Wait, perhaps I need to consider that M can change after each insertion.

Wait, in this case, M=10, after inserting 10, the new array is [4,-2,8,10], whose maximum subarray sum is 10 +8 +(-2) +4=22, but that's not correct.

Wait, the maximum subarray sum is the maximum sum of any contiguous subarray.

So, in [4,-2,8,10], the maximum subarray sum is 8+10=18.

Wait, is 18 the maximum? Let's see:

Subarrays:

[4]:4

[4,-2]:2

[4,-2,8]:10

[4,-2,8,10]:22

Wait, so the maximum subarray sum is 22.

But according to the formula, Sk = S0 + M*(2^k -1) =10 +10*(1)=20, but actual is 22.

So, the formula is not holding here.

Wait, perhaps I need to consider that M is not just the maximum subarray sum of the original array, but the maximum possible M over all operations.

But that seems too vague.

Alternatively, perhaps M is the maximum subarray sum of the original array, and in each operation, I insert M, and then the new M becomes S_{k-1}.

Wait, in the first operation, I insert M=10, then the new array is [4,-2,8,10], sum=22.

Then, M1=22, so in the second operation, I insert 22, making the array [4,-2,8,10,22], sum=44.

But according to the formula Sk =10 +10*(2^2 -1)=10 +10*3=40, but actual sum is 44.

So, discrepancy again.

Wait, perhaps the formula is Sk = S0 + M*(2^k -1) - (M - S0)*(2^k -1 -k).

But that seems too convoluted.

Alternatively, perhaps Sk = S0 + M*k.

In this case, Sk=10 +10*1=20, but actual is 22.

Wait, doesn't match.

Alternatively, perhaps Sk = S0 + M*(2^k -1) - S0*(2^k -2).

Wait, plugging in k=1: Sk=10 +10*(1) -10*(0)=20, still not matching 22.

Wait, perhaps Sk = S0 + M*2^k - M.

In this case, Sk=10 +10*2 -10=10 +20 -10=20, still not 22.

Wait, perhaps Sk = S0 + M*(2^k -1) + adjustments.

This is getting too complicated.

Maybe I need to think differently.

Let me recall that in each operation, I'm inserting one element, which is the sum of some subarray.

So, in total, after k operations, I've inserted k new elements, each being the sum of some subarray.

Therefore, the total sum after k operations is the original sum plus the sum of the k inserted elements.

Now, to maximize the sum, I need to maximize the sum of these k inserted elements.

Each inserted element is the sum of some subarray of the current array.

But the current array changes with each insertion, making it tricky to model.

Wait, perhaps I can find that the maximum sum is achieved by always inserting the current maximum subarray sum.

In that case, in each operation, I insert the maximum subarray sum of the current array.

But computing this for each operation is too slow for large k.

I need a better way.

Wait, perhaps I can find a recurrence relation for Sk.

Let me denote Sk as the sum after k operations.

Let Mk be the maximum subarray sum after k operations.

Then, Sk = Sk-1 + Mk.

But Mk is the maximum subarray sum of the array after k-1 operations.

Now, after k-1 operations, the array has n + k-1 elements.

But finding Mk directly seems difficult.

Wait, perhaps Mk = Sk-1, because the entire array's sum is Sk-1, and if all elements are positive, this would be the maximum subarray sum.

But in reality, Mk can be less than Sk-1 if there are negative elements.

Wait, in the earlier example, with a=[4,-2,8], S0=10, M=10.

After inserting 10, array becomes [4,-2,8,10], sum=22.

Now, Mk (M1) is 18 (from subarray [8,10]).

Wait, but 4 + (-2) +8 +10=20, but the maximum subarray sum is [8,10]=18.

Wait, no: 4 + (-2)=2; 2 +8=10; 10 +10=20.

Wait, the cumulative sum is [4, 2, 10, 20].

Wait, the maximum subarray sum is indeed 20, from [4, -2, 8, 10].

Wait, perhaps I miscalculated earlier.

Yes, [4,-2,8,10] sum is 20.

Earlier, I thought it was 22, but that's incorrect.

So, Sk =20, which matches the formula Sk =10 +10*(2-1)=20.

Similarly, for k=2, S1=20, M1=20, S2=20 +20=40.

Actual operations: insert 10, array becomes [4,-2,8,10], sum=20.

Insert 20, array becomes [4,-2,8,10,20], sum=40.

Which matches the formula.

Wait, earlier I thought M1=18, but actually M1=20.

So, M_k = Sk-1.

Hence, Sk = Sk-1 + M_k = Sk-1 + Sk-1 = 2*Sk-1.

Thus, Sk = 2^k * S0.

But in the first example with negative numbers, S0=-11, M=0, S1=-11 +0= -11, S2=-11 +0=-11.

Which matches.

So, perhaps Sk = S0 + M*(2^k -1), where M is the maximum subarray sum of the original array.

In the first example, M=0, Sk=-11 +0*(2^2 -1)=-11.

In the second example, M=12, Sk=12 +12*(2^3 -1)=12 +12*7=96.

In the third example, M=7, Sk=7 +7*(2^7 -1)=7 +7*127=896.

In the fourth example, M=10, Sk=10 +10*(2^1 -1)=10 +0=10, but actual sum is 20.

Wait, discrepancy again.

Wait, earlier I thought M1=20, but according to the formula, Sk=10 +10*(2^1 -1)=20.

Wait, actually, Sk=10 +10*(2^1 -1)=10 +10=20, which matches the actual sum after one operation.

Wait, but earlier I thought S1=20, which matches.

Wait, perhaps I was mistaken earlier about the sum after one operation.

Wait, inserting M=10, array becomes [4,-2,8,10], sum=20, which matches Sk=20.

Then, for k=2, Sk=20 +20=40, which matches inserting M1=20.

So, the formula holds.

Wait, but earlier I thought M1=18, but actually M1=20.

So, M_k = Sk-1.

Hence, Sk = Sk-1 + M_k = Sk-1 + Sk-1 = 2*Sk-1.

Thus, Sk = 2^k * S0.

But in the first example, Sk = -11 * (2^2)= -44, but actual sum is -11.

Wait, doesn't match.

Wait, but in the first example, M=0, so Sk = S0 + M*(2^k -1)= -11 +0*(3)=-11, which matches.

In this case, M=0, so Sk = S0 +0*(2^k -1)=S0.

But according to Sk =2^k * S0, for M=S0.

Wait, perhaps Sk = S0 + M*(2^k -1), where M is the maximum subarray sum of the original array.

In the first example, M=0, Sk=-11 +0*(3)=-11.

In the second example, M=12, Sk=12 +12*(7)=96.

In the third example, M=7, Sk=7 +7*(127)=896.

In the fourth example, M=10, Sk=10 +10*(1)=20.

Which matches.

So, the formula seems to hold.

Wait, but in the first operation, S1 = S0 + M.

In the second operation, S2 = S1 + M.

And so on, up to k operations.

Hence, Sk = S0 + k*M.

But in the second example, Sk=12 +3*12=48, but according to the formula Sk=12 +12*(2^3 -1)=12 +12*7=96.

Wait, discrepancy here.

Wait, perhaps I'm confusing two different formulas.

Wait, if Sk = S0 + M*(2^k -1), then for k=1, Sk=12 +12*(1)=24, which matches the first operation.

Wait, in the second operation, Sk=24 +24=48, which is 12 +12*(3)=48.

Wait, but according to the formula Sk=12 +12*(2^k -1), for k=2, 2^2 -1=3, so 12 +12*3=48.

For k=3, 2^3 -1=7, so 12 +12*7=96, which matches.

Wait, but earlier I thought Sk = S0 + M*k, but that doesn't match the second example.

So, the correct formula is Sk = S0 + M*(2^k -1), where M is the maximum subarray sum of the original array.

Hence, in the fourth example, S0=10, M=10.

For k=1, Sk=10 +10*(1)=20, which matches.

For k=2, Sk=10 +10*(3)=40, which matches.

Hence, the general formula is Sk = S0 + M*(2^k -1).

Now, to implement this, I need to compute M, which is the maximum subarray sum of the original array.

Then, compute Sk = S0 + M*(2^k -1), and take modulo 10^9+7.

But, 2^k can be up to 2^(2*10^5), which is too large to compute directly.

Hence, I need a way to compute 2^k modulo (10^9+7).

I can use fast exponentiation for this.

Also, M can be negative, but in the formula Sk = S0 + M*(2^k -1), if M is negative, it will reduce the sum.

But, in the first example, M=0, which is correct.

In other cases, M is positive.

But, in the fourth example, M=10, which is correct.

Wait, but in the first example, M=0, which is the maximum subarray sum of the original array, since all elements are negative.

Hence, M is the maximum sum of any contiguous subarray, which could be zero if all subarrays have negative sums.

Hence, to compute M, I need to find the maximum subarray sum of the original array, which can be done using Kadane's algorithm.

Hence, the plan is:

1. Compute S0 = sum of the original array.

2. Compute M = maximum subarray sum of the original array (can be zero if all subarrays have negative sums).

3. Compute Sk = S0 + M*( (2^k modulo P) -1 ), where P=10^9+7.

4. Take Sk modulo P.

But, (2^k modulo P) -1 could be negative if 2^k modulo P <1.

Wait, no, since P is a large prime, 2^k modulo P is always between 0 and P-1.

Hence, (2^k modulo P) -1 is between -1 and P-2.

But, M could be negative, so M*( (2^k modulo P) -1 ) could be positive or negative.

Hence, Sk could be negative, so I need to take Sk modulo P, which is Sk mod P.

If Sk is negative, Sk mod P = Sk + P*ceil(-Sk/P), which effectively makes it positive.

But, in Python, the modulo operator handles negative numbers correctly, so I can just do Sk % P.

Hence, the formula is Sk = (S0 + M * (pow(2, k, P) -1)) % P.

Now, I need to implement this efficiently.

Given that t can be up to 10^4, and n and k up to 2*10^5, with sum of n and k over all test cases up to 2*10^5, I need an efficient implementation.

I can precompute the power of 2 modulo P using built-in pow function, which is efficient.

For each test case, I need to compute S0 and M.

To compute M, I can use Kadane's algorithm, which runs in O(n).

Hence, overall time complexity is O(n + k) per test case, but since k can be up to 2*10^5, and t up to 10^4, but sum of n and k over all test cases is up to 2*10^5, it should be fine.

Hence, the plan is:

- Read t, the number of test cases.

- For each test case:

- Read n and k.

- Read the array a.

- Compute S0 = sum(a).

- Compute M = maximum subarray sum of a.

- Compute Sk = (S0 + M * (pow(2, k, P) -1)) % P.

- Output Sk.

Now, to implement M, the maximum subarray sum.

I can use Kadane's algorithm:

Initialize:

current_max = 0

global_max = 0

For each element in a:

current_max = max(0, current_max + element)

global_max = max(global_max, current_max)

But, this sets global_max to 0 even if all elements are negative.

To handle cases where all elements are negative, I need to set M to 0 if global_max is negative.

Wait, no. If all subarrays have negative sums, M should be 0.

Hence, in Kadane's algorithm, if all elements are negative, current_max remains 0, and global_max remains 0.

Hence, the standard Kadane's algorithm with an adjustment to set M to 0 if global_max is negative will work.

Wait, no, in standard Kadane's, if all elements are negative, current_max would be 0, and global_max would be 0.

Hence, I can use:

Initialize:

current_max = 0

global_max = 0

For each element in a:

current_max = max(0, current_max + element)

global_max = max(global_max, current_max)

Then, M = global_max

This ensures that M is at least 0, even if all elements are negative.

Hence, this is correct.

Now, to implement this efficiently in Python, I need to handle large inputs efficiently.

Hence, I should read all input at once and process it.

But, since the constraints are high, and sum of n and k over all test cases is up to 2*10^5, I need to read input efficiently.

I can read all input at once using sys.stdin.read(), split it into tokens, and process them one by one.

This is faster than reading line by line.

Hence, I can implement a generator to yield the next token each time.

This is an efficient way to handle large inputs.

Hence, the implementation steps are:

- Read all input at once.

- Split the input into tokens.

- Define