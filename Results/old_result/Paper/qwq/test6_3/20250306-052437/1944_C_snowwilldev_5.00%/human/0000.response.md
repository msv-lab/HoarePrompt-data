Alright, I've got this problem to solve. Let's see what it's about. So, there's this game between Alice and Bob where they play on an array of size n. Alice starts with an empty array c. They take turns, with Alice going first. On Alice's turn, she picks an element from a, appends it to c, and deletes it from a. Bob, on his turn, picks an element from a, and deletes it from a. The game ends when a is empty, and the score is the MEX of c. Alice wants to maximize the score, and Bob wants to minimize it. I need to find the final score if both play optimally.

First, I need to understand what MEX is. MEX stands for minimum excludant, which is the smallest non-negative integer not present in the array. For example, MEX of [2,2,1] is 0, since 0 isn't in the array. MEX of [3,1,0,1] is 2, because 0 and 1 are present, but 2 isn't. MEX of [0,3,1,2] is 4, as 0,1,2,3 are present, but 4 isn't.

So, the goal is to find the MEX of array c after the game ends, assuming both players play optimally. Alice wants to maximize this MEX, and Bob wants to minimize it.

Let me think about how the game progresses. Alice and Bob alternate turns, with Alice going first. Alice gets to add one element to c and remove it from a, while Bob just removes an element from a.

Given that, Alice has some control over what goes into c, and Bob can interfere by removing elements that Alice might want to include in c.

I need to find a strategy for both players that leads to the optimal MEX.

Let me consider some small examples to get a feel for the problem.

Example 1:

Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Output:

2

1

0

In the first test case, n=4, a=[0,0,1,1]

Possible game play:

- Alice picks 1 and adds to c, so c=[1], a=[0,0,1]

- Bob picks 0, a=[0,1]

- Alice picks 0 and adds to c, c=[1,0], a=[1]

- Bob picks 1, a is empty, c=[1,0]

MEX of c is 2, which matches the sample output.

Another possible game:

- Alice picks 0 and adds to c, c=[0], a=[0,1,1]

- Bob picks 0, a=[1,1]

- Alice picks 1 and adds to c, c=[0,1], a=[1]

- Bob picks 1, a is empty, c=[0,1]

MEX is 2 again.

What if Alice picks differently?

- Alice picks 1 and adds to c, c=[1], a=[0,0,1]

- Bob picks 1, a=[0,0]

- Alice picks 0 and adds to c, c=[1,0], a=[0]

- Bob picks 0, a is empty, c=[1,0]

Still MEX 2.

Seems like no matter how they play, MEX is 2.

Example 2:

n=4, a=[0,1,2,3]

Possible game:

- Alice picks 0 and adds to c, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2 and adds to c, c=[0,2], a=[3]

- Bob picks 3, a is empty, c=[0,2]

MEX is 1, which matches the sample output.

Another possible game:

- Alice picks 1 and adds to c, c=[1], a=[0,2,3]

- Bob picks 0, a=[2,3]

- Alice picks 2 and adds to c, c=[1,2], a=[3]

- Bob picks 3, a is empty, c=[1,2]

MEX is 0.

Wait, but the sample output is 1. So, perhaps there's a better strategy.

Alternatively:

- Alice picks 0 and adds to c, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2 and adds to c, c=[0,2], a=[3]

- Bob picks 3, a is empty, c=[0,2]

MEX is 1.

Alternatively, if Bob picks differently:

- Alice picks 0 and adds to c, c=[0], a=[1,2,3]

- Bob picks 2, a=[1,3]

- Alice picks 1 and adds to c, c=[0,1], a=[3]

- Bob picks 3, a is empty, c=[0,1]

MEX is 2.

But Bob wants to minimize, so he would choose to pick 1, leading to MEX 1.

So, with optimal play, it's 1.

Example 3:

n=2, a=[1,1]

Possible game:

- Alice picks 1 and adds to c, c=[1], a=[1]

- Bob picks 1, a is empty, c=[1]

MEX is 0, which matches the sample output.

Another possible game:

- Alice picks 1 and adds to c, c=[1], a=[1]

- Bob picks 1, a is empty, c=[1]

MEX is 0.

No other choices.

So, in this case, it's always 0.

From these examples, it seems like the MEX depends on which elements Alice can include in c, considering Bob's interference.

I need to find a general strategy for any n and any array a.

Let me think about the properties of MEX.

MEX is the smallest non-negative integer not present in c.

To maximize MEX, Alice wants to have as many small integers in c as possible.

Bob, on the other hand, wants to minimize MEX, so he wants to prevent Alice from including certain small integers in c.

Given that Alice can choose which element to include in c, and Bob can remove elements, their strategies interact in a specific way.

Let me consider the frequency of each number in a.

Suppose I count how many times each number appears in a.

For example, in the first test case:

a = [0,0,1,1]

Count: 0:2, 1:2

In the second test case:

a = [0,1,2,3]

Count: 0:1,1:1,2:1,3:1

In the third test case:

a = [1,1]

Count: 1:2

I need to relate the counts to the possible MEX.

Let me consider that Alice wants to include as many small integers as possible in c, and Bob wants to prevent that.

Alice starts first, and they alternate turns.

Each turn, Alice can choose to add an element to c and remove it from a, while Bob just removes an element from a.

I need to find out, for each small integer i, whether Alice can ensure that i is included in c, despite Bob's attempts to prevent it.

If Alice can ensure that i is in c, then MEX cannot be i.

If Bob can prevent i from being in c, then MEX can be i.

So, for each i starting from 0 upwards, I need to determine if Alice can force i to be in c.

If Alice can force i to be in c, then MEX is at least i+1.

If Bob can prevent i from being in c, then MEX is i.

So, I need to find the smallest i such that Bob can prevent i from being in c.

Now, how does the frequency of i in a affect this?

If a contains multiple instances of i, Alice has more chances to include i in c.

Bob can try to reduce the count of i, but Alice can still pick one of them.

Let me think about the parity of the number of moves.

Since Alice starts first, and they alternate turns, the total number of turns is n, which is the size of a.

Alice has (n + 1) // 2 moves, and Bob has n // 2 moves.

Wait, no. Since Alice picks an element and adds it to c, and Bob just picks and removes it, the total number of elements removed is n, and the number of elements added to c is (n + 1) // 2, since Alice makes the first move and chooses which elements to add.

Wait, let's think differently.

Each turn consists of:

- Alice picks an element, adds it to c, and deletes it from a.

- Bob picks an element and deletes it from a.

So, for each pair of turns (Alice and Bob), two elements are removed from a: one added to c and one not.

If n is even, there are n/2 such pairs, and c will have n/2 elements.

If n is odd, there are (n-1)/2 pairs plus one additional Alice's turn, so c will have (n + 1)/2 elements.

Wait, let's confirm:

- Total operations: n deletions from a.

- Each Alice's turn: +1 to c and -1 from a.

- Each Bob's turn: -1 from a.

- Alice starts, and they alternate.

- If n is even:

- Alice has n/2 turns, Bob has n/2 turns.

- c has n/2 elements.

- If n is odd:

- Alice has (n + 1)/2 turns, Bob has (n - 1)/2 turns.

- c has (n + 1)/2 elements.

Yes, that's correct.

So, the final size of c is ceil(n/2).

Now, considering that, I need to determine the MEX of c, which is the smallest non-negative integer not in c.

Alice wants to maximize MEX, which might not make sense initially, but actually, she wants to include as many small integers in c as possible to make MEX as large as possible.

Wait, no. Alice wants to maximize the MEX, which means she wants to have as many small integers in c as possible, so that the smallest missing one is as large as possible.

Bob wants to minimize the MEX, meaning he wants to ensure that some small integers are missing from c.

So, their strategies are opposed.

I need to find, for each i from 0 to n, whether Alice can ensure that i is in c, or Bob can ensure that i is not in c.

If Alice can ensure that all i from 0 to k-1 are in c, then MEX is at least k.

Bob tries to prevent this by ensuring that at least one of these i is not in c.

So, for each i, I need to see if Alice can force i into c, given that Bob is trying to prevent it.

Let's consider the frequency of i in a.

If cnt[i] is the number of times i appears in a, then:

- If cnt[i] is even, Bob can pair Alice's selections of i, and remove them, preventing i from being in c.

- If cnt[i] is odd, Alice can ensure that at least one i is in c, because she has the first move.

Wait, is that accurate?

Let me think about it.

Suppose cnt[i] = 1.

Alice can pick it and add to c, and Bob can't do anything about it.

So, i is in c.

If cnt[i] = 2.

Alice picks i and adds to c.

Bob can pick another i and remove it.

Then, Alice's next turn, she can pick another i and add to c.

But Bob can again remove another i.

Wait, no, in each turn, Alice adds one to c and removes it from a, and Bob removes one from a.

Wait, let's think step by step.

Initial a: [i, i]

Turn 1:

- Alice picks i and adds to c, a becomes [i]

- Bob picks i and removes it, a becomes empty

c = [i]

So, i is in c.

Similarly, if cnt[i] = 3:

a = [i, i, i]

Turn 1:

- Alice picks i and adds to c, a = [i, i]

- Bob picks i and removes it, a = [i]

Turn 2:

- Alice picks i and adds to c, a = []

- Bob has no move

c = [i, i]

So, i is in c.

Wait, but c can have duplicates.

But MEX is based on the presence of numbers, not their counts.

So, duplicates don't matter for MEX.

So, in both cases, i is in c.

Similarly, if cnt[i] = 4:

a = [i, i, i, i]

Turn 1:

- Alice picks i and adds to c, a = [i, i, i]

- Bob picks i and removes it, a = [i, i]

Turn 2:

- Alice picks i and adds to c, a = [i]

- Bob picks i and removes it, a = []

c = [i, i]

So, i is in c.

Similarly, for any cnt[i] >=1 and odd, Alice can ensure i is in c.

For cnt[i] even, Bob can pair Alice's additions and remove them, but actually, in the above example with cnt[i]=2, c still has one i.

Wait, in the cnt[i]=2 case, c ends up with one i.

In cnt[i]=4, c ends up with two i's.

So, seems like for any cnt[i] >=1, Alice can ensure that at least one i is in c.

Wait, but in the second test case, where a=[0,1,2,3], the output is 1, meaning MEX is 1, which implies that 0 is in c, but 1 is not.

But according to the above, for cnt[1]=1, Alice should be able to include 1 in c.

But in the sample explanation, it's 1.

Wait, perhaps I need to think differently.

Maybe Alice can't always include all small i's if Bob can prevent it.

Let me think again.

Suppose we have a=[0,1,2,3], n=4.

Total c will have ceil(4/2)=2 elements.

Alice wants to include two small integers, and Bob wants to prevent that.

If Alice includes 0 and 1, then MEX is 2.

If Alice includes 0 and 2, MEX is 1.

If Alice includes 0 and 3, MEX is 1.

If Alice includes 1 and 2, MEX is 0.

If Alice includes 1 and 3, MEX is 0.

If Alice includes 2 and 3, MEX is 0.

So, the minimal MEX Bob can achieve is 1, which matches the sample output.

So, in this case, Alice can't ensure that both 0 and 1 are in c.

Wait, but according to earlier thinking, for cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1, Alice should be able to include at least one of them.

But Bob can prevent Alice from including both 0 and 1.

Wait, perhaps I need to consider that Bob can interfere with Alice's choices.

Let me think about the game progression.

Total turns: n=4.

Alice has (4+1)//2 = 2 turns.

Bob has 4//2 = 2 turns.

So, Alice adds 2 elements to c.

Bob removes 2 elements from a.

But Alice chooses which elements to add to c.

So, in the second test case, a=[0,1,2,3].

Possible game:

- Alice picks 0 and adds to c, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2 and adds to c, c=[0,2], a=[3]

- Bob picks 3, a is empty, c=[0,2]

MEX is 1.

Another possible game:

- Alice picks 1 and adds to c, c=[1], a=[0,2,3]

- Bob picks 0, a=[2,3]

- Alice picks 2 and adds to c, c=[1,2], a=[3]

- Bob picks 3, a is empty, c=[1,2]

MEX is 0.

But the sample output is 1, so perhaps Bob can force MEX to be 1.

Wait, but in the second game, MEX is 0.

Hmm.

Wait, maybe I'm missing something.

Let me look back at the problem.

Alice wants to maximize the MEX, which is counterintuitive because MEX is smallest excluded integer.

Wait, no, Alice wants to maximize the MEX, meaning she wants the smallest excluded integer to be as large as possible, which means she wants to include as many small integers as possible in c.

Bob wants to minimize the MEX, meaning he wants the smallest excluded integer to be as small as possible, so he wants to prevent Alice from including some small integers in c.

So, in the second test case, Bob can prevent Alice from including 1 in c, forcing MEX to be 1.

Wait, but in one of the game plays, MEX is 0.

I'm getting confused.

Let me think differently.

Perhaps I should consider that the MEX is determined by which numbers from 0 to k are present in c, for some k.

Alice wants to maximize k such that all numbers from 0 to k-1 are in c, and k is not in c.

Bob wants to minimize k.

So, for each i from 0 to n, determine if Alice can force i to be in c, or Bob can force it not to be in c.

If Alice can force all i from 0 to k-1 to be in c, then MEX is at least k.

Bob tries to prevent this by ensuring that at least one of these i is not in c.

So, for each i, I need to see if Alice can ensure that i is in c, against Bob's attempts to prevent it.

Given that, perhaps I can think in terms of the number of times i appears in a and how many turns Alice gets.

Earlier, I thought that if cnt[i] is >=1, Alice can ensure i is in c.

But the sample input suggests otherwise.

Wait, perhaps I need to consider the total number of elements Alice can add to c.

Total elements in c is ceil(n/2).

So, Alice can add ceil(n/2) elements to c.

To maximize MEX, she wants to include the smallest possible integers in c.

Bob wants to prevent that by removing elements that Alice wants to include.

Wait, perhaps I need to think in terms of the frequency of each i and the number of turns Alice has.

Let me consider that Alice has ceil(n/2) choices to add elements to c.

She wants to include as many small i's as possible.

Bob can remove elements, trying to prevent Alice from including certain i's.

I need to find out which i's Alice can ensure are in c.

Let me try to model this.

Suppose I have a set of i's that Alice wants to include in c.

For each i, the number of times it appears in a is cnt[i].

Alice needs to include at least one of each i she wants to ensure is in c.

Bob can remove elements, trying to prevent Alice from including certain i's.

I need to find the largest k such that Alice can include all i from 0 to k-1 in c.

Wait, perhaps I can iterate over k from 0 upwards, and check if Alice can include all i from 0 to k-1 in c.

To do this, I need to see if the total number of elements Alice needs to include these i's is <= the number of choices she has.

But Bob can interfere by removing elements that Alice wants to include.

Wait, perhaps I need to consider the minimal number of turns Alice needs to include all required i's, considering Bob's removals.

This is getting complicated.

Let me look for a different approach.

I recall that in some games, the MEX can be determined by looking at the parity of the counts of the smallest integers.

Wait, in the provided program, it seems like it's checking the counts of i for i from 0 to n-1.

It's iterating through i from 0 to n-1, checking if cnt[i] == 1, and keeping a count t of such i's.

If t >= 2 or cnt[i] == 0, it prints i.

Wait, this seems too simplistic compared to the problem's complexity.

I need to verify if this logic is correct.

In the first test case:

a = [0,0,1,1]

cnt[0]=2, cnt[1]=2

So, for i=0, cnt[0]=2 !=1, so t=0

for i=1, cnt[1]=2 !=1, t=0

then i=2, cnt[2]=0, so print 2

which matches the sample output.

In the second test case:

a = [0,1,2,3]

cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1

for i=0, cnt[0]=1, t=1

for i=1, cnt[1]=1, t=2, t>=2, print 1

which matches the sample output.

In the third test case:

a = [1,1]

cnt[0]=0, cnt[1]=2

for i=0, cnt[0]=0, print 0

which matches the sample output.

So, in all sample cases, this logic works.

But is it generally correct?

Let me try to find a counterexample.

Suppose n=3, a=[0,0,1]

cnt[0]=2, cnt[1]=1

Iterate:

i=0, cnt[0]=2 !=1, t=0

i=1, cnt[1]=1, t=1

i=2, cnt[2]=0, print 2

But let's see what the actual MEX would be.

Total c has ceil(3/2)=2 elements.

Possible games:

- Alice picks 0 and adds to c, c=[0], a=[0,1]

- Bob picks 0, a=[1]

- Alice picks 1 and adds to c, c=[0,1], a=[]

MEX is 2.

Another game:

- Alice picks 1 and adds to c, c=[1], a=[0,0]

- Bob picks 0, a=[0]

- Alice picks 0 and adds to c, c=[1,0], a=[]

MEX is 1.

Wait, but according to the program, it would output 2, but in reality, Bob can force MEX to be 1.

So, in this case, the program would be incorrect.

Wait, but in this example, the program prints 2, but actually, Bob can force MEX to be 1.

So, the program is incorrect in this case.

Hence, the program is flawed.

Wait, but in the sample inputs, it works.

But in this additional case, it fails.

Therefore, the program is not generally correct.

Alternative approach:

I need to find the smallest i such that Alice cannot ensure that i is in c.

Given that, I need to find the minimal i where, even if Alice tries to include i in c, Bob can prevent it.

From the earlier example, when n=3, a=[0,0,1], the program would output 2, but actually, Bob can force MEX to be 1.

So, the program is incorrect.

Hence, Correctness: False

**Final Solution**

To solve this problem, we need to determine the final MEX score of array \( c \) after Alice and Bob play optimally on array \( a \). Alice wants to maximize the MEX, while Bob wants to minimize it.

### Approach

1. **Understanding MEX**: MEX of an array is the smallest non-negative integer not present in it.
2. **Game Mechanics**:
   - Alice starts first and picks an element from \( a \), appends it to \( c \), and deletes it from \( a \).
   - Bob then picks an element from \( a \) and deletes it.
   - They alternate turns until \( a \) is empty.
3. **Optimal Play Analysis**:
   - Alice aims to maximize the MEX by including as many small integers in \( c \) as possible.
   - Bob aims to minimize the MEX by preventing Alice from including certain small integers in \( c \).
4. **Key Insight**:
   - For each integer \( i \), determine if Alice can ensure that \( i \) is included in \( c \) despite Bob's interference.
   - Track the frequency of each element in \( a \) and simulate the game based on these frequencies.

### Solution Code

```python
from collections import defaultdict

def find_mex(n, a):
    cnt = defaultdict(int)
    for num in a:
        cnt[num] += 1
    t = 0
    for i in range(n):
        if cnt[i] == 1:
            t += 1
        if t >= 2 or cnt[i] == 0:
            return i
    return n  # If all smaller integers are present, MEX is n

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index =