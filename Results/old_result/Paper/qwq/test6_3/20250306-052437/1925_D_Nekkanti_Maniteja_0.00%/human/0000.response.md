Alright, I have this problem to solve. Let's read it carefully.

There are n children in a class, and m pairs among them are friends, each with a friendship value f_i. The teacher goes on k excursions, and for each excursion, she chooses a pair of children randomly and equiprobably. If the chosen pair are friends, their friendship value increases by 1 for all subsequent excursions. Pairs who are not friends have a friendship value of 0, which never changes.

I need to find the expected value of the sum of friendship values of all k pairs chosen for the excursions, considering that the friendship values can increase over time.

The answer should be in the form of p/q mod (10^9 + 7), where p and q are coprime.

First, I need to understand the process:

1. There are n children, so the total number of possible pairs is C(n, 2) = n*(n-1)/2.

2. Among these, m pairs are friends, each with an initial friendship value f_i.

3. For each excursion, a pair is chosen uniformly at random from all possible pairs.

4. If the chosen pair are friends, their friendship value increases by 1 for all subsequent excursions.

5. The friendship value of non-friend pairs is always 0 and never changes.

6. I need to find the expected sum of the friendship values of all k chosen pairs, where each value is taken at the time of choice.

Let me try to model this.

Let’s denote the pairs as edges in a graph with n nodes, where m edges are friends with initial weights f_i.

At each step, we select a pair (u, v) uniformly at random.

- If (u, v) are friends, their friendship value increases by 1 for all subsequent steps.

- If not friends, their friendship value remains 0 forever.

We need the expected sum of the friendship values of the k chosen pairs, where each value is taken at the time of choice.

First, I need to find the expected value for each excursion and then sum them up.

Let’s consider the i-th excursion.

At this point, some friendship values may have already been increased by previous selections.

But wait, the problem says that if a friend pair is chosen, their friendship value increases by 1 for all subsequent excursions.

So, for each friend pair, their friendship value starts at f_i and can increase by 1 each time they are chosen.

However, in the sum, we need to consider the friendship value at the time of choice.

So, for each excursion, the sum is the friendship value of the chosen pair at that moment.

I need to compute the expected sum of these k values.

Let me think about the expected value for each excursion.

For a single excursion, the expected friendship value is the sum over all possible pairs of the probability of selecting that pair multiplied by their friendship value at that moment.

But since the selections are independent and equiprobable, the expected value for each excursion is the same.

Wait, no, because the friendship values can increase over time.

Wait, the problem says that the teacher chooses k pairs randomly, independently, and equiprobably.

Wait, but the problem says "the teacher can choose a pair of children more than once."

So, with replacement.

So, each excursion, any pair can be chosen, including those chosen before.

And for each chosen pair, if they are friends, their friendship value increases by 1 for all subsequent excursions.

So, the friendship values can increase over time, based on how many times they have been chosen before.

But the sum is the sum of the friendship values at the time of choice.

So, for each excursion, the friendship value of the chosen pair is considered at the time of choice, not after.

So, I need to find the expected sum of these k values.

This seems a bit tricky because the friendship values can change over time based on previous choices.

I need to find a way to compute this expected sum efficiently.

Let me try to model this step by step.

Let’s denote the set of friend pairs as E, with |E| = m.

Each friend pair e in E has an initial friendship value f_e.

At each excursion, a pair is chosen uniformly at random from all possible pairs (including non-friend pairs).

If the chosen pair is a friend pair e, then f_e increases by 1 for all subsequent excursions.

Non-friend pairs always have friendship value 0 and never change.

I need to find the expected sum of the friendship values of the k chosen pairs, where each value is taken at the time of choice.

Let me think about the process.

Let’s define X_t as the friendship value of the pair chosen at excursion t.

Then, the total sum S = sum_{t=1 to k} X_t.

I need E[S] = sum_{t=1 to k} E[X_t].

Because expectation is linear.

So, I need to compute E[X_t] for each t from 1 to k and sum them up.

Now, E[X_t] is the expected friendship value at time t.

But, the friendship values can change over time based on previous choices.

This seems complicated.

Wait, but the selections are independent and equiprobable.

Wait, no, because the problem says the teacher chooses k pairs randomly, independently, and equiprobably.

Wait, but with the condition that if a friend pair is chosen, their friendship value increases by 1 for all subsequent excursions.

So, the choices are independent, but the friendship values can increase based on how many times a friend pair has been chosen before.

Wait, but the problem says "the teacher can choose a pair of children more than once."

So, with replacement.

So, each excursion, any pair can be chosen again, including those chosen before.

And for each chosen pair, if they are friends, their friendship value increases by 1 for all subsequent excursions.

So, the friendship values can increase over time based on how many times they have been chosen before.

This seems like a Markov process, where the state is the current friendship values of the friend pairs.

But with k up to 2e5 and m up to 1e5, simulating this directly is not feasible.

I need a smarter approach.

Let me think differently.

Let’s consider that for each friend pair e, with initial friendship value f_e, each time it is chosen, its friendship value increases by 1 for subsequent choices.

But in the sum, we need to sum the friendship values at the time of choice.

So, for each friend pair e, suppose it is chosen t_e times among the k excursions.

Then, its contribution to the sum is sum_{i=1 to t_e} (f_e + (i-1)).

Because each time it is chosen, its friendship value is f_e plus the number of times it has been chosen before.

Wait, more precisely:

Let’s say for friend pair e, suppose it is chosen at times t1 < t2 < ... < t_{t_e}.

Then, at time t1, its friendship value is f_e.

At time t2, it's f_e + 1.

At time t3, it's f_e + 2.

And so on.

So, its total contribution to the sum S is f_e + (f_e + 1) + (f_e + 2) + ... + (f_e + t_e - 1) = t_e * f_e + (0 + 1 + 2 + ... + (t_e - 1)) = t_e * f_e + t_e * (t_e - 1) / 2.

Similarly, non-friend pairs always contribute 0.

So, the total sum S is sum over all friend pairs e of [t_e * f_e + t_e * (t_e - 1) / 2].

Now, I need to find the expected value of S.

So, E[S] = sum over e of E[t_e * f_e + t_e * (t_e - 1) / 2].

This seems complicated, but maybe I can find E[t_e] and E[t_e * (t_e - 1)].

Let me see.

First, note that the probability of choosing any particular pair in one excursion is 2 / (n choose 2), but wait, no.

Wait, total number of possible pairs is C(n, 2) = n*(n-1)/2.

So, probability of choosing any specific pair is 1 / C(n, 2).

Wait, actually, in code, it's often written as 2 / (n*(n-1)), but that's the same.

Wait, no, 1 / C(n, 2) = 2 / (n*(n-1)).

Wait, no, 1 / C(n, 2) = 2 / (n*(n-1)) is incorrect.

Wait, C(n, 2) = n*(n-1)/2.

So, 1 / C(n, 2) = 2 / (n*(n-1)).

Wait, no.

Wait, 1 / C(n, 2) = 2 / (n*(n-1)) is incorrect.

Actually, 1 / C(n, 2) = 2 / (n*(n-1)) is not correct.

Because C(n, 2) = n*(n-1)/2.

So, 1 / C(n, 2) = 2 / (n*(n-1)).

Wait, no.

Wait, no, 1 / C(n, 2) = 2 / (n*(n-1)) is incorrect.

Wait, C(n, 2) = n*(n-1)/2.

So, 1 / C(n, 2) = 2 / (n*(n-1)).

Yes, that's correct.

So, probability of choosing any specific pair is 2 / (n*(n-1)).

Wait, but in the code, it's written as pow(n * (n - 1) // 1, -1, M), which is 1 / (n*(n-1)/2) modulo M, which is correct.

Wait, no, pow(x, -1, M) is the modular inverse of x modulo M.

So, pow(n * (n - 1) // 2, -1, M) would be the modular inverse of C(n, 2).

But in the code, it's written as pow(n * (n - 1) // 1, -1, M), which is incorrect.

Wait, no, it's pow(n * (n - 1) // 1, -1, M), which is pow(n * (n - 1), -1, M).

Wait, but C(n, 2) = n*(n-1)/2.

So, the modular inverse should be pow(n * (n - 1) // 2, -1, M).

But in the code, it's pow(n * (n - 1) // 1, -1, M), which is pow(n * (n - 1), -1, M).

This seems incorrect.

Wait, perhaps it's a typo.

Wait, but in the code, it's c = pow(n * (n - 1) // 1, -1, M).

This should be c = pow(n * (n - 1) // 2, -1, M).

Probably a typo.

Assuming it's a typo and should be c = pow(n * (n - 1) // 2, -1, M), which is the modular inverse of C(n, 2).

Proceeding with that.

Now, for each friend pair e, the number of times it is chosen, t_e, follows a binomial distribution with parameters k and p = 1 / C(n, 2).

So, E[t_e] = k / C(n, 2).

Similarly, E[t_e * (t_e - 1)] = E[t_e^2 - t_e] = Var(t_e) + (E[t_e])^2 - E[t_e] = k * p * (1 - p) + (k * p)^2 - k * p.

But since k can be up to 2e5 and m up to 1e5, computing this for each friend pair separately may be too slow.

Wait, but m can be up to 1e5 and t up to 5e4, and sum over all test cases of m and n is up to 1e5, and sum of k up to 2e5.

So, total complexity needs to be O(T * m + T * k), which with T up to 5e4, m up to 1e5, and k up to 2e5, would be too slow.

So, I need a better approach.

Let me think differently.

Let’s consider that in each excursion, the expected friendship value of the chosen pair is the same, because the choices are independent and equiprobable.

So, E[X_t] = E[X_1] for all t.

Therefore, E[S] = k * E[X_1].

So, I only need to compute E[X_1], the expected friendship value of a single excursion, and multiply by k.

But, wait, the friendship values can increase over time, so choices later may have higher friendship values.

Wait, but in the sum, we are summing the friendship values at the time of choice.

So, for each excursion, the friendship value is determined at the time of choice, considering any increases from previous choices.

So, it's not just E[X_1] multiplied by k, because the friendship values can increase over time.

This seems more involved.

Let me try to model E[S].

Let’s consider that for each friend pair e, its contribution to S is the sum over all excursions where it is chosen, of its friendship value at that time.

As previously, if it is chosen t_e times, its contribution is t_e * f_e + t_e * (t_e - 1) / 2.

So, E[S] = sum over e in E of [E[t_e * f_e] + E[t_e * (t_e - 1) / 2]].

Now, E[t_e] = k / C(n, 2).

And E[t_e * (t_e - 1)] = k * (k - 1) / C(n, 2)^2.

Because t_e is the number of times e is chosen, which follows a binomial distribution with parameters k and p = 1 / C(n, 2).

So, E[t_e] = k * p = k / C(n, 2).

E[t_e * (t_e - 1)] = k * (k - 1) * p^2.

Because for binomial, E[X*(X-1)] = n*(n-1)*p^2.

So, plugging in, E[t_e * (t_e - 1)] = k * (k - 1) / C(n, 2)^2.

Therefore, E[S] = sum over e in E of [ (k / C(n, 2)) * f_e + (k * (k - 1) / C(n, 2)^2) * 0.5 ].

Wait, but this seems off because t_e * (t_e - 1) / 2 is the sum of the first t_e - 1 integers.

Wait, more precisely, sum_{i=1 to t_e} (f_e + i - 1) = t_e * f_e + (t_e * (t_e - 1)) / 2.

So, E[S] = sum over e in E of [ E[t_e] * f_e + 0.5 * E[t_e * (t_e - 1)] ].

And as above, E[t_e] = k / C(n, 2).

E[t_e * (t_e - 1)] = k * (k - 1) / C(n, 2)^2.

So, E[S] = sum over e in E of [ (k / C(n, 2)) * f_e + 0.5 * (k * (k - 1) / C(n, 2)^2) ].

Now, sum over e in E of f_e is the total initial friendship values.

Let’s denote S_f = sum_{e in E} f_e.

And sum over e in E of 1 is m.

So, E[S] = (k / C(n, 2)) * S_f + 0.5 * (k * (k - 1) / C(n, 2)^2) * m.

But this seems too simplistic. Let me verify with the sample input.

Take the second test case:

n=2, m=1, k=10

Only one friend pair with f=1

So, C(2,2)=1

E[S] = (10 / 1) * 1 + 0.5 * (10 * 9 / 1^2) * 1 = 10 + 0.5 * 90 * 1 = 10 + 45 = 55.

Which matches the sample output.

Another test case:

n=3, m=1, k=2

Only one friend pair with f=1

C(3,2)=3

E[S] = (2 / 3) * 1 + 0.5 * (2 * 1 / 3^2) * 1 = 2/3 + 0.5 * 2/9 * 1 = 2/3 + 1/9 = 7/9.

Which matches the sample output of 777777784, since 7 * 769230769 ≡ 7 * 769230769 mod 10^9+7 = 7 * 769230769 = 5384615383, mod 10^9+7 is 777777784.

Seems correct.

So, general formula is:

E[S] = (k / C(n,2)) * S_f + 0.5 * (k * (k - 1) / C(n,2)^2) * m.

Now, C(n,2) = n*(n-1)/2.

So, E[S] = (2k / (n*(n-1))) * S_f + (k*(k-1) / (n*(n-1))^2) * m.

But need to compute this modulo 10^9+7, as p/q mod 10^9+7, where p and q are coprime.

So, need to compute E[S] as a fraction and then find p * q^{-1} mod 10^9+7.

In code, need to compute this efficiently using modular inverses.

Looking back at the provided code:

def func():

for i in range(int(input())):

(n, m, k) = map(int, input().split())

M = 10 ** 9 + 7

c = pow(n * (n - 1) // 1, -1, M)

s = 0

a = 0

for i in range(m):

(u, v, f) = map(int, input().split())

a += f

for i in range(k):

s = s + c * i * c * m + c * a

print(s % M)

There are a few issues here.

First, c should be the modular inverse of C(n,2), which is n*(n-1)//2.

But in the code, it's pow(n * (n - 1) // 1, -1, M), which is pow(n * (n - 1), -1, M), which is incorrect.

It should be pow(n * (n - 1) // 2, -1, M).

Second, the formula being used in the loop seems incorrect.

It's summing s += c * i * c * m + c * a for i from 0 to k-1.

This doesn't align with the formula we derived earlier.

According to our earlier derivation, E[S] = (2k / (n*(n-1))) * S_f + (k*(k-1) / (n*(n-1))^2) * m.

So, in terms of modular arithmetic:

Let inv_C = pow(n * (n - 1) // 2, M-2, M)

Then, 1 / C(n,2) = inv_C

Similarly, 1 / C(n,2)^2 = pow(n * (n - 1) // 2, 2*(M-2) % (M-1), M)

Wait, no, since M is prime, pow(a, b, M) is a^b mod M.

So, 1 / C(n,2) = pow(C(n,2), M-2, M)

And 1 / C(n,2)^2 = pow(C(n,2), 2*(M-2), M)

But it's easier to compute inv_C once and then inv_C2 = inv_C * inv_C mod M.

Then, E[S] = (2k * inv_C * S_f) + (k * (k - 1) * inv_C2 * m / 2)

But need to handle division by 2 modulo M.

Since M is odd, division by 2 is equivalent to multiplying by the modular inverse of 2, which is (M+1)//2.

So, E[S] = (2k * inv_C * S_f + k * (k - 1) * inv_C2 * m * ((M+1)//2)) mod M

Wait, but in the formula, it's 0.5 * k * (k - 1) / C(n,2)^2 * m.

So, in modular arithmetic:

E[S] = (k * inv_C * S_f * 2 + k * (k - 1) * inv_C2 * m * ((M+1)//2)) mod M

Wait, no, need to be careful.

Let's compute it step by step.

First, compute inv_C = pow(C(n,2), M-2, M)

Then, inv_C2 = inv_C * inv_C mod M

Then, term1 = 2k * inv_C * S_f mod M

term2 = k * (k - 1) * inv_C2 * m * inv2 mod M, where inv2 = pow(2, M-2, M) = (M+1)//2

Then, E[S] = (term1 + term2) mod M

So, in code, it should be:

C = n * (n - 1) // 2

inv_C = pow(C, M-2, M)

inv_C2 = inv_C * inv_C % M

inv2 = (M + 1) // 2

term1 = 2 * k * inv_C * S_f % M

term2 = k * (k - 1) * inv_C2 * m * inv2 % M

E_S = (term1 + term2) % M

print(E_S)

But in the provided code, it's using a loop from 0 to k-1, adding c * i * c * m + c * a each time.

This seems incorrect.

Moreover, in the first test case, n=100, m=0, k=24

So, m=0, S_f=0

So, E[S] = 0, which matches the sample output.

In the second test case, n=2, m=1, k=10

C(2,2)=1

inv_C = 1

inv_C2 = 1

inv2 = 500000004

term1 = 2 * 10 * 1 * 1 % 1000000007 = 20

term2 = 10 * 9 * 1 * 1 * 500000004 % 1000000007 = 90 * 500000004 % 1000000007 = 45000000360 % 1000000007 = 45000000360 - 45*1000000007 = 45000000360 - 45000000315 = 545

So, E[S] = (20 + 545) % 1000000007 = 565, but the sample output is 55.

This suggests that the formula is incorrect.

Wait, perhaps I messed up the formula.

Let me re-examine.

Earlier, I had:

E[S] = sum over e in E of [ (k / C(n,2)) * f_e + 0.5 * (k * (k - 1) / C(n,2)^2) * m ]

Wait, no, more precisely:

E[S] = sum over e in E of [ E[t_e] * f_e + 0.5 * E[t_e * (t_e - 1)]