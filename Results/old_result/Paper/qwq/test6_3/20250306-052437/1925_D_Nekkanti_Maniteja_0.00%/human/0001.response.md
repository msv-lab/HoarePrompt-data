Alright, I have this problem to solve. Let's read it carefully.

There are n children in a class, and m pairs among them are friends with a friendship value f_i. The teacher goes on k excursions, and for each excursion, she chooses a pair of children randomly and equiprobably. If the chosen pair are friends, their friendship value increases by 1 for all subsequent excursions. Pairs who are not friends have a friendship value of 0 that doesn't change.

I need to find the expected value of the sum of friendship values of all k pairs chosen, at the time of being chosen. And the answer should be modulo 10^9+7 after adjusting for coprime p and q in p/q.

First, I need to understand the process:

1. There are n children, so the total number of possible pairs is n*(n-1)/2.

2. Among these, m pairs are friends with initial friendship values f_i.

3. For each excursion, a pair is chosen randomly from all possible pairs.

4. If the chosen pair are friends, their friendship value increases by 1 for all future excursions.

5. The friendship value of non-friend pairs is always 0.

6. I need the expected sum of the friendship values at the time of choosing each pair over k excursions.

Let's think about how to approach this.

First, consider that each excursion is independent in terms of choosing the pair, but the friendship values can increase over time if friends are chosen.

Wait, no, the problem says that if a friend pair is chosen, their friendship value increases by 1 for all subsequent excursions. So, the choice in one excursion can affect the values in future excursions.

But the problem also says that the pairs are chosen independently and randomly each time, meaning that the same pair can be chosen multiple times.

Hmm, this seems tricky because the friendship values can change based on previous choices.

Wait, but the problem specifies that the pairs are chosen independently and randomly each time, so the choice in one excursion doesn't affect the probability of choosing in another excursion.

However, the friendship values can increase over time if the same friend pair is chosen multiple times.

But the problem asks for the expected sum of friendship values at the time of choosing each pair, considering the increases.

Let me try to rephrase the process:

- Start with m friend pairs, each with an initial friendship value f_i.

- For each of k excursions:

- Choose a pair randomly from all possible pairs (n*(n-1)/2).

- If the chosen pair is a friend pair, increment their friendship value by 1 for all future excursions.

- The friendship value of non-friend pairs is always 0.

- The sum we're interested in is the sum of the friendship values at the time of choosing each pair over k excursions.

- We need the expected value of this sum.

I think the key here is to realize that the sum of expected values is the expected sum. So, I can compute the expected friendship value for each excursion and then sum them up.

So, for each excursion, the expected friendship value is the sum over all friend pairs of the probability of choosing that pair multiplied by their expected friendship value at the time of choosing.

Wait, but since the friendship value can increase over time, I need to consider the history of choices.

This seems complicated. Maybe there's a smarter way to model this.

Let me consider defining the state of the system after each excursion, keeping track of how many times each friend pair has been chosen.

But that might be too involved, especially since m can be up to 1e5 and t can be up to 5e4, with sum of n and m over all test cases up to 1e5 and sum of k up to 2e5.

I need an efficient way to compute this.

Perhaps I can think in terms of linearity of expectation.

For each friend pair, I can calculate the expected number of times their friendship value is contributed to the total sum over all k excursions.

Then, sum over all friend pairs of their expected contribution.

Also, since non-friend pairs contribute 0, I can ignore them.

So, for each friend pair, their expected contribution is the expected number of times they are chosen multiplied by their initial friendship value, plus the expected number of times they are chosen after being chosen previously.

Wait, that seems messy.

Let me try to model it differently.

Let me consider that for each friend pair, each time they are chosen, their friendship value increases by 1 for all future choices.

So, if a friend pair is chosen t times, their friendship value will be f_i + t - 1, because the first choice sets f_i, and each subsequent choice increases it by 1.

Wait, no. The problem says that when a friend pair is chosen, their friendship value increases by 1 for all subsequent excursions.

So, if a friend pair is chosen at excursion j, then for all future excursions k > j, their friendship value increases by 1.

But their friendship value at the time of choosing is f_i plus the number of times they have been chosen before.

Wait, no. The problem says that when a friend pair is chosen, their friendship value increases by 1 for all subsequent excursions.

So, the friendship value at the time of choosing is f_i plus the number of times they have been chosen before.

Wait, yes, that makes sense.

So, if a friend pair is chosen t times, in the first choice, their friendship value is f_i, in the second choice it's f_i + 1, in the third it's f_i + 2, and so on.

So, the total contribution of a friend pair chosen t times is f_i + (f_i + 1) + (f_i + 2) + ... + (f_i + t - 1) = t*f_i + (t*(t-1))/2.

But, in reality, since the choices are independent, it's not about how many times they are chosen, but about the expected value each time they are chosen.

Wait, perhaps I should think in terms of the expected number of times each friend pair is chosen.

Let me see.

The probability of choosing any particular pair is 2/(n*(n-1)), since there are n*(n-1)/2 pairs.

Wait, no, the probability of choosing a specific pair is 1/(n*(n-1)/2).

Wait, no, wait, the total number of possible pairs is n*(n-1)/2, so the probability of choosing any specific pair is 1/(n*(n-1)/2).

Wait, but in code, it's often easier to work with integers, so maybe it's better to think in terms of total possible pairs.

Let me define total_pairs = n*(n-1)/2.

Then, the probability of choosing any specific pair in one excursion is 1/total_pairs.

Now, for each friend pair, the expected number of times it is chosen in k excursions is k/total_pairs.

Wait, no, since each excursion is independent, the expected number of times a specific pair is chosen in k excursions is k/total_pairs.

But, their friendship value increases by 1 each time they are chosen, for all subsequent choices.

Wait, no, the problem says that when a pair is chosen, their friendship value increases by 1 for all subsequent excursions.

So, in other words, each time a friend pair is chosen, their friendship value increases by 1 for all future choices.

Wait, but the problem says "their friendship value increases by 1 for all subsequent excursions", but it also says "at the time of being chosen".

So, perhaps I need to think about the friendship value at the time of choosing each pair.

Wait, perhaps it's better to think in terms of the contribution of each choice.

Let me consider that for each excursion, the chosen pair's friendship value at that time is added to the sum.

And the friendship value of a friend pair increases by 1 for all subsequent excursions after it is chosen.

So, if a friend pair is chosen at excursion j, then for all excursions k > j, their friendship value increases by 1.

But, I need to consider that the same pair can be chosen multiple times, and each time they are chosen, their friendship value increases by 1 for all subsequent excursions.

This seems complex.

Maybe I can model it using linearity of expectation, considering each friend pair independently.

For each friend pair, I can calculate its expected contribution to the total sum over all k excursions.

Then, sum over all friend pairs of their expected contributions.

Similarly, non-friend pairs contribute 0, so I can ignore them.

So, for each friend pair, I need to find the expected sum of their friendship values over all the times they are chosen.

But since they can be chosen multiple times, and each choice affects their friendship value in future choices, it's not straightforward.

Perhaps I can think in terms of the number of times a friend pair is chosen.

Let me denote X as the number of times a specific friend pair is chosen in k excursions.

Then, X follows a binomial distribution with parameters k and p=1/total_pairs.

Given that, the friendship value at each choice is f_i plus the number of times it has been chosen before.

Wait, yes.

So, if a friend pair is chosen t times, the friendship values at the times of choosing would be f_i, f_i + 1, f_i + 2, ..., f_i + (t-1).

So, the total contribution is t*f_i + (t*(t-1))/2.

Hence, the expected contribution of a specific friend pair is E[t*f_i + (t*(t-1))/2], where t is the number of times it is chosen.

Since t is binomial with parameters k and p=1/total_pairs, E[t] = k*p = k/total_pairs.

Similarly, E[t*(t-1)] = k*(k-1)*p^2.

Wait, no, for binomial distribution, E[t*(t-1)] = k*(k-1)*p^2.

Hence, E[t*f_i + (t*(t-1))/2] = f_i * E[t] + (E[t*(t-1)])/2 = f_i * (k/total_pairs) + (k*(k-1)/total_pairs^2)/2.

Wait, but I need to confirm the formula for E[t*(t-1)].

Actually, for a binomial random variable t ~ Binomial(k, p), E[t] = k*p, and E[t*(t-1)] = k*(k-1)*p^2 + k*p.

Wait, no, let's recall that for binomial distribution, E[t*(t-1)] = Var(t) + (E[t])^2 - E[t] = k*p*(1-p) + (k*p)^2 - k*p.

Wait, perhaps it's better to use the fact that E[t*(t-1)] = k*(k-1)*p^2.

Actually, more accurately, for binomial distribution, E[t*(t-1)] = k*(k-1)*p^2 + k*p*(1 - p).

But for small p and large k, k*(k-1)*p^2 is dominant.

Wait, perhaps I need to look up the formula for E[t*(t-1)] in binomial distribution.

Actually, for t ~ Binomial(k, p), E[t*(t-1)] = k*(k-1)*p^2 + k*p*(1 - p).

Wait, no, actually, E[t*(t-1)] = Var(t) + (E[t])^2 - E[t] = k*p*(1 - p) + (k*p)^2 - k*p = k*p*(k*p - 1).

Wait, perhaps it's better to use the factorial moments.

Actually, for binomial distribution, E[t*(t-1)*...*(t-r+1)] = k*(k-1)*...*(k-r+1)*p^r.

So, for r=2, E[t*(t-1)] = k*(k-1)*p^2.

Hence, E[t*f_i + (t*(t-1))/2] = f_i * E[t] + (E[t*(t-1)])/2 = f_i * (k/total_pairs) + (k*(k-1)/total_pairs^2)/2.

Wait, but this seems off because the second term should be related to the increases in friendship value.

Wait, perhaps I need to think differently.

Let me consider that each time a friend pair is chosen, their friendship value at that time is f_i plus the number of times they have been chosen before.

Wait, more carefully:

- Let's say a friend pair is chosen at times t1, t2, ..., tk.

- Each time they are chosen, their friendship value is f_i plus the number of times they have been chosen before.

- So, for the first choice, it's f_i + 0.

- For the second choice, it's f_i + 1.

- For the third choice, it's f_i + 2.

- And so on.

- So, if they are chosen t times, their total contribution is t*f_i + (t*(t-1))/2.

Hence, the expected total contribution for a specific friend pair is E[t*f_i + (t*(t-1))/2], where t is the number of times they are chosen.

Given that t follows a binomial distribution with parameters k and p=1/total_pairs, we can compute E[t] and E[t*(t-1)].

We have E[t] = k*p = k/total_pairs.

And E[t*(t-1)] = k*(k-1)*p^2.

Hence, E[t*f_i + (t*(t-1))/2] = f_i * (k/total_pairs) + (k*(k-1)/total_pairs^2)/2.

Wait, but this seems a bit messy.

Alternatively, perhaps I can think in terms of the contribution of each choice independently.

Each time a pair is chosen, their friendship value at that time is added to the sum.

And their friendship value increases by 1 for all subsequent choices.

So, the first time they are chosen, their friendship value is f_i.

The second time, it's f_i + 1.

The third time, f_i + 2, and so on.

Hence, the total contribution is sum over t=1 to t=k of f_i + (number of times chosen before t).

This seems complicated.

Maybe I can think in terms of the linearity of expectation for each choice.

For each excursion, the expected friendship value at that excursion is the sum over all friend pairs of the probability of choosing that pair times their expected friendship value at that excursion.

Given that, perhaps I can compute for each excursion, the expected friendship value, and then sum them up.

Let me try that.

For each excursion, the expected friendship value is sum over all friend pairs of P(choosing that pair) * E(friendship value at that excursion | choosing that pair).

But I still need to find E(friendship value at that excursion | choosing that pair).

Wait, maybe it's better to consider that the friendship value of a friend pair at the time of choosing is f_i plus the number of times they have been chosen before.

So, if a friend pair has been chosen t times before the current excursion, their friendship value at this excursion is f_i + t.

Hence, the expected friendship value for a specific friend pair across all excursions is sum over t=0 to t=k-1 of (probability that the pair has been chosen t times) * (f_i + t).

But this seems too involved.

Perhaps there's a smarter way to compute this.

Let me consider that the total sum S is the sum over k excursions of the friendship value at the time of choosing.

I need E[S].

Now, S = sum over j=1 to k of S_j, where S_j is the friendship value at the j-th excursion.

By linearity of expectation, E[S] = sum over j=1 to k of E[S_j].

Now, E[S_j] = sum over all friend pairs of P(pair is chosen at j) * E(friendship value at j | pair is chosen).

But E(friendship value at j | pair is chosen) is f_i plus the number of times the pair has been chosen before.

Wait, the number of times the pair has been chosen before j is the number of times it was chosen in the first j-1 excursions.

This seems complicated because it involves the history.

Perhaps I can model the expected increase in friendship values.

Wait, maybe I can think in terms of the contribution of each friend pair independently.

Let me consider one friend pair.

Let me denote X as the number of times this pair is chosen in k excursions.

Then, X follows a binomial distribution with parameters k and p=1/total_pairs.

Now, the total contribution of this pair to the sum S is sum over j=1 to k of (f_i + number of times chosen before j).

Wait, more carefully:

- Let I_j be an indicator variable that is 1 if the pair is chosen at excursion j, else 0.

- Then, the number of times chosen before j is sum over m=1 to j-1 of I_m.

- Hence, the friendship value at j is f_i + sum over m=1 to j-1 of I_m.

- So, the contribution to S from j is (f_i + sum over m=1 to j-1 of I_m) * I_j.

- Therefore, the total contribution from this pair is sum over j=1 to k of (f_i * I_j + I_j * sum over m=1 to j-1 of I_m).

Hence, the expected contribution is sum over j=1 to k of (f_i * P(I_j=1) + E[I_j * sum over m=1 to j-1 of I_m]).

Now, P(I_j=1) = p = 1/total_pairs.

And E[I_j * sum over m=1 to j-1 of I_m] = sum over m=1 to j-1 of E[I_j * I_m].

Given that I_j and I_m are independent for j != m, E[I_j * I_m] = E[I_j] * E[I_m] = p^2.

Hence, E[I_j * sum over m=1 to j-1 of I_m] = (j-1) * p^2.

Therefore, the expected contribution from this pair is sum over j=1 to k of (f_i * p + (j-1) * p^2).

Which simplifies to sum over j=1 to k of f_i * p + sum over j=1 to k of (j-1) * p^2.

Which is k * f_i * p + sum over j=0 to k-1 of j * p^2.

The sum over j=0 to k-1 of j is (k-1)*k/2.

Hence, the expected contribution is k * f_i * p + ((k-1)*k/2) * p^2.

Now, p = 1 / total_pairs, where total_pairs = n*(n-1)/2.

Hence, p = 2 / (n*(n-1)).

So, the expected contribution is k * f_i * (2 / (n*(n-1))) + (k*(k-1)/2) * (4 / (n*(n-1))^2).

Wait, no, (k-1)*k/2 * p^2 = (k*(k-1)/2) * (4 / (n*(n-1))^2).

Wait, p^2 = 4 / (n*(n-1))^2.

Hence, the expected contribution is k * f_i * (2 / (n*(n-1))) + (k*(k-1)/2) * (4 / (n*(n-1))^2).

Simplify this:

First term: k * f_i * 2 / (n*(n-1)).

Second term: k*(k-1)/2 * 4 / (n*(n-1))^2 = k*(k-1)*2 / (n*(n-1))^2.

Hence, total expected contribution from one friend pair is:

(2*k*f_i)/(n*(n-1)) + (2*k*(k-1))/(n*(n-1))^2.

Now, since there are m friend pairs, the total expected sum S is m times the above expression.

Wait, no, not necessarily, because each friend pair contributes independently.

Hence, total E[S] = sum over all friend pairs of their expected contributions.

So, E[S] = sum over all friend pairs of [(2*k*f_i)/(n*(n-1)) + (2*k*(k-1))/(n*(n-1))^2].

Wait, but this seems off because the second term doesn't depend on f_i.

Wait, perhaps I made a mistake in the calculation.

Let me double-check.

Earlier, for one friend pair, E[contribution] = k * f_i * p + (k*(k-1)/2) * p^2.

But p = 2 / (n*(n-1)).

Hence, E[contribution] = k * f_i * (2 / (n*(n-1))) + (k*(k-1)/2) * (4 / (n*(n-1))^2).

Wait, no, p^2 = [2 / (n*(n-1))]^2 = 4 / (n*(n-1))^2.

Hence, E[contribution] = (2*k*f_i)/(n*(n-1)) + (4*k*(k-1))/(2*(n*(n-1))^2) ) = (2*k*f_i)/(n*(n-1)) + (2*k*(k-1))/(n*(n-1))^2.

So, total E[S] = sum over all friend pairs of [(2*k*f_i)/(n*(n-1)) + (2*k*(k-1))/(n*(n-1))^2)].

But this seems incorrect because the second term should be related to the increases in friendship values.

Wait, perhaps I need to consider that the increase in friendship value is only when a friend pair is chosen, and it affects all subsequent choices.

Maybe I need to think differently.

Let me consider that for each friend pair, their friendship value increases by 1 for each time they are chosen, but only for subsequent choices.

Wait, perhaps it's better to think in terms of the total sum S being equal to sum over all friend pairs of f_i times the number of times they are chosen plus sum over all friend pairs of the number of times they are chosen before each time they are chosen.

This seems too vague.

Maybe I should look for a different approach.

Let me consider that the total sum S is equal to sum over all k excursions of the friendship value at the time of choosing.

Now, for each excursion, the friendship value is f_i plus the number of times the pair has been chosen before, if it's a friend pair.

Wait, but only for friend pairs, and non-friend pairs have friendship value 0.

So, for each excursion, the expected friendship value is sum over all friend pairs of P(choosing that pair) * (f_i + number of times chosen before).

But the number of times chosen before is a random variable.

This seems too involved.

Perhaps I can consider that the expected sum S is equal to sum over all friend pairs of f_i times the expected number of times they are chosen plus the expected number of times they are chosen after being chosen before.

Wait, still complicated.

Let me try to think about a simpler case.

Consider n=2, m=1, k=1.

So, there are two children, one friend pair with friendship value f_1, and one excursion.

The probability of choosing the friend pair is 1 (since there's only one pair).

So, the friendship value at the time of choosing is f_1.

Hence, S = f_1.

Now, according to my earlier formula, total_pairs = 1.

So, E[S] = (2*k*f_i)/(n*(n-1)) + (2*k*(k-1))/(n*(n-1))^2 = (2*1*f_1)/2 + (2*1*0)/4 = f_1 + 0 = f_1.

Which matches.

Another simple case: n=2, m=1, k=2.

Now, there are two excursions.

If the pair is chosen in the first excursion, their friendship value increases by 1 for the second excursion.

So, possible scenarios:

1. Choose the pair in both excursions: S = f_1 + (f_1 + 1).

2. Choose the pair in the first excursion and not in the second: S = f_1 + f_1.

3. Choose the pair in the second excursion and not in the first: S = 0 + f_1.

4. Choose not in either: S = 0 + 0.

Wait, but n=2, m=1, so there's only one pair, so in each excursion, the same pair is chosen.

Wait, no, with n=2, there's only one possible pair, so in each excursion, that pair is chosen.

Hence, S = f_1 + (f_1 + 1) = 2*f_1 + 1.

Hence, E[S] = 2*f_1 + 1.

Now, according to my earlier formula:

total_pairs = 1.

So, E[S] = sum over friend pairs of [(2*k*f_i)/total_pairs + (2*k*(k-1))/total_pairs^2].

Which is (2*2*f_1)/1 + (2*2*1)/1^2 = 4*f_1 + 4.

Which does not match with 2*f_1 + 1.

Hence, my earlier formula is incorrect.

So, perhaps I need to rethink my approach.

Let me consider that for each friend pair, their expected contribution is f_i times the expected number of times they are chosen plus the expected number of times they are chosen after being chosen before.

Wait, perhaps I need to consider that each time a friend pair is chosen, their friendship value increases by 1 for all subsequent choices.

Wait, but the problem says that when a friend pair is chosen, their friendship value increases by 1 for all subsequent excursions.

Wait, no, it says "their friendship value increases by 1 for all subsequent excursions".

Wait, re-reading the problem: "If a pair of children who are friends is chosen, their friendship value increases by 1 for all subsequent excursions."

So, it's not that the friendship value increases by 1 each time they are chosen, but rather that each time they are chosen, their friendship value at that time is f_i plus the number of times they have been chosen before.

Wait, no, the problem says that when a friend pair is chosen, their friendship value increases by 1 for all subsequent excursions.

So, it's as if their friendship value is permanently increased by 1 for each choice.

Hence, the friendship value at the time of choosing is f_i plus the number of times they have been chosen before.

So, if a friend pair is chosen t times, their friendship values at the times of choosing are f_i, f_i +1, f_i +2, ..., f_i +(t-1).

Hence, the total contribution is t*f_i + (t*(t-1))/2.

So, the expected total contribution for one friend pair is E[t*f_i + (t*(t-1))/2], where t is the number of times they are chosen.

Given that t follows a binomial distribution with parameters k and p=1/total_pairs, we have E[t] = k*p and E[t*(t-1)] = k*(k-1)*p^2.

Hence, E[t*f_i + (t*(t-1))/2] = f_i * E[t] + E[t*(t-1)] / 2 = f_i * (k*p) + (k*(k-1)*p^2)/2.

Now, p = 1 / total_pairs, where total_pairs = n*(n-1)/2.

Hence, E[contribution of one friend pair] = f_i * (2*k)/(n*(n-1)) + (k*(k-1))/(2*(n*(n-1)/2)^2).

Wait, p = 1 / (n*(n-1)/2) = 2 / (n*(n-1)).

Hence, E[contribution] = f_i * (2*k)/(n*(n-1)) + (k*(k-1)*4)/(2*(n*(n-1))^2) ) = f_i * (2*k)/(n*(n-1)) + (2*k*(k-1))/(n*(n-1))^2.

Now, for the earlier simple case of n=2, m=1, k=2, f_i = f_1.

Then, E[S] = f_1 * (2*2)/(2*1) + (2*2*1)/(2*1)^2 = f_1 * 2 + 4/4 = 2*f_1 + 1.

Which matches the earlier calculation.

Hence, my formula seems correct now.

So, total E[S] = sum over all m friend pairs of [f_i * (2*k)/(n*(n-1)) + (2*k*(k-1))/(n*(n-1))^2)].

Wait, but in the simple case, it was only one friend pair, so it matched.

Now, for multiple friend pairs, do I need to consider interactions between them?

I think not, because each friend pair's contribution is independent of others.

Hence, E[S] = sum over all m friend pairs of [f_i * (2*k)/(n*(n-1)) + (2*k*(k-1))/(n*(n-1))^2)].

Now, this can be simplified to:

E[S] = (2*k)/(n*(n-1)) * sum over all m friend pairs of f_i + m * (2*k*(k-1))/(n*(n-1))^2.

Now, I need to compute this expression modulo 10^9+7, after adjusting for the fraction.

But, since we have to express it as p/q with p and q coprime, and then compute p * q^{-1} mod 10^9+7.

Hence, I need to compute E[S] as a fraction and then find p and q such that E[S] = p/q, with p and q coprime, and then compute p * q^{-1} mod 10^9+7.

Now, to compute E[S], I need to compute sum of f_i over all friend pairs multiplied by (2*k)/(n*(n-1))) plus m times (2*k*(k-1))/(n*(n-1))^2.

Let me denote sum_f = sum of f_i over all friend pairs.

Then, E[S] = (2*k*sum_f)/(n*(n-1)) + (2*k*(k-1)*m)/(n*(n-1))^2.

Now, I need to compute this expression modulo 10^9+7, after expressing it as p/q with p and q coprime.

To do this efficiently, I need to compute this expression using modular arithmetic, specifically by finding the modular inverse of the denominator.

But since 10^9+7 is a prime, I can use Fermat's Little Theorem to compute inverses.

So, first, I need to compute the denominator q = (n*(n-1))^2.

Then, the numerator p = (2*k*sum_f)*(n*(n-1)) + 2*k*(k-1)*m.

Wait, no, let's see.

Wait, to have a common denominator, I need to write both terms with denominator (n*(n-1))^2.

So, E[S] = [ (2*k*sum_f)*(n*(n-1)) + 2*k*(k-1)*m ] / (n*(n-1))^2.

Hence, p = (2*k*sum_f)*(n*(n-1)) + 2*k*(k-1)*m.

And q = (n*(n-1))^2.

Then, I need to compute p * q^{-1} mod 10^9+7.

Hence, in code, I need to compute p, compute q^{-1} mod 10^9+7, and then multiply them.

But, to handle large numbers, I need to ensure that all operations are done modulo 10^9+7, except for the inverse computation.

Wait, but p can be very large, since f_i can be up to 1e9 and m can be up to 1e5, and k up to 2e5, and n up to 1e5.

Hence, p can be up to around 1e9 * 2e5 * 1e5, which is 2e23, which is too big to handle directly.

Hence, I need a better way to compute p modulo 1e9+7.

To do this, I need to compute each term modulo 1e9+7 and then sum them up modulo 1e9+7.

So, I need to compute:

p = (2*k*sum_f * n*(n-1) + 2*k*(k-1)*m) mod (1e9+7)

And q = (n*(n-1))^2 mod (1e9+7)

Then, compute p * q^{-1} mod (1e9+7)

But, I need to ensure that the fraction p/q is accurate.

Wait, but p and q might not be coprime, but since we are working modulo a prime, p * q^{-1} will give us the correct p/q modulo 1e9+7.

Hence, this should work.

Now, to implement this efficiently, I need to compute sum_f, n, n-1, k, m, all modulo 1e9+7.

Then, compute p and q as above, compute q^{-1}, and then p * q^{-1} mod 1e9+7.

Now, in code, I need to handle multiple test cases, up to 5e4, with sum of n and m over all test cases up to 1e5 and sum of k up to 2e5.

Hence, I need an efficient implementation.

Let me outline the steps:

1. Read the number of test cases t.

2. For each test case:

a. Read n, m, k.

b. Compute total_pairs = n*(n-1)/2.

But need to handle modulo inverse.

Wait, actually, since n and n-1 might not be coprime with 1e9+7, I need to compute (n*(n-1)) modulo 1e9+7.

But, to compute q = (n*(n-1))^2 mod 1e9+7.

Similarly, p = (2*k*sum_f * n*(n-1) + 2*k*(k-1)*m) mod 1e9+7.

Wait, but I need to ensure that n*(n-1) is computed correctly modulo 1e9+7.

Also, need to compute sum_f modulo 1e9+7.

Hence, in code:

- Read n, m, k.

- Compute denominator q = (n * (n - 1)) ^ 2 mod 1e9+7.

- Compute numerator p = (2 * k * sum_f * n * (n - 1) + 2 * k * (k - 1) * m) mod 1e9+7.

- Compute q_inv = modular_inverse(q, 1e9+7).

- Compute result = p * q_inv mod 1e9+7.

- Print result.

Now, I need to implement this efficiently.

Also, need to handle the modular inverse carefully, ensuring that q is not zero modulo 1e9+7.

But q = (n*(n-1))^2, and n >=2, so q is non-zero.

Hence, no issues.

Now, to compute the modular inverse, I can use the built-in pow function in Python: pow(q, -1, MOD).

Now, let's look at the provided code and see if it implements this correctly.

Looking at the provided code:

def func():

for i in range(int(input())):

(n, m, k) = map(int, input().split())

M = 10 ** 9 + 7

c = pow(n * (n - 1) // 1, -1, M)

s = 0

a = 0

for i in range(m):

(u, v, f) = map(int, input().split())

a += f

for i in range(k):

s = s + c * i * c * m + c * a

print(s % M)

Wait, this seems incorrect.

First, c = pow(n * (n - 1) // 1, -1, M)

Wait, n * (n - 1) // 1 is just n * (n - 1), since //1 does nothing.

So, c = modular_inverse(n * (n - 1), M)

Then, in the loop over k excursions, s is updated as s = s + c * i * c * m + c * a

This seems totally off from what I derived earlier.

In my derivation, I have p = (2*k*sum_f * n*(n-1) + 2*k*(k-1)*m) mod M

And q = (n*(n-1))^2 mod M

Then, result = p * q_inv mod M, where q_inv = pow(q, -1, M)

But in the provided code, it's looping over k and adding c * i * c * m + c * a each time.

This doesn't match my formula.

Hence, the provided code is incorrect.

Therefore, Correctness: False

**Final Answer**

\[ \boxed{\text{False}} \]