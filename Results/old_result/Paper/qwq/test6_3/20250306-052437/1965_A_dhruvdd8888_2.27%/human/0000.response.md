Alright, I have this problem to solve. It's about a game that Alice and Bob are playing with piles of stones. The rules are a bit unique. On each turn, a player chooses a positive integer k that is less than or equal to the smallest pile and removes k stones from every non-empty pile. The player who can't make a move loses, which means all piles are empty.

So, I need to determine who wins if both play optimally, given that Alice starts first.

First, I need to understand the game mechanics thoroughly. The key point is that the player chooses a k that is at most the size of the smallest non-empty pile and removes k stones from each non-empty pile. This is different from standard Nim or other stone-removal games where stones are typically removed from one pile at a time.

Let me think about what happens in the game step by step.

Suppose there is only one pile. If it's non-empty, Alice can choose k equal to that pile's size, remove all stones, and Bob has no moves left, so Alice wins.

If there are two piles, things get interesting. If both piles have the same number of stones, say a and a, then Alice can choose k = a, remove a stones from both piles, and make them empty, so Alice wins again.

Wait, but the problem says that k must be at most the smallest non-empty pile, and remove k stones from each non-empty pile. So, if piles are of different sizes, say 1 and 7, Alice can only choose k = 1 (since 1 is the smallest pile). After removing 1 stone from each pile, the piles become 0 and 6. Now, Bob can choose k = 6 (since 6 is the smallest non-empty pile), remove 6 stones from the pile of 6, making it empty, and Alice is left with no stones, so Bob wins.

Hmm, so in this case, with two piles of different sizes, Bob wins.

Wait, but in the example provided in the problem, for the input:

2

1 7

The output is "Bob", which matches my reasoning.

Now, let's consider another example with three piles. Say piles are 1, 2, 3.

Alice must choose k = 1 (smallest pile is 1). She removes 1 stone from each pile, making them 0, 1, 2.

Now, Bob looks at the piles: 0, 1, 2. The smallest non-empty pile is 1. So, he chooses k = 1, removes 1 stone from each non-empty pile, making them 0, 0, 1.

Now, Alice looks at the piles: 0, 0, 1. The smallest non-empty pile is 1. She chooses k = 1, removes 1 stone from the pile of 1, making all piles empty. Bob has no moves left, so Alice wins.

So, in this case, with three piles of sizes 1, 2, 3, Alice wins.

Looking back at the example in the problem, for n=3 and piles=1,2,3, the output is "Alice", which matches.

Let me try another case. Suppose n=4, piles=1,1,1,1.

Alice chooses k=1 (smallest pile is 1), removes 1 stone from each pile, making all piles empty. Bob has no moves left, so Alice wins.

Another case: n=4, piles=2,2,2,2.

Alice chooses k=2, removes 2 stones from each pile, making all piles empty. Bob loses.

So, it seems that if all piles are equal, Alice can always win by choosing k equal to that value and removing from all piles.

But what if the piles are not all equal?

Let's take n=3, piles=1,2,4.

Alice must choose k=1, removes 1 stone from each pile, making piles 0,1,3.

Bob now looks at piles: 0,1,3. The smallest non-empty pile is 1. He chooses k=1, removes 1 stone from each non-empty pile, making piles 0,0,2.

Alice now looks at piles: 0,0,2. She chooses k=2, removes 2 stones from the pile of 2, making all piles empty. Bob loses.

So, Alice wins again.

Another case: n=4, piles=1,2,3,4.

Alice chooses k=1, removes 1 stone from each pile, making piles 0,1,2,3.

Bob looks at piles: 0,1,2,3. The smallest non-empty pile is 1. He chooses k=1, removes 1 stone from each non-empty pile, making piles 0,0,1,2.

Alice looks at piles: 0,0,1,2. The smallest non-empty pile is 1. She chooses k=1, removes 1 stone from each non-empty pile, making piles 0,0,0,1.

Bob looks at piles: 0,0,0,1. He chooses k=1, removes 1 stone from the pile of 1, making all piles empty. Alice has no moves left, so Bob wins.

Wait, so in this case, with n=4 and piles=1,2,3,4, Bob wins.

But according to my earlier logic, with n=3, Alice wins, with n=4, Bob wins.

Wait, maybe there's a pattern based on the number of piles.

Wait, but in the earlier case with n=3, Alice wins, and with n=4, Bob wins, but that doesn't seem consistent.

Wait, perhaps it's based on the number of distinct pile sizes.

Wait, let's think differently. Maybe it's about the mex (minimal excludant) or something related to Grundy numbers in game theory.

In game theory, positions can be assigned Grundy numbers, and the XOR of all Grundy numbers gives the overall game's Grundy number. If it's zero, the position is losing for the current player; otherwise, it's winning.

But in this game, since all moves affect all piles simultaneously, it's not a standard Nim game where piles are independent.

I need to find the Grundy number for this game.

Let me try to model this.

First, observe that the game state is determined by the multiset of pile sizes, since the order doesn't matter.

But because removing k stones from all piles is equivalent to subtracting k from each pile, this is similar to considering the differences in pile sizes.

Wait, perhaps it's similar to making all piles equal to the smallest pile, and then repeating.

Wait, but it's not exactly that, because you're removing k stones from each pile simultaneously.

Let me think differently. Suppose I have piles a1, a2, ..., an.

A move consists of choosing k <= min of the piles, and subtracting k from each pile.

This is equivalent to replacing each pile ai with ai - k.

The game ends when all piles are zero.

This seems similar to the game of Euclidean algorithm, where you subtract multiples from pairs.

But I need to find a way to compute the Grundy number for this game.

Alternatively, maybe there's a pattern based on the number of distinct pile sizes.

Wait, in the first example, with n=5 and all piles equal to 3, Alice can choose k=3 and win immediately.

In the second example, n=2 with piles 1 and 7, Alice chooses k=1, and Bob chooses k=6 and wins.

In the third example, n=7 with piles 1,3,9,7,4,2,100, Alice wins.

In the fourth example, n=3 with piles 1,2,3, Alice wins.

In the fifth example, n=6 with piles 2,1,3,4,2,4, Bob wins.

In the sixth example, n=8 with piles 5,7,2,9,6,3,3,2, Alice wins.

In the seventh example, n=1 with pile 1000000000, Alice wins.

Looking at these examples, it seems that when the number of distinct pile sizes is odd, Alice wins, and when it's even, Bob wins.

Wait, let's check:

First test case: n=5, all piles=3. Distinct pile sizes: 1 (3). Odd number, Alice wins.

Second test case: n=2, piles=1,7. Distinct pile sizes: 2 (1,7). Even number, Bob wins.

Third test case: n=7, piles=1,3,9,7,4,2,100. Distinct pile sizes: 7 (1,2,3,4,7,9,100). Odd number, Alice wins.

Fourth test case: n=3, piles=1,2,3. Distinct pile sizes: 3 (1,2,3). Odd number, Alice wins.

Fifth test case: n=6, piles=2,1,3,4,2,4. Distinct pile sizes: 4 (1,2,3,4). Even number, Bob wins.

Sixth test case: n=8, piles=5,7,2,9,6,3,3,2. Distinct pile sizes: 6 (2,3,5,6,7,9). Even number, Bob wins.

Wait, but in the output, it's "Alice". Wait, in the problem statement, the sixth test case output is "Alice".

Wait, maybe I miscounted.

Wait, piles: 5,7,2,9,6,3,3,2. Distinct pile sizes: 2 appears twice, 3 appears twice, so distinct sizes are 2,3,5,6,7,9. That's 6, which is even, so Bob should win, but the output is "Alice".

So, my hypothesis is wrong.

Hmm.

Let me think again.

Maybe it's about the number of piles that are larger than the smallest pile.

Wait, in the first test case, all piles are equal to 3. So, no piles larger than the smallest pile. Alice wins.

In the second test case, piles=1,7. One pile larger than the smallest pile (7 >1). Bob wins.

In the third test case, piles=1,3,9,7,4,2,100. There are piles larger than the smallest pile. Alice wins.

Fourth test case: piles=1,2,3. Piles larger than the smallest pile: 2 and 3. Alice wins.

Fifth test case: piles=2,1,3,4,2,4. Piles larger than the smallest pile: 1 is the smallest, so all others are larger. Alice wins? Wait, output is "Bob".

Wait, this isn't consistent.

Wait, output for the fifth test case is "Bob", but according to this, there are piles larger than the smallest pile, and Alice still loses.

So, this hypothesis doesn't hold.

Let me think differently.

Perhaps it's about the mex of the pile sizes.

Wait, in game theory, the mex (minimal excludant) is the smallest non-negative integer not present in the set.

But I'm not sure how to apply that here.

Alternatively, maybe it's about the number of times the pile sizes change.

Wait, perhaps it's about the number of possible moves.

But that seems too vague.

Let me consider the game as equivalent to some other known game.

Wait, the operation of removing k stones from each pile is similar to taking the minimum pile size and reducing it to zero, but that doesn't seem directly applicable.

Wait, perhaps I can think of the game in terms of the differences between pile sizes.

Wait, let's consider that after each move, the differences between the pile sizes change.

But I need a better approach.

Let me look for a pattern in the number of distinct pile sizes.

In the first test case, distinct pile sizes: 1 (all equal), Alice wins.

Second test case: 2, Bob wins.

Third test case: 7, Alice wins.

Fourth test case: 3, Alice wins.

Fifth test case: 4, Bob wins.

Sixth test case: 6, Alice wins.

Wait, in the sixth test case, with 6 distinct pile sizes, output is "Alice", which contradicts my earlier hypothesis that even number of distinct pile sizes lead to Bob winning.

Wait, perhaps I miscounted the distinct pile sizes in the sixth test case.

Piles: 5,7,2,9,6,3,3,2. Distinct pile sizes: 2,3,5,6,7,9. That's 6 distinct sizes, and output is "Alice".

So, my earlier hypothesis is incorrect.

Let me try another approach.

Maybe it's about the number of piles that are equal to the smallest pile.

In the first test case, n=5, all piles=3. Number of piles equal to smallest pile: 5.

Second test case, n=2, piles=1,7. Number of piles equal to smallest pile:1.

Third test case, n=7, piles=1,3,9,7,4,2,100. Smallest pile=1, number of piles equal to 1:1.

Fourth test case, n=3, piles=1,2,3. Smallest pile=1, number of piles equal to 1:1.

Fifth test case, n=6, piles=2,1,3,4,2,4. Smallest pile=1, number of piles equal to 1:1.

Sixth test case, n=8, piles=5,7,2,9,6,3,3,2. Smallest pile=2, number of piles equal to 2:2.

Seventh test case, n=1, pile=1000000000. Number of piles equal to smallest pile:1.

Looking at the outputs:

First test case: Alice (number of piles equal to smallest:5).

Second test case: Bob (1).

Third test case: Alice (1).

Fourth test case: Alice (1).

Fifth test case: Bob (1).

Sixth test case: Alice (2).

Seventh test case: Alice (1).

This doesn't seem to follow a clear pattern based on the number of piles equal to the smallest pile.

Maybe I need to think in terms of the number of times Alice and Bob can make moves.

But that seems too vague.

Let me try to simulate the game for a few steps for a general case.

Suppose we have piles a1, a2, ..., an sorted in increasing order.

On each move, the player chooses k between 1 and a1 (the smallest pile), and subtracts k from each ai.

After the move, the new piles are ai - k for all i.

The game continues until all piles are zero.

This seems similar to repeated subtraction games, but with a twist that k affects all piles simultaneously.

Perhaps I can model this as a single pile game, where the pile size is some function of the current pile sizes.

Wait, maybe it's equivalent to a single pile game where the pile size is the number of non-empty piles.

Wait, that doesn't seem right.

Let me think about the number of non-empty piles.

In the first move, Alice chooses k between 1 and the smallest pile.

After removing k from each pile, some piles may become zero.

The number of non-empty piles decreases based on how many piles were equal to k.

Wait, perhaps the game can be modeled based on the number of distinct non-empty pile sizes.

Wait, I need a better approach.

Let me look for a pattern in the sample inputs and outputs.

Looking back at the sample inputs and outputs:

Test case 1:

n=5, piles=3 3 3 3 3

Output: Alice

Test case 2:

n=2, piles=1 7

Output: Bob

Test case 3:

n=7, piles=1 3 9 7 4 2 100

Output: Alice

Test case 4:

n=3, piles=1 2 3

Output: Alice

Test case 5:

n=6, piles=2 1 3 4 2 4

Output: Bob

Test case 6:

n=8, piles=5 7 2 9 6 3 3 2

Output: Alice

Test case 7:

n=1, pile=1000000000

Output: Alice

Looking at these, it seems that when there is only one pile, Alice wins by taking all stones.

When there are two piles, Bob wins if the piles are different, as shown in test case 2.

In test case 3, with seven piles having distinct sizes, Alice wins.

In test case 4, with three piles having distinct sizes, Alice wins.

In test case 5, with six piles having some duplicates, Bob wins.

In test case 6, with eight piles and some duplicates, Alice wins.

It's unclear what the exact condition is.

Perhaps it's about the number of distinct pile sizes being odd or even.

In test case 1: 1 distinct pile size (3), Alice wins.

Test case 2: 2 distinct pile sizes (1,7), Bob wins.

Test case 3: 7 distinct pile sizes (1,2,3,4,7,9,100), Alice wins.

Test case 4: 3 distinct pile sizes (1,2,3), Alice wins.

Test case 5: 4 distinct pile sizes (1,2,3,4), Bob wins.

Test case 6: 6 distinct pile sizes (2,3,5,6,7,9), Alice wins.

Wait, in test case 6, there are 6 distinct pile sizes, which is even, but the output is Alice wins, which contradicts the pattern that even number of distinct pile sizes lead to Bob winning.

Wait, perhaps I miscounted the distinct pile sizes in test case 6.

Piles: 5,7,2,9,6,3,3,2.

Distinct pile sizes: 2,3,5,6,7,9. That's 6 distinct pile sizes.

Output is Alice wins.

This contradicts the pattern.

So, perhaps the pattern is not just based on the number of distinct pile sizes.

Let me think differently.

Maybe it's about the number of piles that are larger than the smallest pile.

In test case 1: n=5, all piles=3. Number of piles larger than smallest: 0 (since all are equal). Alice wins.

Test case 2: n=2, piles=1,7. Number of piles larger than smallest:1 (7>1). Bob wins.

Test case 3: n=7, piles=1,3,9,7,4,2,100. Number of piles larger than smallest:6 (all except 1). Alice wins.

Test case 4: n=3, piles=1,2,3. Number of piles larger than smallest:2 (2 and 3). Alice wins.

Test case 5: n=6, piles=2,1,3,4,2,4. Number of piles larger than smallest:5 (all except 1). Bob wins.

Test case 6: n=8, piles=5,7,2,9,6,3,3,2. Number of piles larger than smallest:6 (all except 2's). Alice wins.

Test case 7: n=1, pile=1000000000. Number of piles larger than smallest:0. Alice wins.

Hmm, looking at this, it seems that when the number of piles larger than the smallest pile is even, Alice wins, and when it's odd, Bob wins.

Wait, let's check:

Test case 1: number of piles larger than smallest=0 (even), Alice wins.

Test case 2: number of piles larger than smallest=1 (odd), Bob wins.

Test case 3: number of piles larger than smallest=6 (even), Alice wins.

Test case 4: number of piles larger than smallest=2 (even), Alice wins.

Test case 5: number of piles larger than smallest=5 (odd), Bob wins.

Test case 6: number of piles larger than smallest=6 (even), Alice wins.

Test case 7: number of piles larger than smallest=0 (even), Alice wins.

This seems to hold.

So, the winning condition is that if the number of piles larger than the smallest pile is even, Alice wins; otherwise, Bob wins.

This seems consistent with all the sample inputs.

Let me verify this with another example.

Consider n=4, piles=1,1,1,1. Number of piles larger than smallest=0 (even), Alice wins.

n=4, piles=1,1,1,2. Number of piles larger than smallest=1 (odd), Bob wins.

n=4, piles=1,1,2,2. Number of piles larger than smallest=2 (even), Alice wins.

n=4, piles=1,2,2,2. Number of piles larger than smallest=3 (odd), Bob wins.

n=4, piles=2,2,2,2. Number of piles larger than smallest=0 (even), Alice wins.

This seems consistent.

So, the strategy is:

- Find the smallest pile.

- Count the number of piles that are larger than the smallest pile.

- If this count is even, Alice wins; otherwise, Bob wins.

This seems to be a winning strategy.

Now, looking at the given code, let's see if it implements this logic.

The code is:

from collections import *

from math import *

from heapq import *

import sys

from bisect import *

from random import randint

rrr = randint(8888, 88888)

for _ in range(int(input())):

func_1()

def func_1():

N = int(input())

nums = set(input().split())

nums = sorted(map(int, nums))

if len(nums) == 1:

return print('Alice')

if len(nums) == 2:

return print('Bob')

nums.insert(0, 0)

cd = 0

for i in range(len(nums) - 2):

if nums[i + 1] - nums[i] == 1:

cd += 1

else:

break

if cd & 1:

return print('Bob')

else:

return print('Alice')

Wait, this code seems more complicated than necessary.

First, it reads the number of test cases and defines a function func_1() that handles each test case.

In func_1():

- Read N, the number of piles.

- Read the pile sizes into a set, then sort them.

- If there is only one distinct pile size, print "Alice".

- If there are two distinct pile sizes, print "Bob".

- For more than two distinct pile sizes, insert 0 at the beginning of the sorted list.

- Then, count the number of consecutive integers starting from the smallest (excluding 0).

- If this count is odd, print "Bob"; else, print "Alice".

Wait, this doesn't seem to match the strategy I derived earlier.

According to my strategy, I need to count the number of piles larger than the smallest pile and check if that count is even or odd.

But in the code, it's sorting the distinct pile sizes, inserting 0, and then counting the number of consecutive integers starting from 0.

This seems different.

Let me see with an example.

Take test case 3:

n=7, piles=1,3,9,7,4,2,100

Distinct pile sizes: 1,2,3,4,7,9,100

Sorted: [1,2,3,4,7,9,100]

Insert 0 at beginning: [0,1,2,3,4,7,9,100]

Then, count the number of consecutive integers starting from 0:

0 to 1: difference 1, cd +=1

1 to 2: difference 1, cd +=1

2 to 3: difference 1, cd +=1

3 to 4: difference 1, cd +=1

4 to 7: difference 3, break

cd = 4, which is even, so print "Alice"

According to my earlier strategy, number of piles larger than smallest (1): 6, which is even, Alice wins. Matches.

Another example, n=3, piles=1,2,3

Distinct pile sizes:1,2,3

Sorted with 0: [0,1,2,3]

cd: 0 to1:1, 1 to2:1, 2 to3:1, cd=3, which is odd, print "Bob"

According to my strategy, number of piles larger than smallest (1):2, which is even, so Alice should win. But according to this code, it's printing "Bob", which is inconsistent with my strategy.

Wait, but in the sample input, for n=3, piles=1,2,3, output is "Alice". So, the code is wrong in this case.

Wait, perhaps my strategy is wrong.

Wait, in my earlier simulation, with n=3, piles=1,2,3, Alice wins.

But according to the code, cd=3, which is odd, so print "Bob", which contradicts the sample output.

So, perhaps my strategy is incorrect.

Wait, maybe I made a mistake in counting the number of piles larger than the smallest pile.

In n=3, piles=1,2,3:

Smallest pile=1, number of piles larger than 1:2 (2 and 3), which is even, so Alice should win.

But according to the code, cd=3, which is odd, print "Bob", but the sample output is "Alice".

So, the code is incorrect in this case.

Wait, perhaps the code is implementing a different strategy.

Let me see another example.

n=4, piles=1,1,1,2

Distinct pile sizes:1,2

Sorted with 0: [0,1,2]

cd: 0 to1:1, 1 to2:1, cd=2, which is even, print "Alice"

According to my strategy, smallest pile=1, number of piles larger than 1:1 (only 2), which is odd, so Bob should win.

But according to the code, it's printing "Alice", which is incorrect.

Wait, but according to the sample input, for n=3, piles=1,2,3, output is "Alice", but according to my strategy, it should be "Bob" in this case, but the code prints "Bob" when cd is odd.

Wait, I'm getting confused.

Wait, perhaps the correct strategy is to count the number of distinct pile sizes larger than the smallest pile.

In n=3, piles=1,2,3:

Smallest pile=1, number of distinct piles larger than 1:2 (2 and 3), which is even, so Alice wins.

In n=4, piles=1,1,1,2:

Smallest pile=1, number of distinct piles larger than 1:1 (only 2), which is odd, so Bob wins.

In n=4, piles=1,1,1,2:

According to the code, distinct piles:1,2, sorted with 0: [0,1,2], cd=2, even, print "Alice", which matches the corrected strategy.

In n=3, piles=1,2,3:

Distinct piles:1,2,3, sorted with 0: [0,1,2,3], cd=3, odd, print "Bob", but sample output is "Alice", which contradicts.

Wait, perhaps my strategy is wrong.

Wait, maybe it's about the number of distinct pile sizes larger than the smallest pile being even or odd.

In n=3, piles=1,2,3:

Number of distinct piles larger than 1:2, even, Alice wins.

In n=4, piles=1,1,1,2:

Number of distinct piles larger than 1:1, odd, Bob wins.

But in the code, for n=3, piles=1,2,3, it would print "Bob", which contradicts the sample output of "Alice".

So, perhaps my strategy is incorrect.

Wait, maybe I need to consider the frequency of the smallest pile.

Wait, perhaps if the number of piles equal to the smallest pile is even or odd.

In n=3, piles=1,2,3:

Number of piles equal to smallest:1, which is odd.

In n=4, piles=1,1,1,2:

Number of piles equal to smallest:3, which is odd.

But in the sample input, n=3, piles=1,2,3, output is "Alice", and n=4, piles=1,1,1,2, not in sample input, but according to my strategy, number of piles larger than smallest is even for n=3, Alice wins, which matches sample.

Wait, I'm getting more confused.

Maybe I need to look for an alternative approach.

Let me consider the game as a subtraction game where the allowed moves are to subtract k from all piles, where k <= smallest pile.

This is similar to converting all piles by subtracting k, which is equivalent to making all piles equal to ai - k.

This is similar to making all piles equal to some value between 0 and the current pile size.

Wait, perhaps it's similar to making moves based on the mex of the pile sizes.

But I'm not sure.

Alternatively, maybe it's about the number of times the smallest pile changes.

Wait, perhaps it's about the number of distinct pile sizes.

Wait, perhaps it's about the number of times the smallest pile is unique.

But I don't know.

Let me consider the game in terms of Nimbers or mex.

Wait, perhaps I can think of the game in terms of the number of times the smallest pile is the only pile of its size.

But this seems too vague.

Let me look back at the code.

The code sorts the distinct pile sizes and counts the number of consecutive integers starting from the smallest (excluding 0).

Then, if this count is odd, print "Bob"; else, print "Alice".

In the sample input where n=3, piles=1,2,3, sorted with 0: [0,1,2,3], cd=3 (0 to1,1 to2,2 to3), which is odd, so print "Bob", but the sample output is "Alice". So, the code is incorrect in this case.

Similarly, in n=4, piles=1,1,1,2, distinct piles:1,2, sorted with 0: [0,1,2], cd=2, even, print "Alice", which should be correct according to my earlier strategy.

But in the sample input, for n=3, piles=1,2,3, output is "Alice", which contradicts the code's output of "Bob".

So, the code seems to be incorrect.

Therefore, Correctness: False

**Final Answer**

\boxed{\text{False}}