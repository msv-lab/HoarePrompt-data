Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an integer n, and I need to build a string of uppercase letters such that there are exactly n "special" characters in this string. A special character is defined as one that is equal to exactly one of its neighbors.

First, I need to understand what makes a character special. Let's look at the example provided: in the string "AAABAACC", there are 6 special characters at positions 1, 3, 5, 6, 7, and 8. Let's verify that:

- Position 1: 'A' - neighbors are 'A' (left) and 'A' (right). But since it's the start, it only has a right neighbor. So, 'A' equals its only neighbor 'A', but the definition says "exactly one of its neighbors". Wait, but in this case, it's only equal to one neighbor because there's only one neighbor. So, it's special.

- Position 2: 'A' - neighbors are 'A' (left) and 'A' (right). It equals both neighbors, so it's not special.

- Position 3: 'A' - neighbors are 'A' (left) and 'B' (right). It equals only its left neighbor, so it's special.

- Position 4: 'B' - neighbors are 'A' (left) and 'A' (right). It doesn't equal either neighbor, so it's not special.

- Position 5: 'A' - neighbors are 'B' (left) and 'A' (right). It equals only its right neighbor, so it's special.

- Position 6: 'A' - neighbors are 'A' (left) and 'C' (right). It equals only its left neighbor, so it's special.

- Position 7: 'C' - neighbors are 'A' (left) and 'C' (right). It equals only its right neighbor, so it's special.

- Position 8: 'C' - neighbors are 'C' (left) and none on the right. It equals its only neighbor, so it's special.

Okay, that matches the example.

Now, I need to find a string where the number of such special characters is exactly n. I need to do this for multiple test cases, up to 50, and each n is between 1 and 50.

The output should be 'YES' followed by the string if such a string exists, or 'NO' if it doesn't. The string should be at most 200 characters long.

First, I need to think about how to construct such a string.

Let me think about the properties of these special characters.

- For a character to be special, it must equal exactly one of its neighbors.

- At the ends of the string, a character has only one neighbor, so it can only be special if it equals that neighbor.

- In the middle of the string, a character has two neighbors, and it must equal exactly one of them to be special.

I need to maximize or minimize the number of such special characters based on the given n.

Let me try to find a pattern or a way to calculate the number of special characters based on the string's structure.

Let's consider some small strings and count their special characters.

- "A": length 1, special characters: 1 (since it only has one neighbor, which is none, so it equals nothing, but according to the problem, it's equal to exactly one of its neighbors, which is none, so maybe it's not considered special. Wait, the problem says "equal to exactly one of its neighbors", but if there's only one neighbor, it needs to equal that single neighbor.

- Wait, in the case of the first and last characters, they have only one neighbor. So, for the first character, it's equal to its only neighbor to be special.

- For example, in "AA", both characters are equal to their only neighbor, so both are special.

- In "AB", the first 'A' equals its neighbor 'B'? No, so it's not special. The second 'B' equals its neighbor 'A'? No, so neither is special.

- In "AAB", the first 'A' equals its neighbor 'A', so it's special. The second 'A' equals both neighbors, so not special. The third 'B' equals its neighbor 'A', so it's special.

- So, in "AAB", positions 1 and 3 are special.

- So, for n=2, "AAB" works.

- Similarly, "AAAB" has special characters at positions 1, 3, and 4.

- Wait, let's check:

- Position 1: 'A' equals neighbor 'A', so special.

- Position 2: 'A' equals both neighbors 'A', so not special.

- Position 3: 'A' equals neighbor 'B', so special.

- Position 4: 'B' equals neighbor 'A', so special.

- So, positions 1, 3, and 4 are special. That's 3 special characters.

- So, for n=3, "AAAB" works.

- Wait, but according to the example, for n=6, "AAABAACC" has 6 special characters.

- Wait, in "AAABAACC":

- Position 1: 'A' equals 'A', special.

- Position 2: 'A' equals both 'A's, not special.

- Position 3: 'A' equals 'B', special.

- Position 4: 'B' doesn't equal neighbors, not special.

- Position 5: 'A' equals 'A', special.

- Position 6: 'A' equals 'C', special.

- Position 7: 'C' equals 'C', special.

- Position 8: 'C' equals 'C', special.

- So, positions 1,3,5,6,7,8 are special, total 6.

- So, pattern seems to be that by arranging As and Bs in certain ways, we can control the number of special characters.

Now, I need a general way to construct a string with exactly n special characters.

Let me think about the parity of n.

Looking at the example, for n=6, it's possible, for n=1 it's not possible, for n=2, "AAB" works.

Wait, in "AAB", positions 1 and 3 are special, total 2.

For n=1, is it possible?

If I have a string with only one special character, say length 2: "AB" - no specials.

Length 3: "AAB" - two specials.

Length 4: "AABB" - let's see:

- Position 1: 'A' equals 'A', special.

- Position 2: 'A' equals both 'A's, not special.

- Position 3: 'B' equals 'B', special.

- Position 4: 'B' equals 'B', special.

- So, positions 1,3,4 are special, total 3.

- Not 1.

Is there a way to have only one special character?

Let me try "A":

- Only one character, which is special, total 1.

Wait, but according to the problem, for a single character, it only has one neighbor, which is none, so it doesn't equal one neighbor because it has no neighbors to equal.

Wait, the problem says "exactly one of its neighbors", but if there's only one neighbor and it's none, then it doesn't equal one neighbor.

So, maybe single character is not special.

Wait, I need to think carefully.

If a character has only one neighbor, to be special, it must equal that single neighbor.

In the case of the first character, it only has a right neighbor.

So, for it to be special, it must equal its right neighbor.

Similarly, the last character must equal its left neighbor to be special.

If the string has only one character, it has no neighbors, so it cannot equal exactly one neighbor because there are no neighbors.

Hence, it's not special.

So, for n=1, it's impossible because you can't have just one special character.

That matches the example where n=1 outputs 'NO'.

Similarly, for n=2, "AAB" works.

For n=6, "AAABAACC" works.

So, it seems that n must be even.

Wait, n=6 is even, n=2 is even, n=1 is odd and not possible.

Wait, in the example, n=2 is possible with "MM".

Wait, in the example output, for n=6: YES AAABAACC

n=1: NO

n=2: YES MM

So, "MM" would be "MM", which is two characters, both 'M's.

So, in "MM":

- Position 1: 'M' equals 'M', so special.

- Position 2: 'M' equals 'M', so special.

- So, two special characters.

Hence, n=2 is possible.

Similarly, n=4: "AABAA"

- Position 1: 'A' equals 'A', special.

- Position 2: 'A' equals both 'A's, not special.

- Position 3: 'B' doesn't equal neighbors, not special.

- Position 4: 'A' equals 'A', special.

- Position 5: 'A' equals 'A', special.

- So, positions 1,4,5 are special, total 3.

- Not 4.

Wait, need another arrangement.

Maybe "AABBAACC"

- Position 1: 'A' equals 'A', special.

- Position 2: 'A' equals both 'A's, not special.

- Position 3: 'B' equals 'A', special.

- Position 4: 'B' equals 'A', special.

- Position 5: 'A' equals 'A', special.

- Position 6: 'A' equals 'C', special.

- Position 7: 'C' equals 'C', special.

- Position 8: 'C' equals 'C', special.

- So, positions 1,3,4,5,6,7,8 are special, total 7.

- Not 4.

Need a different approach.

Alternatively, think that every 'A' between two 'B's or similar can create specials.

Wait, maybe it's easier to see that for n even, it's possible, for n odd, it's not.

From the example, n=6 even, possible; n=1 odd, not possible; n=2 even, possible.

Let me check n=4.

Can I construct a string with exactly 4 special characters?

Let's try "AABBAACC":

- Position 1: 'A' equals 'A', special.

- Position 2: 'A' equals both 'A's, not special.

- Position 3: 'B' equals 'A', special.

- Position 4: 'B' equals 'A', special.

- Position 5: 'A' equals 'A', special.

- Position 6: 'A' equals 'C', special.

- Position 7: 'C' equals 'C', special.

- Position 8: 'C' equals 'C', special.

- Total specials: 1,3,4,5,6,7,8 → 7, which is more than 4.

Not good.

Try "AABB":

- Position 1: 'A' equals 'A', special.

- Position 2: 'A' equals both 'A's, not special.

- Position 3: 'B' equals 'B', special.

- Position 4: 'B' equals 'B', special.

- Total specials: 1,3,4 → 3.

- Not 4.

Try "AABBC":

- Position 1: 'A' equals 'A', special.

- Position 2: 'A' equals both 'A's, not special.

- Position 3: 'B' equals 'B', special.

- Position 4: 'B' equals 'C', special.

- Position 5: 'C' equals nothing, special.

- Total specials: 1,3,4,5 → 4.

- Perfect.

So, for n=4, "AABBC" works.

Hence, it seems that for even n, it's possible, and for odd n, it's not.

Wait, but in the example, for n=1, it's impossible, which is odd.

For n=2, possible; n=6, possible.

Let me check n=3.

Is n=3 possible?

Try "AAB":

- Specials at positions 1 and 3, total 2.

Not enough.

Try "AABBA":

- Position 1: 'A' equals 'A', special.

- Position 2: 'A' equals both 'A's, not special.

- Position 3: 'B' equals 'A', special.

- Position 4: 'B' equals 'A', special.

- Position 5: 'A' equals nothing, special.

- Total specials: 1,3,4,5 → 4.

- More than 3.

Is there a way to get exactly 3 specials?

Try "AABA":

- Position 1: 'A' equals 'A', special.

- Position 2: 'A' equals both 'A's, not special.

- Position 3: 'B' equals 'A', special.

- Position 4: 'A' equals nothing, special.

- Total specials: 1,3,4 → 3.

- Perfect.

So, n=3 is possible with "AABA".

But according to earlier thinking, n=3 is odd, and according to the initial assumption, odd n might not be possible, but in this case, it is possible.

Wait, but in the example, n=1 is impossible, n=3 is possible.

Wait, maybe only n=1 is impossible, but higher odd n are possible.

Wait, but in the initial example, n=1 is impossible, but n=3 is possible.

Wait, perhaps my earlier assumption is wrong.

Wait, perhaps there's another pattern.

Wait, in "AABA", n=3 is possible.

Similarly, in "AABBA", n=4 is possible.

Wait, perhaps it's possible for all n >=2.

But in the example, n=1 is impossible.

Wait, maybe n=1 is the only impossible one.

But in the program given, it checks if n % 2 == 1, then 'NO', else 'YES'.

But according to "AABA", n=3 is possible.

Wait, maybe the program is incorrect.

Wait, perhaps there's a different way to construct the string.

Let me think differently.

Suppose I use a pattern like 'AAB' repeated.

In 'AAB':

- Specials at positions 1 and 3.

So, every 'AAB' adds 2 specials.

So, for even n, I can have 'AAB' repeated n/2 times.

For odd n, it's impossible because I can't have half 'AAB's.

Wait, but in "AABA", which is 'AAB' + 'A', I get 3 specials.

So, perhaps for odd n, I can have 'AAB' repeated (n-1)/2 times and add an 'A' at the end.

Wait, in "AABA", n=3 specials.

So, perhaps the program is incorrect because it says for odd n, 'NO', but in reality, for n=3, it's possible.

Hence, the program is incorrect.

Wait, but in the example, for n=1, 'NO', which is correct.

For n=6, 'YES AAABAACC', which is correct.

For n=2, 'YES MM', which is correct.

But according to my earlier thinking, n=3 should be possible, but the program says 'NO'.

Wait, perhaps there's a constraint I'm missing.

Looking back at the problem, it says "print any suitable string or report that there is no such string."

It also says "it can be shown that if some answers exist, then there is an answer of length at most 200."

So, perhaps for some n, there is no such string.

But according to my earlier example, n=3 is possible with "AABA".

Wait, but the program would say for n=3, 'NO', which contradicts with "AABA" being a valid string with 3 specials.

Hence, the program is incorrect.

Perhaps the correct condition is that n cannot be 1.

Because for n=1, it's impossible, but for n >=2, it's possible.

Wait, but according to my earlier example, n=3 is possible.

Wait, perhaps the correct condition is that n cannot be 1.

But in "AABA", n=3 is possible.

Wait, maybe n cannot be 1, and for all n >=2, it's possible.

Wait, but in the program, it checks if n % 2 ==1, then 'NO', else 'YES'.

But according to "AABA", n=3 is possible, so the program would say 'NO' for n=3, which is incorrect.

Hence, the program is incorrect.

Perhaps the correct condition is that n cannot be 1.

So, for n=1, 'NO', for n >=2, 'YES'.

But in "AABA", n=3 is possible, and "AAB" * (n//2) would give 'AAB' *1 = 'AAB', which has 2 specials, not 3.

But by adding an extra 'A', it becomes 'AABA', which has 3 specials.

So, perhaps the program needs to handle odd n differently.

Hence, the program is incorrect because it doesn't handle odd n correctly.

Hence, Correctness: **False**

**Final Solution**

To solve this problem, we need to construct a string of uppercase Latin letters such that there are exactly n special characters in the string. A special character is defined as one that is equal to exactly one of its neighbors.

## Approach

1. **Understanding Special Characters**:
   - For a character to be special, it must be equal to exactly one of its neighbors.
   - Characters at the ends of the string have only one neighbor, so they are special if they are equal to that neighbor.
   - Characters in the middle have two neighbors, so they are special if they are equal to one but not both neighbors.

2. **Observations**:
   - For n=1, it is impossible to have a single special character because the first character is special only if it equals the second character, making the second character also special unless it equals the third, and so on.
   - For n=2, a string like "AAB" works, where the first and third characters are special.
   - For higher even n, repeating the pattern "AAB" will add two special characters each time.
   - For odd n greater than 1, we can use a similar pattern but need to adjust to achieve the odd count.

3. **Solution Strategy**:
   - For n=1, output 'NO' because it is impossible.
   - For n >= 2, construct a string using the pattern "AAB" repeated (n//2) times. If n is odd, adjust by appending an 'A' to the string to achieve the exact count of special characters.

## Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    t = int(data[idx])
    idx += 1
    for _ in range(t):
        n = int(data[idx])
        idx += 1
        if n == 1:
            print('NO')
        else:
            # For n >= 2, construct the string
            base = 'AAB'
            if n % 2 == 0:
                s = (base * (n // 2))[:200]
            else:
                # For odd n, adjust by appending an 'A'
                s = (base * (n // 2)) + 'A'[:200 - len(base * (n // 2))]
            if len(s) > 0 and len(s) <= 200:
                print('YES')
                print(s)
            else:
                print('NO')

if __name__ == "__main__":
    main()
```

## Explanation

- **Input Handling**:
  - Read all input data at once for efficiency.
  - Parse the number of test cases and iterate through each one.

- **Special Case Handling**:
  - If n=1, directly output 'NO' since it's impossible to have a single special character.

- **String Construction**:
  - Use the pattern "AAB" which contributes 2 special characters.
  - For even n, repeat "AAB" (n//2) times.
  - For odd n, repeat "AAB" (n//2) times and append an 'A' to achieve the desired count.

- **Output**:
  - Print 'YES' followed by the constructed string if the string meets the criteria and is within the length limit.
  - Print 'NO' if it's impossible to construct such a string for the given n.

This approach ensures that we handle all cases correctly, including the edge case of n=1, and construct valid strings for other values of n within the constraints.