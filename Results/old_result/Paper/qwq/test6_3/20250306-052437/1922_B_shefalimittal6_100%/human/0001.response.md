Alright, I've got this problem to solve. Let's see what it's asking for. So, I have n sticks, each with a length of 2 raised to the power of a certain number, specifically 2^{a_i} for each stick i. I need to choose exactly 3 sticks and form a non-degenerate triangle with them. A non-degenerate triangle means that the area is greater than 0, which in terms of side lengths translates to the triangle inequality holding: the sum of any two sides must be greater than the third side.

So, my task is to count how many ways I can choose 3 sticks such that they satisfy the triangle inequality.

First, I need to understand the properties of the lengths given. Since the lengths are of the form 2^{a_i}, and exponents a_i can range from 0 to n, I should consider the properties of powers of 2.

One important property of powers of 2 is that they are distinct and double each time. So, 2^0 = 1, 2^1 = 2, 2^2 = 4, and so on. This means that each stick has a unique length in terms of powers of 2, except if there are duplicates in the a_i values.

Wait, but the problem states that a_i can be from 0 to n, and n can be up to 3*10^5, so a_i can be large, but since 2^{a_i} can be very large numbers, I need to think about how to handle these lengths efficiently.

Given that the lengths are powers of 2, maybe there's a smart way to use the properties of exponents to simplify the problem.

Let me think about the triangle inequality again. For three lengths to form a triangle, the sum of the two smaller lengths must be greater than the largest length.

Given that all lengths are powers of 2, and powers of 2 are strictly increasing, meaning that for any two different exponents, one length will be strictly greater than the other.

So, if I have three lengths 2^a, 2^b, and 2^c, where a <= b <= c, then the condition for forming a triangle is 2^a + 2^b > 2^c.

Given that 2^a + 2^b is equal to 2^b * (2^{a-b} + 1). But since a <= b <= c, and 2^b + 2^a is less than or equal to 2*2^b = 2^{b+1}, which is less than or equal to 2^c if b+1 <= c.

Wait, more carefully: 2^a + 2^b <= 2^b + 2^b = 2^{b+1}. So, 2^a + 2^b <= 2^{b+1}.

Now, since c >= b, if c > b+1, then 2^{b+1} < 2^c, so 2^a + 2^b < 2^c, and the triangle inequality would not hold.

Therefore, the only way to have 2^a + 2^b > 2^c is if c <= b+1.

But since a <= b <= c, and c <= b+1, this means that c can be either equal to b or equal to b+1.

So, for three lengths 2^a, 2^b, 2^c with a <= b <= c:

- If c = b, then 2^a + 2^b > 2^c becomes 2^a + 2^b > 2^b, which simplifies to 2^a > 0, which is always true since a >= 0.

- If c = b+1, then 2^a + 2^b > 2^{b+1}, which simplifies to 2^a > 2^{b+1} - 2^b = 2^b (since 2^{b+1} - 2^b = 2^b).

So, 2^a > 2^b, but since a <= b, this is only possible if a = b.

Wait, if a <= b and 2^a > 2^b, that would require a > b, which contradicts a <= b. So, in this case, it's only possible if a = b.

Therefore, for c = b+1, the condition 2^a + 2^b > 2^{b+1} holds only if a = b.

So, summarizing:

- If c = b, then any a <= b works.

- If c = b+1, then only a = b works.

- If c >= b+2, then no triangles can be formed.

So, now I need to count the number of triplets (a, b, c) where a <= b <= c, and either c = b or (c = b+1 and a = b).

But since the sticks are indistinguishable except for their lengths, I need to consider the frequency of each length.

Let me denote freq[k] as the number of sticks with length 2^k.

Given that, I can iterate over all possible c values, and for each c, determine the possible a and b that can form a triangle with c.

Given the conditions above, for each c, I need to consider:

- All a and b such that a <= b <= c, and either c = b or (c = b+1 and a = b).

Wait, but it's more efficient to group by the exponents.

Let me sort the exponents first.

Wait, actually, since the lengths are powers of 2, and exponents are given, I can sort the exponents and then work with them.

Let me think differently.

Suppose I sort the exponents in non-decreasing order.

So, I have a sorted list of exponents: a1 <= a2 <= ... <= an.

Now, for each triplet (i,j,k) with i < j < k, I need to check if 2^{a_i} + 2^{a_j} > 2^{a_k}.

From earlier, this holds only if a_k <= a_j + 1.

Wait, but a_j <= a_k, so a_j <= a_k <= a_j + 1.

So, a_k can be either a_j or a_j + 1.

So, for each k from 3 to n, I need to choose i and j such that i < j < k, and a_k <= a_j + 1.

Moreover, if a_k = a_j + 1, then a_i must be equal to a_j.

If a_k = a_j, then a_i can be anything less than or equal to a_j.

So, perhaps I can iterate over all possible c (or a_k), and for each c, find the number of pairs (a,b) where a <= b <= c, and either c = b or (c = b+1 and a = b).

But to make it efficient, I need a better way, considering the constraints are up to 3*10^5 per test case, and t up to 10^4, but with the sum of n over all test cases being up to 3*10^5.

So, I need an O(n log n) solution per test case.

Let me consider frequency counts.

Let freq[k] be the number of sticks with length 2^k.

I need to consider triplets (x,y,z) where x <= y <= z, and either z = y or (z = y + 1 and x = y).

First, count the number of triplets where z = y.

In this case, x can be any value <= y.

So, for each y, the number of such triplets is freq[y] choose 3, since z = y and x can be from 0 to y.

Wait, no. Since x <= y, and z = y, the number of triplets is freq[y] choose 3.

But actually, since z = y, and x <= y, it's freq[y] choose 3.

Wait, but freq[y] choose 3 counts the number of ways to choose three sticks with length 2^y.

But in the problem, we need to choose three sticks with possibly different lengths, but in this case, all three have the same length.

So, in this case, since all three lengths are equal, they can form a triangle only if 2*x > x, which is always true as long as x > 0.

Wait, but in our earlier analysis, if z = y, then any a <= b <= c = y works.

So, it's not just choosing three sticks of length y, but choosing any three sticks where the lengths are <= y.

Wait, no.

Wait, let's clarify.

If z = y, then a <= b <= y, and c = y.

So, the condition is 2^a + 2^b > 2^y.

But since b <= y, and a <= b, 2^a + 2^b <= 2^b + 2^b = 2^{b+1} <= 2^{y+1}.

But since c = y, we have 2^{y+1} > 2^y, so the condition holds only if y+1 > y, which is always true.

Wait, no.

Wait, 2^a + 2^b > 2^y.

Given that b <= y, and a <= b, 2^a + 2^b <= 2^b + 2^b = 2^{b+1}.

So, for 2^{b+1} > 2^y, which holds if b+1 > y, i.e., b >= y.

But b <= y, so b = y.

Therefore, for z = y, the condition holds only if b = y.

So, in this case, x can be any value <= y, but since b = y, x can be from 0 to y.

Wait, no.

Wait, for z = y, and b = y, x can be from 0 to y.

But, in reality, since b = y, and x <= y, x can be from 0 to y.

So, the number of such triplets is freq[y] choose 1 (for z = y), times (freq[y] choose 2 for x and y both being y), plus freq[y] choose 3 for all three being y.

Wait, I'm getting confused.

Let me think differently.

Suppose I have freq[k] for each k from 0 to n.

I need to count the number of triplets (x,y,z) where x <= y <= z, and either z = y or (z = y + 1 and x = y).

Wait, in terms of frequencies.

First, count the number of triplets where z = y.

In this case, x can be any value <= y.

So, for each y, the number of such triplets is freq[y] * (freq[y] choose 2), because z = y, and x can be any of the freq[y] sticks, but since x <= y, and z = y, it's freq[y] choose 3.

Wait, no.

Wait, to choose x, y, z where z = y, and x <= y.

Actually, since z = y, and y is fixed, x can be any stick with length <= y.

But since y is fixed to a specific k, x can be any stick with length <= y.

Wait, but y is fixed to k, so x can be from any length from 0 to k.

So, the number of ways to choose x is the sum of freq[0] to freq[k].

But z and y are both fixed to k.

So, the number of such triplets is (sum_{i=0}^k freq[i]) * freq[k] * (freq[k] - 1) / 2.

Wait, but this overcounts because z and y are both k, and x is <= k.

But actually, since z and y are both k, and x is <= k, the number of such triplets is (sum_{i=0}^k freq[i]) * (freq[k] choose 2).

But wait, no.

Wait, to choose x <= y = z = k, it's equivalent to choosing x from freq[0] to freq[k], and y and z from freq[k], with y and z being the same.

So, the number of such triplets is (sum_{i=0}^k freq[i]) * (freq[k] choose 2).

But actually, since y and z are both k, and x is <= k, it's (sum_{i=0}^k freq[i]) * (freq[k] choose 2).

Wait, but (freq[k] choose 2) is for choosing y and z, and sum_{i=0}^k freq[i] is for choosing x.

But this seems correct.

Similarly, for the case where z = y + 1 and x = y.

In this case, z = y + 1, and x = y.

So, x and y are both y, and z is y + 1.

So, the number of such triplets is freq[y] * (freq[y] - 1) / 2 * freq[y + 1].

Because we need to choose two sticks with length y (for x and y), and one stick with length y + 1 (for z).

So, total number of such triplets is (freq[y] choose 2) * freq[y + 1].

Therefore, the total number of valid triplets is the sum over all y of (sum_{i=0}^y freq[i]) * (freq[y] choose 2) + (freq[y] choose 2) * freq[y + 1].

Wait, but in the first part, (sum_{i=0}^y freq[i]) * (freq[y] choose 2) counts the triplets where z = y, and x <= y.

But actually, since z = y and y = z, and x <= y, it's equivalent to choosing x from freq[0] to freq[y], and y and z from freq[y].

But perhaps I'm overcomplicating it.

An alternative approach is to sort the exponents in non-decreasing order and then iterate through all possible c values, and for each c, find the number of pairs (a,b) where a <= b <= c and either c = b or (c = b + 1 and a = b).

But this seems inefficient for the given constraints.

Wait, perhaps I can precompute prefix sums of freq.

Let me define prefix[k] = sum_{i=0}^k freq[i], the total number of sticks with exponents <= k.

Then, for each y from 0 to n, the number of triplets where z = y is prefix[y] * (freq[y] choose 2).

Additionally, for each y from 0 to n-1, the number of triplets where z = y + 1 and x = y is (freq[y] choose 2) * freq[y + 1].

Wait, but in the first part, when z = y, it's actually (freq[y] choose 3) plus (freq[y] choose 2) * prefix[y].

Wait, perhaps I need to think differently.

Let me consider that for z = y, any x <= y can be chosen, and y and z are both y.

So, the number of such triplets is (prefix[y]) * (freq[y] choose 2).

But actually, since y and z are both y, and x can be from 0 to y, it's (prefix[y]) * (freq[y] choose 2).

Then, for z = y + 1 and x = y, it's (freq[y] choose 2) * freq[y + 1].

So, total number of valid triplets is the sum over y from 0 to n of (prefix[y]) * (freq[y] choose 2) plus the sum over y from 0 to n-1 of (freq[y] choose 2) * freq[y + 1].

Wait, but I need to make sure I'm not double-counting.

Wait, perhaps I should think in terms of combinations.

Let me consider that for any three sticks with exponents a <= b <= c:

- If c = b, then any a <= b works.

- If c = b + 1, then only a = b works.

So, the total number of valid triplets is:

- The number of triplets where c = b, which is sum over y of (freq[y] choose 3).

- Plus the number of triplets where c = b + 1 and a = b, which is sum over y of (freq[y] choose 2) * freq[y + 1].

Wait, that seems more accurate.

So, total number of valid triplets is:

sum_{y=0}^n C(freq[y], 3) + sum_{y=0}^{n-1} C(freq[y], 2) * freq[y + 1]

Where C(n, k) is the combination of n choose k.

This seems efficient because I can precompute freq[y] and prefix[y], and then compute these sums.

Given that n can be up to 3*10^5 and t up to 10^4, but with the sum of n over all test cases being up to 3*10^5, I need an O(n) per test case solution.

Now, looking at the given program, let's see if it implements this logic correctly.

In the program:

- It reads all input at once and splits it into data.

- Then it processes each test case one by one.

- For each test case, it reads n and then reads n values of a_i.

- It initializes a frequency array v of size n+1, assuming a_i ranges from 0 to n.

- Then it populates v with the frequency of each a_i.

- It initializes cnt and ans to 0.

- Then it iterates from i=0 to n:

- If v[i] >= 2, ans += cnt * v[i] * (v[i] - 1) // 2

- If v[i] >= 3, ans += v[i] * (v[i] - 1) * (v[i] - 2) // 6

- cnt += v[i]

- Finally, it appends the answer for this test case to results.

Wait, this seems similar to what I derived.

Let me map this to my earlier reasoning.

In my reasoning, the total number of valid triplets is:

sum_{y=0}^n C(freq[y], 3) + sum_{y=0}^{n-1} C(freq[y], 2) * freq[y + 1]

In the program:

- It seems to accumulate cnt, which is the prefix sum of freq[i].

- For each i, if v[i] >= 2, ans += cnt * v[i] * (v[i] - 1) // 2

- If v[i] >= 3, ans += v[i] * (v[i] - 1) * (v[i] - 2) // 6

- Then cnt += v[i]

Wait, C(freq[y], 3) is freq[y] * (freq[y] - 1) * (freq[y] - 2) / 6, which matches the second part.

And C(freq[y], 2) * freq[y + 1] is freq[y] * (freq[y] - 1) / 2 * freq[y + 1], which matches the first part, but in the program, it's ans += cnt * v[i] * (v[i] - 1) // 2

Wait, but cnt is the prefix sum up to i, which is sum_{k=0}^i freq[k].

So, in the program, for each i, it adds cnt * C(freq[i], 2), which is sum_{k=0}^i freq[k] * C(freq[i], 2).

But according to my earlier reasoning, for z = y, the number of triplets is C(freq[y], 3) + sum_{k=0}^y freq[k] * C(freq[y], 2)

Wait, but in the program, it's adding cnt * C(freq[i], 2), and then if freq[i] >= 3, it adds C(freq[i], 3).

So, it's ans += cnt * C(freq[i], 2) + C(freq[i], 3)

But according to my earlier reasoning, it should be sum_{y} [prefix[y] * C(freq[y], 2)] + sum_{y} C(freq[y], 3)

Wait, that seems exactly what the program is doing.

Because cnt is prefix[i], and for each i, it adds prefix[i] * C(freq[i], 2) + C(freq[i], 3)

But according to my earlier reasoning, the total number of valid triplets is sum_{y} C(freq[y], 3) + sum_{y} C(freq[y], 2) * freq[y + 1]

So, there's a discrepancy here.

Wait, perhaps I need to reconcile these two expressions.

Is sum_{y} prefix[y] * C(freq[y], 2) + C(freq[y], 3) equal to sum_{y} C(freq[y], 3) + sum_{y} C(freq[y], 2) * freq[y + 1]?

Wait, probably not directly. So maybe my earlier reasoning was incomplete.

Let me think differently.

Perhaps the program is using a different approach to count the valid triplets.

An alternative way to count the triplets is to iterate through all possible c values, and for each c, count the number of pairs (a,b) where a <= b <= c and the triangle inequality holds.

Given that, perhaps the program is accumulating the prefix sum to count the number of possible a and b for each c.

Wait, but I need to verify if this approach correctly counts the number of valid triplets.

Let me consider a simple example.

Take the first test case from the example:

n = 7

a = [1,1,1,1,1,1,1]

So, freq[1] = 7

According to the program:

- cnt starts at 0

- For i=1, v[1]=7

- Since v[1]>=2, ans += cnt * 7 * 6 / 2 = 0 * 21 = 0

- Since v[1]>=3, ans += 7 * 6 * 5 / 6 = 35

- cnt += 7

- So, ans = 35

Which matches the first test case's output.

Another test case:

n=4

a=[3,2,1,3]

So, freq[1]=1, freq[2]=1, freq[3]=2

Iterate from i=1 to 3:

i=1:

v[1]=1

Nothing added to ans

cnt=1

i=2:

v[2]=1

cnt=2

ans += 2 * 1 * 0 / 2 = 0

No addition

i=3:

v[3]=2

cnt=3

ans += 3 * 2 * 1 / 2 = 3

ans += 2 * 1 * 0 / 6 = 0

So, ans=3

But according to the example, the second test case should output 2.

Wait, that's inconsistent.

Wait, perhaps I misread the freq array.

Wait, n=4

a=[3,2,1,3]

So, freq[0]=0, freq[1]=1, freq[2]=1, freq[3]=2

So, iterating from i=0 to 3:

i=0: v[0]=0, nothing

cnt=0

i=1: v[1]=1

cnt=0

ans += 0 * 1 * 0 / 2 = 0

cnt +=1 -> cnt=1

i=2: v[2]=1

cnt=1

ans +=1 *1*0 /2 =0

cnt +=1 -> cnt=