Alright, I have this problem to solve. Let's read it carefully.

So, there are n possible outcomes in a game, and for each outcome, there's a multiplier k_i. I need to bet some integer amount x_i on each outcome. The condition is that no matter which outcome wins, the total coins I get back should be more than the total coins I bet.

More formally, if I bet x_1, x_2, ..., x_n on outcomes 1 to n, the total bet is S = x_1 + x_2 + ... + x_n. If outcome i wins, I get back k_i * x_i coins, and this should be greater than S for every i.

So, for each i, k_i * x_i > S.

But S is the sum of all x_j for j from 1 to n.

So, for each i, k_i * x_i > sum_{j=1 to n} x_j.

This seems tricky. I need to find such x_i's that satisfy this condition for every i.

First, I should think about whether such x_i's always exist. Maybe not, depending on the k_i's.

Let me consider a simple case. Suppose n=1. Then, k_1 * x_1 > x_1. Since k_1 >= 2, this is always true for any x_1 >=1. So, it's straightforward.

Now, for n=2, let's say k_1=2, k_2=2.

I need 2*x_1 > x_1 + x_2, which simplifies to x_1 > x_2.

And 2*x_2 > x_1 + x_1, which simplifies to x_2 > x_1.

But these two inequalities can't be true at the same time: x_1 > x_2 and x_2 > x_1. So, no solution in this case.

Wait, but the problem says that exactly one outcome will win, and I need the condition to hold for whichever outcome wins.

So, in this case, with n=2 and both k_i=2, it's impossible to have x_1 > x_2 and x_2 > x_1 simultaneously. So, in this case, the answer should be -1.

So, sometimes there is no solution.

Now, I need a general method to find such x_i's if they exist.

Let me think about the conditions again.

For each i, k_i * x_i > sum_{j=1 to n} x_j.

Let me denote S = sum_{j=1 to n} x_j.

So, for each i, k_i * x_i > S.

But S = x_i + sum_{j≠i} x_j.

So, k_i * x_i > x_i + sum_{j≠i} x_j.

Which implies (k_i - 1) * x_i > sum_{j≠i} x_j.

But sum_{j≠i} x_j = S - x_i.

So, (k_i - 1) * x_i > S - x_i.

Let's rearrange:

(k_i - 1) * x_i + x_i > S

k_i * x_i > S.

Wait, same as before.

This seems tricky.

Maybe I can use the concept of least common multiple or something.

Let me look at the example in the problem.

In the first test case:

n=3, k=[3,2,7]

One possible solution is x=[27,41,12]

Sum S=27+41+12=80

Check for each i:

3*27=81 >80

2*41=82>80

7*12=84>80

So, it works.

How to find such x_i's?

Another test case:

n=2, k=[3,3]

Solution: x=[1,1]

Sum S=2

Check:

3*1=3>2

3*1=3>2

So, it works.

But earlier I thought that if k_i=2 for all i, it's impossible, but in this case, k_i=3, which is greater.

Wait, in my earlier thought experiment, I set k_i=2, and saw that it's impossible.

So, maybe when k_i >2, it's possible.

But in the problem constraints, k_i >=2.

So, sometimes possible, sometimes not.

I need a general method.

Let me think about setting x_i proportional to some function of k_i.

Suppose I set x_i = L / k_i, where L is the LCM of all k_i.

Wait, LCM?

Let's see.

Compute L = LCM of all k_i.

Then, set x_i = L / k_i.

Then, S = sum_{i=1 to n} (L / k_i)

Now, for each i, k_i * x_i = k_i * (L / k_i) = L

So, I need L > S for all i.

But S = sum_{i=1 to n} (L / k_i)

So, for all i, L > sum_{i=1 to n} (L / k_i)

Which simplifies to 1 > sum_{i=1 to n} (1 / k_i)

So, the condition for the solution to exist is that sum_{i=1 to n} (1 / k_i) <1.

Is that the case?

Let me check with the example.

First test case: n=3, k=[3,2,7]

Sum of 1/k_i = 1/3 + 1/2 + 1/7 = (14 + 21 + 6)/42 = 41/42 <1.

Second test case: n=2, k=[3,3]

Sum of 1/k_i = 1/3 + 1/3 = 2/3 <1.

Third test case: n=5, k=[5,5,5,5,5]

Sum of 1/k_i = 5*(1/5)=1.

Which is equal to 1, not less than 1, so no solution, which matches the sample output of -1.

Fourth test case: n=6, k=[7,9,3,17,9,13]

Sum of 1/k_i = 1/7 + 1/9 + 1/3 + 1/17 + 1/9 + 1/13.

Let's calculate:

1/7 ≈0.1429

1/9 ≈0.1111

1/3 ≈0.3333

1/17≈0.0588

1/9≈0.1111

1/13≈0.0769

Sum ≈0.1429+0.1111+0.3333+0.0588+0.1111+0.0769≈0.8341<1.

So, solution exists, which matches the sample output.

Fifth test case: n=3, k=[6,3,2]

Sum of 1/k_i=1/6+1/3+1/2=1/6+2/6+3/6=6/6=1.

So, no solution, which matches the sample output of -1.

Sixth test case: n=5, k=[9,4,6,8,3]

Sum of 1/k_i=1/9+1/4+1/6+1/8+1/3.

Let's calculate:

1/9≈0.1111

1/4=0.25

1/6≈0.1667

1/8=0.125

1/3≈0.3333

Sum≈0.1111+0.25+0.1667+0.125+0.3333≈0.9861<1.

So, solution exists, which matches the sample output.

Therefore, the condition for the solution to exist is that sum_{i=1 to n} (1 / k_i) <1.

If this sum is less than 1, then a solution exists; otherwise, it doesn't.

Now, assuming this condition holds, how to find such x_i's?

From earlier, if I set x_i = L / k_i, where L is the LCM of all k_i, then S = sum_{i=1 to n} (L / k_i), and for each i, k_i * x_i = L, which needs to be greater than S.

But since sum_{i=1 to n} (1 / k_i) <1, then L > S, because L = L * 1 > L * sum_{i=1 to n} (1 / k_i) = S.

So, this seems correct.

But in the first sample input, n=3, k=[3,2,7], LCM(L) of 3,2,7 is 42.

Then, x_i = 42 / k_i => x1=14, x2=21, x3=6.

Sum S=14+21+6=41.

Then, for each i:

3*14=42>41

2*21=42>41

7*6=42>41

So, this works.

But in the sample output, they have x=[27,41,12], which also works, but my method gives x=[14,21,6].

So, multiple solutions exist.

Now, in the second sample input, n=2, k=[3,3], LCM=3, x=[1,1], sum S=2, 3*1=3>2, which works.

In the fourth sample input, n=6, k=[7,9,3,17,9,13], LCM=LCM(7,9,3,17,9,13)=LCM(7,9,17,13), since 3 divides 9.

Compute LCM:

7 is prime, 9=3^2, 17 is prime, 13 is prime.

So, LCM=7*9*17*13.

Calculate 7*9=63, 63*17=1071, 1071*13=13923.

Then, x_i = L / k_i.

So, x1=13923/7=1989

x2=13923/9=1547

x3=13923/3=4641

x4=13923/17=819

x5=13923/9=1547

x6=13923/13=1071

Sum S=1989+1547+4641+819+1547+1071=11614

Check for each i:

7*1989=13923>11614

9*1547=13923>11614

3*4641=13923>11614

17*819=13923>11614

9*1547=13923>11614

13*1071=13923>11614

So, it works.

But in the sample output, they have x=[1989,1547,4641,819,1547,1071], which matches this.

So, this method works.

Now, in the fifth sample input, n=3, k=[6,3,2], sum of 1/k_i=1/6+1/3+1/2=1, which is not less than 1, so no solution, which matches the sample output of -1.

Similarly, in the third sample input, n=5, k=[5,5,5,5,5], sum of 1/k_i=1, so no solution.

So, this seems correct.

Now, in the case where sum of 1/k_i <1, a solution exists, and setting x_i = L / k_i, where L is the LCM of all k_i, works.

But in the first sample input, x_i = 42 / k_i gives x=[14,21,6], sum S=41, which works.

But in the sample output, they have x=[27,41,12], which also works.

So, multiple solutions exist.

I need to find any solution, or output -1 if no solution exists.

So, in code, for each test case, compute sum of 1/k_i, and if it's less than 1, compute LCM of k_i, then set x_i = L / k_i for each i, and output them.

Otherwise, output -1.

Now, in code, I need to handle multiple test cases, read n, then k_i for each test case.

Compute sum of 1/k_i, check if less than 1, if not, output -1.

If yes, compute LCM of k_i, then x_i = L / k_i for each i, output them.

Need to handle multiple test cases.

Also, need to compute LCM of k_i efficiently.

Given that n <=50 and k_i <=20, and sum of n over all test cases <=2e5, so need an efficient way to compute LCM.

Since k_i <=20, and n<=50, LCM can be computed efficiently.

In Python, math.gcd, and for LCM, lcm(a,b)=a*b / gcd(a,b), and extend to multiple numbers.

So, I can write a function to compute LCM of a list.

Also, need to handle floating point precision for sum of 1/k_i.

But since k_i are integers, and n is small, I can compute sum of 1/k_i as a fraction.

But in Python, it's fine to use floating point for this purpose, since k_i are small.

But to be safe, I can compute sum of 1/k_i as a fraction using fractions module.

But for simplicity, I can use floating point, and check if sum <1.

But need to be careful with floating point precision.

Alternatively, compute sum of 1/k_i as a fraction, and check if numerator < denominator.

But that might be overkill.

Given the constraints, floating point should be fine.

Now, look at the provided program.

It seems to implement this logic.

Read t, number of test cases.

For each test case:

Define a function lcm to compute LCM of a list.

Then read n, read k_i.

Compute L = LCM of k_i.

Compute sumo = sum of L / k_i for all i.

If sumo >= L, output -1.

Else, output x_i = L / k_i for all i.

This matches the logic I thought of.

But in the first sample input, with n=3, k=[3,2,7], L=42, sumo=14+21+6=41<42, so output x_i=[14,21,6], which works.

But in the sample output, it's [27,41,12], which also works, but my method gives [14,21,6].

So, multiple solutions exist.

The problem says "if there are multiple suitable solutions, output any of them".

So, [14,21,6] is also a valid solution, but the sample output shows [27,41,12].

So, my method gives a different valid solution, which is acceptable.

Now, check for correctness.

In the second sample input, n=2, k=[3,3], sum of 1/k_i=2/3<1, so solution exists.

L=3, x_i=[1,1], sum S=2, 3*1=3>2 for both, which works.

In the third sample input, n=5, k=[5,5,5,5,5], sum of 1/k_i=1, so output -1.

In the fourth sample input, n=6, k=[7,9,3,17,9,13], sum of 1/k_i<1, so output x_i as computed, which works.

In the fifth sample input, n=3, k=[6,3,2], sum of 1/k_i=1/6+1/3+1/2=1, so output -1.

In the sixth sample input, n=5, k=[9,4,6,8,3], sum of 1/k_i<1, so output x_i as computed, which works.

So, the provided program seems correct.

But wait, in the first sample input, the program outputs x_i=[14,21,6], but the sample output shows [27,41,12]. Is there an issue?

No, both are valid solutions. The problem allows any valid solution.

So, the program is correct.

Hence, Correctness: **True**

## Final Solution
To solve this problem, we need to determine how to distribute coins among various outcomes in a game such that, regardless of which outcome wins, the total coins received are strictly more than the total coins bet. This must hold for any possible winning outcome.

### Approach

1. **Condition Analysis**:
   - For each outcome \(i\), the condition is \(k_i \times x_i > S\), where \(S\) is the total sum of all bets.
   - This can be rephrased using the least common multiple (LCM) of the multipliers \(k_i\).

2. **Existence of Solution**:
   - Compute the sum of the reciprocals of \(k_i\). If this sum is less than 1, a solution exists.
   - If the sum of \(1 / k_i\) is greater than or equal to 1, output -1 as no solution exists.

3. **Calculating Bets**:
   - Compute the LCM of all \(k_i\).
   - Set each bet \(x_i\) to be \(L / k_i\), where \(L\) is the LCM.
   - Verify that for each \(i\), \(k_i \times x_i > S\), where \(S\) is the sum of all \(x_i\).

### Solution Code

```python
from math import gcd

def lcm(l):
    g = 1
    for i in l:
        g = g * i // gcd(g, i)
    return g

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index = 1
    for _ in range(t):
        n = int(data[index])
        index += 1
        k = list(map(int, data[index:index+n]))
        index += n
        # Check if sum of 1/k_i < 1
        sum_reciprocals = sum(1 / ki for ki in k)
        if sum_reciprocals >= 1:
            print(-1)
            continue
        # Compute LCM of k
        L = lcm(k)
        # Calculate x_i = L / k_i
        x = [L // ki for ki in k]
        # Calculate sum of x_i
        S = sum(x)
        # Verify the condition
        if all(ki * xi > S for ki, xi in zip(k, x)):
            print(' '.join(map(str, x)))
        else:
            print(-1)

if __name__ == "__main__":
    main()
```

### Explanation

1. **LCM Calculation**:
   - The `lcm` function calculates the least common multiple of a list of integers using the greatest common divisor (GCD).

2. **Main Function**:
   - Read the input values.
   - For each test case:
     - Read the number of outcomes \(n\) and the multipliers \(k_i\).
     - Calculate the sum of reciprocals of \(k_i\). If this sum is not less than 1, output -1.
     - Otherwise, compute the LCM of \(k_i\) and set each bet \(x_i\) to \(L / k_i\).
     - Verify that each \(k_i \times x_i > S\), where \(S\) is the total sum of bets. If the condition holds, print the bets; otherwise, print -1.

This approach ensures that the bets are distributed correctly to satisfy the problem's conditions, providing a robust and efficient solution.