Alright, I have this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform exactly k operations on it. In each operation, I can select any contiguous subarray (which could even be empty) and insert the sum of that subarray anywhere in the array. My goal is to maximize the sum of the array after performing exactly k operations, and I need to output this sum modulo 10^9 + 7.

First, I need to understand what exactly an operation does. When I select a subarray and insert its sum into the array, I'm essentially adding that sum to the array at any position I choose. The subarray can be empty, and the sum of an empty subarray is zero. So, I can insert zeros into the array if I want.

Now, I need to think about how these operations affect the total sum of the array. Let's consider that the original sum of the array is S. Each operation allows me to insert a sum of a subarray into the array, which effectively adds that sum to the total sum again because I'm inserting it into the array.

Wait, but actually, when I insert the sum of a subarray into the array, I'm adding that value to the array, so the total sum increases by that amount. But I need to be careful because the subarray sum might include negative numbers, which could decrease the total sum if I'm not careful.

Let me try to think differently. Suppose I have the array [a1, a2, ..., an], with sum S. If I select a subarray [ai, ai+1, ..., aj] with sum X and insert it into the array, the new array becomes [a1, ..., ai-1, X, ai, ..., aj, ..., an], with a new sum S + X. So, each operation allows me to add X to the sum, where X is the sum of any subarray (including the empty subarray, which is 0).

My goal is to maximize the sum after exactly k operations. So, I need to choose k subarrays, compute their sums, and add those sums to the array, aiming to maximize the total sum.

This sounds a bit like dynamic programming, where I make choices at each step to maximize some cumulative value. But maybe there's a smarter way to approach this.

Let me consider the maximum possible sum I can achieve. If I always choose the subarray with the maximum sum and insert it, I can keep adding that maximum sum over k operations. But is that always the best strategy?

Wait, but each time I insert a sum, I'm modifying the array, which could potentially change the location of the maximum subarray sum. However, since I'm inserting the sum anywhere in the array, and the sum is just a single value, perhaps the array's structure doesn't change in a way that affects the maximum subarray sum.

Let me think about this more carefully. Suppose I have the original array a with sum S, and the maximum subarray sum is M. If I insert M into the array, the new sum becomes S + M. Now, the new maximum subarray could be either the original M or the newly inserted M, depending on the array's values.

Wait, but since I'm inserting M as a single element, and it's the sum of some subarray, the maximum subarray sum in the new array would be max(M, M + some adjacent elements). But if M is the sum of a subarray that includes positive elements, inserting M somewhere might not necessarily increase the maximum subarray sum, especially if M is already the largest possible sum.

This seems a bit messy. Maybe there's a better way to model this.

Let me consider the effect of k operations. Each operation allows me to add the sum of any subarray to the array. So, in terms of increasing the total sum, I want to add the largest possible subarray sum each time.

If I can identify the maximum subarray sum in the original array, say it's M, then in each operation, I can choose to add M to the array, thus increasing the total sum by M each time.

Wait, but after adding M to the array, the new array has an additional element with value M, so the total sum becomes S + M. Then, in the next operation, I can again add M, making the sum S + 2M, and so on, up to S + kM.

But is M always the maximum subarray sum I can choose? Or is there a way to choose different subarrays in each operation to get a higher total sum?

Let me consider an example. Suppose I have the array [1, 2, 3], so S = 6, and k = 2. The maximum subarray sum is 6 (the entire array). If I add 6 to the array, the new array is [1, 2, 3, 6], with sum 12. Then, in the second operation, I can add 12 (the sum of the new array), making the final sum 24.

Wait, but according to my earlier logic, I would add M = 6 in each operation, resulting in S + 2M = 6 + 12 = 18, which is less than 24. So, there's something wrong with my initial approach.

Let me think again. Maybe in each operation, I can choose to add the current sum of the array, which would exponentially increase the sum.

Wait, but the problem says I have to select a contiguous subarray and insert its sum into the array. The subarray has to be contiguous.

In the above example, if I choose the entire array [1,2,3], whose sum is 6, and insert it into the array, the new array becomes [1,2,3,6], with sum 12. Then, in the second operation, I can choose the subarray [6,6], with sum 12, and insert it into the array, making the array [1,2,3,6,12], with sum 24.

Alternatively, I could choose different subarrays in each operation to maximize the sum.

This seems complicated. Maybe I need to find a way to maximize the sum by choosing the best subarrays in each operation.

Let me consider another approach. Suppose I denote the sum of the array after i operations as S_i. Initially, S_0 = S. After the first operation, S_1 = S + M, where M is the maximum subarray sum. After the second operation, S_2 = S_1 + M', where M' is the maximum subarray sum in the new array.

But this seems recursive, and it might be time-consuming to compute this way, especially since n and k can be up to 2e5.

I need a smarter way to compute the maximum possible sum after k operations.

Let me consider that in each operation, I can add the maximum subarray sum of the current array to the array. Now, the question is, how does the maximum subarray sum change after each operation.

Suppose that after adding the sum S_i to the array, the new maximum subarray sum is max(M, S_i), because I can choose the subarray consisting only of S_i, which is S_i, or some larger sum including other elements.

Wait, but S_i is the sum of the entire array up to that point, so it's possible that choosing the entire array as the subarray would give me S_i, which is the sum of all elements up to that point.

This seems confusing. Maybe I need to find a formula or a pattern for the sum after k operations.

Let me consider a simple case where all elements in the array are non-negative. In this case, the maximum subarray sum is the sum of the entire array, S. If I insert S into the array in each operation, then the sum after k operations would be S + k*S = S*(k+1). But I need to take modulo 10^9+7.

Wait, but in the example where a = [1,2,3], k=2, S=6, according to this, S*(k+1)=6*3=18, but earlier I saw that it's possible to get 24. So, this approach is insufficient.

Maybe there's a better way to model the growth of the sum.

Let me consider that each time I insert the current sum S_i into the array, the new sum S_{i+1} = S_i + S_i = 2*S_i. So, it's doubling each time.

Wait, in the example, starting with S=6, after first operation, S=6+6=12, then after second operation, S=12+12=24, which matches what I did earlier.

So, in this case, the sum doubles each time I insert the current sum into the array.

But is this always possible? Only if I can choose the entire array as the subarray to insert, which gives me the sum of the entire array.

Wait, but in the first operation, I can choose the entire array and insert its sum, then in the second operation, I can choose the new subarray that includes the previously inserted sum, and so on.

So, it seems that by always choosing the entire array as the subarray to insert, I can double the sum in each operation.

Wait, not exactly double, because I'm adding the sum to the array, so the new sum is S + S = 2S, but the array now has an additional element equal to S, so the new sum is 2S, but the array has n+1 elements.

Wait, no, the sum of the array after inserting S is S + S = 2S.

Wait, but in the second operation, if I choose the entire array again, which now has sum 2S, and insert 2S into the array, the new sum becomes 2S + 2S = 4S.

Then, in the third operation, I can insert 4S into the array, making the sum 4S + 4S = 8S, and so on.

So, it seems that by always choosing the entire array in each operation, the sum doubles in each operation.

Wait, but in the first operation, starting from S, I insert S, making the new sum 2S.

In the second operation, I insert 2S, making the sum 4S.

In the third operation, I insert 4S, making the sum 8S, and so on.

So, after k operations, the sum would be S * 2^k.

But in the first test case, n=2, k=2, a=[-4,-7], sum S=-11.

The maximum subarray sum is max(subarray sums), which in this case is 0, since all elements are negative.

Wait, no. The maximum subarray sum for [-4,-7] is max(-4, -7, -4-7) = -4.

Wait, no, actually, the maximum subarray sum is the largest sum of any contiguous subarray, which in this case is -4.

But according to the note, in the first test case, they took empty subarrays and inserted 0 twice, resulting in a sum of -11, which modulo 1e9+7 is 999,999,996.

So, in this case, choosing to insert the sum of the empty subarray (which is 0) is better than inserting the sum of the entire array or any other subarray.

This suggests that when all subarray sums are negative, it's better to choose the empty subarray with sum 0 to insert.

So, perhaps the strategy is: if the maximum subarray sum is positive, insert it to maximize the sum; if it's negative, insert 0 instead.

Wait, but in the first example, the maximum subarray sum is -4, which is negative, so inserting 0 is better.

In the second example, a=[2,2,8], sum=12, maximum subarray sum is 12.

So, in this case, inserting 12 each time doubles the sum each operation.

After first operation: 12 + 12 = 24

After second operation: 24 + 24 = 48

After third operation: 48 + 48 = 96

Which matches the sample output.

So, the strategy seems to be:

- Find the maximum subarray sum M.

- If M > 0, then in each operation, insert M, which effectively adds M to the sum each time.

- If M <= 0, then inserting 0 in each operation keeps the sum unchanged.

Wait, but in the first example, M=-4, which is less than 0, so inserting 0 is better.

In the second example, M=12, which is greater than 0, so inserting 12 each time.

But wait, in the second example, inserting 12 each time results in the sum being S * 2^k.

Wait, but S=12, k=3, so S * 2^3 = 96, which matches the sample.

In the first example, S=-11, M=-4, but inserting 0 each time keeps the sum as -11.

So, the formula would be:

- If M > 0: sum = S + M * (2^k - 1)

Wait, wait, in the second example, S=12, M=12, sum after k=3 operations is 12 * 2^3 = 96.

But according to S + M * (2^k - 1) = 12 + 12*(8-1) = 12 + 84 = 96, which matches.

In the first example, S=-11, M=0 (since inserting 0 is better), sum after k=2 operations is -11 + 0*(4-1) = -11.

But according to the sample, they insert 0 twice, so sum remains -11, which is correct.

Wait, but in the first example, M is -4, but they choose to insert 0 instead.

So, perhaps the formula should be:

sum = S + M' * (2^k - 1), where M' is the maximum between M and 0.

Yes, that makes sense.

So, in general:

- Compute M = maximum subarray sum.

- If M > 0, then sum = S + M * (2^k - 1)

- Else, sum = S + 0 * (2^k - 1) = S

But in the second example, sum = 12 + 12*(8-1) = 12 + 84 = 96

In the first example, sum = -11 + 0*(4-1) = -11, which modulo 1e9+7 is 999,999,996.

This seems to work.

Wait, but in the fourth test case, n=5, k=1, a=[4,-2,8,-12,9], sum=7, M=8 (subarray [8]), so sum = 7 + 8*(2^1 -1) = 7 + 8*1 = 15, but according to the sample, it's 17.

Wait, perhaps I miscalculated M.

Let's compute M for [4,-2,8,-12,9]:

Possible subarrays:

[4]: 4

[4,-2]: 2

[4,-2,8]: 10

[4,-2,8,-12]: -4

[4,-2,8,-12,9]: 7

[-2]: -2

[-2,8]: 6

[-2,8,-12]: -6

[-2,8,-12,9]: 3

[8]: 8

[8,-12]: -4

[8,-12,9]: 5

[-12]: -12

[-12,9]: -3

[9]: 9

So, the maximum subarray sum M is 10 (from [4,-2,8]).

Therefore, sum = 7 + 10*(2^1 -1) = 7 + 10*1 = 17, which matches the sample.

Okay, so M is 10, not 8.

So, I need to correctly compute the maximum subarray sum.

Therefore, the general formula seems to be:

sum = S + M * (2^k -1), where M is the maximum subarray sum.

If M <= 0, then it's better to set M' = 0, so sum = S.

Otherwise, sum = S + M * (2^k -1)

And finally, take sum modulo 1e9+7.

So, in code, I need to:

- For each test case:

- Read n and k.

- Read the array a.

- Compute S = sum(a).

- Compute M = maximum subarray sum.

- If M > 0:

- sum = S + M * (2^k -1)

- Else:

- sum = S

- Output sum modulo 1e9+7.

Now, computing 2^k modulo (1e9+7) can be done efficiently using fast exponentiation.

Also, computing the maximum subarray sum can be done efficiently in O(n) time using Kadane's algorithm.

Given that n and k can be up to 2e5, and t up to 1e4, but with the sum of n and k across all test cases up to 2e5, it should be efficient enough.

Wait, the problem says "the sum of the values of n and k for all test cases does not exceed 2e5", so total n across all test cases is up to 2e5, and total k across all test cases is up to 2e5.

So, overall time complexity should be O(2e5), which is acceptable.

Now, let's look at the provided program and see if it implements this logic correctly.

Looking at the code:

from math import *

t = int(input())

for _ in range(t):

(n, k) = map(int, input().split())

a = list(map(int, input().split()))

max_segment = func_2(a)

if max_segment[0] == -1:

max_segment[0] = 0

answer = max_segment[0] * 2 ** k + sum(a) - max_segment[0]

print(func_1(answer))

def func_1(number):

return number % 1000000007

def func_2(arr):

new_segment = []

max_segment = [0, 0]

segments_variants = []

max_sum = -1

for i in range(len(arr)):

if new_segment:

if arr[i] < 0:

if max_segment[0] > new_segment[0]:

segments_variants.append(max_segment + [i - 1])

else:

segments_variants.append(new_segment + [i - 1])

max_segment = new_segment

new_segment = []

max_segment[0] += arr[i]

else:

max_segment[0] += arr[i]

new_segment[0] += arr[i]

else:

if arr[i] >= 0:

new_segment = [arr[i], i]

max_segment[0] += arr[i]

segments_variants.append(max_segment + [len(arr) - 1])

segments_variants.append(new_segment + [len(arr) - 1])

total_max_segment = [-1]

for segment in segments_variants:

if total_max_segment[0] < segment[0] and len(segment) != 1:

total_max_segment = segment

return total_max_segment

def func_3(number, quantity):

answer = 0

So, the main logic is in func_2, which is supposed to compute the maximum subarray sum.

Let me see if func_2 correctly implements Kadane's algorithm or some variant to find the maximum subarray sum.

Looking at func_2:

It initializes new_segment and max_segment as lists with initial sum 0.

It iterates through the array, and if new_segment is not empty:

- If arr[i] < 0:

- Compares max_segment[0] and new_segment[0], appends the larger one to segments_variants.

- Sets new_segment to empty and updates max_segment[0] += arr[i]

- Else (arr[i] >= 0):

- Adds arr[i] to both max_segment[0] and new_segment[0]

Else (new_segment is empty):

- If arr[i] >= 0:

- Sets new_segment = [arr[i], i]

- Adds arr[i] to max_segment[0]

After the loop, appends max_segment and new_segment to segments_variants.

Then, iterates through segments_variants to find the one with the maximum sum.

This seems overly complicated and might not correctly handle all cases.

For example, in the first test case, a = [-4, -7], the maximum subarray sum should be 0 (from the empty subarray), but according to the code, max_segment[0] would be -4, and since it's -1, it's set to 0.

Then, answer = 0 * 2**k + sum(a) - 0 = sum(a) = -11.

But in the code, it's printed as func_1(answer), which is -11 % (1e9+7) = 999,999,996, which matches the sample.

In the second test case, a = [2,2,8], sum=12, max_segment[0]=10 (from [2,2,8]), but according to the earlier analysis, it should be 12.

Wait, no, in the second test case, the maximum subarray sum is 12, which is the sum of the entire array.

So, if func_2 correctly returns 12, then answer = 12 * 2**k + 12 - 12 = 12 * 8 + 0 = 96, which matches the sample.

Wait, but in the fourth test case, a=[4,-2,8,-12,9], sum=7, max_segment[0]=10 (from [4,-2,8]), which is correct, answer = 10 * 2**1 + 7 - 10 = 20 + 7 -10 = 17, which matches the sample.

So, perhaps func_2 is correctly computing the maximum subarray sum, despite its complexity.

But in the first test case, a=[-4,-7], max_segment[0]=-4, which is less than 0, so it's set to 0, and answer = 0*2**2 + (-11) - 0 = -11, which is correct.

So, perhaps func_2 is working correctly for these cases, even though it's not implemented in the standard way.

But to be sure, let's consider another test case.

Suppose a=[-1, -2, -3], sum=-6, maximum subarray sum is 0 (from empty subarray).

According to func_2, it would set max_segment[0]=-1, then set to 0, answer=0*2**k + (-6)-0 = -6, which is correct.

Another test case: a=[1, -2, 3], sum=2, maximum subarray sum is 3 (from [3]).

According to func_2, it should return 3, answer=3*2**k + 2 -3 = 3*2**k -1.

But according to the earlier formula, it should be S + M*(2**k -1) = 2 + 3*(2**k -1) = 2 + 3*2**k -3 = 3*2**k -1, which matches.

So, seems correct.

Another test case: a=[-2,1,-3,4,-1,2,1,-5,4], sum=6, maximum subarray sum is 6 (from [4,-1,2,1]).

According to func_2, it should return 6, answer=6*2**k +6 -6=6*2**k.

Wait, according to the formula, S + M*(2**k -1) =6 +6*(2**k -1)=6*2**k.

Yes, matches.

So, it seems that func_2 is correctly computing the maximum subarray sum, even though its implementation is not the standard Kadane's algorithm.

Therefore, the program seems to be correct.

Hence, Correctness: **True**

**Final Answer**

\[ \boxed{\text{see explanation}} \]