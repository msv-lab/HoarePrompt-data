Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n ships, each with some durability a_i, and they're arranged in a line from 1 to n. The Kraken attacks these ships k times, alternating between the first and the last ship. Each attack reduces the durability of the target ship by 1. If a ship's durability drops to 0, it sinks and is removed from the line. I need to figure out how many ships are sunk after k attacks.

First, I need to understand the process. The Kraken starts by attacking the first ship, then the last, then the first again, and so on. After each attack, if a ship's durability reaches zero, it's removed, which might change which ships are first and last.

This seems like a simulation problem, but simulating each attack one by one could be inefficient, especially since k can be up to 10^15 and n can be up to 2*10^5 per test case. So, a straightforward simulation would be too slow.

I need a smarter way to handle this. Let's think about how the attacks are distributed.

Since the Kraken alternates between the first and last ships, I can consider the attacks in pairs: one on the first and one on the last. Each pair of attacks would reduce the durability of both the first and last ships by 1, unless one of them has already been sunk.

But wait, if one of them has been sunk, then the next attack would target the new first or last ship.

This seems a bit tricky. Maybe I can model this as a queue or a deque, where I can efficiently remove ships from both ends.

Let me consider using a deque to represent the ships, with their durabilities. I'll keep track of the number of attacks remaining and the number of sunks.

I'll need to alternate between attacking the left and right ends of the deque.

But even with a deque, if I simulate each attack individually, it might still be too slow for large n and k.

Is there a way to batch the attacks?

Let's think about how many attacks can be performed before a ship is sunk.

Suppose I have ships with durabilities [a1, a2, a3, ..., an].

If a1 <= a_n, then attacking the first ship a1 times will sink it, and during these a1 attacks, the last ship will also be attacked a1 times.

So, after 2*a1 attacks (assuming a1 <= a_n), the first ship is sunk, and the last ship's durability is reduced by a1.

Similarly, if a_n < a1, then after 2*a_n attacks, the last ship is sunk, and the first ship's durability is reduced by a_n.

Wait, not necessarily, because attacks alternate. So, in 2*a1 attacks, the first ship is attacked a1 times and the last ship is attacked a1 times.

But if a1 <= a_n, then both ships are reduced by a1, and the first ship sinks, leaving the last ship with a_n - a1.

Then, the next attack would be on the new first ship, which is now the second ship, and so on.

Hmm.

Maybe I can iteratively handle batches of attacks where I consider sinking one ship at a time.

Let me try to formalize this.

Initialize left = 0, right = n-1, sunks = 0.

While left <= right and k > 0:

If left == right:

# Only one ship left

if k >= a[left]:

sunks += 1

break

else:

break

else:

# Two or more ships

if a[left] <= a[right]:

# Attack first ship until it sinks

attacks = a[left]

k -= attacks * 2  # Attacked first and last each 'attacks' times

if k < 0:

break

a[right] -= attacks

if a[right] == 0:

sunks += 1

right -= 1

sunks += 1

left += 1

else:

# a[right] < a[left]

# Attack last ship until it sinks

attacks = a[right]

k -= attacks * 2

a[left] -= attacks

if a[left] == 0:

sunks += 1

left += 1

sunks += 1

right -= 1

This seems similar to the code provided.

Wait, looking back at the code:

def func_1(n, k, a):

(l, r) = (0, n - 1)

sunks = 0

while l <= r:

if k == 0:

break

if l == r:

if k >= a[r]:

sunks += 1

break

else:

break

if a[l] <= a[r]:

if k >= a[l] * 2:

k -= a[l] * 2

a[r] -= a[l]

if a[r] == 0:

sunks += 1

r -= 1

sunks += 1

l += 1

continue

elif a[l] * 2 - 1 == k:

sunks += 1

break

else:

break

if k == 0:

break

if a[r] < a[l]:

if k >= a[r] * 2:

k -= a[r] * 2

a[l] -= a[r]

if a[l] == 0:

sunks += 1

l += 1

sunks += 1

r -= 1

continue

elif a[r] * 2 - 1 == k:

sunks += 1

break

else:

break

return sunks

This seems to follow the logic I just outlined.

But I need to verify if this logic is correct.

Let's consider the example given:

n=4, k=5, a=[1,2,4,3]

Step 1: Attack first ship (1), durability becomes 0, sunk. sunks=1, a=[2,4,3], l=1, r=2

Step 2: Attack last ship (3), durability becomes 2, a=[2,4,2]

Step 3: Attack first ship (2), durability becomes 1, a=[1,4,2]

Step 4: Attack last ship (2), durability becomes 1, a=[1,4,1]

Step 5: Attack first ship (1), durability becomes 0, sunk. sunks=2, a=[4,1], l=1, r=1

Now, l=1 and r=1, k=0, so stop.

Total sunks=2, which matches the example.

Another test case:

n=4, k=6, a=[1,2,4,3]

Following the same steps as above, after 5 attacks, a=[4,1], l=1, r=1, k=1.

Then, attack the first ship (4), durability becomes 3, a=[3], sunks=2.

Wait, but according to the example output, it should be 3.

Wait, maybe I'm missing something.

Wait, in the first example, after 5 attacks, sunks=2.

In the second example, with k=6, after 5 attacks, a=[4,1], l=1, r=1, k=1.

Then, attack the first ship (4), durability becomes 3, a=[3], l=1, r=1, k=0.

No ship sinks, so sunks=2.

But the example output is 3, which suggests that another ship is sunk.

Wait, perhaps I miscalculated.

Wait, let's follow the steps carefully.

n=4, k=6, a=[1,2,4,3]

Step 1: Attack first ship (1), durability 0, sunk. sunks=1, a=[2,4,3], l=1, r=2

Step 2: Attack last ship (3), durability 2, a=[2,4,2]

Step 3: Attack first ship (2), durability 1, a=[1,4,2]

Step 4: Attack last ship (2), durability 1, a=[1,4,1]

Step 5: Attack first ship (1), durability 0, sunk. sunks=2, a=[4,1], l=1, r=1

Step 6: Attack the first ship (4), durability 3, a=[3], l=1, r=1, k=0.

No ship sinks, so total sunks=2.

But the example output is 3, which suggests that I'm missing something.

Wait, perhaps the sixth attack sinks another ship.

Wait, no, the sixth attack reduces the first ship's durability from 4 to 3, but it doesn't sink.

So, maybe the example output is wrong, or I'm misunderstanding something.

Wait, perhaps when k=6, after step 5, sunks=2, a=[4,1], l=1, r=1, and k=1.

Then, attack the first ship (4), durability becomes 3, but it doesn't sink.

So, sunks=2.

But the example output is 3.

Wait, maybe there's a mistake in the example or in my understanding.

Let me check the problem statement again.

"if all the ships have sunk, the Kraken has nothing to attack and it swims away."

But in this case, after step 5, a=[4,1], l=1, r=1, k=1.

Then, attack the first ship (4), durability becomes 3, a=[3], l=1, r=1, k=0.

No ship sinks, so sunks=2.

But the example output is 3.

Wait, maybe the sixth attack sinks the last remaining ship.

Wait, no, the ship's durability is reduced to 3, which is still positive.

So, sunks=2.

Perhaps the example is incorrect, or I need to re-examine the logic.

Wait, maybe the sixth attack sinks the ship because it's the last ship.

Wait, no, if durability is reduced to 3, it's still above 0, so it shouldn't sink.

I'm confused.

Let me look at another example.

n=2, k=2, a=[3,2]

According to the code, l=0, r=1

Step 1: Attack first ship (3), durability 2, a=[2,2], k=1

Step 2: Attack last ship (2), durability 1, a=[2,1], k=0

No ship has sunk, so sunks=0.

But the example output is 2, which is incorrect based on this.

Wait, perhaps I'm miscounting sunks.

Wait, in the code, when a ship's durability reaches 0, sunks +=1.

In the first example, when the first ship is attacked and its durability reaches 0, sunks +=1, and it's removed.

Similarly, when the second ship is attacked and its durability reaches 0, sunks +=1.

But in the second test case with k=6, perhaps another ship sinks.

Wait, maybe I need to simulate it again.

n=4, k=6, a=[1,2,4,3]

Step 1: Attack first ship (1), durability 0, sunk. sunks=1, a=[2,4,3], l=1, r=2

Step 2: Attack last ship (3), durability 2, a=[2,4,2]

Step 3: Attack first ship (2), durability 1, a=[1,4,2]

Step 4: Attack last ship (2), durability 1, a=[1,4,1]

Step 5: Attack first ship (1), durability 0, sunk. sunks=2, a=[4,1], l=1, r=1

Step 6: Attack the first ship (4), durability 3, a=[3], l=1, r=1, k=0

No ship sinks, so total sunks=2.

But the example output is 3.

Wait, perhaps there's a mistake in the example or in my understanding.

Wait, maybe the ship with durability 1 would sink in the next attack.

Wait, no, after step 5, a=[4,1], l=1, r=1, k=1.

Attack the first ship (4), durability becomes 3, a=[3], l=1, r=1, k=0.

The ship's durability is still 3, which is greater than 0, so it doesn't sink.

Hence, sunks=2.

But the example output is 3.

This inconsistency suggests that either the example is wrong or my interpretation is incorrect.

Wait, perhaps the sixth attack causes the ship to sink because k=1 and a[1]=4, so k >= a[1], sunks +=1.

But in the code, it doesn't seem to handle that case.

Wait, in the code, when l == r, it checks if k >= a[r], then sunks +=1 and break.

In step 6, l=1, r=1, k=1, a[1]=4.

Since k < a[r], it breaks without sinking the ship.

Hence, sunks=2.

But the example output is 3.

This suggests that the code is incorrect.

Wait, perhaps I misread the code.

Looking back at the code:

if l == r:

if k >= a[r]:

sunks += 1

break

else:

break

In step 6, l=1, r=1, k=1, a[1]=4.

Since k < a[r], it breaks without sinking the ship.

Hence, sunks=2.

But according to the example, the output is 3.

This indicates that the code is incorrect.

Wait, perhaps the example is misinterpreted.

Looking back at the problem statement, it says:

"For example, if n=4 , k=5 , and a=[1, 2, 4, 3] , the following will happen:

1. The Kraken attacks the first ship, its durability becomes zero and now a = [2, 4, 3];

2. The Kraken attacks the last ship, now a = [2, 4, 2];

3. The Kraken attacks the first ship, now a = [1, 4, 2];

4. The Kraken attacks the last ship, now a = [1, 4, 1];

5. The Kraken attacks the first ship, its durability becomes zero and now a = [4, 1]."

"How many ships were sunk after the Kraken's attack?"

In this sequence, two ships are sunk (the first ship twice), but the output is 2.

Wait, but in the example input, for n=4 k=5, output is 2, and for n=4 k=6, output is 3.

But according to my simulation, for k=6, sunks=2, not 3.

This suggests that either the example is incorrect or there's a mistake in my simulation.

Wait, perhaps in the sixth attack, since l=r and k=1 < a[r], no ship sinks.

Hence, sunks=2.

But the example output is 3, which doesn't match.

Wait, maybe the ship with durability 1 sinks in some way.

Wait, perhaps I need to consider that when l=r and k >= a[r], sunks +=1.

But in my simulation, after step 5, a=[4,1], l=1, r=1, k=1.

Then, attack the first ship (4), durability becomes 3, but since k=1 < a[r]=1, which is not possible because a[r]=1 and k=1, so k >= a[r], sunks +=1.

Wait, a[r]=1, k=1, so k >= a[r], sunks +=1.

Hence, sunks=3.

Wait, perhaps I misread the code.

Looking back at the code:

if l == r:

if k >= a[r]:

sunks += 1

break

else:

break

In this case, l=1, r=1, k=1, a[r]=1.

Since k >= a[r], sunks +=1 and break.

Hence, sunks=3.

Wait, but in my earlier simulation, I thought that the attack would reduce the durability by 1, making a[r]=0, hence sinking.

So, sunks=3.

Therefore, the code is correct in this case.

I must have miscounted the k value.

So, for n=4, k=6, a=[1,2,4,3]

After step 5, a=[4,1], l=1, r=1, k=1.

Then, k >= a[r]=1, so sunks +=1, total sunks=3.

Hence, the output is 3, matching the example.

I see, I made a mistake in simulating the steps.

Another test case:

n=2, k=2, a=[3,2]

Step 1: Attack first ship (3), durability 2, a=[2,2], k=1

Step 2: Attack last ship (2), durability 1, a=[2,1], k=0

No ship has sunk, so sunks=0.

But the example output is 0, which matches.

Another test case:

n=2, k=7, a=[1,5]

Step 1: Attack first ship (1), durability 0, sunk. sunks=1, a=[5], l=0, r=0

Step 2: l=r, k=6 >= a[r]=5, sunks +=1, total sunks=2.

Hence, output is 2, which matches the example.

Another test case:

n=5, k=2, a=[5,2,7,1,8]

Step 1: Attack first ship (5), durability 4, a=[4,2,7,1,8], k=1

Step 2: Attack last ship (8), durability 7, a=[4,2,7,1,7], k=0

No ship has sunk, sunks=0.

But the example input has n=5, k=20, a=[2,7,1,8,2], output=5.

Wait, I need to check the correct test case.

Wait, in the example input:

5 20

2 7 1 8 2

Output:5

So, all ships are sunk.

The code should handle this correctly.

In this case, with k=20, and a=[2,7,1,8,2], the attacks would proceed as follows:

Step 1: Attack first ship (2), durability 1, a=[1,7,1,8,2], k=19

Step 2: Attack last ship (2), durability 1, a=[1,7,1,8,1], k=18

Step 3: Attack first ship (1), durability 0, sunk. sunks=1, a=[7,1,8,1], l=0, r=3

Step 4: Attack last ship (1), durability 0, sunk. sunks=2, a=[7,1,8], l=0, r=2

Step 5: Attack first ship (7), durability 6, a=[6,1,8], k=16

Step 6: Attack last ship (8), durability 7, a=[6,1,7], k=15

Step 7: Attack first ship (6), durability 5, a=[5,1,7], k=14

Step 8: Attack last ship (7), durability 6, a=[5,1,6], k=13

Step 9: Attack first ship (5), durability 4, a=[4,1,6], k=12

Step 10: Attack last ship (6), durability 5, a=[4,1,5], k=11

Step 11: Attack first ship (4), durability 3, a=[3,1,5], k=10

Step 12: Attack last ship (5), durability 4, a=[3,1,4], k=9

Step 13: Attack first ship (3), durability 2, a=[2,1,4], k=8

Step 14: Attack last ship (4), durability 3, a=[2,1,3], k=7

Step 15: Attack first ship (2), durability 1, a=[1,1,3], k=6

Step 16: Attack last ship (3), durability 2, a=[1,1,2], k=5

Step 17: Attack first ship (1), durability 0, sunk. sunks=3, a=[1,2], l=0, r=1

Step 18: Attack last ship (2), durability 1, a=[1,1], k=4

Step 19: Attack first ship (1), durability 0, sunk. sunks=4, a=[1], l=0, r=0

Step 20: Attack the first ship (1), durability 0, sunk. sunks=5, a=[], l=0, r=-1

Hence, all ships are sunk, output=5, which matches the example.

So, the code seems to handle this correctly.

Another test case:

n=2, k=2, a=[3,2]

As simulated earlier, sunks=0, which matches the example output.

Hence, the code seems correct.

Therefore, Correctness: **True**

**Final Answer**

\[ \boxed{\text{see explanation}} \]