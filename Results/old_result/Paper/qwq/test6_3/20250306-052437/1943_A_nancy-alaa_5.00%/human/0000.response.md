Alright, I have this problem to solve. Let's see what it's about. There are two players, Alice and Bob, playing a game on an array of integers. Alice starts with an empty array c. They take turns, with Alice going first. On Alice's turn, she picks an element from the original array a, appends it to c, and deletes it from a. On Bob's turn, he picks an element from a, and deletes it from a. The game ends when a is empty, and the score is the MEX of c, which is the smallest non-negative integer not in c. Alice wants to maximize the score, and Bob wants to minimize it. I need to find out what the final score will be if both play optimally.

First, I need to understand the MEX concept clearly. MEX of an array is the smallest non-negative integer not present in it. For example, MEX of [2,2,1] is 0, since 0 is the smallest non-negative integer not in the array. MEX of [3,1,0,1] is 2, because 0 and 1 are present, but 2 is not. MEX of [0,3,1,2] is 4, as 0,1,2,3 are present, but 4 is not.

So, in this game, Alice wants to maximize the MEX of c, meaning she wants c to have as many of the smaller non-negative integers as possible, up to some point, to make the MEX as high as possible. Bob, on the other hand, wants to minimize the MEX, meaning he wants to disrupt Alice's efforts and ensure that some smaller numbers are not in c.

Let's think about how the game progresses. Alice and Bob alternate turns, with Alice going first. Each turn, Alice picks an element to add to c and removes it from a, while Bob just removes an element from a without adding it to c.

Since Alice wants to maximize the MEX, she would ideally want to include as many of the smaller numbers in c as possible. Bob, to minimize the MEX, would want to prevent Alice from including certain numbers in c.

I need to find out, given that both play optimally, what the final MEX of c will be.

Let me consider some examples to get a better understanding.

Example 1:

Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Output:

2

1

0

In the first test case, n=4, and a=[0,0,1,1]. The possible MEX values for c could be 0,1, or 2.

Alice wants to maximize MEX, so she would try to make c such that MEX is as large as possible. Bob tries to minimize it.

One possible sequence of moves:

- Alice picks 1 and adds to c. Now, a=[0,0,1], c=[1]

- Bob picks 0 from a. Now, a=[0,1], c=[1]

- Alice picks 0 from a and adds to c. Now, a=[1], c=[1,0]

- Bob picks 1 from a. Now, a=[] , c=[1,0]

MEX of c is 2, since 0 and 1 are present.

Is this the optimal play? Let's see if Bob can do better.

Suppose Bob picks 1 in his first turn:

- Alice picks 1. a=[0,0], c=[1]

- Bob picks 1. a=[0], c=[1]

- Alice picks 0 and adds to c. a=[], c=[1,0]

Again, MEX is 2.

Alternatively, if Alice picks 0 first:

- Alice picks 0. a=[0,1,1], c=[0]

- Bob picks 0. a=[1,1], c=[0]

- Alice picks 1 and adds to c. a=[1], c=[0,1]

- Bob picks 1. a=[], c=[0,1]

MEX is 2 again.

Seems like regardless of how they play, MEX is 2.

Wait, but Bob wants to minimize MEX. Is there a way for Bob to make MEX less than 2?

Suppose:

- Alice picks 0. a=[0,1,1], c=[0]

- Bob picks 1. a=[0,1], c=[0]

- Alice picks 1 and adds to c. a=[0], c=[0,1]

- Bob picks 0. a=[], c=[0,1]

MEX is still 2.

Another scenario:

- Alice picks 1. a=[0,0,1], c=[1]

- Bob picks 1. a=[0,0], c=[1]

- Alice picks 0 and adds to c. a=[0], c=[1,0]

- Bob picks 0. a=[], c=[1,0]

MEX is 2.

Seems like MEX is always 2 in this case, no matter how they play.

Second test case:

n=4, a=[0,1,2,3]

Possible MEX values: 4, since all numbers from 0 to 3 are present.

Alice can include all of them in c, but Bob can prevent that.

Let's see:

- Alice picks 0 and adds to c. a=[1,2,3], c=[0]

- Bob picks 1. a=[2,3], c=[0]

- Alice picks 2 and adds to c. a=[3], c=[0,2]

- Bob picks 3. a=[], c=[0,2]

MEX is 1, since 1 is missing.

Alternatively:

- Alice picks 1 and adds to c. a=[0,2,3], c=[1]

- Bob picks 0. a=[2,3], c=[1]

- Alice picks 2 and adds to c. a=[3], c=[1,2]

- Bob picks 3. a=[], c=[1,2]

MEX is 0, since 0 is missing.

Wait, but Alice wants to maximize MEX, so she would prefer to have 0 in c to make MEX higher.

Let's see another sequence:

- Alice picks 0 and adds to c. a=[1,2,3], c=[0]

- Bob picks 2. a=[1,3], c=[0]

- Alice picks 1 and adds to c. a=[3], c=[0,1]

- Bob picks 3. a=[], c=[0,1]

MEX is 2.

Alternatively:

- Alice picks 0 and adds to c. a=[1,2,3], c=[0]

- Bob picks 3. a=[1,2], c=[0]

- Alice picks 1 and adds to c. a=[2], c=[0,1]

- Bob picks 2. a=[], c=[0,1]

MEX is 2.

Another sequence:

- Alice picks 2 and adds to c. a=[0,1,3], c=[2]

- Bob picks 1. a=[0,3], c=[2]

- Alice picks 0 and adds to c. a=[3], c=[2,0]

- Bob picks 3. a=[], c=[2,0]

MEX is 1.

Seems like depending on the moves, MEX can be 1 or 2. Bob can force MEX to be 1.

So, in this case, the output is 1.

Third test case:

n=2, a=[1,1]

- Alice picks 1 and adds to c. a=[1], c=[1]

- Bob picks 1. a=[], c=[1]

MEX is 0, since 0 is missing.

Alternatively:

- Alice picks 1 and adds to c. a=[1], c=[1]

- Bob picks 1. a=[], c=[1]

MEX is still 0.

So, the output is 0.

From these examples, it seems that the game's final score depends on how Alice and Bob manipulate the inclusion of certain numbers in c, particularly the smaller non-negative integers.

I need to find a general strategy for both players to determine the optimal MEX.

Let me think about the frequency of each number in the array.

Suppose I count the frequency of each number from 0 to n-1 in the array.

Let's denote freq[i] as the number of times i appears in a.

Alice wants to include as many of the smaller i's in c as possible, while Bob tries to prevent that.

Since Alice can choose which element to add to c on her turn, and Bob can only remove an element on his turn, the dynamics are such that Alice has more control over what goes into c.

However, Bob can influence the game by removing elements that Alice might want to include in c.

Let me consider the total number of turns.

There are n turns in total, since n elements are removed from a.

Alice plays on turns 1,3,5,... (odd turns), and Bob plays on turns 2,4,6,... (even turns).

Since Alice starts, if n is odd, Alice makes the last move; if n is even, Bob makes the last move.

But in terms of influencing the final content of c, we need to see how Alice can maximize the MEX, which depends on which numbers are in c.

Let me consider that Alice wants to include as many of the smaller numbers in c as possible, while Bob wants to prevent that.

One way to think about it is that for each number i, starting from 0 upwards, Alice needs to ensure that i is included in c if possible, despite Bob's attempts to prevent it.

I need to determine, for each i, whether Alice can ensure that i is included in c, even against Bob's optimal play.

If Alice can ensure that i is in c, then MEX cannot be i. If there exists some i that Alice cannot ensure is in c, then the MEX will be i.

So, for each i, I need to check if Alice can force i to be in c.

Let's consider the frequency of i, freq[i].

If freq[i] is greater than the number of times Bob can remove i, then Alice can ensure that at least one i is included in c.

Conversely, if freq[i] is less than or equal to the number of times Bob can remove i, then Bob can prevent i from being in c.

I need to calculate, for each i, the maximum number of times Bob can remove i.

Since Bob plays every even turn, and there are n turns in total, the number of times Bob plays is floor(n/2).

So, if freq[i] > floor(n/2), then Alice can ensure that at least one i is in c, because even if Bob removes floor(n/2) instances of i, there are still some left for Alice to pick.

If freq[i] <= floor(n/2), then Bob can potentially remove all instances of i, preventing Alice from including any i in c.

Wait, but this might not be entirely accurate, because Alice gets to choose which elements to pick and when.

Let me think differently.

Let me consider that Alice and Bob are playing optimally, and I need to find the smallest i such that freq[i] <= floor(n/2), meaning Bob can remove all instances of i before Alice can include any in c.

If freq[i] > floor(n/2), then Alice can include at least one i in c.

So, the smallest i where freq[i] <= floor(n/2) will be the MEX.

Wait, but in the first example:

n=4, a=[0,0,1,1]

freq[0]=2, freq[1]=2

floor(4/2)=2

For i=0: freq[0]=2 > 2, so Alice can include 0 in c.

For i=1: freq[1]=2 > 2, so Alice can include 1 in c.

Then, MEX should be 2, which matches the first output.

In the second example:

n=4, a=[0,1,2,3]

freq[0]=1, freq[1]=1, freq[2]=1, freq[3]=1

floor(4/2)=2

For i=0: freq[0]=1 <=2, so Bob can prevent 0 from being in c.

For i=1: freq[1]=1 <=2, so Bob can prevent 1 from being in c.

For i=2: freq[2]=1 <=2, so Bob can prevent 2 from being in c.

For i=3: freq[3]=1 <=2, so Bob can prevent 3 from being in c.

So, the smallest i where Bob can prevent it is i=0, but in the output, it's 1.

Wait, that doesn't match.

Hmm, maybe my earlier assumption is incorrect.

Let me think again.

Perhaps I need to consider the order in which Alice and Bob make their moves.

Let me consider that Alice and Bob are playing optimally, and I need to simulate their decisions.

Alice wants to maximize MEX, so she would try to include as many small numbers as possible in c.

Bob wants to minimize MEX, so he would try to prevent Alice from including certain small numbers in c.

Let me consider that for each number i, starting from 0 upwards, Alice needs to ensure that i is included in c.

Bob will try to prevent that.

If freq[i] > number of times Bob can interfere, then Alice can include i in c.

Otherwise, Bob can prevent i from being in c.

But, the number of times Bob can interfere with a particular i is not straightforward.

Wait, perhaps I should think in terms of the number of times Bob can remove elements.

Total number of moves by Bob is floor(n/2).

If freq[i] > floor(n/2), then Alice can ensure that at least one i is included in c, because Bob can remove at most floor(n/2) instances of i.

If freq[i] <= floor(n/2), then Bob can remove all instances of i, preventing Alice from including any i in c.

In the second example:

n=4, floor(n/2)=2

freq[0]=1 <=2, so Bob can prevent 0 from being in c.

freq[1]=1 <=2, so Bob can prevent 1 from being in c.

freq[2]=1 <=2, so Bob can prevent 2 from being in c.

freq[3]=1 <=2, so Bob can prevent 3 from being in c.

So, the smallest i where Bob can prevent it is i=0, but the output is 1.

This suggests that my earlier assumption is incorrect.

Wait, maybe I need to consider that Alice can include multiple instances of the same number, but since MEX only cares about presence, not multiplicity, perhaps I need to treat freq[i] as boolean (whether i is present or not).

But that doesn't seem right, because frequency matters in terms of how many times Bob can remove i.

Wait, perhaps I need to consider the number of times Alice can include i in c.

Let me think differently.

Let me consider that for each i, if freq[i] is greater than 0, and freq[i] > floor(n/2), then Alice can include i in c.

Wait, but in the second example, freq[i]=1 <= floor(n/2)=2, so Bob can remove all instances of i, preventing Alice from including any i in c.

Hence, for i from 0 to 3, Bob can prevent them from being in c.

So, MEX should be 0, but the output is 1.

Wait, maybe I need to consider that if Alice can include any number less than i in c, then MEX is at least i.

But in this case, Bob can prevent all numbers from 0 to 3 from being in c, so MEX should be 0.

But the output is 1, which contradicts this.

Wait, perhaps there is a mistake in my earlier reasoning.

Let me consider the game more carefully.

In the second test case:

n=4, a=[0,1,2,3]

Possible moves:

- Alice picks 0 and adds to c. a=[1,2,3], c=[0]

- Bob picks 1. a=[2,3], c=[0]

- Alice picks 2 and adds to c. a=[3], c=[0,2]

- Bob picks 3. a=[], c=[0,2]

MEX is 1.

Alternatively:

- Alice picks 1 and adds to c. a=[0,2,3], c=[1]

- Bob picks 0. a=[2,3], c=[1]

- Alice picks 2 and adds to c. a=[3], c=[1,2]

- Bob picks 3. a=[], c=[1,2]

MEX is 0.

Wait, in this sequence, MEX is 0.

But the output is 1, which suggests that there is a better play by Bob to make MEX=1.

Wait, perhaps Bob can force MEX to be 1 by preventing 0 from being in c.

Let's see:

- Alice picks 0 and adds to c. a=[1,2,3], c=[0]

- Bob picks 0. a=[1,2,3], c=[0]

Wait, but freq[0]=1, so after Alice picks 0, there are no more 0's left.

Wait, no, freq[0]=1, so after Alice picks 0, there are no 0's left for Bob to pick.

Wait, in the first move, Alice picks 0 and adds to c. a=[1,2,3], c=[0]

Then Bob picks, say, 1. a=[2,3], c=[0]

Alice picks 2 and adds to c. a=[3], c=[0,2]

Bob picks 3. a=[], c=[0,2]

MEX is 1.

Alternatively, Bob could pick 2 in his first move:

- Alice picks 0 and adds to c. a=[1,2,3], c=[0]

- Bob picks 2. a=[1,3], c=[0]

- Alice picks 1 and adds to c. a=[3], c=[0,1]

- Bob picks 3. a=[], c=[0,1]

MEX is 2.

So, depending on Bob's choices, MEX can be 1 or 2.

Bob wants to minimize MEX, so he would choose the sequence that results in MEX=1.

Hence, the output is 1.

Wait, but according to the earlier reasoning, Bob can prevent 0 from being in c, making MEX=0, but in the output, it's 1.

Wait, no, in the sequences above, MEX is at least 1.

Wait, perhaps I'm missing something.

Let me consider another approach.

Let me consider that Alice can include ceil(freq[i]/2) instances of i in c, because for each pair of i, Alice can include one, as she goes first.

Wait, but this might not be accurate.

Wait, perhaps I should think in terms of the number of times Alice gets to choose an element.

Total number of turns by Alice is ceil(n/2), since she goes first.

Similarly, Bob has floor(n/2) turns.

So, for each i, if freq[i] > floor(n/2), then Alice can include at least one i in c, because Bob can remove at most floor(n/2) instances of i.

If freq[i] <= floor(n/2), then Bob can remove all instances of i, preventing Alice from including any in c.

Hence, the smallest i where freq[i] <= floor(n/2) will be the MEX.

In the first test case:

n=4, floor(n/2)=2

freq[0]=2 <=2, so Bob can prevent 0 from being in c.

freq[1]=2 <=2, so Bob can prevent 1 from being in c.

freq[2]=0 <=2, so Bob can prevent 2 from being in c (though it's already absent).

Hence, MEX should be 0, but in the first test case, the output is 2.

Wait, that doesn't match.

Wait, in the first test case, a=[0,0,1,1], n=4.

freq[0]=2, freq[1]=2, freq[2]=0.

floor(n/2)=2.

For i=0: freq[0]=2 <=2, so Bob can prevent 0 from being in c.

For i=1: freq[1]=2 <=2, so Bob can prevent 1 from being in c.

For i=2: freq[2]=0 <=2, so Bob can prevent 2 from being in c.

Hence, MEX should be 0, but in the first test case, the output is 2.

This suggests that my earlier assumption is incorrect.

Wait, perhaps I need to consider that if freq[i] > floor(n/2), Alice can include at least one i in c.

In the first test case, freq[0]=2 > floor(n/2)=2? Wait, freq[0]=2 <=2, so no.

Wait, freq[0]=2 <=2, so Bob can prevent 0 from being in c.

Similarly, freq[1]=2 <=2, so Bob can prevent 1 from being in c.

freq[2]=0 <=2, so Bob can prevent 2 from being in c.

But in the example, c=[1,0], which has MEX=2.

Wait, perhaps I need to consider that even if freq[i] <= floor(n/2), Bob can prevent i from being in c only if he focuses on removing i.

But in the first test case, Bob can choose to remove other elements instead of i, which might allow Alice to include i.

This seems complicated.

Let me think differently.

Let me consider that Alice wants to include as many small numbers in c as possible, while Bob wants to prevent that.

I need to find the smallest i such that, even with Alice's best efforts, i is not included in c.

To do that, I need to determine for each i, whether Alice can ensure that i is included in c.

If Alice can ensure that i is included in c, then MEX cannot be i.

Otherwise, MEX is i.

To ensure that i is included in c, Alice needs to pick i at some point when it's her turn, and make sure that Bob doesn't remove all instances of i before she can pick one.

Given that Bob can remove up to floor(n/2) elements, if freq[i] > floor(n/2), then Alice can ensure that at least one i is included in c.

Because even if Bob removes floor(n/2) instances of i, there is still at least one left for Alice to pick.

If freq[i] <= floor(n/2), then Bob can remove all instances of i before Alice can pick any, thus preventing i from being in c.

Hence, the smallest i