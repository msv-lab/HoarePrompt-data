Alright, I've got this problem to solve. It's an interactive problem, which means I need to communicate with another program (likely a judge) to get information and provide answers. The problem involves graphs, specifically a complete undirected graph with n vertices where n-2 edges have been removed. My task is to find a Hamiltonian path in this graph using at most n queries.

First, I need to understand what a complete undirected graph is. In a complete graph with n vertices, every pair of distinct vertices is connected by a unique edge. So, there are n*(n-1)/2 edges in total. In this problem, Kostyanych has removed exactly n-2 edges from this complete graph. That means the resulting graph has n*(n-1)/2 - (n-2) edges.

The problem states that a Hamiltonian path always exists under these constraints, and I need to find it using at most n queries. A Hamiltonian path is a path in the graph that visits each vertex exactly once.

Now, let's understand the queries I can make. I can ask queries of the type "? d", where d is an integer between 0 and n-1 inclusive. In response, Kostyanych will tell me two things:

1. The number of a vertex v that has a degree at least d. Among all such vertices, he picks the one with the minimum degree, and if there are multiple, the one with the minimum number.

2. The number of another vertex that is not connected to v by an edge, provided such a vertex exists; otherwise, 0 is reported. Again, among all possible such vertices, the one with the minimum number is chosen.

After each query, the vertex v is removed from the graph along with all its incident edges.

If no vertex has a degree at least d, then "0 0" is reported.

My goal is to use these queries to determine a Hamiltonian path in the original graph.

Looking at the example provided:

Input:

3

4

0 0

1 4

2 3

4

1 0

4 2

2

1 0

Output:

? 3

? 2

? 1

! 4 3 1 2

? 3

? 0

! 4 1 2 3

? 0

! 2 1

In the first test case, with n=4, the queries and responses are:

- "? 3" -> "0 0" (no vertex with degree >=3)

- "? 2" -> "1 4" (vertex 1 has degree >=2, and it's not connected to vertex 4)

- "? 1" -> "2 3" (vertex 2 has degree >=1, and it's not connected to vertex 3)

Then, the Hamiltonian path is reported as "4 3 1 2".

I need to find a way to use these queries to reconstruct the graph or at least find a Hamiltonian path.

First, I need to think about how the removal of n-2 edges affects the graph. Starting from a complete graph and removing n-2 edges means that the graph is still highly connected. In fact, since a complete graph is (n-1)-regular, removing n-2 edges will result in a graph where most vertices still have high degrees.

Given that, I need to find a way to identify a Hamiltonian path using the queries. The queries provide information about the degrees of vertices and some information about missing edges.

One approach could be to iteratively build the path by selecting vertices with higher degrees first, as they are more likely to be connected to many other vertices, thus helping in constructing a path that covers all vertices.

However, since the graph is modified after each query (the queried vertex is removed), I need to be careful about how I choose d in each query to maximize the information I get.

Looking at the example, in the first query with d=3, no vertex has degree >=3, so "0 0" is returned. Then, with d=2, vertex 1 has degree >=2 and is not connected to vertex 4. Next, with d=1, vertex 2 has degree >=1 and is not connected to vertex 3.

From this, perhaps I can infer some connections and missing edges to build the path.

Wait, but in the end, the path is "4 3 1 2", which seems to avoid the missing edges.

I need to think about how to use the query responses to build the path.

Let me consider the properties of the graph after removing n-2 edges from a complete graph. Since only n-2 edges are removed, the graph remains connected because a complete graph is (n-1)-connected, and removing n-2 edges doesn't disconnect it.

In a complete graph with n vertices, removing n-2 edges leaves a graph that is still connected and has at least 2 vertices with degree n-1.

Wait, actually, in a complete graph with n vertices, each vertex has degree n-1. Removing n-2 edges can reduce the degrees of some vertices, but the graph remains connected.

I need to think about the degrees of the vertices after removing n-2 edges.

Let me consider that in the original complete graph, every vertex has degree n-1. When we remove n-2 edges, some vertices will have their degrees reduced.

Each edge removal reduces the degrees of two vertices by one each. So, removing n-2 edges can reduce the degrees of up to 2*(n-2) vertex-edge incidences.

But since each vertex can have its degree reduced multiple times, I need to think about the possible degree distribution.

However, this seems too vague. Maybe I should think differently.

Given that the graph is still connected (since removing n-2 edges from a complete graph doesn't disconnect it), and it's highly connected, there must be a way to traverse it in a way that forms a Hamiltonian path.

The problem allows up to n queries, which is enough to potentially query about degrees and connections.

Looking back at the queries, each query with a certain d returns a vertex v with degree at least d (or the one with minimal degree among those with degree at least d, and minimal number if there are ties), and a vertex u that v is not connected to (or 0 if all are connected).

After each query, v is removed from the graph.

My idea is to iteratively build the Hamiltonian path by selecting vertices with higher degrees first, as they are more likely to be connected to many others.

But I need to ensure that the path remains Hamiltonian, i.e., each vertex is visited exactly once, and edges exist between consecutive vertices in the path.

Wait, but since the graph is connected and has only n-2 edges removed from the complete graph, it's still highly connected, and a Hamiltonian path should exist.

I need to find a way to construct such a path using the queries.

Let me consider the following approach:

1. Start by querying with the highest possible d, which is n-1.

- If there's a vertex with degree n-1, it's connected to all other vertices.

- If such a vertex exists, querying with d=n-1 will return that vertex and a u=0, since it's connected to all.

- Remove that vertex from the graph.

- Add it to the path.

- Continue with the remaining graph.

2. If no vertex has degree n-1, try with d=n-2, and so on, decreasing d until a vertex is found.

- For each query, if a vertex v is returned, add it to the path and remove it from the graph.

- Use the information about u (the vertex not connected to v) to avoid creating paths that include that missing edge.

But I need to be careful about how I construct the path, ensuring that the path remains possible.

Wait, maybe I can think of building the path in reverse.

Alternatively, perhaps I can build the path step by step, choosing vertices with higher degrees first, and ensuring that the path can be extended.

But this seems too vague.

Let me consider the properties of the graph.

In a complete graph with n vertices and n-2 edges removed, the graph has:

- n vertices

- n*(n-1)/2 - (n-2) edges

Simplify that:

n*(n-1)/2 - n + 2 = (n^2 - n - 2n + 4)/2 = (n^2 - 3n + 4)/2 edges.

But perhaps that's not immediately helpful.

Given that only n-2 edges are removed from the complete graph, the graph remains connected and has a high minimum degree.

In fact, in a complete graph, each vertex has degree n-1. Removing n-2 edges can reduce the degrees of some vertices, but not by much.

Let me calculate the minimum degree in the resulting graph.

In the worst case, the n-2 edges are removed in such a way that they all reduce the degree of a single vertex. For example, if all n-2 edges are removed from one vertex, its degree would be reduced to 1 (since n-1 - (n-2) = 1).

So, the minimum degree in the graph is at least 1.

But likely, the degrees are higher for most vertices.

Given that, I need to find a way to traverse the graph in a way that forms a Hamiltonian path.

One standard way to find a Hamiltonian path in a graph is to use a depth-first search (DFS) approach, but since this is an interactive problem with limited queries, I need a more efficient way.

Given that I can only make up to n queries, I need to use each query to maximize the information I get about the graph's structure.

Looking back at the query format:

- "? d" : Get a vertex v with degree at least d (or minimal degree among those with degree >=d), and a vertex u not connected to v (or 0 if all are connected).

- After the query, v is removed from the graph.

My idea is to use these queries to identify vertices with high degrees, which are likely to be connected to many other vertices, and use them to build the path.

Specifically, I can start by querying with high d values to get vertices that are well-connected, and then use the information about which vertices are not connected to v to avoid those in the path.

Wait, but after each query, v is removed from the graph, so I need to build the path incrementally, considering the remaining graph after each removal.

This seems complicated.

Let me consider the following plan:

1. Initialize an empty path.

2. While there are remaining vertices:

a. Query with the highest possible d (starting from n-1 down to 0) until a vertex v is returned.

b. Add v to the path.

c. Remove v from the graph.

d. Use the information about u (the vertex not connected to v) to adjust the path if necessary.

But I'm not sure how to use u in this context.

Wait, perhaps I can use u to decide the order in which to add vertices to the path.

Alternatively, maybe I can build the path by always adding the vertex with the highest degree remaining, as it's most likely connected to many others.

But I still need to ensure that the path remains Hamiltonian.

Wait, maybe I can think of building the path by always extending it at one end with a vertex that has the highest degree in the remaining graph.

But this requires knowing the connections, which I don't have directly.

Alternatively, perhaps I can build the path by always adding a vertex that is connected to the last vertex in the path.

But I don't have information about which vertices are connected until I query.

This is tricky.

Let me think differently.

Since the graph is modified after each query (v is removed), I need to think about how the queries affect the remaining graph.

Each query gives me a vertex v and a vertex u not connected to v (if any).

After querying, v is removed, so u remains in the graph unless it was previously removed.

Wait, but u is just information about v's connections.

I need to keep track of which edges are missing.

But with n up to 1e5 and t up to 1e3, I can't store the entire graph.

I need a smarter way.

Looking back at the example, in the first test case:

- n=4

- "? 3" -> "0 0" (no vertex with degree >=3)

- "? 2" -> "1 4" (vertex 1 has degree >=2, not connected to 4)

- "? 1" -> "2 3" (vertex 2 has degree >=1, not connected to 3)

Then, the path is "4 3 1 2".

How does this path avoid the missing edges?

From the queries:

- After "? 2", v=1, u=4 => edge (1,4) is missing

- After "? 1", v=2, u=3 => edge (2,3) is missing

So, the missing edges are (1,4) and (2,3).

The path is 4-3-1-2, which avoids these missing edges.

Wait, but in this path, 4 is connected to 3, 3 is connected to 1, and 1 is connected to 2.

Given that edges (1,4) and (2,3) are missing, this path is valid.

So, perhaps by collecting the missing edges from the queries, I can construct the path accordingly.

But in general, with n-2 edges removed, there could be multiple missing edges, and I need to find a path that avoids them.

But querying n times would allow me to find up to n vertices and their missing connections, but I need to find a way to piece this information together to form a Hamiltonian path.

Wait, but in the first test case, n=4, and n-2=2 edges are removed.

From the queries, I can find out about these missing edges.

Similarly, in the second test case:

- n=4

- "? 3" -> "1 0" (vertex 1 has degree >=3, but u=0, meaning it's connected to all remaining vertices)

- "? 0" -> "4 2" (vertex 4 has degree >=0, and is not connected to 2)

Then, the path is "4 1 2 3".

From the queries, I know that edge (4,2) is missing.

The path is 4-1-2-3, which avoids the missing edge.

So, perhaps I can collect the missing edges and then find a path that avoids them.

But in general, with n up to 1e5 and t up to 1e3, I need an efficient way to do this.

But storing all missing edges isn't feasible due to time and memory constraints.

I need a better approach.

Let me consider that in a complete graph with n vertices and n-2 edges removed, the graph is still connected, and has a Hamiltonian path.

I need to find this path using at most n queries.

Each query gives me information about a vertex and one of its non-neighbors.

I need to use this information to build the path.

An alternative idea: Since the graph is modified after each query (v is removed), perhaps I can build the path step by step, always choosing a vertex with high degree in the remaining graph.

Then, I can add this vertex to one end of the path and remove it from the remaining graph.

But I need to ensure that the path remains Hamiltonian.

Wait, perhaps I can build the path by always adding a vertex with the highest degree to one end of the path, and use the information about its non-neighbor to decide which end to add it to.

This seems promising.

Let me elaborate:

- Start with an empty path.

- While there are remaining vertices:

- Query with the highest possible d to get a vertex v with high degree in the remaining graph.

- Add v to one end of the path.

- Remove v from the remaining graph.

- Use the information about u (a vertex not connected to v) to decide which end to add v to.

Wait, but how exactly?

If u is already in the path, I need to ensure that v is added to the opposite end.

But since I'm building the path incrementally, and u is a vertex not connected to v, I need to ensure that v is added to the path in a way that doesn't create any conflicts with u.

This is getting complicated.

Let me think differently.

Perhaps I can treat the queries as a way to identify a vertex with a certain degree and a non-neighbor, and use this information to reconstruct the graph's structure incrementally.

But reconstructing the entire graph is not feasible due to time and memory constraints.

I need a smarter way.

Looking back at the problem statement, it mentions that a Hamiltonian path always exists under these constraints.

So, I don't need to worry about the graph not having a Hamiltonian path; I just need to find one using the queries.

Another idea: Since I can query about degrees and non-neighbors, perhaps I can use this to identify leaves or vertices with low degrees, which could help in constructing the path.

Wait, but in a graph where n-2 edges are removed from a complete graph, the graph is still highly connected, and may not have leaves.

Wait, in a complete graph with n vertices and n-2 edges removed, the number of edges is n*(n-1)/2 - (n-2).

Simplify that:

n*(n-1)/2 - n + 2 = (n^2 - n - 2n + 4)/2 = (n^2 - 3n + 4)/2.

This is still a lot of edges, meaning the graph is dense.

So, it's unlikely to have vertices with low degrees.

Wait, but if n-2 edges are removed, some vertices could have their degrees reduced by up to n-2, but in practice, it's spread out.

I need to think differently.

Let me consider that in such a graph, the graph remains connected and has a Hamiltonian path.

I need to find a way to traverse the graph in a way that forms a Hamiltonian path, using the queries to guide me.

An idea: Use the queries to identify a starting vertex for the path.

Then, iteratively add neighbors to the path, using the queries to find the next vertex to add.

But I need to ensure that I don't get stuck in a dead end.

Wait, perhaps I can build the path by always adding a vertex with high degree to one end, and ensuring that I can continue extending the path from both ends.

This sounds similar to approaches used in building Eulerian paths, but for Hamiltonian paths, it's more challenging.

Another thought: Since the graph is modified after each query (v is removed), I need to adjust my strategy accordingly.

Each time I query with a certain d, I get a vertex v with degree at least d (or the one with minimal degree among those with degree >=d), and a non-neighbor u.

Then, v is removed from the graph.

I can use this to iteratively build the path.

Wait, perhaps I can build the path in reverse order.

Let me consider that.

Suppose I start from the end of the path and add vertices one by one.

Each time I query, I get a vertex v with high degree, add it to the beginning of the path, and remove it from the graph.

Then, I can continue adding vertices to the beginning of the path.

But I need to ensure that the path remains Hamiltonian.

Wait, perhaps I can treat the path as a sequence where the first vertex is the one queried first, and so on.

Then, the path would be in the order of queried vertices.

But I need to ensure that consecutive vertices in this sequence are connected by edges.

Wait, but after each query, v is removed, so I need to make sure that the remaining vertices are still connected in a way that allows the path to be extended.

This seems too vague.

Let me consider the following plan:

1. Initialize an empty list for the path.

2. While there are remaining vertices:

a. Query with the highest possible d to get a vertex v with high degree.

b. Add v to the path.

c. Remove v from the graph.

d. Use the information about u (a non-neighbor of v) to adjust the path if necessary.

But I still need to ensure that the path is Hamiltonian.

Wait, perhaps I can treat the path as a sequence where each new vertex is added to one end, and ensure that it's connected to the previous vertex.

But without knowing the connections between vertices, this is difficult.

Alternatively, perhaps I can use the non-neighbor information to avoid creating paths that include missing edges.

For example, if v and u are not connected, I should not place them consecutively in the path.

But since I'm building the path step by step, I need to ensure that no two consecutive vertices in the path are not connected.

To do this, I need to keep track of the connections as I build the path.

But with n up to 1e5, I need an efficient way to do this.

This seems challenging.

Let me consider a different approach.

Since the graph is modified after each query (v is removed), perhaps I can think of the queries as revealing parts of the graph step by step.

Each time I query with a certain d, I get a vertex v with degree at least d, and a non-neighbor u.

Then, I remove v from the graph.

I can use this to build the path incrementally.

Wait, perhaps I can always query with d as high as possible to get a vertex with high degree, add it to the path, and continue.

Then, the path would be a sequence of vertices with decreasing degrees.

But I still need to ensure that consecutive vertices in the path are connected.

This seems insufficient.

Let me consider that in a graph where n-2 edges are removed from a complete graph, the graph is still connected and has a Hamiltonian path.

Perhaps I can use a standard algorithm for finding Hamiltonian paths in such graphs, but adapted to the interactive setting with limited queries.

But finding Hamiltonian paths is generally NP-hard, but in this specific case, with the graph being very dense (only n-2 edges removed from a complete graph), it might be possible to find a path efficiently.

I need to find a way to exploit the high connectivity of the graph.

Another idea: Since the graph is highly connected, perhaps any path that visits all vertices without revisiting any will be a Hamiltonian path.

But this is not necessarily true, as I need to ensure that consecutive vertices in the path are connected by edges.

Wait, but in a graph where n-2 edges are removed from a complete graph, there are still many edges remaining, so it's likely that many paths exist.

But I still need to construct one explicitly.

Let me think about the properties of the graph again.

In a complete graph with n vertices, the number of Hamiltonian paths is (n-1)!.

By removing n-2 edges, we're still left with a graph that has at least one Hamiltonian path.

My task is to find one such path using at most n queries.

Given that, perhaps I can use the queries to identify a path step by step.

Wait, perhaps I can use the queries to identify the starting and ending vertices of the path.

But how?

Alternatively, perhaps I can use the queries to identify vertices with degree 1, which would be the endpoints of the path.

But in this graph, after removing n-2 edges, it's possible that no vertex has degree 1, unless n-2 edges are removed in a way that creates such degrees.

Wait, in a complete graph with n vertices, each vertex has degree n-1.

Removing n-2 edges can reduce the degrees of some vertices.

The minimum degree in the resulting graph would be at least 1, as established earlier.

But I need a better way to approach this.

Let me consider that in a complete graph with n vertices and n-2 edges removed, the number of connected components is still 1, meaning the graph remains connected.

Given that, I can start from any vertex and traverse the graph to reach all other vertices.

But in an interactive problem with limited queries, I need a more strategic way to build the path.

Let me consider starting from a vertex with high degree and building the path from there.

Each time, I choose a vertex with high degree, add it to the path, and remove it from the graph.

Then, I continue with the remaining graph.

But again, I need to ensure that the path is Hamiltonian.

Wait, perhaps I can treat the path as a sequence where each new vertex is connected to the previous one.

But without knowing the connections between vertices, this is difficult.

Alternatively, perhaps I can use the non-neighbor information to avoid creating invalid paths.

For example, if v and u are not connected, I should ensure that they are not consecutive in the path.

But managing this for potentially large n is challenging.

Let me consider a different strategy.

Since the graph is modified after each query (v is removed), perhaps I can think of the queries as revealing more about the structure of the graph incrementally.

Each query gives me a vertex v and a non-neighbor u, and then v is removed.

So, I can keep track of the missing edges (v, u) from the queries.

Then, using this information, I can try to construct a path that avoids these missing edges.

But with n up to 1e5, storing all missing edges isn't practical.

I need a smarter way.

Let me consider that in a complete graph with n vertices and n-2 edges removed, the graph has exactly n-2 missing edges.

Each query can reveal one of these missing edges, provided that the queried vertex has a non-neighbor.

So, in total, I can potentially find up to n-2 missing edges through the queries.

But I need to find a Hamiltonian path that avoids these missing edges.

Given that, perhaps I can collect information about the missing edges and then construct a path that doesn't include them.

But again, with large n, this needs to be efficient.

An alternative idea: Since the graph is highly connected, perhaps I can construct a path by always moving to a neighbor of the current vertex, choosing one with the highest degree among the remaining vertices.

This is similar to a greedy algorithm for finding a Hamiltonian path.

But I need to adapt this to the interactive setting with the given queries.

Wait, perhaps I can simulate a depth-first search (DFS) or a similar traversal using the queries.

But since I can only make n queries, I need to make each query count.

Let me consider starting from a vertex with high degree, adding it to the path, then querying again to find the next vertex to