Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n possible outcomes in a game, and for each outcome, there's a multiplier k_i. I need to bet some integer amount of coins on each outcome such that, no matter which outcome wins, the total coins I get back are more than the total coins I bet overall.

First, I need to understand the constraints:

- There are t test cases, up to 10,000 of them.

- For each test case, there's an integer n (1 ≤ n ≤ 50), the number of outcomes.

- Then, there are n integers k_i (2 ≤ k_i ≤ 20), which are the multipliers for each outcome.

- The sum of n over all test cases doesn't exceed 200,000.

- I need to output for each test case either -1 if it's impossible to find such a distribution of bets, or n integers x_i (1 ≤ x_i ≤ 1,000,000,000) representing the bets on each outcome.

The key condition is that the total amount bet should be less than the amount received for any winning outcome. Mathematically, if I bet x_1, x_2, ..., x_n on the outcomes, then for each i, k_i * x_i > sum of all x_j for j ≠ i.

Alternatively, rearranging, for each i, k_i * x_i > total - x_i, where total is the sum of all x_j.

So, k_i * x_i > total - x_i

=> k_i * x_i + x_i > total

=> x_i * (k_i + 1) > total

This needs to hold for all i.

I need to find x_i such that x_i * (k_i + 1) > total for all i.

Also, x_i must be positive integers.

This seems like a system of inequalities that needs to be satisfied simultaneously.

I recall that in such problems, finding a common multiple or using the least common multiple (LCM) can be helpful.

Looking at the sample input and output:

First test case:

n = 3

k = [3, 2, 7]

Output: 27 41 12

Let's check:

Total bet: 27 + 41 + 12 = 80

If first outcome wins: 3*27 = 81 > 80

Second outcome: 2*41 = 82 > 80

Third outcome: 7*12 = 84 > 80

So, it satisfies the condition.

Another test case:

n = 2

k = [3, 3]

Output: 1 1

Total bet: 1 + 1 = 2

First outcome: 3*1 = 3 > 2

Second outcome: 3*1 = 3 > 2

Good.

Another test case:

n = 5

k = [5, 5, 5, 5, 5]

Output: -1

Meaning it's impossible in this case.

So, I need to find a general method to determine if such x_i exist for given k_i, and if they do, find one possible set of x_i.

Looking at the program provided:

It reads the number of test cases, then for each test case, it calls func_2.

func_1 is defined to compute the least common multiple (LCM) of two numbers using their gcd.

func_2 reads n and the list of k_i.

It initializes den as the first k_i, then computes the LCM of den with each k_i in the list.

Then, it computes vprod as den divided by each k_i.

Then, it computes den as den - sum(vprod).

If den <= 0, it prints -1; else, it prints vprod.

Wait, that doesn't make complete sense to me.

Let me see with the first sample input:

n = 3

k = [3, 2, 7]

den starts as 3.

Then, func_1(3,2) = LCM(3,2) = 6.

Then, func_1(6,7) = LCM(6,7) = 42.

So, den = 42.

vprod = [42//3, 42//2, 42//7] = [14, 21, 6]

Then, sum(vprod) = 14 + 21 + 6 = 41.

den = 42 - 41 = 1, which is >0, so it prints vprod: 14 21 6.

But in the sample output, it's 27 41 12. So, different numbers, but still valid.

Wait, is there multiple solutions?

Yes, the problem says if multiple solutions exist, output any.

So, the program seems to be finding a valid solution, but not necessarily the one in the sample.

Let me check if the program's output is correct.

Take n=3, k=[3,2,7]

Program's output: 14 21 6

Total bet: 14 + 21 + 6 = 41

First outcome: 3*14 = 42 > 41

Second: 2*21 = 42 > 41

Third: 7*6 = 42 > 41

So, it's correct.

Sample output was 27 41 12, which also sums to 80, and satisfies the conditions as shown earlier.

So, multiple solutions are possible.

Now, let's see how the program arrives at this.

It computes den as the LCM of all k_i.

Then, vprod_i = den / k_i for each i.

Then, sum of vprod is sum(den / k_i for all i)

Then, den = den - sum(vprod)

If den > 0, it prints vprod.

Wait, but in the first sample, den = 42 - 41 = 1 > 0, so it's okay.

But in the third test case:

n=5

k=[5,5,5,5,5]

den starts as 5.

LCM of 5 with 5 is 5, repeated for all five, so den=5.

vprod = [5//5, 5//5, 5//5, 5//5, 5//5] = [1,1,1,1,1]

sum(vprod) = 5

den = 5 - 5 = 0 <=0, so it prints -1.

Which matches the sample output.

Another test case:

n=6

k=[7,9,3,17,9,13]

den starts as 7.

LCM(7,9)=63.

LCM(63,3)=63.

LCM(63,17)=1071.

LCM(1071,9)=1071.

LCM(1071,13)=13923.

vprod = [13923//7, 13923//9, 13923//3, 13923//17, 13923//9, 13923//13]

Which is [1989, 1547, 4641, 819, 1547, 1071]

sum(vprod) = 1989 + 1547 + 4641 + 819 + 1547 + 1071 = let's calculate:

1989 + 1547 = 3536

3536 + 4641 = 8177

8177 + 819 = 9096

9096 + 1547 = 10643

10643 + 1071 = 11714

den = 13923 - 11714 = 2209 >0, so it's okay.

Which matches the fourth test case's output in the sample.

Now, for the fifth test case:

n=3

k=[6,3,2]

den starts as 6.

LCM(6,3)=6.

LCM(6,2)=6.

vprod = [6//6, 6//3, 6//2] = [1,2,3]

sum(vprod)=1+2+3=6

den=6-6=0 <=0, so prints -1.

Which matches the sample output.

Last test case:

n=5

k=[9,4,6,8,3]

den starts as 9.

LCM(9,4)=36.

LCM(36,6)=36.

LCM(36,8)=72.

LCM(72,3)=72.

vprod=[72//9, 72//4, 72//6, 72//8, 72//3] = [8,18,12,9,24]

sum(vprod)=8+18+12+9+24=71

den=72-71=1>0, so it's okay.

Which matches the last test case's output.

So, the program seems to be working correctly for the sample inputs.

Now, I need to verify if this approach is correct in general.

Let's think about the conditions again.

We need to find x_i such that for each i, x_i * k_i > sum of all x_j.

Let’s denote S = sum of all x_j.

Then, for each i, x_i * k_i > S.

But S = sum_{j=1 to n} x_j.

So, x_i * k_i > S = x_i + sum_{j ≠ i} x_j.

Wait, but that's not directly helpful.

Alternatively, from x_i * k_i > S, and S = x_i + (S - x_i), so x_i * k_i > x_i + (S - x_i).

Simplify: x_i * k_i - x_i > S - x_i

x_i * (k_i - 1) > S - x_i

But not sure if that helps directly.

Let me think differently.

I recall that in some optimization problems, using the concept of LCM can help in finding a common scaling factor.

In this program, it computes den as the LCM of all k_i.

Then, it sets x_i = den / k_i for each i.

Then, it computes S = sum of x_i.

Then, it sets den = den - S.

If den > 0, it prints x_i.

I need to understand why this works.

Let’s see:

If x_i = den / k_i, then for each i, k_i * x_i = k_i * (den / k_i) = den.

So, k_i * x_i = den.

Now, the condition is that den > S.

Because den > S.

But S = sum_{j=1 to n} x_j = sum_{j=1 to n} (den / k_j).

So, den > sum_{j=1 to n} (den / k_j)

Divide both sides by den: 1 > sum_{j=1 to n} (1 / k_j)

So, the condition is that sum_{j=1 to n} (1 / k_j) < 1.

If this is true, then den > S, and the solution is valid.

Otherwise, if sum_{j=1 to n} (1 / k_j) >=1, then it's impossible.

So, the program is effectively checking if sum_{j=1 to n} (1 / k_j) < 1.

If it is, then it sets x_i = LCM / k_i, which satisfies the conditions.

Moreover, since LCM is a multiple of each k_i, den / k_i is an integer, so x_i are integers.

Also, since den > S, den - S >0, which is checked in the program.

So, this seems correct.

Let me verify with an example.

Take n=3, k=[3,2,7]

sum of 1/k_i = 1/3 + 1/2 + 1/7 = (14 + 21 + 6)/42 = 41/42 <1

So, solution exists.

n=2, k=[3,3]

sum=1/3 + 1/3 = 2/3 <1

n=5, k=[5,5,5,5,5]

sum=1/5 *5 =1, which is not less than 1, so -1

n=6, k=[7,9,3,17,9,13]

sum=1/7 + 1/9 + 1/3 + 1/17 + 1/9 + 1/13

Calculate:

1/7 ≈0.1429

1/9≈0.1111

1/3≈0.3333

1/17≈0.0588

1/9≈0.1111

1/13≈0.0769

Sum≈0.1429+0.1111+0.3333+0.0588+0.1111+0.0769≈0.8341 <1

n=3, k=[6,3,2]

sum=1/6 + 1/3 + 1/2 = (1 + 2 + 3)/6 = 6/6 =1, which is not less than 1, so -1

n=5, k=[9,4,6,8,3]

sum=1/9 + 1/4 + 1/6 + 1/8 + 1/3 = (8 + 18 + 12 + 9 + 24)/72 = 71/72 <1

So, in all these cases, the program correctly identifies when a solution exists and provides a valid solution when it does.

Also, the x_i values are within the constraints (1 ≤ x_i ≤ 1,000,000,000).

Given that the LCM of numbers up to 20 for n up to 50 should not exceed 10^9, as the LCM of numbers up to 20 is 232792560, which is less than 10^9.

Wait, 232792560 is less than 10^9, so den = LCM, and x_i = LCM / k_i, which should be at least LCM/20, which is at least 232792560 /20 = 11639628, which is still less than 10^9.

Wait, but in the first sample, x_i were 27,41,12, which are smaller.

Wait, perhaps I miscalculated.

Wait, no, 232792560 / 20 = 11639628, which is still fine.

But in the first sample, den was 42, which is smaller.

So, perhaps in some cases, the LCM is smaller.

Anyway, the x_i values are within the constraints.

Therefore, the program is correct.

**Final Solution**

To solve this problem, we need to determine how to distribute coins among various outcomes in a game such that, regardless of which outcome wins, the total coins received are strictly greater than the total coins bet.

## Approach

1. **Understanding the Problem**:
    - We have `n` outcomes, each with a multiplier `k_i`.
    - We need to bet integer amounts `x_i` on each outcome such that the sum of all bets is less than the return from any winning outcome.
    - Mathematically, for each `i`, `k_i * x_i > sum_of_all_x_j`.

2. **Key Insight**:
    - We realize that if the sum of `1 / k_i` for all `i` is less than 1, a solution exists.
    - We use the Least Common Multiple (LCM) of all `k_i` to find suitable `x_i`.

3. **Algorithm**:
    - Calculate the LCM of all `k_i`.
    - Compute bets `x_i` as `LCM / k_i`.
    - Check if the sum of all `x_i` is less than the LCM; if so, the bets are valid.

## Solution Code

```python
from math import gcd

def func_1(a, b):
    return a * b // gcd(a, b)

def func_2():
    N = int(input().strip())
    vals = [int(r) for r in input().strip().split()]
    den = vals[0]
    for x in vals:
        den = func_1(den, x)
    vprod = [den // r for r in vals]
    total_sum = sum(vprod)
    if den > total_sum:
        print(' '.join(str(x) for x in vprod))
    else:
        print(-1)

cases = int(input())
for _ in range(cases):
    func_2()
```

## Explanation

1. **Input Handling**:
    - Read the number of test cases `t`.
    - For each test case, read `n` (number of outcomes) and the list of multipliers `k_i`.

2. **LCM Calculation**:
    - Compute the LCM of all `k_i` values using the `func_1` function, which calculates the LCM of two numbers.

3. **Bet Calculation**:
    - Calculate the bet for each outcome as `x_i = LCM / k_i`.
    - Sum all bets and check if the LCM is greater than this sum.
    - If it is, print the bets; otherwise, print `-1`.

4. **Correctness**:
    - This approach ensures that for each outcome, the return `k_i * x_i` equals the LCM, which is greater than the total sum of bets if the condition holds.
    - This satisfies the problem's requirement that the return from any winning outcome is strictly greater than the total coins bet.