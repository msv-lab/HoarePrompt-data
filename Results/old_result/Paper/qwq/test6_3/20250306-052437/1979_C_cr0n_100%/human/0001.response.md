Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n possible outcomes, and for each outcome, there's a multiplier k_i. I need to bet some integer amount of coins on each outcome such that, no matter which outcome wins, the total coins I get back are more than the total coins I bet overall.

First, I need to understand the constraints. For each test case, I'm given n (number of outcomes) and then a list of k_i values, where each k_i is at least 2 and up to 20. The problem guarantees that the sum of n over all test cases doesn't exceed 2*10^5, which means there could be up to 10^4 test cases, each with up to 50 outcomes.

The task is to find n integers x_i (bets), each at least 1 and up to 10^9, such that the sum of all x_i is less than k_i * x_i for each i. In other words, for every possible winning outcome, the return should be greater than the total coins bet.

So, mathematically, for each i from 1 to n:

Sum of all x_j for j from 1 to n < k_i * x_i

This needs to hold for all i simultaneously.

Let me try to manipulate this inequality to find a relationship between the x_i's and the k_i's.

Let S = sum of all x_j from j=1 to n.

Then, for each i, S < k_i * x_i

I can rearrange this to x_i > S / k_i

But since x_i must be integers, x_i >= ceil(S / k_i)

But this seems a bit circular because S depends on x_i.

Hmm.

Maybe I need to find a way to express x_i in terms of the other variables.

Let me consider that for each i, x_i needs to be greater than the sum of all other x_j's divided by (k_i - 1).

Wait, that might not make sense.

Let me think differently.

Suppose I fix x_i and express S in terms of x_i.

S = x_i + sum of other x_j's

Then, S < k_i * x_i

So, x_i + sum of other x_j's < k_i * x_i

Which implies sum of other x_j's < (k_i - 1) * x_i

This needs to hold for all i.

This seems tricky.

Maybe I can use the concept of least common multiple (LCM) or something similar.

Let me look at the reference solution provided.

In the code, there's a function func_1 that computes the least common multiple (LCM) of two numbers using their product divided by their greatest common divisor (GCD).

Then, in func_2, which handles each test case, it reads n and the list of k_i's.

It initializes den (which might stand for denominator or something similar) to the first k_i and then computes the LCM of den and each k_i in the list.

So, den ends up being the LCM of all k_i's.

Then, it computes vprod as den divided by each k_i, so vprod[i] = den / k_i.

Then, it calculates den - sum(vprod). Wait, den seems to be the LCM, and sum(vprod) is the sum of den / k_i for all i.

Then, it checks if den - sum(vprod) <= 0. If so, it prints -1; otherwise, it prints vprod.

Wait, this seems interesting.

Let me try to understand what's happening here.

First, it computes the LCM of all k_i's, den = LCM of k_1 to k_n.

Then, for each outcome i, it sets x_i = den / k_i.

Then, the sum S = sum(den / k_i for all i).

Then, it computes den - sum(vprod), which is den - S.

If den - S <= 0, it's impossible; else, it outputs x_i = vprod[i].

Wait, but why is it doing den - S? That seems counterintuitive.

Wait, perhaps I need to verify if this approach works.

Let me take the first test case from the example:

n = 3

k = [3, 2, 7]

LCM of 3, 2, 7 is 42.

Then, x1 = 42 / 3 = 14

x2 = 42 / 2 = 21

x3 = 42 / 7 = 6

Sum S = 14 + 21 + 6 = 41

Then, den - S = 42 - 41 = 1, which is greater than 0, so it's okay.

Now, check if S < k_i * x_i for each i:

For i=1: 41 < 3 * 14 = 42 → yes

For i=2: 41 < 2 * 21 = 42 → yes

For i=3: 41 < 7 * 6 = 42 → yes

All conditions are satisfied.

Another test case:

n=2

k=[3,3]

LCM=3

x1=3/3=1

x2=3/3=1

S=1+1=2

den - S=3-2=1 >0

Check:

2 < 3*1=3 → yes for both outcomes

Now, third test case:

n=5

k=[5,5,5,5,5]

LCM=5

x_i=5/5=1 for all i

S=1+1+1+1+1=5

den - S=5-5=0 ≤0 → print -1

Which matches the sample output.

Fourth test case:

n=6

k=[7,9,3,17,9,13]

LCM of 7,9,3,17,9,13.

First, LCM of 7 and 9 is 63.

LCM of 63 and 3 is 63.

LCM of 63 and 17 is 63*17=1071.

LCM of 1071 and 9 is still 1071.

LCM of 1071 and 13 is 1071*13/1=13923 (since 1071 and 13 are coprime).

Wait, but in the code, it's using func_1(a, b) = a*b // gcd(a,b), which is correct for LCM.

So, den=13923

Then, x_i = den / k_i:

x1=13923/7=1989

x2=13923/9=1547

x3=13923/3=4641

x4=13923/17=819

x5=13923/9=1547

x6=13923/13=1071

Sum S=1989+1547+4641+819+1547+1071=11614

den - S=13923-11614=2309 >0

Check:

11614 < 7*1989=13923 → yes

11614 < 9*1547=13923 → yes

11614 < 3*4641=13923 → yes

11614 < 17*819=13923 → yes

11614 < 9*1547=13923 → yes

11614 < 13*1071=13923 → yes

All conditions satisfied.

Fifth test case:

n=3

k=[6,3,2]

LCM of 6,3,2 is 6.

x1=6/6=1

x2=6/3=2

x3=6/2=3

S=1+2+3=6

den - S=6-6=0 ≤0 → print -1

Which matches the sample output.

Sixth test case:

n=5

k=[9,4,6,8,3]

LCM of 9,4,6,8,3.

First, LCM of 9 and 4 is 36.

LCM of 36 and 6 is 36.

LCM of 36 and 8 is 72.

LCM of 72 and 3 is 72.

So, den=72.

x1=72/9=8

x2=72/4=18

x3=72/6=12

x4=72/8=9

x5=72/3=24

S=8+18+12+9+24=71

den - S=72-71=1 >0

Check:

71 < 9*8=72 → yes

71 < 4*18=72 → yes

71 < 6*12=72 → yes

71 < 8*9=72 → yes

71 < 3*24=72 → yes

All conditions satisfied.

So, the approach seems to work based on the sample inputs.

Now, let's see why this works.

The key idea is to set x_i = LCM(k) / k_i, where LCM(k) is the least common multiple of all k_i's.

Then, the sum S = sum(LCM(k) / k_i for all i).

We need to ensure that S < k_i * x_i for all i.

Substituting x_i:

S < k_i * (LCM(k) / k_i) ⇒ S < LCM(k)

But S = sum(LCM(k) / k_i for all i)

So, S < LCM(k)

This seems contradictory because S is a sum of positive terms, each being LCM(k) divided by k_i, which are integers at least 1.

Wait, actually, S could be less than LCM(k) if the sum of 1/k_i is less than 1.

Wait, but 1/k_i is less than or equal to 1/2, since k_i >=2.

So, for n=1, S=LCM(k)/k1 < LCM(k), which is true only if LCM(k)/k1 < LCM(k), which simplifies to 1 < k1, which is true since k1 >=2.

For n=2, S=(LCM(k)/k1) + (LCM(k)/k2) < LCM(k)

This would require that 1/k1 + 1/k2 <1.

Similarly, for general n, sum(1/k_i) <1.

Wait, but in the third test case, n=5, k=[5,5,5,5,5], sum(1/5)=1, which is not less than 1, so den - S = LCM(k) - sum(LCM(k)/k_i) = LCM(k) - n*(LCM(k)/k_i) = 5 - 5*(1)=0, which is <=0, so print -1, which is correct.

In the fifth test case, n=3, k=[6,3,2], sum(1/6 + 1/3 + 1/2) = 1/6 + 2/6 + 3/6 = 6/6=1, so den - S=6-6=0, which is <=0, so print -1.

In the second test case, n=2, k=[3,3], sum(1/3 + 1/3)=2/3 <1, so den - S=3-2=1 >0.

In the first test case, n=3, k=[3,2,7], sum(1/3 + 1/2 + 1/7)= (14/42 + 21/42 + 6/42)=41/42 <1, den - S=42-41=1>0.

In the fourth test case, n=6, k=[7,9,3,17,9,13], sum(1/7 + 1/9 + 1/3 + 1/17 + 1/9 + 1/13).

Calculating this:

1/7 ≈0.142857

1/9 ≈0.111111

1/3 ≈0.333333

1/17≈0.058824

1/9≈0.111111

1/13≈0.076923

Sum ≈0.142857 + 0.111111 + 0.333333 + 0.058824 + 0.111111 + 0.076923 ≈ 0.834160 <1

So, den - S=13923 - 11614=2309 >0.

In the sixth test case, n=5, k=[9,4,6,8,3], sum(1/9 + 1/4 + 1/6 + 1/8 + 1/3)= (8/72 + 18/72 + 12/72 + 9/72 + 24/72)=71/72 <1, den - S=72-71=1>0.

So, it seems that den - S = LCM(k) - sum(LCM(k)/k_i) = LCM(k)*(1 - sum(1/k_i)).

Since LCM(k) is positive, den - S >0 if and only if sum(1/k_i) <1.

Therefore, the condition den - S >0 is equivalent to sum(1/k_i) <1.

This makes sense because for the inequalities S < k_i * x_i to hold for all i, which simplifies to S < LCM(k), and S = sum(LCM(k)/k_i), so S < LCM(k) implies sum(LCM(k)/k_i) < LCM(k), which divides both sides by LCM(k) to get sum(1/k_i) <1.

Hence, the solution correctly checks if sum(1/k_i) <1, and if so, provides a valid set of x_i's as LCM(k)/k_i.

Moreover, since k_i >=2 and n <=50, sum(1/k_i) can be less than 1, making a solution possible, or greater than or equal to 1, making it impossible.

This seems to be a correct approach.

Therefore, the given program is correct.

**Final Answer**

\[ \boxed{\text{True}} \]