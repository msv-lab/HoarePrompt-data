Alright, I have this problem to solve. It's about a game that Alice and Bob are playing with their wallets, each containing some coins. They take turns, and Alice goes first. In each turn, the player can choose to exchange wallets with the opponent or keep their current wallet, and then remove one coin from their current wallet. The player who can't make a valid move loses. I need to determine who wins if both play optimally.

First, I need to understand the game mechanics clearly. So, in each turn:

1. The player chooses to exchange wallets or keep the current one.

2. Then, they remove one coin from their current wallet.

Also, the wallet can't have zero coins before removing a coin. So, if a player's wallet has zero coins, they can't remove a coin and thus lose.

Given that both play optimally, I need to find out who wins for given values of a and b, where a is the number of coins in Alice's wallet and b is the number of coins in Bob's wallet.

Let's look at the example provided:

Input:

10

1 1

1 4

5 3

4 5

11 9

83 91

1032 9307

839204 7281

1000000000 1000000000

53110 2024

Output:

Bob

Alice

Bob

Alice

Bob

Bob

Alice

Alice

Bob

Bob

Looking at the first test case: 1 1

Output: Bob

From the note, it explains that Alice chooses not to swap, so a=0, b=1. Then Bob chooses not to swap, so a=0, b=0. Alice can't make a move, so Bob wins.

Second test case: 1 4

Output: Alice

Explanation in the note: Alice swaps, so a=3, b=1. Bob swaps, a=1, b=2. Alice doesn't swap, a=0, b=2. Bob doesn't swap, a=0, b=1. Alice swaps, a=0, b=0. Bob can't make a move, so Alice wins.

From these examples, it seems that the winner depends on the parity of the sum of a and b.

Looking at the program provided:

def func():

test = int(input())

for t in range(test):

(a, b) = map(int, input().split())

if a + b & 1 == 0:

print('Bob')

else:

print('Alice')

It's checking if the sum of a and b is even or odd. If it's even, Bob wins; else, Alice wins.

Let me verify this logic with the examples:

1. 1 + 1 = 2, which is even → Bob wins. Correct.

2. 1 + 4 = 5, which is odd → Alice wins. Correct.

3. 5 + 3 = 8, even → Bob wins. Correct.

4. 4 + 5 = 9, odd → Alice wins. Correct.

5. 11 + 9 = 20, even → Bob wins. Correct.

6. 83 + 91 = 174, even → Bob wins. Correct.

7. 1032 + 9307 = 1032 + 9307 = 1032 is even, 9307 is odd, so sum is odd → Alice wins. Correct.

8. 839204 + 7281 = 839204 is even, 7281 is odd, sum is odd → Alice wins. Correct.

9. 1000000000 + 1000000000 = even + even = even → Bob wins. Correct.

10. 53110 + 2024 = both even → sum even → Bob wins. Correct.

All the examples match the program's output. So, it seems the logic is correct.

But I should think deeper to confirm.

Let me consider the game as a Nim game or something similar, where the number of coins represents the number of objects in a heap.

In standard Nim, the XOR of the heap sizes determines the winner. But here, the game is different because of the swapping option.

Given that players can choose to swap wallets or not, and then remove one coin from their current wallet, it's similar to choosing which heap to remove a coin from, but with an additional swapping option.

However, the program is simply checking the parity of the sum of a and b.

Let me see if I can find a general strategy based on the sum's parity.

Suppose a + b is even.

Then, if Alice can force the game into a state where a + b remains even, Bob will always face an even sum, and eventually, when a + b = 0, which is even, Bob loses.

Wait, but in the first example, a + b = 2, even, and Bob wins. So maybe it's the opposite.

Wait, in the first example, a + b = 2, even, and Bob wins. In the second example, a + b = 5, odd, Alice wins.

So, perhaps when a + b is even, Bob wins, and when a + b is odd, Alice wins.

Let me try to see why this might be the case.

Let me consider the game in terms of the total number of coins.

Total coins are a + b.

Each move, one coin is removed from the total, since the player removes one coin from their wallet.

However, the swapping complicates things because it allows players to choose which wallet to deplete.

But in the end, each move reduces the total by one coin.

The game ends when a player cannot remove a coin, which happens when their current wallet has zero coins.

But since they can swap, they can choose which wallet to deplete.

Wait, but they have to choose before removing the coin.

So, in each turn:

1. Choose to swap or not.

2. Remove one coin from the current wallet.

The current wallet must have at least one coin before removing.

So, the game is about managing the wallets' coins such that the opponent is forced to face a situation where their wallet has zero coins, and they can't swap to the other wallet if it also has zero coins.

But in reality, since they can choose to swap or not, they can always choose the wallet with coins, unless both wallets have zero coins.

Wait, but once one wallet reaches zero coins, the player whose turn it is and who has that wallet must remove a coin, but their wallet has zero coins, so they lose.

But if they swap, they take the opponent's wallet, which might have coins or not.

Wait, in the first example:

a=1, b=1

Alice's turn:

- Choose not to swap: keeps a=1, then removes one coin, a=0, b=1.

- Now, Bob has b=1, chooses not to swap, removes one coin, b=0.

- Now, a=0, b=0.

- Alice's turn: a=0, can't remove a coin, so Bob wins.

Alternative scenario:

- Alice chooses to swap: a=1, b=1 -> a=1, b=1 (same as before).

So, same outcome.

In the second example:

a=1, b=4

Alice's turn:

- Choose to swap: a=4, b=1.

- Remove one coin from a: a=3, b=1.

Bob's turn:

- Choose to swap: a=1, b=3.

- Remove one coin from a: a=0, b=3.

Alice's turn:

- Can only choose b=3, since a=0.

- Choose not to swap: b=3 -> b=2.

Bob's turn:

- Choose not to swap: b=2 -> b=1.

Alice's turn:

- Choose not to swap: b=1 -> b=0.

Bob's turn:

- a=0, b=0 -> Bob can't make a move, so Alice wins.

So, in this case, Alice wins.

Looking for a general strategy:

Let me think in terms of the total number of coins.

Total coins = a + b.

Each move reduces the total by one coin.

The game ends when a player can't make a move, which happens when their current wallet has zero coins, and they can't swap to a non-zero wallet.

But since they can choose to swap or not, they can always choose the wallet with coins, unless both are zero.

So, the game ends when the total number of coins is zero.

Wait, but the player who faces zero total coins can't make a move, so the previous player wins.

Wait, but in the first example, total coins go from 2 to 1 to 0, and Bob wins.

Alice made the first move, reducing total from 2 to 1, then Bob from 1 to 0, then Alice can't move.

So, Bob wins when total coins are even.

In the second example, total coins are 5, which is odd, Alice wins.

So, it seems that if the total number of coins is even, Bob wins; if odd, Alice wins.

Wait, but why does the program check a + b & 1 == 0 to print 'Bob'.

That's equivalent to checking if a + b is even.

So, if a + b is even, Bob wins; else, Alice wins.

This seems to match the examples.

Let me try to generalize this.

Total coins = a + b.

Players take turns, starting with Alice.

Each move reduces the total by one coin.

The game continues until total coins reach zero.

The player who faces zero coins loses, because they can't make a move.

So, if total coins are even, Bob wins; if odd, Alice wins.

Wait, but in standard Nim game theory, the XOR of the heap sizes determines the winner.

But here, since there are two heaps, a and b, the XOR would be a XOR b.

But in this problem, it's different because of the swapping option.

But in this case, the program is checking a + b is even or odd.

Let me see if a + b even or odd correlates with the XOR.

Wait, a + b even means a and b are both even or both odd.

a + b odd means one is even and one is odd.

But in terms of XOR, a XOR b is non-zero if a and b are different, and zero if a and b are the same.

Wait, but that doesn't directly correlate with a + b being even or odd.

So, maybe there's a different way to look at it.

Let me consider the game as a sequence of moves where each move reduces the total by one, and the player who faces zero total loses.

This is similar to a game where the total number of moves is equal to a + b.

Since Alice starts, if the total number of moves is even, Bob makes the last move and wins; if odd, Alice makes the last move and wins.

Wait, that seems to make sense.

Total moves = a + b.

If a + b is even, Bob makes the last move and wins.

If a + b is odd, Alice makes the last move and wins.

This matches the program's logic.

So, the program is correct.

Therefore, Correctness: **True**

**Final Solution**

To solve this problem, we need to determine the winner of a game between Alice and Bob based on the number of coins in their wallets, assuming both play optimally.

## Approach

1. **Problem Analysis**:
   - Alice and Bob take turns with Alice starting first.
   - Each player can choose to swap wallets or keep their current wallet and then remove one coin from their chosen wallet.
   - The game continues until a player cannot make a move (i.e., their current wallet has zero coins), resulting in their loss.

2. **Insight**:
   - The total number of moves possible is equal to the sum of coins in both wallets (`a + b`).
   - Since Alice starts, if the total number of moves is odd, Alice will make the last move and win; otherwise, Bob will make the last move and win.

3. **Optimal Strategy**:
   - If `a + b` is odd, Alice wins.
   - If `a + b` is even, Bob wins.

## Solution Code

```python
def func():
    test = int(input())
    for t in range(test):
        a, b = map(int, input().split())
        if (a + b) & 1 == 0:
            print('Bob')
        else:
            print('Alice')

# Example Usage
# func()
```

## Explanation

- **Step-by-step Reasoning**:
  - Read the number of test cases.
  - For each test case, read the values of `a` and `b`.
  - Check the parity of the sum `a + b`:
    - If `a + b` is even, print "Bob".
    - If `a + b` is odd, print "Alice".

- **Efficiency**:
  - Time Complexity: O(1) per test case, as it involves simple arithmetic and bitwise operations.
  - Space Complexity: O(1), as no additional space is required beyond a few variables.

This approach ensures that we efficiently determine the winner based on the parity of the sum of coins in Alice's and Bob's wallets, leveraging the insight that the total number of moves dictates the outcome when both players play optimally.