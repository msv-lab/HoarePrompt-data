Alright, I've got this problem to solve. Let's see what it's about. So, Alice and Bob are playing a game with their wallets. Alice has 'a' coins, and Bob has 'b' coins. They take turns, with Alice going first. In each turn, the player can choose to exchange wallets with the opponent or keep their current wallets. Then, they remove one coin from their current wallet, and the wallet can't have zero coins before removing.

The player who can't make a valid move loses. We need to determine who wins if both play optimally.

First, I need to understand the game mechanics properly. So, each turn consists of two steps:

1. Choose to exchange wallets or keep the current one.

2. Remove one coin from the current wallet.

Also, the wallet can't have zero coins before removing one. So, if a player's wallet has zero coins, they can't remove a coin and thus can't make a move, leading to a loss.

Given that both play optimally, I need to find a strategy that leads to a win for either Alice or Bob.

Let me consider some small test cases to see if I can find a pattern or a general rule.

Test case 1:

a = 1, b = 1

Let's see what happens:

- Alice's turn:

- Option 1: Don't swap. Then a becomes 0, b remains 1.

- Option 2: Swap. Then a becomes 1, b becomes 0.

- If Alice chooses not to swap:

- Now a=0, b=1.

- Bob's turn:

- Bob must not swap because his wallet has 1 coin.

- Remove 1 coin: b becomes 0.

- Now a=0, b=0.

- Alice's turn:

- Both wallets are empty; Alice can't make a move. So, Bob wins.

- If Alice chooses to swap:

- a=1, b=0.

- Bob's turn:

- Bob must not swap because his wallet has 0 coins.

- But he can't remove a coin because his wallet is empty.

- So, Alice wins.

Wait, in the note, it says that in the first test case, Bob wins. So, apparently, Alice choosing not to swap leads to Bob winning, while choosing to swap leads to Alice winning. But since Alice plays optimally, she should choose the option that leads to her win. However, in the example, Bob wins. So, maybe there's more to it.

Let me look at another test case.

Test case 2:

a = 1, b = 4

- Alice's turn:

- Option 1: Don't swap. a=0, b=4.

- Bob's turn:

- Must not swap because a=0.

- Remove 1 from b: b=3.

- Alice's turn:

- a=0, b=3.

- Alice must swap to have a non-zero wallet.

- After swap: a=3, b=0.

- Remove 1 from a: a=2, b=0.

- Bob's turn:

- a=2, b=0.

- Must not swap.

- Remove 1 from a: a=1, b=0.

- Alice's turn:

- a=1, b=0.

- Choose not to swap.

- Remove 1 from a: a=0, b=0.

- Bob's turn:

- Both wallets empty; Bob can't make a move. Alice wins.

- Option 2: Swap. a=4, b=1.

- Bob's turn:

- Option 1: Don't swap. a=4, b=0.

- Alice's turn:

- a=4, b=0.

- Choose not to swap.

- Remove 1 from a: a=3, b=0.

- And so on, until a=0, b=0.

- Alice wins.

Wait, in the example, it's said that Alice wins in this case. So, perhaps the key is whether a + b is odd or even.

Looking back at the first test case: a=1, b=1; a+b=2, which is even; Bob wins.

Second test case: a=1, b=4; a+b=5, which is odd; Alice wins.

Let me check another test case.

Test case 3:

a=5, b=3; a+b=8, even; Bob wins.

Test case 4:

a=4, b=5; a+b=9, odd; Alice wins.

Test case 5:

a=11, b=9; a+b=20, even; Bob wins.

Test case 6:

a=83, b=91; a+b=174, even; Bob wins.

Test case 7:

a=1032, b=9307; a+b=10339, odd; Alice wins.

Test case 8:

a=839204, b=7281; a+b=846485, odd; Alice wins.

Test case 9:

a=1000000000, b=1000000000; a+b=2000000000, even; Bob wins.

Test case 10:

a=53110, b=2024; a+b=55134, even; Bob wins.

Looking at the output:

Bob

Alice

Bob

Alice

Bob

Bob

Alice

Alice

Bob

Bob

Wait, in test case 6: a=83, b=91; a+b=174, even; output is Bob.

But according to my earlier assumption, a+b even should mean Bob wins, which matches.

Wait, but test case 7: a=1032, b=9307; a+b=10339, odd; output is Alice.

Similarly, test case 8: a=839204, b=7281; a+b=846485, odd; output is Alice.

Test case 9: a=1000000000, b=1000000000; a+b=2000000000, even; output is Bob.

Test case 10: a=53110, b=2024; a+b=55134, even; output is Bob.

So, it seems that when a+b is even, Bob wins, and when a+b is odd, Alice wins.

But in the first test case, a=1, b=1; a+b=2, even; output is Bob.

In the second test case, a=1, b=4; a+b=5, odd; output is Alice.

This matches.

So, perhaps the winner is determined by the parity of a+b.

If a+b is even, Bob wins; else, Alice wins.

But is this always true?

Wait, perhaps there's a mathematical pattern here.

Let me think about the game in terms of game theory.

This seems similar to the Nim game, where players reduce the number of objects in heaps.

In this case, there are two heaps: a and b coins.

But there's an additional twist with the option to swap wallets.

I need to model this game to understand the winning strategy.

Let's think recursively.

Define the game state as (a, b), where a and b are the number of coins in Alice's and Bob's wallets, respectively.

Alice moves first.

A move consists of:

1. Choosing to swap or not.

2. Removing one coin from the current wallet.

The player who can't make a move loses.

To determine who wins, I need to see who can force the opponent into a losing position.

A losing position is when a player cannot make a move, i.e., both wallets are empty.

Wait, no. The player cannot make a move when their current wallet has zero coins and they choose not to swap, or swapping would still result in a zero coin wallet.

Wait, let's think differently.

Let's consider the total number of coins: s = a + b.

Each move reduces the total number of coins by one.

The game ends when s = 0.

The player who faces s = 0 loses.

But the twist is the option to swap wallets.

This swapping option allows players to choose which wallet to deplete.

So, perhaps the game is equivalent to choosing which heap to remove a coin from, with the added option to switch which heap is which.

But in standard Nim game terms, having two heaps where players can choose which heap to reduce is similar to Nim game with two heaps.

In standard Nim, the winning strategy is based on the XOR of the heap sizes.

But here, there's a subtraction of one and an option to swap.

Wait, perhaps it's similar to Nim with two heaps where each move consists of decrementing one heap by one.

But the swap adds a twist.

Let me try to model this.

Let me consider that swapping allows players to switch which heap they are reducing.

So, effectively, they can choose which heap to reduce by one each turn.

Then, the game would end when both heaps are zero.

The player who faces both heaps zero loses.

This seems similar to the standard Nim game, where the last player to move wins.

But in this case, the last player to move loses because they are the one who can't make a move after that.

Wait, no.

In this game, the player who can't make a move loses.

So, the player who reduces one of the heaps to zero and the opponent still has a non-zero heap can still play.

Wait, it's a bit confusing.

Let me think differently.

Let me consider the parity of a + b.

In the first test case, a=1, b=1; a+b=2, even; Bob wins.

Second test case, a=1, b=4; a+b=5, odd; Alice wins.

Third test case, a=5, b=3; a+b=8, even; Bob wins.

Fourth test case, a=4, b=5; a+b=9, odd; Alice wins.

And so on.

It seems consistent that if a+b is even, Bob wins; else, Alice wins.

Is there a pattern here?

Let me see.

Suppose a + b is even.

Then, the total number of moves is a + b.

Since Alice starts, if the total number of moves is even, then Bob makes the last move, meaning Alice can't make a move after that, so Bob wins.

Similarly, if a + b is odd, Alice makes the last move, meaning Bob can't make a move after that, so Alice wins.

But wait, in the first test case, a=1, b=1; a+b=2, even; Bob wins.

Second test case, a=1, b=4; a+b=5, odd; Alice wins.

This seems to hold.

But in standard Nim game terms, the winner is determined by the XOR of the heap sizes.

But in this case, since each move reduces one coin from one heap, it's similar to subtracting one from one heap.

But the swap option allows players to choose which heap to subtract from.

So, effectively, they can choose any non-empty heap to subtract one from.

Thus, the game is equivalent to subtracting one from any non-empty heap, and the player who can't make a move loses.

This is similar to the standard Nim game with subtraction by one.

In such a game, the winning strategy depends on the parity of the total number of coins.

If the total number of coins is even, the second player wins; else, the first player wins.

Wait, but in standard Nim, the winner is determined by the XOR of the heap sizes.

In this case, since each move subtracts one from any heap, it's similar to Nim with allowed moves being subtracting one.

In such a game, the winning strategy is based on the total number of coins.

If the total number of coins is even, the second player wins; else, the first player wins.

But in our earlier test cases, when a+b is even, Bob (second player) wins; when a+b is odd, Alice (first player) wins.

This seems to match.

Therefore, the program provided:

def func():

test = int(input())

for t in range(test):

(a, b) = map(int, input().split())

if a + b & 1 == 0:

print('Bob')

else:

print('Alice')

This program checks if a + b is even; if so, Bob wins; else, Alice wins.

This seems correct based on the analysis above.

But to confirm, let's think about a larger test case.

Test case:

a=1000000000, b=1000000000; a+b=2000000000, even; Bob wins.

Another test case:

a=53110, b=2024; a+b=55134, even; Bob wins.

Another one:

a=1032, b=9307; a+b=10339, odd; Alice wins.

Seems consistent.

But let's think about the swap option.

Does the swap option change this conclusion?

In the standard Nim game, players can choose any heap to reduce, similar to choosing which wallet to remove a coin from.

The swap option allows players to switch the wallets, which is like choosing which heap to play from.

But in standard Nim, players can already choose which heap to reduce.

Therefore, the swap option doesn't change the game's nature because players can already choose which heap to reduce by selecting the corresponding wallet.

Hence, the game is equivalent to standard Nim with multiple heaps, where each move consists of reducing one heap by one.

In such a game, the winner is determined by the parity of the total number of coins.

Therefore, the provided program is correct.

**Final Answer**

\boxed{\text{if } a + b \text{ is even, Bob wins; else, Alice wins}}