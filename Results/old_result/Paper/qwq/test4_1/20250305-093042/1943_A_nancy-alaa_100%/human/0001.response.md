Alright, I have this problem to solve. Let's read it carefully.

So, there's this game between Alice and Bob involving an array of integers. Alice starts with an empty array c. They take turns, with Alice going first. On Alice's turn, she picks an element from array a, appends it to c, and deletes it from a. On Bob's turn, he picks an element from a, and deletes it from a. The game ends when a is empty, and the score is the MEX of c, which is the smallest non-negative integer not in c.

Alice wants to maximize the score, and Bob wants to minimize it. I need to find the final score if both play optimally.

First, I need to understand what MEX is. MEX of an array is the smallest non-negative integer not present in it. For example:

- MEX of [2,2,1] is 0 (since 0 is missing).

- MEX of [3,1,0,1] is 2 (0 and 1 are present, 2 is missing).

- MEX of [0,3,1,2] is 4 (0,1,2,3 are present, 4 is missing).

So, the game is about choosing elements to include in c (only Alice does that), and the final score is the MEX of c.

Now, Alice and Bob are playing optimally. Alice wants to maximize the MEX, and Bob wants to minimize it.

I need to think about how their turns affect the MEX.

Let's consider that the total number of turns is n, since they remove one element each turn.

Alice gets to choose which element goes into c on her turns, and Bob just removes an element on his turns.

Wait, actually, Alice chooses an element to append to c and then deletes it from a, while Bob just chooses an element to delete from a.

So, Alice is selecting elements for c, and Bob is removing elements from a, but not necessarily from c.

Wait, no, Bob deletes the element from a, which means it's no longer available, whether it's in c or not.

Wait, actually, Alice appends the element to c and then deletes it from a, so she's selecting elements to include in c.

Bob just deletes an element from a, without adding it to c.

So, overall, c will contain elements chosen only by Alice, and Bob is just removing elements from a, potentially preventing Alice from choosing them.

Wait, no, Bob deletes elements from a, which might be elements that Alice hasn't chosen yet.

So, the game is that Alice chooses elements to include in c and removes them from a, and Bob removes elements from a, which are not included in c.

The game ends when a is empty, and the score is the MEX of c.

I need to find the MEX of c when both play optimally.

Let me try to rephrase the rules:

- There are n elements in a initially.

- Players take turns; Alice starts.

- On Alice's turn: Choose an element from a, append it to c, remove it from a.

- On Bob's turn: Choose an element from a, remove it from a.

- The game ends when a is empty.

- Score is MEX of c.

- Alice wants to maximize MEX, Bob wants to minimize it.

I need to find the final score when both play optimally.

I need to think about what Alice and Bob can do to influence the MEX of c.

First, MEX is the smallest missing non-negative integer in c.

So, to maximize MEX, Alice wants c to contain as many small non-negative integers as possible, in order.

Similarly, Bob wants to minimize MEX, which means he wants to disrupt Alice's ability to include small integers in c.

Let's consider some examples.

Example 1:

n = 4

a = [0,0,1,1]

Possible game:

- Alice chooses 1, c = [1], a = [0,0,1]

- Bob chooses 0, a = [0,1]

- Alice chooses 0, c = [1,0], a = [1]

- Bob chooses 1, a = []

Final c = [1,0], MEX = 2.

Another possible game:

- Alice chooses 0, c = [0], a = [0,1,1]

- Bob chooses 1, a = [0,1]

- Alice chooses 1, c = [0,1], a = [0]

- Bob chooses 0, a = []

Final c = [0,1], MEX = 2.

So, in both cases, MEX is 2.

Is this the optimal outcome?

Can Alice achieve a higher MEX? Let's see.

Suppose Alice tries to get MEX = 3, which would require c to contain 0 and 1 and possibly other elements, but not necessarily 2, since 2 is not in a.

Wait, in this example, 2 is not in a, so Alice can't include 2 in c anyway.

Hence, MEX would be 2.

So, in this case, the answer is 2.

Example 2:

n = 4

a = [0,1,2,3]

Possible game:

- Alice chooses 0, c = [0], a = [1,2,3]

- Bob chooses 1, a = [2,3]

- Alice chooses 1, c = [0,1], a = [3]

- Bob chooses 3, a = []

Final c = [0,1], MEX = 2.

Another possible game:

- Alice chooses 1, c = [1], a = [0,2,3]

- Bob chooses 0, a = [2,3]

- Alice chooses 2, c = [1,2], a = [3]

- Bob chooses 3, a = []

Final c = [1,2], MEX = 0.

Wait, but Alice could have chosen 0 instead.

Wait, perhaps there are better strategies.

Wait, Alice wants to maximize MEX, which means she wants c to have as many small numbers as possible.

Bob wants to minimize MEX, so he wants to prevent Alice from having small numbers.

In this second example, if Alice chooses 0, then Bob can choose 1, and Alice chooses 1, then Bob chooses 3, resulting in c = [0,1], MEX = 2.

If Alice chooses 1 first, Bob chooses 0, Alice chooses 2, Bob chooses 3, c = [1,2], MEX = 0.

Wait, MEX is 0 because 0 is missing in c.

But if Alice chooses 0, then Bob chooses 1, Alice chooses 1, Bob chooses 3, c = [0,1], MEX = 2.

So, in this case, Alice can achieve a higher MEX by choosing 0 first.

Hence, the optimal play would lead to MEX = 2.

But in the sample output, it's 1 for this case.

Wait, let me check the sample output again.

Sample Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Sample Output:

2

1

0

Wait, for the second test case, the output is 1, not 2.

So, perhaps I made a mistake.

Let me think again.

In the second test case:

n = 4

a = [0,1,2,3]

Possible game:

- Alice chooses 0, c = [0], a = [1,2,3]

- Bob chooses 1, a = [2,3]

- Alice chooses 2, c = [0,2], a = [3]

- Bob chooses 3, a = []

Final c = [0,2], MEX = 1.

Another possible game:

- Alice chooses 1, c = [1], a = [0,2,3]

- Bob chooses 0, a = [2,3]

- Alice chooses 2, c = [1,2], a = [3]

- Bob chooses 3, a = []

Final c = [1,2], MEX = 0.

So, if Alice chooses 0 first, MEX = 1.

If Alice chooses 1 first, MEX = 0.

So, Alice can choose to maximize MEX by choosing 0 first, achieving MEX = 1.

Hence, the optimal outcome is MEX = 1.

Bob can force MEX to be 1 by choosing 1 in his first turn if Alice chooses 0.

Wait, in the first variation, MEX is 1.

In the second variation, MEX is 0.

So, the maximum MEX Alice can achieve is 1.

Hence, the answer is 1 for the second test case.

I see.

So, I need to find the maximum MEX Alice can achieve against Bob's opposition.

Let me try to think of a general strategy.

First, note that Alice and Bob alternate turns, with Alice starting.

Each turn, Alice chooses an element to add to c and removes it from a.

Bob just removes an element from a.

The game ends when a is empty.

The MEX is determined by c, which contains elements chosen only by Alice.

So, Alice wants c to contain as many small integers as possible, while Bob wants to prevent that.

I need to model this as a game where Alice and Bob make optimal moves.

This seems like a combinatorial game theory problem.

I need to think about the possible moves and their impacts on the final MEX.

An important observation is that Alice can choose which elements to include in c, and Bob can try to limit Alice's choices by removing elements.

Since Bob can remove elements from a, he can prevent Alice from choosing certain elements in the future.

Alice needs to strategically choose elements to include in c, considering that Bob will try to disrupt her plans.

I need to find a way to determine the optimal MEX that Alice can achieve.

Let me consider the frequency of each number in a.

Let's count the occurrences of each number in a.

For example, in the first test case:

a = [0,0,1,1]

Count:

0: 2

1: 2

So, Alice can choose to include 0 and 1 in c.

Bob can remove elements, but since there are multiple copies, Alice can still choose to include at least one of each.

In the second test case:

a = [0,1,2,3]

Count:

0:1

1:1

2:1

3:1

Here, Alice can choose to include 0 and 2, leading to c = [0,2], MEX = 1.

Or include 0 and 1, leading to c = [0,1], MEX = 2.

But Bob can interfere.

Wait, in the sample output, it's 1, so perhaps I'm missing something.

Wait, in the sample explanation, it says the output is 2 for the first test case and 1 for the second.

But in my earlier simulation, for the second test case, I thought MEX could be 2, but according to the sample output, it's 1.

Wait, perhaps I need to think differently.

Let me consider the number of times each number appears.

In the first test case, 0 appears twice and 1 appears twice.

Alice can choose to include both 0 and 1 in c, making c = [0,1], MEX = 2.

Bob cannot prevent this because even if he removes one 0 or one 1, Alice can still choose the other one.

Hence, MEX = 2.

In the second test case, each number appears once.

Alice chooses one number to include in c, and Bob removes another number.

Alice then chooses another number, and Bob removes the last one.

So, Alice can include two numbers in c.

To maximize MEX, she should choose the smallest possible numbers.

If she chooses 0 and 1, c = [0,1], MEX = 2.

But according to the sample output, it's 1.

Wait, maybe I'm misunderstanding.

Wait, in the sample output, for the second test case, it's 1, not 2.

Wait, perhaps there's a misunderstanding in the game progression.

Let me think again.

In the second test case:

n = 4

a = [0,1,2,3]

Turns:

1. Alice chooses 0, c = [0], a = [1,2,3]

2. Bob chooses 1, a = [2,3]

3. Alice chooses 2, c = [0,2], a = [3]

4. Bob chooses 3, a = []

Final c = [0,2], MEX = 1.

Alternatively:

1. Alice chooses 1, c = [1], a = [0,2,3]

2. Bob chooses 0, a = [2,3]

3. Alice chooses 2, c = [1,2], a = [3]

4. Bob chooses 3, a = []

Final c = [1,2], MEX = 0.

So, Alice can choose to include 0 and 2, resulting in MEX = 1.

Or include 1 and 2, resulting in MEX = 0.

Hence, the best Alice can do is MEX = 1.

Hence, the answer is 1.

So, how to generalize this?

I need to find the smallest integer that Alice cannot include in c, considering Bob's interference.

In other words, Alice wants to include as many small integers as possible in c, and Bob tries to prevent her from doing so.

I need to model this.

Let me think in terms of the frequency of each number.

Suppose I have counts of each number from 0 to n.

For each number i, if it appears at least once, Alice can potentially include it in c.

But Bob can try to prevent Alice from including some numbers.

Wait, more precisely, Bob can remove elements from a, which might be elements that Alice hasn't chosen yet.

So, Bob can remove elements that Alice wants to include in c.

Wait, but Alice chooses elements to include in c and removes them from a immediately.

Bob removes elements from a, which could be elements that Alice hasn't chosen yet.

So, Bob can remove elements that Alice might want to include in c in the future.

Hence, Bob can try to remove elements that Alice wants, to force her to choose less desirable elements.

So, in the second test case, with a = [0,1,2,3], each appearing once.

Alice chooses one element to include in c and removes it.

Bob then chooses to remove another element.

Alice chooses another element to include in c, and Bob removes the last one.

Hence, Alice can include two elements in c, and Bob can remove two elements.

But in this case, since n=4 and Alice includes two elements, the MEX depends on which two elements she includes.

To maximize MEX, Alice should include the two smallest possible numbers.

If she includes 0 and 1, MEX = 2.

If she includes 0 and 2, MEX = 1.

If she includes 1 and 2, MEX = 0.

Hence, the best Alice can do is to include 0 and 2, getting MEX = 1.

But in the first test case, with a = [0,0,1,1], Alice can include both 0 and 1 in c, since she has two choices, and Bob can only remove two elements.

Hence, MEX = 2.

In the third test case, n=2, a=[1,1].

Alice chooses one 1, c=[1], a=[1].

Bob chooses to remove one 1, a=[].

Game ends with c=[1], MEX=0.

Hence, the answer is 0.

So, in general, I need to determine, for each possible MEX, whether Alice can achieve it against Bob's interference.

I need to find the highest possible MEX that Alice can achieve.

Wait, but in the problem statement, it says "the game's score is the MEX of c. Alice wants to maximize the score while Bob wants to minimize it. Find game's final score if both players play optimally."

So, I need to find the MEX that would result when both play optimally.

Given that Alice wants to maximize MEX and Bob wants to minimize it, I need to find the equilibrium, i.e., the MEX that Alice can guarantee to achieve, no matter how Bob plays.

This sounds like a minimax problem.

I need to think in terms of game theory.

Let me consider the counts of each number.

Suppose I have counts of numbers from 0 to n.

For each number i, if it appears k times, then Alice can include up to k times in c.

But Bob can try to reduce the number of times Alice can include certain numbers.

Wait, perhaps I should think in terms of the number of times Alice can include each number, considering Bob's removals.

Wait, maybe I can think in terms of the number of turns Alice has to include elements in c.

Total turns are n, with Alice and Bob each getting n//2 turns (if n is even) or Alice getting one more turn (if n is odd).

Wait, in each turn, Alice chooses an element to include in c and removes it from a.

Bob chooses an element to remove from a.

So, in total, Alice includes floor((n+1)/2) elements in c.

Because Alice starts and has one more turn if n is odd.

Wait, let's think about the number of elements Alice can include in c.

Total turns: n.

Alice's turns: ceil(n/2).

Bob's turns: floor(n/2).

Hence, Alice includes ceil(n/2) elements in c.

So, c will have ceil(n/2) elements.

But the problem is which elements Alice can include.

Bob can try to remove elements that Alice wants to include.

Hence, it's like Alice wants to include certain elements, and Bob tries to prevent her from doing so.

This seems complex.

Let me look for a pattern or a simpler way to compute the MEX.

Looking back at the sample inputs:

First test case:

n=4, a=[0,0,1,1]

Alice can include 0 and 1, so c=[0,1], MEX=2.

Second test case:

n=4, a=[0,1,2,3]

Alice can include 0 and 2, so c=[0,2], MEX=1.

Third test case:

n=2, a=[1,1]

Alice includes one 1, c=[1], MEX=0.

So, in each case, the MEX is determined by which numbers Alice can include in c.

I need to find the smallest number that Alice cannot include in c, considering Bob's interference.

Wait, perhaps I can think in terms of availability.

For each number i from 0 to n:

- If i is not in a, then MEX is i.

- Else, check if Alice can include i in c.

But Bob can try to prevent Alice from including i.

So, I need to see if Alice can guarantee to include i in c, despite Bob's removals.

Let me think about the frequency of i.

If a number i appears k times in a, and Alice needs to include at least one in c, then Bob can try to reduce the number of times Alice can include i.

Wait, perhaps I can think in terms of the number of times Alice can include i, given that Bob can remove elements.

This seems tricky.

Let me look for another approach.

Perhaps I can think about the game in terms of selecting elements to include in c, and Bob can block certain selections.

Wait, maybe I can consider the game as a selection game where Alice tries to select certain elements, and Bob tries to prevent her from selecting others.

An alternative approach is to think about the final composition of c.

c will have ceil(n/2) elements.

I need to find the smallest number from 0 to n that is not in c.

But determining which elements Alice can include is complex due to Bob's interference.

Wait, perhaps I can iterate through the possible MEX values and see if Alice can force that MEX.

To find the MEX, I need to find the smallest i that is not in c.

So, for each i from 0 to n:

- Check if Alice can ensure that i is not in c, or that i is in c.

Wait, actually, Alice wants to maximize MEX, which means she wants higher MEX, meaning she wants to have as many small numbers in c as possible.

Bob wants to minimize MEX, meaning he wants to prevent Alice from having small numbers in c.

Hence, to find the final MEX, I need to find the smallest i such that Alice cannot guarantee that i is in c.

Wait, perhaps I need to find the smallest i where, no matter how Alice plays, Bob can ensure that i is not in c.

That would be the MEX that Bob can force, which is what we need to find.

Wait, perhaps I need to find the smallest i where Bob can prevent Alice from including i in c.

Alternatively, Alice can include i in c if she has enough "power" to do so, meaning she has sufficient occurrences of i to overcome Bob's removals.

Wait, perhaps I can think in terms of the number of times i appears in a and how many times Alice can include it despite Bob's removals.

Let me formalize this.

Let count[i] be the number of times i appears in a.

Alice and Bob take turns, with Alice starting.

Alice includes one element in c and removes it from a.

Bob removes one element from a.

So, for each i, the number of times Alice can include i in c is limited by the number of times i appears and how Bob removes elements.

Wait, perhaps I can model this as:

For each i, the number of times Alice can include i in c is:

- If count[i] > floor((n - count[i])/2), then Alice can include at least one i in c.

Wait, perhaps I need to think in terms of the number of times Bob can remove i.

If count[i] is the number of i's, and Bob can remove floor(n/2) elements, but not necessarily i's.

Wait, this seems too vague.

Let me try to think differently.

Suppose I try to ensure that a particular i is included in c.

To ensure that i is included in c, Alice needs to choose i when it's available, before Bob removes it.

But Bob can try to remove i to prevent Alice from including it.

So, for Alice to include i at least once, she needs to choose i before Bob can remove all occurrences of it.

Hence, if count[i] > floor((n - count[i])/2), then Alice can include at least one i in c.

Wait, perhaps.

Let me think.

Suppose count[i] = k.

Total other elements = n - k.

Bob can remove floor((n - k)/2) elements that are not i.

Hence, if k > floor((n - k)/2), then Alice can include at least one i in c.

Is this correct?

Wait, perhaps I need to think in terms of the number of turns Alice has to include i.

Total turns: n.

Alice's turns: ceil(n/2).

Bob's turns: floor(n/2).

Alice can include up to ceil(n/2) elements in c.

But Bob can remove floor(n/2) elements from a, which could be elements that Alice wants to include.

Hence, for each i, if count[i] > floor(n/2), then Alice can include at least one i in c.

Because even if Bob removes floor(n/2) elements, there will still be at least one i left for Alice to choose.

Similarly, if count[i] <= floor(n/2), Bob can potentially remove all i's before Alice can choose one.

Hence, for each i from 0 to n:

- If count[i] > floor(n/2), Alice can include i in c.

- Else, Bob can prevent Alice from including i in c.

Hence, the MEX would be the smallest i where count[i] <= floor(n/2).

Wait, but in the sample inputs, this doesn't match.

In the first test case:

n=4, a=[0,0,1,1]

count[0]=2, count[1]=2

floor(n/2) = 2

Hence, for i=0: count[0]=2 <= floor(n/2)=2, so Bob can prevent Alice from including 0 in c.

for i=1: count[1]=2 <= floor(n/2)=2, so Bob can prevent Alice from including 1 in c.

Hence, MEX should be 0, but in the sample output, it's 2.

Wait, that doesn't match.

In the second test case:

n=4, a=[0,1,2,3]

count[0]=1, count[1]=1, count[2]=1, count[3]=1

floor(n/2)=2

Hence, for i=0: count[0]=1 <=2, Bob can prevent Alice from including 0.

Hence, MEX should be 0, but in the sample output, it's 1.

This contradicts.

Wait, perhaps my earlier assumption is incorrect.

Let me think again.

If count[i] > floor(n/2), then Alice can include i in c.

But in the first test case, count[0]=2 <=2, so Bob can prevent Alice from including 0.

Hence, MEX should be 0, but sample output is 2.

So, my assumption is wrong.

Hence, my earlier logic is flawed.

I need to think differently.

Let me consider that Alice can include ceil(count[i]/2) elements in c.

Wait, perhaps.

Let me think.

For each i, the number of times Alice can include i in c is ceil(count[i]/2).

Because for each pair of i's, Alice can include one, and if there's an extra, she can include it.

Wait, perhaps.

Let me consider:

- If count[i] is odd, Alice can include ceil(count[i]/2) in c.

- If count[i] is even, Alice can include count[i]/2 in c.

But in the first test case, count[0]=2, so Alice can include 1 in c.

Similarly, count[1]=2, so Alice can include 1 in c.

Hence, c can have 0 and 1.

Hence, MEX=2.

In the second test case, count[0]=1, count[1]=1, count[2]=1, count[3]=1.

Hence, Alice can include one of them in c.

To maximize MEX, she would choose the smallest possible numbers.

So, if she includes 0 and 1, MEX=2.

But in the sample output, it's 1.

Hence, perhaps Bob can prevent Alice from including both 0 and 1.

Wait, in the second test case, n=4, Alice has ceil(4/2)=2 turns to include elements in c.

Bob has floor(4/2)=2 turns to remove elements.

Suppose Alice includes 0 and 2, then c=[0,2], MEX=1.

Alternatively, if Alice includes 0 and 1, c=[0,1], MEX=2.

But Bob can interfere.

Wait, perhaps Bob can force Alice to have MEX=1.

For example:

- Alice includes 0, c=[0], a=[1,2,3]

- Bob removes 1, a=[2,3]

- Alice includes 2, c=[0,2], a=[3]

- Bob removes 3, a=[]

Final c=[0,2], MEX=1.

Alternatively:

- Alice includes 1, c=[1], a=[0,2,3]

- Bob removes 0, a=[2,3]

- Alice includes 2, c=[1,2], a=[3]

- Bob removes 3, a=[]

Final c=[1,2], MEX=0.

So, in this case, Alice can choose to have MEX=1 by including 0 and 2.

Hence, the answer is 1.

Similarly, in the first test case, Alice can include both 0 and 1, since she has two turns and Bob can only remove two elements, but Alice can choose to include both 0 and 1.

Hence, MEX=2.

In the third test case, n=2, a=[1,1]

- Alice includes 1, c=[1], a=[1]

- Bob removes 1, a=[]

Final c=[1], MEX=0.

Hence, the answer is 0.

So, perhaps the general rule is:

- Sort the unique elements in a in ascending order.

- Alice can include floor((count[i]+1)/2) elements in c.

- Then, find the smallest i that is not included in c.

Wait, in the first test case, count[0]=2, floor((2+1)/2)=1

Similarly, count[1]=2, floor((2+1)/2)=1

Hence, c can have 0 and 1, so MEX=2.

In the second test case, count[0]=1, floor((1+1)/2)=1

count[1]=1, floor((1+1)/2)=1

count[2]=1, floor((1+1)/2)=1

count[3]=1, floor((1+1)/2)=1

But Alice can only include two elements in c.

So, she includes the smallest two: 0 and 1, but in the sample output, it's 1.

Wait, no, in the sample output for the second test case, it's 1, but according to this, if she includes 0 and 1, MEX=2.

But earlier analysis shows that Bob can force MEX=1.

Hence, perhaps Alice can include floor((count[i]+1)/2) elements in c, but she has a limited number of turns.

Hence, she needs to prioritize including the smallest possible i's.

But it's not straightforward.

Perhaps I need to iterate through the possible MEX values and see if Alice can guarantee that all smaller numbers are in c.

So, for each i from 0 to n:

- Check if Alice can include all j < i in c.

- If she can, then MEX is i.

- Else, find the smallest i where she cannot include all j < i in c.

Wait, more precisely:

- For each i, check if Alice can include all j < i in c.

- The smallest i where she cannot include all j < i in c is the MEX.

But I need to find the highest i where she can include all j < i in c, and the next i is the MEX.

Wait, perhaps I need to find the smallest i where the sum of floor((count[j]+1)/2) for j < i is <= ceil(n/2).

Because Alice has ceil(n/2) turns to include elements in c.

Hence, for each i, if the sum of floor((count[j]+1)/2) for j < i is <= ceil(n/2), then Alice can include all j < i in c.

Else, Bob can prevent Alice from including all j < i in c.

Hence, the smallest i where sum(floor((count[j]+1)/2) for j < i) > ceil(n/2) is the MEX.

Wait, no.

Wait, if the sum of floor((count[j]+1)/2) for j < i is <= ceil(n/2), then Alice can include all j < i in c.

Else, Bob can prevent Alice from including all j < i in c.

Hence, the smallest i where sum(floor((count[j]+1)/2) for j < i) > ceil(n/2) cannot be achieved by Alice, and that i is the MEX.

Hence, the answer is the smallest i where sum(floor((count[j]+1)/2) for j < i) > ceil(n/2).

Wait, but in the first test case:

i=0: sum=0 <= ceil(4/2)=2

i=1: sum(floor((count[0]+1)/2))=floor((2+1)/2)=1 <=2

i=2: sum(floor((count[0]+1)/2) + floor((count[1]+1)/2))=1 +1=2 <=2

i=3: sum=2 <=2

Hence, MEX=3?

But in the sample output, it's 2.

Hence, my assumption is incorrect.

Wait, perhaps it's sum(floor((count[j]+1)/2)) >= ceil(n/2) +1.

Wait, perhaps I need to think differently.

Let me consider that Alice can include floor((count[j]+1)/2) elements of each j in c.

Then, the total number of elements Alice can include is sum(floor((count[j]+1)/2)) over all unique j.

But in the first test case, sum(floor((2+1)/2) + floor((2+1)/2))=1+1=2, which is equal to ceil(4/2)=2.

Hence, Alice can include all she needs.

But in the second test case, sum(floor((1+1)/2) for j from 0 to 3)=0+0+0+0=0 <= ceil(4/2)=2.

But according to the sample output, MEX=1.

Wait, this seems inconsistent.

Wait, perhaps I need to accumulate the floor((count[j]+1)/2) for j from 0 to i-1 and see when the sum exceeds ceil(n/2).

In the first test case:

i=0: sum=0 <=2

i=1: sum=1 <=2

i=2: sum=2 <=2

i=3: sum=2 <=2

Hence, MEX=2.

In the second test case:

i=0: sum=0 <=2

i=1: sum=0 <=2

i=2: sum=0 <=2

i=3: sum=0 <=2

Hence, MEX=3, but sample output is 1.

Hence, my assumption is wrong.

I need to think differently.

Let me look at the provided program.

def func():

for _ in range(int(input())):

n = int(input())

arr = list(map(int, input().split()))

mpp = Counter(arr)

first = False

for i in range(n + 1):

if i not in mpp.keys():

print(i)

break

if mpp[i] == 1 and first:

print(i)

break

if mpp[i] == 1:

first = True

This program is iterating through i from 0 to n:

- If i is not in mpp, print i and break.

- Else, if mpp[i] ==1 and first is True, print i and break.

- Else, if mpp[i] ==1, set first = True.

Wait, in the first test case:

mpp = {0:2, 1:2}

Iterate i from 0 to 4:

i=0: mpp[0]=2, skip

i=1: mpp[1]=2, skip

i=2: not in mpp, print 2.

Hence, output is 2, which matches the sample.

In the second test case:

mpp = {0:1,1:1,2:1,3:1}

Iterate i from 0 to 4:

i=0: mpp[0]=1, set first=True

i=1: mpp[1]=1, first=True, print 1.

Hence, output is 1, which matches the sample.

In the third test case:

mpp = {1:2}

Iterate i from 0 to 2:

i=0: not in mpp, print 0.

Hence, output is 0, which matches the sample.

So, the program seems to be correct.

But why does this logic work?

Let's analyze it.

The program checks for each i from 0 to n:

- If i is not in mpp, then it's not in a, so MEX is i.

- Else, if mpp[i] ==1 and first is True, print i.

- Else, if mpp[i] ==1, set first=True.

Wait, what is "first"?

In the code, "first" is set to True when mpp[i]==1 for the first time.

Then, for subsequent i where mpp[i]==1 and first is True, it prints i.

Wait, in the second test case:

mpp = {0:1,1:1,2:1,3:1}

Iterate i from 0 to 4:

i=0: mpp[0]=1, set first=True

i=1: mpp[1]=1 and first=True, print 1.

Hence, output is 1.

In the first test case:

mpp = {0:2,1:2}

i=0: mpp[0]=2, skip

i=1: mpp[1]=2, skip

i=2: not in mpp, print 2.

Hence, output is 2.

In the third test case:

mpp = {1:2}

i=0: not in mpp, print 0.

Hence, output is 0.

So, it seems to work, but why?

Let's think about what this code is doing.

It's finding the smallest i where either:

- i is not in a, or

- i is in a exactly once, and there is at least one other j < i that is in a exactly once.

Wait, in the second test case, it prints 1 because mpp[1]=1 and first is True (set by mpp[0]=1).

Hence, it's finding the smallest i where mpp[i]=1 and there is at least one j < i with mpp[j]=1.

Wait, but in the first test case, mpp[0]=2 and mpp[1]=2, so it goes to i=2 which is not in mpp.

Hence, MEX is 2.

In the third test case, mpp[1]=2, so i=0 is not in mpp, hence MEX=0.

So, the logic seems to be:

- Find the smallest i where either:

- i is not in a, or

- i is in a exactly once and there is at least one other j < i with mpp[j]=1.

But I need to verify if this is indeed the correct way to compute the MEX in this game.

Let me think about what Alice can achieve.

Alice can include floor((count[i]+1)/2) elements of i in c.

Bob can remove floor(n/2) elements.

Hence, for each i, the number of times Alice can include i in c is floor((count[i]+1)/2).

Hence, in c, for each i, the number of i's is at least floor((count[i]+1)/2).

Wait, but c is a multiset, but MEX is about the presence of each i at least once.

Hence, Alice can include at least floor((count[i]+1)/2) copies of i in c.

But for MEX, we only care if i is present at least once in c.

Hence, for each i, if floor((count[i]+1)/2) >=1, then Alice can include i in c.

Else, Bob can prevent Alice from including i in c.

Wait, floor((count[i]+1)/2) >=1 implies count[i] >=1.

But that's not always true.

Wait, floor((count[i]+1)/2) >=1 when count[i] >=1.

Wait, no.

floor((1+1)/2)=1

floor((2+1)/2)=1

Hence, for count[i] >=1, floor((count[i]+1)/2) >=1.

Hence, Alice can always include at least one i in c if count[i] >=1.

But in the second test case, count[0]=1, count[1]=1, count[2]=1, count[3]=1.

Hence, Alice can include one of each in c.

But in reality, she has ceil(4/2)=2 turns to include elements.

Hence, she can include two elements in c.

Hence, she can choose to include 0 and 1, making c=[0,1], MEX=2.

But according to the sample output, it's 1.

Hence, perhaps I need to consider that Alice can include only ceil(n/2) elements in c, and she needs to choose which ones to include.

Hence, she needs to prioritize including smaller numbers to maximize MEX.

But Bob can try to force Alice to include larger numbers.

Wait, perhaps I need to think in terms of the number of turns and the counts.

Let me think differently.

Suppose I sort the unique elements in a in ascending order.

Then, Alice wants to include as many small elements as possible.

Bob wants to prevent her from including small elements.

Hence, for each small element, Bob might try to remove it to prevent Alice from including it.

But Alice has some turns to include elements.

Hence, for each small element, if it appears only once, Bob can remove it before Alice can include it.

Hence, Alice needs to have multiple copies of small elements to ensure their inclusion in c.

Wait, in the first test case, 0 and 1 each appear twice.

Hence, even if Bob removes one 0 and one 1, Alice can still include one 0 and one 1.

Hence, MEX=2.

In the second test case, each of 0,1,2,3 appears once.

Hence, for each i, count[i]=1.

Hence, Alice can include one of them in c.

To maximize MEX, she would choose to include the smallest possible numbers.

Hence, she can include 0 and 1, making c=[0,1], MEX=2.

But according to the sample output, it's 1.

Hence, perhaps Bob can force Alice to have MEX=1.

Wait, perhaps Bob can remove elements in such a way that Alice cannot include both 0 and 1.

For example:

- Alice includes 0, c=[0], a=[1,2,3]

- Bob removes 1, a=[2,3]

- Alice includes 2, c=[0,2], a=[3]

- Bob removes 3, a=[]

Final c=[0,2], MEX=1.

Alternatively:

- Alice includes 1, c=[1], a=[0,2,3]

- Bob removes 0, a=[2,3]

- Alice includes 2, c=[1,2], a=[3]

- Bob removes 3, a=[]

Final c=[1,2], MEX=0.

Hence, in this scenario, Alice can choose to have MEX=1 by including 0 and 2.

Hence, the answer is 1.

Hence, perhaps the logic is:

- For each i from 0 to n:

- Count the number of times i appears in a.

- If i does not appear in a, then MEX is i.

- Else, if i appears only once, then Bob can remove it, preventing Alice from including it in c.

- Hence, if i appears only once, it cannot be included in c.

- Hence, the MEX is the smallest i where either i does not appear in a, or i appears only once and there is at least one j < i that appears only once.

Wait, in the second test case, i=0 appears once, i=1 appears once.

Hence, Alice can include one of them.

But to have MEX=1, she needs to include 0 but not 1.

Hence, perhaps the logic is:

- Find the smallest i where either:

- i does not appear in a, or

- i appears only once, and there is at least one j < i that appears only once.

Hence, in the second test case:

i=0: appears once, but no j < 0, so cannot include 0.

Hence, MEX=0.

Wait, but according to the sample output, it's 1.

Hence, perhaps my logic is still incorrect.

Wait, perhaps it's:

- Find the smallest i where either:

- i does not appear in a, or

- i appears only once, and there is at least one other j < i that appears at least once (not necessarily only once).

In the second test case:

i=0: appears once, no j < 0, cannot include 0.

Hence, MEX=0.

But sample output is 1, which contradicts.

Hence, my logic is still flawed.

I need to think differently.

Let me look back at the provided program.

def func():

for _ in range(int(input())):

n = int(input())

arr = list(map(int, input().split()))

mpp = Counter(arr)

first = False

for i in range(n + 1):

if i not in mpp.keys():

print(i)

break

if mpp[i] == 1 and first:

print(i)

break

if mpp[i] == 1:

first = True

In the second test case:

mpp = {0:1,1:1,2:1,3:1}

Iterate i from 0 to 4:

i=0: mpp[0]=1, set first=True

i=1: mpp[1]=1 and first=True, print 1.

Hence, output is 1.

In this case, Alice can choose to include 0 and 2, making c=[0,2],