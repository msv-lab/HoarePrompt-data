Alright, I've got this problem to solve. Let's see what it's asking for. So, Anton has a permutation of size n and a number x that he wants to find using a binary search. But here's the catch: the array isn't sorted, and I can only perform up to two swaps to rearrange the elements before running the binary search. The goal is to adjust the array so that after the binary search, p_l equals x.

First, I need to understand what a permutation is. A permutation of size n is just an array containing each number from 1 to n exactly once, but in any order. So, for example, [2, 3, 1] is a permutation of size 3.

Now, binary search typically works on sorted arrays. Here, we're applying it to an unsorted array, which usually wouldn't work. But the problem allows us to perform up to two swaps to make it possible for the binary search to find x correctly.

Let me try to understand the binary search algorithm as described in the problem:

- Initialize l = 1 and r = n + 1.

- While r - l > 1:

- Set m = floor((r + l) / 2).

- If p_m <= x, set l = m; else set r = m.

- After the loop, p_l should be equal to x.

Wait a second, this seems a bit off. In standard binary search, we have l = 0 and r = n, and we adjust m based on whether the middle element is less than or equal to x. But here, l starts at 1 and r at n+1, which is unusual because array indices usually start at 0.

I need to clarify the indices. In Python, arrays are 0-based, but the problem seems to be using 1-based indices for the array. So, p_1 is array[0], p_2 is array[1], and so on, up to p_n is array[n-1].

Let me adjust my understanding:

- l starts at 1 (which corresponds to array[0])

- r starts at n+1 (which is beyond the array)

- m = floor((r + l)/2)

- If p_m <= x, set l = m

- Else, set r = m

- Repeat until r - l = 1

- Finally, p_l should be equal to x.

I need to ensure that after possibly swapping two elements, this binary search ends with p_l being x.

First, I need to see how the binary search proceeds on the given array and see if I can make adjustments via swaps to make it work.

Let's consider an example from the input:

n = 6, x = 3

array = [1, 2, 3, 4, 5, 6]

Let's simulate the binary search:

- l = 1, r = 7

- m = floor((7 + 1)/2) = 4 -> p_4 = 4

- Since 4 > 3, set r = 4

- Now, l = 1, r = 4

- m = floor((4 + 1)/2) = 2 -> p_2 = 2

- Since 2 <= 3, set l = 2

- Now, l = 2, r = 4

- m = floor((4 + 2)/2) = 3 -> p_3 = 3

- Since 3 <= 3, set l = 3

- Now, l = 3, r = 4

- m = floor((4 + 3)/2) = 3 -> p_3 = 3

- Since 3 <= 3, set l = 3

- Now, r - l = 1, so loop ends.

- p_l = p_3 = 3, which is equal to x = 3.

So, in this case, no swaps are needed.

Another example:

n = 6, x = 5

array = [3, 1, 6, 5, 2, 4]

Simulate binary search:

- l = 1, r = 7

- m = floor((7 + 1)/2) = 4 -> p_4 = 5

- Since 5 <= 5, set l = 4

- Now, l = 4, r = 7

- m = floor((7 + 4)/2) = 5 -> p_5 = 2

- Since 2 <= 5, set l = 5

- Now, l = 5, r = 7

- m = floor((7 + 5)/2) = 6 -> p_6 = 4

- Since 4 <= 5, set l = 6

- Now, l = 6, r = 7

- m = floor((7 + 6)/2) = 6 -> p_6 = 4

- Since 4 <= 5, set l = 6

- Now, r - l = 1, loop ends.

- p_l = p_6 = 4, which is not equal to x = 5.

So, we need to perform swaps to make p_l = 5.

Looking at the array: [3, 1, 6, 5, 2, 4]

We need p_l to be 5. Currently, p_4 = 5, but the search ends up at p_6 = 4.

Maybe if we swap p_4 and p_5, so array becomes [3, 1, 6, 2, 5, 4]

Let's simulate:

- l = 1, r = 7

- m = 4 -> p_4 = 2

- 2 <= 5, set l = 4

- l = 4, r = 7

- m = 5 -> p_5 = 5

- 5 <= 5, set l = 5

- l = 5, r = 7

- m = 6 -> p_6 = 4

- 4 <= 5, set l = 6

- l = 6, r = 7

- m = 6 -> p_6 = 4

- 4 <= 5, set l = 6

- r - l = 1, loop ends.

- p_l = p_6 = 4, still not 5.

Not working. Maybe swap p_5 and p_6:

[3, 1, 6, 5, 4, 2]

Simulate:

- l = 1, r = 7

- m = 4 -> p_4 = 5

- 5 <= 5, set l = 4

- l = 4, r = 7

- m = 5 -> p_5 = 4

- 4 <= 5, set l = 5

- l = 5, r = 7

- m = 6 -> p_6 = 2

- 2 <= 5, set l = 6

- l = 6, r = 7

- m = 6 -> p_6 = 2

- 2 <= 5, set l = 6

- r - l = 1, loop ends.

- p_l = p_6 = 2, not 5.

Hmm, not working. Maybe swap p_3 and p_4:

[3, 1, 5, 6, 2, 4]

Simulate:

- l = 1, r = 7

- m = 4 -> p_4 = 6

- 6 > 5, set r = 4

- l = 1, r = 4

- m = 2 -> p_2 = 1

- 1 <= 5, set l = 2

- l = 2, r = 4

- m = 3 -> p_3 = 5

- 5 <= 5, set l = 3

- l = 3, r = 4

- m = 3 -> p_3 = 5

- 5 <= 5, set l = 3

- r - l = 1, loop ends.

- p_l = p_3 = 5, which is x = 5.

Great, so one swap (p_3 and p_4) achieves the goal.

So, in this case, swapping indices 3 and 4 would work.

Looking at the sample output for this case:

1

3 4

Which matches what I found.

So, the strategy seems to be: find a way to make p_l = x after at most two swaps.

But how to generalize this?

I need to find a way to adjust the array with at most two swaps so that the binary search ends with p_l = x.

Let me think about what the binary search is doing.

In each step, it's choosing a midpoint m and deciding whether to go left or right based on p_m compared to x.

Eventually, it narrows down to l and r differing by 1, and p_l should be x.

I need to ensure that after the search, p_l is x.

One approach could be to directly make sure that x is at the position where l ends up.

But l depends on the array configuration.

This seems circular.

Alternatively, perhaps I can think about where the binary search will end up and make sure that x is at that position.

But the search depends on the array, which I can modify with swaps.

Wait, maybe I can simulate the binary search on the original array and see where it ends up.

Then, if p_l is not x, I can try to adjust the array so that p_l becomes x.

But I only have two swaps to do that.

Let me consider the positions involved in the binary search path.

Perhaps if I can make x appear at the final l position, or adjust the path to go where x is, with minimal swaps.

This seems complicated.

Let me consider a simpler approach.

Since I can perform up to two swaps, I can consider swapping x to a position that would make the binary search find it.

But again, I need to know where the search will end up.

Wait, maybe I can fix l to be the position of x, but that might require too many swaps.

Alternatively, perhaps I can ensure that x is in a position that the binary search would naturally reach.

But I'm getting stuck in the same loop.

Let me look at another sample input to see if I can find a pattern.

Sample Input 3:

5 1

3 5 4 2 1

Sample Output:

2

2 4

1 5

So, n=5, x=1

array = [3, 5, 4, 2, 1]

Simulate binary search:

- l=1, r=6

- m=floor((6+1)/2)=3 -> p_3=4

- 4 > 1, set r=3

- l=1, r=3

- m=floor((3+1)/2)=2 -> p_2=5

- 5 > 1, set r=2

- l=1, r=2

- m=floor((2+1)/2)=1 -> p_1=3

- 3 > 1, set r=1

- r - l = 0, which is not >1, so loop ends.

- p_l = p_1 = 3, which is not 1.

So, need to perform swaps.

According to the sample output, perform two swaps:

Swap indices 2 and 4: [3, 2, 4, 5, 1]

Then swap indices 1 and 5: [1, 2, 4, 5, 3]

Now, simulate binary search on [1, 2, 4, 5, 3]:

- l=1, r=6

- m=3 -> p_3=4

- 4 > 1, set r=3

- l=1, r=3

- m=2 -> p_2=2

- 2 > 1, set r=2

- l=1, r=2

- m=1 -> p_1=1

- 1 <=1, set l=1

- r - l =1, loop ends.

- p_l = p_1=1, which is x=1.

Great, it works.

But how to generalize this?

It seems that with two swaps, I can adjust the array to make x end up at the correct l position.

But I need a systematic way to determine which swaps to perform.

Let me consider the following plan:

1. Simulate the binary search on the original array to see where it ends up.

2. If p_l is already x, no swaps are needed.

3. If p_l is not x, find the current position of x in the array.

4. Try to swap x to the final l position.

5. If that alone doesn't suffice, perform a second swap to adjust the path.

But this is still vague.

Let me consider another approach.

Since I can perform up to two swaps, I can consider swapping x to the position where l ends up, and if necessary, perform another swap to fix any disruptions caused by the first swap.

But this seems too vague to implement.

Let me think differently.

Perhaps I can consider that with two swaps, I can place x anywhere in the array.

Because with one swap, I can bring x to any position, and with the second swap, I can adjust another element if needed.

Wait, actually, with one swap, I can bring x to any position, but I might need to adjust another element to make the binary search path correct.

But I'm still not sure.

Let me consider that with two swaps, I can rearrange any three elements in the array.

Because two swaps can be used to perform any permutation of three elements.

Wait, actually, two swaps can generate any permutation, but in practice, two swaps can adjust up to three elements.

But perhaps I can think in terms of placing x in the desired position and adjusting at most two other elements.

But I need a clearer plan.

Let me consider the following strategy:

- Perform the binary search on the original array to find the final l.

- If p_l == x, do nothing.

- Else, find the current position of x, say pos_x.

- Swap p_l and p_{pos_x}.

- Check if now p_l == x.

- If yes, output one swap: pos_x and l.

- If not, it means that swapping x to l isn't sufficient, so I need a second swap.

- In that case, find another element that is causing the issue and swap it appropriately.

But I need to make this more concrete.

Looking back at the sample input 2:

n=6, x=5

array=[3,1,6,5,2,4]

After swapping 3 and 4, array becomes [3,1,5,6,2,4]

Simulate binary search:

- l=1, r=7

- m=4 -> p_4=6 >5, r=4

- m=2 -> p_2=1 <=5, l=2

- m=3 -> p_3=5 <=5, l=3

- m=3 -> p_3=5 <=5, l=3

- r - l =1, loop ends.

- p_l = p_3=5, which is x=5.

So, one swap sufficed.

But in the first place, why did swapping p_3 and p_4 work?

Because p_3 was 6, which is greater than 5, and p_4 was 5.

By swapping, p_3 becomes 5, and p_4 becomes 6.

Then, in the binary search:

- m=4, p_4=6 >5, so r=4

- m=2, p_2=1 <=5, so l=2

- m=3, p_3=5 <=5, so l=3

- m=3, p_3=5 <=5, so l=3

- r - l =1, loop ends.

- p_l =5, which is x=5.

So, it worked because placing x=5 at p_3 allowed the search to find it.

But how to generalize this?

Another sample input:

n=5, x=1

array=[3,5,4,2,1]

After two swaps:

Swap 2 and 4: [3,2,4,5,1]

Swap 1 and 5: [1,2,4,5,3]

Now, binary search:

- l=1, r=6

- m=3, p_3=4 >1, r=3

- m=2, p_2=2 >1, r=2

- m=1, p_1=1 <=1, l=1

- r - l=1, loop ends.

- p_l =1, which is x=1.

So, two swaps were needed here.

But what's the logic behind choosing these swaps?

It seems that the first swap moves x to position 5, and the second swap moves it to position 1.

But why these specific positions?

I need a better understanding.

Let me consider that the binary search divides the array into segments and narrows down the search based on comparisons.

But since the array is not sorted, the search can land on any position depending on the values.

Perhaps I need to ensure that x is in a position that aligns with the binary search's expected path.

But this is too vague.

Let me consider that with two swaps, I can adjust the array significantly, but I need to target specific positions that affect the binary search's path.

Wait, maybe I can identify the positions that the binary search visits and ensure that x is at one of those positions or that the path leads to x.

But I need a more concrete plan.

Let me try to think recursively about the binary search process.

Start with l=1, r=n+1.

Compute m = floor((l + r)/2).

Depending on p_m compared to x, set l or r to m, and repeat.

Eventually, l will be at a position where p_l should be x.

I need to make sure that p_l = x.

One way is to directly swap x to position l.

But I need to know what l will be before performing the swaps.

Wait, that's circular because l depends on the array configuration.

This is tricky.

Let me consider that with two swaps, I can potentially place x anywhere in the array, and adjust one other element if needed.

But I need to ensure that the binary search path leads to x.

Perhaps I can find a position that the binary search will reach and swap x there.

But I need to predict where the binary search will end up.

Wait, maybe I can simulate the binary search to find where l ends up, and then swap x to that position.

If that's possible with one swap, great; if not, use the second swap to adjust another element if needed.

Let me try this approach on the second sample input.

Sample Input 2:

6 5

3 1 6 5 2 4

Simulate binary search:

- l=1, r=7

- m=4, p_4=5 <=5, l=4

- l=4, r=7

- m=5, p_5=2 <=5, l=5

- l=5, r=7

- m=6, p_6=4 <=5, l=6

- l=6, r=7

- m=6, p_6=4 <=5, l=6

- r - l =1, loop ends.

- p_l = p_6=4, which is not 5.

So, l ends up at position 6.

Current p_6=4, but we want p_6=5.

So, swap p_6 and p_{pos_x}, where pos_x is the current position of 5, which is position 4.

Swap p_4 and p_6: [3,1,6,4,2,5]

Now, p_6=5, which is x.

Simulate binary search:

- l=1, r=7

- m=4, p_4=4 <=5, l=4

- l=4, r=7

- m=5, p_5=2 <=5, l=5

- l=5, r=7

- m=6, p_6=5 <=5, l=6

- l=6, r=7

- m=6, p_6=5 <=5, l=6

- r - l=1, loop ends.

- p_l = p_6=5, which is x=5.

So, one swap sufficed: swap p_4 and p_6.

This matches the first sample output, which used swap 3 and 4, but in this case, swap 4 and 6 works.

So, perhaps a general strategy is:

- Perform the binary search on the original array to find the final l.

- If p_l == x, do nothing.

- Else, find the current position of x, say pos_x.

- Swap p_l and p_{pos_x}.

- Check if now p_l == x.

- If yes, output one swap: pos_x and l.

- If not, perform a second swap to adjust another element.

But in the above example, one swap sufficed.

Let's see another sample input.

Sample Input 4:

6 3

4 3 1 5 2 6

Simulate binary search:

- l=1, r=7

- m=4, p_4=5 >3, r=4

- l=1, r=4

- m=2, p_2=3 <=3, l=2

- l=2, r=4

- m=3, p_3=1 <=3, l=3

- l=3, r=4

- m=3, p_3=1 <=3, l=3

- r - l=1, loop ends.

- p_l = p_3=1, which is not 3.

So, l ends up at position 3.

Current p_3=1, but we want p_3=3.

So, swap p_3 and p_{pos_x}, where pos_x is the current position of 3, which is position 2.

Swap p_2 and p_3: [4,1,3,5,2,6]

Now, p_3=3, which is x=3.

Simulate binary search:

- l=1, r=7

- m=4, p_4=5 >3, r=4

- l=1, r=4

- m=2, p_2=1 <=3, l=2

- l=2, r=4

- m=3, p_3=3 <=3, l=3

- l=3, r=4

- m=3, p_3=3 <=3, l=3

- r - l=1, loop ends.

- p_l = p_3=3, which is x=3.

So, one swap sufficed: swap p_2 and p_3.

This matches the sample output, which used two swaps, but in this case, one sufficed.

Wait, in the sample output for this case:

2

4 5

2 4

But in my approach, one swap sufficed.

So, perhaps there are multiple ways to achieve the goal with at most two swaps.

Hence, my approach seems valid, as long as I can ensure that p_l = x with at most two swaps.

Let me consider another example where one swap isn't enough.

Sample Input 3:

5 1

3 5 4 2 1

Simulate binary search:

- l=1, r=6

- m=3, p_3=4 >1, r=3

- l=1, r=3

- m=2, p_2=5 >1, r=2

- l=1, r=2

- m=1, p_1=3 >1, r=1

- r - l=0, loop ends.

- p_l = p_1=3, which is not 1.

So, l ends up at position 1.

Current p_1=3, x=1 is at position 5.

Swap p_1 and p_5: [1,5,4,2,3]

Simulate binary search:

- l=1, r=6

- m=3, p_3=4 >1, r=3

- l=1, r=3

- m=2, p_2=5 >1, r=2

- l=1, r=2

- m=1, p_1=1 <=1, l=1

- r - l=1, loop ends.

- p_l = p_1=1, which is x=1.

So, one swap sufficed here as well.

But according to the sample output, two swaps were used:

2

2 4

1 5

Which also works, but one swap would have been sufficient.

So, perhaps in some cases, one swap suffices, but in others, two are needed.

But in practice, as long as I can achieve the goal with at most two swaps, it's acceptable.

Now, I need to implement this logic.

Let me outline the steps:

1. Perform the binary search on the original array to find the final l.

2. If p_l == x, output 0 swaps.

3. Else, find the current position of x, say pos_x.

4. Swap p_l and p_{pos_x}.

5. Perform the binary search again to check if p_l == x.

- If yes, output one swap: pos_x and l.

- If not, perform a second swap to adjust another element.

But in the above examples, one swap sufficed.

Perhaps in all cases, one swap suffices, and the problem allows up to two swaps just to be safe.

But the problem says that two operations are always sufficient, so perhaps there are cases where one swap isn't enough.

Let me consider such a case.

Suppose n=4, x=2

array = [4,1,3,2]

Simulate binary search:

- l=1, r=5

- m=3, p_3=3 >2, r=3

- l=1, r=3

- m=2, p_2=1 <=2, l=2

- l=2, r=3

- m=2, p_2=1 <=2, l=2

- r - l=1, loop ends.

- p_l = p_2=1, which is not 2.

So, l ends up at position 2.

Current p_2=1, x=2 is at position 4.

Swap p_2 and p_4: [4,2,3,1]

Simulate binary search:

- l=1, r=5

- m=3, p_3=3 >2, r=3

- l=1, r=3

- m=2, p_2=2 <=2, l=2

- l=2, r=3

- m=2, p_2=2 <=2, l=2

- r - l=1, loop ends.

- p_l = p_2=2, which is x=2.

So, one swap sufficed.

Another example:

n=4, x=3

array = [1,4,2,3]

Simulate binary search:

- l=1, r=5

- m=3, p_3=2 <=3, l=3

- l=3, r=5

- m=4, p_4=3 <=3, l=4

- l=4, r=5

- m=4, p_4=3 <=3, l=4

- r - l=1, loop ends.

- p_l = p_4=3, which is x=3.

So, no swaps needed.

Wait, but suppose x=2.

array = [1,4,2,3]

Simulate binary search:

- l=1, r=5

- m=3, p_3=2 <=2, l=3

- l=3, r=5

- m=4, p_4=3 >2, r=4

- l=3, r=4

- m=3, p_3=2 <=2, l=3

- r - l=1, loop ends.

- p_l = p_3=2, which is x=2.

So, no swaps needed.

Another example where one swap suffices.

Wait, maybe in all cases, one swap suffices, and the problem allows two swaps to cover those cases.

But according to the problem statement, "It can be shown that 2 operations are always sufficient."

So, there must be cases where two swaps are necessary.

Let me try to find such a case.

Consider n=5, x=2

array = [3,5,4,1,2]

Simulate binary search:

- l=1, r=6

- m=3, p_3=4 >2, r=3

- l=1, r=3

- m=2, p_2=5 >2, r=2

- l=1, r=2

- m=1, p_1=3 >2, r=1

- r - l=0, loop ends.

- p_l = p_1=3, which is not 2.

So, l ends up at position 1.

Current p_1=3, x=2 is at position 5.

Swap p_1 and p_5: [2,5,4,1,3]

Simulate binary search:

- l=1, r=6

- m=3, p_3=4 >2, r=3

- l=1, r=3

- m=2, p_2=5 >2, r=2

- l=1, r=2

- m=1, p_1=2 <=2, l=1

- r - l=1, loop ends.

- p_l = p_1=2, which is x=2.

So, one swap sufficed.

Another example:

n=6, x=4

array = [5,3,6,2,1,4]

Simulate binary search:

- l=1, r=7

- m=4, p_4=2 <=4, l=4

- l=4, r=7

- m=5, p_5=1 <=4, l=5

- l=5, r=7

- m=6, p_6=4 <=4, l=6

- l=6, r=7

- m=6, p_6=4 <=4, l=6

- r - l=1, loop ends.

- p_l = p_6=4, which is x=4.

So, no swaps needed.

Wait, let's try a different one.

n=6, x=3

array = [5,4,6,2,1,3]

Simulate binary search:

- l=1, r=7

- m=4, p_4=2 <=3, l=4

- l=4, r=7

- m=5, p_5=1 <=3, l=5

- l=5, r=7

- m=6, p_6=3 <=3, l=6

- l=6, r=7

- m=6, p_6=3 <=3, l=6

- r - l=1, loop ends.

- p_l = p_6=3, which is x=3.

No swaps needed.

Another example:

n=4, x=3

array = [1,4,2,3]

Simulate binary search:

- l=1, r=5

- m=3, p_3=2 <=3, l=3

- l=3, r=5

- m=4, p_4=3 <=3, l=4

- l=4, r=5

- m=4, p_4=3 <=3, l=4

- r - l=1, loop ends.

- p_l = p_4=3, which is x=3.

No swaps needed.

Wait, I can't find a case where one swap isn't enough.

Maybe in all cases, one swap suffices, and the problem allows two swaps as a safety net.

Alternatively, perhaps there are cases where one swap isn't enough, but I haven't encountered one yet.

Let me try to think of such a case.

Suppose n=5, x=2

array = [3,4,5,1,2]

Simulate binary search:

- l=1, r=6

- m=3, p_3=5 >2, r=3

- l=1, r=3

- m=2, p_2=4 >2, r=2

- l=1, r=2

- m=1, p_1=3 >2, r=1

- r - l=0, loop ends.

- p_l = p_1=3, which is not 2.

Swap p_1 and p_5: [2,4,5,1,3]

Simulate binary search:

- l=1, r=6

- m=3, p_3=5 >2, r=3

- l=1, r=3

- m=2, p_2=4 >2, r=2

- l=1, r=2

- m=1, p_1=2 <=2, l=1

- r - l=1, loop ends.

- p_l = p_1=2, which is x=2.

Again, one swap sufficed.

Hmm.

Maybe I need to look for a more complex case.

Let's consider n=7, x=4

array = [5,6,7,1,2,3,4]

Simulate binary search:

- l=1, r=8

- m=4, p_4=1 <=4, l=4

- l=4, r=8

- m=6, p_6=3 <=4, l=6

- l=6, r=8

- m=7, p_7=4 <=4, l=7

- l=7, r=8

- m=7, p_7=4 <=4, l=7

- r - l=1, loop ends.

- p_l = p_7=4, which is x=4.

No swaps needed.

Another example:

n=7, x=3

array = [4,5,6,7,1,2,3]

Simulate binary search:

- l=1, r=8

- m=4, p_4=7 >3, r=4

- l=1, r=4

- m=2, p_2=5 >3, r=2

- l=1, r=2

- m=1, p_1=4 >3, r=1

- r - l=0, loop ends.

- p_l = p_1=4, which is not 3.

Swap p_1 and p_7: [3,5,6,7,1,2,4]

Simulate binary search:

- l=1, r=8

- m=4, p_4=7 >3, r=4

- l=1, r=4

- m=2, p_2=5 >3, r=2

- l=1, r=2

- m=1, p_1=3 <=3, l=1

- r - l=1, loop ends.

- p_l = p_1=3, which is x=3.

Again, one swap sufficed.

I'm starting to think that perhaps in all cases, one swap is enough, and the problem allows two swaps to make it easier.

But according to the problem, "It can be shown that 2 operations are always sufficient.", which suggests that there might be cases where one swap isn't enough.

Perhaps I need to consider a case where swapping x to l doesn't fix the binary search path.

Let me try to construct such a case.

Suppose n=5, x=2

array = [3,4,5,1,2]

Simulate binary search:

- l=1, r=6

- m=3, p_3=5 >2, r=3

- l=1, r=3

- m=2, p_2=4 >2, r=2

- l=1, r=2

- m=1, p_1=3 >2, r=1

- r - l=0, loop ends.

- p_l = p_1=3, which is not 2.

Swap p_1 and p_5: [2,4,5,1,3]

Simulate binary search:

- l=1, r=6

- m=3, p_3=5 >2, r=3

- l=1, r=3

- m=2, p_2=4 >2, r=2

- l=1, r=2

- m=1, p_1=2 <=2, l=1

- r - l=1, loop ends.

- p_l = p_1=2, which is x=2.

Again, one swap sufficed.

Wait, maybe in all cases, one swap is enough.

Perhaps the problem allows up to two swaps to cover cases where one swap isn't enough, but in practice, one swap suffices.

Alternatively, maybe there are cases where even after swapping x to l, the binary search still doesn't end at x.

But I can't find such a case.

Let me consider another approach.

Suppose I perform the binary search and find the final l.

If p_l != x, I swap p_l with x.

Then, I perform the binary search again to see if p_l == x.

If yes, then one swap sufficed.

If not, I need a second swap.

But in all the examples I've tried, one swap sufficed.

Perhaps I should implement this approach and assume that one swap is enough in most cases, and use the second swap if necessary.

But I need to ensure that two swaps are always sufficient.

Let me consider a pathological case.

Suppose n=4, x=2

array = [3,4,1,2]

Simulate binary search:

- l=1, r=5

- m=3, p_3=1 <=2, l=3

- l=3, r=5

- m=4, p_4=2 <=2, l=4

- l=4, r=5

- m=4, p_4=2 <=2, l=4

- r - l=1, loop ends.

- p_l = p_4=2, which is x=2.

No swaps needed.

Another example:

n=4, x=1

array = [3,4,2,1]

Simulate binary search:

- l=1, r=5

- m=3, p_3=2 >1, r=3

- l=1, r=3

- m=2, p_2=4 >1, r=2

- l=1, r=2

- m=1, p_1=3 >1, r=1

- r - l=0, loop ends.

- p_l = p_1=3, which is not 1.

Swap p_1 and p_4: [1,4,2,3]

Simulate binary search:

- l=1, r=5

- m=3, p_3=2 <=1, l=3

- l=3, r=5

- m=4, p_4=3 >1, r=4

- l=3, r=4

- m=3, p_3=2 <=1, l=3

- r - l=1, loop ends.

- p_l = p_3=2, which is not 1.

Oh, so one swap wasn't enough.

I need to perform a second swap.

Current array: [1,4,2,3]

p_l = p_3=2, x=1 is at p_1=1.

I need p_l =1, so swap p_3 and p_1: [1,4,1,3], but that would duplicate 1 and remove 2, which is invalid since it's a permutation.

Wait, that's not a valid permutation anymore.

Wait, I must ensure that I'm swapping indices correctly.

Wait, perhaps I need to choose different swaps.

Original array: [3,4,2,1]

After first swap: [1,4,2,3]

Now, p_l = p_3=2, which is not x=1.

I need to perform a second swap.

Find another position to swap.

Maybe swap p_3 and p_4: [1,4,3,2]

Simulate binary search:

- l=1, r=5

- m=3, p_3=3 >1, r=3

- l=1, r=3

- m=2, p_2=4 >1, r=2

- l=1, r=2

- m=1, p_1=1 <=1, l=1

- r - l=1, loop ends.

- p_l = p_1=1, which is x=1.

So, two swaps were needed:

- Swap p_1 and p_4: [1,4,2,3]

- Swap p_3 and p_4: [1,4,3,2]

Which matches the sample output format.

Hence, in some cases, two swaps are needed.

Therefore, the general strategy is:

1. Perform the binary search on the original array to find the final l.

2. If p_l == x, output 0 swaps.

3. Else, perform the following:

a. Swap p_l with x.

b. Perform the binary search again.

c. If p_l == x, output one swap.

d. Else, perform a second swap to adjust another element to fix the path.

In the above example, swapping p_l and x with one swap wasn't enough, but with two swaps, it worked.

Hence, two swaps are always sufficient.

Now, I need to implement this logic.

But implementing it directly might be too slow because of the multiple binary searches and swaps.

Given the time constraints, I need an efficient way to determine the swaps.

Let me try to find a better way.

I need to find a way to place x in such a position that the binary search ends up at x.

Given that I can perform up to two swaps, I can consider all possible pairs of swaps and check if any of them lead to p_l = x.

But with n up to 2e5 and t up to 2e4, this is not feasible directly.

I need a smarter approach.

Let me consider that with two swaps, I can generate any permutation of three elements.

Hence, I can potentially place x anywhere and adjust two other elements.

But I need to ensure that the binary search path leads to x.

Alternatively, perhaps I can consider the positions that the binary search visits and ensure that x is at one of those positions.

Wait, maybe I can simulate the binary search to find the path it takes, and ensure that x is at the final l position.

Hence, the strategy would be:

- Simulate the binary search on the original array to find the final l.

- If p_l == x, do nothing.

- Else, swap p_l with x.

- Simulate the binary search again to check if p_l == x.

- If yes, output one swap.

- Else, perform a second swap to fix any inconsistencies.

But in the above example