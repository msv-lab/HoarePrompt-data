Alright, I have this problem to solve. Let's see what it's asking for. Bob has a bakery, and on the opening day, he baked n buns that he wants to sell. The usual price for each bun is a coins. But to attract customers, he's offering a promotion:

- He can choose some integer k (between 0 and the minimum of n and b)。

- For the first k buns sold, the price of the i-th bun is (b - i + 1) coins。

- The remaining (n - k) buns are sold at the usual price a coins each。

My task is to help Bob determine the maximum profit he can make by selling all n buns.

First, I need to understand the promotion clearly. So, if he chooses k buns to sell at the modified price, the price for each of these k buns decreases as more are sold. The first bun is sold at b coins, the second at (b - 1), and so on, down to the k-th bun, which is sold at (b - k + 1) coins.

After selling k buns at this decreasing price, the remaining buns are sold at the usual price a coins each.

I need to maximize the total profit, which is the sum of the prices of all buns sold.

Let me think about when it's beneficial to choose a particular k.

Case 1: If a is greater than or equal to b, meaning the usual price is higher or equal to the initial modified price, it might be better to sell all buns at the usual price. Let's see.

Case 2: If a is less than b, then selling some buns at the modified price might be more profitable.

Wait, actually, it's not just about a compared to b, but about the average price in the modified scheme versus the usual price.

Let me consider the sum of the modified prices for k buns.

The sum of the first k modified prices is:

sum from i=1 to k of (b - i + 1) = sum from i=1 to k of (b + 1 - i) = k*(b + 1) - sum from i=1 to k of i = k*(b + 1) - k*(k + 1)/2 = k*(b + 1 - (k + 1)/2) = k*(2b + 2 - k - 1)/2 = k*(2b - k + 1)/2

Wait, perhaps there's a simpler way to calculate this sum.

Actually, the sum of an arithmetic series: first term b, last term (b - k + 1), number of terms k.

Sum = k * (b + (b - k + 1))/2 = k*(2b - k + 1)/2

Then, the sum for the remaining (n - k) buns is (n - k)*a.

So, total profit P(k) = k*(2b - k + 1)/2 + (n - k)*a

I need to maximize P(k) over k from 0 to min(n, b).

To find the maximum, I can consider P(k) as a function and find its maximum value.

But since n, a, b can be up to 10^9, and t can be up to 10^4, I need an efficient way to compute this.

Let me see if I can find a way to choose the optimal k.

Let's consider the difference between P(k) and P(k-1), and see when it increases or decreases.

But perhaps a better approach is to find the k that maximizes P(k).

Let me consider P(k) = k*(2b - k + 1)/2 + (n - k)*a

Simplify this:

P(k) = (2bk - k^2 + k)/2 + na - ka

P(k) = (2bk)/2 - k^2/2 + k/2 + na - ka

P(k) = bk - k^2/2 + k/2 + na - ka

P(k) = -k^2/2 + (b + 1/2 - a)k + na

This is a quadratic in terms of k: P(k) = (-1/2)k^2 + (b + 0.5 - a)k + na

To maximize this quadratic function, since the coefficient of k^2 is negative (-1/2), the maximum occurs at k = -B/(2A), where A = -1/2, B = b + 0.5 - a.

So, k = -(b + 0.5 - a)/(2*(-1/2)) = (b + 0.5 - a)/1 = b + 0.5 - a

But k has to be an integer between 0 and min(n, b).

So, the optimal k is floor(b + 0.5 - a) , but need to clamp it within [0, min(n, b)]

Wait, but k has to be an integer, so I need to choose k as the integer closest to (b + 0.5 - a), but also within the bounds.

But let me think again.

Actually, in discrete optimization, for quadratic functions, the maximum for integer k is either floor(k*) or ceil(k*), where k* is the real-valued maximum.

Here, k* = b + 0.5 - a

So, the optimal integer k is floor(b + 0.5 - a) or ceil(b + 0.5 - a), whichever gives a higher P(k).

But considering the constraints 0 <= k <= min(n, b), I need to choose k within these limits.

Alternatively, perhaps there's a better way to approach this.

Let me consider the marginal benefit of increasing k.

Compute P(k) - P(k-1):

= [ -k^2/2 + (b + 0.5 - a)k + na ] - [ -(k-1)^2/2 + (b + 0.5 - a)(k-1) + na ]

Simplify:

= -k^2/2 + (b + 0.5 - a)k - [ -(k^2 - 2k + 1)/2 + (b + 0.5 - a)(k - 1) ]

= -k^2/2 + (b + 0.5 - a)k - [ -k^2/2 + k - 1/2 + (b + 0.5 - a)k - (b + 0.5 - a) ]

= -k^2/2 + (b + 0.5 - a)k + k^2/2 - k + 1/2 - (b + 0.5 - a)k + (b + 0.5 - a)

= (-k^2/2 + k^2/2) + ((b + 0.5 - a)k - (b + 0.5 - a)k) + (-k) + 1/2 + (b + 0.5 - a)

= -k + 1/2 + b + 0.5 - a

= -k + b - a + 1

So, P(k) - P(k-1) = -k + b - a + 1

This represents the additional profit when increasing k by 1.

We can use this to decide whether to increase k or not.

Start with k=0, and increment k as long as P(k) - P(k-1) > 0.

Set P(-1) = 0 for initialization.

So, while -k + b - a + 1 > 0:

-k + b - a + 1 > 0

=> -k > -(b - a + 1)

=> k < b - a + 1

Therefore, increase k until k >= b - a + 1

So, the optimal k is k = b - a

Wait, let's see.

Wait, the condition is k < b - a + 1

So, the last k where P(k) - P(k-1) > 0 is k = b - a

Therefore, the optimal k is k = b - a

But k has to be between 0 and min(n, b)

So, k = clamp(b - a + 1, 0, min(n, b))

Wait, clamp(b - a + 1, 0, min(n, b))

But in the earlier calculation, it's k < b - a + 1, so k = floor(b - a + 0.5), but in integer terms, it's b - a + 1 if b - a + 1 <= min(n, b), else k = min(n, b)

Wait, perhaps I need to reconsider.

Actually, from P(k) - P(k-1) = -k + b - a + 1

We can see that as k increases, P(k) - P(k-1) decreases by 1 each time.

Start with k=0: P(0) - P(-1) = b - a + 1 (assuming P(-1) = 0)

Then for k=1: P(1) - P(0) = -1 + b - a + 1 = b - a

For k=2: P(2) - P(1) = -2 + b - a + 1 = b - a - 1

And so on.

The profit increases as long as P(k) - P(k-1) > 0, which is when -k + b - a + 1 > 0

Which simplifies to k < b - a + 1

Therefore, the optimal k is the largest integer k such that k < b - a + 1, which is k = floor(b - a + 1)

But k has to be at least 0 and at most min(n, b)

Therefore, k = min(max(0, b - a + 1), min(n, b))

Wait, max(0, b - a + 1) ensures k is at least 0, and min(n, b) ensures it doesn't exceed n or b.

But actually, since k <= min(n, b), and k >=0, we can set k = min(max(0, b - a + 1), min(n, b))

Then, the maximum profit is P(k)

Now, let's see how to compute P(k):

P(k) = sum of first k modified prices + sum of remaining (n - k) usual prices

Sum of first k modified prices: sum from i=1 to k of (b - i + 1) = k*(b + (b - k + 1))/2 = k*(2b - k + 1)/2

Sum of remaining (n - k) usual prices: (n - k)*a

Therefore, total profit P(k) = k*(2b - k + 1)/2 + (n - k)*a

Now, in code, I need to compute this efficiently for t test cases, with large values of n, a, b up to 10^9, and t up to 10^4.

I need to make sure that the computation is fast and handles large numbers correctly, avoiding integer overflows.

Let's think about how to implement this.

First, read t, the number of test cases.

Then, for each test case, read n, a, b.

Compute k = min(max(0, b - a + 1), min(n, b))

Then, compute P(k) = k*(2b - k + 1)/2 + (n - k)*a

But need to be careful with integer division and potential large products.

In Python, integers can be arbitrarily large, so no worries about overflow.

But need to ensure that the division by 2 in k*(2b - k + 1)/2 is handled correctly.

Let's make sure that it's integer division.

So, in code:

k = min(max(0, b - a + 1), min(n, b))

Then, ans = (k * (2*b - k + 1)) // 2 + (n - k) * a

Print ans.

Let's verify this with the sample inputs.

Sample Input:

7

4 4 5

5 5 9

10 10 5

5 5 11

1000000000 1000000000 1000000000

1000000000 1000000000 1

1000 1 1000

Sample Output:

17

35

100

45

1000000000000000000

1000000000000000000

500500

Let's check the first test case:

n=4, a=4, b=5

k = min(max(0, 5 - 4 + 1), min(4,5)) = min(max(0,2),4) = min(2,4) = 2

P(2) = 2*(2*5 - 2 + 1)/2 + (4 - 2)*4 = 2*(10 - 2 + 1)/2 + 2*4 = 2*9/2 + 8 = 9 + 8 = 17

Which matches the sample output.

Second test case:

n=5, a=5, b=9

k = min(max(0,9-5+1), min(5,9)) = min(max(0,5),5) = min(5,5) = 5

P(5) = 5*(2*9 - 5 + 1)/2 + (5 - 5)*5 = 5*(18 - 5 + 1)/2 + 0 = 5*14/2 = 5*7 = 35

Matches the sample.

Third test case:

n=10, a=10, b=5

k = min(max(0,5-10+1), min(10,5)) = min(max(0,-4),5) = min(0,5) = 0

P(0) = 0*(2*5 - 0 + 1)/2 + (10 - 0)*10 = 0 + 100 = 100

Matches the sample.

Fourth test case:

n=5, a=5, b=11

k = min(max(0,11-5+1), min(5,11)) = min(max(0,7),5) = min(7,5) = 5

P(5) = 5*(2*11 - 5 + 1)/2 + (5 - 5)*5 = 5*(22 - 5 + 1)/2 + 0 = 5*18/2 = 5*9 = 45

Matches the sample.

Fifth test case:

n=1000000000, a=1000000000, b=1000000000

k = min(max(0,1000000000 - 1000000000 + 1), min(1000000000,1000000000)) = min(max(0,1),1000000000) = min(1,1000000000) = 1

P(1) = 1*(2*1000000000 - 1 + 1)/2 + (1000000000 - 1)*1000000000 = 1*(2000000000)/2 + 999999999*1000000000 = 1*1000000000 + 999999999000000000 = 1000000000 + 999999999000000000 = 1000000000000000000

Matches the sample.

Sixth test case:

n=1000000000, a=1000000000, b=1

k = min(max(0,1 - 1000000000 + 1), min(1000000000,1)) = min(max(0,1 - 999999999),1) = min(max(0,0),1) = min(0,1) = 0

P(0) = 0*(2*1 - 0 + 1)/2 + (1000000000 - 0)*1000000000 = 0 + 1000000000000000000 = 1000000000000000000

Matches the sample.

Seventh test case:

n=1000, a=1, b=1000

k = min(max(0,1000 - 1 + 1), min(1000,1000)) = min(max(0,1000),1000) = min(1000,1000) = 1000

P(1000) = 1000*(2*1000 - 1000 + 1)/2 + (1000 - 1000)*1 = 1000*(2000 - 1000 + 1)/2 + 0 = 1000*1001/2 = 1000*500.5 = 500500

Matches the sample.

So, the formula seems correct.

Now, looking at the provided program:

def func():

t = int(input())

for _ in range(t):

(n, a, b) = map(int, input().split())

if a >= b:

print(n * a)

else:

k = min(b - a + 1, n)

ans = int((b + (b - k + 1)) / 2 * k)

p2 = (n - k) * a

print(ans + p2)

It seems similar to what I derived.

In the else clause, when a < b, it sets k = min(b - a + 1, n)

Then computes ans = (b + (b - k + 1)) / 2 * k, which is the sum of the first k modified prices.

Then p2 = (n - k) * a, the sum of the remaining buns sold at usual price.

Finally, prints ans + p2.

Wait, but in my earlier calculation, I had k = min(max(0, b - a + 1), min(n, b))

But in the code, it's k = min(b - a + 1, n), which assumes b - a + 1 >=0, which is not always true.

If b - a + 1 < 0, then k should be 0.

But in the code, it's min(b - a + 1, n), which could be negative if b - a + 1 < 0.

But in Python, min() with negative numbers will return the negative number.

Wait, but k has to be at least 0.

So, perhaps it should be k = max(0, min(b - a + 1, n))

But in the code, it's just min(b - a + 1, n), which could be negative.

Wait, but in the earlier test cases, k was set to 0 when b - a + 1 <=0.

Wait, in the third test case, n=10, a=10, b=5:

b - a + 1 = 5 - 10 + 1 = -4

So, k = min(-4, 10) = -4, which is incorrect; k should be 0.

But in the earlier reasoning, k = min(max(0, b - a + 1), min(n, b))

So, it should be k = max(0, min(b - a + 1, n))

But in the code, it's just min(b - a + 1, n), which can be negative.

So, perhaps there's a mistake in the code.

Wait, but in Python, when you compute min(b - a + 1, n), and b - a + 1 is negative, it will set k to that negative value, which is incorrect because k cannot be negative.

So, perhaps the code implicitly assumes that k is non-negative, but in reality, it can be negative.

Wait, but in the sample input where n=10, a=10, b=5, k should be 0, but according to the code, k = min(5 - 10 + 1, 10) = min(-4,10) = -4, which is wrong.

Then, ans = (-4)*(2*5 - (-4) + 1)/2 + (10 - (-4))*10 = (-4)*(10 +4 +1)/2 + 14*10 = (-4)*15/2 + 140 = (-4)*7.5 + 140 = (-30) + 140 = 110

But according to the sample, it should be 100.

Wait, but in the sample, it's 100, not 110.

So, the code is incorrect in this case.

Wait, but in the sample, when k=0, P(0) = 0*(2*5 - 0 +1)/2 + 10*10 = 0 + 100 = 100

But according to the code, k = min(5 - 10 +1, 10) = min(-4,10) = -4, then ans = (-4)*(2*5 - (-4) +1)/2 + (10 - (-4))*10 = (-4)*(10 +4 +1)/2 + 14*10 = (-4)*15/2 + 140 = -30 +140 =110

Which is incorrect; it should be 100.

So, the code is wrong here.

Therefore, to fix this, we need to ensure that k >=0.

So, k = max(0, min(b - a +1, n))

Then, ans = k*(2*b - k +1)/2 + (n -k)*a

In the above example, k = max(0, min(5 -10 +1,10)) = max(0, min(-4,10)) = max(0,-4) =0

Then, ans = 0*(2*5 -0 +1)/2 +10*10 =0 +100=100, which matches the sample.

So, the code is missing the max(0, ...) part.

Therefore, the code is incorrect.

Wait, but in the if condition, it has if a >= b: print(n * a)

else:

k = min(b - a +1, n)

...

So, in this case, when a >= b, it prints n*a, which is correct.

But in the else case, it should set k = min(max(0, b - a +1), n)

So, to fix the code, it should be:

k = min(max(0, b - a +1), n)

Then, ans = k*(2*b - k +1)//2 + (n -k)*a

Print ans.

But in the current code, it's missing the max(0, ...)

Hence, the code is incorrect.

Wait, but in the sample input where a >= b, it handles correctly, but in cases where a < b, it may set k to a negative value if b - a +1 <0, which is incorrect.

Hence, the code is incorrect.

Therefore, the answer is Correctness: **False**

**Final Solution**

To solve this problem, we need to maximize Bob's profit from selling buns under a promotional pricing scheme. We'll handle this by carefully selecting the optimal number of buns to sell at a modified price and ensuring our calculations are efficient for large inputs.

## Approach

1. **Understand the Pricing Scheme:**
   - For the first `k` buns, the price of the `i`-th bun is `(b - i + 1)` coins.
   - For the remaining `(n - k)` buns, the price is `a` coins each.

2. **Determine the Optimal `k`:**
   - If the usual price `a` is greater than or equal to `b`, it's better to sell all buns at the usual price.
   - Otherwise, compute the optimal `k` to maximize profit by selling some buns at the modified price.

3. **Calculate the Profit:**
   - Compute the sum of the first `k` modified prices using the arithmetic series sum formula.
   - Add the sum of the remaining `(n - k)` buns sold at the usual price.

4. **Ensure `k` is Within Bounds:**
   - `k` should be within the range `[0, min(n, b)]`.
   - Adjust `k` to ensure it doesn't go below 0 or exceed `min(n, b)`.

## Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        n, a, b = map(int, input().split())
        if a >= b:
            print(n * a)
        else:
            k = min(max(0, b - a + 1), min(n, b))
            ans = (k * (2 * b - k + 1)) // 2 + (n - k) * a
            print(ans)

# To use this function, you can call it directly:
# func()
```

## Explanation

1. **Reading Input:**
   - Read the number of test cases `t`.
   - For each test case, read `n`, `a`, and `b`.

2. **Choosing the Optimal Strategy:**
   - If `a >= b`, selling all buns at the usual price `a` is optimal.
   - Otherwise, compute the optimal `k` as `min(max(0, b - a + 1), min(n, b))`.

3. **Calculate the Profit:**
   - Sum of the first `k` modified prices: `k * (2*b - k + 1) // 2`.
   - Sum of the remaining `(n - k)` usual prices: `(n - k) * a`.
   - Total profit is the sum of these two amounts.

4. **Output the Result:**
   - Print the computed profit for each test case.

This approach ensures that we handle large inputs efficiently and compute the maximum profit correctly by choosing the optimal number of buns to sell at the modified price.