Alright, I have this problem to solve. Let's see what it's asking for. So, Alice has n coins and wants to buy exactly k jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel that's an integer between 1 and 10^18 coins. Alice buys jewels greedily: she goes to each stall in order and buys as many jewels as she can with her remaining coins.

My task is to determine if Bob can set up the stalls and set their prices in such a way that Alice ends up buying exactly k jewels. If it's possible, I need to output "YES" along with the number of stalls and their prices. If not, I should output "NO".

First, I need to understand the constraints and what exactly is being asked. The inputs are t test cases, each with n (coins) and k (desired jewels). I need to process each test case individually.

Looking at the example:

Input:

3

7 3

6 4

255 8

Output:

YES

10

2 3 4 5 6 7 8 9 10 11

NO

YES

8

128 64 32 16 8 4 2 1

In the first test case, with 7 coins and wanting to buy 3 jewels, the solution uses 10 stalls with prices from 2 to 11. Alice buys 3 jewels at 2 coins each, using 6 coins, and has 1 coin left, which isn't enough to buy any jewels from the other stalls.

In the third test case, with 255 coins and wanting to buy 8 jewels, the solution uses 8 stalls with prices being powers of 2, from 128 down to 1. Alice buys one jewel from each stall, spending 128, 64, 32, 16, 8, 4, 2, and 1 coins, totaling 255 coins, and buying exactly 8 jewels.

The second test case, with 6 coins and wanting to buy 4 jewels, is impossible, hence "NO".

From this, I can see that in some cases, it's possible to set up stalls to make Alice buy exactly k jewels, and in other cases, it's not.

I need to find a general approach to determine whether it's possible for any given n and k, and if so, provide a valid setup of stalls and their prices.

Let me think about the constraints:

- Bob can set up at most 60 stalls.

- Each stall can have a price per jewel from 1 to 10^18 coins.

- Alice buys jewels greedily: she buys as many jewels as possible from each stall in order.

- Alice doesn't need to spend all her coins, but she must buy exactly k jewels.

First, consider the simplest case: k = 1.

If k = 1, Bob can set up a single stall with price n coins. Alice will buy one jewel with her n coins. So, "YES" with one stall and price n.

Another simple case: k = n.

If k = n, Bob can set up one stall with price 1 coin per jewel. Alice will buy n jewels with her n coins. So, "YES" with one stall and price 1.

Now, what if k > n?

Wait, but each jewel costs at least 1 coin, so if k > n, it's impossible for Alice to buy k jewels because she doesn't have enough coins. So, in such cases, the answer should be "NO".

Wait, but in the problem statement, it says "each test case contains two positive integers n and k (1 ≤ n, k ≤ 10^18)", so k can be larger than n, but as I thought, it should be impossible if k > n, because even if each jewel costs 1 coin, she needs k coins to buy k jewels. But in the problem description, it says "Alice does not need to spend all her coins", but she still needs to have enough coins to buy the jewels.

Wait, but in the first test case, n=7, k=3, and the solution makes Alice buy 3 jewels and have 1 coin left. So, she had enough coins to buy more jewels, but didn't because she couldn't afford them at the higher prices.

Wait, no, in that case, she had 1 coin left, which wasn't enough to buy any jewels from the other stalls.

So, in general, if k > n, it's impossible because even if each jewel costs 1 coin, she can't buy more jewels than she has coins for.

Wait, but what if some jewels cost more than 1 coin? Could there be a setup where k > n, but still possible because some jewels are expensive?

Wait, no. Because if a jewel costs more than 1 coin, she can buy fewer jewels with her coins. So, if k > n, she can't buy k jewels, each costing at least 1 coin.

Therefore, if k > n, it's impossible, and we should output "NO".

Wait, but in the problem description, for the first test case, n=7, k=3, which is k < n, and it's possible.

Second test case, n=6, k=4, which is k > n, and it's impossible.

Third test case, n=255, k=8, which is k < n, and it's possible.

So, my conclusion is: if k > n, output "NO". Otherwise, it's possible.

But wait, is that always true?

Wait, no. Consider n=3, k=2.

If Bob sets up two stalls, one with price 2 and one with price 1.

Alice goes to the first stall, buys 1 jewel for 2 coins, has 1 coin left.

Then goes to the second stall, buys 1 jewel for 1 coin, has 0 coins left.

Total jewels bought: 2, which is exactly k=2.

Another setup: n=3, k=1.

Bob sets up one stall with price 3, Alice buys one jewel, spends all 3 coins.

Or, Bob sets up one stall with price 1, Alice buys 3 jewels, which is more than k=1.

Wait, but in this case, she buys more than k=1, which is not desired.

So, to make her buy exactly k=1, Bob should set up a stall with price 3, so she buys one jewel and has 0 coins left.

Alternatively, Bob can set up two stalls: first with price 2, second with price 1.

Alice buys one jewel for 2 coins, has 1 coin left, which is not enough to buy the second jewel at 1 coin, so total jewels bought: 1.

So, in this case, it's possible.

Wait, but in this setup, she has 1 coin left, but it's not enough to buy any more jewels, so it's acceptable.

Another example: n=4, k=2.

Option 1: One stall with price 2, Alice buys 2 jewels, spends 4 coins.

Option 2: One stall with price 3, Alice buys 1 jewel, has 1 coin left, which is not enough to buy another jewel at any price >1.

Option 3: Two stalls, first with price 2, second with price 1.

Alice buys 2 jewels at the first stall, spends 4 coins, total jewels: 2.

Option 4: Two stalls, first with price 3, second with price 1.

Alice buys 1 jewel at the first stall, spends 3 coins, has 1 coin left, which is enough to buy a jewel at the second stall for 1 coin, so total jewels: 2.

Option 5: Three stalls, first with price 2, second with price 1, third with price 1.

Alice buys 2 jewels at the first stall, spends 4 coins, has 0 coins left.

Total jewels: 2.

So, in this case, it's possible to make Alice buy exactly 2 jewels with 4 coins.

Wait, but if Bob sets up only one stall with price 2, Alice will buy 2 jewels, which is exactly k=2.

So, in this case, it's possible with just one stall.

Another case: n=5, k=2.

Option 1: One stall with price 3, Alice buys 1 jewel, has 2 coins left.

If there's a second stall with price 3, she can't buy anything, total jewels: 1.

Option 2: One stall with price 2, Alice buys 2 jewels, spends 4 coins, has 1 coin left.

Total jewels: 2.

Option 3: Two stalls, first with price 3, second with price 2.

Alice buys 1 jewel at the first stall, spends 3 coins, has 2 coins left.

Then buys 1 jewel at the second stall for 2 coins, total jewels: 2.

Option 4: Three stalls, first with price 3, second with price 2, third with price 1.

Alice buys 1 jewel at the first stall, spends 3 coins, has 2 coins left.

Buys 1 jewel at the second stall for 2 coins, has 0 coins left.

Total jewels: 2.

So, in this case, it's possible.

Wait, but what if Bob sets up only one stall with price 3, Alice buys 1 jewel, has 2 coins left, which isn't enough to buy another jewel at price 3.

So, total jewels: 1, which is less than k=2.

So, to make her buy exactly 2 jewels, Bob needs to set up stalls in such a way that she buys exactly 2 jewels.

From the above options, setting up one stall with price 2 or setting up two stalls with prices 3 and 2 achieves the desired result.

So, in this case, it's possible.

Wait, but in the second test case, n=6, k=4, it's impossible.

Wait, why is that?

If Bob sets up one stall with price 2, Alice buys 3 jewels, spends 6 coins.

Total jewels: 3, which is less than k=4.

If Bob sets up two stalls, first with price 2, second with price 1.

Alice buys 3 jewels at the first stall, spends 6 coins, has 0 coins left.

Total jewels: 3.

If Bob sets up two stalls, first with price 1, second with price 1.

Alice buys 6 jewels at the first stall, spends 6 coins.

Total jewels: 6, which is more than k=4.

So, in this case, it's impossible to make Alice buy exactly 4 jewels.

Hence, "NO".

So, the problem is to determine whether it's possible to set up at most 60 stalls with integer prices between 1 and 10^18 such that Alice buys exactly k jewels.

I need to find a general approach to solve this for any n and k.

Let me try to find a general strategy.

First, if k > n, it's impossible, since each jewel costs at least 1 coin.

Second, if k <= n, it might be possible, depending on how the prices are set.

I need to ensure that Alice buys exactly k jewels, not more, not less.

To make her buy exactly k jewels, I need to set up stalls in such a way that:

1. She buys some jewels at the first stall, reducing her coins accordingly.

2. Then, at the next stall, she buys more jewels with the remaining coins, and so on.

3. The total number of jewels bought should be exactly k.

Moreover, after buying k jewels, she should not have enough coins to buy any more jewels from the remaining stalls.

Or, even if she has coins left, those coins are not sufficient to buy any more jewels from the remaining stalls.

This seems a bit tricky.

Let me think differently.

Suppose Bob sets up s stalls, with prices p1, p2, ..., ps.

Alice will buy as many jewels as possible from each stall in order.

So, from the first stall, she buys floor(n / p1) jewels, and her remaining coins are n - (floor(n / p1) * p1).

Then, she moves to the second stall, buys floor(remaining coins / p2) jewels, and so on.

The sum of jewels bought from all stalls should be exactly k.

I need to choose s <= 60 and p1, p2, ..., ps such that this sum is k.

This seems like a Diophantine equation with multiple variables, which might be complicated.

Maybe there's a smarter way to approach this.

Looking back at the examples:

First test case: n=7, k=3

Solution: 10 stalls with prices 2,3,4,5,6,7,8,9,10,11

Alice buys 3 jewels at the first stall (7//2=3, spends 6 coins, has 1 left), which isn't enough for any other stall.

Total jewels: 3

Second test case: n=6, k=4

Impossible, "NO"

Third test case: n=255, k=8

Solution: 8 stalls with prices 128,64,32,16,8,4,2,1

Alice buys one jewel from each stall, spending 128,64,32,16,8,4,2,1 coins, totaling 255 coins, and buying exactly 8 jewels.

So, in the third test case, it's like a binary representation of n, where each stall's price is a power of 2, starting from the highest possible.

This seems similar to the binary representation of numbers.

In general, any number can be represented as a sum of distinct powers of 2.

But in this problem, it's not exactly the same, because the prices can be any integers between 1 and 10^18, not necessarily powers of 2.

However, in the third test case, using powers of 2 works because it allows Alice to buy one jewel from each stall, effectively spending a specific amount each time.

Wait, but in the first test case, the prices are not powers of 2, yet it still works.

So, maybe there's a general strategy here.

Let me consider the following approach:

- Start with the highest possible price that Alice can buy at least one jewel from.

- Let her buy as many jewels as possible from that price, reducing her coins accordingly.

- Repeat the process with the remaining coins and lower prices.

- Continue until she has bought exactly k jewels or can't buy more.

But I need to ensure that she buys exactly k jewels, not more, not less.

Wait, but in the first test case, with n=7 and k=3, the solution uses prices from 2 to 11, and Alice buys 3 jewels in total.

In the third test case, with n=255 and k=8, it uses prices that are powers of 2, descending from 128 to 1, and Alice buys one jewel from each stall, totaling 8 jewels.

So, perhaps in general, if k <= n, and I set up k stalls with prices that are greater than the average coin per jewel, but in a way that Alice buys one jewel from each stall, it might work.

Wait, but in the first test case, k=3 and n=7, and the solution uses 10 stalls, which is more than k.

Wait, but in the third test case, k=8 and n=255, and it uses exactly 8 stalls.

So, maybe in some cases, using k stalls is sufficient, each with a price that Alice can afford only one jewel from.

But in the first test case, they used more than k stalls.

Maybe there's a general method to set up stalls in a way that Alice buys exactly k jewels.

Let me think about the minimal number of stalls required.

If I set up k stalls, each with a price such that Alice can buy exactly one jewel from each stall, and the prices are decreasing in a way that she can afford one jewel from each subsequent stall with her remaining coins, then she will buy exactly k jewels.

For example, in the third test case, with prices 128,64,32,16,8,4,2,1, which are decreasing powers of 2, she buys one from each.

Similarly, in the first test case, they used prices from 2 to 11, and she bought 3 jewels.

Wait, but in that case, she bought 3 jewels from the first stall and nothing from the others.

So, it's not exactly the same as setting up k stalls with prices that allow her to buy one jewel from each.

So, perhaps a better approach is to set up stalls with decreasing prices, starting from the highest possible price that allows her to buy at least one jewel, and then adjust the remaining stalls accordingly.

But this seems a bit vague.

Let me consider another angle.

Suppose I set up stalls with prices p1, p2, ..., ps.

I need to choose these prices such that the sum of floor(n / p1), floor((n - floor(n/p1)*p1)/p2), ..., equals k.

This is complicated.

Maybe I can think in terms of the minimal and maximal number of jewels she can buy.

The minimal number of jewels she can buy is floor(n / p1), if there's only one stall with price p1.

The maximal number of jewels she can buy is floor(n / 1), which is n, if all stalls have price 1.

I need to find a setup where the total is exactly k.

Given that s <= 60, perhaps I can find a way to set up s stalls to achieve the desired k.

Wait, maybe I can use a greedy approach to maximize or minimize the number of jewels bought.

But I need to target exactly k, which is tricky.

Let me consider the minimal number of stalls required to make Alice buy exactly k jewels.

If I set up k stalls, each with a price that Alice can afford exactly one jewel from, then she will buy one from each, totaling k.

But I need to ensure that she can't buy more jewels from additional stalls.

Moreover, I need to make sure that with these k stalls, she buys exactly k jewels and doesn't have enough coins to buy from any more stalls.

But in the first test case, they used 10 stalls for k=3, which is more than k.

So, perhaps using more stalls can also work.

Wait, perhaps there's a way to set up stalls with increasing prices so that she buys fewer jewels from each subsequent stall.

But in the first test case, the prices are increasing from 2 to 11, and she buys 3 jewels from the first stall and nothing from the rest.

In the third test case, the prices are decreasing from 128 to 1, and she buys one from each.

So, the order of stalls seems to matter.

But according to the problem, Alice goes to stall 1 first, then stall 2, and so on.

So, the order of stalls is fixed.

Hence, the pricing strategy should be such that she buys a certain number of jewels from each stall in sequence.

I need to design the prices so that the cumulative number of jewels bought is exactly k.

This seems similar to partitioning n coins into k jewels, with some constraints on how the partitioning is done.

Wait, perhaps I can think of it as partitioning n coins into k jewels, where each jewel costs at least 1 coin, and the costs are arranged in a way that fits the stall prices.

But it's more complicated than that because of the way Alice buys jewels.

Wait, maybe I can model this as a series of steps where at each stall, she buys as many jewels as possible with her remaining coins, given the price of that stall.

I need to find a sequence of prices such that the total number of jewels bought is exactly k.

This seems quite involved.

Let me consider a different approach.

Suppose I set up two stalls.

First stall with price p1, second stall with price p2, where p1 > p2.

Alice will buy floor(n / p1) jewels from the first stall, spending floor(n / p1) * p1 coins.

Then, she will have n - floor(n / p1) * p1 coins left.

From the second stall, she will buy floor(remaining coins / p2) jewels.

And so on.

I need to choose p1 and p2 such that the total jewels bought are exactly k.

But this seems too vague.

Let me try to find a general method.

One idea is to use the greedy algorithm to maximize the number of jewels bought.

But here, I need to target exactly k jewels.

Alternatively, perhaps I can use a binary search approach to adjust the prices.

But that might be too time-consuming, especially since s is at most 60, which is manageable.

Wait, perhaps I can use the concept of binary representation.

In the third test case, they used prices that are powers of 2, which are 128,64,32,16,8,4,2,1.

This is similar to the binary representation of n=255, which is 11111111 in binary.

In this setup, Alice buys one jewel from each stall, corresponding to each bit in the binary representation.

So, perhaps in general, if I set up stalls with prices that are powers of 2, starting from the highest possible down to 1, Alice will buy one jewel from each stall, effectively spending n coins to buy log2(n) jewels.

But in the third test case, k=8, which is more than log2(255), which is around 8, since 2^8=256.

Wait, 2^8=256, which is greater than 255.

So, in this case, it works because k=8 and n=255.

But in general, if k is greater than log2(n), this approach might not work.

Wait, but in the third test case, k=8 and n=255, and it worked.

Wait, but log2(255) is approximately 7.99, which is less than 8.

But in the solution, they used 8 stalls with prices 128,64,32,16,8,4,2,1.

Alice buys one jewel from each, spending exactly 255 coins.

So, perhaps in this case, it worked because n is just below 256, which is 2^8.

But if n were smaller, say n=254, k=8, would this still work?

Let's see: 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255.

But n=254 is less than 255, so she might not be able to afford the last jewel at 1 coin, or something like that.

Wait, no, she would buy one jewel from each stall until she doesn't have enough for the next stall.

So, with n=254, she would buy one jewel from each stall, spending 128,64,32,16,8,4,2, totaling 254 coins, and have 0 coins left.

So, she buys 7 jewels, which is less than k=8.

Hence, in this case, it's impossible to make her buy exactly 8 jewels with n=254.

So, in that case, the answer should be "NO".

Wait, but with n=255 and k=8, it's possible.

So, perhaps for n=254 and k=7, it's possible.

Wait, but the problem is to make her buy exactly k jewels, not more or less.

So, in this approach, using powers of 2 descending, it might work for certain n and k, but not for others.

Hence, it's not a general solution.

I need a more general method.

Let me think about the minimal and maximal number of stalls needed.

If k=1, minimal number of stalls is 1, with price n.

If k=n, minimal number of stalls is 1, with price 1.

If k is between 1 and n, I need to find a way to set up stalls such that the total jewels bought is exactly k.

Moreover, s <= 60.

So, I need to ensure that the number of stalls doesn't exceed 60.

I need to find a way to achieve this for any n and k, with s <= 60.

Let me consider the following approach:

- Set up s stalls, where s is minimized but doesn't exceed 60.

- Choose prices p1, p2, ..., ps such that the sum of floor(n / p1), floor(n - floor(n/p1)*p1 / p2), ..., equals k.

This seems too vague.

Perhaps I can use the concept of the minimal price to buy k jewels.

Wait, suppose I set up one stall with price floor(n/k).

But wait, if I set up one stall with price floor(n/k), then Alice will buy floor(n / floor(n/k)) jewels.

But this might not be exactly k.

For example, n=7, k=3.

floor(7/3)=2.

So, price=2.

Then, floor(7/2)=3 jewels.

So, in this case, it works.

Another example: n=6, k=4.

floor(6/4)=1.

Price=1.

Then, floor(6/1)=6 jewels, which is more than k=4.

So, in this case, it's not sufficient.

Hence, setting up only one stall might not always work.

Wait, in the first case, n=7, k=3, setting up one stall with price 2 gives us 3 jewels, which is exactly k.

In the second case, n=6, k=4, setting up one stall with price floor(6/4)=1 gives 6 jewels, which is more than k.

So, perhaps I need to adjust the price to make sure she buys exactly k jewels.

But how?

Wait, perhaps I can set up two stalls: one with a price that makes her buy as many as possible up to k, and the second stall makes up the remaining jewels.

But this seems too vague.

Let me try to formalize this.

Let me consider setting up two stalls.

First stall: price p1.

Alice buys m1 = floor(n / p1) jewels.

Then, she has n - m1 * p1 coins left.

Second stall: price p2.

She buys m2 = floor( (n - m1 * p1) / p2 ) jewels.

Total jewels: m1 + m2 = k.

I need to choose p1 and p2 such that m1 + m2 = k.

This seems like a system of equations, but it's still not straightforward.

Perhaps I need to consider that p1 > p2, so that m1 is maximized first, then m2.

But it's still complex.

Let me consider another angle.

Suppose I fix p1, then p2 can be determined based on the remaining coins and the remaining jewels to buy.

But this seems too dependent on the specific values.

I need a better approach.

Let me consider the minimal and maximal possible prices.

The minimal price is 1, the maximal is 10^18.

I need to choose prices in a way that the total jewels bought is exactly k.

Wait, perhaps I can use the concept of the minimal price to buy k jewels.

Suppose I set p1 = ceil(n / k).

Then, Alice buys m1 = floor(n / p1) jewels from the first stall.

If m1 = k, then we're done.

If m1 < k, then I need to set up more stalls to make up the remaining jewels.

But in the second test case, n=6, k=4, ceil(6/4)=2.

Then, m1 = floor(6/2) = 3 jewels.

Still less than k=4.

Then, I need to set up a second stall.

With remaining coins: 6 - 3*2 = 0 coins.

So, can't buy any more jewels.

Hence, total jewels: 3, which is less than k=4.

Hence, "NO".

In the first test case, n=7, k=3, ceil(7/3)=3.

Then, m1 = floor(7/3) = 2 jewels.

Remaining coins: 7 - 2*3 = 1 coin.

Then, set up a second stall with p2 = 1.

Alice buys floor(1 / 1) = 1 jewel.

Total jewels: 3, which is exactly k.

Hence, "YES" with two stalls: 3 and 1.

But in the first test case, the solution used 10 stalls with prices from 2 to 11.

So, multiple solutions are possible.

Hence, perhaps setting up two stalls with p1 = ceil(n/k) and p2 =1 works in some cases.

But in the second test case, n=6, k=4, ceil(6/4)=2.

m1 = floor(6/2) = 3 jewels.

Remaining coins: 6 - 3*2 = 0.

Can't buy any more jewels, so total jewels: 3 < 4.

Hence, "NO".

So, this approach seems to work for some cases.

But I need to generalize it.

Let me try to formalize this approach.

Algorithm:

1. If k > n, output "NO".

2. Else, set p1 = ceil(n / k).

3. m1 = floor(n / p1).

4. If m1 = k, output "YES" with one stall and price p1.

5. Else, set up a second stall with p2 =1.

6. remaining_coins = n - m1 * p1.

7. m2 = floor(remaining_coins / p2).

8. total_jewels = m1 + m2.

9. If total_jewels = k, output "YES" with two stalls: p1 and p2.

10. Else, output "NO".

But in the first test case, n=7, k=3:

p1 = ceil(7/3)=3

m1 = floor(7/3)=2

remaining_coins = 7 - 2*3=1

m2 = floor(1/1)=1

total_jewels=3, which equals k=3.

Hence, "YES" with two stalls: 3 and 1.

In the second test case, n=6, k=4:

p1=ceil(6/4)=2

m1=floor(6/2)=3

remaining_coins=6-3*2=0

m2=floor(0/1)=0

total_jewels=3 <4.

Hence, "NO".

In the third test case, n=255, k=8:

p1=ceil(255/8)=32

m1=floor(255/32)=8

remaining_coins=255-8*32=255-256=-1 → Wait, no, 32*8=256, but 255 -256=-1, which is invalid.

Wait, but in integer division, floor(255/32)=8, but 32*8=256, which is more than 255.

Hence, remaining_coins=255-255=0, since she can't spend more than she has.

Wait, but in practice, she can't buy 8 jewels at 32 each with only 255 coins, because 8*32=256 >255.

So, floor(255/32)=8 is incorrect; it should be floor(255/32)=7, because 32*7=224 <=255, and 32*8=256 >255.

Wait, but in Python, 255//32=7.

Yes, because 32*7=224, which is <=255, and 32*8=256 >255.

Hence, m1=7.

Then, remaining_coins=255-224=31.

Then, p2=1.

m2=floor(31/1)=31.

total_jewels=7+31=38 >8.

Which is more than k=8.

Hence, this approach doesn't work for this case.

But in the third test case, the solution used prices 128,64,32,16,8,4,2,1, making Alice buy one from each, totaling 8 jewels.

So, my approach fails for this case.

Hence, I need a better method.

Let me try to think recursively.

Suppose I set up one stall with price p1.

Alice buys m1 = floor(n / p1) jewels.

Then, I need to set up remaining stalls to make her buy exactly k - m1 jewels with the remaining coins.

I can repeat this process recursively.

But this might lead to a large number of stalls, and I need to ensure that s <=60.

Moreover, it's not efficient to implement recursively for large t and large n,k.

I need a smarter way.

Let me consider the following approach inspired by the binary representation.

Set up stalls with prices that are powers of some base, say 2, but adjusted according to n and k.

In the third test case, they used powers of 2 starting from 128 down to 1, which worked.

Perhaps I can generalize this.

Let me consider setting up stalls with prices that are as large as possible, starting from the highest possible price that allows her to buy at least one jewel, and then decreasing the price for subsequent stalls.

But I need to ensure that the total jewels bought is exactly k.

This is still too vague.

Let me consider another idea.

Suppose I set up s stalls with prices p1, p2, ..., ps, where p1 > p2 > ... > ps.

Then, Alice will buy as many jewels as possible from p1, then from p2, and so on.

I need to choose p1, p2, ..., ps such that the total jewels bought is exactly k.

This seems similar to a greedy algorithm for making change with coins of different denominations.

In fact, it's analogous to the coin change problem, where the goal is to make a certain amount with a certain number of coins.

But in this case, it's slightly different because Alice buys as many jewels as possible from each stall.

So, perhaps I can model this as a coin change problem where I need to make n coins using exactly k jewels, with each jewel costing at least 1 coin.

But in the standard coin change problem, the goal is to make a certain amount with the fewest number of coins.

Here, it's the opposite: I need to make exactly n coins using exactly k jewels, with the added constraint that the stalls are visited in order and she buys as many as possible from each stall.

This seems quite different from the standard coin change problem.

I need to think differently.

Let me consider that the total number of jewels bought is the sum of floor(n / p1), floor( (n - floor(n/p1)*p1) / p2 ), and so on.

I need this sum to be exactly k.

This seems like a system of equations, but it's too complex to solve directly.

Perhaps I can use an iterative approach to adjust the prices based on how many jewels are bought at each step.

But this might be too time-consuming.

Let me consider the following approach:

- Start with s=1.

- Set p1 = ceil(n / k).

- Compute m1 = floor(n / p1).

- If m1 == k, output "YES" with one stall and price p1.

- Else if m1 < k, set p2=1, compute m2 = floor(remaining_coins / p2).

- If m1 + m2 == k, output "YES" with two stalls: p1 and p2.

- Else, continue adding stalls as needed.

But in the second test case, n=6, k=4:

- s=1, p1=ceil(6/4)=2, m1=floor(6/2)=3.

- m1 < k=4.

- Set p2=1, remaining_coins=6-3*2=0, m2=0.

- Total jewels=3 <4.

- Hence, "NO".

In the first test case, n=7, k=3:

- s=1, p1=ceil(7/3)=3, m1=floor(7/3)=2.

- m1 < k=3.

- Set p2=1, remaining_coins=7-2*3=1, m2=1.

- Total jewels=3 == k=3.

- Hence, "YES" with two stalls: 3 and 1.

In the third test case, n=255, k=8:

- s=1, p1=ceil(255/8)=32, m1=floor(255/32)=7.

- m1 < k=8.

- Set p2=1, remaining_coins=255-7*32=255-224=31, m2=31.

- Total jewels=7+31=38 >8.

- Hence, need to adjust p2.

But in this approach, p2 is fixed to 1, which might not always be optimal.

Perhaps I need to adjust p2 based on the remaining jewels needed.

Wait, maybe I can set p2 = ceil(remaining_coins / (k - m1)).

Then, m2 = floor(remaining_coins / p2), which should be equal to k - m1.

Hence, total jewels = m1 + m2 = k.

Let's try this.

In the first test case, n=7, k=3:

- s=1, p1=ceil(7/3)=3, m1=floor(7/3)=2.

- remaining_coins=7-2*3=1.

- p2=ceil(1 / (3-2))=ceil(1/1)=1.

- m2=floor(1/1)=1.

- total_jewels=2+1=3==k=3.

- Hence, "YES" with two stalls: 3 and 1.

In the second test case, n=6, k=4:

- s=1, p1=ceil(6/4)=2, m1=floor(6/2)=3.

- remaining_coins=6-3*2=0.

- p2=ceil(0 / (4-3))=ceil(0/1)=0.

- But p2 must be at least 1, so p2=1.

- m2=floor(0/1)=0.

- total_jewels=3+0=3 <4.

- Hence, "NO".

In the third test case, n=255, k=8:

- s=1, p1=ceil(255/8)=32, m1=floor(255/32)=7.

- remaining_coins=255-7*32=255-224=31.

- p2=ceil(31 / (8-7))=ceil(31/1)=31.

- m2=floor(31/31)=1.

- total_jewels=7+1=8==k=8.

- Hence, "YES" with two stalls: 32 and 31.

But in the original solution, they used eight stalls with prices 128,64,32,16,8,4,2,1, making Alice buy one from each, totaling 8 jewels.

So, my adjusted approach also works, using only two stalls: 32 and 31.

Alice buys 7 jewels from the first stall (32 each), spending 224 coins, then 1 jewel from the second stall (31), spending 31 coins, totaling 255 coins and 8 jewels.

This seems correct.

Hence, perhaps this approach can be generalized.

Algorithm:

1. If k > n, output "NO".

2. Else, set s=1, p1=ceil(n/k).

3. m1=floor(n / p1).

4. If m1 == k, output "YES" with one stall and price p1.

5. Else, set s=2, p2=ceil(remaining_coins / (k - m1)).

6. m2=floor(remaining_coins / p2).

7. If m1 + m2 == k, output "YES" with two stalls: p1 and p2.

8. Else, output "NO".

This seems promising.

Let's test it with the second test case: n=6, k=4.

- p1=ceil(6/4)=2, m1=floor(6/2)=3.

- remaining_coins=6-3*2=0.

- p2=ceil(0 / (4-3))=ceil(0/1)=0 → set p2=1.

- m2=floor(0/1)=0.

- total_jewels=3+0=3 <4.

- Hence, "NO".

Correct.

Another test case: n=10, k=3.

- p1=ceil(10/3)=4, m1=floor(10/4)=2.

- remaining_coins=10-2*4=2.

- p2=ceil(2 / (3-2))=ceil(2/1)=2.

- m2=floor(2/2)=1.

- total_jewels=2+1=3==k=3.

- Hence, "YES" with two stalls: 4 and 2.

This seems correct.

Another test case: n=10, k=4.

- p1=ceil(10/4)=3, m1=floor(10/3)=3.

- remaining_coins=10-3*3=1.

- p2=ceil(1 / (4-3))=1.

- m2=floor(1/1)=1.

- total_jewels=3+1=4==k=4.

- Hence, "YES" with two stalls: 3 and 1.

Correct.

Another test case: n=5, k=2.

- p1=ceil(5/2)=3, m1=floor(5/3)=1.

- remaining_coins=5-1*3=2.

- p2=ceil(2 / (2-1))=ceil(2/1)=2.

- m2=floor(2/2)=1.

- total_jewels=1+1=2==k=2.

- Hence, "YES" with two stalls: 3 and 2.

Correct.

Another test case: n=10, k=5.

- p1=ceil(10/5)=2, m1=floor(10/2)=5.

- total_jewels=5==k=5.

- Hence, "YES" with one stall: 2.

Correct.

Another test case: n=10, k=6.

- p1=ceil(10/6)=2, m1=floor(10/2)=5.

- remaining_coins=10-5*2=0.

- p2=ceil(0 / (6-5))=0 → set p2=1.

- m2=floor(0/1)=0.

- total_jewels=5+0=5 <6.

- Hence, "NO".

Correct, since it's impossible to buy 6 jewels with 10 coins.

Hence, this approach seems to work for these cases.

But I need to ensure that s <=60.

In the above approach, s is at most 2, which is less than 60.

Hence, it satisfies the constraint.

Therefore, I can implement this approach.

Let me summarize the algorithm:

func_1(n, k):

if k > n:

print('NO')

return

p1 = ceil(n / k)

m1 = floor(n / p1)

if m1 == k:

