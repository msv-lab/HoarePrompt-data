Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n containers of water, each with some amount of water, a_i units. The sum of all a_i is divisible by n, which means that theoretically, we can distribute the water equally among all containers. The goal is to determine whether it's possible to make the amount of water in all containers the same using a specific operation: pouring any amount of water from container i to container j, but only if i < j.

First, I need to understand the constraints and what operation I can perform. The operation allows me to pour water from a container with a lower index to a container with a higher index. This is important because it imposes a direction on the flow of water—water can only move from left to right in the line of containers.

Given that, I need to figure out if it's possible to make all containers have the same amount of water by only moving water from left to right.

Let's consider the target amount of water each container should have. Since the total sum is divisible by n, the target is sum(a_i) / n. Let's call this target.

So, for each container, if it has more than the target, it needs to give some water to the containers on its right. If it has less than the target, it needs to receive water from the containers on its left.

But wait, the operation only allows pouring from i to j where i < j. So, a container can only give water to containers on its right, and can only receive water from containers on its left.

Therefore, to make all containers have the target amount, each container must have at least the target amount minus the sum of the deficits of all containers to its left.

Wait, that sounds confusing. Let me think differently.

Let me consider processing the containers from left to right. I'll keep track of the cumulative surplus or deficit up to each container.

Start with container 1:

- If container 1 has more than the target, it can give the excess to the containers on its right.

- If it has less, it needs to receive water from somewhere on its left, but since it's the first one, it can't receive from anywhere. So, if container 1 has less than the target, it's impossible to make all containers equal.

Wait, but according to the operation, I can only pour from i to j where i < j. So, if container 1 has less than the target, there's no way to add water to it from the left since there's no container before it.

Similarly, container 1 can only give water to containers on its right.

So, in order to make container 1 reach the target, if it's deficient, there's no way to do it because there's no container before it to take water from.

Therefore, container 1 must have at least the target amount.

Wait, but that can't be right. If container 1 has less than the target, maybe the containers to its right have excess that can be poured into it.

But according to the operation, I can only pour from a lower index to a higher index, not the other way around.

So, in fact, container 1 can only give water to containers on its right, not receive.

Therefore, if container 1 has less than the target, there's no way to make it reach the target because it can't receive water from the left.

Hence, container 1 must have at least the target amount.

Similarly, for container 2, it can receive water from container 1 (if container 1 has excess) and from containers to its right.

But, since water can only flow from left to right, container 2 can only receive water from container 1 or from containers to its right.

Wait, but container 1 can give water to container 2, and container 2 can give water to container 3, and so on.

So, in order to make container 2 reach the target, it must have, after receiving water from container 1, at least the target amount.

But container 1 can only give its excess water to container 2.

So, the water available to container 2 is its own water plus any excess from container 1.

Therefore, for container 2 to reach the target, it must be that a[1] + a[2] >= target * 2.

Because container 1 can give its excess to container 2.

Similarly, for container 3, it must have a[1] + a[2] + a[3] >= target * 3, and so on.

Wait, that seems promising.

So, in general, for each k from 1 to n, the sum of the first k containers must be at least target * k.

Because, to make the first k containers each have at least the target, their total water must be at least k * target.

If that's not the case for any k, then it's impossible.

And, since water can only flow from left to right, the first k containers can only use their own water among themselves; they can't receive water from containers to the right.

Therefore, for each k from 1 to n, sum(a[1..k]) >= target * k must hold.

If that's true for all k, then it's possible to distribute the water such that each container has exactly the target amount.

Otherwise, it's impossible.

Let me test this idea with the sample input.

Sample Input:

6

1

43

2

1 3

5

4 5 2 1 3

3

1 2 3

7

4 5 5 0 6 4 4

7

6 5 5 1 3 4 4

Sample Output:

YES

NO

YES

NO

NO

YES

Let's take the second test case:

n=2

a=[1,3]

target = (1+3)/2 = 2

Check:

k=1: sum(a[1..1]) = 1 < 2*1 = 2 → impossible → NO

Third test case:

n=5

a=[4,5,2,1,3]

target = (4+5+2+1+3)/5 = 15/5=3

Check:

k=1: sum=4 >=3*1=3 → OK

k=2: sum=4+5=9 >=3*2=6 → OK

k=3: sum=4+5+2=11 >=3*3=9 → OK

k=4: sum=4+5+2+1=12 >=3*4=12 → OK

k=5: sum=4+5+2+1+3=15 >=3*5=15 → OK

All conditions satisfied → YES

Fourth test case:

n=3

a=[1,2,3]

target=(1+2+3)/3=6/3=2

Check:

k=1: sum=1 <2*1=2 → impossible → NO

Fifth test case:

n=7

a=[4,5,5,0,6,4,4]

target=(4+5+5+0+6+4+4)/7=28/7=4

Check:

k=1: 4 >=4*1=4 → OK

k=2: 4+5=9 >=4*2=8 → OK

k=3: 4+5+5=14 >=4*3=12 → OK

k=4: 4+5+5+0=14 >=4*4=16 → 14 <16 → NO

Sixth test case:

n=7

a=[6,5,5,1,3,4,4]

target=(6+5+5+1+3+4+4)/7=28/7=4

Check:

k=1:6>=4*1=4 → OK

k=2:6+5=11>=4*2=8 → OK

k=3:6+5+5=16>=4*3=12 → OK

k=4:6+5+5+1=17>=4*4=16 → OK

k=5:6+5+5+1+3=20>=4*5=20 → OK

k=6:6+5+5+1+3+4=24>=4*6=24 → OK

k=7:6+5+5+1+3+4+4=28>=4*7=28 → OK

All conditions satisfied → YES

This matches the sample output.

So, the condition seems to hold.

Therefore, the algorithm is:

- For each test case:

- Read n and a[1..n]

- Compute target = sum(a)/n

- For k from 1 to n:

- If sum(a[1..k]) < target*k:

- Output "NO"

- After checking all k, output "YES"

Now, looking at the given program:

import sys

input = sys.stdin.read

data = input().split()

n = int(data[0])

a = list(map(int, data[1:]))

print(func_1(n, a))

def func_1(n, a):

total_water = sum(a)

if total_water % n != 0:

return 'No'

target = total_water // n

container = 0

for water in a:

container += water - target

if container < 0:

return 'No'

return 'Yes'

Wait, but according to the problem, it's guaranteed that the sum of a_i is divisible by n, so the if total_water % n != 0: return 'No' is unnecessary, because according to the problem, it's always divisible.

But perhaps it's there for safety.

Now, the function iterates through the list, keeping a running sum of (water - target). If at any point this cumulative sum becomes negative, it returns 'No'.

This seems similar to the condition I derived earlier.

Let me see.

In my earlier reasoning, for each k from 1 to n, sum(a[1..k]) >= target*k.

This is equivalent to sum(a[1..k]) - target*k >=0.

Which is equivalent to the cumulative sum of (a[i] - target) from i=1 to k being >=0.

Exactly what the function is checking.

So, if the cumulative sum of (a[i] - target) remains >=0 for all k from 1 to n, then it's possible, else not.

Hence, the given program seems correct.

Let me verify with the sample input.

First test case:

n=1

a=[43]

target=43

cumulative sum: 43-43=0 >=0 → YES

Second test case:

n=2

a=[1,3]

target=2

k=1: 1-2=-1 <0 → NO

Third test case:

n=5

a=[4,5,2,1,3]

target=3

k=1:4-3=1>=0

k=2:1+(5-3)=1+2=3>=0

k=3:3+(2-3)=3-1=2>=0

k=4:2+(1-3)=2-2=0>=0

k=5:0+(3-3)=0+0=0>=0 → YES

Fourth test case:

n=3

a=[1,2,3]

target=2

k=1:1-2=-1 <0 → NO

Fifth test case:

n=7

a=[4,5,5,0,6,4,4]

target=4

k=1:4-4=0>=0

k=2:0+(5-4)=0+1=1>=0

k=3:1+(5-4)=1+1=2>=0

k=4:2+(0-4)=2-4=-2 <0 → NO

Sixth test case:

n=7

a=[6,5,5,1,3,4,4]

target=4

k=1:6-4=2>=0

k=2:2+(5-4)=2+1=3>=0

k=3:3+(5-4)=3+1=4>=0

k=4:4+(1-4)=4-3=1>=0

k=5:1+(3-4)=1-1=0>=0

k=6:0+(4-4)=0+0=0>=0

k=7:0+(4-4)=0+0=0>=0 → YES

Which matches the sample output.

Therefore, the program is correct.

**Final Answer**

\[ \boxed{\text{See the explanation for the code.}} \]