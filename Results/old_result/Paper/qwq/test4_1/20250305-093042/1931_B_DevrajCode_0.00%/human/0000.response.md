Alright, I have this problem to solve. Let's see what it's about. There are n containers of water lined up in a row, each containing a certain amount of water. The goal is to make sure that all containers have the same amount of water, and I can only pour water from a container with a lower index to one with a higher index. Also, it's guaranteed that the total amount of water is divisible by the number of containers, so it's possible to have an equal amount in each container in theory.

First, I need to understand the constraints and what operations are allowed. I can only pour water from a container i to a container j if i < j. That means water can only move from left to right, not the other way around. I need to find out if it's possible to make all containers have the same amount of water with this restriction.

Given that the total water is divisible by the number of containers, I can calculate the target amount each container should have by dividing the total water by the number of containers.

So, the target is total_water // n.

Now, I need to check if it's possible to reach this target for each container, given the pouring restriction.

I should think about the cumulative water up to each container. Since I can only pour water from left to right, each container can only receive water from the containers before it, not after.

Wait, no, actually, reading the problem again, it says: "pour any amount of water from the i-th container to the j-th container, where i must be less than j (i.e., i < j)."

So, water can only be poured from a left container to a right container, but once it's poured to a right container, it can't be poured back to a left container because of the i < j constraint.

So, the water flow is unidirectional, from left to right.

Given that, the leftmost containers can only give water to the right, not receive from the right.

Similarly, the rightmost container can only receive water from the left, but since no one can pour into it from the right, it can only have its initial amount plus any water poured into it from the left.

Wait, but according to the problem, when pouring from i to j, i < j, so only left to right pouring is allowed.

So, for the first container, it can only keep its initial amount or pour some to the right containers, but it cannot receive any water from the right.

Similarly, the last container can only receive water from the containers before it, but cannot pour any water out to the right since there is no one to its right.

Given that, I need to ensure that each container, starting from the left, has at least the target amount minus the water it has already received from the previous containers.

Wait, perhaps I need to iterate from left to right and keep track of the cumulative water up to each point.

Let me think about it step by step.

First, calculate the target amount: total_water // n.

Then, iterate through the containers from left to right.

At each step, check if the current container has more or less than the target.

If it has more than the target, I can pour the excess to the right containers.

If it has less than the target, I need to see if there's enough water from the previous containers to make up the difference.

But given that water can only be poured from left to right, I need to ensure that the cumulative water up to that point is at least the target times the number of containers up to that point.

Wait, maybe I need to keep track of the cumulative sum and compare it to the target multiplied by the number of containers up to that point.

Let's formalize it.

Let prefix_sum[k] be the sum of a[0] to a[k-1] (0-indexed).

Then, for the first k containers, the total water should be at least k * target.

Because if I have k containers, each needs to have at least the target amount.

So, prefix_sum[k] >= k * target for all k from 1 to n.

If this condition holds for all k, then it's possible to distribute the water as required.

Wait, but I need to make sure that the cumulative sum up to each point is at least the target times the number of containers up to that point.

Wait, but since water can only be poured from left to right, the first container must have at least the target amount, because it can't receive any water from the right.

Wait, no, the first container can have less than the target, but then it would need to receive water from the containers to its right, but according to the problem, I can only pour from left to right.

Wait, no, I think I'm getting confused.

Let me read the problem again: "pour any amount of water from the i-th container to the j-th container, where i must be less than j (i.e., i < j)."

So, water can only be poured from left to right.

Therefore, the first container can only keep its water or pour some to the right, but it cannot receive any water from the right because there's no one to its left.

Similarly, the last container can only receive water from the left, but cannot pour any out since there's no one to its right.

Given that, the first container must have at least the target amount, because it can't receive any water from the left.

Wait, but actually, no. If the first container has less than the target, it could potentially receive water from the containers to its right, but given that water can only be poured from left to right, it cannot receive water from the right.

Wait, but if I can only pour from left to right, then the first container can only keep its water or pour some to the right, but it cannot receive any water from the right because there's no one to pour into it from the right.

Therefore, the first container must have at least the target amount.

Similarly, the second container can receive water from the first container, but only if the first container has excess water.

Wait, no, actually, according to the problem, I can pour from i to j where i < j.

So, from the first container to the second, third, etc., but not the other way around.

So, the first container can only give water to the right, not receive from the right.

Therefore, the first container must have at least the target amount, because it can't receive any water.

Similarly, the second container can receive water from the first container, but only if the first container has excess water.

So, for the second container, its initial amount plus any water poured from the first container should be at least the target.

But, since the first container can only give water to the second container, and not receive from the second, the first container's water after pouring should not go below the target.

Wait, no, actually, the first container doesn't have to keep any water for itself; it can pour all its excess water to the right containers.

But, given that the first container must have at least the target amount after all pourings, because it can't receive any water from the left.

Wait, but the problem is to make all containers have the same amount, which is the target.

So, for the first container, after pouring some water to the right, it should retain the target amount.

Similarly, for each subsequent container, it can receive water from the left and possibly pour some to the right.

But, the cumulative sum up to each point should be at least the target times the number of containers up to that point.

Wait, maybe I need to iterate through the containers and keep track of the deficit or surplus.

Let me try to think of an algorithm.

Initialize a variable, say, "excess" = 0.

Iterate through the containers from left to right.

For each container:

if a[i] + excess < target:

# there is a deficit

deficit = target - (a[i] + excess)

# check if the deficit can be covered by the excess from previous containers

# but since excess is the excess water available from previous pourings, and it's less than needed, it's impossible

if excess < deficit:

return 'No'

else:

# pour enough water to make a[i] up to target

a[i] += min(excess, deficit)

excess += (a[i] - target)

else:

# a[i] + excess >= target

# pour excess water to the right

excess += (a[i] + excess - target)

Wait, this seems complicated.

Maybe there's a simpler way.

Given that water can only be poured from left to right, the cumulative sum up to each point should be at least the target times the number of containers up to that point.

So, for each k from 1 to n:

sum(a[0] to a[k-1]) >= target * k

If this holds for all k, then it's possible.

Otherwise, it's not possible.

Let me test this logic with the sample input.

Sample Input:

6

1

43

2

1 3

5

4 5 2 1 3

3

1 2 3

7

4 5 5 0 6 4 4

7

6 5 5 1 3 4 4

Sample Output:

YES

NO

YES

NO

NO

YES

Take the second test case:

n = 2

a = [1, 3]

target = (1+3)/2 = 2

Check cumulative sums:

k=1: sum(a[0]) = 1 >= 2*1 = 2 ? No, 1 < 2 → 'NO'

Which matches the sample output.

Third test case:

n=5

a=[4,5,2,1,3]

target = (4+5+2+1+3)/5 = 15/5=3

Check cumulative sums:

k=1: sum=4 >= 3*1=3 → yes

k=2: sum=4+5=9 >= 3*2=6 → yes

k=3: sum=4+5+2=11 >= 9 → yes

k=4: sum=4+5+2+1=12 >= 12 → yes

k=5: sum=4+5+2+1+3=15 >= 15 → yes

So, 'YES'

Fourth test case:

n=3

a=[1,2,3]

target=(1+2+3)/3=2

Check cumulative sums:

k=1: 1 >= 2? No → 'NO'

Which matches the sample output.

So, this seems to be a correct approach.

Therefore, in the code, I need to:

- Read t test cases.

- For each test case:

- Read n

- Read a list of n integers

- Calculate target = sum(a) // n

- Iterate through the list, keeping a running sum

- At each step, check if running sum >= target * k, where k is the current index +1

- If all checks pass, output 'YES'; else, 'NO'

Now, looking at the given program:

import sys

input = sys.stdin.read

data = input().split()

n = int(data[0])

a = list(map(int, data[1:]))

print(func_1(n, a))

def func_1(n, a):

total_water = sum(a)

if total_water % n != 0:

return 'No'

target = total_water // n

container = 0

for water in a:

container += water - target

if container < 0:

return 'No'

return 'Yes'

So, the function func_1 seems to implement the logic I just described.

It calculates the target, then iterates through the list, keeping a running sum of (water - target), and checks if this running sum ever goes negative.

Wait, is this equivalent to checking if the cumulative sum up to each point is >= target * k?

Let's see.

Initialize container = 0

For each water in a:

container += water - target

So, container is累加每个容器的水量减去目标水量。

如果在任何一步container小于0，说明累计的水量减去目标水量的总和小于0，即累计水量小于目标水量的累计需求。

这与我之前的想法一致：累计水量应该大于或等于目标水量的累计需求。

所以，如果container >= 0一直 holds，那么就是YES，否则是NO。

因此，这个实现是正确的。

再看看样本输入：

6

1

43

2

1 3

5

4 5 2 1 3

3

1 2 3

7

4 5 5 0 6 4 4

7

6 5 5 1 3 4 4

对于第二个测试用例，n=2, a=[1,3]

target=2

container变化：

container += 1-2 = -1 <0 → 'No'

对于第三个测试用例，n=5, a=[4,5,2,1,3]

target=3

container变化：

container +=4-3=1

container +=5-3=3

container +=2-3=2

container +=1-3=-1 <0 → 'No' wait, but sample output is 'Yes'

Wait, but in the earlier manual check, it should be 'Yes'.

Wait, perhaps I miscalculated.

Wait, cumulative sums:

k=1: 4 >= 3

k=2: 4+5=9 >= 6

k=3: 4+5+2=11 >= 9

k=4: 4+5+2+1=12 >= 12

k=5: 15 >=15

All hold, so it should be 'Yes'

But according to the code:

container +=4-3=1

container +=5-3=3

container +=2-3=1

container +=1-3=-1 <0 → 'No'

Wait, but according to my earlier reasoning, it should be 'Yes'

So, perhaps there's a mistake in the code.

Wait, no, perhaps I misread the code.

Wait, in the code, it's:

container += water - target

So, for the third test case:

a=[4,5,2,1,3]

target=3

container=0

container +=4-3=1 → container=1

container +=5-3=2 → container=3

container +=2-3=-1 → container=2

container +=1-3=-1 → container=1

container +=3-3=0 → container=1

Never goes negative, so 'Yes'

Wait, no, 2-3=-1, but container was 3, so 3 + (-1) = 2

Then 2 + (-2) = 0, but wait, 1-3=-2

Wait, a=[4,5,2,1,3]

target=3

container=0

container +=4-3=1 →1

container +=5-3=2 →3

container +=2-3=-1 →2 (3 + (-1)=2)

container +=1-3=-2 →0 (2 + (-2)=0)

container +=3-3=0 →0

Never goes negative, so 'Yes'

But in my earlier manual check, I thought it would go negative, but it doesn't.

So, the code seems correct.

Therefore, the program is correct.

**Final Solution**

To solve this problem, we need to determine if it is possible to make the amount of water in each container the same by pouring water from left to right as per the given constraints.

## Approach

1. **Understand the Problem:**
   - We have `n` containers arranged in a line, each containing a certain amount of water.
   - We can pour water from a container with a lower index to a container with a higher index (left to right).
   - The total sum of water is divisible by the number of containers, ensuring an equal distribution is mathematically possible.

2. **Determine the Target Amount:**
   - Calculate the target amount of water each container should have by dividing the total water by the number of containers: `target = total_water // n`.

3. **Check Cumulative Sums:**
   - To ensure that we can distribute the water correctly with the pouring constraints, we need to make sure that at any point, the cumulative water up to that container is at least the target amount multiplied by the number of containers up to that point.
   - This is achieved by maintaining a running sum of the differences between the current container's water and the target. If this running sum ever becomes negative, it means that at some point, we don't have enough water to meet the target requirements, hence it's impossible to equalize the water levels under the given constraints.

4. **Algorithm:**
   - For each test case:
     - Read the number of containers `n` and the list of water amounts `a`.
     - Calculate the target amount.
     - Iterate through the containers, maintaining a running sum of `(current water - target)`.
     - If the running sum becomes negative at any point, return 'No'.
     - If the running sum remains non-negative for all containers, return 'Yes'.

## Solution Code

```python
import sys

def main():
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index = 1
    for _ in range(t):
        n = int(data[index])
        a = list(map(int, data[index+1:index+1+n]))
        index += 1 + n
        print(func_1(n, a))

def func_1(n, a):
    total_water = sum(a)
    if total_water % n != 0:
        return 'No'
    target = total_water // n
    container = 0
    for water in a:
        container += water - target
        if container < 0:
            return 'No'
    return 'Yes'

if __name__ == "__main__":
    main()
```

## Explanation

- **Input Handling:**
  - Read all input data at once for efficiency.
  - Parse the number of test cases `t`.
  - For each test case, read `n` (number of containers) and the list `a` (water in each container).

- **Target Calculation:**
  - Compute the target amount of water each container should have: `target = total_water // n`.

- **Feasibility Check:**
  - Use a running sum (`container`) that adds `water - target` for each container.
  - If `container` becomes negative at any point, it means we don't have enough water to meet the target, so return 'No'.
  - If the loop completes without the running sum becoming negative, return 'Yes'.

This approach ensures that we are adhering to the constraints of pouring water only from left to right while achieving the goal of equalizing the water levels in all containers.