Alright, I have this problem to solve. Let's see what it's asking for. So, Nikita has some cubes, and he wants to build a tower by adding or removing one cube at a time in each move. He can do this for n moves, and I need to figure out if it's possible to have exactly m cubes in the tower at the end of these n moves.

First, I need to understand the operations he can perform. In each move, he can either add one cube to the top of the tower or remove one cube from the top. That means the tower's height can increase or decrease by one in each step.

I need to consider the sequence of these operations over n moves and see if it's possible to end up with exactly m cubes in the tower.

Let me think about the initial state. Initially, the tower has no cubes. So, starting from zero cubes, after n moves, can I have m cubes?

Let's consider a simple case. If n = 3 and m = 3, can I have 3 cubes after 3 moves? Well, if I add a cube in each of the 3 moves, I'll have 3 cubes. So, that's "Yes."

Another case: n = 2 and m = 4. Can I have 4 cubes after 2 moves? If I start with 0, add one to get 1, add another to get 2. So, I only have 2 cubes, not 4. Is there a way to get 4? Wait, I can't remove cubes in a way that increases the number beyond what I've built. So, seems like "No."

Third case: n = 5 and m = 3. Can I have 3 cubes after 5 moves? Let's see. One possible sequence: add, add, add, remove, add. That would be 1, 2, 3, 2, 3. So, yes, that works.

From these examples, I need to find a general rule.

Let's think about the maximum and minimum number of cubes I can have after n moves.

- The maximum number of cubes is if I add a cube in every move: m = n.

- The minimum number of cubes is if I remove a cube in every move, but I can't have negative cubes, so it's m = 0 (if n is even, I can remove as many as I add, but since I start from 0, removing when there are no cubes isn't allowed. So actually, the minimum is m = n if n is less than or equal to 0, but starting from 0, I can't have negative cubes.

Wait, that seems confusing. Let's think differently.

Each move is either +1 or -1, starting from 0.

So, after n moves, the number of cubes in the tower can be represented as the difference between the number of addition moves and the number of removal moves.

Let’s denote:

- x = number of addition moves

- y = number of removal moves

Then:

- x + y = n (total moves)

- m = x - y (since each addition adds 1 and each removal subtracts 1)

So, we have:

m = x - y

n = x + y

We can solve these equations for x and y:

x = (n + m)/2

y = (n - m)/2

For x and y to be non-negative integers, (n + m) must be even, and (n - m) must be even, and x and y must be greater than or equal to 0.

Wait, actually, since x and y are integers, (n + m) must be even, because x must be an integer.

Similarly, (n - m) must be even for y to be an integer.

Also, x >= 0 and y >= 0.

But, in the context of the problem, y (removal moves) can't exceed the current number of cubes in the tower. Meaning, I can't remove more cubes than are present.

This seems like a crucial point. So, the sequence matters because I can't remove cubes that aren't there.

But, in the equations above, we're just considering the final state, not the path.

I think I need to consider the constraints more carefully.

Let's consider the constraints:

1. x + y = n

2. m = x - y

3. x >= 0

4. y >= 0

5. y <= some value depending on the current number of cubes.

But, constraint 5 is tricky because it depends on the sequence of moves.

Maybe there's a better way to approach this.

I recall that in such problems, the number of additions and removals must satisfy certain parity conditions.

Let me think about parity.

If n and m are both even or both odd, that might be a condition.

Wait, from the equations:

x = (n + m)/2

y = (n - m)/2

For x and y to be integers, (n + m) must be even, and (n - m) must be even.

Actually, (n + m) and (n - m) are both even only if n and m are both even or both odd.

Wait, no.

Let's see:

- If n and m are both even, then (n + m) is even, and (n - m) is even.

- If n and m are both odd, (n + m) is even, and (n - m) is even.

- If one is even and the other is odd, (n + m) is odd, and (n - m) is odd.

So, x and y are integers only if n and m are both even or both odd.

But, there's more to it.

Also, x and y must be non-negative.

So, (n + m)/2 >= 0 and (n - m)/2 >= 0.

Which implies:

n + m >= 0 and n - m >= 0

Since n and m are positive integers, n + m >= 0 is always true.

So, the main condition is n - m >= 0, which means n >= m.

But, in the second test case, n=2 and m=4, which has n < m, so "No".

In the first test case, n=3 and m=3, n >= m, and both are odd, so "Yes".

In the third test case, n=5 and m=3, n >= m, and both are odd, so "Yes".

Wait, but according to the earlier condition, it's not just about n >= m and both being odd or both even.

Wait, in the second test case, n=2 and m=4, n < m, so "No", regardless of parity.

In the first test case, n=3 and m=3, n >= m, and both are odd, "Yes".

In the third test case, n=5 and m=3, n >= m, and both are odd, "Yes".

But, is n >= m the only condition?

Wait, no. In the second test case, n=2 and m=0, it's possible to have m=0 with n=2 by adding and then removing, or removing and then adding, but since we start with 0, removing first isn't allowed.

Wait, but in the problem statement, it says: "the tower doesn't have any cubes initially", and "remove exactly 1 cube from the top of the tower".

So, if the tower has no cubes, removing a cube isn't allowed.

Therefore, in the sequence of moves, we can't have a removal move before an addition move.

Wait, more precisely, we can't have a removal move when the tower has zero cubes.

So, the sequence must ensure that we don't remove a cube when the tower is empty.

This makes the problem more complex, as we need to consider the order of operations.

This seems tricky to handle directly.

Maybe there's a simpler way.

I found this reference solution:

def func():

a = int(input())

for i in range(a):

(b, c) = map(int, input().split())

q = (b, c)

if b == c:

print('YES')

elif b < c:

print('NO')

elif a % 2 == b % 2:

print('Yes')

else:

print('No')

Let's analyze this solution step by step.

First, it reads the number of test cases, a.

Then, for each test case, it reads b (n) and c (m).

Then, it checks:

1. If b == c, print "YES"

2. Elif b < c, print "NO"

3. Elif a % 2 == b % 2, print "Yes"

4. Else, print "No"

Wait, a is the number of test cases, which is constant for all test cases. So, a % 2 is either 0 or 1, and it's the same for all test cases.

But in the problem, t is the number of test cases, and in the solution code, t is named as a.

Assuming t is a, then in each test case, it reads b and c, which are n and m respectively.

So, the conditions are:

1. If n == m, print "YES"

2. Elif n < m, print "NO"

3. Elif t % 2 == n % 2, print "Yes"

4. Else, print "No"

But t is the number of test cases, which is independent of n and m.

I think there might be a mistake in the solution code.

Wait, in the problem statement, "Each test contains multiple test cases. The first line of input contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. The description of the test cases follows.

The only line of each test case contains two integers n and m (1 ≤ n, m ≤ 100)."

So, t is the number of test cases.

In the solution code, a = int(input()), which is t.

Then, for i in range(a):

(b, c) = map(int, input().split())

q = (b, c)

Then, the conditions are based on b and c.

But in the third condition, it checks a % 2 == b % 2.

Wait, a is t, the number of test cases, which is unrelated to n and m.

I think it's a mistake in the solution code.

It should probably be checking b % 2 == c % 2, meaning n and m have the same parity.

So, perhaps it should be:

if n == m:

print("YES")

elif n < m:

print("NO")

elif n % 2 == m % 2:

print("Yes")

else:

print("No")

But, as I thought earlier, n >= m is a necessary condition.

Additionally, n and m need to have the same parity, meaning both even or both odd.

Because, from the earlier equations:

x = (n + m)/2

y = (n - m)/2

For x and y to be integers, n + m must be even, which implies n and m have the same parity.

Also, n >= m is necessary because y = (n - m)/2 >= 0.

Moreover, we need to ensure that in the sequence of moves, we don't try to remove a cube when the tower is empty.

But, if we ensure that the number of removals doesn't exceed the current number of cubes, which is guaranteed if y <= x, but I'm not sure.

Wait, perhaps it's sufficient to just check n >= m and n and m have the same parity.

Let me test this with the example cases.

First test case: n=3, m=3

n == m, so "YES"

Second test case: n=2, m=4

n < m, so "NO"

Third test case: n=5, m=3

n >= m and both are odd, so "Yes"

Seems correct.

Let me think of some more test cases.

Test case 1: n=1, m=1

Add one cube, end with one cube: "Yes"

Test case 2: n=1, m=0

Not possible, since you can't remove a cube from an empty tower: "No"

Wait, but according to the condition, n=1, m=0: n >= m and n and m have different parity, so it would go to "No", which is correct.

Test case 3: n=4, m=2

n >= m, both even: "Yes"

Sequence: add, add, add, remove -> 1,2,3,2

Test case 4: n=3, m=2

n >= m, both odd: "Yes"

But sequence: add, add, remove -> 1,2,1 (not 2)

Wait, that's 1,2,1, which is not 2.

Alternative sequence: add, remove, add -> 1,0,1 (invalid, can't remove from 0)

Wait, but according to the condition, n >= m and both have different parity.

Wait, n=3 is odd, m=2 is even, so n % 2 != m % 2, which would go to "No", but actually, is it possible?

Let's see:

Sequence:

Add, add, add -> 1,2,3

Then remove one -> 2

But that's 3 moves to get m=2, which seems possible.

But according to the condition, since n=3 and m=2 have different parity, it would print "No", but actually, it's possible.

Wait, this seems like a mistake.

Wait, in my earlier reasoning, I thought that n and m need to have the same parity, but in this case, n=3 and m=2 have different parity, but it seems possible to achieve m=2 with n=3 moves.

Wait, perhaps my earlier assumption is wrong.

Let me recast the equations.

x + y = n

x - y = m

Then, x = (n + m)/2

y = (n - m)/2

For x and y to be integers, (n + m) must be even, and (n - m) must be even.

But, in this case, n=3 and m=2:

x = (3 + 2)/2 = 2.5, which is not an integer.

y = (3 - 2)/2 = 0.5, not an integer.

So, it's impossible to have integer values for x and y, meaning it's impossible to achieve m=2 with n=3 moves.

Therefore, the condition should be that (n + m) is even and n >= m.

In this case, n=3 and m=2, n + m = 5, which is odd, so impossible.

Hence, the third condition in the code is incorrect.

The correct conditions are:

- If n == m, print "YES"

- Elif n < m, print "NO"

- Else (n > m), check if (n + m) is even and n >= m, then "Yes", else "No"

But since n >= m is already ensured in the else clause, it's sufficient to check if (n + m) is even.

Wait, no.

Wait, if n > m, and (n + m) is even, then "Yes", else "No"

But in the earlier mistaken test case, n=3, m=2, n > m, but n + m = 5, which is odd, so "No", which matches the earlier conclusion.

Another test case: n=4, m=2

n > m, n + m = 6, even, so "Yes"

Sequence: add, add, add, remove -> 1,2,3,2

That works.

Another test case: n=5, m=1

n > m, n + m = 6, even, so "Yes"

Sequence: add, add, add, remove, remove -> 1,2,3,2,1

Works.

Another test case: n=5, m=3

n > m, n + m = 8, even, so "Yes"

Sequence: add, add, add, remove, add -> 1,2,3,2,3

Works.

Another test case: n=4, m=0

n > m, n + m = 4, even, so "Yes"

Sequence: add, add, remove, remove -> 1,2,1,0

Works.

Another test case: n=3, m=0

n > m, n + m = 3, odd, so "No"

Indeed, it's impossible to have m=0 with n=3 moves.

Because x = (3 + 0)/2 = 1.5, not integer.

So, the correct condition is:

- If n == m, "YES"

- Elif n < m, "NO"

- Else (n > m), if (n + m) is even, "Yes", else "No"

Therefore, the reference solution seems to have a mistake.

In the reference solution, it has:

elif a % 2 == b % 2:

print('Yes')

else:

print('No')

But a is t, the number of test cases, which is unrelated to n and m.

It should be checking if (n + m) % 2 == 0.

So, the correct condition should be:

elif (n + m) % 2 == 0:

print("Yes")

else:

print("No")

Therefore, the reference solution is incorrect.

Hence, Correctness: **False**

**Final Solution**

To solve this problem, we need to determine if it is possible for Nikita to have exactly `m` cubes in the tower after performing `n` moves, where each move consists of either adding or removing one cube from the tower.

### Approach

1. **Initial Considerations**:
   - We start with 0 cubes.
   - Each move can either add or remove one cube.

2. **Key Observations**:
   - To achieve exactly `m` cubes in `n` moves, the difference between the number of addition moves and removal moves must be `m`.
   - The total number of moves `n` must be greater than or equal to `m` because removing cubes cannot bring the count below 0.

3. **Mathematical Formulation**:
   - Let `x` be the number of addition moves.
   - Let `y` be the number of removal moves.
   - We have two equations:
     - `x + y = n` (total moves)
     - `x - y = m` (net addition)
   - Solving these equations:
     - `x = (n + m)/2`
     - `y = (n - m)/2`
   - For `x` and `y` to be integers (since moves are whole numbers), `(n + m)` must be even.

4. **Conditions for Feasibility**:
   - `n >= m` to ensure non-negative cube count.
   - `(n + m)` is even to ensure `x` and `y` are integers.

### Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        n, m = map(int, input().split())
        if n == m:
            print('YES')
        elif n < m:
            print('NO')
        elif (n + m) % 2 == 0:
            print('Yes')
        else:
            print('No')

func()
```

### Explanation

- **Input Handling**:
  - Read the number of test cases `t`.
  - For each test case, read `n` and `m`.

- **Decision Logic**:
  - If `n` equals `m`, it is always possible by adding one cube in each move.
  - If `n` is less than `m`, it is impossible since we cannot have more cubes than the total moves.
  - If `n` is greater than `m`, check if `(n + m)` is even. If so, it is possible to achieve `m` cubes; otherwise, it is not.

- **Output**:
  - Print "YES" if the conditions are met.
  - Print "NO" otherwise.

This approach ensures that we correctly determine the feasibility of achieving exactly `m` cubes in `n` moves by considering both the total moves and the parity of the sum of `n` and `m`.