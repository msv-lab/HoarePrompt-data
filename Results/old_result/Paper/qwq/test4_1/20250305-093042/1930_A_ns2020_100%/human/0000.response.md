Alright, I've got this problem to solve. Let's see what it's asking for. So, there are 2n positive integers on a whiteboard, and I need to perform n moves. In each move, I choose two integers, add the smaller one to my score, and erase both from the board. I have to do this n times, and I want to maximize my total score.

First, I need to understand the problem clearly. I have a set of numbers, and I need to pair them up in such a way that the sum of the smaller numbers in each pair is as large as possible. Since I have to do this for multiple test cases, efficiency is probably important, but given that n can be up to 50 and 2n is 100, it's manageable.

Let me think about how to approach this. If I just pair any two numbers randomly, I might not be getting the maximum score. I need a strategy to pair them optimally.

One idea is to sort the numbers first. If I sort them in ascending order, I can see all the numbers from smallest to largest. Now, how should I pair them?

Suppose I have sorted list: a1, a2, a3, ..., a2n.

If I pair a1 with a2, then the smaller one is a1. Then, pair a3 with a4, the smaller one is a3, and so on.

Wait, but a1 is the smallest number, and pairing it with a2 means I'm adding a1 to the score. Similarly, a3 is smaller than a4, so adding a3.

But is this the best way? Let me consider another approach.

What if I pair the largest number with the smallest number? So, pair a1 with a2n.

Then, the smaller one is a1, so add a1 to the score.

Next, pair a2 with a2n-1, add a2, and so on.

Wait, in this case, I'm always adding the smaller one of each pair, but since I'm pairing the smallest with the largest, I might be missing out on higher values.

Wait, no. Let's think about an example.

Take the first test case: n=1, numbers are 2 and 3.

If I pair 2 and 3, I add min(2,3)=2 to the score.

That's what's done in the example.

So, in this case, sorting and pairing the smallest with the largest gives the same result.

But let's look at the second test case: n=2, numbers are 1,1,2,1.

Sort them: 1,1,1,2.

Now, pairing as per the program: a1=1, a2=1; add 1.

Then a3=1, a4=2; add 1.

Total score: 2.

Is this the maximum possible?

According to the note, it is.

Alternatively, if I pair 1 and 2 first, add 1, then pair 1 and 1, add 1 again. Total is still 2.

So, same result.

Another way: pair 1 and 1, add 1, then pair 1 and 2, add 1.

Again, 2.

Seems like no matter how I pair, I get the same score.

But let's check another example: n=3, numbers are all 1s.

Sorted: 1,1,1,1,1,1.

Pairing as per the program: a1=1, a2=1; add 1.

a3=1, a4=1; add 1.

a5=1, a6=1; add 1.

Total score: 3.

Which matches the example.

But is there a way to get a higher score?

If I pair differently, say pair 1 and 1, add 1; then pair 1 and 1, add 1; and finally pair 1 and 1, add 1. Still 3.

So, in this case, it's the same.

Wait, but in the first test case, pairing the smallest with the largest gave the same result as pairing smallest with next smallest.

But maybe in other cases, it makes a difference.

Let me think of a different example.

Suppose n=2, numbers are 1,2,3,4.

Sorted: 1,2,3,4.

Pairing as per the program: 1 with 2, add 1; 3 with 4, add 3. Total: 4.

Alternatively, pair 1 with 3, add 1; 2 with 4, add 2. Total: 3.

Or pair 1 with 4, add 1; 2 with 3, add 2. Total: 3.

So, in this case, pairing the smallest with the next smallest gives a higher total of 4.

Similarly, if I have n=3, numbers 1,2,3,4,5,6.

Sorted: 1,2,3,4,5,6.

Pairing as per the program: 1 with 2 (add 1), 3 with 4 (add 3), 5 with 6 (add 5). Total: 9.

Alternatively, pair 1 with 3 (add 1), 2 with 5 (add 2), 4 with 6 (add 4). Total: 7.

Or pair 1 with 5 (add 1), 2 with 4 (add 2), 3 with 6 (add 3). Total: 6.

So, again, pairing smallest with next smallest gives the highest score.

It seems like the strategy of sorting and pairing the smallest with the next smallest is optimal.

Wait, but why?

Because by pairing the smallest with the next smallest, you're ensuring that the smaller numbers are being added to the score, and you're not wasting larger numbers by pairing them with even larger ones.

In other words, you're maximizing the sum of the minimums by pairing numbers that are close to each other in value.

Let me think about it in terms of possible pairings.

In any pairing, you're adding the smaller number of the pair.

So, to maximize the sum of these minima, you want to pair numbers in such a way that the smaller numbers are as large as possible.

But in sorted order, pairing a1 with a2 ensures that a1 is paired with the next larger number, and so on.

Wait, but in the sorted list, a1 is the smallest, a2 is next, and so on.

So, pairing a1 with a2, a3 with a4, etc., ensures that the minima are a1, a3, a5, etc.

But is there a better way to pair them to get a higher sum?

Let's consider that in the sorted list, a1 < a2 < a3 < a4 < ... < a2n.

If I pair a1 with a2, I get a1.

If I pair a3 with a4, I get a3.

And so on.

Alternatively, if I pair a1 with a3, I get a1.

Pair a2 with a4, get a2.

Total would be a1 + a2 + a3 + ... as per the pairings.

But in the first approach, sum of a1, a3, a5, etc., seems to be less than sum of a2, a4, etc.

Wait, no.

Wait, in the first example with n=2 and numbers 1,2,3,4.

Pairing a1=1 with a2=2, sum +=1.

Pairing a3=3 with a4=4, sum +=3.

Total: 4.

Alternatively, pairing a1=1 with a3=3, sum +=1.

Pairing a2=2 with a4=4, sum +=2.

Total: 3.

So, the first approach gives a higher total.

Similarly, in n=3, numbers 1,2,3,4,5,6.

Pairing a1=1 with a2=2, sum +=1.

a3=3 with a4=4, sum +=3.

a5=5 with a6=6, sum +=5.

Total: 9.

Alternatively, pairing a1=1 with a3=3, sum +=1.

a2=2 with a4=4, sum +=2.

a5=5 with a6=6, sum +=5.

Total: 8.

Another way: pair a1=1 with a4=4, sum +=1.

a2=2 with a5=5, sum +=2.

a3=3 with a6=6, sum +=3.

Total: 6.

So, indeed, pairing the smallest with the next smallest gives the highest sum.

Therefore, the strategy is to sort the array in ascending order and pair each first number with the next one, adding the first one to the score.

In code, this is implemented by sorting the array and summing every other element starting from the first.

That's what the given program does: it sorts the array and sums A[0], A[2], A[4], etc., up to A[2n-2].

Hence, this approach is correct.

Therefore, the program is correct.

**Final Answer**

\[ \boxed{\text{See the program above}} \]

**Correctness: True**

