Alright, I have this problem to solve. Monocarp wants to throw a party and invite some of his friends, but there are some conditions. He has n friends, and each friend has a best friend, which is specified by p_i. The key points are:

1. All p_i are distinct and p_i != i.

2. A friend i will come to the party only if both friend i and friend p_i receive an invitation.

3. Monocarp wants at least 2 friends to come to the party.

4. He needs to send the minimum number of invitations to achieve this.

First, I need to understand the relationship between the friends. Since each friend has a unique best friend and p_i != i, it means that the friendships are pairwise and don't form any cycles beyond pairs.

For example, if p = [3,1,2,5,4], then:

- Friend 1's best friend is 3.

- Friend 2's best friend is 1.

- Friend 3's best friend is 2.

- Friend 4's best friend is 5.

- Friend 5's best friend is 4.

So, friends are paired up: (1,3), (2,1), (4,5). Wait, actually, since p_i is the best friend of i, and p_i are distinct, it forms mutual pairs. So, (1,3), (2,1), but 2's best friend is 1, who already has 3 as best friend? Wait, actually, in this example:

- 1's best friend is 3.

- 3's best friend is 2.

- 2's best friend is 1.

Wait, no, according to the input, p = [3,1,2,5,4], so:

- Friend 1's best friend is 3.

- Friend 2's best friend is 1.

- Friend 3's best friend is 2.

- Friend 4's best friend is 5.

- Friend 5's best friend is 4.

So, it's two cycles: (1,3,2) and (4,5).

But the problem says all p_i are distinct and p_i != i, and n can be up to 50.

Wait, but in this example, p = [3,1,2,5,4], which seems consistent.

Now, the condition for a friend to come is that both the friend and their best friend receive an invitation.

So, for friend i to come, both i and p_i must receive invitations.

Each invitation is sent to exactly one friend.

So, if I invite friend i, it counts as one invitation, and similarly for p_i.

But, if I invite both i and p_i, then friend i will come.

But, I need at least 2 friends to come.

I need to minimize the number of invitations sent.

Let me think about the example given:

First test case:

n = 5

p = [3,1,2,5,4]

Monocarp sends invitations to [1,2,4,5]

Then, friends [2,4,5] will come.

Wait, why does friend 2 come?

Friend 2 will come only if both friend 2 and friend p_2 (which is 1) are invited.

Yes, friend 2 is invited, and friend 1 is invited, so friend 2 comes.

Similarly, friend 4: invited, and friend p_4 =5 is invited, so friend 4 comes.

Friend 5: invited, and friend p_5 =4 is invited, so friend 5 comes.

Wait, but according to the problem, friend i comes only if both i and p_i are invited.

But in this case, friend 2,4,5 are coming because both they and their best friends are invited.

But friend 1 is invited, and friend 3 is invited, but friend 1 will not come because friend p_1 =3 is invited, but friend 1 is invited as well.

Wait, but according to the problem, "the i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation".

So, friend 1 should come because friend 1 and friend 3 are both invited.

But in the example, it says only friends [2,4,5] will come.

Wait, maybe I misread the example.

Wait, no, in the example, it says:

"the friends [2,4,5] will come to the party."

But according to the condition, friend 1 should also come because both friend 1 and friend 3 are invited.

Wait, maybe there is a misunderstanding.

Wait, let's read the problem again.

"the i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation (note that the p_i-th friend doesn't have to actually come to the party). Each invitation is sent to exactly one of the friends."

So, friend i comes if both friend i and friend p_i are invited, regardless of whether p_i comes or not.

In the example, friend 1 is invited, and friend 3 is invited, so friend 1 should come.

Similarly, friend 2 is invited, and friend p_2=1 is invited, so friend 2 should come.

Friend 3 is invited, and friend p_3=2 is invited, so friend 3 should come.

Friend 4 is invited, and friend p_4=5 is invited, so friend 4 should come.

Friend 5 is invited, and friend p_5=4 is invited, so friend 5 should come.

But in the example, it says only friends [2,4,5] will come.

Wait, maybe I'm misunderstanding something.

Wait, perhaps the friends come only if both they and their best friends are invited, but their best friends might not be coming because their best friends might not have been invited.

Wait, no, the condition is: friend i comes if both friend i and friend p_i are invited.

It doesn't depend on whether p_i comes or not.

So, in the example, if Monocarp sends invitations to [1,2,4,5], then friends [1,2,4,5] are invited.

Then, friend 1 comes because friend 1 and friend 3 are invited.

Friend 2 comes because friend 2 and friend 1 are invited.

Friend 4 comes because friend 4 and friend 5 are invited.

Friend 5 comes because friend 5 and friend 4 are invited.

So, all of them should come.

But in the example, it says only [2,4,5] come.

Wait, perhaps friend 3 is not invited, but in the example, friend 3 is invited because p_1=3, and friend 1 is invited.

Wait, no, friend 3 is invited explicitly in the invitation list [1,2,4,5].

Wait, maybe there's a mistake in the example explanation.

Wait, perhaps I misread the invitation list.

In the example, it says:

"Monocarp can send invitations to friends [1,2,4,5], then the friends [2,4,5] will come to the party."

Wait, perhaps friend 1 does not come because friend p_1=3 is invited, but friend 3 is not in the invitation list.

Wait, no, friend 3 is in the invitation list [1,2,4,5], but perhaps I misread the list.

Wait, no, friend 3 is not in the invitation list [1,2,4,5]. Wait, p = [3,1,2,5,4], so friend 1's best friend is 3, friend 2's best friend is 1, friend 3's best friend is 2, friend 4's best friend is 5, friend 5's best friend is 4.

So, if Monocarp sends invitations to [1,2,4,5], then:

- Friend 1 is invited, and friend p_1=3 is not invited, so friend 1 does not come.

- Friend 2 is invited, and friend p_2=1 is invited, so friend 2 comes.

- Friend 3 is not invited, so friend 3 does not come.

- Friend 4 is invited, and friend p_4=5 is invited, so friend 4 comes.

- Friend 5 is invited, and friend p_5=4 is invited, so friend 5 comes.

So, friends [2,4,5] come to the party.

I see, I misread the invitation list earlier. Friend 3 is not in the invitation list [1,2,4,5], so friend 1 does not come because friend p_1=3 is not invited.

Hence, only friends [2,4,5] come.

Okay, that makes sense now.

So, to rephrase, a friend i comes only if both friend i and friend p_i are invited.

Monocarp needs to send invitations such that at least 2 friends come.

He wants to minimize the number of invitations sent.

Now, I need to find the minimum number of invitations required to have at least 2 friends coming to the party.

Let me think about how to approach this.

First, note that the relationships form pairs or cycles.

Since p_i are distinct and p_i != i, it's a permutation with no fixed points.

In such permutations, you have cycles of even length or pairs.

Wait, actually, in general permutations without fixed points, cycles can be of any length greater than or equal to 2.

But in this problem, since p_i is the best friend of i, and p_i's best friend is some other j, it can form cycles of any length.

But given that p_i are distinct and p_i != i, it's a derangement.

But in this problem, it's specified that p_i are distinct and p_i != i, so it's a derangement.

But in the context of friendships, it's a matching, but since n can be odd, it might have cycles of various lengths.

Wait, no, in this setup, since p_i is the best friend of i, and p_j is the best friend of j, it forms a graph where each edge is mutual.

So, it's a disjoint union of cycles of even length or pairs.

Wait, no, actually, it can have cycles of any length.

For example, in the second test case:

n = 4

p = [2,3,4,1]

This forms a cycle: 1 -> 2 -> 3 -> 4 -> 1.

So, it's a cycle of length 4.

In the first test case:

n = 5

p = [3,1,2,5,4]

This seems to have two cycles: (1->3->2->1) and (4->5->4).

Wait, no, p = [3,1,2,5,4], so:

1's best friend is 3.

3's best friend is 2.

2's best friend is 1.

4's best friend is 5.

5's best friend is 4.

So, it's a cycle of length 3 (1,3,2) and a cycle of length 2 (4,5).

Wait, but the problem says all p_i are distinct and p_i != i, which is satisfied here.

So, in general, we can have cycles of any length greater than or equal to 2.

Now, to minimize the number of invitations, we need to select a subset of friends to invite such that at least 2 friends come to the party, i.e., at least 2 friends have both themselves and their best friends invited.

Let me think about the cycles.

In a cycle of length k, what is the minimal number of invitations needed to have at least 2 friends come?

For example, in a cycle of length 2: A and B are best friends of each other.

If we invite both A and B, then both come.

If we invite only one, say A, then A does not come because B is not invited.

So, to have at least one come in a cycle of 2, we need to invite both.

But we need at least 2 friends to come, so in this case, we need to invite both A and B.

In a cycle of length 3: A's best friend is B, B's best friend is C, C's best friend is A.

In this case, if we invite A and B, then:

- A comes because A and p_A=C are invited? Wait, p_A is C, but C is not invited, so A does not come.

- B comes if B and p_B=A are invited, which they are, so B comes.

- C does not come because C is not invited.

So, only B comes, which is not enough.

If we invite A, B, and C, then:

- A comes if A and C are invited, yes.

- B comes if B and A are invited, yes.

- C comes if C and B are invited, yes.

So, all three come, but we need at least 2, so inviting all three is fine, but maybe there is a better way.

Wait, perhaps in a cycle of length 3, inviting any two adjacent friends is not enough, because only one will come.

So, we need to invite all three to have all three come.

But maybe there is a way to have only two come without inviting all three.

Wait, if we invite A and C, then:

- A comes if A and C are invited, yes.

- C comes if C and B are invited, but B is not invited, so C does not come.

- B is not invited, so doesn't come.

So, only A comes, which is not enough.

If we invite B and C:

- B comes if B and A are invited, but A is not invited, so B does not come.

- C comes if C and B are invited, yes.

- A is not invited, so doesn't come.

So, only C comes, which is not enough.

Hence, in a cycle of length 3, to have at least 2 friends come, we need to invite all three.

Similarly, in a cycle of length 4: A->B->C->D->A.

If we invite A and B:

- A comes if A and D are invited, but D is not invited, so A does not come.

- B comes if B and A are invited, yes.

- C is not invited, so doesn't come.

- D is not invited, so doesn't come.

Only B comes, which is not enough.

If we invite A, B, and C:

- A comes if A and D are invited, no.

- B comes if B and A are invited, yes.

- C comes if C and B are invited, yes.

- D is not invited, so doesn't come.

So, B and C come, which is enough.

So, in a cycle of length 4, inviting 3 friends is sufficient.

Alternatively, inviting A, C, and D:

- A comes if A and D are invited, yes.

- C comes if C and B are invited, but B is not invited, so no.

- D comes if D and A are invited, yes.

- B is not invited, so doesn't come.

So, A and D come, which is enough.

So, in a cycle of length 4, inviting any 3 friends is sufficient to have at least 2 come.

Is there a way to have at least 2 come by inviting only 2 friends?

Let's see:

Invite A and C:

- A comes if A and D are invited, no.

- C comes if C and B are invited, no.

- B is not invited, so doesn't come.

- D is not invited, so doesn't come.

No one comes, which is not enough.

Invite A and D:

- A comes if A and D are invited, yes.

- D comes if D and A are invited, yes.

- B is not invited, so doesn't come.

- C is not invited, so doesn't come.

So, A and D come, which is enough.

So, in a cycle of length 4, inviting 2 specific friends who are not adjacent can achieve having 2 friends come.

Wait, but in the second test case:

n = 4

p = [2,3,4,1]

Which is a cycle: 1->2->3->4->1.

If Monocarp invites [1,2,3], then:

- Friend 1 comes if 1 and p_1=2 are invited, yes.

- Friend 2 comes if 2 and p_2=3 are invited, yes.

- Friend 3 comes if 3 and p_3=4 are invited, but 4 is not invited, so no.

- Friend 4 is not invited, so doesn't come.

So, friends 1 and 2 come.

Alternatively, inviting [1,3], then:

- Friend 1 comes if 1 and p_1=2 are invited, but 2 is not invited, so no.

- Friend 3 comes if 3 and p_3=4 are invited, but 4 is not invited, so no.

- Friend 2 is not invited, so doesn't come.

- Friend 4 is not invited, so doesn't come.

No one comes.

Inviting [1,4]:

- Friend 1 comes if 1 and p_1=2 are invited, no.

- Friend 4 comes if 4 and p_4=1 are invited, yes.

- Friend 2 is not invited, so doesn't come.

- Friend 3 is not invited, so doesn't come.

Only friend 4 comes, which is not enough.

So, in this case, inviting [1,2,3] makes friends 1 and 2 come, which is acceptable.

But the problem says it's impossible to send invitations to fewer than 3 friends in such a way that at least 2 come.

Wait, but in the earlier analysis, inviting [1,4] makes only friend 4 come, and inviting [1,2,3] makes friends 1 and 2 come.

So, with 3 invitations, we can have 2 friends come.

Is there a way to have 2 friends come with only 2 invitations?

From the earlier analysis, no.

Hence, the minimal number of invitations is 3.

Wait, but in my earlier analysis for a cycle of length 4, inviting 2 specific friends who are not adjacent can make 2 friends come.

But in this specific case, inviting [1,4] only makes friend 4 come.

Wait, perhaps in this particular cycle, inviting non-adjacent friends doesn't work.

Wait, maybe I need to think differently.

Let me consider general cycles.

In a cycle of length k, what is the minimal number of invitations needed to have at least 2 friends come?

In a cycle of length 2:

- Invite both to have both come.

In a cycle of length 3:

- Need to invite all three to have all three come, as inviting any two only makes one come.

In a cycle of length 4:

- Invite any 3 to have at least 2 come.

- Or, invite 2 specific friends who are not adjacent, but in some cases, it might not work.

Wait, in the second test case, inviting [1,2,3] makes friends 1 and 2 come, which is acceptable.

But inviting only [1,4] makes only friend 4 come, which is not enough.

So, in cycles of length 4, it seems that inviting 3 friends is necessary to have at least 2 come.

Wait, but perhaps there is a smarter way.

Let me think differently.

Suppose we have a cycle of length k.

We need to select a subset S of friends to invite such that the number of friends who come is at least 2.

A friend i comes if both i and p_i are in S.

So, the number of friends who come is equal to the number of pairs (i, p_i) fully in S.

We need at least 2 such pairs.

Our goal is to minimize the size of S.

This seems similar to selecting edges in a cycle graph such that at least 2 edges are selected, and minimizing the number of vertices selected.

Wait, but it's not exactly the same.

Wait, in graph terms, the friendships form a disjoint union of cycles.

Each cycle is a cycle where each node points to its best friend.

Given such a cycle, we need to select a subset S of vertices to invite, such that the number of edges fully contained in S is at least 2, and minimize the size of S.

So, in a cycle of length k, what is the minimal S such that at least 2 edges are fully in S?

Wait, but in our problem, it's about pairs (i, p_i) being both in S.

So, it's about selecting S such that at least 2 pairs (i, p_i) are both in S.

In graph terms, it's about selecting S such that the subgraph induced by S has at least 2 edges.

But, in our case, the graph is a disjoint union of cycles.

I need to find the minimal size of S such that the number of edges in the subgraph induced by S is at least 2.

This seems related to selecting vertices to cover edges.

Wait, perhaps it's similar to selecting vertices to cover at least 2 edges.

But I need to think carefully.

Let me consider that in a cycle of length k, the minimal S where the number of edges fully in S is at least 2.

For a cycle of length 2:

- S must include both vertices.

For a cycle of length 3:

- S must include all three vertices to have two edges fully in S.

For a cycle of length 4:

- S can include any 3 vertices to have at least 2 edges fully in S.

Wait, in a cycle of length 4, selecting any 3 vertices will include at least 2 edges.

Yes, because in a 4-cycle, selecting 3 vertices will always include 2 edges.

Similarly, in a cycle of length k, selecting k-1 vertices will include at least k-1 edges, but we only need at least 2 edges.

But perhaps there is a way to select fewer than k-1 vertices and still have at least 2 edges fully in S.

Wait, in a cycle of length 4, selecting any 2 adjacent vertices will include only 1 edge, which is not enough.

Selecting any 2 non-adjacent vertices will include 0 edges, as in the earlier example.

Hence, in a cycle of length 4, we need to select at least 3 vertices to have at least 2 edges fully in S.

Similarly, in a cycle of length 3, selecting any 2 vertices includes only 1 edge, which is not enough; we need to select all 3.

In a cycle of length 2, selecting both vertices includes 1 edge, which is not enough; we need to select both, but in this case, only 1 edge is present, so perhaps this case is different.

Wait, in a cycle of length 2, there is only 1 edge, so to have at least 2 edges, it's impossible unless we consider multiple cycles.

Wait, no, in a cycle of length 2, there is only 1 edge, so to have at least 2 edges, it's impossible unless there are multiple cycles.

Wait, but the problem requires at least 2 friends to come, which corresponds to at least 2 edges being fully in S.

But in a single cycle of length 2, there is only 1 edge, so we can't have at least 2 edges.

Wait, perhaps I need to think differently.

Wait, perhaps I need to have at least 2 friends coming, which means at least 2 pairs (i, p_i) are both in S.

In a cycle of length 2, there is only 1 such pair, so to have at least 2, it's impossible unless there are multiple cycles.

Wait, in a cycle of length 2, there is only 1 pair, so we can't have at least 2 pairs.

Hence, in a cycle of length 2, it's impossible to have at least 2 friends come.

But in the problem, n >= 2, and p_i are distinct and p_i != i.

Wait, but in the first test case, n=5, which has a cycle of length 3 and a cycle of length 2.

But in that case, we can have friends from different cycles coming.

Wait, no, in the first test case, n=5, p=[3,1,2,5,4], which has cycles (1,3,2) and (4,5).

So, to have at least 2 friends come, we can have one from (1,3,2) and one from (4,5).

But in that case, do we need to invite from both cycles?

Wait, no, because friends from different cycles are independent in terms of invitations.

So, in that case, perhaps inviting 2 friends from different cycles can make 2 friends come.

Wait, for example, inviting friend 2 and friend 4.

Then:

- Friend 2 comes if friend 2 and friend p_2=1 are invited, but friend 1 is not invited, so friend 2 does not come.

- Friend 4 comes if friend 4 and friend p_4=5 are invited, yes.

- Friend 5 is invited, so friend 5 comes if friend 5 and friend p_5=4 are invited, yes.

So, friends 4 and 5 come.

Hence, with invitations to 2 friends (4 and 5), we have 2 friends come (4 and 5).

So, in this case, the minimal number of invitations is 2.

Similarly, in the second test case, n=4, p=[2,3,4,1], which is a single cycle of length 4.

From earlier analysis, to have at least 2 friends come, we need to invite at least 3 friends.

In the third test case, n=2, p=[2,1], which is a cycle of length 2.

In this case, to have at least 2 friends come, but there is only one pair, so it's impossible to have at least 2 friends come.

Wait, but in the sample output, for n=2, p=[2,1], the output is 2.

But according to my earlier reasoning, in a cycle of length 2, inviting both makes only one friend come, because only one pair is present.

Wait, but according to the problem, in this case, inviting both friends makes both come.

Wait, let's check:

n=2

p=[2,1]

If Monocarp invites both friends 1 and 2:

- Friend 1 comes if friend 1 and friend p_1=2 are invited, yes.

- Friend 2 comes if friend 2 and friend p_2=1 are invited, yes.

Hence, both friends come.

So, with 2 invitations, both friends come.

Hence, the minimal number of invitations is 2.

Wait, but in a cycle of length 2, inviting both makes both come, which satisfies the condition of at least 2 friends coming.

So, in cycles of length 2, inviting both is sufficient and necessary to have both come.

Hence, in general, for a cycle of length k:

- If k=2, inviting both makes both come.

- If k=3, inviting all three makes all three come.

- If k>=4, inviting k-1 makes at least floor((k-1)/2) pairs come.

Wait, but in k=4, inviting 3 makes at least 2 pairs come.

Wait, perhaps in general, for a cycle of length k, the minimal number of invitations to have at least 2 friends come is:

- If k=2: 2 invitations.

- If k=3: 3 invitations.

- If k>=4: k-1 invitations.

But in the second test case, n=4, cycle of length 4, minimal invitations are 3.

In the first test case, n=5, with cycles of length 3 and 2, minimal invitations are 2.

In the third test case, n=2, cycle of length 2, minimal invitations are 2.

So, in general, for disjoint cycles, the minimal number of invitations is the sum of the minimal invitations for each cycle, but with the condition that we need at least 2 friends to come in total.

Hence, if there are multiple cycles, we can choose to invite from one cycle to have some friends come, and from another cycle to have others come.

In the first test case, n=5, with cycles of length 3 and 2, inviting 2 from the cycle of length 2 makes both come, satisfying the condition.

But in the second test case, n=4, single cycle of length 4, needing to invite 3 to have at least 2 come.

In the third test case, n=2, single cycle of length 2, inviting 2 to have both come.

Hence, in general, for a graph consisting of disjoint cycles, the minimal number of invitations is:

- For each cycle, determine the minimal invitations needed to have at least m friends come from that cycle.

- Since we need at least 2 friends coming in total, we can distribute the invitations across cycles to minimize the total invitations.

But in this problem, since the cycles are disjoint, the friends coming from one cycle are independent of those from another cycle.

Hence, to minimize the total invitations, we can choose to invite from the smallest cycles first to maximize the number of friends coming per invitation.

Wait, but in the first test case, inviting 2 from the cycle of length 2 makes 2 friends come, which is sufficient.

In the second test case, with a single cycle of length 4, needing to invite 3 to have 2 come.

In the third test case, inviting 2 from the cycle of length 2 makes 2 friends come.

So, in general, for cycles of length 2, inviting 2 makes 2 come.

For cycles of length 3, inviting 3 makes 3 come.

For cycles of length >=4, inviting k-1 makes floor((k-1)/2) pairs come, which is at least 2 for k>=4.

Hence, in general, for a graph with multiple cycles, the minimal number of invitations is the minimal over all subsets of cycles of the sum of the minimal invitations needed for those cycles, such that the total number of friends coming is at least 2.

This seems complicated, but perhaps there is a simpler way.

Let me consider that to have at least 2 friends come, we can either have:

- Two friends from the same cycle come, which requires inviting enough from that cycle.

- One friend from one cycle and one from another cycle.

Hence, if there are multiple cycles, we can invite from different cycles to have one friend from each come.

In the first test case, n=5, with cycles of length 3 and 2, inviting 1 friend from each cycle who both come.

Wait, no, in the first test case, if we invite 2 from the cycle of length 2, both come, which is sufficient.

Alternatively, inviting 3 from the cycle of length 3 makes all 3 come, which is more than enough.

But to minimize, inviting 2 from the cycle of length 2 is better.

Hence, in general, for disjoint cycles, the minimal invitations are the minimal among the invitations needed for each cycle to have at least 2 friends come.

But need to consider combinations across cycles.

Wait, perhaps it's better to think in terms of selecting friends to invite such that the number of friends who come is at least 2, and minimize the number of invitations.

This can be formulated as an optimization problem.

But perhaps there is a pattern in the sample inputs and outputs.

First test case:

n=5, cycles: length 3 and length 2.

Minimal invitations: 2.

Second test case:

n=4, cycle: length 4.

Minimal invitations: 3.

Third test case:

n=2, cycle: length 2.

Minimal invitations: 2.

Looking at these, perhaps the minimal number of invitations is:

- If there are multiple cycles, invite from the smallest cycles first to minimize the total invitations.

- For a single cycle, use the minimal invitations for that cycle.

Hence, perhaps in general, the minimal number of invitations is:

- For cycles of length 2: 2 invitations.

- For cycles of length 3: 3 invitations.

- For cycles of length >=4: k-1 invitations.

But need to consider combinations.

Wait, perhaps the program provided does something different.

Looking at the program:

def func():

n = int(input())

for i in range(n):

x = int(input())

l = list(map(int, input().strip().split()))

for i in range(0, x):

if l[l[i] - 1] == i + 1:

flag = True

print(2)

break

else:

print(3)

This function reads t test cases.

For each test case:

- Read n (number of friends).

- Read p_i as a list.

- Iterate through each friend i from 0 to n-1.

- Check if l[l[i]-1] == i+1.

- If yes, print 2.

- If no for all i, print 3.

Wait, but in the first test case, n=5, p=[3,1,2,5,4].

So, l = [3,1,2,5,4]

Check for i=0:

l[l[0]-1] = l[2-1] = l[1] =1, and i+1=1. So, l[l[0]-1] == i+1 -> 1 ==1, so print 2.

Similarly, for i=1:

l[l[1]-1] = l[1-1] = l[0] =3, and i+1=2. 3 !=2.

For i=2:

l[l[2]-1] = l[2-1] = l[1] =1, and i+1=3. 1 !=3.

For i=3:

l[l[3]-1] = l[5-1] = l[4] =4, and i+1=4. 4 ==4.

So, it would print 2 for i=0 and i=3.

But in the program, it breaks after the first match.

Hence, for the first test case, it would print 2.

Similarly, for the second test case:

n=4

p=[2,3,4,1]

l=[2,3,4,1]

For i=0:

l[l[0]-1] = l[1-1] = l[0]=2, and i+1=1. 2 !=1.

For i=1:

l[l[1]-1] = l[3-1]=l[2]=4, and i+1=2. 4 !=2.

For i=2:

l[l[2]-1] = l[4-1]=l[3]=1, and i+1=3. 1 !=3.

For i=3:

l[l[3]-1] = l[1-1]=l[0]=2, and i+1=4. 2 !=4.

Hence, no match, so print 3.

Third test case:

n=2

p=[2,1]

l=[2,1]

For i=0:

l[l[0]-1] = l[1-1]=l[0]=2, and i+1=1. 2 !=1.

For i=1:

l[l[1]-1] = l[1-1]=l[0]=2, and i+1=2. 2 ==2.

Hence, print 2.

So, the program outputs 2, 3, 2, which matches the sample outputs.

Hence, the program is correct.

But is this logic general?

In the first test case, it found i=0 and i=3 matching, and printed 2.

In the second test case, no i matched, so printed 3.

In the third test case, i=1 matched, so printed 2.

So, the logic seems to be: if there exists any i such that l[l[i]-1] == i+1, then print 2, else print 3.

Is this general?

Looking back at the earlier analysis:

- In cycles of length 2, l[l[i]-1] == i+1 is true for both i in the cycle.

- In cycles of length 3, it's not true for any i.

- In cycles of length 4, it's not true for any i.

Hence, the program is checking if there is any cycle of length 2 in the graph.

If there is at least one cycle of length 2, then it prints 2, else prints 3.

But in the first test case, there is a cycle of length 2 and a cycle of length 3.

It prints 2, which is correct.

In the second test case, there is only a cycle of length 4, so it prints 3, which is correct.

In the third test case, there is only a cycle of length 2, so it prints 2, which is correct.

Hence, the program seems to be correct for these cases.

But is this general?

Wait, in a cycle of length 2, l[l[i]-1] == i+1 is true for both i in the cycle.

In cycles of length greater than 2, this condition is not met for any i.

Hence, the program checks if there is any cycle of length 2 in the graph.

If yes, then minimal invitations are 2, else 3.

But, in the earlier analysis, for cycles of length >=3, the minimal invitations are k-1, which for k=3 is 3, matching the output.

For k=4, it's 3, which also matches.

Hence, in general, if there is at least one cycle of length 2, the minimal invitations are 2, else it's 3.

Because:

- In cycles of length 2, inviting both makes both come, which is 2 invitations and 2 friends coming.

- In cycles of length >=3, inviting k-1 makes at least floor((k-1)/2) pairs come, which is at least 1 for k=3 and 2 for k=4.

But in the second test case, with k=4, inviting 3 makes 2 friends come.

Hence, for cycles of length >=3, minimal invitations are 3 to have at least 2 friends come.

Hence, the program's logic seems correct.

Therefore, the program is correct.

**Final Answer**

\boxed{2, 3, 2}