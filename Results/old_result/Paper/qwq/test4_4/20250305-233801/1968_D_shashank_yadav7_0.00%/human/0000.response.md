Alright, I have this problem to solve. It's about a game played by Bodya and Sasha on a permutation and an array. They make moves simultaneously for k turns, and at each turn, they can choose to stay or move to another position based on the permutation. The goal is to determine who ends up with the higher score after k turns.

First, I need to understand the problem completely. We have a permutation p of length n, and an array a of length n. Both players start at specific positions P_B and P_S. In each turn, both players can choose to stay at their current position or move to the position specified by the permutation p. If they stay, their score increases by the value of a at their current position. If they move, they go to p[x], where x is their current position.

The game lasts for exactly k turns, and both players are trying to maximize their scores. I need to determine who wins, or if it's a draw, based on their final scores.

Looking at the example provided, it seems that the players make decisions independently, and I need to find the optimal strategy for each player separately.

Let me think about how to model this. Since both players make decisions simultaneously and independently, I can consider their paths separately. Each player has a sequence of positions they can choose to stay or move at each turn.

But this seems complex, especially since n and k can be large (n up to 2*10^5 and k up to 10^9). I need an efficient way to compute the maximum possible score for each player.

I recall that in problems involving permutations and movements, cycles can be important. Permutations can be decomposed into disjoint cycles, and the behavior of the players might depend on the cycles they are in.

Let me consider the permutation p and find its cycle decomposition. This might help in understanding the movement of the players.

For each player, starting from their initial position, I can follow the permutation to see the sequence of positions they can visit.

But since they can choose to stay or move at each turn, it's not just following the permutation. They have a choice at each step.

Wait, more carefully: at each turn, they can choose to stay or move to p[x]. It's not that they follow a path determined by the permutation; rather, at each turn, they make an independent decision to stay or move.

Given that, I need to find, for each player, the maximum possible score they can achieve in k turns, given that at each turn they can choose to stay or move.

This sounds like a dynamic programming problem, where for each turn, I keep track of the current position and the accumulated score. However, with k up to 10^9, a standard DP approach would be too slow.

I need a smarter way to handle this.

Let me consider what the optimal strategy is for each player.

At each turn, the player has to choose between staying and getting a[x], or moving to p[x] and getting a[p[x]] in the next turn, and so on.

Wait, no. If they move, they go to p[x], but their score increases by a[x] if they stay.

Actually, the problem says: "the player either stays at his current position x or moves from x to p[x]."

So, if they stay, they get a[x], and stay at x for the next turn.

If they move, they go to p[x], and their score increases by a[p[x]] in the next turn, but actually, they move first, then get a[p[x]].

Wait, the sequence is:

1. Both players make their move decision simultaneously.

2. Based on their decision, they either stay at x or move to p[x].

3. Then, their score increases by a[x], where x is their current position after the move decision.

Wait, the problem says: "On each turn, two things happen to each player:

- If the current position of the player is x, his score increases by a_x.

- Then the player either stays at his current position x or moves from x to p_x."

Wait, the order is:

1. Score increases by a[x].

2. Then, decide to stay or move.

But the example seems to suggest that the score increases before moving.

Wait, looking back at the example, it shows that the score increases at each turn based on the current position before moving.

So, perhaps it's:

- At the start of the turn, the player is at position x.

- The player's score increases by a[x].

- Then, the player decides to stay at x or move to p[x].

- The next turn, the player is at the position decided in the previous step.

Yes, that makes sense.

So, in each turn:

- Score += a[x]

- Choose to stay at x or move to p[x]

- The next turn, the player is at the chosen position.

Given that, each player can choose, at each turn, whether to stay or move to p[x].

The goal is to maximize the sum of a[x] over k turns.

This seems like a standard dynamic programming problem, where for each turn, we keep track of the current position and the accumulated score.

However, with k up to 10^9 and n up to 2*10^5, a standard DP approach would be too slow.

I need a smarter way to handle this.

Let me consider the possible behaviors based on the cycles in the permutation.

Permutations consist of disjoint cycles, and within each cycle, moving according to p[x] cycles through the elements in that cycle.

Given that, I can decompose the permutation into its cycles and analyze the behavior within each cycle separately.

For each player, their starting position belongs to some cycle, and their movement options are constrained by that cycle.

Within a cycle of length m, if a player keeps moving, they will cycle through the positions in that cycle every m turns.

However, they can choose to stay at any position in the cycle.

Given that, for each player, I need to find the optimal strategy within their cycle.

Let me formalize this.

Suppose a player is in a cycle of length m.

They can choose, at each turn, to stay or to move to the next position in the cycle.

Their goal is to maximize the sum of a[x] over k turns.

I need to find the maximum possible sum for each player.

Given that, perhaps I can model this as a graph where each position is a node, and there are edges representing staying or moving.

Specifically, for each position x:

- There is an edge from x to x, with cost a[x], representing staying.

- There is an edge from x to p[x], with cost a[p[x]], representing moving.

Wait, but actually, the cost is added at the current position before moving.

Wait, no.

Wait, at each turn:

- The player is at position x.

- Their score increases by a[x].

- Then, they choose to stay at x or move to p[x].

So, the cost a[x] is added before deciding to stay or move.

Therefore, the cost is associated with the position before moving.

Given that, perhaps it's better to think in terms of decisions at each position.

Let me try to model this differently.

Let me define dp[x][t] as the maximum score achievable by being at position x at turn t.

But with k up to 10^9, this is not feasible.

I need a better approach.

Let me consider that, for each player, their movement is constrained by their cycle.

Suppose a player is in a cycle of length m.

If they keep moving, they will cycle through the positions every m turns.

If they choose to stay at some position, they will remain there for subsequent turns.

Given that, their optimal strategy would be to stay at the position with the highest a[x] in their cycle.

But is that always the case?

Wait, no. Because they can choose to move and collect a[p[x]] in the next turn.

Wait, perhaps I need to consider the average gain per turn.

But I'm getting confused.

Let me consider small examples to understand.

Take n=3, k=2, p=[2,3,1], a=[1,2,3], P_B=1, P_S=2.

So, positions: 1->2->3->1...

Player B starts at 1.

Turn 1:

- At 1, score +=1

- Choose to stay at 1 or move to p[1]=2

Option 1: Stay at 1, score=1 +1=2

Option 2: Move to 2, score=1 +2=3

Turn 2:

Option 1: Stay at 1, score=2 +1=3

Option 2: Move to 2, score=2 +2=4

Option 3: Stay at 2, score=3 +2=5

Option 4: Move to 3, score=3 +3=6

Wait, but in the first option, if they stay at 1, then in the second turn, they can choose again to stay or move.

Similarly, if they move to 2, then in the second turn, they can choose to stay at 2 or move to 3.

So, the possible total scores after 2 turns:

- Stay at 1 both turns: 1 +1=2

- Stay at 1, then move to 2: 1 +2=3

- Move to 2, then stay at 2: 1 +2=3 +2=5

- Move to 2, then move to 3: 1 +2=3 +3=6

So, the maximum is 6.

Similarly for player S starting at 2.

Turn 1:

- At 2, score +=2

- Choose to stay at 2 or move to 3

Option 1: Stay at 2, score=2 +2=4

Option 2: Move to 3, score=2 +3=5

Turn 2:

Option 1: Stay at 2, score=4 +2=6

Option 2: Move to 3, score=4 +3=7

Option 3: Stay at 3, score=5 +3=8

Option 4: Move to 1, score=5 +1=6

So, the maximum is 8.

Therefore, player S wins with score 8 vs player B's 6.

But according to the problem, the higher score wins.

Wait, but in the example provided in the problem, it's different.

Wait, in the problem's example, it's Bodya vs Sasha, and Bodya has higher score.

In my example, Sasha has higher score.

Wait, perhaps I made a mistake in calculating Bodya's score.

Wait, in my example, n=3, k=2, p=[2,3,1], a=[1,2,3], P_B=1, P_S=2.

Bodya starts at 1, Sasha at 2.

From above, Bodya can get up to 6, Sasha up to 8.

So Sasha wins.

But according to the problem's example, Bodya can have higher score.

Wait, perhaps I need to think differently.

Wait, maybe the players make decisions simultaneously, but independently.

Wait, no, they make decisions independently.

So, for Bodya, his decisions only affect his own score, same for Sasha.

So, I need to find the maximum score each can achieve independently.

Given that, I need to find, for each player, the maximum possible sum of a[x] over k turns, given their movement options.

Given the constraints on n and k, I need an efficient way to compute this.

Let me consider the cycle structure.

Suppose a player is in a cycle of length m.

Then, the player can choose to stay at any position in the cycle, or cycle through the positions.

Given that, the optimal strategy would be to stay at the position with the highest a[x] in the cycle for all remaining turns.

But is that always optimal?

Wait, in my previous example, if Bodya stays at position 3 (a[3]=3), his total score would be 3*k=3*2=6.

But if he moves through the cycle, he can get higher.

Wait, let's see:

Turn 1:

- At 1, a[1]=1

- Choose to move to 2

- Score +=1, position=2

Turn 2:

- At 2, a[2]=2

- Choose to move to 3

- Score +=2, position=3

Total score: 1 + 2 = 3

Wait, that's less than staying at 3.

Wait, no, if he stays at 3, he gets a[3]=3 each turn.

Wait, in the first turn:

- At 1, a[1]=1

- Choose to move to 2

- Score +=1, position=2

Turn 2:

- At 2, a[2]=2

- Choose to stay at 2

- Score +=2, position=2

Total: 1 + 2 = 3

But if he chooses to stay at 3:

- Turn 1:

- At 1, a[1]=1

- Choose to move to 2

- Score +=1, position=2

- Then, choose to move to 3

- Score +=3, position=3

Total: 1 + 3 =4

Wait, that seems better.

Wait, I'm getting confused.

Wait, no, in the first turn:

- At 1, a[1]=1

- Choose to move to 2

- Score +=1, position=2

Turn 2:

- At 2, a[2]=2

- Choose to stay at 2

- Score +=2, position=2

Total: 1 + 2 =3

Alternatively:

- Turn 1:

- At 1, a[1]=1

- Choose to move to 2

- Score +=1, position=2

- Then, choose to move to 3

- Score +=3, position=3

Total: 1 + 3 =4

Wait, but in the second option, he moves twice in one turn, which is not allowed.

Wait, no, at each turn, they make one decision: stay or move.

So, in turn 1:

- At 1, a[1]=1

- Choose to move to 2

- Score +=1, position=2

Turn 2:

- At 2, a[2]=2

- Choose to stay at 2

- Score +=2, position=2

Total: 1 + 2 =3

Alternatively, in turn 1:

- At 1, a[1]=1

- Choose to stay at 1

- Score +=1, position=1

Turn 2:

- At 1, a[1]=1

- Choose to stay at 1

- Score +=1, position=1

Total: 1 +1=2

Or, in turn 1:

- At 1, a[1]=1

- Choose to move to 2

- Score +=1, position=2

Turn 2:

- At 2, a[2]=2

- Choose to move to 3

- Score +=2, position=3

Total: 1 + 2 =3

Or, in turn 1:

- At 1, a[1]=1

- Choose to move to 2

- Score +=1, position=2

Turn 2:

- At 2, a[2]=2

- Choose to stay at 2

- Score +=2, position=2

Total: 1 + 2 =3

Alternatively:

- Turn 1:

- At 1, a[1]=1

- Choose to stay at 1

- Score +=1, position=1

Turn 2:

- At 1, a[1]=1

- Choose to move to 2

- Score +=1, position=2

Total: 1 +1=2

Wait, seems like the best is 1 +2=3.

But if the cycle length is 3, and k=2, the best is 4, by moving to 2 and then to 3, getting a[1]+a[3]=1+3=4.

Wait, but according to the previous calculations, it's 1 +3=4.

How is that possible?

Wait, in the first turn:

- At 1, a[1]=1

- Choose to move to 2

- Score +=1, position=2

Turn 2:

- At 2, a[2]=2

- Choose to move to 3

- Score +=3, position=3

Total: 1 +3=4

Wait, but according to the problem's description, the score increases at the beginning of the turn based on the current position.

Wait, perhaps I misread.

Let me read the problem again.

"On each turn, two things happen to each player:

- If the current position of the player is x, his score increases by a_x.

- Then the player either stays at his current position x or moves from x to p_x."

So, at the start of the turn, the player is at position x, scores a_x, then decides to stay or move.

In my previous calculation, I added a[x] before deciding to stay or move.

But perhaps I need to think differently.

Let me try again.

In turn 1:

- Player is at position 1, scores a[1]=1.

- Then decides to stay at 1 or move to p[1]=2.

- If stays, remains at 1.

- If moves, goes to 2.

In turn 2:

- If stayed at 1, scores a[1]=1 again.

- If moved to 2, scores a[2]=2.

Wait, but in the problem's example, it seems that the score is added based on the position at the start of the turn.

So, in turn 1:

- At position x, score += a[x]

- Then decide to stay at x or move to p[x]

- In turn 2, the player is at the position chosen in the previous turn.

So, in my earlier calculation, for Bodya starting at 1:

Option 1: Stay at 1 both turns: 1 +1=2

Option 2: Stay at 1, then move to 2: 1 +1=2, then move to 2, score a[2]=2, total 2 +2=4

Wait, but in the second turn, after moving to 2, he scores a[2]=2.

Wait, perhaps I need to think in terms of decision trees.

But with k up to 10^9, this is not feasible.

I need a better approach.

Let me consider that, in the long run, the player can choose to stay at any position in the cycle and collect a[x] every turn.

So, the optimal strategy is to choose the position with the maximum a[x] in the cycle and stay there for all k turns.

But is there a benefit in moving through the cycle to get higher scores?

Wait, in the cycle, if the player keeps moving, he cycles through all positions in the cycle, collecting a[p[x]] each turn.

But since the cycle is of length m, the sum per cycle is sum(a[x] for x in cycle).

Comparing to staying at the position with the maximum a[x], collecting m * a[x] over m turns.

So, if the player stays at the position with the maximum a[x], he gets m * a[x].

If he cycles through the cycle, he gets sum(a[x] for x in cycle).

If m * a[x] > sum(a[x]), then it's better to stay; else, cycle through.

Wait, but this is for m turns.

But k can be up to 10^9.

I need a general way to compute the maximum possible score for each player.

Let me consider that, for each cycle, the player can choose to stay at the position with the maximum a[x] and collect a[x] every turn, or cycle through the cycle and collect the sum per cycle.

Then, for k turns, the maximum score would be max(staying at max a[x] for k turns, cycling through the cycle for as many times as possible and staying at max a[x] for the remaining turns).

Wait, perhaps I need to compute the maximum between:

- k * max_a_in_cycle

- (k // cycle_length) * sum_a_in_cycle + (k % cycle_length) * max_a_in_cycle

Wait, but I need to maximize over all possible strategies.

Actually, the optimal strategy is to stay at the position with the maximum a[x] for all k turns.

Because staying at the best position maximizes the score per turn, and there's no benefit in moving through the cycle unless sum_a_in_cycle > cycle_length * max_a_in_cycle, which is unlikely.

Wait, no, sum_a_in_cycle is always less than or equal to cycle_length * max_a_in_cycle, with equality only if all a[x] are equal.

Therefore, staying at the best position is always better or equal to any other strategy.

Therefore, for each player, the maximum possible score is k * max_a_in_cycle.

So, I need to find, for each player, the cycle they are in, find the maximum a[x] in that cycle, and compute k * max_a_in_cycle.

Then, compare the two players' scores.

This seems efficient, as I can decompose the permutation into cycles and compute the maximum a[x] in each cycle.

Given that, I can preprocess the permutation to find the cycle decomposition.

But, considering that n can be up to 2*10^5 and t up to 10^4, I need an efficient way to handle this.

Wait, but t is up to 10^4, and n up to 2*10^5, but the sum of n over all test cases is up to 2*10^5.

So, overall time complexity should be O(n + t * something).

I need to find a way to compute the maximum a[x] in the cycle for each player efficiently.

One way is to, for each test case, find the cycle containing P_B and P_S, find the maximum a[x] in those cycles, and compute k * max_a_for_P_B and k * max_a_for_P_S.

But finding cycles for each test case would be too slow if t is up to 10^4 and n up to 2*10^5.

I need a smarter way.

Wait, perhaps I can preprocess the cycle decompositions for all n in O(n), and then, for each test case, find the cycle containing P_B and P_S and find the maximum a[x] in those cycles.

But with t up to 10^4, and n up to 2*10^5, I need to optimize this.

Wait, no, cycle decompositions are specific to the permutation, which changes with each test case.

Wait, no, the permutation is given for each test case.

Wait, no, reading the problem again:

"The first line contains a single integer t (1≤ t≤ 10^4 ) — the number of testcases."

"Each testcase consists of four lines."

So, for each testcase, there is a new permutation p and array a.

So, I need to process t testcases, each with its own permutation and array.

Given that, I need to handle t=10^4 testcases, each with n up to 2*10^5, but with the sum of n over all testcases not exceeding 2*10^5.

So, overall time complexity should be O(2*10^5).

Given that, I need an efficient way to handle each testcase in O(n) time.

So, for each testcase, I need to find the maximum a[x] in the cycle containing P_B and P_S.

But I need to find the cycle containing P_B and P_S