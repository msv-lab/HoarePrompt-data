Alright, I've got this problem to solve. Let's see what it's asking for. So, Bob has a bakery, and on the opening day, he baked n buns that he wants to sell. The usual price for each bun is a coins. But to attract customers, he's running a promotion where he can choose some integer k (between 0 and the minimum of n and b) and sell the first k buns at a modified price. The price for the i-th bun (where i ranges from 1 to k) is (b - i + 1) coins. The remaining (n - k) buns are sold at the usual price of a coins each.

My task is to help Bob determine the maximum profit he can obtain by selling all n buns.

First, I need to understand the promotion clearly. If Bob chooses k = 0, he sells all n buns at the usual price a coins each, so the total profit is n * a.

If he chooses k > 0, he sells the first k buns at prices (b, b-1, b-2, ..., b - k + 1) coins respectively, and the remaining (n - k) buns at a coins each.

So, the total profit when choosing k > 0 would be the sum of the first k modified prices plus the profit from the remaining (n - k) buns sold at a coins each.

I need to maximize this total profit over all possible values of k from 0 to min(n, b).

Let me think about how to approach this.

First, I should consider the possible ranges of k. Since k can be from 0 to min(n, b), and n, a, b can be up to 10^9, I need an efficient way to compute the maximum profit without iterating through all possible k values, as that would be too slow for large n and b.

I need to find a way to compute the maximum profit efficiently.

Let me try to find a formula for the total profit when choosing a specific k.

The sum of the first k modified prices is:

sum from i=1 to k of (b - i + 1) = sum from i=1 to k of b - sum from i=1 to k of i + sum from i=1 to k of 1 = k*b - (k*(k+1)/2) + k = k*b - k*(k+1)/2 + k = k*(b - (k+1)/2 + 1)

Wait, that seems a bit messy. Maybe there's a better way to express this sum.

Actually, the sum of an arithmetic series where the first term is b and the last term is b - k + 1 is:

sum = (number of terms)/2 * (first term + last term) = k/2 * (b + (b - k + 1)) = k/2 * (2b - k + 1)

So, sum of the first k modified prices is k*(2b - k + 1)/2

Then, the profit from the remaining (n - k) buns sold at a coins each is a*(n - k)

Therefore, the total profit for a given k is:

profit = k*(2b - k + 1)/2 + a*(n - k)

I need to maximize this profit over k from 0 to min(n, b)

Now, since n, a, b can be up to 10^9, and t can be up to 10^4, I need a O(1) or O(1) per test case solution, meaning I can't iterate over k for each test case.

I need to find the value of k that maximizes the profit formula.

Let me see if I can find a mathematical way to maximize this expression.

Consider the profit function:

profit(k) = k*(2b - k + 1)/2 + a*(n - k)

Simplify this:

profit(k) = (2b*k - k^2 + k)/2 + a*n - a*k

         = (2b*k)/2 - (k^2)/2 + k/2 + a*n - a*k

         = b*k - k^2/2 + k/2 + a*n - a*k

         = (-k^2/2 + k*(b + 1/2) - a*k) + a*n

         = -k^2/2 + k*(b + 1/2 - a) + a*n

This is a quadratic function in terms of k: profit(k) = (-1/2)*k^2 + (b + 0.5 - a)*k + a*n

To maximize this quadratic function, since the coefficient of k^2 is negative (-1/2), the maximum occurs at k = -B/(2*A), where A = -1/2, B = b + 0.5 - a

So, k_max = -(b + 0.5 - a)/(2*(-1/2)) = (a - b - 0.5)

But this seems odd because k should be a non-negative integer between 0 and min(n, b)

Moreover, since k has to be an integer, and the quadratic formula might not give an integer value, I need to consider the integer values around k_max.

But I'm not sure if this approach is the best, especially considering the constraints.

Let me think differently.

I need to maximize:

profit(k) = k*(2b - k + 1)/2 + a*(n - k)

Let me rearrange this:

profit(k) = (k*(2b - k + 1) + 2*a*(n - k))/2 = (2b*k - k^2 + k + 2*a*n - 2*a*k)/2 = (-k^2 + (2b + 1 - 2*a)*k + 2*a*n)/2

This is still a quadratic in k, and as before, the coefficient of k^2 is negative, so it has a maximum at k = (2b + 1 - 2*a)/ (2*1/2) = (2b + 1 - 2*a)

Wait, this seems messy.

Alternatively, maybe I can consider the difference in profit when increasing k by 1.

Let me compute profit(k+1) - profit(k):

= [ (k+1)*(2b - (k+1) + 1)/2 + a*(n - (k+1)) ] - [ k*(2b - k + 1)/2 + a*(n - k) ]

= [ (k+1)*(2b - k) / 2 + a*(n - k - 1) ] - [ k*(2b - k + 1)/2 + a*(n - k) ]

= [ (k+1)*(2b - k)/2 + a*n - a*(k + 1) ] - [ k*(2b - k + 1)/2 + a*n - a*k ]

= [ (k+1)*(2b - k)/2 - a*(k + 1) ] - [ k*(2b - k + 1)/2 - a*k ]

Expand (k+1)*(2b - k)/2:

= (2b(k + 1) - k(k + 1))/2 = (2b*k + 2b - k^2 - k)/2 = (2b*k - k^2 + 2b - k)/2

Similarly, k*(2b - k + 1)/2 = (2b*k - k^2 + k)/2

So, profit(k+1) - profit(k) = [ (2b*k - k^2 + 2b - k)/2 - a*(k + 1) ] - [ (2b*k - k^2 + k)/2 - a*k ]

Simplify:

= (2b*k - k^2 + 2b - k)/2 - a*k - a - (2b*k - k^2 + k)/2 + a*k

= [(2b*k - k^2 + 2b - k) - (2b*k - k^2 + k)] / 2 - a

= (2b*k - k^2 + 2b - k - 2b*k + k^2 - k)/2 - a

= (2b - 2k)/2 - a

= (b - k) - a

= b - k - a

So, profit(k+1) - profit(k) = b - k - a

This is useful!

This tells me that the profit increases when b - k - a > 0, stays the same when b - k - a = 0, and decreases when b - k - a < 0.

So, profit increases as long as k < b - a, stays the same when k = b - a, and decreases when k > b - a.

Wait, let's solve b - k - a > 0 for k:

k < b - a

And b - k - a = 0 when k = b - a

And b - k - a < 0 when k > b - a

So, the profit increases for k from 0 to b - a - 1, stays the same at k = b - a, and decreases for k > b - a.

Therefore, the maximum profit occurs at k = b - a, assuming b - a >= 0.

But k cannot exceed min(n, b), so I need to handle cases where b - a > min(n, b).

Also, k cannot be negative, so if b - a < 0, then k = 0.

Wait, but k can be from 0 to min(n, b), and b - a could be negative, zero, or positive.

So, to maximize profit:

- If b - a < 0, choose k = 0

- If 0 <= b - a <= min(n, b), choose k = b - a

- If b - a > min(n, b), choose k = min(n, b)

Wait, but in the case where b - a > min(n, b), choosing k = min(n, b) would be the best possible within the constraints.

So, the optimal k is:

k = max(0, min(b - a, min(n, b)))

Wait, but min(n, b) is already the upper limit for k, so min(b - a, min(n, b))

And ensure it's not negative, so k = max(0, min(b - a, min(n, b)))

But min(b - a, min(n, b)) can be negative if b - a < 0 and min(n, b) < b - a, but since min(n, b) is at least 0 (because n and b are at least 1), and b - a could be negative, but k cannot be negative, so k = max(0, b - a)

Wait, no, min(n, b) could be less than b - a if n or b is small.

Wait, let's think carefully.

Given that k can be from 0 to min(n, b), and the profit increases as long as k < b - a, stays the same at k = b - a, and decreases for k > b - a.

So, if b - a <= min(n, b), then the maximum profit is at k = b - a.

If b - a > min(n, b), then the maximum profit is at k = min(n, b).

If b - a < 0, then the maximum profit is at k = 0.

Therefore, the optimal k is:

k = max(0, min(b - a, min(n, b)))

But since min(n, b) is the upper limit for k, and b - a could be less than or equal to it, or greater.

Wait, actually, since k cannot exceed min(n, b), the optimal k should be:

k = min(max(0, b - a), min(n, b))

This ensures that k doesn't exceed min(n, b) and is at least 0.

Yes, that makes sense.

So, in code, for given n, a, b:

k = min(max(0, b - a), min(n, b))

Then, total profit is:

sum of first k modified prices + a*(n - k)

Sum of first k modified prices is k*(2b - k + 1)/2

So, profit = k*(2b - k + 1)/2 + a*(n - k)

But I need to handle large numbers, up to 10^9, so I need to use integer types that can handle large multiplications, probably using int in Python, which can handle big integers.

Let me verify this with the sample inputs.

First sample input:

4 4 5

n=4, a=4, b=5

k = min(max(0, 5 - 4), min(4,5)) = min(1,4) =1

Profit = 1*(2*5 -1 +1)/2 + 4*(4 -1) = 1*10/2 + 4*3 = 5 + 12 = 17

Which matches the first sample output.

Second sample input:

5 5 9

n=5, a=5, b=9

k = min(max(0,9-5), min(5,9)) = min(4,5) =4

Profit =4*(18 -4 +1)/2 +5*(5-4) =4*15/2 +5*1 =30 +5=35

Which matches the second sample output.

Third sample input:

10 10 5

n=10, a=10, b=5

k = min(max(0,5-10), min(10,5)) = min(0,5)=0

Profit =0*(10 -0 +1)/2 +10*(10-0)=0 +100=100

Which matches the third sample output.

Seems correct.

But let's consider another case where b - a > min(n, b)

For example:

n=3, a=1, b=10

k = min(max(0,10-1), min(3,10)) = min(9,3)=3

Profit =3*(20 -3 +1)/2 +1*(3-3)=3*18/2 +0=27

If k=2:

Profit=2*(20 -2 +1)/2 +1*(3-2)=2*19/2 +1=19+1=20 <27

If k=1:

Profit=1*(20 -1 +1)/2 +1*(3-1)=10 +2=12 <27

If k=0:

Profit=0 +3*1=3 <27

So, indeed, k=3 is the best choice.

Another case where b - a <0

n=1000000000, a=1000000000, b=1

k = min(max(0,1-1000000000), min(1000000000,1))=min(0,1)=0

Profit=0 +1000000000*1000000000=1000000000000000000

Which matches the sample input.

Seems correct.

Now, I need to implement this efficiently in code.

Given that t can be up to 10^4 and n, a, b up to 10^9, I need to compute this quickly for each test case.

The key is to compute k correctly and then compute the profit using the formula.

In code:

Read t

For each test case:

Read n, a, b

Compute k = min(max(0, b - a), min(n, b))

Compute profit = k*(2*b - k +1)//2 + a*(n - k)

Print profit

This should work efficiently.

But I need to make sure that all operations are integer operations to handle large numbers.

Also, need to make sure that for k=0, the sum of first k modified prices is 0.

Let me check with k=0:

profit = 0 + a*n, which is correct.

Another thing to consider is that min(n, b) can be computed as b if b < n else n.

But in Python, min(n, b) is straightforward.

Edge cases to consider:

- n=1, a=1, b=1

k = min(max(0,1-1), min(1,1))=min(0,1)=0

Profit=0 +1*1=1

- n=1, a=1, b=2

k=min(max(0,2-1), min(1,2))=min(1,1)=1

Profit=1*(4 -1 +1)/2 +1*(1-1)=1*4/2 +0=2

- n=1, a=2, b=1

k=min(max(0,1-2), min(1,1))=min(0,1)=0

Profit=0 +2*1=2

- n=0, but n >=1 as per constraints.

- n=10^9, a=10^9, b=10^9

k=min(max(0,10^9-10^9), min(10^9,10^9))=min(0,10^9)=0

Profit=0 +10^9*10^9=10^18, which is within Python's int type.

Seems fine.

Another way to think about it is to consider that the modified prices are higher than the usual price only if b - i +1 > a, for each i from 1 to k.

So, for each i, if b - i +1 > a, then it's better to sell at the modified price, else sell at a.

So, the maximum k where b - k +1 > a is k < b - a +1

So, the maximum k where modified price is greater than a is k < b - a +1

Therefore, the optimal k is the maximum k where b - k +1 > a, which is k < b - a +1

But since k has to be <= min(n, b), the optimal k is min(n, b, b - a)

But need to ensure k >=0

So, k = min(n, b, b - a)

But wait, b - a could be negative, so need to take max(0, b - a)

Thus, k = min(n, b, max(0, b - a))

But min(n, b, max(0, b - a)) is equivalent to min(max(0, b - a), min(n, b))

Yes, same as before.

So, my initial approach is correct.

Therefore, the code provided seems correct.

Hence, Correctness: **True**

**Final Solution**

To solve this problem, we need to maximize Bob's profit from selling buns under a promotional pricing scheme. We achieve this by carefully selecting the number of buns to sell at the modified price to maximize total revenue.

## Approach

1. **Problem Analysis**:
   - We have `n` buns, a usual price `a` per bun, and a promotional price scheme starting from `b` coins for the first bun, decreasing by 1 coin for each subsequent bun up to `k` buns.
   - We need to choose `k` (0 ≤ k ≤ min(n, b)) to maximize the total profit.

2. **Insight**:
   - The promotional price for the `i`-th bun is `(b - i + 1)` coins.
   - The sum of the first `k` promotional prices is `k*(2*b - k + 1)/2`.
   - The remaining `(n - k)` buns are sold at the usual price `a` coins each.
   - Total profit for a given `k` is: `k*(2*b - k + 1)/2 + a*(n - k)`.

3. **Optimal `k` Selection**:
   - The optimal `k` is determined by the point where the promotional price equals the usual price.
   - Mathematically, the best `k` is `min(max(0, b - a), min(n, b))`.

4. **Efficient Calculation**:
   - Calculate the optimal `k`.
   - Compute the total profit using the formula for the sum of promotional prices and the usual prices.

## Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index = 1
    for _ in range(t):
        n = int(data[index])
        a = int(data[index+1])
        b = int(data[index+2])
        index += 3
        k = min(max(0, b - a), min(n, b))
        sum_promo = k * (2 * b - k + 1) // 2
        sum_usual = a * (n - k)
        profit = sum_promo + sum_usual
        print(profit)

if __name__ == "__main__":
    main()
```

## Explanation

1. **Reading Input**:
   - Read all input data at once for efficiency.
   - Parse the number of test cases `t`.
   - For each test case, read `n`, `a`, and `b`.

2. **Calculating Optimal `k`**:
   - Determine the optimal number of buns `k` to sell at the modified price.
   - `k` is bounded by `max(0, b - a)` and `min(n, b)`.

3. **Computing Profit**:
   - Calculate the sum of the first `k` promotional prices using the arithmetic series sum formula.
   - Calculate the sum of the remaining `(n - k)` buns sold at the usual price.
   - Add these two sums to get the total profit.

4. **Output**:
   - Print the total profit for each test case.

This approach ensures that we efficiently compute the maximum profit for each test case in constant time, making it suitable for large input sizes.