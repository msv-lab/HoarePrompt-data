Alright, I've got this problem to solve. Let's see what it's asking for. So, Alice has n coins and wants to buy exactly k jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel that's an integer between 1 and 10^18 coins. Alice buys jewels greedily: she goes to each stall in order, buys as many jewels as she can with her remaining coins, and moves on to the next stall.

My task is to determine if Bob can set up the stalls and set the prices in such a way that Alice ends up buying exactly k jewels. If it's possible, I need to output "YES" along with the number of stalls and their respective prices. If not, I should output "NO".

First, I need to understand the constraints and what they imply. The constraints are:

- There are multiple test cases, up to t=1000.

- For each test case, n and k are positive integers up to 10^18.

- Bob can set up at most 60 stalls.

- Each stall has a price per jewel between 1 and 10^18 coins.

- Alice buys jewels greedily from stall 1 to stall s (s <= 60).

I need to make sure that the total number of jewels Alice buys is exactly k.

Let me think about how Alice buys the jewels. She starts with n coins and goes to each stall in order. At each stall, she buys as many jewels as she can with her current coins, subtracts the cost of those jewels from her coins, and moves to the next stall.

So, for stall i with price p_i, the number of jewels she buys is floor(n / p_i), and then she has n - (floor(n / p_i) * p_i) coins left for the next stall.

My goal is to choose up to 60 stalls with prices p_1, p_2, ..., p_s such that the total number of jewels bought is exactly k.

I need to find a sequence of prices that leads to exactly k jewels being bought.

Let me consider some examples to understand this better.

Looking at the example provided:

Test case 1:

n = 7, k = 3

Output:

YES

10

2 3 4 5 6 7 8 9 10 11

Explanation:

- Stall 1: p=2, jewels bought = 7//2 = 3, coins left = 7 - 3*2 = 1

- Since 1 < 3, she can't buy any more jewels from the remaining stalls.

- Total jewels bought: 3

This matches k=3.

Another test case:

n=255, k=8

Output:

YES

8

128 64 32 16 8 4 2 1

Explanation:

- Stall 1: p=128, jewels bought = 255//128 = 1, coins left = 255 - 128 = 127

- Stall 2: p=64, jewels bought = 127//64 = 1, coins left = 127 - 64 = 63

- Stall 3: p=32, jewels bought = 63//32 = 1, coins left = 63 - 32 = 31

- Stall 4: p=16, jewels bought = 31//16 = 1, coins left = 31 - 16 = 15

- Stall 5: p=8, jewels bought = 15//8 = 1, coins left = 15 - 8 = 7

- Stall 6: p=4, jewels bought = 7//4 = 1, coins left = 7 - 4 = 3

- Stall 7: p=2, jewels bought = 3//2 = 1, coins left = 3 - 2 = 1

- Stall 8: p=1, jewels bought = 1//1 = 1, coins left = 1 - 1 = 0

- Total jewels bought: 1+1+1+1+1+1+1+1=8

This also matches k=8.

From these examples, it seems that using decreasing prices, starting from a high price and halving it each time, helps in buying one jewel per stall, which can be useful for achieving a total of k jewels.

But in the first example, they used increasing prices from 2 to 11, which also worked for k=3.

So, there are different strategies depending on n and k.

I need to find a general approach that works for any n and k, with s <= 60.

First, consider the minimal number of stalls required.

The minimal number of stalls is 1, where p=ceil(n/k), but only if n/k is integer.

But in the problem, s can be up to 60, so we have some flexibility.

Wait, no, I need to think differently.

Let me consider that with s stalls, I can control how many jewels are bought at each stall.

If I can control p_1, p_2, ..., p_s, then I can control how many jewels Alice buys at each stall based on the remaining coins.

I need to choose p_i such that the sum of floor(n / p_i) over i=1 to s is exactly k.

Additionally, the sequence of p_i should be such that after buying from stall i, the remaining coins are n - floor(n / p_i) * p_i, and this is used for the next stall.

I need to make sure that the total jewels bought is exactly k.

This seems tricky because the number of jewels bought at each stall depends on the remaining coins and the price at that stall.

I need to find a way to decompose k into a sum of floor(n / p_i) for chosen p_i.

Let me think about the minimal and maximal possible jewels bought.

- If p_i = 1 for all stalls, then Alice buys n jewels, which may be more than k.

- If p_i = n+1 for any stall, Alice buys 0 jewels from that stall.

- If p_i > n, it's useless because Alice can't buy any jewels from that stall.

- So, p_i should be <= n for all stalls.

Wait, unless n=0, but n is positive as per constraints.

Also, p_i >=1.

I need to ensure that the total jewels bought is exactly k.

Let me consider some edge cases.

Edge case 1: n = k

In this case, if I set p=1, Alice buys n= k jewels from the first stall, which is exactly k.

So, output "YES" with s=1 and p=1.

Edge case 2: n < k

This is impossible because even if p=1, Alice can buy at most n jewels, which is less than k.

So, output "NO"

Edge case 3: k=1

In this case, I need to make sure that Alice buys exactly one jewel.

This can be done by setting p = n, then Alice buys one jewel and has 0 coins left.

So, output "YES" with s=1 and p=n.

Edge case 4: k=0

Wait, k is a positive integer, so k >=1 as per constraints.

Good.

Another thought: if I set p_i in decreasing order, Alice will buy fewer jewels from earlier stalls and more from later stalls if coins allow.

But in the first example, they used increasing p_i, which still worked.

Wait, no, in the first example, p_i are increasing from 2 to 11, but Alice only bought from the first stall because after buying 3 jewels, she had only 1 coin left, which was insufficient for any other stall.

So, in that case, it's effectively only the first stall that matters.

Wait, but according to the explanation, she bought 3 jewels from the first stall and had 1 coin left, which was insufficient for any of the remaining stalls.

So, the remaining stalls didn't contribute any jewels.

So, in that case, it's as if only the first stall was considered.

But in the third example, multiple stalls were used.

So, the strategy seems to be:

- If k is small compared to n, use higher p_i to control the number of jewels bought per stall.

- If k is large, use lower p_i to buy more jewels per stall.

But I need a general approach.

Let me consider the following approach:

Start with p_1 = ceil(n / k)

This would make floor(n / p_1) as close as possible to k.

But it may not be exact, so I need to adjust accordingly.

Wait, no. Let me think differently.

I need to decompose k into a sum of floor(n / p_i) for chosen p_i.

I need to find s <=60 and p_i such that sum(floor(n / p_i)) =k.

This seems similar to decomposing k into a sum of divisors of n, but it's not exactly that.

Wait, floor(n / p_i) is the quotient when n is divided by p_i.

So, it's like decomposing k into a sum of quotients of n divided by some divisors.

But it's not necessarily divisors, as p_i can be any integer between 1 and 10^18.

I need another way.

Let me consider the minimal and maximal number of jewels Alice can buy.

- If s=1, p=1, Alice buys n jewels.

- If s=1, p=n, Alice buys 1 jewel.

- If s=2, p1=n, p2=1, Alice buys 1 jewel from stall 1 and n-1 jewels from stall 2, total 1 + (n-1) = n jewels.

- But I need exactly k jewels.

Wait, maybe I can use binary search to find p_i such that the sum of floor(n / p_i) equals k.

But that seems too vague.

Let me consider the following approach:

Start with p1 = ceil(n / k)

Then, remaining jewels to buy is k - floor(n / p1)

Then, set p2 = ceil(n_remaining / (k - floor(n / p1)))

And so on, until the remaining k is 0.

This seems similar to the greedy algorithm for optimizing the number of stalls.

But I need to ensure that s <=60.

Wait, but this could potentially require more than 60 stalls.

I need to find a way to minimize s.

But the problem allows up to 60 stalls, so I need to make sure that s <=60.

Wait, in the first example, they used 10 stalls for k=3, which is way more than necessary, but s=10 is still <=60.

In the third example, s=8, which is also <=60.

So, perhaps there's a way to always achieve s <=60.

Let me consider that 60 is a generous upper limit, and perhaps s=60 is enough for any n and k.

But I need to confirm that.

Wait, 60 is chosen because 2^60 is a very large number, beyond 10^18.

But in this problem, p_i can be up to 10^18.

Wait, perhaps using p_i that are powers of 2 can help.

Let me consider using p_i = 2^a, where a decreases by 1 each time.

Like in the third example, they used p_i = 128,64,32,16,8,4,2,1, which are powers of 2.

In that case, Alice buys one jewel from each stall, as n is reduced by p_i each time.

This works when k <=60, because 2^0 to 2^59 are distinct and n can be decomposed into binary representation.

Wait, but in the first example, they used p_i from 2 to 11, which are not powers of 2, but it still worked because Alice only bought from the first stall.

So, perhaps using powers of 2 is a general strategy.

Let me think about it.

If I set p_i = 2^{b - i}, where b is some base.

Wait, perhaps starting from the highest power of 2 less than or equal to n.

For example, in the third test case, n=255, which is 2^8 -1, so highest power is 128.

Then, set p_i = 128,64,32,16,8,4,2,1, as in the example.

In this way, Alice buys one jewel from each stall, totaling k=8.

This works because 255 in binary is 11111111, which has 8 bits set to 1.

So, using p_i as powers of 2 allows Alice to buy one jewel from each stall corresponding to a set bit in n's binary representation.

But in the first example, n=7 and k=3, they used p_i from 2 to 11, but in reality, using p_i as powers of 2 would also work.

For n=7, which is 111 in binary, k=3, setting p_i=4,2,1 would allow Alice to buy one jewel from each stall, totaling 3 jewels.

But in the given example, they used 10 stalls with p_i from 2 to 11, which also worked because Alice only bought from the first stall.

So, using powers of 2 seems like a general strategy.

But I need to confirm if this always works.

Let me consider n=10, k=3.

If I set p_i=8,4,2,1.

- Stall 1: p=8, jewels=1, coins left=10-8=2

- Stall 2: p=4, jewels=0 (since 2<4)

- Stall 3: p=2, jewels=1, coins left=2-2=0

- Stall 4: p=1, jewels=0 (since coins=0)

- Total jewels=1+1=2, which is less than k=3.

So, in this case, using powers of 2 doesn't give me k=3.

Hmm, so maybe this approach isn't general.

Alternative approach:

I need to make sure that the sum of floor(n / p_i) equals k.

Let me consider that floor(n / p_i) is the quotient when n is divided by p_i.

So, if I set p_i to be divisors of n, then floor(n / p_i) = n / p_i.

But p_i don't have to be divisors.

Wait, perhaps I can set p_i such that floor(n / p_i) is a certain value.

But it's tricky.

Let me consider that for each p_i, floor(n / p_i) can be any integer from 0 up to floor(n /1).

But I need to choose p_i such that the sum is exactly k.

This seems too vague.

Let me think differently.

Suppose I set p1 = ceil(n /k), then set n_remaining = n - (floor(n / p1)) * p1, and k_remaining = k - floor(n / p1).

Then, set p2 = ceil(n_remaining / k_remaining), and so on.

This is similar to the greedy algorithm for optimizing the number of stalls.

But I need to ensure that s <=60.

Wait, but this could potentially require more than 60 stalls if k is large.

But since s is allowed up to 60, and k can be up to 10^18, this might not work.

Wait, but 60 is enough because 2^60 is much larger than 10^18.

Wait, perhaps there's a way to decompose k using at most 60 stalls.

Let me consider that in the worst case, k can be up to 10^18, and n can be up to 10^18.

But with s=60, and p_i up to 10^18, it should be possible to achieve any k up to n.

But I need to confirm this.

Wait, perhaps using p_i = [n - k +1, 1] works.

Wait, in the code provided, it seems that they are trying to use two stalls: one with p1 = n -k +1 and p2=1.

Let me see what happens with this.

- At stall 1: p1 = n -k +1

- Jewels bought: floor(n / (n -k +1))

Let me compute this.

Let q = floor(n / (n -k +1))

Then, q is floor(n / (n -k +1))

Let me see what q is.

Let me set m = n -k +1

Then, q = floor(n / m)

Which is floor(n / (n -k +1))

Now, n >=k, so m >=1.

Now, n / m = n / (n -k +1)

Let me see for n=7, k=3:

m =7-3+1=5

q = floor(7/5)=1

Then, n_remaining = n - q*m =7 -1*5=2

Then, at stall 2 with p2=1:

jewels bought: floor(2/1)=2

Total jewels:1+2=3, which matches k=3.

Another example: n=10, k=3

m=10-3+1=8

q=floor(10/8)=1

n_remaining=10-1*8=2

Stall 2: p2=1, jewels= floor(2/1)=2

Total jewels:1+2=3, which matches k=3.

Another example: n=255, k=8

m=255-8+1=248

q=floor(255/248)=1

n_remaining=255-1*248=7

Stall 2: p2=1, jewels=floor(7/1)=7

Total jewels:1+7=8, which matches k=8.

This seems to work for these cases.

So, the strategy is:

- Set p1 = n -k +1

- Set p2=1

- Then, jewels bought from stall 1: floor(n / p1)

- Jewels bought from stall 2: floor(n_remaining / p2)

- Total jewels: floor(n / p1) + floor((n - floor(n / p1)*p1) / p2)

In the above examples, this equals k.

But does this always work?

Let me consider n=1, k=1.

p1=1-1+1=1

jewels from stall1: floor(1/1)=1

n_remaining=1-1*1=0

stall2: p2=1, jewels=floor(0/1)=0

Total jewels:1+0=1, which matches k=1.

Another case: n=5, k=1

p1=5-1+1=5

jewels from stall1: floor(5/5)=1

n_remaining=5-1*5=0

stall2: p2=1, jewels=0

Total jewels:1+0=1, which matches k=1.

Another case: n=5, k=2

p1=5-2+1=4

jewels from stall1: floor(5/4)=1

n_remaining=5-1*4=1

stall2: p2=1, jewels=floor(1/1)=1

Total jewels:1+1=2, which matches k=2.

Another case: n=5, k=3

p1=5-3+1=3

jewels from stall1: floor(5/3)=1

n_remaining=5-1*3=2

stall2: p2=1, jewels=floor(2/1)=2

Total jewels:1+2=3, which matches k=3.

Seems consistent.

Wait, but what if k > n?

For example, n=5, k=6

p1=5-6+1=0, but p1 cannot be 0.

Wait, p1 = n -k +1, but n -k +1 could be <=0 if k >n.

But in the problem, n and k are positive integers, and n >=1, k >=1.

But if k >n, then p1 = n -k +1 <=0, which is invalid because p1 >=1.

So, in this case, I need to handle k >n separately.

But according to the problem, if it's impossible, output "NO".

Since n <k implies that Alice cannot buy more jewels than she has coins, unless p_i are fractions, which they aren't, so it's impossible.

Hence, in this case, output "NO".

So, in the code, they have:

if n ==k:

print('YES')

print(1)

print(1)

elif n <k:

print('NO')

else:

costs = [n -k +1, 1]

h =0

for i in costs:

curr = n //i

h += curr

n -= i * curr

if h <k:

print('NO')

else:

print('YES')

print(2)

print(*costs)

So, they are using s=2 stalls: p1 =n -k +1 and p2=1.

Then, they compute h = floor(n / p1) + floor((n - floor(n / p1)*p1) / p2)

And check if h >=k.

In all the above examples, h equals k.

But is this always the case?

Let me try to generalize.

Let p1 =n -k +1

Then, floor(n / p1) = floor(n / (n -k +1))

Let q = floor(n / (n -k +1))

Then, n_remaining = n - q*(n -k +1)

Then, floor(n_remaining / p2) = floor(n_remaining /1) =n_remaining

Total jewels: q + n_remaining

But q = floor(n / (n -k +1))

And n_remaining =n - q*(n -k +1)

So, total jewels = q + (n - q*(n -k +1))

Simplify:

q + n - q*(n -k +1) = n + q*(1 - (n -k +1)) = n + q*( -n +k)

= n - q*(n -k)

Now, since q = floor(n / (n -k +1)), it's the integer division of n by (n -k +1).

Let me see for n=7, k=3:

q = floor(7 / (7-3 +1))=floor(7/5)=1

Total jewels=7 -1*(7-3)=7-4=3, which matches k=3.

Another example: n=10, k=3

q=floor(10/8)=1

Total jewels=10 -1*(10-3)=10-7=3, which matches k=3.

Another example: n=255, k=8

q=floor(255/248)=1

Total jewels=255 -1*(255-8)=255-247=8, which matches k=8.

Seems consistent.

So, in general, with p1 =n -k +1 and p2=1, the total jewels bought is n - q*(n -k), where q=floor(n / (n -k +1))

And from the examples, this equals k.

Hence, this seems to be a general solution for n >=k.

Wait, but is this always true?

Let me try to prove it.

Let q = floor(n / m), where m =n -k +1

Then, n = q*m + r, where 0 <= r < m

Then, total jewels = q + r

But r = n - q*m

Substitute m =n -k +1:

r =n - q*(n -k +1)

So, total jewels = q + (n - q*(n -k +1)) = n - q*(n -k +1) +q =n - q*(n -k +1 -1) =n - q*(n -k)

Now, I need this to equal k.

So, n - q*(n -k) =k

Rearrange:

n -k = q*(n -k)

Then, q= (n -k)/(n -k) =1, but only if n -k !=0.

Wait, but n >=k, so n -k >=0.

If n -k =0, then k=n, which is handled separately.

But if n -k >0, then q= floor(n / m), where m =n -k +1

But from the earlier examples, it seems to work.

Wait, perhaps I need to consider specific values.

Let me consider n=6, k=4

p1 =6-4+1=3

q=floor(6/3)=2

n_remaining=6 -2*3=0

stall2: p2=1, jewels=floor(0/1)=0

Total jewels:2+0=2, which is less than k=4.

Wait, this is a problem.

According to the code, it would output "NO" in this case, because h=2 <4.

But according to the problem, in this test case, the output is "NO"

Hence, the code correctly identifies that it's impossible to buy exactly k=4 jewels with n=6 coins using this strategy.

But why is it impossible?

Let me see.

If p1=3, q=2, n_remaining=0, so total jewels=2, which is less than 4.

Even if I add more stalls with p_i=1, she can't buy more jewels because she has 0 coins left.

Hence, it's impossible.

So, in this case, the code correctly outputs "NO"

Hence, the strategy is:

- If n ==k, output s=1, p=1

- If n <k, output "NO"

- Else, set p1 =n -k +1 and p2=1, and check if the total jewels bought equals k.

- If it does, output "YES" with s=2 and p1, p2

- Else, output "NO"

But in the second test case, n=6, k=4, it correctly outputs "NO"

Hence, the code seems correct.

But is there any case where h >k?

In the first and third examples, h equals k.

In the second example, h=2 <4.

Is there a case where h >k?

Let me consider n=10, k=3

p1=10-3+1=8

q=floor(10/8)=1

n_remaining=10-1*8=2

stall2: p2=1, jewels=2

Total jewels=1+2=3, which equals k=3.

Another case: n=10, k=2

p1=10-2+1=9

q=floor(10/9)=1

n_remaining=10-1*9=1

stall2: p2=1, jewels=1

Total jewels=1+1=2, which equals k=2.

Another case: n=10, k=1

p1=10-1+1=10

q=floor(10/10)=1

n_remaining=10-1*10=0

stall2: p2=1, jewels=0

Total jewels=1+0=1, which equals k=1.

Seems consistent.

Another case: n=10, k=4

p1=10-4+1=7

q=floor(10/7)=1

n_remaining=10-1*7=3

stall2: p2=1, jewels=3

Total jewels=1+3=4, which equals k=4.

Wait, but earlier with n=6, k=4, h=2 <4, which is impossible.

So, in some cases, h <k, meaning it's impossible.

But in other cases, h equals k.

Is there a way to have h >k?

Let me see.

Take n=10, k=5

p1=10-5+1=6

q=floor(10/6)=1

n_remaining=10-1*6=4

stall2: p2=1, jewels=4

Total jewels=1+4=5, which equals k=5.

Another case: n=10, k=6

p1=10-6+1=5

q=floor(10/5)=2

n_remaining=10-2*5=0

stall2: p2=1, jewels=0

Total jewels=2+0=2, which is less than k=6.

Hence, "NO"

Another case: n=10, k=3

p1=10-3+1=8

q=floor(10/8)=1

n_remaining=10-1*8=2

stall2: p2=1, jewels=2

Total jewels=1+2=3, which equals k=3.

Seems consistent.

Hence, the code seems correct in identifying whether it's possible or not.

But in the case where h <k, it's impossible.

In the case where h ==k, it's possible.

In the case where h >k, but in the code, h is only checked against h <k, but h >=k.

But in practice, h ==k.

Wait, in the code, they check if h <k, then "NO", else "YES"

But in reality, h ==k, so it's "YES"

But in the second test case, n=6, k=4, h=2 <4, so "NO"

Hence, the code seems correct.

But perhaps I need to confirm if h can be greater than k.

Let me see.

Take n=10, k=2

p1=10-2+1=9

q=floor(10/9)=1

n_remaining=10-1*9=1

stall2: p2=1, jewels=1

Total jewels=1+1=2, which equals k=2.

No h >k.

Another case: n=10, k=1

h=1+0=1==k

Another case: n=10, k=3

h=1+2=3==k

Seems h always equals k with this strategy.

Hence, the code is correct.

**Final Solution**

To solve this problem, we need to determine if Bob can set up at most 60 stalls with specific pricing such that Alice buys exactly k jewels using her n coins. The solution involves a strategic approach to set up stall prices to control the number of jewels Alice purchases.

## Approach

1. **Base Cases:**
   - If `n == k`, Alice can buy one jewel from a single stall priced at 1 coin.
   - If `n < k`, it's impossible for Alice to buy more jewels than the number of coins she has, hence output "NO".

2. **General Case:**
   - Set up two stalls:
     - First stall with price `p1 = n - k + 1`.
     - Second stall with price `p2 = 1`.
   - Calculate the number of jewels Alice can buy from each stall:
     - From the first stall: `q = n // p1`
     - Remaining coins after buying from the first stall: `n - q * p1`
     - From the second stall: `(n - q * p1) // p2`
   - Sum of jewels bought from both stalls should be equal to `k`.

3. **Verification:**
   - If the total jewels bought equal `k`, output "YES" along with the number of stalls and their prices.
   - If the total jewels bought are less than `k`, output "NO".

## Solution Code

```python
t = int(input())
for _ in range(t):
    (n, k) = list(map(int, input().split()))
    func_1(n, k)

def func_1(n, k):
    if n == k:
        print('YES')
        print(1)
        print(1)
        return
    if n < k:
        print('NO')
        return
    costs = [n - k + 1, 1]
    h = 0
    for i in costs:
        curr = n // i
        h += curr
        n -= i * curr
    if h < k:
        print('NO')
    else:
        print('YES')
        print(2)
        print(*costs)
```

## Explanation

- **Step-by-step Execution:**
  - For each test case, read `n` and `k`.
  - If `n` equals `k`, print "YES" and set up one stall with price 1.
  - If `n` is less than `k`, print "NO" since it's impossible.
  - Otherwise, set up two stalls with prices `n - k + 1` and `1`.
  - Calculate the jewels bought from each stall and verify if the total equals `k`.
  - Print "YES" and the stall prices if total jewels equal `k`, else print "NO".

- **Key Insight:**
  - By choosing `p1 = n - k + 1`, we control the number of jewels Alice buys from the first stall.
  - The remaining coins are then used to buy jewels from the second stall priced at 1 coin per jewel.
  - This strategy ensures that the total jewels bought equal `k`, provided `n >= k`.

- **Efficiency:**
  - The approach uses a constant number of operations per test case, making it efficient for large values of `n` and `k`.