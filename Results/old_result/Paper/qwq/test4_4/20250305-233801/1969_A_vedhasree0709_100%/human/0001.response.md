Alright, I've got this problem to solve. Let's see what it's asking for. Monocarp wants to throw a party and invite some of his friends, but there are some conditions. He has n friends, and each friend has a best friend, which is specified by p_i. The key points are:

1. All p_i are distinct and p_i ≠ i, meaning everyone's best friend is someone else, and no two people have the same best friend.

2. A friend comes to the party only if both they and their best friend receive an invitation.

3. Monocarp wants at least 2 friends to come to the party.

4. He needs to send the minimum number of invitations to achieve this.

First, I need to understand the relationship between the friends and their best friends. Since p_i is the best friend of the i-th friend, and all p_i are distinct and not equal to i, this forms a permutation of the friends. In other words, it's like a mapping where each friend is mapped to another unique friend.

For example, if n=5 and p=[3,1,2,5,4], this means:

- Friend 1's best friend is 3

- Friend 2's best friend is 1

- Friend 3's best friend is 2

- Friend 4's best friend is 5

- Friend 5's best friend is 4

So, it's like a bunch of cycles. In this case, friends 1,3,2 form a cycle, and friends 4 and 5 form another cycle.

Now, the condition for a friend to come to the party is that both they and their best friend receive an invitation. But note that their best friend doesn't have to come; they just need to have received an invitation.

Wait, actually, the problem says: "the i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation". So, friend i comes only if both friend i and friend p_i have received invitations.

But friend p_i might not come if they don't have an invitation from their best friend.

Wait, no. The condition is only about receiving an invitation, not about whether their best friend is coming.

Wait, let's read it again: "the i-th friend comes to the party if both the i-th friend and the p_i-th friend receive an invitation (note that the p_i-th friend doesn't have to actually come to the party). Each invitation is sent to exactly one of the friends."

So, to rephrase: Friend i will come if they have an invitation and their best friend p_i has an invitation. Friend p_i might or might not come, depending on whether they have an invitation and their own best friend has an invitation.

This seems a bit tricky. I need to think about how to model this.

First, since p_i is a permutation (since all p_i are distinct and p_i ≠ i), the structure forms a collection of disjoint cycles.

For example, in the first test case:

p = [3,1,2,5,4]

This forms two cycles:

- 1 -> 3 -> 2 -> 1 (cycle of length 3)

- 4 -> 5 -> 4 (cycle of length 2)

In general, in a cycle of length k, to make any friend in the cycle come, we need to invite both the friend and their best friend.

But wait, in a cycle of length k, how many invitations do we need to send to make at least two friends come?

Let's consider a cycle of length 2: A and B are best friends of each other.

If we invite both A and B, then both will come, because each has an invitation and their best friend has an invitation.

But if we only invite one of them, say A, then A has an invitation, but B doesn't, so A won't come. Similarly, if we invite B, same thing.

So, for a cycle of length 2, we need to invite both to make both come.

But the problem is that we need at least 2 friends to come, not necessarily from the same cycle.

Wait, no. In the first test case, n=5, p=[3,1,2,5,4], and the answer is 2.

Wait, according to the example, Monocarp can send invitations to friends 4 and 5, and both will come because 4's best friend is 5, and 5's best friend is 4, and both have invitations.

So, in this cycle of length 2, by inviting both, both come.

Similarly, in the second test case, n=4, p=[2,3,4,1], and the answer is 3.

In this case, the cycle is 1->2->3->4->1 (a single cycle of length 4).

To make at least 2 friends come, we need to invite 3 friends.

For example, invite 1,2,3:

- Friend 1 has invitation, friend p_1=2 has invitation, so friend 1 comes.

- Friend 2 has invitation, friend p_2=3 has invitation, so friend 2 comes.

- Friend 3 has invitation, friend p_3=4 has invitation, so friend 3 comes.

- Friend 4 has invitation, friend p_4=1 has invitation, so friend 4 comes.

But according to the example, Monocarp can send invitations to [1,2,3], and friends 1 and 2 will come.

Wait, but according to the problem, friend 3's best friend is 4, who has an invitation, but friend 3 doesn't have an invitation, so friend 3 won't come.

Wait, no, in the example, Monocarp sends invitations to [1,2,3], and friends 1 and 2 will come because:

- Friend 1 has invitation, friend p_1=2 has invitation, so friend 1 comes.

- Friend 2 has invitation, friend p_2=3 has invitation, so friend 2 comes.

- Friend 3 has invitation, friend p_3=4 has invitation, but friend 4 does not have an invitation, so friend 3 does not come.

Wait, but according to the problem statement, friend 3 should come because both friend 3 and friend p_3=4 have invitations.

But in this case, friend 4 has an invitation, and friend p_4=1 has an invitation, so friend 4 should also come.

Wait, but in the example, it says only friends 1 and 2 will come, which seems contradictory.

Wait, perhaps I misread the example.

Let me read the example again:

"In the second testcase, Monocarp can send invitations to friends 1,2 and 3, then friends 1 and 2 will attend: friend 1 and his best friend 2 have invitations, friend 2 and his best friend 3 have invitations. Friend 3 won't come since his friend 4 doesn't have an invitation. It's impossible to send invitations to fewer than 3 friends in such a way that at least 2 come."

Wait, according to this, friend 3 has invitation, and friend p_3=4 has invitation, but friend 4 doesn't have an invitation, so friend 3 doesn't come.

Wait, no, friend 4 has an invitation, because he is included in the invitations [1,2,3,4], but in this example, Monocarp sends invitations to [1,2,3], so friend 4 is not invited.

Wait, no, in the example, it says Monocarp sends invitations to [1,2,3], but p_3=4, and friend 4 is not invited, so friend 3 doesn't come.

Wait, but in the invitation list, it's [1,2,3], so friend 4 is not invited.

Therefore, friend 3 has invitation, but friend p_3=4 does not have invitation, so friend 3 doesn't come.

Similarly, friend 2 has invitation, and friend p_2=3 has invitation, so friend 2 comes.

Friend 1 has invitation, and friend p_1=2 has invitation, so friend 1 comes.

Friend 3 has invitation, but friend p_3=4 does not have invitation, so friend 3 doesn't come.

Friend 4 is not invited, so doesn't come.

Hence, only friends 1 and 2 come.

But according to the problem, Monocarp wants at least 2 friends to come, which is satisfied by inviting 3 friends in this case.

But the example also says it's impossible to send invitations to fewer than 3 friends in such a way that at least 2 come.

So, in this case, the minimum number of invitations is 3.

Another example is the third test case with n=2, p=[2,1], and the answer is 2.

In this case, inviting both friends 1 and 2 will make both come, since each has an invitation and their best friend has an invitation.

So, for cycles of length 2, inviting both makes both come.

For cycles of length 3, like in the first test case, inviting 2 friends from the cycle makes 2 come.

Wait, in the first test case, inviting friends 4 and 5 (which are in a cycle of length 2) makes both come, so total of 2 come.

In the second test case, inviting 3 friends makes 2 come.

So, perhaps in general, for a cycle of length k, the number of invitations needed to make at least 2 friends come is:

- For k=2: invite both to make both come.

- For k=3: invite 2 to make 2 come.

- For k=4: invite 3 to make 2 come.

Wait, in the second test case, n=4, cycle length 4, inviting 3 makes 2 come.

Is there a pattern here?

Wait, perhaps in a cycle of length k, the minimal number of invitations to make at least 2 friends come is ceil(k/2).

Wait, for k=2: ceil(2/2)=1, but in reality, for k=2, inviting both is needed to make both come.

Wait, no, ceil(2/2)=1, but in reality, for k=2, inviting both is needed.

Wait, maybe it's different.

Wait, perhaps in a cycle of length k, to make at least 2 friends come, we need to invite a certain number of people.

Wait, perhaps it's k if k is even, and k-1 if k is odd.

Wait, no, that doesn't match the examples.

Wait, in the first test case, cycle lengths 3 and 2: inviting 2 makes 2 come.

In the second test case, cycle length 4: inviting 3 makes 2 come.

In the third test case, cycle length 2: inviting 2 makes 2 come.

So, perhaps in general, for a cycle of length k, the minimal number of invitations to make at least 2 friends come is min(k, ceil(k/2) + something).

This seems complicated.

Alternatively, perhaps we can think in terms of selecting pairs.

Wait, no, it's more about selecting subsets of friends to invite, such that at least 2 friends come, where a friend comes only if both they and their best friend are invited.

But this seems time-consuming for n up to 50 and t up to 5000.

Wait, but n is up to 50 and t is up to 5000, so a straightforward approach might be too slow.

Wait, but n is small (n<=50), and t is 5000, so perhaps an O(n^2) per test case is acceptable.

But let's think about the problem differently.

Given that p_i is a permutation without fixed points and all p_i are distinct, this permutation can be decomposed into disjoint cycles.

In each cycle, the friends are connected in a cycle where each points to their best friend.

Now, to make a friend come, both the friend and their best friend need to be invited.

But since it's a cycle, inviting every alternate friend might not suffice.

Wait, perhaps thinking in terms of matching in graph theory could help.

If we consider the friends as nodes in a graph, and the best friend relationships as edges, then the graph is a collection of disjoint cycles.

In each cycle, we need to select a subset of nodes to invite, such that for at least 2 nodes, both the node and its best friend are invited.

We need to minimize the total number of invitations.

This seems similar to selecting edges in the cycle such that at least 2 nodes are covered by both endpoints of the edges.

Wait, perhaps another way: in each cycle, to make a friend come, we need to invite both the friend and its best friend.

So, in terms of the cycle, selecting a pair (i, p_i) means inviting both i and p_i, and friend i will come.

But since p_i is also invited, and p_i's best friend is p_{p_i}, if p_{p_i} is also invited, then p_i will come as well.

Wait, no, each invitation is sent to exactly one friend, so inviting i and p_i are two separate invitations.

Wait, no, each invitation is sent to exactly one friend, but you can send invitations to multiple friends.

Wait, the problem says "Each invitation is sent to exactly one of the friends."

But you can send invitations to as many friends as needed.

Wait, but in the code provided, it seems like it's trying to invite subsets of friends and see who comes.

But the code is not clear to me.

Wait, let's look at the provided code:

def func():

for _ in range(int(input())):

n = int(input())

l = list(map(int, input().split()))

i = 0

j = 0

while i <= n - 1:

p = l[i]

q = l[p - 1]

if q == i + 1:

print(2)

j = 1

break

i += 1

if j == 0:

print(3)

So, it's reading t test cases, for each test case, reading n and the list p.

Then, it iterates through each friend i from 0 to n-1.

For each i, it gets p[i] and q = l[p-1], which is p_{p_i}.

If q == i+1, meaning p_{p_i} == i+1, which means that p_i's best friend is i.

But since p_i is the best friend of i, and i's best friend is p_i, and p_{p_i} is i, this forms a cycle of length 2.

Wait, no, in general, p_{p_i} = i, because p is a permutation where p_p_i = i.

Wait, is that always true?

Wait, given that p is a permutation without fixed points and all p_i are distinct, and p_p_i = i, because p is an involution (since p_p_i = i).

Wait, is p an involution?

Wait, in the first test case, p = [3,1,2,5,4]

p_1 = 3, p_3 = 2, p_2 = 1; p_4 = 5, p_5 = 4.

So, p_p_1 = p_3 = 2, which is not 1.

Wait, p_p_1 should be p_{p_1} = p_3 = 2, which is not equal to 1.

Wait, but in the code, it checks if q == i+1, which would be p_{p_i} == i+1.

In the first test case, for i=0, p=3, q=l[2]=2, which is not equal to 1.

For i=1, p=1, but p_i cannot be i, as p_i ≠ i.

Wait, but in the problem statement, p_i ≠ i, so p_p_i may or may not be equal to i.

Wait, in the first test case, p = [3,1,2,5,4]

Wait, p_1=3, p_3=2, p_2=1; p_4=5, p_5=4.

So, p_p_1 = p_3 = 2, which is not equal to 1.

Similarly, p_p_2 = p_1 = 3, which is not equal to 2.

p_p_3 = p_2 = 1, which is equal to 3 only if 1==3, which it's not.

p_p_4 = p_5 = 4, which is equal to 4, but p_i ≠ i, so p_p_i ≠ i.

Wait, in this case, p_p_4 = p_5 = 4, but p_i ≠ i, so p_p_i ≠ i.

Wait, no, p_p_i can be i, but in this case, p_p_i = i only if p_i = p^{-1}_i.

Wait, this is getting complicated.

In the code, it checks if p_p_i == i+1, which seems arbitrary.

In the first test case, it doesn't find any i where p_p_i == i+1, so it prints 3.

But according to the example, the minimal number is 2.

So, the code is wrong for the first test case.

Wait, but in the first test case, the minimal number is 2, but the code prints 3 if it doesn't find any i where p_p_i == i+1.

So, the code is incorrect.

Wait, but in the third test case, n=2, p=[2,1], p_p_1 = p_2 =1, which is equal to 1+1=2? Wait, no, i=0, p=2, q=l[1]=1, which is not equal to 2.

i=1, p=1, but p_i ≠ i, so p=1 is invalid.

Wait, in the input, p_i are 1-based indices, but in the list, they are 0-based.

Wait, no, in the code, l is 0-based, but p_i are 1-based.

Wait, in the code, l = list(map(int, input().split())), so l[0] corresponds to p_1.

So, in the first test case, l=[3,1,2,5,4], so p_1=3, p_2=1, p_3=2, p_4=5, p_5=4.

In the loop, i goes from 0 to n-1:

p = l[i]

q = l[p - 1]

if q == i + 1:

print(2)

j = 1

break

So, for i=0:

p=l[0]=3, q=l[2]=2, check if 2 == 1 (i+1=1), no.

i=1:

p=l[1]=1, q=l[0]=3, check if 3 == 2, no.

i=2:

p=l[2]=2, q=l[1]=1, check if 1 == 3, no.

i=3:

p=l[3]=5, q=l[4]=4, check if 4 == 4, which is true.

So, it prints 2 for the first test case, which is correct.

In the second test case, p=[2,3,4,1]

So, l=[2,3,4,1]

Loop:

i=0:

p=2, q=l[1]=3, check if 3==1, no.

i=1:

p=3, q=l[2]=4, check if 4==2, no.

i=2:

p=4, q=l[3]=1, check if 1==3, no.

i=3:

p=1, q=l[0]=2, check if 2==4, no.

So, it prints 3, which is correct.

In the third test case, n=2, p=[2,1]

l=[2,1]

i=0:

p=2, q=l[1]=1, check if 1==1, yes, print 2.

So, it prints 2, which is correct.

So, in this case, it seems to work.

But is this logic correct in general?

In the first test case, it found that p_p_3 =1 == i+1=4, which is false.

Wait, i=3, p=5, q=l[4]=4, check if 4==4, which is true, so print 2.

But in this case, it's correct.

In the second test case, it doesn't find any such i, so prints 3.

In the third test case, i=0: p=2, q=1, check if 1==1, yes, print 2.

So, it seems to work for these cases.

But is this logic general?

Let's think about what the condition p_p_i == i+1 means.

p_p_i == i+1 means that the best friend of p_i is i+1.

But p_i is the best friend of i, and p_p_i is the best friend of p_i, which should be i, since p is a permutation without fixed points and all p_i are distinct.

Wait, in the first test case, p_p_1 = p_3 =2, which is not equal to 1.

p_p_2 = p_1 =3, which is not equal to 2.

p_p_3 = p_2 =1, which is equal to 3 only if 1==3, which it's not.

p_p_4 = p_5 =4, which is equal to 4, but p_i ≠ i, so p_p_i ≠ i.

Wait, but in the first test case, p_p_4 = p_5 =4, and i=3 (0-based), i+1=4, so 4==4, which satisfies the condition.

Similarly, in the third test case, p_p_1 = p_2 =1 ==1+1=2? No, p_p_1=1 ==2? No.

Wait, i=0, p=2, q=1, check if 1==1, yes.

i=1, p=1, but p_i ≠ i, so p=1 is invalid.

Wait, in the third test case, p=[2,1], but p_i ≠ i, so p_1=2, p_2=1.

p_p_1 = p_2 =1 ==2? 1==2? No.

Wait, i=0, p=2, q=1, check if 1==1, which is true.

So, it prints 2.

But in general, is this condition sufficient to determine that the minimal number of invitations is 2?

In other words, if there exists an i such that p_p_i ==i+1, then the minimal number of invitations is 2, else it's 3.

Is this always true?

In the second test case, p=[2,3,4,1], p_p_i for i=1:

p_p_1 = p_2 =3 !=1

i=2:

p_p_2 = p_3=4 !=2

i=3:

p_p_3 = p_4=1 !=3

i=4:

p_p_4 = p_1=2 !=4

So, no such i, so prints 3, which is correct.

In the first test case, for i=3, p_p_4 = p_5=4 ==4, so prints 2, which is correct.

In the third test case, i=0: p_p_1 = p_2=1 ==1, so prints 2, which is correct.

Let me think of another test case.

Suppose n=3, p=[2,3,1]

This is a cycle of length 3.

According to the code, for i=0:

p=2, q=3, check if 3==1? No.

i=1:

p=3, q=1, check if 1==2? No.

i=2:

p=1, q=2, check if 2==3? No.

So, it would print 3, which is correct, because in this cycle of 3, inviting 3 makes at least 2 come.

Wait, but in this cycle of 3, inviting any 2 friends makes all 3 come.

Wait, let's see:

If we invite friends 1 and 2:

- Friend 1 has invitation, p_1=2 has invitation, so friend 1 comes.

- Friend 2 has invitation, p_2=3 has invitation, so friend 2 comes.

- Friend 3 has invitation, p_3=1 has invitation, so friend 3 comes.

So, inviting 2 makes all 3 come.

But according to the code, it would print 3, which is incorrect in this case.

Wait, but according to the problem, Monocarp wants at least 2 friends to come, so inviting 2 is sufficient.

But the code would print 3, which is incorrect.

Wait, but in this case, there is no i such that p_p_i ==i+1.

p_p_1 = p_2=3 !=1+1=2

p_p_2 = p_3=1 !=2+1=3

p_p_3 = p_1=2 !=3+1=4

So, it prints 3, but actually inviting 2 is sufficient.

So, the code is incorrect in this case.

Hence, the code is wrong.

Therefore, Correctness: **False**

**Final Answer**

\[ \boxed{\text{False}} \]