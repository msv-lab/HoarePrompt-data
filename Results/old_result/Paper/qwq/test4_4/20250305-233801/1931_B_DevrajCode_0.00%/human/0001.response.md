Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n containers of water, each containing a certain amount of water. The sum of all the water in these containers is divisible by n, which means if I divide the total water by n, there's no remainder. That makes sense because the goal is to make sure each container has the same amount of water in the end.

Now, the operation I can perform is pouring water from one container to another, but with a restriction: I can only pour from a container with a lower index to a higher index. That means if I have containers 1 through n, I can pour from container 1 to 2, or from 1 to 3, and so on, but not from 2 to 1. Also, I can choose any i and j as long as i < j, and pour any amount from i to j, multiple times if I want.

The question is, can I make all the containers have the same amount of water using these operations?

First, since the sum of a_i is divisible by n, there exists some value, let's call it 'target', such that each container should have 'target' units of water in the end. Target is simply the total sum divided by n.

So, my goal is to make sure each a_i equals target.

But I have restrictions on how I can move the water. I can only pour from a lower-indexed container to a higher-indexed one.

Let me think about what this implies.

Suppose I have three containers: a1, a2, a3.

If a1 has more than target, I can pour from a1 to a2 or a3.

If a2 has more than target, I can only pour to a3, since a3 has a higher index than a2.

Similarly, a3 can't receive water from anywhere because there's no container with a higher index.

Wait, a3 can receive from a1 or a2, but a2 can only pour to a3.

So, in this scenario, a3 is the last container, and it can receive from any previous container.

My intuition tells me that, starting from the left, I need to make sure that any excess water in a container is poured to the right, and any deficit is filled from the left.

But I have to ensure that I'm only pouring from left to right, as per the operation's restriction.

Let me consider the first test case in the example:

n = 1

a = [43]

Well, with only one container, it already has the required amount, so YES.

Second test case:

n = 2

a = [1, 3]

Total sum is 4, divisible by 2, so target is 2.

So, I need to make both containers have 2 units.

Looking at the containers:

Container 1 has 1, needs 1 more.

Container 2 has 3, has 1 more than needed.

So, I can pour 1 unit from container 2 to container 1.

After pouring, both have 2, which is the target.

So, YES.

But according to the sample output, it's NO. Wait, no, the sample output for n=2 is NO.

Wait, let's check the sample input and output again.

Sample Input:

6

1

43

2

1 3

5

4 5 2 1 3

3

1 2 3

7

4 5 5 0 6 4 4

7

6 5 5 1 3 4 4

Sample Output:

YES

NO

YES

NO

NO

YES

Wait, for n=2, a=[1,3], the output is NO. But according to my earlier reasoning, it should be YES.

Hmm, maybe I'm missing something.

Let me read the problem statement again.

"Oh, I see. The operation is: pour any amount of water from the i-th container to the j-th container, where i < j."

So, in the second test case, n=2, a=[1,3].

I can only pour from container 1 to container 2, since 1 < 2.

So, I can pour up to 1 unit from container 1 to container 2.

But container 1 has only 1 unit, so after pouring, container 1 has 0, and container 2 has 4.

Which is not equal. So, it's impossible to make both have the same amount.

Wait, but in my earlier thought, I was considering pouring from container 2 to container 1, but that's not allowed because 2 is not less than 1.

So, indeed, it's impossible. So, the answer should be NO.

I must be careful with the direction of pouring.

So, in this problem, I can only pour from left to right, not the other way around.

So, in the second test case, I can only pour from container 1 to container 2, but that won't help in equalizing the water.

Similarly, in the third test case, n=5, a=[4,5,2,1,3].

Total sum is 15, divisible by 5, so target is 3.

So, I need each container to have 3 units.

Looking at the containers:

Container 1: 4 (needs to give 1)

Container 2: 5 (needs to give 2)

Container 3: 2 (needs 1)

Container 4: 1 (needs 2)

Container 5: 3 (okay)

So, I can pour from container 1 to container 3: pour 1 unit, so container 1 has 3, container 3 has 3.

Now, container 2 has 5, needs to give 2.

Can pour to container 4 and 5.

Pour 2 units to container 4: container 4 has 3, container 2 has 3.

Now, all containers have 3 units.

So, it's possible.

Hence, YES.

But how can I generalize this?

I need to find a way to distribute the water such that each container ends up with the target amount, only by pouring from lower-indexed to higher-indexed containers.

I need to ensure that for each container, if it has more than the target, I can pour its excess to the right, and if it has less, it can receive from the left.

But I need to make sure that the operations are only from left to right.

Maybe I can iterate from left to right, keeping track of the cumulative difference from the target.

If at any point, the cumulative difference becomes negative, it means I need more water than what's available from the left, which is impossible because I can't pour from right to left.

So, perhaps, I can iterate through the containers, keeping a running sum of (a_i - target).

If this running sum ever becomes negative, it means I've tried to pour more water to the right than what's available from the left, which is not possible with the given operations.

If the running sum remains non-negative throughout, then it's possible to equalize the water.

Let me test this idea with the sample inputs.

First test case:

n=1, a=[43], target=43.

Running sum: 43 - 43 = 0. Non-negative. YES.

Second test case:

n=2, a=[1,3], target=2.

Running sum:

1 - 2 = -1 (negative), which is not allowed. So, NO.

Third test case:

n=5, a=[4,5,2,1,3], target=3.

Running sum:

4-3=1

1 + (5-3)=3

3 + (2-3)=2

2 + (1-3)=0

0 + (3-3)=0

Never negative. So, YES.

Fourth test case:

n=3, a=[1,2,3], target=2.

Running sum:

1-2=-1 (negative). So, NO.

Fifth test case:

n=7, a=[4,5,5,0,6,4,4], target=4.

Running sum:

4-4=0

0 + (5-4)=1

1 + (5-4)=2

2 + (0-4)=-2 (negative). So, NO.

Sixth test case:

n=7, a=[6,5,5,1,3,4,4], target=4.

Running sum:

6-4=2

2 + (5-4)=3

3 + (5-4)=4

4 + (1-4)=1

1 + (3-4)=0

0 + (4-4)=0

0 + (4-4)=0

Never negative. So, YES.

This matches the sample outputs.

So, this seems to be a correct approach.

Hence, the function should iterate through the containers, keeping a running sum of (a_i - target), and check if this sum ever becomes negative.

If it does, return 'NO', else return 'YES'.

This is a O(n) solution per test case, which is efficient given the constraints.

Now, looking at the given program:

import sys

input = sys.stdin.read

data = input().split()

n = int(data[0])

a = list(map(int, data[1:]))

print(func_1(n, a))

def func_1(n, a):

total_water = sum(a)

if total_water % n != 0:

return 'No'

target = total_water // n

container = 0

for water in a:

container += water - target

if container < 0:

return 'No'

return 'Yes'

Wait a minute, in the problem statement, it's guaranteed that the sum of a_i is divisible by n, so the if condition checking if total_water % n != 0 is redundant, but it doesn't harm to have it.

The function seems to implement exactly what I described: iterate through the containers, keep a running sum of (a_i - target), and if it ever becomes negative, return 'No', else return 'Yes'.

Looking back at the sample inputs and outputs, it matches.

Hence, I believe this program is correct.

**Final Solution**

To solve this problem, we need to determine if it is possible to make the amount of water in each of the n containers the same by pouring water from a lower-indexed container to a higher-indexed container.

### Approach

1. **Calculate the Target Amount:**
   - Compute the total amount of water across all containers.
   - Check if the total water is divisible by the number of containers (n). If not, it's impossible to equalize.
   - Compute the target amount of water each container should have.

2. **Check Feasibility:**
   - Iterate through the containers from left to right.
   - Maintain a running sum of the difference between the current container's water and the target.
   - If at any point this running sum becomes negative, it means we are trying to pour more water to the right than is available, which is not allowed. Hence, it's impossible to equalize the water.

### Solution Code

```python
def func_1(n, a):
    total_water = sum(a)
    if total_water % n != 0:
        return 'No'
    target = total_water // n
    container = 0
    for water in a:
        container += water - target
        if container < 0:
            return 'No'
    return 'Yes'

# Example usage:
# t = int(input())
# for _ in range(t):
#     n = int(input())
#     a = list(map(int, input().split()))
#     print(func_1(n, a))
```

### Explanation

- **Step 1:** Calculate the total water and determine the target amount each container should have.
- **Step 2:** Iterate through each container, adjusting a running sum by adding the difference between the current container's water and the target.
- **Step 3:** If the running sum ever goes negative, return 'No' indicating it's impossible to equalize the water.
- **Step 4:** If the loop completes without the running sum going negative, return 'Yes' indicating it's possible to equalize the water.

This approach ensures that we are only pouring water from left to right and efficiently checks the feasibility in O(n) time per test case.