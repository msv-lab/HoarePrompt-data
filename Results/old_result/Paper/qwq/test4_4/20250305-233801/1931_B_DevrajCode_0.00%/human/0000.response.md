Alright, I have this problem to solve. Let's see what it's asking for. So, there are n containers of water, each containing a certain amount of water. The containers are lined up from left to right, numbered from 1 to n. I can pour water from one container to another, but only if the source container has a higher number than the destination container. In other words, I can only pour from a rightward container to a leftward one, but only if the source index is greater than the destination index.

The goal is to make sure that all containers have the same amount of water in the end, and I can do this by performing any number of these pouring operations.

First, I need to understand the constraints and what's given:

- There are t test cases.

- For each test case, there's an integer n (1 ≤ n ≤ 2*10^5), which is the number of containers.

- Then there's a list of n integers a1, a2, ..., an (0 ≤ ai ≤ 10^9), representing the initial amount of water in each container.

- The sum of ai for each test case doesn't exceed 2*10^9, and the sum is divisible by n.

- The total sum of n over all test cases doesn't exceed 2*10^5.

- I can only pour from a higher-indexed container to a lower-indexed one (i < j).

- I need to determine if it's possible to make all containers have the same amount of water using such operations.

First, since the sum of ai is divisible by n, the target amount of water in each container is sum(ai)/n. Let's call this target.

So, the target is achievable in terms of total water, but the question is whether it's possible given the pouring constraints.

Let me think about what the pouring operation allows me to do. I can only pour from a higher-indexed container to a lower-indexed one. That means, for any container k, I can only receive water from containers with indices greater than k.

So, for each container k, the amount of water it can have in the end is its initial amount plus any amount poured into it from containers with indices greater than k.

Similarly, for any container k, it can pour its water to any container with an index less than k.

Wait, but the operation is only from higher to lower indices directly. So, I can't pour from a higher container to a lower one via intermediate containers; each pouring is direct from one to another.

But actually, since I can perform multiple operations, I might be able to indirect pouring through multiple steps.

Wait, but I think the key is to realize that pouring from i to j (i < j) means that water can only move from right to left, but in a direct manner.

But in multiple steps, water can be moved further left by pouring through a sequence of pourings.

But perhaps there's a better way to model this.

Let me consider that in the end, each container should have the target amount.

Let's consider the containers from right to left.

Start from the rightmost container (highest index). It can only pour water to the left, but no one can pour into it since there's no higher-indexed container to pour into it.

So, the rightmost container can only reduce its water by pouring to the left. It cannot receive any water from elsewhere.

Similarly, the second-rightmost container can pour to the left, and can receive pouring only from the rightmost container.

Wait, but according to the problem, pouring is only allowed from i to j where i < j, meaning pouring from left to right is not allowed. So, higher-indexed containers can pour to lower-indexed ones.

Wait, no, i < j means pouring from lower to higher indices is allowed, but the problem says i must be less than j, which means pouring from left to right.

Wait, let's clarify: containers are numbered from 1 to n, left to right.

So, lower indices are leftmost containers, higher indices are rightmost containers.

The operation allows pouring from i to j where i < j, meaning pouring from left to right.

So, I can pour from a leftward container to a rightward one, but not the other way around.

Wait, that seems counterintuitive based on the earlier interpretation, so let's make sure.

Looking back at the problem statement:

"pour any amount of water from the i-th container to the j-th container, where i must be less than j (i.e., i < j)."

So, i < j means pouring from left to right.

So, operations are only allowed to pour from left to right.

So, in terms of directions:

- Containers on the left can pour to containers on the right.

- Containers on the right cannot pour to containers on the left.

Given that, let's think about what this implies for achieving equal amounts.

Starting from the leftmost container, it can pour to any container to its right, directly or indirectly.

The rightmost container can only receive water from the containers to its left, but cannot pour out to any container since there's no j > n.

Wait, actually, for the rightmost container (index n), j must be greater than n, which is impossible, so it cannot pour to any container. So, the rightmost container cannot pour out to anyone.

Similarly, the leftmost container (index 1) can pour to any container with j > 1.

Given that, I need to make sure that each container ends up with the target amount.

Let me consider the rightmost container first. Since it cannot receive any pouring from the right (there's no higher index), it can only reduce its water by pouring to the left, but wait, it cannot pour to the left because pouring is only from left to right.

Wait, no: pouring is from i to j where i < j, meaning from left to right.

So, the rightmost container cannot pour to anyone because there's no j > n.

Therefore, the rightmost container can only reduce its water by pouring to some container to its left, but since it cannot pour to anyone, its initial amount must already be equal to the target.

Wait, no: the rightmost container cannot pour to anyone, so its initial amount must be less than or equal to the target, because it can only receive water, not give water.

Wait, actually, no: the rightmost container cannot pour to anyone because j must be greater than n, which is impossible. So, it cannot pour out to anyone.

But it can receive pouring from any container to its left, meaning any container with index less than n can pour into it.

Wait, no: pouring is from i to j where i < j, meaning pouring from left to right.

So, any container with i < n can pour into the rightmost container (j = n).

Therefore, the rightmost container can receive pouring from any container to its left, but it cannot pour out to anyone.

Given that, the rightmost container's final amount will be its initial amount plus any amount poured into it from the containers to its left.

To achieve the target, if its initial amount is already equal to the target, no pouring is needed.

If its initial amount is less than the target, it needs to receive some amount from the containers to its left.

If its initial amount is more than the target, it has a problem because it cannot pour out to anyone; it's stuck with that extra water.

Wait, but the sum of all a_i is divisible by n, so the total water is sufficient, but the distribution needs to be equal.

Given that, for the rightmost container, if its initial amount is more than the target, it cannot reduce it by pouring out, because it cannot pour out to anyone.

Therefore, for the rightmost container, its initial amount must be less than or equal to the target.

Similarly, for the second-rightmost container, after considering the rightmost container's requirements.

Wait, maybe I should approach this from the right to the left.

Let me consider the containers in reverse order, from n to 1.

For container n:

- It can receive pouring from any container with i < n.

- It cannot pour out to anyone.

- Therefore, its final amount is its initial amount plus any pouring from containers to its left.

- To reach the target, if its initial amount is less than the target, it needs to receive some amount from the containers to its left.

- If its initial amount is more than the target, it's impossible because it cannot pour out.

Therefore, for container n, its initial amount must be less than or equal to the target.

Similarly, for container n-1:

- It can receive pouring from containers with i < n-1.

- It can also have pouring to container n.

- However, pouring to container n affects both container n-1 and container n.

This seems a bit complicated.

Maybe I need to think in terms of cumulative sums.

Let me consider the target amount, which is sum(a)/n.

Let's denote the target as t = sum(a)/n.

Now, for each container i, its final amount should be t.

Given that, I need to make sure that, starting from the rightmost container, its initial amount is <= t, because it cannot pour out to anyone.

Similarly, for the second-rightmost container, its initial amount plus any pouring to the rightmost container should allow both to reach t.

This seems tricky.

Maybe I can think of it in terms of deficits and surpluses.

Let's define for each container i:

- If a_i < t, it has a deficit of t - a_i.

- If a_i >= t, it has a surplus of a_i - t.

Now, the total surplus must equal the total deficit, since sum(a) = n*t.

Given that, I need to make sure that the surplus in the left containers can be poured into the deficit in the right containers, given the pouring direction constraints.

Since pouring is only allowed from left to right, surpluses can only be poured into deficits that are to the right.

Therefore, for each container, if it has a surplus, it can pour it to any container to its right that has a deficit.

Similarly, a container with a deficit can only receive pouring from containers to its left that have surpluses.

Given that, to determine if it's possible to balance all containers, I need to ensure that for every container with a deficit, there is sufficient surplus available from the containers to its left.

Wait, but more precisely, for each container with a deficit, the sum of surpluses from all containers to its left should be at least equal to its deficit.

But, since pouring is only from left to right, I need to make sure that at any point, the cumulative surplus from the left is enough to cover the cumulative deficit on the right.

Wait, perhaps I should iterate from left to right, keeping track of the cumulative surplus or deficit.

Let me try that.

Initialize a variable, let's say, "excess", starting at 0.

Iterate through each container from left to right:

- For each container, calculate a_i - t.

- If a_i - t > 0, it's a surplus, add it to excess.

- If a_i - t < 0, it's a deficit, subtract it from excess.

- At any point, if excess < 0, it means the deficit cannot be covered by the surplus available from the left, so it's impossible.

- If I can go through all containers without excess becoming negative, then it's possible.

Wait, let's think about this.

Excess starts at 0.

For each container:

- If a_i > t, add (a_i - t) to excess.

- If a_i < t, subtract (t - a_i) from excess.

- If at any point excess < 0, return "No".

- If all containers are processed without excess < 0, return "Yes".

This seems similar to the idea in some other problems, like checking if a subarray sum exceeds a certain value.

Let me test this logic with the sample input.

Sample Input:

6

1

43

2

1 3

5

4 5 2 1 3

3

1 2 3

7

4 5 5 0 6 4 4

7

6 5 5 1 3 4 4

Sample Output:

YES

NO

YES

NO

NO

YES

Let's take the second test case:

n = 2

a = [1, 3]

t = (1+3)/2 = 2

So, a_i - t:

1 - 2 = -1 (deficit of 1)

3 - 2 = 1 (surplus of 1)

Excess starts at 0.

First container: -1, so excess -= 1 => excess = -1 < 0 => "No"

Which matches the sample output "NO".

Third test case:

n = 5

a = [4,5,2,1,3]

t = (4+5+2+1+3)/5 = 15/5 = 3

a_i - t:

4-3=1

5-3=2

2-3=-1

1-3=-2

3-3=0

Excess starts at 0.

First container: 1, excess +=1 => 1

Second container: 2, excess +=2 => 3

Third container: -1, excess -=1 => 2

Fourth container: -2, excess -=2 => 0

Fifth container: 0, excess +=0 => 0

Never negative, so "Yes".

Which matches the sample output.

Fourth test case:

n=3

a=[1,2,3]

t=(1+2+3)/3=2

a_i - t:

1-2=-1

2-2=0

3-2=1

Excess starts at 0.

First container: -1, excess -=1 => -1 <0 => "No"

Which matches the sample output "NO".

Fifth test case:

n=7

a=[4,5,5,0,6,4,4]

t=(4+5+5+0+6+4+4)/7=28/7=4

a_i - t:

4-4=0

5-4=1

5-4=1

0-4=-4

6-4=2

4-4=0

4-4=0

Excess starts at 0.

First container: 0, excess +=0 =>0

Second container:1, excess +=1 =>1

Third container:1, excess +=1 =>2

Fourth container:-4, excess -=4 => -2 <0 => "No"

Which matches the sample output "NO".

Sixth test case:

n=7

a=[6,5,5,1,3,4,4]

t=(6+5+5+1+3+4+4)/7=28/7=4

a_i - t:

6-4=2

5-4=1

5-4=1

1-4=-3

3-4=-1

4-4=0

4-4=0

Excess starts at 0.

First container:2, excess +=2 =>2

Second container:1, excess +=1 =>3

Third container:1, excess +=1 =>4

Fourth container:-3, excess -=3 =>1

Fifth container:-1, excess -=1 =>0

Sixth container:0, excess +=0 =>0

Seventh container:0, excess +=0 =>0

Never negative, so "Yes", which matches the sample output.

So, this logic seems to work for the sample inputs.

Now, let's look at the provided program and see if it implements this logic correctly.

Given program:

import sys

input = sys.stdin.read

data = input().split()

n = int(data[0])

a = list(map(int, data[1:]))

print(func_1(n, a))

def func_1(n, a):

total_water = sum(a)

if total_water % n != 0:

return 'No'

target = total_water // n

container = 0

for water in a:

container += water - target

if container < 0:

return 'No'

return 'Yes'

Wait, but in the problem statement, it says that the sum is always divisible by n, so the check if total_water % n != 0 is redundant, but it doesn't hurt to have it.

Then, target = total_water // n

Then, it initializes a variable "container" to 0.

Then, iterates through each a_i:

container += water - target

if container < 0:

return 'No'

return 'Yes'

This seems to match the logic I thought of earlier.

"container" here represents the cumulative excess.

For each a_i, a_i - target:

- If a_i > target, it's added to container (excess).

- If a_i < target, it's subtracted from container (deficit).

If at any point container < 0, it means the deficit cannot be covered by the surplus available from the left, so it's impossible.

Otherwise, it's possible.

This matches exactly with the logic I tested with the sample inputs, and it works correctly for those cases.

Therefore, I conclude that the given program is correct.

**Final Answer**

\[\boxed{\text{Yes}}\]