Alright, I have this problem to solve. It involves a game between Alice and Bob on an array, and I need to determine the final score based on their optimal plays. Let's break down the problem step by step.

First, understanding the game mechanics:

1. There's an array `a` of size `n`, and Alice starts with an empty array `c`.

2. Players take turns, with Alice going first.

3. On Alice's turn, she picks one element from `a`, appends it to `c`, and deletes it from `a`.

4. On Bob's turn, he picks one element from `a`, deletes it from `a`, but does not add it to `c`.

5. The game ends when `a` is empty, and the score is the MEX of `c`. Alice wants to maximize the MEX, while Bob wants to minimize it.

MEX is the smallest non-negative integer not present in the array. For example:

- MEX of [2,2,1] is 0.

- MEX of [3,1,0,1] is 2.

- MEX of [0,3,1,2] is 4.

Given that, I need to find out what the final MEX will be if both play optimally.

Looking at the provided program:

```python
from collections import Counter

def func():
    for _ in range(int(input())):
        n = int(input())
        arr = list(map(int, input().split()))
        mpp = Counter(arr)
        first = False
        for i in range(n + 1):
            if i not in mpp.keys():
                print(i)
                break
            if mpp[i] == 1 and first:
                print(i)
                break
            if mpp[i] == 1:
                first = True
```

I need to determine if this program correctly solves the problem.

Let's analyze the logic:

1. It reads the number of test cases.

2. For each test case, it reads `n` and the array `a`.

3. It creates a frequency map (`mpp`) of the elements in `a` using `Counter`.

4. It then iterates from 0 to `n`:

- If the current number `i` is not in `mpp`, it prints `i` and breaks.

- If `mpp[i] == 1` and `first` is True, it prints `i` and breaks.

- If `mpp[i] == 1`, it sets `first` to True.

Wait, this seems off. Let's see what this is doing.

Essentially, it's looking for the smallest `i` that is either not present in `a` or present only once, with some condition based on `first`.

But is this correctly capturing the optimal play scenario?

Let's think about the game dynamics:

- Alice wants to maximize the MEX of `c`, which means she wants to include as many required numbers in `c` as possible, in the order of their smallest missing value.

- Bob wants to minimize the MEX, meaning he wants to prevent Alice from including certain numbers in `c`.

- Since Alice can choose which element to add to `c` and remove from `a`, and Bob can only remove an element from `a`, their actions affect which elements remain available and which end up in `c`.

I need to model their optimal strategies:

- Alice will try to include the smallest possible numbers in `c` that are still needed to maximize the MEX.

- Bob will try to hinder Alice by removing elements that Alice could use to maximize the MEX.

Given that, I need to simulate their decisions or find a way to compute the final MEX based on the frequencies of the numbers.

Looking back at the provided code, it seems to be trying to find the smallest `i` that is either missing or appears only once, with some condition on the sequence of appearances.

But is this accurate?

Let me consider the examples provided:

First test case:

n = 4

a = [0, 0, 1, 1]

According to the explanation, a possible game leads to c = [1,0], MEX = 2.

But is this the optimal outcome?

Wait, let's think differently. Since Alice wants to maximize MEX, she would aim to have as many low numbers in `c` as possible.

Bob, wanting to minimize MEX, would try to prevent Alice from including certain numbers.

Given that, the MEX would be the smallest number not included in `c` after the game.

Given that Alice starts and both play optimally, I need to determine the final MEX.

Looking at the first test case:

a = [0,0,1,1]

Possible moves:

- Alice picks 1, c = [1], a = [0,0,1]

- Bob picks 0, a = [0,1]

- Alice picks 0, c = [1,0], a = [1]

- Bob picks 1, a = []

Final c = [1,0], MEX = 2.

Is this the best Alice can do? Could she have gotten a higher MEX?

If Alice picks 0 first:

- Alice picks 0, c = [0], a = [0,1,1]

- Bob picks 1, a = [0,1]

- Alice picks 1, c = [0,1], a = [0]

- Bob picks 0, a = []

Final c = [0,1], MEX = 2.

Same MEX.

Another scenario:

- Alice picks 1, c = [1], a = [0,0,1]

- Bob picks 1, a = [0,0]

- Alice picks 0, c = [1,0], a = [0]

- Bob picks 0, a = []

Again, c = [1,0], MEX = 2.

Seems consistent.

Second test case:

n = 4

a = [0,1,2,3]

Possible moves:

- Alice picks 0, c = [0], a = [1,2,3]

- Bob picks 1, a = [2,3]

- Alice picks 2, c = [0,2], a = [3]

- Bob picks 3, a = []

Final c = [0,2], MEX = 1.

Alternative:

- Alice picks 1, c = [1], a = [0,2,3]

- Bob picks 0, a = [2,3]

- Alice picks 2, c = [1,2], a = [3]

- Bob picks 3, a = []

c = [1,2], MEX = 0.

Wait, but according to the output, it's 1. So perhaps the first scenario is not optimal.

Wait, the output is 1, but in my alternative move, c = [1,2], MEX = 0.

So perhaps Alice can force a higher MEX.

Let's try:

- Alice picks 0, c = [0], a = [1,2,3]

- Bob picks 1, a = [2,3]

- Alice picks 2, c = [0,2], a = [3]

- Bob picks 3, a = []

c = [0,2], MEX = 1.

Alternatively:

- Alice picks 0, c = [0], a = [1,2,3]

- Bob picks 3, a = [1,2]

- Alice picks 1, c = [0,1], a = [2]

- Bob picks 2, a = []

c = [0,1], MEX = 2.

Wait, but the output is 1, so perhaps Bob can prevent this.

Maybe Bob has a better strategy.

Alternatively, perhaps the MEX is indeed 1.

Wait, I'm getting confused.

Looking at the output, it's 1 for the second test case.

So, perhaps in the second test case, the optimal MEX is 1.

Third test case:

n = 2

a = [1,1]

Possible moves:

- Alice picks 1, c = [1], a = [1]

- Bob picks 1, a = []

Final c = [1], MEX = 0.

Alternative:

- Alice picks 1, c = [1], a = [1]

- Bob picks 1, a = []

Same c = [1], MEX = 0.

So, MEX is 0.

Now, looking back at the provided code, let's see if it produces these outputs.

First test case:

a = [0,0,1,1]

mpp = {0:2, 1:2}

Iterate from 0 to 4:

i=0: mpp[0]=2 → in mpp, continue.

i=1: mpp[1]=2 → in mpp, continue.

i=2: not in mpp → print 2.

Correct, matches the output.

Second test case:

a = [0,1,2,3]

mpp = {0:1,1:1,2:1,3:1}

Iterate from 0 to 4:

i=0: mpp[0]=1 → set first=True, continue.

i=1: mpp[1]=1 and first=True → print 1.

Correct, matches the output.

Third test case:

a = [1,1]

mpp = {1:2}

Iterate from 0 to 2:

i=0: not in mpp → print 0.

Correct, matches the output.

So, at least for these test cases, the code seems to work.

But is this logic generally correct?

Let me try to generalize.

The idea seems to be:

- For each number i from 0 to n:

- If i is not in mpp, it's missing, so MEX is i.

- Else, if mpp[i] == 1 and some condition, then MEX is i.

Wait, the code has:

for i in range(n + 1):

if i not in mpp.keys():

print(i)

break

if mpp[i] == 1 and first:

print(i)

break

if mpp[i] == 1:

first = True

So, it's checking for each i:

1. If i is missing, return i.

2. Else, if i appears only once and it's the second such i, return i.

Wait, that doesn't seem right.

Wait, "if mpp[i] == 1 and first: print(i); break" and "if mpp[i] == 1: first = True"

So, first tracks if there's at least one i with mpp[i] == 1.

Then, if there's another i with mpp[i] == 1, it prints that i.

Is this capturing the optimal MEX correctly?

Let me think about the game mechanics again.

Alice wants to maximize MEX, which means she wants to include as many low numbers in c as possible.

Bob wants to minimize MEX, meaning he wants to prevent Alice from including certain numbers.

Given that Alice picks and adds to c, and Bob just removes.

The total number of times a number i appears determines how many times it can end up in c.

Since Alice goes first and they alternate, in an array of size n, Alice can choose floor((n+1)/2) elements to add to c.

Bob can remove floor(n/2) elements.

So, for each number i, the number of times it can end up in c depends on its frequency and the order of picks.

Wait, perhaps I need to think in terms of the frequency of each number.

For a number i to be in c, Alice needs to pick it and add it to c before Bob can remove it.

But Bob can remove it without adding to c.

Wait, Bob just removes an element without adding to c.

So, for a number i to be in c, Alice needs to pick it and add it to c, before Bob removes all its occurrences.

Given that, if a number i appears only once, Alice can choose to pick it and add it to c, or Bob can pick it and remove it.

If i appears twice, Alice can ensure one instance ends up in c, unless Bob removes both.

Wait, let's formalize this.

Let’s consider the frequency of each number.

For each number i:

- If frequency is 0, it's missing, so MEX could be i.

- If frequency is 1, Alice can choose to pick it and add to c, or Bob can pick it and remove it.

- If frequency is 2, Alice can ensure at least one ends up in c, because she can pick one and add to c, and even if Bob removes the other, she still has one in c.

- If frequency is 3, Alice can ensure at least one or two, depending on Bob's actions.

Wait, perhaps I need to think in terms of parity.

Given that Alice and Bob alternate turns, and Alice starts, the player who has the turn when the last element is picked can decide what to do.

Wait, maybe it's better to think in terms of who has the majority of picks.

But perhaps a better approach is to consider that Alice can select floor((frequency+1)/2) instances of a number to add to c, because she goes first.

Wait, let's think about it.

For a number i with frequency f:

- If f is 0: i is missing, MEX is i.

- If f is 1: Alice can choose to pick it and add to c, or Bob can pick it and remove it.

- If f is 2: Alice can pick one and add to c, Bob can pick the other and remove it.

- If f is 3: Alice can pick two and add to c, Bob can pick one and remove it.

Wait, perhaps it's that for each number i, the number of times it ends up in c is ceil(f / 2).

Because Alice goes first, and she can choose to pick the elements she wants.

Wait, perhaps not exactly ceil(f / 2), but close.

Wait, let's take an example.

Take i with f=3.

- Total picks: 3.

- Alice picks first: picks i and adds to c.

- Bob picks next: picks i and removes it.

- Alice picks again: picks i and adds to c.

So, in c, there are two i's.

But MEX is about the presence of the number, not the count.

So, as long as at least one i is in c, it's considered present.

So, for i to be in c, Alice needs to add it at least once.

Given that, for f >=1, Alice can ensure that at least ceil(f / 2) instances are in c.

But since we only care about presence, not multiplicity, as long as f >=1 and ceil(f / 2) >=1, which is always true for f >=1, i can be in c.

Wait, but Bob can try to prevent Alice from adding i to c.

Wait, no, if f >=1, Alice can choose to pick i and add it to c, unless Bob picks it first.

But Alice goes first, so she can prioritize picking the i she needs.

Wait, perhaps I need to think differently.

Let’s consider that for each number i from 0 to n:

- If i is not in a, MEX is i.

- Else, if i is in a, Alice can try to include it in c.

- Bob can try to prevent Alice from including i in c by removing it from a.

Given that Alice goes first, and both play optimally, we need to see which i Alice can ensure are in c.

Wait, perhaps it's about the parity of the frequency.

If f_i is odd, Alice can ensure that at least one i is in c.

If f_i is even, Bob can ensure that no i is in c.

Wait, let's think.

For f_i = 1:

- Alice picks it and adds to c.

- Bob can't do anything to prevent it.

- So, i is in c.

For f_i = 2:

- Alice picks one, adds to c.

- Bob picks the other and removes it.

- So, i is in c once.

Wait, but Bob can't add to c, he can only remove.

Wait, so c will have one i.

Wait, no, Bob removes it from a, but Alice has already added it to c.

Wait, no, Bob can only remove from a, not from c.

Wait, re-reading the problem:

"On Alice's turn, she picks one element from a, appends that element to c, and then deletes it from a.

On Bob's turn, he picks one element from a, and then deletes it from a.

So, Bob cannot add to c, only Alice can.

So, for f_i = 2:

- Alice picks one i, adds to c, removes from a. Now a has one i left.

- Bob picks the remaining i and removes it from a.

So, c has one i.

Hence, i is in c.

For f_i = 1:

- Alice picks i, adds to c, removes from a.

- Bob does nothing (if n is even).

Or, if n is odd, Bob picks another element, but i is already in c.

So, i is in c.

For f_i = 3:

- Alice picks i, adds to c, removes from a. Now a has two i's.

- Bob picks an i, removes it from a. Now a has one i left.

- Alice picks the remaining i, adds to c, removes from a.

So, c has two i's.

But since we only care if i is in c, it is.

For f_i = 4:

- Alice picks i, adds to c, removes from a. Now a has three i's.

- Bob picks an i, removes it from a. Now a has two i's.

- Alice picks an i, adds to c, removes it from a. Now a has one i left.

- Bob picks the remaining i, removes it from a.

So, c has two i's.

Again, i is in c.

Wait, in all these cases where f_i >=1, i ends up in c.

So, does that mean that for any i with f_i >=1, Alice can ensure that i is in c?

Wait, but in the second test case, with a = [0,1,2,3], the output is 1, meaning MEX is 1, implying that 0 is in c, but 1 is not.

Wait, but according to this logic, since f_1 =1, Alice should be able to include 1 in c.

But the output says MEX is 1, meaning 1 is not in c.

So, there's a contradiction.

Wait, perhaps I'm misunderstanding.

Let me look back at the second test case.

n=4

a=[0,1,2,3]

According to the output, MEX=1.

Which implies that c contains 0 but not 1.

But according to my earlier logic, since f_1=1, Alice should be able to include 1 in c.

So, what's happening here?

Maybe I need to consider that both players are playing optimally, considering the MEX.

Bob wants to minimize the MEX, so he wants to prevent Alice from including certain numbers in c.

In the second test case, perhaps Bob can prevent Alice from including 1 in c.

Let's simulate:

- Alice picks 0, adds to c, a=[1,2,3]

- Bob picks 1, removes from a, a=[2,3]

- Alice picks 2, adds to c, a=[3]

- Bob picks 3, removes from a, a=[]

Final c=[0,2], MEX=1.

Alternative:

- Alice picks 1, adds to c, a=[0,2,3]

- Bob picks 0, removes from a, a=[2,3]

- Alice picks 2, adds to c, a=[3]

- Bob picks 3, removes from a, a=[]

Final c=[1,2], MEX=0.

But the output is 1, so perhaps in this case, Bob can force a higher MEX by choosing different elements.

Wait, maybe Bob can pick in a way to force a higher MEX.

Wait, but according to the output, it's 1.

So, perhaps in optimal play, c=[0,2], MEX=1.

But according to my earlier logic, Alice can still include 1 in c.

Wait, maybe I need to think differently.

Perhaps the MEX is determined by which numbers Alice can include in c, considering Bob's interference.

Given that, perhaps the MEX is the smallest number that Alice cannot ensure is in c.

So, in the second test case, Alice cannot ensure that 1 is in c, because Bob can choose to remove it.

Wait, but in the first scenario above, Alice can pick 1 and add it to c.

But Bob can choose to remove 1 in his turn.

Wait, no, Bob can only remove an element, not from c, only from a.

Once Alice adds to c, it stays in c.

So, if Alice picks 1 and adds it to c, it remains in c regardless of Bob's actions.

So, in that case, c would have 1.

But according to the output, MEX is 1, which suggests that c does not have 1.

So, perhaps there's a misunderstanding in the problem statement.

Wait, perhaps I'm misinterpreting the output.

Wait, in the second test case, output is 1, which means that c has 0 but not 1.

But according to my earlier reasoning, Alice can always include 1 in c.

So, perhaps my reasoning is flawed.

Let me think again.

Maybe the MEX is determined by the final c, but Bob can influence which elements are in c by removing them from a before Alice can pick them.

In the second test case:

- Alice picks 0, adds to c, a=[1,2,3]

- Bob picks 1, removes from a, a=[2,3]

- Alice picks 2, adds to c, a=[3]

- Bob picks 3, removes from a, a=[]

Final c=[0,2], MEX=1.

In this sequence, 1 was removed by Bob before Alice could pick it.

So, Bob prevented 1 from being in c.

Alice could have picked 1 if she picked it before Bob removed it.

So, in optimal play, Bob can prevent 1 from being in c.

Hence, MEX is 1.

Alternatively, if Alice picks 1 first:

- Alice picks 1, adds to c, a=[0,2,3]

- Bob picks 0, removes from a, a=[2,3]

- Alice picks 2, adds to c, a=[3]

- Bob picks 3, removes from a, a=[]

Final c=[1,2], MEX=0.

So, if Alice picks 1 first, MEX is 0.

But the output is 1, which suggests that in optimal play, Bob can force MEX to be 1.

Wait, but in this scenario, if Alice picks 1 first, MEX is 0.

So, perhaps Bob can force MEX to be 1 by removing 1.

Wait, but in the first scenario, where Alice picks 0 first, Bob can remove 1, forcing MEX to be 1.

Alice, being optimal, would choose the path where MEX is minimized for Bob.

Wait, no, Alice wants to maximize MEX, but in this case, picking 0 first allows Bob to remove 1, resulting in MEX=1.

While picking 1 first results in MEX=0.

So, Bob, wanting to minimize MEX, would prefer MEX=1 over MEX=0.

Wait, no, Bob wants to minimize MEX, so he would prefer MEX=0, but in this case, by removing 1, he gets MEX=1.

Wait, I'm getting confused.

Let me clarify:

- Alice wants to maximize MEX.

- Bob wants to minimize MEX.

In the second test case:

- If Alice picks 0 first, Bob can pick 1, leading to c=[0,2], MEX=1.

- If Alice picks 1 first, c=[1,2], MEX=0.

So, Alice can choose to pick 1 first, resulting in MEX=0, which is worse for her (since she wants to maximize MEX).

Wait, no, MEX=0 is worse than MEX=1.

Wait, no, MEX=0 is better for Bob, but Alice wants to maximize MEX.

So, Alice would prefer MEX=1 over MEX=0.

Hence, in optimal play, Alice will pick 0 first, allowing Bob to pick 1, resulting in MEX=1.

Hence, the output is 1.

So, in this case, Alice chooses a suboptimal move for herself, but it's because Bob can force MEX=1.

Wait, no, Alice wants to maximize MEX, so she would choose the move that leads to the highest possible MEX.

In this case, picking 0 first leads to MEX=1, while picking 1 first leads to MEX=0.

So, Alice prefers picking 0 first, resulting in MEX=1.

Hence, the optimal MEX is 1.

So, in this scenario, Alice cannot ensure that 1 is in c, because Bob can remove it.

Hence, the MEX is 1.

Now, going back to the provided code:

It seems to be checking for each i from 0 to n:

- If i is not in mpp, print i.

- Else, if mpp[i] == 1 and some condition, print i.

But in the second test case, i=1 has mpp[i]=1, and it's being printed as MEX=1.

So, perhaps the logic is that if i is present only once, and some condition is met, then MEX is i.

But I need to formalize this.

Perhaps the rule is:

- For each i from 0 to n:

- If i is not present in a, then MEX is i.

- Else, if i is present only once, and there is at least one other number present only once, then MEX is i.

Wait, that seems to match the code.

In the code:

- `first` is set to True when the first i with mpp[i]==1 is found.

- Then, if another i with mpp[i]==1 is found, it prints that i.

Wait, but in the second test case, mpp={0:1,1:1,2:1,3:1}, so it should print 1, which matches the output.

But is this logic general?

Let me consider another test case.

Suppose n=3

a=[0,1,1]

mpp={0:1,1:2}

Iterate from 0 to 3:

i=0: mpp[0]=1 → set first=True, continue.

i=1: mpp[1]=2 → in mpp, continue.

i=2: not in mpp → print 2.

But according to the game:

- Alice picks 0, adds to c, a=[1,1]

- Bob picks 1, removes from a, a=[1]

- Alice picks 1, adds to c, a=[]

Final c=[0,1], MEX=2.

Which matches the code's output.

Another test case:

n=5

a=[0,1,2,3,4]

mpp={0:1,1:1,2:1,3:1,4:1}

Iterate from 0 to 5:

i=0: mpp[0]=1 → set first=True, continue.

i=1: mpp[1]=1 and first=True → print 1.

But according to the game:

- Alice picks 0, adds to c, a=[1,2,3,4]

- Bob picks 1, removes from a, a=[2,3,4]

- Alice picks 2, adds to c, a=[3,4]

- Bob picks 3, removes from a, a=[4]

- Alice picks 4, adds to c, a=[]

Final c=[0,2,4], MEX=1.

So, MEX=1, which matches the code's output.

Another test case:

n=3

a=[0,0,1]

mpp={0:2,1:1}

Iterate from 0 to 3:

i=0: mpp[0]=2 → in mpp, continue.

i=1: mpp[1]=1 → set first=True, continue.

i=2: not in mpp → print 2.

According to the game:

- Alice picks 0, adds to c, a=[0,1]

- Bob picks 0, removes from a, a=[1]

- Alice picks 1, adds to c, a=[]

Final c=[0,1], MEX=2.

Which matches the code's output.

Seems consistent.

So, perhaps the logic is:

- For each i from 0 to n:

- If i is not in a, then MEX is i.

- Else, if i is present only once, and there is at least one other number present only once, then MEX is i.

But why?

Wait, perhaps it's because for numbers present more than once, Alice can ensure they are in c, while for numbers present once, Bob can prevent them from being in c by removing them.

Wait, in the second test case, i=1 is present once, but Bob can remove it, leading to MEX=1.

Hence, if a number is present only once, Bob can choose to remove it, preventing it from being in c.

If a number is present twice or more, Alice can ensure at least one is in c.

Hence, the MEX is the smallest i such that either:

- i is not present in a, or

- i is present only once, and there is at least one other number present only once.

Wait, but in the second test case, i=1 is present only once, and there are other numbers present only once, so MEX=1.

In the first test case, i=2 is not present, so MEX=2.

In the third test case, i=0 is present twice, so Alice can ensure it's in c.

i=1 is present twice, so Alice can ensure it's in c.

Hence, MEX=2.

Wait, no, in the third test case, n=2, a=[1,1], mpp={1:2}, so i=0 is not present, so MEX=0.

Wait, but according to the earlier simulation, c=[1], MEX=0.

So, matches.

Hence, perhaps the rule is:

- For each i from 0 to n:

- If i is not present in a, MEX is i.

- Else, if i is present only once, and there is at least one other number present only once, MEX is i.

But in the second test case, i=1 is present only once, and there are other numbers present only once, so MEX=1.

In the first test case, i=2 is not present, so MEX=2.

In the third test case, i=0 is not present, so MEX=0.

Seems consistent.

Hence, the provided code seems to implement this logic correctly.

Therefore, the program is correct.

**Final Answer**

\[ \boxed{\text{True}} \]