Alright, I have this problem to solve. Monocarp wants to throw a party and invite some of his friends, but there are specific conditions about who comes to the party based on who gets invited. Let's break this down.

First, Monocarp has n friends, and each friend has a best friend, denoted by p_i, where p_i is the index of their best friend. The problem says that all p_i are distinct and p_i ≠ i, meaning no one is their own best friend, and everyone has a unique best friend.

The goal is to send invitations to some friends such that at least two friends come to the party. A friend comes to the party only if both they and their best friend receive an invitation.

I need to find the minimum number of invitations required to ensure that at least two friends come to the party.

Let's look at the example provided:

Input:

3

5

3 1 2 5 4

4

2 3 4 1

2

2 1

Output:

2

3

2

In the first test case, n=5 and p=[3,1,2,5,4]. Monocarp sends invitations to friends 4 and 5, and both come because each other is their best friend.

In the second test case, n=4 and p=[2,3,4,1]. Sending invitations to friends 1,2, and 3 results in friends 1 and 2 coming to the party.

In the third test case, n=2 and p=[2,1]. Inviting both friends results in both coming.

From these examples, it seems like the minimum number of invitations needed is either 2 or 3, depending on the configuration of best friends.

I need to generalize this.

First, observe that if two friends are best friends of each other, i.e., p_i = j and p_j = i, then inviting both i and j would make both come to the party. In this case, the number of invitations is 2, and at least two friends come.

In the first test case, friends 4 and 5 are best friends of each other (p_4=5 and p_5=4), so inviting both makes both come.

Similarly, in the third test case, friends 1 and 2 are best friends of each other (p_1=2 and p_2=1), so inviting both makes both come.

In the second test case, n=4, p=[2,3,4,1]. Here, friend 1's best friend is 2, friend 2's best friend is 3, friend 3's best friend is 4, and friend 4's best friend is 1. This forms a cycle: 1 -> 2 -> 3 -> 4 -> 1.

In this cycle, if we invite any two consecutive friends, say 1 and 2, friend 1 will come because both 1 and 2 are invited, but friend 2 will not come because their best friend 3 is not invited. So, only friend 1 comes.

If we invite three consecutive friends, say 1, 2, and 3, then friend 1 and friend 2 will come because both they and their best friends are invited. Friend 3 will not come because their best friend 4 is not invited.

Hence, in this case, inviting three friends results in two coming, which satisfies the condition.

So, in cycles of length 4, inviting three friends is sufficient to have at least two come.

Similarly, in a cycle of length 2 (mutual best friends), inviting two is sufficient.

What about larger cycles? For example, if n=6 with p=[2,3,4,5,6,1], a single cycle of length 6.

If we invite any three consecutive friends, say 1,2,3, then friend 1 and friend 2 will come, since both and their best friends are invited. Friend 3 will not come because friend 4 is not invited.

So, inviting three results in two coming.

If we invite four friends, say 1,2,3,4, then friend 1, friend 2, and friend 3 will come, since both they and their best friends are invited. Friend 4 will not come because friend 5 is not invited.

So, inviting four results in three coming.

But we only need at least two to come, so inviting three is sufficient.

Is there a way to have at least two come by inviting fewer than three?

Let's try inviting two friends in a cycle of length 6.

Suppose we invite friends 1 and 2.

Friend 1 will come if friend 2 is invited, which is true.

Friend 2 will come if friend 3 is invited, which is not the case.

So, only friend 1 comes.

Not sufficient.

Invite friends 1 and 3.

Friend 1 will come if friend 2 is invited, which is not the case.

Friend 3 will come if friend 4 is invited, which is not the case.

So, no one comes.

Not sufficient.

Invite friends 1,3,5.

Friend 1 will come if friend 2 is invited, which is not the case.

Friend 3 will come if friend 4 is invited, which is not the case.

Friend 5 will come if friend 6 is invited, which is not the case.

No one comes.

Not sufficient.

So, in cycles longer than 2, inviting two is not sufficient; we need to invite at least three to have at least two come.

Wait, in cycles of length 2, inviting two is sufficient.

In cycles of length 4, inviting three is sufficient.

In cycles of length 6, inviting three is sufficient.

Seems like for cycles of length >=3, inviting three is sufficient.

But let's confirm for length 3.

Suppose n=3, p=[2,3,1].

Invite friends 1,2,3.

Friend 1 will come if friend 2 is invited, which is true.

Friend 2 will come if friend 3 is invited, which is true.

Friend 3 will come if friend 1 is invited, which is true.

So, all three come.

But we only need at least two to come, so inviting three is sufficient.

Is there a way to have at least two come by inviting fewer than three?

Invite friends 1 and 2.

Friend 1 will come if friend 2 is invited, which is true.

Friend 2 will come if friend 3 is invited, which is not the case.

So, only friend 1 comes.

Not sufficient.

Invite friends 1 and 3.

Friend 1 will come if friend 2 is invited, which is not the case.

Friend 3 will come if friend 1 is invited, which is true.

But friend 3's best friend is friend 1, who is invited, so friend 3 comes.

Friend 1 does not come because friend 2 is not invited.

So, only friend 3 comes.

Not sufficient.

Hence, in cycles of length 3, inviting three is necessary to have at least two come.

Similarly, in cycles of length 4, inviting three is sufficient.

In cycles of length 2, inviting two is sufficient.

So, in general, for a single cycle:

- If the cycle length is 2, inviting two is sufficient.

- If the cycle length is >=3, inviting three is sufficient.

Given that p_i are distinct and p_i ≠ i, the graph formed by friends and their best friends is a collection of disjoint cycles, since each friend points to exactly one other friend, and there are no self-loops.

Given that p_i are distinct, it means that no two friends point to the same best friend, which implies that the graph is a collection of disjoint cycles, where each cycle is of length at least 2.

Wait, actually, if p_i are distinct and p_i ≠ i, it means that the graph is a collection of disjoint cycles, each of length >=2.

So, in the general case, the friends are organized into disjoint cycles.

To minimize the number of invitations, we need to select a subset of friends to invite such that at least two friends come to the party, and the number of invitations is minimized.

From the earlier analysis, in a cycle of length 2, inviting two is sufficient.

In cycles of length >=3, inviting three is sufficient.

So, in the general case, the minimal number of invitations needed is:

- If there exists a cycle of length 2, then 2 invitations are sufficient.

- Otherwise, 3 invitations are sufficient.

Wait, but in the second test case, n=4, p=[2,3,4,1], which is a single cycle of length 4, and the minimal number of invitations is 3.

In the first test case, there are two cycles: 1-3 (length 2) and 2-5-4 (length 3). By inviting two from the length 2 cycle, we achieve the goal with 2 invitations.

In the third test case, a single cycle of length 2, inviting two is sufficient.

Hence, if there is at least one cycle of length 2, then 2 invitations are sufficient.

If all cycles have length >=3, then 3 invitations are sufficient.

So, the minimal number of invitations is:

- 2, if there is at least one cycle of length 2.

- 3, otherwise.

Looking back at the code provided:

def func():

for _ in range(int(input())):

n = int(input())

l = list(map(int, input().split()))

i = 0

j = 0

while i <= n - 1:

p = l[i]

q = l[p - 1]

if q == i + 1:

print(2)

j = 1

break

i += 1

if j == 0:

print(3)

It seems to be checking for cycles of length 2.

It iterates through each friend, checks if p_p_i == i, meaning that i and p_i form a cycle of length 2.

If such a pair is found, it prints 2.

If no such pair is found, it prints 3.

This aligns with the reasoning above.

Hence, the given program is correct.

**Final Answer**

\[\boxed{2}\]