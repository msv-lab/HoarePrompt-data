Alright, I have this problem to solve. Let's see what it's asking for. So, Alex has n constraints on an integer k, and there are three types of constraints:

1. k must be greater than or equal to some integer x.

2. k must be less than or equal to some integer x.

3. k must be not equal to some integer x.

And I need to find out how many integers k satisfy all these n constraints. Also, it's guaranteed that there's at least one constraint of type 1 and one of type 2, which ensures that the range of k is finite. Also, no two constraints are the same, meaning all (a, x) pairs are distinct.

First, I need to understand the input and output format. The input consists of multiple test cases. The first line has an integer t, representing the number of test cases. For each test case, the first line is n, the number of constraints, followed by n lines each containing a pair of integers a and x, where a is the type of constraint and x is the value.

My task is to process each test case and output the number of integers k that satisfy all the constraints for that test case.

Let me think about how to approach this.

I need to find the number of integers k that satisfy all the given constraints. Given that there are constraints of types 1, 2, and 3, I need a way to combine these constraints effectively.

First, constraints of type 1: k >= x. If there are multiple such constraints, k must be greater than or equal to the maximum of all these x values because k needs to satisfy all constraints simultaneously.

Similarly, for constraints of type 2: k <= x. Here, k must be less than or equal to the minimum of all these x values.

So, effectively, the possible values of k lie within a range [bx, ax], where bx is the maximum of all x from type 1 constraints, and ax is the minimum of all x from type 2 constraints.

But, there are also constraints of type 3: k != x. These are the values that k cannot take.

So, the total number of possible k values would be the number of integers in the range [bx, ax], excluding the values specified in the type 3 constraints.

Wait, but I need to make sure that bx <= ax; otherwise, there are no possible k values.

So, first, I need to determine bx and ax.

Initialize bx to negative infinity and ax to positive infinity.

Then, for each constraint:

- If a == 1, bx = max(bx, x)

- If a == 2, ax = min(ax, x)

- If a == 3, add x to a set of forbidden values

Then, if bx > ax, there are no possible k values.

Else, the number of possible k values is the number of integers from bx to ax, inclusive, minus the number of forbidden values within that range.

I need to be careful with the forbidden values because it's possible that some forbidden values are outside the range [bx, ax], but I only need to consider those that are within the range.

Also, since ax and bx are derived from constraints of type 1 and 2, and it's guaranteed that there's at least one of each, and that the range is finite, I don't need to worry about infinite ranges.

Additionally, it's guaranteed that no two constraints are the same, so all (a, x) pairs are unique.

Let me think about the example provided:

Input:

6

4

1 3

2 10

3 1

3 5

Output:

7

Explanation:

k >= 3, k <= 10, k != 1, k != 5

So, bx = max(3) = 3

ax = min(10) = 10

Forbidden values: 1,5

But 1 is less than bx, so only 5 is within the range.

So, number of k from 3 to 10 is 8 (3,4,5,6,7,8,9,10)

Minus the forbidden value 5, so 7.

Another example:

2

1 5

2 4

Output:

0

Explanation:

k >= 5 and k <= 4, which is impossible, so 0.

Another example:

10

3 6

3 7

1 2

1 7

3 100

3 44

2 100

2 98

1 3

3 99

Output:

90

Let's see:

Type 1 constraints: k >= max(2,7,3) = 7

Type 2 constraints: k <= min(100,98) = 98

Forbidden values: 6,7,100,44,99

So, k from 7 to 98, inclusive.

Total numbers: 98 - 7 + 1 = 92

Forbidden values within the range: 7,44,99 (but 99 is greater than 98, so only 7 and 44)

So, 92 - 2 = 90.

Wait, but in the constraints, 7 is both a type 1 constraint and a forbidden value.

But since k >=7 and k !=7, then k >7.

Wait, but in the code, it's handling it by excluding forbidden values within the range.

So, in this case, k from 7 to 98, but k !=7 and k!=44.

So, 92 - 2 = 90.

Okay, that makes sense.

Now, looking at the provided program:

def func():

t = int(input())

r = []

for _ in range(t):

n = int(input())

cx = set()

ax = int(1000000000.0 + 7)

bx = -1

for _ in range(n):

(a, x) = map(int, input().split())

if a == 1:

bx = max(x, bx)

elif a == 2:

ax = min(x, ax)

else:

cx.add(x)

if bx > ax:

r.append(0)

else:

tmp = 0

for i in cx:

if i >= bx and i <= ax:

tmp += 1

r.append(ax - bx + 1 - tmp)

print(*r, sep='\n')

So, it's reading t test cases, then for each test case, reading n constraints.

It initializes a set cx for forbidden values.

It initializes ax to a large number (1000000007) and bx to -1.

Then, for each constraint:

- If a ==1, bx = max(x, bx)

- If a ==2, ax = min(x, ax)

- If a ==3, add x to cx

Then, if bx > ax, impossible, so append 0 to r.

Else, count the number of forbidden values within the range [bx, ax], and subtract that from the total numbers in the range.

Finally, print all results in r, one per line.

Seems correct.

But let me check for potential issues.

First, ax is initialized to a large number, which is fine.

bx is initialized to -1, which is also fine if all type1 constraints have x >=0.

But since x can be any integer from 1 to 10^9, and a ==1 means k >=x, so bx should be the maximum of all such x.

Similarly, ax is the minimum of all x where a ==2.

Then, the range is from bx to ax inclusive.

Forbidden values are those x where a ==3, and they are stored in a set.

Then, for each test case, if bx > ax, impossible, else, calculate the number of k values as ax - bx +1 minus the number of forbidden values within that range.

Seems correct.

But, is there any edge case that might fail?

Let's think about it.

Edge Case 1: bx == ax

In this case, only one possible k value, which is bx == ax.

If this k value is in the forbidden set, then the count should be 0; else, 1.

The code should handle this correctly.

Edge Case 2: Forbidden values outside the range [bx, ax]

The code only counts forbidden values that are within the range [bx, ax], which is correct because k cannot be outside that range.

Edge Case 3: Multiple forbidden values within the range

The code iterates through cx and counts how many are within [bx, ax], which is correct.

Edge Case 4: bx == ax and k == bx == ax, and it's forbidden.

Then, the count should be 0, which the code correctly handles.

Edge Case 5: All forbidden values are outside the range.

Then, the count should be ax - bx +1.

Edge Case 6: No forbidden values.

Then, the count is ax - bx +1.

Seems all covered.

Also, since n can be up to 100, and t up to 500, and operations are O(n) per test case, it should be efficient enough.

Also, using a set for cx ensures that forbidden values are unique, which is fine because duplicates aren't possible per problem statement.

So, I think the given program is correct.

**Final Answer**

\[ \boxed{\text{Yes}} \]

**Final Solution**

To solve this problem, we need to determine the number of integers \( k \) that satisfy a given set of constraints. These constraints include lower bounds, upper bounds, and exclusions on the value of \( k \). The solution involves processing these constraints to find the range of possible \( k \) values and then excluding the forbidden values within that range.

### Approach

1. **Processing Constraints:**
   - For constraints of type 1 (\( k \geq x \)), track the maximum \( x \) value, as \( k \) must be at least this maximum value.
   - For constraints of type 2 (\( k \leq x \)), track the minimum \( x \) value, as \( k \) must be at most this minimum value.
   - For constraints of type 3 (\( k \neq x \)), collect these \( x \) values in a set to exclude them from the possible \( k \) values.

2. **Determine the Range:**
   - Calculate the lower bound \( bx \) as the maximum of all type 1 constraints.
   - Calculate the upper bound \( ax \) as the minimum of all type 2 constraints.

3. **Check Feasibility:**
   - If \( bx > ax \), no \( k \) can satisfy all constraints, so the result is 0.

4. **Count Valid \( k \) Values:**
   - Calculate the total number of integers in the range [\( bx \), \( ax \)].
   - Subtract the number of forbidden values (type 3) that fall within this range.

### Solution Code

```python
def func():
    t = int(input())
    r = []
    for _ in range(t):
        n = int(input())
        cx = set()
        ax = int(1e9 + 7)  # Large number to initialize upper bound
        bx = -1           # Initialize lower bound
        for _ in range(n):
            a, x = map(int, input().split())
            if a == 1:
                bx = max(x, bx)
            elif a == 2:
                ax = min(x, ax)
            else:
                cx.add(x)
        if bx > ax:
            r.append(0)
        else:
            tmp = 0
            for i in cx:
                if i >= bx and i <= ax:
                    tmp += 1
            r.append(ax - bx + 1 - tmp)
    print(*r, sep='\n')

func()
```

### Explanation

- **Input Handling:**
  - Read the number of test cases \( t \).
  - For each test case, read the number of constraints \( n \).
  - Read each constraint and process it based on its type.

- **Constraint Processing:**
  - For type 1 constraints, update the lower bound \( bx \) to be the maximum of the provided \( x \) values.
  - For type 2 constraints, update the upper bound \( ax \) to be the minimum of the provided \( x \) values.
  - For type 3 constraints, collect the forbidden values in a set.

- **Feasibility Check:**
  - If the lower bound \( bx \) exceeds the upper bound \( ax \), no solution exists, and the result is 0.

- **Counting Valid \( k \) Values:**
  - Calculate the total possible \( k \) values in the range [\( bx \), \( ax \)].
  - Subtract the count of forbidden values that lie within this range to get the final count of valid \( k \) values.

This approach ensures that all constraints are considered efficiently, and the solution is computed correctly for each test case.