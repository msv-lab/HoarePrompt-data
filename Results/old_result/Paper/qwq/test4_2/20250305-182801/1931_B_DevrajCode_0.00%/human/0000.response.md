Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n containers of water lined up in a row, each containing a certain amount of water. The containers are numbered from 1 to n, left to right. I can pour water from one container to another, but only if the source container has a higher number than the destination container. In other words, I can only pour from a rightward container to a leftward one, but not the other way around. The goal is to make sure that all containers have the same amount of water in the end, and I need to determine whether this is possible given the operation constraints.

First things first, I need to understand the constraints and what exactly is allowed. Each operation consists of pouring any amount of water from container i to container j, where i < j. That means I can only pour water from a rightward container to a leftward one. I can perform this operation any number of times, including zero.

The problem also states that the sum of all a_i is divisible by n, which means that there is a target amount of water that each container should have, which is the total sum divided by n. Let's call this target amount "target". So, target = sum(a_i) / n.

My task is to check if it's possible to rearrange the water in the containers, using the allowed operations, so that each container ends up with exactly "target" amount of water.

Let me think about how the operations work. Since I can only pour from a higher-numbered container to a lower-numbered one, it's like the water can only move leftward, never rightward. So, once water is poured into a container from a rightward container, it can't be moved further left beyond that point.

This seems similar to problems where you have to distribute resources with certain movement constraints.

Let's consider a simple example to build some intuition.

Take the first test case:

n = 1

a = [43]

Since there's only one container, it already has the target amount, so "YES".

Second test case:

n = 2

a = [1, 3]

Target = (1 + 3) / 2 = 2

So, I need to make both containers have 2 units of water.

Starting with [1, 3], I can pour 1 unit from container 2 to container 1, resulting in [2, 2]. That works, so "YES". But according to the sample output, it's "NO". Wait, that's contradictory.

Wait, looking back at the sample output, for n=2 and a=[1,3], the output is "NO". So, in this case, it's not possible to make both containers have the same amount.

But in my earlier thought, I thought it was possible. Let me see where I went wrong.

Oh, wait, the operation is pouring from i to j where i < j. So, in this case, pouring from container 2 (i=2) to container 1 (j=1) is not allowed because i > j. So, I can't pour from a higher-numbered container to a lower-numbered one in that way.

Wait, no, the condition is i < j, meaning you pour from i to j, where i is less than j. So, pouring from container 1 to container 2 is allowed, but not from 2 to 1.

In the initial state, a1 = 1, a2 = 3.

If I pour from container 1 to container 2, that would increase a2 and decrease a1. So, a1 becomes less than 1, which is not helpful.

Wait, but a1 is already less than target, and a2 is greater than target. But since I can't pour from a2 to a1, I can't balance them. So, in this case, it's impossible, hence "NO".

Okay, that makes sense now.

So, the key point is that water can only move leftward from higher-numbered containers to lower-numbered ones, not the other way around.

So, in general, for a given array a, I need to check if it's possible to redistribute the water such that each container has the target amount, given this constraint.

Another way to think about it is to consider the cumulative sum from the right.

Let me consider the containers from right to left.

Starting from the rightmost container, it can only receive water from containers to its right, but there are none. So, it has to have exactly the target amount, otherwise, it's impossible to balance it since no water can be poured into it from the right.

Wait, but in the sample input, for n=5 and a=[4,5,2,1,3], the output is "YES", but according to my previous thought, the last container should have exactly target amount, which is sum(a)/5.

Wait, let's calculate sum(a) for that case: 4+5+2+1+3=15, target=15/5=3.

So, the last container has 3, which is equal to target. So, it's fine.

Moving to the second last container, which has 1. Since it's less than target, it needs to receive some water from the right. But there's no container to its right to receive from, so it has to have at least target amount, but it has only 1, which is less than 3. So, according to my previous thought, it should be "NO", but the sample output is "YES".

Hmm, so my earlier assumption is incorrect.

Wait, perhaps I need to think differently.

Let me look at the operation again: pour from i to j, where i < j.

So, pouring from a rightward container to a leftward one.

So, for each container, it can receive water from all containers to its right (higher indices).

So, for container k, the amount of water it has initially plus the water poured into it from containers k+1 to n should be at least the target.

But, since water can only be poured leftward, each container can only give water to those on its left.

So, starting from the rightmost container, it can only keep its own water or give some to the left.

Similarly, the second last container can receive from the last one and so on.

So, perhaps I need to iterate from right to left, keeping track of the surplus water that can be used by the leftward containers.

Let me try to formalize this.

Initialize a variable, say, "surplus" to 0.

Start from the rightmost container (index n-1).

If a[n-1] >= target, then the surplus that can be poured to the left is a[n-1] - target.

If a[n-1] < target, then it's impossible because this container can't receive water from the right.

Wait, but in the sample input with n=5 and a=[4,5,2,1,3], target=3.

Starting from the last container: a[4]=3, which is equal to target, so surplus=0.

Then, move to a[3]=1, which is less than target=3.

Since surplus=0, I need to check if I can pour some water from a[4] to a[3], but a[4] only has exactly target, so no surplus to give.

Hence, it's impossible to make a[3]=3, because it's already less than target and can't receive from the right.

But according to the sample output, it's "YES", so my reasoning must be wrong.

Wait, perhaps I need to consider cumulative surplus.

Let me try again.

Initialize surplus=0.

Start from the rightmost container:

a[4]=3, which is equal to target, so surplus=0.

Move to a[3]=1, which is less than target=3.

I need to make it 3, so I need 2 units of water.

But surplus=0, so I need to see if the containers to the right can provide this.

But there are no containers to the right of a[3], so it's impossible.

But the sample output is "YES", so clearly, my approach is incorrect.

Wait, perhaps I need to consider that containers to the right can provide surplus to containers on their left.

Let me think differently.

Suppose I calculate the cumulative surplus from right to left.

Initialize surplus=0.

For each container from n-1 to 0:

if a[i] + surplus >= target:

surplus += a[i] - target

else:

return "NO"

Wait, that might work.

Let's try it on the sample input.

n=5, a=[4,5,2,1,3], target=3.

Start from a[4]=3, surplus=0.

3 + 0 >= 3, so surplus += 3 - 3 = 0.

Move to a[3]=1, surplus=0.

1 + 0 < 3, so return "NO"

But the sample output is "YES", so this approach is wrong.

Wait, maybe I have the logic inverted.

Let me think about it differently.

If I can only pour from right to left, then each container can give water to the leftward containers, but once it's given, it's given.

So, starting from the right, each container can contribute its surplus to the leftward containers.

So, perhaps I should track the accumulated surplus from the right.

Let me try this:

Initialize surplus=0.

For each container from n-1 to 0:

if a[i] + surplus >= target:

surplus += a[i] - target

else:

return "NO"

Wait, that's similar to what I did earlier.

Let's apply it to the third test case:

n=5, a=[4,5,2,1,3], target=3.

Start from a[4]=3, surplus=0.

3 + 0 >= 3, so surplus += 3 - 3 = 0.

Move to a[3]=1, surplus=0.

1 + 0 < 3, so return "NO"

But the sample output is "YES", which contradicts this approach.

So, perhaps I need to adjust the logic.

Wait, maybe I need to consider that surplus can be carried over even if a[i] + surplus < target, by taking deficit into account.

Wait, perhaps I need to think in terms of deficits and surpluses.

For each container, if a[i] >= target, it has surplus a[i] - target, which can be used to fill deficits in previous containers.

If a[i] < target, it has a deficit of target - a[i], which needs to be filled from the surplus of future containers.

So, as I iterate from right to left, I need to make sure that the accumulated surplus is always greater than or equal to the deficit of the current container.

Let's try that.

Initialize surplus=0.

For each i from n-1 to 0:

if a[i] >= target:

surplus += a[i] - target

else:

deficit = target - a[i]

if surplus >= deficit:

surplus -= deficit

else:

return "NO"

At the end, return "YES"

Let's test this on the third test case:

n=5, a=[4,5,2,1,3], target=3.

Start from a[4]=3, which is equal to target.

surplus += 0.

Move to a[3]=1, which is less than target.

deficit = 3 - 1 = 2

surplus = 0 < 2, so return "NO"

But the sample output is "YES", so this approach is still incorrect.

Wait, maybe I need to accumulate surplus differently.

Wait, in the problem, pouring from i to j where i < j means pouring from a rightward container to a leftward one.

So, in reality, the surplus from a[right] can be used to fill the deficit of a[left], where left < right.

So, perhaps I need to iterate from left to right, keeping track of the cumulative deficit and seeing if the surplus from the right can cover it.

Wait, perhaps I need to iterate from right to left, accumulating the surplus, and ensuring that at each step, the surplus can cover the deficit.

Let me try that.

Initialize surplus=0.

For i from n-1 to 0:

if a[i] >= target:

surplus += a[i] - target

else:

deficit = target - a[i]

if surplus >= deficit:

surplus -= deficit

else:

return "NO"

At the end, return "YES"

Wait, that's the same as before, and it's giving "NO" for a case where the sample output is "YES".

Hmm.

Maybe I need to look at the operations more carefully.

In the third test case, a=[4,5,2,1,3], target=3.

As per the note, they perform:

1. Pour 1 unit from container 1 to 4: a becomes [3,5,2,2,3]

2. Pour 1 unit from container 2 to 3: a becomes [3,4,3,2,3]

3. Pour 1 unit from container 2 to 4: a becomes [3,3,3,3,3]

Wait, but according to the operation definition, pouring from i to j requires i < j.

Wait, in the first operation, pouring from container 1 to 4: i=1, j=4, which satisfies i < j.

Similarly, pouring from 2 to 3: i=2, j=3, which is allowed.

Then, pouring from 2 to 4: i=2, j=4, which is allowed.

So, in this sequence, they are pouring water from right to left, which is allowed.

But according to my earlier logic, it should have returned "NO", but the sample output is "YES".

So, perhaps my logic is incomplete.

Wait, maybe I need to consider that surplus from multiple containers can be used to fill deficits in leftward containers.

In other words, surplus from a[k] where k > i can be used to fill the deficit of a[i], but only if there is enough surplus accumulated from k > i.

Let me try to think of it in terms of prefix sums.

Let me calculate the prefix sums from the right.

Initialize surplus=0.

For i from n-1 to 0:

if a[i] >= target:

surplus += a[i] - target

else:

deficit = target - a[i]

if surplus >= deficit:

surplus -= deficit

else:

return "NO"

At the end, return "YES"

Wait, that's the same as before.

Let's apply it step by step to the third test case:

n=5, a=[4,5,2,1,3], target=3.

i=4, a[4]=3 >= 3, surplus += 0, surplus=0

i=3, a[3]=1 < 3, deficit=2, surplus=0 < 2, return "NO"

But sample output is "YES", so clearly, this logic is flawed.

Wait, maybe I need to accumulate surplus differently.

Wait, perhaps I need to consider that surplus from rightward containers can be distributed to any leftward containers, not just immediately to the left.

In other words, surplus from a[k] can be used to fill deficits in any a[i] where i < k.

In that case, perhaps I need to ensure that the cumulative surplus from all rightward containers is at least the cumulative deficit up to the current container.

Let me try to think in terms of cumulative sums.

Let me iterate from right to left, keeping track of the cumulative surplus.

Initialize surplus=0.

For i from n-1 to 0:

if a[i] >= target:

surplus += a[i] - target

else:

deficit = target - a[i]

if surplus >= deficit:

surplus -= deficit

else:

return "NO"

At the end, return "YES"

Wait, I think I need to adjust this.

Let me consider that surplus is the amount available to fill deficits in leftward containers.

So, as I move left, I accumulate surplus from rightward containers and use it to fill deficits.

In the third test case:

i=4, a[4]=3 >= 3, surplus += 0, surplus=0

i=3, a[3]=1 < 3, deficit=2

surplus=0 < 2, so return "NO"

But the sample output is "YES", which suggests that there is a way to make it work.

Perhaps I need to consider that surplus from containers further to the right can be used to fill deficits in containers further to the left, as long as the order of operations is maintained.

Wait, maybe I need to look at the problem differently.

Let me consider that the total sum is divisible by n, so the target is achievable, but I need to make sure that the surplus from the rightward containers is enough to cover the deficits of the leftward containers.

In other words, at any point, the cumulative surplus from the right should be at least the cumulative deficit from the left.

Wait, perhaps I need to iterate from left to right, keeping track of the cumulative deficit and ensuring that the surplus from the right can cover it.

But I'm getting confused.

Let me try to think about the operations allowed.

Each operation is pouring from a rightward container to a leftward one, meaning water can only move leftward.

So, for a container at position i, it can receive water from any container j where j > i.

Similarly, a container at position j can give water to any container i where i < j.

In the third test case, they poured from container 1 to 4, then from 2 to 3, and from 2 to 4.

Wait, container 1 is the leftmost, and container 4 is to its right.

So, pouring from 1 to 4 is allowed, but in the operations described in the note, they first pour from 1 to 4, then from 2 to 3, and from 2 to 4.

This seems like they are moving water from right to left in multiple steps.

Maybe I need to think in terms of multiple operations and how surplus can be propagated.

This is getting complicated.

Let me look at the provided program and see what it's doing.

The program is:

def func_1(n, a):

total_water = sum(a)

if total_water % n != 0:

return 'No'

target = total_water // n

container = 0

for water in a:

container += water - target

if container < 0:

return 'No'

return 'Yes'

Wait, but according to the problem statement, it's guaranteed that the sum of a_i is divisible by n, so the first check is unnecessary.

In the program, it initializes a variable "container" to 0.

Then, for each a[i] in the list, it adds a[i] - target to container.

If at any point container < 0, it returns 'No'.

Otherwise, it returns 'Yes'.

So, it's accumulating a[i] - target for each i, and checking if the cumulative sum ever goes negative.

I need to understand why this works.

Let's try applying this to the third test case:

n=5, a=[4,5,2,1,3], target=3.

Initialize container=0.

For i=0: container += 4 - 3 = 1 -> container=1

For i=1: container += 5 - 3 = 2 -> container=3

For i=2: container += 2 - 3 = -1 -> container=2

Wait, 3 + (2 - 3) = 2, not -1.

Wait, 3 + (-1) = 2.

Wait, but according to my calculation, 3 + (2 - 3) = 3 -1 = 2.

Is that correct? Yes.

For i=3: container += 1 - 3 = -2 -> container=0

Wait, 2 + (-2) = 0.

For i=4: container += 3 - 3 = 0 -> container=0

At no point is container < 0, so it returns 'Yes'.

Which matches the sample output.

Now, let's try the second test case:

n=2, a=[1,3], target=2.

Initialize container=0.

For i=0: container += 1 - 2 = -1 -> container=-1

Since container < 0, return 'No'

Which matches the sample output.

Another test case:

n=3, a=[1,2,3], target=2.

Initialize container=0.

For i=0: container += 1 - 2 = -1 -> container=-1

Since container < 0, return 'No'

Which matches the sample output.

So, it seems to work.

But why does this work?

Let's think about what "container" represents.

"container" is the cumulative sum of a[i] - target.

So, container = sum_{k=0 to i} (a[k] - target)

Which is equal to sum_{k=0 to i} a[k] - (i+1)*target

This represents the excess or deficit of water in the first (i+1) containers compared to the target.

If container < 0 at any point, it means that the sum of a[0 to i] is less than (i+1)*target.

In other words, the first (i+1) containers don't have enough water to each have the target amount.

Given the operation constraints, we can only pour water from rightward containers to leftward ones.

So, if at any point the cumulative sum of a[0 to i] is less than (i+1)*target, it means that even if we pour all possible water from the rightward containers to the leftward ones, we can't make up for this deficit.

Hence, it's impossible to balance all containers.

Therefore, the condition that container >= 0 at every step ensures that the cumulative water in the first i+1 containers is at least what's needed to make each of them have the target amount.

If this condition holds for all i, then it's possible to balance all containers.

Hence, the program is correct.

So, the answer is Correctness: **True**

**Final Solution**

To solve this problem, we need to determine if it is possible to make the amount of water in each of the containers the same by performing a specific pouring operation any number of times. The operation allows pouring water from a rightward container to a leftward one, provided the source container has a higher index than the destination container.

### Approach

1. **Calculate the Target Amount:**
   - First, we calculate the target amount of water each container should have, which is the total sum of water divided by the number of containers `n`. Since the sum is guaranteed to be divisible by `n`, the target will be an integer.

2. **Check Cumulative Deficit:**
   - We iterate through the containers from left to right, keeping a running total of the difference between the current container's water and the target.
   - If at any point this running total becomes negative, it means there isn't enough water in the preceding containers to reach the target, even if we pour water from the subsequent containers. Hence, it's impossible to balance the water levels, and we return "No".
   - If the running total never becomes negative, it means we can always make up the deficit by pouring water from right to left, and we return "Yes".

### Solution Code

```python
def func_1(n, a):
    total_water = sum(a)
    if total_water % n != 0:
        return 'No'
    target = total_water // n
    container = 0
    for water in a:
        container += water - target
        if container < 0:
            return 'No'
    return 'Yes'
```

### Explanation

- **Step-by-Step Execution:**
  1. **Calculate Target:**
     - Ensure the total sum of water is divisible by `n` to find the target amount each container should have.
  2. **Cumulative Check:**
     - Maintain a running sum (`container`) of the differences between each container's water and the target.
     - If this running sum ever goes negative, it indicates a deficit that cannot be overcome with the allowed operations, leading to an impossible balancing scenario.

- **Correctness:**
  - By iterating from left to right and ensuring the cumulative sum never drops below zero, we confirm that the water can be redistributed correctly using the allowed operations. This approach efficiently determines the possibility of balancing the containers in linear time.