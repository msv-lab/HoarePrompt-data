Alright, I have this problem to solve. Let's see what it's about. So, there's a game being played on a tree structure with n nodes. The tree has exactly two leaves, which makes it sort of like an array because in an array, the endpoints are like leaves in a tree. The game is played over t rounds, but in this specific version, t is always 1, so I only need to handle one round.

In each round, there's a stone placed on one node, and that node is activated. Players take turns moving the stone to an inactive neighbor, activating that neighbor in the process. Ron starts first, then Hermione, and they alternate until someone can't make a move. The player who can't make a move loses.

I need to determine, for a given starting node, who wins the game if both players play optimally.

First, I need to understand the structure of the tree. It's mentioned that the tree has exactly two leaves. So, in a tree, leaves are nodes with only one edge. Since it's specified that there are exactly two leaves, this means the tree is a straight path from one leaf to the other, with possible branches in between. But wait, in a tree with exactly two leaves, is it just a straight path without any branches? Because in a tree, leaves are endpoints, and if there are only two leaves, does that mean it's a linear structure?

Let me think about that. In a tree, if there are only two leaves, does that mean it's a simple path? Actually, no. Consider a Y-shaped tree: one central node connected to three leaves, but if I remove one of the leaves, I'd have a tree with two leaves. But according to the problem, the tree has exactly two leaves, and it's compared to an array, which suggests it's a linear structure. Maybe I need to confirm this.

Looking back at the problem, it says "it has exactly two leaves. It can thus be seen as an array." So, it's like a straight line of nodes, with two endpoints (leaves), and the rest have degree 2, similar to an array where elements are connected in a linear fashion.

So, the tree is essentially a straight path from one leaf to another, with no branches. That simplifies things because now I can think of it as a linear structure.

Now, the game is played by moving the stone along this path, activating nodes as we go, and the player who can't move loses.

I need to determine, for a given starting node, who wins if both players play optimally.

Given that it's a linear path, I can model this as a game of nim on a path, where the length of the path determines the game's outcome.

In such games, the concept of "xor" or "nim-sum" often comes into play, but perhaps there's a simpler way since the structure is linear and there are no branches.

Let me consider the distance from the starting node to each leaf.

If I can calculate the distance from the starting node to each leaf, perhaps I can determine the total number of moves possible.

Wait, in this game, each move activates a new node, and the game ends when there are no more inactive neighbors to move to.

So, the total number of moves possible is equal to the number of nodes minus one, since the starting node is already activated.

But, since players alternate moves, starting with Ron, if the total number of moves is odd, Ron makes the last move, and Hermione is left without a move, so Ron wins. If it's even, Hermione makes the last move, and Ron is left without a move, so Hermione wins.

Wait, is that correct? Let's think.

If there are k moves possible, and Ron makes the first move, then:

- If k is odd, Ron makes the last move, and Hermione has no move left, so Ron wins.

- If k is even, Hermione makes the last move, and Ron has no move left, so Hermione wins.

But, is the total number of moves equal to n - 1, where n is the number of nodes?

Wait, yes, because starting from one node, each move activates one new node, and there are n - 1 other nodes to activate.

So, total moves = n - 1.

Then, if n - 1 is odd, Ron wins; if even, Hermione wins.

Is that it? Seems too straightforward. But let's verify with the sample inputs.

Looking at the first sample input:

3 1

2 3

3 1

3

So, n=3, t=1, edges are 2-3 and 3-1, starting at node 3.

So, the tree looks like 1 - 3 - 2, which is a straight line with two leaves: 1 and 2.

Total nodes = 3, so total moves = 2 (n - 1 = 2), which is even, so Hermione should win.

But the output is "Ron". Hmm, that contradicts my earlier assumption.

Wait, maybe I have a mistake.

Wait, starting at node 3, which is between 1 and 2.

Ron moves first: he can move to either 1 or 2.

If he moves to 1, then Hermione can't move anymore, so Ron wins.

If he moves to 2, then Hermione can't move anymore, so again Ron wins.

Wait, in this case, Ron can always win by moving to one of the leaves, leaving Hermione with no moves.

But according to my earlier logic, with n - 1 = 2 moves, which is even, Hermione should win.

But in reality, Ron wins. So, my earlier assumption is incorrect.

Maybe I need to rethink this.

Perhaps the game isn't simply determined by the total number of moves, but by the structure of the tree and the distance from the starting node to the leaves.

Let me think differently.

In game theory, such games can be analyzed using the concept of "Nimbers" or "mex" for the game positions.

But perhaps there's a simpler way since the tree is a straight path.

Let me consider the distance from the starting node to each leaf.

In the first sample input, starting at node 3, distance to leaf 1 is 1, and to leaf 2 is 1.

In the second sample input:

5 1

1 2

2 3

3 4

4 5

Starting at node 5.

The tree is 1 - 2 - 3 - 4 - 5, with leaves at 1 and 5.

Distance from start (5) to leaf 1 is 4, to leaf 5 is 0 (since it's already at 5).

Output is "Hermione".

Wait, in the first sample, starting at 3, distances to leaves are 1 and 1.

In the second sample, starting at 5, distances to leaves are 4 and 0.

Maybe I need to consider the parity of these distances.

In the first sample, both distances are odd (1 is odd), so Ron wins.

In the second sample, distances are 4 (even) and 0 (even), so Hermione wins.

Wait, but in the first sample, both distances are odd, and Ron wins.

In the second sample, both distances are even, and Hermione wins.

Is there a pattern here?

Let me consider:

- If there exists at least one even distance from the starting node to a leaf, then Ron wins.

- Otherwise, if all distances are odd, Hermione wins.

Wait, but in the first sample, both distances are odd, and Ron wins. That contradicts my hypothesis.

Wait, perhaps it's the opposite:

- If all distances are odd, Ron wins.

- If there exists at least one even distance, Hermione wins.

Wait, but in the second sample, both distances are even, and Hermione wins.

Wait, maybe:

- If the minimum distance to a leaf is even, Hermione wins.

- If the minimum distance to a leaf is odd, Ron wins.

Wait, in the first sample, minimum distance to a leaf is 1 (odd), Ron wins.

In the second sample, minimum distance to a leaf is 0 (even), Hermione wins.

This seems consistent.

Let me test this hypothesis.

Suppose starting at node 3 in a tree 1-3-2:

- Distances to leaves: 1 and 1 (both odd), minimum is 1 (odd), so Ron wins.

In the second sample, starting at 5 in tree 1-2-3-4-5:

- Distances to leaves: 4 and 0 (both even), minimum is 0 (even), so Hermione wins.

Seems correct.

Is this always true?

Let me think of another example.

Suppose n=4, t=1

Edges:

1-2

2-3

3-4

Start at node 2.

Tree: 1 - 2 - 3 - 4, leaves are 1 and 4.

Distances from 2 to leaves: 1 (to 1) and 2 (to 4).

Minimum distance is 1 (odd), so Ron wins.

But let's simulate the game:

Start at 2.

Ron can move to 1 or 3.

- If Ron moves to 1, Hermione can't move, so Ron wins.

- If Ron moves to 3, Hermione can move to 4, then Ron can't move, so Hermione wins.

Wait, so depending on Ron's first move, he can choose to win or lose.

But according to my hypothesis, since the minimum distance is odd, Ron wins.

Which seems consistent with the first option.

But in reality, Ron can choose to move to 3, allowing Hermione to win.

But if he plays optimally, he would choose to move to 1, winning the game.

So, Ron can win if he plays optimally.

Hence, the hypothesis holds.

Another example:

n=4, t=1

Edges:

1-2

2-3

3-4

Start at node 3.

Distances to leaves: 1 (to 4) and 2 (to 1).

Minimum distance is 1 (odd), so Ron wins.

Indeed, if Ron moves to 4, Hermione can't move, so Ron wins.

If he moves to 2, Hermione moves to 1, Ron can't move, so Hermione wins.

But optimally, Ron chooses to move to 4, winning the game.

Hence, the hypothesis seems correct.

So, the rule is:

- Calculate the distances from the starting node to each leaf.

- Find the minimum distance.

- If this minimum distance is odd, Ron wins.

- If it's even, Hermione wins.

Wait, but in the second sample, starting at 5, distances to leaves are 0 and 4, minimum is 0, which is even, so Hermione wins.

Which matches the sample output.

In the first sample, starting at 3, distances are 1 and 1, minimum is 1, odd, so Ron wins.

Which matches the sample output.

In my additional example, starting at 2 in a tree of 4 nodes, distances are 1 and 2, minimum is 1, odd, Ron wins.

Starting at 3 in the same tree, distances are 1 and 2, minimum is 1, odd, Ron wins.

Another example: n=2, t=1

Only one edge: 1-2

Start at node 1.

Distances to leaves: 0 (to 1) and 1 (to 2).

Minimum is 0, even, Hermione wins.

Indeed, starting at 1, Ron can only move to 2, then Hermione can't move, so Ron wins.

Wait, but according to the earlier rule, minimum distance is 0, which is even, so Hermione wins.

But in reality, Ron wins.

Wait, this contradicts my hypothesis.

Wait, in this case, starting at node 1, which is a leaf.

Leaves are 1 and 2.

Distances to leaves: 0 (from 1 to 1) and 1 (from 1 to 2).

Minimum distance is 0, which is even, so according to the hypothesis, Hermione wins.

But in reality, Ron moves to 2, Hermione can't move, so Ron wins.

Hence, the hypothesis is incorrect.

So, my previous hypothesis is wrong.

I need to rethink this.

Perhaps the rule is:

- If the distance from the starting node to the nearest leaf is even, Ron wins.

- If it's odd, Hermione wins.

But in this new example, starting at node 1 (distance 0, even), Ron wins.

In the first sample, starting at node 3 (distances 1 and 1, minimum 1, odd), Ron wins.

Wait, that doesn't make sense with the new example.

Wait, maybe it's the total number of moves from the starting node to the nearest leaf.

Wait, perhaps it's the number of moves required to reach a leaf.

Wait, perhaps it's the number of moves to reach a leaf where no more moves are possible.

Wait, in the game, the player who can't move loses.

So, if a player is forced to move to a leaf, and there are no more moves, the other player wins.

Wait, maybe I need to think in terms of game theory and determine the "grundy number" or "Nimber" for each position.

But perhaps there's a simpler way since the tree is a straight path.

Let me try to model this as a game on a path graph.

In a path graph, each node is connected to at most two neighbors, except for the endpoints (leaves).

The game is to move the stone to an inactive neighbor, activating it, and the player who can't move loses.

This resembles the game of Kayles or Nim played on a path.

In such games, the concept of "inversion" or "mex" can be used to determine the winner.

Alternatively, perhaps I can think in terms of the number of moves each player can make.

Wait, perhaps I need to calculate the number of possible moves from the starting node to the nearest leaf and see who ends up making the last move.

Wait, maybe I should consider the distance from the starting node to each leaf and see if that distance is odd or even.

Wait, perhaps I need to consider the parity of the distances.

Let me consider the starting node's distance to each leaf and see the possible moves.

In the first sample:

n=3, t=1

Edges: 2-3 and 3-1

Starting at 3.

Distances to leaves: 1 to 1, 1 to 2.

Ron can move to 1 or 2.

If he moves to 1, Hermione can't move, so Ron wins.

If he moves to 2, Hermione can't move, so Ron wins.

So, Ron wins.

In the second sample:

n=5, t=1

Edges: 1-2, 2-3, 3-4, 4-5

Starting at 5.

Distances to leaves: 0 to 5, 4 to 1.

Ron can move to 4.

Hermione moves to 3.

Ron moves to 2.

Hermione moves to 1.

Ron can't move, so Hermione wins.

So, in this case, Hermione wins.

Looking at the distances:

- In the first sample, distances to leaves are both odd (1).

- In the second sample, distances to leaves are even (0 and 4).

So, perhaps the rule is:

- If the distance from the starting node to at least one leaf is even, Hermione wins.

- Otherwise, Ron wins.

Wait, but in the first sample, distances are both odd, so Ron wins.

In the second sample, both distances are even, so Hermione wins.

In my earlier example with n=4, starting at node 2:

Distances to leaves: 1 (odd) and 2 (even).

According to this rule, Hermione wins, but in reality, Ron can choose to win.

Wait, but according to the rule, if at least one distance is even, Hermione wins.

But in this case, Ron can choose to move to 1, winning the game.

So, perhaps this rule isn't accurate.

Alternatively, perhaps it's the XOR of the distances.

Wait, in impartial game theory, combining multiple games can be done using XOR of their grundy numbers.

But in this case, it's a single game, not multiple independent games.

Wait, perhaps I can think of the game as two separate games from the starting node to each leaf.

But I'm not sure.

Alternatively, perhaps I should model this as a path and see who makes the last move.

In the first sample, path length is 2 (nodes 1-3-2), starting at 3.

Total moves: 2 (n - 1).

Ron moves first: moves to 1, Hermione can't move, Ron wins.

Alternatively, moves to 2, Hermione can't move, Ron wins.

In the second sample, path length is 4 (nodes 1-2-3-4-5), starting at 5.

Total moves: 4.

Ron moves to 4, Hermione moves to 3, Ron moves to 2, Hermione moves to 1, Ron can't move, so Hermione wins.

So, in this case, with total moves even, Hermione wins; with total moves odd, Ron wins.

Wait, but in the first sample, total moves are even (2), and Ron wins, which contradicts the earlier assumption.

Wait, maybe I need to consider something else.

Let me consider the number of moves each player can make.

In the first sample:

- Total moves: 2.

- Ron makes move 1, Hermione has no move.

- Ron wins.

In the second sample:

- Total moves: 4.

- Ron makes move 1, Hermione move 2, Ron move 3, Hermione move 4.

- Ron has no move left, so Hermione wins.

So, in general, if the total number of moves is odd, Ron wins; if even, Hermione wins.

Wait, but in the first sample, total moves are even (2), and Ron wins, which contradicts this.

Wait, maybe I need to consider who makes the last move.

In the first sample, Ron makes the last move (move 1), Hermione has no move, so Ron wins.

In the second sample, Hermione makes the last move (move 4), Ron has no move, so Hermione wins.

So, the player who makes the last move wins.

But in the first sample, Ron makes the last move, wins; in the second sample, Hermione makes the last move, wins.

But according to the total number of moves:

- If total moves are odd, Ron wins.

- If even, Hermione wins.

But in the first sample, total moves are even (2), Ron wins.

In the second sample, total moves are even (4), Hermione wins.

This inconsistency suggests that my assumption is wrong.

Perhaps I need to think differently.

Let me consider that in a path graph, the game is equivalent to a game of removing stones from a heap, where each move reduces the heap size by one, and the player who can't move loses.

In such a game, the winner depends on whether the initial number of stones is odd or even.

But in this problem, it's not exactly the same because the tree can have a more complex structure, even though in this problem, it's a straight path.

Wait, but in this specific problem, the tree is a straight path with two leaves, so it's like a line.

So, perhaps it is equivalent to a single heap where the number of stones is n - 1.

Then, the player who makes the last move wins.

In standard Nim game theory, in a single heap of size k, the first player wins if k is odd, and the second player wins if k is even.

Wait, but in standard Nim, the first player wins if k > 0, since they can take all stones.

But in this game, it's different because you're moving along the path, activating nodes one by one.

Maybe I need to consider the game as a sum of Nimbers.

Alternatively, perhaps I should consider the distance from the starting node to the nearest leaf.

Wait, in the first sample, starting at node 3, distance to nearest leaf is 1.

In the second sample, starting at node 5, distance to nearest leaf is 0.

Wait, distance 0? Wait, if you're starting at a leaf, the distance to that leaf is 0.

So, in that case, in the second sample, starting at leaf 5, distance to leaf 5 is 0, which is even, and Hermione wins.

In the first sample, starting at node 3, distance to leaf 1 is 1, which is odd, and Ron wins.

In my earlier example with n=4, starting at node 2, distances to leaves are 1 and 2.

Minimum distance is 1, which is odd, so Ron wins.

But in reality, Ron can choose to win or lose based on his first move.

So, perhaps the rule is:

- If the minimum distance to a leaf is odd, Ron wins.

- If the minimum distance to a leaf is even, Hermione wins.

But as I saw in the n=2 example, starting at leaf 1 (distance 0, even), but Ron can still win by moving to the only other node.

Wait, perhaps the rule needs to be adjusted.

Let me think differently.

Suppose I calculate the distance from the starting node to each leaf.

Then, the game can be thought of as a race to reach a leaf.

But in this game, players are alternately moving the stone along the path, activating nodes.

The player who moves the stone to a leaf and there are no more moves loses.

Wait, no, in this game, when you move to a leaf, there are no more moves, so the player who moves to a leaf loses because the other player can't move.

So, the player who is forced to move to a leaf loses.

So, it's similar to a game where you don't want to be the one to reach the end.

This sounds like the game of Nim with a single pile, where the player who takes the last stone loses.

This is known as the misère version of Nim.

In standard Nim, the player who takes the last stone wins, but in misère Nim, the player who takes the last stone loses.

Wait, but in this problem, it's more similar to misère Nim on a path.

So, perhaps I need to consider the parity of the number of moves until the stone is moved to a leaf.

Wait, perhaps I need to think recursively.

Define the winner for each node, assuming optimal play.

- If a node is a leaf, the player who moves to it loses, because they can't move anymore.

- If a node has one or more non-leaf neighbors, the player can choose to move to one of them.

So, in game theory terms, the value of a position is zero (loss) if it's a leaf, and non-zero otherwise.

Wait, but it's more nuanced because the game alternates between players.

Perhaps I should think in terms of mex (minimum excludant).

In impartial game theory, the mex rule is used to determine the nimber of a position.

But perhaps I'm overcomplicating it.

Let me try to find a pattern.

Consider a path of length 2: A - B - C, with leaves A and C.

Start at B.

- Ron moves to A or C.

- Hermione can't move, so Ron wins.

Start at A.

- Ron moves to B.

- Hermione moves to C.

- Ron can't move, so Hermione wins.

Start at C.

- Same as starting at A.

So, for n=3:

- Starting at B: Ron wins.

- Starting at A or C: Hermione wins.

For n=4: A - B - C - D, leaves A and D.

Start at B:

- Ron moves to A or C.

- If Ron moves to A, Hermione can't move, so Ron wins.

- If Ron moves to C, Hermione moves to D, Ron can't move, so Hermione wins.

So, Ron can choose to win or lose based on his first move.

Assuming optimal play, Ron会选择赢的策略，所以 Ron wins.

Start at C:

- Ron moves to B or D.

- If Ron moves to B, Hermione moves to A, Ron can't move, so Hermione wins.

- If Ron moves to D, Hermione can't move, so Ron wins.

So, Ron can choose to win or lose; assuming optimal play, Ron chooses to win.

Start at D:

- Ron moves to C.

- Hermione moves to B.

- Ron moves to A.

- Hermione can't move, so Ron wins.

Similarly, starting at A:

- Ron moves to B.

- Hermione moves to C.

- Ron moves to D.

- Hermione can't move, so Ron wins.

Wait, but earlier I thought starting at A, Hermione wins.

Wait, perhaps I made a mistake.

Let me simulate starting at A in n=4:

- Ron moves to B.

- Hermione moves to C.

- Ron moves to D.

- Hermione can't move, so Ron wins.

Wait, contrary to my earlier thought, starting at A in n=4, Ron wins.

Wait, but in n=3, starting at A, Hermione wins.

So, in n=3, starting at A or C (leaves), Hermione wins.

In n=4, starting at A or D (leaves), Ron wins.

Wait, this is getting confusing.

Perhaps I need a general rule.

Let me consider the distance from the starting node to each leaf.

Define the distance as the number of edges from the starting node to the leaf.

Then, perhaps the winner depends on whether the minimum distance to a leaf is odd or even.

In n=3, starting at B, distances to leaves A and C are both 1 (odd), Ron wins.

Starting at A or C, distance to nearest leaf is 0 (even), Hermione wins.

In n=4, starting at B, distances to leaves A and D are 1 and 2.

Minimum distance is 1 (odd), Ron wins.

Starting at C, distances to leaves A and D are 1 and 1.

Minimum distance is 1 (odd), Ron wins.

Starting at A or D, distance to nearest leaf is 0 (even), Hermione wins.

Wait, but in n=4, starting at A or D, Hermione wins.

But in the simulation, starting at A in n=4, Ron wins.

Wait, there must be a mistake in my simulation.

Let me simulate starting at A in n=4 again:

- Ron moves to B.

- Hermione moves to C.

- Ron moves to D.

- Hermione can't move, so Ron wins.

So, Ron wins, but according to the rule, distance to nearest leaf is 0 (even), which would suggest Hermione wins, but in reality, Ron wins.

So, the rule is incorrect.

Perhaps I need to adjust the rule.

Wait, maybe it's the parity of the distance plus one.

In n=3, starting at B, distance to leaf is 1, 1 is odd, Ron wins.

Starting at A or C, distance to leaf is 0, 0 is even, Hermione wins.

In n=4, starting at B, distance to leaf is 1, odd, Ron wins.

Starting at C, distance to leaf is 1, odd, Ron wins.

Starting at A or D, distance to leaf is 0, even, Hermione wins.

But in reality, starting at A in n=4, Ron wins, which contradicts the rule.

Wait, maybe the rule is:

- If the minimum distance to a leaf is odd, Ron wins.

- If it's even and greater than 0, Ron wins.

- If it's 0, Hermione wins.

Wait, in n=4, starting at A, distance is 0, Hermione wins.

Starting at B or C, distance is 1, Ron wins.

Starting at D, distance is 0, Hermione wins.

But in reality, starting at A in n=4, Ron wins, which contradicts the rule.

Hmm, perhaps I need to consider the total number of moves from the starting node to the nearest leaf.

Wait, in n=3, starting at B, moves: B to A or B to C, then game ends. Total moves: 1, which is odd, Ron wins.

In n=4, starting at B, moves: B to A, game ends, or B to C, then C to D, game ends. So, total moves are 1 or 2.

If Ron chooses to move to A, total moves are 1 (odd), Ron wins.

If he chooses to move to C, total moves are 2 (even), Hermione wins.

So, Ron can choose to win or lose based on his first move.

Assuming optimal play, he chooses to win.

Hence, Ron wins.

Starting at C in n=4, moves: C to B, then B to A, game ends (2 moves, even, Hermione wins).

Or C to D, game ends (1 move, odd, Ron wins).

So, Ron can choose to win or lose; assuming optimal play, he chooses to win.

Hence, Ron wins.

Starting at A in n=4, moves: A to B, then B to C, then C to D, game ends (3 moves, odd, Ron wins).

Starting at D in n=4, moves: D to C, then C to B, then B to A, game ends (3 moves, odd, Ron wins).

Wait, but earlier I thought starting at A in n=4, Ron wins, which aligns with this.

But according to the distance rule, distance from A to nearest leaf is 0 (even), Hermione should win, but in reality, Ron wins.

So, perhaps the rule should be:

- If the minimum distance to a leaf is odd, Ron wins.

- If the minimum distance to a leaf is even and greater than 0, Ron wins.

- If the minimum distance to a leaf is 0, Hermione wins.

Wait, in n=4, starting at A, distance is 0, Hermione wins, but in simulation, Ron wins.

Contradiction.

Wait, perhaps the rule is:

- If the minimum distance to a leaf is even, Ron wins.

- If the minimum distance to a leaf is odd, Hermione wins.

Wait, but in n=3, starting at B, distance is 1 (odd), Hermione should win, but in reality, Ron wins.

Contradiction again.

This is getting complicated.

Maybe I need to think recursively.

Define a function that, for a given node, determines who wins if the game starts there.

Base case: if the node is a leaf, the player who moves there loses.

So, if a player is forced to move to a leaf, they lose.

Otherwise, the player can choose to move to any inactive neighbor.

Wait, perhaps I can define the winning positions recursively.

Let me try to define winning and losing positions.

- A losing position is a leaf, because the player who moves there can't move anymore.

- A winning position is any position from which you can move to a losing position.

- More generally, a position is a winning position if there exists at least one move to a losing position.

- Otherwise, it's a losing position.

So, starting from a node, if there exists at least one neighbor that is a losing position, then the current position is a winning position.

Otherwise, it's a losing position.

So, I need to determine, for each node, whether it's a winning or losing position.

But in this problem, the game starts with some nodes already activated, but in each round, only the starting node is activated, and the rest are inactive.

Wait, no, in each round, all nodes are initially inactive, except the starting node.

Wait, in the problem statement, it says:

"each round starts with a stone on exactly one node, which is considered as activated."

So, at the start of each round, only the starting node is activated, and the rest are inactive.

Wait, but in the game, when you move the stone to a neighbor, that neighbor becomes activated.

Wait, but in standard graph terminology, "activated" might not be the standard term, but in this context, it means that the node has been visited.

So, in this game, you can only move to inactive (unvisited) neighbors.

So, it's similar to a path in the graph where you can't revisit nodes.

This is similar to a game of moving along the path without revisiting nodes.

In such a game, the player who can't move loses.

This is similar to a game of Nim on a path.

In such games, the winner depends on the parity of the number of moves.

But earlier examples show that it's not just about the parity of the total number of moves.

Perhaps I need to consider the distance from the starting node to the nearest leaf.

Wait, maybe I should think in terms of the number of moves required to force the opponent into a losing position.

Alternatively, perhaps I can model this as a game where the number of moves is fixed, and the player who makes the last move wins.

But in this game, the player who can't move loses, which is similar to normal play convention in game theory.

In normal play convention, the player who makes the last move wins.

So, in this game, the player who makes the last move before no moves are left wins.

Hence, if the total number of moves is odd, Ron wins; if even, Hermione wins.

Wait, but in the first sample, n=3, total moves=2 (even), Ron wins.

But according to this, if total moves are even, Hermione should win, but in the sample, Ron wins.

Contradiction.

Wait, perhaps I need to consider who makes the last move.

In the first sample, total moves=2:

- Ron moves 1: moves to A or C.

- Hermione has no move.

- So, Ron makes the last move, wins.

In the second sample, n=5, total moves=4:

- Ron moves to 4.

- Hermione moves to 3.

- Ron moves to 2.

- Hermione moves to 1.

- Ron has no move, so Hermione makes the last move, wins.

So, it seems that the player who makes the last move wins.

Hence, if the total number of moves is odd, Ron wins; if even, Hermione wins.

But in the first sample, total moves=2 (even), Ron wins, which contradicts this.

Wait, perhaps I need to consider that Ron makes the first move, and if the total number of moves is odd, Hermione makes the last move, so she wins; if even, Ron makes the last move, so he wins.

Wait, no, in the first sample, total moves=2 (even), Ron makes the last move, wins.

In the second sample, total moves=4 (even), Hermione makes the last move, wins.

Wait, that doesn't make sense.

Wait, perhaps I need to consider that the total number of moves includes Ron's and Hermione's moves.

So, if total moves are even, Hermione makes the last move; if odd, Ron makes the last move.

Wait, no.

Let's see:

- Total moves = 2: Ron moves first (move 1), Hermione moves second (move 2).

- So, if total moves are even, Hermione makes the last move.

- If total moves are odd, Ron makes the last move.

But in the first sample, total moves=2 (even), Hermione should make the last move, but according to the sample, Ron wins.

Contradiction.

Wait, perhaps I need to think differently.

Maybe the total number of moves is n - 1, and the player who moves to the leaf loses.

Wait, but in the first sample, n=3, moves=2 (even), Ron wins.

In the second sample, n=5, moves=4 (even), Hermione wins.

Wait, perhaps it's about who makes the second-to-last move.

Wait, I'm getting confused.

Let me try to think recursively.

Define a function win(node):

- If node is a leaf, return "Hermione" (since the player who moves there loses).

- Else, for each neighbor, if win(neighbor) == "Hermione", return "Ron".

- If all neighbors are "Ron", return "Hermione".

Wait, in this setup:

- Leaf nodes are losing positions for the player who moves there.

- For non-leaf nodes, if there exists at least one losing position among the neighbors, then the current node is a winning position.

- Otherwise, it's a losing position.

So, in code:

def win(node):

if node is leaf:

return "Hermione"

else:

for neighbor in neighbors:

if win(neighbor) == "Hermione":

return "Ron"

return "Hermione"

But in this game, the players alternate moves, and the player who can't move loses.

This seems correct.

But in practice, for n=3, starting at B:

- B has neighbors A and C, both leaves.

- So, win(A) = "Hermione", win(C) = "Hermione".

- So, win(B) = "Ron".

Which matches the sample.

For n=4, starting at B:

- Neighbors A and C.

- win(A) = "Hermione", win(C) = "Hermione".

- So, win(B) = "Ron".

But in the simulation, starting at B in n=4:

- Ron moves to A, Hermione can't move, Ron wins.

- Or Ron moves to C, Hermione moves to D, Ron can't move, Hermione wins.

So, Ron can choose to win or lose based on his first move.

But according to the win function, win(B) = "Ron", which is correct.

For n=4, starting at C:

- Neighbors B and D.

- win(B) = "Ron", win(D) = "Hermione".

- So, win(C) = "Ron" (since there exists a neighbor with win("Hermione")).

Which matches the simulation.

For n=4, starting at A:

- Neighbor B.

- win(B) = "Ron".

- So, win(A) = "Hermione".

Which contradicts the simulation where Ron wins.

Wait, but in the simulation, starting at A in n=4:

- Ron moves to B.

- Hermione moves to C.

- Ron moves to D.

- Hermione can't move, so Ron wins.

But according to the win function, win(A) = "Hermione".

This suggests that the win function is incorrect.

Wait, perhaps I need to adjust the win function to consider that the game ends when a player moves to a leaf.

So, perhaps:

def win(node):

if all neighbors are leaves:

return "Hermione"

else:

for neighbor in neighbors:

if win(neighbor) == "Hermione":

return "Ron"

return "Hermione"

Wait, in n=4, starting at A:

- Neighbor B.

- win(B):

- Neighbors A and C.

- A is a leaf, win(A) = "Hermione".

- win(C) = "Ron".

- So, win(B) = "Ron".

- So, win(A) = "Ron".

Wait, but according to the simulation, starting at A, Ron wins.

So, perhaps the initial win function was correct, and I made a mistake earlier.

So, the correct win function is:

def win(node):

if node is leaf:

return "Hermione"

else:

for neighbor in neighbors:

if win(neighbor) == "Hermione":

return "Ron"

return "Hermione"

This matches the simulation in n=4 starting at A:

- win(A):

- Neighbor B.

- win(B):

- Neighbors A and C.

- win(A) = "Hermione", win(C) = "Ron".

- So, win(B) = "Ron".

- So, win(A) = "Ron".

Which matches the simulation where Ron wins.

Earlier, I thought win(A) was "Hermione", but according to this function, it's "Ron".

So, my mistake was in the initial assumption of win(A).

Hence, the win function is correct.

So, to implement this, I need to:

- Build the tree structure.

- Identify the leaves.

- Define the win function recursively.

- Memoize the results to avoid recomputation.

But since n can be up to 2e5, recursion might not be efficient enough, and I need to handle it iteratively.

Perhaps I can perform a topological sort, starting from the leaves and propagating the winning positions to the root.

But since it's a tree, I can perform a DFS and compute the win value for each node.

But given the constraints, I need an efficient solution.

Wait, perhaps I can observe that in a path graph, the winning positions alternate based on the distance to the leaves.

Wait, perhaps I can calculate the distance from each node to the nearest leaf and determine the winning player based on that.

But earlier attempts at that were inconsistent.

Alternatively, perhaps I can find that Ron wins if the distance to the nearest leaf is odd, and Hermione wins if it's even.

Wait, in n=3, starting at B, distance=1 (odd), Ron wins.

In n=4, starting at B, distance=1 (odd), Ron wins.

Starting at C, distance=1 (odd), Ron wins.

Starting at A, distance=0 (even), Hermione wins.

Starting at D, distance=0 (even), Hermione wins.

But in the simulation, starting at A in n=4, Ron wins, but distance=0, which is even, suggesting Hermione wins, but in reality, Ron wins.

So, perhaps this rule doesn't hold.

Wait, maybe I need to consider the parity of the number of moves from the starting node to the nearest leaf.

Wait, perhaps Ron wins if the distance to the nearest leaf is even, and Hermione wins if it's odd.

Wait, in n=3, distance=1 (odd), Ron wins.

In n=4, distance=0 (even), Hermione wins.

But in n=4, starting at A, distance=0 (even), but Ron wins.

Contradiction.

Wait, perhaps I need to consider the distance plus one.

So, if distance is even, moves are odd, Ron wins; if distance is odd, moves are even, Hermione wins.

Wait, in n=3, distance=1 (odd), moves=2 (even), Hermione should win, but Ron wins.

Contradiction.

Wait, perhaps I need to consider that the number of moves is equal to the distance to the leaf.

Wait, no, the number of moves is equal to the number of edges traversed.

Wait, perhaps I need to think in terms of the number of moves required to force the opponent into a losing position.

This is getting too complicated.

Given time constraints, perhaps I should accept that the initial approach is correct: calculate the distance to the nearest leaf, and determine the winner based on whether that distance is odd or even.

But given the confusion with the n=4 example, I'm not entirely sure.

Alternatively, perhaps I should trust the initial recursive function and implement it efficiently.

So, in code, I can perform a BFS from the leaves, assigning Hermione as the winner for leaves, and then propagating the winning positions to the parent nodes.

But I need to handle this efficiently.

Wait, perhaps I can perform a BFS from the leaves, and for each node, determine if it's a winning position based on its neighbors.

Starting from the leaves, which are Hermione's winning positions, and then moving inward.

But I need to ensure that I process nodes in the correct order.

Alternatively, since it's a tree, I can root the tree and perform a DP from the leaves up to the root.

Define dp[node] as the winner if the game starts at node.

For leaf nodes, dp[node] = "Hermione".

For internal nodes, dp[node] = "Ron" if there exists at least one neighbor with dp[neighbor] = "Hermione", else "Hermione".

This can be implemented efficiently in linear time.

Given that n can be up to 2e5, I need an efficient O(n) solution.

So, I can perform a DFS or BFS to compute dp for each node.

But in practice, implementing this efficiently in Python might be tricky due to recursion limits.

Alternatively, since the tree is a straight path with two leaves, I can find the two leaves and compute the distances to them.

Then, determine the winning position based on these distances.

Wait, but in earlier examples, this approach led to contradictions.

Perhaps I need to accept that and proceed with the initial approach.

So, in the given program, it calculates the distances from the starting node to each leaf, and then checks if any of these distances is even.

If any distance is even, Hermione wins; else, Ron wins.

But according to my simulation in n=4, starting at A, distance=0 (even), but Ron wins.

So, perhaps this rule is incorrect.

Alternatively, perhaps it's the parity of the minimum distance.

In the program, it seems to check if any distance is even, Hermione wins; else, Ron wins.

But in the n=4 example, starting at A, distance