Alright, I have this problem to solve. Let's see what it's asking for. So, I'm given a "beautiful" array, and I need to find the minimum number of elements to remove so that it's no longer beautiful. If it's impossible to make it un-beautiful, I should output -1.

First, I need to understand what makes an array beautiful. According to the problem, an array is beautiful if you can make all its elements the same by repeatedly choosing an index i (where 2 ≤ i ≤ n-1) such that a[i-1] equals a[i+1], and then replacing a[i] with a[i-1]. Essentially, you're allowed to change elements that are sandwiched between two identical elements to make them the same as their neighbors.

The goal is to remove the minimum number of elements to prevent this process from making all elements equal. If it's impossible to do so, meaning the array can't be made un-beautiful no matter how many elements I remove, I should return -1.

Looking at the examples:

1. For n=3 and array [2,2,2], it's already all equal, and no matter how many elements I remove, it remains beautiful. So, the answer is -1.

2. For n=5 and array [1,2,1,2,1], removing one element can make it un-beautiful.

3. For n=1, a single-element array is beautiful, and removing the only element would make it empty, which might be considered un-beautiful. But according to the problem, if it's impossible to make it un-beautiful, we output -1. An empty array isn't considered beautiful, I suppose.

4. For n=7 and array [3,3,3,5,3,3,3], removing the first three 3's leaves [5,3,3,3], which is not beautiful.

From these, it seems that if the array consists of all identical elements, it's impossible to make it un-beautiful, hence -1. Otherwise, there might be a way to remove elements to disrupt the beauty.

I need to find a general approach. Let's think about the operations allowed. The operation allows changing an element in the middle if its neighbors are equal. So, to make the array not beautiful, I need to ensure that no sequence of operations can make all elements equal.

One way to approach this is to look for repeating patterns or sequences that allow such operations. It seems like sequences where elements are sandwiched between identical elements are vulnerable to being changed.

Wait, perhaps I should consider the array in terms of blocks of identical elements. For example, in [1,2,1,2,1], there are alternating blocks: 1, 2, 1, 2, 1. Each block is of length 1.

In [3,3,3,5,3,3,3], there are blocks: 3 (length 3), 5 (length 1), 3 (length 3).

If I can ensure that there's a block that cannot be made equal to others through operations, then the array is not beautiful.

But I need to think differently. The operation allows changing elements that are between two equal elements to match their neighbors. So, if I have a sequence like a, b, a, I can change b to a, making it a, a, a.

Similarly, if I have a, a, b, a, a, I can change b to a, making all a's.

So, to prevent this, I need to disrupt such sequences where elements can be changed based on their neighbors.

Perhaps, if I remove elements such that no two identical elements are adjacent, or something like that.

Wait, but removing elements reduces the array's size, and I need to ensure that after removal, it's impossible to make all elements equal through the given operations.

Let me consider the array as a sequence of runs of identical elements.

For example:

- [2,2,2]: one run of 2's of length 3.

- [1,2,1,2,1]: five runs of length 1 each.

- [3,3,3,5,3,3,3]: three runs: 3 (len 3), 5 (len 1), 3 (len 3).

If all runs are of the same value, like [2,2,2], it's impossible to make it un-beautiful because any removal just reduces the length but keeps it beautiful.

If there are multiple runs with different values, I need to find a way to remove the minimum number of elements so that the remaining array cannot be made beautiful.

What makes an array not beautiful? If there's no sequence of operations that can make all elements equal.

Given the operation, if I can ensure that there are at least two different values that cannot be made equal through the operations, then the array is not beautiful.

Wait, perhaps if I can make sure that there's at least one element that cannot be changed to match others, then the array is not beautiful.

But I need a clearer criterion.

Let's consider that the array is beautiful if all elements can be made equal by repeatedly applying the operation.

So, to make it not beautiful, I need to ensure that after removal, there's no way to make all elements equal.

One way to think about this is to consider the array as a graph where elements connected by the operation can be linked, and removing elements breaks those links.

But that might be too complicated.

An alternative approach is to find the minimum number of elements to remove so that the remaining array has at least two different values that cannot be made equal through the operations.

But I need a more concrete plan.

Let me consider that if the array has only one unique value, it's impossible to make it un-beautiful, hence -1.

If there are multiple unique values, perhaps the minimum number of elements to remove is related to the frequency of the most frequent value.

Wait, in the second example, [1,2,1,2,1], the most frequent value is 1, appearing three times. If I remove one element, I can disrupt the sequence.

Wait, maybe the answer is the minimum frequency of any value.

But in the fourth example, [3,3,3,5,3,3,3], the most frequent value is 3, appearing six times. Removing three elements can disrupt it.

Wait, perhaps the answer is the minimum number of elements to remove is equal to the minimum number of runs that have the most frequent value.

I need to think differently.

Let me consider that in order for the array to remain beautiful, it must be possible to make all elements equal by changing elements that are between two identical elements.

So, if I have runs of different values, I need to ensure that after removal, it's impossible to make all elements equal.

Perhaps, the key is to remove elements such that the remaining array has at least two different values, and no run of one value can be expanded to cover the entire array through the operations.

But I'm still not getting a clear formula.

Let me look at the sample inputs and outputs again.

First sample input: [2,2,2]. It's all the same, so -1.

Second sample input: [1,2,1,2,1]. Removing one element can make it un-beautiful.

Third sample input: [1]. It's a single element, so -1.

Fourth sample input: [3,3,3,5,3,3,3]. Removing three elements can make it un-beautiful.

Wait, in the second sample, [1,2,1,2,1], if I remove the last element, it becomes [1,2,1,2]. Now, trying to make all elements equal:

- Choose i=2 (value 2), since a[1]=1 and a[3]=1, but a[1] ≠ a[3], so can't apply the operation.

- Choose i=3 (value 1), but a[2]=2 and a[4]=2, which are equal, so can replace a[3] with 2, making [1,2,2,2]. Now, choose i=1 (value 1), but a[0] doesn't exist, so can't apply. So, it's not beautiful.

Hence, removing one element is sufficient.

In the fourth sample, [3,3,3,5,3,3,3], if I remove the first three 3's, it becomes [5,3,3,3]. Now, trying to make all elements 3:

- Choose i=1 (value 3), since a[0]=5 and a[2]=3, but 5 ≠ 3, can't apply.

- Choose i=2 (value 3), a[1]=3 and a[3]=3, which are equal, so can replace a[2] with 3 (though it's already 3).

- Choose i=3 (value 3), a[2]=3 and a[4] doesn't exist.

So, it's not possible to make all elements equal to 5, and it's already all 3's except for one 5, which can't be changed. Hence, it's not beautiful.

So, the strategy seems to be: remove elements to break the sequences in such a way that it's impossible to make all elements equal.

Now, to generalize, perhaps the answer is the size of the smallest run of the most frequent value.

Wait, in the second sample, the most frequent value is 1, appearing three times, each as a run of length 1. So, the smallest run is 1.

In the fourth sample, the most frequent value is 3, with runs of length 3.

Wait, no, in the fourth sample, after removing three elements, you're left with [5,3,3,3], which has runs of 1 (5) and 3 (3's).

Wait, perhaps I need to remove enough elements so that the remaining array has a run that cannot be expanded to cover the entire array.

This is getting complicated.

Let me consider that in order for the array to remain beautiful, it must be possible to make all elements equal by propagating a certain value through the array using the operations.

So, if I can choose a value and ensure that it can be propagated to all positions through the operations, the array is beautiful.

To make it not beautiful, I need to prevent this propagation.

One way to think about it is to consider connected components where elements can be made equal through operations.

If the entire array is one connected component, it's beautiful.

If it's divided into multiple components, it's not beautiful.

So, perhaps the answer is the size of the smallest component that needs to be removed to disconnect the array.

But I need to think in terms of removing elements to break the connectivity.

Wait, perhaps I should model the array as a graph where elements are nodes, and there's an edge between nodes if they can be made equal through operations.

Then, to make the array not beautiful, I need to remove elements such that the graph is disconnected.

The minimum number of elements to remove would be the size of the smallest component in this graph.

But this seems too vague.

Let me consider a different approach.

Suppose I have runs of identical elements.

If there is only one unique value, it's impossible to make it un-beautiful.

If there are multiple unique values, the minimum number of elements to remove is equal to the length of the shortest run.

Wait, in the second sample, the runs are all of length 1, so the shortest run is 1, which matches the answer.

In the fourth sample, the runs are of lengths 3,1,3, so the shortest run is 1, but the answer is 3.

Wait, that doesn't match.

Wait, in the fourth sample, removing three elements (the first three 3's) leaves [5,3,3,3], which is not beautiful.

But according to my hypothesis, the shortest run is 1, but the answer is 3.

So my hypothesis is incorrect.

I need to think differently.

Let me consider that in order to make the array not beautiful, I need to ensure that after removal, there are at least two different values that cannot be made equal through operations.

So, perhaps the answer is related to the frequency of the least frequent value.

But in the fourth sample, the least frequent value is 5, appearing once, but removing three elements is required to make it not beautiful.

That doesn't align.

Wait, perhaps it's related to the number of times the most frequent value appears in runs.

Wait, in the fourth sample, the most frequent value is 3, appearing in two runs of length 3 and 3.

Removing three elements (the first three 3's) breaks one of the runs, leaving [5,3,3,3], which cannot be made beautiful.

So, perhaps the answer is the size of the smallest run of the most frequent value.

But in the second sample, the most frequent value is 1, with runs of length 1, and the answer is 1.

This seems to hold.

In the first sample, all elements are the same, so -1.

In the third sample, only one element, so -1.

In the fourth sample, the smallest run of the most frequent value is 3, and the answer is 3.

Wait, no, in the fourth sample, the runs of 3 are of length 3 each, and removing three elements breaks one of them.

But in the second sample, runs of 1 are of length 1 each, and removing one element suffices.

So, perhaps the answer is the size of the smallest run of the most frequent value.

But in the fourth sample, the smallest run of 3 is 3, and that's the answer.

In the second sample, the smallest run of 1 is 1, and that's the answer.

In the first and third samples, there's only one unique value, so -1.

This seems to be a consistent approach.

Let me test this hypothesis with another example.

Suppose the array is [1,1,2,2,1,1].

The most frequent value is 1, with runs of length 2,1,2.

The smallest run of 1 is of length 1.

So, according to this, the answer should be 1.

If I remove one element, say the third element (value 2), the array becomes [1,1,2,1,1].

Let's see if this is still beautiful.

Can I make all elements equal to 1?

- Choose i=3 (value 1), since a[2]=2 and a[4]=1, which are not equal, can't apply.

- Choose i=2 (value 2), a[1]=1 and a[3]=1, which are equal, so replace a[2] with 1, making [1,1,1,1,1]. Now, it's all 1's.

So, it's still beautiful.

Wait, so removing one element isn't enough.

Maybe my hypothesis is incorrect.

Wait, perhaps I need to remove all elements of the smallest run.

But in this case, the smallest run is of length 1, but removing one element still allows the array to be made beautiful.

So, perhaps I need to remove enough elements to ensure that no run of the most frequent value can connect the entire array.

This is getting complicated.

Let me look back at the provided program and see what it's doing.

The program iterates through the array, tracking the length of current runs of the same value.

It keeps track of the minimum run length of the most frequent value.

Then, it prints this minimum run length, or -1 if all elements are the same.

Wait, but in my earlier example, this approach fails.

Wait, perhaps I need to consider that in order to make the array not beautiful, I need to remove enough elements so that the remaining array has at least two distinct values, and no run of one value can be expanded to cover the entire array.

But I need a better way to think about this.

Let me consider that the array is beautiful if all elements can be made equal by repeatedly applying the operation.

So, to make it not beautiful, I need to ensure that after removal, it's impossible to make all elements equal.

One way to achieve this is to have at least two distinct values in the array, and ensure that no sequence of operations can make them all equal.

Given that the operation allows changing elements that are between two identical elements to match their neighbors, it's like propagating values through the array.

So, if I have islands of different values that cannot be connected through these operations, then the array is not beautiful.

Hence, the minimum number of elements to remove would be the size of the smallest connecting component that allows propagation.

But I need a more straightforward way to compute this.

Looking back at the provided program:

- It seems to iterate through the array, grouping consecutive identical elements.

- It keeps track of the minimum length of these groups for the most frequent value.

- Then, it prints this minimum length, or -1 if the array is uniform.

Wait, in the fourth sample, the groups are [3,3,3], [5], [3,3,3], so the smallest group for 3 is 3, which matches the answer.

In the second sample, groups are [1], [2], [1], [2], [1], so the smallest group for 1 is 1, which matches the answer.

In the first sample, all elements are the same, so -1.

In the third sample, only one element, so -1.

This seems consistent.

But in my earlier example, [1,1,2,2,1,1], the groups for 1 are of lengths 2,1,2.

The smallest group is 1, so according to this, the answer would be 1.

But as I saw earlier, removing one element isn't enough to make it not beautiful.

So, perhaps this approach is incorrect.

Wait, maybe the correct answer is the minimum number of runs of the most frequent value.

In the fourth sample, there are two runs of 3's, each of length 3.

Removing three elements can break one of them.

In the second sample, there are three runs of 1's, each of length 1.

Removing one element breaks one of them.

In my example, [1,1,2,2,1,1], there are three runs of 1's: two of length 2 and one of length 1.

According to this, removing one element should be sufficient, but in practice, it's not enough.

Hence, this approach might be flawed.

Perhaps, the correct answer is the total number of elements that are not part of the largest run of the most frequent value.

But in the fourth sample, the largest run of 3's is 3, and there are two such runs.

Wait, I'm getting confused.

This is tricky.

Let me consider that to make the array not beautiful, I need to ensure that after removal, there are at least two different values, and no run of one value can be expanded to cover the entire array through operations.

Hence, the minimum number of elements to remove is equal to the size of the smallest run of the most frequent value.

But as my earlier example shows, this might not hold.

Alternatively, perhaps it's the size of the smallest run among all runs of the most frequent value.

In the fourth sample, the smallest run of 3 is 3, which matches the answer.

In the second sample, the smallest run of 1 is 1, which matches the answer.

In my example, the smallest run of 1 is 1, but removing one element doesn't make it un-beautiful, as shown earlier.

Hence, this approach might be incorrect.

I need to think differently.

Let me consider binary search on the answer: the minimum number of elements to remove.

For a given k, I need to check if removing k elements can make the array not beautiful.

If I can find the smallest k where this is possible, that's my answer.

If for all k, it's not possible, then output -1.

But this might be too slow, given the constraints.

I need a better way.

Let me consider that if the array consists of only one value, it's impossible to make it un-beautiful.

If it has multiple values, I need to remove elements such that no sequence of operations can make all elements equal.

One way to ensure this is to have at least two different values in the array, and ensure that no value can be propagated to cover the entire array.

Given the operation allows changing elements that are between two identical elements to match their neighbors, it's like fire spreading through the array.

So, to prevent the fire from spreading, I need to remove elements that act as bridges.

This sounds like I need to find the minimum number of elements to remove to break all paths of the most frequent value.

In graph terms, it's like finding the minimum cut to separate the array into parts where the most frequent value cannot propagate across.

But implementing this efficiently is challenging.

Given the time constraints, I need a simpler approach.

Looking back at the provided program, it seems to assume that the answer is the minimum length of runs of the most frequent value.

Given that this matches the sample inputs, it might be correct.

However, as per my earlier example, it seems insufficient.

Wait, perhaps I made a mistake in my earlier example.

Let's reconsider [1,1,2,2,1,1].

If I remove one element, say the third element (value 2), the array becomes [1,1,2,1,1].

Now, can I make all elements equal?

- Choose i=3 (value 1), a[2]=2 and a[4]=1, which are not equal, so can't apply.

- Choose i=2 (value 2), a[1]=1 and a[3]=1, which are equal, so replace a[2] with 1, making [1,1,1,1,1]. It's all 1's, so it's still beautiful.

Hence, removing one element isn't enough.

What if I remove two elements? Say the third and fourth elements.

The array becomes [1,1,1,1].

All elements are already equal, so it's still beautiful.

Wait, perhaps I need to remove more elements.

Wait, maybe in this case, it's impossible to make it un-beautiful, so the answer should be -1, but according to the program's logic, it would be 1, which is incorrect.

Hence, the provided program is incorrect.

Therefore, Correctness: **False**

**Final Answer**

\[ \boxed{\text{False}} \]