Alright, I've got this problem to solve. Let's see what it's asking for. So, Alice has n coins and wants to buy exactly k jewels from Bob's store. Bob can set up at most 60 stalls, each with a price per jewel that's an integer between 1 and 10^18 coins. Alice buys jewels greedily: she goes to each stall in order, buys as many jewels as she can with her remaining coins, and moves on to the next stall.

My task is to determine if Bob can set up the stalls with prices such that Alice buys exactly k jewels. If it's possible, I need to output "YES" along with the number of stalls and their prices. If not, I should output "NO".

First, I need to understand the constraints and what exactly is being asked. The input consists of multiple test cases, each with values of n and k, both can be up to 10^18. There can be up to 1000 test cases. So, efficiency is important here.

Let's look at the example provided:

Input:

3

7 3

6 4

255 8

Output:

YES

10

2 3 4 5 6 7 8 9 10 11

NO

YES

8

128 64 32 16 8 4 2 1

In the first case, with 7 coins and needing to buy exactly 3 jewels, Bob sets up 10 stalls with prices from 2 to 11 coins per jewel. Alice buys 3 jewels from the first stall (7 // 2 = 3, spending 6 coins), and then doesn't have enough coins for the next stalls. So, she buys exactly 3 jewels.

In the third case, with 255 coins and needing to buy exactly 8 jewels, Bob sets up 8 stalls with prices that are powers of 2, decreasing from 128 down to 1. Alice buys one jewel from each stall, spending 128, then 64, then 32, and so on, until she has spent all 255 coins and bought exactly 8 jewels.

The second case, with 6 coins and needing to buy exactly 4 jewels, is impossible, as the output is "NO".

From these examples, it seems that the key is to control how many jewels Alice buys at each stall by setting appropriate prices.

Let me think about the general approach.

First, if n < k, it's impossible because Alice can't buy more jewels than the number of coins she has, assuming each jewel costs at least 1 coin. So, if n < k, output "NO".

If n == k, Bob can set up a single stall with price 1, so Alice buys exactly k jewels.

Now, for n > k, Bob needs to set up stalls with prices such that Alice buys exactly k jewels in total.

One straightforward way is to set up k stalls, each with price 1, but that would make Alice buy one jewel from each stall, totaling k jewels. However, the problem allows up to 60 stalls, so this approach is feasible as long as k â‰¤ 60. But k can be up to 10^18, which is way beyond 60, so this won't work.

Another approach is to set up stalls with increasing prices, like in the first example, where prices are 2,3,4,...,11. In that case, Alice buys a certain number of jewels from the first stall, and then doesn't have enough for the next stalls.

But in the first example, setting up 10 stalls with prices from 2 to 11 allows Alice to buy 3 jewels. But if I set up fewer stalls, say 2 stalls with prices 2 and 1, what happens?

Let's try:

Stall 1: 2 coins per jewel

Alice has 7 coins, buys 7//2 = 3 jewels, spends 6 coins, left with 1 coin.

Then moves to stall 2: 1 coin per jewel

She has 1 coin, buys 1 jewel.

Total jewels: 4, which is more than k=3.

So, that's not good. Need to adjust the prices.

Alternatively, set stall 1 to have a higher price so that Alice buys fewer jewels there.

Let's set stall 1 to 3 coins per jewel.

Alice has 7 coins, buys 7//3 = 2 jewels, spends 6 coins, left with 1 coin.

Stall 2: 1 coin per jewel

Buys 1 jewel.

Total jewels: 3.

That works.

So, with two stalls: 3 and 1, Alice buys 3 jewels.

But in the first example, they used 10 stalls. Maybe to illustrate that multiple solutions are possible.

So, for n > k, Bob needs to set up some stalls with prices such that the total jewels bought is exactly k.

Now, considering the constraint of at most 60 stalls, we need a way to achieve exactly k jewels using up to 60 stalls.

Let me think about the minimal number of stalls required.

Suppose Bob sets up s stalls with prices p1, p2, ..., ps.

Alice buys floor(n/pi) jewels from stall i, and then updates n to n - pi * floor(n/pi).

She does this for each stall in order.

The total jewels bought is sum over i of floor(n/pi).

We need this sum to be exactly k.

Our task is to choose s <= 60 and pi's such that this sum is k.

This seems tricky, especially with n and k up to 10^18.

Let me consider a binary representation approach.

Wait, in the third example, with n=255 and k=8, the prices are 128,64,32,16,8,4,2,1, which are powers of 2.

In this case, Alice buys one jewel from each stall, since 255 is the sum of all these powers of 2.

So, she buys one from each stall, totaling 8 jewels.

This seems like a way to make Alice buy exactly one jewel from each stall by setting prices as powers of 2.

But in general, if I set prices as powers of 2, and choose s <= 60, since 2^60 is already beyond 10^18, but 2^60 is approximately 1.1529215e+18, which is within the limit.

Wait, 2^60 is 1152921504606846976, which is less than 10^18 (1000000000000000000).

Wait, no, 2^60 is actually 1152921504606846976, which is greater than 10^18 (1000000000000000000).

But in Python, integers can handle that.

So, if I set up stalls with prices that are powers of 2, starting from 2^0 up to 2^(s-1), where s <= 60, Alice will buy one jewel from each stall, spending the corresponding amount, and finally buy any remaining jewels with the remaining coins.

Wait, but in the third example, they used prices 128,64,32,16,8,4,2,1, which are powers of 2, and Alice bought one from each, totaling 8 jewels.

So, perhaps setting prices as powers of 2 is a general solution when n is at least 2^s - 1.

Wait, 2^8 -1 = 255, which matches the third example.

So, if n >= 2^s -1, and k = s, then setting prices as 2^{s-1}, 2^{s-2}, ..., 2^0, Alice will buy one from each stall, spending exactly n = 2^s -1 coins.

But in general, for any n and k, can we find s <=60 and p1, p2, ..., ps such that sum floor(n/pi) = k?

This seems complicated.

Let me consider another approach.

Suppose Bob sets up s=2 stalls.

Let p1 and p2 be the prices.

Alice buys floor(n/p1) jewels from stall 1, spends p1 * floor(n/p1) coins, then moves to stall 2 with the remaining coins.

From stall 2, she buys floor(remaining / p2) jewels.

Total jewels: floor(n/p1) + floor(remaining / p2).

We need this to be equal to k.

Similarly, for s=3, it's floor(n/p1) + floor(remaining_after_first/p2) + floor(remaining_after_second/p3) = k.

This seems messy to handle directly.

Maybe there's a smarter way to choose the prices.

Let me consider the minimal number of stalls required.

If I set up s=1 stall with price p, then Alice buys floor(n/p) jewels.

We need floor(n/p) = k.

So, p = floor(n/k).

But wait, floor(n/p) = k implies that p = floor(n/k).

But this may not be exact, because floor(n/p) might not be exactly k.

Wait, actually, for p = floor(n/k), floor(n/p) could be greater than k.

Wait, let's think about it.

Let p = floor(n/k).

Then, floor(n/p) >= k, but it may be larger than k.

For example, n=7, k=3.

p = floor(7/3) = 2.

floor(7/2) = 3, which is exactly k.

Another example, n=6, k=4.

p = floor(6/4) = 1.

floor(6/1) = 6, which is larger than k=4.

So, in this case, we need to adjust the prices.

So, perhaps setting up two stalls can help.

Set first stall with p1 = p = floor(n/k).

Alice buys floor(n/p1) jewels from the first stall.

If floor(n/p1) == k, we're done.

If floor(n/p1) > k, we need to make sure that in the second stall, she buys exactly k - floor(n/p1) jewels.

Wait, but she can only buy up to floor(remaining / p2) jewels in the second stall.

This seems tricky.

Maybe I need to think recursively.

Define a function that, given n coins and k jewels to buy, returns whether it's possible with s stalls and their prices.

But s is at most 60, so perhaps some greedy approach or binary representation can be used.

Wait, maybe I can think in terms of binary representation of k.

If I can make Alice buy 1 jewel from each stall, and set up s stalls where s = k, but s can be up to 60, which is fine if k <=60.

But k can be up to 10^18, which is way larger than 60.

So, that won't work.

Wait, but in the third example, they set up 8 stalls for k=8, which is acceptable since 8 <=60.

But for larger k, say k=100, which is still less than 60, wait, 100 >60, so that won't work.

Wait, s <=60, but k can be up to 10^18.

So, I need a way to set up up to 60 stalls to make Alice buy exactly k jewels.

This seems challenging.

Let me consider the minimal number of stalls required.

Suppose I set up s stalls with prices p1, p2, ..., ps.

I need sum floor(n/pi) = k.

I need to choose p1, p2, ..., ps such that this sum is exactly k.

This seems similar to a change-making problem, but with floor divisions.

I need a way to control the sum of floor divisions to be exactly k.

This seems non-trivial.

Let me consider some extreme cases.

Case 1: n = k

Then, set s=1, p1=1.

Alice buys floor(n/1) = n = k jewels.

So, this works.

Case 2: n < k

Impossible, since each jewel costs at least 1 coin.

So, if n < k, output "NO".

Case 3: n > k

Need to set up stalls such that sum floor(n/pi) = k.

Let me consider setting up two stalls.

Set p1 = ceil(n/k), p2 =1.

Wait, no, prices have to be integers between 1 and 10^18.

Wait, p1 and p2 need to be integers.

Let me think differently.

Suppose I set p1 = something, and then p2, p3, etc., such that the sum of floor(n/pi) is k.

This seems too vague.

Maybe I can use the fact that floor(n/pi) is the greatest integer less than or equal to n/pi.

So, perhaps I can choose pi's such that the sum of these floor divisions is k.

But I need a systematic way to choose the pi's.

Let me consider the following approach:

Start with s=1.

Choose p1 such that floor(n/p1) =k.

This requires that floor(n/p1) =k.

Which implies that k <= n/p1 < k+1.

So, n/(k+1) < p1 <= n/k.

If n is divisible by p1, then floor(n/p1) = n/p1.

So, p1 needs to be in (n/(k+1), n/k].

But p1 has to be an integer, so p1 = ceil(n/(k+1)) to floor(n/k).

Wait, n/(k+1) < p1 <= n/k.

So, p1 can be ceil(n/(k+1)) to floor(n/k).

If such a p1 exists, then set s=1, p1.

But, in the first example, n=7, k=3.

n/(k+1) =7/4=1.75, n/k=7/3â‰ˆ2.333.

So, p1 can be ceil(1.75)=2, floor(2.333)=2.

So, p1=2.

Then, floor(7/2)=3, which is exactly k.

So, in this case, s=1, p1=2 works.

In the second example, n=6, k=4.

n/(k+1)=6/5=1.2, n/k=6/4=1.5.

So, p1=ceil(1.2)=2, but 2 >1.5, which is floor(n/k)=1.

So, no p1 exists in this range.

Hence, need to use more than one stall.

Let's try s=2.

Choose p1 and p2.

Let's choose p1=2, p2=1.

As in earlier thought.

Alice buys floor(6/2)=3 jewels from stall 1, spends 6 coins, left with 0 coins.

Then, can't buy from stall 2.

Total jewels:3, which is less than k=4.

Not enough.

Alternatively, p1=3, p2=1.

Floor(6/3)=2 jewels, spends 6 coins, left with 0.

Total jewels:2, still less than 4.

Alternatively, p1=1, p2=1.

Floor(6/1)=6 jewels, which is more than k=4.

Not good.

So, seems impossible with s=2.

Hence, "NO" is the correct output.

Now, in the third example, n=255, k=8.

As shown, s=8, p_i=128,64,32,16,8,4,2,1.

Alice buys one from each, totaling 8 jewels.

This works.

Alternatively, could I use fewer stalls?

For example, s=3: p1=128, p2=64, p3=63.

Alice buys 1 jewel from p1 (128), left with 127.

Buys 1 jewel from p2 (64), left with 63.

Buys 1 jewel from p3 (63), left with 0.

Total jewels:3, which is less than k=8.

Not enough.

Alternatively, s=4: p1=64, p2=64, p3=64, p4=1.

Alice buys 1 from p1 (64), left with 191.

Buys 1 from p2 (64), left with 127.

Buys 1 from p3 (64), left with 63.

Buys 63 from p4 (1), totaling 1+1+1+63=66 jewels, which is more than k=8.

Not good.

So, seems like using multiple stalls with decreasing prices is necessary.

Looking back at the first example, with n=7 and k=3, they used s=10 stalls with prices from 2 to 11.

But in reality, s=2 with p1=2 and p2=1 works, as floor(7/2)=3 jewels, and then no coins left.

But according to their output, they used s=10.

Maybe to show that multiple solutions are possible.

But in the sample input, for n=7 and k=3, both "YES" with s=2 and s=10 are acceptable, as long as s <=60.

Wait, but in the explanation, they bought 3 jewels with s=10.

But according to my calculation, with s=2 and p1=2, p2=1, Alice buys 3 jewels.

Is there a mistake here?

Wait, with p1=2, p2=1:

Alice buys floor(7/2)=3 jewels from p1, spends 6 coins, left with 1 coin.

Then, from p2=1, buys floor(1/1)=1 jewel.

Total jewels:4, which is more than k=3.

So, that doesn't work.

Wait, so my earlier thought was incorrect.

Hence, to make exactly k=3, I need to adjust p2 to be higher than the remaining coins.

For example, set p2=3.

Then, after buying 3 jewels from p1=2, left with 1 coin.

Then, p2=3, which is higher than 1, so can't buy anything.

Total jewels:3.

That works.

So, s=2, p1=2, p2=3 works.

Similarly, s=10 with p1=2 to p10=11 also works.

So, multiple solutions are possible.

Hence, for n=7 and k=3, "YES" with s=2 and p1=2, p2=3 is acceptable.

But in the sample output, they used s=10.

So, it seems that any s <=60 that satisfies the condition is acceptable.

Now, for n=6 and k=4, as earlier, it seems impossible.

Hence, "NO".

For n=255 and k=8, s=8 with p_i=128,64,32,16,8,4,2,1 works.

So, "YES" with s=8.

Now, I need to generalize this.

I need a way to determine, for given n and k, whether it's possible to set up s <=60 stalls with prices p1, p2, ..., ps such that sum floor(n/pi) =k.

And if possible, output "YES", s, and the list of p1, p2, ..., ps.

Otherwise, "NO".

Given the time constraints, I need an efficient solution.

Let me consider the following approach:

First, handle the base cases:

- If n < k: impossible, output "NO".

- If n == k: set s=1, p1=1.

- If n > k:

Try to set up s stalls with prices p1, p2, ..., ps such that sum floor(n/pi) =k.

I need a way to control the sum of floor divisions to be exactly k.

One way to think about it is to set up stalls with decreasing prices, similar to the third example.

For example, set p1 = n - k +1, p2 =1.

Wait, in the code provided, it seems to do something similar.

Let me look at the provided code:

def func_1(n, k):

if n == k:

print('YES')

print(1)

print(1)

return

if n < k:

print('NO')

return

costs = [n - k +1, 1]

h = 0

for i in costs:

curr = n // i

h += curr

n -= i * curr

if h < k:

print('NO')

else:

print('YES')

print(2)

print(*costs)

So, it sets up s=2 stalls, with p1 = n - k +1 and p2=1.

Then, it calculates h = floor(n/p1) + floor((n - floor(n/p1)*p1)/p2).

If h >=k, it outputs "YES" with s=2 and p1, p2.

Else, "NO".

In the first example, n=7, k=3:

p1=7-3+1=5, p2=1.

floor(7/5)=1, spends 5 coins, left with 2 coins.

Then, floor(2/1)=2.

Total jewels:3.

Which matches k=3.

Hence, "YES" with s=2 and p1=5, p2=1.

In the third example, n=255, k=8:

p1=255-8+1=248, p2=1.

floor(255/248)=1, spends 248, left with 7.

floor(7/1)=7.

Total jewels:8.

Which matches k=8.

In the second example, n=6, k=4:

p1=6-4+1=3, p2=1.

floor(6/3)=2, spends 6, left with 0.

floor(0/1)=0.

Total jewels:2 <4.

Hence, "NO".

So, this approach seems to work for these cases.

But is it general?

Let me see.

Suppose n=10, k=3.

p1=10-3+1=8, p2=1.

floor(10/8)=1, spends 8, left with 2.

floor(2/1)=2.

Total jewels:3.

Which matches k=3.

Another example: n=5, k=1.

p1=5-1+1=5, p2=1.

floor(5/5)=1, spends 5, left with 0.

floor(0/1)=0.

Total jewels:1.

Which matches k=1.

Another example: n=100, k=10.

p1=100-10+1=91, p2=1.

floor(100/91)=1, spends 91, left with 9.

floor(9/1)=9.

Total jewels:10.

Which matches k=10.

Seems to work.

But is there any case where this doesn't work?

Wait, suppose n=5, k=2.

p1=5-2+1=4, p2=1.

floor(5/4)=1, spends 4, left with 1.

floor(1/1)=1.

Total jewels:2.

Which matches k=2.

Another case: n=4, k=2.

p1=4-2+1=3, p2=1.

floor(4/3)=1, spends 3, left with 1.

floor(1/1)=1.

Total jewels:2.

Which matches k=2.

Another case: n=3, k=2.

p1=3-2+1=2, p2=1.

floor(3/2)=1, spends 2, left with 1.

floor(1/1)=1.

Total jewels:2.

Which matches k=2.

Another case: n=2, k=2.

p1=2-2+1=1, p2=1.

floor(2/1)=2, spends 2, left with 0.

Total jewels:2.

Which matches k=2.

Another case: n=1, k=1.

p1=1-1+1=1, p2=1.

floor(1/1)=1, spends 1, left with 0.

Total jewels:1.

Which matches k=1.

Seems to work for these cases.

Is there any case where this doesn't work?

Wait, suppose n=1, k=2.

But n <k, so "NO".

Wait, n >=k is already handled.

Wait, n=1, k=1 is acceptable.

n=2, k=2 is acceptable.

n=3, k=2 is acceptable.

n=4, k=2 is acceptable.

n=5, k=2 is acceptable.

n=6, k=4:

p1=6-4+1=3, p2=1.

floor(6/3)=2, spends 6, left with 0.

floor(0/1)=0.

Total jewels:2 <4.

Hence, "NO".

Which matches the second example.

Another case: n=10, k=5.

p1=10-5+1=6, p2=1.

floor(10/6)=1, spends 6, left with 4.

floor(4/1)=4.

Total jewels:5.

Which matches k=5.

Another case: n=15, k=5.

p1=15-5+1=11, p2=1.

floor(15/11)=1, spends 11, left with 4.

floor(4/1)=4.

Total jewels:5.

Which matches k=5.

Seems consistent.

Hence, this approach seems to work.

So, in the function func_1, it sets p1 = n - k +1, p2=1.

Then, calculates h = floor(n/p1) + floor((n - floor(n/p1)*p1)/p2).

If h >=k, output "YES" with s=2 and p1, p2.

Else, "NO".

In the code, it seems to check if h >=k, but in the explanation, it should be h ==k.

Wait, in the function, it sets costs = [n - k +1, 1], then calculates h = floor(n/p1) + floor((n - floor(n/p1)*p1)/p2).

Then, if h <k, print "NO", else print "YES" with s=2 and p1, p2.

But in reality, h should be exactly k.

In the first example, h=3 ==k=3.

In the third example, h=8 ==k=8.

In the second example, h=2 <k=4, so "NO".

So, it seems to work.

But is there a case where h >k?

Wait, in the approach, h = floor(n/p1) + floor((n - floor(n/p1)*p1)/p2).

With p1 = n - k +1 and p2=1.

Let's see:

floor(n/p1) = floor(n/(n - k +1)).

Let me denote m = n - k +1.

So, floor(n/m).

Now, m = n - k +1.

So, m <=n, since k >=1.

Hence, floor(n/m) is at least 1.

Let me compute floor(n/m).

Let q = floor(n/m), r = n - q*m.

Then, h = q + floor(r/p2) = q + floor(r/1) = q + r.

But r = n - q*m.

So, h = q + (n - q*m).

But m = n - k +1.

So, h = q + (n - q*(n - k +1)).

Simplify:

h = q + n - q*n + q*k - q.

h = n - q*n + q*k.

h = n*(1 - q) + q*k.

Wait, not sure if this helps.

Let me consider specific cases.

In the first example, n=7, k=3.

m =7-3+1=5.

floor(7/5)=1, r=7-1*5=2.

h=1 + floor(2/1)=1+2=3==k=3.

In the third example, n=255, k=8.

m=255-8+1=255-8+1=248.

floor(255/248)=1, r=255-1*248=7.

h=1 + floor(7/1)=1+7=8==k=8.

In another case, n=10, k=3.

m=10-3+1=8.

floor(10/8)=1, r=10-1*8=2.

h=1 + floor(2/1)=1+2=3==k=3.

Seems consistent.

Is there a case where h >k?

Suppose n=10, k=4.

m=10-4+1=7.

floor(10/7)=1, r=10-1*7=3.

h=1 + floor(3/1)=1+3=4==k=4.

Another case: n=10, k=5.

m=10-5+1=6.

floor(10/6)=1, r=10-1*6=4.

h=1 + floor(4/1)=1+4=5==k=5.

Another case: n=10, k=2.

m=10-2+1=9.

floor(10/9)=1, r=10-1*9=1.

h=1 + floor(1/1)=1+1=2==k=2.

Seems consistent.

Another case: n=10, k=1.

m=10-1+1=10.

floor(10/10)=1, r=10-1*10=0.

h=1 + floor(0/1)=1+0=1==k=1.

Good.

Another case: n=10, k=6.

m=10-6+1=5.

floor(10/5)=2, r=10-2*5=0.

h=2 + floor(0/1)=2+0=2 <6.

Hence, h <k, so "NO".

Another case: n=10, k=7.

m=10-7+1=4.

floor(10/4)=2, r=10-2*4=2.

h=2 + floor(2/1)=2+2=4 <7.

"NO".

So, in cases where h <k, output "NO".

Hence, the approach seems correct.

Therefore, the provided code seems to correctly implement this logic.

Hence, the answer is **True**.

**Final Solution**

To solve this problem, we need to determine if Bob can set up at most 60 stalls with integer prices such that Alice buys exactly k jewels with her n coins. The solution involves a strategic approach to setting up stall prices to control the number of jewels Alice purchases.

## Approach

1. **Base Cases:**
   - If `n < k`, it's impossible for Alice to buy `k` jewels since each jewel costs at least one coin. Hence, output "NO".
   - If `n == k`, set up a single stall with price `1`. Alice will buy exactly `k` jewels.

2. **General Case (`n > k`):**
   - Set up two stalls with specific prices:
     - First stall price (`p1`): `n - k + 1`
     - Second stall price (`p2`): `1`
   - Calculate the number of jewels Alice buys from each stall:
     - From the first stall: `floor(n / p1)`
     - From the second stall: `floor((n - (floor(n / p1) * p1)) / p2)`
   - Sum these to check if the total jewels bought equals `k`. If yes, output "YES" along with the number of stalls and their prices; otherwise, output "NO".

## Solution Code

```python
def func_1(n, k):
    if n == k:
        print('YES')
        print(1)
        print(1)
        return
    if n < k:
        print('NO')
        return
    p1 = n - k + 1
    p2 = 1
    jewels_from_first = n // p1
    remaining_coins = n - (jewels_from_first * p1)
    jewels_from_second = remaining_coins // p2
    total_jewels = jewels_from_first + jewels_from_second
    if total_jewels < k:
        print('NO')
    else:
        print('YES')
        print(2)
        print(p1, p2)

t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    func_1(n, k)
```

## Explanation

- **Base Cases:**
  - For `n < k`, it's impossible, so output "NO".
  - For `n == k`, set up one stall with price `1` to directly buy `k` jewels.

- **General Case (`n > k`):**
  - By setting `p1 = n - k + 1` and `p2 = 1`:
    - Alice buys `floor(n / p1)` jewels from the first stall.
    - With the remaining coins, she buys `floor(remaining_coins / p2)` jewels from the second stall.
  - If the sum of jewels bought from both stalls equals `k`, output "YES" with the stall setup; otherwise, output "NO".

This approach ensures that we minimize the number of stalls while meeting the condition of buying exactly `k` jewels with `n` coins.