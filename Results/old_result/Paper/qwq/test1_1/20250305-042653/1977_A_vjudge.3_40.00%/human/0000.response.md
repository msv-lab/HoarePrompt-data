Alright, I've got this problem to figure out. Let's see what it's asking. So, Nikita has some cubes and he wants to build a tower using exactly n moves, and at the end, the tower should have exactly m cubes. In each move, he can either add one cube to the top or remove one cube from the top. The tower starts with no cubes.

First, I need to understand what's possible with these moves. Let's think about it step by step.

Imagine n is 1. So, one move. What can he do? He can either add one cube or remove one cube. But if he removes one cube from an empty tower, nothing happens. So, with one move, he can either have 1 cube (if he adds) or 0 cubes (if he removes, but since it's empty, it stays 0). So, for n=1 and m=1, it's "Yes", and for n=1 and m=0, it's also "Yes". For any other m, it's "No".

Wait, but according to the sample input, for n=3 and m=3, it's "Yes". That makes sense because he can add three times: +1, +1, +1, ending with 3 cubes.

For n=2 and m=4, it's "No". Let's see why. If he adds twice: +1, +1, he ends with 2 cubes. If he adds and then removes: +1, -1, he's back to 1 cube. If he removes and then adds: -1 (but since it's empty, nothing happens), then +1, ending with 1 cube. If he removes twice: -1 (nothing), -1 (nothing), still 0 cubes. So, with n=2, possible m values are 0 or 2, but not 4. Hence, "No".

For n=5 and m=3: Let's see. One way could be: +1, +1, +1, +1, -1, ending with 3 cubes. So, "Yes".

From these examples, it seems like the key is to find sequences of +1 and -1 moves that result in exactly m cubes after n moves.

Let me try to generalize this.

Let’s denote:

- a = number of add moves (+1)

- r = number of remove moves (-1)

Then, n = a + r (total moves)

And the final number of cubes is a - r.

We need a - r = m and a + r = n.

We can solve these equations:

From a + r = n,

And a - r = m,

Adding them: 2a = n + m => a = (n + m)/2

Subtracting them: 2r = n - m => r = (n - m)/2

For a and r to be valid, they must be non-negative integers.

So, for the sequence to be possible:

1. (n + m)/2 must be an integer (since a must be integer)

2. (n - m)/2 must be an integer (since r must be integer)

3. a >= 0 and r >= 0, which implies:

- (n + m)/2 >= 0 => n + m >= 0 (which is always true since n and m are positive)

- (n - m)/2 >= 0 => n >= m

Wait, but in the sample input, n=3 and m=3 is "Yes", which satisfies n >= m.

But in the second case, n=2 and m=4, which would require a = (2+4)/2 = 3, r = (2-4)/2 = -1, which is invalid because r < 0. Hence, "No".

In the third case, n=5 and m=3: a = (5+3)/2 = 4, r = (5-3)/2 = 1, which is valid.

So, the general condition seems to be:

- (n + m) is even

- (n - m) is even

- n >= m

But wait, (n + m) and (n - m) being even is equivalent to n and m being both even or both odd. Because:

- If n and m are both even, n + m is even, n - m is even

- If n and m are both odd, n + m is even, n - m is even

- If one is even and the other is odd, n + m is odd, n - m is odd

So, the condition simplifies to: n and m are both even or both odd, and n >= m.

But, in the sample input, n=5 and m=3: both odd, and n >= m, which is "Yes".

n=3 and m=3: both odd, n >= m, "Yes".

n=2 and m=4: both even, n < m, which should be "No".

Wait, but according to our earlier calculation, it's "No" because r would be negative.

But according to the simplified condition, it's both even and n < m, which should be "No".

So, the condition is: n >= m, and n and m are both even or both odd.

But, is there any exception to this?

Let me check with some test cases.

Test case 1: n=1, m=1 -> both odd, n >= m -> "Yes"

n=1, m=0 -> n >= m, but n is odd, m is even -> doesn't satisfy n and m both even or both odd, but in reality, it should be "Yes" because he can add once to get 1, or do nothing (remove from empty) to get 0.

Wait, but according to our earlier reasoning, for n=1, m=0 is "Yes", but according to the condition, n=1 (odd), m=0 (even), not both even or both odd, so it would say "No", which is incorrect.

Hmm, so there's a flaw in the simplified condition.

Let me revisit.

Actually, in the case where m=0, it's possible for any n, because he can add and remove in such a way that they cancel out.

Wait, but according to the earlier examples, for n=2, m=0: he can add and then remove, ending with 0.

For n=1, m=0: he can remove (which does nothing) and then add, or just add and then remove, ending with 0.

So, m=0 is possible for any n.

But according to the condition n >= m and both even or both odd, m=0 is even, n can be any.

So, for n odd and m=0 (even), it would say "No", but in reality, it's "Yes".

Wait, but in n=1, m=0 should be "Yes", but according to the condition, n=1 (odd), m=0 (even), not both even or both odd, so it would say "No". But actually, it should be "Yes".

So, perhaps the condition needs to be adjusted.

Let me think differently.

Given a and r as above, a = (n + m)/2, r = (n - m)/2.

We need a and r to be non-negative integers.

So, the conditions are:

1. (n + m) is even

2. (n - m) is even

3. a >= 0 and r >= 0, which means n >= m

But, in the case where m=0, n can be any value, and a = n/2, r = n/2.

For n even, a and r are integers.

For n odd, a and r are not integers, but in reality, for n odd, m=0 is still possible because he can have an equal number of adds and removes, with perhaps one extra remove that does nothing.

Wait, but if n is odd and m=0, a = (n + 0)/2 = n/2, which is not integer if n is odd. So, it should be invalid.

But in reality, for n=1, m=0: remove (does nothing), then add, but n=1 allows only one move: add or remove.

Wait, n=1, m=0: if he removes from an empty tower, it remains empty, so yes, it's possible.

But according to the formula, a = (1 + 0)/2 = 0.5, which is invalid.

So, perhaps the formula needs adjustment for the case when the tower is empty and remove operations are ignored.

This is getting complicated.

Maybe I need to think in terms of effective moves.

Each add operation increases the cube count by 1.

Each remove operation decreases the cube count by 1, but only if there is at least one cube.

So, the effective removals are min(r, current cubes).

This makes it tricky to model directly with simple equations.

Perhaps a better approach is to consider the maximum and minimum possible cubes after n moves.

The maximum cubes he can have is if he adds every time: m = n.

The minimum is if he removes every time, but considering that removing from an empty tower does nothing.

So, for n moves:

- If n <= cubes, he can remove to decrease the cubes, but since starting from 0, removing doesn't do anything initially.

Wait, starting from 0 cubes:

- First move: add -> 1

- Second move: add -> 2

- ...

- After k adds: k cubes

- Then, if he removes, he can reduce by 1 each time, but not below 0.

So, the minimal cubes after n moves is max(0, n - m), but I'm getting confused.

Wait, perhaps it's better to think in terms of possible parities.

From the earlier analysis, a = (n + m)/2 must be integer, and r = (n - m)/2 must be integer, and a >=0, r >=0.

But in the case where m=0 and n is odd, a = n/2 is not integer, but in reality, he can have m=0 with n=1: remove (does nothing), or add and then remove.

Wait, but with n=1, m=0: if he removes, tower remains 0; if he adds, tower becomes 1.

So, to have m=0 after n=1 move, he must do remove, which does nothing, so tower remains 0.

Hence, it's possible.

But according to the formula, a = (1 + 0)/2 = 0.5, which is invalid.

So, perhaps the formula needs to account for the fact that removes from an empty tower are无效的, so they don't change the cube count.

This complicates things.

Maybe I need to think recursively or dynamically.

Let's consider f(n, m): whether it's possible to have m cubes after n moves.

Base case:

- f(0, 0) = True (no moves, no cubes)

- f(0, m) = False for m > 0 (no moves, can't have cubes)

Recursive step:

- f(n, m) = f(n-1, m-1) (if he adds) or f(n-1, m+1) (if he removes, but only if m+1 <= current cubes)

Wait, this is getting too complicated for an interview setting.

Perhaps I should look back at the provided program and see what logic it's using.

Looking at the program:

def func():

t = int(input())

for i in range(t):

(n, m) = [int(i) for i in input().split()]

if n == m:

print('Yes')

elif m > n:

print('No')

elif m == n - 1:

print('Yes')

elif m % 2 == 0 and n % 2 == 0:

print('Yes')

elif m % 2 != 0 and n % 2 != 0:

print('Yes')

else:

print('No')

So, the logic is:

- If n == m, then "Yes"

- Else if m > n, "No"

- Else if m == n - 1, "Yes"

- Else if m and n are both even, "Yes"

- Else if m and n are both odd, "Yes"

- Else, "No"

Let's test this logic with the sample inputs.

Sample Input 1:

3

3 3 -> n == m, "Yes" (correct)

2 4 -> m > n, "No" (correct)

5 3 -> m == n - 2, but n=5, m=3: n and m both odd, so "Yes" (correct)

Another test case: n=1, m=0

According to the program:

n != m (1 != 0), m <= n (0 <=1), m != n-1 (0 != 0), n and m are both odd? n=1 odd, m=0 even, so move to next condition: m % 2 !=0 and n %2 !=0? m=0 even, n=1 odd, so "No". But in reality, it should be "Yes".

Wait, but earlier we saw that it's possible to have m=0 with n=1 by doing a remove operation, which does nothing, so tower remains 0.

Hence, the program would output "No", but it should be "Yes". So, the program is incorrect in this case.

Another test case: n=2, m=0

According to the program:

n != m (2 != 0), m <= n (0 <=2), m != n-1 (0 !=1), n and m are both even, so "Yes".

In reality, yes, it's possible: add and then remove, ending with 0.

So, "Yes" is correct.

Another test case: n=3, m=2

According to the program:

n != m (3 !=2), m <= n (2 <=3), m != n-1 (2 !=2), m %2 ==0 and n%2 ==1, so move to next condition: m%2 !=0 and n%2 !=0? m=2 even, n=3 odd, so "No".

Is this correct? Let's see.

If n=3, m=2: possible sequences.

Option 1: add, add, add -> 3

Option 2: add, add, remove -> 2

Option 3: add, remove, add -> 2

Option 4: add, remove, remove -> 0

Option 5: remove, add, add -> 2 (remove does nothing)

Option 6: remove, add, remove -> 0

Option 7: remove, remove, add -> 0

Option 8: remove, remove, remove -> 0

So, it's possible to end with 2 cubes: sequences 2 and 3 and 5.

Hence, "Yes". But according to the program, it's "No". So, incorrect.

Another test case: n=4, m=2

According to the program:

n != m (4 !=2), m <= n (2 <=4), m == n-1? 2 !=3, so no. m even, n even, so "Yes".

Is this correct? Yes, because he can add, add, add, remove -> 3 then remove ->2.

So, "Yes" is correct.

Another test case: n=4, m=1

According to the program:

n != m (4 !=1), m <= n (1 <=4), m != n-1 (1 !=3), m%2 ==1, n%2 ==0, so "No".

Is this correct? Let's see.

Possible sequences:

add, add, add, remove ->3 then remove ->2

add, add, remove, add ->2 then add ->3

add, remove, add, add ->2 then add ->3

add, add, remove, remove ->2 then remove ->1

So, yes, it's possible to end with 1 cube. But according to the program, it's "No". So, incorrect.

It seems that the program is missing some cases where m != n or m != n-1, but m is still achievable.

Perhaps a better approach is to consider that the difference between n and m must be even, and n >= m.

Wait, in the earlier analysis, we had a = (n + m)/2 and r = (n - m)/2, both need to be integers and non-negative.

So, the conditions are:

- (n + m) % 2 == 0

- (n - m) % 2 == 0

- n >= m

But, in the case where m=0 and n is odd, (n + 0) is odd, so (n + m)/2 is not integer, but in reality, it's possible to have m=0 with n odd by doing remove operations that don't affect the tower.

Hence, the condition needs to be adjusted to account for m=0 being always achievable, regardless of n.

Wait, but m=0 is achievable for any n, because he can do any sequence of adds and removes that cancel each other out, or just do remove operations which do nothing if the tower is empty.

Hence, perhaps the condition should be:

- If m == 0, then "Yes"

- Else, if n >= m and (n - m) % 2 == 0

Wait, let's test this.

For n=3, m=2: n >= m and (3 - 2) =1, which is odd, so "No". But earlier we saw it's possible, so this is incorrect.

Wait, in that case, a = (3 + 2)/2 = 2.5, not integer, but in reality, it's possible, so the condition is insufficient.

Alternatively, perhaps it's n >= m and (n - m) <= m

Wait, not sure.

Maybe I need to think differently.

Let’s consider that the number of remove operations cannot exceed the number of add operations at any point, because removing from an empty tower does nothing.

This is similar to the concept of Catalan numbers or balanced parentheses.

But that might be too complicated for this problem.

Alternatively, perhaps the number of remove operations cannot exceed m, since he can't remove more than he has added.

But, in reality, he can remove more than m if he has added more and then removed some, as long as the tower doesn't go below zero.

This is getting too involved.

Perhaps the best way is to simulate the process.

But for the purpose of this problem, with time constraints, maybe the provided program is acceptable, even if it's not perfect.

Alternatively, perhaps the condition is that n >= m and either both are even or both are odd.

But, as we saw, in n=3, m=2, which are both even or both odd? n=3 odd, m=2 even, so "No" according to this, but in reality, it's "Yes".

Hence, this condition is insufficient.

Alternatively, perhaps n >= m and (n - m) is even.

Wait, in n=3, m=2: n - m =1, which is odd, but it's possible, so不符.

Wait, perhaps it's n >= m and (n + m) is even.

In n=3, m=2: n + m =5, which is odd, "No"

But in reality, it's "Yes", so still incorrect.

Alternatively, perhaps n >= m and (n - m) <= m.

In n=3, m=2: n - m =1 <=2, "Yes"

In n=2, m=4: n - m =-2 not <=4, "No"

In n=1, m=0: n - m =1 <=0, "No", but should be "Yes"

So, still not correct.

This is tricky.

Maybe the condition is:

- If m ==0, then "Yes"

- Else if n >= m and (n - m) %2 ==0, then "Yes"

- Else, "No"

But, in n=3, m=2: n >= m and (3-2)=1, which is odd, so "No", but should be "Yes"

Hence, this doesn't work.

Alternatively, perhaps it's n >= m and (n + m) %2 ==0

In n=3, m=2: 3+2=5, odd, "No"

But should be "Yes", so still incorrect.

I think the only way to be sure is to check if a and r are integers and non-negative.

So, a = (n + m)/2 >=0 and integer

r = (n - m)/2 >=0 and integer

Hence, n + m is even and n - m is even, and n >= m.

This would cover most cases, but as we saw, m=0 is a special case where n can be odd, but according to this, n + m =n is odd, so a is not integer, but in reality, it's possible.

Hence, the condition needs to be adjusted for m=0.

Perhaps, if m=0, then it's "Yes" for any n.

Else, if m >0, then n >= m and (n + m) %2 ==0 and (n - m) %2 ==0.

Wait, (n + m) %2 ==0 and (n - m) %2 ==0 is equivalent to n and m both even or both odd.

So, the condition is:

- If m ==0, "Yes"

- Else if n >= m and n and m are both even or both odd, "Yes"

- Else, "No"

Let's test this.

n=3, m=2: m !=0, n >= m, n=3 odd, m=2 even, not both even or both odd, so "No", but should be "Yes"

Hence, still incorrect.

Another approach: think in terms of steps.

Each add operation increases the cube count by 1.

Each remove operation decreases the cube count by 1, if possible.

So, the final cube count is the number of add operations minus the number of remove operations that were effective.

Effective remove operations are min(r, a)

So, m = a - min(r, a)

But r = n - a

So, m = a - min(n - a, a)

This is a bit complicated, but perhaps we can consider two cases:

1. If r <= a, i.e., n - a <= a => n <= 2a, then m = a - (n - a) = 2a - n

So, m = 2a - n

And since m >=0, 2a - n >=0 => a >= n/2

Also, a <=n, since a + r =n

So, a is in [ceil(n/2), n]

2. If r > a, i.e., n - a > a => n > 2a, then m = a - a =0

So, if n > 2a, m=0

But a can be from 0 to n.

Wait, but in this case, m=0 when n > 2a.

But a can be from 0 to n.

So, for m=0, it's possible when n > 2a, for some a.

But this seems too vague.

Perhaps better to consider that m can be from max(0, n - 2a) to min(n, a)

This is getting too complicated.

At this point, I think the best approach is to accept that the provided program might not be perfect, but it's a reasonable attempt.

Given time constraints, perhaps it's acceptable.

But based on the analysis above, the program incorrectly answers "No" for some cases that should be "Yes", such as n=3, m=2.

Hence, the program is incorrect.

**Final Answer**

\boxed{\text{False}}