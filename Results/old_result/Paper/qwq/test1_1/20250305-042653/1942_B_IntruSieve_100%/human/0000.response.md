Alright, I've got this problem to solve. Let's see what it's asking for. So, Farmer John has a permutation p of numbers from 0 to n-1, and he gives Bessie an array a, where each a_i is calculated as the MEX of the first i elements of p minus p_i. My job is to reconstruct the permutation p from the array a.

First, I need to understand what MEX means. MEX stands for Minimum EXcluded number, which is the smallest non-negative integer not present in the given array. For example, MEX of [1,2,3] is 0 because 0 is the smallest non-negative integer not in the array. MEX of [3,1,0] is 2, since 0 and 1 are present, but 2 is missing.

So, for each position i in the permutation p, a_i = MEX(p_1 to p_i) - p_i. I need to find p given a.

The problem says that there is at least one valid p for the given a, so I don't have to worry about invalid inputs.

Let me think about how to approach this. Since p is a permutation, each number from 0 to n-1 appears exactly once in p. I need to find which number goes into each position based on the a array.

Let me consider the first element p_1. The MEX of p_1 alone is the smallest non-negative integer not equal to p_1. So, if p_1 is x, then MEX(p_1) is 0 if x is not 0, otherwise it's 1. Wait, no. If p_1 is x, then MEX is 0 if x is not 0, else it's 1.

Wait, let's take an example. If p_1 is 0, then MEX is 1, because 0 is present. So a_1 = 1 - 0 = 1. If p_1 is 1, then MEX is 0, so a_1 = 0 - 1 = -1. If p_1 is 2, MEX is 0, so a_1 = 0 - 2 = -2, and so on.

So, for the first element, a_1 = MEX(p_1) - p_1.

Similarly, for the second element, a_2 = MEX(p_1, p_2) - p_2.

And so on, up to a_n = MEX(p_1, p_2, ..., p_n) - p_n.

I need to find p given a.

The problem mentions that at least one valid p exists for the given a, so I don't need to handle cases where no solution exists.

Let me think about how to reconstruct p.

I can try to iterate through the array a and determine p_i step by step.

Let me consider the first element again.

If a_1 is positive, then MEX(p_1) - p_1 is positive, which implies that MEX(p_1) > p_1.

From the earlier observation, if p_1 is x, then MEX(p_1) is 0 if x > 0, else 1.

Wait, no. If p_1 is 0, then MEX is 1.

If p_1 is 1, then MEX is 0.

If p_1 is 2, then MEX is 0.

Wait, in general, MEX(p_1) is 0 if p_1 is not 0, else 1.

So, a_1 = MEX(p_1) - p_1.

If p_1 = 0, a_1 = 1 - 0 = 1.

If p_1 = 1, a_1 = 0 - 1 = -1.

If p_1 = 2, a_1 = 0 - 2 = -2.

So, for a_1 = 1, p_1 must be 0.

For a_1 = -1, p_1 must be 1.

For a_1 = -2, p_1 must be 2.

And so on.

So, in general, if a_1 > 0, p_1 = a_1 - MEX(p_1).

Wait, no. From the above, it seems that if a_1 = 1, p_1 = 0.

Similarly, if a_1 = -1, p_1 = 1.

If a_1 = -2, p_1 = 2.

So, p_1 = -a_1 if a_1 < 0, else p_1 = MEX value minus a_1.

Wait, I'm getting confused.

Let me try to find a general formula for p_i.

Given a_i = MEX(p_1 to p_i) - p_i.

So, p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) is a function of p_i, which is what I'm trying to find.

This seems circular.

Maybe I need to find a way to compute MEX(p_1 to p_i) without knowing p_i.

Wait, but p_i is part of the MEX calculation.

This seems tricky.

Let me think differently.

Perhaps I can keep track of the numbers that have been used so far and determine the MEX at each step.

Let me try to simulate the process.

Initialize a set to keep track of the numbers used so far.

Initialize a variable minn to 0, which will represent the current MEX.

Iterate through the array a:

For each a_i:

If a_i is positive, then MEX(p_1 to p_i) = a_i + p_i.

But since p_i is unknown, this doesn't help directly.

Wait, from p_i = MEX(p_1 to p_i) - a_i.

But I don't know MEX yet.

Maybe I need to consider that MEX is always the smallest non-negative integer not in the used set.

So, at each step, MEX is minn, and minn is incremented until it's not in the used set.

Wait, but p_i could be any unused number.

This is getting complicated.

Let me look at the example provided.

In the first test case:

n = 5

a = [1, 1, -2, 1, 2]

The expected p is [0,1,4,2,3]

Let's verify:

For i=1:

p_1 = 0

MEX(p_1) = 1 (since 0 is used)

a_1 = 1 - 0 = 1

For i=2:

p_1=0, p_2=1

MEX(0,1)=2 (0 and 1 are used)

a_2=2-1=1

For i=3:

p_1=0, p_2=1, p_3=4

MEX(0,1,4)=2 (0,1,4 are used; 2 is missing)

a_3=2-4=-2

For i=4:

p_1=0, p_2=1, p_3=4, p_4=2

MEX(0,1,4,2)=3

a_4=3-2=1

For i=5:

p_1=0, p_2=1, p_3=4, p_4=2, p_5=3

MEX(0,1,4,2,3)=5

a_5=5-3=2

So, a=[1,1,-2,1,2], which matches the input.

Now, how can I reconstruct p from a?

Looking at the first element a_1=1.

From the earlier observation, if a_1=1, then p_1=0.

Because if p_1=0, MEX=1, so a_1=1-0=1.

If p_1=1, MEX=0, a_1=0-1=-1.

If p_1=2, MEX=0, a_1=0-2=-2.

So, for a_1=1, p_1 must be 0.

Similarly, for a_1=-1, p_1=1.

For a_1=-2, p_1=2.

So, in general, for a_1=k, p_1=-k if k<0, else p_1=MEX - k.

Wait, but in the first case, a_1=1, p_1=0, which is MEX=1 - p_1=1 - 0=1.

Similarly, a_2=1, p_2=1, MEX=2 -1=1.

a_3=-2, p_3=4, MEX=2 -4=-2.

a_4=1, p_4=2, MEX=3 -2=1.

a_5=2, p_5=3, MEX=5 -3=2.

So, perhaps I can iterate through a, and for each a_i, compute p_i = MEX(p_1 to p_i) - a_i.

But I don't know MEX yet.

Wait, but MEX is the smallest non-negative integer not in p_1 to p_i.

So, perhaps I can keep track of the used numbers and find the MEX at each step.

Let me try to formalize this.

Initialize an empty set used.

Initialize minn=0.

For each a_i in a:

if a_i > 0:

p_i = minn

used.add(p_i)

while minn in used:

minn +=1

else:

p_i = MEX - a_i

Wait, but MEX is minn.

So, p_i = minn - a_i

used.add(p_i)

while minn in used:

minn +=1

Let me test this with the first test case.

Test case 1:

n=5

a=[1,1,-2,1,2]

Initialize used={}, minn=0

i=1, a_1=1 >0:

p_1=minn=0

used={0}

minn=1 (since 0 is used)

i=2, a_2=1 >0:

p_2=minn=1

used={0,1}

minn=2 (since 2 is not used)

i=3, a_3=-2 <0:

p_3=minn - a_3 = 2 - (-2) = 4

used={0,1,4}

minn=2 (since 2 is not used; note that minn was 2 already)

i=4, a_4=1 >0:

p_4=minn=2

used={0,1,4,2}

minn=3 (since 3 is not used)

i=5, a_5=2 >0:

p_5=minn=3

used={0,1,4,2,3}

minn=4 (since 4 is not used)

So, p=[0,1,4,2,3], which matches the example.

Let's check another example.

Test case 2:

n=5

a=[1,1,1,1,1]

Following the same approach:

Initialize used={}, minn=0

i=1, a_1=1 >0:

p_1=0

used={0}

minn=1

i=2, a_2=1 >0:

p_2=1

used={0,1}

minn=2

i=3, a_3=1 >0:

p_3=2

used={0,1,2}

minn=3

i=4, a_4=1 >0:

p_4=3

used={0,1,2,3}

minn=4

i=5, a_5=1 >0:

p_5=4

used={0,1,2,3,4}

minn=5

So, p=[0,1,2,3,4], which is another valid permutation.

Test case 3:

n=3

a=[-2,1,2]

Initialize used={}, minn=0

i=1, a_1=-2 <0:

p_1=minn - a_1 = 0 - (-2) = 2

used={2}

minn=0 (since 0 is not used)

i=2, a_2=1 >0:

p_2=minn=0

used={2,0}

minn=1 (since 1 is not used)

i=3, a_3=2 >0:

p_3=minn=1

used={2,0,1}

minn=3 (since 3 is not used)

So, p=[2,0,1], which matches the third example.

This seems to work for the given examples.

Let me see if this logic holds in general.

Suppose a_i > 0:

Set p_i = minn

Add p_i to used

Increment minn until it's not in used

Else (a_i <= 0):

Set p_i = minn - a_i

Add p_i to used

Increment minn until it's not in used

I need to ensure that p_i is unique and within 0 to n-1.

Since we're constructing p by assigning p_i and keeping track of used numbers, and minn is the smallest unused number, this should ensure that p is a permutation of 0 to n-1.

Also, from the problem statement, it's guaranteed that at least one valid p exists for the given a.

So, this approach seems correct.

Now, looking at the given program:

for _ in range(int(input())):

func_1()

def func_1():

n = int(input())

arr = list(map(int, input().split()))

mex = []

minn = 0

used = {}

for i in range(n):

if arr[i] > 0:

mex.append(minn)

used[minn] = True

while minn in used:

minn += 1

else:

mex.append(abs(arr[i] - minn))

used[abs(arr[i] - minn)] = True

for itm in mex:

print(itm, end=' ')

print()

Wait, this doesn't look right.

In the code, they are appending to mex list based on arr[i].

If arr[i] > 0:

mex.append(minn)

used[minn] = True

while minn in used:

minn += 1

else:

mex.append(abs(arr[i] - minn))

used[abs(arr[i] - minn)] = True

But according to my reasoning, when arr[i] > 0, p_i = minn

and when arr[i] <= 0, p_i = minn - arr[i]

But in the code, they are appending to mex, which should be p.

Also, they are using a dictionary used to keep track of used numbers.

Wait, but in the code, the list is named mex, but it should be p.

Also, in the else clause, they are appending abs(arr[i] - minn), but according to my logic, it should be minn - arr[i].

But arr[i] can be negative, so arr[i] - minn could be negative, but p_i should be non-negative.

Wait, but in the test case, a_i can be negative, as shown in the first test case where a_3=-2.

But p_i should be between 0 and n-1.

So, p_i = minn - a_i should be non-negative.

Given that a_i can be negative, minn is non-negative, so p_i = minn - a_i could be larger than minn.

Wait, in the first test case, for a_3=-2, p_3=4, which is minn=2 - (-2)=4.

So, p_i = minn - a_i.

But in the code, they are appending abs(arr[i] - minn), which is abs(a_i - minn).

In the first test case, for i=3, a_i=-2, minn=2, abs(-2 - 2)=4, which matches p_3=4.

But is this always correct?

In the third test case, for i=1, a_i=-2, minn=0, abs(-2 - 0)=2, which is p_1=2.

For i=2, a_i=1, minn=0, p_i=minn=0, which matches.

For i=3, a_i=2, minn=1, p_i=1, which matches.

So, using abs(a_i - minn) seems to work in these cases.

But is this always correct?

Let me consider another example.

Suppose n=4

a=[1, -1, -2, 1]

Following the code's logic:

Initialize used={}, minn=0

i=1, a_1=1 >0:

p_1=minn=0

used={0}

minn=1

i=2, a_2=-1 <0:

p_2=abs(-1 - 1)=2

used={0,2}

minn=1 (since 1 is not used)

i=3, a_3=-2 <0:

p_3=abs(-2 -1)=3

used={0,2,3}

minn=1 (since 1 is not used)

i=4, a_4=1 >0:

p_4=minn=1

used={0,2,3,1}

minn=4

So, p=[0,2,3,1]

Let's verify:

p_1=0: MEX=1, a_1=1-0=1

p_1=0, p_2=2: MEX=1, a_2=1-2=-1

p_1=0, p_2=2, p_3=3: MEX=1, a_3=1-3=-2

p_1=0, p_2=2, p_3=3, p_4=1: MEX=4, a_4=4-1=3

Wait, but in the example I just made, a_4 should be 4-1=3, but in my a array, it's 1.

Wait, that's a mistake.

If p_1=0, p_2=2, p_3=3, p_4=1:

a_1=1-0=1

a_2=1-2=-1

a_3=1-3=-2

a_4=4-1=3

But in my supposed a array, it's [1, -1, -2, 1], which doesn't match.

So, this suggests that my example is invalid because a_4 should be 3, not 1.

But the problem states that the input is given in such a way that at least one valid p exists, so I shouldn't worry about invalid inputs.

But in this case, if a_4=1, then p_4 should be such that MEX(p_1 to p_4) - p_4 =1.

Given p_1=0, p_2=2, p_3=3, p_4=x, MEX would be 1 if x=1, since 0,2,3 are used.

So, MEX=1, a_4=1 - x=1 => x=0, but 0 is already used.

Wait, that can't be.

Wait, if p_4=1, MEX=4, since 0,2,3,1 are used, so MEX=4, a_4=4-1=3.

But in my supposed a array, a_4=1, which doesn't match.

So, this suggests that a=[1,-1,-2,1] is invalid for n=4.

But according to the problem, the input is guaranteed to have at least one valid p.

So, in this case, a=[1,-1,-2,3] would be valid, with p=[0,2,3,1].

Therefore, in my earlier example, a_4 should be 3, not 1.

Hence, the code's logic seems to work.

So, in the code, they are using mex list to store p_i.

But in my reasoning, I named it p.

Also, they are using a dictionary used to keep track of used numbers, which is fine.

They are using minn to track the current MEX.

In the if arr[i] >0 clause, they set p_i=minn, add it to used, and increment minn until it's not in used.

In the else clause, they set p_i=abs(arr[i] - minn), add it to used, and increment minn until it's not in used.

In my earlier reasoning, I set p_i=minn - arr[i], which is equivalent to abs(arr[i] - minn) when arr[i] <0.

Because arr[i] is negative, minn is non-negative, so minn - arr[i] = minn - (-|a_i|) = minn + |a_i|.

But in the code, they are using abs(arr[i] - minn), which for arr[i]<0, is minn + |a_i|.

Wait, no.

abs(arr[i] - minn) = |arr[i] - minn|

If arr[i] <0, say arr[i]=-k, then abs(-k - minn) = | -k - minn | = k + minn, if k and minn are non-negative.

Wait, but in the first test case, arr[i]=-2, minn=2, abs(-2 -2)=4, which matches p_i=4.

Similarly, in the third test case, arr[i]=-2, minn=0, abs(-2 -0)=2, which matches p_i=2.

So, it seems that using abs(arr[i] - minn) works in these cases.

But in my earlier manual example, where a=[1,-1,-2,3], n=4, p=[0,2,3,1], it also works.

So, perhaps this is a correct approach.

But I'm still a bit uneasy about it, because I don't fully understand why abs(arr[i] - minn) gives the correct p_i.

In my earlier reasoning, I thought p_i = minn - arr[i], which for arr[i]<0 would be minn - (-|a_i|) = minn + |a_i|, which is the same as abs(arr[i] - minn) since arr[i] is negative.

But in the code, they are using abs(arr[i] - minn), which works for both arr[i]>0 and arr[i]<=0.

Wait, but in the if arr[i]>0 clause, they set p_i=minn, which aligns with my earlier reasoning that p_i=minn when arr[i]>0.

In the else clause, they set p_i=abs(arr[i] - minn), which, as shown in the examples, gives the correct p_i.

So, perhaps this is a correct implementation.

I need to verify this with another example.

Let's consider n=3, a=[1,1,1]

Following the code:

Initialize used={}, minn=0

i=1, a_1=1>0:

p_1=minn=0

used={0}

minn=1

i=2, a_2=1>0:

p_2=minn=1

used={0,1}

minn=2

i=3, a_3=1>0:

p_3=minn=2

used={0,1,2}

minn=3

So, p=[0,1,2], which is correct.

Another example: n=4, a=[1,-1,-2,3]

Initialize used={}, minn=0

i=1, a_1=1>0:

p_1=minn=0

used={0}

minn=1

i=2, a_2=-1<0:

p_2=abs(-1 -1)=2

used={0,2}

minn=1 (since 1 is not used)

i=3, a_3=-2<0:

p_3=abs(-2 -1)=3

used={0,2,3}

minn=1 (since 1 is not used)

i=4, a_4=3>0:

p_4=minn=1

used={0,2,3,1}

minn=4

So, p=[0,2,3,1], which is correct.

Hence, the code seems to be correct.

Therefore, the answer is Correctness: **True**

**Final Solution**
To solve this problem, we need to reconstruct a permutation of integers from 0 to n-1 based on a given array `a`, where each element `a_i` is calculated as the MEX of the initial segment of the permutation up to position `i` minus the element at that position.

### Approach

1. **Understanding MEX**: MEX of an array is the smallest non-negative integer not present in that array.
2. **Reconstructing the Permutation**:
    - We maintain a set of used numbers and a variable to track the current MEX.
    - For each element in `a`:
        - If `a_i` is positive, the corresponding permutation element is the current MEX, and we update the used set and increment the MEX.
        - If `a_i` is non-positive, we calculate the permutation element as the absolute difference between `a_i` and the current MEX, ensure it's not already used, and update accordingly.

### Solution Code

```python
for _ in range(int(input())):
    func_1()

def func_1():
    n = int(input())
    arr = list(map(int, input().split()))
    mex = []
    minn = 0
    used = {}
    for i in range(n):
        if arr[i] > 0:
            mex.append(minn)
            used[minn] = True
            while minn in used:
                minn += 1
        else:
            mex.append(abs(arr[i] - minn))
            used[abs(arr[i] - minn)] = True
            while minn in used:
                minn += 1
    for itm in mex:
        print(itm, end=' ')
    print()
```

### Explanation

1. **Initialization**:
    - Read the number of test cases.
    - For each test case, read `n` and the array `a`.
2. **Permutation Construction**:
    - Use a list `mex` to build the permutation.
    - Use a dictionary `used` to track numbers already used in the permutation.
    - Use a variable `minn` to track the current MEX.
3. **Processing Each Element**:
    - If `a_i` is positive:
        - Append the current MEX to `mex`.
        - Mark it as used.
        - Increment `minn` until it's not used.
    - If `a_i` is non-positive:
        - Calculate the permutation element as `abs(a_i - minn)`.
        - Mark it as used.
        - Increment `minn` until it's not used.
4. **Output the Permutation**:
    - Print the constructed permutation for each test case.

This approach ensures that the permutation is correctly reconstructed based on the given array `a` and the MEX conditions.