Alright, I've got this problem to solve. Let's see what it's asking for. So, it's about an n x n chessboard where I'm placing white rooks and the computer is placing black rooks in a specific way. The goal is to find out how many different final configurations are possible after I've already made k moves, and the computer has mirrored those moves accordingly.

First, I need to understand the rules of the game:

1. I place a white rook on the board in a position (r, c) where no other rook, regardless of color, is attacking that position. Rooks attack each other if they are in the same row or column.

2. The computer then mirrors my move by placing a black rook at (c, r), provided r ≠ c. If r = c, the computer skips its turn.

3. We continue taking turns until no more valid moves are possible.

Given that I've already made k moves, and the computer has mirrored them appropriately, I need to find out how many different final configurations can arise from this point onward.

The input consists of multiple test cases, each with n (the size of the chessboard) and k (the number of moves I've already made). Then, for each of the k moves, I get the positions (r, c) where I've placed my white rooks.

The output should be the number of possible final configurations modulo 10^9 + 7 for each test case.

Looking at the example provided:

Input:

3

4 1

1 2

8 1

7 6

1000 4

4 4

952 343

222 333

90 91

Output:

3

331

671968183

In the first test case, n=4 and k=1 with my move at (1,2). The computer mirrors it to (2,1). From there, there are 3 possible configurations.

I need to find a general way to calculate this for any n and k, given the constraints.

Constraints:

- t ≤ 10^4

- n ≤ 3*10^5

- k ≤ n

- Sum of n over all test cases ≤ 3*10^5

Given these constraints, efficiency is key. I need an approach that can handle up to 10^4 test cases quickly.

Let me try to model this problem.

First, observe that placing a rook at (r, c) affects the entire row r and column c, preventing any other rooks from being placed there.

Moreover, since the computer mirrors my move at (c, r), that also affects row c and column r.

So, each of my moves at (r, c) effectively blocks row r, column c, row c, and column r, provided that (r, c) ≠ (c, r).

Wait, if r = c, then the computer skips its turn, but in this problem, it's guaranteed that all moves are valid, so I don't need to worry about that.

Given that, for each of my k moves at (r, c), the computer places a rook at (c, r), which might be the same cell if r = c, but according to the problem, if r = c, the computer skips its turn. So, in the case r = c, only my rook is placed, and the computer does nothing.

But in the problem statement, it's guaranteed that all moves are valid, so I can assume that no two rooks are attacking each other.

I need to find out how many different ways the game can proceed from this point, considering that I always make the next move, placing a white rook, and the computer mirrors it.

Wait, actually, the problem says: "You have already played k moves with the computer (the computer tries to mirror these moves too), and you must continue playing the game until there are no valid moves remaining."

Wait, the way I interpret it is that I make a move, then the computer mirrors it, and this continues until no more moves are possible.

But in the problem statement, it says: "You have already played k moves with the computer (the computer tries to mirror these moves too), and you must continue playing the game until there are no valid moves remaining."

So, it seems that up to this point, I've made k moves, and for each of my moves, the computer has mirrored it, provided that r ≠ c.

Now, I need to continue the game until no more valid moves are possible, and count how many different final configurations are possible.

I need to think about the state of the board after k moves have been made by me and mirrored by the computer.

Each move I make blocks certain rows and columns from future moves, and the computer's mirror move does the same.

I need to find a way to model the remaining available positions and count the number of ways to place rooks in these positions, considering the mirroring constraint.

This seems complicated. Maybe there's a smarter way to approach this.

Let me consider the symmetry in the problem. Since the computer mirrors my moves, there is a symmetry along the diagonal.

In fact, the positions (r, c) and (c, r) are related through this symmetry.

I should think about pairs of positions (r, c) and (c, r), where r ≠ c.

When I place a rook at (r, c), the computer places one at (c, r), provided r ≠ c.

If r = c, then only my rook is placed, and the computer does nothing.

So, perhaps I can think in terms of placing pairs of rooks symmetrically, except when r = c.

But in the problem, it's guaranteed that all moves are valid, so no two rooks are attacking each other.

I need to find the number of ways to continue placing rooks under these constraints until no more moves are possible.

This seems tricky. Maybe I can find a mathematical formula or pattern that allows me to compute this efficiently.

Looking at the sample input and output:

For n=4, k=1 with my move at (1,2), and computer's move at (2,1), there are 3 possible configurations.

In the explanation, it shows three possible ways to continue the game:

1. Place a white rook at (3,4), computer places at (4,3).

2. Place a white rook at (4,3), computer places at (3,4).

3. Place a white rook at (3,3), and then at (4,4), or vice versa, but both result in the same configuration.

So, in total, 3 distinct configurations.

I need to find a general way to calculate this for any n and k.

Let me try to find a pattern or formula.

First, consider the case when k=0, meaning no moves have been made yet.

In this case, the number of possible final configurations would be the number of ways to place rooks such that no two attack each other, with the mirroring constraint.

Wait, but the problem specifies that k moves have already been made, and I need to continue the game from there.

I need to find a way to compute the number of ways to place the remaining rooks, considering the mirroring constraint.

Perhaps I can think in terms of available rows and columns that are not yet blocked.

Let me try to model the problem in terms of available rows and columns.

Initially, all rows and columns are available.

Each time I place a rook at (r, c), I block row r and column c.

The computer then places a rook at (c, r), which blocks row c and column r.

So, effectively, placing a rook at (r, c) blocks rows r and c, and columns r and c.

Wait, but in chessboard terms, placing a rook at (r, c) blocks the entire row r and column c.

Similarly, placing a rook at (c, r) blocks row c and column r.

So, together, they block rows r and c, and columns r and c.

Therefore, no further rooks can be placed in rows r and c, or columns r and c.

Hence, the board is divided into four subregions:

- Rows < r and columns < c

- Rows < r and columns > c

- Rows > r and columns < c

- Rows > r and columns > c

But this might not be the best way to think about it.

Alternatively, perhaps I can model this as choosing a set of positions such that no two positions share a row or a column, and considering the mirroring constraint.

Wait, perhaps it's better to think in terms of graph theory, where rows and columns are vertices, and placing a rook corresponds to selecting an edge between a row and a column.

But that might be too abstract for this problem.

Let me consider a different approach.

Suppose I have a set of rows and columns that are still available (not blocked by previous moves).

Each move I make is to choose a position (r, c) where r is an available row and c is an available column, and then the computer mirrors it at (c, r), provided r ≠ c.

If r = c, then only my rook is placed, and the computer does nothing.

I need to count the number of ways to continue placing rooks until no more moves are possible.

This seems similar to counting the number of perfect matchings in a bipartite graph, but with some differences due to the mirroring constraint.

Alternatively, perhaps it's related to counting the number of ways to place non-attacking rooks on a chessboard, with some positions already occupied.

But in this problem, the mirroring adds an extra layer of complexity.

Let me try to find a pattern or recurrence relation.

Suppose I have m available rows and m available columns left (since each move blocks two rows and two columns, but need to account for diagonals where r = c).

Wait, perhaps I need to consider the number of remaining available positions.

Let me try to compute the number of remaining available positions after the initial k moves.

Each of my k moves blocks two rows and two columns (except when r = c, which blocks only one row and one column).

Wait, no. Placing a rook at (r, c) blocks row r and column c.

The computer's move at (c, r) blocks row c and column r.

So, together, they block rows r and c, and columns r and c.

Hence, for each pair of distinct r and c, the moves block rows r and c, and columns r and c.

If r = c, then only row r and column r are blocked.

Wait, but in the problem, it's guaranteed that all moves are valid, so no two rooks are attacking each other.

Hence, after k moves, some rows and columns are blocked.

I need to find out how many rows and columns are still available.

Let me define:

- Let S be the set of rows and columns that are blocked.

- Initially, S is empty.

- For each of my k moves at (r, c):

- Add r and c to S.

- The computer mirrors at (c, r), so add c and r to S.

Hence, S is the union of all rows and columns that have been used in the moves.

Wait, but since rows and columns are indexed from 1 to n, and S contains the indices of blocked rows and columns, then the number of remaining available rows and columns is n - |S|.

But wait, each move blocks two indices: one row and one column.

But if r = c, then only one index is added to S.

Wait, no. Even if r = c, both row r and column r are blocked.

Hence, for each move, whether r = c or not, rows r and c are blocked, and columns r and c are blocked.

Wait, but in the case r = c, it's only one unique index being blocked.

Hence, |S| is the number of unique row and column indices that have been blocked so far.

Given that, after k moves, the size of S is equal to the number of unique row and column indices that have been used in the moves.

Wait, more precisely, S is the union of all rows and columns that have been used in any of the k moves.

Hence, |S| is the number of unique rows and columns that have been used in the k moves.

Wait, no. Since each move uses two indices: one row and one column.

Hence, |S| is the number of unique indices that appear either as a row or as a column in any of the k moves.

So, |S| is the number of unique elements in the union of all r and c across the k moves.

Given that, the number of remaining available rows and columns is n - |S|.

Now, from this point onward, I need to place rooks in the remaining available positions, with the mirroring constraint.

I need to find out how many different final configurations are possible.

Let me consider that the remaining available positions form a subgrid of size (n - |S|) x (n - |S|).

In this subgrid, I need to place rooks such that no two rooks attack each other, and with the mirroring constraint.

Wait, but it's not exactly a subgrid, because the remaining available rows and columns may not correspond to a contiguous block.

However, since the rows and columns are independent, I can think of it as a bipartite graph where one set of vertices are the available rows and the other set are the available columns, and edges represent possible positions to place rooks.

Given that, placing a rook at (r, c) removes all edges connected to row r and column c, and the computer mirrors it at (c, r), which would remove additional edges.

But this seems complicated.

Let me think differently.

Suppose that after the initial k moves, there are m = n - |S| available rows and columns.

Then, the number of ways to continue the game is equal to the number of ways to place non-attacking rooks in this m x m subgrid, considering the mirroring constraint.

Wait, but the mirroring constraint complicates things.

Let me try to find a pattern or formula for small values of m.

Let's compute for m = 1:

- Only one row and one column available.

- I can place a rook at (1,1), and the computer mirrors it at (1,1), but since it's the same position, only one rook is placed.

- Hence, only one configuration.

Wait, but according to the code, dp[1] = 1.

For m = 2:

- Two rows and two columns available.

- Possible moves:

1. Place a rook at (1,2), computer places at (2,1). Then no more moves are possible.

2. Place a rook at (2,1), computer places at (1,2). This is the same as the first configuration.

3. Place a rook at (1,1), computer skips. Then, no more moves are possible.

4. Place a rook at (2,2), computer skips. Then, no more moves are possible.

Hence, there are 3 distinct configurations.

This matches dp[2] = 3.

Wait, but according to the code, dp[2] = 3.

Wait, but in the explanation for n=4 and k=1, with m = n - |S| = 4 - 2 = 2, dp[2] = 3, which matches the sample output.

Hence, it seems that dp[m] gives the number of possible final configurations for an m x m subgrid with no previous moves.

But in the problem, we have already made k moves, and we need to continue the game from there.

Wait, but in the code, it's printing dp[n - len(invalid)], where invalid is the set of blocked rows and columns.

Hence, m = n - len(invalid), and dp[m] is the number of possible final configurations for an m x m subgrid with no previous moves.

But in reality, some moves have already been made, so this might not directly apply.

Wait, perhaps dp[m] represents the number of ways to place rooks in an m x m grid with the mirroring constraint, starting from an empty grid.

But in our case, part of the grid has already been used in the k moves.

Hence, simply using dp[m] might not account for the fact that some positions are already occupied.

Wait, but in the code, it's using dp[n - len(invalid)], which is dp[m], where m is the number of remaining available rows and columns.

But this assumes that the remaining subgrid is empty, which is not necessarily true because some positions within this subgrid might have been used in the initial k moves.

Wait, no. Actually, the set invalid contains all the rows and columns that have been blocked by the initial k moves.

Hence, the remaining m = n - len(invalid) rows and columns have not been used yet.

Therefore, dp[m] should represent the number of ways to place rooks in this m x m subgrid, starting from empty.

But in reality, some of these positions might be invalid due to the initial k moves, but since the problem guarantees that the initial k moves are valid, and the computer mirrored them appropriately, the remaining positions should be completely available.

Hence, perhaps dp[m] is indeed the number of possible final configurations for the remaining m x m subgrid.

But in the sample input, when n=4 and k=1 with my move at (1,2) and computer at (2,1), the remaining available positions are rows 3 and 4 and columns 3 and 4.

Hence, m = 2, and dp[2] = 3, which matches the sample output.

Similarly, for n=8 and k=1 with my move at (7,6) and computer at (6,7), m = 8 - 4 = 4 (since rows 6,7 and columns 6,7 are blocked), dp[4] should be 15, but in the sample output, it's 331, which doesn't match.

Wait, perhaps I'm miscalculating m.

Wait, in the second sample input, n=8, k=1, with my move at (7,6), computer at (6,7).

Hence, blocked rows: 6,7 and blocked columns:6,7.

Hence, m = 8 - 4 = 4? Wait, no.

Wait, len(invalid) = number of unique rows and columns blocked.

Here, rows 6 and 7 are blocked, columns 6 and 7 are blocked.

Hence, invalid set contains {6,7}, so len(invalid) = 2.

Hence, m = 8 - 2 = 6.

But according to the code, it's dp[6], which is being calculated.

But in the sample output, it's 331, which is dp[6].

Hence, dp[6] = 331.

Similarly, for n=1000 and k=4 with some moves, m = 1000 - len(invalid).

Need to calculate len(invalid).

Given that, it seems that the code is correctly calculating dp[m] for each test case.

Hence, it seems that dp[m] represents the number of possible final configurations for an m x m subgrid with no previous moves.

But I need to verify if this is indeed correct.

Let me try to derive a formula for dp[m].

Looking at the function func_1(n):

dp[1] = 1

dp[2] = 3

for i in range(3, n + 1):

dp[i] = (dp[i - 1] + 2 * (i - 1) * dp[i - 2]) % 1000000007

Let's compute dp[m] for m from 1 to 6:

dp[1] = 1

dp[2] = 3

dp[3] = dp[2] + 2*2*dp[1] = 3 + 4*1 = 7

dp[4] = dp[3] + 2*3*dp[2] = 7 + 6*3 = 7 + 18 = 25

dp[5] = dp[4] + 2*4*dp[3] = 25 + 8*7 = 25 + 56 = 81

dp[6] = dp[5] + 2*5*dp[4] = 81 + 10*25 = 81 + 250 = 331

This matches the sample output for m=6, which is 331.

Similarly, for m=4, dp[4] = 25, but in the first sample input with m=2, dp[2]=3, which matches the first sample output.

Hence, it seems that dp[m] correctly represents the number of possible final configurations for an m x m subgrid with no previous moves.

Therefore, in the code, dp[n - len(invalid)] should give the number of possible final configurations for the remaining subgrid.

But I need to confirm if this is correct.

Wait, in the first sample input, n=4, k=1, invalid set has rows and columns 1,2 (since my move is at (1,2) and computer at (2,1)), so len(invalid)=2, m=2, dp[2]=3, which matches the sample output.

In the second sample input, n=8, k=1, my move at (7,6), computer at (6,7), so invalid set has rows and columns 6,7, len(invalid)=2, m=6, dp[6]=331, which matches the sample output.

In the third sample input, n=1000, k=4, with specific moves, need to calculate len(invalid).

Given the moves:

4 4

952 343

222 333

90 91

Hence, invalid set contains rows and columns: 4,952,222,90,4,343,333,91.

Need to find the unique elements in this set.

But since some indices may repeat, need to find the number of unique rows and columns blocked.

Given that n=1000, and k=4, len(invalid) would be the number of unique rows and columns in these moves.

Assuming all rows and columns are distinct, len(invalid)=8, hence m=1000-8=992, dp[992].

But in the sample output, it's 671968183, which is dp[992] modulo 10^9+7.

Hence, it seems consistent.

Therefore, the approach in the code is correct: compute m = n - len(invalid), and then output dp[m].

Hence, Correctness: **True**

**Final Solution**
To solve this problem, we need to determine the number of different final configurations possible on an n x n chessboard after a series of moves involving placing rooks with specific constraints. The solution involves precomputing the number of configurations for subgrids of varying sizes and then using this precomputed data to answer multiple test cases efficiently.

### Approach

1. **Understanding the Problem:**
   - We place white rooks and the computer places black rooks in a mirrored fashion.
   - We need to ensure that no two rooks attack each other, i.e., no two rooks share the same row or column.
   - We need to find the number of possible final configurations after k initial moves.

2. **Key Observations:**
   - Each move blocks certain rows and columns.
   - The computer mirrors the move, adding another blocked row and column.
   - The remaining available rows and columns form a subgrid where we can place further rooks.

3. **Dynamic Programming Solution:**
   - Precompute the number of configurations for subgrids of size m x m using dynamic programming.
   - Use a DP array where `dp[m]` represents the number of configurations for an m x m subgrid.

4. **DP Recurrence Relation:**
   - `dp[1] = 1` (only one way to place a rook in a 1x1 grid).
   - `dp[2] = 3` (three possible configurations for a 2x2 grid).
   - For `m >= 3`, `dp[m] = (dp[m-1] + 2 * (m-1) * dp[m-2]) % (10^9 + 7)`.

5. **Processing Each Test Case:**
   - Calculate the set of blocked rows and columns based on the initial k moves.
   - Compute the size of the remaining subgrid `m = n - len(invalid)`.
   - Output `dp[m]` for each test case.

### Solution Code

```python
import sys

sys.setrecursionlimit(400000)
MOD = 10**9 + 7
dp = [-1 for _ in range(300007)]

def precompute_dp(n):
    dp[1] = 1
    dp[2] = 3
    for i in range(3, n + 1):
        dp[i] = (dp[i - 1] + 2 * (i - 1) * dp[i - 2]) % MOD

def main():
    precompute_dp(300000)
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        invalid = set()
        for _ in range(k):
            r, c = map(int, input().split())
            invalid.add(r)
            invalid.add(c)
        m = n - len(invalid)
        # Ensure m is non-negative
        m = max(0, m)
        # If m == 0, there is only one configuration: no more moves
        print(max(1, dp[m]))

if __name__ == "__main__":
    main()
```

### Explanation

1. **Precomputation:**
   - We precompute the DP array up to the maximum possible value of n (300,000) to handle all test cases efficiently.

2. **Processing Test Cases:**
   - For each test case, we read n and k.
   - We track the blocked rows and columns using a set.
   - We calculate the size of the remaining subgrid `m = n - len(invalid)`.
   - We print `dp[m]` for each test case, ensuring to handle the case when m = 0 by outputting 1.

This approach ensures that we handle the constraints efficiently and compute the required configurations correctly.