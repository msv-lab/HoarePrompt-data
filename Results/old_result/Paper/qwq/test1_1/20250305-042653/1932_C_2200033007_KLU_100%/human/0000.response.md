Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, a positive integer m, and a string of commands consisting of 'L's and 'R's. For each command, I need to output the product of the current array modulo m, and then remove either the leftmost or the rightmost element of the array based on whether the command is 'L' or 'R'. This process repeats for all commands in the string.

First, I need to understand the problem clearly. I have to process each command in order, output the product modulo m each time, and then remove an element from either end of the array. After all commands are processed, the array should be empty.

I need to make sure that my solution is efficient because the constraints are quite large. The array can be up to 2*10^5 elements, and there can be up to 10^4 test cases, but the total sum of n across all test cases is up to 2*10^5. So, I need an algorithm that's linear per test case.

Let me think about how to compute the product modulo m efficiently. If I were to compute the product naively for each step, it would be O(n^2), which is too slow. I need a smarter way.

Wait, perhaps I can precompute the product of the entire array and then, for each step, divide by the element being removed and take modulo m. But division under modulo is tricky, especially if m is not a prime number. I need to be careful with that.

Alternatively, maybe I can keep track of the product and update it by dividing by the removed element and multiplying by its modular inverse. But again, this might not work for all m, especially if the element and m are not coprime.

Hmm, maybe there's another approach. Let's consider the sequence of removals. Each command either removes the leftmost or the rightmost element. So, the order in which elements are removed is determined by the sequence of 'L's and 'R's in the string s.

If I can determine the order in which elements are removed, then I can compute the product of the remaining elements at each step.

Wait, but computing the product of remaining elements directly would still be O(n^2) if done naively.

I need a way to compute the product of the array excluding the elements that have been removed so far.

Let me think differently. Suppose I process the commands in reverse order. That is, start from the end of the string s and work backwards. In this way, I can simulate adding elements back to the array instead of removing them.

If I do that, I can maintain the current product modulo m, and at each step, before adding the new element, I can output the current product, then multiply it by the new element, and take modulo m.

But wait, if I'm processing the commands in reverse, I need to know which element to add back at each step, which depends on whether the command was 'L' or 'R'.

Let's see: if the last command is 'L', that means the last operation was to remove the leftmost element, so to simulate in reverse, I should add this element back to the left end. Similarly, if the last command is 'R', I should add it back to the right end.

However, since I'm dealing with a list or array, inserting at the beginning (left end) is expensive if the list is large, because it requires shifting elements.

Wait, perhaps I can collect all the elements that are removed and then add them back in reverse order.

But this seems complicated. Let me consider another approach.

Maybe I can precompute the order in which elements are removed and then compute the product for each step based on which elements are still present.

But precomputing the order of removal seems necessary.

Let me try to simulate the process for a small example to see if I can find a pattern.

Take the first example from the problem:

n = 4, m = 6

a = [3, 1, 4, 2]

s = "LRRL"

Let's simulate the process:

1. Initial array: [3, 1, 4, 2]

Product modulo 6: 3*1*4*2 = 24 % 6 = 0

Command is 'L', remove leftmost element (3)

Array becomes: [1, 4, 2]

2. Array: [1, 4, 2]

Product modulo 6: 1*4*2 = 8 % 6 = 2

Command is 'R', remove rightmost element (2)

Array becomes: [1, 4]

3. Array: [1, 4]

Product modulo 6: 1*4 = 4 % 6 = 4

Command is 'R', remove rightmost element (4)

Array becomes: [1]

4. Array: [1]

Product modulo 6: 1 % 6 = 1

Command is 'L', remove leftmost element (1)

Array becomes empty.

So, the output is: 0 2 4 1

Now, how can I generalize this process?

One way is to keep track of the elements that are not yet removed, i.e., the elements that are still in the array at each step.

But maintaining the product of these elements directly would be inefficient if done naively.

I need a way to compute the product of the remaining elements efficiently.

Let me consider the fact that the array is being reduced by removing either the leftmost or rightmost element at each step.

This means that the remaining elements form a subarray that is contiguous.

Wait, but as elements are removed from either end, the remaining array remains contiguous.

So, perhaps I can keep track of the left and right boundaries of the remaining array and compute the product within these boundaries.

But computing the product of a subarray efficiently suggests using a prefix product array.

However, since m can be as small as 1, and we're dealing with modulo m, I need to handle division carefully.

Wait, perhaps prefix products modulo m can help.

Let me try that.

Compute prefix products where prefix[i] = a[0] * a[1] * ... * a[i-1] % m

Similarly, compute suffix products where suffix[i] = a[i] * a[i+1] * ... * a[n-1] % m

Then, at any step, the product of the remaining array would be prefix[l] * suffix[r] % m, where l and r are the current left and right boundaries.

Wait, but this might not work because multiplication modulo m doesn't necessarily allow combining prefix and suffix products in this way, especially if there are duplicates or if m has repeated prime factors.

Let me check with the first example.

For a = [3,1,4,2], m = 6

prefix[0] = 1

prefix[1] = 3 % 6 = 3

prefix[2] = 3*1 % 6 = 3

prefix[3] = 3*1*4 % 6 = 12 % 6 = 0

prefix[4] = 0*2 % 6 = 0

suffix[4] = 1

suffix[3] = 2 % 6 = 2

suffix[2] = 4*2 % 6 = 8 % 6 = 2

suffix[1] = 1*4*2 % 6 = 8 % 6 = 2

suffix[0] = 3*1*4*2 % 6 = 24 % 6 = 0

Now, at each step:

Initial: l=0, r=3

Product should be prefix[0] * suffix[3] % m = 1 * 2 % 6 = 2, but actual product is 3*1*4*2=24%6=0

Wait, that doesn't match. So, this approach is flawed.

I need another way.

Let me consider that since m can be as small as 1, and product can be large, I need a way to handle large products modulo m.

Perhaps I can compute the product incrementally, removing one element at a time.

But I need to remove either the leftmost or rightmost element, so maybe I can maintain a deque and keep removing from either end.

But computing the product each time would still be O(n^2) if done naively.

Wait, perhaps I can precompute the order in which elements are removed and then compute the product based on that.

Let me try to simulate the removal order.

In the first step, command is 'L', so remove the leftmost element, which is a[0].

In the second step, command is 'R', so remove the rightmost element, which is now a[3].

In the third step, command is 'R', so remove the rightmost element, which is a[2].

In the fourth step, command is 'L', so remove the leftmost element, which is a[1].

So, the order of removal is a[0], a[3], a[2], a[1].

Wait, but in the first step, the product is of all elements: a[0]*a[1]*a[2]*a[3].

In the second step, it's a[1]*a[2]*a[3].

In the third step, it's a[1]*a[2].

In the fourth step, it's a[1].

So, to compute these products efficiently, perhaps I can compute the full product, then divide by the removed element, but again, division under modulo is tricky.

Alternatively, perhaps I can compute the product incrementally.

Wait, maybe I can keep track of the product modulo m, and at each step, remove the corresponding element's contribution.

But removing an element's contribution is equivalent to dividing, which is problematic under modulo.

Let me think differently.

Maybe I can precompute all the products and store them in a list.

But that would require O(n) space and time, which is acceptable.

Wait, but for each test case, n can be up to 2*10^5, and t can be up to 10^4, but the total n across all test cases is up to 2*10^5, so it's manageable.

So, perhaps for each test case, I can compute the product of the current array and store it in a list, then remove the appropriate element.

But I need to do this efficiently.

Let me consider reversing the process.

If I process the commands in reverse order, I can build up the array step by step and keep track of the product.

Wait, that might work.

Let's try it.

Start with an empty array.

Then, for each command in reverse order:

- If the command is 'L', it means that in the forward process, we removed the leftmost element.

So, in reverse, we're adding an element to the left.

- Similarly, if the command is 'R', in reverse, we're adding an element to the right.

So, I can maintain a list or deque that starts empty, and in reverse order, add elements to either end based on the command.

At each step, before adding the element, I can output the current product modulo m, then add the element, and update the product.

Wait, but in the reverse process, I need to output the product of the array before adding the element.

But in the forward process, we output the product of the current array before removing an element.

So, in reverse, it should be before adding the element.

Wait, perhaps I need to think more carefully.

Let's consider the steps in reverse.

Take the first example:

Forward steps:

1. Array: [3,1,4,2], output product, remove L (3)

2. Array: [1,4,2], output product, remove R (2)

3. Array: [1,4], output product, remove R (4)

4. Array: [1], output product, remove L (1)

Empty array.

In reverse:

1. Start with empty array.

2. Add L (3), array becomes [3], output product before adding: 1 (empty product)

Wait, but in the forward process, the first output is the product of all elements, which is 3*1*4*2=24%6=0.

In reverse, starting from empty, adding elements in reverse order of removal.

Wait, perhaps I need to collect all the removed elements first and then add them in reverse order.

Let me try to collect the removed elements in order.

In the forward process:

- Remove 3 (L), then 2 (R), then 4 (R), then 1 (L)

So, in reverse, I add 1 (L), then 4 (R), then 2 (R), then 3 (L)

Starting from empty:

1. Add 1 to left, array: [1], product: 1

2. Add 4 to right, array: [1,4], product: 1*4=4

3. Add 2 to right, array: [1,4,2], product: 1*4*2=8%6=2

4. Add 3 to left, array: [3,1,4,2], product: 3*1*4*2=24%6=0

Which matches the forward process outputs: 0,2,4,1

So, in reverse, before adding each element, I output the current product, then add the element, and update the product.

This seems promising.

Now, in code, I can collect the removed elements in order, then iterate backwards, adding them to either end of a deque, and keep track of the current product.

But collecting the removed elements requires knowing which elements are removed in which order.

Wait, but the string s tells me the order of removals.

So, I can collect the removed elements in order by iterating through s and picking 'L' or 'R' accordingly.

Wait, but to know which element is removed at each step, I need to know the current leftmost and rightmost elements.

This seems a bit involved.

Let me consider another approach.

Perhaps I can simulate the process using a deque.

Initialize a deque with the array a.

Then, for each command in s:

- Output the product of the deque modulo m.

- Remove the leftmost element if command is 'L', or the rightmost if 'R'.

But this is too slow for large n.

I need something faster.

Wait, maybe I can precompute the order in which elements are removed and then compute the products based on that.

Let me try to collect the sequence of removed elements.

In the forward process, I remove either the leftmost or rightmost element based on s.

So, for s = "LRRL", and a = [3,1,4,2]:

- First, remove L (3), array becomes [1,4,2]

- Second, remove R (2), array becomes [1,4]

- Third, remove R (4), array becomes [1]

- Fourth, remove L (1), array becomes empty

So, the order of removal is 3,2,4,1

In reverse, adding back 1 (L), then 4 (R), then 2 (R), then 3 (L), as I did earlier.

So, perhaps I can collect this order of removal and then compute the products in reverse.

Let me see.

In the reverse process:

- Start with empty array, product = 1

- Add 1 to left, before adding, output product=1, then add 1, product=1

- Add 4 to right, before adding, output product=1, then add 4, product=1*4=4

- Add 2 to right, before adding, output product=4, then add 2, product=4*2=8%6=2

- Add 3 to left, before adding, output product=2, then add 3, product=3*2=6%6=0

So, outputs are 1,1,4,2, and final product is 0.

But in the forward process, outputs are 0,2,4,1.

Wait, this is the reverse order.

I think I'm getting confused.

Let me try to formalize this approach.

Define removed_order as the sequence of removed elements based on s.

In the first example, removed_order = [3,2,4,1]

Then, in the reverse process, I start with an empty array, and add back elements in the reverse of removed_order, i.e., [1,4,2,3]

At each step, before adding the element, I output the current product, then add the element, and update the product.

So, steps in reverse:

1. Array: empty, product=1, output 1

2. Add 1 to left, array=[1], product=1%6=1, output 1

3. Add 4 to right, array=[1,4], product=1*4%6=4, output 4

4. Add 2 to right, array=[1,4,2], product=1*4*2%6=8%6=2, output 2

5. Add 3 to left, array=[3,1,4,2], product=3*1*4*2%6=24%6=0, output 0

But in the forward process, the outputs are 0,2,4,1.

So, the outputs in reverse are 0,2,4,1, which matches the forward process outputs.

Wait, but in the reverse process, I'm outputting 1,1,4,2, which doesn't match.

I must be misunderstanding something.

Wait, perhaps the issue is with the initial product in the reverse process.

In the forward process, the first output is the product of all elements modulo m.

In the reverse process, starting from empty array, the first output should be the product of the empty array, which is 1, but in the forward process, it's the product of all elements.

This seems inconsistent.

I need to think differently.

Let me consider that in the forward process, at each step, before removing an element, I output the product of the current array modulo m.

In the reverse process, before adding an element, I output the product of the current array modulo m.

So, in the reverse process, the sequence of outputs should be the reverse of the forward process outputs.

But in the first example, forward outputs are 0,2,4,1, and in reverse process, outputs are 1,2,4,1, which doesn't match.

I must be making a mistake.

Wait, perhaps I need to adjust how I compute the product in the reverse process.

Let me try to think in terms of maintaining the product as I add elements back.

Start with an empty array, product = 1 (since the product of an empty array is conventionally 1).

Then, for each element in the reverse order of removal:

- Before adding the element, output the current product.

- Add the element to the appropriate end (left or right based on the command).

- Update the product by multiplying by the added element and taking modulo m.

Wait, but in this approach, the outputs in reverse process don't match the forward process outputs.

Maybe this approach isn't correct.

Let me consider another idea.

Since the operations are removing from left or right, and I need the product of the remaining array each time, perhaps I can compute the product of all elements first, and then, for each removal, divide by the removed element (if possible) and take modulo m.

But division under modulo is only straightforward if m is prime, which it may not be in this problem since m can be any positive integer >=1.

So, I need a general way to divide under modulo.

I recall that if I have a product p and I want to divide by a number x, and m and x are coprime, then I can multiply by the modular inverse of x modulo m.

But if m and x are not coprime, then division is not possible.

However, in this problem, m can be any positive integer, and the elements of a can be any positive integers up to 10^4.

So, m and the elements may not be coprime, which means I can't always compute the modular inverse.

Therefore, this approach seems problematic.

I need another way.

Let me consider that since m can be up to 10^4, and n can be up to 2*10^5, I need an efficient way to compute the product modulo m at each step.

Wait, perhaps I can factor m into its prime factors and compute the product modulo each prime power, then use the Chinese Remainder Theorem to combine them.

But this seems too complicated and time-consuming, especially since m can have multiple prime factors and computing inverses for each prime power is involved.

I need a simpler approach.

Let me consider that for each test case, m is fixed, so I can precompute some values related to m.

But I'm not sure.

Wait, perhaps I can keep track of the product modulo m, and when removing an element, adjust the product accordingly.

But again, this runs into the division problem under modulo.

I need to find a way around this.

Let me consider that since m can be small (up to 10^4), and n can be large (up to 2*10^5), but the total sum of n across all test cases is up to 2*10^5, which is manageable.

So, perhaps I can accept the O(n) per test case time complexity and find an efficient way to compute the product at each step.

Wait, maybe I can precompute the product of all elements, and then, for each step, divide by the removed element if possible, otherwise handle the case where division isn't possible.

But again, this seems too vague.

Let me consider that in the forward process, at each step, I need to output the product of the current array modulo m, and then remove an element.

So, perhaps I can simulate this process step by step, keeping track of the product modulo m, and updating it after each removal.

But as mentioned earlier, updating the product after removal is tricky due to the modulo division issue.

Wait, perhaps I can keep track of the product and the removed elements separately, and compute the product modulo m at each step without dividing.

Is there a way to do that?

Let me think about inclusion-exclusion or some other method.

Alternatively, perhaps I can compute the product of all elements, and then, for each step, divide by the product of the removed elements up to that point.

But again, division under modulo is problematic.

This seems like a dead end.

Let me look at the sample input and output again.

Sample Input:

4

4 6

3 1 4 2

LRRL

5 1

1 1 1 1 1

LLLLL

6 8

1 2 3 4 5 6

RLLLRR

1 10000

10000

R

Sample Output:

0 2 4 1

0 0 0 0 0

0 0 0 4 4 4

0

Looking at the first test case:

n=4, m=6, a=[3,1,4,2], s=LRRL

Outputs: 0,2,4,1

As I simulated earlier, this seems correct.

Second test case:

n=5, m=1, a=[1,1,1,1,1], s=LLLLL

Outputs: 0 0 0 0 0

Since any product modulo 1 is 0.

Third test case:

n=6, m=8, a=[1,2,3,4,5,6], s=RLLLRR

Outputs: 0 0 0 4 4 4

Let me simulate this:

Commands: R L L L R R

Remove R (6), array: [1,2,3,4,5], product=120%8=0

Remove L (1), array: [2,3,4,5], product=120%8=0

Remove L (2), array: [3,4,5], product=60%8=4

Remove L (3), array: [4,5], product=20%8=4

Remove R (5), array: [4], product=4%8=4

Remove R (4), array empty

So, outputs: 0,0,0,4,4,4, which matches the sample.

Fourth test case:

n=1, m=10000, a=[10000], s=R

Outputs: 0

Since 10000%10000=0, and then remove R (10000), array empty.

Okay, that makes sense.

So, my approach needs to handle these cases correctly.

I need to find a way to compute the product modulo m efficiently for each step.

Let me consider that m can be any positive integer up to 10^4, and a[i] can be up to 10^4.

So, the product can be up to (10^4)^n, but since n can be up to 2*10^5, the product can be enormous.

Thus, I need to compute the product modulo m at each step without storing huge numbers.

But as we've seen, removing elements and adjusting the product is tricky due to modulo division.

Wait, perhaps I can compute the product of all elements, and then, for each step, divide by the product of removed elements.

But again, division under modulo is problematic.

Alternatively, perhaps I can compute the product of all elements, and then, for each step, divide by the removed element, but only if the removed element and m are coprime.

If they are not coprime, then I can't divide by the removed element.

This seems too involved.

Let me consider that in the forward process, I can keep track of the product of the current array modulo m.

At each step, before removing an element, I output the current product modulo m.

Then, I remove the element, which means I need to adjust the product accordingly.

If I remove an element x, then the new product should be (current_product / x) modulo m, but only if x and m are coprime.

If x and m are not coprime, then I can't simply divide.

This seems too complicated.

Let me think about another approach.

Perhaps I can compute the product of all elements, and then, for each step, divide by the product of removed elements up to that point.

But again, division under modulo is tricky.

Wait, maybe I can avoid division altogether.

Let me consider that since m can be small, up to 10^4, perhaps I can factor m into its prime factors and compute the product modulo each prime power, then use the Chinese Remainder Theorem to combine them.

But this seems overkill and time-consuming.

I need a simpler way.

Let me consider that for each test case, m is fixed, so I can precompute some values related to m.

But I'm not sure.

Wait, perhaps I can keep track of the exponents of the prime factors in the product and in the removed elements, and adjust accordingly.

But this seems too involved for the time constraints.

I need to find a better way.

Let me consider that since the array is being reduced by removing elements from either end, perhaps I can use prefix and suffix products modulo m.

Wait, but as I saw earlier, prefix[l] * suffix[r] % m doesn't give the correct product of the subarray from l to r.

So, that approach doesn't work.

Let me consider that in the forward process, I can compute the product of the current array at each step, but in a way that allows me to efficiently update the product when removing an element.

Wait, perhaps I can maintain a product variable and update it by dividing by the removed element, but only if the removed element divides the current product.

But this seems too error-prone.

Let me consider that if m is 1, then any product modulo m is 0, so I can handle this special case separately.

Similarly, if m is greater than 1, I need to handle it accordingly.

But this doesn't solve the general problem.

I need to think differently.

Let me consider that in the forward process, I can collect all the removed elements in order, and then, in reverse order, add them back to compute the product step by step.

Wait, perhaps I can use dynamic programming or some cumulative product approach.

But I'm not sure.

Wait, perhaps I can compute the product of all elements, and then, for each step, divide by the product of the removed elements up to that step.

But again, division under modulo is problematic.

I need to find another way.

Let me consider that since m can be small, up to 10^4, and n can be up to 2*10^5, but the total sum of n across all test cases is up to 2*10^5, perhaps I can accept an O(n) per test case solution, even if it's a bit slow, as long as it's correct.

But I need to make sure it's efficient enough.

Wait, perhaps I can compute the product of the array using a sliding window approach, but I'm not sure.

Alternatively, maybe I can use logarithms to convert multiplication to addition, but modulo m complicates this.

This seems too vague.

Let me consider that in programming, there are ways to handle large products modulo m efficiently, perhaps using built-in functions or libraries.

But in Python, handling large integers is manageable, but I need to make sure that the computations are efficient.

Wait, perhaps I can compute the product of all elements, and then, for each step, divide by the removed element, but since m is small, I can compute the division directly.

But again, division under modulo is tricky.

I need to find a way to handle this.

Let me look back at the problem statement.

I need to output the remainder of the product of all elements of the array a when divided by m, before removing the specified element.

So, at each step, I need to compute the product of the current array modulo m, and then remove the specified element.

I need to do this efficiently.

Wait, perhaps I can precompute the product of all elements, and then, for each step, divide by the removed element, but only if the removed element divides the current product.

If it doesn't, then the product modulo m is 0.

But this seems too simplistic.

Let me think about it.

Suppose the current product is p, and I remove an element x.

If x divides p, then the new product should be p // x.

Otherwise, p modulo x is not zero, which shouldn't affect the modulo m.

But this seems incorrect.

I need to find a better way.

Let me consider that for each step, I can compute the product of the current array by multiplying the previous product by the inverse of the removed element, if it exists.

But again, this runs into the problem of computing inverses under modulo m.

I need to find a way around this.

Wait, perhaps I can compute the product of the current array by keeping track of the product and updating it after each removal.

But without division, I need another approach.

Let me consider that in the forward process, the product at each step is the product of the current array modulo m.

So, perhaps I can compute this directly for each step, without trying to optimize too much.

But this would be O(n^2), which is too slow.

I need to find a way to compute the product for each step in O(n) time.

Wait, perhaps I can use the fact that the array is being reduced by removing elements from either end, so the remaining array is always a subarray.

So, perhaps I can precompute prefix and suffix products modulo m, and then, for each step, compute the product as prefix[l] * suffix[r] % m.

But earlier, I saw that this doesn't work because of the way modulo affects multiplication.

Let me try with the first example.

a = [3,1,4,2], m=6

prefix[0] = 1

prefix[1] = 3 % 6 = 3

prefix[2] = 3*1 % 6 = 3

prefix[3] = 3*1*4 % 6 = 12 % 6 = 0

prefix[4] = 0*2 % 6 = 0

suffix[4] = 1

suffix[3] = 2 % 6 = 2

suffix[2] = 4*2 % 6 = 8 % 6 = 2

suffix[1] = 1*4*2 % 6 = 8 % 6 = 2

suffix[0] = 3*1*4*2 % 6 = 24 % 6 = 0

Now, for each step:

1. Initial array: [3,1,4,2], l=0, r=3

product should be prefix[0] * suffix[3] % m = 1 * 2 % 6 = 2, but actual product is 24 % 6 = 0

This doesn't match.

2. After removing L (3), array: [1,4,2], l=1, r=3

product should be prefix[1] * suffix[3] % m = 3 * 2 % 6 = 6 % 6 = 0, but actual product is 8 % 6 = 2

Again, doesn't match.

3. After removing R (2), array: [1,4], l=1, r=2

product should be prefix[1] * suffix[2] % m = 3 * 2 % 6 = 6 % 6 = 0, but actual product is 4 % 6 = 4

Doesn't match.

4. After removing R (4), array: [1], l=1, r=1

product should be prefix[1] * suffix[1] % m = 3 * 2 % 6 = 6 % 6 = 0, but actual product is 1 % 6 = 1

Doesn't match.

So, this approach doesn't work.

I need to think differently.

Let me consider that in the forward process, at each step, I need to compute the product of the current array modulo m, and then remove an element.

So, perhaps I can compute the product for the current array, output it, then remove the appropriate element.

But computing the product naively at each step is too slow.

I need a way to compute the product efficiently, perhaps in O(1) time per step after some O(n) preprocessing.

But I'm not sure how.

Wait, perhaps I can precompute the product of all elements, and then, for each step, keep dividing by the removed element, but handle the division under modulo properly.

But as we've seen, this is tricky.

Let me consider that if m is a prime number, I could compute the modular inverse of the removed element and multiply by it.

But m is not necessarily prime.

So, that doesn't help.

Wait, perhaps I can compute the greatest common divisor (GCD) of the removed element and m, and adjust the product accordingly.

Let me think about it.

Suppose I have the current product p, and I remove an element x.

If GCD(x, m) = 1, then x has an inverse modulo m, and I can compute p * inv(x) % m.

If GCD(x, m) !=1, then x does not have an inverse modulo m, and I need to handle this case differently.

In this case, perhaps I can divide p and m by GCD(x, m), compute the adjusted product, and keep track of the adjusted m.

But this seems complicated, and I need to ensure that I handle all cases correctly.

This might be too error-prone for the time constraints.

I need a simpler approach.

Let me consider that since m can be small, up to 10^4, and n can be up to 2*10^5, but the total sum of n across all test cases is up to 2*10^5, perhaps I can accept an O(n) per test case solution, even if it involves some overhead.

But I need to make sure it's efficient enough.

Wait, perhaps I can precompute the product of all elements, and then, for each step, divide by the removed element, but only if the removed element divides the current product.

If it doesn't, then the product modulo m is 0.

But this seems too simplistic and likely incorrect.

Let me think about it with an example.

Take the first example:

n=4, m=6, a=[3,1,4,2], s=LRRL

Product = 3*1*4*2=24, 24%6=0

Remove L (3), product=1*4*2=8, 8%6=2

Remove R (2), product=1*4=4, 4%6=4

Remove R (4), product=1, 1%6=1

Remove L (1), array empty

So, outputs: 0,2,4,1

Now, if I compute product=24, then remove 3, which divides 24, so new product=24//3=8, 8%6=2

Then remove 2, which divides 8, so new product=8//2=4, 4%6=4

Then remove 4, which divides 4, so new product=4//4=1, 1%6=1

Then remove 1, which divides 1, so new product=1//1=1, but array is empty.

This seems to work in this case.

Another example:

n=5, m=1, a=[1,1,1,1,1], s=LLLLL

Product=1, 1%1=0

Remove L (1), product=1, 1%1=0

Remove L (1), product=1, 1%1=0

Remove L (1), product=1, 1%1=0

Remove L (1), product=1, 1%1=0

Remove L (1), array empty

Outputs: 0 0 0 0 0

Which matches the sample.

Another example:

n=6, m=8, a=[1,2,3,4,5,6], s=RLLLRR

Product=1*2*3*4*5*6=720, 720%8=0

Remove R (6), product=1*2*3*4*5=120, 120%8=0

Remove L (1), product=2*3*4*5=120, 120%8=0

Remove L (2), product=3*4*5=60, 60%8=4

Remove L (3), product=4*5=20, 20%8=4

Remove R (5), product=4, 4%8=4

Remove R (4), array empty

Outputs: 0,0,0,4,4,4

Which matches the sample.

So, in these cases, it seems to work.

But I need to confirm if this approach is generally correct.

The approach is:

- Compute the product of all elements.

- At each step, divide the product by the removed element (only if the element divides the product) and take modulo m.

- If the element does not divide the product, set the product to 0.

But in the above examples, the element always divides the product, so it works.

But is this always the case?

Wait, suppose m=6, a=[2,3], s=LR

Product=2*3=6, 6%6=0

Remove L (2), 6//2=3, 3%6=3

Remove R (3), 3//3=1, 1%6=1

But actual products should be:

Initial: 2*3=6%6=0

After removing L (2), array: [3], 3%6=3

After removing R (3), array empty

So, outputs: 0,3,1

Which matches the above approach.

Another test case:

n=3, m=4, a=[2,2,2], s=RRR

Product=2*2*2=8, 8%4=0

Remove R (2), 8//2=4, 4%4=0

Remove R (2), 4//2=2, 2%4=2

Remove R (2), 2//2=1, 1%4=1

Outputs: 0,0,2,1

Actual:

Initial: 2*2*2=8%4=0

Remove R (2), array: [2,2], product=4%4=0

Remove R (2), array: [2], product=2%4=2

Remove R (2), array empty

Outputs: 0,0,2,1

Again, matches.

So, it seems that in these cases, the element always divides the current product.

Is this always true?

Wait, suppose m=4, a=[2,3], s=LR

Product=2*3=6, 6%4=2

Remove L (2), 6//2=3, but 3*2=6 != original product, so this is incorrect.

Wait, but 6%4=2, and 3%4=3, which is not equal to the actual product after removing 2, which should be 3%4=3.

Wait, in this case, the approach gives 2 (initial), then 3 after removing 2, which matches the actual product modulo m.

So, it seems to work.

Another test case:

n=2, m=4, a=[2,3], s=RL

Product=2*3=6, 6%4=2

Remove R (3), 6//3=2, 2%4=2

Remove L (2), 2//2=1, 1%4=1

Actual:

Initial: 2*3=6%4=2

Remove R (3), array: [2], 2%4=2

Remove L (2), array empty

Outputs: 2,2,1

Which matches the approach.

So, perhaps this approach is correct.

Wait, but in the earlier case where m=4, a=[2,3], s=LR:

Approach:

Product=6%4=2

Remove L (2), 6//2=3%4=3

Actual product after removal: 3%4=3

Then remove R (3), 3//3=1%4=1

Actual product after removal: 1%4=1

Which matches.

So, perhaps in all cases, the removed element divides the current product.

Is this always true?

Wait, suppose m=4, a=[1,2], s=LR

Product=1*2=2%4=2

Remove L (1), 2//1=2%4=2

Actual product after removal: 2%4=2

Then remove R (2), 2//2=1%4=1

Actual product after removal: 1%4=1

Matches.

Another case: m=4, a=[1,3], s=LR

Product=1*3=3%4=3

Remove L (1), 3//1=3%4=3

Actual product after removal: 3%4=3

Then remove R (3), 3//3=1%4=1

Actual product after removal: 1%4=1

Matches.

Another case: m=4, a=[1,2], s=RR

Product=1*2=2%4=2

Remove R (2), 2//2=1%4=1

Actual product after removal: 1%