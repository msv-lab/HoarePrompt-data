Alright, I have this problem to solve. It involves a game between Alice and Bob on an array of integers, and I need to determine the final score of the game when both play optimally. The score is defined as the MEX of the array that Alice collects. MEX is the smallest non-negative integer not present in the array.

First, I need to understand the game rules clearly:

1. The game is played on an array `a` of size `n`.

2. Alice starts with an empty array `c`.

3. Players take turns, with Alice going first.

4. On Alice's turn, she picks one element from `a`, appends it to `c`, and deletes it from `a`.

5. On Bob's turn, he picks one element from `a`, deletes it from `a`, but does not add it to `c`.

6. The game ends when `a` is empty.

7. The score is the MEX of `c` at the end of the game.

8. Alice wants to maximize the score, while Bob wants to minimize it.

My task is to find the final score when both play optimally.

Okay, so MEX is about finding the smallest missing non-negative integer in the array `c`. Since Alice wants to maximize the MEX, she would prefer to have as many small non-negative integers in `c` as possible, ideally in order starting from 0. Bob, on the other hand, wants to minimize the MEX, so he would try to prevent Alice from collecting certain numbers.

Let me think about how the game progresses. Alice and Bob are alternately removing elements from `a`, but only Alice adds elements to `c`. Since Bob can remove any element he wants, he can potentially remove elements that Alice might need to achieve a higher MEX.

I need to model their optimal strategies:

- Alice wants to collect elements in `c` such that the MEX is as large as possible.

- Bob wants to disrupt Alice's collection to minimize the MEX of `c`.

Given that both play optimally, I need to simulate their decision-making process.

Let's consider some examples to build intuition.

**Example 1:**

Input:

4

0 0 1 1

Possible game play:

- Alice picks 1, c = [1], a = [0, 0, 1]

- Bob picks 0, a = [0, 1]

- Alice picks 0, c = [1, 0], a = [1]

- Bob picks 1, a = []

MEX of c = [1, 0] is 2.

Is this the optimal outcome?

Could Alice have done better? If Alice picks 0 first, then:

- Alice picks 0, c = [0], a = [0, 1, 1]

- Bob picks 1, a = [0, 1]

- Alice picks 1, c = [0, 1], a = [0]

- Bob picks 0, a = []

MEX of c = [0, 1] is 2 again.

Seems like MEX is 2 in both scenarios.

**Example 2:**

Input:

4

0 1 2 3

Possible game play:

- Alice picks 0, c = [0], a = [1, 2, 3]

- Bob picks 1, a = [2, 3]

- Alice picks 2, c = [0, 2], a = [3]

- Bob picks 3, a = []

MEX of c = [0, 2] is 1.

Alternatively:

- Alice picks 1, c = [1], a = [0, 2, 3]

- Bob picks 0, a = [2, 3]

- Alice picks 2, c = [1, 2], a = [3]

- Bob picks 3, a = []

MEX of c = [1, 2] is 0.

But if Alice picks 0 initially, she gets MEX 1, which is better for her.

So, in this case, the minimal MEX Alice can achieve, given Bob's opposition, is 1.

**Example 3:**

Input:

2

1 1

Possible game play:

- Alice picks 1, c = [1], a = [1]

- Bob picks 1, a = []

MEX of c = [1] is 0.

Alice cannot do better because all elements are 1, and she has to take one 1, leaving the other for Bob to remove.

So, MEX is 0.

From these examples, it seems that Alice tries to collect numbers in a way that covers as many small integers as possible, while Bob tries to hinder her by removing elements that could help her achieve a higher MEX.

I need to find a general strategy for both players.

Let me think in terms of availability and turns.

Since Alice and Bob are alternately removing elements, and Alice gets to choose which elements to add to `c`, I need to consider the sequence of choices.

One approach could be to simulate the game by considering the frequency of each number in the array and the turns of the players.

Let's consider counting the frequency of each number in `a`.

For example, in the first test case:

4

0 0 1 1

Frequency:

0: 2

1: 2

In the second test case:

4

0 1 2 3

Frequency:

0:1

1:1

2:1

3:1

In the third test case:

2

1 1

Frequency:

1:2

Now, I need to model how Alice and Bob take turns picking elements and how this affects the final composition of `c`.

Since Alice wants to maximize MEX and Bob wants to minimize it, it's a zero-sum game, and I need to find the minimax value.

But simulating the game move by move would be too slow, given the constraints (n up to 2*10^5 per test case, and t up to 2*10^4).

I need a smarter way to compute the result without simulating each move.

Let me think about MEX.

MEX is determined by the smallest missing non-negative integer in `c`.

To maximize MEX, Alice wants to have as many of the smaller integers as possible in `c`.

Bob, to minimize MEX, wants to prevent Alice from having those smaller integers.

So, in some sense, Alice is trying to collect 0, then 1, then 2, etc., while Bob is trying to stop her.

But it's not that straightforward because Bob can remove any element, not just the ones Alice wants.

Wait, but Bob can remove elements that Alice might need.

Let me think in terms of availability.

Suppose I sort the unique numbers in `a` and see how many of each are available.

Alice will try to collect 0, then 1, then 2, etc., as much as possible, considering that Bob can remove elements that Alice needs.

Given that Alice and Bob alternate turns, and Alice starts, Alice gets to choose an element each turn, and Bob removes an element each turn.

But Bob can remove any element, so he can choose to remove elements that are critical for Alice's MEX.

I need to model this interaction.

Perhaps I can think in terms of the number of times Alice can pick the numbers she needs before Bob removes them.

Let me try to formalize this.

Let's consider the numbers in increasing order, starting from 0.

For each number i, count how many times it appears in `a`.

Then, simulate the turns where Alice tries to collect i, and Bob tries to prevent her.

But again, simulating turn by turn is not efficient.

I need a better way.

Let me consider the total number of elements n.

The game will last for n turns, with Alice and Bob alternately picking elements.

Alice gets to pick n//2 elements if n is even, or (n//2)+1 elements if n is odd, since she starts first.

Wait, no.

Wait, total turns are n.

Alice moves first, so she moves on turns 1,3,5,... and Bob moves on turns 2,4,6,...

So, if n is even, Alice and Bob each make n//2 moves.

If n is odd, Alice makes (n//2)+1 moves, and Bob makes n//2 moves.

But in this problem, Alice collects one element per turn, and Bob removes one element per turn.

But Bob removes without collecting.

So, in total, Alice will have collected (n//2)+1 elements if n is odd, or n//2 if n is even.

But wait, no.

Wait, in each of Alice's turns, she picks one element to add to c and deletes it from a.

In Bob's turns, he picks one element to delete from a.

So, in total, after n turns, a is empty.

Alice has collected one element per her turn.

So, if n is even, Alice has n//2 elements in c.

If n is odd, Alice has (n//2)+1 elements in c.

But that's not necessarily the case because Bob can remove elements that Alice needs.

Wait, no, Bob removes elements from a, but Alice chooses which elements to add to c.

So, Alice can strategically choose which elements to add to c, considering that Bob will remove some elements.

But it's getting complicated.

Let me think differently.

Suppose I try to build the array c that Alice can achieve.

I need to maximize the MEX of c, considering that Bob is trying to minimize it.

So, it's like a game where Alice tries to collect numbers to maximize the MEX, and Bob tries to disrupt her by removing elements that could help her.

I need to find the minimal possible MEX that Alice can achieve despite Bob's interference.

Wait, actually, Alice wants to maximize the MEX, and Bob wants to minimize it.

So, in game theory terms, this is a minimax problem.

The final MEX is determined by the smallest i such that c doesn't contain i.

So, I need to find the smallest i such that, even when Alice tries to include i in c, Bob can prevent her from doing so.

Alternatively, I can think in terms of how many times each number appears and how many turns Alice and Bob get.

Let me try to think in terms of frequencies.

Suppose I have the frequency count of each number in a.

For each number i, if Alice wants to include i in c, she needs to pick it from a during her turn.

But Bob can remove elements from a during his turn, potentially removing elements that Alice needs.

I need to model how many times Alice can successfully include i in c, considering Bob's removals.

This seems tricky.

Let me consider a different approach.

Let me consider that Alice wants to collect as many distinct small numbers as possible.

So, she would prefer to collect 0, then 1, then 2, and so on.

Bob, to minimize the MEX, would try to prevent Alice from collecting some of these small numbers.

Given that, perhaps I can iterate through the numbers starting from 0 and see how many of them Alice can collect, considering Bob's interference.

Let me try to formalize this.

Let's sort the unique numbers in a in ascending order.

For each number i in this sorted list, count how many times it appears in a.

Then, for each i, calculate how many of them Alice can collect, considering that Bob can remove some.

Since Alice and Bob take turns, and Alice starts first, Alice can choose to collect i, but Bob can choose to remove i as well.

I need to find out, for each i, how many of them Alice can successfully collect.

Wait, perhaps I can think in terms of the number of times Alice can pick i before Bob removes all occurrences of i.

But this seems complicated.

Let me think about it differently.

Suppose I have the frequency of each number.

For each number i, if Alice wants to collect k instances of i, she needs to pick them during her turns before Bob removes them.

But Bob can remove them during his turns.

So, for each i, the number of times Alice can collect i is limited by the number of times it appears in a and how many times Bob can remove it.

Wait, perhaps I can think in terms of the available counts after considering Bob's removals.

But I'm getting stuck.

Let me look back at the examples.

In the first example:

n=4

a=[0,0,1,1]

Alice can collect one 1 and one 0, so c=[1,0], MEX=2.

In the second example:

n=4

a=[0,1,2,3]

Alice can collect 0 and 1 (if she plays optimally), so c=[0,1], MEX=2.

Wait, in the explanation, it says the MEX is 1, but according to this, it seems like 2.

Wait, in the second test case, the output is 1.

Wait, perhaps I misread.

Wait, in the second test case, n=4, a=[0,1,2,3], output is 1.

Wait, but if Alice collects 0 and 1, c=[0,1], MEX=2.

But the output is 1, so perhaps Alice cannot collect both 0 and 1.

Wait, maybe Bob can prevent Alice from collecting one of them.

Let me think.

Possible game play:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob picks 3, a=[]

MEX of c=[0,2] is 1.

Alternatively:

- Alice picks 1, c=[1], a=[0,2,3]

- Bob picks 0, a=[2,3]

- Alice picks 2, c=[1,2], a=[3]

- Bob picks 3, a=[]

MEX of c=[1,2] is 0.

So, in this case, depending on how Alice plays, she can get MEX=1 or MEX=0.

But Bob can force the MEX to be 1 by picking 1 first.

Wait, no, in the first scenario, Bob picks 1 after Alice picks 0, and then Alice picks 2, and Bob picks 3.

So, c=[0,2], MEX=1.

In the second scenario, Alice picks 1, Bob picks 0, Alice picks 2, Bob picks 3, c=[1,2], MEX=0.

So, the minimal MEX Alice can achieve, given Bob's opposition, is 1.

Hence, the output is 1.

So, in this case, Bob can force the MEX to be 1.

Similarly, in the third test case:

n=2

a=[1,1]

Alice picks one 1, c=[1], a=[1]

Bob picks 1, a=[]

MEX of c=[1] is 0.

No better option for Alice.

So, MEX is 0.

From these examples, it seems that the MEX depends on how Alice and Bob interact in choosing elements.

I need a systematic way to compute this.

Let me consider the frequency counts again.

Suppose I have the frequency count of each number in a.

I need to determine, for each number i starting from 0, whether Alice can collect at least one i.

If she can collect i, then that number is in c, and we can consider the next number.

If she cannot collect i, then i is the MEX.

But Bob is trying to prevent Alice from collecting i.

So, for each i, I need to see if Alice can collect at least one i, given that Bob is trying to prevent her from doing so.

Given that Alice and Bob take turns, and Alice starts first, the number of turns Alice gets is (n + 1) // 2, and Bob gets n // 2 turns.

But it's not just about the number of turns; it's about which elements they choose to pick.

Wait, maybe I can think in terms of the total number of elements that Alice can pick and how they cover the required numbers.

This is getting too vague.

Let me try to think in terms of a greedy approach.

Suppose Alice tries to collect numbers starting from 0 upwards, and Bob tries to disrupt her by removing elements that she needs.

So, for each i starting from 0, check if Alice can collect at least one i.

To do this, see if the number of available i's is greater than the number of times Bob can remove i's.

But I need to model this more precisely.

Let me consider that for each i, the number of times Alice can collect i is freq[i] minus the number of times Bob can remove i's.

But Bob can choose to remove i's strategically to prevent Alice from collecting them.

So, for each i, the number of times Alice can collect i is freq[i] - floor(freq[i] / 2), since Bob can remove floor(freq[i] / 2) instances of i.

Wait, perhaps.

Wait, if freq[i] is the frequency of i, then the number of times Alice can collect i is ceil(freq[i] / 2), because she gets to pick on every other turn.

Wait, no.

Wait, if freq[i] is even, Alice can pick freq[i]/2 instances, and Bob can pick freq[i]/2 instances.

If freq[i] is odd, Alice can pick (freq[i]//2) + 1 instances, and Bob can pick freq[i]//2 instances.

So, Alice can collect ceil(freq[i] / 2) instances of i.

But in our problem, Alice only needs at least one i to include i in c.

So, for each i, if ceil(freq[i] / 2) >= 1, then Alice can collect at least one i.

Otherwise, she cannot.

So, to find the MEX, find the smallest i such that ceil(freq[i] / 2) == 0.

Wait, but ceil(freq[i] / 2) == 0 only when freq[i] == 0.

Wait, no, for freq[i] >=1, ceil(freq[i]/2) >=1.

Only when freq[i] ==0, ceil(freq[i]/2) ==0.

But in that case, i is not present at all, so MEX would be i.

Wait, this seems too simplistic.

Wait, perhaps I need to consider interactions between different i's.

Because Bob can choose to remove elements that are not i but affect Alice's ability to collect i.

Wait, maybe my earlier assumption is incorrect.

Let me think of it differently.

Suppose I sort the unique elements in a and consider them in increasing order.

Start with i=0.

Check if Alice can collect at least one 0.

If yes, move to i=1, check if Alice can collect at least one 1, and so on.

If at any point Alice cannot collect i, then i is the MEX.

To check if Alice can collect at least one i, consider that she needs to pick it before Bob removes all instances of i.

So, for a given i, if freq[i] > 0, and ceil(freq[i] / 2) >=1, then Alice can collect at least one i.

But wait, ceil(freq[i]/2) >=1 when freq[i] >=1.

So, as long as freq[i] >=1, Alice can collect at least one i.

Only if freq[i] ==0, Alice cannot collect i.

But this seems too optimistic.

Because Bob can choose to remove i's in a way that Alice cannot collect them.

Wait, no.

If freq[i] >=1, Alice can always collect at least one i, because she picks first.

Even if Bob removes one i, if freq[i] >=2, Alice can still collect one i.

If freq[i] ==1, and Alice picks it, she gets it; if Bob picks it, it's removed, and Alice doesn't get it.

But Alice picks first, so if freq[i] >=1, Alice can choose to pick i on her first turn to ensure she gets it.

Wait, but if Bob can remove elements, he might remove i before Alice can pick it.

Wait, no.

Alice picks first, so if freq[i] >=1, Alice can pick i on her first turn, add it to c, and delete it from a.

Thus, she collects it.

If freq[i] >=1, Alice can always collect at least one i by picking it on her first turn.

Unless Bob picks it first.

Wait, but Alice picks first.

Wait, in the game, Alice and Bob alternate turns, with Alice starting first.

On Alice's turn, she picks one element, adds it to c, and deletes it from a.

On Bob's turn, he picks one element and deletes it from a.

So, in the first turn, Alice picks an element to add to c.

If she picks i, she collects it.

If she doesn't pick i, Bob might pick i and remove it.

So, if freq[i] >=1, Alice can choose to pick i on her first turn to ensure she collects it.

If she doesn't, Bob might pick i and remove it, making it unavailable for Alice.

Therefore, to maximize the MEX, Alice should prioritize collecting the smallest i's first.

But Bob can try to prevent Alice from collecting certain i's by removing them.

Wait, but if Alice picks first, she can always choose to pick the smallest available i.

Then Bob can either pick another i or pick a larger j.

Alice can continue to pick the smallest available i.

But Bob can try to remove elements that Alice needs.

This seems like a pursuit game, but perhaps there's a better way to model it.

Let me consider the total number of elements and the number of turns.

Total turns are n, with Alice making (n + 1) // 2 picks for c.

Bob makes n // 2 picks to remove elements.

Alice wants to maximize the MEX of c, which is the smallest missing integer in c.

So, to maximize MEX, Alice wants c to contain as many small integers as possible.

Bob wants to minimize MEX, so he wants to prevent Alice from having small integers in c.

Given that, perhaps I can think in terms of the availability of small integers after the game.

Let me consider that Alice can choose to collect the smallest available integers first.

But Bob can remove elements to prevent Alice from collecting certain integers.

I need to find a way to calculate the minimal MEX that Alice can achieve despite Bob's interference.

Let me try to think in terms of the frequency of each number.

Suppose I have the frequency count of each number in a.

For each number i starting from 0, I need to see if Alice can collect at least one i.

If she can, then MEX is greater than i, and I move to i+1.

If she cannot, then MEX is i.

To determine if Alice can collect at least one i, I need to see if freq[i] is greater than the number of times Bob can remove i before Alice picks it.

Given that Alice picks first, she can choose to pick i on her first turn.

If freq[i] >=1, Alice can pick it on her first turn and add it to c.

Bob might remove other elements, but he cannot prevent Alice from picking i if she chooses to do so on her first turn.

Therefore, if freq[i] >=1, Alice can always collect at least one i.

Only if freq[i] ==0, Alice cannot collect i.

Therefore, the MEX would be the smallest i such that freq[i] ==0.

But this seems too straightforward, and it doesn't match the sample inputs.

In the first sample input:

n=4

a=[0,0,1,1]

freq[0]=2

freq[1]=2

freq[2]=0

freq[3]=0

So, MEX should be 2, which matches the sample output.

In the second sample input:

n=4

a=[0,1,2,3]

freq[0]=1

freq[1]=1

freq[2]=1

freq[3]=1

So, MEX should be 4, but the sample output is 1.

Wait, that doesn't make sense.

Wait, MEX is the smallest missing non-negative integer.

In this case, a=[0,1,2,3], so c could be [0,1,2,3], MEX=4.

But the sample output is 1, which suggests that Bob can prevent Alice from having certain numbers.

Wait, in the explanation of the second test case, it shows that c could be [0,2], MEX=1.

So, apparently, Bob can force the MEX to be 1 by removing elements in a way that Alice cannot collect both 0 and 1.

Wait, but according to my earlier logic, if freq[i] >=1, Alice can always collect at least one i.

But in the second test case, freq[0]=1, freq[1]=1, freq[2]=1, freq[3]=1.

So, according to that, Alice can collect 0,1,2,3, MEX=4.

But the sample output is 1, which means that Bob can prevent Alice from collecting 1.

Wait, perhaps I need to consider that Bob can remove elements that Alice needs.

Let me think carefully.

In the second test case:

n=4

a=[0,1,2,3]

Possible game play:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob picks 3, a=[]

Here, c=[0,2], which has MEX=1.

Alternatively:

- Alice picks 1, c=[1], a=[0,2,3]

- Bob picks 0, a=[2,3]

- Alice picks 2, c=[1,2], a=[3]

- Bob picks 3, a=[]

Here, c=[1,2], which has MEX=0.

But the sample output is 1, which suggests that the minimal MEX Alice can achieve is 1.

Wait, perhaps the minimal MEX is the maximum over all possible plays.

Wait, no.

Wait, Alice wants to maximize MEX, Bob wants to minimize it.

So, it's a minimax problem.

The final MEX is the minimal MEX that Alice can achieve, given that Bob is trying to minimize it.

In the second test case, depending on how Alice plays, she can get MEX=1 or MEX=0.

But Bob can force MEX=1 by picking 1 after Alice picks 0.

Hence, the minimal MEX Alice can achieve is 1.

So, my earlier assumption that Alice can always collect at least one i if freq[i]>=1 is incorrect because Bob can remove elements that Alice needs.

Therefore, I need a better way to model this interaction.

Let me consider that for each i, the number of times Alice can collect i is ceil(freq[i] / 2).

Because Alice gets to pick ceil(freq[i]/2) instances of i, and Bob gets floor(freq[i]/2).

But in our case, since Alice only needs at least one i to include it in c, and she picks first, she can choose to pick i on her first turn.

But in reality, the game is more complex because the sequence of picks matters.

Wait, perhaps I can iterate through the sorted unique elements and see how many of them Alice can collect.

Let me try to simulate it.

Sort the unique elements: 0,1,2,3,...

For each i, starting from 0, check if Alice can collect at least one i.

To do this, see if freq[i] > 0.

If freq[i] > 0, Alice can pick it on her first turn, adding it to c.

Then, proceed to the next i.

If freq[i] ==0, then MEX is i.

But as we saw in the second test case, this doesn't hold because Bob can remove elements that Alice needs.

Wait, perhaps I need to consider the order in which Alice picks elements.

Wait, maybe I should iterate through the sorted unique elements and for each i, check if Alice can collect it given the remaining elements and Bob's removals.

This seems too vague.

Let me think differently.

Suppose I try to find the smallest i such that the number of times Alice can collect i is zero.

To find that, I need to calculate for each i how many times Alice can collect it.

Given that Alice picks first and both players play optimally.

Wait, perhaps I can think in terms of the number of turns Alice needs to collect i.

If freq[i] >=1, Alice can collect it in one turn.

But Bob can try to remove i to prevent Alice from collecting it.

Wait, but Alice picks first, so she can pick i first.

Hence, Alice can always collect at least one i if freq[i] >=1.

But in the second test case, that's not happening.

Wait, perhaps I need to consider that Alice has to choose which i to collect in which turn.

Given that, perhaps there is a limit to how many small i's Alice can collect, depending on the frequencies and Bob's removals.

This is getting too complicated.

Let me look for a different approach.

I recall that MEX is about the smallest missing integer.

So, perhaps I can iterate through the possible MEX values and check if Alice can achieve a MEX greater than that value.

For example, to check if Alice can achieve MEX >= k, she needs to collect all numbers from 0 to k-1.

So, I need to check if Alice can collect all numbers from 0 to k-1.

Given that, I can binary search on k to find the minimal k that Alice cannot achieve.

Wait, perhaps not.

Wait, maybe I can perform a binary search on the possible MEX values.

Let's say I want to check if Alice can achieve MEX >= k.

To do that, she needs to collect all numbers from 0 to k-1.

So, for each i from 0 to k-1, she needs to collect at least one i.

Given that, I need to check if Alice can collect all these i's despite Bob's removals.

To do this, I need to calculate the total number of turns Alice needs to collect all these i's.

For each i, the number of turns Alice needs to collect at least one i is 1, provided that freq[i] >=1.

But Bob can remove elements, potentially preventing Alice from collecting some i's.

Wait, perhaps I need to calculate the total number of turns Alice needs to collect all required i's, considering that Bob can remove elements in between.

This seems too involved.

Let me consider that for each i from 0 to k-1, if freq[i] >=1, Alice can collect it in one turn.

But Bob can remove elements, potentially removing i's that Alice hasn't collected yet.

Wait, perhaps I need to consider the sum of freq[i] for i from 0 to k-1 and see if Alice can collect at least k elements from them.

But I'm getting stuck.

Let me try to think in terms of the total number of elements Alice needs to collect to achieve MEX=k.

To achieve MEX=k, Alice needs to have all numbers from 0 to k-1 in c.

So, she needs to collect at least the numbers 0 to k-1.

But some numbers may appear multiple times in a.

So, for each i from 0 to k-1, she needs at least one i.

So, the total number of elements she needs to collect is at least k.

But she also needs to collect other elements, depending on the frequencies.

Wait, perhaps I need to calculate the minimal number of turns Alice needs to collect all numbers from 0 to k-1.

Given that, for each i from 0 to k-1, if freq[i] >=1, Alice can collect it in one turn.

But Bob can remove elements in between.

Wait, perhaps I need to calculate, for each i from 0 to k-1, the minimal number of turns Alice needs to collect i, considering that Bob can remove elements.

This seems too complex.

Let me consider that Alice needs to collect k different numbers to achieve MEX=k.

So, she needs to collect numbers 0 to k-1.

The number of turns she needs is equal to k, assuming that she can collect one new number each turn.

But Bob can remove elements to make it harder for Alice to collect these numbers.

I need to find the minimal k such that Alice cannot collect all numbers from 0 to k-1.

To do this, perhaps I can calculate, for each k, whether the total frequency of numbers from 0 to k-1 is greater than the number of times Bob can remove elements.

Wait, perhaps.

Let me define:

For a given k, consider the numbers from 0 to k-1.

Let s = sum of freq[i] for i from 0 to k-1.

Alice needs to collect at least one of each of these i's.

Bob can remove floor(s / 2) elements from these.

So, the number of i's that Alice can collect is s - floor(s / 2) = ceil(s / 2).

For Alice to collect all k i's, ceil(s / 2) >= k.

So, if ceil(s / 2) >= k, Alice can collect all k i's.

Otherwise, she cannot.

Hence, for a given k, if ceil(sum(freq[0 to k-1]) / 2) >=k, then Alice can achieve MEX >=k.

Else, she cannot.

So, to find the minimal MEX that Alice can achieve, I can find the smallest k such that ceil(sum(freq[0 to k-1]) / 2) < k.

Wait, let's test this with the sample inputs.

First test case:

n=4

a=[0,0,1,1]

sum(freq[0 to 0]) = 2

ceil(2/2)=1 >=1

sum(freq[0 to 1])=2+2=4

ceil(4/2)=2 >=2

sum(freq[0 to 2])=2+2+0=4

ceil(4/2)=2 <3

So, k=3 is the minimal k where ceil(sum(freq[0 to k-1])/2) < k.

But MEX is 2 in the first test case.

Wait, that doesn't match.

Wait, in the first test case, the output is 2.

According to this, k=3 is the minimal k where ceil(sum(freq[0 to k-1])/2) <k, which is ceil(4/2)=2 <3.

So, MEX is 3.

But the sample output is 2.

So, my formula is incorrect.

Wait, perhaps I