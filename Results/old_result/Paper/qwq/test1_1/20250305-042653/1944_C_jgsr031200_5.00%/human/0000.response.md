Alright, I've got this problem to solve. It's about a game played by Alice and Bob on an array of integers. The goal is to determine the final score of the game when both players play optimally. The score is defined as the MEX of the array that Alice collects. MEX is the smallest non-negative integer not present in the array.

First, I need to understand the game rules clearly:

1. The game is played on an array `a` of size `n`.

2. Alice starts with an empty array `c`.

3. Players take turns, with Alice going first.

4. On Alice's turn, she picks one element from `a`, appends it to `c`, and deletes it from `a`.

5. On Bob's turn, he picks one element from `a`, and deletes it from `a`.

6. The game ends when `a` is empty.

7. The score is the MEX of `c`, which is the smallest non-negative integer not in `c`.

8. Alice wants to maximize the score, while Bob wants to minimize it.

Given that both play optimally, I need to find out what the final score will be.

Alright, let's break this down.

First, I need to understand what MEX is. MEX of an array is the smallest non-negative integer not present in the array. For example:

- MEX of `[2,2,1]` is `0` (since `0` is missing).

- MEX of `[3,1,0,1]` is `2` (since `0` and `1` are present, but `2` is missing).

- MEX of `[0,3,1,2]` is `4` (since `0`, `1`, `2`, and `3` are present, but `4` is missing).

So, the goal is to have as high a MEX as possible for Alice, but Bob is trying to prevent that.

Let me think about how the game progresses.

Each turn:

- Alice picks an element for `c` and removes it from `a`.

- Bob picks an element and removes it from `a`.

This continues until `a` is empty.

The final score is the MEX of `c`.

Alice wants to maximize the MEX, which means she wants to have as many small non-negative integers in `c` as possible. Bob, on the other hand, wants to minimize the MEX, meaning he wants to prevent Alice from having those small integers in `c`.

So, it's a game of strategy where Alice tries to collect the necessary numbers to maximize the MEX, while Bob tries to hinder her by removing numbers that could help her.

I need to find out, given that both play optimally, what the final MEX will be.

Let me consider some examples to get a better understanding.

Example 1:

Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Output:

2

1

0

Let's analyze the first test case:

n = 4

a = [0, 0, 1, 1]

Possible moves:

- Alice picks 1, a becomes [0,0,1], c = [1]

- Bob picks 0, a becomes [0,1], c = [1]

- Alice picks 0, a becomes [1], c = [1,0]

- Bob picks 1, a becomes empty, c = [1,0]

MEX of [1,0] is 2.

Is this the optimal play? Let's see.

Another possible sequence:

- Alice picks 0, a becomes [0,1,1], c = [0]

- Bob picks 1, a becomes [0,1], c = [0]

- Alice picks 1, a becomes [0], c = [0,1]

- Bob picks 0, a becomes empty, c = [0,1]

MEX is still 2.

Another sequence:

- Alice picks 1, a becomes [0,0,1], c = [1]

- Bob picks 1, a becomes [0,0], c = [1]

- Alice picks 0, a becomes [0], c = [1,0]

- Bob picks 0, a becomes empty, c = [1,0]

MEX is 2 again.

Seems like no matter how they play, MEX is 2.

Second test case:

n = 4

a = [0,1,2,3]

Possible moves:

- Alice picks 0, a becomes [1,2,3], c = [0]

- Bob picks 1, a becomes [2,3], c = [0]

- Alice picks 2, a becomes [3], c = [0,2]

- Bob picks 3, a becomes empty, c = [0,2]

MEX is 1, since 1 is missing.

Another sequence:

- Alice picks 1, a becomes [0,2,3], c = [1]

- Bob picks 0, a becomes [2,3], c = [1]

- Alice picks 2, a becomes [3], c = [1,2]

- Bob picks 3, a becomes empty, c = [1,2,3]

MEX is 0, since 0 is missing.

Wait, but according to the output, it's 1. So perhaps the optimal play leads to MEX 1.

Wait, maybe I missed something.

Wait, perhaps Alice can't always pick the numbers she wants, depending on Bob's actions.

This seems complicated.

Third test case:

n = 2

a = [1,1]

Possible moves:

- Alice picks 1, a becomes [1], c = [1]

- Bob picks 1, a becomes empty, c = [1]

MEX is 0, since 0 is missing.

Another sequence:

- Alice picks 1, a becomes [1], c = [1]

- Bob picks 1, a becomes empty, c = [1]

Same result.

So, output is 0.

Alright, now I need to think about a general strategy.

Let me think in terms of game theory. This is a game where two players are making choices that affect the final composition of array `c`, and hence the MEX.

Alice wants to maximize the MEX, which means she wants to have as many of the smaller non-negative integers in `c` as possible. Bob wants to minimize the MEX, so he wants to prevent Alice from having those smaller integers in `c`.

Given that both play optimally, I need to model their strategies accordingly.

Let me consider that the game is turn-based, perfect information, and deterministic. So, I can think in terms of game tree and maybe try to find a way to simulate the game or find a pattern.

But simulating the game move by move for each test case would be too slow, given the constraints (n up to 2*10^5 and t up to 2*10^4, with total n across all test cases up to 2*10^5). So, I need a smarter approach.

Perhaps I can think in terms of the frequency of each number in the array and how Alice and Bob can influence the final composition of `c`.

Let's consider that Alice can choose any number to add to `c`, and Bob can choose any number to remove from `a`. They both play optimally.

I need to find out, for each possible MEX value, whether Alice can force that MEX or higher, and Bob can force it to be lower.

Wait, perhaps I can think in terms of the number of available copies of each number.

Let's consider that for MEX to be k, Alice needs to have all numbers from 0 to k-1 in her array `c`.

So, for each k, I need to check if Alice can collect all numbers from 0 to k-1 despite Bob's efforts.

Given that, I can think of it as a game where Alice is trying to collect certain numbers, and Bob is trying to prevent her from collecting them.

Let me consider the frequency of each number in the array.

Let's say I have the count of each number in the array.

For a given k, Alice needs to have all numbers from 0 to k-1 in her array `c`.

Each number can be either picked by Alice for `c`, picked by Alice not for `c`, or picked by Bob.

But Alice can choose to pick a number for `c` or not.

Wait, actually, Alice always picks a number for `c` on her turn.

Bob just picks a number to remove.

So, Alice has control over what goes into `c`, but Bob can influence what numbers are available for Alice to pick.

Wait, no. Alice picks a number and appends it to `c`, then deletes it from `a`. Bob picks a number and deletes it from `a`.

So, in each turn, one number is added to `c` by Alice, and one number is removed from `a` by Bob.

The game ends when `a` is empty.

The question is: what is the MEX of `c` at the end, assuming both play optimally.

I need to find a way to determine the highest possible MEX that Alice can achieve, given that Bob is trying to minimize it.

Let me try to think differently.

Suppose I try to maximize the MEX, which means Alice wants to have as many small numbers in `c` as possible.

Bob, on the other hand, wants to minimize the MEX, so he wants to prevent Alice from having those small numbers in `c`.

Given that, perhaps I can model this as a game where Alice is trying to collect certain numbers, and Bob is trying to deny her those numbers.

Let me consider the frequency of each number.

Let's say I have counts of each number from 0 to n-1.

For MEX to be k, Alice must have all numbers from 0 to k-1 in `c`.

So, for each k, I need to check if Alice can collect all numbers from 0 to k-1, given that Bob is trying to prevent it.

I need to find the smallest k where Alice cannot collect all numbers from 0 to k-1.

In other words, the MEX will be the smallest k such that Alice cannot collect all numbers from 0 to k-1.

So, I need to find the minimal k where Alice cannot guarantee having all numbers from 0 to k-1 in `c`.

Given that, perhaps I can perform a binary search on k.

But given the constraints, I need an efficient way to compute this.

Wait, maybe I can think in terms of the number of turns.

Total turns are n turns, with Alice and Bob alternating, Alice starting.

So, total moves: n.

Alice moves: ceil(n/2)

Bob moves: floor(n/2)

Wait, no.

Wait, Alice moves first, then Bob, then Alice, and so on, until a is empty.

So, if n is even, Alice and Bob each make n/2 moves.

If n is odd, Alice makes ceil(n/2) moves, Bob makes floor(n/2) moves.

Wait, no.

Wait, total operations: n deletions.

Alice deletes one and adds to c, Bob deletes one.

So, Alice performs floor((n+1)/2) moves, Bob performs floor(n/2) moves.

Wait, let's think.

First move: Alice picks and adds to c, deletes from a.

Second move: Bob picks and deletes from a.

Third move: Alice picks and adds to c, deletes from a.

And so on.

So, total operations: n deletions.

Number of Alice's moves: ceil(n/2)

Number of Bob's moves: floor(n/2)

Yes.

So, Alice makes ceil(n/2) moves, each time adding one number to c.

Bob makes floor(n/2) moves.

So, c will have ceil(n/2) numbers at the end.

But c may have duplicates.

Wait, but the MEX is about the presence of numbers, not their frequency.

So, duplicates don't matter for MEX.

So, MEX is determined by which numbers are present in c, not how many times.

So, I need to find which numbers are in c.

But Alice can choose which numbers to put in c.

Bob can choose which numbers to remove from a, thereby affecting which numbers are available for Alice to choose.

So, it's a strategic game.

Let me try to think in terms of availability.

For Alice to have a certain number in c, she needs to pick it when it's available, before Bob can remove it.

But Bob can remove any number from a on his turn.

So, Bob can choose to remove numbers that Alice needs to maximize the MEX.

Similarly, Alice can choose to pick the numbers that are crucial for achieving a higher MEX.

So, it's a game where Alice tries to collect the necessary numbers, and Bob tries to prevent her from doing so.

I need to find the minimal k such that Alice cannot collect all numbers from 0 to k-1 in c.

In other words, the MEX will be the smallest k where, even with optimal play, Alice cannot guarantee having all numbers from 0 to k-1 in c.

Given that, perhaps I can iterate through k from 0 upwards, and check if Alice can collect all numbers from 0 to k-1.

To do this efficiently, I need a way to determine, for a given k, whether Alice can collect all numbers from 0 to k-1.

Let me consider the counts of each number in the array.

Let’s denote count[i] as the frequency of number i in the array.

For Alice to collect all numbers from 0 to k-1, she needs to have at least one of each of these numbers in c.

Bob can try to prevent this by removing numbers that Alice needs.

So, for each number from 0 to k-1, the number of times it appears in the array is count[i].

Alice needs at least one of each i from 0 to k-1.

Bob can try to remove these numbers to prevent Alice from collecting them.

Given that Alice and Bob take turns, with Alice going first, and Alice getting ceil(n/2) moves, while Bob gets floor(n/2) moves.

Wait, perhaps I need to think in terms of the number of available copies.

For each number i from 0 to k-1, the number of times it appears in the array is count[i].

Alice needs at least one of each of these numbers.

Bob can remove any number from a, trying to deny Alice these numbers.

I need to find out, for a given k, whether Alice can collect all numbers from 0 to k-1, given that Bob is trying to prevent it.

Let me think about it in terms of the total number of critical items and the total number of non-critical items.

Critical items are numbers from 0 to k-1.

Non-critical items are numbers greater than or equal to k.

Alice needs to collect all critical items.

Bob can try to remove critical items to prevent Alice from collecting them.

Alice can choose to pick critical items for c or non-critical items for c.

Wait, but Alice wants to maximize the MEX, so she would prefer to collect critical items.

Bob wants to minimize the MEX, so he would prefer to remove critical items.

So, the struggle is over the critical items.

Let me think about it in terms of the number of critical items and the number of moves.

Total critical items: sum of count[i] for i from 0 to k-1.

Total non-critical items: sum of count[i] for i from k to max(a).

Let’s denote:

- c = sum_{i=0}^{k-1} count[i]  (critical items)

- n_c = sum_{i=k}^{max(a)} count[i]  (non-critical items)

Total moves: n = c + n_c

Alice's moves: ceil(n / 2)

Bob's moves: floor(n / 2)

Alice needs to collect at least one of each critical item in c.

Bob can remove critical items to make it difficult for Alice.

So, for Alice to collect all critical items, she needs to pick them before Bob removes them.

Let me think about it in terms of the number of times each critical item can be removed by Bob.

Wait, perhaps I can model it as a race between Alice and Bob to control the critical items.

For each critical item i (from 0 to k-1), Alice needs to pick at least one instance of i before Bob removes all instances of i.

So, for each i in 0 to k-1, if count[i] = f, then Bob can remove up to f-1 instances, and Alice can still pick one.

Wait, but Bob can remove any number, not just i.

So, Bob can choose to remove critical items to make it hard for Alice.

Wait, perhaps I need to think in terms of the total number of critical items and the number of moves.

Total critical items: c

Alice's moves: ceil(n / 2)

Bob's moves: floor(n / 2)

Alice needs to collect at least one of each critical item.

But she can only pick one item per move, and Bob can remove any item per move.

This seems tricky.

Let me try to find a condition where Alice can collect all critical items.

Suppose that for each critical item i, there are count[i] copies.

Bob can remove up to floor(n / 2) items in total.

Alice needs to collect at least one of each critical item before Bob removes them all.

Wait, for a critical item i, if count[i] > 0, Alice can collect it as long as Bob doesn't remove all count[i] before Alice picks one.

But Bob can only remove floor(n / 2) items in total.

So, if for any critical item i, count[i] == 1, and Bob removes it, then Alice cannot collect it.

But Alice goes first, so she can pick a critical item first.

Wait, perhaps I need to think in terms of the minimal number of critical items and the number of moves.

Wait, maybe I should consider that Alice needs to collect c critical items, and Bob can remove floor(n / 2) items.

So, if c > ceil(n / 2), then Alice cannot collect all critical items.

Wait, no.

Wait, Alice has ceil(n / 2) moves to collect critical items.

Bob has floor(n / 2) moves to remove items.

But Bob can remove critical items to make it impossible for Alice to collect them.

Wait, perhaps I need to think in terms of the number of critical items and the number of moves Alice has.

If the number of critical items c <= Alice's moves, then Alice can collect all critical items.

But Bob can try to remove critical items to make it harder.

Wait, perhaps the condition is that for each critical item i, the number of times Bob can remove it is count[i] - 1.

But Bob can remove items in a way to maximize the disruption to Alice.

Wait, maybe I need to think in terms of the total number of critical items and the number of moves.

Let me consider that Alice needs to collect c critical items, and she has ceil(n / 2) moves.

Bob has floor(n / 2) moves to remove items.

If c > ceil(n / 2), then Alice cannot collect all critical items.

But this might not be accurate, because Bob might remove non-critical items.

Wait, perhaps I need to consider the worst case where Bob removes critical items whenever possible.

So, to make it hardest for Alice, Bob will remove critical items whenever he can.

Therefore, the number of critical items that Bob can remove is up to floor(n / 2).

Alice needs at least one of each critical item, so she needs c critical items.

But Bob can remove up to floor(n / 2) critical items.

So, if c > floor(n / 2), then Alice cannot collect all critical items.

Wait, no.

Wait, Alice has ceil(n / 2) moves to pick critical items.

Bob has floor(n / 2) moves to remove critical items.

So, for each critical item, Alice needs to pick it before Bob removes it.

If Bob removes a critical item, it's no longer available for Alice.

So, if Bob removes floor(n / 2) critical items, and Alice has ceil(n / 2) moves to pick critical items, but if c <= floor(n / 2), then Bob can remove all critical items, making it impossible for Alice to collect any.

Wait, no.

Wait, if c <= floor(n / 2), Bob can remove all critical items if he chooses to.

But Alice goes first, so she can pick a critical item first.

Wait, perhaps I need to think in terms of the total number of critical items and the number of moves each has.

Let me try to formalize this.

Let’s denote:

- c: total number of critical items (sum of count[i] for i from 0 to k-1)

- n_c: total number of non-critical items (sum of count[i] for i from k to max(a))

- n = c + n_c

- Alice's moves: a_m = ceil(n / 2)

- Bob's moves: b_m = floor(n / 2)

Alice needs to collect at least one of each critical item.

Bob can remove critical items to prevent Alice from collecting them.

So, for Alice to collect all critical items, she needs to pick them before Bob removes them.

In other words, for each critical item i, the number of times Bob can remove it is count[i] - 1.

But perhaps it's better to think in terms of the minimal number of moves Alice needs to collect all critical items.

Alice needs to collect c critical items.

Bob can remove up to b_m items, possibly critical ones.

So, Alice needs to collect c critical items before Bob removes them.

So, the number of critical items that Bob can remove is up to b_m.

Therefore, Alice needs c > b_m, meaning that even if Bob removes b_m critical items, Alice can still collect at least c - b_m critical items.

Wait, no.

Wait, if c > b_m, then Alice can collect at least c - b_m critical items, which would be positive.

But she needs to collect all c critical items.

Wait, perhaps I need to think differently.

Let me consider that Alice needs to collect c critical items, and she has a_m moves to do so.

Bob has b_m moves to remove critical items.

So, the effective number of critical items Alice can collect is c - b_m.

But c - b_m needs to be >= the number of unique critical items.

Wait, no.

Wait, perhaps I need to think in terms of the number of unique critical items.

Let’s denote u = k, the number of unique critical items (from 0 to k-1).

Alice needs to collect at least one of each of these u items.

Bob can remove up to b_m items.

So, if for each unique critical item, there are multiple copies, Bob needs to remove all copies except one for Alice to still collect one.

Wait, no.

Wait, for each unique critical item i (from 0 to k-1), if count[i] > 0, Alice can collect one, as long as Bob doesn't remove all count[i] copies before Alice picks one.

So, for Alice to collect one of each unique critical item, for each i from 0 to k-1, count[i] - (number of times Bob removes i) >=1.

Which means count[i] - number of times Bob removes i >=1.

So, number of times Bob removes i <= count[i] -1.

But Bob can choose to remove any items, not necessarily only i.

So, perhaps I need to consider the worst case where Bob removes as many critical items as possible.

Wait, maybe I need to think in terms of the total number of critical items and the number of moves Bob has.

Total critical items: c.

Bob can remove up to b_m items.

So, the minimal number of critical items remaining is c - b_m.

Alice needs at least u (the number of unique critical items) among these remaining critical items.

So, if c - b_m >= u, then Alice can collect all unique critical items.

Wait, but this might not be sufficient, because Bob can remove specific critical items to make it impossible for Alice to collect certain unique items.

So, perhaps I need to consider the minimal number of unique critical items that Bob can prevent Alice from collecting.

This is getting complicated.

Let me try to think differently