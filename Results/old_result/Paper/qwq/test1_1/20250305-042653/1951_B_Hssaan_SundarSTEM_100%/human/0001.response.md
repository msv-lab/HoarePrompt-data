Alright, I've got this problem to solve. Let's see what it's asking for. There are n cows with unique ratings, each in a specific position, and they're going to have a tournament where they fight in a specific sequence. The fights start between the first two cows, and then the winner continues to fight the next cow in line, and so on. The goal is to maximize the number of wins for a specific cow, which is cow k, by possibly swapping its position with another cow only once.

First, I need to understand the initial setup. We have n cows, each with a distinct rating, and they're initially in positions 1 to n. The tournament is a series of matches where the first match is between position 1 and 2, and then the winner fights the next cow in position 3, and so on, until all cows have been included.

My task is to maximize the number of wins for cow k. I can choose to swap cow k with any other cow (including keeping it in its original position) exactly once before the tournament starts.

I need to figure out the best position to place cow k to maximize its wins.

Let me think about how the tournament progresses. It's like a single-elimination tournament where the winner of each match proceeds to fight the next cow in line.

So, the key is to position cow k in such a way that it can win as many consecutive matches as possible before it loses.

Given that all ratings are unique, and higher-rated cows always win, I need to place cow k in a position where the cows it faces subsequently have lower ratings than it.

So, if I can arrange it so that cow k faces a sequence of cows with lower ratings, it will keep winning until it faces a cow with a higher rating.

Therefore, the number of wins cow k can achieve is equal to the number of subsequent cows with lower ratings than it, before encountering a cow with a higher rating.

Now, I need to decide whether to swap cow k to the first position or keep it where it is or swap it elsewhere.

Wait, actually, in the problem, we can swap cow k with any other cow, including keeping it in its original position.

So, one approach could be to consider all possible positions to place cow k and calculate the number of wins in each case, then choose the maximum.

But that sounds inefficient, especially since n can be up to 10^5 per test case, and t can be up to 10^4, with the total n across all test cases up to 10^5.

So, I need a more efficient way to compute this.

Let me think about the tournament process in more detail.

Initially, the tournament starts with the first two cows fighting. The winner then fights the next cow, and so on, until all cows have been included.

But if I swap cow k to a different position, it changes the sequence of fights.

Wait, actually, the problem says that after each match, the winner proceeds to fight the next cow in position i+1.

So, the sequence of fights is determined by the positions of the cows.

So, if I swap cow k to position p, then cow k will be in position p, and the tournament proceeds accordingly.

I need to simulate the tournament for different positions of cow k and see how many wins it can achieve.

But simulating the tournament for each possible position of cow k would be too slow.

I need a smarter way to calculate the maximum number of wins for cow k.

Let me consider that cow k, once placed in a position, will participate in the tournament based on its position.

I need to find the position where placing cow k maximizes the number of wins before it loses to a higher-rated cow.

Given that all ratings are unique, and higher-rated cows always win, I can think in terms of the sequence of ratings.

Let me consider that if cow k is placed in position p, then it will fight the cows in positions p and onwards, depending on whether it wins or loses.

Wait, actually, the tournament proceeds as follows:

- Start with position 1 vs position 2.

- The winner vs position 3.

- The winner vs position 4.

- And so on, until all cows have been included.

But if I swap cow k to position p, then the sequence of fights changes accordingly.

Wait, perhaps I can think in terms of the initial sequence and see where to place cow k to maximize its wins.

Let me consider that if I place cow k at the beginning, say position 1, then it will fight position 2, then the winner fights position 3, and so on.

But if cow k is not in position 1, I need to see how the tournament progresses until it reaches cow k.

Wait, maybe I can consider two scenarios:

1. Cow k is placed in position 1.

2. Cow k is placed in some position p > 1, and I need to see how many wins it can achieve from there.

Then, I can choose the maximum between these two scenarios.

But I need to generalize it for any position p.

Let me try to formalize this.

Letâ€™s denote the sequence of cows as s[1], s[2], ..., s[n], where s[i] is the rating of the cow in position i.

If cow k is in position p, then the tournament proceeds as follows:

- Start with s[1] vs s[2], the winner is the one with higher rating.

- The winner then vs s[3], and so on, until s[p].

- Then, cow k (in position p) fights the current winner, and then continues to fight the remaining cows.

But this seems complicated to model directly.

Maybe I can think in terms of the maximum number of consecutive cows with lower ratings that cow k can defeat before facing a stronger cow.

So, if I place cow k in position p, then it will fight the cows from position p onwards, skipping those that have already been eliminated.

But this is still tricky.

Let me consider that in the tournament, the winner of each match is the one with the higher rating, and the loser is eliminated.

So, effectively, the tournament is determining the maximum rating among all cows, but in a specific sequence.

But I need to focus on cow k and maximize its wins.

Let me consider that cow k can win against all cows with lower ratings until it faces a cow with a higher rating.

So, if I sort all cows by their ratings in descending order, the highest-rated cow will win the entire tournament.

But I need to maximize the number of wins for cow k, which means placing it in a position where it can win against as many cows with lower ratings as possible before facing a stronger cow.

Wait, perhaps I can think in terms of the number of cows with lower ratings that are after cow k in the sequence.

Because cow k can win against those cows until it faces a stronger one.

But I need to consider the sequence of fights.

Wait, maybe I can consider the following approach:

- If I place cow k in position p, then the number of wins cow k can achieve is equal to the number of cows with lower ratings that are after position p, before encountering a cow with a higher rating.

This seems plausible.

So, for each possible position p, I can calculate the number of cows with lower ratings than cow k[p] that come after position p, until a cow with a higher rating is encountered.

Then, I can choose the position p that maximizes this number.

But calculating this directly would be O(n^2), which is too slow for n up to 10^5 per test case.

I need a more efficient way to compute this.

Let me think about the initial sequence without any swaps.

In the initial sequence, cow k is at position k.

I can simulate the tournament and count how many wins cow k achieves in this case.

Then, consider swapping cow k with another cow and simulate again, but this is still too slow.

I need a smarter approach.

Let me consider that in the tournament, the winner of each match is the one with the higher rating.

So, effectively, the tournament is like a linked list where each winner points to the next cow to fight.

But managing this for each possible position of cow k seems complicated.

Wait, perhaps I can precompute for each position p, the number of wins cow k can achieve if it is placed at p.

To do this efficiently, I need to find for each p, the number of consecutive cows after p with lower ratings than cow k, until a cow with a higher rating is encountered.

This sounds like finding the number of elements less than cow k[p] until the first element greater than cow k[p].

This can be computed using some preprocessing.

Let me consider that for each cow, I can compute how many consecutive cows after it have lower ratings until a higher-rated cow is encountered.

Then, for cow k, I can use this precomputed value for each possible position p.

This seems promising.

So, I can precompute for each position p, the number of wins cow k can achieve if it is placed at p.

Then, take the maximum over all p.

But I need to make sure that cow k, when placed at p, doesn't interfere with the original sequence.

Wait, actually, when I swap cow k to position p, I need to adjust the sequence accordingly.

This is getting a bit messy.

Let me try to think differently.

Suppose I fix cow k in position p, then I need to simulate the tournament to see how many wins it can achieve.

But simulating for each p is too slow.

I need a way to compute this in O(n) or O(n log n) time.

Let me consider that in the tournament, the number of wins cow k can achieve is equal to the number of cows after it in the sequence that have lower ratings than it, until it faces a cow with a higher rating.

So, for each possible p, I can compute the number of cows j > p where a[j] < a[p], until I find a j where a[j] > a[p].

This is similar to computing the length of the decreasing sequence starting from p.

Wait, but it's not exactly decreasing because cow k can only win against cows with lower ratings.

So, it's the number of consecutive cows with lower ratings after p, until a cow with a higher rating is encountered.

This is similar to computing the number of elements less than a[p] in the suffix starting from p, until the first element greater than a[p] is found.

This can be precomputed efficiently.

Let me think about how to precompute this.

I can iterate from the end to the beginning, keeping track of the maximum value seen so far.

For each position p, the number of wins is the number of cows between p and the next higher cow.

Wait, perhaps I can use a stack to compute, for each p, the position of the next higher cow to the right.

Then, the number of wins is the number of cows between p and the next higher cow minus one (since it's the number of wins before losing).

Wait, no, it's the number of cows between p and the next higher cow, because each win corresponds to defeating one cow.

So, if the next higher cow is at position q, then the number of wins is q - p - 1.

But I need to handle the case where there is no higher cow to the right, meaning cow k can win all remaining matches.

Also, I need to consider that if I swap cow k to position p, I need to make sure that cow k reaches position p in the tournament.

This is getting complicated.

Let me try to formalize the steps.

1. For each position p, compute the number of wins cow k can achieve if it is placed at p.

2. Choose the p that maximizes this number.

To compute the number of wins for cow k at position p:

- Place cow k at position p.

- Simulate the tournament until cow k is involved.

- Once cow k is involved, count how many wins it achieves before losing.

But simulating for each p is too slow.

I need a better way.

Let me consider that the tournament is a sequence of matches where the winner of the previous match fights the next cow in line.

So, the winner progresses to fight the next cow.

Therefore, the number of wins cow k achieves is determined by how many cows it can defeat consecutively before losing.

To maximize this, I need to place cow k in a position where the subsequent cows have lower ratings, allowing it to win more matches.

So, the key is to find the position p where the number of consecutive cows with lower ratings after p is maximized, before encountering a cow with a higher rating.

This sounds like finding the length of the longest decreasing subarray starting at p.

Yes, exactly.

So, for each p, I can compute the length of the decreasing subarray starting at p.

Then, the number of wins is equal to this length.

But I need to make sure that if I place cow k at p, it can reach that position in the tournament.

Wait, no, actually, if I swap cow k to p, then cow k is at p, and the tournament proceeds accordingly.

So, I just need to compute, for each p, the number of consecutive cows after p with lower ratings than cow k[p], until a cow with a higher rating is encountered.

Then, the maximum over all p of these values will be the answer.

Wait, but cow k's rating is fixed; it's a[k-1].

So, when I swap cow k to position p, its rating remains a[k-1], but its position is now p.

So, I need to compute, for each p, the number of consecutive cows after p with ratings less than a[k-1], until a cow with rating greater than a[k-1] is encountered.

Then, the maximum over all p of these values plus one (since cow k can also win against the cow at position p if p >1 and the previous winner has a lower rating).

Wait, I need to be careful here.

Let me try to formalize this.

Define for each position p, the number of wins cow k can achieve if placed at p as follows:

- If p ==1:

- Cow k fights position 2, then the winner fights position 3, and so on.

- The number of wins is the number of consecutive cows after p with ratings less than a[k-1], until a cow with rating greater than a[k-1] is encountered.

- If p >1:

- First, the tournament proceeds until cow k is involved.

- The winner of the previous match fights cow k.

- If the winner has a higher rating than a[k-1], cow k loses immediately.

- Otherwise, cow k wins and continues to fight the next cows until it faces a cow with a higher rating.

This seems a bit involved.

Maybe I can consider two cases:

1. Cow k is placed at position 1.

2. Cow k is placed at some position p >1.

For case 1:

- Cow k fights position 2, then the winner fights position 3, and so on.

- The number of wins is the number of consecutive cows after position 1 with ratings less than a[k-1], until a cow with rating greater than a[k-1] is encountered.

For case 2:

- The tournament proceeds until cow k is involved.

- Suppose cow k is at position p.

- The winner of the first p-1 matches fights cow k.

- If the winner of the first p-1 matches has a higher rating than a[k-1], cow k loses immediately.

- Otherwise, cow k wins and continues to fight the remaining cows, winning against those with lower ratings until it faces a cow with a higher rating.

So, for case 2, the number of wins is:

- If the winner of the first p-1 matches has a higher rating than a[k-1], then 0.

- Else, 1 (for winning against the winner of the first p-1 matches) plus the number of consecutive cows after p with ratings less than a[k-1], until a cow with rating greater than a[k-1] is encountered.

This seems manageable.

So, to compute this efficiently, I need to:

1. Precompute for each position p, the winner of the first p-1 matches.

2. For each p, check if the winner of the first p-1 matches has a lower rating than a[k-1].

- If yes, then cow k wins against this winner and can continue to win against the next cows with lower ratings.

- The number of wins is 1 (for winning against the winner of the first p-1 matches) plus the number of consecutive cows after p with ratings less than a[k-1], until a cow with rating greater than a[k-1] is encountered.

- If no, then cow k loses immediately, and the number of wins is 0.

3. For p=1, the winner of the first p-1 matches is undefined, so cow k fights position 2 directly.

So, I need to precompute for each p, the winner of the first p-1 matches.

Wait, but computing the winner for each p is O(n), which is acceptable.

Wait, actually, I can precompute the winner up to each position.

Let me define w[i] as the winner of the first i matches.

Then, w[1] is the winner between position 1 and 2.

w[2] is the winner between w[1] and position 3.

And so on, up to w[n-1], which is the winner of the first n-1 matches.

But I need to compute w[i] for each p to determine if cow k can win against w[p-1].

Wait, but if I place cow k at position p, then the tournament changes.

So, I need to adjust the w[i] accordingly.

This seems complicated.

Maybe I need to consider the tournament in a different way.

Let me consider that if I place cow k at position p, then:

- The winner up to position p-1 is w[p-1].

- If w[p-1] > a[k-1], then cow k loses immediately.

- Else, cow k wins and can continue to win against the next cows with lower ratings until it faces a cow with a higher rating.

So, for each p, I need to compute:

- If w[p-1] < a[k-1], then number of wins is 1 (for beating w[p-1]) plus the number of consecutive cows after p with ratings less than a[k-1], until a cow with rating greater than a[k-1] is encountered.

- Else, number of wins is 0.

Additionally, for p=1, w[0] is undefined, so cow k fights position 2 directly.

Wait, but in the initial sequence, position 1 fights position 2, but if I swap cow k to position 1, then position 1 is cow k, and position 2 is s[1].

Wait, this is getting too tangled.

I need a better approach.

Let me consider that the number of wins cow k can achieve is equal to the number of cows with lower ratings that it can defeat before facing a cow with a higher rating.

So, if I place cow k in position p, the number of wins is equal to the number of consecutive cows after p with ratings less than a[k-1], until a cow with rating greater than a[k-1] is encountered.

Plus, if p >1, I need to consider whether cow k can beat the winner of the first p-1 matches.

But this seems too involved.

Maybe I can simplify it by considering that the maximum number of wins cow k can achieve is the maximum number of cows with lower ratings that it can defeat in a row, regardless of the sequence.

But that might not be accurate because of the tournament structure.

Wait, perhaps I can consider that cow k can achieve the maximum number of wins if it is placed in a position where it can fight the maximum number of weaker cows in sequence.

So, I can find, for each p, the number of consecutive cows after p with ratings less than a[k-1], until a cow with rating greater than a[k-1] is encountered.

Then, the maximum over all p of these values would be the answer, provided that cow k can reach position p.

But I need to ensure that cow k can reach position p, meaning that if p >1, the winner of the first p-1 matches has a lower rating than a[k-1].

This is still complicated.

Let me try to think about it differently.

Suppose I fix cow k in position p, then I need to see how many cows it can defeat in a row.

To do this, I need to see:

- If p=1, cow k fights position 2, then position 3, and so on, winning against each cow with a lower rating until it faces a cow with a higher rating.

- If p>1, cow k is in position p, and the tournament proceeds as follows:

- The first p-1 matches determine a winner, say w.

- Then, w fights cow k.

- If w > a[k-1], cow k loses immediately.

- Else, cow k wins and then fights the next cows, winning against those with lower ratings until it faces a cow with a higher rating.

So, in this case, the number of wins for cow k is:

- 0, if w > a[k-1].

- 1 + the number of consecutive cows after p with ratings less than a[k-1], until a cow with rating greater than a[k-1] is encountered.

Wait, this seems manageable.

So, for each p, I can compute:

- If p=1, number of wins is the number of consecutive cows after p with ratings less than a[k-1], until a cow with rating greater than a[k-1] is encountered.

- If p>1, need to check if the winner of the first p-1 matches has a rating less than a[k-1].

- If yes, then number of wins is 1 (for beating w) plus the number of consecutive cows after p with ratings less than a[k-1], until a cow with rating greater than a[k-1] is encountered.

- Else, number of wins is 0.

So, to implement this efficiently, I need to:

1. Precompute for each p, the number of consecutive cows after p with ratings less than a[k-1], until a cow with rating greater than a[k-1] is encountered.

2. Precompute the winner of the first p-1 matches for each p.

Then, for each p, compute the number of wins based on the above rules.

But precomputing the winner of the first p-1 matches is O(n), which is acceptable.

Wait, but how do I precompute the winner of the first p-1 matches?

I can iterate from p=1 to p=n-1, keeping track of the current winner.

Let me define w[p] as the winner of the first p matches.

Then:

w[1] = max(s[0], s[1])

w[2] = max(w[1], s[2])

...

w[p] = max(w[p-1], s[p])

Wait, actually, since each match is between the current winner and the next cow, and the higher-rated cow wins, then w[p] is simply the maximum of s[0] to s[p].

So, w[p] = max(s[0], s[1], ..., s[p])

Therefore, w[p] is the maximum rating among the first p+1 cows (since p starts from 0).

Wait, let's clarify the indices.

Given that p is the match number, and matches are between the current winner and the next cow.

So, match 0: s[0] vs s[1], winner is max(s[0], s[1]).

match 1: winner of match 0 vs s[2], so w[1] = max(w[0], s[2])

...

match p-1: winner of match p-2 vs s[p], w[p-1] = max(w[p-2], s[p])

So, w[p] = max(s[0], s[1], ..., s[p])

Therefore, w[p] is the maximum of s[0] to s[p].

Got it.

So, w[p] = max(s[0] to s[p])

Then, for each p, if p=1:

number of wins is the number of consecutive s[j] for j from p+1 to n-1 where s[j] < a[k-1], until s[j] > a[k-1]

Else if p >1:

if w[p-1] < a[k-1]:

number of wins is 1 (for beating w[p-1]) plus the number of consecutive s[j] for j from p+1 to n-1 where s[j] < a[k-1], until s[j] > a[k-1]

else:

number of wins is 0

Then, the maximum over all p from 1 to n of the number of wins is the answer.

Now, to compute this efficiently, I can:

1. Precompute w[p] for p from 0 to n-1, where w[p] = max(s[0] to s[p])

2. Precompute for each p, the number of consecutive s[j] for j from p+1 to n-1 where s[j] < a[k-1], until s[j] > a[k-1]

Then, for each p from 1 to n:

- If p ==1:

- number of wins = precomputed number of consecutive s[j] < a[k-1] starting from p+1

- Else:

- if w[p-1] < a[k-1]:

- number of wins = 1 + precomputed number of consecutive s[j] < a[k-1] starting from p+1

- Else:

- number of wins = 0

Then, take the maximum over all p of the number of wins.

This seems efficient, as precomputing w[p] is O(n), and precomputing the number of consecutive s[j] < a[k-1] for each p is O(n).

Now, let's see how to implement this.

First, read t test cases.

For each test case:

- Read n and k.

- Read the array s of size n.

- Find a[k-1], the rating of cow k.

- Precompute w[p] for p from 0 to n-1, where w[p] = max(s[0] to s[p])

- Precompute for each p, the number of consecutive s[j] < a[k-1] starting from p+1, until s[j] > a[k-1]

- Then, for each p from 1 to n:

- If p ==1:

- wins = precomputed number for p+1

- Else:

- if w[p-1] < a[k-1]:

- wins = 1 + precomputed number for p+1

- Else:

- wins = 0

- Keep track of the maximum wins over all p

- Output the maximum wins.

Wait, but p starts from 1 to n, and in programming, indices start from 0.

So, need to adjust indices accordingly.

Also, need to handle the case where p+1 exceeds n.

Let me try to formalize the precomputations.

First, w[p] = max(s[0] to s[p])

This can be computed in O(n) time using a running maximum.

Second, for each p, compute the number of consecutive s[j] < a[k-1] starting from j=p+1, until s[j] > a[k-1].

This can also be precomputed in O(n) time by iterating from p=n-1 down to p=0, keeping track of how many consecutive s[j] < a[k-1].

Let me define r[p] as the number of consecutive s[j] < a[k-1] starting from j=p+1, until s[j] > a[k-1].

To compute r[p], I can iterate from p=n-1 to p=0:

- If s[p] < a[k-1]:

- r[p] = 1 + r[p+1], if p+1 < n

- Else:

- r[p] = 0

With r[n] = 0.

Then, for each p from 0 to n-1:

- If p ==0:

- wins = r[1]

- Else:

- if w[p-1] < a[k-1]:

- wins = 1 + r[p+1]

- Else:

- wins = 0

Then, take the maximum over all p of wins.

Wait, but in the first case, when p==1 (assuming p starts from 1), it should be r[p], but in the code, p starts from 0 to n-1.

I need to make sure the indices are consistent.

Let me adjust the indices to be 0-based.

So, p from 0 to n-1.

For p=0:

- Cow k is placed at position 1.

- It fights position 2 (p=1), then position 3 (p=2), etc., winning against each s[j] < a[k-1] until s[j] > a[k-1].

- So, number of wins is r[1]

For p >0:

- The winner of the first p matches is w[p-1]

- If w[p-1] < a[k-1]:

- Cow k wins against w[p-1], and then wins against the next r[p+1] cows.

- So, total wins = 1 + r[p+1]

- Else:

- Cow k loses immediately.

- So, wins =0

Then, the maximum over all p of wins is the answer.

Yes, this seems correct.

Now, let's see an example to verify.

Take the first test case:

n=6, k=1

s = [12,10,14,11,8,3]

a[k-1] = s[0] =12

Compute w[p] for p from 0 to 5:

w[0] = max(s[0]) =12

w[1] = max(s[0],s[1]) =12

w[2] = max(s[0],s[1],s[2]) =14

w[3] = max(s[0],s[1],s[2],s[3]) =14

w[4] = max(s[0],s[1],s[2],s[3],s[4]) =14

w[5] = max(s[0],s[1],s[2],s[3],s[4],s[5]) =14

Compute r[p] for p from 0 to 5:

a[k-1] =12

s = [12,10,14,11,8,3]

r[5] =0 (p=5, j=6, which is out of bounds, so 0)

s[4]=8 <12, so r[4] =1 + r[5] =1

s[3]=11 <12, r[3]=1 + r[4]=2

s[2]=14 >12, r[2]=0

s[1]=10 <12, r[1]=1 + r[2]=1

s[0]=12 >=12, r[0]=0

So, r[p] = [0,1,0,2,1,0]

Now, for each p from 0 to 5:

p=0:

- p==0, wins = r[1] =1

p=1:

- p>0, w[p-1]=w[0]=12 <12? no, 12 not less than 12, so wins=0

p=2:

- p>0, w[p-1]=w[1]=12 <12? no, so wins=0

p=3:

- p>0, w[p-1]=w[2]=14 >=12, so wins=0

p=4:

- p>0, w[p-1]=w[3]=14 >=12, so wins=0

p=5:

- p>0, w[p-1]=w[4]=14 >=12, so wins=0

So, the maximum wins is 1, which matches the first test case output.

Another test case:

n=6, k=5

s=[7,2,727,10,12,13]

a[k-1]=s[4]=12

Compute w[p] for p from 0 to 5:

w[0]=7

w[1]=max(7,2)=7

w[2]=max(7,2,727)=727

w[3]=max(7,2,727,10)=727

w[4]=max(7,2,727,10,12)=727

w[5]=max(7,2,727,10,12,13)=727

Compute r[p] for p from 0 to 5:

a[k-1]=12

s=[7,2,727,10,12,13]

r[5]=0

s[4]=12 >=12, so r[4]=0

s[3]=10 <12, r[3]=1 + r[4]=1

s[2]=727 >=12, r[2]=0

s[1]=2 <12, r[1]=1 + r[2]=1

s[0]=7 <12, r[0]=1 + r[1]=2

So, r[p]=[2,1,0,1,0,0]

Now, for each p from 0 to 5:

p=0:

- p==0, wins = r[1]=1

p=1:

- p>0, w[p-1]=w[0]=7 <12, so wins=1 + r[p+1]=1 + r[2]=1 +0=1

p=2:

- p>0, w[p-1]=w[1]=7 <12, so wins=1 + r[p+1]=1 + r[3]=1 +1=2

p=3:

- p>0, w[p-1]=w[2]=727 >=12, so wins=0

p=4:

- p>0, w[p-1]=w[3]=727 >=12, so wins=0

p=5:

- p>0, w[p-1]=w[4]=727 >=12, so wins=0

So, the maximum wins is 2, which matches the second test case output.

Another test case:

n=2, k=2

s=[1000000000,1]

a[k-1]=s[1]=1

Compute w[p] for p from 0 to1:

w[0]=1000000000

w[1]=max(1000000000,1)=1000000000

Compute r[p] for p from 0 to1:

a