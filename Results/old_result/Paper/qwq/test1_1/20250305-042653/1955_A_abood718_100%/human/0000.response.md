Alright, I have this problem to solve. Let's read it carefully.

So, the problem is about buying yogurts in a store called "Vosmiorochka." There are two ways to buy yogurts: individually at price 'a' burles each, or in pairs at price 'b' burles for two. I need to find the minimum amount of burles Maxim should spend to buy exactly 'n' yogurts.

First, I need to understand the promotion. Buying two yogurts for 'b' burles might be cheaper than buying them individually for 'a' burles each. So, sometimes it's better to buy in pairs, and sometimes it's better to buy individually.

I need to consider both options and choose the one that minimizes the total cost.

Let's think about when it's better to buy in pairs.

If buying two yogurts for 'b' is cheaper than buying them individually for 'a' each, then it's better to buy as many pairs as possible.

So, if b < 2*a, then it's better to buy in pairs.

Otherwise, it's better to buy individually.

But wait, it's not that straightforward because 'n' might be odd, so I can't buy completely in pairs.

Let me consider different cases based on the value of 'n'.

Case 1: n is even.

If n is even, then I can buy all yogurts in pairs.

So, the total cost would be (n/2) * b.

But, I need to check if buying individually is cheaper.

Wait, no. If b < 2*a, then buying in pairs is cheaper.

Else, buying individually is cheaper.

Wait, but the problem says that when buying two yogurts, I can choose to buy them at the regular price or at the promotion price.

So, for each pair of yogurts, I can choose the cheaper option between 2*a or b.

So, for n even, the total cost would be (n/2) * min(2*a, b).

For n odd, I can buy (n-1)/2 pairs and one individual yogurt.

So, total cost would be ((n-1)/2) * min(2*a, b) + a.

Wait, but I need to make sure that I'm buying exactly n yogurts.

Let me try with the example given.

In the first test case:

2 5 9

So, n=2, a=5, b=9

min(2*5, 9) = min(10, 9) = 9

So, total cost is 9, which matches the first output.

Second test case:

3 5 9

n=3, a=5, b=9

For n=3, I can buy one pair and one individual.

Cost would be min(2*5, 9) + 5 = 9 + 5 = 14, which matches the second output.

Third test case:

3 5 11

n=3, a=5, b=11

min(2*5, 11) = min(10, 11) = 10

So, total cost is 10 + 5 = 15, which matches the third output.

Fourth test case:

4 5 11

n=4, a=5, b=11

min(2*5, 11) = min(10, 11) = 10

So, for n=4, total cost is (4/2)*10 = 20, which matches the fourth output.

So, this seems correct.

Now, let's look at the provided program and see if it implements this logic correctly.

The program is:

def func():

for i in range(int(input())):

(A, B, C) = map(int, input().split())

if B * 2 < C:

print(A * B)

elif A % 2 == 0:

print(int(A * C / 2))

else:

X = A // 2

print(X * C + B)

Wait, this doesn't seem to match my earlier reasoning.

Let's analyze it step by step.

First, it reads the number of test cases, t.

Then, for each test case, it reads n, a, b.

Then, it checks if b * 2 < c. Wait, no, it's (A, B, C) = map(int, input().split()), so A is n, B is a, C is b.

So, if B * 2 < C:

print(A * B)

Else if A % 2 == 0:

print(int(A * C / 2))

Else:

X = A // 2

print(X * C + B)

Wait, this seems incorrect.

First, in the if condition, it checks if 2*a < b.

If yes, then it buys all yogurts individually: A * B.

Else, if A is even, it buys all in pairs: (A * C) / 2.

Else, it buys X pairs and one individual: X * C + B, where X = A // 2.

Wait, but in the earlier reasoning, for even n, it should be (A / 2) * min(2*B, C).

Similarly, for odd n, it should be (A // 2) * min(2*B, C) + B.

But in the code, it's using min(2*B, C) implicitly.

Wait, in the if condition, if 2*B < C, then it chooses to buy individually: A * B.

Else, if A is even, it buys in pairs: (A * C) / 2.

Else, it buys (A // 2) pairs and one individual: X * C + B.

Wait, in the else clause, it's using X = A // 2, which is correct, and then X * C + B, which seems correct.

But in the elif clause, it's printing int(A * C / 2), which is equivalent to (A / 2) * C.

But, according to the earlier reasoning, it should be (A / 2) * min(2*B, C).

Wait, but in the if condition, it already checked if 2*B < C.

If 2*B < C, then it chooses to buy individually: A * B.

Else, if A is even, it buys in pairs: (A / 2) * C.

Which is correct, because if 2*B >= C, then buying in pairs is cheaper.

Hence, for even A, it's better to buy in pairs: (A / 2) * C.

For odd A, buy (A // 2) pairs and one individual: (A // 2)*C + B.

Wait, but in the else clause, it's using X = A // 2, which is correct, and then X * C + B, which is correct.

In the elif clause, for even A, it's printing int(A * C / 2), which is correct.

But, in the if clause, it's checking if 2*B < C, then it buys all individually: A * B.

Is this correct?

Wait, if 2*B < C, then buying individually is cheaper than buying in pairs.

So, for even A, buying in pairs would cost (A / 2) * C.

But, since 2*B < C, it's better to buy individually: A * B.

Hence, the if condition is correct.

Similarly, for odd A, if 2*B >= C, then it's better to buy as many pairs as possible and one individually.

Which is what the else clause does.

Hence, the program seems correct.

Let me verify with the third test case:

n=3, a=5, b=11

2*5=10 < 11, so 2*B < C, so it goes to the if clause and prints A*B = 3*5=15, which matches the third output.

Wait, but according to my earlier reasoning, for n=3, a=5, b=11, min(2*5,11)=10, so total cost is 10 + 5 =15.

But according to the program, since 2*5=10 <11, it buys all individually: 3*5=15.

Which is the same as buying one pair at 10 and one at 5.

So, in this case, it's coincidental.

But, is the program always correct?

Let me consider another example.

Suppose n=4, a=5, b=8.

Then, 2*5=10 >8, so it's better to buy in pairs.

Total cost: (4/2)*8=16.

According to the program:

2*5=10 >8, so it goes to the elif clause since A=4 is even: print(int(4*8/2)=16), which is correct.

Another example: n=3, a=5, b=8.

2*5=10 >8, so it's better to buy in pairs.

So, buy one pair at 8 and one at 5, total 13.

According to the program:

2*5=10 >8, so since A=3 is odd, it goes to else clause: X=3//2=1, so 1*8 +5=13, which is correct.

Another example: n=2, a=5, b=9.

2*5=10 >9, so buy in pairs: 9.

According to the program:

2*5=10 >9, so since A=2 is even, it goes to elif clause: int(2*9/2)=9, which is correct.

Another example: n=1, a=5, b=9.

2*5=10 >9, but n=1 is odd, so buy one at 5.

According to the program:

2*5=10 >9, so else clause: X=1//2=0, so 0*9 +5=5, which is correct.

Another example: n=4, a=3, b=5.

2*3=6 >5, so buy in pairs: (4/2)*5=10.

According to the program:

2*3=6 >5, A=4 even, so int(4*5/2)=10, which is correct.

Another example: n=5, a=3, b=5.

2*3=6 >5, so buy 2 pairs and one individual: 2*5 +3=13.

According to the program:

2*3=6 >5, A=5 odd, so X=5//2=2, so 2*5 +3=13, which is correct.

Another example: n=2, a=4, b=7.

2*4=8 >7, so buy in pairs:7.

According to the program:

2*4=8 >7, A=2 even, so int(2*7/2)=7, which is correct.

Another example: n=3, a=4, b=7.

2*4=8 >7, so buy one pair and one individual:7+4=11.

According to the program:

2*4=8 >7, A=3 odd, so X=3//2=1, so 1*7 +4=11, which is correct.

Another example: n=2, a=4, b=8.

2*4=8 ==8, so it's indifferent.

According to the program:

2*4=8 ==8, so since 2*4 is not less than 8, it goes to elif since A=2 even: int(2*8/2)=8, which is correct.

Another example: n=1, a=4, b=8.

2*4=8 ==8, but n=1, so buy one at 4.

According to the program:

2*4=8 ==8, so else clause: X=1//2=0, so 0*8 +4=4, which is correct.

Seems like the program is correctly implementing the logic.

Hence, the answer is Correctness: **True**

**Final Solution**

To solve this problem, we need to determine the minimum cost for Maxim to buy exactly n yogurts given the regular price per yogurt and a promotional price for two yogurts.

## Approach

1. **Input Parsing:** 
   - Read the number of test cases, t.
   - For each test case, read the values n (number of yogurts), a (price per yogurt), and b (promotional price for two yogurts).

2. **Decision Making:**
   - If buying two yogurts individually is cheaper than the promotional price (i.e., if 2*a < b), it's better to buy all yogurts individually.
   - If n is even and buying in pairs is cheaper or equal to buying individually, buy all yogurts in pairs.
   - If n is odd, buy as many pairs as possible and buy the remaining single yogurt individually.

3. **Calculation:**
   - For even n, calculate the total cost as (n / 2) * b if buying in pairs is not more expensive than buying individually.
   - For odd n, calculate the total cost as (n // 2) * b + a.

## Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        n, a, b = map(int, input().split())
        if 2 * a < b:
            print(n * a)
        elif n % 2 == 0:
            print((n * b) // 2)
        else:
            X = n // 2
            print(X * b + a)

func()
```

## Explanation

- **Step-by-step breakdown:**
  1. Read the input values for each test case.
  2. Check if buying two yogurts individually is cheaper than the promotional price.
     - If yes, buy all yogurts individually.
     - If not, check if the number of yogurts is even.
        - If even, buy all in pairs using the promotional price.
        - If odd, buy as many pairs as possible and buy the remaining single yogurt individually.
  
- **Correctness:**
  - The approach ensures that the minimum possible cost is calculated by comparing the costs of individual and promotional purchases and choosing the optimal strategy based on the values of a and b.
  - The solution handles both even and odd quantities of yogurts appropriately, ensuring that no extra cost is incurred by unnecessary individual purchases.

By following this method, we can efficiently determine the least amount of burles Maxim needs to spend to buy exactly n yogurts.