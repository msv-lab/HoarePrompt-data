Alright, I've got this problem to solve. Let's see what it's about. So, I'm given an array of integers, and I can perform a specific operation on any element that is at least 10. The operation allows me to delete that element and insert its digits in the same position, maintaining their order. For example, if I have [12, 3, 45, 67] and I apply the operation to the third element, 45, it becomes [12, 3, 4, 5, 67]. Another example is [2, 10], and applying the operation to the second element gives [2, 1, 0].

My task is to determine whether it's possible to make the array sorted in non-decreasing order by performing this operation any number of times, possibly zero.

First, I need to understand the operation clearly. So, for any number that is 10 or above, I can split it into its individual digits and insert them in place of the number. Numbers less than 10 can't be split because they are single digits.

I need to check if, by splitting some or all of the numbers that are 10 or above, I can arrange the array in non-decreasing order.

Let's look at the examples provided:

1. Input: [12, 3, 45, 67]

   - If I split 12: [1, 2, 3, 45, 67]

   - If I split 45: [1, 2, 3, 4, 5, 67]

   - If I split 67: [1, 2, 3, 4, 5, 6, 7]

   - Any of these arrays are sorted in non-decreasing order.

   - So, the answer is YES.

2. Input: [12, 28, 5]

   - If I split 12: [1, 2, 28, 5]

   - If I split 28: [1, 2, 2, 8, 5]

   - If I split 5: It's already a single digit, can't be split.

   - None of these arrangements are sorted in non-decreasing order.

   - So, the answer is NO.

3. Input: [0, 0]

   - Already sorted.

   - So, the answer is YES.

From these examples, it seems that splitting numbers can help rearrange the array to be sorted, but not always.

Now, I need to find a general approach to determine if it's possible to sort the array by splitting numbers as described.

Let's think about how splitting affects the array:

- Splitting a number increases the length of the array by the number of digits minus one.

- The digits are inserted in the same order they appear in the number.

- So, splitting doesn't allow me to reorder the digits themselves, only to separate them into individual elements.

Given that, I need to consider all possible ways of splitting some numbers and check if any of those configurations result in a sorted array.

However, considering all possible combinations of splitting or not splitting each eligible number could be computationally expensive, especially since n can be up to 50.

I need a smarter way to approach this.

Let's consider the positions in the array and compare adjacent elements.

If the array is already sorted, I don't need to do anything.

If there is a position where arr[i] > arr[i+1], I need to see if splitting arr[i] or arr[i+1] can resolve this issue.

But splitting can only help if the digits of the split number are smaller than or equal to the next element.

Wait, maybe I should consider splitting the previous element when there is a descent.

Let me try to formalize this.

I'll iterate through the array from left to right.

At each step, I'll keep track of the last element in the current "sorted" subarray.

If the next element is greater than or equal to the last element in the subarray, I can just append it as is.

If the next element is less than the last element in the subarray, I need to see if splitting the previous element can help.

When splitting the previous element, I'm replacing it with its digits.

I need to ensure that all these digits are less than or equal to the next element.

Wait, that might not be sufficient.

Let me think differently.

Suppose I have two consecutive elements, a and b, and a > b.

I need to decide whether to split a, split b, or neither.

But splitting a would replace it with its digits, which are all less than or equal to a.

Similarly, splitting b would replace it with its digits, which are all less than or equal to b.

But since a > b, splitting a might help if its digits are less than or equal to b.

Similarly, splitting b might not help because its digits could still be less than the digits of a.

Wait, maybe it's better to consider splitting the larger number in such a descent.

Let me consider an example.

Example 1: [12, 3, 45, 67]

- Start with 12 and 3: 12 > 3 → need to split 12.

- Split 12 into [1, 2].

- Now the array becomes [1, 2, 3, 45, 67], which is sorted.

Example 2: [12, 28, 5]

- 12 > 28? No.

- 28 > 5? Yes.

- Split 28 into [2, 8].

- Array becomes [12, 2, 8, 5].

- Still, 12 > 2.

- Split 12 into [1, 2].

- Array becomes [1, 2, 2, 8, 5].

- Still, 2 > 5.

- Can't fix this.

Example 3: [0, 0]

- Already sorted.

From these, it seems that splitting numbers can help in some cases but not in others.

I need a way to model this process efficiently.

Perhaps I can think of the array as a sequence of digits, considering that splitting allows me to separate digits.

Wait, but numbers have multiple digits, and splitting separates them.

So, maybe I can consider each number as a sequence of digits, and decide whether to keep it as is or split it into its digits.

Then, I need to arrange these sequences in a way that the entire array is sorted.

This sounds similar to deciding whether to split a number or keep it whole, considering the digits.

I need to ensure that the sequence of elements, after possible splits, is sorted in non-decreasing order.

To make this efficient, perhaps I can iterate from the end of the array to the beginning, deciding for each number whether to split it or keep it whole, based on the already processed part of the array.

Let me try to formalize this approach.

I'll start from the end of the array and move towards the beginning.

I'll maintain a list that represents the current state of the array, considering the splits.

Initially, this list is empty.

For each element from the end to the beginning:

- If the element is less than 10, it's a single digit.

- If the element is 10 or more, I have the option to split it into digits or keep it as is.

- I need to decide which option allows me to maintain the sorted order.

I need to ensure that the element (or its digits, if split) is less than or equal to the previous element in the list.

Wait, actually, since I'm moving from the end to the beginning, I need to ensure that the current element (or its digits) is less than or equal to the next element in the list.

Wait, maybe it's better to iterate from the beginning to the end.

Let me try that.

Initialize an empty list.

Iterate through the array from left to right.

For each element:

- If it's less than 10, it's a single digit.

- If it's 10 or more, I can choose to split it into digits or keep it as is.

- I need to add either the number itself or its digits to the list, maintaining the sorted order.

- To maintain the sorted order, each new element or digit should be greater than or equal to the last element in the list.

Let me try this with the first example: [12, 3, 45, 67]

Initialize list: []

First element: 12

- Option 1: Keep 12.

- Add 12 to the list: [12]

- Option 2: Split 12 into [1, 2].

- Add [1, 2] to the list: [1, 2]

- Choose the option that allows further elements to be added correctly.

Second element: 3

- Current list: [12]

- 3 < 12, so need to split 12 into [1, 2].

- Now list: [1, 2]

- Add 3: [1, 2, 3]

Third element: 45

- Current list: [1, 2, 3]

- Option 1: Keep 45.

- Add 45: [1, 2, 3, 45]

- Option 2: Split 45 into [4, 5].

- Add [4, 5]: [1, 2, 3, 4, 5]

- Both options maintain the sorted order.

Fourth element: 67

- Current list: [1, 2, 3, 45]

- Option 1: Keep 67.

- Add 67: [1, 2, 3, 45, 67]

- Option 2: Split 67 into [6, 7].

- Add [6, 7]: [1, 2, 3, 45, 6, 7]

- But 6 < 45, so this would not be sorted.

- So, only keeping 67 maintains the sorted order.

Alternatively, if I chose to split 45 earlier, the list would be [1, 2, 3, 4, 5]

- Then, adding 67: [1, 2, 3, 4, 5, 67]

- Or splitting 67 into [6,7]: [1, 2, 3, 4, 5, 6,7]

- Both are sorted.

So, in this case, it's possible to have a sorted array.

Now, let's consider the second example: [12, 28, 5]

Initialize list: []

First element: 12

- Option 1: Keep 12.

- Add 12: [12]

- Option 2: Split 12 into [1,2].

- Add [1,2]: [1,2]

Second element: 28

- Current list: [12]

- 28 > 12, so can keep 28.

- Add 28: [12,28]

- Or split 28 into [2,8].

- Add [2,8]: [12,2,8]

- But 2 < 12, which breaks the sorted order.

- So, only keeping 28 maintains the sorted order.

Third element: 5

- Current list: [12,28]

- 5 < 28, so need to consider splitting 28.

- If split 28 into [2,8], then list becomes [12,2,8,5]

- 2 < 12, which is not sorted.

- Alternatively, split 5 into [5] (but 5 is less than 8).

- No way to make this sorted.

Hence, it's impossible to sort this array with the given operations.

From this, it seems that the approach of building the list step by step, choosing to split or not split each number as needed, can determine if a sorted array is achievable.

However, implementing this directly could be inefficient for n=50, as it might require considering all possible combinations of splitting or not splitting numbers.

I need a more efficient way.

Let me consider that splitting a number into its digits always results in digits that are less than or equal to the number itself.

For example, splitting 12 gives [1,2], both less than or equal to 12.

Similarly, splitting 45 gives [4,5], both less than or equal to 45.

So, splitting a number can only help in making the array sorted if the digits are smaller and can fit into the sequence.

Given that, perhaps I can iterate through the array and whenever I find a descent (arr[i] > arr[i+1]), I can check if splitting arr[i] can resolve it.

But I need to ensure that all digits of arr[i] are less than or equal to arr[i+1].

Wait, that might not be sufficient.

Let me think about it.

Suppose I have [23, 4, 56].

- 23 > 4 → need to split 23 into [2,3].

- Now, the array becomes [2,3,4,56].

- Which is sorted.

So, in this case, splitting 23 resolves the issue.

But what if I have [34, 5, 45].

- 34 > 5 → split 34 into [3,4].

- Now, the array becomes [3,4,5,45].

- Which is sorted.

Seems to work.

But consider [34, 5, 4].

- 34 > 5 → split 34 into [3,4].

- Array becomes [3,4,5,4].

- Now, 4 > 4, which is equal, so it's still sorted.

Wait, 4 == 4 is allowed in non-decreasing order.

Wait, no, 4 == 4 is allowed, but in the last step, 5 > 4, which is a problem.

Wait, no, the array would be [3,4,5,4].

Here, 4 <=5, but then 5 >4, which is fine in non-decreasing order, since 4 <=5.

Wait, no, in non-decreasing order, each element should be <= the next one.

So, [3,4,5,4] is not sorted because 5 >4.

Hence, this arrangement is not sorted.

Alternatively, if I split 5 into [5], but 5 is a single digit, can't be split.

So, in this case, it's impossible to sort [34,5,4].

Hence, the answer is NO.

So, in this case, even after splitting 34, I still can't sort the array because 5 and 4 create a descent that can't be resolved.

Therefore, I need a way to check, for each descent, whether splitting the larger number can resolve it.

But it's not just about splitting the larger number; sometimes splitting the smaller number might help.

Wait, but in the operation described, I can only split numbers that are >=10, and only one at a time, replacing it with its digits.

So, I need to decide for each number that is >=10 whether to split it or not, in a way that the entire array becomes sorted.

This sounds like a dynamic programming problem, where I keep track of the state of the array as I process each element, considering both options: split or not split.

However, with n=50, and each number potentially having up to 2 digits, the state space could be manageable.

But perhaps there's a smarter way.

Let me consider that after splitting some numbers, the array will consist of single digits.

Wait, no, because numbers less than 10 are not split, so they remain as they are.

Wait, but numbers less than 10 can't be split, so they stay as single digits.

Numbers 10 or above can be split into their digits, which are single digits.

So, in the final array, some elements are original numbers less than 10, and others are digits from split numbers that were 10 or above.

Hence, the final array consists only of single digits.

Wait, no, because if a number >=10 is not split, it remains as is, which could be a two-digit number.

Hence, the final array can have a mix of single-digit numbers and two-digit numbers, depending on which numbers were split.

Wait, no, numbers >=10 can be split into their digits, which are single digits, or kept as is.

So, the final array can have elements that are either original numbers less than 10 or digits from split numbers.

Hence, all elements in the final array are single digits.

Wait, but if I choose not to split a number >=10, it remains as is, which is a two-digit number.

So, the final array can have a mix of single digits and two-digit numbers.

Hence, I need to consider both possibilities.

This complicates things.

Let me try to think differently.

Suppose I consider all possible splits for each number >=10, and see if any combination leads to a sorted array.

This is similar to generating all possible sequences by choosing to split or not split each eligible number, and checking if any of those sequences are sorted.

But with n=50, this could be computationally expensive, as the number of possible sequences could be up to 2^n, which is 2^50.

That's way too big.

Hence, I need a smarter approach.

Let me consider that splitting a number >=10 always results in digits that are less than or equal to the original number.

Hence, splitting can only help in making the array sorted by reducing the value of elements.

Given that, I can assume that for any descent in the array, I can try to split the larger number to make it smaller, in hopes of resolving the descent.

But as seen in earlier examples, this isn't always sufficient.

Hence, I need a way to systematically check if splitting some numbers can resolve all descents.

Let me try to iterate through the array and check for descents, and see if splitting the larger number can resolve them.

Here's a possible algorithm:

1. Initialize an empty list to build the sorted array.

2. Iterate through each element in the input array:

a. If the element is less than 10, it can't be split, so add it to the list.

b. If the element is 10 or more, consider both options: split it into digits or keep it as is.

c. Choose the option that allows the list to remain sorted.

3. If at any point neither option allows the list to remain sorted, conclude that it's impossible.

However, this might still be inefficient for n=50.

I need a way to optimize this.

Let me consider that splitting a number >=10 into its digits will always result in digits that are less than or equal to 9, since they are single digits.

Hence, splitting can only introduce digits from 0 to 9.

Given that, if there is a descent in the array, and the larger number is >=10, I can try splitting it into its digits to see if that resolves the descent.

But I need to ensure that all digits are less than or equal to the next element in the array.

Wait, perhaps I need to ensure that the largest digit in the split number is less than or equal to the next element.

But that might not be sufficient.

Let me think about it.

Suppose I have [12, 3, 45, 67].

- At position 0: 12 >= 3? No, 12 > 3 → need to split 12 into [1,2].

- Now, consider [1,2,3,45,67], which is sorted.

- At position 1: 2 <=3 → okay.

- At position 2: 3 <=45 → okay.

- At position 3: 45 <=67 → okay.

Another example: [12, 28, 5].

- At position 0: 12 >=28? No, 12 <28 → okay.

- At position 1: 28 >=5? No, 28 >5 → need to split 28 into [2,8].

- Now, the array becomes [12,2,8,5].

- At position 1: 12 >=2? No → not sorted.

- Alternatively, split 12 into [1,2].

- Then the array becomes [1,2,28,5].

- Still, 28 >5 → not sorted.

- No way to make it sorted.

Hence, in this case, it's impossible.

From this, perhaps I can iterate through the array and whenever I find a descent, I check if splitting the larger number can resolve it by making sure that all its digits are less than or equal to the next element.

But this might not be enough, as seen in earlier examples.

Wait, perhaps I need to ensure that the largest digit in the split number is less than or equal to the next element.

Let me try that.

In the first example: [12,3,45,67]

- At position 0: 12 >3 → split 12 into [1,2].

- The largest digit is 2, which is <=3 → okay.

- New array: [1,2,3,45,67], which is sorted.

In the second example: [12,28,5]

- At position 0: 12 <28 → okay.

- At position 1: 28 >5 → need to split 28 into [2,8].

- The largest digit is 8, which is >5 → cannot resolve.

- Hence, impossible.

Seems promising.

Let me try another example: [34,5,45]

- At position 0: 34 >5 → split 34 into [3,4].

- The largest digit is 4, which is <=5 → okay.

- New array: [3,4,5,45], which is sorted.

Another example: [34,5,4]

- At position 0: 34 >5 → split 34 into [3,4].

- The largest digit is 4, which is >5? Wait, 4 <=5 → okay.

- New array: [3,4,5,4].

- At position 2: 5 >4 → descent.

- Cannot resolve this, since 5 cannot be split (it's <10).

- Hence, impossible.

So, in this approach, I check for each descent whether splitting the larger number into its digits, and ensuring that the largest digit is less than or equal to the next element, allows me to resolve the descent.

If I can resolve all descents this way, then it's possible to sort the array; otherwise, it's not.

This seems efficient because I can iterate through the array once, checking for descents and applying this condition.

Let me formalize this approach.

Algorithm:

1. Initialize an empty list to build the sorted array.

2. Iterate through the input array from left to right.

3. For each element:

a. If it's less than 10, add it to the list as is.

b. If it's 10 or more, check if it's greater than the next element.

i. If it is, split it into its digits and add them to the list.

ii. Ensure that the largest digit is less than or equal to the next element.

iii. If not, it's impossible to sort.

4. After processing all elements, check if the list is sorted in non-decreasing order.

5. If it is, output YES; otherwise, output NO.

Wait, but in the earlier example [34,5,4], even after splitting 34 into [3,4], the array becomes [3,4,5,4], which has a descent between 5 and 4.

Hence, in this case, it's still not sorted, even though I split 34.

Hence, this approach might not be sufficient.

I need a way to handle multiple splits and ensure that the entire array can be made sorted.

Perhaps I need to iteratively apply the splitting where necessary until no descents remain.

But this could be time-consuming for large n.

Let me consider a different approach.

Suppose I consider the array as a sequence of digits, where each number >=10 is represented by its digits, and numbers <10 are represented as is.

Then, I need to check if there's a way to choose which numbers to split such that the resulting sequence is sorted.

This sounds similar to topological sorting, where I need to order the elements based on certain constraints.

But I'm not sure.

Alternatively, perhaps I can model this as a graph, where each number is a node, and edges represent the ordering constraints.

But that might be overkill.

Let me think about the problem differently.

Suppose I have the entire array split into its digits.

For example, [12,3,45,67] becomes [1,2,3,4,5,6,7].

This is sorted.

But in reality, I can choose to keep some numbers intact if they are less than the next element.

Hence, I need to find a way to maximize the number of numbers kept intact while ensuring the array remains sorted.

Wait, maybe I need to find the longest non-decreasing subsequence consisting of numbers that are not split, and ensure that splitting the remaining numbers can fill in the gaps to make the entire array sorted.

But this seems complicated.

Let me consider that for any two consecutive elements, if the first is greater than the second, I must split the first element and ensure that all its digits are less than or equal to the second element.

If I can do this for all descents, then it's possible to sort the array.

Otherwise, it's not.

Let me try to implement this logic.

I'll iterate through the array from left to right.

I'll keep track of the last value in the current sorted subarray.

Initially, the subarray is empty.

For each element:

- If the element is less than the last value in the subarray, I need to