Alright, I have this problem to solve. It involves a game between Alice and Bob on an array, and I need to determine the final score of the game based on their optimal plays. Let's break down the problem step by step.

First, understanding the game mechanics:

- There's an array `a` of size `n`, and Alice starts with an empty array `c`.

- Players take turns, with Alice going first.

- On Alice's turn, she picks an element from `a`, appends it to `c`, and deletes it from `a`.

- On Bob's turn, he picks an element from `a`, deletes it from `a`, but does not add it to `c`.

- The game ends when `a` is empty, and the score is the MEX of `c`, which is the smallest non-negative integer not present in `c`.

- Alice wants to maximize the MEX, and Bob wants to minimize it.

My task is to find the final MEX when both play optimally.

Okay, so MEX is about finding the smallest missing non-negative integer in `c`. To maximize MEX, Alice would want to have as many small integers as possible in `c`, in order, starting from 0. Bob, wanting to minimize MEX, would try to hinder Alice's efforts.

Let's think about how the game progresses:

1. Alice picks an element to add to `c`.

2. Bob picks an element to remove from `a`.

This alternates until `a` is empty.

I need to model their optimal strategies.

First, consider that Alice wants to include as many of the smaller numbers in `c` as possible, because having 0, 1, 2, ..., up to some number will maximize the MEX.

Bob, on the other hand, wants to prevent Alice from having a complete sequence, so he will try to remove elements that could help Alice achieve this.

Let's consider some examples to get a better understanding.

Example 1:

Input:

4

0 0 1 1

Possible game:

- Alice picks 1, c = [1], a = [0, 0, 1]

- Bob picks 0, a = [0, 1]

- Alice picks 0, c = [1, 0], a = [1]

- Bob picks 1, a = []

MEX of c = [1, 0] is 2.

Is this the optimal outcome?

Could Alice have done better? If Alice picks 0 first:

- Alice picks 0, c = [0], a = [0, 1, 1]

- Bob picks 1, a = [0, 1]

- Alice picks 1, c = [0, 1], a = [1]

- Bob picks 1, a = []

MEX of c = [0, 1] is 2 again.

Another scenario:

- Alice picks 1, c = [1], a = [0, 0, 1]

- Bob picks 1, a = [0, 0]

- Alice picks 0, c = [1, 0], a = [0]

- Bob picks 0, a = []

MEX is still 2.

Seems like 2 is the best Alice can achieve in this case.

Example 2:

Input:

4

0 1 2 3

Possible game:

- Alice picks 0, c = [0], a = [1, 2, 3]

- Bob picks 1, a = [2, 3]

- Alice picks 2, c = [0, 2], a = [3]

- Bob picks 3, a = []

MEX of c = [0, 2] is 1.

Alternatively:

- Alice picks 3, c = [3], a = [0, 1, 2]

- Bob picks 0, a = [1, 2]

- Alice picks 1, c = [3, 1], a = [2]

- Bob picks 2, a = []

MEX of c = [3, 1] is 0.

Bob can force a lower MEX by removing crucial elements.

In this case, the minimal MEX Alice can achieve is 1.

Wait, but according to the sample output, it's 1.

Example 3:

Input:

2

1 1

Possible game:

- Alice picks 1, c = [1], a = [1]

- Bob picks 1, a = []

MEX of c = [1] is 0.

Seems straightforward.

From these examples, it seems that the game's outcome depends on how well Alice can collect the smallest possible numbers, and Bob tries to disrupt that by removing elements that could help Alice.

I need to find a general strategy for both players.

Let me think in terms of who can control the inclusion of certain numbers.

Alice controls which elements go into `c`, but Bob can influence what's available for Alice to pick.

Since Alice wants to include as many small numbers as possible, she would prefer to pick smaller numbers when possible.

Bob, to minimize the MEX, would want to prevent Alice from picking certain small numbers.

Wait, but Bob doesn't get to choose what goes into `c`; he only decides which element to remove from `a` on his turn.

So, Bob can remove elements that Alice might want to pick later.

This seems like a game where the order of picks matters a lot.

Let me consider the total number of turns.

Total elements: `n`.

Each turn, one element is removed from `a`.

Number of turns: `n`.

Alice and Bob alternate turns, with Alice starting.

So, Alice gets to pick `ceil(n/2)` elements to add to `c`, and Bob gets to remove `floor(n/2)` elements.

Wait, more precisely:

- Alice picks an element to add to `c` and removes it from `a`.

- Bob picks an element to remove from `a`.

So, in total, per turn:

- One element is removed from `a` by Alice.

- Another element is removed from `a` by Bob.

Wait, no.

Wait, on Alice's turn:

- She picks an element from `a`, appends it to `c`, and deletes it from `a`.

On Bob's turn:

- He picks an element from `a`, and deletes it from `a`.

So, in total, per full turn (Alice and Bob):

- Alice removes one element and adds it to `c`.

- Bob removes one element.

So, two elements are removed from `a` per full turn.

Wait, but the game ends when `a` is empty.

So, the number of full turns is floor(n/2).

Then, if `n` is odd, Alice gets one more turn.

Wait, let's think carefully.

Total operations: `n`, since each pick removes one element.

Alice picks first, then Bob, then Alice, and so on.

So, if `n` is even, Alice and Bob each pick `n/2` times.

If `n` is odd, Alice picks `(n+1)/2` times, and Bob picks `(n-1)/2` times.

But in this game, Alice not only picks but also adds to `c`, while Bob only picks and removes.

So, the number of elements in `c` at the end is equal to the number of times Alice picks, which is ceil(n/2).

But, Bob can influence which elements are available for Alice to pick.

I need to model this interaction.

Let me consider that Alice wants to include as many small numbers as possible in `c`, and Bob wants to disrupt that.

One way to think about it is that Bob can choose to remove elements that Alice would want to pick, forcing her to pick less desirable elements.

So, perhaps, the minimal MEX that Alice can achieve is determined by the minimal number that she can't include in `c`, despite Bob's interference.

Let me try to formalize this.

Suppose Alice aims to include all numbers from 0 to k in `c`. Bob will try to prevent her from doing so.

I need to find the largest k such that Alice can include all numbers from 0 to k in `c`, regardless of Bob's actions.

Wait, but MEX is the smallest missing number, so to maximize MEX, Alice wants to include as many consecutive numbers starting from 0 as possible.

Bob wants to minimize MEX, so he wants to ensure that some small number is missing from `c`.

So, the game is about Alice trying to collect a certain set of numbers, and Bob trying to prevent her from doing so.

This sounds like a game where I can model the optimal play using some kind of strategy or algorithm.

Let me consider the frequency of each number in the array.

Suppose I count how many times each number appears in the array.

Let's say I have a frequency count `freq` where `freq[i]` is the number of times `i` appears in `a`.

Alice wants to include as many small `i` in `c` as possible, and Bob wants to prevent that.

Given that Alice gets to pick `ceil(n/2)` elements to include in `c`, and Bob gets to remove `floor(n/2)` elements.

But Bob's removals can be strategic to prevent Alice from including certain elements.

Wait, more precisely, Bob can choose to remove elements that Alice would want to pick, forcing her to pick other elements.

So, perhaps, for each number `i`, I need to see if Alice can include it in `c` despite Bob's removals.

Let's consider the frequency of each `i`.

If `freq[i]` is the number of times `i` appears in `a`, then Alice needs at least one of those to be in `c` to include `i` in `c`.

Bob can choose to remove some of them.

So, for each `i`, the number of times `i` is available for Alice to pick is `freq[i] -` the number of times Bob removes `i`.

Bob will try to minimize the number of `i` that Alice can include.

Wait, perhaps I need to think in terms of the minimal number that Alice cannot include in `c`, even when she plays optimally.

So, the MEX would be the smallest such number.

To find that, I need to determine, for each `i` starting from 0, whether Alice can include `i` in `c` despite Bob's efforts.

If Alice can include all `i` from 0 to k, then the MEX is k+1.

But I need to find the minimal MEX, given both play optimally.

Wait, actually, since Alice wants to maximize MEX and Bob wants to minimize it, the final MEX is the result of their opposing strategies.

I need to find the equilibrium where Alice cannot include a certain `i`, and that `i` becomes the MEX.

Let me try to model this.

Suppose I sort the unique numbers in `a` and see how many times each is available.

Alice will prioritize including smaller numbers, and Bob will try to prevent that.

So, for each `i` in increasing order, I need to see if Alice can include it in `c`.

Given that Alice gets to pick `ceil(n/2)` elements to include, and Bob gets to remove `floor(n/2)` elements.

But Bob can choose to remove elements that Alice wants.

Wait, perhaps I can think in terms of the total number of picks Alice needs to include certain numbers.

Let me consider the frequency of each number.

Suppose I have the unique numbers sorted: 0, 1, 2, ..., up to some max.

For each number `i`, `freq[i]` is the count in `a`.

Alice needs at least one of each `i` she wants to include in `c`.

Bob can choose to remove some of them.

So, for each `i`, the number of times Alice can include `i` is `freq[i] -` the number of times Bob removes `i`.

Bob will try to minimize the number of `i` that Alice can include.

To model this, perhaps I can think of the minimal number of times Alice can include each `i`, considering Bob's interference.

Wait, maybe I should think in terms of the total number of picks Alice needs to include certain numbers.

Let me consider that Alice needs to include numbers from 0 to k in `c`.

For each `i` from 0 to k, she needs at least one instance of `i` in `c`.

Bob can remove elements, trying to prevent Alice from including some `i`.

I need to find the maximal k such that, even with Bob removing elements, Alice can still include all `i` from 0 to k in `c`.

Alternatively, I can iterate over possible MEX values and find the smallest one where Alice cannot include all smaller numbers.

Wait, perhaps a greedy approach would work.

Sort the unique numbers in `a`.

Then, for each number starting from 0, check if Alice can include it in `c`.

To do that, she needs to pick at least one instance of it, before Bob removes all instances.

But Bob can remove elements, including those that Alice wants.

Wait, perhaps I need to calculate the number of available picks for Alice for each `i`.

Let me try to formalize this.

Let's sort the unique numbers in `a`.

For each `i` in sorted order, calculate how many times it appears.

Then, for each `i`, calculate the number of times Alice can include it, considering Bob's removals.

But this seems complicated.

Let me consider the following approach:

- Sort the unique numbers in `a`.

- For each `i` from 0 to some max, check if Alice can include `i` in `c`.

- To include `i`, Alice needs to pick at least one instance of `i` before Bob removes all instances.

- So, for each `i`, the number of times Alice can pick `i` is `freq[i] -` the number of times Bob removes `i`.

- Bob will try to minimize the number of times Alice can pick `i`.

- So, for each `i`, the minimal number of times Alice can pick `i` is `max(freq[i] - removes_by_Bob, 0)`.

- But Bob has a limited number of removals.

Wait, perhaps I need to think in terms of the total number of removals Bob can make.

Total removals by Bob: floor(n/2).

So, Bob can remove up to floor(n/2) elements.

Alice can pick up to ceil(n/2) elements to include in `c`.

I need to see, for each `i`, if Alice can include at least one instance of `i` in `c`, given that Bob can remove up to floor(n/2) elements.

But Bob can choose which elements to remove to prevent Alice from including certain `i`.

So, Bob will prioritize removing elements that Alice wants, i.e., the smaller `i`.

Wait, but Bob doesn't know which elements Alice will pick; he just removes elements on his turn.

But in terms of strategy, Bob can choose to remove elements that Alice would want to pick.

This seems like a selection game where Alice tries to select certain elements, and Bob tries to block her.

Perhaps I can model this as a game where Alice needs to secure enough picks of certain elements, and Bob tries to deny her those picks.

This is getting complicated.

Let me look at the provided program and see if I can understand its logic.

Looking at the code:

def func():

T = int(input())

for _ in range(T):

S = int(input())

N = list(map(int, input().split()))

N.sort()

cur = -1

M = {}

for num in N:

if num > cur:

if num > cur + 1:

cur += 1

break

cur = num

M[cur] = 1

else:

M[cur] += 1

if sum([M[k] for k in M.keys()]) == S:

cur += 1

cnt = []

for k in M.keys():

if M[k] == 1:

cnt.append(k)

if len(cnt) >= 2:

cur = cnt[1]

print(cur)

So, the code does the following:

- Reads the number of test cases T.

- For each test case:

- Reads n and the array a.

- Sorts the array a.

- Initializes cur to -1 and an empty dictionary M.

- Iterates through the sorted array:

- If num > cur, sets cur to num and adds it to M with count 1.

- Else, increments the count of cur in M.

- If the sum of counts in M equals n, increments cur.

- Collects keys in M with count 1 into cnt.

- If there are at least two such keys, sets cur to the second one.

- Prints cur.

Wait, this seems to be trying to find the MEX based on some criteria, but it's not clear how it relates to the game.

Let me try to understand what this code is doing.

It sorts the array and then iterates through it, keeping track of the current expected number (`cur`), and building a dictionary `M` where keys are the numbers in sequence and values are their counts.

If a number in the sorted array is greater than `cur + 1`, it breaks and increments `cur`.

Then, if the sum of counts in M equals n, it increments cur again.

Finally, it looks at keys in M with count 1, and if there are at least two, sets cur to the second one.

This seems convoluted and not directly related to the game's mechanics.

I think this code is incorrect because it doesn't model the game's interaction between Alice and Bob.

The correct approach should consider the game's turns and the strategies of both players.

Let me try to think differently.

Suppose I consider the minimal number that Alice cannot include in `c`, given Bob's interference.

I can iterate through the numbers starting from 0 and check if Alice can include that number in `c`.

For each number `i`, check if freq[i] > 0, and if Alice can pick at least one instance of `i` before Bob removes all instances.

But Bob can remove elements strategically to prevent Alice from picking certain `i`.

Wait, perhaps I can think in terms of the number of times Alice can pick `i` before Bob removes all instances.

For each `i`, the number of times Alice can pick `i` is ceil(freq[i] / 2), assuming Bob removes floor(freq[i]/2).

Because for each freq[i], Bob can remove up to floor(n/2) elements in total, but specifically for `i`, it's floor(freq[i]/2).

Wait, perhaps more precisely, for each `i`, Bob can remove up to floor(freq[i]/2) instances of `i`, and Alice can pick the remaining ceil(freq[i]/2).

But I need to consider that Bob can distribute his removals across different `i`.

Wait, perhaps I need to think in terms of the total number of removals Bob can make and how they affect the availability of different `i`.

Let me consider that for each `i`, the number of instances available for Alice is freq[i] - floor(freq[i]/2) = ceil(freq[i]/2).

Because Bob can remove up to floor(freq[i]/2) instances of `i`.

So, Alice can pick up to ceil(freq[i]/2) instances of `i`.

But since Alice only needs at least one instance of `i` to include it in `c`, we can say that for each `i`, if ceil(freq[i]/2) >= 1, then Alice can include `i` in `c`.

Which means freq[i] >= 1 and ceil(freq[i]/2) >=1, which is always true if freq[i] >=1.

But that can't be right because Bob can still interfere by removing elements.

Wait, perhaps I need to consider the total number of picks Alice can make.

Alice can make ceil(n/2) picks.

So, she can include up to ceil(n/2) elements in `c`.

But she needs to include as many small numbers as possible.

Bob can remove elements to prevent Alice from including certain numbers.

So, perhaps, for each `i`, I need to see if the number of times Alice can pick `i` is at least 1, given that Bob can remove up to floor(n/2) elements.

Wait, perhaps I need to calculate the minimal number of times Alice can include each `i`, considering Bob's removals.

This is getting too complicated.

Let me try a different approach.

Suppose I sort the unique numbers in `a` and count their frequencies.

Then, I try to include as many consecutive numbers starting from 0 as possible, considering that Alice can pick ceil(freq[i]/2) instances of each `i`.

Wait, but Alice can pick any elements, not necessarily the smallest available.

But her goal is to maximize the MEX, so she wants to include as many small numbers as possible.

Bob wants to minimize the MEX, so he wants to prevent Alice from including some small numbers.

So, perhaps, I can find the smallest `k` such that the total number of instances of numbers from 0 to k is greater than the number of picks Bob can make.

Wait, maybe more precisely:

- To include numbers from 0 to k, Alice needs to have at least one of each in `c`.

- Bob can remove up to floor(n/2) elements.

- So, for each `i` from 0 to k, if freq[i] - floor(freq[i]/2) >=1, then Alice can include `i`.

- Because floor(freq[i]/2) is the maximum Bob can remove from freq[i], so if freq[i] - floor(freq[i]/2) >=1, Alice can pick at least one.

- But this seems similar to what I thought earlier.

Wait, but freq[i] - floor(freq[i]/2) = ceil(freq[i]/2), which is >=1 if freq[i] >=1.

So, according to this, Alice can always include any `i` that appears at least once in `a`.

But that can't be right because Bob can choose to remove elements strategically.

Wait, perhaps I need to consider the total number of removals Bob can make and how they affect the availability of multiple `i`.

Let me think differently.

Suppose I have a set of numbers that Alice wants to include in `c` to achieve a certain MEX.

She needs to include all numbers from 0 to k in `c` to have MEX = k+1.

Bob can remove elements to prevent Alice from including some of these numbers.

So, for Alice to include all numbers from 0 to k, she needs to have enough picks to overcome Bob's removals for each of these numbers.

I need to find the largest k such that, for all i from 0 to k, freq[i] - floor(freq[i]/2) >=1, and the total number of picks Alice needs does not exceed her available picks.

Wait, but Alice has ceil(n/2) picks.

So, perhaps, the total number of picks Alice needs to include all numbers from 0 to k is the sum over i from 0 to k of ceil(freq[i]/2).

But she only needs to pick one instance of each i, so maybe it's the sum of 1 for each i, but considering the frequency.

This is getting confusing.

Let me try to think in terms of the minimal MEX.

The minimal MEX is the smallest k such that Alice cannot include k in `c`, even when she plays optimally.

So, I need to find the smallest k where, despite Alice's efforts, Bob can prevent her from including k in `c`.

To find this k, I need to see up to which k Alice can include all numbers from 0 to k in `c`, against Bob's interference.

So, for each k, from 0 upwards, check if Alice can include all numbers from 0 to k in `c`, given that Bob removes floor(n/2) elements.

If there exists a k where Alice cannot include all numbers from 0 to k, then that k is the MEX.

Wait, perhaps I need to calculate the minimal k where the total number of picks Alice needs to include all numbers from 0 to k exceeds the number of picks she has.

So, for each k, calculate the number of picks Alice needs to include all numbers from 0 to k, considering Bob's removals.

Then, find the smallest k where the required picks exceed Alice's available picks.

But I need to define what the required picks are.

Wait, perhaps for each k, the required picks are the number of i from 0 to k where freq[i] is odd (since ceil(freq[i]/2) >=1).

But this seems too vague.

Let me try to think in terms of the total number of picks Alice needs to include all numbers from 0 to k.

For each i from 0 to k, Alice needs at least one pick of i, provided that Bob doesn't remove all instances of i.

So, for each i, if freq[i] > 0, and freq[i] - floor(freq[i]/2) >=1, then Alice can include i.

But freq[i] - floor(freq[i]/2) = ceil(freq[i]/2), which is >=1 if freq[i] >=1.

So, according to this, Alice can always include any i that appears at least once in a.

But that can't be, because Bob can remove elements to prevent Alice from including certain i.

Wait, perhaps I need to consider that Bob can remove elements across different i's.

Suppose Alice needs to include multiple i's, and Bob can remove elements from any i's.

So, Bob can focus his removals on certain i's to prevent Alice from including them.

Therefore, I need to consider the total number of picks Alice needs to include all i's from 0 to k, and see if it exceeds her available picks.

Wait, perhaps I can calculate the minimal number of picks Alice needs to include all i from 0 to k, considering Bob's removals.

But I'm going in circles here.

Let me try to look for a different approach.

Suppose I consider the game where Alice wants to include as many small numbers as possible, and Bob wants to disrupt that.

I can think of it as Alice trying to collect a set of numbers that maximizes the MEX, and Bob trying to minimize it.

Given that, perhaps I can model it as a game where Alice needs to secure certain numbers, and Bob tries to block them.

Alternatively, perhaps I can think in terms of the minimal number that Alice cannot include in c, no matter how she plays.

Wait, but Alice is trying to maximize the MEX, so she wants to include as many small numbers as possible.

Bob is trying to minimize the MEX, so he wants to prevent Alice from including some small numbers.

The final MEX will be the smallest number that Alice cannot include in c.

So, to find this, I need to determine the smallest k such that Alice cannot include k in c, even when she plays optimally.

To find this k, I can iterate over possible k values and check if Alice can include all numbers from 0 to k in c, despite Bob's removals.

If she can, then the MEX is higher than k; if she can't, then MEX is k.

So, I need to find the minimal k where Alice cannot include k in c.

To check if Alice can include all numbers from 0 to k, I need to see if the total number of picks she needs to include at least one of each of these numbers is less than or equal to the number of picks she has.

But I need to account for Bob's removals.

Wait, perhaps I can calculate, for each k, the minimal number of picks Alice needs to include all numbers from 0 to k, considering Bob's removals.

Then, find the smallest k where this minimal number exceeds Alice's available picks.

But I need a better way to calculate this.

Let me consider that for each number i from 0 to k, Alice needs at least one pick of i.

Bob can remove elements to make it harder for Alice to pick i.

Specifically, for each i, Bob can remove floor(freq[i]/2) instances of i.

So, Alice can pick ceil(freq[i]/2) instances of i.

But Alice only needs one instance of i to include it in c.

So, as long as ceil(freq[i]/2) >=1, which is true if freq[i] >=1, Alice can include i.

But this suggests that Alice can always include any i that appears at least once in a.

But that can't be, because Bob can choose to remove instances of i that Alice wants.

Wait, perhaps I need to consider that Bob can remove elements in a way that maximizes the number of i's that Alice cannot include.

But I'm getting stuck here.

Let me try to think about the minimal MEX differently.

Suppose I sort the unique numbers in a in increasing order.

Then, the MEX will be the smallest number missing in c.

Alice wants to include as many small numbers as possible, and Bob wants to prevent that.

So, perhaps, the MEX is determined by the first number where the frequency is such that Bob can prevent Alice from including it.

Wait, perhaps if freq[i] is even, Bob can remove all instances of i if he dedicates enough removals to it.

Wait, but Bob's removals are limited to floor(n/2).

So, for each i, if freq[i] is even, Bob can remove floor(freq[i]/2) instances, leaving ceil(freq[i]/2) for Alice.

But Alice only needs one instance to include i in c.

So, as long as ceil(freq[i]/2) >=1, which is always true if freq[i] >=1, Alice can include i.

But this suggests that Alice can always include any i that appears at least once in a, which contradicts the sample inputs.

In the second sample input:

n=4

a=[0,1,2,3]

According to this logic, Alice can include any of 0,1,2,3 in c, but the sample output is MEX=1, meaning that 0 is included, but 1 is not.

Wait, but according to the earlier logic, Alice should be able to include all of them.

Wait, perhaps I'm missing something.

Wait, in that sample input, n=4, a=[0,1,2,3].

Alice can pick 0, c=[0], a=[1,2,3]

Bob can pick 1, a=[2,3]

Alice can pick 2, c=[0,2], a=[3]

Bob can pick 3, a=[]

MEX of c=[0,2] is 1.

Alternatively, Alice could pick 3 first, c=[3], a=[0,1,2]

Bob picks 0, a=[1,2]

Alice picks 1, c=[3,1], a=[2]

Bob picks 2, a=[]

MEX of c=[3,1] is 0.

So, Bob can force MEX to be 0 or 1, and apparently, the minimal MEX is 1.

But according to my earlier logic, Alice should be able to include all numbers from 0 to 3.

Wait, no, because Bob can remove elements that Alice wants.

Wait, perhaps I need to think in terms of the total number of picks Alice needs to include certain numbers.

Let me consider that Alice needs to include numbers from 0 to k in c, and Bob can remove elements to make it harder.

So, for Alice to include all numbers from 0 to k, she needs to pick at least one of each in her picks.

Bob can remove elements to reduce the availability of certain numbers.

But Bob can only remove floor(n/2) elements in total.

So, perhaps, the minimal MEX is the smallest k such that the total number of picks Alice needs to include all numbers from 0 to k exceeds her available picks.

Wait, perhaps I need to calculate, for each k, the number of picks Alice needs to include all numbers from 0 to k, considering Bob's removals.

But I'm still stuck.

Let me look back at the provided code and see if I can find any inspiration.

In the code:

- It sorts the array.

- It iterates through the sorted array, keeping track of 'cur', which seems to be the current expected number.

- It builds a dictionary M where keys are the numbers and values are their counts in a certain subset.

- Then, it checks if the sum of counts in M equals n, and increments cur.

- Finally, it looks at keys in M with count 1 and sets cur to the second one if there are at least two.

This seems arbitrary and not directly related to the game's logic.

Given that, I think the provided code is incorrect.

Instead, I need to find a proper way to model the game.

Let me consider that Alice can pick ceil(n/2) elements to include in c, and Bob can remove floor(n/2) elements.

So, the total elements removed are floor(n/2), and Alice picks ceil(n/2) elements to include in c.

The MEX is determined by the contents of c.

Alice wants to include as many small numbers as possible, and Bob wants to prevent that.

So, perhaps, the MEX is determined by the smallest number that Alice cannot include in c, given that Bob removes floor(n/2) elements optimally.

Wait, perhaps I can think in terms of the minimal number that Alice cannot include in c, even when she picks optimally.

To find that, I can sort the unique numbers in a, and try to include as many consecutive numbers starting from 0 as possible, given that Alice can pick ceil(n/2) elements.

But Bob can remove elements to prevent Alice from including certain numbers.

Wait, perhaps I can calculate the number of times Alice can pick each number, considering Bob's removals.

For each number i, the number of times Alice can pick it is ceil(freq[i]/2).

Because Bob can remove floor(freq[i]/2) instances of i.

So, if ceil(freq[i]/2) >=1, Alice can include i in c.

But in the second sample input, n=4, a=[0,1,2,3], freq of each is 1.

So, ceil(1/2)=1 for each, meaning Alice can include any one of them.

But she has ceil(4/2)=2 picks.

So, she can include two numbers, say 0 and 1, making c=[0,1], MEX=2.

But the sample output is 1, which contradicts this.

Wait, perhaps I'm missing something.

Wait, in that sample input, Alice can include two numbers, but Bob can force her to include certain numbers.

Wait, perhaps Bob can remove a number that Alice wants, forcing her to include a higher number.

Wait, I need to think more carefully.

Let me consider that Alice can pick ceil(n/2) elements to include in c, and Bob can remove floor(n/2) elements.

So, in total, Alice includes ceil(n/2) elements in c.

The MEX is determined by the contents of c.

To maximize MEX, Alice wants to include as many small numbers as possible.

Bob wants to minimize MEX, so he wants to prevent Alice from including small numbers.

So, perhaps, the MEX is determined by the smallest number that Alice cannot include in c, given that Bob removes floor(n/2) elements optimally.

Wait, perhaps I can sort the unique numbers in a and try to include as many consecutive numbers starting from 0 as possible, given that Alice can include ceil(n/2) elements.

But I need to consider that Bob can remove elements to prevent Alice from including certain numbers.

Wait, maybe I can model this as selecting the smallest possible set of numbers that Alice can include in c, and find the MEX based on that.

This is getting too convoluted.

Let me try to think differently.

Suppose I consider the game where Alice picks an element and includes it in c, and Bob picks an element to remove.

They alternate until a is empty.

I need to find the MEX of c at the end.

Given that, perhaps I can think in terms of which elements Alice can include in c, considering Bob's removals.

But I need a better strategy.

Let me look for patterns in the sample inputs.

Sample Input 1:

n=4

a=[0,0,1,1]

Possible c=[1,0], MEX=2

Sample Input 2:

n=4

a=[0,1,2,3]

Possible c=[0,2], MEX=1

Sample Input 3:

n=2

a=[1,1]

Possible c=[1], MEX=0

So, in the first sample, MEX=2

In the second, MEX=1

In the third, MEX=0

Looking at the frequencies:

First sample: 0 appears twice, 1 appears twice.

Alice can pick two elements, and include both 0 and 1, making MEX=2.

Second sample: each number appears once.

Alice can pick two elements, say 0 and 1, making MEX=2, but the sample output is 1, so perhaps Bob can force a lower MEX.

Wait, in the second sample, if Alice picks 0 and 1, MEX=2, but if she picks 0 and 2, MEX=1.

Wait, but the sample output is 1, which suggests that Bob can force MEX=1.

So, perhaps, the minimal MEX is 1.

Wait, but according to my earlier logic, Alice can pick 0 and 1 to make MEX=2.

But the sample output is 1, so perhaps there's something wrong with that approach.

Wait, perhaps Bob can remove an element that Alice wants.

For example:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob picks 3, a=[]

MEX of c=[0,2] is 1.

Alternatively:

- Alice picks 3, c=[3], a=[0,1,2]

- Bob picks 0, a=[1,2]

- Alice picks 1, c=[3,1], a=[2]

- Bob picks 2, a=[]

MEX of c=[3,1] is 0.

So, Bob can force MEX to be 0 or 1, and apparently, the minimal MEX is 1.

So, in this case, Alice cannot achieve MEX=2; the best she can do is MEX=1.

Hence, the minimal MEX is 1.

So, perhaps, the minimal MEX is determined by the minimal number that Alice cannot include in c, even when she plays optimally.

In this case, Alice cannot include 1 in c in one of the scenarios, so MEX=1.

Wait, but in the first scenario, she included 0 and 2, missing 1, resulting in MEX=1.

In another scenario, she included 3 and 1, missing 0 and 2, but MEX is 0.

So, the minimal MEX is 1.

Wait, I'm getting confused.

Wait, perhaps I should think in terms of the number of times Alice can include each number, considering Bob's removals.

Given that, perhaps for each number i, if freq[i] is 1, and Alice doesn't pick it, Bob can remove it, making it unavailable.

Wait, but in the second sample, for i=0, freq=1.

If Alice picks 0, c includes 0.

If Alice doesn't pick 0, Bob can remove it.

Similarly for i=1,2,3.

So, Alice can pick two numbers, and Bob can remove one.

If Alice picks two numbers including 0, then c includes 0 and another number, say 2, MEX=1.

If Alice picks two numbers not including 0, say 1 and 3, c=[1,3], MEX=0.

So, the minimal MEX is 1, as per the sample output.

Hence, Bob can force MEX to be 1 by removing 0 if Alice doesn't pick it.

So, Alice can include only one of 0,1,2,3 in c, effectively.

Wait, no, she includes two numbers.

But in doing so, she misses one number that Bob can remove.

Wait, perhaps I need to calculate the minimal MEX as the smallest number that Alice cannot guarantee to include in c, even when she picks optimally.

So, in this case, Alice can include two numbers, but she cannot include all of 0,1,2,3.

Hence, the minimal MEX is 1.

Wait, perhaps the minimal MEX is the smallest number where the frequency is such that Bob can prevent Alice from including it in c.

In other words, for each i from 0 to max(a), if freq[i] is 1 and Alice doesn't pick it, Bob can remove it, making it unavailable in c.

Hence, the MEX is the smallest i where freq[i]=1 and Alice doesn't pick it.

Wait, but in the second sample, freq[0]=1, freq[1]=1, freq[2]=1, freq[3]=1.

Alice picks two numbers; hence, she can pick 0 and 1, leaving MEX=2.

But the sample output is 1, which contradicts this.

Wait, perhaps I need to consider that Bob can remove a number that Alice wants.

Wait, perhaps it's more nuanced.

Let me try to think in terms of the number of times Alice can include each i, considering Bob's removals.

Given that, perhaps the minimal MEX is determined by the first i where the number of available picks for Alice is less than what she needs to include it.

But I need to formalize this.

Alternatively, perhaps the minimal MEX is the smallest i where the cumulative number of picks Alice needs to include all numbers from 0 to i exceeds the number of picks she has.

But I need to define the picks needed.

Wait, perhaps I can sort the unique numbers in a and try to include as many as possible, up to the number of picks Alice has.

But I need to consider Bob's removals.

This is getting too tangled.

Let me try to look for a different approach.

Suppose I consider that Alice can include ceil(n/2) elements in c.

Bob can remove floor(n/2) elements.

The MEX is determined by which numbers are missing in c.

Alice wants to include as many small numbers as possible.

Bob wants to prevent that.

Hence, the minimal MEX is the smallest number where, even if Alice tries to include it, Bob can prevent her from doing so.

To find this, perhaps I can iterate through the numbers starting from 0 and check if Alice can include that number in c, given Bob's removals.

If Alice can include all numbers up to k, then MEX is k+1.

Otherwise, MEX is the smallest k where Alice cannot include k in c.

To check if Alice can include k in c, she needs to pick at least one instance of k, and Bob can remove up to floor(n/2) elements.

So, if