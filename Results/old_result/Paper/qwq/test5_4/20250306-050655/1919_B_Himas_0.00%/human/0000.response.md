Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a string consisting of "+" and "-" characters, and I need to split this string into substrings in such a way that when I concatenate these substrings, I get back the original string. For each substring, I calculate a penalty which is the absolute value of the sum of the substring's elements multiplied by its length. My goal is to split the string optimally to minimize the total penalty.

First, I need to understand how the array 'a' is constructed from the string 's'. It says that each "+" in the string corresponds to a 1 in the array, and each "-" corresponds to a -1. So, for example, if s = "+-+", then a = [1, -1, 1].

Now, I need to split this array 'a' into non-empty subarrays, and for each subarray, calculate its penalty, which is |sum of subarray| * length of subarray. Then, sum up all these penalties and find the minimum possible total penalty among all possible ways to split 'a'.

Let me consider some examples to get a better understanding.

Example 1:

n = 1

s = "+"

So, a = [1]

Possible splits: only [1]

Penalty: |1| * 1 = 1

Total penalty: 1

Example 2:

n = 5

s = "-----"

So, a = [-1, -1, -1, -1, -1]

Possible splits:

- Split into individual elements: ([-1], [-1], [-1], [-1], [-1])

Penalty for each: | -1 | * 1 = 1

Total penalty: 5

- Split into two subarrays: ([-1, -1, -1], [-1, -1])

First subarray: | -3 | * 3 = 9

Second subarray: | -2 | * 2 = 4

Total penalty: 9 + 4 = 13

- Split into one subarray: ([-1, -1, -1, -1, -1])

Penalty: | -5 | * 5 = 25

So, the minimal total penalty is 5, achieved by splitting into individual elements.

Example 3:

n = 6

s = "+-+-+-

So, a = [1, -1, 1, -1, 1, -1]

Possible splits:

- Split into individual elements: ([1], [-1], [1], [-1], [1], [-1])

Penalty for each: |1|*1 + |-1|*1 + |1|*1 + |-1|*1 + |1|*1 + |-1|*1 = 1+1+1+1+1+1 = 6

- Split into two subarrays: ([1, -1], [1, -1, 1, -1])

First subarray: |0|*2 = 0

Second subarray: |0|*4 = 0

Total penalty: 0 + 0 = 0

- Split into three subarrays: ([1, -1, 1], [-1, 1], [-1])

First: |1|*3 = 3

Second: |0|*2 = 0

Third: |-1|*1 = 1

Total penalty: 3 + 0 + 1 = 4

- Split into one subarray: ([1, -1, 1, -1, 1, -1])

Penalty: |0|*6 = 0

Wait, but according to the example, the output is 0, which matches this split.

Wait, but in the explanation, it says splitting into ([1,-1,1,-1],[1,-1]) gives p([1,-1,1,-1]) + p([1,-1]) = 0 + 0 = 0.

So, that's consistent with what I have.

Okay, so in this case, splitting into subarrays where the sum is zero doesn't contribute to the total penalty, which can lead to a minimal total penalty.

Another example:

n = 10

s = "--+++++++-

So, a = [-1, -1, 1, 1, 1, 1, 1, 1, 1, -1]

Possible splits:

- Split into individual elements: sum penalties would be 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 10

- Split into ([ -1, -1 ], [ 1, 1, 1, 1, 1, 1, 1, -1 ])

First subarray: | -2 | * 2 = 4

Second subarray: | +6 -1 | = |5| * 8 = 40

Total: 4 + 40 = 44

- Split into ([ -1 ], [ -1, 1, 1, 1, 1, 1, 1, 1 ], [ -1 ])

First: | -1 | * 1 = 1

Second: | +6 | * 7 = 42

Third: | -1 | * 1 = 1

Total: 1 + 42 + 1 = 44

- Split into ([ -1, -1, 1, 1, 1, 1, 1, 1, 1, -1 ])

Sum: | -2 + 7 -1 | = |4| * 10 = 40

- Split into ([ -1, -1, 1, 1 ], [ 1, 1, 1, -1 ])

First: | -2 + 2 | * 4 = 0

Second: | +2 -1 | * 4 = |1| * 4 = 4

Total: 0 + 4 = 4

According to the sample output, the minimal penalty is 4, which matches this split.

So, from these examples, it seems that the optimal way is to split the array into subarrays where the sum is zero, or as close to zero as possible, to minimize the penalty.

But, in the third example, splitting into subarrays with sum zero gives a total penalty of 0, which is better than other splits.

In the fourth example, splitting into subarrays where one has sum zero and the other has sum one, giving a total penalty of 4.

Wait, but in the third example, the minimal penalty is 0, achieved by splitting into subarrays with sum zero.

In the fourth example, minimal penalty is 4, achieved by splitting into subarrays with sums zero and one.

So, it seems that minimizing the sum's absolute value times the subarray's length leads to these minimal values.

Now, looking at the provided program:

def func():

for i in range(int(input())):

s = int(input())

e = input()

P = 0

M = 0

for q in e:

if q == '+':

P += 1

else:

M += 1

print(P - M)

Wait, this seems off.

First, it reads the number of test cases, then for each test case, it reads an integer s (which is the length of the string), then reads the string e.

Then, it counts the number of '+' and '-' in the string, storing them in P and M respectively.

Finally, it prints P - M.

But according to the problem, we need to split the array and calculate the minimal possible penalty based on the splitting.

However, this program is simply counting the number of '+' and '-' and printing their difference.

This seems too simplistic and doesn't take into account the splitting of the array or the penalties based on subarrays.

Let me check the sample inputs and outputs to see if this program matches.

Sample Input:

5

1

+

5

-----

6

+-+-+-

10

--+++++++-

20

+---++++-+++++---++-

Sample Output:

1

5

0

4

4

Now, let's see what the program would output for these inputs.

Test case 1:

n=1, s="+" => P=1, M=0 => P - M = 1, which matches the sample output.

Test case 2:

n=5, s="-----" => P=0, M=5 => P - M = -5, but the sample output is 5. Wait, that's different.

Wait, the program prints P - M, which would be 0 - 5 = -5, but the sample output is 5. So, this doesn't match.

Unless, perhaps, the program is printing the absolute difference? But no, it's P - M, which is signed.

Wait, in the first test case, it's 1, which matches, but in the second, it should be -5, but the sample output is 5.

Hmm, perhaps there's a misunderstanding.

Wait, maybe the program is supposed to print the absolute difference, but it's not taking the absolute value.

Wait, but in the third test case:

n=6, s="+-+-+-" => P=3, M=3 => P - M = 0, which matches the sample output of 0.

Fourth test case:

n=10, s="--+++++++-" => P=7, M=3 => P - M = 4, which matches the sample output of 4.

Fifth test case:

n=20, s="+---++++-+++++---++-" => P=10, M=10 => P - M = 0, but the sample output is 4. Wait, but in the sample output, it's 4, which doesn't match P - M = 0.

Wait, perhaps I miscounted.

Let's count P and M for the fifth test case:

s = "+---++++-+++++---++-"

Count of '+': positions 1,5,6,7,9,10,11,12,14,15,16,17,19,20 => 14 '+'

Count of '-': positions 2,3,4,8,13,18 => 6 '-'

So, P=14, M=6, P - M = 8, but the sample output is 4. So, this doesn't match.

Wait, perhaps I misread the string.

Wait, s = "+---++++-+++++---++-"

Let's index from 1:

1: +

2: -

3: -

4: -

5: +

6: +

7: +

8: +

9: -

10: +

11: +

12: +

13: +

14: -

15: +

16: +

17: +

18: -

19: +

20: +

So, P: positions 1,5,6,7,8,10,11,12,13,15,16,17,19,20 => 14 '+'

M: positions 2,3,4,9,14,18 => 6 '-'

Thus, P=14, M=6, P - M = 8, but sample output is 4. So, they don't match.

Wait, perhaps there's a mistake in the program.

Alternatively, maybe the program is calculating something else, but it's not clear.

In the second test case, n=5, s="-----", P=0, M=5, P - M = -5, but sample output is 5.

In the fourth test case, n=10, s="--+++++++-", P=7, M=3, P - M =4, which matches sample output 4.

In the fifth test case, P=14, M=6, P - M =8, but sample output is 4.

So, it's inconsistent.

Wait, perhaps the program is printing the absolute difference, but in the second test case, it prints -5 instead of 5.

Wait, but in the first test case, it's 1, which is correct, and in the third test case, it's 0, which is correct, and in the fourth test case, it's 4, which is correct, but in the fifth test case, it's 8, which doesn't match the sample output of 4.

Hmm.

Alternatively, perhaps the program is intended to print P - M, but in the explanation, it's |sum| * something, which is not matching.

Wait, perhaps I need to rethink the problem.

Let me try to find a pattern or a formula that can be used to compute the minimal penalty without explicitly considering all possible splits, as that would be inefficient for n up to 5000.

Given that n can be up to 5000 and t up to 1000, a O(n^2) per test case solution might be too slow, so I need a linear or near-linear time solution.

Let me consider the properties of the penalty.

For a subarray b, penalty p(b) = |sum of b| * len(b)

I need to split the array a into subarrays b1, b2, ..., bk such that the sum of p(bi) is minimized.

I need to find a way to group elements to minimize the sum of |sum of subarray| * length of subarray.

One approach is to observe that if a subarray has a sum of zero, its penalty is zero, which is ideal. So, if I can split the array into subarrays where each has a sum of zero, the total penalty would be zero.

However, this might not always be possible, especially if the total sum of the array is not zero.

In the third test case, a=[1,-1,1,-1,1,-1], total sum is zero, and it's possible to split it into subarrays with sum zero, achieving a total penalty of zero.

In the second test case, a=[-1,-1,-1,-1,-1], total sum is -5, and splitting into individual elements gives a total penalty of 5, which seems minimal.

Wait, but perhaps there's a better way.

Wait, no. If I split into individual elements, each with sum -1 and length 1, penalty is 1 per element, total 5.

If I split into two subarrays, say ([-1,-1,-1], [-1,-1]), penalties are | -3 | * 3 = 9 and | -2 | * 2 = 4, total 13, which is worse.

Splitting into one subarray: | -5 | * 5 = 25, worse than 5.

So, splitting into individual elements is optimal in this case.

In the fourth test case, a=[-1,-1,1,1,1,1,1,1,1,-1], sum is -2 + 7 -1 = 4, and splitting into subarrays with sum zero and minimal penalties achieves a total penalty of 4.

Wait, specifically, splitting into ([ -1, -1, 1, 1, 1, 1, 1, 1, 1 ], [ -1 ]), the first subarray has sum 4, length 9, penalty 36, and the second has sum -1, length 1, penalty 1, total 37, which is not 4.

Wait, in my earlier manual calculation, I had a different split.

Wait, perhaps I need to find a way to split the array such that the sum of |sum of subarray| * length is minimized.

I need a systematic way to do this.

Let me consider dynamic programming.

Define dp[i] as the minimal total penalty for the subarray a[0 to i-1].

Then, dp[0] = 0

For each i from 1 to n, dp[i] = min over j from 0 to i-1 of dp[j] + p(a[j to i-1])

Where p(b) = |sum of b| * len(b)

This would be O(n^2), which for n=5000 would be too slow, as it would be about 25 million operations per test case, and with t=1000, it's infeasible.

So, I need a smarter approach.

Let me consider the properties of the sum and the penalty.

Let’s define prefix sums.

Let’s compute the prefix sum array, where prefix[0] = 0, prefix[1] = a[0], prefix[2] = a[0] + a[1], ..., prefix[n] = a[0] + a[1] + ... + a[n-1]

Then, the sum of a subarray from j to i-1 is prefix[i] - prefix[j]

And the length is i - j

So, p(b) = |prefix[i] - prefix[j]| * (i - j)

Thus, dp[i] = min over j from 0 to i-1 of dp[j] + |prefix[i] - prefix[j]| * (i - j)

This still seems quadratic.

Is there a way to optimize this?

Let me consider sorting or grouping based on prefix sums.

Alternatively, perhaps there's a way to group consecutive elements to maximize the cancellation in their sums, thereby minimizing the absolute sum times the length.

Wait, perhaps I can look for runs of '+' and '-', and group them in a way that the sum's absolute value is minimized.

Wait, but that might not lead to the optimal solution.

Let me consider that for a subarray with sum S and length L, its penalty is |S| * L

I need to minimize the sum of |S| * L over all subarrays in the partition.

Is there a way to rearrange or group the elements to minimize this?

Wait, perhaps I can consider the array as a whole and find a way to partition it based on the cumulative sum.

Let me consider plotting the prefix sums.

Imagine the prefix sum as a path, where each step is +1 or -1.

The penalty for a subarray from j to i-1 is the vertical distance |prefix[i] - prefix[j]| multiplied by the horizontal distance (i - j).

This seems similar to some geometric interpretations, perhaps related to Manhattan distances or something similar.

Is there a way to minimize the sum of such distances?

Alternatively, perhaps I can consider that the minimal penalty corresponds to the minimal total variation in some sense.

Wait, perhaps I can model this as a path and find a way to split it into segments where the sum's absolute value times the length is minimized.

This seems complicated.

Let me think differently.

Suppose I fix the number of partitions, say k, and try to find the minimal total penalty for k partitions.

Then, I can try to find the minimal over k from 1 to n.

But this would still be too slow.

Wait, perhaps there's a way to compute the minimal penalty in linear time.

Let me consider that the minimal penalty is achieved by splitting the array into subarrays where each subarray has a sum as close to zero as possible.

But how do I formalize that efficiently?

Wait, perhaps I can use a greedy approach: at each step, choose the smallest possible subarray that minimizes the penalty incrementally.

But that might not lead to the global optimum.

Alternatively, perhaps I can use a sliding window approach, adjusting the window size to minimize the penalty.

But again, this might not guarantee the minimal total penalty.

Let me consider the total penalty if I don't split the array at all, i.e., k=1.

Then, penalty = |sum of a| * n

In the first test case, sum(a) = 1, n=1, penalty=1*1=1

In the second test case, sum(a)=-5, n=5, penalty=5*5=25

In the third test case, sum(a)=0, n=6, penalty=0*6=0

In the fourth test case, sum(a)=4, n=10, penalty=4*10=40

In the fifth test case, let's say sum(a)=some value, n=20, penalty=|sum(a)|*20

But in the sample outputs, for the second test case, it's 5, which is better than 25, so splitting helps.

Similarly, in the fourth test case, it's 4, which is better than 40.

So, splitting is necessary to achieve the minimal penalty.

Now, perhaps I can consider that the minimal penalty is equal to the sum of the absolute differences between consecutive prefix sums, each multiplied by 1 (since each subarray has length 1).

Wait, that would be equivalent to splitting into individual elements.

In the second test case, sum of | -1 |*1 + | -1 |*1 + | -1 |*1 + | -1 |*1 + | -1 |*1 = 5, which matches the sample output of 5.

In the third test case, sum of |1|*1 + |-1|*1 + |1|*1 + |-1|*1 + |1|*1 + |-1|*1 = 6, but the sample output is 0, which is better than 6, so splitting into longer subarrays helps.

So, splitting into individual elements is not always optimal.

Wait, but in the second test case, it is optimal.

So, perhaps the minimal penalty is equal to the sum of the absolute values of the elements, i.e., sum of |a_i| for all i.

In the second test case, sum of | -1 | five times is 5, which matches the sample output of 5.

In the third test case, sum of |1| + |-1| + |1| + |-1| + |1| + |-1| = 6, but the sample output is 0, which is better than 6.

So, this can't be the minimal penalty.

Wait, perhaps not.

Wait, in the fifth test case, sum of |a_i| for 20 elements, which would be 20, but the sample output is 4, which is much better.

So, sum of |a_i| is not the minimal penalty.

Alternatively, perhaps it's the minimal penalty when splitting into subarrays with sum zero.

But in the third test case, splitting into one subarray with sum zero gives penalty 0.

In the fifth test case, perhaps it's possible to split into subarrays where most have sum zero, leading to a minimal penalty.

But counting the number of '+” and '-' doesn't directly give the minimal penalty.

Wait, in the provided program, it's printing P - M, which is the difference between the number of '+' and '-'.

In the first test case, P=1, M=0, P - M =1, matches sample output 1.

Second test case, P=0, M=5, P - M = -5, but sample output is 5.

Wait, perhaps it's printing |P - M|, but no, it's P - M without absolute value.

In the third test case, P=3, M=3, P - M=0, matches sample output 0.

Fourth test case, P=7, M=3, P - M=4, matches sample output 4.

Fifth test case, P=14, M=6, P - M=8, but sample output is 4, which doesn't match.

So, it seems that in some cases it matches, in some it doesn't.

Wait, perhaps there's a pattern.

In the second test case, sum(a) = -5, P - M = -5, but sample output is 5, which is |sum(a)|.

In the fifth test case, sum(a) = 8, P - M =8, but sample output is 4, which is less than |sum(a)|.

So, it's not simply |sum(a)|.

Wait, perhaps the minimal penalty is |sum(a)|, but in the third test case, sum(a)=0, |sum(a)|=0, which matches sample output 0.

In the second test case, sum(a)=-5, |sum(a)|=5, which matches sample output 5.

In the fourth test case, sum(a)=4, |sum(a)|=4, which matches sample output 4.

In the fifth test case, sum(a)=8, |sum(a)|=8, but sample output is 4, which is half of |sum(a)|.

Wait, perhaps not.

Wait, in the fifth test case, sum(a)=8, but the sample output is 4, which is |sum(a)| / 2.

But why would that be?

Wait, perhaps because the array can be split into subarrays where the sum is 4, and some are -4, but not sure.

Wait, perhaps I need to consider that the minimal penalty is |sum(a)| when split into individual elements, but by grouping elements, we can reduce the penalty further.

In the third test case, by grouping all elements into one subarray, since sum(a)=0, penalty=0.

In the second test case, sum(a)=-5, and splitting into individual elements gives penalty 5, which is |sum(a)|, and splitting into one subarray gives penalty |sum(a)| * n =25, which is worse.

In the fourth test case, sum(a)=4, splitting into individual elements gives penalty 4, which matches the sample output.

Wait, but in the fifth test case, sum(a)=8, but sample output is 4, which is half of |sum(a)|.

Wait, perhaps it's min(|sum(a)|, something else).

Wait, perhaps it's min over all possible splits of the sum of |sum(b_i)| for each subarray b_i.

Wait, but in the third test case, sum(a)=0, so sum of |sum(b_i)| for each subarray can be zero, which matches the sample output.

In the second test case, sum(a)=-5, and if we split into individual elements, sum of |sum(b_i)|=5, which is |sum(a)|.

But if we split into subarrays where sum(b_i) is as close to zero as possible, but with sum of all sum(b_i) equal to sum(a), it's hard to make sum of |sum(b_i)| less than |sum(a)|.

Wait, unless sum(a)=0, in which case sum of |sum(b_i)| can be zero.

In general, sum of |sum(b_i)| >= |sum(a)|, by the triangle inequality.

Wait, actually, the triangle inequality says |sum(a)| <= sum of |sum(b_i)|.

So, sum of |sum(b_i)| >= |sum(a)|, with equality if all sum(b_i) have the same sign and are added up in the same direction.

So, the minimal possible sum of |sum(b_i)| is |sum(a)|, achieved by splitting into individual elements.

But in the third test case, sum(a)=0, and sum of |sum(b_i)| can be zero, which is achieved.

In the fifth test case, sum(a)=8, and sum of |sum(b_i)| cannot be less than 8.

But the sample output is 4, which is less than |sum(a)|=8, which contradicts the earlier reasoning.

Wait, perhaps I'm miscalculating the sum(a) for the fifth test case.

Let's recount:

s = "+---++++-+++++---++-"

n=20

Positions:

1: + → 1

2: - → -1

3: - → -1

4: - → -1

5: + → 1

6: + → 1

7: + → 1

8: + → 1

9: - → -1

10: + → 1

11: + → 1

12: + → 1

13: + → 1

14: - → -1

15: + → 1

16: + → 1

17: + → 1

18: - → -1

19: + → 1

20: + → 1

Sum(a) = 1 -1 -1 -1 +1 +1 +1 +1 -1 +1 +1 +1 +1 -1 +1 +1 +1 -1 +1 +1

Let's compute step by step:

1: 1

1 + (-1) = 0

0 + (-1) = -1

-1 + (-1) = -2

-2 + 1 = -1

-1 + 1 = 0

0 + 1 = 1

1 + 1 = 2

2 + (-1) = 1

1 + 1 = 2

2 + 1 = 3

3 + 1 = 4

4 + (-1) = 3

3 + 1 = 4

4 + 1 = 5

5 + 1 = 6

6 + (-1) = 5

5 + 1 = 6

6 + 1 = 7

So, sum(a) =7, but the sample output is 4, which is less than |sum(a)|=7.

This contradicts the earlier assumption that sum of |sum(b_i)| >= |sum(a)|.

Wait, perhaps I'm missing something.

Let me consider that the minimal total penalty is not equal to sum of |sum(b_i)|, but something else.

Wait, the penalty is sum over all subarrays b_i of |sum(b_i)| * len(b_i)

So, it's not just sum of |sum(b_i)|, but sum of |sum(b_i)| multiplied by the length of b_i.

So, perhaps there is a way to split the array such that the sum of |sum(b_i)| * len(b_i) is minimized, potentially being less than |sum(a)| in some cases.

In the fifth test case, sum(a)=7, but sample output is 4, which is less than |sum(a)|.

Wait, but in the third test case, sum(a)=0, and minimal penalty is 0, which is equal to |sum(a)|.

In the second test case, sum(a)=-5, minimal penalty is 5, which is |sum(a)|.

In the fourth test case, sum(a)=4, minimal penalty is 4, which is |sum(a)|.

In the fifth test case, sum(a)=7, but minimal penalty is 4, which is less than |sum(a)|.

Wait, perhaps I miscalculated sum(a) again.

Let's recount sum(a) for the fifth test case:

Positions 1 to 20:

1: + → 1

2: - → -1

3: - → -1

4: - → -1

5: + → 1

6: + → 1

7: + → 1

8: + → 1

9: - → -1

10: + → 1

11: + → 1

12: + → 1

13: + → 1

14: - → -1

15: + → 1

16: + → 1

17: + → 1

18: - → -1

19: + → 1

20: + → 1

Sum = 1 -1 -1 -1 +1 +1 +1 +1 -1 +1 +1 +1 +1 -1 +1 +1 +1 -1 +1 +1

Let's group them:

(1) +1

(2) -1

(3) -1

(4) -1

(5) +1

(6) +1

(7) +1

(8) +1

(9) -1

(10) +1

(11) +1

(12) +1

(13) +1

(14) -1

(15) +1

(16) +1

(17) +1

(18) -1

(19) +1

(20) +1

Sum:

1 -1 -1 -1 +1 +1 +1 +1 -1 +1 +1 +1 +1 -1 +1 +1 +1 -1 +1 +1

Let's compute step by step:

Start with 0.

0 +1 =1

1 -1 =0

0 -1 =-1

-1 -1 =-2

-2 +1 =-1

-1 +1 =0

0 +1 =1

1 +1 =2

2 -1 =1

1 +1 =2

2 +1 =3

3 +1 =4

4 -1 =3

3 +1 =4

4 +1 =5

5 +1 =6

6 -1 =5

5 +1 =6

6 +1 =7

7 -1 =6

6 +1 =7

7 +1 =8

Wait, earlier I thought sum(a)=7, but actually, sum(a)=8.

But in my earlier count, I had sum(a)=7, but recounting gives sum(a)=8.

Wait, perhaps I miscounted again.

Let's count the number of '+' and '-':

'+' counts: positions 1,5,6,7,8,10,11,12,13,15,16,17,19,20 → 14 '+'s

'-' counts: positions 2,3,4,9,14,18 → 6 '-'s

So, sum(a) = 14 - 6 = 8

But in the sample output, it's 4, which is less than |sum(a)|=8.

So, how is that possible?

Wait, perhaps I'm misunderstanding the penalty calculation.

Wait, the penalty is sum over all subarrays b_i of p(b_i), where p(b_i) = |sum(b_i)| * len(b_i)

So, it's not just sum of |sum(b_i)|, but sum of |sum(b_i)| multiplied by the length of b_i.

So, perhaps by splitting the array into subarrays where some have sum zero, we can minimize the total penalty.

In the third test case, sum(a)=0, and by splitting into one subarray, penalty is |0|*6=0.

In the second test case, sum(a)=-5, and splitting into individual elements gives penalty 1*5=5, which is better than splitting into one subarray with penalty | -5 | *5=25.

In the fourth test case, sum(a)=4, splitting into individual elements gives penalty |1|*1 + | -1 |*1 + ... + |1|*1 =4, which matches the sample output of 4.

Wait, but in the fifth test case, sum(a)=8, but sample output is 4, which is less than |sum(a)|*something.

Wait, perhaps I need to consider that the minimal penalty is |sum(a)| when split into individual elements, but in some cases, like the third test case, sum(a)=0, and penalty=0.

But in the fifth test case, sum(a)=8, but sample output is 4, which is less than |sum(a)|.

Wait, perhaps there is a way to split the array such that the sum of |sum(b_i)| * len(b_i) is minimized, potentially being less than |sum(a)| * something.

Wait, perhaps the minimal penalty is |sum(a)| * c, where c is some factor.

But in the third test case, sum(a)=0, penalty=0.

In the second test case, sum(a)=-5, penalty=5=|sum(a)|.

In the fourth test case, sum(a)=4, penalty=4=|sum(a)|.

In the fifth test case, sum(a)=8, penalty=4=|sum(a)| /2.

Wait, perhaps the minimal penalty is |sum(a)| when split into individual elements, but by grouping elements, we can reduce the penalty.

Wait, but in the third test case, sum(a)=0, and penalty=0, which is less than |sum(a)|.

Wait, sum(a)=0, |sum(a)|=0, penalty=0.

In the second test case, sum(a)=-5, |sum(a)|=5, penalty=5.

In the fourth test case, sum(a)=4, |sum(a)|=4, penalty=4.

In the fifth test case, sum(a)=8, |sum(a)|=8, but penalty=4.

Wait, perhaps there's a misunderstanding.

Looking back at the fifth test case, sample output is 4, but according to my calculation, sum(a)=8, which doesn't align with the sample output.

Wait, perhaps the provided program is incorrect, and that's why it's printing P - M, which in the fifth test case would be 14 - 6 =8, but sample output is 4.

So, the provided program is incorrect for the fifth test case.

Wait, but in the fourth test case, P=7, M=3, P - M=4, which matches the sample output.

In the second test case, P=0, M=5, P - M=-5, but sample output is 5, which is |P - M|.

In the first test case, P=1, M=0, P - M=1, matches sample output 1.

In the third test case, P=3, M=3, P - M=0, matches sample output 0.

In the fifth test case, P=14, M=6, P - M=8, but sample output is 4.

So, it seems that in some cases, the minimal penalty is P - M, in others, it's |P - M|, but that doesn't hold consistently.

Wait, perhaps the minimal penalty is |sum(a)|, which is |P - M|.

In the second test case, | -5 | =5, matches sample output 5.

In the fourth test case, |4|=4, matches sample output 4.

In the fifth test case, |8|=8, but sample output is 4.

So, it's not |sum(a)|.

Wait, perhaps there is a misprint in the sample outputs or I'm misunderstanding the problem.

Wait, perhaps the penalty is not simply |sum(a)|, but something else.

Let me consider another approach.

Let me consider that the minimal penalty is achieved by splitting the array into subarrays where each subarray has a sum as close to zero as possible.

So, for example, in the third test case, sum(a)=0, and splitting into one subarray gives penalty 0.

In the second test case, sum(a)=-5, and splitting into individual elements gives penalty 5, which is minimal.

In the fourth test case, sum(a)=4, and splitting into individual elements gives penalty 4.

In the fifth test case, sum(a)=8, but sample output is 4, which is half of |sum(a)|.

Wait, perhaps the minimal penalty is |sum(a)| when split into individual elements, but by grouping elements, we can reduce the penalty.

Wait, but in the third test case, sum(a)=0, and penalty=0, which is |sum(a)|.

In the second test case, sum(a)=-5, penalty=5=|sum(a)|.

In the fourth test case, sum(a)=4, penalty=4=|sum(a)|.

In the fifth test case, sum(a)=8, penalty=4=|sum(a)| /2.

So, perhaps in some cases, we can group subarrays in a way that the sum of |sum(b_i)| * len(b_i) is less than |sum(a)|.

Wait, but in the third test case, sum(a)=0, and penalty=0, which is |sum(a)|.

In the fifth test case, sum(a)=8, penalty=4, which is |sum(a)| /2.

Wait, perhaps the minimal penalty is |sum(a)| when split into individual elements, but by grouping, we can make it |sum(a)| / k for some k.

But I need a general approach.

Wait, perhaps I need to consider that the minimal penalty is equal to the minimal number of sign changes in the array or something similar.

Wait, perhaps it's related to the number of times the cumulative sum returns to zero.

Wait, perhaps it's equal to the absolute difference between the number of '+' and '-', which is |P - M|.

In the first test case, |1 - 0|=1, matches sample output 1.

Second test case, |0 - 5|=5, matches sample output 5.

Third test case, |3 - 3|=0, matches sample output 0.

Fourth test case, |7 - 3|=4, matches sample output 4.

Fifth test case, |14 - 6|=8, but sample output is 4, which doesn't match.

So, it's not