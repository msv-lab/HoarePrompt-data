Alright, I've got this problem here. It seems like it's about distributing water equally among containers with some constraints on how I can pour the water. Let me try to understand it step by step.

So, there are n containers lined up, each containing some amount of water, given by a_i. The sum of all a_i is divisible by n, which means it's possible to distribute the water equally among all containers in theory. The goal is to determine whether it's possible to make the amount of water in all containers the same using a specific operation: pouring any amount of water from container i to container j, but only if i < j.

First, I need to understand the constraints of the operation. The condition i < j means I can only pour water from a left container to a right container. I can't pour water from a right container to a left one. This seems like an important constraint because it imposes a direction on the flow of water.

Given that, I need to find out if it's possible to make all containers have the same amount of water by only pouring water from left to right.

Let me think about what the target amount of water per container should be. Since the total sum is divisible by n, the target amount is sum(a_i) / n. Let's call this target value 'mean'.

So, for each container, I need to adjust its water amount to 'mean'. But I can only pour water from left to right, meaning that any excess water in a container can only be poured into the containers to its right.

This sounds like a problem that can be solved by iterating through the containers from left to right and keeping track of the excess or deficit at each step.

Let me consider the first container. If it has more water than the mean, I can pour the excess to the right containers. If it has less, I need to receive water from the left, but since I can't pour from right to left, I can't get water from the right. So, if the first container has less than the mean, it's impossible to make it equal to the mean because I can't pour water from the right to the left.

Similarly, for subsequent containers, if their current amount plus the excess from the previous containers doesn't reach the mean, it's impossible.

Wait, maybe I need to keep track of the cumulative excess or deficit as I iterate through the containers.

Let me try to formalize this.

Let's iterate through the containers from left to right, and at each step, calculate the current cumulative excess or deficit compared to the mean.

Initialize a variable 'curr' to 0.

For each container from 1 to n:

curr += nums[i] - mean

If curr < 0 at any point, it means that the cumulative deficit is more than the excess from the previous containers, which can't be compensated by pouring from left to right because any excess can only be poured to the right.

Therefore, if at any point curr < 0, it's impossible to make all containers equal, and the answer is 'NO'. Otherwise, if curr remains non-negative throughout, it's possible, and the answer is 'YES'.

Wait, does this make sense?

Let me test this logic with the example given.

In the third test case:

n = 5

nums = [4, 5, 2, 1, 3]

sum(nums) = 4 + 5 + 2 + 1 + 3 = 15

mean = 15 / 5 = 3

Now, let's compute curr at each step:

i=0: curr = 4 - 3 = 1

i=1: curr += 5 - 3 = 1 + 2 = 3

i=2: curr += 2 - 3 = 3 - 1 = 2

i=3: curr += 1 - 3 = 2 - 2 = 0

i=4: curr += 3 - 3 = 0 + 0 = 0

curr never goes negative, so according to this, it should be 'YES', which matches the example.

Now, let's look at the second test case:

n = 2

nums = [1, 3]

sum(nums) = 1 + 3 = 4

mean = 4 / 2 = 2

Compute curr:

i=0: curr = 1 - 2 = -1

Since curr < 0 at the first step, it's 'NO', which matches the example.

Another test case:

n = 3

nums = [1, 2, 3]

sum(nums) = 6

mean = 2

Compute curr:

i=0: curr = 1 - 2 = -1

Since curr < 0 at the first step, it's 'NO', matching the example.

Another 'YES' case:

n = 7

nums = [6, 5, 5, 1, 3, 4, 4]

sum(nums) = 6 + 5 + 5 + 1 + 3 + 4 + 4 = 28

mean = 4

Compute curr:

i=0: curr = 6 - 4 = 2

i=1: curr += 5 - 4 = 2 + 1 = 3

i=2: curr += 5 - 4 = 3 + 1 = 4

i=3: curr += 1 - 4 = 4 - 3 = 1

i=4: curr += 3 - 4 = 1 - 1 = 0

i=5: curr += 4 - 4 = 0 + 0 = 0

i=6: curr += 4 - 4 = 0 + 0 = 0

curr never goes negative, so 'YES'.

A 'NO' case:

n = 7

nums = [4, 5, 5, 0, 6, 4, 4]

sum(nums) = 4 + 5 + 5 + 0 + 6 + 4 + 4 = 28

mean = 4

Compute curr:

i=0: curr = 4 - 4 = 0

i=1: curr += 5 - 4 = 0 + 1 = 1

i=2: curr += 5 - 4 = 1 + 1 = 2

i=3: curr += 0 - 4 = 2 - 4 = -2

Since curr < 0 at i=3, 'NO'.

This seems to work for the examples.

Now, let's think about why this works.

The idea is that as we iterate from left to right, any excess water in a container can be poured to the right containers. So, if a container has more than the mean, it can contribute to the containers to its right. If a container has less than the mean, it needs to receive water from the containers to its left.

But since we can only pour from left to right, the cumulative water available up to any point should be at least the cumulative mean up to that point. If it's not, it means there's a deficit that can't be compensated by pouring from the left.

Therefore, by keeping track of the cumulative difference, if it ever goes negative, it's impossible to achieve equal distribution.

Also, since the total sum is divisible by n, we don't need to worry about fractional amounts; the mean is an integer.

Edge cases to consider:

1. n = 1: Only one container, which is already equal to itself. Should be 'YES'.

2. All containers have the mean value: Should be 'YES'.

3. Containers have values in increasing order: Should be 'YES'.

4. Containers have values in decreasing order: Might be 'NO' depending on the values.

Let's test n=1:

n=1

nums=[43]

sum=43

mean=43

curr = 43 - 43 = 0

Never negative, 'YES'.

Another case:

n=3

nums=[2, 2, 2]

sum=6

mean=2

curr:

i=0: 2-2=0

i=1: 0 + (2-2)=0

i=2: 0 + (2-2)=0

'YES'.

n=4

nums=[1, 2, 3, 4]

sum=10

mean=2.5

Wait, but the problem states that sum is divisible by n, so mean is integer. Maybe I should assume mean is integer, as per the problem statement.

Wait, looking back:

"It is guaranteed that the sum of a_i is divisible by n ."

So, sum(a_i) % n == 0, so mean is integer.

Therefore, mean is always integer, and a_i are integers.

So, no need to worry about fractions.

Another test case:

n=4

sum=12

mean=3

nums=[3, 3, 3, 3]

curr:

i=0: 3-3=0

i=1: 0 + (3-3)=0

i=2: 0 + (3-3)=0

i=3: 0 + (3-3)=0

'YES'.

n=4

nums=[4, 2, 3, 3]

curr:

i=0: 4-3=1

i=1: 1 + (2-3)=-1+1=0

Wait, 1 + (-1)=0

i=2: 0 + (3-3)=0

i=3: 0 + (3-3)=0

'YES'.

But according to our logic, as long as curr doesn't go negative, it's 'YES'.

But in this case, curr did go to zero, which is okay.

Wait, but zero is not negative.

So, it's still 'YES'.

Another case:

n=3

nums=[0, 0, 6]

mean=2

curr:

i=0: 0-2=-2

Negative, 'NO'.

Correct, because we can't pour from left to right to make the first containers have more water.

Similarly, n=3

nums=[1, 2, 3]

mean=2

curr:

i=0: 1-2=-1

Negative, 'NO'.

Correct.

Now, let's consider n=4

nums=[2, 4, 0, 4]

mean=2.5? Wait, sum=10, mean=2.5, but according to the problem, sum is divisible by n, so mean is integer. So, maybe sum=12, n=4, mean=3.

nums=[3, 3, 3, 3]

Already covered.

Wait, to test more, let's consider:

n=4

sum=12

mean=3

nums=[4, 2, 2, 4]

curr:

i=0: 4-3=1

i=1: 1 + (2-3)=-1+1=0

Wait, 1 + (-1)=0

i=2: 0 + (2-3)=-1+1=0

Wait, 0 + (-1)=-1

Negative, 'NO'.

But let's see if it's actually possible.

Target is 3 for each container.

Starting with [4,2,2,4]

Pour from 0 to 1: [4-1,2+1=3,2,4] => [3,3,2,4]

Pour from 1 to 2: [3,3-1,2+1=3,4] => [3,2,3,4]

Wait, but 1 has only 2, which is less than mean, and 2 has 2, which is less than mean. Wait, this seems tricky.

Alternatively, pour from 3 to 2: [3,2,3+1=4,4-1=3] => [3,2,4,3]

Still, 2 has 4, which is more than mean, but 1 has 2, less than mean.

It seems impossible to balance all to 3 with the given operation.

Hence, 'NO', which matches the logic.

Another test case:

n=5

nums=[3,3,3,3,3]

mean=3

curr:

i=0: 3-3=0

i=1: 0 + (3-3)=0

i=2: 0 + (3-3)=0

i=3: 0 + (3-3)=0

i=4: 0 + (3-3)=0

'YES'.

Seems correct.

Now, considering the implementation:

The function func_1 takes nums as input.

It calculates n = len(nums)

total = sum(nums)

Checks if total % n != 0, but according to the problem, it's guaranteed that sum is divisible by n, so this check is redundant.

Then, mean = total // n

Initialize curr = 0

Iterate through nums:

curr += nums[i] - mean

if curr < 0:

return 'NO'

If loop completes without curr < 0, return 'YES'

This seems correct based on the reasoning above.

But in the given program, there's a check if total % n != 0, but according to the problem, it's guaranteed, so this check is unnecessary.

However, since the problem guarantees that sum is divisible by n, we can omit this check.

But having it doesn't harm, except for possibly incorrect inputs, which we are to assume are valid.

Given that, the function should work correctly for the problem's constraints.

Hence, the program is correct.

**Final Answer**

\[\boxed{\text{Yes}}\]