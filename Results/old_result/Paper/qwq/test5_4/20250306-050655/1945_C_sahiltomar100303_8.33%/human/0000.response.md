Alright, I've got this problem to solve. Let's see what it's asking for.

So, there are n houses in a village, and the villagers want to build a big road that divides the village into left and right sides. Each resident has a preference: they want to live on either the left side (0) or the right side (1). The road can be built between any two houses, or before the first house or after the last house.

The goal is to place the road such that at least half of the residents on each side are satisfied with their side. Satisfaction means that their preferred side matches the side they end up on. We need to choose the position that's as close as possible to the middle of the village, and if there are multiple positions with the same closeness to the middle, we should choose the smaller index.

First, I need to understand the problem clearly. We have a sequence of 0s and 1s, where each digit represents a resident's preference. We need to split this sequence into two parts at some position, and ensure that in each part, at least half of the residents are getting their preferred side.

For example, if we split after position i, the left side will be houses 1 to i, and the right side will be houses i+1 to n. We need to make sure that in the left side, at least ceil(i/2) residents want to be on the left (i.e., have 0), and in the right side, at least ceil((n-i)/2) residents want to be on the right (i.e., have 1).

The task is to find the position i that minimizes the absolute difference between i and n/2, and if there are multiple such positions, choose the smallest i.

I need to make sure that my solution is efficient because the constraints are large: n can be up to 3*10^5, and there can be up to 2*10^4 test cases, with the sum of n over all test cases up to 3*10^5.

So, efficiency is key here. I need an approach that can handle this within reasonable time limits.

Let me think about how to approach this.

First, for each possible split position i (from 0 to n), I need to check two conditions:

1. In the left part (houses 1 to i), the number of 0s is at least ceil(i/2).

2. In the right part (houses i+1 to n), the number of 1s is at least ceil((n-i)/2).

I need to find the i that minimizes |i - n/2|, and among such i's, choose the smallest one.

Brute-forcing this would be too slow because for each test case, if I iterate through all possible i's and check the conditions each time, it would be O(n) per test case, which with n up to 3*10^5 and t up to 2*10^4, would be too slow.

So, I need a smarter way to compute this.

I think prefix sums can help here. I can precompute the number of 0s up to each position and the number of 1s from each position to the end.

Let's define:

- leftZero[i]: number of 0s in houses 1 to i

- rightOne[i]: number of 1s in houses i+1 to n

Then, for each i, I can quickly get:

- leftSide = i

- rightSide = n - i

- satisfiedLeft = leftZero[i]

- satisfiedRight = rightOne[i]

Then, I need to check:

- satisfiedLeft >= ceil(leftSide / 2)

- satisfiedRight >= ceil(rightSide / 2)

I can precompute leftZero and rightOne using prefix sums.

Let me think about how to implement this.

First, read t, the number of test cases.

Then, for each test case:

- Read n and the string s of length n.

- Compute leftZero[i]: number of 0s from position 1 to i.

- Compute rightOne[i]: number of 1s from position i+1 to n.

- Then, iterate through i from 0 to n, and for each i, check the conditions:

- If leftSide = i, then ceil(leftSide / 2) = ceil(i / 2)

- If rightSide = n - i, then ceil(rightSide / 2) = ceil((n - i) / 2)

- Check if leftZero[i] >= ceil(i / 2) and rightOne[i] >= ceil((n - i) / 2)

- Among all i that satisfy these conditions, find the one with the smallest |i - n/2|, and if there are multiple, choose the smallest i.

I need to handle the ceiling of division carefully. In Python, I can use math.ceil(x / 2) or use (x + 1) // 2.

Let me see an example to verify this.

Take the first example from the problem:

n = 3

s = "101"

Possible splits:

- i = 0: entire village on right side.

rightSide = 3, need ceil(3/2) = 2 ones on right.

satisfiedRight = number of 1s in positions 1 to 3: 2 (positions 1 and 3).

So, 2 >= 2, which is okay.

leftSide = 0, which is fine since there's no left side.

- i = 1: road after house 1.

leftSide = 1, need ceil(1/2) = 1 satisfied on left.

leftZero[1] = number of 0s in position 1: 0 (since s[1] = '1')

0 < 1, so condition fails.

rightSide = 2, need ceil(2/2) = 1 satisfied on right.

rightOne[1] = number of 1s in positions 2 and 3: 1 (position 3).

1 >= 1, which is okay.

But left side fails, so i=1 is invalid.

- i = 2: road after house 2.

leftSide = 2, need ceil(2/2) = 1 satisfied on left.

leftZero[2] = number of 0s in positions 1 and 2: 1 (position 2).

1 >= 1, which is okay.

rightSide = 1, need ceil(1/2) = 1 satisfied on right.

rightOne[2] = number of 1s in position 3: 1.

1 >= 1, which is okay.

So, i=2 is valid.

- i = 3: entire village on left side.

leftSide = 3, need ceil(3/2) = 2 satisfied on left.

leftZero[3] = number of 0s in positions 1 to 3: 1 (position 2).

1 < 2, so condition fails.

So, only i=2 is valid.

According to the problem, we need to choose the i that is closest to n/2, which is 1.5. So, i=2 has |2 - 1.5| = 0.5, and i=0 has |0 - 1.5| = 1.5. So, i=2 is closer.

Hence, output is 2.

Another example:

n=6

s=010111

Let's compute leftZero and rightOne.

positions: 1:0, 2:1, 3:0, 4:1, 5:1, 6:1

leftZero[i]:

i=0: 0

i=1:1

i=2:1

i=3:2

i=4:2

i=5:2

i=6:2

rightOne[i]:

i=0:3

i=1:3

i=2:2

i=3:2

i=4:1

i=5:1

i=6:0

Now, check for each i from 0 to 6:

i=0:

leftSide=0 (no left side)

rightSide=6, ceil(6/2)=3

rightOne[0]=3 >=3, okay.

So, valid.

|i - n/2| = |0 - 3| = 3

i=1:

leftSide=1, ceil(1/2)=1

leftZero[1]=1 >=1

rightSide=5, ceil(5/2)=3

rightOne[1]=3 >=3

Okay.

|i - n/2| = |1 - 3| = 2

i=2:

leftSide=2, ceil(2/2)=1

leftZero[2]=1 >=1

rightSide=4, ceil(4/2)=2

rightOne[2]=2 >=2

Okay.

|i - n/2| = |2 - 3| =1

i=3:

leftSide=3, ceil(3/2)=2

leftZero[3]=2 >=2

rightSide=3, ceil(3/2)=2

rightOne[3]=2 >=2

Okay.

|i - n/2| = |3 - 3| =0

i=4:

leftSide=4, ceil(4/2)=2

leftZero[4]=2 >=2

rightSide=2, ceil(2/2)=1

rightOne[4]=1 >=1

Okay.

|i - n/2| = |4 - 3| =1

i=5:

leftSide=5, ceil(5/2)=3

leftZero[5]=2 <3

Fails.

i=6:

leftSide=6, ceil(6/2)=3

leftZero[6]=2 <3

Fails.

So, valid i's are 0,1,2,3,4.

Among these, the one with minimal |i - n/2| is i=3 with |3-3|=0.

So, output is 3.

Another example:

n=6

s=011001

leftZero[i]:

i=0:0

i=1:1

i=2:1

i=3:1

i=4:2

i=5:2

i=6:2

rightOne[i]:

i=0:3

i=1:3

i=2:2

i=3:1

i=4:1

i=5:1

i=6:0

Check i from 0 to 6:

i=0:

leftSide=0

rightSide=6, ceil(6/2)=3

rightOne[0]=3 >=3

Okay.

|i - n/2| = |0 - 3|=3

i=1:

leftSide=1, ceil(1/2)=1

leftZero[1]=1 >=1

rightSide=5, ceil(5/2)=3

rightOne[1]=3 >=3

Okay.

|i - n/2|=2

i=2:

leftSide=2, ceil(2/2)=1

leftZero[2]=1 >=1

rightSide=4, ceil(4/2)=2

rightOne[2]=2 >=2

Okay.

|i - n/2|=1

i=3:

leftSide=3, ceil(3/2)=2

leftZero[3]=1 <2

Fails.

i=4:

leftSide=4, ceil(4/2)=2

leftZero[4]=2 >=2

rightSide=2, ceil(2/2)=1

rightOne[4]=1 >=1

Okay.

|i - n/2|=1

i=5:

leftSide=5, ceil(5/2)=3

leftZero[5]=2 <3

Fails.

i=6:

leftSide=6, ceil(6/2)=3

leftZero[6]=2 <3

Fails.

Valid i's:0,1,2,4

Minimal |i - n/2| is 1, achieved at i=2 and i=4.

Choose the smaller i, which is 2.

Output is 2.

Another example:

n=3

s=000

leftZero[i]:

i=0:0

i=1:1

i=2:2

i=3:3

rightOne[i]:

i=0:0

i=1:0

i=2:0

i=3:0

Check i from 0 to 3:

i=0:

leftSide=0

rightSide=3, ceil(3/2)=2

rightOne[0]=0 <2

Fails.

i=1:

leftSide=1, ceil(1/2)=1

leftZero[1]=1 >=1

rightSide=2, ceil(2/2)=1

rightOne[1]=0 <1

Fails.

i=2:

leftSide=2, ceil(2/2)=1

leftZero[2]=2 >=1

rightSide=1, ceil(1/2)=1

rightOne[2]=0 <1

Fails.

i=3:

leftSide=3, ceil(3/2)=2

leftZero[3]=3 >=2

rightSide=0

Okay.

|i - n/2| = |3 - 1.5| =1.5

So, only i=3 is valid.

Output is 3.

Another example:

n=3

s=110

leftZero[i]:

i=0:0

i=1:0

i=2:0

i=3:1

rightOne[i]:

i=0:3

i=1:3

i=2:2

i=3:1

Check i from 0 to 3:

i=0:

leftSide=0

rightSide=3, ceil(3/2)=2

rightOne[0]=3 >=2

Okay.

|i - n/2| = |0 - 1.5|=1.5

i=1:

leftSide=1, ceil(1/2)=1

leftZero[1]=0 <1

Fails.

i=2:

leftSide=2, ceil(2/2)=1

leftZero[2]=0 <1

Fails.

i=3:

leftSide=3, ceil(3/2)=2

leftZero[3]=1 <2

Fails.

Only i=0 is valid.

Output is 0.

Another example:

n=3

s=001

leftZero[i]:

i=0:0

i=1:1

i=2:2

i=3:2

rightOne[i]:

i=0:1

i=1:1

i=2:1

i=3:1

Check i from 0 to 3:

i=0:

leftSide=0

rightSide=3, ceil(3/2)=2

rightOne[0]=1 <2

Fails.

i=1:

leftSide=1, ceil(1/2)=1

leftZero[1]=1 >=1

rightSide=2, ceil(2/2)=1

rightOne[1]=1 >=1

Okay.

|i - n/2| = |1 - 1.5|=0.5

i=2:

leftSide=2, ceil(2/2)=1

leftZero[2]=2 >=1

rightSide=1, ceil(1/2)=1

rightOne[2]=1 >=1

Okay.

|i - n/2|=0.5

i=3:

leftSide=3, ceil(3/2)=2

leftZero[3]=2 >=2

rightSide=0

Okay.

|i - n/2|=1.5

So, valid i's:1,2,3

Minimal |i - n/2| is 0.5, achieved at i=1 and i=2.

Choose the smaller i, which is 1.

Output is 1.

Last example:

n=4

s=1100

leftZero[i]:

i=0:0

i=1:0

i=2:0

i=3:1

i=4:1

rightOne[i]:

i=0:2

i=1:2

i=2:1

i=3:1

i=4:0

Check i from 0 to 4:

i=0:

leftSide=0

rightSide=4, ceil(4/2)=2

rightOne[0]=2 >=2

Okay.

|i - n/2|=|0 - 2|=2

i=1:

leftSide=1, ceil(1/2)=1

leftZero[1]=0 <1

Fails.

i=2:

leftSide=2, ceil(2/2)=1

leftZero[2]=0 <1

Fails.

i=3:

leftSide=3, ceil(3/2)=2

leftZero[3]=1 <2

Fails.

i=4:

leftSide=4, ceil(4/2)=2

leftZero[4]=1 <2

Fails.

Only i=0 is valid.

Output is 0.

From these examples, it seems that my approach is correct.

Now, to implement this efficiently, I need to precompute leftZero and rightOne arrays.

In code, I can do:

leftZero = [0] * (n + 1)

for i in range(1, n + 1):

leftZero[i] = leftZero[i-1] + (s[i-1] == '0')

Similarly,

rightOne = [0] * (n + 1)

for i in range(n-1, -1, -1):

rightOne[i] = rightOne[i+1] + (s[i] == '1')

Then, for each i from 0 to n:

leftSide = i

rightSide = n - i

satisfiedLeft = leftZero[i]

satisfiedRight = rightOne[i]

needLeft = (leftSide + 1) // 2

needRight = (rightSide + 1) // 2

if satisfiedLeft >= needLeft and satisfiedRight >= needRight:

candidate_i = i

compute |i - n/2| and keep track of the minimum.

If multiple i's have the same |i - n/2|, choose the smallest i.

Finally, output the chosen i.

To optimize, since we need to minimize |i - n/2|, we can iterate i in order of increasing |i - n/2|.

That is, start from i = floor(n/2), then move outwards.

But since n can be up to 3*10^5, and t up to 2*10^4, with sum of n over all test cases up to 3*10^5, we need an efficient way.

Wait, actually, for each test case, n can be up to 3*10^5, and t up to 2*10^4, but the sum of n over all test cases is up to 3*10^5, so overall time should be O(n*t) = O(3*10^5), which should be acceptable.

But still, I need to make sure that for each test case, I can compute the answer in O(n) time, which is acceptable.

Now, in the code, I need to handle i from 0 to n, which is n+1 positions.

I need to iterate through all possible i's, compute the conditions, and keep track of the minimum |i - n/2| and the smallest i among those.

An optimization could be to iterate i in order of increasing |i - n/2|, but that might not be necessary if we can iterate i from 0 to n and keep track of the minimum |i - n/2|.

Wait, actually, to minimize |i - n/2|, I can compute the absolute difference for each i and keep track of the minimum difference and the corresponding i's, and then choose the smallest i among those with the minimum difference.

But to make it efficient, I can iterate i from 0 to n, compute the conditions, and keep track of the minimum |i - n/2| and the corresponding i's.

Finally, choose the smallest i among those with the minimum |i - n/2|.

I need to make sure that I handle i=0 and i=n correctly.

Also, I need to make sure that for i=0, leftSide=0, and rightSide=n, and similarly for i=n, leftSide=n, rightSide=0.

In programming terms, floor division in Python can be used, but I need to be careful with ceil division.

In Python, ceil(x / 2) can be implemented as (x + 1) // 2.

So, needLeft = (leftSide + 1) // 2

needRight = (rightSide + 1) // 2

satisfiedLeft = leftZero[i]

satisfiedRight = rightOne[i]

If both satisfiedLeft >= needLeft and satisfiedRight >= needRight, then i is a candidate.

Among all candidate i's, find the one with the smallest |i - n/2|, and if there are multiple, choose the smallest i.

I need to implement this logic efficiently.

Now, looking at the given program, let's see if it matches this logic.

The given program is:

def func():

t = int(input())

for _ in range(t):

n = int(input())

s = input()

mid = n // 2

leftZero = 0

rightZero = 0

leftOne = 0

rightOne = 0

tleftZero = 0

trightZero = 0

tleftOne = 0

trightOne = 0

for i in range(mid):

if s[i] == '0':

leftZero += 1

tleftZero += 1

else:

leftOne += 1

tleftOne += 1

for i in range(mid, n):

if s[i] == '0':

rightZero += 1

trightZero += 1

else:

rightOne += 1

trightOne += 1

left = mid

leftMove = 0

while left > 0 and (leftZero < (left + 1) // 2 or rightOne < (n - left + 1) // 2):

if s[left - 1] == '0':

leftZero -= 1

rightZero += 1

else:

leftOne -= 1

rightOne += 1

left -= 1

right = mid

while right < n and (tleftZero < (right + 1) // 2 or trightOne < (n - right + 1) // 2):

if s[right] == '0':

tleftZero += 1

trightZero -= 1

else:

tleftOne += 1

trightOne -= 1

right += 1

if left == 0:

if right != n:

print(right)

elif rightOne >= (n + 1) // 2:

print(left)

else:

print(right)

elif right == n:

if tleftZero >= (n + 1) // 2:

print(right)

else:

print(left)

elif abs((n + 1) // 2 - left) <= abs((n + 1) // 2 - right):

print(left)

else:

print(right)

}

So, the given program seems to be trying to find the optimal i by moving left and right pointers and adjusting the counts accordingly.

It starts with mid = n // 2, and initializes counts for leftZero, rightZero, leftOne, rightOne, tleftZero, trightZero, tleftOne, trightOne.

Then, it seems to be trying to adjust the left and right pointers to satisfy the conditions.

However, I'm not entirely sure about the logic behind leftMove and the while loops.

Let me try to understand.

It seems like it's trying to move left and right pointers to find the smallest |i - n/2|.

But the logic seems a bit convoluted.

I think a simpler approach would be to iterate through all possible i from 0 to n, compute the conditions, and keep track of the minimum |i - n/2| and the corresponding i's.

Then, choose the smallest i among those with the minimum |i - n/2|.

But the given code seems to be trying to optimize by moving pointers.

I need to verify if the given code is correct.

Looking back at the examples, let's see if the given code produces the correct output.

Take the first example:

n=3

s=101

mid=1

Initialize:

for i in range(1):

i=0

s[0]='1' -> leftOne +=1, tleftOne +=1

for i in range(1,3):

i=1

s[1]='0' -> rightZero +=1, trightZero +=1

i=2

s[2]='1' -> rightOne +=1, trightOne +=1

So:

leftZero=0

rightZero=1

leftOne=1

rightOne=1

tleftZero=0

trightZero=1

tleftOne=1

trightOne=1

left=1

leftMove=0

while left > 0 and (0 < (1 +1)//2 or 1 < (3 -1 +1)//2) -> (0 < 1 or 1 < 2) -> (False or True) -> True

s[0]='1' -> leftOne -=1, rightOne +=1 -> leftOne=0, rightOne=2

left=0

Now:

right=1

while right < 3 and (0 < (1 +1)//2 or 1 < (3 -1 +1)//2) -> (0 < 1 or 1 < 2) -> (False or True) -> True

s[1]='0' -> tleftZero +=1 -> tleftZero=1; trightZero -=1 -> trightZero=0

right=2

while condition:

(1 < (2+1)//2 or 0 < (3-2+1)//2) -> (1 < 1 or 0 < 1) -> (False or True) -> True

s[2]='1' -> tleftOne +=1 -> tleftOne=2; trightOne -=1 -> trightOne=0

right=3

Now:

left=0

if left ==0:

if right !=3:

print(3)

elif rightOne >=2:

print(0)

else:

print(3)

rightOne=2 >=2, so print(0)

But according to the first example, the correct answer is 2, but the code outputs 0.

This suggests that the code is incorrect.

Wait, maybe I made a mistake in simulating the code.

Let's re-simulate.

After the while loops:

left=0

right=3

Now, left ==0 and right !=n (since n=3, right=3 which is equal to n), so right !=n is False.

So, print(right), which is 3.

But according to the correct answer, it should be 2.

So, there's a mistake in the code.

Hence, the given program is incorrect.

Therefore, Correctness: False

**Final Answer**

\boxed{\text{False}}