Alright, I've got this problem to solve. Let's see what it's about. There are n people in a programming contest chat, ordered by their activity, but each person sees themselves at the top of the list. So, for example, if the actual order is [2, 3, 1, 4], then:

- User 1 sees [1, 2, 3, 4]

- User 2 sees [2, 3, 1, 4]

- User 3 sees [3, 2, 1, 4]

- User 4 sees [4, 2, 3, 1]

Got it. So, k people posted screenshots of the order they saw, and I need to determine if there's a single actual order that corresponds to all these screenshots.

First, I need to understand the problem clearly. Each screenshot shows an order where the user who took the screenshot sees themselves at the top, followed by the rest of the users in the actual order.

So, if the actual order is [2, 3, 1, 4], then:

- User 1 would see [1, 2, 3, 4]

- User 2 sees [2, 3, 1, 4]

- User 3 sees [3, 2, 1, 4]

- User 4 sees [4, 2, 3, 1]

Given k such screenshots, I need to check if there exists an actual order that could produce all these views.

Constraints:

- 1 ≤ k ≤ n ≤ 2*10^5

- n*k ≤ 2*10^5

- All authors of screenshots are different.

Input consists of t test cases, each starting with n and k, followed by k lines each containing n integers representing the order seen by the user who took the screenshot (with themselves at the front).

Output for each test case is "YES" if there's a possible actual order consistent with all screenshots, else "NO".

Example is provided, but I need to think about the general approach.

Approach:

1. **Identify the actual order from the screenshots:**

- Each screenshot shows the user who took it at the front, followed by the rest of the users in the actual order.

- So, if I have multiple screenshots, I can try to reconstruct the actual order by aligning these views.

2. **Check consistency between screenshots:**

- For the actual order to be consistent across all screenshots, the relative order of users (excluding the top user in each screenshot) should match.

- Essentially, for any two screenshots, the order of users excluding the top user should be permutations of each other, with possible differences only in the position of the top user.

3. **Algorithm:**

- Read the first screenshot and assume it's the actual order, but with the first user being at the top.

- For each subsequent screenshot, compare the order excluding the first user with the previous orders, adjusting for the new top user.

- Ensure that the relative order of the remaining users is consistent.

Wait, maybe I need a better way to model this.

Alternative approach:

- Consider the actual order as a permutation of 1 to n.

- Each screenshot provides a view where the user who took the screenshot is at the front, followed by the rest of the users in the actual order.

- So, for a given actual order, say [a1, a2, a3, ..., an], user ai would see [ai, a1, a2, ..., ai-1, ai+1, ..., an].

- But in the problem, it's specified that each user sees themselves at the top, followed by the rest in the actual order.

Wait, no. More precisely, each user sees themselves at the top, followed by the rest of the users in the actual order.

So, if the actual order is [2, 3, 1, 4], then:

- User 1 sees [1, 2, 3, 4]

- User 2 sees [2, 3, 1, 4]

- User 3 sees [3, 2, 1, 4]

- User 4 sees [4, 2, 3, 1]

Looking at this, I can see that for any user ai, their view is [ai, followed by the rest of the actual order excluding ai].

So, in general, for user x, their view is [x, followed by the actual order minus x].

Given k such views, I need to find if there exists an actual order such that each view corresponds to some user's perspective.

This seems like a problem where I need to find a consistent actual order that matches all the provided views.

I need to find a way to reconstruct the actual order from these views.

Let me consider that the actual order is a permutation P = [p1, p2, ..., pn].

Then, for any user x, their view would be [x, followed by P minus x].

Given that, if I have k such views, I can try to find P such that for each view, it matches [x, followed by P minus x].

So, for each view, I know the user who took it (it's the first element), and the rest should be P minus x.

Thus, for two different views, say view A and view B, the rest of the elements after the first should be the same except that the first elements are moved to the front.

Wait, maybe I need to think in terms of relative positions.

Another way: consider that in the actual order P, for any two users, their relative order in P should be consistent across all views, except for the top user who is moved to the front.

So, if I fix the actual order P, then for any user x, their view would be [x, followed by P minus x].

Given that, if I have multiple views, I can compare the sequences excluding the first element to see if they are permutations of each other, with possible differences only in the position of the top user.

Wait, maybe I need to look for a common sequence that can be transformed into each view by moving one user to the front.

This sounds similar to checking if all views can be obtained by rotating or permuting the actual order in a specific way.

Let me consider that the actual order is a fixed permutation, and each view is a modification of this permutation by moving one element to the front.

So, to check consistency, I need to see if there exists a permutation P such that for each view, it can be obtained by moving some element to the front.

But in this specific problem, it's more constrained because each user sees themselves at the front, followed by the rest in the actual order.

So, perhaps I can try to reconstruct the actual order step by step.

Let's consider the first view:

- Let's say the first view is from user A, so it's [A, B, C, D, ...]

- This means that in the actual order, B, C, D, ... follow A.

Now, take the second view:

- Suppose it's from user B: [B, C, A, D, ...]

- So, in the actual order, C, A, D, ... follow B.

- Comparing with the first view, we can try to align these sequences.

I need to find a way to merge these views consistently.

Maybe I can think of it as constructing a graph where nodes are users, and edges represent the relative order.

For example, if in one view, A comes before B, and in another view, B comes before A, then it's inconsistent.

But in this problem, since each user sees themselves at the top, followed by the actual order, the relative order of other users should be consistent.

Wait, perhaps I can fix the actual order and see if all views correspond to some user's perspective.

Let me try with the example provided.

Example Input:

10

5 1

1 2 3 4 5

4 4

1 2 3 4

2 3 1 4

3 2 1 4

4 2 3 1

6 2

1 3 5 2 4 6

6 3 5 2 1 4

3 3

1 2 3

2 3 1

3 2 1

10 2

1 2 3 4 5 6 7 8 9 10

10 9 8 7 6 5 4 3 2 1

1 1

1

5 2

1 2 3 5 4

2 1 3 5 4

3 3

3 1 2

2 3 1

1 3 2

5 4

3 5 1 4 2

2 5 1 4 3

1 5 4 3 2

5 1 4 3 2

3 3

1 3 2

2 1 3

3 2 1

Example Output:

YES

YES

YES

YES

NO

YES

YES

YES

YES

NO

Looking at the first test case:

n=5, k=1

Screenshot: [1,2,3,4,5]

Since there's only one screenshot, it's trivially consistent. So, "YES"

Second test case:

n=4, k=4

Screenshots:

[1,2,3,4]

[2,3,1,4]

[3,2,1,4]

[4,2,3,1]

Need to check if there exists an actual order P such that:

- User 1 sees [1,2,3,4]

- User 2 sees [2,3,1,4]

- User 3 sees [3,2,1,4]

- User 4 sees [4,2,3,1]

Let's assume P = [2,3,1,4]

- User 1 would see [1,2,3,4]

- User 2 would see [2,3,1,4]

- User 3 would see [3,2,1,4]

- User 4 would see [4,2,3,1]

This matches all the screenshots. So, "YES"

Third test case:

n=6, k=2

Screenshots:

[1,3,5,2,4,6]

[6,3,5,2,1,4]

So, user 1 sees [1,3,5,2,4,6]

User 6 sees [6,3,5,2,1,4]

Assume actual order P = [3,5,2,4,6,1]

- User 1 would see [1,3,5,2,4,6]

- User 6 would see [6,3,5,2,1,4]

This matches both screenshots. So, "YES"

Fourth test case:

n=3, k=3

Screenshots:

[1,2,3]

[2,3,1]

[3,2,1]

Assume actual order P = [2,3,1]

- User 1 would see [1,2,3]

- User 2 would see [2,3,1]

- User 3 would see [3,2,1]

This matches all screenshots. So, "YES"

Fifth test case:

n=10, k=2

Screenshots:

[1,2,3,4,5,6,7,8,9,10]

[10,9,8,7,6,5,4,3,2,1]

Assume actual order P = [1,2,3,4,5,6,7,8,9,10]

- User 1 would see [1,2,3,4,5,6,7,8,9,10]

- User 10 would see [10,1,2,3,4,5,6,7,8,9]

But the second screenshot is [10,9,8,7,6,5,4,3,2,1], which doesn't match [10,1,2,3,4,5,6,7,8,9]

So, no consistent actual order exists. Hence, "NO"

Sixth test case:

n=1, k=1

Screenshot: [1]

Trivially "YES"

Seventh test case:

n=5, k=2

Screenshots:

[1,2,3,5,4]

[2,1,3,5,4]

Assume actual order P = [2,1,3,5,4]

- User 1 would see [1,2,3,5,4]

- User 2 would see [2,1,3,5,4]

This matches both screenshots. So, "YES"

Eighth test case:

n=3, k=3

Screenshots:

[3,1,2]

[2,3,1]

[1,3,2]

Assume actual order P = [3,1,2]

- User 3 would see [3,1,2]

- User 2 would see [2,3,1]

- User 1 would see [1,3,2]

This matches all screenshots. So, "YES"

Ninth test case:

n=5, k=4

Screenshots:

[3,5,1,4,2]

[2,5,1,4,3]

[1,5,4,3,2]

[5,1,4,3,2]

Let's try to find a consistent P.

Looking at these, it seems possible, but I need to check.

Tentatively, assume P = [5,1,4,3,2]

- User 3 would see [3,5,1,4,2]

- User 2 would see [2,5,1,4,3]

- User 1 would see [1,5,4,3,2]

- User 5 would see [5,1,4,3,2]

This matches all screenshots. So, "YES"

Tenth test case:

n=3, k=3

Screenshots:

[1,3,2]

[2,1,3]

[3,2,1]

Assume P = [1,3,2]

- User 1 would see [1,3,2]

- User 2 would see [2,1,3]

- User 3 would see [3,1,2]

Wait, but the third screenshot is [3,2,1], which doesn't match [3,1,2]

So, no consistent P exists. Hence, "NO"

From these examples, I can see that to solve this problem, I need to find if there exists an actual order P such that for each screenshot, it matches the view obtained by moving the user who took the screenshot to the front, followed by the rest of P in order.

Approach:

1. **Handle the case when k=1:** Always "YES" since there's only one screenshot.

2. **For k>1:**

a. Take the first two screenshots and try to find a common actual order.

b. For each subsequent screenshot, verify if it's consistent with the inferred actual order.

But I need a better way to do this efficiently, considering the constraints.

I need to find a way to reconstruct P from the screenshots and check consistency.

Another idea:

- Consider that in the actual order P, for any two users x and y, if x comes before y in P, then in all screenshots excluding the top user, x should come before y, unless y is the top user in that screenshot.

Wait, maybe I can model this as a graph where edges represent the relative order of users, and check for consistency.

But that might be too time-consuming given the constraints.

Alternative idea:

- Since each screenshot shows the user who took it at the front, followed by the actual order minus that user, I can try to align the sequences by removing the first element and see if the remaining sequences are permutations of each other, with possible differences only in the position of the top user.

Wait, perhaps I can find the intersection of the sequences after removing the first element.

Let me think about it step by step.

Given two screenshots:

- [a, b, c, d, ...]

- [e, b, c, d, ...]

Then, the actual order P should be such that after moving a and e to the front in their respective views, the rest matches P minus a and P minus e.

So, P should be [b, c, d, ...], with a and e inserted appropriately.

Wait, maybe I can reconstruct P by merging the sequences.

Let me consider that P is the order that can be obtained by merging the sequences after removing the first element, while respecting the positions of the top users.

This seems complicated. Maybe I can look for a way to find the actual order by fixing one sequence and adjusting the others accordingly.

Looking back at the provided code, it seems to handle the merging of sequences in a specific way, especially for k=2 and k=3.

But I need to verify if this approach is correct.

Looking at the code:

def func():

t = int(input())

for _ in range(t):

n, m = map(int, input().split())

if m == 1:

input()

print('yes')

continue

(a1, *l1) = map(int, input().split())

(a2, *l2) = map(int, input().split())

l11 = [i for i in l1 if i != a2]

l22 = [i for i in l2 if i != a1]

if l11 != l22:

for _ in range(m - 2):

input()

print('no')

continue

idx1 = idx2 = -1

p1 = p2 = 0

for i in range(n - 1):

if i + max(p1, p2) == n - 1:

break

if l1[i + p1] != l2[i + p2]:

if l1[i + p1] == a2 and l2[i + p2] == a1:

idx1 = idx2 = i

break

else:

if l1[i + p1] == a2:

idx1 = i

p1 = 1

else:

idx2 = i

p2 = 1

if idx1 >= 0 and idx2 >= 0:

break

val = []

if idx1 < idx2:

l2.insert(idx1, a2)

l = l2

elif idx1 > idx2:

l1.insert(idx2, a1)

l = l1

else:

if m == 2:

print('yes')

continue

(a3, *l3) = map(int, input().split())

if l3.index(a1) < l3.index(a2):

l1.insert(idx2, a1)

l = l1

else:

l2.insert(idx1, a2)

l = l2

val.append((a3, l3))

m -= 1

for _ in range(m - 2):

(a3, *l3) = map(int, input().split())

val.append((a3, l3))

for (a3, l3) in val:

if l3 != [i for i in l if i != a3]:

print('no')

break

else:

print('yes')

This code seems to handle the merging of the first two sequences to infer the actual order, and then checks the remaining sequences against this inferred order.

Let's see how it works with an example.

Take the second test case:

n=4, k=4

Screenshots:

[1,2,3,4]

[2,3,1,4]

[3,2,1,4]

[4,2,3,1]

Processing:

- m=4 >1

- a1=1, l1=[2,3,4]

- a2=2, l2=[3,1,4]

- l11 = [2,3,4] excluding a2=2: [3,4]

- l22 = [3,1,4] excluding a1=1: [3,4]

- l11 == l22: [3,4]

- idx1 = idx2 = -1

- p1 = p2 =0

- For i from 0 to 3:

i=0:

l1[0+0]=2 != l2[0+0]=3

l1[0]=2 == a2=2 and l2[0]=3 == a1=1? 2 ==2 and 3==1? No

- Since l1[i+p1]=2 != a2=2, and l2[i+p2]=3 != a1=1, no action

i=1:

l1[1+0]=3 != l2[1+0]=1

l1[1]=3 !=a2=2, l2[1]=1 !=a1=1

- Since l1[1]=3 != l2[1]=1, and neither is equal to a1 or a2, something's wrong

Wait, but in the example, it should work.

Wait, maybe I need to trace the code more carefully.

In the code, for i in range(n-1):

if i + max(p1,p2) == n-1:

break

if l1[i+p1] != l2[i+p2]:

if l1[i+p1] == a2 and l2[i+p2] == a1:

idx1 = idx2 = i

break

else:

if l1[i+p1] == a2:

idx1 =i

p1=1

else:

idx2=i

p2=1

if idx1 >=0 and idx2 >=0:

break

In the example:

n=4, m=4

a1=1, l1=[2,3,4]

a2=2, l2=[3,1,4]

i=0:

l1[0+0]=2 != l2[0+0]=3

l1[0]=2 == a2=2, l2[0]=3 == a1=1? 2==2 and 3==1? No

- l1[i+p1]=2 ==a2=2, so idx1=0, p1=1

i=1:

l1[1+1]=4 != l2[1+0]=1

l1[2]=4 != a2=2, l2[1]=1 != a1=1

- Since l1[2]=4 != a2=2, and l2[1]=1 != a1=1, and l1[2] != l2[1], it's inconsistent

But in the example, it should be consistent.

Wait, perhaps I need to see what the code does in this case.

Given that idx1=0 and p1=1, and idx2 is still -1, and p2=0

Continue loop:

i=1:

l1[1+1]=4 != l2[1+0]=1

l1[2]=4 !=a2=2, l2[1]=1 !=a1=1

- Since l1[2]=4 != l2[1]=1, and l1[2] !=a2=2, and l2[1] !=a1=1, it seems inconsistent

But in reality, it should be consistent. Maybe the code has a flaw.

Wait, perhaps I need to see what the correct approach should be.

Alternative approach:

- Collect all the screenshots.

- For each screenshot, note the user who took it (first element).

- For each screenshot, the rest of the list should be the actual order minus the user who took the screenshot.

- So, for k screenshots, I can try to find an actual order P such that for each screenshot, P minus the top user matches the rest of the screenshot.

- To find such P, I can try to find the intersection of all the rest parts, considering the positions.

- Alternatively, I can try to find a permutation P such that for each screenshot, the rest of the elements match P minus the top user.

- This can be done by checking if all the rest parts are permutations of each other, with the top user moved to the front.

Wait, perhaps I can fix P based on one screenshot and check consistency with others.

For example:

- Take the first screenshot and assume P is the rest of the elements in that screenshot, with the top user at the front.

- Then, for each subsequent screenshot, check if the rest of the elements match P minus the top user of that screenshot.

Wait, let's formalize this.

Algorithm:

1. If k=1, output "YES" since there's only one screenshot.

2. For k>=2:

a. Take the first screenshot. Let's say it's [a1, b1, c1, ..., n1]

- Assume P = [a1, b1, c1, ..., n1]

b. For each subsequent screenshot [ai, bi, ci, ..., ni]:

- The expected order should be [ai, a1, b1, c1, ..., n1] minus ai.

- So, check if