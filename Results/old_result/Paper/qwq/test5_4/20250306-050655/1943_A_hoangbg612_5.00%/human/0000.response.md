Alright, I have this problem to solve. It involves a game between Alice and Bob on an array of integers, and I need to determine the final score of the game based on their optimal plays. Let's break this down step by step.

First, understanding the game mechanics:

1. There's an array `a` of size `n`, and Alice starts with an empty array `c`.

2. Players take turns, with Alice going first.

3. On Alice's turn, she picks one element from `a`, appends it to `c`, and deletes it from `a`.

4. On Bob's turn, he picks one element from `a`, deletes it from `a`, but does not add it to `c`.

5. The game ends when `a` is empty, and the score is the MEX of `c`, which is the smallest non-negative integer not present in `c`.

6. Alice wants to maximize the MEX, while Bob wants to minimize it.

Given that, I need to find out what the MEX will be if both play optimally.

Let me think about what MEX actually means. MEX is the smallest non-negative integer not present in the array. So, for example:

- If `c` is [0, 1, 3], MEX is 2.

- If `c` is [0, 1, 2, 3], MEX is 4.

- If `c` is [1, 2, 3], MEX is 0.

So, Alice wants the highest possible MEX, which means she wants to have as many small integers in `c` as possible, in order. Bob, on the other hand, wants to minimize the MEX, so he'll try to disrupt Alice's efforts.

Given that Alice and Bob are playing optimally, I need to model their strategies accordingly.

Let's consider the total number of moves:

- There are `n` elements in `a`.

- Alice makes a move by choosing an element for `c` and removing it from `a`.

- Bob makes a move by removing an element from `a` without adding it to `c`.

- Since Alice starts, and they alternate turns, the number of moves Alice makes is ceil(n/2), and Bob makes floor(n/2) moves.

Wait, no. Let's think carefully:

- Total elements: `n`.

- Alice picks one element per turn and adds it to `c`.

- Bob picks one element per turn but doesn't add it to `c`.

- The game ends when `a` is empty.

- Since Alice starts, if `n` is odd, Alice makes one more move than Bob.

- If `n` is even, they make equal moves.

So, number of elements Alice picks: ceil(n/2).

Number of elements Bob picks: floor(n/2).

Hence, size of `c` will be ceil(n/2).

Now, Alice wants to maximize the MEX of `c`, meaning she wants `c` to contain as many small integers as possible, in order.

Bob wants to minimize the MEX of `c`, meaning he wants to disrupt Alice's efforts by removing elements that would help Alice achieve a higher MEX.

So, in essence, Alice is trying to collect numbers to make `c` have a high MEX, while Bob is trying to prevent that by removing potentially useful numbers.

I need to simulate their optimal strategies to find out what the final MEX of `c` would be.

Let me consider some examples to understand this better.

Example 1:

Input:

4

0 0 1 1

Steps:

1. Alice picks 1, c = [1], a = [0,0,1]

2. Bob picks 0, a = [0,1]

3. Alice picks 0, c = [1,0], a = [1]

4. Bob picks 1, a = []

Final c: [1,0], MEX is 2.

Example 2:

Input:

4

0 1 2 3

Steps:

1. Alice picks 0, c = [0], a = [1,2,3]

2. Bob picks 1, a = [2,3]

3. Alice picks 2, c = [0,2], a = [3]

4. Bob picks 3, a = []

Final c: [0,2], MEX is 1.

Wait, but according to the example output, it should be 1, which is correct.

Example 3:

Input:

2

1 1

Steps:

1. Alice picks 1, c = [1], a = [1]

2. Bob picks 1, a = []

Final c: [1], MEX is 0.

Okay, that makes sense.

From these examples, it seems like the game's outcome depends on who has control over picking which numbers and how they can block each other.

I need a systematic way to determine the MEX.

Let me think about the MEX in terms of the numbers available and the moves made.

Since Alice wants to maximize MEX, she would ideally want to have all numbers from 0 to k in `c`, where k is as large as possible.

Bob, wanting to minimize MEX, would try to prevent Alice from collecting a complete sequence.

Given that, perhaps I can model this as a game where Alice is trying to collect numbers in order, and Bob is trying to disrupt her collection.

Let me consider the frequency of each number in the initial array `a`.

Suppose I count how many times each number appears.

For example, in the first test case:

4

0 0 1 1

Frequency:

0: 2

1: 2

In the second test case:

4

0 1 2 3

Frequency:

0:1

1:1

2:1

3:1

In the third test case:

2

1 1

Frequency:

1:2

Now, considering that Alice and Bob alternate turns, with Alice starting, and Alice picking elements for `c`, while Bob picks elements to remove from `a`.

I need to see how the frequencies influence who can pick what.

Wait, perhaps I can think in terms of the number of times each number appears and how many times Alice can pick them versus how many times Bob can remove them.

Let's consider that for each number, the total count is known, and depending on the number of times it appears, Alice and Bob can make choices.

Let me consider that for a number `i`, if it appears `f[i]` times, then the number of times Alice can pick it is ceil(f[i]/2), assuming Bob tries to minimize her picks.

Wait, actually, since Alice picks first, for each number `i`, if it appears `f[i]` times, and Alice and Bob alternate picking, with Alice starting, then the number of times Alice can pick `i` is ceil(f[i]/2), and Bob can pick floor(f[i]/2).

Yes, that makes sense.

Hence, for each number `i`, Alice can get ceil(f[i]/2) instances into `c`.

Given that, the total number of times each `i` appears in `c` would be ceil(f[i]/2).

Then, `c` would contain, for each `i`, up to ceil(f[i]/2) instances.

But wait, MEX is about the smallest missing non-negative integer, so the order and counts matter in a certain way.

But in this problem, since we're dealing with non-negative integers and MEX, perhaps the counts only matter in terms of whether a number is present or not, but since duplicates can be present, their counts might influence who gets to pick them.

Wait, but MEX is about the smallest missing integer, so having multiple instances of the same number doesn't help in increasing MEX; it's about coverage of different integers.

But, in the first example, c=[1,0], which has both 0 and 1, so MEX is 2.

In the second example, c=[0,2], MEX is 1, even though 1 is present in a but Bob can remove it.

Wait, in the second example, a=[0,1,2,3], and c ends up with [0,2], so 1 and 3 are removed by Bob.

But according to the earlier logic, for each number, Alice can get ceil(f[i]/2) instances into c.

But in this case, f[0]=1, ceil(1/2)=1, so Alice gets 1 instance of 0.

Similarly, f[1]=1, ceil(1/2)=1, Alice gets 1 instance of 1.

f[2]=1, ceil(1/2)=1, Alice gets 1 instance of 2.

f[3]=1, ceil(1/2)=1, Alice gets 1 instance of 3.

But in reality, in the second example, c is [0,2], meaning Alice couldn't get both 1 and 3 into c.

Wait, perhaps I need to consider that Alice and Bob are picking elements in turns, and Alice chooses which element to pick for c, while Bob chooses which to remove.

So, Bob can strategically remove elements that Alice wants.

Hence, perhaps the earlier assumption that Alice gets ceil(f[i]/2) for each i isn't accurate, because Bob can choose to remove elements that Alice values more.

So, perhaps I need a different approach.

Let me think in terms of the game being a selection game where Alice wants to collect numbers to maximize MEX, and Bob wants to minimize it.

I need to find the optimal MEX that Alice can achieve despite Bob's efforts to minimize it.

This sounds like a game where I need to find the minimal MEX that Alice can guarantee to achieve, considering Bob's opposition.

In game theory, this is similar to finding the minimal value that the maximizing player (Alice) can ensure, given that the minimizing player (Bob) is trying to lower that value.

So, perhaps I can model this as a game where Alice tries to maximize MEX, and Bob tries to minimize it, and find the equilibrium point.

Let me consider that MEX is determined by the numbers present in c.

To maximize MEX, Alice wants c to contain as many small integers as possible.

Bob, to minimize MEX, would want to ensure that some small integers are not in c.

So, Bob would try to remove elements that Alice needs to achieve a higher MEX.

Given that, perhaps I can think in terms of the numbers that are critical for achieving a certain MEX.

For example, to have MEX k, Alice needs to have all numbers from 0 to k-1 in c.

Bob would try to prevent Alice from having all numbers from 0 to k-1.

So, for a given k, I need to check if Alice can guarantee having all numbers from 0 to k-1 in c, despite Bob's efforts.

This sounds like a minimax problem, where I need to find the maximum k such that Alice can ensure she has all numbers from 0 to k-1 in c.

To approach this, perhaps I can iterate over possible MEX values and check feasibility.

But given the constraints (n up to 2*10^5 per test case, and sum of n over all test cases up to 2*10^5), I need an efficient solution, preferably O(n log n) or better.

Let me consider binary searching on the MEX value.

Suppose I want to check if MEX can be at least k, meaning Alice can have all numbers from 0 to k-1 in c.

To check this, I need to ensure that Alice can collect all numbers from 0 to k-1 into c, despite Bob's removals.

Given that, for each number i from 0 to k-1, I need to have enough instances of i in a so that, even after Bob tries to remove them, Alice can still get at least one into c.

Given that Alice gets ceil(f[i]/2) instances of i into c, and Bob gets floor(f[i]/2).

So, for each i from 0 to k-1, if ceil(f[i]/2) >=1, then Alice can get at least one instance into c.

Hence, for MEX to be at least k, for all i from 0 to k-1, ceil(f[i]/2) >=1.

Which simplifies to f[i] >=2*(1)=2.

Wait, ceil(f[i]/2) >=1 implies f[i]/2 >=1, which implies f[i] >=2.

Wait, ceil(f[i]/2) >=1 as long as f[i] >=1.

Because if f[i]=1, ceil(1/2)=1 >=1.

If f[i]=2, ceil(2/2)=1 >=1.

So, ceil(f[i]/2) >=1 for f[i] >=1.

Hence, for each i from 0 to k-1, if f[i] >=1, then Alice can get at least one into c.

But wait, Bob can choose to remove elements, and perhaps influence which elements Alice can get.

Wait, perhaps this simplistic view isn't accurate.

Let me think differently.

Suppose I consider that for each number i, the total number of times it appears is f[i].

Alice and Bob take turns picking elements from a, with Alice starting.

Alice picks an element and adds it to c, while Bob just removes an element.

So, for each f[i], Alice can get ceil(f[i]/2) instances into c, as she picks first.

Wait, but this might not be entirely accurate, because Bob can choose which elements to remove, potentially prioritizing the ones Alice wants.

But in reality, since Alice picks first, she can choose which elements to add to c, and Bob can only remove elements.

But Bob can choose to remove elements that Alice hasn't added yet.

Wait, more carefully:

- On Alice's turn: she picks an element from a, adds it to c, and removes it from a.

- On Bob's turn: he picks an element from a, removes it from a.

So, in each turn, one element is removed from a, and sometimes added to c (by Alice).

Hence, the total number of elements in a decreases by one each turn.

Alice makes ceil(n/2) moves, and Bob makes floor(n/2) moves.

But in terms of controlling which elements go into c, Alice has some control, but Bob can remove elements that Alice might need.

So, perhaps focusing on frequencies isn't the best approach.

Let me consider another angle.

Suppose I sort the array a in non-decreasing order.

Then, Alice can try to pick the smallest available numbers to maximize the MEX.

But Bob can interfere by removing elements that Alice needs.

Wait, maybe I should think in terms of the game being a selection process where Alice tries to collect numbers in order, and Bob tries to disrupt that.

Let me consider building the array c in a simulated manner.

Start with the sorted array a.

Initialize c as empty.

Turns alternate between Alice and Bob, with Alice starting.

On Alice's turn, she picks an element from a, adds it to c, and removes it from a.

On Bob's turn, he picks an element from a, removes it from a.

The goal is to see what c looks like at the end and find its MEX.

But simulating this for up to 2e5 elements per test case is too slow, as it would be O(n), and with up to 2e4 test cases, it would be O(n*t), which is too much.

Hence, I need a smarter way to compute the MEX without simulating each move.

Let me try to find a pattern or a mathematical formula that can directly give me the MEX based on the frequencies of the numbers.

Given that, perhaps I can look at how many times each number is present and see how many times Alice can get each number into c.

As earlier thought, for each number i, Alice can get ceil(f[i]/2) instances into c.

Then, for the MEX to be k, Alice needs to have at least one of each number from 0 to k-1 in c.

So, if for all i from 0 to k-1, ceil(f[i]/2) >=1, then Alice can achieve MEX >=k.

But as I saw earlier, ceil(f[i]/2) >=1 as long as f[i] >=1.

Wait, but this can't be right, because in the second example:

n=4

a=[0,1,2,3]

f[0]=1, f[1]=1, f[2]=1, f[3]=1

Then, ceil(f[i]/2)=1 for each i.

So, according to this, Alice should be able to achieve MEX >=4, meaning c contains 0,1,2,3, so MEX would be 4.

But in reality, in the example, c=[0,2], MEX=1.

So, clearly, this approach is flawed.

Hence, there must be something wrong with assuming that ceil(f[i]/2)>=1 for each i from 0 to k-1 is sufficient.

Perhaps Bob can strategically remove elements that Alice needs.

For instance, in the second example, Bob removes 1 and 3, so Alice is left with 0 and 2.

Hence, even though f[1]=1 and f[3]=1, Alice couldn't get them into c because Bob removed them.

So, perhaps I need to consider that Bob can remove elements that Alice wants, and Alice can only get ceil(f[i]/2) instances into c for each i.

Wait, but in this case, for f[i]=1, Alice gets ceil(1/2)=1 instance into c.

But in reality, for i=1 and i=3 in the second example, Alice couldn't get them into c because Bob removed them.

So, perhaps the formula ceil(f[i]/2) isn't directly applicable.

Maybe I need to think differently.

Let me consider that for each number i, the number of times Alice can get i into c is ceil((f[i] - floor(f[i]/2)).

Wait, that seems convoluted.

Actually, for each f[i], Alice can get ceil(f[i]/2) instances into c, as she picks first.

Because:

- If f[i] is odd, Alice picks first, so she gets (f[i]+1)/2.

- If f[i] is even, Alice gets f[i]/2.

Hence, Alice gets ceil(f[i]/2).

Similarly, Bob gets floor(f[i]/2).

So, in the second example:

f[0]=1 -> Alice gets 1, Bob gets 0.

f[1]=1 -> Alice gets 1, Bob gets 0.

f[2]=1 -> Alice gets 1, Bob gets 0.

f[3]=1 -> Alice gets 1, Bob gets 0.

But in reality, c=[0,2], meaning Alice only got 0 and 2 into c, not 1 and 3.

So, perhaps I need to consider that Bob can choose to remove elements that Alice hasn't picked yet.

Wait, perhaps I need to consider the sequence of moves.

Let me try to simulate the game for the second example:

a = [0,1,2,3]

Turns:

1. Alice picks 0, adds to c=[0], removes 0 from a -> a=[1,2,3]

2. Bob picks 1, removes it from a -> a=[2,3]

3. Alice picks 2, adds to c=[0,2], removes 2 from a -> a=[3]

4. Bob picks 3, removes it from a -> a=[]

Game ends, c=[0,2], MEX=1.

So, in this case, Alice could only get 0 and 2 into c, not 1 and 3.

Hence, even though Alice is entitled to ceil(f[i]/2)=1 for each i, Bob can prevent her from getting certain i into c by removing them before Alice can pick them.

Wait, but in this scenario, Bob removed 1 and 3, which Alice hadn't picked yet.

So, perhaps Alice can only guarantee to get ceil(f[i]/2) instances into c if Bob doesn't remove them.

But in reality, Bob can choose to remove elements that Alice hasn't picked yet, thereby preventing her from adding them to c.

Hence, perhaps the earlier assumption is incorrect.

Let me think differently.

Suppose I consider that for each number i, the number of times it appears in c is ceil(f[i]/2).

Then, the MEX would be the smallest i such that ceil(f[i]/2)=0.

But ceil(f[i]/2)=0 only when f[i]=0.

Wait, but in the second example, f[1]=1, ceil(1/2)=1, but in reality, c doesn't contain 1.

So, this approach is flawed.

Perhaps I need to consider that Alice can only get ceil(f[i]/2) instances into c, but Bob can choose to remove some instances strategically.

Wait, maybe I need to look at the total number of moves Alice makes and see how she can distribute her picks among the available numbers.

Given that, perhaps I can prioritize the numbers that Alice needs for a higher MEX.

But this seems too vague.

Let me try to think in terms of necessary and sufficient conditions for Alice to achieve a certain MEX.

To have MEX=k, Alice must have all numbers from 0 to k-1 in c.

So, for each i from 0 to k-1, Alice must have at least one i in c.

Given that, and knowing that Alice gets ceil(f[i]/2) instances of i into c, we can say that for each i from 0 to k-1, ceil(f[i]/2) >=1.

But as seen in the second example, this isn't sufficient, because Bob can remove elements that Alice hasn't picked yet.

Wait, but in the second example, for i=1, f[i]=1, ceil(1/2)=1.

However, Bob removed 1 before Alice could pick it.

Hence, even though Alice is entitled to one instance, Bob can prevent her from getting it into c by removing it.

So, perhaps Alice can only guarantee to have i in c if f[i] >=2*ceil(f[i]/2) -1.

Wait, this seems complicated.

Let me think differently.

Suppose I sort the unique numbers in a in ascending order and see how many of the smallest numbers Alice can get into c.

Given that Alice makes ceil(n/2) moves, and Bob makes floor(n/2) moves.

Alice wants to pick the smallest possible numbers to maximize the MEX.

Bob wants to prevent that by removing numbers that Alice wants.

So, perhaps I can model this as Alice trying to collect the smallest possible numbers, and Bob trying to block her.

Given that, perhaps the minimal MEX that Alice can guarantee is the smallest k such that the sum of ceil(f[i]/2) for i from 