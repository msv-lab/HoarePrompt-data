Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a string consisting of "+" and "-" characters, and I need to split this string into parts in a way that minimizes the total penalty. The penalty for each part is the absolute value of its sum multiplied by its length.

First, I need to understand how the array 'a' is defined from the string 's'. It says that if s_i is "+", then a_i is 1, and if s_i is "-", then a_i is -1. So, the array 'a' is just a numerical representation of the string, with pluses being positive one and minuses being negative one.

Now, the task is to split this array 'a' into non-empty subarrays, and for each subarray, calculate its penalty, which is the absolute value of the sum of its elements multiplied by its length. The goal is to find the way to split the array that results in the minimum total penalty.

I need to process multiple test cases, each consisting of an integer n (the length of the string) and the string s itself.

Looking at the example:

- For n=1 and s="+", the array is [1]. The only way to split it is into [1], and the penalty is |1| * 1 = 1.

- For n=5 and s="-----", the array is [-1, -1, -1, -1, -1]. If I split it into individual elements, each has a penalty of |-1| * 1 = 1, so total penalty is 5.

- For n=6 and s="+-+-+-", the array is [1, -1, 1, -1, 1, -1]. If I split it into [1, -1, 1, -1] and [1, -1], the sums are 0 and 0, so penalties are 0 and 0, total penalty is 0.

- For n=10 and s="--+++++++-", the array is [-1, -1, 1, 1, 1, 1, 1, 1, 1, -1]. If I split it optimally, the total penalty is 4.

- For n=20 and s="+---++++-+++++---++-", the array is [1, -1, -1, -1, 1, 1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, 1, -1]. The optimal split gives a total penalty of 4.

From these examples, it seems that grouping pluses and minuses in a way that their sums cancel out can lead to lower penalties, especially when the sum is zero.

Now, looking at the provided program:

- It reads the number of test cases t.

- For each test case, it reads n and s.

- It splits the string s by "-", which gives parts consisting of "+" sequences.

- It calculates the length of these parts and sums them up as result_length.

- Then, it calls func_1 with the expression and result_length, and prints the result.

Looking into func_1:

- It takes the expression (the string s) and length (which seems to be the sum of lengths of parts split by "-").

- It initializes count and balance to 0.

- It iterates through each character in the expression:

- If it's "+", balance increases by 1.

- If it's "-", balance decreases by 1.

- If balance becomes negative, it resets balance to 0 and increments count.

- After the loop, if balance is greater than 0, it adds 1 to count.

- It returns count plus whether balance is greater than 0.

Wait, this seems different from what the problem is asking. The problem is about splitting the array into subarrays and minimizing the sum of penalties, where penalty is the absolute sum of the subarray multiplied by its length.

But in the provided code, it's splitting the string by "-", calculating the sum of lengths of these parts, and then in func_1, it's counting something related to balance, which seems to be counting the number of times the cumulative sum goes negative.

This doesn't align with the problem description. The problem is about splitting the array in a way that minimizes the total penalty, which is defined based on the sum and length of each subarray.

The provided code seems to be trying to count something different, possibly the number of times the cumulative sum goes negative, but it's not clear how this relates to the minimum penalty.

Moreover, in the main loop, it's splitting the string by "-", which gives parts consisting of "+" only, but according to the problem, subarrays can have both "+" and "-" characters.

This approach doesn't seem to be correctly addressing the problem. The problem requires splitting the array into subarrays where the sum of penalties is minimized, and penalty is defined as the absolute sum of the subarray multiplied by its length.

I think a different approach is needed. Maybe dynamic programming can be used here, where we keep track of the minimum penalty up to each position in the array.

Let's consider defining dp[i] as the minimum total penalty for the subarray a[0..i].

Then, for each i, we can consider all possible splits before position i, and choose the one that minimizes the penalty.

Specifically, for each j from 0 to i-1, we can split the array into a[0..j] and a[j+1..i], and calculate the penalty for a[j+1..i], then add it to dp[j].

We need an efficient way to calculate the penalty for any subarray a[l..r].

Given that a[i] is either 1 or -1, the sum of a[l..r] is sum(a[l..r]) = sum of 1's minus sum of -1's, which is simply (number of "+" - number of "-").

The penalty is |sum(a[l..r])| * (r - l + 1).

To compute this efficiently, we might need to precompute prefix sums.

Let's define prefix_sum[i] as the sum of a[0..i-1].

Then, sum(a[l..r]) = prefix_sum[r+1] - prefix_sum[l].

So, penalty(l, r) = |prefix_sum[r+1] - prefix_sum[l]| * (r - l + 1).

We can precompute prefix_sum for the entire array.

Then, dp[i] = min over all j from 0 to i-1 of (dp[j] + penalty(j+1, i)).

This would have a time complexity of O(n^2), which for n=5000 might be too slow, as it would be up to 25,000,000 operations per test case.

Given that t can be up to 1000, this would be too slow.

We need a more efficient way to compute the minimum penalty.

Let me think differently.

Maybe we can find a way to group the pluses and minuses to cancel each other out as much as possible, since the penalty is the absolute sum multiplied by the length.

If we can group sections where the number of pluses and minuses cancel out, the sum would be zero, and thus the penalty for that subarray would be zero.

So, the ideal situation is to have subarrays where the number of pluses equals the number of minuses.

In that case, the sum is zero, and the penalty is zero.

However, in reality, it might not be possible to have all subarrays with equal numbers of pluses and minuses.

So, we should aim to have subarrays where the sum is as close to zero as possible, meaning the difference between the number of pluses and minuses is minimized.

But the penalty is |sum| * length, so even if the sum is small, if the length is large, the penalty could still be high.

Therefore, there's a trade-off between the sum and the length of the subarray.

Perhaps it's better to have smaller subarrays with small sums rather than larger subarrays with larger sums.

Wait, but if we have a large subarray where the sum is zero, the penalty is zero, which is better than having multiple small subarrays with non-zero sums.

So, it's not straightforward.

Let me consider another approach.

Suppose I try to split the array whenever the cumulative sum deviates too much from zero.

I can keep track of the cumulative sum, and try to split the array when the sum becomes too positive or too negative.

But I need a way to quantify "too much".

Alternatively, maybe I can use dynamic programming with some optimization to reduce the time complexity.

Looking back at the provided code, it seems to be trying to count the number of times the cumulative sum goes negative, which might not directly relate to the minimum penalty.

Given that, I think the provided code is incorrect for solving this problem.

Therefore, the answer should be Correctness: **False**

**Final Answer**

\[ \boxed{\text{False}} \]