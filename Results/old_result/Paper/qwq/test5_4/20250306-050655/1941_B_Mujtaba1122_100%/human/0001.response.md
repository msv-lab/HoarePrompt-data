Alright, I've got this problem to solve. Let's see what it's about. So, Rudolf has an array of integers, and he can perform a specific operation on it any number of times. The operation involves choosing an index i (which has to be between 2 and n-1, inclusive), and then decrementing a[i-1], a[i], and a[i+1] by 1, 2, and 1, respectively. The goal is to determine whether it's possible to make all elements of the array zero by applying this operation any number of times.

First, I need to understand the operation clearly. So, for any chosen i (where 2 ≤ i ≤ n-1), the operation does the following:

- a[i-1] = a[i-1] - 1

- a[i] = a[i] - 2

- a[i+1] = a[i+1] - 1

And this can be done any number of times, with any i in the valid range, and the same i can be chosen multiple times if needed.

The question is, can we make all elements of the array zero using these operations?

Let me think about the implications of this operation. Each operation affects three consecutive elements, decrementing them by specific amounts. I need to find a sequence of such operations that will zero out the entire array.

One way to approach this is to model the problem as a system of equations. Since each operation corresponds to subtracting specific values from certain positions, I can think of it as solving a system where the operations are variables, and the equations represent the desired changes to each array element.

However, with n up to 2*10^5 and t up to 10^4, this direct approach would be too slow. There must be a smarter way to check if it's possible to zero out the array.

Let me consider the constraints and properties of the operations.

First, note that the operation can only be performed on indices from 2 to n-1. This means the first and last elements can only be affected indirectly, through operations on their neighboring elements.

Wait, but the operation affects a[i-1], a[i], and a[i+1]. So, for example, if I operate on i=2, it affects positions 1, 2, and 3. Similarly, operating on i=3 affects positions 2, 3, and 4, and so on.

I need to see if I can combine these operations in such a way that all elements are reduced to zero.

Let me try to find a pattern or a way to sequentially apply operations to achieve this.

Perhaps I can process the array from left to right, deciding how many operations to perform at each position to zero out the previous elements.

Wait, maybe I can use differences between consecutive elements.

Let me consider the differences between consecutive elements.

Define d[i] = a[i] - a[i-1] for i from 1 to n, assuming a[0] = 0.

Wait, but a[0] is not defined. Maybe I need to adjust this.

Alternatively, think about how the operations affect the differences.

Each operation on i increments d[i] by 1 and decrements d[i+1] by 1.

Wait, perhaps I should think in terms of prefix sums.

Let me try to model this.

Suppose I have an array a of length n.

I can define a new array s where s[i] is the sum of operations performed on indices up to i.

Wait, maybe not. Let's think differently.

Let me consider that each operation on index i corresponds to subtracting [1, 2, 1] from positions i-1, i, and i+1.

I need to find a set of operations such that the total subtraction equals the original array.

This sounds like solving a system of linear equations, but it's too slow for large n.

Is there a way to simplify this?

Let me consider the first and last elements.

Since operations can only be performed on indices from 2 to n-1, the first and last elements can only be affected by operations on index 2 and n-1, respectively.

Wait, operation on i=2 affects a[1], a[2], a[3].

Operation on i=3 affects a[2], a[3], a[4], and so on.

So, a[1] can only be affected by operations on i=2.

Similarly, a[n] can only be affected by operations on i=n-1.

So, perhaps I can express the operations needed for each position in terms of the previous positions.

Let me try to process the array from left to right.

Start with a[1].

Since only operations on i=2 can affect a[1], and each such operation decreases a[1] by 1.

So, to make a[1] zero, I need to perform exactly a[1] operations on i=2.

Wait, but I can perform operations on i=2 any number of times, as long as a[2] and a[3] allow it.

But a[2] is also affected by operations on i=2 and i=3.

This seems complicated.

Maybe I should consider the differences between consecutive elements.

Let me define d[i] = a[i] - a[i-1] for i from 1 to n, assuming a[0] = 0.

Then, the operation on i decrements d[i] by 1 and d[i+1] by 1, since:

- a[i] -= 2 => d[i] = a[i] - a[i-1] decreases by 2

- a[i+1] -=1 => d[i+1] = a[i+1] - a[i] decreases by (-1) - (-2) = +1

Wait, perhaps I need to redefine d[i].

Let me think again.

Define d[i] = a[i] - a[i-1] for i from 1 to n.

Then, an operation on i will:

- a[i-1] -=1 => d[i] +=1 (since d[i] = a[i] - a[i-1], and a[i-1] decreases)

- a[i] -=2 => d[i+1] +=2 (since d[i+1] = a[i+1] - a[i], and a[i] decreases)

- a[i+1] -=1 => d[i+1] -=1

Wait, no.

Let me recast.

Original d[i] = a[i] - a[i-1].

After operation on i:

a[i-1] -=1 => d[i] = a[i] - (a[i-1] -1) = (a[i] - a[i-1]) +1 => d[i] +=1

a[i] -=2 => d[i+1] = a[i+1] - (a[i] -2) = (a[i+1] - a[i]) +2 => d[i+1] +=2

a[i+1] -=1 => d[i+1] = (a[i+1] -1) - a[i] = (a[i+1] - a[i]) -1 => d[i+1] -=1

So, overall, operation on i:

- d[i] +=1

- d[i+1] +=1 (because +2 -1 = +1)

So, each operation on i affects d[i] and d[i+1] by +1.

Wait, but in the operation, we are subtracting from a[i-1], a[i], and a[i+1], so the changes should be negative.

Wait, perhaps I messed up the signs.

Let me redo this.

Original d[i] = a[i] - a[i-1].

After operation on i:

a[i-1] -=1 => d[i] = a[i] - (a[i-1] -1) = (a[i] - a[i-1]) +1 => d[i] +=1

a[i] -=2 => d[i+1] = a[i+1] - (a[i] -2) = (a[i+1] - a[i]) +2 => d[i+1] +=2

a[i+1] -=1 => d[i+1] = (a[i+1] -1) - a[i] = (a[i+1] - a[i]) -1 => d[i+1] += (-1)

So, net effect on d[i+1]: +2 -1 = +1.

So, operation on i:

- d[i] +=1

- d[i+1] +=1

Our goal is to make all a[j] = 0, which implies that d[i] should be adjusted accordingly.

But I'm not sure this is leading me anywhere.

Let me try to think differently.

Perhaps I can model this as a system where each operation subtracts a specific vector from the array.

Each operation on i subtracts [0, ..., 0, 1, 2, 1, 0, ..., 0] from the array, where the 1,2,1 are at positions i-1, i, i+1.

Then, the problem reduces to checking if the vector a can be expressed as a linear combination of these operation vectors.

But with large n, this is not practical.

I need a better approach.

Let me consider the sum of the array elements.

Each operation reduces the sum of the array by 1+2+1=4.

So, if the total sum is not divisible by 4, it's impossible to zero out the array.

Wait, but that's not sufficient, as the operations are constrained in where they can be applied.

Moreover, in the sample input, the sums are:

First test case: 1+3+5+5+2=16, which is divisible by 4, and it's YES.

Second test case: 2+4+4+5+1=16, also divisible by 4, but it's NO.

So, sum divisible by 4 is necessary but not sufficient.

I need more conditions.

Let me consider the prefix sums.

Define s[i] = a[1] + a[2] + ... + a[i]

Each operation on i will subtract 1 from s[i], 2 from s[i+1], and 1 from s[i+2].

Wait, no.

Wait, operation on i subtracts 1 from a[i-1], 2 from a[i], and 1 from a[i+1].

So, for prefix sums s[i] = a[1] + a[2] + ... + a[i]

Then, operation on i will:

- s[j] for j < i-1: no change

- s[i-1]: subtracts 1

- s[i]: subtracts 1 + 2 = 3

- s[i+1]: subtracts 1 + 2 + 1 = 4

- s[j] for j > i+1: subtracts 4

Wait, no.

Wait, s[j] is the sum up to j.

So, after operation on i:

- For j < i-1: s[j] remains the same, since a[k] for k <= j < i-1 are unchanged.

- For j = i-1: s[j] -=1, since a[i-1] -=1

- For j = i: s[j] -=1 (from a[i-1]) + -=2 (from a[i]) = total -=3

- For j = i+1: s[j] -=1 (from a[i-1]) + -=2 (from a[i]) + -=1 (from a[i+1]) = total -=4

- For j > i+1: s[j] -=4, since all a[k] for k <= i+1 are decreased by a total of 4.

Wait, no. Each operation subtracts 1 from a[i-1], 2 from a[i], and 1 from a[i+1]. So, for s[j]:

- If j < i-1: s[j] unchanged

- If j == i-1: s[j] -=1

- If j == i: s[j] -=1 (from a[i-1]) + -=2 (from a[i]) = -=3

- If j == i+1: s[j] -=1 (from a[i-1]) + -=2 (from a[i]) + -=1 (from a[i+1]) = -=4

- If j > i+1: s[j] -=4

So, the prefix sums are affected in this way.

But I'm not sure if this helps me directly.

Let me think about the conditions that must hold for the array to be zeroable.

First, consider the first element: a[1].

Only operations on i=2 can affect a[1], by subtracting 1 from it each time.

So, to make a[1]=0, I need to perform exactly a[1] operations on i=2.

But, performing operations on i=2 affects a[1], a[2], and a[3].

Specifically, each operation on i=2 subtracts 1 from a[1], 2 from a[2], and 1 from a[3].

So, performing a[1] operations on i=2 will subtract a[1] from a[1], 2*a[1] from a[2], and a[1] from a[3].

After these operations, a[1] becomes 0, a[2] becomes a[2] - 2*a[1], and a[3] becomes a[3] - a[1].

Now, I need to make a[2]=0, a[3]=0, and so on.

Next, consider a[2].

After the operations on i=2, a[2] is now a[2] - 2*a[1].

To make a[2]=0, I need to perform operations on i=3.

Each operation on i=3 subtracts 1 from a[2], 2 from a[3], and 1 from a[4].

So, to make a[2]=0, I need to perform (a[2] - 2*a[1]) / 1 operations on i=3.

But, operations on i=3 affect a[2], a[3], and a[4].

So, if I perform k operations on i=3, where k = a[2] - 2*a[1], then a[2] becomes 0, a[3] becomes a[3] - a[1] - 2*k = a[3] - a[1] - 2*(a[2] - 2*a[1]) = a[3] - a[1] - 2*a[2] + 4*a[1] = a[3] + 3*a[1] - 2*a[2]

This seems messy.

Maybe there's a better way to approach this.

Let me consider the differences between consecutive elements again.

Define d[i] = a[i] - a[i-1] for i from 1 to n, with a[0] = 0.

Then, the operation on i increases d[i] by 1 and increases d[i+1] by 1.

Our goal is to make all d[i] = 0.

Wait, no. Our goal is to make all a[i] = 0.

But maybe I can think in terms of differences.

Wait, if I can adjust the differences d[i] to make a[i] = 0 for all i, that might work.

But I'm getting stuck here.

Let me try to look for an invariant or some property that must hold for the array to be zeroable.

One thing I notice is that the operations can be performed any number of times, and the operations are commutative; the order doesn't matter.

So, perhaps I can model this as a system of linear equations.

Let me define x[i] as the number of times operation is performed on index i, for i from 2 to n-1.

Then, each x[i] must be an integer greater than or equal to zero.

Now, the effect of x[i] is:

- a[i-1] -= x[i]

- a[i] -= 2*x[i]

- a[i+1] -= x[i]

So, to make a[j] = 0 for all j, I need:

For j = 1: a[1] - x[2] = 0 => x[2] = a[1]

For j = 2: a[2] - 2*x[2] - x[3] = 0

For j = 3: a[3] - x[2] - 2*x[3] - x[4] = 0

...

For j = n-1: a[n-1] - x[n-2] - 2*x[n-1] - x[n] = 0

Wait, no, since operations are only on i from 2 to n-1, and a[n] is only affected by operations on i=n-1.

Wait, let's write the equations properly.

For j = 1: a[1] - x[2] = 0 => x[2] = a[1]

For j = 2: a[2] - 2*x[2] - x[3] = 0 => x[3] = a[2] - 2*x[2]

But x[2] is already a[1], so x[3] = a[2] - 2*a[1]

For j = 3: a[3] - x[2] - 2*x[3] - x[4] = 0 => x[4] = a[3] - x[2] - 2*x[3]

And so on, up to j = n-1.

Then, for j = n: a[n] - x[n-1] = 0 => x[n-1] = a[n]

But from earlier equations, x[n-1] is also expressed in terms of a[n-1], x[n-2], etc.

This seems like a system of equations that I can solve sequentially.

Let me try to write this in code.

I can start from x[2] = a[1]

Then x[3] = a[2] - 2*x[2] = a[2] - 2*a[1]

Then x[4] = a[3] - x[2] - 2*x[3]

And so on, until x[n-1], which should also equal a[n]

I need to check if these equations are consistent, meaning that all x[i] are non-negative integers.

This seems promising.

Let me try this with the first sample input.

Sample Input 1:

5

1 3 5 5 2

So, n=5, a=[1,3,5,5,2]

Then:

x[2] = a[1] = 1

x[3] = a[2] - 2*x[2] = 3 - 2*1 = 1

x[4] = a[3] - x[2] - 2*x[3] = 5 - 1 - 2*1 = 2

Then, check x[n-1] = x[4] = 2, and a[n] = 2, which matches.

So, x[2]=1, x[3]=1, x[4]=2

Now, I need to verify that applying these operations makes all a[j]=0.

Apply operation on i=2 once:

a[1] = 1 -1 =0

a[2] = 3 -2 =1

a[3] =5 -1 =4

Apply operation on i=3 once:

a[2] =1 -2 =-1

a[3] =4 -2 =2

a[4] =5 -1 =4

Apply operation on i=4 twice:

a[3] =2 -2*1 =0

a[4] =4 -2*1 =2

a[5] =2 -1*2 =0

Wait, a[2] is -1, which is negative, but in the problem, a[j] are non-negative integers, and operations can only be performed if a[j] are sufficient.

So, perhaps this approach needs adjustment.

Wait, maybe I need to ensure that all x[i] are non-negative.

In this case, x[2]=1, x[3]=1, x[4]=2, and a[2] after operations becomes negative, which is invalid.

Wait, but in the sample input, it's possible to make all zeros, as per the description.

Wait, perhaps I need to adjust the order of operations or the number of operations.

Wait, maybe I need to ensure that at each step, the x[i] operations are possible without making any a[j] negative.

This seems complicated.

Let me think differently.

Perhaps I can use the fact that the operations correspond to certain linear combinations, and check if the array is a linear combination of the operation vectors.

But with large n, this is not practical.

Wait, perhaps there's a simpler condition.

Let me consider the sum of the array elements.

Each operation reduces the sum by 4.

So, the total sum must be divisible by 4.

But in the second sample input, the sum is also 16, which is divisible by 4, but the output is NO.

So, sum divisible by 4 is necessary but not sufficient.

I need more conditions.

Let me consider the first and last elements.

In the first sample, a[1]=1, a[n]=2

In the second sample, a[1]=2, a[n]=1

In the third sample, a[1]=0, a[n]=1

In the fourth sample, a[1]=5, a[n]=0

Wait, in the first sample, x[2]=1, x[3]=1, x[4]=2, and a[2] after operations becomes negative, which is invalid.

Wait, perhaps I need to ensure that a[2] - 2*x[2] - x[3]