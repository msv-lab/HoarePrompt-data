Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an integer n and three strings a, b, and c, each of length n. I need to determine if there exists a template t such that strings a and b match this template, but c does not.

First, I need to understand what it means for a string to match the template. The template can have both lowercase and uppercase letters. If the template has a lowercase letter at position i, then the string must have exactly that letter at that position. If the template has an uppercase letter at position i, then the string must have a different lowercase letter at that position.

So, for example, if t has 'a' at position i, then s must have 'a' at position i. If t has 'A' at position i, then s must have any letter except 'a' at position i.

My task is to find such a template t that makes a and b match, but c does not match.

Let me think about how to approach this.

I need to consider each position from 1 to n and decide whether to make that position in the template lowercase or uppercase.

If I choose a position to be lowercase in the template, then both a and b must have the same letter at that position, and c must have a different letter.

If I choose a position to be uppercase in the template, then a and b must have letters that are different from the specified uppercase letter's lowercase counterpart, and c must either match that uppercase letter's lowercase version or not, depending on the template.

Wait, no. Let's clarify.

If the template has an uppercase letter at position i, say 'A', then a and b must have any letter except 'a' at that position, and c could have 'a' or something else, but since the template specifies 'A', c must have something different from 'a' if it's to match, or 'a' if it's to not match.

Hold on, this is getting confusing. Maybe I should look at it differently.

I need to find a template t such that:

- For each position i, if t[i] is lowercase, then a[i] == t[i] and b[i] == t[i], and c[i] != t[i] for c to not match.

- If t[i] is uppercase, then a[i] != t[i].lower() and b[i] != t[i].lower(), and c[i] == t[i].lower() for c to not match.

Wait, no. Let's read the problem again carefully.

"The string s matches the template t if the following conditions hold for all i from 1 to n:

- if the i-th letter of the template is lowercase, then s_i must be the same as t_i;

- if the i-th letter of the template is uppercase, then s_i must be different from the lowercase version of t_i."

"And accordingly, the string doesn't match the template if the condition doesn't hold for at least one i."

So, for c to not match the template, there should be at least one position where:

- If t[i] is lowercase, then c[i] != t[i];

- If t[i] is uppercase, then c[i] == t[i].lower().

And for a and b to match the template, they must satisfy the conditions for all positions.

So, I need to choose t such that:

- For each position i:

- If t[i] is lowercase, then a[i] == t[i] and b[i] == t[i], and c[i] != t[i].

- If t[i] is uppercase, then a[i] != t[i].lower() and b[i] != t[i].lower(), and c[i] == t[i].lower().

Wait, no. Let's separate the conditions.

For a and b to match the template:

- For each position i:

- If t[i] is lowercase, then a[i] == t[i] and b[i] == t[i].

- If t[i] is uppercase, then a[i] != t[i].lower() and b[i] != t[i].lower().

For c to not match the template:

- There exists at least one position i where:

- If t[i] is lowercase, then c[i] != t[i].

- If t[i] is uppercase, then c[i] == t[i].lower().

So, I need to choose t such that:

1. For all positions i:

- If t[i] is lowercase, then a[i] == t[i] and b[i] == t[i].

- If t[i] is uppercase, then a[i] != t[i].lower() and b[i] != t[i].lower().

2. There exists at least one position j where:

- If t[j] is lowercase, then c[j] != t[j].

- If t[j] is uppercase, then c[j] == t[j].lower().

I need to find if such a template t exists.

Let me think about this step by step.

First, I need to ensure that a and b both match the template. That means, for each position i:

- If t[i] is lowercase, then a[i] and b[i] must both be equal to t[i].

- If t[i] is uppercase, then a[i] and b[i] must both be different from t[i].lower().

Additionally, for c to not match the template, there must be at least one position j where:

- If t[j] is lowercase, then c[j] != t[j].

- If t[j] is uppercase, then c[j] == t[j].lower().

So, I need to choose t in such a way that a and b satisfy the template, and c does not satisfy it.

Let me consider each position independently.

For each position i, I have two choices for t[i]:

1. Make t[i] lowercase, meaning t[i] = a[i] = b[i], and c[i] != a[i].

2. Make t[i] uppercase, meaning t[i].lower() != a[i] and t[i].lower() != b[i], and c[i] == t[i].lower().

Wait, no. If t[i] is uppercase, then t[i].lower() should be different from a[i] and b[i], but a[i] and b[i] must be different from t[i].lower().

Wait, no. If t[i] is uppercase, say 'A', then a[i] != 'a' and b[i] != 'a'. And for c to not match, c[i] == 'a'.

So, in this case, t[i].lower() is 'a', and c[i] == 'a'.

But I need to make sure that a[i] != 'a' and b[i] != 'a', and c[i] == 'a'.

So, for uppercase t[i], t[i].lower() is some letter, say 'a', and a[i] != 'a', b[i] != 'a', and c[i] == 'a'.

Wait, but t[i] is uppercase, so t[i].lower() is the lowercase version of t[i].

So, if t[i] is 'A', t[i].lower() is 'a'.

So, for uppercase t[i]:

- a[i] != 'a'

- b[i] != 'a'

- c[i] == 'a'

Similarly, for lowercase t[i]:

- t[i] = a[i] = b[i]

- c[i] != a[i]

So, for each position i, I have two options:

Option 1: t[i] is lowercase.

- a[i] == b[i]

- t[i] = a[i]

- c[i] != a[i]

Option 2: t[i] is uppercase.

- a[i] != c[i]

- b[i] != c[i]

Wait, no. Let's see.

If t[i] is uppercase:

- a[i] != t[i].lower()

- b[i] != t[i].lower()

- c[i] == t[i].lower()

So, t[i].lower() must be such that:

- a[i] != t[i].lower()

- b[i] != t[i].lower()

- c[i] == t[i].lower()

So, t[i].lower() must be equal to c[i], and a[i] != c[i] and b[i] != c[i].

So, for uppercase t[i]:

- t[i].lower() == c[i]

- a[i] != c[i]

- b[i] != c[i]

So, summarizing:

For each position i:

- If I choose t[i] to be lowercase:

- a[i] == b[i]

- t[i] = a[i]

- c[i] != a[i]

- If I choose t[i] to be uppercase:

- a[i] != c[i]

- b[i] != c[i]

- t[i].lower() == c[i]

So, in this case, t[i] can be any uppercase version of c[i].

Wait, but t[i] must be uppercase, so t[i] is c[i].upper(), since t[i].lower() == c[i].

So, for uppercase t[i]:

- t[i] is c[i].upper()

- a[i] != c[i]

- b[i] != c[i]

So, for each position i, I have to choose between making t[i] lowercase or uppercase, based on the above conditions.

Now, to have a valid template t, for all positions i, one of the above options must hold.

Moreover, for c to not match the template, there must be at least one position j where:

- If t[j] is lowercase, then c[j] != t[j]

- If t[j] is uppercase, then c[j] == t[j].lower()

But since we're constructing t such that for each position, one of the above holds, and for c to not match, there must be at least one position where the condition for c is not met.

Wait, I'm getting tangled here.

Let me think differently.

I need to check if there exists a template t such that:

- For all i, a matches t and b matches t.

- There exists at least one i where c does not match t.

Given the definitions of matching.

So, first, a and b must both match t.

That means:

- For each i:

- If t[i] is lowercase, then a[i] == t[i] and b[i] == t[i]

- If t[i] is uppercase, then a[i] != t[i].lower() and b[i] != t[i].lower()

And, for c to not match t, there exists at least one i where:

- If t[i] is lowercase, then c[i] != t[i]

- If t[i] is uppercase, then c[i] == t[i].lower()

So, I need to choose t such that a and b both match t, and c does not match t.

Let me consider each position independently.

For each position i, I can choose t[i] to be either lowercase or uppercase, based on the conditions above.

Let me consider two cases for each position:

Case 1: t[i] is lowercase.

- Then, a[i] == t[i], b[i] == t[i], and c[i] != t[i]

So, for this case to be possible:

- a[i] == b[i], and c[i] != a[i]

If a[i] != b[i], then this case is invalid.

Case 2: t[i] is uppercase.

- Then, a[i] != t[i].lower(), b[i] != t[i].lower(), and c[i] == t[i].lower()

So, t[i].lower() must be c[i], and a[i] != c[i], b[i] != c[i]

Therefore, for this case to be possible:

- a[i] != c[i], and b[i] != c[i]

So, for each position i, I can choose t[i] to be:

- Lowercase a[i], if a[i] == b[i] and c[i] != a[i]

- Uppercase c[i].upper(), if a[i] != c[i] and b[i] != c[i]

Now, I need to make sure that for all positions, one of these two choices is possible, and that there is at least one position where c does not match t.

Wait, more precisely, since c must not match t, there must be at least one position where c does not satisfy the matching condition for t.

Given that a and b match t, and c does not, I need to ensure that c differs from t in at least one position where t is lowercase, or equals t[i].lower() where t[i] is uppercase.

But, in the choices above, if I choose t[i] to be lowercase a[i], then c[i] != a[i], which satisfies the mismatch for c.

If I choose t[i] to be uppercase c[i].upper(), then c[i] == t[i].lower(), which, if t[i] is uppercase, would make c not match t.

Wait, but in this case, for c to not match t, there must be at least one position where:

- If t[i] is lowercase, c[i] != t[i]

- Or if t[i] is uppercase, c[i] == t[i].lower()

So, in the second case, when t[i] is uppercase and c[i] == t[i].lower(), c does not match t.

So, in both cases, c does not match t.

Wait, no. If I choose t[i] to be lowercase a[i], then c[i] != a[i], so c does not match t at that position.

If I choose t[i] to be uppercase c[i].upper(), then c[i] == t[i].lower(), so c does not match t at that position.

So, in either choice, c does not match t at that position.

But, I need c to not match t overall, which means that there is at least one position where c does not match t.

So, if I make t such that for all positions, c does not match t at those positions, that's fine, as long as there is at least one position where c does not match t.

Wait, no. Actually, for c to not match t, it's sufficient that there exists at least one position where c does not match t.

So, if I can make t such that for all positions, c does not match t, that's still c not matching t.

But, in practice, I just need to ensure that there is at least one position where c does not match t, given that a and b match t.

Wait, but in the choices above, if I choose t[i] to be lowercase a[i], then c[i] != a[i], so c does not match t at that position.

If I choose t[i] to be uppercase c[i].upper(), then c[i] == t[i].lower(), which means c does not match t at that position.

So, in both cases, c does not match t at that position.

Therefore, as long as for each position, one of the two choices is possible (i.e., the conditions for that choice are met), and I choose the template accordingly, then c will not match t.

But, I need to ensure that a and b match t for all positions.

So, for the template t to be valid:

- For each position i:

- If t[i] is lowercase, then a[i] == t[i] and b[i] == t[i], and c[i] != t[i]

- If t[i] is uppercase, then a[i] != t[i].lower() and b[i] != t[i].lower(), and c[i] == t[i].lower()

Moreover, there must be at least one position where c does not match t.

Now, to make this easier, I can think of it as follows:

For each position i:

- If a[i] == b[i]:

- Option 1: Set t[i] to a[i] (lowercase), provided c[i] != a[i]

- Option 2: Set t[i] to any uppercase letter whose lowercase is not a[i], but this would not satisfy the condition for c, because c[i] would have to be equal to t[i].lower(), which is not a[i], but c[i] could be anything.

Wait, no. If a[i] == b[i], and c[i] != a[i], then I can set t[i] to a[i] (lowercase), and c[i] != a[i], so c does not match t at this position.

Alternatively, if a[i] == b[i], but c[i] == a[i], then I cannot set t[i] to a[i] (lowercase), because c[i] == a[i], which would make c match t at this position.

In that case, I need to set t[i] to uppercase, with t[i].lower() != a[i], and c[i] == t[i].lower().

But c[i] == a[i], and a[i] == b[i], so I need t[i].lower() == c[i] == a[i], but t[i].lower() != a[i], which is a contradiction.

Therefore, in this case, there is no valid choice for t[i], and hence no valid template t exists.

Similarly, if a[i] != b[i], then I cannot set t[i] to be lowercase, because that would require a[i] == b[i] == t[i], which is not possible since a[i] != b[i].

So, in that case, I must set t[i] to be uppercase, with t[i].lower() != a[i] and t[i].lower() != b[i], and c[i] == t[i].lower().

Wait, no. If a[i] != b[i], and I set t[i] to be uppercase, then t[i].lower() must be different from both a[i] and b[i], and c[i] == t[i].lower().

So, t[i].lower() must be equal to c[i], and c[i] != a[i] and c[i] != b[i].

Therefore, for a[i] != b[i], to have a valid t[i], it must be that c[i] != a[i] and c[i] != b[i].

Otherwise, no valid t[i] exists for that position.

Wait, to summarize:

- If a[i] == b[i]:

- If c[i] != a[i], then I can set t[i] to a[i] (lowercase)

- If c[i] == a[i], then I must set t[i] to uppercase with t[i].lower() != a[i], but this requires c[i] == t[i].lower(), which is c[i] == something != a[i], but c[i] == a[i], so contradiction. Hence, no valid t[i].

- If a[i] != b[i]:

- I must set t[i] to uppercase with t[i].lower() != a[i] and t[i].lower() != b[i], and c[i] == t[i].lower().

- Therefore, c[i] must be != a[i] and != b[i], for t[i].lower() == c[i].

So, in this case, c[i] must be different from both a[i] and b[i].

Otherwise, no valid t[i].

Therefore, for the template t to exist, for all positions i:

- If a[i] == b[i], then c[i] != a[i]

- If a[i] != b[i], then c[i] != a[i] and c[i] != b[i]

Moreover, there must be at least one position where c does not match t, but given the above conditions, c will not match t in at least one position.

Wait, but actually, if all positions satisfy the above conditions, then c will not match t in all positions, which satisfies the condition that c does not match t.

But, perhaps it's sufficient to check that for all positions:

- If a[i] == b[i], then c[i] != a[i]

- If a[i] != b[i], then c[i] != a[i] and c[i] != b[i]

And if this holds, then there exists a template t where a and b match t, and c does not.

Otherwise, if there exists at least one position where:

- If a[i] == b[i], but c[i] == a[i], or

- If a[i] != b[i], but c[i] == a[i] or c[i] == b[i]

Then no such template exists.

Wait, but in the first case, if a[i] == b[i] and c[i] == a[i], then no valid t[i] exists.

In the second case, if a[i] != b[i], and c[i] == a[i] or c[i] == b[i], then no valid t[i] exists.

Therefore, to have a valid t, for all positions i:

- If a[i] == b[i], then c[i] != a[i]

- If a[i] != b[i], then c[i] != a[i] and c[i] != b[i]

If this condition holds, then I can construct t accordingly.

Moreover, in this case, c will not match t in at least one position, specifically where a[i] == b[i] and c[i] != a[i], or where a[i] != b[i] and c[i] != a[i] and c[i] != b[i].

Therefore, the condition is sufficient to ensure that c does not match t.

Hence, to solve the problem, for each test case, I need to check for all positions i:

- If a[i] == b[i], then c[i] != a[i]

- If a[i] != b[i], then c[i] != a[i] and c[i] != b[i]

If this holds for all positions, then output "YES", else "NO".

Wait, but in the example given:

Test case 1:

n = 1

a = "a"

b = "b"

c = "c"

Here, a[1] != b[1], so we need c[1] != a[1] and c[1] != b[1], which is "c" != "a" and "c" != "b", which is true, so "YES"

Test case 2:

n = 2

a = "aa"

b = "bb"

c = "aa"

So, for position 1: a[1] = "a", b[1] = "b", c[1] = "a"

a[1] != b[1], so need c[1] != a[1] and c[1] != b[1], but c[1] = "a" == a[1], so "NO"

Test case 3:

n = 10

a = "mathforces"

b = "luckforces"

c = "adhoccoder"

Comparing position by position:

Position 1: a[1] = "m", b[1] = "l", c[1] = "a"

a[1] != b[1], need c[1] != "m" and c[1] != "l", which is "a" != "m" and "a" != "l", true.

Position 2: a[2] = "a", b[2] = "u", c[2] = "d"

a[2] != b[2], need c[2] != "a" and c[2] != "u", which is "d" != "a" and "d" != "u", true.

...

Continuing this way, if all positions satisfy the condition, then "YES", else "NO"

Test case 4:

n = 3

a = "acc"

b = "abd"

c = "abc