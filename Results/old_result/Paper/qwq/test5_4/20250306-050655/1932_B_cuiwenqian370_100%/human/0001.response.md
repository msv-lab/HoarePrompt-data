Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n signs of the apocalypse, and each sign occurs every a_i years. The signs happen sequentially, meaning that after the first sign occurs, we start waiting for the second sign in the next year after the first one, and so on.

Okay, so I need to find out in which year all n signs will have occurred, following this sequential rule.

First, I need to understand the input and output formats. The input consists of multiple test cases, each starting with an integer n, which is the number of signs, followed by n integers representing the periodicity of each sign.

The output should be a single integer for each test case, indicating the year in which the nth sign occurs.

Looking at the example, for the first test case:

n = 6

a = [3, 2, 4, 5, 9, 18]

And the output is 36.

From the note, it explains the sequence:

- First sign in year 3

- Wait for the second sign starting from year 4, and since the second sign occurs every 2 years, the next occurrence after year 3 is year 4.

- Wait for the third sign starting from year 5, and since it occurs every 4 years, the next occurrence is year 4*1=4, but since we're starting from year 5, it's year 8.

- Wait for the fourth sign starting from year 9, occurs every 5 years, so next is year 10.

- Wait for the fifth sign starting from year 11, occurs every 9 years, next is year 18.

- Wait for the sixth sign starting from year 19, occurs every 18 years, next is year 18*2=36.

So, the sixth sign occurs in year 36.

Another test case:

n = 5

a = [1, 2, 3, 4, 5]

Output: 5

Let's see:

- First sign in year 1

- Wait for second sign starting from year 2, occurs every 2 years, next is year 2.

- Wait for third sign starting from year 3, occurs every 3 years, next is year 3.

- Wait for fourth sign starting from year 4, occurs every 4 years, next is year 4.

- Wait for fifth sign starting from year 5, occurs every 5 years, next is year 5.

So, the fifth sign occurs in year 5.

Another test case:

n = 5

a = [1, 1, 1, 1, 1]

Output: 5

Similar to above, each sign occurs every year, so the fifth sign occurs in year 5.

Last test case:

n = 6

a = [50, 30, 711, 200, 503, 1006]

Output: 2012

I need to verify this.

- First sign in year 50

- Wait for second sign starting from year 51, occurs every 30 years, so next is year 60.

- Wait for third sign starting from year 61, occurs every 711 years, next is year 711.

- Wait for fourth sign starting from year 712, occurs every 200 years, next is year 800.

- Wait for fifth sign starting from year 801, occurs every 503 years, next is year 1304.

- Wait for sixth sign starting from year 1305, occurs every 1006 years, next is year 2012.

Yes, that matches the output.

So, the logic seems to be:

- Start with the first sign occurring in year a[0].

- For each subsequent sign, find the smallest year that is greater than the year the previous sign occurred and is a multiple of a[i].

- Continue this process until the nth sign.

Looking at the code provided:

if __name__ == '__main__':

func_1()

def func_1():

import sys

input = sys.stdin.read

data = input().split()

index = 0

T = int(data[index])

index += 1

results = []

for _ in range(T):

n = int(data[index])

index += 1

a = list(map(int, data[index:index + n]))

index += n

last_year = a[0]

for i in range(1, n):

next_year = (last_year + 1 + a[i] - 1) // a[i] * a[i]

last_year = next_year

results.append(str(last_year))

sys.stdout.write('\n'.join(results) + '\n')

So, it reads all input at once, splits it into tokens, and processes each test case.

For each test case:

- Read n

- Read the next n integers as a list a

- Initialize last_year to a[0]

- For each sign from the second to the nth:

- Calculate next_year as the smallest multiple of a[i] greater than last_year

- Update last_year to next_year

- Append the last_year to results

- Finally, print all results separated by newline.

The formula used to calculate next_year is:

next_year = (last_year + 1 + a[i] - 1) // a[i] * a[i]

This is essentially calculating the ceiling of (last_year + 1) divided by a[i], then multiplying by a[i]. This gives the smallest multiple of a[i] that is greater than last_year.

Let's verify this with the first test case:

a = [3,2,4,5,9,18]

Initialize last_year = 3

For i=1:

next_year = (3 + 1 + 2 - 1) // 2 * 2 = (4 + 1 - 1) // 2 * 2 = 4 // 2 * 2 = 2 * 2 = 4

last_year = 4

For i=2:

next_year = (4 + 1 + 4 - 1) // 4 * 4 = (5 + 4 - 1) // 4 * 4 = 8 // 4 * 4 = 2 * 4 = 8

last_year = 8

For i=3:

next_year = (8 + 1 + 5 - 1) // 5 * 5 = (9 + 5 - 1) // 5 * 5 = 13 // 5 * 5 = 3 * 5 = 15

Wait, but according to the note, it should be 10. Hmm.

Wait, in the note, it says:

- Wait for the fourth sign in the 10 -th year (since year 5 have already passed)

But according to the code, it's calculating next_year as 15, which doesn't match.

Wait, maybe I misread the note. Let's check the note again.

In the first set of input data of the example:

- The tribe will wait for the first sign in the 3 -rd year;

- the tribe will wait for the second sign in the 4 -th year (since year 2 have already passed);

- the tribe will wait for the third sign in the 8 -th year (since the second sign has already occurred in the 4 -th year);

- the tribe will wait for the fourth sign in the 10 -th year (since year 5 have already passed);

- the tribe will wait for the fifth sign in the 18 -th year (since year 9 have already passed);

- the tribe will wait for the sixth sign in the 36 -th year (since the fifth sign has already occurred in the 18 -th year).

Wait, so after the third sign in year 8, they wait for the fourth sign starting from year 9, and the fourth sign occurs every 5 years. So, the next occurrence after year 8 is year 10 (since 5*2=10), which is greater than 8.

Similarly, after the fourth sign in year 10, they wait for the fifth sign starting from year 11, which occurs every 9 years, so next is year 18.

After the fifth sign in year 18, they wait for the sixth sign starting from year 19, which occurs every 18 years, so next is year 18*2=36.

So, in the code, for i=3, a[3]=5, last_year=8

next_year = (8 + 1 + 5 - 1) // 5 * 5 = (9 + 5 - 1) // 5 * 5 = 13 // 5 * 5 = 3 * 5 = 15

But according to the note, it should be 10.

Wait, there's a discrepancy here.

Alternatively, maybe the formula should be:

next_year = ((last_year + 1) + a[i] - 1) // a[i] * a[i]

Let's compute that:

next_year = ((8 + 1) + 5 - 1) // 5 * 5 = (9 + 5 - 1) // 5 * 5 = 13 // 5 * 5 = 3 * 5 = 15

But in the note, it's 10.

Wait, maybe the formula in the code is incorrect.

Alternatively, maybe the formula should be:

next_year = ((last_year + 1) + a[i] - 1) // a[i] * a[i]

Which is what the code is doing, and in this case, it's 15, but according to the note, it's 10.

So, there's an inconsistency here.

Wait, perhaps I'm misunderstanding the problem.

Let me read the problem statement again.

"the i -th sign occurs every a_i years (in years a_i , 2 \cdot a_i , 3 \cdot a_i , \dots )."

"the signs must occur sequentially. That is, first they wait for the first sign to occur, then strictly after it, the second sign will occur, and so on."

"if the i -th sign occurred in the year x , the tribe starts waiting for the occurrence of the (i+1) -th sign, starting from the year x+1 ."

So, after the i-th sign occurs in year x, they start waiting for the (i+1)-th sign starting from year x+1.

The (i+1)-th sign occurs in years a[i+1], 2*a[i+1], 3*a[i+1], etc.

So, the (i+1)-th sign will occur in the smallest multiple of a[i+1] that is greater than x.

So, given x, find the smallest multiple of a[i+1] that is greater than x.

That's what the code is trying to do with the formula:

next_year = (last_year + 1 + a[i] - 1) // a[i] * a[i]

Which simplifies to:

next_year = ceil((last_year + 1) / a[i]) * a[i]

Yes, that's the formula for the smallest multiple of a[i] greater than last_year.

In the first test case, when last_year=8, a[3]=5

next_year = ceil((8 + 1) / 5) * 5 = ceil(9 / 5) * 5 = ceil(1.8) * 5 = 2 * 5 = 10

Wait, but according to the code, it's calculating next_year = 15, but according to this, it should be 10.

Wait, in the earlier calculation, I had:

next_year = (8 + 1 + 5 - 1) // 5 * 5 = (13) // 5 * 5 = 3 * 5 = 15

But according to this, it should be ceil((8 + 1) / 5) * 5 = 10.

Wait, but (8 + 1 + 5 - 1) = 13, 13 // 5 = 3, 3 * 5 = 15

But (8 + 1) = 9, 9 + 5 -1 = 13, same as above.

Wait, perhaps the formula in the code is incorrect.

Alternatively, maybe I'm miscalculating.

Let me check with another example.

Take n=2, a=[2,3]

According to the problem, first sign in year 2.

Then wait for the second sign starting from year 3, which occurs every 3 years.

So, the second sign occurs in year 3.

So, the second sign occurs in year 3.

According to the code:

last_year = 2

next_year = (2 + 1 + 3 -1) // 3 * 3 = (5) // 3 * 3 = 2 * 3 = 6

Which is incorrect, because according to the problem, it should be 3.

Wait, but according to the formula, it's calculating the smallest multiple of 3 greater than 2, which is 3.

But according to the formula in the code, it's giving 6.

Wait, that's wrong.

Wait, (2 + 1 + 3 -1) = 5, 5 // 3 = 2, 2 * 3 = 6

But ceil((2 + 1)/3) * 3 = ceil(3/3)*3 = 1*3=3, which is correct.

So, the formula in the code is incorrect.

It should be:

next_year = ((last_year + 1) + a[i] - 1) // a[i] * a[i]

But in the code, it's:

next_year = (last_year + 1 + a[i] - 1) // a[i] * a[i]

Which is the same as:

next_year = (last_year + a[i]) // a[i] * a[i]

But according to the example, it should be ceil((last_year + 1)/a[i]) * a[i]

Which is ((last_year + 1) + a[i] - 1) // a[i] * a[i]

Wait, but in the code, it's (last_year + 1 + a[i] -1) // a[i] * a[i], which is the same as ((last_year + 1) + a[i] -1) // a[i] * a[i]

Which simplifies to ceil((last_year + 1)/a[i]) * a[i]

So, it should be correct.

Wait, in the earlier calculation, for last_year=8, a[i]=5

next_year = (8 + 1 + 5 -1) // 5 *5 = (13) //5 *5=3*5=15

But according to the problem, it should be 10.

Wait, but according to the note, they wait for the fourth sign starting from year 9, and since the fourth sign occurs every 5 years, the next occurrence after year 8 is year 10.

So, it should be 10, but the code is calculating 15.

There's a discrepancy here.

Wait, maybe I'm miscalculating.

Let me check with n=2, a=[2,3]

last_year = 2

next_year = (2 + 1 + 3 -1) //3 *3 = (5)//3*3=2*3=6

But according to the problem, it should be 3.

So, the code is wrong here.

Alternatively, maybe the formula should be:

next_year = ((last_year + 1 + a[i] -1) // a[i]) * a[i]

Wait, but that's what the code is doing.

Wait, perhaps I need to adjust the formula.

Alternative formula for smallest multiple of k greater than x:

next = ((x + k - 1) // k) * k

But in this case, x is last_year +1

So, next_year = ((last_year +1 + a[i] -1) // a[i]) * a[i]

Which simplifies to ((last_year + a[i]) // a[i]) * a[i]

Which should be correct.

Wait, but in the n=2, a=[2,3] example, last_year=2, a[i]=3

next_year = ((2 + 3) // 3) * 3 = (5 // 3) * 3 = 2 * 3 = 6

But according to the problem, it should be 3, since they start waiting from year 3, and the second sign occurs in year 3.

So, there's an error in the logic.

Wait, maybe the formula should be:

next_year = ((last_year + 1) + a[i] -1) // a[i] * a[i]

Which for last_year=2, a[i]=3:

next_year = ((3) + 3 -1) //3 *3 = (5)//3*3=2*3=6

But it should be 3.

Wait, perhaps the formula should be:

next_year = ((last_year + 1) + a[i] -1) // a[i]

if ((last_year +1) % a[i] ==0):

next_year = last_year +1

else:

next_year = ((last_year +1) // a[i] +1) * a[i]

But in the code, it's just ((last_year +1 + a[i] -1) // a[i]) * a[i], which should cover all cases.

Wait, in the n=2, a=[2,3] case:

last_year =2

next_year = ((2 +1 +3 -1)//3)*3 = (5)//3*3=2*3=6

But according to the problem, the second sign occurs in year 3, not 6.

So, the code is wrong here.

Wait, maybe I need to adjust the formula.

Alternative approach:

To find the smallest multiple of a[i] greater than last_year:

next_year = last_year + (a[i] - last_year % a[i]) % a[i]

This should give the next multiple of a[i] after last_year.

Let's test with last_year=2, a[i]=3

next_year = 2 + (3 - 2%3)%3 = 2 + (3 - 2)%3=2 +1%3=2+1=3

Correct.

In the earlier case, last_year=8, a[i]=5

next_year =8 + (5 - 8%5)%5=8 + (5 - 3)%5=8 +2%5=8+2=10

Correct.

In the code's formula, for last_year=8, a[i]=5:

next_year = (8 +1 +5 -1)//5 *5=(13)//5*5=3*5=15

Which is incorrect, as it should be 10.

So, the code has a bug in the formula used to calculate the next year.

It should use:

next_year = last_year + (a[i] - last_year % a[i]) % a[i]

Instead of:

next_year = (last_year +1 +a[i]-1)//a[i]*a[i]

Therefore, the given program is incorrect.

Correctness: **False**