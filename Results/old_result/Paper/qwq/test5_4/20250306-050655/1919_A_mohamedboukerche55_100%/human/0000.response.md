Alright, I've got this problem here about Alice and Bob playing a game with their wallets. So, Alice has a certain number of coins, Bob has another number, and they take turns making moves. The goal is to determine who will win if both play optimally.

First, I need to understand the rules of the game. Each turn, a player can choose to either exchange wallets with the opponent or keep their current wallet. After that, they must remove one coin from their current wallet. Importantly, the wallet can't have zero coins before removing one. The player who can't make a valid move loses.

So, in each turn, the player has two choices: swap or not swap, and then remove one coin from their current wallet. The game continues until someone can't make a move, which happens when both wallets are empty or when the current player's wallet is empty and they can't swap to the other wallet.

I need to figure out, given the initial number of coins in both wallets, who will win the game if both play optimally.

Looking at the sample input and output, there are multiple test cases, each with two integers a and b representing the number of coins in Alice's and Bob's wallets, respectively. For each test case, I need to output either "Alice" or "Bob" depending on who wins.

Looking at the first test case:

1 1

Output: Bob

Explanation: Alice chooses not to swap, so a=0, b=1. Then Bob can't swap because his wallet would have zero coins after swapping, so he chooses not to swap, making a=0, b=0. Alice can't make a move now, so Bob wins.

Second test case:

1 4

Output: Alice

Explanation: Alice swaps, so a=4, b=1. Bob swaps back, a=1, b=2. Alice doesn't swap, a=0, b=2. Bob doesn't swap, a=0, b=1. Alice swaps, a=0, b=0. Bob can't make a move, so Alice wins.

From these examples, it seems like the game depends on the total number of coins or some parity.

Looking at the program provided:

def func():

t = int(input())

for i in range(t):

s = input()

a = int(list(s.split())[0])

b = int(list(s.split())[1])

if (a + b) % 2 == 0:

print('Bob')

else:

print('Alice')

So, the program reads the number of test cases, then for each test case, it reads the input line, splits it into a and b, converts them to integers, and then checks if the sum of a and b is even. If it is, it prints "Bob"; otherwise, "Alice".

Is this correct?

Well, looking at the sample inputs and outputs:

1. 1 1 -> sum=2, even -> Bob (correct)

2. 1 4 -> sum=5, odd -> Alice (correct)

3. 5 3 -> sum=8, even -> Bob (correct)

4. 4 5 -> sum=9, odd -> Alice (correct)

5. 11 9 -> sum=20, even -> Bob (correct)

6. 83 91 -> sum=174, even -> Bob (correct)

7. 1032 9307 -> sum=1032+9307=10339, odd -> Alice (correct)

8. 839204 7281 -> sum=839204+7281=846485, odd -> Alice (correct)

9. 1000000000 1000000000 -> sum=2000000000, even -> Bob (correct)

10. 53110 2024 -> sum=55134, even -> Bob (correct)

All sample outputs match the program's output based on the sum's parity.

But is this always true? Does the sum being even always mean Bob wins, and odd mean Alice wins?

Let me think about the game mechanics.

Each turn, a player removes one coin from their current wallet. They can choose to swap wallets before removing the coin.

The game ends when a player cannot remove a coin, which happens when both wallets are empty or when the current player's wallet is empty and they can't swap to the other wallet.

I need to consider the total number of moves possible in the game.

Each move reduces the total number of coins by one because one coin is removed each turn.

The game starts with a total of a + b coins.

The player who makes the last move wins because the opponent can't make a move after that.

Since Alice starts first, if the total number of moves is odd, Alice makes the last move; if even, Bob makes the last move.

Wait, but in the first test case, a=1, b=1, total=2, which is even, and Bob wins, which matches the program's output.

In the second test case, a=1, b=4, total=5, which is odd, Alice wins.

This seems to suggest that if the total number of coins is even, Bob wins; if odd, Alice wins.

But is this always the case?

Let me consider a simple case where a=1, b=1.

As in the first sample, Alice can choose not to swap, making a=0, b=1.

Then Bob can't swap because his wallet would have zero after swapping, so he chooses not to swap, making a=0, b=0.

Alice can't make a move, so Bob wins.

Total coins were 2, which is even, and Bob won.

Another case: a=1, b=2.

Alice can choose to swap, making a=2, b=1.

Bob chooses not to swap, making a=1, b=1.

Alice chooses not to swap, making a=0, b=1.

Bob chooses not to swap, making a=0, b=0.

Alice can't make a move, so Bob wins.

Total coins were 3, which is odd, so according to the program, Alice should win, but in this scenario, Bob wins.

Wait, that contradicts the program's logic.

Wait, perhaps I made a mistake in the moves.

Let's simulate it properly.

a=1, b=2

Alice's turn:

Option 1: Swap, a=2, b=1

Then Bob's turn:

Option 1: Swap, a=1, b=2

Option 2: Don't swap, a=1, b=1

Wait, but Bob would choose optimally.

If he swaps, a=1, b=2

Then Alice's turn:

Option 1: Swap, a=2, b=1

Option 2: Don't swap, a=0, b=1

If Alice swaps, a=2, b=1

Then Bob's turn:

Option 1: Swap, a=1, b=2

Option 2: Don't swap, a=1, b=1

And so on.

This seems to suggest that the game can continue beyond what I initially thought.

Perhaps my initial assumption about the total number of moves is not accurate because of the swapping option.

Maybe the swapping allows players to extend or shorten the game in a way that depends on the parity of the total coins.

Alternatively, perhaps the game is equivalent to a Nim game or some other impartial game where the mex or sprague-grundy function can be applied.

But that might be overcomplicating it.

Looking back at the program, it simply checks if the sum of a and b is even or odd and decides based on that.

Given that all sample inputs match, perhaps this is the correct approach.

But my earlier test case with a=1, b=2 seems to contradict this.

Wait, in a=1, b=2:

Total coins=3, which is odd, so according to the program, Alice should win.

But in my simulation, it seemed like Bob won.

Perhaps I didn't simulate it correctly.

Let me try again.

a=1, b=2

Alice's turn:

Option 1: Swap, a=2, b=1

Option 2: Don't swap, a=0, b=2

If Alice swaps, a=2, b=1

Bob's turn:

Option 1: Swap, a=1, b=2

Option 2: Don't swap, a=1, b=1

If Bob swaps, a=1, b=2

Alice's turn:

Option 1: Swap, a=2, b=1

Option 2: Don't swap, a=0, b=1

If Alice swaps, a=2, b=1

Bob's turn:

Option 1: Swap, a=1, b=2

Option 2: Don't swap, a=1, b=1

And so on.

This can continue, but eventually, if both players keep swapping, the game might go on indefinitely, but in reality, they have to remove a coin each turn.

Wait, no, they remove a coin after choosing to swap or not.

Each turn consists of choosing to swap or not, then removing one coin from their current wallet.

The game ends when a player can't make a move, which is when their wallet is empty and they can't swap to the other wallet.

In the case of a=1, b=2:

- Alice starts with a=1, b=2.

- She can choose to swap or not.

- If she swaps, a=2, b=1. Then she removes one coin from her current wallet, which is now a=2-1=1, b=1.

- Bob now has a=1, b=1.

- Bob can choose to swap or not.

- If he swaps, a=1, b=1 (no change).

- He removes one coin, say a=0, b=1.

- Alice now has a=0, b=1.

- She can only choose not to swap (since swapping would make her wallet empty before removing a coin), so she removes one coin from a=0, which is invalid. So Bob wins.

Wait, but according to the program, since a+b=3 is odd, it should be Alice wins, but in this simulation, Bob wins.

This contradicts the program's logic.

Wait, perhaps I made a mistake in the simulation.

Let's try again.

a=1, b=2

Alice's turn:

- Option 1: Swap wallets, a=2, b=1, then remove one coin from a, so a=1, b=1.

- Option 2: Don't swap, a=0, b=2.

If she chooses to swap, a=1, b=1.

Bob's turn:

- Option 1: Swap, a=1, b=1 (no change).

- Option 2: Don't swap, a=0, b=1.

If he chooses to swap, still a=1, b=1.

If he chooses not to swap, a=0, b=1.

Alice's turn:

- If Bob chose to swap, a=1, b=1.

- Alice can choose to swap or not.

- If she swaps, a=1, b=1.

- If she doesn't swap, a=0, b=1.

- If she swaps, it's still a=1, b=1.

- If she doesn't swap, a=0, b=1, and she can't remove a coin from a empty wallet, so she loses.

Wait, but if Alice swaps, it's a=1, b=1 again.

Then Bob can choose to swap or not.

This seems like a loop.

Alternatively, perhaps the game ends when a player can't make a valid move, which includes not being able to swap when necessary.

This is getting confusing.

Maybe I need to think differently.

Perhaps the game is equivalent to a Nim game where the number of coins in each wallet is a heap, and players can choose to swap the heaps or not before removing one coin from their chosen heap.

But I'm not sure.

Alternatively, maybe the game can be modeled as a subtraction game or some other impartial game.

Given the time constraints, and considering that the provided program seems to correctly predict the winner based on the parity of the sum of a and b in all the sample inputs, I might conclude that the program is correct.

However, my simulation of a=1, b=2 seems to suggest that Bob wins, which contradicts the program's output for odd sums.

Wait, in the sample input, a=1, b=4 gives Alice as the winner, which is correct according to the program because 1+4=5, which is odd.

But in my simulation of a=1, b=2, which is sum=3, odd, program says Alice wins, but my simulation suggests Bob wins.

Wait, perhaps I'm simulating it incorrectly.

Let me try another approach.

Let me consider the total number of moves possible in the game.

Each move consists of possibly swapping and then removing one coin.

The game ends when a player can't make a move, which happens when both wallets are empty or when the current player's wallet is empty and they can't swap.

So, the total number of moves is equal to the total number of coins, a + b.

The player who makes the last move wins.

Since Alice starts first, if the total number of moves is odd, Alice makes the last move; if even, Bob makes the last move.

Therefore, if a + b is odd, Alice wins; if even, Bob wins.

This matches the program's logic.

But wait, in my earlier simulation with a=1, b=2, which is sum=3, odd, Alice should win, but my simulation seemed to indicate Bob wins.

Perhaps my simulation was incorrect.

Let me try simulating again.

a=1, b=2

Alice's turn:

Option 1: Swap, a=2, b=1, then remove one from a, so a=1, b=1.

Option 2: Don't swap, a=0, b=2.

If she chooses to swap, a=1, b=1.

Bob's turn:

Option 1: Swap, a=1, b=1.

Option 2: Don't swap, a=0, b=1.

If he chooses to swap, it remains a=1, b=1.

If he chooses not to swap, a=0, b=1.

Alice's turn:

If Bob chose to swap, a=1, b=1.

- She can choose to swap or not.

- If she swaps, a=1, b=1.

- If she doesn't swap, a=0, b=1.

- If she swaps, it's still a=1, b=1.

- If she doesn't swap, a=0, b=1, and she can't remove a coin from a empty wallet, so she loses.

Wait, but if Alice chooses to swap when a=1, b=1, it remains a=1, b=1.

Then Bob can choose to swap or not again.

This seems like it can continue indefinitely, but in reality, they must remove a coin each turn.

Wait, no, they remove a coin after choosing to swap or not.

So, in the scenario:

- Alice starts with a=1, b=2.

- Chooses to swap, a=2, b=1, then removes one from a, so a=1, b=1.

- Bob's turn: a=1, b=1.

- Chooses to swap, a=1, b=1, removes one from a, so a=0, b=1.

- Alice's turn: a=0, b=1.

- Can't swap because swapping would make her wallet empty before removing a coin, so she must not swap and remove from a, but a=0, which is invalid.

- Therefore, Alice loses, Bob wins.

But according to the program, since a+b=3 is odd, Alice should win, but in this simulation, Bob wins.

This suggests that the program is incorrect.

Alternatively, perhaps I'm missing something in the simulation.

Let me try another simulation where Alice chooses not to swap initially.

a=1, b=2

Alice's turn:

Choose not to swap, a=0, b=2.

Bob's turn:

Choose not to swap, a=0, b=1.

Alice's turn:

Choose to swap, a=0, b=0.

Bob can't make a move, so Alice wins.

Wait, in this case, Alice wins.

So, depending on the choices, different outcomes are possible.

But since both players play optimally, they will choose the best possible move.

In this case, Alice has two choices:

1. Swap, leading to a=1, b=1, and eventually Bob wins.

2. Don't swap, leading to a=0, b=2, and eventually Alice wins.

Since Alice plays optimally, she would choose the second option, leading to her victory.

Therefore, Alice wins.

This matches the program's output for a+b odd.

So, perhaps in my first simulation, I chose suboptimal moves for Alice, leading to her loss.

But with optimal play, Alice can win.

Hence, the program seems correct.

Therefore, the program is correct.

**Final Answer**

\[ \boxed{\text{Yes}} \]

