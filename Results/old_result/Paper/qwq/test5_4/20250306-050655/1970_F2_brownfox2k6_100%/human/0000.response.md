Alright, I have this problem to solve. Let's see what it's about. So, there's a Quidditch game going on between Gryffindor and Ravenclaw. Each team has players, goals, and there's a Quaffle and possibly a Bludger on the field. My job is to referee the game by tracking the positions of all these entities and determining when a goal is scored or a player is eliminated.

First, I need to understand the setup. The field is a grid with N rows and M columns, where N and M are both at least 3 and at most 99, and both are odd numbers. This ensures there's a central cell where the Quaffle is moved after a goal is scored.

Each cell can contain multiple entities, like players, the Quaffle, or the Bludger. The entities are represented by specific codes: 'R0' to 'R9' for Gryffindor players, 'B0' to 'B9' for Ravenclaw players, 'RG' for Gryffindor's goal, 'BG' for Ravenclaw's goal, '.Q' for the Quaffle, and '.B' for the Bludger.

The game consists of T steps, where each step involves an action by one entity. The actions can be moving (U, D, L, R), catching a ball (C), or throwing the Quaffle (T).

My task is to process these actions, keep track of the positions, detect when a goal is scored or a player is eliminated, and finally output the sequence of events and the final score.

Let me think about how to approach this.

First, I need to parse the initial grid. I'll need to store the positions of all players, the goals, the Quaffle, and the Bludger. Since multiple entities can be in the same cell, I need to handle that properly.

I'll create dictionaries or lists to store these positions. For example, I can have a dictionary where the keys are the entity codes ('R0', 'B1', '.Q', etc.) and the values are their positions [row, column].

I also need to keep track of which player is carrying the Quaffle. Initially, no one is carrying it.

As I process each action, I need to update the positions accordingly and check for specific conditions:

1. **Moving (U, D, L, R):**

- Update the position of the entity based on the direction.

- If it's a player moving into a cell with the Bludger, the player is eliminated.

- If a player is carrying the Quaffle and moves, the Quaffle moves with them.

2. **Catching a ball (C):**

- The player catches the specified ball if they are on the same cell.

- Only players can catch balls.

- If a player catches the Quaffle, they start carrying it.

3. **Throwing the Quaffle (T):**

- The player stops carrying the Quaffle, and the Quaffle remains in the player's current position.

- If the Quaffle is in a goal cell, the opposing team scores a point, and the Quaffle is moved to the center of the field.

I need to make sure that all actions are valid as per the problem statement, so I don't need to handle invalid moves.

Now, let's think about how to implement this.

First, read N and M, then read the grid.

Parse the grid to find the positions of all entities.

Then, read T, the number of steps, and process each step one by one.

For each step:

- Identify which entity is performing the action.

- Determine the type of action and perform it accordingly.

- Check for goal scoring or player elimination after each action.

- Output the events in the order they happen.

Finally, after all steps, output the final score.

Let me consider some edge cases:

- A player scores a goal immediately.

- A player is eliminated immediately.

- Multiple players are eliminated in the same step.

- The Quaffle is thrown into a goal.

- A player throws the Quaffle and then catches it again.

- The Bludger is moved around and eliminates players.

I need to ensure that the program handles these scenarios correctly.

Also, I need to make sure that the positions are updated correctly and that entities don't go out of bounds, but since the problem says all actions are valid, I don't need to handle invalid moves.

Now, let's think about how to implement the movement function.

I can create a function that takes an object's position and a direction and updates its position accordingly.

Similarly, for catching and throwing, I need to update the carry status and the Quaffle's position.

For checking goals:

- If the Quaffle is in a 'BG' cell and a red player threw it or left it there, then blue scores.

- If the Quaffle is in a 'RG' cell and a blue player threw it or left it there, then red scores.

- If a player scores in their own goal, the opposite team scores.

For player elimination:

- If a player moves into the same cell as the Bludger, the player is eliminated.

- If the Bludger moves into a cell with a player, the player is eliminated.

- Need to handle multiple eliminations in the same step and print them in alphabetical order.

I need to keep track of the scores for red and blue teams.

I should also ensure that the central cell is correctly calculated as [(N+1)/2, (M+1)/2], considering 0-based indexing.

Let me sketch a rough plan:

1. Read N and M.

2. Read the grid of N rows and M columns.

3. Parse the grid to find positions:

- Find all 'RG' and store their positions in a list.

- Find all 'BG' and store their positions in a list.

- Find '.Q' and store its position.

- Find '.B' and store its position.

- Find all 'R0' to 'R9' and 'B0' to 'B9' and store their positions in a dictionary.

4. Initialize variables:

- carry = None (no one is carrying the Quaffle initially)

- rs = 0 (red team score)

- bs = 0 (blue team score)

5. Read T, the number of steps.

6. For each step from 0 to T-1:

- Read the action line.

- Extract the entity and the action.

- If action is 'C', handle catching.

- If action is 'T', handle throwing.

- If action is a direction (U, D, L, R), handle movement.

- After each action, check for goal scoring and player elimination.

- Print the events as they happen.

7. After all steps, print the final score.

Now, let's think about implementing the movement.

I'll create a function to move an object in a specified direction.

For example:

def move(obj, d):

if d == 'U':

obj[0] -= 1

elif d == 'D':

obj[0] += 1

elif d == 'L':

obj[1] -= 1

elif d == 'R':

obj[1] += 1

This assumes that the object is a list [row, col].

I need to make sure that after movement, I check for collisions with the Bludger.

Similarly, for catching and throwing:

- Catching: if the player is on the same cell as the ball they're trying to catch, they catch it.

- Throwing: the player stops carrying the Quaffle, and the Quaffle is placed at the player's current position.

For goal scoring:

- After any action that places the Quaffle in a goal cell, check if it's the opponent's goal and increment the score accordingly.

- Then, move the Quaffle to the center of the field.

I need to make sure that the Quaffle's position is updated correctly when it's being carried by a player.

Also, need to handle the case where a player is eliminated while carrying the Quaffle. In that case, the Quaffle should remain in the cell where the player was eliminated.

Wait, the problem says: "If a player is eliminated while it is carrying the Quaffle, the Quaffle remains on the cell containing both the player and the Bludger after the move."

So, if a player carrying the Quaffle is eliminated, the Quaffle stays in that cell.

I need to handle that.

Also, it's guaranteed that this never occurs while the player is in a cell containing a goal.

So, I don't need to worry about scoring a goal at the same time as being eliminated.

That simplifies things.

Now, let's think about how to organize the data.

I'll have:

- A list of goal positions for each team: rg (Red Goals), bg (Blue Goals)

- Position of the Quaffle: ball

- Position of the Bludger: blud

- Positions of players: player dictionary with keys 'R0' to 'R9' and 'B0' to 'B9'

- Variable carry: stores which player is carrying the Quaffle, or None.

I need to make sure that only one player can carry the Quaffle at a time.

Now, for each step, I need to process the action:

- If it's a movement (U, D, L, R):

- Move the entity accordingly.

- If it's a player, check if they're moving into the Bludger's cell. If so, eliminate the player.

- If a player is carrying the Quaffle, move the Quaffle with them.

- If the Bludger is moving into a player's cell, eliminate that player.

- If it's catching (C):

- The player tries to catch a specified ball.

- If the player is on the same cell as the ball, they catch it.

- If catching the Quaffle, set carry to the player.

- If it's throwing (T):

- The player throws the Quaffle, so set carry to None and place the Quaffle at the player's position.

- Then, check if the Quaffle is in a goal cell.

- If so, score a goal for the opposing team.

- Move the Quaffle to the center of the field.

After each action, I need to check for goal scoring and player elimination and print the events accordingly.

I need to make sure that if multiple players are eliminated in the same step, I print their elimination in alphabetical order.

Finally, after all steps, print the final score.

I think this covers the main logic.

Let me consider the sample inputs to verify.

Take the first sample input:

3 5

.. .. R0 .. ..

RG .. .Q .. BG

.. .. B0 .. ..

12

R0 D

R0 C .Q

R0 R

R0 T

R0 D

B0 R

B0 U

B0 C .Q

B0 L

B0 L

B0 L

B0 T

According to the expected output:

11 BLUE GOAL

FINAL SCORE: 0 1

So, let's simulate this step by step.

Initial positions:

Row 0:

.. .. R0 .. ..

Row 1:

RG .. .Q .. BG

Row 2:

.. .. B0 .. ..

Step 0: R0 D

R0 moves down from [0,2] to [1,2]

Now, R0 is at [1,2], which is where .Q is.

Step 1: R0 C .Q

R0 catches the Quaffle. So, carry = 'R0', and .Q moves with R0.

Step 2: R0 R

R0 moves right from [1,2] to [1,3]

Quaffle moves with R0 to [1,3]

Step 3: R0 T

R0 throws the Quaffle, so carry = None, and .Q is at [1,3]

Check if [1,3] is a goal cell. It's not, so no goal.

Step 4: R0 D

R0 moves down from [1,2] to [2,2]

Step 5: B0 R

B0 moves right from [2,2] to [2,3]

Step 6: B0 U

B0 moves up from [2,3] to [1,3]

Now, B0 is at [1,3], where .Q is.

Step 7: B0 C .Q

B0 catches the Quaffle. So, carry = 'B0', and .Q moves with B0.

Step 8: B0 L

B0 moves left from [1,3] to [1,2]

Quaffle moves with B0 to [1,2]

Step 9: B0 L

B0 moves left from [1,2] to [1,1]

Quaffle moves with B0 to [1,1]

Step 10: B0 L

B0 moves left from [1,1] to [1,0]

Quaffle moves with B0 to [1,0]

Step 11: B0 T

B0 throws the Quaffle, so carry = None, and .Q is at [1,0]

Check if [1,0] is a goal cell. It's 'RG', which is Red's goal.

Since B0 (Blue team) threw it into Red's goal, Blue scores a goal.

So, bs += 1, and move .Q to center [n//2, m//2] = [1, 2]

So, output "11 BLUE GOAL"

Then, final score is 0 for Red and 1 for Blue.

This matches the sample output.

Good, my logic seems to hold for this case.

Let me look at the second sample input:

3 5

.. .. R0 .. ..

RG .. .Q .. BG

.. .. B0 .. ..

5

R0 D

R0 C .Q

R0 L

R0 L

R0 T

Expected output:

4 BLUE GOAL

FINAL SCORE: 0 1

Simulate step by step:

Initial positions:

Row 0:

.. .. R0 .. ..

Row 1:

RG .. .Q .. BG

Row 2:

.. .. B0 .. ..

Step 0: R0 D

R0 moves down from [0,2] to [1,2]

Now, R0 is at [1,2], where .Q is.

Step 1: R0 C .Q

R0 catches the Quaffle. So, carry = 'R0', and .Q moves with R0.

Step 2: R0 L

R0 moves left from [1,2] to [1,1]

Quaffle moves with R0 to [1,1]

Step 3: R0 L

R0 moves left from [1,1] to [1,0]

Quaffle moves with R0 to [1,0]

Step 4: R0 T

R0 throws the Quaffle, so carry = None, and .Q is at [1,0]

Check if [1,0] is a goal cell. It's 'RG', which is Red's goal.

But R0 (Red team) threw it into their own goal, so Blue scores a goal.

So, bs += 1, and move .Q to center [1,2]

Output "4 BLUE GOAL"

Final score: 0 for Red, 1 for Blue.

Again, matches the sample output.

Good.

Now, third sample input:

5 5

.. .. .. .. ..

.. .. .. .. ..

RG R0 .Q B0 BG

.. .. .. .. ..

.. .. .B .. ..

5

.B L

.B U

.B U

B0 L

B0 L

Expected output:

2 R0 ELIMINATED

4 B0 ELIMINATED

FINAL SCORE: 0 0

Let's simulate:

Initial positions:

Row 0:

.. .. .. .. ..

Row 1:

.. .. .. .. ..

Row 2:

RG R0 .Q B0 BG

Row 3:

.. .. .. .. ..

Row 4:

.. .. .B .. ..

Step 0: .B L

Bludger moves left from [4,2] to [4,1]

Step 1: .B U

Bludger moves up from [4,1] to [3,1]

Step 2: .B U

Bludger moves up from [3,1] to [2,1]

Now, Bludger is at [2,1], where RG is.

But RG is a goal, not a player, so no elimination.

Step 3: B0 L

B0 moves left from [2,3] to [2,2]

Check if [2,2] has Bludger: no, it's at [2,1]

So, no elimination.

Step 4: B0 L

B0 moves left from [2,2] to [2,1]

Now, B0 is at [2,1], where Bludger is.

So, B0 is eliminated.

Also, check if any other players are at [2,1]: no.

So, print "4 B0 ELIMINATED"

But according to the sample output, there's "2 R0 ELIMINATED"

Wait, when does R0 get eliminated?

Looking back:

After step 2, Bludger is at [2,1], where RG is.

But RG is a goal, not a player.

So, no elimination there.

In step 3, B0 moves to [2,2], no Bludger there.

In step 4, B0 moves to [2,1], where Bludger is, so B0 is eliminated.

But the sample output shows "2 R0 ELIMINATED"

Hmm, maybe I missed something.

Wait, perhaps there's a mistake in my simulation.

Let's check the steps again.

Step 0: .B L

Bludger moves from [4,2] to [4,1]

Step 1: .B U

Bludger moves from [4,1] to [3,1]

Step 2: .B U

Bludger moves from [3,1] to [2,1]

Now, Bludger is at [2,1], where RG is.

But RG is a goal, not a player, so no elimination.

Step 3: B0 L

B0 moves from [2,3] to [2,2]

No Bludger there, so no elimination.

Step 4: B0 L

B0 moves from [2,2] to [2,1], where Bludger is.

So, B0 is eliminated.

But according to the sample output, "2 R0 ELIMINATED" and "4 B0 ELIMINATED"

Wait, perhaps when the Bludger moves to [2,1], it eliminates R0, who is at [2,1].

Wait, initially, R0 is at [2,1], .Q is at [2,2], B0 at [2,3], BG at [2,4]

Wait, no: "RG R0 .Q B0 BG"

Looking back at the grid:

Row 2: RG R0 .Q B0 BG

So, positions:

[2,0]: RG

[2,1]: R0

[2,2]: .Q

[2,3]: B0

[2,4]: BG

Initially, Bludger is at [4,2]

Step 0: .B L, Bludger moves to [4,1]

Step 1: .B U, Bludger moves to [3,1]

Step 2: .B U, Bludger moves to [2,1], where R0 is.

So, R0 is eliminated.

So, at step 2, R0 is eliminated.

Then, step 3: B0 L, B0 moves from [2,3] to [2,2]

No Bludger there, so no elimination.

Step 4: B0 L, B0 moves from [2,2] to [2,1], where Bludger is.

So, B0 is eliminated.

Hence, the output should be:

2 R0 ELIMINATED

4 B0 ELIMINATED

FINAL SCORE: 0 0

Good, now I see where I made a mistake in my earlier simulation.

So, my logic needs to handle player elimination when a player is on the same cell as the Bludger after movement.

Now, I need to implement this in code.

I need to make sure that after each movement, I check if the moving entity is a player and if it's moving into the Bludger's cell, or if the Bludger is moving into a player's cell.

In both cases, the player is eliminated.

I need to handle both possibilities.

Also, ensure that if multiple players are eliminated in the same step, I print them in alphabetical order.

Now, let's think about how to implement this in code.

I'll have to:

- After a player moves, check if their new position is the same as the Bludger's position. If so, eliminate the player.

- After the Bludger moves, check if its new position has any players. If so, eliminate those players.

- Collect all eliminated players in a list, sort them, and print the elimination events.

I need to make sure that once a player is eliminated, their position is set to some invalid value, like [-1, -1], to indicate they're out of the game.

Also, need to ensure that eliminated players can't perform actions anymore.

Now, let's think about how to implement the goal scoring.

After any action that places the Quaffle in a goal cell, check if it's the opponent's goal.

- If a red player throws the Quaffle into the blue goal, blue scores.

- If a blue player throws the Quaffle into the red goal, red scores.

- If a red player throws the Quaffle into the red goal, blue scores.

- If a blue player throws the Quaffle into the blue goal, red scores.

Wait, no. According to the problem:

- To win a point, a player must leave the Quaffle at a goal of the other team.

- If a player puts the ball in its own goal, the other team wins the point.

So, regardless of which goal the Quaffle is in, the opposite team scores.

Wait, no. More precisely:

- A player must leave the Quaffle at a goal of the other team to score a point for their own team.

- If a player leaves the Quaffle at their own goal, the other team scores.

So, for a red player:

- Leaving the Quaffle at a blue goal scores a point for red.

- Leaving the Quaffle at a red goal scores a point for blue.

Similarly for blue players.

I need to make sure I handle this correctly.

Now, in terms of code, I need to:

- Keep lists of goal positions for red and blue.

- After an action that places the Quaffle in a goal cell, determine which team scores.

- Move the Quaffle to the center of the field.

Now, let's think about the center of the field.

Given that N and M are odd, the center is at row N//2, column M//2 (0-based indexing).

So, I'll calculate center_row = N // 2 and center_col = M // 2.

Now, I need to make sure that after a goal is scored, the Quaffle is moved to this center position.

Also, ensure that there are no goals at the center, as per the problem statement.

Now, I need to implement functions for movement and elimination checks.

I'll define a function to move an object:

def move(obj, d):

if d == 'U':

obj[0] -= 1

elif d == 'D':

obj[0] += 1

elif d == 'L':

obj[1] -= 1

elif d == 'R':

obj[1] += 1

Then, after moving a player or the Bludger, check for eliminations.

I need to make sure that eliminated players are marked appropriately and don't participate further.

Now, let's think about how to handle the carry status.

- Only players can carry the Quaffle.

- When a player catches the Quaffle, set carry = player_code.

- When a player throws the Quaffle, set carry = None and place the Quaffle at the player's position.

- If a player is carrying the Quaffle and moves, the Quaffle moves with them.

- If a player is eliminated while carrying the Quaffle, the Quaffle remains in the cell where the elimination occurred.

I need to make sure that the Quaffle's position is updated correctly in all these scenarios.

Now, let's consider implementing the main loop.

For each step from 0 to T-1:

- Read the action line.

- Parse the entity and the action.

- If the action is a movement (U, D, L, R):

- If the entity is a player:

- Move the player.

- If the player is carrying the Quaffle, move the Quaffle with them.

- Check if the player's new position is the same as the Bludger's position. If so, eliminate the player.

- If the entity is the Bludger:

- Move the Bludger.

- Check if the Bludger's new position has any players. If so, eliminate those players.

- If the action is catching (C):

- The player catches the specified ball if they are on the same cell.

- If catching the Quaffle, set carry = player_code.

- If the action is throwing (T):

- The player throws the Quaffle, so set carry = None and place the Quaffle at the player's position.

- Check if the Quaffle is in a goal cell. If so, score a goal for the appropriate team and move the Quaffle to the center.

- After each action, check for goal scoring and player elimination and print the events accordingly.

Finally, print the final score.

I need to make sure that all events are printed in the order they occur, and that multiple eliminations in the same step are printed in alphabetical order.

Now, I need to think about how to implement the elimination checks.

I'll need to:

- After a player moves, check if their position matches the Bludger's position.

- After the Bludger moves, check if its position matches any player's position.

- Collect all eliminated players and print them in sorted order.

Also, need to ensure that eliminated players are removed from the game properly.

I'll set their position to [-1, -1] to indicate they're eliminated.

Now, I need to make sure that eliminated players don't perform any actions.

But according to the problem, actions are guaranteed to be valid, so I don't need to handle cases where an eliminated player tries to perform an action.

But I should still handle it to ensure the program doesn't crash.

Now, let's think about how to implement the goal scoring check.

After any action that places the Quaffle in a goal cell, check which goal it's in and which team should score.

- If Quaffle is in a blue goal, and it was placed there by a red player, then red scores.

- If Quaffle is in a blue goal, and it was placed there by a blue player, then red scores.

- Similarly, if Quaffle is in a red goal, and placed there by a blue player, blue scores.

- If Quaffle is in a red goal, and placed there by a red player, blue scores.

Wait, no.

According to the problem:

- To win a point, a player must leave the Quaffle at a goal of the other team.

- If a player puts the ball in its own goal, the other team wins the point.

So, regardless of which goal the Quaffle is in, the scoring is based on whose goal it is.

More precisely:

- If a player leaves the Quaffle in the opponent's goal, their team scores.

- If a player leaves the Quaffle in their own goal, the opponent's team scores.

So, in code, I can determine the scoring team based on which goal the Quaffle is in and which team the player is from.

For example:

- If Quaffle is in a blue goal:

- If the player is from red team, red scores.

- If the player is from blue team, red scores.

- If Quaffle is in a red goal:

- If the player is from blue team, blue scores.

- If the player is from red team, blue scores.

Wait, that can't be right.

Wait, no. According to the problem:

- To win a point, a player must leave the Quaffle at a goal of the other team.

- If a player puts the ball in its own goal, the other team wins the point.

So, it's not dependent on which player performed the action, but which goal the Quaffle is in.

Wait, no. It is dependent on which team the player is from.

Wait, let's read the problem again:

"To win a point, a player must leave the Quaffle at a goal of the other team.

When it does, the team of the player wins one point, and the Quaffle instantly moves to the middle of the field (the cell at the (M+1)/2 -th column of the (N+1)/2 -th line of the field, starting from 1). There is no goal in the middle of the field. If a player puts the ball in its own goal, the other team wins the point."

So, if a player leaves the Quaffle in the opponent's goal, their team scores.

If they leave it in their own goal, the opponent's team scores.

So, I need to determine which team the player is from, and which goal the Quaffle is in.

Wait, no, it's based on who left it in which goal.

Wait, more precisely:

- If a red player leaves the Quaffle in a blue goal, red scores.

- If a red player leaves the Quaffle in a red goal, blue scores.

- If a blue player leaves the Quaffle in a red goal, blue scores.

- If a blue player leaves the Quaffle in a blue goal, red scores.

So, it's based on the player's team and the goal's team.

I need to implement logic to determine the scoring team based on these conditions.

I need to make sure I handle this correctly.

Now, in terms of code, I need to:

- Keep track of which team each player belongs to.

- Keep track of which goals belong to which team.

- When a Quaffle is left in a goal cell, determine which team scores based on the above rules.

I can create dictionaries to map player codes to their team.

For example:

team = {'R0': 'R', 'R1': 'R', ..., 'B0': 'B', 'B1': 'B', ...}

Then, for each goal, know which team it belongs to.

rg = [positions of red goals]

bg = [positions of blue goals]

Then, when the Quaffle is left in a goal cell:

- If it's in a blue goal, and the player is red, red scores.

- If it's in a blue goal, and the player is blue, red scores.

- If it's in a red goal, and the player is blue, blue scores.

- If it's in a red goal, and the player is red, blue scores.

So, in code:

if ball in bg:

if team[player] == 'R':

rs += 1

print(t, 'RED GOAL')

else:

bs += 1

print(t, 'BLUE GOAL'

elif ball in rg:

if team[player] == 'B':

bs += 1

print(t, 'BLUE GOAL'

else:

rs += 1

print(t, 'RED GOAL'

Then, move the Quaffle to the center.

Now, I need to make sure that the player performing the action is the one who left the Quaffle in the goal.

But, in the case of throwing the Quaffle, it's the player who threw it.

In the case of moving with the Quaffle, it's the player who moved it.

I need to make sure that I know which player is responsible for placing the Quaffle in the goal cell.

So, I need to keep track of which player is carrying the Quaffle when it's moved.

Wait, no. When a player is carrying the Quaffle and moves, the Quaffle moves with them.

So, if a player carrying the Quaffle moves into a goal cell, that's equivalent to leaving the Quaffle there.

Similarly, when a player throws the Quaffle, it's left at their position.

So, in both cases, I need to check if the Quaffle is in a goal cell after the action.

Now, I need to make sure that I check for goal scoring after the action is performed.

Also, need to handle the case where a player is eliminated while carrying the Quaffle.

In that case, the Quaffle remains in the cell where the player was eliminated.

I need to make sure that the Quaffle's position is updated correctly in this case.

Now, I need to think about how to implement this in code.

I'll have to:

- After each action, check if the Quaffle is in a goal cell.

- If so, determine which team scores based on which player is responsible.

- Move the Quaffle to the center.

- Print the goal event.

Also, need to handle player elimination after movements.

I need to make sure that I handle all these events in the correct order.

Now, I need to think about how to structure the code.

I can have:

- Read N and M.

- Read the grid and parse positions.

- Initialize variables: carry = None, rs = 0, bs = 0.

- Read T.

- For each step from 0 to T-1:

- Read the action line.

- Parse the entity and the action.

- If entity is '.Q' or '.B', handle their movement.

- If entity is a player, handle their movement, catching, or throwing.

- After the action, check for goal scoring and player elimination.

- Print the events accordingly.

- After all steps, print the final score.

Now, I need to implement functions for movement and elimination checks.

I can have a function to move an object:

def move(obj, d):

if d == 'U':

obj[0] -= 1

elif d == 'D':

obj[0] += 1

elif d == 'L':

obj[1] -= 1

elif d == 'R':

obj[1] += 1

Then, after moving a player or the Bludger, check for eliminations.

For elimination checks:

- After a player moves, check if their position matches the Bludger's position.

- After the Bludger moves, check if its position matches any player's position.

- Collect all eliminated players and print them in sorted order.

I need to make sure that eliminated players are removed from the game properly.

Now, I need to think about how to handle the carry status.

- When a player catches the Quaffle, set carry = player_code and move the Quaffle to the player's position.

- When a player throws the Quaffle, set carry = None and place the Quaffle at the player's position.

- If a player is carrying the Quaffle and moves, move the Quaffle with them.

- If a player is eliminated while carrying the Quaffle, the Quaffle remains at the elimination position.

I need to make sure that the Quaffle's position is updated correctly in all these scenarios.

Now, let's think about implementing the goal scoring check.

After any action that places the Quaffle in a goal cell, determine which team scores and move the Quaffle to the center.

I need to make sure that the Quaffle is only moved to the center after scoring a goal.

Also, need to ensure that scoring can only happen after an action that places the Quaffle in a goal cell.

Now, I need to make sure that I handle all possible actions correctly.

Let me think about the different types of actions:

1. Movement (U, D, L, R):

- If the entity is a player:

- Move the player.

- If the player is carrying the Quaffle, move the Quaffle with them.

- Check if the player's new position is the same as the Bludger's position. If so, eliminate the player.

- If the Quaffle is now in a goal cell, check for goal scoring.

- If the entity is the Bludger:

- Move the Bludger.

- Check if the Bludger's new position has any players. If so, eliminate those players.

- If the Quaffle is now in a goal cell, check for goal scoring.

2. Catching (C):

- The player catches a specified ball if they are on the same cell.

- If catching the Quaffle, set carry = player_code.

- If the Quaffle is now in a goal cell, check for goal scoring.

3. Throwing (T):

- The player throws the Quaffle, set carry = None and place the Quaffle at the player's position.

- Check if the Quaffle is now in a goal cell, and score accordingly.

I need to make sure that after each action, I check if the Quaffle is in a goal cell and handle scoring.

Also, need to handle player elimination after movements.

Now, I need to think about how to implement the elimination checks.

I can have a function that checks if a player is eliminated and collects their codes.

Then, sort the list and print the elimination events.

I need to make sure that eliminated players are marked as eliminated and don't participate further.

Now, let's think about how to represent the positions.

I'll use lists [row, column], 0-based indexing.

Now, I need to make sure that after each movement, the positions are updated correctly.

Also, need to ensure that entities don't go out of bounds, but since actions are guaranteed to be valid, I don't need to handle invalid moves.

Now, I need to implement this logic in code.

I need to make sure that I handle all the edge cases correctly.

I think this covers the main logic.

## Final Solution
To solve this problem, we need to simulate a Quidditch game based on given inputs and determine the correctness of the provided Python program. The task involves tracking the positions of players, the Quaffle, and potentially a Bludger on a grid, processing a series of actions, and determining when goals are scored or players are eliminated.

### Approach

1. **Initialization**:
   - Read and parse the grid to determine the initial positions of all entities including players, goals, the Quaffle, and the Bludger.
   - Track which player is carrying the Quaffle and the scores for each team.

2. **Processing Actions**:
   - For each action, identify the entity performing the action and the type of action (movement, catching, throwing).
   - Update positions accordingly and check for goals scored or players eliminated after each action.

3. **Checking for Goals and Eliminations**:
   - If the Quaffle is placed in a goal cell, determine which team scores based on the rules.
   - If a player moves onto the same cell as the Bludger or vice versa, eliminate the player.

4. **Output Events**:
   - Print events such as goals and eliminations in the order they occur.
   - At the end, print the final scores.

### Solution Code

```python
(n, m) = map(int, input().split())
rg = []
bg = []
blud = [-1, -1]
player = {}
team = {}
for i in range(n):
    s = input().split()
    for j in range(m):
        if s[j] == 'RG':
            rg.append([i, j])
        elif s[j] == 'BG':
            bg.append([i, j])
        elif s[j] == '.Q':
            ball = [i, j]
        elif s[j] == '.B':
            blud = [i, j]
        else:
            player[s[j]] = [i, j]
            team[s[j]] = s[j][0]  # 'R' or 'B'

carry = None
rs = 0
bs = 0
center = [n // 2, m // 2]

for t in range(int(input())):
    (p, d) = input().split()[:2]
    
    if d == 'C':
        # Catching
        if p in player and player[p] == ball:
            carry = p
    elif d == 'T':
        # Throwing
        if p in player and carry == p:
            carry = None
            if ball in bg:
                if team[p] == 'R':
                    rs += 1
                    print(t, 'RED GOAL')
                else:
                    bs += 1
                    print(t