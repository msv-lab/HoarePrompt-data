Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find an array of integers, with at most 200 elements, such that the number of increasing subsequences in it is exactly X, where X can be up to 10^18. If it's not possible, I should output -1. There are multiple test cases, up to 1000 of them.

First, I need to understand what an increasing subsequence is. From the problem statement, it's a sequence obtained by removing some elements from the array without changing the order of the remaining elements, and the remaining elements are strictly increasing. Also, different positions can have the same values, but they are considered different subsequences if their positions differ.

So, for example, if I have the array [1, 2, 3], the increasing subsequences are:

- Empty subsequence

- [1]

- [2]

- [3]

- [1,2]

- [1,3]

- [2,3]

- [1,2,3]

That's a total of 8 subsequences. Wait, but according to the problem, the empty subsequence is also considered increasing, so including that, it should be 8.

Now, if I have an array where elements are not strictly increasing, like [1, 3, 2], the increasing subsequences would be:

- Empty

- [1]

- [3]

- [2]

- [1,3]

- [1,2]

- [3,2] (but [3,2] is not increasing, so it should be excluded)

Wait, [3,2] is not increasing, so it shouldn't be counted. So only:

- Empty

- [1]

- [3]

- [2]

- [1,3]

- [1,2]

That's 6 subsequences.

Another example, [2, 2]. According to the problem, there are two different subsequences equal to [2], presumably [2] from the first position and [2] from the second position.

So, increasing subsequences are:

- Empty

- [2] (first position)

- [2] (second position)

- [2,2] (but is [2,2] increasing? Wait, the problem says strictly increasing, so [2,2] is not increasing.

So only 3 increasing subsequences: empty, [2] (first), [2] (second).

Wait, but the problem mentions that in the array [2,2], there are two different subsequences equal to [2], which are considered different because their positions differ.

So, total increasing subsequences are:

- Empty

- [2] (first position)

- [2] (second position)

That's 3.

Wait, but according to the earlier example with X=2, the output is an array of length 1 with [0], which has 2 increasing subsequences: empty and [0].

So, for X=2, [0] has 2 increasing subsequences.

For X=5, the output is [0,1,0], which has 5 increasing subsequences.

Let's verify that.

Array [0,1,0]:

- Empty

- [0] (first 0)

- [1]

- [0] (second 0)

- [0,1]

That's 5 increasing subsequences.

Yes, that matches.

Another example, X=13, array [2,2,3,4,2].

Let's list the increasing subsequences:

- Empty

- [2] (first 2)

- [2] (second 2)

- [3]

- [4]

- [2,3]

- [2,4]

- [2,3,4]

- [2,4]

Wait, but [2,4] appears twice, once from the first 2 and once from the second 2.

Wait, let's list them carefully:

- Empty: 1

- Single elements: [2] (first), [2] (second), [3], [4]: total 4

- Two elements:

- [2,3] (first 2 and 3)

- [2,4] (first 2 and 4)

- [2,3] (second 2 and 3)

- [2,4] (second 2 and 4)

- [3,4]

- Total: 5

- Three elements:

- [2,3,4] (first 2, 3, 4)

- [2,3,4] (second 2, 3, 4)

- But since the elements are the same, but positions differ, they are considered different subsequences.

- So, two [2,3,4]

- Total: 2

- Four elements:

- [2,3,4,2]: but this is not increasing, so excluded.

- Five elements:

- The whole array is not increasing, so excluded.

Total increasing subsequences: 1 (empty) + 4 (single) + 5 (double) + 2 (triple) = 12.

Wait, but the problem says for X=13, the array is [2,2,3,4,2], but according to my count, it has 12 increasing subsequences. Maybe I missed one.

Wait, perhaps I missed [2,4] from second 2 to 4. Wait, I think I counted it.

Wait, maybe the problem considers [2,4] from first 2 and 4, and [2,4] from second 2 and 4 as two different subsequences. So, total 6 for two-element subsequences.

Wait, let's recount:

- Empty: 1

- Single: [2] (first), [2] (second), [3], [4]: 4

- Two-element:

- [2,3] (first 2 and 3)

- [2,4] (first 2 and 4)

- [2,3] (second 2 and 3)

- [2,4] (second 2 and 4)

- [3,4]

- Total: 5

- Three-element:

- [2,3,4] (first 2, 3, 4)

- [2,3,4] (second 2, 3, 4)

- Total: 2

Total: 1 + 4 + 5 + 2 = 12.

But the problem says the array [2,2,3,4,2] has 13 increasing subsequences for X=13. Maybe I missed one.

Wait, perhaps the single [2] from the third 2 is missing. Wait, no, there are only two 2's in the positions 1 and 2, and another 2 at position 5. So, three 2's.

Wait, the array is [2,2,3,4,2], so positions 1,2,4,5 have 2,2,4,2.

Wait, positions 1:2, position 2:2, position 3:3, position 4:4, position 5:2.

So, single elements:

- [2] (position 1)

- [2] (position 2)

- [3]

- [4]

- [2] (position 5)

That's 5 single elements.

Two elements:

- [2,2] (positions 1 and 2): not increasing

- [2,3] (positions 1 and 3)

- [2,4] (positions 1 and 4)

- [2,3] (positions 2 and 3)

- [2,4] (positions 2 and 4)

- [3,4] (positions 3 and 4)

- [2,4] (positions 4 and 5): [4,2] is not increasing

- [2,2] (positions 1 and 5): not increasing

- [2,2] (positions 2 and 5): not increasing

So, only [2,3], [2,4], [2,3], [2,4], [3,4]: total 5.

Three elements:

- [2,3,4] (positions 1,3,4)

- [2,3,4] (positions 2,3,4)

- [2,4,2] (positions 1,4,5): not increasing

- [2,4,2] (positions 2,4,5): not increasing

So, only two [2,3,4]

Four elements:

- [2,2,3,4]: not increasing

- [2,3,4,2]: not increasing

Five elements:

- The whole array: not increasing

So, total increasing subsequences: 1 (empty) + 5 (single) + 5 (double) + 2 (triple) = 13.

Yes, that makes sense now. I missed the third single [2] from position 5 earlier.

Okay, so the problem is to find an array of at most 200 elements such that the number of increasing subsequences is exactly X.

First, I need to find a way to construct such an array for a given X.

I need to think about how the number of increasing subsequences can be calculated.

Let me think about the properties of the array that affect the number of increasing subsequences.

One thing I notice is that if the array is strictly increasing, then the number of increasing subsequences is 2^n, where n is the length of the array, because every subset is an increasing subsequence.

But in this problem, the array doesn't have to be strictly increasing; only the subsequences need to be strictly increasing.

Also, the problem allows elements to be equal, but in that case, subsequences with the same values but different positions are considered different.

So, in the earlier example, [2,2,3,4,2], which has 13 increasing subsequences.

I need to find a general way to construct an array that achieves exactly X increasing subsequences.

Given that X can be up to 10^18, and t=1000, I need an efficient way to construct such arrays.

First, I need to understand how the number of increasing subsequences is related to the array's structure.

Let me consider building the array step by step and see how the number of increasing subsequences changes as I add elements.

Suppose I start with an empty array; it has exactly 1 increasing subsequence, which is the empty subsequence.

If I add one element, say 'a', then the increasing subsequences are:

- Empty

- [a]

Total: 2.

If I add another element 'b':

- If b > a, then the increasing subsequences are:

- Empty

- [a]

- [b]

- [a,b]

Total: 4.

- If b < a, then:

- Empty

- [a]

- [b]

Total: 3.

- If b == a, then:

- Empty

- [a]

- [b] (different positions)

Total: 3.

Wait, but according to the problem, if b == a, then [a,b] is not increasing, so it's not counted.

So, in this case, with b == a, we have:

- Empty

- [a]

- [b]

Total: 3.

Similarly, if b > a, we have 4.

If b < a, we have 3.

So, adding an element can increase the number of increasing subsequences in different ways depending on its value relative to the previous elements.

I need to find a way to add elements in such a way that the total number of increasing subsequences reaches exactly X.

Given that X can be up to 10^18, I need an efficient method, probably based on some mathematical formula or binary representation.

Let me think about binary representation.

In binary, each bit represents a power of 2, and any number can be represented as a sum of distinct powers of 2.

But in this problem, the number of increasing subsequences isn't necessarily a sum of powers of 2, unless the array is strictly increasing.

Wait, if the array is strictly increasing, the number of increasing subsequences is 2^n, which is a sum of powers of 2.

But in general, it's not necessarily a power of 2.

In the earlier example, for [0], it's 2; for [0,1,0], it's 5; for [2,2,3,4,2], it's 13.

Notice that 2 = 2, 5 = 2^2 + 1, 13 = 2^3 + 2^2 + 1.

Hmm, not sure if that helps.

Wait, perhaps I can think of the array as a sequence of chains, where each chain is a strictly increasing subsequence.

But that might not directly help.

Another approach: perhaps model this using binary decisions.

Wait, perhaps think in terms of binary trees or something similar.

Wait, maybe I should look for a way to represent X in terms of the contributions of each element to the total number of increasing subsequences.

Let me consider the contribution of each element to the total count.

Each element can be either included or not in an increasing subsequence.

But because the subsequences must be increasing, the inclusion depends on the previous elements.

This seems complicated.

Let me consider building the array in a specific way.

Suppose I build the array such that it has a certain structure that allows me to control the number of increasing subsequences easily.

One idea is to build a array that consists of a sequence of decreasing blocks.

Wait, perhaps it's better to think in terms of the minimal elements.

Wait, perhaps I can use the concept of the minimal number of elements needed to achieve a certain number of increasing subsequences.

But that might not be straightforward.

Let me consider the following approach:

- Start with an empty array, which has 1 increasing subsequence (the empty subsequence).

- Add elements one by one, each time choosing the value such that it maximizes or minimizes the increase in the number of increasing subsequences, depending on what's needed to reach X.

But this seems too vague.

Let me think differently.

Suppose I have an array A with n elements, and I want to add a new element x.

How does this affect the number of increasing subsequences?

The new increasing subsequences will be:

- All the previous increasing subsequences.

- All the previous increasing subsequences that can have x appended to them, provided x is larger than the last element of those subsequences.

So, the increase in the number of increasing subsequences is equal to the number of increasing subsequences whose last element is less than x.

In particular, if x is smaller than all previous elements, then no previous subsequence can have x appended, so the number of increasing subsequences remains the same as before, plus the new single element [x].

Similarly, if x is larger than all previous elements, then all previous increasing subsequences can have x appended, so the increase is equal to the total number of increasing subsequences before, plus the new single element [x].

Wait, no.

Wait, if x is larger than all previous elements, then all previous increasing subsequences can have x appended to them, so the increase is equal to the number of previous increasing subsequences, and plus the new single element [x].

So, total increasing subsequences after adding x is:

- Previous count + previous count + 1 = 2 * previous count + 1.

Wait, but that doesn't seem right.

Wait, let's see:

- Previous increasing subsequences: S

- New increasing subsequences: S where you append x to each, plus [x]

- So, total: S + S + 1 = 2*S + 1.

Wait, but in the earlier example, starting with [0], which has 2 increasing subsequences (empty and [0]), adding 1 gives [0,1], which should have 4 increasing subsequences: empty, [0], [1], [0,1].

So, previous count is 2, new count is 2 (append 1 to empty and to [0]), plus [1], so total is 4.

So, in this case, it's previous count * 2 - not previous count * 2 + 1.

Wait, in this case, 2 * 2 = 4, which matches.

Wait, in general, if x is larger than all previous elements, then the number of new increasing subsequences is equal to the previous count (since all previous subsequences can have x appended), plus the new single element [x].

But in the [0,1] example, previous count is 2, new subsequences are [0,1] and [1], which is 2 + 1 = 3, plus the previous ones, total 4.

Wait, but 2 * previous count is 4, which matches.

Wait, hold on.

Wait, perhaps it's previous count * 2 - number of previous single element subsequences.

Wait, in [0], previous count is 2 (empty and [0]).

Adding 1:

- Previous subsequences: empty, [0]

- New subsequences: [1], [0,1]

- Total: 4

So, it's previous count + number of previous subsequences where the last element is less than x.

In this case, since x=1 > 0, so number of previous subsequences where last element < 1 is 1 ([0]), plus the new single element [1], so increase is 1 + 1 = 2, total 4.

Wait, but in general, if x > all previous elements, then the number of previous subsequences where the last element < x is equal to the number of previous subsequences where the last element is any previous element, which is previous count - 1 (excluding the empty subsequence).

Wait, no.

Wait, in the [0,1] example, previous count is 2 (empty and [0]), number of previous subsequences where last element < 1 is only [0], because empty subsequence has no last element.

Wait, perhaps I need to consider only the subsequences that can have x appended, which are those whose last element < x.

So, in [0], adding 1:

- Subsequences that can have 1 appended: [0]

- So, new subsequences: [0,1]

- Plus the new single element [1]

- So, increase is 1 ( [0,1] ) + 1 ( [1] ) = 2

- Total: 2 + 2 = 4.

Similarly, in [0,1], adding 2:

- Subsequences that can have 2 appended: [0,1], [0], [1]

- So, new subsequences: [0,1,2], [0,2], [1,2]

- Plus the new single element [2]

- Increase: 3 + 1 = 4

- Total: 4 + 4 = 8.

Wait, but in the earlier example, [1,2,3] has 8 increasing subsequences, which matches.

So, in general, when adding an element x, the increase in the number of increasing subsequences is equal to the number of previous subsequences whose last element is less than x, plus one for the new single element [x].

But, how do I count the number of previous subsequences whose last element is less than x?

This seems tricky.

Alternatively, perhaps I can think in terms of dynamic programming, where I keep track of the number of increasing subsequences ending with each element.

But that might be too slow for large X.

Given that X can be up to 10^18, I need a smarter way.

Let me consider building the array in a way that allows me to control the number of increasing subsequences in a binary-like fashion.

Wait, perhaps I can think of the array as a binary tree, where each level corresponds to adding a new element, and the branches correspond to including or not including that element in the subsequence.

But in this case, the subsequences must be increasing, so it's not a simple binary tree.

Wait, maybe I can model this using exponents.

Wait, let's consider that in a strictly increasing array, the number of increasing subsequences is 2^n.

But in this problem, the array doesn't have to be strictly increasing.

So, perhaps I can build the array in such a way that groups of elements contribute specific amounts to the total count.

Wait, perhaps I can use the fact that adding an element that is larger than all previous elements doubles the number of increasing subsequences, plus one for the new single element.

Wait, in the [0,1] example, adding 2 to [0,1] should double the number of increasing subsequences (from 4 to 8), which matches.

Similarly, adding an element that is smaller than all previous elements would only add one new subsequence, the single element itself.

Wait, in [0,1], adding -1:

- Previous subsequences: empty, [0], [1], [0,1]

- New subsequences: [-1], [0,-1], [1,-1], [0,1,-1]

- But [0,-1], [1,-1], [0,1,-1] are not increasing, so invalid.

- So, only the new single element [-1]

- Total increasing subsequences: 4 (previous) + 1 (new) = 5.

Wait, but according to earlier examples, for X=5, the array is [0,1,0], which has 5 increasing subsequences.

Wait, but in my calculation above, [0,1,-1] would have only 5 increasing subsequences.

Wait, perhaps I need to choose elements carefully to control the count.

Let me consider building the array by choosing elements that are either larger than all previous elements or smaller than all previous elements.

If I add an element larger than all previous elements, the number of increasing subsequences doubles plus one.

If I add an element smaller than all previous elements, the number of increasing subsequences increases by one.

So, if I denote:

- S: current number of increasing subsequences

- Adding a large element: S_new = 2*S + 1

- Adding a small element: S_new = S + 1

Then, I can think of building the array by choosing to add either a large or small element at each step.

My goal is to reach exactly X increasing subsequences.

So, I can think of this as a binary-like process, where adding a large element corresponds to a '0' bit, and adding a small element corresponds to a '1' bit, in the binary representation of X.

Wait, perhaps not directly.

Let me see.

If I start with S=1 (empty subsequence), and I want to reach X.

At each step, I can choose to add a large element (S -> 2*S + 1) or a small element (S -> S + 1).

I need to find a sequence of additions that leads from S=1 to S=X, using at most 200 steps.

Given that X can be up to 10^18, and 2^60 is about 10^18, so 60 bits should suffice, but since each 'large' addition effectively multiplies by 2 and adds 1, it's not a simple binary increment.

Let me try to model this.

Let me consider the operations:

- Operation A: S -> 2*S + 1

- Operation B: S -> S + 1

I need to find a sequence of these operations that transforms S=1 into S=X.

I need to find the sequence with the minimal number of operations, but since the constraint is at most 200 operations, and 200 is a large number, perhaps any sequence within 200 operations is acceptable.

But to minimize the array length, I should minimize the number of operations.

So, I need to find the minimal number of operations to reach X from 1 using operations A and B.

Let me think recursively.

Suppose I am at S and I want to reach X.

Option 1: Use operation B, so S -> S + 1, then continue to reach X - 1.

Option 2: Use operation A, so S -> 2*S + 1, then continue to reach X - 2*S - 1.

Wait, no.

Wait, if I do S -> 2*S + 1, then to reach X, I need 2*S + 1 = X.

So, S = (X - 1)/2.

But only if X is odd, since 2*S + 1 is always odd.

So, operation A can only be applied if X is odd, and it corresponds to S = (X - 1)/2.

Operation B can be applied anytime, moving from S to S + 1.

So, I can think of this as working backwards from X to 1.

At each step, if X is odd, I can apply operation A (S -> (X - 1)/2), else apply operation B (S -> X - 1).

Wait, no.

Wait, if X is odd, then I can apply operation A, which corresponds to S = (X - 1)/2.

If X is even, I can only apply operation B, which corresponds to S = X - 1.

Wait, but if X is even, S -> S + 1 = X, which is even, so S = X - 1.

But in that case, S -> S + 1 = X.

Wait, perhaps I need to think differently.

Let me try to work backwards.

Start from X, and see how to reach 1.

At each step:

- If X is odd, then the previous state must have been (X - 1)/2, and the last operation was A.

- If X is even, then the previous state must have been X - 1, and the last operation was B.

Wait, but let's check this.

Suppose X=5.

- 5 is odd, so previous state is (5-1)/2=2, operation A.

- 2 is even, so previous state is 2-1=1, operation B.

So, sequence: B, A.

Meaning, start with S=1, apply B: S=2, then apply A: S=2*2 + 1=5.

Similarly, for X=13.

- 13 is odd, previous state (13-1)/2=6, operation A.

- 6 is even, previous state 6-1=5, operation B.

- 5 is odd, previous state (5-1)/2=2, operation A.

- 2 is even, previous state 2-1=1, operation B.

So, sequence: B, A, B, A.

Starting from S=1, apply B: S=2, apply A: S=5, apply B: S=6, apply A: S=13.

Similarly, for X=2.

- 2 is even, previous state 2-1=1, operation B.

So, sequence: B.

Starting from S=1, apply B: S=2.

For X=3.

- 3 is odd, previous state (3-1)/2=1, operation A.

So, sequence: A.

Starting from S=1, apply A: S=3.

This seems to work.

So, in general, to reach X, I can work backwards using the operations:

- If X is odd, apply A (S=(X-1)/2)

- If X is even, apply B (S=X-1)

Until I reach S=1.

Then, the sequence of operations in reverse order will give me the sequence to reach from 1 to X.

This seems promising.

Now, I need to translate this into constructing the array.

Each operation A corresponds to adding a large element (doubling the number of increasing subsequences and adding one), and operation B corresponds to adding a small element (adding one to the number of increasing subsequences).

So, I can start with an empty array (S=1), and apply the sequence of operations to build the array.

But I need to ensure that the array has at most 200 elements.

Given that each operation adds one element to the array, the total number of operations should be at most 200.

Given that X can be up to 10^18, and each operation A roughly doubles the number of increasing subsequences, I think 200 operations should be sufficient.

Now, I need to implement this construction.

Let me think about how to assign values to the elements based on whether I'm performing operation A or B.

Suppose I keep track of the current minimum and maximum values in the array.

For operation A (adding a large element), I need to add an element larger than all previous elements.

For operation B (adding a small element), I need to add an element smaller than all previous elements.

This way, I can control the number of increasing subsequences accordingly.

Let me initialize:

- min_val = some large negative number, say -1e9

- max_val = some large positive number, say 1e9

- array starts empty, S=1

Then, for each operation:

- If operation is A, add max_val to the array, then set max_val -= 1 (to ensure it's larger than previous elements)

- If operation is B, add min_val to the array, then set min_val += 1 (to ensure it's smaller than previous elements)

Wait, no.

If I add a large element, it should be larger than all previous elements, so I should set it to max_val, then decrease max_val by 1 for the next large element.

Similarly, if I add a small element, it should be smaller than all previous elements, so I should set it to min_val, then increase min_val by 1 for the next small element.

Wait, but min_val should be the smallest possible, so perhaps I need to set min_val to some very small number and max_val to some very large number initially.

Let me set:

- min_val = -1e9

- max_val = 1e9

Then, for each operation:

- If operation is A (add large element):

- Add max_val to the array

- Set max_val -= 1

- If operation is B (add small element):

- Add min_val to the array

- Set min_val += 1

This should ensure that large elements are strictly decreasing, and small elements are strictly increasing.

Wait, but in terms of the array, large elements are larger than all previous, and small elements are smaller than all previous.

This should maintain the necessary properties for the number of increasing subsequences.

Let me test this with X=5.

Sequence: B, A

- Start with S=1, min_val=-1e9, max_val=1e9

- Operation B: add min_val (-1e9), set min_val +=1 -> -1e9 +1

- Now, array: [-1e9], S=2

- Operation A: add max_val (1e9), set max_val -=1 -> 1e9 -1

- Now, array: [-1e9, 1e9], S=5

Yes, according to earlier calculations, this should have 5 increasing subsequences.

Similarly, for X=3:

Sequence: A

- Start with S=1, min_val=-1e9, max_val=1e9

- Operation A: add max_val (1e9), set max_val -=1 -> 1e9 -1

- Now, array: [1e9], S=3

Which should have 3 increasing subsequences: empty, [1e9], and [1e9].

Wait, but [1e9] is only one subsequence, right?

Wait, no, if there's only one element, it's [1e9], which is one subsequence, plus empty, total 2.

Wait, but according to the earlier reasoning, operation A should lead to S=3.

Wait, perhaps there's a mistake here.

Wait, perhaps I need to adjust the initial S.

Wait, starting with S=1 (empty), add a large element: S=2*S +1=3.

So, array [large], S=3.

But in reality, array with one element has 2 increasing subsequences: empty and [large].

But according to the operation A, S=2*S +1=3.

So, there's a discrepancy here.

Wait, perhaps my understanding of operation A is incorrect.

Wait, perhaps operation A corresponds to adding an element larger than all previous, which should double the number of increasing subsequences plus one.

Wait, in the [large] example, previous S=1, operation A: S=2*1 +1=3, but in reality, the array [large] has 2 increasing subsequences.

There's a mismatch here.

So, perhaps my initial assumption is wrong.

Wait, perhaps operation A corresponds to adding an element larger than all previous, which should make S=2*S, not 2*S +1.

Wait, in the [large] example, S=2*S=2, which matches the reality.

Wait, but earlier, in [0,1], adding 2 should make S=2*S=4, but according to previous calculations, it's 2*S +1=5, which doesn't match.

Wait, perhaps I need to rethink the operations.

Let me recast the operations.

Let me consider that