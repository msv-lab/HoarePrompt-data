Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find an array of integers, with at most 200 elements, such that the number of increasing subsequences in it is exactly X, where X can be up to 10^18. If it's not possible, I should output -1. There are multiple test cases, up to 1000 of them.

First, I need to understand what an increasing subsequence is. From the problem statement, it's a sequence obtained by removing some elements from the array without changing the order, and the remaining elements are strictly increasing. Also, different positions can have the same values, but they are considered different subsequences if their positions differ.

So, for example, in the array [0, 1, 0], the increasing subsequences are:

- Empty subsequence

- [0] (first element)

- [0] (third element)

- [1]

- [0,1] (first and second elements)

That's 5 subsequences, which matches the second example in the problem.

Another example: [2,2,3,4,2]. The increasing subsequences would include:

- Empty

- [2] (first)

- [2] (second)

- [3]

- [4]

- [2] (fifth)

- [2,3] (first and third)

- [2,4] (first and fourth)

- [2,3] (second and third)

- [2,4] (second and fourth)

- [2,3,4] (first, third, and fourth)

- [2,3,4] (second, third, and fourth)

- And so on, totaling 13 subsequences, as per the third example.

Okay, so the goal is to construct an array with exactly X increasing subsequences.

Constraints:

- Array length ≤ 200

- Elements in the range [-1e9, 1e9]

- t ≤ 1000 test cases

- X can be up to 1e18

Given that t can be up to 1000 and X up to 1e18, efficiency is key.

First, I need a way to calculate the number of increasing subsequences for a given array. But since X can be up to 1e18, I need a smart way to construct the array without iterating through all possible subsequences, which would be too slow.

I recall that in a sequence where each element is strictly increasing, the number of increasing subsequences is 2^n - 1, where n is the length of the sequence, since every non-empty subset is an increasing subsequence.

But in this problem, the array doesn't have to be strictly increasing; it can have equal elements or even decreasing elements, as long as the subsequences are increasing.

Wait, but the problem allows equal elements, and they are considered different if their positions differ.

So, for example, in [0,1,0], there are two different subsequences [0], one from the first element and one from the third.

In [2,2,3,4,2], there are multiple [2]'s in different positions.

So, the total number of increasing subsequences is not just 2^n - 1, because some subsequences may not be strictly increasing.

I need a way to calculate the number of increasing subsequences for a given array.

I think I can use dynamic programming for this.

Let me think about it.

Define dp[i] as the number of increasing subsequences ending with the i-th element.

Then, dp[i] = 1 + sum(dp[j] for all j < i where a[j] < a[i])

The total number of increasing subsequences is sum(dp[i] for all i)

But this would be O(n^2), and with n up to 200 and t up to 1000, it's manageable, but I need to construct the array, not calculate for a given one.

Wait, but constructing the array is the challenge here.

I need to find an array where the total number of increasing subsequences is exactly X.

Given that X can be up to 1e18, and n is at most 200, I need to find a way to represent X in terms of the possible subsequences.

I need to find a way to maximize or minimize the number of increasing subsequences for a given n.

Wait, perhaps I can think in terms of binary representation.

If I have an array where elements are strictly increasing, then the number of increasing subsequences is 2^n - 1.

But X can be up to 1e18, and 2^60 is already over 1e18, but n is limited to 200, which is way more than 60.

But 2^60 is approximately 1.2e18, which is larger than 1e18, so I need to be careful with the exponents.

Wait, perhaps I can use a combination of increasing and non-increasing elements to adjust the total count.

Let me consider a simpler case.

Suppose I have an array with all elements equal, say [1,1,1,...,1].

Then, the only increasing subsequences are the singletons [1], because any subsequence with more elements cannot be strictly increasing.

So, the total number of increasing subsequences is n.

Similarly, if the array is strictly increasing, like [1,2,3,...,n], the number of increasing subsequences is 2^n - 1.

If I have some elements equal and some increasing, the count will be somewhere in between.

I need a way to combine these to reach exactly X.

Wait, perhaps I can think of it in terms of binary representation.

If I have elements that are strictly increasing, each new element doubles the number of possible subsequences (adding new subsequences that include the new element).

But with equal elements, I can add additional subsequences.

Wait, maybe I need to think in terms of bits.

Let me consider constructing the array such that certain positions correspond to powers of two.

For example, if I have positions where elements are strictly increasing, each new element adds a new power of two to the total count.

But I need to be able to represent X as a sum of certain counts.

Wait, perhaps I can use the binary representation of X.

Let's say X is represented in binary as b_k b_{k-1} ... b0.

Then, X = sum over i where b_i == 1 of 2^i.

So, perhaps I can construct the array such that certain positions contribute 2^i to the total count.

But I need to make sure that the contributions are additive, which they are because the subsequences are distinct.

Wait, but in reality, the total number of increasing subsequences is sum over i of dp[i], where dp[i] is the number of increasing subsequences ending with the i-th element.

I need a way to make these dp[i] values such that their sum is exactly X.

This seems tricky.

Let me consider another approach.

Suppose I build the array step by step, and at each step, decide whether to add a new element that is larger than all previous elements or equal to some previous elements.

If I add an element larger than all previous elements, it will double the number of increasing subsequences, because for each existing subsequence, I can choose to include this new element or not.

Wait, actually, adding a new largest element will double the number of increasing subsequences, because for each existing subsequence, I can append the new element to it, and all these new subsequences will be increasing.

So, if I have an array with n elements and m increasing subsequences, adding a new element larger than all previous ones will result in 2m increasing subsequences.

Similarly, adding an element equal to some previous elements will add some new subsequences, but not double the count.

Wait, let's think carefully.

If I add a new element that is larger than all previous elements, then for each existing subsequence, I can choose to include it or not, but including it will always keep the subsequence increasing.

So, the total number of increasing subsequences becomes twice the original number.

Wait, but actually, it's more than that, because the new element can also be included in any subsequence that didn't include any element after a certain point.

Wait, maybe I need to formalize this.

Let me denote that if I have an array A of length n with s increasing subsequences, and I add a new element x that is larger than all elements in A, then the number of new increasing subsequences is s, because for each existing subsequence, I can append x to it.

So, the total number becomes s (original) + s (new ones with x appended) = 2s.

Wait, but actually, I can also have subsequences that consist only of x, so maybe it's s (original) + s (with x appended) + 1 (just x), so total s + s + 1 = 2s + 1.

But in the strictly increasing case, the total should be 2^{n+1} - 1, which for n=0 is 0, n=1 is 1, n=2 is 3, n=3 is 7, etc.

Wait, perhaps my earlier assumption is incorrect.

Let me verify with n=1: array [1], number of increasing subsequences is 1 (only [1]).

Add a new element 2: array [1,2], subsequences are [1], [2], [1,2], total 3, which is 2^2 - 1 = 3.

So, from n=1 to n=2, subsequences go from 1 to 3, which is 2*1 +1.

Wait, 2*s +1 matches this.

Similarly, from n=2 to n=3, subsequences go from 3 to 7, which is 2*3 +1.

Yes, that seems consistent.

So, adding a new largest element multiplies the number of subsequences by 2 and adds 1 (the new single element subsequence).

Similarly, adding an element equal to some previous elements would add some new subsequences.

But perhaps I can think in terms of binary representation.

If I consider the binary representation of X, I can try to build the array by choosing to add larger elements when I need to double the number of subsequences, and add equal elements when I need to add a certain amount.

Wait, perhaps I can build the array from the least significant bit to the most significant bit.

Let's consider X in binary.

Each bit in X corresponds to a power of two.

I can try to build the array by starting with the least significant bit and adding elements accordingly.

Wait, maybe I should think recursively.

Suppose I have X, and I want to build an array for it.

If X is 1, then an empty array suffices, but since the array must have at least one element, perhaps I need to handle X=1 differently.

But the problem states X >=2, so X=1 is not considered.

Wait, in the problem, X starts from 2.

So, for X=2, I can have an array with one element, since the number of increasing subsequences is 1 (the single element), but X=2 requires two subsequences, which would include the empty subsequence and the single element subsequence.

Wait, but the problem considers only non-empty subsequences, as in the example with X=2, the array has one element, which corresponds to one subsequence, but X=2 seems to include the empty subsequence.

Wait, let's check the problem statement again.

"Note that an empty subsequence is also increasing."

And in the example for X=2, the array has one element, which should have two subsequences: empty and the single element.

Wait, but according to the problem, the array of length 1 has two increasing subsequences: empty and the single element.

But in the problem statement, for X=2, the array has one element.

Wait, but in the problem statement, it says "the array of length at most 200", and "has exactly X increasing subsequences", considering that "an empty subsequence is also increasing".

So, for X=2, the array has one element, with subsequences: empty and the single element.

For X=5, the array has three elements: 0,1,0, with subsequences: empty, [0](first), [0](third), [1], [0,1].

That's five subsequences.

Wait, but in binary, 5 is 101, which is 1*2^2 + 0*2^1 + 1*2^0.

Not sure if that helps.

Wait, perhaps I can think of building the array by choosing to add elements in a way that corresponds to the binary representation of X.

Wait, perhaps I need to consider that each time I add a new largest element, I double the number of subsequences and add one.

Wait, from earlier, adding a new largest element multiplies the number of subsequences by 2 and adds 1.

Wait, let's formalize this.

Let me denote that if I have s increasing subsequences with n elements, and I add a new element larger than all previous ones, the new number of increasing subsequences is 2*s +1.

Because for each existing subsequence, I can choose to append the new element or not, and also the new single element subsequence.

Wait, but in the earlier example, with n=1, s=1 (only [1]), adding a new larger element 2, gives s=3 ([1], [2], [1,2]).

Which is 2*1 +1=3.

Similarly, adding another larger element 3 would give 2*3 +1=7 subsequences.

This seems consistent.

So, if I denote s_new = 2*s +1 when adding a new largest element.

Similarly, if I add an element that is equal to some previous elements, it might add a different amount to s.

Wait, let's see.

Suppose I have array [1,2], s=3.

If I add another 2, making it [1,2,2], what are the increasing subsequences?

- Empty

- [1]

- [2] (first)

- [2] (third)

- [1,2] (first and second)

- [1,2] (first and third)

- [2,2] (second and third), but [2,2] is not strictly increasing, so it's invalid.

So, only the first three and the two [1,2]'s.

Total s=5, which is 3 (previous) +2.

But 2 is the number of elements equal to the new element that are before it.

Wait, in general, if I add an element equal to some previous elements, say k previous elements are equal to it, then the new subsequences added are those that end with any of those k elements, plus the new single element.

So, s_new = s + k +1.

Wait, but in the example above, k=1 (only one previous 2), so s_new =3 +1 +1=5, which matches.

Yes.

So, in general:

- If I add a new largest element, s_new = 2*s +1.

- If I add an element equal to k previous elements, s_new = s + k +1.

My goal is to reach exactly X increasing subsequences.

Given that, I can try to build the array step by step, choosing to add either a new largest element or an element equal to some previous ones, to reach X.

But with X up to 1e18, I need an efficient way to do this.

Let me consider starting from s=1 (empty subsequence) and build up to X.

Wait, but in the problem, for X=2, s=2 (empty and one element).

So, perhaps it's better to think in terms of s+1, where s is the number of non-empty increasing subsequences.

Wait, no, the problem considers the empty subsequence as well, so s=X.

Wait, in the example, X=2 corresponds to s=2 (empty and one element).

With n=1, s=2.

With n=3, s=5.

Wait, but in general, s=2^n, but that's only if all elements are equal.

Wait, no, if all elements are equal, s=n (only single elements), since subsequences with more elements are not strictly increasing.

Wait, perhaps I need to think differently.

Let me consider that s is the number of increasing subsequences, including the empty one.

So, s = number of increasing subsequences, including empty.

Our target is to make s == X.

Operations:

- Add a new largest element: s = 2*s +1.

- Add an element equal to k previous elements: s = s + k +1.

I need to find a sequence of these operations to reach s == X.

I need to find the minimal n (length of array) to reach s == X.

But since n is at most 200, and X can be up to 1e18, it's feasible.

Wait, but I need to find any array with n <=200 that achieves s == X.

If I start with s=1 (empty subsequence), and perform operations to reach s==X.

Each operation corresponds to adding an element to the array.

I need to choose whether to add a new largest element or add an element equal to some previous ones.

Let me try to work backwards.

Suppose I have s == X, and I want to see if I can reach it.

From s, I can either:

- Come from s_prev, where s = 2*s_prev +1, meaning I added a new largest element.

- Or, s = s_prev + k +1, where k is the number of previous elements equal to the new one.

But k depends on the previous array.

This seems complicated.

Perhaps I can limit the number of equal elements.

Wait, maybe I can fix the array to be non-decreasing, which might simplify things.

If the array is non-decreasing, then the number of increasing subsequences is the sum of binomial coefficients, which is 2^n -1, but including empty subsequence, it's 2^n.

But in the problem, it's strictly increasing, so it's different.

Wait, no, the problem allows non-strictly increasing subsequences, since equal elements are allowed in the array, but the subsequences must be strictly increasing.

So, equal elements in the array can be part of different subsequences, but not in the same subsequence.

Wait, no, equal elements can be in different positions, but in a subsequence, if you have two equal elements, the subsequence cannot be strictly increasing.

So, in the array, equal elements can be present, but in a subsequence, you can choose at most one of them.

Wait, but in the problem statement, it's strictly increasing subsequences.

So, in a subsequence, all elements must be strictly increasing.

Therefore, in a subsequence, you cannot have two equal elements.

So, when building the array, if I have multiple elements with the same value, they can be part of different subsequences, but only one can be chosen in each subsequence.

This complicates things.

Let me try to find a way to calculate s for a given array.

Let me use dynamic programming.

Define dp[i] as the number of increasing subsequences ending with the i-th element.

Then, s = sum(dp[i] for all i) +1 (for the empty subsequence).

To compute dp[i], dp[i] = 1 + sum(dp[j] for all j < i where a[j] < a[i]).

Wait, but this is O(n^2), which is too slow for n=200 and t=1000.

I need a smarter way.

Perhaps I can consider that if I have a sorted array, I can keep track of the number of times each value appears.

Wait, but the array doesn't have to be sorted.

Wait, maybe I can sort the array and keep track of the frequencies.

But I need to maintain the order.

This seems tricky.

Let me consider another approach.

Suppose I build the array by adding elements one by one, and keep track of the current s.

At each step, I can choose to add a new largest element, which sets s = 2*s +1.

Or, I can choose to add an element equal to some previous element.

But in this case, s increases by the number of previous elements equal to it plus one.

Wait, in the earlier example, when adding an element equal to k previous elements, s increases by k +1.

So, s_new = s + k +1.

I need to find a sequence of operations to reach s == X.

I can try to work backwards.

Start from s == X, and try to find a sequence of operations that lead back to s ==1.

At each step, I can:

- If s is odd, and s-1 is divisible by 2, then I could have come from s_prev = (s-1)/2 by adding a new largest element.

- Or, if s - s_prev - k -1 ==0 for some k, but k depends on the previous array, which is unknown.

This seems messy.

Perhaps I can limit the number of equal elements.

Suppose I build the array such that each element is either a new largest element or equal to the smallest existing element.

This might simplify things.

Let me try.

Define:

- Adding a new largest element: s = 2*s +1.

- Adding an element equal to the smallest existing element: s = s + m +1, where m is the number of elements equal to the smallest element.

Wait, in this case, m is the number of elements equal to the smallest element.

But this still seems complicated.

Let me consider using only two types of operations:

1. Add a new largest element.

2. Add an element equal to the smallest existing element.

Let me see.

Suppose I have s=1 (empty).

Add a new largest element: s=2*1 +1=3.

Add a new largest element: s=2*3 +1=7.

Add an element equal to the smallest (which is the first element): s=7 +1 +1=9.

Wait, in this case, adding an element equal to the smallest adds m+1, where m is the number of smallest elements.

If I have one smallest element, adding another equal to it adds 1+1=2 to s.

So, s=7 +2=9.

Then, adding a new largest element: s=2*9 +1=19.

And so on.

This way, I can build up s step by step.

But it's not clear how to generalize this to reach any X.

Perhaps I can think in terms of binary representation again.

If I keep adding new largest elements, s becomes 2*s +1, which is like shifting left and adding 1 in binary.

Wait, let's see:

Start with s=1.

Add a new largest element: s=2*1 +1=3, which is 11 in binary.

Add a new largest element: s=2*3 +1=7, which is 111 in binary.

Add a new largest element: s=2*7 +1=15, which is 1111 in binary.

And so on.

So, by repeatedly adding new largest elements, s becomes all 1's in binary.

If I add an element equal to some previous elements, it adds a certain amount to s, which depends on k.

This seems like a way to set specific bits in s.

Wait, perhaps I can think of s in binary, and decide which operations to perform based on the bits of X.

Let me try to work on an example.

Take X=5, which is 101 in binary.

I need to reach s=5.

Start with s=1.

If I add a new largest element, s=3 (11 in binary).

Then, if I add an element equal to some previous elements, how does s change?

Suppose I add an element equal to the smallest existing element.

If the array is [a,b], where b > a, and I add another a, then k=1 (one previous a), so s_new = s +1 +1=5.

So, s=3 +2=5.

Perfect, that matches the second example in the problem.

So, in this case:

- Start with s=1.

- Add a new largest element: s=3.

- Add an element equal to the smallest existing element: s=5.

So, the array would be [a,b,a], where b > a.

In the example, [0,1,0], which fits.

Similarly, for X=13, which is 1101 in binary.

Start with s=1.

Add a new largest element: s=3.

Add a new largest element: s=7.

Add an element equal to the smallest existing element: s=7 +1 +1=9.

Add a new largest element: s=2*9 +1=19.

But 19 is larger than 13, so this doesn't work.

Wait, maybe I need to choose differently.

Alternatively, perhaps I need to work backwards.

Start from s=X, and see how it can be decomposed.

If s is odd, it could have come from (s-1)/2 by adding a new largest element.

If s is even, it's not clear.

Wait, s_new = 2*s_prev +1, so s_prev = (s_new -1)/2.

So, if s is odd and (s-1)/2 is an integer, then it could have come from s_prev=(s-1)/2 by adding a new largest element.

Alternatively, if s - s_prev - k -1 =0 for some k, but k is unknown.

This seems tricky.

Perhaps I can build the array by considering the binary representation of X.

Let me consider that adding a new largest element corresponds to multiplying s by 2 and adding 1, which is like appending a '1' in binary.

Adding an element equal to some previous elements corresponds to adding a certain value based on k.

Wait, maybe I can think of it in terms of binary digits.

Let me consider that each time I add a new largest element, I'm effectively setting another bit in s.

For example, starting from s=1 (1 in binary).

Add a new largest element: s=3 (11 in binary).

Add a new largest element: s=7 (111 in binary).

Add a new largest element: s=15 (1111 in binary).

And so on.

If I want to set specific bits, I can add elements equal to some previous elements to adjust s accordingly.

Wait, perhaps I can prioritize adding new largest elements until s >=X, then adjust by adding elements equal to some previous elements to fine-tune s to exactly X.

But this might be too vague.

Let me try to formalize this.

Define a procedure:

Initialize s=1, array A empty.

While s < X:

If X <= 2*s +1:

Add an element equal to some previous elements to adjust s to X.

Else:

Add a new largest element: s = 2*s +1.

But how to choose which previous elements to equal when adding an element?

This seems unclear.

Wait, perhaps I can maintain a set of elements and keep track of how many times each value appears.

Then, when adding a new element equal to some value, I can compute k based on the frequency of that value.

But this might be too time-consuming.

Let me consider another approach.

Suppose I fix the array to be non-decreasing.

Then, the number of increasing subsequences can be calculated using combinatorics.

Wait, but in a non-decreasing array, the number of strictly increasing subsequences is the sum of the number of times each unique value appears, since subsequences with duplicate values are not strictly increasing.

Wait, no, in a non-decreasing array, strictly increasing subsequences are those where each new element is strictly larger than the previous one.

So, it's similar to choosing subsets where each subsequent element is strictly larger.

This seems complex.

Perhaps I need to look for a different strategy.

Let me consider that in order to maximize s for a given n, I should have all elements distinct and strictly increasing, giving s=2^n -1 +1 =2^n.

But X can be up to 1e18, and 2^60 is about 1.2e18, which is larger than 1e18, so n=60 is sufficient for X up to 1e18.

But the problem allows n up to 200, which is more than enough.

But I need to handle X up to 1e18 efficiently.

Wait, perhaps I can represent X in binary and build the array accordingly.

Let me consider that each bit in the binary representation of X corresponds to adding a new largest element or adding elements equal to existing ones.

Wait, perhaps I can think of it in terms of binary digits.

Let me try to build the array based on the binary representation of X.

Suppose X is represented as b_k b_{k-1} ... b0 in binary.

I can try to build the array by adding elements corresponding to each bit.

For example, starting with s=1.

If b0 ==1, add an element equal to some previous elements to add 1 to s.

If b1 ==1, add a new largest element to set s=2*s +1.

Wait, but this seems arbitrary.

Wait, perhaps I need to iterate through the bits from highest to lowest.

Let me try.

Start with s=1.

For each bit from the highest to the lowest:

If that bit is set in X, add a new largest element, which sets s=2*s +1.

Else, add an element equal to some previous elements to adjust s accordingly.

But I need to ensure that s reaches exactly X.

This seems tricky.

Let me try with X=5 (101 in binary).

Start with s=1.

High bit is 4 (b2=1):

Add a new largest element: s=2*1 +1=3.

Next bit is 2 (b1=0):

Since b1=0, add an element equal to some previous elements.

Suppose I add an element equal to the first element, k=1, so s=3 +1 +1=5.

Perfect, s=5.

Another example: X=13 (1101 in binary).

Start with s=1.

High bit is 8 (b3=1):

Add a new largest element: s=2*1 +1=3.

Next bit is 4 (b2=1):

Add a new largest element: s=2*3 +1=7.

Next bit is 2 (b1=0):

Add an element equal to some previous elements.

Choose to add an element equal to the first element, k=1: s=7 +1 +1=9.

Next bit is 1 (b0=1):

Add a new largest element: s=2*9 +1=19, which is larger than 13.

Oops, that doesn't work.

Alternative approach needed.

Perhaps I need to adjust when b_i ==0, I add an element equal to some previous elements to make up the difference.

But it's not clear how.

Let me consider another idea.

Suppose I build the array by choosing to add new largest elements when the corresponding bit in X is set, and add elements equal to the smallest existing element otherwise.

Wait, let's try with X=5 (101 in binary).

Start with s=1.

Add a new largest element (for b2=1): s=3.

Add an element equal to the smallest (for b1=0): s=3 +1 +1=5.

Perfect.

Another example: X=13 (1101 in binary).

Start with s=1.

Add a new largest element (for b3=1): s=3.

Add a new largest element (for b2=1): s=7.

Add an element equal to the smallest (for b1=0): s=7 +1 +1=9.

Add a new largest element (for b0=1): s=2*9 +1=19, which is larger than 13.

Not good.

Alternative approach: maybe I need to adjust the positions where I add equal elements.

Wait, perhaps I need to add equal elements in such a way that the s increases by the required amount to reach X.

In the previous example, after s=7, I need to reach s=13.

So, 13 -7=6.

If I add an element equal to k previous elements, s increases by k +1.

So, I need k +1 =6, thus k=5.

But in the array so far, if I have two elements, say [a,b], with b>a, then the number of previous elements equal to a is 1.

So, k=1, s_new=7 +1 +1=9, which is not enough.

Then, add another element equal to a: s_new=9 +1 +1=11.

Still not enough.

Add another element equal to a: s_new=11 +1 +1=13.

Now, s=13.

So, in total, I added three elements equal to a.

This works.

So, in this case:

- Start with s=1.

- Add a new largest element: s=3.

- Add a new largest element: s=7.

- Add three elements equal to a: s=7 +1+1=9, then 9+1+1=11, then 11+1+1=13.

So, the array would be [a,b,a,a,a].

But the problem allows n<=200, and X up to 1e18, so this seems feasible.

So, general approach:

- Start with s=1.

- For each bit in X from highest to lowest:

- If the bit is set, add a new largest element: s=2*s +1.

- Else, if s < X, add elements equal to the smallest existing element until s reaches X.

But in the previous example, after s=7, I needed to add three elements equal to a to reach s=13.

This seems workable, but I need to ensure that I don't exceed n=200.

Given that 2^60 is about 1.2e18, which is larger than 1e18, and n=60 would suffice for the bits, plus additional elements for adjusting s.

So, n=60 + some additional elements for adjusting s should be well within 200.

Now, I need to implement this logic.

Let me try to formalize the algorithm.

Initialize:

- s =1

- array A = []

For each bit from highest to lowest:

If the bit is set in X:

Add a new largest element to A:

Choose a value larger than any existing element, say max(A) +1.

Set s =2*s +1.

Else:

If s < X:

Determine how much to add to s to reach X.

Let delta = X - s.

Need to add elements equal to some previous elements to increase s by delta.

Each time I add an element equal to k previous elements, s increases by k +1.

So, I need to choose how many elements to add and which elements to equal.

To minimize n, I should choose k as large as possible.

The largest k is the frequency of the most frequent element.

But to simplify, I can choose to add elements equal to the smallest element, which has frequency f.

Then, each new element adds f +1 to s.

So, to add m elements equal to the smallest, s increases by m*(f +1).

I need m*(f +1) = delta.

So, m = delta / (f +1).

If delta is divisible by (f +1), then m = delta / (f +1).

Otherwise, it's not possible.

But in the previous example, s=7, X=13, delta=6, f=1, so m=6 /2=3.

Which is integer, so it works.

So, in general:

- If delta % (f +1) ==0, then m = delta / (f +1), and add m elements equal to the smallest.

- Else, it's not possible.

But I need to ensure that f +1 divides delta.

In the previous example, it worked.

Another example: s=9, X=14, delta=5, f=3 (suppose), then 5 % (3+1)=5%4=1 !=0, so not possible.

But in reality, f=3 means adding a new element equal to the smallest adds 3+1=4 to s.

So, to reach s=13 from s=9, delta=4, m=1.

Wait, s=9 +4=13.

So, m=1.

Yes, works.

So, in code, I need to keep track of the frequency of the smallest element.

But in practice, to make it simple, I can choose to add elements equal to the smallest element each time I need to add elements equal to some previous elements.

This way, I can calculate how many to add to reach the desired s.

Now, I need to implement this logic.

I need to represent the array A, keep track of s, and the frequency of the smallest element.

Let me try to write pseudocode.

Initialize:

A = []

s =1

f =0  # frequency of the smallest element

Define variables:

current_value = some initial value, say 0

smallest = current_value

For each bit from highest to lowest:

if bit is set:

add a new largest element to A:

A.append(current_value +1)

current_value +=1

s =2*s +1

f =1  # the new largest element has frequency 1

else:

if s < X:

delta = X - s

if delta % (f +1) ==0:

m = delta / (f +1)

for _ in range(m):

A.append(smallest)

s += f +1

else:

output -1

After processing all bits, output the array A.

Wait, but in the earlier example, when adding elements equal to the smallest, f increases.

Wait, in the first step, A=[], s=1, f=0.

Add a new largest element: A=[0], s=3, f=1.

Add a new largest element: A=[0,1], s=7, f=1.

Add elements equal to the smallest (0), m=3, A=[0,1,0,0,0], s=13.

This matches the third example in the problem.

So, it works.

In this case, when adding elements equal to the smallest, f remains the same because the smallest frequency increases, but in the calculation, m*(f +1) = delta.

So, f remains the same for each addition.

Wait, but actually, when I add an element equal to the smallest, f increases by 1.

Wait, in the first addition, A=[0,1,0], f=2.

Then, adding another 0, A=[0,1,0,0], f=3.

Then, adding another 0, A=[0,1,0,0,0], f=4.

But in the earlier calculation, m=3, and each time f increases.

Wait, perhaps I need to adjust the calculation.

Wait, perhaps it's better to calculate m = delta / (f +1), and then add m elements equal to the smallest, updating f each time.

Wait, but in the earlier example, m=3, and f=1 initially.

But after adding the first 0, f becomes 2, then adding another 0, f=3, and so on.

This seems messy.

Perhaps I need to recalculate f after each addition.

But this is inefficient.

An alternative approach is to choose to add elements equal to a value that has a frequency such that (f +1) divides delta.

But to simplify, I can choose to add elements equal to the smallest, and ensure that delta is divisible by (f +1).

If it is, then I can add m=delta / (f +1) elements equal to the smallest.

Then, update f accordingly.

In the earlier example, s=7, f=1, delta=6, m=3.

After adding 3 elements equal to the smallest, f becomes 1 +3=4.

But s=7 +3*(1 +1)=7 +6=13, which matches.

So, it works.

Hence, in code, I can keep track of f, and when adding elements equal to the smallest, update f accordingly.

Now, I need to implement this logic.

But I need to make sure that I don't exceed n=200.

Given that X can be up to 1e18, and each addition of a new largest element roughly doubles s, plus one, it should be manageable within n=200.

Now, I need to handle multiple test cases, up to t=1000.

To optimize, I need to make the construction efficient.

Let me outline the steps in code:

- Read t.

- For each test case:

- Read X.

- Initialize A = [], s =1, f =0, current_value = some initial value, say 0.

- For each bit from highest to lowest:

- If the bit is set in X:

- Add a new largest element to A: A.append(current_value +1), current_value +=1

- s =2*s +1

- f =1  # the new largest element has frequency 1

- Else:

- If s < X:

- delta = X - s

- if delta % (f +1) ==0:

- m = delta / (f +1)

- for _ in range(m):

- A.append(smallest)

- s += f +1

- f +=1  # since each addition increases the frequency of the smallest by 1

- Else:

- Output -1

- After processing all bits, output the array A, or -1 if impossible.

Wait, but in the earlier example, when adding elements equal to the smallest, f increases by 1 for each addition.

Wait, no, f is the frequency of the smallest element.

Initially, A=[0,1], f=1 (only one 0).

After adding one 0, A=[0,1,0], f=2.

Then, adding another 0, A=[0,1,0,0], f=3.

And so on.

So, f increases by 1 for each addition of the smallest element.

Hence, in code, f should be updated after each addition.

But in the calculation, m = delta / (f +1), assuming f is the frequency before adding.

Wait, perhaps I need to calculate m based on the initial f, and then update f accordingly.

Let me try with X=13, s=7, f=1.

delta=6, m=6 / (1 +1)=3.

Then, add 3 elements equal to the smallest.

After each addition:

- Add first 0: s=7 +1 +1=9, f=2

- Add second 0: s=9 +2 +1=12, f=3

- Add third 0: s=12 +3 +1=16, f=4

Wait, but 16 >13, which is not correct.

Wait, this contradicts the earlier calculation.

What's wrong here?

Wait, perhaps my understanding is incorrect.

Let me recast the dp.

dp[i] = number of increasing subsequences ending with a[i].

Then, s = sum(dp[i]).

If I add an element equal to a[j], where a[j] is the smallest, then for each subsequence ending with a[j], I can create a new subsequence by appending the new element, but since a[j] == new element, it's not strictly increasing, so no new subsequences are created.

Wait, but in the problem, subsequences must be strictly increasing, so adding an element equal to some previous element doesn't create new increasing subsequences.

Wait, that can't be right, because in earlier examples, adding equal elements did increase s.

Wait, perhaps I need to revisit the dp.

Let me define dp[i] as the number of increasing subsequences ending with a[i].

If I add a new element equal to a[j], then dp[new] = sum(dp[k] for k where a[k] < a[new]).

But since a[new] == a[j], and a[k] < a[j], then dp[new] = dp[j].

Wait, but in reality, dp[new] should be sum(dp[k] for k where a[k] < a[j]), but since a[new] == a[j], and a[k] < a[j], then dp[new] = sum(dp[k] for k where a[k] < a[j]).

But this seems complicated.

Perhaps I need to accept that calculating s for a given array is non-trivial, and focus on the construction approach.

Given the time constraints, I'll proceed with the earlier approach, assuming that adding m elements equal to the smallest, with each addition increasing s by f +1, where f is the frequency of the smallest before addition.

Then, m = delta /