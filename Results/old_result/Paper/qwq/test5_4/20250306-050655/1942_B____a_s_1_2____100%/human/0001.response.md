Alright, I've got this problem to solve. Let's see what it's asking for. So, Farmer John has a permutation p of numbers from 0 to n-1, and he gives Bessie an array a, where each a_i is defined as the MEX of the first i elements of p minus p_i. My job is to reconstruct p from a.

First, I need to understand what MEX means. MEX stands for "minimum excluded," which is the smallest non-negative integer not present in the given array up to that point. For example, MEX of [1,2,3] is 0 because 0 is the smallest non-negative integer not in the list. MEX of [3,1,0] is 2, since 0 and 1 are present, but 2 is not.

So, for each position i in the permutation p, a_i = MEX(p_1 to p_i) - p_i. I need to find p given a.

The problem says that there is at least one valid p for the given a, so I don't have to worry about invalid inputs.

Let me think about how to approach this. Since p is a permutation, each number from 0 to n-1 appears exactly once in p. That's important because it means p_i are all unique and cover the range from 0 to n-1.

I need to find a way to relate a_i back to p_i, given that a_i = MEX(p_1 to p_i) - p_i.

Let me try to express p_i in terms of a_i and MEX.

From a_i = MEX(p_1 to p_i) - p_i, I can write p_i = MEX(p_1 to p_i) - a_i.

So, p_i = MEX(p_1 to p_i) - a_i.

Hmm, that seems useful. But MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

I need to find a way to compute MEX(p_1 to p_i) for each i, but I don't know p yet.

This seems a bit circular. Maybe I need to find a way to break this circular dependency.

Let me consider the properties of MEX and how it changes as I add more elements to p.

For i=1, MEX(p_1) is the smallest non-negative integer not equal to p_1.

Since p_1 can be any number from 0 to n-1, MEX(p_1) would be 0 if p_1 != 0, or 1 if p_1 = 0.

Wait, no. If p_1 = 0, then MEX(p_1) = 1, because 0 is present, so the smallest excluded is 1.

If p_1 = 1, then MEX(p_1) = 0, since 0 is not present.

Wait, no. If p_1 = 1, then MEX(p_1) = 0, because 0 is the smallest non-negative integer not in [1].

Wait, that seems inconsistent with my earlier statement. Let's clarify.

If p_1 = 0, then MEX(p_1) = 1.

If p_1 = 1, then MEX(p_1) = 0.

If p_1 = 2, then MEX(p_1) = 0.

Wait, no. If p_1 = 2, then MEX(p_1) = 0, because 0 is not in [2].

Similarly, if p_1 = 3, MEX(p_1) = 0.

So, in general, for any p_1 != 0, MEX(p_1) = 0, and if p_1 = 0, MEX(p_1) = 1.

Wait, is that right? Let's check.

If p_1 = 0, MEX(p_1) = 1.

If p_1 = 1, MEX(p_1) = 0.

If p_1 = 2, MEX(p_1) = 0.

Yes, that seems correct.

So, for i=1:

a_1 = MEX(p_1) - p_1.

If p_1 = 0, a_1 = 1 - 0 = 1.

If p_1 = 1, a_1 = 0 - 1 = -1.

If p_1 = 2, a_1 = 0 - 2 = -2.

And so on.

So, for i=1, a_1 gives me some information about p_1.

Similarly, for i=2:

a_2 = MEX(p_1, p_2) - p_2.

MEX(p_1, p_2) is the smallest non-negative integer not in {p_1, p_2}.

I need to find p_2 based on a_2 and the MEX of p_1 and p_2.

This seems tricky because MEX depends on both p_1 and p_2.

Similarly, for higher i, it depends on all previous p_j.

I need a way to compute MEX incrementally or find a pattern.

Let me think differently. Since p is a permutation, each p_i is unique.

Maybe I can think about the positions where certain numbers appear.

Let me consider that in a permutation of 0 to n-1, each number from 0 to n-1 appears exactly once.

Given that, perhaps I can keep track of which numbers have appeared so far and determine the MEX.

Wait, but I don't know the order of p yet.

Maybe I can iterate through the array a and try to assign p_i accordingly.

Let me consider the first example:

n=5

a = [1,1,-2,1,2]

The corresponding p is [0,1,4,2,3]

Let's verify:

For i=1:

MEX(p_1) = MEX([0]) = 1

a_1 = 1 - 0 = 1

For i=2:

MEX(p_1,p_2) = MEX([0,1]) = 2

Wait, no. MEX([0,1]) is 2, because 0 and 1 are present.

But in the example, a_2 = 1, so 1 = MEX([0,1]) - p_2 => 1 = 2 - p_2 => p_2 = 1

Yes, that matches.

For i=3:

MEX([0,1,4]) = 2 (since 0,1,4 are present; 2 and 3 are missing, so smallest is 2)

a_3 = 2 - 4 = -2

Which matches the example.

For i=4:

MEX([0,1,4,2]) = 3

a_4 = 3 - 2 = 1

Matches the example.

For i=5:

MEX([0,1,4,2,3]) = 5 (since 0,1,2,3,4 are present, so 5 is missing)

a_5 = 5 - 3 = 2

Which matches.

So, in this case, p=[0,1,4,2,3] corresponds to a=[1,1,-2,1,2]

Now, how can I generalize this to find p from a?

Let me try to think of an algorithm.

I need to find p_i for each i from 1 to n, given a.

I know that p is a permutation of 0 to n-1, and all p_i are distinct.

Also, a_i = MEX(p_1 to p_i) - p_i

So, p_i = MEX(p_1 to p_i) - a_i

But MEX(p_1 to p_i) depends on p_1 to p_i, which are all unknowns.

This seems tricky.

Maybe I can find a way to compute MEX incrementally.

Let me think about the MEX function.

MEX(p_1 to p_i) is the smallest non-negative integer not present in p_1 to p_i.

As i increases, the set of p_j's considered grows, so the MEX can only stay the same or increase.

Wait, actually, MEX can decrease if a smaller number is introduced.

Wait, no. MEX is the smallest missing number.

If I have p_1 to p_k with MEX=m, and then p_{k+1}=m, then MEX(p_1 to p_{k+1}) would be the next smallest missing number.

So, MEX can increase or stay the same, but never decrease, because once a number is included, it can't be missing anymore.

Wait, no, actually, MEX can decrease if a larger number is added.

Wait, let's think carefully.

Suppose p_1 to p_k have MEX=m.

If p_{k+1} = m, then m is now present, so the new MEX is the next smallest missing number, which would be greater than m.

If p_{k+1} != m, then MEX remains m.

Wait, no. If p_{k+1} is equal to m, then m is now present, so the new MEX is m+1, assuming m+1 was not present before.

Wait, not necessarily.

For example:

p_1 to p_k = [0,1,2], MEX=3.

If p_{k+1}=3, then MEX becomes 4.

If p_{k+1}=4, then MEX becomes 3 again, because 3 is now missing.

Wait, no.

Wait, p_1 to p_k = [0,1,2], MEX=3.

If p_{k+1}=3, then MEX(p_1 to p_{k+1}) = 4.

If p_{k+1}=4, then MEX(p_1 to p_{k+1}) = 3, because 3 is now missing.

So, MEX can decrease in this case.

So, MEX can both increase or decrease depending on the value of p_{k+1}.

This makes it a bit complicated to track.

Let me think differently.

Since p is a permutation of 0 to n-1, all numbers from 0 to n-1 appear exactly once in p.

Given that, the MEX at any point i is the smallest number from 0 to n-1 that hasn't appeared in p_1 to p_i.

Wait, no. MEX is the smallest non-negative integer not in the array, which could be greater than or equal to 0.

But in this problem, since p contains numbers from 0 to n-1, MEX could be from 0 to n, depending on the permutation.

Wait, no. MEX can be up to n, because if p_1 to p_n contain 0 to n-1, then MEX(p_1 to p_n) = n.

But in the example, for n=5, MEX(p_1 to p_5)=5.

So, MEX can range from 0 to n.

Now, a_i = MEX(p_1 to p_i) - p_i

Given that, p_i = MEX(p_1 to p_i) - a_i

But MEX(p_1 to p_i) is unknown.

I need a way to find MEX(p_1 to p_i) for each i.

Wait, perhaps I can iterate from the end to the beginning.

Let's consider the last element, i=n.

a_n = MEX(p_1 to p_n) - p_n

But p_1 to p_n contain all numbers from 0 to n-1, so MEX(p_1 to p_n) = n

Therefore, a_n = n - p_n

So, p_n = n - a_n

That's straightforward.

So, for the last element, p_n can be directly computed as n - a_n.

Similarly, for i=n-1:

a_{n-1} = MEX(p_1 to p_{n-1}) - p_{n-1}

But MEX(p_1 to p_{n-1}) is the smallest missing number in p_1 to p_{n-1}.

Since p_n is now known, and p is a permutation, the MEX of p_1 to p_{n-1} would be the number that is not in p_1 to p_{n-1}, which is either p_n or some other number not yet present.

Wait, no. p_n is already determined, but in the permutation, p_n is part of the full permutation, but not part of p_1 to p_{n-1}.

Wait, perhaps I can think recursively.

Starting from the end:

p_n = n - a_n

Then, for i=n-1:

MEX(p_1 to p_{n-1}) is the smallest number not in p_1 to p_{n-1}.

But p_1 to p_{n-1} are all numbers from 0 to n-1 except p_n.

So, MEX(p_1 to p_{n-1}) is p_n if p_n < n, otherwise it's n.

Wait, p_n is between 0 and n-1, since p is a permutation of 0 to n-1.

So, MEX(p_1 to p_{n-1}) is the smallest number from 0 to n-1 not in p_1 to p_{n-1}, which is p_n.

Wait, no. p_1 to p_{n-1} contain all numbers from 0 to n-1 except p_n.

But p_n is already assigned, so MEX(p_1 to p_{n-1}) should be p_n.

Wait, no. MEX is the smallest missing number, which might not be p_n if p_n is not the smallest missing.

Wait, for example, if p_n is large, the MEX could be a smaller number.

Wait, no. If p_1 to p_{n-1} contain all numbers from 0 to n-1 except p_n, then MEX(p_1 to p_{n-1}) is p_n.

Because p_n is the only number missing in p_1 to p_{n-1}.

Wait, is that correct?

Let's see an example.

Take n=5, p=[0,1,4,2,3]

For i=5, p_5=3, MEX(p_1 to p_4)=3, which is p_n=3.

Yes, in this case, MEX(p_1 to p_{n-1})=p_n.

Similarly, in another example, n=3, p=[2,0,1]

For i=3, p_3=1, MEX(p_1 to p_2)=1, which is p_n=1.

So, in general, MEX(p_1 to p_{n-1})=p_n.

Wait, but p_n could be any number from 0 to n-1 not in p_1 to p_{n-1}, but since p is a permutation, it's the only number missing.

But in the MEX, it's the smallest missing number, which may or may not be p_n.

Wait, p_n could be any number from 0 to n-1 not in p_1 to p_{n-1}, but since p is a permutation, there's only one number missing, which is p_n.

But p_n could be any number from 0 to n-1, depending on the permutation.

Wait, but in the MEX definition, it's the smallest missing number.

So, MEX(p_1 to p_{n-1}) is the smallest number from 0 to n-1 not in p_1 to p_{n-1}.

Which is not necessarily equal to p_n, unless p_n is the smallest missing number.

Wait, for example, if p_1 to p_{n-1} contain all numbers from 0 to n-2, then p_n must be n-1, and MEX(p_1 to p_{n-1})=n-1=p_n.

If p_1 to p_{n-1} contain all numbers from 0 to n-1 except, say, 2, then MEX(p_1 to p_{n-1})=2, and p_n=2.

Wait, but p_n could be any number not in p_1 to p_{n-1}, but in the permutation, it's only one number missing, which is p_n.

Wait, I'm getting confused.

Let me think again.

Given that p is a permutation of 0 to n-1, p_1 to p_{n-1} contain n-1 distinct numbers from 0 to n-1, so exactly one number is missing, which is p_n.

Therefore, MEX(p_1 to p_{n-1}) is the smallest number from 0 to n-1 not in p_1 to p_{n-1}.

Which may or may not be equal to p_n, depending on what p_n is.

Wait, for example:

n=4

p=[0,1,3,2]

For i=4, p_4=2

MEX(p_1 to p_3)=MEX([0,1,3])=2, which is p_n=2.

Another example:

p=[1,2,3,0]

For i=4, p_4=0

MEX(p_1 to p_3)=MEX([1,2,3])=0, which is p_n=0.

Another example:

p=[2,0,1,3]

For i=4, p_4=3

MEX(p_1 to p_3)=MEX([2,0,1])=3, which is p_n=3.

Wait, in all these cases, MEX(p_1 to p_{n-1})=p_n.

Is this always true?

Wait, no. Consider p=[1,0,3,2]

For i=4, p_4=2

MEX(p_1 to p_3)=MEX([1,0,3])=2, which is p_n=2.

Another example: p=[3,1,2,0]

For i=4, p_4=0

MEX(p_1 to p_3)=MEX([3,1,2])=0, which is p_n=0.

Seems like in all these examples, MEX(p_1 to p_{n-1})=p_n.

Is this always the case?

Wait, yes, because p_1 to p_{n-1} contain n-1 distinct numbers from 0 to n-1, so the missing one is p_n.

And MEX is the smallest missing number, which is p_n, because p_n is the smallest number not in p_1 to p_{n-1}.

Wait, no. That's not necessarily true.

Wait, for example:

p=[2,0,1,3]

For i=4, p_4=3

MEX(p_1 to p_3)=MEX([2,0,1])=3, which is p_n=3.

Another example:

p=[1,2,0,3]

For i=4, p_4=3

MEX(p_1 to p_3)=MEX([1,2,0])=3, which is p_n=3.

Wait, but what if p_n is not the smallest missing number?

Wait, no, in this setup, since p is a permutation, and p_1 to p_{n-1} miss exactly p_n, then MEX(p_1 to p_{n-1}) is p_n.

Because MEX is the smallest missing number, and p_n is the only missing number.

Wait, but what if p_n is not the smallest missing number?

Wait, no, that can't happen because if p_n is missing, and it's the only missing number, then it must be the smallest missing number.

Wait, but that doesn't make sense.

Wait, for example, if p_1 to p_{n-1} contain all numbers from 0 to n-1 except p_n, then p_n is the only missing number, so MEX is p_n.

But p_n could be any number from 0 to n-1, but in this scenario, it's the only missing number, so MEX is p_n.

Wait, but in reality, MEX is the smallest missing number, which is p_n in this case.

Wait, but p_n could be larger than some missing numbers.

Wait, no, if p_1 to p_{n-1} contain all numbers from 0 to n-1 except p_n, then p_n is the only missing number, so it's both the only and the smallest missing number.

Wait, no, that's not necessarily true.

Wait, for example, n=5

p_1 to p_4 = [1,2,3,4]

p_n=0

MEX(p_1 to p_4)=0, which is p_n=0.

Another example:

p_1 to p_4=[0,1,2,4]

p_n=3

MEX(p_1 to p_4)=3, which is p_n=3.

Another example:

p_1 to p_4=[0,1,3,4]

p_n=2

MEX(p_1 to p_4)=2, which is p_n=2.

So, in all these cases, MEX(p_1 to p_{n-1})=p_n.

Therefore, in general, for any permutation p, MEX(p_1 to p_{n-1})=p_n.

Wait, but in the first example, n=5, p=[0,1,4,2,3]

For i=4, p_1 to p_4=[0,1,4,2], MEX=3, which is p_n=3.

Yes, it matches.

So, in general, MEX(p_1 to p_{n-1})=p_n.

Wait, but p_n can be any number from 0 to n-1 not in p_1 to p_{n-1}, but since p is a permutation, it's the only missing number.

Therefore, MEX(p_1 to p_{n-1})=p_n.

So, a_n = MEX(p_1 to p_n) - p_n = n - p_n

Therefore, p_n = n - a_n

Similarly, for i=n-1:

a_{n-1} = MEX(p_1 to p_{n-1}) - p_{n-1} = p_n - p_{n-1}

Therefore, p_{n-1} = p_n - a_{n-1}

Wait, no.

Wait, a_{n-1} = MEX(p_1 to p_{n-1}) - p_{n-1} = p_n - p_{n-1}

Therefore, p_{n-1} = p_n - a_{n-1}

Wait, but p_n is known from earlier.

Similarly, for i=n-2:

a_{n-2} = MEX(p_1 to p_{n-2}) - p_{n-2}

But MEX(p_1 to p_{n-2}) is the smallest number not in p_1 to p_{n-2}.

Given that p_1 to p_{n-2} contain n-2 distinct numbers from 0 to n-1, so two numbers are missing: p_{n-1} and p_n.

Therefore, MEX(p_1 to p_{n-2}) is the smaller of p_{n-1} and p_n.

Wait, no. The MEX is the smallest missing number, which could be less than both p_{n-1} and p_n, or between them, depending on the values.

Wait, no.

Wait, p_1 to p_{n-2} contain n-2 distinct numbers from 0 to n-1, so two numbers are missing: p_{n-1} and p_n, or one number is missing twice, but since it's a permutation, both p_{n-1} and p_n are distinct and not in p_1 to p_{n-2}.

Therefore, MEX(p_1 to p_{n-2}) is the smaller of p_{n-1} and p_n.

Because the MEX is the smallest number not in p_1 to p_{n-2}.

So, if p_{n-1} < p_n, then MEX(p_1 to p_{n-2})=p_{n-1}

Else, MEX(p_1 to p_{n-2})=p_n

Therefore, a_{n-2} = MEX(p_1 to p_{n-2}) - p_{n-2} = min(p_{n-1}, p_n) - p_{n-2}

But this seems complicated.

Wait, maybe I can think of it differently.

I already have p_n = n - a_n

Then, for i=n-1:

a_{n-1} = MEX(p_1 to p_{n-1}) - p_{n-1} = p_n - p_{n-1}

Therefore, p_{n-1} = p_n - a_{n-1}

Similarly, for i=n-2:

a_{n-2} = MEX(p_1 to p_{n-2}) - p_{n-2} = min(p_{n-1}, p_n) - p_{n-2}

But this is tricky because I need to know which of p_{n-1} and p_n is smaller.

Wait, perhaps I can keep track of the MEX as I go backwards.

Let me try to see a pattern.

In the first example:

n=5

a=[1,1,-2,1,2]

p=[0,1,4,2,3]

Let's see:

p_5 = 5 - 2 = 3

p_4 = p_5 - a_4 = 3 - 1 = 2

p_3 = min(p_4, p_5) - a_3 = min(2,3) - (-2) = 2 + 2 = 4

p_2 = min(p_3, p_4, p_5) - a_2 = min(4,2,3) - 1 = 2 - 1 = 1

p_1 = min(p_2, p_3, p_4, p_5) - a_1 = min(1,4,2,3) - 1 = 1 - 1 = 0

So, p=[0,1,4,2,3]

This seems to work.

Wait, in p_3, MEX(p_1 to p_3) = min(p_4, p_5) = min(2,3)=2

Then, a_3 = 2 - p_3 = -2 => p_3 = 2 - (-2) = 4

Similarly, p_2 = min(p_3, p_4, p_5) - a_2 = min(4,2,3) - 1 = 2 - 1 = 1

p_1 = min(p_2, p_3, p_4, p_5) - a_1 = min(1,4,2,3) - 1 = 1 - 1 = 0

So, it seems that for general i, p_i = min(p_{i+1}, p_{i+2}, ..., p_n) - a_i

Wait, but in the above step, for p_3, it's min(p_4, p_5) - a_3

For p_2, it's min(p_3, p_4, p_5) - a_2

For p_1, it's min(p_2, p_3, p_4, p_5) - a_1

So, it seems that for each i from n-1 downto 1:

p_i = min(p_{i+1}, p_{i+2}, ..., p_n) - a_i

But computing this directly would be inefficient for large n.

I need a better way to compute this.

Let me define mex_i = MEX(p_1 to p_i)

Then, a_i = mex_i - p_i

Therefore, p_i = mex_i - a_i

But mex_i = min(p_{i+1}, p_{i+2}, ..., p_n)

Because MEX(p_1 to p_i) is the smallest number not in p_1 to p_i, which is the smallest number in p_{i+1} to p_n, since p is a permutation.

Wait, no. MEX(p_1 to p_i) is the smallest number not in p_1 to p_i.

Given that p is a permutation of 0 to n-1, MEX(p_1 to p_i) is the smallest number from 0 to n-1 not in p_1 to p_i.

But p_{i+1} to p_n contain all numbers not in p_1 to p_i, so MEX(p_1 to p_i) is the smallest number in p_{i+1} to p_n.

Therefore, mex_i = min(p_{i+1}, p_{i+2}, ..., p_n)

So, p_i = mex_i - a_i

Therefore, p_i = min(p_{i+1}, p_{i+2}, ..., p_n) - a_i

This seems to hold.

So, to compute p, I can start from the end:

p_n = n - a_n

Then, for i from n-1 downto 1:

mex_i = min(p_{i+1}, p_{i+2}, ..., p_n)

p_i = mex_i - a_i

But computing mex_i for each i would be O(n^2), which is too slow for n up to 2e5.

I need a way to compute mex_i efficiently.

I can keep track of the minimum value from i+1 to n as I iterate from n downto 1.

So, initialize mex = n

Set p_n = n - a_n

Then, set mex = min(mex, p_n)

Then, for i from n-1 downto 1:

p_i = mex - a_i

mex = min(mex, p_i)

This seems efficient, as it's O(n).

Let me test this with the first example:

n=5

a=[1,1,-2,1,2]

Initialize mex = 5

p_5 = 5 - 2 = 3

mex = min(5, 3) = 3

p_4 = 3 - 1 = 2

mex = min(3, 2) = 2

p_3 = 2 - (-2) = 4

mex = min(2, 4) = 2

p_2 = 2 - 1 = 1

mex = min(2, 1) = 1

p_1 = 1 - 1 = 0

Which matches the example p=[0,1,4,2,3]

Great, this seems to work.

Let me try another example:

n=5

a=[1,1,1,1,1]

Compute p:

mex = 5

p_5 = 5 - 1 = 4

mex = min(5,4)=4

p_4 = 4 - 1 = 3

mex = min(4,3)=3

p_3 = 3 - 1 = 2

mex = min(3,2)=2

p_2 = 2 - 1 =1

mex = min(2,1)=1

p_1 =1 -1=0

So, p=[0,1,2,3,4]

Which matches the second test case.

Another example:

n=3

a=[-2,1,2]

Compute p:

mex=3

p_3=3-2=1

mex=min(3,1)=1

p_2=1-1=0

mex=min(1,0)=0

p_1=0 - (-2)=2

So, p=[2,0,1]

Which matches the third test case.

Perfect.

So, the algorithm is:

For each test case:

Read n

Read array a of length n

Initialize p as array of size n

Set mex = n

Set p[n-1] = n - a[n-1]

Set mex = min(mex, p[n-1])

For i from n-2 downto 0:

p[i] = mex - a[i]

mex = min(mex, p[i])

Print p

This should work efficiently, as it's O(n) per test case, and the total sum of n over all test cases is up to 2e5, which is acceptable.

I need to implement this in code.

Given that, I can write the function as provided in the program.

So, the program seems correct.

**Final Solution**
To solve this problem, we need to reconstruct a permutation array \( p \) from another array \( a \), where each element \( a_i \) is defined based on the MEX (Minimum EXcluded) of the subarray \( p_1 \) to \( p_i \).

## Approach
1. **Understanding MEX**: The MEX of an array is the smallest non-negative integer that does not appear in that array.
2. **Key Insight**: For each position \( i \), \( a_i = \text{MEX}(p_1, p_2, \ldots, p_i) - p_i \). We can rearrange this to find \( p_i = \text{MEX}(p_1, p_2, \ldots, p_i) - a_i \).
3. **Efficient Calculation of MEX**: Since \( p \) is a permutation, the MEX of the first \( i \) elements is the smallest number not present in those elements, which is equivalent to the minimum of the remaining elements in the permutation.
4. **Iterative Calculation**: Start from the end of the array and calculate \( p_i \) iteratively using the MEX value, which is maintained as the minimum of the previously calculated \( p \) values.

## Solution Code
```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        p = [-1] * n
        mex = n
        for i in range(n - 1, -1, -1):
            p[i] = mex - a[i]
            mex = min(mex, p[i])
        print(*p)

func()
```

## Explanation
1. **Initialization**: Read the number of test cases \( t \).
2. **Processing Each Test Case**:
   - Read the length of the arrays \( n \).
   - Read the array \( a \) which contains the values \( a_1 \) to \( a_n \).
   - Initialize the permutation array \( p \) with placeholders.
   - Set the initial MEX value to \( n \).
3. **Backward Iteration**:
   - Starting from the last element to the first, compute \( p_i \) using the formula \( p_i = \text{mex} - a_i \).
   - Update the MEX value to be the minimum of the current MEX and the newly computed \( p_i \).
4. **Output the Permutation**: Print the permutation array \( p \) for each test case.

This approach ensures that we correctly reconstruct the permutation \( p \) from the array \( a \) by leveraging the properties of the MEX function and iterating backwards for efficient computation.

**Final Solution**
To solve this problem, we need to reconstruct a permutation array \( p \) from another array \( a \), where each element \( a_i \) is defined based on the MEX (Minimum EXcluded) of the subarray \( p_1 \) to \( p_i \).

## Approach
1. **Understanding MEX**: The MEX of an array is the smallest non-negative integer that does not appear in that array.
2. **Key Insight**: For each position \( i \), \( a_i = \text{MEX}(p_1, p_2, \ldots, p_i) - p_i \). We can rearrange this to find \( p_i = \text{MEX}(p_1, p_2, \ldots, p_i) - a_i \).
3. **Efficient Calculation of MEX**: Since \( p \) is a permutation, the MEX of the first \( i \) elements is the smallest number not present in those elements, which is equivalent to the minimum of the remaining elements in the permutation.
4. **Iterative Calculation**: Start from the end of the array and calculate \( p_i \) iteratively using the MEX value, which is maintained as the minimum of the previously calculated \( p \) values.

## Solution Code
```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        p = [-1] * n
        mex = n
        for i in range(n - 1, -1, -1):
            p[i] = mex - a[i]
            mex = min(mex, p[i])
        print(*p)

func()
```

## Explanation
1. **Initialization**: Read the number of test cases \( t \).
2. **Processing Each Test Case**:
   - Read the length of the arrays \( n \).
   - Read the array \( a \) which contains the values \( a_1 \) to \( a_n \).
   - Initialize the permutation array \( p \) with placeholders.
   - Set the initial MEX value to \( n \).
3. **Backward Iteration**:
   - Starting from the last element to the first, compute \( p_i \) using the formula \( p_i = \text{mex} - a_i \).
   - Update the MEX value to be the minimum of the current MEX and the newly computed \( p_i \).
4. **Output the Permutation**: Print the permutation array \( p \) for each test case.

This approach ensures that we correctly reconstruct the permutation \( p \) from the array \( a \) by leveraging the properties of the MEX function and iterating backwards for efficient computation.

**Final Solution**
To solve this problem, we need to reconstruct a permutation array \( p \) from another array \( a \), where each element \( a_i \) is defined based on the MEX (Minimum EXcluded) of the subarray \( p_1 \) to \( p_i \).

## Approach
1. **Understanding MEX**: The MEX of an array is the smallest non-negative integer that