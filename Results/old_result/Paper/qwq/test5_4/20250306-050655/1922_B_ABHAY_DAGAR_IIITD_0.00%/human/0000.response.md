Alright, I've got this problem to solve. Let's see what it's asking for. So, I have n sticks, each with a length of 2 raised to the power of a given number a_i. I need to choose exactly 3 sticks and form a non-degenerate triangle with them. A non-degenerate triangle means that the area is greater than 0, which implies that the sum of any two sides must be greater than the third side. Makes sense.

So, the task is to count how many ways I can pick 3 sticks that satisfy the triangle inequality. The input consists of multiple test cases, and for each test case, I have n and a list of a_i values.

First, I need to understand the properties of the lengths. Since the lengths are of the form 2^{a_i}, and exponents a_i can range from 0 to n, the lengths are all powers of 2, which are distinct and positive.

I recall that for any three lengths to form a triangle, the sum of the two smaller lengths must be greater than the largest length. Given that the lengths are powers of 2, maybe there's a smart way to leverage the properties of exponents and powers of 2 to optimize the counting.

Let me think about the properties of powers of 2. Powers of 2 are strictly increasing, so if I have three lengths 2^a, 2^b, and 2^c where a < b < c, then 2^a + 2^b > 2^c only if 2^{b} + 2^{a} > 2^{c}. But since a < b < c, 2^a + 2^b = 2^a (1 + 2^{b-a}) < 2^b * 2 = 2^{b+1} <= 2^c, because b < c implies b + 1 <= c. Wait, that suggests that 2^a + 2^b <= 2^c, which would mean that the sum of the two smaller sides is less than or equal to the largest side. But for a non-degenerate triangle, the sum must be strictly greater than the largest side. So, does that mean no three distinct powers of 2 can form a triangle?

Hold on, that seems off. Let me check with an example. Take a_i = 0, 1, 2. So lengths are 2^0 = 1, 2^1 = 2, and 2^2 = 4. Check if 1 + 2 > 4? 1 + 2 = 3, which is less than 4. So, no, they don't form a triangle. Another example: a_i = 1, 1, 1. Lengths are all 2^1 = 2. 2 + 2 > 2, yes, so they do form a triangle. Wait, but in this case, all a_i are the same, so all sticks have the same length.

So, it seems that if all three sticks have the same length, they can form a triangle, provided that the length is positive, which it is since it's 2^{a_i}. But if the lengths are distinct powers of 2, then the sum of the two smaller ones won't exceed the largest one.

Therefore, the only way to form a triangle is to have at least two sticks of the same length. Wait, but in the first test case of the example, where a_i = [1,1,1,1,1,1,1], it's saying that any three sticks form a triangle, which makes sense because all sticks have the same length of 2^1 = 2, and 2 + 2 > 2.

In the second test case, a_i = [3,2,1,3], which corresponds to lengths 8, 4, 2, 8. So, possible combinations are:

- 2,4,8: 2 + 4 = 6 > 8? No.

- 2,8,8: 2 + 8 = 10 > 8, yes.

- 4,8,8: 4 + 8 = 12 > 8, yes.

So, there are two valid combinations, which matches the sample output.

In the third test case, a_i = [1,2,3], which are lengths 2,4,8, and as we saw, 2 + 4 <= 8, so no triangle can be formed.

In the fourth test case, a_i = [1], which is only one stick, so no way to form a triangle.

From this, it seems that triangles can be formed only when at least two sticks have the same length, and the third stick satisfies the triangle inequality.

So, to generalize:

- If all three sticks have the same length (i.e., same a_i), then they form a triangle.

- If two sticks have the same length and the third is smaller than their sum, which, given that lengths are powers of 2, would depend on the exponents.

Wait, but in the second test case, we have lengths 2,4,8,8. So, for combinations:

- 2,8,8: 2 + 8 > 8, which is true.

- 4,8,8: 4 + 8 > 8, which is true.

But in both cases, since two sticks have the same length, and the third is smaller than their sum.

Wait, but in the first case, 2 + 8 > 8, which holds, but in the second case, 4 + 8 > 8, which also holds.

So, it seems that if two sticks have the same length, and the third stick is less than twice that length, then they can form a triangle.

Given that lengths are powers of 2, if two sticks have length 2^k, then the third stick must be less than 2^{k+1} to form a triangle.

Wait, because 2^k + 2^k = 2^{k+1}, so the third stick must be less than 2^{k+1}.

Given that all other sticks are also powers of 2, the third stick must be less than 2^{k+1}, which means its exponent must be less than k+1.

So, for two sticks of length 2^k, the third stick can be any stick with length 2^m where m < k+1.

But, in the second test case, for two sticks of length 8 (2^3), the third stick must be less than 2^4 = 16. So, possible third sticks are those with a_i < 4, which in that test case are 2 (4) and 1 (2).

But in that test case, only one stick has a_i=1 (length 2) and one has a_i=2 (length 4), so two possible combinations.

Wait, but in the second test case, there are two sticks with a_i=3 (length 8), one with a_i=2 (4), and one with a_i=1 (2). So, combinations are:

- Two sticks of length 8 and one stick of length 4: 8 + 8 > 4, 8 + 4 > 8, and 8 + 4 > 8, so yes.

- Two sticks of length 8 and one stick of length 2: 8 + 8 > 2, 8 + 2 > 8, and 8 + 2 > 8, so yes.

Hence, two valid combinations.

In the third test case, a_i = [1,2,3], which are lengths 2,4,8.

Possible combinations:

- 2,4,8: 2 + 4 = 6 > 8? No.

Hence, no triangles can be formed.

In the first test case, all sticks have a_i=1 (length 2). So, any three sticks will form a triangle since 2 + 2 > 2.

The number of ways to choose 3 sticks out of 7 is C(7,3) = 35.

So, in the first test case, the answer is 35.

In the second test case, as we saw, there are two valid combinations.

In the third and fourth test cases, no triangles can be formed.

So, the output is 35, 2, 0, 0.

Now, I need to find a general way to compute this efficiently, considering the constraints: t <= 10^4, n <= 3*10^5, and the sum of n over all test cases does not exceed 3*10^5.

So, I need an efficient algorithm, preferably O(n log n) per test case or better.

First, I need to count the number of ways to choose three sticks that satisfy the triangle inequality.

Given that lengths are powers of 2, which are strictly increasing, I can leverage that property.

Let me think about grouping sticks by their lengths. Since sticks with the same a_i have the same length, I can count the frequency of each a_i.

Let freq[x] be the number of sticks with a_i = x.

Now, to form a triangle:

Case 1: All three sticks have the same length.

This is possible only if freq[x] >= 3, and in that case, the number of ways is C(freq[x], 3) = freq[x] * (freq[x]-1) * (freq[x]-2) / 6.

Case 2: Two sticks have the same length, and the third has a different length.

Let's say two sticks have length 2^x, and the third has length 2^y, where y < x+1.

Wait, but since the lengths are powers of 2, 2^y < 2^{x+1} means y < x+1.

So, for two sticks of length 2^x, the third stick can have any length 2^m where m < x+1.

But m can be from 0 up to x.

So, the number of ways for this case is freq[x] * (freq[x]-1)/2 * (total sticks with a_i < x+1) - the sticks with a_i = x.

Wait, more carefully:

For two sticks of length 2^x, the third stick can be any stick with a_i < x+1, but we have to subtract the sticks with a_i = x, because those are already counted in the first case (all three sticks have a_i = x).

Wait, no. In the first case, we're counting when all three have a_i = x.

In this case, we're counting when two have a_i = x and the third has a_i < x+1 and a_i != x.

Wait, but a_i can be equal to x, but if we're choosing two sticks with a_i = x and one with a_i < x+1, but we have to make sure that the third stick is different from the first two.

So, the third stick must have a_i < x+1 and a_i != x.

Wait, but in the second test case, for x=3 (length 8), there are two sticks with a_i=3 and one with a_i=2 and one with a_i=1.

So, for two sticks with a_i=3, the third stick can be a_i=2 or a_i=1, which are both less than x+1=4.

So, the number of ways is C(freq[3], 2) * (freq[0] + freq[1] + freq[2]).

But in this case, freq[0] = 0, freq[1] =1, freq[2]=1.

So, C(2,2) * (0 +1 +1) = 1 * 2 = 2, which matches the sample output.

Similarly, in the first test case, all a_i=1, so freq[1]=7.

Number of ways: C(7,3) = 35.

In the third test case, a_i=[1,2,3], so freq[1]=1, freq[2]=1, freq[3]=1.

No three sticks with the same a_i, and for two sticks with the same a_i, there's only one pair for each a_i, but since the third stick must have a_i < x+1, but there's only one stick for each a_i.

So, for a_i=1, two sticks with a_i=1 and third with a_i < 2, but there's only one stick with a_i=1, so not possible.

Similarly for a_i=2 and a_i=3.

Hence, no triangles can be formed.

So, generalizing, the total number of ways is the sum over all x of:

- C(freq[x], 3) if freq[x] >= 3

- C(freq[x], 2) * (total sticks with a_i < x+1 - freq[x]) if freq[x] >= 2

Wait, but in the second term, total sticks with a_i < x+1 include freq[x], but we have to exclude that because the third stick must be different from the first two.

Hence, total sticks with a_i < x+1 minus freq[x].

Wait, but in the second test case, for x=3, total sticks with a_i < 4 are a_i=0,1,2,3.

But freq[0]=0, freq[1]=1, freq[2]=1, freq[3]=2.

So, total sticks with a_i < 4 is 0 +1 +1 +2 =4.

But we have to exclude the sticks with a_i=3 for the third stick, because those are already counted in the first term.

Wait, no. Wait, in the first term, we're counting when all three have a_i=x.

In the second term, we're counting when two have a_i=x and one has a_i < x+1 and a_i != x.

So, total sticks available for the third stick are those with a_i < x+1 and a_i != x.

Hence, total sticks with a_i < x+1 minus freq[x].

So, in the second test case, for x=3, total sticks with a_i <4 are 0+1+1+2=4, minus freq[3]=2, so 2 sticks available for the third stick.

Hence, C(2,2) * 2 = 1 * 2 =2, which matches.

Similarly, in the first test case, x=1, freq[1]=7.

Total sticks with a_i <2 are a_i=0 and a_i=1.

But a_i=0 is not present, so only freq[1]=7.

So, total sticks with a_i <2 is 7.

Then, for two sticks with a_i=1, third stick can be any stick with a_i <2 and a_i !=1, which is none, since only a_i=1 is present.

Hence, C(7,2) * (7 - 7) = 21 * 0 =0.

But in reality, in the first test case, all combinations are C(7,3)=35.

Wait, that doesn't add up.

Wait, perhaps I'm missing something.

Wait, in the first test case, all a_i=1, so all sticks have the same length.

Hence, the number of ways is C(7,3)=35.

In my previous approach, I have:

- For x=1, freq[1]=7.

- Case 1: C(7,3)=35.

- Case 2: C(7,2)* (total sticks with a_i <2 minus freq[1]) = C(7,2)*(0 +7 -7)=0.

Hence, total is 35 +0=35, which matches the sample output.

So, that seems correct.

In the second test case:

- For x=3, freq[3]=2.

- Case 1: C(2,3)=0.

- Case 2: C(2,2)*(total sticks with a_i <4 minus freq[3])=1*(0+1+1+2 -2)=1*(2)=2.

Hence, total is 0 +2=2, which matches.

In the third test case:

- For x=1, freq[1]=1.

- Case 1: C(1,3)=0.

- Case 2: C(1,2)=0.

- For x=2, freq[2]=1.

- Case 1: C(1,3)=0.

- Case 2: C(1,2)=0.

- For x=3, freq[3]=1.

- Case 1: C(1,3)=0.

- Case 2: C(1,2)=0.

Hence, total is 0, which matches.

So, this seems to be a correct approach.

Now, to implement this efficiently, I need to:

- For each test case:

- Read n and the list a_i.

- Count the frequency of each a_i.

- For each a_i, compute:

- If freq[x] >=3, add C(freq[x],3).

- If freq[x] >=2, add C(freq[x],2) * (total sticks with a_i < x+1 - freq[x]).

- To compute total sticks with a_i < x+1 efficiently, I can precompute a prefix sum.

- Sort the a_i and compute a prefix sum of frequencies up to each a_i.

- Then, for each x, total sticks with a_i < x+1 is prefix_sum[x].

- But since a_i can be up to n (which is up to 3*10^5), I need to handle that.

- Also, a_i can be 0, so the range is from 0 to n.

Given that n can be up to 3*10^5 and t up to 10^4, but the sum of n over all test cases is up to 3*10^5, I need an O(n log n) per test case or better.

So, in code, I can:

- For each test case:

- Read n and a_i list.

- Count freq[x] for each x in a_i.

- Sort the unique a_i in ascending order.

- Compute prefix_sum, where prefix_sum[x] = sum of freq[y] for y < x+1.

- Then, for each x in a_i, compute:

- If freq[x] >=3, add C(freq[x],3).

- If freq[x] >=2, add C(freq[x],2) * (prefix_sum[x] - freq[x]).

- But need to handle x+1 correctly in the prefix_sum.

Wait, to compute prefix_sum[x], it's the sum of freq[y] for y < x+1.

So, if I have sorted unique a_i, I can compute prefix_sum for each x.

Wait, perhaps it's better to use a list to store freq for a_i from 0 to max_a, where max_a is the maximum a_i in the test case.

Since a_i can be up to n, which is up to 3*10^5, I can use a list of size 3*10^5 +1 to store freq.

Then, compute prefix_sum from 0 to max_a.

Then, for each x, prefix_sum[x] = sum of freq[y] for y < x+1.

Then, for each x, if freq[x] >=3, add C(freq[x],3).

If freq[x] >=2, add C(freq[x],2) * (prefix_sum[x] - freq[x]).

This should work efficiently.

Now, let's think about implementing this.

First, I need a function to compute C(n, k), which is n choose k.

But since n can be up to 3*10^5 and t up to 10^4, I need an efficient way to compute C(n, k) for small k.

For k=2, C(n,2)=n*(n-1)/2.

For k=3, C(n,3)=n*(n-1)*(n-2)/6.

I can implement these directly.

Now, in terms of code structure:

- Read t.

- For each test case:

- Read n.

- Read a_i list.

- Count freq[x] for x in a_i.

- Find max_a in a_i.

- Compute prefix_sum[x] for x from 0 to max_a+1.

- Initialize prefix_sum[0] = freq[0].

- For x from 1 to max_a+1, prefix_sum[x] = prefix_sum[x-1] + freq[x].

- Then, for each x in a_i, sorted uniquely:

- If freq[x] >=3, add C(freq[x],3).

- If freq[x] >=2, add C(freq[x],2) * (prefix_sum[x] - freq[x]).

- Print the result.

Wait, but prefix_sum[x] is sum of freq[y] for y < x+1.

So, prefix_sum[x] includes freq[x].

Hence, prefix_sum[x] - freq[x] is sum of freq[y] for y < x.

But in the earlier reasoning, for the second case, it should be sum of freq[y] for y < x+1 minus freq[x], which is sum of freq[y] for y < x+1 and y != x, which is sum of freq[y] for y < x+1 minus freq[x].

But sum of freq[y] for y < x+1 is prefix_sum[x], so prefix_sum[x] - freq[x] is sum of freq[y] for y < x.

Wait, but in the second test case, for x=3, prefix_sum[3] = freq[0] + freq[1] + freq[2] + freq[3] = 0 +1 +1 +2 =4.

Then, prefix_sum[3] - freq[3] =4 -2=2, which matches the number of sticks with a_i <3, which are a_i=0,1,2, but freq[0]=0, freq[1]=1, freq[2]=1, total 2.

Hence, correct.

So, in code, for each x, prefix_sum[x] = sum of freq[y] for y < x+1.

Then, for freq[x] >=2, add C(freq[x],2) * (prefix_sum[x] - freq[x]).

This seems correct.

Now, to implement this efficiently, I need to:

- For each test case, create a freq list of size max_a +1, where max_a is the maximum a_i in that test case.

- But since a_i can be up to n, which is up to 3*10^5, and t up to 10^4, but sum of n over all test cases is up to 3*10^5, it's manageable.

- Use a default dictionary to count freq[x].

- Then, sort the unique a_i in ascending order.

- Compute prefix_sum[x] for x from 0 to max_a+1.

- Then, for each x in a_i, compute the contributions.

- Since n can be up to 3*10^5 and t up to 10^4, but sum of n over t is up to 3*10^5, it should be efficient enough.

Now, in terms of code, I need to make sure that I handle the prefix_sum correctly.

Let me try to write a small example.

Take the second test case:

n=4

a_i=[3,2,1,3]

freq[1]=1

freq[2]=1

freq[3]=2

max_a=3

prefix_sum[0]=freq[0]=0

prefix_sum[1]=freq[0]+freq[1]=0+1=1

prefix_sum[2]=prefix_sum[1]+freq[2]=1+1=2

prefix_sum[3]=prefix_sum[2]+freq[3]=2+2=4

Now, for x=1:

freq[1]=1

C(1,3)=0

C(1,2)=0

So, no addition.

For x=2:

freq[2]=1

C(1,3)=0

C(1,2)=0

So, no addition.

For x=3:

freq[3]=2

C(2,3)=0

C(2,2)=1

prefix_sum[3] - freq[3]=4 -2=2

So, add 1 *2 =2

Hence, total=2, which matches.

Another example, first test case:

n=7

a_i=[1,1,1,1,1,1,1]

freq[1]=7

max_a=1

prefix_sum[0]=0

prefix_sum[1]=0 + freq[1]=7

prefix_sum[2]=prefix_sum[1] + freq[2]=7 +0=7

For x=1:

C(7,3)=35

C(7,2)=21

prefix_sum[1] - freq[1]=7 -7=0

So, add 35 + 21*0 =35, which matches.

Seems correct.

Hence, this approach should work.

Now, to implement this in code.

I need to make sure that:

- I handle a_i=0 correctly.

- a_i can be up to n, which is up to 3*10^5, so I need to handle freq up to that.

- Use a list for freq, initialized to 0.

- For each a_i, increment freq[a_i].

- Find max_a in a_i.

- Compute prefix_sum from 0 to max_a+1.

- For each x in a_i, sorted uniquely, compute the contributions.

- Sum them up and print the result.

Also, to optimize, I can precompute the C(n,2) and C(n,3) for n up to 3*10^5, but since they can be computed on the fly efficiently, it's not necessary.

Now, in terms of code structure:

- Read t.

- For each test case:

- Read n.

- Read a_i list.

- Count freq[x] for x in a_i.

- Find max_a in a_i.

- Initialize prefix_sum[0]=freq[0].

- For x from 1 to max_a+1, prefix_sum[x] = prefix_sum[x-1] + freq[x].

- Initialize res=0.

- For each x in sorted unique a_i:

- If freq[x] >=3, res += C(freq[x],3).

- If freq[x] >=2, res += C(freq[x],2) * (prefix_sum[x] - freq[x]).

- Print res.

This should work.

Now, let's think about edge cases.

Edge case 1: n=1

- Only one stick, can't form a triangle.

- Output 0.

Edge case 2: n=2

- Only two sticks, can't form a triangle.

- Output 0.

Edge case 3: n=3

- If all three have the same a_i, output 1.

- If not, output 0.

Edge case 4: All a_i are the same.

- Number of ways is C(n,3).

Edge case 5: All a_i are distinct.

- No two sticks have the same length, so only case 1 applies, which requires freq[x] >=3, but since all a_i are distinct, freq[x]=1 for all x.

- Hence, output 0.

Edge case 6: t=10^4, each n=3.

- Need to make sure that the code runs efficiently.

Given that the sum of n over all test cases is up to 3*10^5, and per test case operations are O(n), it should be fine.

Now, to implement this in code.

I need to make sure that I handle the input efficiently, especially since t can be up to 10^4.

In Python, reading input using sys.stdin.readline can be faster.

Also, using a list for freq and prefix_sum is efficient.

Implementing C(n,2) and C(n,3) directly using formulae.

Now, write the code accordingly.

## Final Solution
To solve this problem, we need to determine the number of ways to choose exactly 3 sticks from given sticks such that they can form a non-degenerate triangle. The lengths of the sticks are given by \(2^{a_i}\), where \(a_i\) are integers provided in the input.

### Approach

1. **Understanding the Problem**:
    - We need to form a triangle with three sticks where the sum of any two sides is greater than the third side.
    - Given the lengths are powers of 2, we need to leverage their properties for efficient computation.

2. **Key Observations**:
    - If all three sticks have the same length, they can form a triangle.
    - If two sticks have the same length, the third stick must be smaller than their sum to form a triangle.

3. **Efficient Calculation**:
    - Use frequency counting for each \(a_i\) value.
    - Use prefix sums to quickly calculate the total number of sticks with lengths less than a certain value.
    - Calculate combinations using combinatorial formulas for efficiency.

4. **Implementation Steps**:
    - Read the input values.
    - Count the frequency of each \(a_i\).
    - Compute prefix sums for quick range queries.
    - Calculate the number of valid triangles using combinatorial counting.

### Solution Code

```python
import sys
from collections import defaultdict

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    t = int(data[idx])
    idx += 1
    results = []
    for _ in range(t):
        n = int(data[idx])
        idx += 1
        a = list(map(int, data[idx:idx+n]))
        idx += n
        freq = defaultdict(int)
        for x in a:
            freq[x] += 1
        max_a = max(a) if a else 0
        prefix_sum = [0] * (max_a + 2)
        for x in range(max_a + 1):
            prefix_sum[x+1] = prefix_sum[x] + freq[x]
        res = 0
        for x in sorted(freq.keys()):
            cnt = freq[x]
            if cnt >= 3:
                res += cnt * (cnt - 1) * (cnt - 2) // 6
            if cnt >= 2:
                total_smaller = prefix_sum[x+1] - cnt
                res += cnt * (cnt - 1) // 2 * total_smaller
        results.append(str(res))
    print('\n'.join(results))

if __name__ == "__main__":
    main()
```

### Explanation

1. **Reading Input**:
    - Read all input data at once for efficiency.
    - Parse the number of test cases and process each test case sequentially.

2. **Frequency Counting**:
    - Use a dictionary to count the frequency of each \(a_i\).

3. **Prefix Sum Calculation**:
    - Compute prefix sums to quickly get the total number of sticks with lengths less than \(2^{x+1}\).

4. **Combination Counting**:
    - For each unique \(a_i\), calculate the number of ways to choose three sticks with the same \(a_i\) if frequency is at least 3.
    - Calculate the number of ways to choose two sticks with the same \(a_i\) and one stick with a smaller \(a_i\) if frequency is at least 2.

5. **Output Results**:
    - Collect results for all test cases and print them.

This approach ensures efficient computation within the given constraints, leveraging combinatorial mathematics and prefix sums for quick range queries.