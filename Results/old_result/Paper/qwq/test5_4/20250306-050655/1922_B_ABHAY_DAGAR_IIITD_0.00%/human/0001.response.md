Alright, I've got this problem to solve. Let's see what it's asking for. So, I have n sticks, each with a length of 2 raised to the power of a_i, where a_i is given for each stick. I need to choose exactly 3 sticks and form a non-degenerate triangle with them. A non-degenerate triangle means that the area is greater than 0, which in terms of stick lengths translates to the triangle inequality holding: the sum of any two sides must be greater than the third side.

First, I need to understand the properties of the lengths. Since the lengths are of the form 2^{a_i}, and a_i can range from 0 to n, the lengths are all positive powers of 2, which means they are all positive and distinct for different a_i, but there can be duplicates if a_i are the same.

Given that, I need to find the number of unique triplets of sticks that can form a triangle, meaning for any triplet (x, y, z), x + y > z, x + z > y, and y + z > x must hold.

Given that the lengths are powers of 2, there might be some properties I can exploit. For example, powers of 2 are strictly increasing, so if I have three lengths 2^a, 2^b, and 2^c where a < b < c, then 2^a + 2^b > 2^c only if a and b are such that their sum exceeds 2^c.

Wait, but 2^a + 2^b is equal to 2^a + 2^b, and since a < b < c, 2^a + 2^b is less than or equal to 2^{b+1}, which is less than or equal to 2^c if b+1 <= c. Hmm, actually, 2^a + 2^b is always less than or equal to 2^{b+1}, and since b < c, 2^{b+1} <= 2^c only if b+1 >= c, but b < c, so b+1 could be equal to c or greater.

Wait, this seems messy. Maybe I should think differently.

Let me consider that all lengths are powers of 2, so they are all distinct powers unless a_i are the same. But even if a_i are the same, the lengths would be equal.

Wait, no, if a_i are the same, then multiple sticks have the same length. So, I need to handle cases where multiple sticks have the same length.

I recall that for triangle inequality, if I have three sides where one side is larger than the sum of the other two, it doesn't form a triangle. So, to maximize the number of triangles, I need to ensure that for any three sticks, the sum of the two smaller ones is greater than the largest one.

Given that the lengths are powers of 2, which are exponents of a_i, I need to work with these exponents.

Maybe I can sort the exponents first. Let's say I sort the a_i in ascending order. Then, for any three sticks with exponents a, b, c where a <= b <= c, the condition for forming a triangle is 2^a + 2^b > 2^c.

Given that 2^a + 2^b is equal to 2^a (1 + 2^{b-a}) , and since b >= a, this is 2^a (1 + 2^{k}) where k = b - a.

I need 2^a (1 + 2^{k}) > 2^c.

But since c >= b, and b >= a, c >= b >= a, so c >= a + k.

Wait, this seems complicated. Maybe I need a better approach.

I recall that for powers of 2, the sum of two smaller powers is less than or equal to the next higher power. For example, 2^0 + 2^1 = 1 + 2 = 3, which is less than 4 (2^2). Similarly, 2^1 + 2^2 = 2 + 4 = 6, which is greater than 8 (2^3). Wait, that's not always true.

Wait, 2^0 + 2^0 = 1 + 1 = 2 > 1, but in this case, a_i are such that a_i >=0 and a_i <=n.

Wait, maybe I need to think in terms of frequency of each a_i.

Let me think about counting the frequency of each a_i. Let's say I have frequencies f(a) for each a from 0 to n.

Then, the number of ways to choose three sticks with lengths 2^a, 2^b, 2^c, where a, b, c are exponents, and a <= b <= c, and 2^a + 2^b > 2^c.

Given that 2^a + 2^b > 2^c, and a <= b <= c, I can try to iterate over c and find pairs (a,b) where a <= b and 2^a + 2^b > 2^c.

But since a and b can be up to c, and c can be up to n, this might be time-consuming, especially since t can be up to 10^4 and n up to 3*10^5, with the sum of n over all test cases up to 3*10^5.

I need an efficient way to compute this.

Let me consider that 2^a + 2^b > 2^c is equivalent to a + b > c when a, b, c are exponents, but that's not accurate because 2^a + 2^b can be less than or equal to 2^c depending on the values.

Wait, no, 2^a + 2^b is equal to 2^a (1 + 2^{b-a}), which is less than or equal to 2^{b+1} if b > a.

So, if b +1 > c, then 2^{b+1} > 2^c, which would mean 2^a + 2^b > 2^c.

Wait, but 2^{b+1} is equal to 2 * 2^b, which is greater than 2^b, but I need to see if 2^a + 2^b > 2^c.

Wait, maybe I should think in terms of logarithms or properties of exponents.

Alternatively, perhaps I can group sticks by their length and then calculate combinations based on their frequencies.

Let me consider that.

Suppose I have frequencies f(a) for each a from 0 to n.

Then, the number of ways to choose three sticks with the same length is C(f(a), 3) if f(a) >=3.

Similarly, the number of ways to choose two sticks of one length and one of another is C(f(a), 2) * (total sticks minus f(a)).

Wait, but this might not directly account for the triangle inequality.

Wait, perhaps I need to iterate through possible c values and find all pairs (a,b) where a <= b and 2^a + 2^b > 2^c.

Given that, I can sort the a_i in ascending order, and for each c, find the number of pairs (a,b) with a <= b and 2^a + 2^b > 2^c.

Given that a <= b <= c, I can fix c and find the number of pairs (a,b) where a <= b and a, b <= c, and 2^a + 2^b > 2^c.

This seems manageable.

To optimize, I can sort the a_i and for each c, find the range of a and b where a <= b and a, b <= c, and 2^a + 2^b > 2^c.

But with n up to 3*10^5 and t up to 10^4, I need an O(n log n) solution per test case.

Wait, but the sum of n over all test cases is 3*10^5, so it should be fine.

Let me think about how to implement this efficiently.

First, sort the a_i in ascending order for each test case.

Then, for each c from 0 to n, precompute the number of pairs (a,b) where a <= b and a, b <= c and 2^a + 2^b > 2^c.

Wait, but a and b are exponents, so 2^a + 2^b > 2^c translates to a + b > c in terms of exponents, but that's not accurate because addition doesn't directly translate to exponents.

Wait, perhaps I need to think differently.

Let me consider that for a <= b <= c, 2^a + 2^b > 2^c is equivalent to 2^a + 2^b > 2^c.

Given that 2^a + 2^b is at most 2^{b+1} if a < b, and 2^{a+1} if a = b.

So, if a = b, then 2^{a+1} > 2^c, which implies a +1 > c, or a >= c.

But a <= b <= c, so a <= c.

Wait, that can't be.

Wait, 2^{a+1} > 2^c implies a +1 > c.

But a <= b <= c, so a <= c.

So, for a +1 > c, that would require a >= c, which with a <= c can only happen if a = c and c >=1.

Wait, that seems messy.

Maybe I should look for a different approach.

I recall that for powers of 2, the largest stick must be less than the sum of the other two.

Given that, perhaps I can iterate through all possible triplets and check the condition, but that's too slow for n=3*10^5.

I need a smarter way.

Let me consider that in sorted order, for a <= b <= c, 2^a + 2^b > 2^c.

Given that, perhaps for each c, I can find the number of pairs (a,b) where a <= b <= c and 2^a + 2^b > 2^c.

To optimize, perhaps for each c, I can find the minimum b such that for a given a, 2^a + 2^b > 2^c.

Given that, I can fix a and find the smallest b where 2^a + 2^b > 2^c.

But this seems complicated.

Wait, perhaps I can use the fact that 2^a + 2^b > 2^c is equivalent to 2^b > 2^c - 2^a.

Given that 2^c - 2^a is equal to 2^a (2^{c-a} -1), so 2^b > 2^a (2^{c-a} -1).

But I'm not sure if that helps.

Alternatively, perhaps I can iterate over c, and for each c, fix a, and find the smallest b where 2^a + 2^b > 2^c.

Given that, for a fixed a and c, I can solve for b.

Wait, perhaps.

Let me try to find a better way.

I found that in discussions, people mention that for powers of 2, the triangle can only be formed if two sides are equal and the third is smaller.

Wait, is that true?

Let's take an example: sticks of lengths 2^1, 2^1, 2^1: 2,2,2. This can form a triangle since 2 + 2 > 2.

Another example: 2^1, 2^1, 2^2: 2,2,4. Here, 2 + 2 = 4, which is not strictly greater than 4, so it's degenerate.

Wait, but the problem says non-degenerate triangle, so area >0, which means sum of any two sides must be strictly greater than the third.

So, in this case, 2 + 2 = 4 is not strictly greater than 4, so it's invalid.

Another example: 2^0, 2^1, 2^1: 1,2,2. 1 + 2 > 2, 1 + 2 > 2, 2 + 2 >1, so this is valid.

Wait, but in the problem's example, when n=7 and all a_i=1, which means all sticks have length 2, and choosing any three would be 2,2,2, which should be invalid based on the previous example.

But in the problem's example, it says that any three sticks can be chosen, which would mean that 2,2,2 is valid, but according to the triangle inequality, 2 + 2 > 2 is true, so area would be greater than 0.

Wait, maybe I miscalculated earlier. For sides 2,2,2: 2 + 2 > 2, which is true, so it's a valid triangle.

For sides 2,2,4: 2 + 2 > 4? 4 > 4 is false, so invalid.

So, in the first test case, all a_i=1, which means all sticks have length 2, and choosing any three would be 2,2,2, which is valid.

In the second test case, a_i=3,2,1,3, which means lengths 8,4,2,8.

Possible triplets:

- 2,4,8: 2 +4 =6 >8? No, so invalid.

- 2,8,8: 2 +8=10 >8, 2 +8=10 >8, 8 +8=16 >2, so valid.

- 4,8,8: 4 +8=12 >8, 4 +8=12 >8, 8 +8=16 >4, so valid.

So, there are two valid triplets, which matches the sample output.

In the third test case, a_i=1,2,3: lengths 2,4,8.

Possible triplets:

- 2,4,8: 2 +4=6 >8? No, so invalid.

Hence, 0 valid triplets.

In the fourth test case, a_i=1: only one stick, so cannot form any triangle, hence 0.

So, the approach should be to count the number of triplets where the sum of any two is greater than the third.

Given that, and considering that lengths are powers of 2, perhaps there's a way to exploit the frequency of each length.

Let me try to think in terms of frequency.

Let me denote f[a] as the frequency of exponent a.

Then, the number of ways to choose three sticks with exponents a,b,c where a <= b <= c and 2^a + 2^b > 2^c.

I need to iterate over all possible c, and for each c, find the number of pairs (a,b) where a <= b <= c and 2^a + 2^b > 2^c.

Given that, perhaps I can precompute the cumulative frequencies.

Wait, perhaps I can sort the exponents and for each c, find the number of pairs (a,b) where a <= b <= c and 2^a + 2^b > 2^c.

To optimize, perhaps for each c, find the minimal a and b such that a <= b <= c and 2^a + 2^b > 2^c.

But I need a better way.

Let me consider that for a <= b <= c, 2^a + 2^b > 2^c.

Given that, perhaps I can iterate over c from smallest to largest, and maintain a list of a and b where a <= b <= c.

Wait, perhaps using two pointers.

Let me sort the exponents in ascending order.

Then, for each c, find the number of pairs (a,b) where a <= b <= c and 2^a + 2^b > 2^c.

Given that, perhaps for each c, I can find the minimal a and b such that a <= b and 2^a + 2^b > 2^c.

Wait, maybe I can fix c and iterate a from smallest to largest, and for each a, find the minimal b such that 2^a + 2^b > 2^c.

Given that, I can use two pointers for a and b.

Let me try to implement this logic.

First, sort the exponents a_i in ascending order.

Then, for each c from 0 to n-1:

Find the number of pairs (a,b) where a <= b <= c and 2^a + 2^b > 2^c.

To optimize, I can iterate c from smallest to largest, and maintain pointers for a and b.

Wait, perhaps I can iterate c from smallest to largest, and for each c, iterate a from smallest to c, and for each a, find the minimal b where 2^a + 2^b > 2^c.

Given that, I can precompute for each a, the minimal b where 2^a + 2^b > 2^c.

Wait, but c is varying, so I need to adjust b based on c.

This seems tricky.

Maybe I can precompute for each c, the minimal a and b where a <= b and 2^a + 2^b > 2^c.

Wait, perhaps it's better to iterate over c, and for each c, iterate a from 0 to c, and find the minimal b from a to c where 2^a + 2^b > 2^c.

Given that, I can use a sliding window approach.

Wait, maybe I need to think in terms of frequency and combinations.

Let me consider that.

Suppose I have frequencies f[a] for each a.

Then, the number of ways to choose three sticks with exponents a,b,c where a <= b <= c and 2^a + 2^b > 2^c.

I can iterate over c from min(a) to max(a), and for each c, calculate the number of pairs (a,b) where a <= b <= c and 2^a + 2^b > 2^c.

To optimize, perhaps I can precompute the cumulative frequency up to each c, and then subtract the invalid pairs.

Wait, perhaps I need to think in terms of inclusion-exclusion.

Alternatively, perhaps I can use the fact that for a <= b <= c, 2^a + 2^b > 2^c only if b > c -1.

Wait, not sure.

Let me consider specific cases.

Case 1: a = b = c.

Then, 2^a + 2^b = 2^{a+1} > 2^c =2^a.

This holds if a +1 > a, which is always true.

So, triplets where a = b = c are always valid.

Case 2: a < b = c.

Then, 2^a + 2^b > 2^c => 2^a + 2^b > 2^b => 2^a >0, which is always true.

So, any triplet where two sticks have the same exponent and the third has a smaller exponent is valid.

Case 3: a < b < c.

Then, 2^a + 2^b > 2^c.

Given that a < b < c, 2^a + 2^b > 2^c only if b +1 > c.

Wait, is that true?

2^a + 2^b = 2^a (1 + 2^{b-a}) = 2^a * (1 + 2^{k}), where k = b -a.

This sum is less than or equal to 2^{b+1}.

So, 2^{b+1} > 2^c implies b +1 > c.

Wait, but b < c, so b +1 > c implies b >= c, but b < c, so this is impossible.

Wait, no, if b < c, then b +1 <= c.

So, 2^{b+1} <= 2^c.

Therefore, 2^a + 2^b <= 2^{b+1} <= 2^c, which is not greater than 2^c.

Hence, in this case, 2^a + 2^b <= 2^c, so it's invalid.

Therefore, the only valid triplets are those where at least two sticks have the same exponent.

Wait, is that accurate?

Let me check.

From case 1: a = b = c, valid.

Case 2: a < b = c, valid.

Case 3: a < b < c, invalid.

Hence, only triplets where at least two sticks have the same exponent are valid.

Wait, but in the sample input, n=4, a_i=3,2,1,3.

So, exponents are 3,2,1,3.

Sorted: 1,2,3,3.

Possible triplets:

- 1,2,3: 2^1 + 2^2 = 2 + 4 =6 > 8? No.

- 1,2,3: invalid.

- 1,3,3: 2^1 + 2^3 =2 +8=10 >8, yes.

- 2,3,3: 2^2 +2^3=4 +8=12 >8, yes.

Hence, only triplets where at least two sticks have the same exponent are valid.

Wait, but in the first test case, all a_i=1, so all triplets have a = b = c =1, which are valid.

In the third test case, a_i=1,2,3: only possible triplet is 1,2,3, which is invalid.

In the fourth test case, only one stick, no triplets.

Hence, the conclusion seems to hold.

Therefore, the number of valid triplets is equal to the total number of triplets minus the number of triplets where all three exponents are distinct.

Wait, but in the second test case, n=4, a_i=3,2,1,3.

Total triplets: C(4,3)=4.

Valid triplets: 2, as per sample output.

So, total triplets minus triplets with all distinct exponents.

Wait, but in this case, exponents are 1,2,3,3.

Triplets with all distinct exponents: 1,2,3 -> invalid.

Triplets with at least two same exponents: 1,3,3 and 2,3,3 -> valid.

Hence, total triplets:4.

Triplets with all distinct exponents:1.

Hence, valid triplets:4-1=3, but sample output is 2.

Wait, inconsistency here.

Hence, my previous assumption is incorrect.

Hence, the number of valid triplets is not simply total triplets minus triplets with all distinct exponents.

Wait, perhaps I need to calculate the number of triplets where at least two sticks have the same exponent, but not all three.

Wait, but in the first test case, all a_i=1, which means all triplets have a = b = c =1, which are valid.

In the second test case, exponents are 1,2,3,3, and valid triplets are those where at least two exponents are the same.

So, triplets are:

- 1,2,3: invalid.

- 1,3,3: valid.

- 2,3,3: valid.

- 1,2,3: invalid (already counted).

Hence, total valid triplets:2.

Wait, but according to my earlier logic, triplets with at least two same exponents are valid.

Hence, in