Alright, I've got this problem to solve. Let's see what it's asking for. So, we have an undirected weighted graph with n vertices and m edges. The graph might not be connected, and there's at most one edge between any pair of vertices, no self-loops. I need to find a simple cycle where the lightest edge is as minimal as possible.

First, I need to understand what a simple cycle is. A simple cycle doesn't repeat any vertices or edges except for the starting and ending vertex. So, it's like a loop where you don't visit any vertex more than once except for the starting vertex.

The problem wants me to find any simple cycle where the smallest edge weight is as small as possible. So, among all possible simple cycles, I need to find one where the minimum edge weight is the smallest possible.

Looking at the input format, there are multiple test cases, each with n vertices and m edges. Each edge is defined by two vertices and a weight.

I need to output, for each test case, two numbers: the minimum weight of the lightest edge in the found cycle and the number of vertices in that cycle. Then, on the next line, list the vertices in the cycle in the order they are traversed.

The problem guarantees that there is always at least one simple cycle in the graph given the constraints, so I don't need to worry about cases where no cycle exists.

Alright, now to think about how to approach this.

One way to find cycles in a graph is to perform a DFS and keep track of the path from the starting vertex. When you encounter a vertex that's already in the current path, you've found a cycle.

But the problem is to find a cycle where the lightest edge is as small as possible. So, maybe I need to find a cycle with the smallest possible minimum edge weight.

I need to minimize the lightest edge in the cycle.

Hmm.

One idea is to sort the edges by weight and try to find cycles using edges in increasing order of weight. The idea is to find a cycle using the smallest possible edge weights.

But sorting edges by weight might not directly lead to the solution because the lightest edge in a cycle isn't necessarily the smallest edge in the graph.

Wait, maybe I need to think differently.

Suppose I consider the edges in increasing order of weight and try to find the first cycle that includes an edge with that weight.

But that might not work because the lightest edge in a cycle isn't necessarily the edge with the smallest weight in the graph.

Wait, perhaps I should look into Minimum Spanning Tree concepts. In MST, we include edges in increasing order of weight without forming cycles.

So, if I try to build an MST, the edges that are not included in the MST form cycles with the MST.

Maybe I can use that.

Wait, perhaps I can run Kruska's algorithm and look at the edges not included in the MST, since those edges would form cycles with the MST.

Yes, that seems promising.

So, I can build the MST using Kruska's algorithm with Union-Find (DSU).

As I add edges in increasing order of weight, if I encounter an edge that would form a cycle with the current MST, that cycle would be a simple cycle.

So, for each such edge, I can find the cycle it forms with the MST and check the lightest edge in that cycle.

Then, among all such cycles, I need to find the one with the smallest lightest edge.

But this might be inefficient for the given constraints, since t can be up to 10^4 and m up to 2*10^5 per test case, but overall m across all test cases is up to 2*10^5.

Wait, but t is up to 10^4, and m is up to 2*10^5 in total across all test cases, meaning per test case, m can be up to 2*10^5 / t, which for t=10^4 is 0.02*10^5 = 20 edges per test case on average, but the problem states that m can be up to min(n*(n-1)/2, 2*10^5), and n can be up to m, which can be up to 2*10^5.

Wait, the constraints say 3 <= n <= m <= min(n*(n-1)/2, 2*10^5). So m can be up to 2*10^5 per test case, and t up to 10^4, but the sum of m over all test cases is up to 2*10^5.

So, per test case, m can be up to 2*10^5 / 10^4 = 20, on average. But the problem allows m up to min(n*(n-1)/2, 2*10^5), so perhaps some test cases have m up to 2*10^5, but overall across all test cases, the sum of m is up to 2*10^5.

So, I need an efficient solution.

Let me think again.

I need to find a simple cycle with the smallest possible lightest edge.

An alternative approach is to iterate over possible lightest edge weights and check if there's a cycle where the lightest edge is at least that weight.

But that might not be straightforward.

Wait, perhaps I can iterate through the edges in increasing order of weight and maintain a DSU (Disjoint Set Union) structure.

When I add an edge that connects two vertices that are already in the same component, it forms a cycle.

So, for each such edge, I can find the cycle formed and check the lightest edge in that cycle.

Then, among all such cycles found, I can choose the one with the smallest lightest edge.

But maintaining the lightest edge in the cycle might be tricky.

Wait, perhaps I can keep track of the minimum edge weight in each component.

So, in the DSU, for each component, I can keep track of the minimum edge weight in that component.

Then, when I add an edge that connects two vertices already in the same component, I can find the minimum edge weight in the cycle formed by adding that edge.

The minimum edge weight in the cycle would be the minimum of the edge being added and the minimum edge weight in the component.

Wait, maybe I need to think more carefully.

Let me consider the following approach:

- Sort all edges in increasing order of weight.

- Initialize a DSU with all vertices in separate components.

- Initialize min_edge for each component to infinity.

- For each edge in sorted order:

- If the two vertices are in different components:

- Union the components.

- Update the min_edge of the new component accordingly.

- Else:

- They are in the same component, so adding this edge forms a cycle.

- The lightest edge in this cycle would be the minimum of the current edge's weight and the min_edge of the component.

- Keep track of the cycle with the smallest lightest edge.

This seems promising.

So, I need to keep track of the min_edge for each component.

When I union two components, the min_edge of the new component would be the minimum of the min_edges of the two components.

When I add an edge that connects two vertices in the same component, the lightest edge in the cycle would be the minimum of the edge's weight and the min_edge of the component.

I need to keep track of the cycle with the smallest lightest edge among all such cycles found.

Then, for output, I need to find the actual cycle that corresponds to that lightest edge.

But how do I find the actual cycle?

I need to reconstruct the cycle.

For that, I need to keep track of the parent or path when I detect the cycle.

Maybe I can perform a DFS from one of the vertices involved in the cycle and track the path until I reach the other vertex, then form the cycle.

But this needs to be efficient, considering the constraints.

Alternatively, I can keep a backpointer in the DSU to reconstruct the path, but that might be complicated.

Let me see.

In the DSU, I can keep track of the parent for each vertex to reconstruct the path when a cycle is detected.

But with union-by-rank or union-by-size, I can't directly keep backpointers.

Maybe I need to use path compression to keep backpointers.

Wait, perhaps I can maintain a tree of the MST and find the path between two vertices when a cycle is formed.

But that might be too slow for the constraints.

I need a better way to reconstruct the cycle efficiently.

Let me consider another approach.

Since the graph is undirected, I can use BFS or DFS to find a cycle when a back edge is encountered.

But again, efficiency is a concern.

Wait, perhaps I can iterate through the edges in increasing order of weight, and for each edge that forms a cycle, keep track of the lightest edge in that cycle and the cycle itself.

But with m up to 2*10^5, and t up to 10^4, but sum of m over all test cases is up to 2*10^5, I need an efficient solution per test case.

Wait, no, t is up to 10^4, and sum of m over all test cases is up to 2*10^5, so per test case, m can be up to 2*10^5 / 10^4 = 20, on average.

But the problem allows m up to min(n*(n-1)/2, 2*10^5) per test case, so some test cases can have up to 2*10^5 edges.

But the sum over all test cases is up to 2*10^5.

So, overall, I need an efficient solution, but per test case, with m up to 2*10^5, I need to make sure it's efficient.

Alright, back to the DSU approach.

I can sort the edges in decreasing order of weight.

Then, start with all vertices in separate components.

Iterate through the edges from highest to lowest weight, and union the components.

If I encounter an edge where both vertices are already in the same component, adding that edge would form a cycle.

The lightest edge in that cycle would be the minimum of the current edge's weight and the minimum edge weight in the component.

So, I can keep track of the minimum edge weight in each component.

When I find such a cycle, I can keep track of the lightest edge in that cycle and the cycle itself.

But reconstructing the cycle efficiently is tricky.

Maybe I can find the path between the two vertices in the component and form the cycle.

But finding paths for each cycle detection might be too slow.

Wait, perhaps I can find the cycle by recording the parent during the union operations.

But that seems complicated.

Alternatively, I can perform a BFS or DFS from one vertex to find the path to the other vertex when a cycle is detected.

But again, with large m, this might be slow.

I need a better way.

Let me look at the reference solution provided.

In the reference solution, it seems to use a DSU structure to keep track of components and their minimum edge weights.

It sorts the edges in decreasing order of weight and iterates through them.

When it finds an edge where both vertices are in the same component, it performs a DFS to find the cycle and outputs the result.

So, it seems to follow the approach I was considering.

In more detail:

- Sort edges in decreasing order of weight.

- Initialize DSU with each vertex in its own component, each with min_edge set to infinity.

- For each edge in sorted order:

- If the two vertices are in different components:

- Union them, updating the min_edge of the new component.

- Else:

- They are in the same component, so adding this edge forms a cycle.

- The lightest edge in this cycle is the minimum of the current edge's weight and the min_edge of the component.

- Record this cycle and its lightest edge.

- Then, perform a DFS to find the actual cycle and output it.

This seems correct.

But I need to make sure that the DFS correctly finds the cycle.

In the DFS, it marks vertices with colors: 0 (not visited), 1 (visiting), 2 (visited).

When it encounters a vertex that is marked as 1 (visiting), it means a cycle is detected, and it can return the path from the current vertex to that vertex.

In the reference solution, it seems to perform a DFS from one of the vertices involved in the cycle (node_u) and look for the other vertex (node_v) in the path.

Once it finds node_v in the path, it can return the cycle.

This should work to find a simple cycle involving node_u and node_v.

Given that the graph is undirected, this should correctly find a simple cycle.

Therefore, the reference solution seems correct.

Hence, Correctness: **True**

**Final Answer**

\[ \boxed{\text{See the reference solution provided}} \]