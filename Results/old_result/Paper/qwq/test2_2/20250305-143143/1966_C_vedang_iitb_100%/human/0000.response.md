Alright, I have this problem here about a game that Alice and Bob are playing with piles of stones. The game rules are a bit unusual: on each turn, a player chooses a positive integer k that is less than or equal to the smallest non-empty pile and removes k stones from every non-empty pile. The player who can't make a move loses, which happens when all piles are empty.

So, I need to determine who wins if both play optimally, given that Alice starts first.

First, I need to understand the game mechanics properly. The key point is that on each turn, the player picks a k and removes k stones from every non-empty pile. This is different from standard game theory problems where stones are removed from a single pile.

Let me think about what happens to the piles when a player chooses a k. If there are piles with different sizes, choosing a k will reduce each pile by k stones, but only if the pile has at least k stones. So, smaller piles might be emptied, while larger ones remain.

I need to find a way to model this game to determine the winner. Since the game involves multiple piles and the moves affect all piles simultaneously, it's not immediately obvious how to approach it.

I recall that in game theory, particularly in impartial games, the concept of Nimbers or the mex function is used to determine the game's state. Maybe that's applicable here.

Let me try to analyze small examples to see if I can find a pattern.

Take the first test case: 5 piles, each with 3 stones.

So, piles: 3, 3, 3, 3, 3.

Alice can choose k up to 3. If she chooses k=3, she removes 3 stones from each pile, making all piles empty. Since there are no stones left, Bob can't make a move and loses. So, Alice wins.

Simple enough.

Second test case: 2 piles, 1 and 7.

Alice must choose k=1 (since the smallest pile has 1 stone). She removes 1 stone from each pile, resulting in piles of 0 and 6.

Now, Bob chooses k up to 6 (since the smallest non-empty pile is 6). He removes 6 stones from each pile, but one pile is already empty, so it remains empty, and the other pile becomes empty as well. Alice can't make a move now, so Bob wins.

Wait, but according to the output, Bob wins this case.

Third test case: 7 piles with sizes 1, 3, 9, 7, 4, 2, 100.

This seems more complex. I need a general approach.

Looking at the provided program, it seems to calculate something called mexsize and compare it to the maximum pile size, then decide based on whether mexsize is even or odd.

I need to understand what mexsize is in this context.

In standard game theory, mex stands for "minimum excludant," which is the smallest non-negative integer not present in a set. But I'm not sure how it's being applied here.

Let me look at the code again.

The code reads the number of test cases t, then for each test case:

- Reads n, the number of piles.

- Reads the pile sizes into a list a.

- Finds the maximum pile size, maxsize.

- Sorts the pile sizes.

- Initializes mexsize to 1.

- Iterates through the sorted pile sizes: for each sz in a, if sz == mexsize, increment mexsize by 1.

- After the loop, compares mexsize to maxsize:

- If mexsize > maxsize:

- Prints "Alice" if mexsize is even, else "Bob".

- Else:

- Prints "Alice" if mexsize is odd, else "Bob".

I need to understand why this logic determines the winner.

First, let's understand what mexsize represents in this context.

The code sorts the pile sizes and then iterates through them, incrementing mexsize each time it finds a pile size that matches the current mexsize.

So, for example, if the sorted piles are [1,1,2,2,3], the iteration would be:

- sz=1 == mexsize=1 → mexsize=2

- sz=1 == mexsize=2? No → mexsize stays 2

- sz=2 == mexsize=2 → mexsize=3

- sz=2 == mexsize=3? No → mexsize stays 3

- sz=3 == mexsize=3 → mexsize=4

So, mexsize ends up being 4.

Wait, but in the code, it's compared to maxsize.

In this example, maxsize is 3, so mexsize > maxsize (4 > 3), and since 4 is even, it would print "Alice".

But according to the first test case, where all piles are 3, mexsize would be 4, which is even, so Alice wins, which matches the first test case.

In the second test case: piles [1,7], sorted [1,7].

- sz=1 == mexsize=1 → mexsize=2

- sz=7 == mexsize=2? No → mexsize stays 2

maxsize is 7, which is greater than mexsize (2), so it goes to the else clause.

mexsize is 2, which is even, so it prints "Alice". Wait, but the output is "Bob". So maybe I'm misunderstanding.

Wait, in the else clause, it's "Alice" if mexsize % 2 == 1 else "Bob". So, if mexsize is even, it's "Bob", which matches the second test case output.

Wait, but in the first test case, mexsize is 4, which is even, so it's "Alice", which matches.

In the second test case, mexsize is 2, which is even, so "Bob", which matches the output.

Wait, but in the first test case, all piles are 3, mexsize is 4, even, Alice wins.

In the second test case, piles are 1 and 7, mexsize is 2, even, Bob wins.

Wait, but in my earlier manual calculation, for piles [1,3,9,7,4,2,100], sorted [1,2,3,4,7,9,100], mexsize would be:

- sz=1 == mex=1 → mex=2

- sz=2 == mex=2 → mex=3

- sz=3 == mex=3 → mex=4

- sz=4 == mex=4 → mex=5

- sz=7 != mex=5 → stay at 5

- sz=9 != 5 → stay at 5

- sz=100 !=5 → stay at5

So, mexsize=5, maxsize=100, mexsize < maxsize, so else clause: Alice if 5%2==1 else Bob → Alice, which matches the third test case output.

Seems like the logic is working.

So, I need to understand why this works.

I think mexsize is essentially finding the smallest positive integer not present in the sorted pile sizes.

In the first test case, piles [3,3,3,3,3], sorted [3,3,3,3,3], mexsize=1 (since 1 is not in the piles), then 2 is also not in the piles, so mexsize becomes 1, then 2, etc., until mexsize=4 (since 4 > 3, the max pile size).

In the second test case, [1,7], sorted [1,7], mexsize=2.

In the third test case, [1,2,3,4,7,9,100], mexsize=5.

So, the mexsize is like the smallest positive integer not present in the pile sizes.

Then, the code checks if mexsize > maxsize:

- If yes, Alice wins if mexsize is even, else Bob wins.

- Else, Alice wins if mexsize is odd, else Bob wins.

But why?

I need to find a logical connection between mexsize and the game's outcome.

Perhaps the game can be modeled in such a way that the mexsize determines the number of moves or something similar.

Wait, maybe mexsize represents the number of possible moves or something.

Alternatively, perhaps the game can be seen as equivalent to some standard game in game theory, like Nim, where the mex function is used to calculate the Nimber.

I need to think differently.

Let me consider the number of moves in the game.

Each move consists of choosing a k and removing k stones from every non-empty pile.

The game ends when all piles are empty.

So, the number of moves is equal to the number of times we can choose a k > 0.

But choosing a k removes k stones from all non-empty piles.

This seems similar to the concept of "parallel moves" in multiple piles.

I need to find a way to calculate the total number of moves possible.

If the total number of moves is odd, Alice wins; if even, Bob wins.

Wait, but that might not be directly applicable because the choice of k affects multiple piles at once.

Let me consider the minimal excludant in this context.

The mexsize seems to be calculating the smallest positive integer not present in the pile sizes.

In the first test case, piles are all 3, so mexsize=4 (since 1,2,3 are present).

In the second test case, piles are 1 and 7, mexsize=2.

In the third test case, piles are 1,2,3,4,7,9,100, mexsize=5.

Now, comparing mexsize to maxsize:

- If mexsize > maxsize, which means that all pile sizes from 1 to maxsize are present.

- Else, some numbers between 1 and maxsize are missing.

In the first test case, piles are all 3, so mexsize=4 > maxsize=3, meaning all sizes from 1 to 3 are present.

Wait, but in the first test case, piles are all 3, so 1 and 2 are not present. Wait, no, in the code, it's checking if sz == mexsize, so in [3,3,3,3,3], none of them are 1 or 2, so mexsize becomes 4.

Wait, but according to the code, if mexsize > maxsize, which is 4 > 3, then Alice wins if mexsize is even, which it is, so Alice wins.

But in reality, Alice can choose k=3, remove 3 from each pile, and win immediately.

So, in this case, Alice wins in one move, which is odd number of moves.

Wait, but in the second test case, piles are [1,7], mexsize=2 > maxsize=7? No, maxsize=7, mexsize=2 < 7? Wait, no, maxsize=7, mexsize=2, so 2 < 7, so else clause: Alice if 2%2==0 else Bob → Bob wins.

In this case, Alice chooses k=1, removes 1 from each pile, resulting in [0,6].

Then Bob chooses k=6, removes 6 from the remaining pile, making it empty. So, Alice can't move, Bob wins.

So, in this case, total moves are 2, which is even, and Bob wins.

Wait, perhaps the number of moves determines the winner: if total moves are odd, Alice wins; even, Bob wins.

In the first test case, Alice makes one move and wins, so odd moves, Alice wins.

In the second test case, there are two moves, Alice and Bob, so even moves, Bob wins.

In the third test case, mexsize=5, which is odd, so Alice wins.

Wait, but according to the code, mexsize > maxsize? 5 < 100, so else clause: Alice if 5%2==1 else Bob → Alice wins.

Which matches the sample output.

So, perhaps the parity of mexsize determines the total number of moves.

But I need to confirm this.

Let me consider another example.

Suppose n=1, a=[1].

Sorted: [1], mexsize=2 > maxsize=1 → Alice wins if 2%2==0 else Bob → Alice wins.

Indeed, Alice chooses k=1, removes 1 stone, piles become empty, Alice wins in one move, which is odd, Alice wins.

Another example: n=3, a=[1,2,3].

Sorted: [1,2,3], mexsize=4 > maxsize=3 → Alice wins if 4%2==0 else Bob → Alice wins.

Indeed, Alice can choose k=1, removes 1 from each pile: [0,1,2].

Then Bob chooses k up to 1 (the smallest non-empty pile is 1).

Chooses k=1, removes 1 from each: [0,0,1].

Alice chooses k=1, removes 1 from the last pile, making it empty.

No more moves, Bob wins.

Wait, but according to the code, Alice should win, but according to this, Bob wins.

Wait, maybe my understanding is incorrect.

Wait, in this case, mexsize=4 > maxsize=3, so Alice wins, but according to my simulation, Bob wins.

So, perhaps the code is wrong.

Wait, in the sample input, for n=3, a=[1,2,3], the output is "Alice", but according to my simulation, Bob should win.

Wait, maybe I'm simulating incorrectly.

Let me simulate again.

Alice's first move: chooses k=1, removes 1 from each pile: [0,1,2].

Bob's move: chooses k=1, removes 1 from each non-empty pile: [0,0,1].

Alice's move: chooses k=1, removes 1 from the last pile: [0,0,0].

Bob can't make a move, so Alice wins.

Wait, now it seems Alice wins in three moves, which is odd, Alice wins.

But earlier I thought Bob wins, but actually, Alice wins because she makes the last move.

So, total moves: 3, odd, Alice wins.

Which matches the code's output.

Another test case: n=6, a=[2,1,3,4,2,4].

Sorted: [1,2,2,3,4,4], mexsize=5 > maxsize=4 → Alice wins if 5%2==1 else Bob → Alice wins.

But according to the sample output, it's "Bob".

Wait, that's inconsistent.

Wait, in the sample input, for n=6, a=[2,1,3,4,2,4], output is "Bob".

But according to the code, mexsize=5 > maxsize=4, Alice wins if 5%2==1 else Bob → Alice wins, but sample output is "Bob".

So, perhaps the code is incorrect.

Wait, maybe I'm misunderstanding the condition.

Wait, in the code, if mexsize > maxsize, then Alice wins if mexsize % 2 == 0 else Bob.

But in this case, mexsize=5 > maxsize=4, so Alice wins if 5%2==0 else Bob → Bob wins.

But according to the sample output, it's "Bob".

Wait, perhaps I misread the code.

Let me look again.

if mexsize > maxsize:

print('Alice' if mexsize % 2 == 0 else 'Bob')

else:

print('Alice' if mexsize % 2 == 1 else 'Bob')

In this case, mexsize=5 > maxsize=4, so it's Alice if 5%2==0 else Bob → 5%2==1, so Bob.

But the sample output is "Bob", which matches.

Wait, in my earlier simulation, I thought Alice would win, but according to the code, it's Bob.

But upon re-simulation, Alice makes the third move and wins, which is Alice.

So, perhaps the code is incorrect.

Wait, maybe my simulation was wrong.

Let me try again.

n=6, a=[2,1,3,4,2,4]

Sorted: [1,2,2,3,4,4]

mexsize=5 > maxsize=4 → Alice wins if 5%2==0 else Bob → Bob wins.

But according to the simulation, Alice can win.

Wait, perhaps the code is incorrect.

Alternatively, maybe the simulation is too complex, and the code's logic is correct based on some game theory I'm not grasping.

I need to think differently.

Perhaps the number of moves is equal to mexsize.

In the first test case, mexsize=4, which is even, Alice wins.

Wait, but in the simulation, Alice wins in 1 move, which is odd.

In the second test case, mexsize=2, even, Bob wins.

In the third test case, mexsize=5, odd, Alice wins.

Wait, but according to the code, when mexsize > maxsize, Alice wins if mexsize is even, else Bob.

In the third test case, mexsize=5 > maxsize=4, Alice wins if 5%2==0 else Bob → Bob wins, but sample output is "Alice".

Wait, no, in the third test case, mexsize=5 > maxsize=4, so Alice wins if 5%2==0 else Bob → since 5%2==1, Bob wins, but sample output is "Alice".

So, perhaps the code is incorrect.

Wait, but in the sample input, for n=6, a=[2,1,3,4,2,4], mexsize=5 > maxsize=4, code says Bob wins, and sample output is "Bob".

Wait, but according to my simulation, Alice can win in an odd number of moves.

Wait, perhaps my simulation is flawed.

Alternatively, maybe the number of moves is equal to mexsize.

In the first test case, mexsize=4, even, Alice wins.

But Alice can win in 1 move, which is odd.

In the second test case, mexsize=2, even, Bob wins.

In the third test case, mexsize=5, odd, Alice wins.

Wait, but in the third test case, according to the code, mexsize=5 > maxsize=4, so Alice wins if 5%2==0 else Bob → Bob wins, but sample output is "Alice".

Wait, perhaps I'm miscalculating mexsize.

Wait, in the third test case, a=[1,3,9,7,4,2,100], sorted [1,2,3,4,7,9,100], mexsize=5.

Yes, because 1,2,3,4 are present, next missing is 5.

maxsize=100, which is greater than mexsize=5.

Wait, no, maxsize=100, mexsize=5, so mexsize < maxsize? Wait, no, in the code, if mexsize > maxsize, which is 5 > 100? No, so else clause: Alice if 5%2==1 else Bob → Alice, which matches the sample output.

Wait, perhaps I misread the condition.

Looking back at the code:

if mexsize > maxsize:

print('Alice' if mexsize % 2 == 0 else 'Bob')

else:

print('Alice' if mexsize % 2 == 1 else 'Bob')

In the third test case, mexsize=5 < maxsize=100, so else clause: Alice if 5%2==1 else Bob → Alice, which matches the sample output.

In the sixth test case, n=8, a=[5,7,2,9,6,3,3,2], sorted [2,2,3,3,5,6,7,9], mexsize=1 (since 1 is missing), maxsize=9.

mexsize=1 < maxsize=9, so else clause: Alice if 1%2==1 else Bob → Alice, which matches the sample output.

In the seventh test case, n=1, a=[1000000000], sorted [1000000000], mexsize=1 (since 1 is not present), maxsize=1000000000.

mexsize=1 < maxsize=1000000000, else clause: Alice if 1%2==1 else Bob → Alice, which matches the sample output.

Wait, but in the second test case, n=2, a=[1,7], sorted [1,7], mexsize=2 > maxsize=7, so Alice if 2%2==0 else Bob → Alice if 0 else Bob → Alice, but sample output is "Bob".

Wait, 2%2==0, so Alice wins, but sample output is "Bob".

Wait, no, in the code, if mexsize > maxsize, print 'Alice' if mexsize % 2 == 0 else 'Bob'.

Here, mexsize=2 > maxsize=1? Wait, no, in the second test case, n=2, a=[1,7], maxsize=7, mexsize=2.

Wait, in the earlier simulation, Alice chooses k=1, removes 1 from each pile: [0,6], then Bob chooses k=6, removes 6 from the remaining pile: [0,0], Alice can't move, Bob wins.

But according to the code, mexsize=2 > maxsize=7? No, mexsize=2 < maxsize=7.

Wait, no, in the code, it's if mexsize > maxsize.

In this case, mexsize=2 < maxsize=7, so else clause: Alice if 2%2==1 else Bob → Bob wins, which matches the sample output.

Wait, but earlier I thought mexsize=2 > maxsize=7, but actually, 2 < 7.

I must have misread earlier.

So, in the second test case, mexsize=2 < maxsize=7, else clause: Alice if 2%2==1 else Bob → Bob wins, which matches the sample output.

In the first test case, mexsize=4 > maxsize=3, Alice if 4%2==0 else Bob → Alice wins, which matches the sample output.

In the third test case, mexsize=5 < maxsize=100, Alice if 5%2==1 else Bob → Alice wins, which matches.

In the fourth test case, n=3, a=[1,2,3], sorted [1,2,3], mexsize=4 > maxsize=3, Alice if 4%2==0 else Bob → Alice wins, which matches the sample output "Alice".

In the fifth test case, n=6, a=[2,1,3,4,2,4], sorted [1,2,2,3,4,4], mexsize=5 > maxsize=4, Alice if 5%2==0 else Bob → Bob wins, which matches the sample output "Bob".

In the sixth test case, n=8, a=[5,7,2,9,6,3,3,2], sorted [2,2,3,3,5,6,7,9], mexsize=1 < maxsize=9, Alice if 1%2==1 else Bob → Alice, which matches "Alice".

In the seventh test case, n=1, a=[1000000000], sorted [1000000000], mexsize=1 < maxsize=1000000000, Alice if 1%2==1 else Bob → Alice, which matches "Alice".

So, in all sample test cases, the code's output matches the sample output.

Therefore, the code seems to be correct.

But to be thorough, I need to understand why this logic works.

I think the key is understanding the relationship between mexsize and the game's outcome.

The mexsize represents the smallest positive integer not present in the pile sizes.

If mexsize > maxsize, it means that all pile sizes from 1 to maxsize are present.

Wait, no, in the first test case, piles are all 3, so 1 and 2 are missing, mexsize=4 > maxsize=3.

Wait, perhaps I need to think differently.

Maybe the number of missing sizes determines something.

Alternatively, perhaps the mexsize indicates the number of possible moves or something similar.

I need to relate it to the game's mechanics.

Each move reduces the piles by k stones, where k is at most the smallest pile.

The game continues until all piles are empty.

I need to find the total number of moves possible.

If the total number of moves is odd, Alice wins; if even, Bob wins.

So, perhaps mexsize is related to the number of moves.

Wait, in the first test case, mexsize=4, and Alice wins in 1 move.

In the second test case, mexsize=2, and there are 2 moves.

In the third test case, mexsize=5, and perhaps the number of moves is odd.

Wait, maybe the number of moves is equal to mexsize - 1.

In the first test case, mexsize=4, moves=3, but Alice wins in 1 move.

Wait, not matching.

In the second test case, mexsize=2, moves=2.

In the third test case, mexsize=5, moves=4, but Alice wins in an odd number of moves.

Wait, this is confusing.

Alternatively, maybe the game can be modeled as a Nim game with mexsize representing something.

I need to think about the game in terms of impartial game theory.

Each position in the game is a state defined by the current pile sizes.

A move consists of choosing a k and subtracting k from each non-empty pile.

This is similar to a parallel move in multiple piles.

I need to find the Grundy number for this game state.

But calculating the Grundy number for each state directly is too time-consuming for large n and a_i up to 1e9.

So, perhaps there's a pattern or a mathematical formula that can determine the winner without simulating the game.

Looking back at the code, it seems to suggest that the winner can be determined based on the parity of mexsize, depending on whether mexsize is greater than maxsize or not.

Given that the code matches all sample test cases, and I couldn't find any contradictions, I'll assume that the logic is correct.

Therefore, the program is correct.

**Final Answer**

\boxed{\text{The given program is correct.}}