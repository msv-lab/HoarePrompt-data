Alright, I have this problem to solve. Let's read it carefully.

We have n signs of the apocalypse, each occurring every a_i years. The signs must occur sequentially, meaning each sign must occur strictly after the previous one. I need to find out in which year the n-th sign will occur, which marks the apocalypse.

First, I need to understand what it means for the signs to occur sequentially. It means that each sign must happen after the previous one has occurred. So, if the first sign occurs in year x, then the second sign must occur in some year greater than x, and so on.

Given that each sign occurs periodically every a_i years, their occurrence years are multiples of a_i. For example, if a_1 = 3, then the first sign occurs in years 3, 6, 9, 12, etc.

The challenge is to find the earliest year where all signs have occurred in sequence, with each subsequent sign occurring after the previous one.

Let me think about how to approach this.

One way is to simulate the process:

1. Start with the first sign. Find the smallest year where the first sign occurs, which is a_1.

2. Then, for the second sign, find the smallest year greater than the year where the first sign occurred, where the second sign occurs, which is the smallest multiple of a_2 greater than the year of the first sign.

3. Continue this process for all n signs, ensuring each sign occurs after the previous one.

This seems straightforward, but I need to make sure it's efficient, especially since n can be up to 100 and a_i can be up to 10^6, and t can be up to 1000, so overall time complexity is important.

Let me consider the example provided:

Input:

4

6

3 2 4 5 9 18

5

1 2 3 4 5

5

1 1 1 1 1

6

50 30 711 200 503 1006

Output:

36

5

5

2012

In the first test case:

n=6, a=[3,2,4,5,9,18]

- First sign occurs in year 3.

- Second sign must occur after year 3, so the next multiple of 2 after 3 is 4.

- Third sign must occur after year 4, next multiple of 4 after 4 is 8.

- Fourth sign must occur after year 8, next multiple of 5 after 8 is 10.

- Fifth sign must occur after year 10, next multiple of 9 after 10 is 18.

- Sixth sign must occur after year 18, next multiple of 18 after 18 is 36.

So, the apocalypse occurs in year 36.

This matches the sample output.

Now, to generalize this process:

Initialize the current year to 0.

For each sign from 1 to n:

Find the smallest multiple of a_i that is greater than the current year.

Set the current year to that multiple.

The final current year will be the year when the n-th sign occurs.

This seems simple enough, but I need to ensure that this is correct and efficient.

Let's think about how to find the smallest multiple of a_i greater than the current year.

Given a current year y, the smallest multiple of a_i greater than y is ceil(y / a_i + 1) * a_i.

Alternatively, a more efficient way is y + a_i - (y % a_i), but if y is a multiple of a_i, then this would be y + a_i, which is the next multiple.

Wait, if y is a multiple of a_i, and we need a strictly greater year, then y + a_i is the next multiple.

If y is not a multiple of a_i, then the next multiple is y - (y % a_i) + a_i.

Wait, no. If y is not a multiple of a_i, the next multiple is y + (a_i - y % a_i).

Yes, that's correct.

So, for each sign, update the current year to y + a_i - (y % a_i), where y is the current year.

But, I need to ensure that the new year is strictly greater than the current year.

Wait, since the signs must occur strictly after the previous one, and a_i >=1, this should be fine.

Let me test this logic with the first sample.

Initialize y=0.

Sign 1: a=3.

Next multiple of 3 after 0 is 3. So, y=3.

Sign 2: a=2.

Next multiple of 2 after 3 is 4. So, y=4.

Sign 3: a=4.

Next multiple of 4 after 4 is 8. So, y=8.

Sign 4: a=5.

Next multiple of 5 after 8 is 10. So, y=10.

Sign 5: a=9.

Next multiple of 9 after 10 is 18. So, y=18.

Sign 6: a=18.

Next multiple of 18 after 18 is 36. So, y=36.

Matches the sample.

Another sample:

n=5, a=[1,2,3,4,5]

Initialize y=0.

Sign 1: a=1.

Next multiple of 1 after 0 is 1. So, y=1.

Sign 2: a=2.

Next multiple of 2 after 1 is 2. So, y=2.

Sign 3: a=3.

Next multiple of 3 after 2 is 3. So, y=3.

Sign 4: a=4.

Next multiple of 4 after 3 is 4. So, y=4.

Sign 5: a=5.

Next multiple of 5 after 4 is 5. So, y=5.

Matches the sample output of 5.

Another sample:

n=5, a=[1,1,1,1,1]

Initialize y=0.

Sign 1: a=1.

Next multiple of 1 after 0 is 1. So, y=1.

Sign 2: a=1.

Next multiple of 1 after 1 is 2. So, y=2.

Sign 3: a=1.

Next multiple of 1 after 2 is 3. So, y=3.

Sign 4: a=1.

Next multiple of 1 after 3 is 4. So, y=4.

Sign 5: a=1.

Next multiple of 1 after 4 is 5. So, y=5.

Again matches the sample output of 5.

Last sample:

n=6, a=[50,30,711,200,503,1006]

Initialize y=0.

Sign 1: a=50.

Next multiple of 50 after 0 is 50. So, y=50.

Sign 2: a=30.

Next multiple of 30 after 50 is 60. So, y=60.

Sign 3: a=711.

Next multiple of 711 after 60 is 711. So, y=711.

Sign 4: a=200.

Next multiple of 200 after 711 is 800. So, y=800.

Sign 5: a=503.

Next multiple of 503 after 800 is 1006. So, y=1006.

Sign 6: a=1006.

Next multiple of 1006 after 1006 is 2012. So, y=2012.

Matches the sample output of 2012.

Seems correct.

Now, let's think about edge cases.

Edge Case 1: n=1, a=[5]

Then, the apocalypse occurs in year 5.

Edge Case 2: n=2, a=[2,3]

Initialize y=0.

Sign 1: a=2. Next multiple after 0 is 2. y=2.

Sign 2: a=3. Next multiple after 2 is 3. y=3.

Apocalypse in year 3.

Edge Case 3: n=3, a=[1,1,1]

Initialize y=0.

Sign 1: a=1. Next multiple after 0 is 1. y=1.

Sign 2: a=1. Next multiple after 1 is 2. y=2.

Sign 3: a=1. Next multiple after 2 is 3. y=3.

Apocalypse in year 3.

Edge Case 4: n=2, a=[5,5]

Initialize y=0.

Sign 1: a=5. Next multiple after 0 is 5. y=5.

Sign 2: a=5. Next multiple after 5 is 10. y=10.

Apocalypse in year 10.

Edge Case 5: n=2, a=[1,1000000]

Initialize y=0.

Sign 1: a=1. Next multiple after 0 is 1. y=1.

Sign 2: a=1000000. Next multiple after 1 is 1000000. y=1000000.

Apocalypse in year 1000000.

Edge Case 6: n=1, a=[1]

Apocalypse in year 1.

Edge Case 7: n=1, a=[1000000]

Apocalypse in year 1000000.

Seems all covered.

Now, think about the time complexity.

For each test case, we have n steps, each step involving simple arithmetic operations, which are O(1).

So, total time complexity is O(t * n), which should be acceptable since t <= 1000 and n <= 100.

Now, let's think about implementing this logic.

I need to read t test cases, each consisting of n and then n integers a_1 to a_n.

For each test case, initialize y=0, then for each a_i, set y to the smallest multiple of a_i greater than y.

Finally, output y for each test case.

Now, to implement the next multiple function.

Define a function next_multiple(y, a):

if y % a == 0:

return y + a

else:

return y - (y % a) + a

Or, more concisely:

return y + a - (y % a)

But if y is a multiple of a, y % a == 0, so y + a - 0 = y + a, which is the next multiple.

If y is not a multiple of a, y + a - (y % a) gives the next multiple.

Yes, this works.

Let me test this function:

y=0, a=5 -> 0 + 5 - 0 = 5

y=3, a=2 -> 3 + 2 - 1 = 4

y=4, a=4 -> 4 + 4 - 0 = 8

y=8, a=5 -> 8 + 5 - 3 = 10

y=10, a=9 -> 10 + 9 - 1 = 18

y=18, a=18 -> 18 + 18 - 0 = 36

Correct as per the sample.

Good.

Now, implement this in code.

I need to read t, then for each test case, read n, then read n integers.

I need to read all input at once and split it into tokens, then process them one by one.

I need to make sure to handle the input correctly, especially since there are multiple test cases.

Let me think about the input format.

First line: t

Then, for each test case:

- First line: n

- Second line: n integers a_1 to a_n

I need to read the input efficiently.

In Python, it's efficient to read all input at once using sys.stdin.read(), split it into tokens, and then process them using an index.

Let me write a main function to handle this.

Define a function main():

import sys

data = sys.stdin.read().split()

index = 0

t = int(data[index])

index += 1

for _ in range(t):

n = int(data[index])

index += 1

a = []

for _ in range(n):

a.append(int(data[index]))

index += 1

y = 0

for ai in a:

y = y + ai - (y % ai)

print(y)

This should work.

Let me test it with the first sample.

Input:

4

6

3 2 4 5 9 18

5

1 2 3 4 5

5

1 1 1 1 1

6

50 30 711 200 503 1006

Output should be:

36

5

5

2012

Let's simulate:

Test case 1:

n=6, a=[3,2,4,5,9,18]

y=0

y=0+3-0=3

y=3+2-1=4

y=4+4-0=8

y=8+5-3=10

y=10+9-1=18

y=18+18-0=36

Correct.

Test case 2:

n=5, a=[1,2,3,4,5]

y=0

y=0+1-0=1

y=1+2-1=2

y=2+3-2=3

y=3+4-3=4

y=4+5-4=5

Correct.

Test case 3:

n=5, a=[1,1,1,1,1]

y=0

y=0+1-0=1

y=1+1-1=1

y=1+1-1=1

y=1+1-1=1

y=1+1-1=1

Wait, but according to earlier reasoning, it should be y=5.

Wait, there's a mistake here.

Wait, no, in the earlier reasoning, y was incremented by 1 each time because y % 1 = 0.

Wait, no.

Wait, y=0

y=0+1-0=1

y=1+1-0=2

y=2+1-0=3

y=3+1-0=4

y=4+1-0=5

Ah, I see, I must have miscalculated earlier.

Yes, y=1+1-1=1 is incorrect because y % 1 =0 always.

Wait, no, y=0+1-0=1

Then y=1+1-0=2

Then y=2+1-0=3

Then y=3+1-0=4

Then y=4+1-0=5

Yes, correct.

So, the code is correct.

Another test case:

n=2, a=[2,3]

y=0+2-0=2

y=2+3-2=3

Correct, apocalypse in year 3.

Another test case:

n=2, a=[5,5]

y=0+5-0=5

y=5+5-0=10

Correct, apocalypse in year 10.

Seems correct.

Now, think about possible issues.

Issue 1: a_i =1

No problem, as shown in earlier test cases.

Issue 2: y becomes very large.

But y is the sum of some multiples, and since a_i can be up to 1e6 and n up to 100, y can be up to around 1e8, which is acceptable.

Issue 3: y overflows.

In Python, integers can be arbitrarily large, so no problem.

Issue 4: a_i =1 and y=0.

y=0+1-0=1, correct.

Issue 5: a_i > y.

Then y + a_i - y % a_i = y + a_i - y = a_i, which is correct.

Wait, no, y % a_i for y < a_i is y, so y + a_i - y = a_i, which is the first multiple greater than y.

Correct.

Issue 6: a_i = y.

Then y + a_i - 0 = y + a_i, which is the next multiple.

Correct.

Seems all covered.

Now, think about the provided program.

Wait, the provided program is for a different problem.

Wait, hold on.

The provided program is:

def func_1(path):

n = len(path)

if n == 0:

return 0

dp = [0] * n

if path[0] == '@':

dp[0] = 1

elif path[0] == '*':

dp[0] = -float('inf')

if n > 1:

if path[1] == '*':

dp[1] = -float('inf')

else:

dp[1] = dp[0] + (1 if path[1] == '@' else 0)

for i in range(2, n):

if path[i] == '*':

dp[i] = -float('inf')

else:

dp[i] = max(dp[i - 1], dp[i - 2]) + (1 if path[i] == '@' else 0)

return max((x for x in dp if x > -float('inf')))

def func_2():

import sys

input = sys.stdin.read

data = input().split()

t = int(data[0])

index = 1

results = []

for _ in range(t):

n = int(data[index])

index += 1

path = data[index]

index += 1

results.append(func_1(path))

for result in results:

print(result)

This seems to be for a different problem, involving some kind of path with characters '@' and '*', and using dynamic programming to count something.

This doesn't relate to the current problem about apocalypse signs.

Wait, perhaps the provided program is incorrect, and I need to determine its correctness.

Wait, no, the problem says: "Your task is to determine if a given Python program is correct based on the provided problem description."

Wait, but the problem description is about the apocalypse signs, but the provided program is for a different problem.

This seems confusing.

Wait, perhaps the task is to determine if the provided program correctly solves the apocalypse signs problem.

But it doesn't seem related.

Wait, perhaps I need to evaluate if the provided program is correct for the given problem.

But the provided program seems to be for a different problem.

Alternatively, maybe the problem description and the program are meant to be related, but they don't seem to match.

Wait, perhaps there's a mistake, and I need to assess the correctness of the provided program for the given problem.

But they don't seem aligned.

Alternatively, maybe the program is incorrect, and I need to identify that.

But without knowing what problem the program is supposed to solve, it's hard to judge.

Wait, perhaps I need to assume that the program is intended to solve the apocalypse signs problem, and I need to determine if it does so correctly.

But that seems forced, as the program appears to be for a different problem.

Alternatively, perhaps the task is to assess the correctness of the program for its own problem, which is described in the example input and output.

But the problem statement says "the provided problem description", which seems to refer to the apocalypse signs problem.

This is confusing.

Perhaps I need to consider that the program is incorrect for the apocalypse signs problem and mark it as such.

Alternatively, maybe the program is correct, but for a different problem.

Given that, I would say the program is incorrect for the apocalypse signs problem.

Therefore, Correctness: False

## Final Solution
To solve this problem, we need to determine the year in which the n-th sign of the apocalypse occurs, given that each sign occurs periodically and must happen sequentially after the previous one.

### Approach
1. **Initialization**: Start from year 0.
2. **Iterative Calculation**: For each sign, calculate the smallest multiple of its periodicity that is greater than the current year.
3. **Update Current Year**: Set the current year to this new multiple for each subsequent sign.
4. **Result**: The year when the n-th sign occurs will be the final current year after processing all signs.

### Solution Code
```python
def main():
    import sys
    data = sys.stdin.read().split()
    index = 0
    t = int(data[index])
    index += 1
    for _ in range(t):
        n = int(data[index])
        index += 1
        a = []
        for _ in range(n):
            a.append(int(data[index]))
            index += 1
        y = 0
        for ai in a:
            y = y + ai - (y % ai)
        print(y)

if __name__ == "__main__":
    main()
```

### Explanation
1. **Reading Input**: Read all input data at once and split it into tokens for easy access.
2. **Processing Each Test Case**:
   - Read the number of signs `n`.
   - Read the periodicities of the n signs.
3. **Calculating the Apocalypse Year**:
   - Initialize the current year `y` to 0.
   - For each sign, calculate the next occurrence year by finding the smallest multiple of its periodicity that is greater than the current year.
   - Update the current year to this new multiple.
4. **Output the Result**: Print the final year for each test case.

This approach ensures that we efficiently determine the year of the apocalypse by sequentially calculating the occurrence years of each sign, adhering to their periodicities and the condition of strict sequencing.