Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm the CEO of a startup, and I need to buy tickets for my employees to a concert. There are n days to buy tickets, and each day has a certain price per ticket, given by the list a_i. There are some constraints:

1. I can't buy more than m tickets per day.

2. If I buy x tickets on a particular day, the price per ticket increases by x for all subsequent days.

My goal is to buy exactly k tickets at the minimum total cost.

First, I need to understand the problem fully. I have to buy k tickets across n days, with daily limits on how many I can buy each day, and there's this complicating factor that each time I buy tickets on a day, it increases the price for all future days.

Let me try to rephrase the problem to make sure I get it. Each day has a base price for tickets, but this price can increase based on how many tickets I've bought on previous days. Specifically, if I buy x tickets on day i, then for all days j > i, the price per ticket increases by x.

So, the total cost on day i is the number of tickets bought on that day multiplied by the current price per ticket, which is the original price plus the sum of all tickets bought on previous days.

I need to minimize the total cost for buying exactly k tickets, respecting the daily limits.

Let me consider a small example to grasp this better. Take the first example from the problem:

n = 4, m = 2, k = 3

a = [8, 6, 4, 2]

According to the explanation, one optimal way is:

- Buy 0 on day 1: prices become [6, 4, 2]

- Buy 0 on day 2: prices become [4, 2]

- Buy 1 on day 3: cost = 4, prices become [3]

- Buy 2 on day 4: cost = 6

Total cost = 4 + 6 = 10

Another possible way:

- Buy 1 on day 1: cost = 8, prices become [7, 5, 3]

- Buy 1 on day 2: cost = 7, prices become [6, 4]

- Buy 1 on day 3: cost = 6

Total cost = 8 + 7 + 6 = 21

So, clearly, buying later is better in this case because the prices decrease over time, and delaying purchases reduces the price increases for future days.

Wait, but in the second test case:

n = 4, m = 2, k = 8

a = [8, 6, 4, 2]

Here, the only way is to buy 2 each day:

- Day 1: buy 2, cost = 16, prices become [8, 6, 4]

- Day 2: buy 2, cost = 16, prices become [8, 6]

- Day 3: buy 2, cost = 16, prices become [8]

- Day 4: buy 2, cost = 16

Total cost = 64

But is there a better way? Let's see:

If I buy more on earlier days, the prices increase more for future days. Maybe buying as late as possible is better, like in the first example.

Another example:

n = 5, m = 100, k = 1

a = [10000, 1, 100, 10, 1000]

Here, m is 100, which is more than enough for k=1. So, I can buy the ticket on any day, but I need to choose the day where the total cost is minimized, considering the price increases.

If I buy on day 1:

- Buy 1 on day 1: cost = 10000, prices for day 2-5 become [10001, 10000, 10001, 10001]

Total cost = 10000

If I buy on day 2:

- Buy 0 on day 1: prices become [1, 100, 10, 1000]

- Buy 1 on day 2: cost = 1, prices become [2, 101, 11]

Total cost = 1

If I buy on day 3:

- Buy 0 on day 1: prices become [1, 100, 10, 1000]

- Buy 0 on day 2: prices become [2, 101, 11, 1001]

- Buy 1 on day 3: cost = 11

Total cost = 11

So, buying on day 2 is better, with a total cost of 1.

Hence, the minimal cost is 1.

From these examples, it seems that buying on days with lower base prices and as late as possible is beneficial because it minimizes the price increases for future days.

But I need a general strategy. Let's think about this.

Let me consider that the price on day i is a_i plus the sum of x_j for all j < i, where x_j is the number of tickets bought on day j.

So, the total cost is sum over i from 1 to n of (x_i * (a_i + sum over j from 1 to i-1 of x_j))

I need to choose x_i for each i such that sum of x_i = k, and x_i <= m for each i, to minimize the total cost.

This seems like an optimization problem with constraints.

I need to minimize the total cost given the constraints.

This looks similar to minimizing a cost function with additive components, where each component depends on the previous decisions.

Maybe I can model this as a dynamic programming problem.

Let me define dp[i][t] as the minimal cost to buy t tickets using the first i days.

Then, dp[i][t] = min over x from 0 to min(m, t) of (x * (a_i + sum over j from 1 to i-1 of x_j)) + dp[i-1][t - x])

But this seems too slow because n and k can be up to 3e5 and 1e9 respectively.

I need a more efficient approach.

Let me think differently.

Suppose I fix the number of tickets I buy on each day, x_1, x_2, ..., x_n, with sum x_i = k and x_i <= m for each i.

The total cost is sum over i of x_i * (a_i + sum over j from 1 to i-1 of x_j)

Let me rearrange this.

Total cost = sum over i of (x_i * a_i) + sum over i of (x_i * sum over j=1 to i-1 of x_j)

The second term is sum over i of (x_i * sum_{j=1}^{i-1} x_j) = sum over i of (x_i * s_{i-1}), where s_i = sum of x_j for j=1 to i.

Wait, s_i = s_{i-1} + x_i.

Wait, maybe there's a better way to express this.

Let me think about the total cost in terms of the cumulative sum of x_i.

Let s_i = sum of x_j for j=1 to i.

Then, the total cost is sum over i of x_i * (a_i + s_{i-1})

Because s_{i-1} is the sum of x_j for j=1 to i-1.

So, total cost = sum over i of (x_i * a_i) + sum over i of (x_i * s_{i-1})

But s_{i-1} = s_i - x_i.

Wait, s_{i-1} = s_i - x_i if i >= 1, with s_0 = 0.

Wait, actually, s_{i-1} is the sum up to i-1.

So, for i=1, s_{0}=0.

For i=2, s_{1}=x_1.

For i=3, s_{2}=x_1 + x_2, etc.

So, total cost = sum over i from 1 to n of (x_i * a_i) + sum over i from 1 to n of (x_i * s_{i-1})

I need to minimize this total cost, given that sum of x_i = k and x_i <= m for all i.

This seems complicated to minimize directly.

Let me see if there's a way to simplify this.

Perhaps I can think of the problem in terms of choosing which days to buy tickets on, considering the increasing prices due to previous purchases.

Wait, maybe I can consider the problem in a different order, like buying tickets on the days with the lowest adjusted prices.

But the prices change based on previous purchases, so it's not straightforward.

Let me consider the greedy approach: always buy as many tickets as possible on the day with the lowest current price.

But the current price on each day changes based on previous purchases.

This seems tricky.

Wait, perhaps I can sort the days in increasing order of a_i and prioritize buying on days with lower a_i, but considering the impact on future prices.

But sorting the days might not be directly applicable because the prices on future days increase based on current purchases.

Let me think about the impact of buying x tickets on day i.

It increases the price for all future days by x, which means that for all days j > i, the price becomes a_j + x.

So, if I buy x tickets on day i, the cost for day i is x * (a_i + t), where t is the sum of all x_j for j < i.

And for all days j > i, the price becomes a_j + t + x.

So, if I buy x tickets on day i, it affects the base price for all subsequent days.

I need to find an order in which to buy tickets to minimize the total cost.

Perhaps I can model this as assigning tickets to days in a way that minimizes the total cost, considering the increasing base prices.

Wait, maybe I can think of it in terms of assigning a certain number of tickets to each day, with the cost per ticket on that day being a_i plus the sum of tickets assigned to previous days.

Let me consider that the total cost is sum over i of x_i * (a_i + sum over j < i of x_j)

Which is equal to sum over i of (x_i * a_i) + (x_i * s_{i-1}), where s_{i-1} is the sum of x_j for j < i.

Wait, s_{i-1} is the cumulative sum up to day i-1.

So, total cost is sum over i of x_i * a_i + x_i * s_{i-1}

Given that s_i = s_{i-1} + x_i, with s_0 = 0.

I need to minimize sum over i of x_i * a_i + x_i * s_{i-1}, subject to sum of x_i = k and x_i <= m for all i.

This seems like a complicated optimization problem.

Let me see if I can find a pattern or a formula to compute the minimal cost without iterating through all possible assignments.

Perhaps I can consider the problem in reverse: starting from the last day and moving backwards.

Wait, in the first example, buying on later days is better because the base prices are lower, and delaying the purchases minimizes the impact on future days.

In the second example, since k is larger, I have to buy on all days, and the minimal cost is achieved by buying the maximum allowed each day.

So, perhaps the strategy is to buy as few tickets as possible on days with higher base prices, and buy more on days with lower base prices.

But considering the increasing nature of future prices, it's beneficial to buy on later days if possible.

But I need a systematic way to determine how many tickets to buy on each day.

Let me consider sorting the days in increasing order of a_i.

If I buy tickets on days with lower a_i, it might be better because the base price is lower, but it also increases the prices for all subsequent days.

So, there's a trade-off.

Maybe I can prioritize buying on days with the lowest a_i, but only after considering the impact on future days.

This seems too vague.

Let me consider the dual approach: instead of thinking about buying tickets on specific days, think about the total cost contributed by each ticket.

Each ticket bought on day i contributes a_i plus the sum of x_j for j < i.

Wait, for each ticket bought on day i, its cost is a_i plus the total number of tickets bought on previous days.

So, if I number the tickets from 1 to k, and assign them to specific days, the cost of the p-th ticket is a_{i} + (p - 1), where i is the day it's assigned to.

Wait, that might not be accurate.

Let me think differently.

Suppose I have to buy k tickets in total.

Each ticket I buy on day i will cost a_i plus the number of tickets already bought on previous days.

So, the cost of the p-th ticket, regardless of the day, is a_i + (p - 1), where p is the order in which it's bought.

Wait, perhaps not.

Let me consider that the first ticket I buy on any day will cost a_i plus the total number of tickets bought on previous days.

The second ticket on that day will cost a_i plus the total number of tickets bought on previous days plus the first ticket on that day, and so on.

This seems complicated.

Maybe I need to think of it in terms of assigning a sequence of ticket purchases across days, where the cost of each ticket depends on the day it's bought and the number of tickets already bought on previous days.

This is getting too convoluted.

Let me try to find a mathematical formula or a pattern.

Suppose I sort the days in increasing order of a_i.

Let's say the sorted prices are b_1 <= b_2 <= ... <= b_n.

Now, suppose I assign x_i tickets to day i in this sorted order.

Then, the cost for day i would be x_i * (b_i + sum of x_j for j < i).

But since the days are sorted by their base prices, and considering that sum of x_j for j < i is the same as the total tickets bought before day i, this might help.

But I'm not sure.

Wait, maybe I can consider the problem as assigning tickets to days in a way that minimizes the sum of (number of tickets on day i) times (base price plus the number of tickets assigned to previous days).

This seems similar to scheduling jobs with processing times and costs.

Wait, perhaps it's similar to the completion time minimization problem.

In fact, this reminds me of the classical problem in scheduling where you have jobs with processing times and costs, and you want to minimize the total cost times the completion time.

In that problem, the optimal schedule is to sort the jobs by their cost per processing time.

Maybe I can draw some analogy here.

In this problem, assigning tickets to days is like scheduling jobs, where each ticket assigned to a day has a cost equal to the base price of that day plus the number of tickets already assigned to previous days.

So, perhaps sorting the days by their base price and assigning as many tickets as possible to the days with the lowest base price is optimal.

But wait, in the first example, it was better to assign tickets to later days with lower base prices.

But in the second example, assigning the maximum allowed per day was necessary because k was large.

Wait, perhaps it's better to assign tickets to days with the lowest adjusted price, which is a_i plus the number of tickets already assigned to previous days.

But this adjusted price increases as more tickets are assigned to previous days.

This seems recursive and not straightforward to optimize.

Let me consider a different perspective.

Suppose I fix the number of tickets assigned to each day, x_1, x_2, ..., x_n, with sum x_i = k and x_i <= m for all i.

Then, the total cost is sum over i of x_i * (a_i + sum over j < i of x_j)

Let s_i = sum over j < i of x_j, which is the total tickets bought before day i.

Then, the total cost is sum over i of x_i * (a_i + s_i)

Now, s_i can be expressed in terms of the cumulative sum.

But I need to minimize this sum.

This seems similar to minimizing a weighted sum, where the weights are (a_i + s_i).

But s_i depends on the previous x_j's, making it interdependent.

This is getting too complicated.

Maybe I need to find a way to compute the minimal cost without iterating through all possible assignments.

Perhaps there's a formula or a mathematical expression that can be derived.

Let me consider small values of n and see if I can find a pattern.

Take n=2, m=2, k=2

a = [3, 2]

Option 1:

- Buy 0 on day 1: prices for day 2 become [2]

- Buy 2 on day 2: cost = 4

Total cost = 4

Option 2:

- Buy 1 on day 1: cost = 3, prices for day 2 become [3 + 1 = 4]

- Buy 1 on day 2: cost = 4

Total cost = 7

Option 3:

- Buy 2 on day 1: cost = 6, prices for day 2 become [3 + 2 = 5]

- Buy 0 on day 2: cost = 0

Total cost = 6

So, the minimal cost is 4, achieved by buying all tickets on the day with the lower base price, after adjusting for the price increases.

Wait, but in this case, buying on day 2 is better, even though its base price is lower, because buying on day 1 increases the price for day 2.

But in the first example, buying on day 3 and day 4 was better.

So, perhaps the general strategy is to buy as many tickets as possible on the days with the lowest base prices, but only after considering the impact on future days.

This seems inconsistent.

Let me try another small example.

n=3, m=1, k=2

a = [1, 2, 3]

Option 1:

- Buy 1 on day 1: cost = 1, prices for day 2 and 3 become [2 + 1 = 3, 3 + 1 = 4]

- Buy 1 on day 2: cost = 3

Total cost = 4

Option 2:

- Buy 0 on day 1: prices for day 2 and 3 become [2, 3]

- Buy 1 on day 2: cost = 2, prices for day 3 become [2 + 1 = 3]

- Buy 1 on day 3: cost = 3

Total cost = 5

Option 3:

- Buy 1 on day 1: cost = 1, prices for day 2 and 3 become [3, 4]

- Buy 0 on day 2: prices for day 3 become [3, 4]

- Buy 1 on day 3: cost = 4

Total cost = 5

So, buying both tickets on day 1 and day 2 gives the minimal cost of 4.

But in this case, buying on day 1 and day 2 is better than buying on day 2 and day 3.

Wait, but in the first example, buying on day 3 and day 4 was better.

So, there doesn't seem to be a consistent rule here.

Maybe I need to think differently.

Let me consider that the total cost can be expressed as sum over i of x_i * a_i + sum over i of x_i * sum over j < i of x_j

Which is sum over i of x_i * a_i + sum over i of x_i * s_{i-1}

Where s_{i-1} is the sum of x_j for j < i.

But s_{i-1} = sum over j from 1 to i-1 of x_j

So, total cost = sum over i of x_i * a_i + x_i * s_{i-1}

I can write this as sum over i of x_i * (a_i + s_{i-1})

Now, s_{i-1} is determined by the previous x_j's.

This seems like a dynamic programming problem, where I can keep track of the cumulative sum s_{i-1} and make decisions for each day.

But with n up to 3e5 and k up to 1e9, a standard DP approach would be too slow.

I need a more efficient way.

Let me consider that the minimal cost can be achieved by assigning as many tickets as possible to the days with the lowest adjusted prices.

The adjusted price for a ticket on day i is a_i plus the number of tickets already bought on previous days.

So, perhaps I can prioritize buying tickets on days with the lowest a_i, but taking into account the increasing base prices for future days.

Wait, maybe I can sort the days in increasing order of a_i and assign tickets accordingly.

Let me try that with the first example.

n=4, m=2, k=3

a = [8,6,4,2]

Sort a: [2,4,6,8]

Now, assign tickets starting from the lowest a_i.

- Assign 2 tickets on the first day (day 4): cost = 2*2 = 4, prices for remaining days increase by 2.

- Assign 1 ticket on the second day (day 3): cost = (4 + 2)*1 = 6

Total cost = 4 + 6 = 10

Which matches the first example.

Another example:

n=4, m=2, k=8

a = [8,6,4,2]

Sort a: [2,4,6,8]

Assign tickets starting from the lowest a_i.

- Assign 2 tickets on day 4: cost = 2*2 = 4, prices for remaining days increase by 2.

- Assign 2 tickets on day 3: cost = (4 + 2)*2 = 12, prices for remaining days increase by 4.

- Assign 2 tickets on day 2: cost = (6 + 4)*2 = 20, prices for remaining day increase by 6.

- Assign 2 tickets on day 1: cost = (8 + 6)*2 = 28

Total cost = 4 + 12 + 20 + 28 = 64

Which matches the second example.

Another example:

n=5, m=100, k=1

a = [10000,1,100,10,1000]

Sort a: [1,10,100,1000,10000]

Assign 1 ticket on the first day (day 2): cost = 1*1 = 1

Total cost = 1

Which matches the third example.

Last example:

n=6, m=3, k=9

a = [5,5,5,5,5,5]

Sort a: [5,5,5,5,5,5]

Assign 3 tickets on day 1: cost = 3*5 = 15, prices for remaining days increase by 3.

Assign 3 tickets on day 2: cost = 3*(5+3) = 24, prices for remaining days increase by 6.

Assign 3 tickets on day 3: cost = 3*(5+6) = 33

Total cost = 15 + 24 + 33 = 72

Which matches the fourth example.

So, it seems that sorting the days by a_i in increasing order and assigning as many tickets as possible to the days with the lowest a_i, considering the daily limits, gives the minimal total cost.

This approach seems to work for all the provided examples.

Therefore, the strategy is:

1. Sort the days in increasing order of a_i.

2. Assign tickets to the sorted days, starting from the lowest a_i.

3. For each day, assign the maximum possible tickets (up to m or the remaining k, whichever is smaller).

4. Keep track of the total cost, considering that each ticket on day i costs a_i plus the total number of tickets already assigned to previous days.

This seems efficient, as sorting can be done in O(n log n), and assigning tickets is O(n).

Given that n can be up to 3e5, this should be efficient enough.

Now, let's look at the provided program and see if it implements this logic correctly.

The program is:

def func():

for i in range(int(input())):

(n, m, k) = map(int, input().split())

l = list(map(int, input().split()))

l.sort()

t = 0

s = 0

c = 0

for i in range(n):

s = min(m, k)

c += s * (l[i] + t)

t += s

k -= s

print(int(c))

This seems to follow the strategy I outlined.

- It sorts the list of a_i in ascending order.

- It iterates through the sorted list, assigning as many tickets as possible to each day, up to m or the remaining k.

- For