Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm the CEO of a startup, and I need to buy tickets for my employees to a concert. There are n days to buy tickets, and each day has a certain price per ticket. There's a limit on how many tickets I can buy per day, which is m, and there's this rule about increasing prices if I buy tickets on a particular day.

Okay, so the problem is to find the minimum amount of money needed to buy exactly k tickets, given these constraints.

First, I need to understand the constraints clearly:

- n: number of days to buy tickets (1 ≤ n ≤ 3*10^5)

- m: maximum tickets可购买 per day (1 ≤ m ≤ 10^9)

- k: total tickets needed (1 ≤ k ≤ min(n*m, 10^9))

- a_i: price per ticket on day i (1 ≤ a_i ≤ 10^9)

And there are two important rules:

1. A person may purchase no more than m tickets per day.

2. If a person purchases x tickets on day i, the prices per ticket for all subsequent days (from day i+1 onwards) increase by x.

My goal is to minimize the total cost of buying exactly k tickets.

Hmm, this seems like an optimization problem, probably involving some sort of scheduling or selection of days to buy tickets.

Let me try to wrap my head around the problem with an example.

Take the first example from the input:

4 2 3

8 6 4 2

So, n=4 days, m=2 tickets per day, k=3 tickets needed.

The prices are 8,6,4,2 per ticket on each day respectively.

Now, according to the explanation, one optimal way is:

- Buy 0 tickets on day 1. Prices for remaining days become [6,4,2]

- Buy 0 tickets on day 2. Prices for remaining days become [4,2]

- Buy 1 ticket on day 3 for 4. Prices for remaining day become [3]

- Buy 2 tickets on day 4 for 6 in total.

Total cost is 4 + 6 = 10.

Another way might be to buy tickets on different days, but this seems to be the optimal strategy.

Wait, why is this the optimal strategy? It seems like buying on the cheaper days, but with the price increases affecting future days.

Let me think differently. If I buy tickets on a day, it increases the price for future days. So, there's a trade-off between buying tickets on a cheap day versus causing higher prices later.

Maybe I should sort the days based on their prices and decide how many tickets to buy each day accordingly.

But the days are given in a specific order, and the price increases affect future days based on how many tickets I buy on a particular day.

This seems complicated. Maybe I need to find a way to model this.

Let me consider that the price increase is cumulative based on the number of tickets bought on previous days.

So, if I buy x tickets on day i, then for all days j > i, the price per ticket increases by x.

My goal is to minimize the total cost, which is the sum of (price per ticket on day i plus the cumulative increases) multiplied by the number of tickets bought on that day.

This sounds like a problem that can be modeled using prefix sums or something similar.

Let me try to formalize this.

Let’s denote:

- Let s_i be the number of tickets bought on day i.

- The cost on day i is a_i plus the sum of s_j for all j < i.

- So, the total cost is sum over i from 1 to n of s_i * (a_i + sum of s_j for j < i).

And we have the constraints:

- sum of s_i = k

- s_i <= m for all i

This seems like a dynamic programming problem.

Let me think about dynamic programming.

Let’s define dp[i][t] as the minimum cost to buy t tickets using the first i days.

Then, dp[i][t] = min over x from 0 to min(m, t) of (x * (a_i + sum of s_j for j < i)) + dp[i-1][t - x]

But sum of s_j for j < i is actually the total tickets bought before day i, which is (t - x).

Wait, that seems a bit messy.

Alternatively, perhaps I can think of the cumulative increase as a prefix sum.

Let me try to think differently.

Suppose I fix the number of tickets bought on each day s_i, with sum s_i = k and s_i <= m.

Then, the total cost is sum over i from 1 to n of s_i * (a_i + sum over j from 1 to i-1 of s_j)

This can be rewritten as sum over i from 1 to n of (s_i * a_i) + (s_i * sum over j from 1 to i-1 of s_j)

Which is sum over i from 1 to n of (s_i * a_i) + sum over i from 1 to n of (s_i * sum over j from 1 to i-1 of s_j)

The second term is sum over i from 1 to n of sum over j from 1 to i-1 of (s_i * s_j)

This seems complicated.

Maybe there's a better way to approach this.

Let me consider the total cost in terms of the assignment of tickets to days.

Each ticket bought on day i contributes a cost of a_i plus the number of tickets bought on previous days.

Wait, that might be a way.

Let me think about it.

Suppose I have k tickets to buy, and each ticket has a cost based on the day it's bought and the number of tickets bought before that day.

Wait, perhaps I should think of assigning each ticket to a day, and calculating its cost based on the day and the order.

This might be getting too complicated.

Let me look for a different approach.

Maybe I can sort the days in a certain order and decide how many tickets to buy on each day.

Given that the price increases are cumulative based on previous purchases, perhaps I should buy tickets on the days with the lowest adjusted prices.

But how do I adjust for the increasing prices?

Wait, perhaps I can think of the problem in terms of assigning tickets to days in a way that minimizes the total cost, considering the increasing prices.

Let me consider that each ticket bought on day i has a cost of a_i plus the number of tickets bought on previous days.

So, if I buy s_i tickets on day i, each of those tickets has a cost of a_i plus the sum of s_j for j from 1 to i-1.

Therefore, the total cost for day i is s_i * (a_i + sum of s_j for j from 1 to i-1)

This is the same as I had earlier.

This seems tricky to optimize directly.

Maybe I can rearrange the days in some order to minimize the total cost.

Perhaps sorting the days in increasing order of a_i is a good strategy.

Wait, but with the price increases, it's not straightforward.

Let me consider the example again.

In the first example:

n=4, m=2, k=3

a = [8,6,4,2]

According to the explanation, buying 0 on day1, 0 on day2, 1 on day3, and 2 on day4 gives a total cost of 10.

Let me see what would happen if I bought tickets on different days.

Suppose I buy 2 on day1 and 1 on day4.

Cost on day1: 2 tickets at price 8 each = 16

Then, prices for day2,3,4 increase by 2, so they become 8+2=10, 6+2=8, 4+2=6, 2+2=4

Then, buying 1 ticket on day4 at price 4 = 4

Total cost: 16 + 4 = 20, which is higher than the optimal 10.

Another way: buy 1 on day3 and 2 on day4.

Cost on day3: 1 ticket at price 4 = 4

Then, prices for day4 increase by 1, so day4 becomes 2+1=3

Then, buy 2 tickets on day4 at price 3 each = 6

Total cost: 4 + 6 = 10, which matches the optimal.

Another way: buy 0 on day1, 2 on day2, and 1 on day4.

Cost on day2: 2 tickets at price 6 each = 12

Then, prices for day3 and day4 increase by 2, so day3 becomes 4+2=6, day4 becomes 2+2=4

Then, buy 1 ticket on day4 at price 4 = 4

Total cost: 12 + 4 = 16, which is higher than 10.

So, buying on later days seems better in this case.

Wait, in all the optimal and suboptimal strategies, the total cost seems to be lower when buying on later days.

Is that always the case?

Let me check another example.

Take the second test case:

4 2 8

8 6 4 2

According to the explanation, the only way is to buy 2 on each day, with increasing prices.

Total cost is 16 + 16 + 16 + 16 = 64.

Wait, but in this case, buying on earlier days doesn't help because the price increases affect future days.

So, it's not always better to buy on later days.

Wait, in the first example, buying on later days was better, but in the second example, there's no choice but to buy on all days.

I need to find a general strategy.

Let me consider that the price increase is based on the number of tickets bought on previous days.

So, the cost for tickets bought on day i is a_i plus the sum of s_j for j from 1 to i-1.

Therefore, the earlier days have lower increases on future days.

Wait, no, the increases are based on the number of tickets bought on previous days.

Wait, perhaps I should think of it in terms of the total increases.

This is getting confusing.

Let me try to think of it differently.

Suppose I sort the days in increasing order of a_i.

Then, I try to buy as many tickets as possible on the days with the lowest a_i, but considering the price increases.

Wait, but in the first example, buying on day4 (a_i=2) is better, but I have to consider the price increases.

Wait, but in that case, buying on day4 is better, but I have to consider that buying on day4 doesn't increase the prices for future days since there are no future days.

Wait, in that specific case, day4 is the last day, so buying on day4 doesn't affect any future days.

Similarly, buying on day3 would increase the prices for day4.

So, perhaps I should prioritize buying on later days to minimize the increases on future days.

Wait, but in the second example, I have to buy on all days because k=8, and m=2 per day.

So, I have to buy on all 4 days, and the prices increase cumulatively.

In that case, the total cost is fixed at 64.

Wait, but in the first example, k=3, m=2 per day, n=4 days.

So, I can choose to buy on any days, up to 2 per day.

And I need to minimize the total cost, considering the price increases.

So, perhaps I should buy on the days where the increased prices have the least impact on future days.

Which would be buying on later days, since they have fewer future days affected.

In the first example, buying on day3 and day4 affects only day4 when buying on day3.

And buying on day4 affects no future days.

So, buying on later days minimizes the increases on future days.

Whereas buying on earlier days increases the prices for more future days.

So, perhaps the strategy is to sort the days in increasing order of a_i plus the number of future days times the number of tickets bought.

Wait, this is getting too vague.

Let me try to model this as choosing a subset of days to buy tickets, considering the price increases.

But it's not a subset; I have to buy a certain number of tickets each day, up to m.

This seems quite involved.

Maybe I should look for a formula or a mathematical way to compute the minimal cost.

Let me consider that the total cost is the sum over all tickets of the price on the day they are bought plus the number of tickets bought on previous days.

Wait, perhaps I can think of it in terms of assigning each ticket to a specific day, and calculating its cost based on the day and the order.

But with k up to 1e9, and n up to 3e5, it's too big to handle per ticket.

I need a more efficient approach.

Let me consider that the problem can be modeled using prefix sums.

Let’s define p_i as the number of tickets bought on day i.

Then, the total cost is sum over i from 1 to n of p_i * (a_i + sum over j from 1 to i-1 of p_j)

Which can be rewritten as sum over i from 1 to n of (p_i * a_i) + (p_i * sum over j from 1 to i-1 of p_j)

Let’s denote s_i = sum over j from 1 to i of p_j

Then, sum over i from 1 to n of p_i * sum over j from 1 to i-1 of p_j = sum over i from 1 to n of p_i * (s_i - p_i)

Which is sum over i from 1 to n of p_i * s_i - p_i^2

But s_i = s_{i-1} + p_i

So, sum over i from 1 to n of p_i * s_{i-1}

Since s_0 = 0.

Therefore, the total cost is sum over i from 1 to n of p_i * a_i + p_i * s_{i-1}

And s_{i-1} is the total tickets bought before day i.

This seems manageable.

Now, I need to minimize this total cost, given that sum p_i = k and p_i <= m for all i.

This seems like a problem that can be solved using priority queues or sorting the days in a certain order.

Wait, perhaps I can sort the days based on a_i in ascending order and assign as many tickets as possible to the days with the lowest a_i, but considering the price increases.

But with the price increases depending on previous purchases, it's not straightforward.

Wait, maybe I can think of it in terms of the additional cost per ticket on each day, considering the increases.

Alternatively, perhaps I can model this as assigning p_i tickets to each day, with the cost being p_i * (a_i + sum p_j for j < i)

I need to minimize this sum.

This seems similar to assigning resources with increasing costs.

Wait, maybe I can use the concept of minimum cost assignment.

But with such large constraints, I need an efficient algorithm.

Let me consider that the total cost can be expressed as sum p_i * a_i + sum p_i * sum p_j for j < i

Which is sum p_i * a_i + sum p_i * s_{i-1}

Where s_{i-1} is the cumulative sum of p_j up to day i-1.

Given that s_i = s_{i-1} + p_i, with s_0 = 0.

So, total cost = sum p_i * a_i + sum p_i * s_{i-1}

I need to minimize this, with sum p_i = k and p_i <= m.

This seems like a problem that can be optimized by selecting the days with the lowest (a_i + s_{i-1}) to buy more tickets.

Wait, perhaps I can sort the days based on a_i + s_{i-1}, and assign as many tickets as possible to the days with the lowest values.

But s_{i-1} depends on the assignment, so it's interdependent.

This is getting recursive.

Let me think differently.

Suppose I sort the days in increasing order of a_i.

Then, I try to buy as many tickets as possible on the days with the lowest a_i, considering the price increases.

Wait, but buying on a day with lower a_i increases the prices for future days.

So, there's a trade-off.

Maybe I should sort the days in increasing order of a_i plus the number of future days.

But I'm not sure.

This is tricky.

Let me look for a different approach.

Perhaps I can model this problem using prefix sums or some cumulative cost.

Let’s consider that the total cost is sum p_i * a_i + sum p_i * s_{i-1}

Which is sum p_i * a_i + sum p_i * (sum p_j for j from 1 to i-1)

This can be rewritten as sum p_i * a_i + sum_{i=1 to n} sum_{j=1 to i-1} p_i * p_j

This seems complicated.

Wait, perhaps I can think of the total cost in terms of the assignment of tickets to days, considering the cumulative increases.

This is getting too convoluted.

Maybe I need to look for a formula or a mathematical pattern.

Let me consider small values of n and see if I can find a pattern.

Take n=2, m=2, k=2

a = [3, 2]

Option 1: buy 2 on day1, cost = 2*3 = 6, prices for day2 increase by 2 to 4, but no tickets bought on day2.

Total cost = 6

Option 2: buy 1 on day1, cost = 3, prices for day2 increase by 1 to 3

Then buy 1 on day2, cost = 3

Total cost = 6

Option 3: buy 0 on day1, prices for day2 increase by 0, so day2 is still 2

Buy 2 on day2, cost = 4

Total cost = 4

So, buying on day2 is better.

Wait, but according to the earlier logic, buying on later days is better.

But in this case, buying on day2 is better.

Wait, but in this case, buying on day2 costs less because the price increase is less.

Wait, no, in this case, buying on day2 costs less because the base price is lower, and there's no increase from previous purchases.

Wait, but in this example, buying on day2 is better.

Wait, but in the first test case, buying on later days was better.

So, perhaps in general, buying on later days is better.

Because the price increases affect fewer future days.

Wait, but in this n=2 example, buying on day2 is better.

Similarly, in the first test case, buying on day3 and day4 is better.

So, perhaps buying on later days is preferable.

But I need to confirm this.

Let me consider another example.

n=3, m=1, k=2

a = [1, 2, 3]

Option 1: buy 1 on day1, cost=1, prices for day2 and day3 increase by 1

Then buy 1 on day2, cost=2+1=3

Total cost=4

Option 2: buy 0 on day1, prices for day2 and day3 increase by 0

Buy 1 on day2, cost=2

Prices for day3 increase by 1 to 3+1=4

Buy 1 on day3, cost=4

Total cost=6

Option 3: buy 0 on day1, 0 on day2, 2 on day3, cost=3*2=6

Total cost=6

So, in this case, buying on day1 and day2 gives a total cost of 4, which is better than the other options.

Wait, but this contradicts the earlier idea that buying on later days is always better.

So, perhaps buying on earlier days can be better in some cases.

Hmm.

Wait, in this case, buying on earlier days allows for lower base prices, even though it increases the prices for future days.

So, there's a trade-off.

If m=1, and k=2, n=3, a=[1,2,3]

Buying on day1 and day2: cost=1 + (2 +1)=4

Buying on day1 and day3: cost=1 + (3 +1)=5

Buying on day2 and day3: cost=(2 +0)+ (3 +1)=6

So, buying on day1 and day2 is better.

In this case, m=1, so can't buy more than 1 per day.

If m=2, n=3, k=2, a=[1,2,3]

Option: buy 1 on day1, cost=1, prices for day2 and day3 increase by1 to 2 and 3+1=4

Buy 1 on day2, cost=2+1=3

Total cost=4

Option: buy 2 on day1, cost=1*2=2, prices for day2 and day3 increase by2 to 2+2=4 and 3+2=5

Total cost=2 + 0 =2

Option: buy 1 on day1 and 1 on day3: cost=1 + (3 +1)=5

Option: buy 0 on day1, 2 on day2: cost= (2+0)*2=4

Option: buy 0 on day1, 1 on day2, 1 on day3: cost=(2+0)+ (3+1)=6

So, in this case, buying on day1 and day2 gives total cost=4, buying only on day1 gives total cost=2.

So, buying on earlier days can be better if m allows buying more tickets to take advantage of lower base prices.

This is getting complicated.

I need a better approach.

Let me consider that the total cost can be expressed as sum p_i * (a_i + sum p_j for j < i)

Which is sum p_i * a_i + sum p_i * sum p_j for j < i

This can be rewritten as sum p_i * a_i + sum_{1 <= j < i <= n} p_i * p_j

This seems difficult to optimize directly.

Maybe I can consider the problem in a different way.

Let me think about the total cost in terms of the assignment of tickets to days, considering the cumulative increases.

Each ticket bought on day i incurs a cost of a_i plus the total number of tickets bought on previous days.

So, if I buy p_i tickets on day i, each of those p_i tickets costs a_i plus the sum of p_j for j from 1 to i-1.

Therefore, the total cost for day i is p_i * (a_i + sum p_j for j from 1 to i-1)

This seems similar to a cumulative sum.

Let me denote s_i = sum p_j for j from 1 to i

Then, the total cost is sum from i=1 to n of p_i * (a_i + s_{i-1})

Where s_0 = 0.

So, total cost = sum p_i * a_i + sum p_i * s_{i-1}

I need to minimize this, given that s_n = k and p_i <= m for all i.

This seems like a dynamic programming problem, where I can keep track of the cumulative sum s_{i-1} and make decisions for p_i.

But with n up to 3e5 and k up to 1e9, a standard DP approach would be too slow.

I need a more efficient way.

Perhaps I can sort the days in a specific order and assign tickets accordingly.

Wait, maybe I can sort the days based on a_i in ascending order and assign tickets accordingly.

Wait, but in the earlier example, buying on days with lower a_i wasn't always better because of the price increases.

This is tricky.

Let me consider that the minimal cost is achieved by assigning as many tickets as possible to the days with the lowest a_i + s_{i-1}.

But s_{i-1} depends on previous assignments, so it's interdependent.

This seems like a problem that can be solved using a priority queue or some sort of greedy algorithm.

Wait, perhaps I can iterate through the days in order, keeping track of the current price increase, and deciding how many tickets to buy on each day.

But I need to decide how many tickets to buy on each day to minimize the total cost.

Let me think about it.

Suppose I sort the days in increasing order of a_i.

Then, I can try to buy as many tickets as possible on the days with the lowest a_i, considering the price increases.

Wait, but the price increases depend on the cumulative sum of tickets bought on previous days.

This seems too vague.

Let me consider that the minimal cost is achieved by buying as many tickets as possible on the days with the lowest a_i + the number of tickets already bought.

But again, it's recursive.

Maybe I can model this problem using the concept of minimum cost in a priority queue.

Let me try to think of it in terms of assigning the tickets to days in a way that minimizes the total cost.

Each ticket assigned to day i has a cost of a_i plus the number of tickets already bought before day i.

So, the cost for each ticket on day i is a_i plus the sum of p_j for j from 1 to i-1.

Therefore, the total cost is sum over all tickets of (a_i + sum p_j for j from 1 to i-1)

Which is sum p_i * a_i + sum p_i * s_{i-1}

I need to minimize this.

This seems similar to minimizing the sum of p_i * c_i, where c_i = a_i + s_{i-1}

But s_{i-1} depends on the assignment.

This is getting too tangled.

Let me try to think differently.

Suppose I fix the order of days and decide how many tickets to buy on each day.

I need to choose p_i for each day, with p_i <= m, and sum p_i = k.

The total cost is sum p_i * (a_i + sum p_j for j < i)

This seems like a sum of p_i weighted by (a_i + sum p_j for j < i)

This is similar to a cumulative weight.

I need to minimize this sum.

This seems similar to the sum of p_i * w_i, where w_i = a_i + sum p_j for j < i

I need to minimize sum p_i * w_i.

But w_i depends on p_j for j < i, so it's interdependent.

This seems like a system of equations that needs to be solved simultaneously.

This is getting too complex.

Maybe I need to look for a different approach.

Let me consider that the minimal total cost can be achieved by assigning tickets to days in a way that the cost per ticket is minimized.

Given that each ticket on day i has a cost of a_i plus the number of tickets bought before day i.

Wait, perhaps I can think in terms of the average cost.

But that seems too vague.

Let me consider that the problem can be modeled using the concept of minimum cost flows or some similar optimization technique.

But with the constraints, it needs to be efficient.

Wait, perhaps I can model this problem using prefix sums and some mathematical formula.

Let me try to derive a formula for the total cost.

Total cost = sum p_i * a_i + sum p_i * s_{i-1}

Where s_{i-1} = sum p_j for j from 1 to i-1

This can be rewritten as sum p_i * a_i + sum p_i * (s_{i-1})

But s_{i-1} = s_i - p_i

Wait, s_i = s_{i-1} + p_i

So, s_{i-1} = s_i - p_i

Therefore, total cost = sum p_i * a_i + sum p_i * (s_i - p_i)

Which is sum p_i * a_i + sum p_i * s_i - sum p_i^2

But s_i = sum p_j for j from 1 to i

This seems like a dead end.

Let me think differently.

Suppose I fix the number of tickets bought on each day, p_i.

Then, the total cost is sum p_i * (a_i + sum p_j for j < i)

Which is sum p_i * a_i + sum p_i * sum p_j for j < i

This can be written as sum p_i * a_i + sum_{1 <= j < i <= n} p_i * p_j

This seems like a quadratic form.

Given that, perhaps I can find a way to minimize this quadratic form under the constraints sum p_i = k and p_i <= m.

But with n up to 3e5, I need a more efficient approach.

Maybe I can sort the days in a certain order and assign tickets accordingly.

Wait, perhaps I can sort the days based on a_i in ascending order and assign tickets starting from the lowest a_i.

But considering the price increases, this might not be optimal.

Alternatively, perhaps I can sort the days based on a_i plus the number of future days.

Wait, perhaps I can sort the days based on a_i + the potential increases.

This is getting too speculative.

Let me try to think of it in terms of choosing p_i for each day, maximizing the benefit.

Wait, perhaps I can model this problem using Lagrange multipliers or some optimization technique.

But that might be too advanced for this context.

Let me consider that the minimal cost is achieved by assigning tickets to days in a way that equalizes the marginal cost across days.

But I'm not sure.

This is getting too abstract.

Maybe I need to look for a different approach.

Let me consider that the problem can be solved by sorting the days in increasing order of a_i and assigning tickets to the days with the lowest a_i, considering the price increases.

Wait, but in the earlier example, that didn't necessarily lead to the minimal cost.

Alternatively, perhaps sorting the days in decreasing order of a_i and assigning tickets to the days with the highest a_i last.

Wait, perhaps it's better to sort the days in increasing order of a_i plus the number of future days.

But I need to formalize this.

Let me consider that each day has a base price a_i, and for each ticket bought on previous days, the price increases by 1 for all subsequent days.

So, the cost for buying a ticket on day i is a_i plus the number of tickets bought on previous days.

Therefore, if I buy p_i tickets on day i, each of those tickets costs a_i plus s_{i-1}, where s_{i-1} is the total tickets bought on days 1 to i-1.

Hence, the total cost is sum p_i * (a_i + s_{i-1})

Which is sum p_i * a_i + sum p_i * s_{i-1}

As before.

Now, perhaps I can iterate through the days in order, keeping track of the current price increase, which is s_{i-1}, and decide how many tickets to buy on day i.

Given that s_{i-1} is known at each step, I can decide p_i based on minimizing the total cost.

But p_i is constrained by m, so p_i <= m.

Moreover, I need to decide p_i for all i to sum up to k.

This seems like a greedy algorithm can be applied here.

Perhaps I can sort the days based on a_i in ascending order and assign as many tickets as possible to the days with the lowest a_i, considering the price increases.

Wait, but I need to consider the price increases due to previous purchases.

Wait, maybe I can sort the days based on a_i plus s_{i-1}, and assign tickets accordingly.

But s_{i-1} is not known in advance.

This is tricky.

Let me think differently.

Suppose I fix the order of days and try to assign p_i tickets to each day, minimizing the total cost.

I can iterate through the days in order, keeping track of the current price increase s_{i-1}, and decide how many tickets to buy on day i.

Given that s_{i-1} is the total tickets bought before day i, which is fixed when deciding p_i.

Therefore, for each day i, the cost per ticket is a_i + s_{i-1}.

So, the total cost for day i is p_i * (a_i + s_{i-1})

Given that, to minimize the total cost, I should prioritize buying tickets on days where a_i + s_{i-1} is minimized.

But s_{i-1} depends on the previous assignments.

This seems recursive.

Wait, perhaps I can sort the days based on a_i in ascending order and assign as many tickets as possible to the days with the lowest a_i, considering the price increases.

But in practice, how do I do that?

Let me consider sorting the days in increasing order of a_i.

Then, assign p_i = min(m, k - sum p_j for j < i)

But this doesn't take into account the price increases.

Wait, perhaps I can iterate through the sorted days and assign p_i accordingly.

But the days are given in a specific order, and the price increases are based on that order.

So, I can't arbitrarily reorder the days.

Wait, maybe I can.

Suppose I sort the days in increasing order of a_i.

Then, assign p_i tickets to each day in this new order, considering the price increases based on the new order.

But the problem specifies that the days are in a specific order, and the price increases are based on that order.

Therefore, reordering the days would not reflect the actual constraints.

So, I can't reorder the days.

I need to find a way to assign p_i to each day in the given order, minimizing the total cost.

Given that, perhaps I can iterate through the days in order, keeping track of the current price increase, and decide how many tickets to buy on each day.

Let me try to formalize this.

Initialize s = 0  # total tickets bought so far

total_cost = 0

for each day i from 1 to n:

    # current cost per ticket on day i: a_i + s

    # decide how many tickets to buy on day i: p_i <= m, and p_i <= k - sum p_j for j < i

    remaining = k - s

    p_i = min(m, remaining)

    # update total_cost and s

    total_cost += p_i * (a_i + s)

    s += p_i

This seems like a greedy approach: buy as many tickets as possible on each day, up to m, until k tickets are bought.

But is this optimal?

In the first example:

n=4, m=2, k=3

a = [8,6,4,2]

Initialize s=0, total_cost=0

Day1:

a_i=8, s=0

p_i = min(2,3)=2

total_cost += 2*(8+0)=16

s += 2 => s=2

Day2:

a_i=6, s=2

p_i = min(2,3-2)=1

total_cost +=1*(6+2)=8

s +=1 => s=3

Day3:

a_i=4, s=3

But s=3, and k=3, so no more tickets needed.

Total cost=16+8=24, which is higher than the optimal 10.

So, this greedy approach doesn't lead to the optimal solution.

Hence, this approach is flawed.

I need a better strategy.

Let me consider that the minimal cost is achieved by buying tickets on days where the marginal cost is minimized.

The marginal cost for buying a ticket on day i is a_i plus the number of tickets bought on previous days.

So, for each day i, the marginal cost is a_i + s_{i-1}

Therefore, to minimize the total cost, I should prioritize buying tickets on days where a_i + s_{i-1} is minimized.

But s_{i-1} depends on previous assignments.

This seems like a circular dependency.

Wait, perhaps I can sort the days based on a_i and decide the number of tickets accordingly.

But I'm stuck.

Let me consider that the problem can be modeled as assigning tickets to days in a way that minimizes the total cost, considering the cumulative increases.

This seems too vague.

Let me look for an alternative approach.

Perhaps I can consider the problem in reverse: starting from the last day and moving backwards.

On the last day, the price is a_n plus the total number of tickets bought on previous days.

Similarly, for the second last day, the price is a_{n-1} plus the total tickets bought on previous days.

Wait, perhaps I can sort the days in increasing order of a_i plus the number of future days.

But I need to formalize this.

Let me think about the dual problem or some transformation that can simplify this.

This is getting too complicated.

I need to find a better way.

Let me consider that the minimal total cost can be expressed as sum p_i * a_i + sum p_i * s_{i-1}

Which is sum p_i * a_i + sum p_i * (sum p_j for j from 1 to i-1)

This can be rewritten as sum p_i * a_i + sum_{1 <= j < i <= n} p_i * p_j

This seems like a quadratic form in terms of p_i.

Given that, perhaps I can find a way to minimize this quadratic form under the constraints sum p_i = k and p_i <= m.

But with n up to 3e5, I need an efficient way to compute this.

Wait, perhaps I can sort the days in increasing order of a_i and assign tickets accordingly.

But as seen earlier, this doesn't necessarily lead to the optimal solution.

Alternatively, perhaps I can sort the days in increasing order of a_i plus the number of future days.

Wait, perhaps I can sort the days based on a_i plus the number of future days, and assign tickets accordingly.

But I need to formalize this.

Let me consider that each day has a base price a_i, and for each ticket bought on previous days, the price increases by 1 for all subsequent days.

Therefore, the cost for buying a ticket on day i is a_i plus the number of tickets bought on previous days.

Hence, to minimize the total cost, I should prioritize buying tickets on days where a_i is low and the number of future days is low.

Wait, because buying on a day with fewer future days minimizes the number of times the price increase is applied.

Therefore, perhaps I should sort the days in increasing order of a_i plus the number of future days, and assign tickets accordingly.

Let me try this.

In the first example:

n=4, m=2, k=3

a = [8,6,4,2]

Number of future days for each day:

Day1: 3 future days

Day2: 2 future days

Day3: 1 future day

Day4: 0 future days

So, a_i + future_days:

Day1: 8 + 3 = 11

Day2: 6 + 2 = 8

Day3: 4 + 1 = 5

Day4: 2 + 0 = 2

So, sorted order: Day4 (2), Day3 (5), Day2 (8), Day1 (11)

Therefore, assign as many tickets as possible to the days with the lowest a_i + future_days.

So, assign p_i = min(m, remaining) to the days in this order.

Starting with Day4: p_4 = min(2,3)=2, remaining=1

Then Day3: p_3 = min(2,1)=1, remaining=0

Total cost: 2*(2 +0) +1*(4 +0)=4 +4=8, which is less than the optimal 10.

Wait, but according to the earlier explanation, the optimal is 10.

So, perhaps this approach is not correct.

Wait, maybe I'm miscalculating.

Wait, in this approach, for Day4, p_4=2, cost per ticket is 2 + s_{3}=1 (since p_3=1), but wait, s_{3}=p_1 + p_2 + p_3=0+0+1=1

Wait, no, s_{i-1} is the sum of p_j for j < i.

So, for Day4, s_{3}=1, so cost per ticket is 2 +1=3, total cost for p_4=2 is 6

For Day3, p_3=1, s_{2}=0, cost per ticket is 4 +0=4, total cost=4

Total cost=6+4=10, which matches the optimal.

So, in this case, it works.

Let me try this approach in general.

Sort the days in increasing order of a_i + (n - i), where n - i is the number of future days.

Then, assign p_i = min(m, remaining) to each day in this order.

Calculate the total cost as p_i * (a_i + s_{i-1}), where s_{i-1} is the sum of p_j for j < i.

This seems to work for this example.

Let me try it on the second example.

n=4, m=2, k=8

a=[8,6,4,2]

Future days:

Day1:3, Day2:2, Day3:1, Day4:0

a_i + future_days:

Day1:8+3=11

Day2:6+2=8

Day3:4+1=5

Day4:2+0=2

Sorted order: Day4, Day3, Day2, Day1

Assign p_4 = min(2,8)=2, remaining=6, s_3=0, cost=2*(2+0)=4

Then p_3 = min(2,6)=2, remaining=4, s_2=0, cost=2*(4+0)=8

Then p_2 = min(2,4)=2, remaining=2, s_1=0, cost=2*(6+0)=12

Then p_1 = min(2,2)=2, remaining=0, s_0=0, cost=2*(8+0)=16

Total cost=4+8+12+16=40, which is less than the given optimal of 64.

Wait, but according to the explanation, the only way is to buy 2 on each day, leading to 16+16+16+16=64.

So, according to this approach, the total cost is 40, which is lower than 64.

But according to the problem, 64 is the minimal cost.

So, this approach is incorrect.

Hence, my assumption is wrong.

Therefore, sorting the days based on a_i + number of future days and assigning tickets accordingly does not lead to the correct minimal cost.

So, I need to find another approach.

This is getting too complicated.

Let me try to think about the problem differently.

Suppose I fix the number of tickets bought on each day, p_i, with p_i <= m and sum p_i = k.

Then, the total cost is sum p_i * (a_i + sum p_j for j < i)

Which is sum p_i * a_i + sum p_i * sum p_j for j < i

This can be rewritten as sum p_i * a_i + sum_{1 <= j < i <= n} p_i * p_j

This seems like a quadratic form.

I need to minimize this quadratic form under the constraints sum p_i = k and p_i <= m.

This seems like a mathematical optimization problem.

Perhaps I can model this as minimizing a quadratic function subject to linear constraints.

But with n up to 3e5, I need an efficient way to compute this.

Maybe I can find a formula for the minimal cost based on sorting the days in a certain order.

Let me consider that the minimal cost is achieved by assigning tickets to days in a way that balances the marginal costs.

Wait, perhaps I can sort the days in increasing order of a_i and assign tickets starting from the days with the lowest a_i, considering the price increases.

But