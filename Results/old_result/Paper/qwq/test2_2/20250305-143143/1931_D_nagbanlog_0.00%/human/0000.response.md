Alright, I have this problem to solve. Let's see what it's asking for. So, Polycarp has two favorite integers, x and y, and he has an array of numbers. He considers a pair of indices <i, j> (where i < j) beautiful if two conditions are met:

1. The sum of the elements at positions i and j is divisible by x.

2. The difference of the elements at positions i and j is divisible by y.

My task is to find out how many such beautiful pairs exist in the array for given values of n, x, y, and the array a.

First, I need to understand what it means for a sum or difference to be divisible by something. If a sum a_i + a_j is divisible by x, that means (a_i + a_j) % x == 0. Similarly, if the difference a_i - a_j is divisible by y, then (a_i - a_j) % y == 0.

I need to find pairs where both these conditions hold true.

Let me think about how to approach this efficiently, especially since n can be up to 2*10^5 and there can be up to 10^4 test cases, but the total n across all test cases is limited to 2*10^5. So, I need an algorithm that's linear or linearithmic in n.

I recall that for counting pairs with certain properties related to modulo, using frequency maps based on modulo values can be helpful.

Let me consider the first condition: a_i + a_j is divisible by x, which is equivalent to (a_i + a_j) % x == 0.

This can be rewritten as (a_i % x + a_j % x) % x == 0.

Similarly, the second condition is (a_i - a_j) % y == 0, which is equivalent to (a_i % y - a_j % y) % y == 0, meaning a_i % y == a_j % y.

So, for two elements a_i and a_j:

1. (a_i % x + a_j % x) % x == 0

2. a_i % y == a_j % y

I need to find pairs where both these conditions are satisfied.

Hmm, these conditions involve modulo operations with x and y, so perhaps I can group numbers based on their remainders when divided by x and y.

But combining these two conditions seems a bit tricky because they involve different modulo operations.

Let me see if I can find a way to combine these conditions.

Let me denote:

Let’s say a_i % x = r1

And a_j % x = r2

Then, (r1 + r2) % x == 0

Also, a_i % y = s1

And a_j % y = s2

But since a_i % y == a_j % y, s1 == s2.

So, for each pair, they must have the same remainder when divided by y, and their remainders when divided by x must add up to a multiple of x.

Wait, actually, since (r1 + r2) % x == 0, it means that r2 == (-r1) % x.

So, for each a_i with r1 = a_i % x and s1 = a_i % y, I need to find another a_j with r2 = (-r1) % x and s2 = s1.

So, for each a_i, I can look for elements a_j that have:

- a_j % x == (-a_i % x) % x

- a_j % y == a_i % y

This seems like a good approach. I can group the numbers based on their (r, s) pairs, where r = a % x and s = a % y.

Then, for each (r, s) group, the number of pairs is the number of ways to choose two elements from that group.

Wait, but in this case, since r2 needs to be (-r1) % x and s2 needs to be s1, it's not exactly the same group.

Wait, perhaps I need to track frequency of (r, s), and for each (r, s), find the frequency of ((-r) % x, s), and add freq(r,s) * freq((-r)%x, s) to the count.

But wait, since I'm dealing with pairs where i < j, I need to make sure I don't double-count.

Actually, since I'm considering unordered pairs, I need to handle the frequency counts carefully to avoid double-counting.

Wait, perhaps it's better to iterate through each element, compute its (r1, s1), then compute the required (r2, s2) which is ((-r1) % x, s1), and add the frequency of (r2, s2) to the count, and then increment the frequency of (r1, s1).

This way, since I'm processing elements in order, I ensure that j > i always.

Let me try to formalize this:

Initialize a frequency map freq that maps (r, s) to the count of elements with that (r, s).

Initialize beautiful_count to 0.

For each element a in the array:

r1 = a % x

s1 = a % y

r2 = (-r1) % x

s2 = s1

If (r2, s2) is in freq:

beautiful_count += freq[(r2, s2)]

Then, if (r1, s1) is not in freq:

freq[(r1, s1)] = 0

freq[(r1, s1)] += 1

This seems correct. Let's verify it with the sample input.

Take the first sample input:

n = 6, x = 5, y = 2

a = [1, 2, 7, 4, 9, 6]

Let's compute (r, s) for each element:

a1 = 1: r = 1 % 5 = 1, s = 1 % 2 = 1 → (1,1)

a2 = 2: r = 2 % 5 = 2, s = 2 % 2 = 0 → (2,0)

a3 = 7: r = 7 % 5 = 2, s = 7 % 2 = 1 → (2,1)

a4 = 4: r = 4 % 5 = 4, s = 4 % 2 = 0 → (4,0)

a5 = 9: r = 9 % 5 = 4, s = 9 % 2 = 1 → (4,1)

a6 = 6: r = 6 % 5 = 1, s = 6 % 2 = 0 → (1,0)

Now, let's simulate the process:

Initialize freq = {}, beautiful_count = 0

Process a1: (1,1)

r2 = (-1) % 5 = 4, s2 = 1

freq[(4,1)] = 0 (since it's not present), so beautiful_count += 0

Then, freq[(1,1)] = 1

Process a2: (2,0)

r2 = (-2) % 5 = 3, s2 = 0

freq[(3,0)] = 0, so beautiful_count += 0

Then, freq[(2,0)] = 1

Process a3: (2,1)

r2 = (-2) % 5 = 3, s2 = 1

freq[(3,1)] = 0, so beautiful_count += 0

Then, freq[(2,1)] = 1

Process a4: (4,0)

r2 = (-4) % 5 = 1, s2 = 0

freq[(1,0)] = 1 (from a6), so beautiful_count += 1 → beautiful_count = 1

Then, freq[(4,0)] = 1

Process a5: (4,1)

r2 = (-4) % 5 = 1, s2 = 1

freq[(1,1)] = 1 (from a1), so beautiful_count += 1 → beautiful_count = 2

Then, freq[(4,1)] = 1

Process a6: (1,0)

r2 = (-1) % 5 = 4, s2 = 0

freq[(4,0)] = 1 (from a4), so beautiful_count += 1 → beautiful_count = 3

Then, freq[(1,0)] = 1

Wait, but according to the sample explanation, there are only 2 beautiful pairs: <1,5> and <4,6>.

But according to this simulation, beautiful_count = 3.

Hmm, that means there's an overcount somewhere.

Wait, let's check which pairs are being counted:

- a1: (1,1) → looks for (4,1), which is a5 → valid pair <1,5>

- a4: (4,0) → looks for (1,0), which is a6 → valid pair <4,6>

- a5: (4,1) → looks for (1,1), which is a1 → but this would correspond to pair <5,1>, which is the same as <1,5>

- a6: (1,0) → looks for (4,0), which is a4 → same as <6,4>, which is the same as <4,6>

So, it seems like the method is counting each pair twice, once in each order.

But since I'm iterating in order and only considering j > i, this shouldn't happen.

Wait, in the simulation above, when processing a1, it adds a count based on freq[(4,1)] which is 0 at that point, then increments freq[(1,1)].

When processing a5, freq[(1,1)] is 1 (from a1), so it adds 1 to beautiful_count.

Similarly, processing a4, it adds based on freq[(1,0)] which is from a6, but a6 hasn't been processed yet.

Wait, no: in the simulation, when processing a4, freq[(1,0)] is 1 from a6.

But according to the algorithm, freq should only include elements processed before the current one.

Wait, perhaps I made a mistake in the simulation.

Let's simulate again, step by step:

Initialize freq = {}, beautiful_count = 0

Process a1: (1,1)

r2 = (-1) % 5 = 4, s2 = 1

freq.get((4,1), 0) = 0, so beautiful_count += 0 → beautiful_count = 0

freq[(1,1)] = 1

Process a2: (2,0)

r2 = (-2) % 5 = 3, s2 = 0

freq.get((3,0), 0) = 0, so beautiful_count += 0 → beautiful_count = 0

freq[(2,0)] = 1

Process a3: (2,1)

r2 = (-2) % 5 = 3, s2 = 1

freq.get((3,1), 0) = 0, so beautiful_count += 0 → beautiful_count = 0

freq[(2,1)] = 1

Process a4: (4,0)

r2 = (-4) % 5 = 1, s2 = 0

freq.get((1,0), 0) = 0 (since a6 hasn't been processed yet), so beautiful_count += 0 → beautiful_count = 0

freq[(4,0)] = 1

Process a5: (4,1)

r2 = (-4) % 5 = 1, s2 = 1

freq.get((1,1), 0) = 1 (from a1), so beautiful_count += 1 → beautiful_count = 1

freq[(4,1)] = 1

Process a6: (1,0)

r2 = (-1) % 5 = 4, s2 = 0

freq.get((4,0), 0) = 1 (from a4), so beautiful_count += 1 → beautiful_count = 2

freq[(1,0)] = 1

So, in this correct simulation, beautiful_count = 2, which matches the sample.

Earlier, I mistakenly thought that processing a4 would look at freq[(1,0)] which would include a6, but actually, when processing a4, freq[(1,0)] is still 0 because a6 hasn't been processed yet. Only when processing a6, freq[(4,0)] is already 1 from a4.

Wait, no: when processing a6: (1,0), it looks for freq[(4,0)], which has been set to 1 when a4 was processed.

Wait, but in the correct simulation above, when processing a4: (4,0), it looks for freq[(1,0)], which at that point is 0 because a6 hasn't been processed yet.

Similarly, when processing a6: (1,0), it looks for freq[(4,0)], which has been set to 1 by a4.

So, in this corrected simulation, beautiful_count correctly becomes 2.

Therefore, the algorithm seems correct.

Let me check another sample to confirm.

Take the second sample:

n = 7, x = 9, y = 5

a = [1,10,15,3,8,12,15]

Compute (r, s) for each:

a1 = 1: r = 1 % 9 = 1, s = 1 % 5 = 1 → (1,1)

a2 = 10: r = 10 % 9 = 1, s = 10 % 5 = 0 → (1,0)

a3 = 15: r = 15 % 9 = 6, s = 15 % 5 = 0 → (6,0)

a4 = 3: r = 3 % 9 = 3, s = 3 % 5 = 3 → (3,3)

a5 = 8: r = 8 % 9 = 8, s = 8 % 5 = 3 → (8,3)

a6 = 12: r = 12 % 9 = 3, s = 12 % 5 = 2 → (3,2)

a7 = 15: r = 15 % 9 = 6, s = 15 % 5 = 0 → (6,0)

Initialize freq = {}, beautiful_count = 0

Process a1: (1,1)

r2 = (-1) % 9 = 8, s2 = 1

freq.get((8,1), 0) = 0, so beautiful_count += 0 → 0

freq[(1,1)] = 1

Process a2: (1,0)

r2 = (-1) % 9 = 8, s2 = 0

freq.get((8,0), 0) = 0, so beautiful_count += 0 → 0

freq[(1,0)] = 1

Process a3: (6,0)

r2 = (-6) % 9 = 3, s2 = 0

freq.get((3,0), 0) = 0, so beautiful_count += 0 → 0

freq[(6,0)] = 1

Process a4: (3,3)

r2 = (-3) % 9 = 6, s2 = 3

freq.get((6,3), 0) = 0, so beautiful_count += 0 → 0

freq[(3,3)] = 1

Process a5: (8,3)

r2 = (-8) % 9 = 1, s2 = 3

freq.get((1,3), 0) = 0, so beautiful_count += 0 → 0

freq[(8,3)] = 1

Process a6: (3,2)

r2 = (-3) % 9 = 6, s2 = 2

freq.get((6,2), 0) = 0, so beautiful_count += 0 → 0

freq[(3,2)] = 1

Process a7: (6,0)

r2 = (-6) % 9 = 3, s2 = 0

freq.get((3,0), 0) = 0, so beautiful_count += 0 → 0

freq[(6,0)] = 2

So, beautiful_count = 0, which matches the sample.

Looks good.

Another sample:

n = 9, x = 4, y = 10

a = [14,10,2,2,11,11,13,5,6]

Compute (r, s):

a1 = 14: r = 14 % 4 = 2, s = 14 % 10 = 4 → (2,4)

a2 = 10: r = 10 % 4 = 2, s = 10 % 10 = 0 → (2,0)

a3 = 2: r = 2 % 4 = 2, s = 2 % 10 = 2 → (2,2)

a4 = 2: r = 2 % 4 = 2, s = 2 % 10 = 2 → (2,2)

a5 = 11: r = 11 % 4 = 3, s = 11 % 10 = 1 → (3,1)

a6 = 11: r = 11 % 4 = 3, s = 11 % 10 = 1 → (3,1)

a7 = 13: r = 13 % 4 = 1, s = 13 % 10 = 3 → (1,3)

a8 = 5: r = 5 % 4 = 1, s = 5 % 10 = 5 → (1,5)

a9 = 6: r = 6 % 4 = 2, s = 6 % 10 = 6 → (2,6)

Initialize freq = {}, beautiful_count = 0

Process a1: (2,4)

r2 = (-2) % 4 = 2, s2 = 4

freq.get((2,4), 0) = 0, so beautiful_count += 0 → 0

freq[(2,4)] = 1

Process a2: (2,0)

r2 = (-2) % 4 = 2, s2 = 0

freq.get((2,0), 0) = 0, so beautiful_count += 0 → 0

freq[(2,0)] = 1

Process a3: (2,2)

r2 = (-2) % 4 = 2, s2 = 2

freq.get((2,2), 0) = 0, so beautiful_count += 0 → 0

freq[(2,2)] = 1

Process a4: (2,2)

r2 = (-2) % 4 = 2, s2 = 2

freq.get((2,2), 0) = 1 (from a3), so beautiful_count += 1 → 1

freq[(2,2)] = 2

Process a5: (3,1)

r2 = (-3) % 4 = 1, s2 = 1

freq.get((1,1), 0) = 0, so beautiful_count += 0 → 1

freq[(3,1)] = 1

Process a6: (3,1)

r2 = (-3) % 4 = 1, s2 = 1

freq.get((1,1), 0) = 0, so beautiful_count += 0 → 1

freq[(3,1)] = 2

Process a7: (1,3)

r2 = (-1) % 4 = 3, s2 = 3

freq.get((3,3), 0) = 0, so beautiful_count += 0 → 1

freq[(1,3)] = 1

Process a8: (1,5)

r2 = (-1) % 4 = 3, s2 = 5

freq.get((3,5), 0) = 0, so beautiful_count += 0 → 1

freq[(1,5)] = 1

Process a9: (2,6)

r2 = (-2) % 4 = 2, s2 = 6

freq.get((2,6), 0) = 0, so beautiful_count += 0 → 1

freq[(2,6)] = 1

So, beautiful_count = 1, which matches the sample.

Seems correct.

Another sample:

n = 9, x = 5, y = 6

a = [10,7,6,7,9,7,7,10,10]

Compute (r, s):

a1 = 10: r = 10 % 5 = 0, s = 10 % 6 = 4 → (0,4)

a2 = 7: r = 7 % 5 = 2, s = 7 % 6 = 1 → (2,1)

a3 = 6: r = 6 % 5 = 1, s = 6 % 6 = 0 → (1,0)

a4 = 7: r = 7 % 5 = 2, s = 7 % 6 = 1 → (2,1)

a5 = 9: r = 9 % 5 = 4, s = 9 % 6 = 3 → (4,3)

a6 = 7: r = 7 % 5 = 2, s = 7 % 6 = 1 → (2,1)

a7 = 7: r = 7 % 5 = 2, s = 7 % 6 = 1 → (2,1)

a8 = 10: r = 10 % 5 = 0, s = 10 % 6 = 4 → (0,4)

a9 = 10: r = 10 % 5 = 0, s = 10 % 6 = 4 → (0,4)

Initialize freq = {}, beautiful_count = 0

Process a1: (0,4)

r2 = (-0) % 5 = 0, s2 = 4

freq.get((0,4), 0) = 0, so beautiful_count += 0 → 0

freq[(0,4)] = 1

Process a2: (2,1)

r2 = (-2) % 5 = 3, s2 = 1

freq.get((3,1), 0) = 0, so beautiful_count += 0 → 0

freq[(2,1)] = 1

Process a3: (1,0)

r2 = (-1) % 5 = 4, s2 = 0

freq.get((4,0), 0) = 0, so beautiful_count += 0 → 0

freq[(1,0)] = 1

Process a4: (2,1)

r2 = (-2) % 5 = 3, s2 = 1

freq.get((3,1), 0) = 0, so beautiful_count += 0 → 0

freq[(2,1)] = 2

Process a5: (4,3)

r2 = (-4) % 5 = 1, s2 = 3

freq.get((1,3), 0) = 0, so beautiful_count += 0 → 0

freq[(4,3)] = 1

Process a6: (2,1)

r2 = (-2) % 5 = 3, s2 = 1

freq.get((3,1), 0) = 0, so beautiful_count += 0 → 0

freq[(2,1)] = 3

Process a7: (2,1)

r2 = (-2) % 5 = 3, s2 = 1

freq.get((3,1), 0) = 0, so beautiful_count += 0 → 0

freq[(2,1)] = 4

Process a8: (0,4)

r2 = (-0) % 5 = 0, s2 = 4

freq.get((0,4), 0) = 1 (from a1), so beautiful_count += 1 → 1

freq[(0,4)] = 2

Process a9: (0,4)

r2 = (-0) % 5 = 0, s2 = 4

freq.get((0,4), 0) = 2 (from a1 and a8), so beautiful_count += 2 → 3

freq[(0,4)] = 3

So, beautiful_count = 3, which matches the sample.

Great, seems consistent.

Another sample:

n = 9, x = 6, y = 2

a = [4,9,7,1,2,2,13,3,15]

Compute (r, s):

a1 = 4: r = 4 % 6 = 4, s = 4 % 2 = 0 → (4,0)

a2 = 9: r = 9 % 6 = 3, s = 9 % 2 = 1 → (3,1)

a3 = 7: r = 7 % 6 = 1, s = 7 % 2 = 1 → (1,1)

a4 = 1: r = 1 % 6 = 1, s = 1 % 2 = 1 → (1,1)

a5 = 2: r = 2 % 6 = 2, s = 2 % 2 = 0 → (2,0)

a6 = 2: r = 2 % 6 = 2, s = 2 % 2 = 0 → (2,0)

a7 = 13: r = 13 % 6 = 1, s = 13 % 2 = 1 → (1,1)

a8 = 3: r = 3 % 6 = 3, s = 3 % 2 = 1 → (3,1)

a9 = 15: r = 15 % 6 = 3, s = 15 % 2 = 1 → (3,1)

Initialize freq = {}, beautiful_count = 0

Process a1: (4,0)

r2 = (-4) % 6 = 2, s2 = 0

freq.get((2,0), 0) = 0, so beautiful_count += 0 → 0

freq[(4,0)] = 1

Process a2: (3,1)

r2 = (-3) % 6 = 3, s2 = 1

freq.get((3,1), 0) = 0, so beautiful_count += 0 → 0

freq[(3,1)] = 1

Process a3: (1,1)

r2 = (-1) % 6 = 5, s2 = 1

freq.get((5,1), 0) = 0, so beautiful_count += 0 → 0

freq[(1,1)] = 1

Process a4: (1,1)

r2 = (-1) % 6 = 5, s2 = 1

freq.get((5,1), 0) = 0, so beautiful_count += 0 → 0

freq[(1,1)] = 2

Process a5: (2,0)

r2 = (-2) % 6 = 4, s2 = 0

freq.get((4,0), 0) = 1 (from a1), so beautiful_count += 1 → 1

freq[(2,0)] = 1

Process a6: (2,0)

r2 = (-2) % 6 = 4, s2 = 0

freq.get((4,0), 0) = 1 (from a1), so beautiful_count += 1 → 2

freq[(2,0)] = 2

Process a7: (1,1)

r2 = (-1) % 6 = 5, s2 = 1

freq.get((5,1), 0) = 0, so beautiful_count += 0 → 2

freq[(1,1)] = 3

Process a8: (3,1)

r2 = (-3) % 6 = 3, s2 = 1

freq.get((3,1), 0) = 1 (from a2), so beautiful_count += 1 → 3

freq[(3,1)] = 2

Process a9: (3,1)

r2 = (-3) % 6 = 3, s2 = 1

freq.get((3,1), 0) = 2 (from a2 and a8), so beautiful_count += 2 → 5

freq[(3,1)] = 3

So, beautiful_count = 5, matching the sample.

Another sample:

n = 9, x = 2, y = 3

a = [14,6,1,15,12,15,8,2,15]

Compute (r, s):

a1 = 14: r = 14 % 2 = 0, s = 14 % 3 = 2 → (0,2)

a2 = 6: r = 6 % 2 = 0, s = 6 % 3 = 0 → (0,0)

a3 = 1: r = 1 % 2 = 1, s = 1 % 3 = 1 → (1,1)

a4 = 15: r = 15 % 2 = 1, s = 15 % 3 = 0 → (1,0)

a5 = 12: r = 12 % 2 = 0, s = 12 % 3 = 0 → (0,0)

a6 = 15: r = 15 % 2 = 1, s = 15 % 3 = 0 → (1,0)

a7 = 8: r = 8 % 2 = 0, s = 8 % 3 = 2 → (0,2)

a8 = 2: r = 2 % 2 = 0, s = 2 % 3 = 2 → (0,2)

a9 = 15: r = 15 % 2 = 1, s = 15 % 3 = 0 → (1,0)

Initialize freq = {}, beautiful_count = 0

Process a1: (0,2)

r2 = (-0) % 2 = 0, s2 = 2

freq.get((0,2), 0) = 0, so beautiful_count += 0 → 0

freq[(0,2)] = 1

Process a2: (0,0)

r2 = (-0) % 2 = 0, s2 = 0

freq.get((0,0), 0) = 0, so beautiful_count += 0 → 0

freq[(0,0)] = 1

Process a3: (1,1)

r2 = (-1) % 2 = 1, s2 = 1

freq.get((1,1), 0) = 0, so beautiful_count += 0 → 0

freq[(1,1)] = 1

Process a4: (1,0)

r2 = (-1) % 2 = 1, s2 = 0

freq.get((1,0), 0) = 0, so beautiful_count += 0 → 0

freq[(1,0)] = 1

Process a5: (0,0)

r2 = (-0) % 2 = 0, s2 = 0

freq.get((0,0), 0) = 1 (from a2), so beautiful_count += 1 → 1

freq[(0,0)] = 2

Process a6: (1,0)

r2 = (-1) % 2 = 1, s2 = 0

freq.get((1,0), 0) = 1 (from a4), so beautiful_count += 1 → 2

freq[(1,0)] = 2

Process a7: (0,2)

r2 = (-0) % 2 = 0, s2 = 2

freq.get((0,2), 0) = 1 (from a1), so beautiful_count += 1 → 3

freq[(0,2)] = 2

Process a8: (0,2)

r2 = (-0) % 2 = 0, s2 = 2

freq.get((0,2), 0) = 2 (from a1 and a7), so beautiful_count += 2 → 5

freq[(0,2)] = 3

Process a9: (1,0)

r2 = (-1) % 2 = 1, s2 = 0

freq.get((1,0), 0) = 2 (from a4 and a6), so beautiful_count += 2 → 7

freq[(1,0)] = 3

So, beautiful_count = 7, matching the sample.

Last sample:

n = 10, x = 5, y = 7

a = [13,3,3,2,12,11,3,7,13,14]

Compute (r, s):

a1 = 13: r = 13 % 5 = 3, s = 13 % 7 = 6 → (3,6)

a2 = 3: r = 3 % 5 = 3, s = 3 % 7 = 3 → (3,3)

a3 = 3: r = 3 % 5 = 3, s = 3 % 7 = 3 → (3,3)

a4 = 2: r = 2 % 5 = 2, s = 2 % 7 = 2 → (2,2)

a5 = 12: r = 12 % 5 = 2, s = 12 % 7 = 5 → (2,5)

a6 = 11: r = 11 % 5 = 1, s = 11 % 7 = 4 → (1,4)

a7 = 3: r = 3 % 5 = 3, s = 3 % 7 = 3 → (3,3)

a8 = 7: r = 7 % 5 = 2, s = 7 % 7 = 0 → (2,0)

a9 = 13: r = 13 % 5 = 3, s = 13 % 7 = 6 → (3,6)

a10 = 14: r = 14 % 5 = 4, s = 14 % 7 = 0 → (4,0)

Initialize freq = {}, beautiful_count = 0

Process a1: (3,6)

r2 = (-3) % 5 = 2, s2 = 6

freq.get((2,6), 0) = 0, so beautiful_count += 0 → 0

freq[(3,6)] = 1

Process a2: (3,3)

r2 = (-3) % 5 = 2, s2 = 3

freq.get((2,3), 0) = 0, so beautiful_count += 0 → 0

freq[(3,3)] = 1

Process a3: (3,3)

r2 = (-3) % 5 = 2, s2 = 3

freq.get((2,3), 0) = 0, so beautiful_count += 0 → 0

freq[(3,3)] = 2

Process a4: (2,2)

r2 = (-2) % 5 = 3, s2 = 2

freq.get((3,2), 0) = 0, so beautiful_count += 0 → 0

freq[(2,2)] = 1

Process a5: (2,5)

r2 = (-2) % 5 = 3, s2 = 5

freq.get((3,5), 0) = 0, so beautiful_count += 0 → 0

freq[(2,5)] = 1

Process a6: (1,4)

r2 = (-1) % 5 = 4, s2 = 4

freq.get((4,4), 0) = 0, so beautiful_count += 0 → 0

freq[(1,4)] = 1

Process a7: (3,3)

r2 = (-3) % 5 = 2, s2 = 3

freq.get((2,3), 0) = 0, so beautiful_count += 0 → 0

freq[(3,3)] = 3

Process a8: (2,0)

r2 = (-2) % 5 = 3, s2 = 0

freq.get((3,0), 0) = 0, so beautiful_count += 0 → 0

freq[(2,0)] = 1

Process a9: (3,6)

r2 = (-3) % 5 = 2, s2 = 6

freq.get((2,6), 0) = 0, so beautiful_count += 0 → 0

freq[(3,6)] = 2

Process a10: (4,0)

r2 = (-4) % 5 = 1, s2 = 0

freq.get((1,0), 0) = 0, so beautiful_count += 0 → 0

freq[(4,0)] = 1

So, beautiful_count = 0, matching the sample.

All samples seem to be correctly handled by this algorithm.

Now, considering the constraints:

- t <= 10^4

- Sum of n over all test cases <= 2*10^5

So, the total time complexity should be O(n), which is acceptable.

Implementing this in code:

- Read t

- For each test case:

- Read n, x, y

- Read array a of size n

- Initialize freq as a dictionary

- Initialize beautiful_count to 0

- For each a_i in a:

- r1 = a_i % x

- s1 = a_i % y

- r2 = (-r1) % x

- s2 = s1

- If (r2, s2) in freq:

- beautiful_count += freq[(r2, s2)]

- If (r1, s1) not in freq:

- freq[(r1, s1)] = 0

- freq[(r1, s1)] += 1

- Output beautiful_count for the test case

In Python, using a dictionary with tuple keys should work fine.

Edge cases to consider:

- x = 1: Since any sum is divisible by 1, the first condition is always true.

- y = 1: Similarly, any difference is divisible by 1.

- x or y equal to 0: But according to constraints, x and y are at least 1, so no need to handle division by zero.

- All elements are the same: For example, n=5, x=2, y=2, a=[1,1,1,1,1]

- In this case, a_i + a_j = 2, which is divisible by x=2

- a_i - a_j = 0, which is divisible by y=2

- So, all pairs are beautiful

- n=2, minimal case

- n=2*10^5, maximal case, need to ensure efficiency

Let's test with n=5, x=2, y=2, a=[1,1,1,1,1]

Compute (r, s):

All a_i =1: r =1%2=1, s=1%2=1 → (1,1)

Process:

a1: (1,1), look for (1,1), freq[(1,1)]=0, so beautiful_count +=0, then freq[(1,1)]=1

a2: (1,1), look for (1,1), freq[(1,1)]=1 (from a1), beautiful_count +=1, freq[(1,1)]=2

a3: (1,1), look for (1,1), freq[(1,1)]=2 (from a1 and a2), beautiful_count +=2, freq[(1,1)]=3

a4: (1,1), look for (1,1), freq[(1,1)]=3 (from a1,a2,a3), beautiful_count +=3, freq[(1,1)]=4

a5: (1,1), look for (1,1), freq[(1,1)]=4 (from a1,a2,a3,a4), beautiful_count +=4, freq[(1,1)]=5

Total beautiful_count =0+1+2+3+4=10, which is correct since for n=5, number of pairs is C(5,2)=10.

Another edge case: n=2, x=2, y=2, a=[1,3]

Compute (r, s):

a1=1: (1,1)

a2=3: (1,1)

Process a1: look for (1,1), freq[(1,1)]=0, so beautiful_count +=0, freq[(1,1)]=1

Process a2: look for (1,1), freq[(1,1)]=1 (from a1), beautiful_count +=1, freq[(1,1)]=2

So, beautiful_count=1, which is correct: pair <1,2> is beautiful since 1+3=4