Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given a beautiful array, and I need to find the minimum number of elements to remove so that it's no longer beautiful. Or output -1 if it's impossible.

First, I need to understand what makes an array beautiful. According to the problem, an array is beautiful if you can make all its elements the same by using a specific operation any number of times. The operation is: choose an index i (2 ≤ i ≤ |a| - 1) such that a[i - 1] = a[i + 1], and replace a[i] with a[i - 1].

So, in other words, if the elements on both sides of an element are equal, I can change that element to match them. The goal is to make all elements equal using such operations.

Now, the problem says that the given array is already beautiful, so I don't need to verify that. I just need to figure out how to make it not beautiful by removing the fewest elements possible.

Let me think about what makes an array not beautiful. If after removing some elements, I can't apply any more operations to make all elements equal, then it's not beautiful.

Looking at the example:

In the first test case:

3

2 2 2

It's already all elements equal, so no matter how many elements I remove, it will still be all equal (or empty, which might be considered not beautiful, but according to the problem, it seems like having at least one element is required).

Wait, the problem says: "the given array a is beautiful. You are to remove some elements from it (possibly none or all, except all) in such a way that the resulting array is not beautiful."

So, removing all elements is not allowed, and the array must still have at least one element.

In the first test case, removing any one element will still leave all elements equal, so it remains beautiful. Removing two elements will leave only one element, which is still all equal, so still beautiful. Removing all elements is not allowed. So, it's impossible to make it not beautiful, hence output -1.

In the second test case:

5

1 2 1 2 1

Removing one element can make it not beautiful, as shown in the explanation.

So, my task is to find the minimum number of elements to remove to break the property of being beautiful.

I need to find a general approach for any given beautiful array.

Let me try to understand the property of a beautiful array.

If the array is already all equal, then it's beautiful, and removing any subset will still leave it all equal or empty (which is not allowed). So, in this case, it's impossible to make it not beautiful, so output -1.

But the problem says that in every test case, the given array is beautiful, so I don't need to worry about verifying beauty.

Wait, but according to the note, in the first test case, even if it's all equal, it's still considered beautiful, and removing any elements won't make it not beautiful, so output -1.

In the second test case, it's not all equal, but it's still beautiful, and by removing one element, it becomes not beautiful.

So, I need to find a way to determine the minimum number of elements to remove to make the array not beautiful.

Let me think about what operations are allowed to make the array beautiful.

The operation is: choose an index i (2 ≤ i ≤ |a| - 1) such that a[i - 1] = a[i + 1], and replace a[i] with a[i - 1].

So, if the neighbors are equal, I can change the middle element to match them.

The goal is to make all elements equal using these operations.

Now, if I can make all elements equal, then the array is beautiful.

To make it not beautiful, I need to ensure that after removing some elements, it's impossible to make all elements equal using these operations.

Wait, but the problem defines a array as beautiful if you can make all elements equal by using these operations any number of times.

So, to make it not beautiful, I need to ensure that after removal, it's impossible to make all elements equal using these operations.

But, in the first test case, where all elements are already equal, removing some elements still leaves all elements equal, so it remains beautiful. Hence, output -1.

In the second test case, by removing one element, I can make it such that it's no longer possible to make all elements equal using these operations.

So, I need to find the minimal number of removals to reach a state where it's impossible to make all elements equal using these operations.

I need to find a general strategy for any beautiful array.

Let me consider that in a beautiful array, you can perform operations to make all elements equal.

So, to make it not beautiful, I need to disrupt this property.

One way to think about it is to break the array into parts where the operations can't be applied anymore.

But I need a more concrete approach.

Let me consider that if the array has all elements equal, it's beautiful, and removing elements won't change that, so output -1.

If the array has different elements, but it's still beautiful, meaning that by applying the operations, I can make all elements equal.

So, to make it not beautiful, I need to ensure that after removal, it's impossible to make all elements equal.

But how?

Let me think about the operations allowed.

The operation allows me to change a[i] to a[i-1] if a[i-1] == a[i+1].

So, essentially, it allows me to propagate values from the ends towards the center, provided that the neighbors are equal.

So, in a way, it's like filling in the gaps where the neighbors are the same.

To make the array not beautiful, I need to ensure that after removal, there are elements that cannot be made equal to each other using these operations.

One way to think about it is to have at least two elements that cannot be made equal.

But I need to be careful.

Let me consider that if there are two different values that are separated in such a way that operations cannot propagate one value to the other, then the array is not beautiful.

So, perhaps, I need to remove elements to create such a separation.

Wait, maybe I should look for the minimal number of removals to make the array not beautiful.

Looking at the example:

Test case 2:

5

1 2 1 2 1

If I remove a[5], the array becomes [1,2,1,2].

Now, can I make all elements equal?

Let's see:

- Initially: [1,2,1,2]

- Can I apply any operations?

- For i=2: a[1]=1, a[3]=1, so a[2]=2 can be changed to 1.

- After changing: [1,1,1,2]

- Now, for i=4: a[3]=1, a[5]=nothing (out of bounds), so can't apply operation.

- Now, [1,1,1,2]

- For i=2: a[1]=1, a[3]=1, so a[2]=1 is already equal.

- For i=3: a[2]=1, a[4]=2, which are different, so no operation.

- So, the array is [1,1,1,2], which is not all equal, so it's not beautiful.

Hence, by removing one element, I can make it not beautiful.

Similarly, in the fourth test case:

7

3 3 3 5 3 3 3

If I remove the first three elements, the array becomes [5,3,3,3].

Is this beautiful?

- [5,3,3,3]

- Can I apply operations?

- For i=2: a[1]=5, a[3]=3, which are different, so no operation.

- For i=3: a[2]=3, a[4]=3, so a[3]=3 is already equal.

- So, no operations can be applied, and the array is not all equal, hence not beautiful.

So, by removing three elements, I can make it not beautiful.

But is there a way to do it by removing fewer elements?

Let's see:

If I remove only one element, say a[4]=5.

Then the array becomes [3,3,3,3,3].

This is all equal, which is beautiful.

If I remove a[1]=3.

Then the array becomes [3,3,5,3,3,3].

Is this beautiful?

- [3,3,5,3,3,3]

- For i=2: a[1]=3, a[3]=5, different, no operation.

- For i=3: a[2]=3, a[4]=3, so a[3]=5 can be changed to 3.

- After changing: [3,3,3,3,3,3], which is all equal, so beautiful.

- So, still beautiful.

If I remove two elements, say a[1] and a[2].

Then the array becomes [3,5,3,3,3].

Is this beautiful?

- [3,5,3,3,3]

- For i=2: a[1]=3, a[3]=3, so a[2]=5 can be changed to 3.

- After changing: [3,3,3,3,3], which is all equal, so beautiful.

- Still beautiful.

If I remove a[1] and a[4].

Then the array becomes [3,3,3,3,3].

Still all equal, beautiful.

If I remove a[4] and a[5].

Then the array becomes [3,3,3,3,3].

Still all equal, beautiful.

If I remove a[1], a[2], and a[3], as in the example, I get [5,3,3,3], which is not beautiful.

So, removing three elements is necessary in this case.

Hence, the minimal number of removals is three.

Now, I need a general approach to find this minimal number for any beautiful array.

Looking back at the problem, it says that in every test case, the given array is beautiful, so I don't need to check that.

I need to find the minimal number of elements to remove so that the resulting array is not beautiful.

Or output -1 if it's impossible.

From the first test case, if the array is all equal, then it's impossible to make it not beautiful, so output -1.

Otherwise, I need to find the minimal number of removals.

Looking at the code provided:

It seems to handle the case where all elements are equal.

It sets a flag to True if all elements are equal, and in that case, prints -1.

Otherwise, it tries to find some minimal value among counts of consecutive elements equal to the first element.

But I'm not sure if this is the correct approach.

Let me think differently.

I need to ensure that after removal, it's impossible to make all elements equal using the given operations.

One way to think about it is to have at least two different elements that cannot be made equal using the operations.

But I need to ensure that these elements cannot be made equal no matter how many operations are performed.

Given the operation allows changing a[i] to a[i-1] if a[i-1] == a[i+1], it seems like it allows propagating values from the ends towards the center, provided the neighbors are equal.

So, perhaps, if I can divide the array into segments where the values cannot be propagated between them, then the array would not be beautiful.

Wait, maybe I need to have at least two segments with different values that cannot be made equal.

So, perhaps, the minimal number of removals is equal to the size of the smallest segment that needs to be removed to separate the array into such segments.

But this is getting complicated.

Let me look for a different approach.

Perhaps, the minimal number of removals is equal to the minimal number of elements that, when removed, disconnect the array in such a way that the remaining elements cannot all be made equal.

But I need a more concrete plan.

Let me consider that if the array is already all equal, then output -1.

Otherwise, if there are different elements, I need to find the minimal number of removals such that after removal, the remaining array cannot be made all equal.

Wait, perhaps the minimal number of removals is equal to the minimal number of elements that, when removed, leave at least two different elements that cannot be made equal.

But I need to formalize this.

Let me consider that in a beautiful array, you can make all elements equal by propagating values from the ends towards the center where neighbors are equal.

So, to make it not beautiful, I need to disrupt this propagation.

One way to do this is to have at least two different elements that cannot be connected through a sequence of operations.

But I need to find the minimal number of removals to achieve this.

Alternatively, perhaps the minimal number of removals is equal to the minimal number of elements that, when removed, leave at least two different elements that are not connected through equal neighbors.

Wait, perhaps it's similar to finding the minimal number of removals to break a connected component.

If I think of the array as a graph where elements are connected if they can be made equal through operations, then removing elements that connect different parts would disconnect the graph.

This might be similar to finding cut vertices or minimum vertex cuts.

But this is getting too complicated for the problem.

Let me look for a simpler approach.

Looking back at the code provided:

It checks if all elements are equal, and if so, prints -1.

Otherwise, it seems to find the minimum count of consecutive elements equal to the first element.

I don't think this is correct.

Let me consider another approach.

Suppose I have an array that is beautiful.

I need to remove elements such that after removal, it's not beautiful.

What if I remove elements to leave an array where not all elements can be made equal?

But I need to minimize the number of removals.

Perhaps, the minimal number of removals is equal to the size of the smallest subset of elements whose removal leaves at least two different elements that cannot be made equal.

But I need a better way to compute this.

Let me consider that in a beautiful array, you can make all elements equal by propagating values where neighbors are equal.

So, if I can divide the array into segments where each segment can be made equal, but the segments themselves have different values, then the array is not beautiful.

Wait, no.

If I have segments with different values that cannot be made equal, then the array is not beautiful.

So, perhaps, the minimal number of removals is equal to the number of elements that connect different segments.

This seems similar to finding the number of elements that, when removed, disconnect the array into segments with different values.

But I need to find a way to compute this efficiently.

Let me consider that in a beautiful array, you can make all elements equal by propagating values through the array where neighbors are equal.

So, if the array has runs of equal elements separated by different elements, and you can propagate values through these runs, then to make it not beautiful, you need to break these propagation paths.

So, perhaps, the minimal number of removals is equal to the number of elements that are connecting different runs.

This might be similar to finding the number of times the element changes value.

Wait, let's think differently.

Suppose I have an array like:

1,1,1,2,2,2,1,1,1

This is beautiful because I can propagate the 1's to the 2's or vice versa.

To make it not beautiful, I need to remove elements in such a way that the remaining array has segments that cannot be made equal.

For example, removing the middle three 2's would leave [1,1,1,1,1], which is all equal, still beautiful.

So, that doesn't help.

Alternatively, removing some 1's to separate the runs.

For example, removing the first and last 1's would leave [1,1,2,2,2,1,1], which is still beautiful because I can propagate the 1's to the 2's.

It's tricky.

Let me consider another approach.

Suppose I fix a value, say the first element's value, and try to see how many elements need to be removed so that not all remaining elements can be made equal to this value.

But I need to consider all possible values.

Wait, perhaps I can find the minimal number of removals needed to prevent the array from being made all equal to any single value.

So, for each value, find the minimal number of removals needed to prevent the array from being made all equal to that value, and then take the minimal over all values.

But I need to think differently.

Let me consider that in a beautiful array, you can make all elements equal by propagating values through the array where neighbors are equal.

So, if I have a value that is present in runs that are connected through equal neighbors, then I can make all elements equal to that value.

To make the array not beautiful, I need to ensure that after removal, there is no value that can be propagated to make all elements equal.

One way to do this is to have at least two different values in the array such that there is no path of equal neighbors connecting them.

This way, I cannot propagate one value to the other.

So, perhaps, the minimal number of removals is equal to the minimal number of elements that, when removed, disconnect the array in such a way that at least two different values are separated.

This sounds similar to finding the minimal vertex cut in a graph where elements are connected if they can be made equal.

But implementing this seems complicated.

Let me think of a simpler way.

Looking back at the code provided:

It checks if all elements are equal, and if so, prints -1.

Otherwise, it initializes a variable 'val' to the first element and 'cnt' to 0.

Then, it iterates through the array, counting consecutive elements equal to 'val', and keeps track of the minimum count of such sequences.

Finally, it prints this minimum count.

Wait, in the second test case:

5

1 2 1 2 1

val = 1

cnt = 1 (first 1)

then 2 is not 1, so ans = min(inf, 1) = 1, cnt = 0

then next 1, cnt = 1

next 2, not 1, ans = min(1,1) =1, cnt=0

next 1, cnt=1

So, ans =1

Which matches the example output.

In the fourth test case:

7

3 3 3 5 3 3 3

val =3

cnt=3 (first three 3's)

then 5 !=3, ans = min(inf,3)=3, cnt=0

then next three 3's, cnt=3

So, ans=3

Which also matches the example output.

So, perhaps this approach is correct.

But I need to verify if this is indeed the correct solution.

Let me see.

The approach seems to be finding the minimum length of a run of the first element's value.

In the second test case, the first element is 1, and the runs of 1's have lengths 1,1,1.

The minimum is 1, which matches the output.

In the fourth test case, runs of 3's have lengths 3 and 3, so minimum is 3.

Which matches the output.

But is this always correct?

Let me consider another example.

Suppose the array is:

4

1 2 1 2

This is beautiful because you can change the middle 1 to 2, making it [1,2,2,2], and then change the first 1 to 2, making it all 2's.

So, it's beautiful.

What does the code output?

val =1

cnt=1 (first 1)

then 2 !=1, ans=min(inf,1)=1, cnt=0

then 1, cnt=1

then 2 !=1, ans=min(1,1)=1, cnt=0

So, ans=1

Which means removing one element is sufficient to make it not beautiful.

Is that correct?

If I remove one element, say the first 1, the array becomes [2,1,2]

Is this not beautiful?

Let's see:

Can I make all elements equal?

- Initially [2,1,2]

- For i=2: a[1]=2, a[3]=2, so change a[2]=1 to 2.

- Now, the array is [2,2,2], which is beautiful.

- So, removing the first 1 doesn't help.

What if I remove the second element, which is 2?

Then the array is [1,1,2]

- Can I make all elements equal?

- For i=2: a[1]=1, a[3]=2, different, no operation.

- So, it's [1,1,2], which is not all equal, and no operations can be performed.

- Hence, not beautiful.

So, removing one element can make it not beautiful.

Hence, ans=1 is correct.

Another example:

4

1 1 2 2

This is beautiful because you can change the third element 2 to 1, making it [1,1,1,2], and then change the last 2 to 1, making it all 1's.

What does the code output?

val=1

cnt=2 (first two 1's)

then 2 !=1, ans=min(inf,2)=2, cnt=0

then next 2, cnt=1

So, ans=1

But actually, removing one element can make it not beautiful.

For example, remove the third element, which is 2.

Then the array is [1,1,2].

- Can I make all elements equal?

- For i=2: a[1]=1, a[3]=2, different, no operation.

- So, [1,1,2] is not beautiful.

Hence, ans=1 is correct.

Another example:

5

1 2 1 2 1

As in the second test case, ans=1, which is correct.

Another example:

3

1 1 1

All equal, output -1, which is correct.

Another example:

4

1 2 3 4

This is beautiful? Let's see.

Can I make all elements equal?

Starting with [1,2,3,4]

No operations can be performed because for i=2, a[1]=1 != a[3]=3, so no operation.

Similarly for i=3, a[2]=2 != a[4]=4, no operation.

So, it's not beautiful.

Wait, but the problem says that the given array is beautiful, so this case won't appear.

But according to the problem, in every test case, the given array is beautiful.

So, I don't need to handle arrays that are not beautiful.

Hence, in this example, it's given that the array is beautiful, meaning that you can make all elements equal using the operations.

Wait, but [1,2,3,4] seems not beautiful, so such a test case won't appear.

Hence, I don't need to consider it.

Another example:

5

1 1 2 2 2

This is beautiful because you can change the third element 2 to 1, making it [1,1,1,2,2], then change the fourth element 2 to 1, making [1,1,1,1,2], and then change the last 2 to 1, making all 1's.

What does the code output?

val=1

cnt=2 (first two 1's)

then 2 !=1, ans=min(inf,2)=2, cnt=0

then next three 2's, cnt=3

So, ans=2

Is removing two elements sufficient to make it not beautiful?

Let's try removing two elements.

Suppose remove the third and fourth elements, which are 2's.

Then the array is [1,1,2], which is not beautiful, as explained earlier.

Hence, ans=2 is correct.

Seems like the approach is working.

Another example:

6

1 2 1 2 1 2

This is beautiful because you can change the second 1 to 2, making [1,2,2,2,1,2], then change the fifth 1 to 2, making [1,2,2,2,2,2], then change the first 1 to 2, making all 2's.

What does the code output?

val=1

cnt=1

then 2 !=1, ans=min(inf,1)=1, cnt=0

then 1, cnt=1

then 2 !=1, ans=min(1,1)=1, cnt=0

then 1, cnt=1

then 2 !=1, ans=min(1,1)=1, cnt=0

So, ans=1

Is removing one element sufficient to make it not beautiful?

Let's try removing the first element.

Array becomes [2,1,2,1,2]

- Can I make all elements equal?

- For i=2: a[1]=2, a[3]=2, so change a[2]=1 to 2.

- Now, [2,2,2,1,2]

- For i=4: a[3]=2, a[5]=2, so change a[4]=1 to 2.

- Now, [2,2,2,2,2], which is beautiful.

- So, still beautiful.

What if I remove the second element?

Array becomes [1,1,2,1,2]

- Can I make all elements equal?

- For i=2: a[1]=1, a[3]=2, different, no operation.

- For i=3: a[2]=1, a[4]=1, so a[3]=2 can be changed to 1.

- Now, [1,1,1,1,2]

- For i=5: a[4]=1, a[6]=nothing, no operation.

- So, [1,1,1,1,2], which is not all equal, and no operations can be performed. Hence, not beautiful.

So, removing one element can make it not beautiful.

Hence, ans=1 is correct.

Seems like the approach is working in this case.

Another example:

5

1 1 2 2 1

This is beautiful because you can change the third element 2 to 1, making [1,1,1,2,1], then change the fourth element 2 to 1, making [1,1,1,1,1].

What does the code output?

val=1

cnt=2

then 2 !=1, ans=min(inf,2)=2, cnt=0

then next two 2's, cnt=2

then 1 !=2, ans=min(2,2)=2, cnt=0

then 1, cnt=1

So, ans=1

Wait, no.

Wait, val is set to the first element, which is 1.

So, cnt=2 (first two 1's)

then 2 !=1, ans=min(inf,2)=2, cnt=0

then next two 2's, cnt=2

then 1 !=2, ans=min(2,2)=2, cnt=0

then 1, cnt=1

So, ans=1

But according to the approach, it should be the minimum of these counts, which is 1.

Is removing one element sufficient to make it not beautiful?

Let's try removing the first element.

Array becomes [1,2,2,1]

- Can I make all elements equal?

- For i=2: a[1]=1, a[3]=2, different, no operation.

- For i=3: a[2]=2, a[4]=1, different, no operation.

- So, [1,2,2,1], which is not all equal, and no operations can be performed. Hence, not beautiful.

So, removing one element is sufficient.

Hence, ans=1 is correct.

Seems like the approach is working.

Let me see the general case.

It seems that the code finds the minimum length of consecutive runs of the first element's value.

Then, it outputs this minimum.

But in the fourth test case:

7

3 3 3 5 3 3 3

val=3

cnt=3 (first three 3's)

then 5 !=3, ans=min(inf,3)=3, cnt=0

then next three 3's, cnt=3

So, ans=3

Which matches the example output.

Is removing three elements sufficient to make it not beautiful?

As shown earlier, yes.

Is removing two elements sufficient?

Let's try removing two elements.

Suppose remove the first two elements.

Array becomes [3,3,5,3,3,3]

- Can I make all elements equal?

- For i=2: a[1]=3, a[3]=5, different, no operation.

- So, [3,5,3,3,3]

- For i=2: a[1]=3, a[3]=3, so change a[2]=5 to 3.

- Now, [3,3,3,3,3], which is beautiful.

- So, still beautiful.

What if I remove the first and the fourth elements.

Array becomes [3,3,3,3,3]

Still beautiful.

What if I remove the fourth, fifth, and sixth elements.

Array becomes [3,3,3,3]

Which is beautiful.

What if I remove the first three elements.

Array becomes [5,3,3,3]

- Can I make all elements equal?

- For i=2: a[1]=5, a[3]=3, different, no operation.

- So, [5,3,3,3], which is not all equal, and no operations can be performed. Hence, not beautiful.

So, removing three elements is sufficient.

Hence, ans=3 is correct.

Seems like the approach is working.

But is this always correct?

Let me think of a case where it might fail.

Suppose the array is:

6

1 1 2 2 3 3

This is beautiful because you can change a[3] to 1, making [1,1,1,2,3,3], then change a[4] to 1, making [1,1,1,1,3,3], then change a[5] to 1, making [1,1,1,1,1,3], and finally change a[6] to 1, making all 1's.

What does the code output?

val=1

cnt=2 (first two 1's)

then 2 !=1, ans=min(inf,2)=2, cnt=0

then next two 2's, cnt=2

then 3 !=2, ans=min(2,2)=2, cnt=0

then next 3, cnt=1

So, ans=1

Is removing one element sufficient to make it not beautiful?

Let's try removing the first element.

Array becomes [1,2,2,3,