Alright, I have this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, and I can perform a certain operation on it no more than 5*10^5 times to maximize the sum of the array. The operation involves choosing a subarray, computing its MEX, and then setting all elements in that subarray to that MEX value.

First, I need to understand what MEX is. MEX of a set of integers is the smallest non-negative integer not present in the set. For example, MEX of [0, 1] is 2, since 0 and 1 are present, and 2 is the smallest non-negative integer missing.

My goal is to maximize the sum of the array by performing these operations. I also need to output the maximum sum and a sequence of operations that achieve this sum, with the number of operations not exceeding 5*10^5.

Given that n can be up to 18, it seems manageable, but I need to think carefully about the approach.

Let me consider the constraints:

- n ≤ 18: relatively small, so exponential time solutions might be feasible.

- a_i ≤ 10^7: quite large, but since we're dealing with sums, I need to make sure I don't have integer overflow issues.

- Operations can be up to 5*10^5: plenty, so I don't need to minimize the number of operations.

Given that n is small (n ≤ 18), I can consider trying all possible subarrays and see what happens, but that would be O(n^2), which is acceptable for n=18.

Wait, but operations can be up to 5*10^5, which is way more than n^2, so maybe I need a different approach.

Let me think about the properties of MEX:

- MEX is always a non-negative integer.

- For a subarray, MEX is determined by the unique elements in that subarray.

- When I set a subarray to its MEX, I'm essentially replacing all elements in that subarray with the MEX value.

- Since I can perform this operation multiple times, I need to find a sequence of operations that maximizes the sum.

I need to maximize the sum of the array. So, I should aim to set as many elements as possible to the highest possible values.

Given that MEX is the smallest missing non-negative integer, in a subarray with elements [0,1], MEX is 2. If I set this subarray to 2, the sum increases.

Wait, in the first example:

Input:

2

0 1

Output:

4 1

1 2

After the operation, the array becomes [2,2], sum=4.

In the second example:

Input:

3

1 3 9

Output:

13 0

No operations are needed because the sum is already 13, which is the maximum possible.

In the third example:

Input:

4

1 100 2 1

Operations:

3 3

3 4

Resulting array: [1,100,2,2], sum=105.

In the fourth example:

Input:

1

0

Output:

1 1

1 1

After operation, array becomes [1], sum=1.

So, in this case, MEX of [0] is 1, so setting it to 1 increases the sum.

From these examples, it seems that performing operations on subarrays can increase the sum by setting them to higher MEX values.

But I need to find a way to maximize this sum efficiently.

Let me consider the following approach:

- Try to find subarrays where setting them to their MEX increases the sum, and perform operations on them.

- Repeat this process until no further improvements can be made.

However, this seems too vague and may not lead to the optimal solution.

Given that n is small (n ≤ 18), perhaps I can consider all possible subarrays and calculate the MEX for each, then decide which operations to perform.

But even for n=18, the number of subarrays is n*(n+1)/2 = 171, which is manageable.

But I need to find a sequence of operations that leads to the maximum sum.

Wait, maybe I can model this as a dynamic programming problem, where states represent the current configuration of the array, and transitions are the operations performed.

But with n=18, the state space is too large for traditional DP.

Alternatively, perhaps I can consider the final array and work backwards.

Wait, let's think differently.

Since I can perform up to 5*10^5 operations, which is way more than needed, perhaps there's a way to achieve the maximum sum with a minimal number of operations.

But the problem allows up to 5*10^5 operations, so I don't need to minimize the number of operations.

I just need to reach the maximum possible sum.

Let me consider what the maximum possible sum could be.

If I could set each element to the highest possible value, that would be ideal.

But the MEX is constrained by the elements in the subarray.

Wait, perhaps there's a way to compute the maximum possible sum independently of the operations and then find a sequence of operations that reaches that sum.

That sounds promising.

So, first, find the maximum possible sum S_max.

Then, find a sequence of operations that transforms the original array into an array that sums to S_max.

But how do I find S_max?

Let me consider that after performing operations, each subarray set to its MEX.

But operations can overlap, and MEX values can change based on previous operations.

This seems complicated.

Wait, perhaps I can consider that in the final array, each element is set to the MEX of some subarray it belongs to.

But that's still unclear.

Let me consider that the final array consists of segments where each segment is set to the MEX of some subarray.

But I need a better way to model this.

Another idea: Since n is small, perhaps I can consider all possible ways to partition the array into segments and compute the MEX for each segment, then sum them up.

Wait, but operations can be performed multiple times on overlapping subarrays.

This seems too vague.

Let me consider that performing operations can only increase the sum, as setting a subarray to its MEX can only increase the sum if MEX is greater than the average of the subarray elements.

Wait, not necessarily. For example, if a subarray is [0,1], MEX is 2, and setting both to 2 increases the sum from 1 to 4.

But if a subarray is [1,3], MEX is 0, and setting both to 0 decreases the sum from 4 to 0.

Wait, no. MEX is the smallest non-negative integer not present in the set.

So, for [1,3], MEX is 0, since 0 is not present.

Wait, but 0 is a non-negative integer, so MEX is 0.

But setting [1,3] to 0 would decrease the sum from 4 to 0, which is not desirable.

But in the problem statement, it says to maximize the sum, so perhaps I need to choose operations that increase the sum.

Wait, in the second example:

3

1 3 9

Output:

13 0

meaning no operations are performed because the sum is already maximized.

In the first example:

2

0 1

Output:

4 1

1 2

setting [0,1] to MEX=2, sum becomes 4.

In the third example:

4

1 100 2 1

Operations:

3 3

3 4

Resulting array: [1,100,2,2], sum=105.

Wait, but initially, sum was 1 + 100 + 2 + 1 = 104.

After operations, sum is 105.

Wait, but in the operations:

First operation: 3 3, meaning set a_3 to MEX of [2], which is 0, so [1,100,0,1].

Then second operation: 3 4, set a_3 and a_4 to MEX of [0,1], which is 2, so [1,100,2,2], sum=105.

Wait, but in the first operation, setting a_3 to MEX of [2], which is 0, decreases the sum from 104 to 1 + 100 + 0 + 1 = 102.

Then, second operation: set a_3 and a_4 to MEX of [0,1], which is 2, so [1,100,2,2], sum=105.

So, overall, the sum increased from 104 to 105.

But why not perform operations that increase the sum further?

Wait, is 105 the maximum possible?

Let's see.

If I try to set the entire array to MEX of [1,100,2,1], which is 0, sum would be 0, which is worse.

Alternatively, set [1,100,2] to MEX=0, and [1] to MEX=0, sum=0+0+0+1=1.

Not better.

Or set [1,100] to MEX=0, and [2,1] to MEX=0, sum=0+0+0+0=0.

Worse.

So, indeed, 105 seems to be the best.

Another consideration: perhaps the maximum sum is achieved when each segment is set to the highest possible MEX value without decreasing the sum.

But how to determine the segments?

This seems tricky.

Let me consider that for a subarray, setting it to its MEX can only be beneficial if the MEX is greater than the average of the subarray elements.

But calculating averages might not be straightforward.

Alternatively, perhaps I can consider that the final array should have segments where each segment is set to the MEX of that segment, and this MEX is as large as possible.

But how to maximize the sum?

Wait, perhaps I can consider that for a segment, setting it to its MEX is only beneficial if the MEX is larger than the current elements' sum divided by the segment length.

But this seems too vague.

Let me think differently.

Suppose I fix the lengths of the segments.

For example, for n=4, I can have segments of lengths (4), (3,1), (2,2), (1,3), (1,1,2), (1,2,1), (2,1,1), (1,1,1,1).

For each possible segmentation, I can compute the MEX for each segment and sum them up.

Then, choose the segmentation that gives the maximum sum.

Given that n is small (n ≤ 18), I can consider all possible ways to split the array into segments, compute the MEX for each segment, set the segment to that MEX, and sum them up.

Then, choose the segmentation that gives the maximum sum.

This sounds feasible.

So, the idea is:

- Consider all possible ways to split the array into contiguous segments.

- For each way, compute the MEX of each segment, set the segment to that MEX, and compute the sum.

- Choose the segmentation that gives the maximum sum.

Given that n is small, I can iterate through all possible segmentations.

But wait, the number of ways to split an array of length n into contiguous segments is the number of ways to choose where to split, which is O(n * 2^n), which is acceptable for n=18.

But perhaps there's a smarter way.

Wait, actually, the number of ways to split an array into contiguous segments is equal to the number of compositions of n, which is 2^(n-1), which for n=18 is about 262,000, which is manageable.

So, I can iterate through all possible segmentations, compute the MEX for each segment, set the segment to that MEX, compute the sum, and keep track of the maximum sum.

Then, for the chosen segmentation, I can construct a sequence of operations that achieves this sum.

But how to construct the operations?

Well, for each segment, I can perform an operation on that segment to set it to its MEX.

Since operations can be performed up to 5*10^5 times, and n is small, I can perform operations segment by segment.

Wait, but I need to make sure that when I set a segment to its MEX, the MEX is correctly computed based on the current values in the segment.

But if I perform operations in a specific order, this could be tricky, because operations can affect each other.

Wait, perhaps I need to perform operations in a way that segments are set in a specific order, maybe from left to right or right to left.

This seems complicated.

Let me think of a better way.

Another idea: Since the operations can be performed any number of times (up to 5*10^5), perhaps I can perform operations in a way that gradually increases the values in the array until I reach the desired maximum sum.

But I need to define what the desired maximum sum is.

Wait, perhaps I can compute the maximum possible sum by considering that each element can be set to the maximum possible value, which would be the MEX of the entire array if I set the entire array at once.

But in the first example, setting [0,1] to MEX=2 gives sum=4, which is better than setting each element individually.

Wait, if I set [0] to MEX=1 and [1] to MEX=0, sum would be 1 + 0 = 1, which is worse than 4.

So, setting larger segments can lead to higher sums.

But in the third example, setting [1,100,2,1] to MEX=0 gives sum=0, which is worse than setting [1,100,2,1] in parts.

So, it's not always optimal to set the entire array at once.

Hence, I need to find the best way to split the array into segments to maximize the sum.

So, dynamic programming might be a way to go.

Let me consider DP[i], which represents the maximum sum for the first i elements.

Then, for each i from 1 to n, DP[i] = max over j from 0 to i-1 of (DP[j] + MEX of a[j+1..i] * (i - j))

Wait, but MEX is not necessarily multiplied by the segment length.

Wait, no, when I set a segment to its MEX, I'm setting each element in the segment to that MEX value, so the sum would be MEX * (i - j).

So, yes, DP[i] = max over j from 0 to i-1 of (DP[j] + MEX of a[j+1..i] * (i - j))

With DP[0] = 0.

Then, the answer would be DP[n].

This seems like a viable approach.

Given that n is small (n ≤ 18), and for each state, I'm iterating over all possible previous states, the total time complexity would be O(n^2), which is acceptable.

Now, I need to implement this DP approach to find the maximum possible sum.

Then, I need to reconstruct the sequence of operations that leads to this sum.

To do that, I can keep track of the previous state during the DP computation and then backtrack to find the segments used.

Once I have the segments, I can perform operations on those segments to set them to their respective MEX values.

Given that operations can be performed multiple times, I can perform operations in any order, as long as I set each segment to its MEX.

Wait, but I need to ensure that when I compute the MEX for a segment, it's based on the current values in that segment.

But if I perform operations in a certain order, the MEX values might change.

Wait, no, if I set a segment to its MEX first, and then set larger segments, the MEX of larger segments might be affected.

This seems tricky.

Perhaps a better approach is to perform operations on the smallest segments first and then larger segments.

Or maybe perform operations from left to right or right to left.

I need to ensure that when I set a segment to its MEX, the MEX is correctly computed based on the current values in that segment.

Wait, perhaps I can perform operations in such a way that once a segment is set to a particular value, it's not changed again.

If I can ensure that, then I can fix the MEX values for each segment and achieve the desired sum.

Given that, I can perform operations in a specific order to set each segment to its desired MEX value without interfering with other segments.

But I need to make sure that when I set a segment, its MEX is correctly computed based on its current values.

Wait, but if I set a segment to its MEX, and then set a larger segment that includes this segment, the MEX of the larger segment might be different.

So, operations can interfere with each other.

This seems complicated.

Perhaps I need to find a sequence of operations where I set the smallest segments first and then larger segments that include them.

But I'm not sure.

Let me consider that MEX is determined by the unique elements in the segment.

If I set a segment to a certain value, it affects the MEX of larger segments that include it.

This seems too tangled.

Maybe I need to accept that constructing the sequence of operations is non-trivial and focus on computing the maximum sum first.

Once I have the maximum sum, I can try to find a way to reach it through a sequence of operations, even if it's not the minimal number of operations.

Given that operations can be performed up to 5*10^5 times, I have plenty of room to perform operations in a non-optimal way.

So, perhaps I can perform operations in a way that sets individual elements to their MEX, then set smaller segments, and so on, until I reach the desired sum.

But I need a systematic way to do this.

Let me consider the DP approach I thought earlier.

Define DP[i] as the maximum sum for the first i elements.

Transition:

DP[i] = max over j from 0 to i-1 of (DP[j] + MEX of a[j+1..i] * (i - j))

With DP[0] = 0.

Then, I can compute DP[n] to get the maximum sum.

To compute MEX of a subarray a[l..r], I need to find the smallest non-negative integer not present in a[l..r].

Given that n is small, I can precompute MEX for all possible subarrays.

Let me consider writing a function to compute MEX of a given subarray.

In Python, I can use a set to store the unique elements in the subarray and then find the smallest missing non-negative integer.

Given that a_i can be up to 10^7, but n is small, it's manageable.

Once I have the MEX for each subarray, I can use them in the DP transitions.

Then, to reconstruct the sequence of operations, I can keep track of the segments chosen in the DP.

For example, keep a list that for each i, stores the j that gives the maximum DP[i].

Then, starting from i=n, go back to j, then from j to the previous j, and so on, collecting the segments.

Once I have the segments, I can perform operations on them to set them to their MEX values.

But I need to ensure that when I perform an operation on a segment, the MEX is correctly computed based on the current values in that segment.

Wait, but if I perform operations in a specific order, say from smallest segments to larger segments, I might avoid interference.

Alternatively, since I have plenty of operations allowed, I can perform operations in a way that sets individual elements first, then sets larger segments.

But I'm not sure.

Perhaps a better approach is to perform operations on individual elements, setting each to its MEX, which is essentially 1 if the element is 0, or 0 if the element is greater than 0.

Wait, no.

For a single element a_i, MEX of [a_i] is the smallest non-negative integer not in {a_i}.

So, if a_i = 0, MEX is 1.

If a_i = 1, MEX is 0.

If a_i = 2, MEX is 0.

Wait, but MEX is the smallest non-negative integer not present in the set.

So, for a_i = 0, MEX is 1.

For a_i = 1, MEX is 0.

For a_i = 2, MEX is 0.

Wait, but in the first example, [0,1] has MEX 2.

Wait, no, MEX is 2 for [0,1] because 0 and 1 are present, so the smallest missing is 2.

Wait, but for a single element:

- a_i = 0: MEX is 1.

- a_i = 1: MEX is 0.

- a_i = 2: MEX is 0.

- a_i = 3: MEX is 0.

And so on.

So, if I perform operations on individual elements, setting each to its MEX, I can get:

- 0 -> 1

- 1 -> 0

- 2 -> 0

- 3 -> 0

Wait, but in the first example, setting [0,1] to MEX=2 gives a better sum than setting them individually to 1 and 0.

So, setting larger segments can lead to higher sums.

Hence, I need to consider larger segments.

But in some cases, setting individual elements might be better.

I need a way to decide which segments to set.

This is getting complicated.

Let me consider another approach.

Suppose I try to maximize the sum by setting segments where the MEX is higher than the current sum of the segment divided by its length.

But this seems too vague.

Alternatively, perhaps I can consider that the optimal sum is achieved when each segment is set to its MEX, and these segments are chosen in such a way that the total sum is maximized.

Given that, perhaps I can iterate through all possible segmentations, compute the sum for each, and choose the one with the highest sum.

Then, for that segmentation, perform operations that set each segment to its MEX.

Given that operations can be performed multiple times, I can perform operations for each segment individually.

But I need to make sure that when I set a segment, it doesn't affect the MEX computation for other segments.

Wait, but operations can be performed in any order, as long as the final result is that each segment is set to its MEX.

Given that, perhaps I can perform operations in a specific order to achieve this.

Let me consider that.

Suppose I have a segmentation where I have segments S1, S2, ..., Sk.

For each segment Si, I want to set it to its MEX value.

To do this, I can perform an operation on Si to set it to its MEX.

But I need to ensure that when I perform this operation, the MEX is correctly computed based on the current values in Si.

Wait, but the MEX is determined by the current values in Si at the time of the operation.

So, if I perform operations in a specific order, the MEX values might change.

This seems tricky.

Perhaps I need to fix the MEX values for each segment and then perform operations in an order that achieves the desired MEX for each segment.

But how?

Let me think differently.

Suppose I fix the MEX values for each segment and then perform operations that set each segment to its MEX, ignoring the dependencies.

Given that operations can be performed up to 5*10^5 times, perhaps performing multiple operations can compensate for any inconsistencies.

But this seems too vague.

Let me consider that performing an operation on a segment sets all its elements to the current MEX of that segment.

Then, if I perform another operation on a larger segment that includes this segment, the MEX of the larger segment might be different.

So, perhaps I need to perform operations in a specific order to achieve the desired MEX values for each segment.

This seems too error-prone.

Let me consider that the final array is composed of segments set to their MEX values, and I need to find a sequence of operations that achieves this final array.

Given that, perhaps I can perform operations on individual elements first to set them to their MEX, and then perform operations on larger segments to set them to their MEX based on the current values.

But I'm not sure if this would lead to the optimal sum.

This is getting too complicated.

Let me consider that the maximum sum can be achieved by setting the entire array to its MEX, but as we've seen in the examples, this is not always optimal.

So, perhaps I need to consider partial segmentations where some segments are set together.

Given the small n, perhaps I can consider all possible mask representations.

Wait, perhaps I can model this as a graph where each state represents a certain configuration of the array, and operations are edges between states.

But this seems too broad.

Let me consider that for n=18, I can represent the array as a binary tree of segments and compute MEX for each node.

But I'm not sure.

Wait, perhaps I can consider that the maximum sum is achieved when each segment is set to the highest possible MEX that doesn't conflict with other segments.

But I need a systematic way to compute this.

Given the time constraints, perhaps I need to accept that finding the optimal sum through DP and then constructing operations in a straightforward way is acceptable.

So, I'll proceed with the DP approach to compute the maximum sum and keep track of the segments chosen.

Then, for the sequence of operations, I'll perform operations on the chosen segments to set them to their MEX values.

Given that operations can be performed multiple times, I can perform operations in any order.

So, in the output, I can list operations for each chosen segment.

Now, let's think about implementing this.

First, precompute MEX for all possible subarrays.

Given that n=18, precomputing MEX for all O(n^2) subarrays is feasible.

Then, implement the DP to find the maximum sum.

Then, backtrack to find the chosen segments.

Finally, output the sum and the sequence of operations corresponding to the chosen segments.

This seems manageable.

But in the code provided, it seems like a different approach is taken.

Let's look at the given code.

Given code:

input()

lst = list(map(int, input().split()))

ops = []

(r, l) = func_1(lst)

while r != l:

lst = func_3(r, l, lst, ops)

(r, l) = func_1(lst)

try:

while True:

i = lst.index(0) + 1

lst[i - 1] = 1

ops.append([i, i])

except ValueError:

pass

print(sum(lst), len(ops))

for r in ops:

print(*r)

def func_1(lst):

r = l = 0

over_sum = sum(lst)

for i in range(len(lst)):

for j in range(i + 1, len(lst)):

sm = sum(lst[:i]) + sum(lst[j + 1:]) + (j - i + 1) ** 2

if sm > over_sum:

(r, l) = [i, j]

over_sum = sm

return (r, l)

def func_2(r, l, ops: list):

if r == l:

ops.append([r + 1, l + 1])

return

func_2(r, l - 1, ops)

ops.append([r + 1, l + 1])

func_2(r, l - 1, ops)

def func_3(r, l, lst: list, ops: list):

ops.append([r + 1, l + 1])

if min(lst[r:l + 1]) == 0:

ops.append([r + 1, l + 1])

ops.append([r + 1, r + 1])

func_2(r, l, ops)

ops.append([r + 1, l + 1])

n = l - r + 1

lst[r:l + 1] = [n for _ in range(n)]

return lst

So, the code seems to be trying to find subarrays where performing operations can increase the sum.

Let's understand the functions:

- func_1(lst): This function seems to find the subarray [r, l] where performing the operation would maximize the sum.

It iterates through all possible subarrays [i,j], computes the sum as sum(lst[:i]) + sum(lst[j+1:]) + (j - i + 1)^2, and chooses the [i,j] that gives the highest sum.

Wait, why (j - i + 1)^2?

Because when you set the subarray [i,j] to its MEX, which is determined by the unique elements in [i,j], but in this code, it seems to assume that the MEX is equal to the length of the subarray, which is not necessarily true.

Wait, for a subarray of length k, setting it to MEX value x, the sum would be x * k.

But x is not necessarily equal to k.

In the first example, for [0,1], MEX is 2, so sum increase is 2*2 = 4.

But in this code, (j - i + 1)^2 is k^2, which is not matching with x*k.

Wait, perhaps the author assumed that MEX is equal to the length of the subarray, but that's not correct.

For example, for [0,1], MEX is 2, which is not equal to the length 2.

Wait, 2 equals the length in this case, but in [1,3], MEX is 0, which is not equal to the length 2.

So, this seems incorrect.

Wait, maybe the author thought that MEX is equal to the length of the subarray, but that's not generally true.

This seems like a mistake in the code.

Hence, this approach is flawed.

Therefore, the given program is incorrect.

So, Correctness: **False**

**Final Answer**

\[ \boxed{\text{Correctness: False}} \]