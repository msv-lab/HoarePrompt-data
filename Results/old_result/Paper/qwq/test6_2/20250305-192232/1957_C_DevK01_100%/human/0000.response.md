Alright, I've got this problem to solve. Let's see what it's asking for. So, it's about an n x n chessboard where me and the computer take turns placing rooks, but we have to make sure that no two rooks attack each other. Rooks attack each other if they're in the same row or column.

I start first by placing a white rook at some position (r, c). Then the computer mirrors my move by placing a black rook at (c, r), unless r equals c, in which case it skips its turn. This has already happened k times, and I need to find out how many different final configurations are possible from this point onward, considering all possible valid moves until no more moves can be made.

The answer needs to be modulo 10^9 + 7 because the numbers can get really big.

First, I need to understand the game mechanics thoroughly.

1. **Placing Rooks:**

- I place white rooks, and the computer places black rooks.

- My moves are at (r, c), and the computer mirrors at (c, r), unless r == c, in which case it skips.

- We have to ensure that no two rooks are in the same row or column.

2. **Initial State:**

- We have an n x n chessboard.

- We've already made k moves, and the computer has mirrored them accordingly.

- It's guaranteed that these k moves and their mirrors are valid.

3. **Objective:**

- Determine the number of distinct final configurations possible from the current state onward.

- Two configurations are different if there's any position with a rook of different color or no rook at all.

Given that, I need to find a way to calculate the number of possible ways to continue the game until no more moves can be made, starting from the current state.

Let's think about how the game progresses.

## Approach

### Key Observations

1. **Symmetry in Moves:**

- When I place a rook at (r, c), the computer places one at (c, r), unless r == c, in which case it skips.

- This introduces a symmetry in the board regarding the diagonal.

2. **Non-attacking Condition:**

- Rooks must not share the same row or column.

- This implies that each row and each column can have at most one rook.

3. **State of the Board:**

- After k moves, some rows and columns are already occupied.

- We need to consider which rows and columns are still available for placing new rooks.

4. **Counting Configurations:**

- We need to count the number of ways to place rooks in the remaining available positions, considering the mirroring rule.

### Solution Code

```python
t = int(input())
for _ in range(t):
    L = list(map(int, input().split()))
    (n, k) = (L[0], L[1])
    for j in range(k):
        L1 = list(map(int, input().split()))
        (a, b) = (L1[0], L1[1])
        if a != b:
            n -= 2
        else:
            n -= 1
    print(func_1(n))
    continue

def func_1(n):
    dp = [1, 1]
    for i in range(2, n + 1):
        dp += [(dp[-1] + 2 * (i - 1) * dp[-2]) % (7 + 10 ** 9)]
        dp.pop(0)
    return dp[-1]
```

### Explanation

1. **Processing Input:**

- Read the number of test cases, t.

- For each test case, read n (size of the chessboard) and k (number of moves already made).

- For each of the k moves, read the positions (a, b) where rooks have been placed.

2. **Adjusting n based on placed rooks:**

- For each move, if a != b, it affects two positions (a, b) and (b, a), so subtract 2 from n.

- If a == b, it affects only one position, so subtract 1 from n.

3. **Computing the number of configurations:**

- Use a dynamic programming function `func_1(n)` to compute the number of ways to place rooks on the remaining part of the board.

4. **Dynamic Programming Function:**

- `func_1(n)` uses a DP approach to calculate the number of configurations for a board of size n.

- It iteratively builds up the solution using the formula `dp[i] = (dp[i-1] + 2*(i-1)*dp[i-2]) % (10**9 + 7)`.

- This formula accounts for placing rooks in such a way that no two rooks attack each other, considering the mirroring rule.

## Final Solution
To solve this problem, we need to determine the number of different final configurations of rooks on an n x n chessboard, given that players take turns placing rooks without allowing any two rooks to attack each other (i.e., no two rooks share the same row or column). The players place rooks in a mirrored fashion, and we need to compute the configurations modulo 10^9 + 7.

### Approach

1. **Input Parsing:**
   - Read the number of test cases, `t`.
   - For each test case, read the chessboard size `n` and the number of moves `k` already made.
   - For each of the `k` moves, read the positions `(a, b)` where rooks have been placed.

2. **Adjusting Board Size:**
   - For each move, if `a != b`, subtract 2 from `n` because both `(a, b)` and `(b, a)` are occupied.
   - If `a == b`, subtract 1 from `n` because only `(a, b)` is occupied.

3. **Computing Configurations:**
   - Use a dynamic programming (DP) function `func_1(n)` to compute the number of ways to place rooks on the remaining part of the board.

4. **Dynamic Programming Function:**
   - Initialize a DP list with `dp = [1, 1]` for base cases.
   - Iteratively compute the number of configurations for each board size up to `n` using the formula:
     \[
     dp[i] = (dp[i-1] + 2 \times (i-1) \times dp[i-2]) \mod (10^9 + 7)
     \]
   - This formula accounts for placing rooks such that no two rooks attack each other, considering the mirroring rule.

### Solution Code

```python
t = int(input())
for _ in range(t):
    L = list(map(int, input().split()))
    (n, k) = (L[0], L[1])
    for j in range(k):
        L1 = list(map(int, input().split()))
        (a, b) = (L1[0], L1[1])
        if a != b:
            n -= 2
        else:
            n -= 1
    print(func_1(n))
    continue

def func_1(n):
    dp = [1, 1]
    for i in range(2, n + 1):
        dp += [(dp[-1] + 2 * (i - 1) * dp[-2]) % (10**9 + 7)]
        dp.pop(0)
    return dp[-1]
```

### Explanation

1. **Processing Input:**
   - Read the number of test cases, `t`.
   - For each test case, read `n` (size of the chessboard) and `k` (number of moves already made).
   - For each of the `k` moves, read the positions `(a, b)` where rooks have been placed.

2. **Adjusting `n` based on placed rooks:**
   - For each move, if `a != b`, subtract 2 from `n` because both positions `(a, b)` and `(b, a)` are occupied.
   - If `a == b`, subtract 1 from `n` because only one position is occupied.

3. **Computing the number of configurations:**
   - Use a dynamic programming function `func_1(n)` to compute the number of ways to place rooks on the remaining part of the board.
   - The DP function efficiently calculates the number of configurations using an iterative approach, ensuring that the result is within the specified modulo.

This approach ensures that we account for all possible valid placements of rooks while respecting the game's rules and constraints.