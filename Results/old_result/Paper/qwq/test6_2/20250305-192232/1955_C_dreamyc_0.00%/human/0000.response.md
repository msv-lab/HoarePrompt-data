Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n ships, each with some durability a_i, and they're arranged in a sequence from 1 to n. The Kraken attacks these ships k times, alternating between the first and the last ship in the sequence. Each attack reduces the durability of the targeted ship by 1. If a ship's durability drops to 0, it sinks and is removed from the sequence. I need to figure out how many ships are sunk after k attacks.

First, I need to understand the process clearly. The Kraken starts by attacking the first ship, then the last, then the first again, and so on. After each attack, if a ship's durability reaches zero, it's removed from the sequence, which might change which ships are first and last.

Given that n can be up to 2*10^5 and k can be up to 10^15, I need an efficient solution. Brute-force simulation won't work because it would be too slow for large inputs.

Let me think about how to optimize this. Since the attacks alternate between the first and last ships, and ships are removed when they sink, I need a way to handle this efficiently.

One idea is to use a deque to represent the sequence of ships, since deques allow efficient operations at both ends.

I'll define a function func_1 that takes n, k, and the list of durabilities nums. I'll convert nums into a deque for easy access to the first and last elements.

Now, in the while loop, I need to simulate the attacks. But since k can be very large, I need to find a way to handle multiple attacks at once, rather than one by one.

Let's consider that in each full cycle (first and last), the Kraken can attack twice unless one of the ships is sunk in the process. So, I can calculate how many full cycles I can perform before any ship sinks.

But this seems a bit tricky. Let's try another approach.

Suppose I look at the minimum durability between the first and last ship. If I can determine how many attacks I can perform on both ends before either of them sinks, I can reduce k accordingly and keep track of how many ships are sunk.

Wait, maybe I can calculate in batches. For example, find the minimum durability between the first and last ship, then see how many full cycles of attacks (first and last) I can perform before either of them sinks. Then, reduce k by the total attacks performed, and remove the sunk ships.

Let me try to formalize this.

In each step:

- Take the first ship's durability a and the last ship's durability b.

- Let x be the minimum of a and b.

- If k >= 2*x, then I can perform 2*x attacks: x attacks on the first and x on the last.

- After these attacks, both a and b are reduced by x.

- If a > 0 after this, keep it; else, remove it and increment the sunk counter.

- Similarly for b.

- Reduce k by 2*x.

- Repeat until k is less than 2*x or there's only one ship left.

- If there's only one ship left and k >= its durability, it sinks.

This seems efficient because in each iteration, I'm reducing k by a significant amount, specifically by 2*x, where x is the minimum durability of the current first and last ships.

Let me see if this works with the example provided.

Example:

n=4, k=5, nums=[1,2,4,3]

Step 1:

a=1, b=3, x=1

k=5 >= 2*1=2

a -=1 -> a=0, remove first ship, ans+=1

b -=1 -> b=2, keep it

nums=[2,4,2]

k -=2 -> k=3

Step 2:

a=2, b=2, x=2

k=3 < 2*2=4, so can't perform a full cycle here.

Wait, in my earlier logic, if k < 2*x, I should break and handle the remaining k attacks.

But in the example, the process continues with k=3 after step 1.

Wait, maybe I need to adjust my approach.

Looking back at the example explanation:

1. Attack first ship: 1 -> 0 (sinks), remaining [2,4,3]

2. Attack last ship: 3 -> 2

3. Attack first ship: 2 -> 1

4. Attack last ship: 2 -> 1

5. Attack first ship: 1 -> 0 (sinks), remaining [4,1]

So, in total, 2 ships are sunk.

In my approach:

- Step 1: a=1, b=3, x=1, k=5 >=2, a=0 (sinks), b=2, k=3

- Step 2: a=2, b=2, x=2, k=3 <4, so can't perform full cycle.

At this point, I need to handle the remaining k=3 attacks.

But in the example, after step 1, there are still 3 ships: [2,4,2]

Then, in step 2, attack first ship: 2 ->1, k=2

Attack last ship: 2 ->1, k=1

Attack first ship:1 ->0 (sinks), k=0

Total sunk: 2 ships.

So, in my approach, after step 1, I need to handle the remaining k attacks one by one.

Maybe my initial approach needs adjustment.

Alternative approach:

Use two pointers to represent the first and last ships, and simulate the attacks alternately.

Initialize front=0, back=n-1

Initialize a variable to keep track of the current end being attacked (front or back)

Initialize a counter for sunk ships.

While k >0 and front <= back:

If attacking front:

If nums[front] >0:

nums[front] -=1

k -=1

If nums[front] ==0:

front +=1

sunk +=1

Else (attacking back):

If nums[back] >0:

nums[back] -=1

k -=1

If nums[back] ==0:

back -=1

sunk +=1

Switch the end to attack next time (alternate between front and back)

This is a straightforward simulation, but with n up to 2e5 and k up to 1e15, it's too slow.

I need a smarter way.

Let me think about the pattern of attacks.

The attacks alternate between the first and last ships, then first, then last, and so on.

I need to find a way to group the attacks in pairs (first and last) and see how many pairs I can perform before any ship sinks.

But since k can be very large, I need to handle this efficiently.

Another idea: Since the attacks alternate, I can consider the sequence of attacks as front, back, front, back, and so on.

I can calculate how many attacks are needed to sink the first ship and the last ship, considering their turn.

For example, for the first ship, it takes a[0] attacks to sink it, but since it's attacked every other time, effectively it takes ceil(a[0]/1) attacks if it's attacked every time, but since it's every other time, I need to adjust.

Wait, maybe I can think in terms of the number of attacks each ship can absorb before sinking, considering their turn.

This seems complicated.

Let me try to think differently.

Use a deque to represent the ships.

In each step:

- Attack the front ship if it's present.

- Attack the back ship if it's present.

- Repeat until k attacks are used or no ships are left.

But again, this would be too slow for large n and k.

Wait, maybe I can batch the attacks in pairs.

For example, find the minimum durability between the front and back ships.

Suppose front has durability a, back has durability b.

Let x = min(a, b)

If k >= 2*x, then I can perform x attacks on both front and back, reducing their durability by x each.

If k < 2*x, then I can perform k//2 full cycles, reducing front and back by k//2 each, and use the remaining k%2 attacks on the front.

Wait, perhaps I need to think in terms of how many full cycles I can perform before any ship runs out of durability.

Let me try to formalize this.

While there are at least two ships and k >=2:

Find x = min(front, back)

If k >= 2*x:

Perform x attacks on front and x on back.

front -=x

back -=x

k -=2*x

If front ==0:

Remove front, sunk +=1

If back ==0:

Remove back, sunk +=1

Else:

# Not enough k for a full cycle

Perform k//2 full cycles.

front -= k//2

back -= k//2

k -= 2*(k//2)

If k >0:

Attack front once.

front -=1

k -=1

If front ==0:

Remove front, sunk +=1

If back ==0:

Remove back, sunk +=1

Then, repeat until k=0 or only one ship is left.

Finally, if k >0 and only one ship is left, check if k >= remaining durability of that ship. If yes, sink it, else, do nothing.

Let me test this logic with the example.

Example:

n=4, k=5, nums=[1,2,4,3]

Step 1:

front=1, back=3, x=1

k=5 >=2, perform x=1 attacks on both.

front=0, back=2

k=5-2=3

Remove front (sunk +=1), remaining [2,4,2]

Step 2:

front=2, back=2, x=2

k=3 <4, so perform k//2=1 full cycles.

front=2-1=1, back=2-1=1, k=3-2=1

Attack front once: front=1-1=0, k=0

Remove front (sunk +=1), remaining [4,1]

Total sunk: 2

Which matches the example.

Another test:

n=4, k=6, nums=[1,2,4,3]

Step 1:

front=1, back=3, x=1

k=6 >=2, perform x=1 attacks on both.

front=0, back=2

k=6-2=4

Remove front (sunk +=1), remaining [2,4,2]

Step 2:

front=2, back=2, x=2

k=4 >=4, perform x=2 attacks on both.

front=0, back=0

k=4-4=0

Remove front (sunk +=1), remaining [4]

Remove back (sunk +=1), remaining []

Total sunk: 3

Which matches the second test case.

Another test:

n=5, k=20, nums=[2,7,1,8,2]

Step 1:

front=2, back=2, x=2

k=20 >=4, perform x=2 attacks on both.

front=0, back=0

k=20-4=16

Remove front (sunk +=1), remaining [7,1,8,2]

Remove back (sunk +=1), remaining [7,1,8]

Step 2:

front=7, back=8, x=7

k=16 >=14, perform x=7 attacks on both.

front=0, back=1

k=16-14=2

Remove front (sunk +=1), remaining [1,8]

Remove back (sunk +=1), remaining [1]

Step 3:

Only one ship left, k=2 >=1, so sink it, sunk +=1

Total sunk: 5

Which matches the third test case.

Seems correct.

Now, implement this logic efficiently.

Use a deque to represent the ships for O(1) operations at both ends.

Implement the while loop as described, with the conditions to handle k and the ships.

Edge cases to consider:

- All ships are sunk.

- Not all ships are sunk.

- Only one ship is left.

- k is larger than the total durability of all ships.

- k is smaller than the durability of the first or last ship.

- Ships with durability 1.

- Ships with high durability.

Make sure to handle these cases correctly.

Also, since n can be up to 2e5 and t up to 1e4, but sum of n over t is up to 2e5, need to ensure the solution is efficient overall.

Implement the function func_1 accordingly.

Given that, I think the program is correct.

**Final Solution**

To solve this problem, we need to determine how many ships are sunk after a series of attacks by the Kraken. The Kraken alternates between attacking the first and last ships in a sequence, reducing their durability until they sink.

### Approach

1. **Initialization**:
   - Read the number of test cases.
   - For each test case, read the number of ships (n), the number of attacks (k), and the list of durabilities of the ships.

2. **Simulation Optimization**:
   - Use a deque for efficient operations at both ends.
   - While there are enough attacks and at least two ships:
     - Determine the minimum durability between the first and last ship.
     - Calculate how many full cycles of attacks (first and last) can be performed.
     - Reduce the durability of the first and last ships accordingly.
     - Remove ships that have been sunk.
   - Handle any remaining attacks if only one ship is left.

3. **Count Sunk Ships**:
   - Keep a count of the ships that have been sunk during the attacks.

### Solution Code

```python
from collections import deque

def func_1(n, k, nums):
    nums = deque(nums)
    ans = 0
    while k >= 2 and len(nums) >= 2:
        front = nums[0]
        back = nums[-1]
        x = min(front, back)
        if k >= 2 * x:
            nums[0] -= x
            nums[-1] -= x
            k -= 2 * x
            if nums[0] == 0:
                nums.popleft()
                ans += 1
            if nums and nums[-1] == 0:
                nums.pop()
                ans += 1
        else:
            full_cycles = k // 2
            nums[0] -= full_cycles
            nums[-1] -= full_cycles
            k -= 2 * full_cycles
            if k > 0:
                nums[0] -= 1
                k -= 1
                if nums[0] == 0:
                    nums.popleft()
                    ans += 1
            if nums and nums[-1] == 0:
                nums.pop()
                ans += 1
    if k > 0 and len(nums) == 1 and k >= nums[0]:
        ans += 1
    return ans

T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    nums = list(map(int, input().split()))
    ans = func_1(n, k, nums)
    print(ans)
```

### Explanation

- **Dequeue Usage**: A deque is used to efficiently handle the removal and addition of elements from both ends, which is crucial for simulating the attacks on the first and last ships.
- **Attack Cycles**: By calculating the minimum durability and the number of full attack cycles, we optimize the simulation, avoiding individual iterations for each attack.
- **Edge Handling**: The approach handles edge cases such as sinking all ships, having only one ship left, and ensuring that the remaining attacks are correctly applied.

This solution efficiently determines the number of ships sunk after the Kraken's attacks, ensuring it performs well even with large inputs.