Alright, I've got this problem to solve. It's about determining who wins a game between Bodya and Sasha based on their scores after a certain number of turns. They start at specific positions in a permutation, and each turn they can choose to stay or move to another position based on the permutation. The goal is to maximize their scores by collecting points associated with the positions they land on.

First, I need to understand the problem fully. We have a permutation p of length n, and an array a of length n, where a_i represents the points gained when landing on position i. Both players start at positions PB and PS respectively, and the game consists of k turns.

Each turn, both players simultaneously:

1. Add a_x to their score, where x is their current position.

2. Choose to either stay at their current position or move to p_x.

The winner is the one with the higher score after k turns. If scores are equal, it's a draw.

My task is to determine the winner or if it's a draw, assuming both players play optimally to maximize their scores.

Looking at the example provided, it seems that the optimal strategy involves identifying cycles in the permutation and calculating the scores accordingly.

Now, let's look at the given program and see if it correctly implements this logic.

The main function is func_2, which reads input and calls func_1 for each test case. func_1 seems to calculate scores for both players and compare them.

The calculate_score function is where the core logic lies. It simulates the game for a single player starting at a given position.

Let's dive into calculate_score:

- It initializes score to 0 and current_pos to the starting position.

- It keeps track of visited positions to detect cycles.

- It iterates up to k steps, adding a[current_pos - 1] to the score each time.

- If it detects a cycle (a position that has been visited before), it calculates the cycle length and the total score within the cycle.

- It then computes how many full cycles fit into the remaining steps and adds the corresponding score.

- Finally, it adds the score for any remaining steps that don't make up a full cycle.

This seems like a correct approach to handle large k efficiently, especially since n can be up to 2e5 and k up to 1e9. Simulating each step individually would be too slow, so detecting cycles and handling them mathematically is efficient.

Now, let's check if this implementation has any flaws.

First, the function uses a dictionary to track visited positions and their steps to detect cycles. This is efficient in terms of time and space.

The cycle detection seems correct: when a position is revisited, the cycle start is set to the step when it was first visited.

Then, it calculates the cycle length and the total score within one cycle.

After that, it calculates how many full cycles can fit into the remaining steps (after the cycle start) and adds the corresponding score.

Finally, it adds the score for any remaining steps that don't complete another cycle.

This seems logically sound.

However, I need to consider edge cases:

1. If k is 1, the player can only stay or move once.

2. If the permutation has multiple cycles, but the player stays in one cycle.

3. If the player is already in a cycle of length 1 (a fixed point), staying or moving gives the same position.

4. If k is very large, up to 1e9, but the cycle lengths are small, so cycles repeat many times.

5. If n is 1, which is allowed since n >=1, though the problem says 1 <= n <=2e5.

Wait, no, the problem says 1 <= P_B, P_S <= n <= 2e5, so n can be 1, but P_B and P_S must be at least 1.

In the case n=1, the permutation is [1], and the player can only stay or move to p_1=1, which is the same position. So, every move, they stay at position 1 and collect a_1 each turn.

Given that, the score would be k * a_1.

Similarly, for larger n, if the player is in a cycle of length m, and m divides k, the total score would be the score accumulated in one cycle multiplied by (k // m).

If m does not divide k, there would be some remainder steps after the full cycles.

I think the implementation handles this correctly.

Another thing to consider is that both players make their moves simultaneously, but since their moves are independent, except for the fact that they both make decisions at each turn, we can calculate their scores separately and then compare them.

The problem states that they make moves simultaneously, but since their moves don't affect each other's positions, we can treat them independently.

Given that, the implementation seems correct.

Also, the use of a dictionary to track visited positions is efficient, as looking up positions is O(1) on average.

The overall time complexity per test case should be O(n + t), where t is the number of test cases, but since n can be up to 2e5 and t up to 1e4, but the sum of n over all test cases is limited to 2e5, the total time should be acceptable.

Wait, the problem says "It is guaranteed that the sum of values of n over all test cases does not exceed 2e5.", so the total time should be O(2e5 + t), which is acceptable.

Therefore, the implementation seems efficient and correct.

Looking back at the example provided, let's see if the implementation would produce the correct output for the first testcase.

First testcase:

n=4, k=2, PB=3, PS=2

p = [4,1,2,3]

a = [7,2,5,6]

From the explanation, Bodya stays at position 3 both turns, collecting 5 + 5 = 10.

Sasha moves from position 2 to position 1, then stays at position 1, collecting 2 + 7 = 9.

So Bodya wins with 10 > 9.

In the calculate_score function, for Bodya starting at 3:

- Step 0: position 3, score += 5, steps=1

- Not in cycle yet

- Step 1: position 3 again, score +=5, steps=2

- Total score=10

For Sasha starting at 2:

- Step 0: position 2, score +=2, steps=1

- Not in cycle yet

- Step 1: position p_2=1, score +=7, steps=2

- Total score=9

Which matches the example.

Seems correct.

Another thing to check is if a player chooses to stay or move optimally.

In the calculate_score function, it seems to always choose to stay, but according to the problem, they can choose to stay or move each turn.

However, in the implementation, it seems to always choose to stay, which might not be optimal.

Wait, no. Actually, the problem says they can choose to stay or move each turn, but the implementation seems to assume they always stay, which is not correct.

Wait, but in the example, Bodya stays both turns and Sasha moves then stays.

But in the implementation, it seems to simulate the player choosing to stay or move in a way that maximizes the score.

But looking at the code, it doesn't explicitly choose to stay or move; it seems to simulate the player moving according to p_x.

Wait, there's a confusion here.

Let me read the problem again.

"each turn, two things happen to each player:

- If the current position of the player is x, his score increases by a_x.

- Then the player either stays at his current position x or moves from x to p_x."

So, at each turn, the player chooses whether to stay at x or move to p_x.

The choice is made simultaneously by both players, and they choose optimally to maximize their own scores.

In the implementation, the calculate_score function seems to simulate the player moving according to p_x, but it doesn't account for the choice to stay or move.

Wait, actually, in the calculate_score function, it seems to always move to p_x, but according to the problem, the player can choose to stay or move each turn.

So, the implementation is incorrect because it doesn't consider the choice to stay.

The player should choose at each turn whether to stay or move to p_x, whichever leads to a higher total score for k turns.

So, the implementation is flawed because it doesn't handle the choice properly.

I need to think about how to handle this choice optimally.

Given that, perhaps the optimal choice at each step is to stay if a_x >= a_{p_x}, otherwise move to p_x.

Because staying adds a_x, moving adds a_{p_x}.

So, choosing to stay or move depends on which a value is higher.

But, since the player can see the entire permutation and a array, they might consider future steps as well.

However, in practice, choosing to stay or move based on the current a_x and a_{p_x} might be sufficient, assuming that future choices will be made optimally as well.

But to be precise, we need to model this properly.

Perhaps, for each player, we can model their position over k turns, making optimal choices at each step.

But simulating this directly for large k is inefficient.

Given that, perhaps we can model the sequence of positions each player can be in over k turns, considering their choices to stay or move.

But this seems complicated.

An alternative approach is to consider that each player can choose to stay or move each turn, and we need to find the maximum possible score they can achieve.

This sounds like a dynamic programming problem, where for each turn, we decide whether to stay or move.

However, with k up to 1e9, dynamic programming with k states is not feasible.

We need a smarter way to handle this.

Let's consider that if a player is at position x, they can choose to stay at x and collect a_x, or move to p_x and collect a_{p_x}.

So, their score for the first turn is a_x, and for the second turn, if they stay, they collect another a_x, or if they move to p_x, they collect a_{p_x}, and so on.

This seems similar to choosing between two options at each step, but we need to maximize the total score over k steps.

Wait, perhaps we can model this as two sequences:

1. If the player stays forever, their score would be k * a_x.

2. If the player moves to p_x and stays there forever, their score would be a_x + (k-1) * a_{p_x}.

But this only considers two options: stay forever or move once and then stay.

However, the player can choose to stay or move at each step independently.

So, this might not capture all possibilities.

Wait, actually, the player can choose differently at each step, but to maximize the score, they might follow a certain pattern.

This seems complex.

Let me think differently.

Suppose we model the player's position over k steps, where at each step, they can choose to stay or move.

This can be represented as a sequence of positions, but it's too large for k=1e9.

An alternative approach is to recognize that the permutation p forms one or more cycles, and within each cycle, the player's movement repeats cyclically.

Given that, perhaps we can identify the cycle that the starting position is in, and then compute the optimal score over k steps within that cycle.

Wait, but the player can choose to stay or move at each step, so it's not just following the permutation cycle.

This is confusing.

Let me consider that the player can choose at each step whether to stay or move, so their position can be seen as a sequence where at each step, they either stay at the current position or move to p_x.

This seems like a graph where each position has two options: stay or move.

But modeling this as a graph with 2n nodes or something similar seems too involved.

Is there a better way?

Perhaps, for each player, we can compute the maximum possible score over k steps, given their choices to stay or move each turn.

Given that, perhaps we can observe that the optimal strategy is to choose at each step to stay if a_x >= a_{p_x}, otherwise move to p_x.

This greedy approach might work because choosing the higher a value at each step maximizes the immediate gain, and since the choices are independent across steps, the total score is maximized.

Let's test this idea with the first example.

In the first testcase:

n=4, k=2, PB=3, PS=2

p = [4,1,2,3]

a = [7,2,5,6]

For Bodya starting at 3:

a_3 = 5

p_3 = 2

So, at each step, Bodya can choose to stay and collect 5 or move to 2 and collect 2.

Optimal choice is to stay, as 5 > 2.

So, for k=2, total score is 5 + 5 =10.

For Sasha starting at 2:

a_2 =2

p_2 =1

So, at the first step, choose to move to 1 and collect 7, since 7 >2.

At the second step, current position is 1, choose to stay and collect 7, since 7 > a_{p_1}=a_4=6.

So, total score is 2 (first step, moving to 1) +7 (second step, staying at 1)=9.

Which matches the example.

So, the greedy approach seems to work here.

Therefore, perhaps the calculate_score function should be modified to choose at each step to stay if a_x >= a_{p_x}, else move to p_x.

This would make the simulation more accurate.

In the current implementation, it seems to always move to p_x, which is incorrect.

Wait, actually, in the calculate_score function, it seems to always move to p_x, but according to the problem, the player can choose to stay or move.

So, the current implementation is incorrect because it doesn't handle the choice properly.

I need to fix this.

Let me modify the calculate_score function to implement the greedy choice at each step: stay if a_x >= a_{p_x}, else move to p_x.

So, in code, it would be:

def calculate_score(start_pos, p, a):

    current_pos = start_pos

    score = 0

    for _ in range(k):

        # Choose to stay if a_x >= a_{p_x}, else move to p_x

        if a[current_pos - 1] >= a[p[current_pos - 1] - 1]:

            score += a[current_pos - 1]

        else:

            score += a[p[current_pos - 1] - 1]

            current_pos = p[current_pos - 1]

    return score

But wait, this isn't exactly correct.

Because when the player chooses to stay, they remain at the current position and collect a_x again next turn.

If they choose to move, they go to p_x and collect a_{p_x} next turn.

So, in terms of simulation, it's like:

for each turn:

    collect a[current_pos -1]

    then, choose to stay or move to p_x

if choosing to stay, remain at current_pos

else, move to p_x

But in the above code, it's adding a[current_pos -1] and then choosing to stay or move.

But according to the problem, first collect a_x, then choose to stay or move.

So, actually, the score should be accumulated based on the position at the start of each turn, before choosing to stay or move.

Hence, the correct simulation should be:

for each turn:

    score += a[current_pos -1]

    then, choose to stay or move

if stay, remain at current_pos

else, move to p_x

So, in code:

def calculate_score(start_pos, p, a, k):

    current_pos = start_pos

    score = 0

    for _ in range(k):

        score += a[current_pos -1]

        # Choose to stay if a_x >= a_{p_x}, else move to p_x

        if a[current_pos -1] >= a[p[current_pos -1] -1]:

            # stay

            pass

        else:

            # move

            current_pos = p[current_pos -1]

    return score

This seems correct.

Now, comparing this to the original calculate_score function, which doesn't handle the choice to stay or move.

Hence, the original implementation is incorrect.

I need to modify the calculate_score function accordingly.

But, with this modification, the function becomes:

def calculate_score(start_pos, p, a, k):

    current_pos = start_pos

    score = 0

    for _ in range(k):

        score += a[current_pos -1]

        if a[current_pos -1] >= a[p[current_pos -1] -1]:

            pass  # stay

        else:

            current_pos = p[current_pos -1]

    return score

This seems straightforward, but for large k (up to 1e9), this approach would be too slow because it simulates each turn individually.

Given that, I need a way to optimize this simulation.

Considering that the permutation p forms cycles, and the player's movement can be periodic within these cycles, I need to find a way to handle large k efficiently.

Let's consider that the player's position over time can be modeled based on the cycle they are in, considering their choices to stay or move.

However, it's not straightforward because the choice to stay or move depends on the current position's a value and the next position's a value.

But perhaps, for each starting position, I can determine the sequence of positions the player would be in over time, based on their choices, and then compute the total score accordingly.

One way to handle this is to recognize that if the player chooses to stay at a position where a_x >= a_{p_x}, they will stay forever, collecting a_x each turn.

If a_x < a_{p_x}, they will move to p_x and repeat the process.

Hence, the player's path can be seen as either staying at a position indefinitely or moving through the permutation until they reach a position where a_x >= a_{p_x}.

Therefore, for each player, I can find the position where they decide to stay permanently, and then compute the total score accordingly.

Let me formalize this:

1. Start at position x.

2. If a_x >= a_{p_x}, stay at x and collect a_x each turn forever.

3. Else, move to p_x and repeat the process.

This way, eventually, the player will reach a position where they decide to stay forever.

So, I can find the final position where the player decides to stay, and then the total score is (k * a_final_position).

But wait, this assumes that after moving through some steps, the player reaches a position where they stay forever.

However, it's possible that the player moves through a cycle before settling into a position where they stay.

Wait, no. According to the rule, once the player reaches a position where a_x >= a_{p_x}, they stay there forever.

So, the player's path is to move from their starting position to p_x until they reach a position where a_x >= a_{p_x}, and then stay there.

Hence, the path is a sequence of moves until they reach such a position, and then stay there for the remaining turns.

Given that, the total score can be calculated as:

- Sum of a_{x_i} for each move until they decide to stay.

- Plus (k - number_of_moves) * a_{final_position}

This seems efficient because it reduces the simulation to finding the final position where the player decides to stay, which can be done in O(n) time per player, but with n up to 2e5 and t up to 1e4, this would be too slow.

Hence, I need a better way to handle this.

Let me think about how to optimize this.

First, for each player, find the position where they decide to stay permanently.

This can be done by following the permutation until a position where a_x >= a_{p_x}.

Once they reach such a position, they stay there forever.

Hence, for each player, their path is a sequence of positions leading to the final position where they stay.

Given that, I can precompute for each starting position, the final position where the player decides to stay.

Then, for each player, calculate the number of moves required to reach the final position, and then the total score is:

- Sum of a_x for each move until reaching the final position.

- Plus (k - number_of_moves) * a_final_position

This way, I can compute the score efficiently.

But, with t up to 1e4 and n up to 2e5, I need to make sure that the per-testcase time is acceptable.

To optimize, I can precompute for each position, the final position where the player stays and the number of moves to reach it.

This can be done in O(n) time by processing the permutation in topological order, starting from positions where a_x >= a_{p_x}.

Wait, but permutations can have cycles, so topological order might not be directly applicable.

Wait, in a permutation, every position is part of some cycle.

Given that, I need to consider the cycles in the permutation.

But in this problem, since the player can choose to stay or move at each step, the movement isn't strictly following the permutation, but can be influenced by the a values.

Hence, perhaps I need to model this differently.

Let me try to formalize the process.

Define for each position x:

- If a_x >= a_{p_x}, then x is a "sink" position, where the player decides to stay forever.

- Else, the player moves to p_x.

Hence, for each position x, if a_x >= a_{p_x}, then final_position[x] = x and moves[x] = 0.

Else, final_position[x] = final_position[p_x], and moves[x] = moves[p_x] + 1.

This way, I can compute final_position and moves for all positions in O(n) time using memoization or iterative assignment.

Then, for each player, once I have final_position and moves, I can compute the score as:

- sum of a_x for the first moves[x] positions leading to the final position.

- plus (k - moves[x]) * a_{final_position[x]}

But I need to accumulate the sum of a_x for the path from the starting position to the final position.

To do this efficiently, I can precompute the path for each position to its final position.

But with n up to 2e5 and t up to 1e4, I need an O(n) precomputation.

Wait, perhaps I can compute for each position x:

- final_position[x]: the position where the player decides to stay forever.

- steps_to_final[x]: the number of steps to reach final_position[x].

- path_sum[x]: the sum of a_x for the path from x to final_position[x], excluding final_position[x].

Then, for each player, the total score would be path_sum[start_pos] + (k - steps_to_final[start_pos]) * a[final_position[start_pos]]

This way, I can precompute final_position, steps_to_final, and path_sum for all positions in O(n) time.

Then, for each test case, answering in O(1) time.

This seems efficient enough.

Now, let's see how to compute final_position, steps_to_final, and path_sum.

Initialize arrays final_position[1..n], steps_to_final[1..n], path_sum[1..n]

Initialize a queue or process positions iteratively.

For each position x from 1 to n:

- if a_x >= a_{p_x}:

- final_position[x] = x

- steps_to_final[x] = 0

- path_sum[x] = 0

- else:

- set final_position[x] = final_position[p_x]

- steps_to_final[x] = steps_to_final[p_x] + 1

- path_sum[x] = path_sum[p_x] + a[p_x -1]

Wait, but this assumes that p_x is already processed, which might not be the case.

Hence, to handle this correctly, I need to process positions in an order such that when processing x, p_x has already been processed.

Given that p is a permutation, which is a set of cycles, I can process positions in reverse topological order, starting from positions where a_x >= a_{p_x}.

But since permutations can have cycles, a topological order might not be directly applicable.

An alternative approach is to iterate through all positions, and for each position x where a_x >= a_{p_x}, set final_position[x] = x, steps_to_final[x] =0, path_sum[x]=0.

Then, for positions where a_x < a_{p_x}, set final_position[x] = final_position[p_x], steps_to_final[x] = steps_to_final[p_x] +1, path_sum[x] = path_sum[p_x] + a[p_x -1].

But this might not work if p_x hasn't been processed yet.

Hence, perhaps I need to process positions in an order that ensures p_x is processed before x.

To achieve this, I can process the positions in the reverse order of their topological sort in the graph where edges are from x to p_x.

But since p is a permutation, it's a collection of cycles with trees rooted at the cycle.

Hence, positions that are part of cycles or leading into cycles.

Wait, perhaps I can iterate over the positions multiple times until all final_position are determined.

But that might be inefficient.

An alternative approach is to use memoization or iterative assignment to compute final_position, steps_to_final, and path_sum.

But to make it efficient, perhaps I can use a while loop for each position to find its final_position.

But with n up to 2e5, this could be too slow if positions have long paths to their final_position.

Hence, I need a way to compute these values in O(n) time.

Let me consider that in the permutation, each position is part of exactly one cycle.

Starting from any position, following p_x, p_{p_x}, etc., will eventually return to the starting position because it's a permutation.

But in this problem, the player can choose to stay or move based on a_x and a_{p_x}.

Hence, the movement isn't strictly following the permutation, but can be influenced by the a values.

Given that, perhaps I can model the graph where each position has an outgoing edge to itself (stay) and to p_x (move).

But this seems too involved.

An alternative approach is to iterate through all positions and categorize them based on whether a_x >= a_{p_x} or not.

First, identify all positions where a_x >= a_{p_x}; these are the positions where players will stay forever if they reach them.

Then, for positions where a_x < a_{p_x}, their final_position is the same as p_x's final_position, and steps_to_final and path_sum can be computed accordingly.

This can be done using a recursive approach or iterative assignment.

To avoid recursion due to potential stack overflow, I'll use iterative assignment.

Here's how I can implement it:

- Initialize final_position[x] for all x where a_x >= a_{p_x} to x, and steps_to_final[x] =0, path_sum[x]=0.

- For x where a_x < a_{p_x}, set final_position[x] = final