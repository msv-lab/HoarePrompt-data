Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find an array of length n, where each element is between 1 and 10^9, and exactly k out of its n cyclic shifts are sorted. If no such array exists, I should output -1.

First, I need to understand what a cyclic shift is. From the description, the x-th cyclic shift of the array a is a_x, a_{x+1}, ..., a_n, a_1, a_2, ..., a_{x-1}. So, for example, if n=4, the cyclic shifts are:

- x=1: a1, a2, a3, a4

- x=2: a2, a3, a4, a1

- x=3: a3, a4, a1, a2

- x=4: a4, a1, a2, a3

I need exactly k of these shifts to be sorted in non-decreasing order.

Let's look at the examples provided:

1. For n=2, k=2:

   - Array: [1, 1]

   - Cyclic shifts:

     - [1, 1] (sorted)

     - [1, 1] (sorted)

   - Both shifts are sorted, so k=2.

2. For n=3, k=1:

   - Array: [69420, 69, 420]

   - Cyclic shifts:

     - [69420, 69, 420] (not sorted)

     - [69, 420, 69420] (sorted)

     - [420, 69420, 69] (not sorted)

   - Only one sorted shift, so k=1.

3. For n=3, k=2:

   - Output: -1

   - Meaning, no such array exists.

So, for different values of n and k, I need to find if there's an array that has exactly k sorted cyclic shifts.

First, think about the constraints:

- 1 ≤ k ≤ n ≤ 10^3

- Sum of n over all test cases ≤ 10^3

So, n can be up to 1000, and t (number of test cases) can be up to 1000, but since the sum of n over all test cases is ≤ 1000, it's manageable.

I need to find, for each test case, an array a of length n, where exactly k cyclic shifts are sorted.

Let me think about the properties of such an array.

Case 1: k = n

If k = n, that means all cyclic shifts are sorted. So, every shift must be non-decreasing.

What does that imply about the array?

If all cyclic shifts are sorted, the array must be constant, i.e., all elements are equal.

Because, if any two elements are different, rotating the array would eventually place a smaller element after a larger one, making that shift not sorted.

For example, if a = [1, 1], all shifts are [1,1] and [1,1], both sorted.

If a = [1, 2], shifts are [1,2] and [2,1], but [2,1] is not sorted.

Hence, for k = n, the array must have all elements equal.

Case 2: k = 1

For k = 1, only one cyclic shift is sorted.

Need to find an array where only one of its cyclic shifts is sorted.

Looking at the example: n=3, k=1, array = [69420, 69, 420]

Shifts:

- [69420, 69, 420] → not sorted

- [69, 420, 69420] → sorted

- [420, 69420, 69] → not sorted

Only one sorted shift.

Is there a general way to construct such an array?

Perhaps making the array strictly increasing, but that would make only one shift sorted, the original array itself.

Wait, no. If the array is strictly increasing, all shifts except the original one would not be sorted.

Wait, let's try:

Let’s say n=3, a = [1, 2, 3]

Shifts:

- [1,2,3] → sorted

- [2,3,1] → not sorted (3 > 1)

- [3,1,2] → not sorted (3 > 1)

So, only one sorted shift.

Similarly, n=4, a = [1,2,3,4]

Shifts:

- [1,2,3,4] → sorted

- [2,3,4,1] → not sorted (4 > 1)

- [3,4,1,2] → not sorted (4 > 1)

- [4,1,2,3] → not sorted (4 > 1)

Again, only one sorted shift.

So, for k=1, an array that is strictly increasing seems to work.

But wait, in the example, the array is [69420,69,420], which is not strictly increasing, but still only one shift is sorted.

So, perhaps there are multiple ways to achieve k=1.

But strictly increasing seems like the simplest way.

Case 3: k=0

Wait, k=0 is not possible because if k=0, no cyclic shift is sorted. But the array itself is always a cyclic shift, so if the array itself is not sorted, but that would contradict the requirement that exactly k shifts are sorted.

Wait, but k=0 is not allowed because k >=1 as per constraints (1 ≤ k ≤ n).

But just to think, if k=0, it would be impossible because the array itself is always a cyclic shift, and if it's not sorted, then at least one shift is not sorted, but if it is sorted, then at least one is sorted.

So, k=0 is impossible.

Case 4: k= n-1

What if k= n-1? That means, all but one cyclic shift are sorted.

Not sure how to construct such an array.

Maybe an array that is sorted, but with two elements swapped.

But likely, that would make only one shift sorted, which is the original sorted one.

Wait, in the example, for n=3, k=2, it's -1.

So, perhaps for n=3, k=2 is impossible.

Let me think why.

If n=3, and k=2, that means two out of three cyclic shifts are sorted.

Suppose the array is [a,b,c]

Shifts:

1. [a,b,c]

2. [b,c,a]

3. [c,a,b]

We need exactly two of these to be sorted.

Suppose [a,b,c] is sorted: a <= b <= c

[ b,c,a ] is sorted: b <= c <= a

[ c,a,b ] is sorted: c <= a <= b

For exactly two to be sorted:

- If [a,b,c] and [b,c,a] are sorted, then from [a,b,c]: a <= b <= c

  and from [b,c,a]: b <= c <= a

  Combining: a <= b <= c <= a, which implies a = b = c

  But then all three shifts are sorted, which is k=3, not k=2.

- If [a,b,c] and [c,a,b] are sorted, then:

  From [a,b,c]: a <= b <= c

  From [c,a,b]: c <= a <= b

  Combining: a <= b <= c <= a, again a = b = c

  Which leads to k=3.

- If [b,c,a] and [c,a,b] are sorted:

  From [b,c,a]: b <= c <= a

  From [c,a,b]: c <= a <= b

  Combining: b <= c <= a <= b, which implies b = c = a

  Again, a = b = c, leading to k=3.

Hence, for n=3, there is no array where exactly two cyclic shifts are sorted. That's why the output is -1 for n=3, k=2.

Generalizing this, for any n, if k != 1 or n, then it's impossible.

Wait, but in the example, for n=3, k=1 is possible.

So, perhaps only k=1 and k=n are possible for any n.

Let me check for n=4.

For n=4, k=2.

Is it possible?

Let's see.

Suppose n=4, k=2.

Need exactly two sorted cyclic shifts.

Let's assume the array is [a,b,c,d]

Shifts:

1. [a,b,c,d]

2. [b,c,d,a]

3. [c,d,a,b]

4. [d,a,b,c]

We need exactly two of these to be sorted.

Let's try to make [a,b,c,d] and [b,c,d,a] sorted.

So:

- a <= b <= c <= d

- b <= c <= d <= a

Combining:

a <= b <= c <= d <= a, which implies a = b = c = d

But then all four shifts are sorted, which is k=4, not k=2.

Similarly, if I try to make [a,b,c,d] and [c,d,a,b] sorted:

- a <= b <= c <= d

- c <= d <= a <= b

Combining:

a <= b <= c <= d <= a <= b, which implies a = b = c = d

Again, k=4.

Similarly, any pair of shifts seems to lead to all shifts being sorted.

Hence, for n=4, k=2 is impossible.

Similarly, for n=4, k=3:

Need exactly three sorted shifts.

Suppose [a,b,c,d], [b,c,d,a], [c,d,a,b], [d,a,b,c]

Suppose [a,b,c,d], [b,c,d,a], [c,d,a,b] are sorted, but [d,a,b,c] is not sorted.

So:

- a <= b <= c <= d

- b <= c <= d <= a

- c <= d <= a <= b

Combining:

From a <= b <= c <= d <= a, implies a = b = c = d

But then [d,a,b,c] is also sorted, so k=4, not k=3.

Hence, for n=4, k=3 is impossible.

Similarly, for any n, it seems that only k=1 and k=n are possible.

Because:

- For k=n, all elements must be equal.

- For k=1, the array can be strictly increasing.

- For any other k, trying to satisfy exactly k sorted shifts leads to either all shifts being sorted or not enough shifts being sorted.

Hence, the general solution seems to be:

- If k == n, output an array where all elements are equal.

- If k == 1, output a strictly increasing array.

- Else, output -1.

Looking back at the sample input:

3

2 2

3 1

3 2

Outputs:

1 1

69420 69 420

-1

Which matches this logic.

Hence, the program provided seems correct.

It does:

res = [1] * n if k == n else range(n) if k == 1 else [-1]

So, for k == n, it outputs [1,1,1,...,1]

For k == 1, it outputs [0,1,2,...,n-1]

For other k, it outputs [-1]

Which is correct, as per our reasoning.

Hence, the program is correct.

**Final Solution**

To solve this problem, we need to determine if there exists an array of length `n` such that exactly `k` of its cyclic shifts are sorted. If such an array exists, we output it; otherwise, we output `-1`.

### Approach

1. **Understanding Cyclic Shifts and Sorted Arrays**:
   - A cyclic shift of an array involves rotating its elements in a circular manner.
   - We need exactly `k` out of `n` possible cyclic shifts to be sorted in non-decreasing order.

2. **Key Observations**:
   - If `k` equals `n`, the array must be constant (all elements equal) because all cyclic shifts must be sorted.
   - If `k` equals `1`, a strictly increasing array satisfies the condition as only the original array is sorted, and all other shifts are not sorted.
   - For other values of `k`, it is impossible to have exactly `k` sorted cyclic shifts.

3. **Solution Logic**:
   - For `k == n`: Create an array where all elements are the same.
   - For `k == 1`: Create a strictly increasing array.
   - For all other `k`: Output `-1` since no such array exists.

### Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        (n, k) = (int(i) for i in input().split())
        if k == n:
            res = [1] * n
        elif k == 1:
            res = list(range(1, n + 1))  # Using 1-based indexing for clarity
        else:
            res = [-1]
        print(*res)

func()
```

### Explanation

- **For `k == n`**:
  - We create an array where all elements are `1`. This ensures that all cyclic shifts are sorted because all elements are equal.
  
- **For `k == 1`**:
  - We create a strictly increasing array from `1` to `n`. This ensures that only the original array is sorted, and all other cyclic shifts are not sorted because they will have at least one element that breaks the non-decreasing order.
  
- **For other `k`**:
  - We output `-1` because it is impossible to have exactly `k` sorted cyclic shifts for any other value of `k`.

This approach ensures that the solution is efficient and straightforward, adhering to the constraints provided.