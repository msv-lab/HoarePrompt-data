Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform an operation at most once. This operation allows me to select three integers i, j, and x, and then set all elements from index i to j to the value x. The cost of this operation is (j - i + 1) burles, which is essentially the number of elements being set to x.

My goal is to make all elements of the array equal, and I need to find the least amount of burles I need to spend to achieve this. It's guaranteed that I can always make all elements equal, so I don't have to worry about cases where it's impossible.

First, I need to understand what's the best strategy here. Since I can perform the operation only once, I need to choose the subarray to set in a way that minimizes the cost.

One straightforward approach is to set the entire array to a single value. That would cost n burles, where n is the length of the array. But maybe I can do better by taking advantage of the elements that are already equal.

Wait, let's think about it. If the array is already uniform, meaning all elements are the same, then I don't need to perform any operation, so the cost is 0.

If not, I need to make all elements equal to some value. I can choose to set a portion of the array to a certain value and see if that helps in minimizing the cost.

But considering I can only perform the operation once, it complicates things. I need to make sure that after setting a certain subarray to a specific value, the entire array becomes equal to that value.

Wait, no. Actually, I can set a subarray to a value x, and the rest of the array will remain as is, but my goal is to have all elements equal. So, I need to ensure that after setting the subarray, the entire array matches that value x.

That means, before performing the operation, I need to choose x such that setting a certain subarray to x will make the entire array equal to x.

Hmm, let's consider an example to understand this better.

Take the first example from the input:

6

1 2 3 4 5 1

I need to make all elements equal. Let's say I choose to set indices 2 to 4 to 1. Then the array becomes [1,1,1,1,5,1]. Now, I still have a 5 in position 5. So, I would need to perform another operation to set that to 1, but I can only perform one operation. So, this approach doesn't work.

Alternatively, if I set indices 2 to 5 to 1, the array becomes [1,1,1,1,1,1], which is all equal. The cost would be (5-2 +1) = 4 burles.

In this case, the output is 4, which matches the example.

Another example:

7

1 1 1 1 1 1 1

The array is already all 1s, so no operation is needed, and the cost is 0.

Another one:

8

8 8 8 1 2 8 8 8

I can set indices 4 to 6 to 8, making the array [8,8,8,8,8,8,8,8]. The cost would be (6-4 +1) = 3 burles. But according to the output, it's 2. So, maybe there's a better way.

Wait, if I set indices 4 to 5 to 8, the array becomes [8,8,8,8,8,8,8,8]. So, cost is (5-4 +1) = 2 burles, which matches the output.

Okay, so I need to find the minimal cost to make the entire array equal by setting at most one subarray to a certain value.

I need to find a strategy to minimize the cost.

Let me consider that I need to choose a value x, and a subarray to set to x, such that after setting, all elements are x.

This means that, for the elements outside the subarray, they must already be equal to x.

So, I need to choose x such that, outside the subarray, all elements are x.

Wait, no. Actually, after setting the subarray to x, the entire array should be x.

So, the elements outside the subarray must already be x.

Therefore, x must be equal to the value of the elements outside the subarray.

So, to minimize the cost, I should maximize the length of the subarray that needs to be set to x.

But x has to be equal to the value outside the subarray.

Wait, let's think differently.

Suppose I choose x to be the value that appears the most in the array. Then, I can set the subarray that contains elements not equal to x to x, so that the entire array becomes x.

But I can only perform the operation once.

Alternatively, I can choose x to be the value that appears at both ends of the array, and then set the middle section to x.

Wait, in the first example, the ends are both 1, so I can set the middle section to 1.

In the third example, the ends are both 8, so I can set the middle section to 8.

In the second example, all elements are 1, so no operation is needed.

In the fourth example, array size 1, already uniform.

In the fifth example, [1,2], I can set either element to the other's value, costing 1 burle.

In the sixth example, [1,2,3], I can set either the first two to 3, or the last two to 1, or the middle one to 1 or 3, etc. The minimal cost is 2 burles.

Okay, so perhaps the strategy is to make the entire array equal to the value at the ends, and find the minimal subarray to set so that all elements are equal to the end value.

Wait, but in some cases, it might be better to choose a different x.

Wait, no. Since I can only perform one operation, and I need to make the entire array equal, I need to set a subarray to a value x, and the rest must already be x.

So, x has to be the value that is already present outside the subarray.

Therefore, x should be the value that is consistent across the array, and I need to set the inconsistent part to x.

To minimize the cost, I need to maximize the length of the array that is already x, and set the remaining part to x.

So, the cost is the length of the array that is not x.

But I can only perform one operation, which is to set a contiguous subarray to x.

So, I need to choose x such that the non-x elements form a contiguous subarray.

Wait, that makes sense.

So, I need to choose x such that all non-x elements are in a single subarray.

Then, setting that subarray to x will make the entire array equal to x.

My goal is to minimize the length of that subarray, which minimizes the cost.

So, I need to choose x such that the non-x elements are all contiguous, and the length of that subarray is minimized.

In other words, find the smallest subarray such that, if set to x, the entire array becomes x.

To find this, I need to find, for each possible x, the minimal subarray that needs to be set so that the entire array is x.

Then, choose the x that minimizes this subarray length.

Wait, but iterating over all possible x might be inefficient.

Given that n can be up to 2e5 and t up to 1e4, with total n across all test cases up to 2e5, I need an efficient solution.

Let me think differently.

Suppose I fix x to be the first element of the array.

Then, I need to set the subarray from the first occurrence of a different element to the last occurrence of a different element to x.

The cost would be the length of that subarray.

Similarly, if I fix x to be the last element of the array, I can do the same.

Then, the minimal cost would be the minimum of these two approaches.

Wait, let's see.

In the first example, a = [1,2,3,4,5,1]

If x = a[0] = 1, then I need to set from index 1 to 4 to 1, which is subarray of length 4.

If x = a[5] = 1, same thing.

So, cost is 4.

In the third example, a = [8,8,8,1,2,8,8,8]

If x = a[0] = 8, then I need to set from index 3 to 5 to 8, which is subarray of length 3.

But in the sample output, it's 2.

Wait, in the sample output, it's 2, but according to this, it's 3.

Wait, no, in the sample explanation, setting indices 4 to 5 to 8 gives cost 2, which matches the output.

So, perhaps I need to set from the first index where a[i] != x to the last index where a[i] != x.

In this case, the first index where a[i] != 8 is i=3, and the last is i=5.

So, setting from 4 to 5 (0-indexed) to 8 gives cost 2.

Wait, but from i=3 to i=5 is length 3, but setting i=3 to i=5 to 8 gives [8,8,8,8,8,8,8,8], which is correct, and cost is 3, but the sample output is 2.

Wait, maybe I miscounted.

Wait, in the sample input, n=8, a=[8,8,8,1,2,8,8,8]

If I set i=3 to i=5 to 8, that's indices 3,4,5, which is length 3.

But in the sample output, it's 2.

Wait, maybe I can set i=4 to i=5 to 8, which is length 2.

Wait, a[4] = 2, a[5] = 8.

Set a[4] to 8, then the array becomes [8,8,8,1,8,8,8,8].

Still, a[3] = 1, which is not 8.

So, I need to set from i=3 to i=5 to 8, which is length 3.

But the sample output is 2.

Wait, maybe I'm misunderstanding something.

Wait, in the sample explanation, it's said that setting indices 4 to 6 to 8 gives cost 3, but in the output, it's 2.

Wait, no, in the sample input, n=8, a=[8,8,8,1,2,8,8,8]

If I set i=3 to i=5 to 8, the array becomes [8,8,8,8,8,8,8,8], which is correct, cost 3.

But the sample output is 2.

Wait, maybe there's a better way.

Wait, if I set i=4 to i=5 to 8, the array becomes [8,8,8,1,8,8,8,8].

Now, a[3] = 1, which is not 8.

So, I still have a mismatch.

Wait, unless I set i=3 to i=5 to 8, which is length 3.

I must have misread the sample output.

Wait, no, in the sample input, for this test case, the output is 2.

But according to my calculation, setting i=4 to i=5 to 8 costs 2, but then a[3] = 1 remains.

Wait, perhaps I need to choose x to be a value that appears at both ends.

Wait, in this case, a[0] = 8 and a[7] = 8.

So, choose x=8.

Then, find the subarray that needs to be set to 8 to make the entire array 8.

The subarray is from the first index where a[i] != 8 to the last index where a[i] != 8.

In this case, first a[i] != 8 is at i=3, last at i=5.

So, set from i=3 to i=5 to 8, which is length 3.

But sample output is 2.

Wait, maybe I need to optimize this.

Wait, perhaps if a[0] == a[-1], I can set the subarray between the first and last mismatch to a[0].

But in this case, setting i=4 to i=5 to 8 would make a[4]=8 and a[5]=8, but a[3]=1 remains.

Wait, no, that doesn't work.

Wait, maybe I need to set from the first mismatch to the last mismatch.

In this case, first mismatch is i=3, last is i=5.

So, set i=3 to i=5 to 8, which is length 3.

But sample output is 2, which suggests there's a better way.

Wait, perhaps if there are multiple segments that are not equal to x, I can choose to set only one segment.

But I can only perform one operation.

Wait, in this case, if I set i=4 to i=5 to 8, which is length 2, but a[3] is still 1.

So, that doesn't make the entire array 8.

Hence, I need to set from i=3 to i=5 to 8, which is length 3.

Wait, maybe there's a different x to choose.

Wait, in this array, a=[8,8,8,1,2,8,8,8], if I choose x=1, but that wouldn't make sense because many elements are not 1.

Wait, no, choosing x=1 would require setting from i=0 to i=2 to 1, and i=5 to i=7 to 1, which would cost more.

Wait, no, I can only perform one operation.

So, choosing x=8 seems the best.

But then, setting i=3 to i=5 to 8 should be the minimal subarray to set to make the entire array 8.

But sample output is 2, which contradicts my reasoning.

Wait, maybe I'm missing something.

Wait, perhaps if a[0] == a[-1], I can set the middle subarray to a[0], and the cost is the length of that subarray.

But in this case, setting i=3 to i=5 to 8 gives cost 3, but sample output is 2.

Wait, perhaps the minimal subarray is from i=4 to i=5, which is length 2.

Wait, but a[4]=2, a[5]=8.

Set them to 8, then a[3]=1 remains.

Wait, no, a[3]=1 is still there.

Wait, unless a[3] is also set to 8 in this operation, but I can only set one subarray.

Wait, perhaps I need to set i=3 to i=5 to 8, which is length 3.

But sample output is 2, which suggests there's a way to set a subarray of length 2 to make the entire array equal.

Wait, maybe setting i=5 to i=6 to 8.

Wait, a[5]=8, a[6]=8, so setting them to 8 doesn't change anything.

Wait, no, setting them to 8 is unnecessary.

Wait, perhaps setting i=4 to i=5 to 8.

Set a[4]=8 and a[5]=8.

Then, the array becomes [8,8,8,1,8,8,8,8].

Now, a[3]=1 is still there.

So, this doesn't make the entire array equal to 8.

Hence, I need to set from i=3 to i=5 to 8, which is length 3.

But sample output is 2.

Wait, maybe I'm misunderstanding the indices.

Wait, perhaps the indices are 1-based or 0-based differently.

Wait, in the problem, it's mentioned that 1 ≤ i ≤ j ≤ n, so indices are 1-based.

But in my reasoning, I've been using 0-based indices.

Let me correct that.

So, in the third example, n=8, a=[8,8,8,1,2,8,8,8]

If I set i=4 to j=5 to 8, which is a[4]=2 and a[5]=8, setting them to 8, the array becomes [8,8,8,1,8,8,8,8].

Still, a[3]=1 is not 8.

So, I need to set i=3 to j=5 to 8, which is a[3]=1, a[4]=2, a[5]=8, setting them to 8, the array becomes [8,8,8,8,8,8,8,8].

Cost is (5-3 +1)=3 burles.

But sample output is 2.

Wait, perhaps there's a different approach.

Wait, maybe choosing x to be a value that appears in the array multiple times.

Wait, in this array, 8 appears 6 times, 1 appears once, 2 appears once.

Choosing x=8 seems optimal.

But to achieve the sample output of 2, perhaps there's a different way.

Wait, maybe setting i=5 to j=6 to 8, which is a[5]=8 and a[6]=8, setting them to 8 doesn't change anything.

Wait, no.

Wait, perhaps setting i=4 to j=5 to 8, which is a[4]=2 and a[5]=8 to 8, making the array [8,8,8,1,8,8,8,8].

Still, a[3]=1 is not 8.

Wait, unless I set i=3 to j=5 to 8, which is a[3]=1, a[4]=2, a[5]=8 to 8, making the array [8,8,8,8,8,8,8,8], which costs 3.

But sample output is 2.

Wait, maybe I'm missing something.

Wait, perhaps if a[0] == a[-1], I can calculate the number of elements that are not equal to a[0] and are contiguous in the middle.

In this case, a[3]=1 and a[4]=2 are not 8, while a[5]=8.

So, the subarray that needs to be set is from i=3 to i=4, which is length 2.

Wait, but a[5]=8 is already 8, so I don't need to set it.

So, setting i=3 to i=4 to 8 would make the array [8,8,8,8,8,8,8,8], which costs 2.

Yes, that makes sense.

So, the minimal subarray to set is from i=3 to i=4, which is length 2.

I must have missed that a[5] is already 8.

So, setting i=3 to i=4 to 8 covers a[3]=1 and a[4]=2, making the array [8,8,8,8,8,8,8,8].

Cost is 2, which matches the sample output.

I see, so I need to find the subarray from the first index where a[i] != x to the last index where a[i] != x, but considering that some elements in between might already be x.

Wait, in this case, a[5]=8, which is x, so I don't need to include it in the subarray to set.

So, I need to set from the first a[i] != x to the last a[i] != x, skipping those that are already x.

Wait, more precisely, find the minimal subarray that covers all a[i] != x.

In this case, a[3]=1 and a[4]=2 are not x=8, and a[5]=8 is already x, so I only need to set i=3 and i=4 to 8.

Hence, cost is 2.

So, to generalize, for x = a[0], find the first index where a[i] != x and the last index where a[i] != x.

Then, set the subarray from first to last to x.

The cost is (last - first + 1).

But in this case, I need to exclude those indices where a[i] == x within the subarray.

Wait, no. I need to set the subarray to x, so even if some a[i] == x within the subarray, setting them to x doesn't change them.

But the cost is still (last - first + 1).

In the above example, first != x is i=3, last != x is i=4.

Setting i=3 to i=4 to x=8 makes the array [8,8,8,8,8,8,8,8], which is correct, cost is 2.

Similarly, in the first example, a=[1,2,3,4,5,1], x=1.

First != x is i=1, last != x is i=4.

Setting i=1 to i=4 to 1 makes the array [1,1,1,1,5,1].

Wait, but a[4]=5 !=1, so I need to set i=1 to i=5 to 1, which is length 5.

But sample output is 4.

Wait, no, in the first example, sample output is 4.

Wait, perhaps I need to set i=1 to i=4 to 1, making [1,1,1,1,5,1], then a[4]=5 is still not 1.

So, I need to set i=1 to i=5 to 1, which is length 5.

But sample output is 4.

Wait, maybe I need to set i=2 to i=5 to 1, which is length 4.

a=[1,1,1,1,1,1], which makes the entire array equal to 1.

So, cost is 4.

Hence, the minimal subarray to set is from i=2 to i=5, which is length 4.

So, in this case, choosing x=a[0]=1, first != x is i=1, last != x is i=4.

Setting from i=1 to i=4 to x=1 makes [1,1,1,1,5,1], which still has a[4]=5.

So, need to set from i=1 to i=5 to x=1, which is length 5.

But in the sample, setting i=2 to i=5 to x=1 gives [1,1,1,1,1,1], which is correct, cost is 4.

So, why is this better?

Wait, perhaps there's a way to choose x to be a[-1]=1, and find the minimal subarray to set to x=1 to make the entire array equal to x=1.

In this case, first != x is i=1, last != x is i=4.

Setting from i=1 to i=4 to x=1 makes [1,1,1,1,5,1], which still has a[4]=5.

So, need to set from i=1 to i=5 to x=1, which is length 5.

But in the sample, setting i=2 to i=5 to x=1 makes [1,1,1,1,1,1], which is correct, cost is 4.

Wait, why is this better?

Wait, because a[1]=2 !=1, a[2]=3 !=1, a[3]=4 !=1, a[4]=5 !=1.

So, from i=1 to i=5, but a[5]=1 == x=1.

So, setting from i=1 to i=4 to x=1 would make [1,1,1,1,5,1], which still has a[4]=5 and a[5]=1.

Wait, but a[4]=5 !=1, so I need to set i=1 to i=5 to x=1.

Wait, but in the sample, setting i=2 to i=5 to x=1 makes [1,1,1,1,1,1], which is correct, cost is 4.

Wait, perhaps choosing x=a[-1]=1, first != x is i=1, last != x is i=4.

Set from i=2 to i=5 to x=1, making [1,1,1,1,1,1].

Wait, why does this work?

Wait, a[1]=2 !=1, a[2]=3 !=1, a[3]=4 !=1, a[4]=5 !=1, a[5]=1 ==1.

So, setting i=2 to i=5 to x=1 changes a[2], a[3], a[4], a[5] to 1, resulting in [1,1,1,1,1,1].

Hence, cost is 4.

Similarly, in the third example, a=[8,8,8,1,2,8,8,8], x=8.

First != x is i=3, last != x is i=4.

Setting i=3 to i=4 to x=8 makes [8,8,8,8,8,8,8,8], cost is 2.

This matches the sample output.

So, the strategy is:

- Choose x to be a[0] or a[-1].

- Find the first index where a[i] != x and the last index where a[i] != x.

- Set the subarray from first != x to last != x to x.

- The cost is (last - first +1).

- Choose the option (x=a[0] or x=a[-1]) that minimizes the cost.

- Additionally, if a[0] == a[-1], then choose x=a[0]=a[-1], and find the minimal subarray to set.

- If a[0] != a[-1], then choose x to be either a[0] or a[-1], and find the corresponding subarrays to set, and choose the one with the smaller cost.

Wait, but in the first example, a[0]=1, a[-1]=1, so x=1.

First !=1 is i=1, last !=1 is i=4.

Setting i=1 to i=4 to 1, cost=4.

But if I set i=1 to i=5 to 1, cost=5.

Wait, no, in the sample, setting i=2 to i=5 to 1, cost=4, which is better.

Wait, perhaps I need to find the minimal subarray that covers all a[i] != x.

In the first example, a=[1,2,3,4,5,1], x=1.

a[1]=2 !=1, a[2]=3 !=1, a[3]=4 !=1, a[4]=5 !=1, a[5]=1 ==1.

So, a[1], a[2], a[3], a[4] !=1.

Hence, set i=1 to i=4 to 1, cost=4.

Alternatively, set i=1 to i=5 to 1, cost=5.

So, minimal is 4.

In the third example, a=[8,8,8,1,2,8,8,8], x=8.

a[3]=1 !=8, a[4]=2 !=8, a[5]=8==8.

So, set i=3 to i=4 to 8, cost=2.

This is better than setting i=3 to i=5 to 8, cost=3.

Hence, the minimal subarray to set is from the first != x to the last != x.

In code, for x=a[0], find the first i where a[i] != x and the last i where a[i] != x.

Then, cost = last - first +1.

Similarly, for x=a[-1], find the first i where a[i] != x and the last i where a[i] != x.

Then, cost = last - first +1.

Choose the minimum of these two costs.

If a[0] == a[-1], then only one x to consider.

Otherwise, choose the minimum of the two.

Edge cases:

- All elements are equal: cost=0.

- Array size 1: cost=0.

- Array size 2, different elements: set one element to the other's value, cost=1.

- Array with elements that can be made equal by setting a minimal subarray.

Implementing this:

- For x=a[0]:

Find the first i where a[i] != a[0].

Find the last i where a[i] != a[0].

If such i exist, cost = last - first +1.

Else, cost=0.

- Similarly for x=a[-1]:

Find the first i where a[i] != a[-1].

Find the last i where a[i] != a[-1].

If such i exist, cost = last - first +1.

Else, cost=0.

- Choose the minimum of these two costs.

- If a[0] == a[-1], then only one x to consider, choose that cost.

- If a[0] != a[-1], choose the minimum of the two costs.

Let's verify this with the sample inputs.

First test case:

n=6, a=[1,2,3,4,5,1]

x=1.

First !=1 is i=1, last !=1 is i=4.

cost = 4 -1 +1 =4.

x=1.

So, cost=4.

Output:4.

Second test case:

n=7, a=[1,1,1,1,1,1,1]

x=1.

No i where a[i] !=1.

cost=0.

Output:0.

Third test case:

n=8, a=[8,8,8,1,2,8,8,8]

x=8.

First !=8 is i=3, last !=8 is i=4.

cost=4-3 +1=2.

Output:2.

Fourth test case:

n=1, a=[1]

Already uniform, cost=0.

Output:0.

Fifth test case:

n=2, a=[1,2]

x=1:

First !=1 is i=1, last !=1 is i=1.

cost=1-1 +1=1.

x=2:

First !=2 is i=0, last !=2 is i=0.

cost=0-0 +1=1.

Choose minimum:1.

Output:1.

Sixth test case:

n=3, a=[1,2,3]

x=1:

First !=1 is i=1, last !=1 is i=2.

cost=2-1 +1=2.

x=3:

First !=3 is i=0, last !=3 is i=1.

cost=1-0 +1=2.

Choose minimum:2.

Output:2.

Seventh test case:

n=7, a=[4,3,2,7,1,1,3]

x=4:

First !=4 is i=1, last !=4 is i=6.

cost=6-1 +1=7.

x=3:

First !=3 is i=0, last !=3 is i=4.

cost=4-0 +1=5.

Choose minimum:5.

Wait, but sample output is 6.

Wait, perhaps I need to choose x to be a[0] or a[-1], but in this case, a[0]=4, a[-1]=3.

Choosing x=4:

first !=4 is i=1, last !=4 is i=6.

cost=6-1 +1=7.

Choosing x=3:

first !=3 is i=0, last !=3 is i=4.

cost=4-0 +1=5.

Choose minimum:5.

But sample output is 6.

Wait, perhaps I'm missing something.

Wait, sample output is 6, but according to this, it should be 5.

Wait, perhaps I need to add 1 because indices are 1-based.

Wait, no, indices are 0-based in my reasoning.

Wait, perhaps I need to consider that setting a subarray to x includes both endpoints.

Wait, no, in my calculation, it's inclusive of both endpoints.

Wait, maybe I need to choose x to be a value that appears in the array.

Wait, but according to the problem, I can choose any x, but it's probably optimal to choose x to be a value that's already in the array.

But in this case, choosing x=1 might be better.

x=1:

first !=1 is i=0, last !=1 is i=3.

cost=3-0 +1=4.

x=3:

first !=3 is i=0, last !=3 is i=4.

cost=4-0 +1=5.

x=4:

first !=4 is i=1, last !=4 is i=6.

cost=6-1 +1=7.

Choose minimum:4.

But sample output is 6.

Wait, maybe I need to set the subarray to x=1, but then a[4]=1 is already 1, so setting i=0 to i=3 to 1 makes [1,1,1,1,1,1,3], then I need to set i=6 to 1, but I can only perform one operation.

Wait, no, I can only set one subarray.

So, setting i=0 to i=3 to 1 makes [1,1,1,1,1,1,3].

Then, a[6]=3 !=1, so I need to set i=0 to i=6 to 1, which is cost 7.

But sample output is 6.

Wait, maybe setting i=1 to i=6 to 1 makes [4,1,1,1,1,1,1], cost=6.

This is better than setting i=0 to i=6 to 1, which is cost 7.

So, choosing x=1, set i=1 to i=6 to 1, cost=6.

Similarly, choosing x=3, set i=0 to i=4 to 3, cost=5.

But sample output is 6, so perhaps choosing x=1 is better in this case.

Wait, but choosing x=1 and setting i=1 to i=6 to 1 gives cost 6.

Choosing x=3 and setting i=0 to i=4 to 3 gives cost 5.

But sample output is 6.

Wait, perhaps I need to choose x to be a[0] or a[-1], and among those, choose the minimal cost.

In this case, x=a[0]=4, which gives cost=7.

x=a[-1]=3, which gives cost=5.

But sample output is 6.

Wait, maybe the rule is to choose x to be a[0] or a[-1], and take the minimum cost among them, but in this case, choosing x=3 gives cost=5, which is less than choosing x=4 giving cost=7.

But sample output is 6.

Wait, perhaps I need to add 1 to the cost when a[0] != a[-1].

Wait, no, that doesn't make sense.

Wait, maybe the cost is (last - first +1), but in this case, for x=3, first !=3 is i=0, last !=3 is i=4.

Setting i=0 to i=4 to 3 makes [3,3,3,3,3,1,3].

Still, a[5]=1 !=3, so I need to set i=0 to i=5 to 3, which is cost=6.

Wait, no, setting i=0 to i=4 to 3 makes [3,3,3,3,3,1,3].

Then, a[5]=1 !=3, so I need to set i=5 to 3, but I can only perform one operation.

Wait, with one operation, I can set i=0 to i=5 to 3, which is cost=6.

This makes [3,3,3,3,3,3,3], which is correct.

Hence, the minimal cost is 6.

Similarly, setting i=1 to i=6 to 1 makes [4,1,1,1,1,1,1], which still has a[0]=4 !=1, so I need to set i=0 to i=6 to 1, which is cost=7.

Wait, no, setting i=1 to i=6 to 1 makes [4,1,1,1,1,1,1], which has a[0]=4 !=1.

So, to make the entire array 1, I need to set i=0 to i=6 to 1, which is cost=7.

But earlier, setting i=0 to i=5 to 3 makes [3,3,3,3,3,3,3], which is cost=6.

Hence, choosing x=3 and setting i=0 to i=6 to 3, cost=7.

Wait, no, setting i=0 to i=4 to 3 makes [3,3,3,3,3,1,3], then I need to set i=5 to 3, but I can only perform one operation.

Hence, I need to set i=0 to i=5 to 3, which is cost=6, making [3,3,3,3,3,3,3].

Hence, cost=6.

Similarly, setting i=1 to i=6 to 1 makes [4,1,1,1,1,1,1], which still has a[0]=4 !=1.

So, to make the entire array 1, I need to set i=0 to i=6 to 1, which is cost=7.

Hence, the minimal cost is 6.

Therefore, in cases where a[0] != a[-1], I need to choose x to be a[0] or a[-1], and choose the one with the minimal cost.

In this case, choosing x=a[-1]=3 gives cost=6, while choosing x=a[0]=4 gives cost=7.

Hence, minimal cost is 6.

So, the general approach is:

- If a[0] == a[-1], choose x=a[0].

- Find the first i where a[i] != x and the last i where a[i] != x.

- Cost = last - first +1.

- If no such i exists, cost=0.

- If a[0] != a[-1], choose x=a[0] or x=a[-1], and compute the costs accordingly, then take the minimum of the two.

- Additionally, consider the case where setting the entire array to x=a[0] or x=a[-1] requires setting from the first != x to the last != x.

- Make sure that after setting that subarray to x, the entire array is x.

- Choose the x that minimizes this cost.

Hence, in code, for each test case:

- Read n and a.

- If n ==1, cost=0.

- Else:

- If a[0] == a[-1]:

- x = a[0]

- Find first i where a[i] != x.

- Find last i where a[i] != x.

- If such i exist, cost = last - first +1.

- Else, cost=0.

- Else:

- For x=a[0]:

- Find first i where a[i] != x.

- Find last i where a[i] != x.

- If such i exist, cost1 = last - first +1.

- Else, cost1=n.

- For x=a[-1]:

- Find first i where a[i] != x.

- Find last i where a[i] != x.

- If such i exist, cost2 = last - first +1.

- Else, cost2=n.

- Take cost = min(cost1, cost2).

- Print cost.

Wait, in the fifth test case, n=2, a=[1,2]

- a[0]=1, a[-1]=2 != a[0]

- For x=1:

- first !=1 is i=1, last !=1 is i=1.

- cost1=1-1 +1=1.

- For x=2:

- first !=2 is i=0, last !=2 is i=0.

- cost2=0-0 +1=1.

- cost = min(1,1)=1.

- Output:1.

Sixth test case:

n=3, a=[1,2,3]

- a[0]=1, a[-1]=3 != a[0]

- For x=1:

- first !=1 is i=1, last !=1 is i=2.

- cost1=2-1 +1=2.

- For x=3:

- first !=3 is i=0, last !=3 is i=1.

- cost2=1-0 +1=2.

- cost = min(2,2)=2.

- Output:2.

Seventh test case:

n=7, a=[4,3,2,7,1,1,3]

- a[0]=4, a[-1]=3 != a[0]

- For x=4:

- first !=4 is i=1, last !=4 is i=6.

- cost1=6-1 +1=7.

- For x=3:

- first !=3 is i=0, last !=3 is i=4.

- cost2=4-0 +1=5.

- cost = min(7,5)=5.

But sample output is 6.

Wait, perhaps I need to set the subarray to cover all elements not equal to x.

In the seventh test case, choosing x=3:

Set i=0 to i=4 to 3, making [3,3,3,3,3,1,3].

Then, a[5]=1 !=3, so I need to set i=5 to 3, but I can only perform one operation.

Hence, I need to set i=0 to i=5 to 3, which is cost=6, making [3,3,3,3,3,3,3].

Hence, cost=6.

Similarly, choosing x=4:

Set i=1 to i=6 to 4, making [4,4,4,4,4,4,3].

Then, a[6]=3 !=4, so need to set i=6 to 4, but I can only perform one operation.

Hence, set i=1 to i=6 to 4, cost=6.

But earlier, choosing x=3 gives cost=6, choosing x=4 also gives cost=6.

But according to the earlier calculation, choosing x=3 gives cost=5, but that's incorrect because setting i=0 to i=4 to 3 and leaving a[5]=1 requires an additional operation, which I can't perform.

Hence, I need to set i=0 to i=5 to 3, which is cost=6.

Similarly, setting i=1 to i=6 to 4, cost=6.

Hence, minimal cost is 6.

So, in code, for x=a[0] and x=a[-1], find the subarrays to set, and choose the minimal cost among them.

Hence, the approach seems correct.

Eighth test case:

n=9, a=[9,9,2,9,2,5,5,5,3]

- a[0]=9, a[-1]=3 != a[0]

- For x=9:

- first !=9 is i=2, last !=9 is i=8.

- cost1=8-2 +1=7.

- For x=3:

- first !=3 is i=0, last !=3 is i=7.

- cost2=7-0 +1=8.

- cost = min(7,8)=7.

- Output:7.

Hence, the approach