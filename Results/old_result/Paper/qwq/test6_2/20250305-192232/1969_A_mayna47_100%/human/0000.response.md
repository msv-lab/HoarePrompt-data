Alright, I've got this problem to solve. Let's see what it's asking for. Monocarp wants to throw a party and invite some of his friends, but there are some conditions. He has n friends, and each friend has a best friend, denoted by p_i. The key points are:

1. All p_i are distinct and p_i ≠ i, meaning everyone has a unique best friend who isn't themselves.

2. A friend comes to the party only if both they and their best friend receive an invitation.

3. Monocarp wants at least 2 friends to come to the party.

4. He needs to send the minimum number of invitations to achieve this.

First, I need to understand the relationship between the friends and their best friends. Since p_i are distinct and p_i ≠ i, it means that the best friend relationships form a permutation of the friends. In other words, it's like matching friends in pairs, but since n can be up to 50, and t up to 5000, I need an efficient way to handle this.

Let me think about how the best friend relationships work. If friend A's best friend is B, then B's best friend is A, because p_i are distinct and p_i ≠ i. So, the relationships form pairs.

Wait, but the problem says that p_i are distinct, which means that if A's best friend is B, then B's best friend is A, and no two friends can have the same best friend. So, the friendships are in unique pairs.

Wait, but in the example given:

p = [3, 1, 2, 5, 4]

So, friend 1's best friend is 3, friend 2's best friend is 1, friend 3's best friend is 2, friend 4's best friend is 5, and friend 5's best friend is 4.

Wait, but in this case, friend 1's best friend is 3, but friend 3's best friend is 2, not 1. So, it's not necessarily that if A's best friend is B, then B's best friend is A. Wait, but the problem says that all p_i are distinct and p_i ≠ i. So, it's possible to have chains or cycles in the best friend relationships.

Wait, let's check:

Given p = [3,1,2,5,4]

So,

Friend 1 -> 3

Friend 2 -> 1

Friend 3 -> 2

Friend 4 -> 5

Friend 5 -> 4

So, this forms two cycles: 1 -> 3 -> 2 -> 1 and 4 -> 5 -> 4.

So, cycles of best friends.

In the problem, a friend comes to the party if both they and their best friend receive an invitation.

So, for friend i to come, both i and p_i must receive invitations.

But, invitations are sent individually to friends.

Now, Monocarp wants at least 2 friends to come to the party, and he wants to send the minimum number of invitations to achieve that.

So, I need to find the minimal number of invitations to send such that at least 2 friends come to the party.

Let me think about how to model this.

First, I need to understand the structure of the best friend relationships. Since p_i are distinct and p_i ≠ i, it means that the best friend relationships form a permutation, which can be decomposed into disjoint cycles.

In the example:

p = [3,1,2,5,4]

The cycles are:

1 -> 3 -> 2 -> 1

4 -> 5 -> 4

So, two cycles: one of length 3 and one of length 2.

Now, in terms of sending invitations, if I send invitations to friends in a cycle, I need to ensure that for any friend to come, both they and their best friend have invitations.

Wait, but the friends coming are based on whether they and their best friend received invitations, not necessarily both being invited together.

Wait, but each invitation is sent to exactly one friend.

So, if I send an invitation to friend A, it doesn't automatically invite friend B, unless B is A's best friend and also received an invitation.

Wait, no. Invitations are sent individually.

Wait, but the condition for a friend to come is that both they and their best friend received invitations.

So, for friend A to come, both A and p_A must have received invitations.

But p_A is friend A's best friend.

So, in terms of cycles, if I have a cycle of length k, how many invitations do I need to send to get at least some friends from that cycle to come?

Let's consider the cycle: 1 -> 3 -> 2 -> 1

If I send invitations to 1 and 3, then:

- Friend 1 has invitation, and their best friend is 3, who also has invitation, so friend 1 comes.

- Friend 3 has invitation, and their best friend is 2, who doesn't have invitation, so friend 3 doesn't come.

- Friend 2 doesn't have invitation, so doesn't come.

So, only friend 1 comes, which is not enough.

If I send invitations to 1, 3, and 2:

- Friend 1 has invitation, best friend 3 has invitation, so friend 1 comes.

- Friend 3 has invitation, best friend 2 has invitation, so friend 3 comes.

- Friend 2 has invitation, best friend is 1, who has invitation, so friend 2 comes.

So, all three come, which is more than enough, but I sent 3 invitations.

Is there a way to get at least 2 friends to come with fewer invitations?

Let's see.

If I send invitations to 1 and 2:

- Friend 1 has invitation, best friend 3 doesn't have invitation, so doesn't come.

- Friend 2 has invitation, best friend is 1, who has invitation, so friend 2 comes.

- Friend 3 doesn't have invitation.

So, only friend 2 comes, which is not enough.

If I send invitations to 1, 2, and 3:

- As before, all three come.

Seems like 3 invitations are needed in this case.

Now, in the second test case:

n = 4

p = [2,3,4,1]

So, cycles are:

1 -> 2 -> 3 -> 4 -> 1 (a single cycle of length 4)

To get at least 2 friends to come, how many invitations do I need to send?

If I send invitations to 1 and 2:

- Friend 1 has invitation, best friend 2 has invitation, so friend 1 comes.

- Friend 2 has invitation, best friend 3 has invitation, so friend 2 comes.

- Friend 3 has invitation, best friend 4 has invitation, so friend 3 comes.

- Friend 4 has invitation, best friend 1 has invitation, so friend 4 comes.

So, all four come, which is more than enough, with 4 invitations.

But the sample output says 3, so there must be a better way.

Wait, maybe sending invitations to 1, 2, and 3:

- Friend 1 has invitation, best friend 2 has invitation, so friend 1 comes.

- Friend 2 has invitation, best friend 3 has invitation, so friend 2 comes.

- Friend 3 has invitation, best friend 4 has invitation, so friend 3 comes.

- Friend 4 has invitation, best friend 1 has invitation, so friend 4 comes.

So, all four come, but I sent 3 invitations.

Wait, no, if I send invitations to 1, 2, and 3, then friend 4 doesn't have invitation, so friend 4 doesn't come.

Wait, no, if I send invitations to 1, 2, and 3:

- Friend 1 has invitation, best friend 2 has invitation, so friend 1 comes.

- Friend 2 has invitation, best friend 3 has invitation, so friend 2 comes.

- Friend 3 has invitation, best friend 4 doesn't have invitation, so friend 3 doesn't come.

- Friend 4 doesn't have invitation, so doesn't come.

So, only friends 1 and 2 come, which is exactly 2, which is acceptable.

So, with 3 invitations, I can get at least 2 friends to come.

Is it possible to do it with 2 invitations?

Let's try:

Send invitations to 1 and 2:

- Friend 1 has invitation, best friend 2 has invitation, so friend 1 comes.

- Friend 2 has invitation, best friend 3 has invitation? Wait, invitation is only sent to 1 and 2, so friend 3 doesn't have invitation, so friend 2 doesn't come.

- Friend 3 doesn't have invitation.

- Friend 4 doesn't have invitation.

So, only friend 1 comes, which is not enough.

Another try: send invitations to 1 and 3:

- Friend 1 has invitation, best friend 2 has invitation? No, so doesn't come.

- Friend 2 doesn't have invitation.

- Friend 3 has invitation, best friend 4 has invitation? No, so doesn't come.

- Friend 4 doesn't have invitation.

So, no one comes.

Another try: send invitations to 1, 3, and 4:

- Friend 1 has invitation, best friend 2 has invitation? No, so doesn't come.

- Friend 2 doesn't have invitation.

- Friend 3 has invitation, best friend 4 has invitation, so friend 3 comes.

- Friend 4 has invitation, best friend 1 has invitation, so friend 4 comes.

So, friends 3 and 4 come, which is at least 2.

So, again, 3 invitations are needed.

Wait, but in the sample input, for n=4, p=[2,3,4,1], the output is 3, which matches this.

Now, for n=2, p=[2,1], output is 2.

Let's see:

If I send invitations to 1 and 2:

- Friend 1 has invitation, best friend 2 has invitation, so friend 1 comes.

- Friend 2 has invitation, best friend 1 has invitation, so friend 2 comes.

So, both come, which is at least 2, with 2 invitations.

Is it possible to do it with fewer invitations? No, because I need to send at least 2 invitations to have at least 2 friends come.

So, in this case, 2 invitations are sufficient.

From these examples, it seems that the minimal number of invitations needed is either 2 or 3, depending on the structure of the best friend relationships.

I need to find a general way to determine this for any given n and p.

Let me think about the cycles in the best friend relationships.

If there is a cycle of length k, to get at least one friend from that cycle to come, I need to send invitations to at least two consecutive friends in the cycle.

Wait, no. To get one friend to come, I need to send invitations to that friend and their best friend.

But in terms of cycles, it's a bit tricky.

Wait, perhaps I should think in terms of selecting edges in the cycle graph.

Each friend coming corresponds to an edge where both endpoints have invitations.

So, in a cycle, to have at least one edge where both endpoints have invitations, I need to select a set of vertices such that at least one edge has both endpoints selected.

In graph terms, this is like selecting a subset of vertices in the cycle such that at least one edge is "covered" by both endpoints being selected.

I need to minimize the number of selected vertices while ensuring that at least one edge is fully covered.

In a cycle of length k, what is the minimal number of vertices to select to have at least one edge where both endpoints are selected?

Wait, but in this problem, it's not just about having at least one such edge; it's about having at least two friends who come, each requiring their own edge to be fully covered.

Wait, no, the problem says "at least two friends come", and each friend comes only if they and their best friend have invitations.

So, I need to have at least two different friends who each have their best friend also invited.

Now, in terms of the cycle, if I select a set of vertices such that at least two different edges have both endpoints selected, then at least two friends will come.

But I need to minimize the number of invitations, i.e., the number of vertices selected.

Let me consider different cycle lengths.

First, for a cycle of length 2: say, 1 -> 2 -> 1

To get at least two friends to come, I need to have both friends coming.

So, I need to send invitations to 1 and 2, and that's it.

So, with 2 invitations, both friends come.

Is there a way to have at least two friends come with fewer invitations? No, because I need to send at least two invitations.

So, for cycle length 2, minimal invitations are 2.

Now, for cycle length 3: say, 1 -> 2 -> 3 -> 1

To have at least two friends come, I need to have at least two edges fully covered.

Let's see:

If I send invitations to 1, 2, and 3:

- All three friends come.

But if I send invitations to only 1 and 2:

- Friend 1 and friend 2 come, since both have their best friends invited.

Wait, in this case, friend 1's best friend is 2, who has invitation, so friend 1 comes.

Friend 2's best friend is 3, who doesn't have invitation, so friend 2 doesn't come.

Wait, no, friend 2 has invitation, and their best friend 3 doesn't have invitation, so friend 2 doesn't come.

Friend 3 doesn't have invitation, so doesn't come.

So, only friend 1 comes, which is not enough.

If I send invitations to 1 and 3:

- Friend 1 has invitation, best friend 2 doesn't have invitation, so doesn't come.

- Friend 3 has invitation, best friend 1 has invitation, so friend 3 comes.

- Friend 2 doesn't have invitation.

So, only friend 3 comes, which is not enough.

If I send invitations to 2 and 3:

- Friend 2 has invitation, best friend 3 has invitation, so friend 2 comes.

- Friend 3 has invitation, best friend 1 has invitation? No, so friend 3 doesn't come.

- Friend 1 doesn't have invitation.

So, only friend 2 comes, which is not enough.

If I send invitations to 1, 2, and 3:

- Friend 1 has invitation, best friend 2 has invitation, so friend 1 comes.

- Friend 2 has invitation, best friend 3 has invitation, so friend 2 comes.

- Friend 3 has invitation, best friend 1 has invitation, so friend 3 comes.

So, all three come, which is fine, but I sent 3 invitations.

Is there a way to have at least two friends come with fewer than 3 invitations? It seems not, from the above tries.

So, for a cycle of length 3, minimal invitations needed are 3.

Wait, but in the first test case, with n=5 and p=[3,1,2,5,4], which has cycles of length 3 and 2, the sample output is 2.

Wait, but according to my earlier reasoning, for the cycle of length 3, I need 3 invitations to have at least two friends come.

But in the sample input, with n=5 and p=[3,1,2,5,4], which has a cycle of length 3 (1-3-2) and a cycle of length 2 (4-5), and the output is 2.

Wait, but according to my earlier reasoning, for the cycle of length 3, I need 3 invitations to have at least two friends come.

But in the sample input, with n=5 and p=[3,1,2,5,4], sending invitations to 4 and 5 allows friends 4 and 5 to come, since they are a cycle of length 2, and sending invitations to both makes both come.

Wait, but in this case, I'm getting two friends coming with two invitations, which matches the sample output.

So, perhaps my earlier reasoning for cycle of length 3 is incorrect.

Wait, in the cycle of length 3, to have at least two friends come, I need to send invitations to all three.

But in the sample input, there are two separate cycles: one of length 3 and one of length 2.

By sending invitations to the two friends in the cycle of length 2, I get two friends coming, which satisfies the condition.

So, in this case, I don't need to worry about the cycle of length 3 because I already have two friends coming from the cycle of length 2.

Hence, the minimal number of invitations is 2.

But if there were only the cycle of length 3 and no other cycles, would I need to send 3 invitations to have at least two friends come?

Wait, let's consider n=3, p=[2,3,1]

If I send invitations to 1 and 2:

- Friend 1 has invitation, best friend 2 has invitation, so friend 1 comes.

- Friend 2 has invitation, best friend 3 doesn't have invitation, so friend 2 doesn't come.

- Friend 3 doesn't have invitation.

So, only friend 1 comes, which is not enough.

If I send invitations to 1 and 3:

- Friend 1 has invitation, best friend 2 doesn't have invitation, so doesn't come.

- Friend 3 has invitation, best friend 1 has invitation, so friend 3 comes.

- Friend 2 doesn't have invitation.

So, only friend 3 comes, which is not enough.

If I send invitations to 2 and 3:

- Friend 2 has invitation, best friend 3 has invitation, so friend 2 comes.

- Friend 3 has invitation, best friend 1 doesn't have invitation, so friend 3 doesn't come.

- Friend 1 doesn't have invitation.

So, only friend 2 comes, which is not enough.

Only if I send invitations to 1, 2, and 3:

- Friend 1 has invitation, best friend 2 has invitation, so friend 1 comes.

- Friend 2 has invitation, best friend 3 has invitation, so friend 2 comes.

- Friend 3 has invitation, best friend 1 has invitation, so friend 3 comes.

So, all three come, which is fine, with 3 invitations.

Hence, for a single cycle of length 3, to have at least two friends come, I need to send invitations to all three.

But if there are multiple cycles, I can choose to send invitations to a cycle with length 2 to get two friends with 2 invitations.

Hence, in the first test case, with cycles of length 3 and 2, sending invitations to the cycle of length 2 is better, requiring only 2 invitations.

In the second test case, n=4, p=[2,3,4,1], which is a single cycle of length 4.

To have at least two friends come, what's the minimal number of invitations needed?

If I send invitations to 1, 2, and 3:

- Friend 1 has invitation, best friend 2 has invitation, so friend 1 comes.

- Friend 2 has invitation, best friend 3 has invitation, so friend 2 comes.

- Friend 3 has invitation, best friend 4 has invitation, so friend 3 comes.

- Friend 4 has invitation, best friend 1 has invitation, so friend 4 comes.

So, all four come, with 3 invitations.

Is it possible to have at least two friends come with fewer invitations?

Let's try sending invitations to 1 and 2:

- Friend 1 has invitation, best friend 2 has invitation, so friend 1 comes.

- Friend 2 has invitation, best friend 3 has invitation? No, so friend 2 doesn't come.

- Friend 3 doesn't have invitation.

- Friend 4 doesn't have invitation.

So, only friend 1 comes, which is not enough.

Sending invitations to 1 and 3:

- Friend 1 has invitation, best friend 2 has invitation? No, so doesn't come.

- Friend 3 has invitation, best friend 4 has invitation? No, so doesn't come.

- Friend 2 doesn't have invitation.

- Friend 4 doesn't have invitation.

So, no one comes.

Sending invitations to 1, 2, and 3:

- As before, friends 1, 2, and 3 come.

So, with 3 invitations, at least two friends come.

Hence, the minimal number is 3.

In the third test case, n=2, p=[2,1], which is a cycle of length 2.

Sending invitations to both friends makes both come, which satisfies the condition with 2 invitations.

So, in summary:

- If there are cycles of length 2, sending invitations to both friends in any cycle of length 2 is sufficient to have at least two friends come, requiring 2 invitations.

- If there are only cycles of length greater than 2, to have at least two friends come, I need to send invitations to all friends in one of the cycles of length greater than 2.

- Therefore, the minimal number of invitations is 2 if there is at least one cycle of length 2, otherwise, it's the length of the smallest cycle (which in this problem, since n ≤ 50, and t ≤ 5000, it's manageable).

Wait, but in the second test case, with a single cycle of length 4, the minimal number is 3, which is less than the cycle length.

Wait, but in that case, sending invitations to 1, 2, and 3 makes friends 1, 2, and 3 come, which is more than enough.

But is there a way to have at least two friends come with fewer invitations?

Let's see:

If I send invitations to 1, 2, and 4:

- Friend 1 has invitation, best friend 2 has invitation, so friend 1 comes.

- Friend 2 has invitation, best friend 3 has invitation? No, so doesn't come.

- Friend 4 has invitation, best friend 1 has invitation, so friend 4 comes.

- Friend 3 doesn't have invitation.

So, friends 1 and 4 come, which is at least two, with 3 invitations.

Is there a way to do it with 2 invitations?

From earlier attempts, it seems not.

Hence, for cycles of length 4, minimal invitations needed are 3 to have at least two friends come.

Similarly, for cycles of length 3, it's 3 invitations.

For cycles of length 2, it's 2 invitations.

Hence, the general approach is:

- If there is any cycle of length 2, then the minimal number of invitations is 2.

- Otherwise, the minimal number of invitations is 3.

Because, in cycles longer than 2, to have at least two friends come, I need to send invitations to all friends in one cycle, which would be longer than 2, but in the sample inputs, it's showing that for cycles longer than 2, the minimal invitations are 3.

Wait, but in the second test case, with a cycle of length 4, the output is 3.

Similarly, in a cycle of length 3, it's 3.

Hence, perhaps the minimal number of invitations is 2 if there exists a cycle of length 2, else 3.

This seems to be the pattern from the sample inputs.

Hence, the program needs to check if there is any cycle of length 2 in the best friend relationships.

If yes, then the minimal number of invitations is 2, else it's 3.

Wait, but in the first test case, there is a cycle of length 2 (4-5), so output is 2.

In the second test case, all cycles are longer than 2 (a single cycle of length 4), so output is 3.

In the third test case, there is a cycle of length 2 (1-2), so output is 2.

Hence, the program can simply check if there is any cycle of length 2 in the best friend relationships.

If yes, output 2, else output 3.

This seems to be the logic.

Now, looking at the given program:

t = int(input())

for i in range(t):

func_1()

def func_1():

n = int(input())

v = [0] * (n + 1)

v = [0] + list(map(int, input().split()))

for i in range(1, n + 1):

if v[v[i]] == i:

print(2)

return

print(3)

So, it reads the number of test cases t, then for each test case, it calls func_1.

func_1 reads n, then reads the list p_i, with 1-based indexing.

Then, it loops through each friend i from 1 to n, and checks if v[v[i]] == i.

If for any i, v[v[i]] == i, then it prints 2 and returns.

Else, after checking all i, it prints 3.

So, it's checking if there exists any i such that p_p_i == i.

Which means, if there is any i where i's best friend's best friend is i.

In other words, if there is a cycle of length 2.

Because, in a cycle of length 2, say 1 -> 2 -> 1.

Then, v[1] = 2, v[2] = 1, so v[v[1]] = v[2] = 1, which equals i=1.

Hence, it's detecting cycles of length 2.

If such a cycle exists, it prints 2, else it prints 3.

Which matches the logic I deduced from the sample inputs.

Hence, the program is correct.

**Final Answer**

\[\boxed{2}\]