Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform exactly k operations on it. In each operation, I select a contiguous subarray (which could even be empty) and insert the sum of this subarray anywhere in the array. I need to maximize the sum of the array after k such operations, and since the sum can be very large, I have to output it modulo 10^9 + 7.

First, I need to understand what exactly an operation is. I can choose any contiguous subarray, compute its sum, and insert that sum into the array, either at the beginning, end, or anywhere in between. So, essentially, I'm adding one new element to the array in each operation, which is the sum of some subarray.

My goal is to maximize the sum of the array after k operations. Since I'm adding k new elements to the array, the total sum will be the original sum plus the sum of these k new elements. To maximize the total sum, I need to choose which subarrays to sum and where to insert them in a way that maximizes the sum after k operations.

But wait, where I insert the new element doesn't seem to matter because I'm just interested in the sum of the array, not in the actual array itself. So, whether I insert the sum at the beginning, end, or in the middle, it won't affect the total sum as long as I'm just adding that sum to the array.

So, the key is to choose which subarrays to sum in each operation to maximize the total sum after k operations.

Let me think about this. In each operation, I can choose any contiguous subarray, compute its sum, and add that sum to the array. Since I can choose any contiguous subarray, including empty subarrays (whose sum is 0), I need to decide which subarrays to choose.

If I choose a subarray with a positive sum, adding its sum to the array will increase the total sum. If I choose a subarray with a negative sum, adding it will decrease the total sum. So, intuitively, I should always choose subarrays with positive sums to maximize the total sum.

But wait, there might be overlapping subarrays or something where choosing a larger subarray could be better. Also, since I can insert the sum anywhere, but as I thought earlier, the insertion position doesn't matter for the sum.

Let me consider a simple example to get a better understanding.

Take the first test case from the example:

2 2

-4 -7

According to the note, it's advantageous to take an empty subarray twice and insert 0 each time, resulting in a sum of -4 + -7 + 0 + 0 = -11, which modulo 10^9 + 7 is 999,999,996.

But why would choosing empty subarrays be advantageous here? Because both elements in the array are negative, so any non-empty subarray would have a negative sum, and adding that would decrease the total sum even more. So, adding 0 is better than adding a negative sum.

So, in cases where all elements are negative, adding 0 in each operation is better.

Another example:

3 3

2 2 8

According to the note, it's advantageous to take the sum of the entire array (2+2+8=12) three times and insert it, resulting in the array [2,2,8,12,24,48], with a sum of 96.

Wait, but according to the operation, in each step, you select a contiguous subarray, compute its sum, and insert it into the array. So, in the first operation, you can choose the entire array [2,2,8], sum is 12, insert 12 into the array, say at the end: [2,2,8,12].

Then, in the second operation, you can again choose the entire array [2,2,8,12], sum is 24, insert 24 into the array: [2,2,8,12,24].

Third operation: choose the entire array [2,2,8,12,24], sum is 48, insert 48 into the array: [2,2,8,12,24,48].

Total sum: 2+2+8+12+24+48 = 96.

So, in this case, choosing the entire array each time and inserting the sum at the end maximizes the sum.

Another test case:

5 1

4 -2 8 -12 9

According to the note, it's advantageous to take the subarray [4, -2, 8], sum is 10, and insert it at the beginning: [10,4,-2,8,-12,9], sum is 17.

So, in this case, choosing a subarray that has a positive sum and inserting it at the beginning increases the sum.

From these examples, it seems that the strategy is to choose the subarray with the maximum sum in each operation and insert it into the array.

But wait, in the first example, choosing the subarray with the maximum sum would be choosing an empty subarray with sum 0, since all elements are negative.

In the second example, choosing the entire array each time, which has the maximum sum, and inserting it.

In the third example, choosing a subarray [4, -2, 8] with sum 10, which is the maximum possible sum of any subarray.

So, it seems that in each operation, choosing the subarray with the maximum sum and inserting its sum into the array maximizes the total sum.

Now, how do I find the subarray with the maximum sum efficiently?

I recall that there's an algorithm called Kadane's algorithm that can find the maximum sum of a subarray in linear time.

So, perhaps in each operation, I can find the maximum sum subarray using Kadane's algorithm, insert its sum into the array, and repeat this k times.

But, there's a problem with this approach. Each time I insert a new sum into the array, the array changes, so I have to recompute the maximum sum subarray each time.

However, if I do this naively, it would be O(k * n), which could be too slow because n and k can be up to 2*10^5, and t can be up to 10^4, but the total sum of n and k across all test cases is 2*10^5.

So, O(k * n) would be too slow for the constraints.

I need a smarter way to compute the maximum possible sum after k operations without iterating through the array k times.

Let me think differently.

Let's consider that in each operation, I can add the sum of some subarray to the total sum.

Initially, the sum is sum(a).

After the first operation, I can choose any subarray, sum it, and add that sum to the total sum.

So, the total sum becomes sum(a) + sum(subarray1).

After the second operation, I can choose another subarray from the modified array and add its sum to the total sum.

But the modified array now has an extra element, which is sum(subarray1).

Wait, no. According to the problem, when I insert the sum of a subarray into the array, the original array size increases by one.

So, after the first operation, the array becomes a + [sum(subarray1)], and the sum is sum(a) + sum(subarray1).

Then, in the second operation, I can choose any subarray from this new array and insert its sum, and so on.

So, after k operations, the array will have n + k elements, and the sum will be sum(a) + sum of the k inserted sums.

So, to maximize the sum, I need to maximize the sum of the k inserted sums.

Each inserted sum is the sum of some contiguous subarray of the current array.

I need to choose k subarrays, compute their sums, insert those sums into the array, and maximize the total sum.

But since each insertion affects the array for the next operations, it's tricky to compute directly.

Let me try to find a pattern or a mathematical formula.

Suppose I choose to insert the sum of a subarray in each operation.

Let me denote s = sum(a).

In the first operation, I choose a subarray with sum s1, and insert it into the array. Now, the sum becomes s + s1.

In the second operation, I choose a subarray with sum s2 and insert it. Now, the sum becomes s + s1 + s2.

And so on, up to k operations.

So, the total sum is s + s1 + s2 + ... + sk.

I need to maximize s + s1 + s2 + ... + sk.

Given that s is fixed, I need to maximize the sum of s1 to sk.

Now, s1 to sk are sums of subarrays of the array after some modifications.

But it's getting complicated because each si depends on the previous modifications.

Is there a way to simplify this?

Wait a minute. Let's consider that in each operation, I can choose any subarray of the current array and insert its sum into the array.

But the sum of the current array is s + sum of previously inserted sums.

Wait, perhaps I can model this as repeatedly adding the maximum possible sum of a subarray in each operation.

If I always choose the subarray with the maximum sum in each operation and insert it, then in each operation, I'm adding the maximum possible sum to the total sum.

This seems optimal.

But how do I compute this efficiently?

Let me consider that after each operation, when I insert the maximum sum subarray, it becomes part of the array for the next operation.

But finding the maximum sum subarray each time would be too slow for the constraints.

Is there a pattern or a formula that can help me compute the total sum after k operations without simulating each operation?

Let me think about the contribution of each element.

Each element in the original array can be part of multiple subarrays, and their sums can be inserted multiple times.

But it's getting too tangled.

Let me look back at the examples to see if there's a pattern.

First test case:

n=2, k=2, a=[-4,-7]

Choose empty subarray with sum 0 in both operations, total sum = -4 -7 +0 +0 = -11.

If I choose any non-empty subarray, its sum would be negative, so adding 0 is better.

Second test case:

n=3, k=3, a=[2,2,8]

Choose the entire array each time: sum=12, then sum=24, then sum=48.

Total sum = 2+2+8+12+24+48 = 96.

Wait, but in the second operation, the array is [2,2,8,12], sum=14.

But according to the note, it's [2,2,8,12,24,48], which suggests that in each operation, they are choosing the entire array and inserting its sum.

But in reality, after the first operation, the array becomes [2,2,8,12], sum=14.

Then, in the second operation, choosing the entire array [2,2,8,12], sum=14, and inserting 14, making the array [2,2,8,12,14], sum=14+14=28.

Then, in the third operation, choosing the entire array [2,2,8,12,14], sum=28, and inserting 28, making the array [2,2,8,12,14,28], sum=28+28=56.

But according to the note, it's [2,2,8,12,24,48], sum=96.

Wait, maybe I misunderstood.

Looking back at the note:

"take the sum of the entire array three times and place it anywhere in the array, then one of the possible sequences of actions: [2,2,8] → [2,2,8,12] → [2,2,8,12,24] → [2,2,8,12,24,48], the sum of the final array is 2+2+8+12+24+48=96."

Ah, so in each operation, they are taking the sum of the entire original array, not the current array, and inserting it.

Wait, but according to the problem statement, in each operation, you select a contiguous subarray of the current array and insert its sum into the array.

So, in the first operation, you can choose the entire array [2,2,8], sum=12, insert 12, making the array [2,2,8,12].

In the second operation, you can choose the entire current array [2,2,8,12], sum=24, insert 24, making the array [2,2,8,12,24].

In the third operation, choose the entire current array [2,2,8,12,24], sum=48, insert 48, making the array [2,2,8,12,24,48].

Sum is indeed 2+2+8+12+24+48=96.

So, in each operation, they are choosing the entire current array, summing it, and inserting the sum into the array.

This seems to be a strategy where, in each operation, you choose the entire array, whose sum is doubling each time.

Wait, in the first operation, sum is 12, second operation sum is 24, third is 48.

So, it's not exactly doubling, but it's exponential growth.

Wait, 12 is the sum of [2,2,8], 24 is the sum of [2,2,8,12], which is 2+2+8+12=24, then 48 is the sum of [2,2,8,12,24], which is 2+2+8+12+24=48.

Wait, but 2+2+8+12+24 is actually 48, yes.

So, in general, if I choose the entire array in each operation, the sum of the array in the next operation is twice the previous sum.

Because sum_{i=1 to n+k} a_i = sum_{i=1 to n+k-1} a_i + sum_{i=1 to n+k-1} a_i = 2 * sum_{i=1 to n+k-1} a_i.

Wait, but in the first operation, sum is s + s, where s is the sum of the original array.

Wait, no.

Wait, in the first operation, I choose the entire array, sum is s, insert s, new sum is s + s = 2s.

In the second operation, I choose the entire array again, which now has sum 2s, insert 2s, new sum is 2s + 2s = 4s.

In the third operation, choose the entire array with sum 4s, insert 4s, new sum is 4s + 4s = 8s.

So, after k operations, the sum is s * 2^k.

Wait, but in the second test case, s = 2+2+8=12, and k=3, so 12 * 8 = 96, which matches the example.

Similarly, in the first test case, s = -4 + (-7) = -11, k=2, so -11 * 4 = -44.

But according to the note, it's -11, but according to this, it should be -44.

Wait, perhaps I'm missing something.

Wait, in the first test case, they chose to insert 0 in both operations, resulting in sum -4 + (-7) + 0 + 0 = -11.

But according to my previous reasoning, if I choose the entire array in each operation, sum would be s * 2^k = -11 * 4 = -44.

But choosing to insert 0 is better than choosing the entire array, because -11 is better than -44.

So, in cases where s is negative, choosing to insert 0 is better.

Hence, perhaps the optimal strategy is:

- If s >= 0, then choose the entire array in each operation, resulting in sum s * 2^k.

- If s < 0, choose an empty subarray in each operation, inserting 0, resulting in sum s + 0*k = s.

But wait, in the first test case, s = -11, k=2, so sum would be -11 + 0*2 = -11, which matches the note.

In the second test case, s=12, k=3, sum=12*2^3=96, which matches.

But in the fourth test case:

5 1

4 -2 8 -12 9

Sum s=4 + (-2) + 8 + (-12) + 9 = 7.

According to the note, they chose subarray [4,-2,8] with sum 10, inserted it at the beginning, resulting in array [10,4,-2,8,-12,9], sum=17.

But according to my previous formula, s * 2^k = 7 * 2 = 14, which is less than 17.

So, there's a discrepancy here.

Hence, my previous assumption that choosing the entire array in each operation leads to s * 2^k is not always optimal.

In this case, choosing a different subarray gives a higher sum.

So, perhaps choosing the maximum sum subarray in each operation is better.

In the fourth test case, choosing [4,-2,8] with sum 10, inserting it, sum becomes 7 + 10 = 17.

If I choose the entire array, sum would be 7 + 7 = 14, which is worse.

Hence, choosing the maximum sum subarray in each operation is better than choosing the entire array.

So, perhaps the optimal strategy is to, in each operation, choose the maximum sum subarray and insert its sum.

In the first test case, the maximum sum subarray is either individual elements or empty subarray with sum 0, so choosing 0 is optimal.

In the second test case, the maximum sum subarray is the entire array, so choosing it is optimal.

In the fourth test case, the maximum sum subarray is [4,-2,8] with sum 10, which is better than choosing the entire array with sum 7.

But, again, simulating this for k operations would be too slow.

I need a way to compute the sum after k operations efficiently.

Let me consider that in each operation, I can add the sum of the maximum sum subarray to the total sum.

So, if m is the sum of the maximum sum subarray, then after k operations, the total sum would be s + k*m.

But in the fourth test case, s=7, m=10, so s + k*m = 7 + 1*10 = 17, which matches the note.

In the second test case, s=12, m=12, so s + k*m = 12 + 3*12 = 48, but according to the note, it's 96.

Wait, that doesn't match.

Wait, perhaps I need to consider that in each operation, m is the maximum sum subarray of the current array.

So, in the second test case:

Operation 1: choose [2,2,8], m=12, insert 12, array becomes [2,2,8,12], s=14, m=14.

Operation 2: choose [2,2,8,12], m=24, insert 24, array becomes [2,2,8,12,24], s=38, m=38.

Operation 3: choose [2,2,8,12,24], m=48, insert 48, array becomes [2,2,8,12,24,48], s=96, m=96.

So, s + k*m = 12 + 3*12 = 48 does not match the actual sum of 96.

Hence, s + k*m is not correct.

Wait, perhaps it's s * 2^k.

Wait, in the second test case, s=12, 12 * 2^3 = 96, which matches.

But in the fourth test case, s=7, 7 * 2^1 = 14, but according to the note, it's 17.

So, in some cases, s * 2^k is correct, in others, s + k*m is correct.

I need to find a general formula that covers both cases.

Wait, perhaps it's s * 2^k if s >=0, else s + 0*k.

But in the fourth test case, s=7, which is positive, so s * 2^k =14, but the note shows 17.

So, that doesn't hold.

Wait, maybe it's m * (2^k -1), where m is the maximum sum subarray.

Wait, in the second test case, m=12, 12*(8-1)=84, which is not 96.

No.

Wait, perhaps it's s + m * (2^k -1).

In the second test case, s=12, m=12, 12 + 12*(8-1)=12 + 84=96, which matches.

In the first test case, s=-11, m=0, -11 + 0*(4-1)=-11, which matches.

In the fourth test case, s=7, m=10, 7 + 10*(2-1)=17, which matches.

So, the general formula seems to be: sum = s + m * (2^k -1), where m is the sum of the maximum sum subarray.

Wait, but in the second test case, m=s=12, so sum=12 + 12*(8-1)=12 + 84=96, which matches.

In the first test case, s=-11, m=0, sum=-11 + 0*(4-1)=-11, which matches.

In the fourth test case, s=7, m=10, sum=7 + 10*(2-1)=17, which matches.

Seems promising.

Let me verify with another example.

Take the seventh test case:

6 1000

-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000

Sum s=-6000000000, m=0 (since all elements are negative), sum=-6000000000 + 0*(2^1000 -1)=-6000000000, which modulo 10^9+7 is 42, as per the note.

Another test case:

2 1

1000000000 8

Sum s=1000000008, m=1000000008 (the entire array), sum=1000000008 +1000000008*(2-1)=1000000008 +1000000008=2000000016, modulo 10^9+7 is 2, which matches the note.

Another test case:

5 4

0 0 0 0 0

Sum s=0, m=0, sum=0 +0*(16-1)=0, which matches the note.

Seems consistent.

Hence, the formula sum = s + m * (2^k -1), where m is the sum of the maximum sum subarray, seems to hold.

So, to implement this, I need to:

1. Compute s = sum(a)

2. Find m = maximum sum of any subarray of a (including empty subarray with sum 0)

3. Compute sum = s + m * (2^k -1)

4. Take sum modulo 10^9+7

Now, to find m, the maximum sum subarray, I can use Kadane's algorithm, which runs in O(n) time.

Given that n and k can be up to 2*10^5 and t up to 10^4, but the total sum of n and k across all test cases is 2*10^5, my solution should be efficient enough.

Edge cases to consider:

- All elements are negative: m=0, sum=s +0*(2^k -1)=s

- s >=0: sum=s + m*(2^k -1), where m >= s

- k=0: but k >=1 as per constraints

- n=1: possible, need to handle correctly

- m=0: when all elements are negative or zero

- m > s: as in the fourth test case

- m == s: when all elements are non-negative

I need to make sure that m is at least 0, because inserting an empty subarray is always an option.

Hence, m = max(Kadane's max subarray sum, 0)

Now, implement this in code.

Also, need to handle large exponents in 2^k efficiently, using modular exponentiation.

But since 2^k can be very large, I need to compute 2^k modulo (10^9+7), but since I'm multiplying by m, which can also be large, I need to handle large numbers.

Wait, but in the formula sum = s + m * (2^k -1), I need to compute this modulo 10^9+7.

So, I can compute 2^k modulo 10^9+7, then compute m * (2^k -1) modulo 10^9+7, and then add s modulo 10^9+7.

But s can be negative, so I need to handle negative sums properly.

In Python, the modulo operation for negative numbers is tricky, so I need to ensure that the result is non-negative.

Hence, I can compute s modulo 10^9+7, m modulo 10^9+7, and then perform the operations.

Wait, but m can be negative if all elements are negative, but in that case, m=0.

Hence, m is always >=0.

s can be negative, so I need to handle negative sums.

To handle this, I can compute s modulo 10^9+7, ensuring it's a non-negative integer.

In Python, I can use the modulo operator, but need to adjust for negative numbers.

So, sum = (s + m * (2^k -1)) % (10^9+7)

To compute 2^k modulo 10^9+7 efficiently, I can use the built-in pow function, which is efficient for large exponents.

Hence, my plan is:

- For each test case:

- Read n, k

- Read array a

- Compute s = sum(a)

- Compute m = max(Kadane's max subarray sum, 0)

- Compute sum = (s + m * (pow(2, k, 10**9+7) -1)) % (10**9+7)

- Print sum

Implement Kadane's algorithm to find the maximum sum subarray.

Here's a sample implementation of Kadane's algorithm:

def max_subarray_sum(a):

current_max = a[0]

global_max = a[0]

for num in a[1:]:

current_max = max(num, current_max + num)

global_max = max(global_max, current_max)

return global_max

But, in the problem, m should be the maximum of Kadane's result and 0, since choosing an empty subarray is allowed.

Hence, m = max(Kadane's result, 0)

Now, implement this in code.

Also, need to handle the case when the array is empty, but n >=1 as per constraints.

Also, ensure that the modulo operation is handled correctly for negative numbers.

In Python, to compute x modulo m for negative x, I can use (x % m + m) % m to get a non-negative result.

Hence, sum = (s + m * (pow(2, k, MOD) -1)) % MOD

But to handle negative s, I can compute s = (s % MOD + MOD) % MOD

Similarly for m, since m is always >=0, no need to adjust.

Hence, the formula remains sum = (s + m * (pow(2, k, MOD) -1)) % MOD

Now, implement this.

I need to make sure that Kadane's algorithm is correctly implemented to handle all cases, including when all elements are negative.

Wait, in the first test case, all elements are negative, so Kadane's algorithm should return the maximum subarray sum, which is the largest element in the array, but since m is max(Kadane's result, 0), m=0, which matches the note.

Hence, this seems correct.

Another consideration is that m can be larger than s, as in the fourth test case.

Hence, this formula seems to cover all cases.

I think this is the correct approach.

## Final Solution
To solve this problem, we need to maximize the sum of an array after performing exactly k operations, where each operation involves selecting a contiguous subarray (which could be empty) and inserting the sum of this subarray anywhere in the array.

### Approach

1. **Understanding Operations**:
   - Each operation allows selecting a contiguous subarray and inserting its sum into the array.
   - To maximize the sum, we should choose subarrays with the highest possible sums to insert.

2. **Key Insight**:
   - We can model the sum after k operations using the formula: 
     \[
     \text{sum} = s + m \times (2^k - 1)
     \]
     where:
     - \( s \) is the initial sum of the array.
     - \( m \) is the maximum sum of any subarray (including zero for empty subarrays).

3. **Handling Negative Sums**:
   - If the maximum subarray sum \( m \) is negative, choosing an empty subarray (sum = 0) is better.
   - Hence, \( m = \max(\text{max subarray sum}, 0) \).

4. **Efficient Calculation**:
   - Use Kadane's algorithm to find the maximum subarray sum efficiently.
   - Use modular arithmetic to handle large numbers and negative sums.

### Solution Code

```python
MOD = 10**9 + 7

def max_subarray_sum(a):
    if not a:
        return 0
    current_max = a[0]
    global_max = a[0]
    for num in a[1:]:
        current_max = max(num, current_max + num)
        global_max = max(global_max, current_max)
    return global_max

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    t = int(data[idx])
    idx += 1
    for _ in range(t):
        n = int(data[idx])
        k = int(data[idx + 1])
        idx += 2
        a = list(map(int, data[idx:idx + n]))
        idx += n
        s = sum(a)
        m = max(max_subarray_sum(a), 0)
        # Compute sum modulo MOD
        sum_mod = (s + m * (pow(2, k, MOD) - 1)) % MOD
        print(sum_mod)

if __name__ == "__main__":
    main()
```

### Explanation

1. **Reading Input**:
   - Read the number of test cases.
   - For each test case, read n (length of array), k (number of operations), and the array a.

2. **Calculating Initial Sum (s)**:
   - Compute the sum of the array a.

3. **Finding Maximum Subarray Sum (m)**:
   - Use Kadane's algorithm to find the maximum sum of any subarray.
   - Set m to the maximum of this sum and 0 (to handle cases where all elements are negative).

4. **Computing Final Sum**:
   - Use the formula \( \text{sum} = s + m \times (2^k - 1) \) to compute the sum after k operations.
   - Take the result modulo \( 10^9 + 7 \) to handle large numbers.

5. **Output**:
   - Print the result for each test case.

This approach ensures that we efficiently compute the maximum possible sum after k operations, considering both positive and negative elements in the array.