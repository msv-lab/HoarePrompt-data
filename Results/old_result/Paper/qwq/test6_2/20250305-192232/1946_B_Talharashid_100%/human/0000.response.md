Alright, I have this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I need to perform exactly k operations on it. In each operation, I can select any contiguous subarray (which could even be empty) and insert the sum of that subarray anywhere in the array. After performing k such operations, I need to find the maximum possible sum of the array, and since it can be very large, I have to output it modulo 10^9 + 7.

First, I need to understand what exactly an operation is. I can choose any contiguous subarray, calculate its sum, and then insert that sum into the array at any position. So, for example, if I have an array [1, 2, 3], and I choose the subarray [2, 3] with sum 5, I can insert 5 at the beginning, end, or in between any elements.

My goal is to maximize the sum of the array after k operations. Since I can choose any contiguous subarray and insert its sum anywhere, I need to think about how to strategically choose subarrays and where to insert their sums to get the highest possible total sum.

Let me consider a simple example to get a better understanding. Suppose n=1, k=1, and the array is [7]. If I choose the entire array [7] and insert its sum (7) anywhere, say at the end, the array becomes [7, 7], and the sum is 14. Alternatively, if I choose an empty subarray with sum 0 and insert it, the sum remains 7. So, in this case, choosing the entire array and inserting its sum is better.

Another example: n=2, k=2, array is [-4, -7]. If I choose the entire array, sum is -11, and inserting it would make the array [-4, -7, -11], sum being -22. Alternatively, choosing an empty subarray with sum 0 and inserting it twice would make the array [-4, -7, 0, 0], sum being -11. So, in this case, inserting the empty subarray sum is better than inserting the sum of the entire array.

Wait, but according to the first test case in the example, for n=2, k=2, array=[-4, -7], the output is 999999996, which is -11 modulo 10^9 + 7. So, it seems that inserting the empty subarray sum of 0 twice is the optimal strategy here.

In another test case, n=3, k=3, array=[2,2,8]. The output is 96. Looking at the explanation, they chose the sum of the entire array (12) and inserted it three times, resulting in the array [2,2,8,12,24,48], sum being 96.

So, in this case, choosing the entire array's sum and inserting it multiple times led to the maximum sum.

From these examples, it seems that the strategy is to choose the subarray with the maximum sum and insert it multiple times.

But in the first test case, choosing the sum of the entire array (-11) and inserting it would decrease the total sum, so choosing to insert the sum of an empty subarray (0) is better.

So, perhaps the general strategy is:

- If the maximum sum of any subarray is positive, then insert that sum as many times as possible.

- If the maximum sum of any subarray is non-positive, then inserting the sum of an empty subarray (0) is better.

Wait, but in the first test case, the maximum subarray sum is the sum of the entire array, which is -11, which is negative. So, inserting 0 is better.

In the second test case, the maximum subarray sum is 12 (sum of [2,2,8]), which is positive, so inserting 12 multiple times increases the sum.

So, perhaps the strategy is:

- Find the maximum sum of any subarray (including the empty subarray, which has sum 0).

- If this maximum sum is positive, then insert it k times.

- If it's non-positive, then inserting the sum of the empty subarray (0) k times is better.

But in the fourth test case, n=5, k=1, array=[4,-2,8,-12,9]. The output is 17.

According to the explanation, they chose the subarray [4,-2,8] with sum 10, and inserted it at the beginning, making the array [10,4,-2,8,-12,9], sum being 17.

So, in this case, inserting the sum of a partial subarray is better than inserting the sum of the entire array or the empty subarray.

Wait, so maybe my previous strategy is not complete.

I need to consider that inserting the sum of a subarray not only adds that sum but also allows me to place it strategically in the array.

But in this case, since the operation is to insert the sum anywhere, it doesn't matter where I insert it because it's just adding to the total sum.

Wait, no, it does matter because the inserted sum can be part of future subarrays chosen for operations.

But in terms of maximizing the total sum, it seems that the best approach is to insert the sum of the maximum subarray as many times as possible.

Wait, but in the fourth test case, inserting the sum of [4,-2,8] which is 10, leads to a total sum of 17.

If they had inserted the sum of the entire array, which is 4 + (-2) + 8 + (-12) + 9 = 7, then the array would be [4,-2,8,-12,9,7], sum being 14, which is less than 17.

So, choosing a subarray with sum 10 and inserting it is better than inserting the entire array's sum.

Wait, but according to my previous strategy, since the maximum subarray sum is 10, which is positive, I should insert it once (since k=1), leading to sum being original sum plus 10, which is 7 + 10 = 17, which matches the output.

So, in this case, it worked.

Wait, but in the first test case, the maximum subarray sum is -11, which is negative, so inserting it would decrease the sum, so instead, inserting 0 is better.

So, perhaps the strategy is:

- Find the maximum sum of any subarray (including the empty subarray, which has sum 0).

- If this maximum sum is positive, then insert it k times.

- If it's non-positive, then insert 0 k times.

But in the seventh test case, n=6, k=1000, array=[-1000000000, -1000000000, -1000000000, -1000000000, -1000000000, -1000000000], the output is 42.

According to the explanation, the sum is -6, and since inserting 0 is better, the sum remains -6, and modulo 10^9 + 7 is 10^9 + 7 - 6 = 999999996 + 42 = 1000000038, but in the note, it says it's 42.

Wait, in the seventh test case, the output is 42, but according to my calculation, it should be 999999996 + 42 = 1000000038, but perhaps I'm missing something.

Wait, in the note, it says that (-6 * (10^9 + 7) + 42 = -6,000,000,000), but I'm not sure how that relates.

Wait, perhaps I need to handle negative sums correctly when taking modulo.

I need to recall that to compute a modulo m when a is negative, I can add m to a until a is non-negative, then take a mod m.

So, for sum s, s % m = (s + m) % m if s < 0.

In the seventh test case, sum is -6,000,000,006, since sum of array is -6, and inserting 0 k=1000 times doesn't change the sum.

But according to the note, it's (-6 * (10^9 + 7) + 42 = -6,000,000,000), which seems off.

Wait, perhaps I need to compute the sum as sum + k * max_subarray_sum, where max_subarray_sum is the maximum sum of any subarray.

But in the seventh test case, max_subarray_sum is 0 (since all elements are negative), so sum remains -6, but according to the note, it's -6 * (10^9 + 7) + 42.

Wait, perhaps I need to consider that inserting 0 k times adds 0 * k = 0 to the sum, but in the note, it's -6 * (10^9 + 7) + 42, which is confusing.

Wait, perhaps I need to think differently.

Wait, maybe the operations allow inserting the sum anywhere in the array, but the sum of the array after operations is original sum plus the sum of the inserted sums.

In each operation, I choose a subarray, compute its sum, and insert that sum into the array.

So, for each operation, I'm adding the sum of some subarray to the total sum.

Therefore, after k operations, the total sum is original sum plus the sum of the k inserted sums.

To maximize the total sum, I need to choose subarrays with the maximum possible sum for each operation, and insert that sum into the array.

So, if I can choose the subarray with the maximum sum in each operation, and insert its sum, then the total sum would be original sum plus k times the maximum subarray sum.

But in the fourth test case, they chose a subarray with sum 10 and inserted it once, so total sum is original sum (7) plus 10, equaling 17.

Wait, but according to my formula, it should be 7 + 1*10 = 17, which matches.

In the second test case, original sum is 2+2+8=12, and maximum subarray sum is 12, so total sum after 3 operations is 12 + 3*12 = 48, but according to the explanation, they have [2,2,8,12,24,48], sum is 96, which is original sum plus 12 + 24 + 48.

Wait, that's different.

Wait, perhaps in each operation, the sum inserted can be based on the current state of the array.

So, in the first operation, choose [2,2,8], sum 12, insert 12, array becomes [2,2,8,12].

In the second operation, choose [2,2,8,12], sum 24, insert 24, array becomes [2,2,8,12,24].

In the third operation, choose [2,2,8,12,24], sum 48, insert 48, array becomes [2,2,8,12,24,48].

Total sum is 2+2+8+12+24+48 = 96.

So, in this case, the sum inserted in each operation is increasing exponentially because each time they are choosing the entire array and inserting its sum, which includes the previously inserted sums.

So, it's not just adding the maximum subarray sum k times, but rather, each insertion affects the possible sums for the next operations.

This complicates things because the sum inserted in each operation depends on the current state of the array.

So, perhaps a better strategy is to, in each operation, choose the entire array and insert its sum, which would exponentially increase the sum.

Wait, but in the first test case, if I choose the entire array with sum -11 and insert it twice, the array becomes [-4,-7,-11,-22], sum being -44, which is worse than inserting the empty subarray sum of 0 twice, resulting in sum -11.

So, in that case, choosing the empty subarray is better.

Similarly, in the seventh test case, inserting 0 k times is better than inserting negative sums.

So, perhaps the strategy is:

- Find the maximum possible sum of any subarray, including the empty subarray (which is 0).

- If this maximum sum is positive, then in each operation, choose this subarray and insert its sum, which would exponentially increase the sum.

- If the maximum sum is non-positive, then inserting the empty subarray sum of 0 is the best option.

But in the second test case, the maximum subarray sum is 12 (the entire array), and by choosing to insert 12, then 24, then 48, the sum becomes 96, which is better than just inserting 12 three times (which would be 12 + 3*12 = 48).

So, there's potential for exponential growth if I choose to insert the current total sum in each operation.

Wait, but in reality, the sum inserted in each operation is based on the current array state, which includes previously inserted sums.

So, it's not just inserting a fixed sum each time, but rather, the sum can grow based on previous insertions.

This seems complex to model directly.

Let me think differently.

Suppose I denote S as the original sum of the array.

In each operation, I can choose any contiguous subarray, compute its sum, and insert it into the array.

So, after the first operation, the sum becomes S + sum1, where sum1 is the sum of the chosen subarray.

In the second operation, I can choose any contiguous subarray from the updated array and insert its sum.

So, the sum after the second operation is S + sum1 + sum2, where sum2 is the sum of the subarray chosen in the second operation, which could include parts of the originally inserted sum1.

This seems recursive and complicated.

Perhaps I need to find a pattern or formula that can express the total sum after k operations.

Let me consider that in each operation, I can choose to insert the current maximum possible subarray sum.

If the maximum subarray sum is positive, then each insertion increases the total sum by that amount.

Moreover, since the inserted sum can be part of future subarrays, it can be reinvested in future operations.

This sounds similar to compound interest, where each addition contributes to future growth.

In the second test case, starting with sum 12, inserting 12, then the new sum is 24, inserting 24, then new sum is 48, inserting 48, total sum is 96.

So, it's like each insertion doubles the sum.

Wait, starting with sum S, after first insertion, sum becomes S + S = 2S.

Second insertion, insert the current sum 2S, sum becomes 2S + 2S = 4S.

Third insertion, insert 4S, sum becomes 4S + 4S = 8S.

So, after k insertions, sum is 2^k * S.

But in the second test case, original sum S = 12, 2^3 * 12 = 96, which matches the explanation.

Similarly, in the first test case, S = -11, 2^2 * (-11) = -44, but according to the explanation, inserting 0 twice gives sum -11.

So, in cases where the maximum subarray sum is positive, the optimal strategy is to insert the current sum each time, achieving exponential growth.

When the maximum subarray sum is non-positive, inserting 0 is better, as it doesn't decrease the sum.

Therefore, the general strategy is:

- Find the maximum subarray sum, say M.

- If M > 0, then the total sum after k operations is original sum S plus M times (2^k - 1).

- If M <= 0, then insert 0 in all k operations, so the total sum is S + 0*k = S.

Wait, in the second test case, M = 12 > 0, so total sum is S + M * (2^k - 1) = 12 + 12*(8 - 1) = 12 + 84 = 96, which matches.

In the first test case, M = 0 (since inserting 0 is better than inserting -11), so total sum is S + 0*k = -11.

Wait, but according to the note, in the seventh test case, sum is -6, and inserting 0 k=1000 times, sum remains -6, but the output is 42.

So, perhaps I need to adjust for modulo correctly.

I need to handle negative sums properly when taking modulo.

In Python, the modulo operation for negative numbers wraps around correctly, but I need to ensure that the final sum is computed correctly.

Wait, in the seventh test case, sum S = -6,000,000,006, but according to the note, it's -6 * (10^9 + 7) + 42 = -6,000,000,000.

Wait, perhaps I'm missing something.

Wait, in the seventh test case, n=6, k=1000, array=[-1000000000, -1000000000, -1000000000, -1000000000, -1000000000, -1000000000], sum S = -6,000,000,000.

If M = 0, then total sum is S + 0*k = -6,000,000,000.

But according to the note, it's (-6 * (10^9 + 7) + 42), which is -6,000,000,000.

But in reality, 10^9 + 7 is 1,000,000,007.

So, -6 * 1,000,000,007 + 42 = -6,000,000,042 + 42 = -6,000,000,000.

But in programming terms, to take modulo, we need to compute (-6,000,000,000) mod (1,000,000,007).

In Python, -6,000,000,000 % 1,000,000,007 = 42.

Because -6,000,000,000 + 6,000,000,035 = 35, and 35 % 1,000,000,007 = 35.

Wait, but according to the note, it's 42.

Wait, perhaps I need to compute it differently.

Wait, in the note, it says "-6 * (10^9 + 7) + 42 = -6,000,000,000", which seems off.

Wait, perhaps I need to compute S + k * M, where M is the maximum subarray sum.

But in this case, M = 0, so sum is S + 0*k = S = -6,000,000,000.

Then, -6,000,000,000 mod (1,000,000,007).

To compute this, since -6,000,000,000 is negative, I can add 1,000,000,007 enough times to make it positive.

-6,000,000,000 + 6 * 1,000,000,007 = -6,000,000,000 + 6,000,000,042 = 42.

Hence, -6,000,000,000 mod 1,000,000,007 = 42.

So, in this case, the output is 42, which matches the sample output.

Therefore, my strategy seems correct.

To summarize:

- Compute the original sum S of the array.

- Find the maximum subarray sum M (including the empty subarray, which is 0).

- If M > 0, then the total sum after k operations is S + M * (2^k - 1).

- If M <= 0, then the total sum is S + 0*k = S.

- Finally, take the result modulo 1,000,000,007.

Wait, but in the second test case, S = 12, M = 12, k = 3, so sum = 12 + 12*(8 - 1) = 12 + 84 = 96.

In the first test case, S = -11, M = 0, sum = -11.

In the seventh test case, S = -6,000,000,000, M = 0, sum = -6,000,000,000, which is 42 modulo 1,000,000,007.

Seems consistent.

But in the fourth test case, S = 7, M = 10, k = 1, sum = 7 + 10 = 17, which matches the sample output.

So, my formula seems correct.

Wait, but in the second test case, according to my formula, sum = S + M*(2^k - 1) = 12 + 12*(8 - 1) = 96, which matches.

In the seventh test case, sum = S + 0*(2^k - 1) = -6,000,000,000, which is 42 modulo 1,000,000,007.

Seems correct.

Now, I need to implement this in code.

First, read t test cases.

For each test case:

- Read n and k.

- Read the array a.

- Compute S = sum(a).

- Compute M = maximum subarray sum, which can be found using Kadane's algorithm.

- If M > 0, then total sum = S + M * (2^k - 1).

- Else, total sum = S.

- Output total sum modulo 1,000,000,007.

But I need to handle large exponents in 2^k efficiently, since k can be up to 2*10^5, and t is up to 10^4, so total operations should be efficient.

In Python, exponentiation is fast, and built-in modulo can handle large numbers efficiently.

Also, Kadane's algorithm runs in O(n), which is acceptable since n is up to 2*10^5 per test case, and t is up to 10^4, but with total n and k summing up to 2*10^5, so it should be fine.

Wait, the problem says "the sum of the values of n and k for all test cases does not exceed 2*10^5", so total time should be O(2*10^5), which is acceptable.

Now, to implement Kadane's algorithm correctly.

Kadane's algorithm finds the maximum sum of a contiguous subarray in O(n) time.

Here's how it works:

Initialize:

max_current = max_global = a[0]

For i from 1 to n-1:

max_current = max(a[i], max_current + a[i])

if max_current > max_global:

max_global = max_current

Return max_global

But in this problem, we also need to consider the empty subarray, which has sum 0.

So, we need to take M = max(Kadane's result, 0)

Because if Kadane's result is negative, inserting 0 is better.

Hence, M = max(Kadane's result, 0)

Now, implement this in code.

Also, need to handle large numbers and modulo correctly.

In Python, integers can be arbitrarily large, but we need to take modulo 1,000,000,007 at the end.

Also, need to handle negative sums correctly when taking modulo.

As shown in the seventh test case, sum can be negative, so need to compute sum % 1,000,000,007 correctly.

In Python, a % m is always non-negative, even if a is negative, but internally, Python computes it as a - (a // m) * m, which may need adjustment for negative a.

But in practice, in Python, -6,000,000,000 % 1,000,000,007 correctly returns 42, as shown earlier.

Hence, I can rely on Python's modulo operation.

Now, write the code accordingly.

But looking at the given program, it seems different.

Let me check the given program.

Given program:

import math

def func():

for i in range(int(input())):

(n, k) = map(int, input().split())

l = list(map(int, input().split()))

c = 0

maxi = 0

for ele in l:

if ele < 0 and c <= abs(ele):

maxi = max(c, maxi)

c = 0

else:

c += ele

maxi = max(c, maxi)

maxi = max(c, maxi)

print((2 ** k * maxi - maxi + sum(l)) % 1000000007)

So, in this program, they are trying to compute M, the maximum subarray sum, considering something about negative elements.

But it seems incomplete.

Wait, in the loop:

for ele in l:

if ele < 0 and c <= abs(ele):

maxi = max(c, maxi)

c = 0

else:

c += ele

maxi = max(c, maxi)

maxi = max(c, maxi)

This seems similar to Kadane's algorithm, but not exactly.

In standard Kadane's algorithm, we have:

max_current = max(a[i], max_current + a[i])

Here, they are checking if ele < 0 and c <= abs(ele), then set c = 0, else c += ele.

This might not correctly handle cases where there are positive elements followed by negative elements.

For example, in [4, -2, 8], the maximum subarray sum is 10 (4 + (-2) + 8), but according to this code:

Initialize c = 0, maxi = 0

First ele = 4:

4 >= 0 or c <= abs(-4)? Wait, the condition is if ele < 0 and c <= abs(ele):

Since ele = 4 >=0, it doesn't satisfy the if condition, so go to else:

c += 4 => c = 4

maxi = max(4, 0) = 4

Second ele = -2:

-2 < 0 and c = 4 <= abs(-2) = 2? 4 <= 2? No, so go to else:

c += (-2) => c = 2

maxi = max(2, 4) = 4

Third ele = 8:

8 >=0, so go to else:

c += 8 => c = 10

maxi = max(10, 4) = 10

Final maxi = max(10, 10) = 10, which is correct.

Another test case: [-4, -7]

Initialize c = 0, maxi = 0

First ele = -4:

-4 < 0 and c = 0 <= abs(-4) = 4? Yes, so maxi = max(0, 0) = 0, c = 0

Second ele = -7:

-7 < 0 and c = 0 <= abs(-7) = 7? Yes, so maxi = max(0, 0) = 0, c = 0

Final maxi = max(0, 0) = 0, which is correct.

Seems like this implementation works correctly for these cases.

Wait, but in the standard Kadane's algorithm, we have:

max_current = max(a[i], max_current + a[i])

But here, they are doing:

if ele < 0 and c <= abs(ele):

maxi = max(c, maxi)

c = 0

else:

c += ele

So, it's a variation of Kadane's algorithm, where they reset c to 0 when the current c is less than or equal to the absolute value of a negative element.

I need to verify if this correctly computes the maximum subarray sum.

Another test case: [1, -2, 3, 4, -5, 6]

Maximum subarray sum is 3 + 4 + (-