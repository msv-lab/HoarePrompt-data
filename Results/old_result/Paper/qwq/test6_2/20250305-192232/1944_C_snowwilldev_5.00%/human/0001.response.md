Alright, I've got this problem to solve. Let's see what it's about. So, there's this game between Alice and Bob involving an array of integers. Alice starts with an empty array c, and they take turns playing until the original array a is empty. On Alice's turn, she picks an element from a, appends it to c, and deletes it from a. Bob, on his turn, just picks an element from a and deletes it without adding it to c. The game ends when a is empty, and the score is the MEX of c, which is the smallest non-negative integer not present in c. Alice wants to maximize the score, and Bob wants to minimize it. I need to find out what the final score will be if both play optimally.

First, I need to understand what MEX is. From the description, MEX of an array is the smallest non-negative integer not present in it. For example, MEX of [2,2,1] is 0, since 0 is the smallest non-negative integer not in the array. MEX of [3,1,0,1] is 2, because 0 and 1 are present, but 2 is not. And MEX of [0,3,1,2] is 4, as 0,1,2,3 are present, but 4 is not.

So, the goal is to find the MEX of array c, which is built by Alice picking elements and adding them to c, while Bob tries to interfere with that to minimize the MEX.

Let me think about how Alice and Bob will play.

Alice wants to maximize the MEX, which means she wants c to contain as many small non-negative integers as possible, in order to make the smallest missing integer as large as possible.

Bob, on the other hand, wants to minimize the MEX, so he wants to prevent Alice from including certain elements in c, specifically smaller integers, to make the MEX smaller.

Since Alice goes first and can choose which elements to add to c, and Bob can remove elements, including those that Alice might want, I need to model their strategies.

Let me consider the game progression:

- Alice picks an element to add to c and removes it from a.

- Bob picks an element to remove from a.

This alternates until a is empty.

I need to find out what c will look like at the end, considering both players play optimally.

Let me consider some small examples to get a feel for the problem.

Example 1:

Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Output:

2

1

0

Let's look at the first test case:

n=4, a=[0,0,1,1]

Possible game:

- Alice picks 1 and adds to c, so c=[1], a=[0,0,1]

- Bob picks 0 from a, a=[0,1]

- Alice picks 0 and adds to c, c=[1,0], a=[1]

- Bob picks 1 from a, a=[]

So c=[1,0], MEX is 2.

Is this the optimal play? Let's see.

Another possible game:

- Alice picks 0, c=[0], a=[0,1,1]

- Bob picks 1, a=[0,1]

- Alice picks 1, c=[0,1], a=[0]

- Bob picks 0, a=[]

c=[0,1], MEX is 2 again.

Another one:

- Alice picks 1, c=[1], a=[0,0,1]

- Bob picks 1, a=[0,0]

- Alice picks 0, c=[1,0], a=[0]

- Bob picks 0, a=[]

c=[1,0], MEX=2.

Seems like regardless of how they play, c ends up with [0,1], and MEX is 2.

Is there a way for Bob to make MEX smaller? Let's see.

- Alice picks 0, c=[0], a=[0,1,1]

- Bob picks 0, a=[1,1]

- Alice picks 1, c=[0,1], a=[1]

- Bob picks 1, a=[]

c=[0,1], MEX=2 again.

Or:

- Alice picks 1, c=[1], a=[0,0,1]

- Bob picks 0, a=[0,1]

- Alice picks 0, c=[1,0], a=[1]

- Bob picks 1, a=[]

c=[1,0], MEX=2.

Seems consistent.

Second test case:

n=4, a=[0,1,2,3]

Possible game:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 1, c=[0,1], a=[2,3]

- Bob picks 2, a=[3]

- Alice picks 2, c=[0,1,2], a=[3]

- Bob picks 3, a=[]

c=[0,1,2], MEX=3.

But the output is 1, so this can't be correct. Wait, maybe Bob can play differently.

Alternative game:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob picks 3, a=[]

c=[0,2], MEX=1.

Ah, so Bob can prevent Alice from getting 1 into c by picking it.

So, in this case, c ends up with 0 and 2, MEX is 1.

Is there a way for Alice to get 1 into c?

- Alice picks 1, c=[1], a=[0,2,3]

- Bob picks 0, a=[2,3]

- Alice picks 0, c=[1,0], a=[2,3]

- Bob picks 2, a=[3]

- Alice picks 2, c=[1,0,2], a=[3]

- Bob picks 3, a=[]

c=[1,0,2], MEX=3.

But Bob can try to pick elements to minimize MEX.

Wait, in this path, Bob picks 0, but maybe he should pick something else.

Alternative:

- Alice picks 1, c=[1], a=[0,2,3]

- Bob picks 2, a=[0,3]

- Alice picks 0, c=[1,0], a=[3]

- Bob picks 3, a=[]

c=[1,0], MEX=2.

Still not as bad as MEX=1.

Wait, in the first path, c=[0,2], MEX=1.

So, depending on how Bob plays, he can force MEX to be 1.

Hence, the minimal possible MEX Alice can achieve is 1.

Wait, but in the output, it's 1, which is the minimal MEX Bob can force, but the problem says Alice wants to maximize MEX and Bob wants to minimize it. So, the final score is the MEX when both play optimally.

In this case, it's 1.

Third test case:

n=2, a=[1,1]

Possible game:

- Alice picks 1, c=[1], a=[1]

- Bob picks 1, a=[]

c=[1], MEX=0.

Another game:

- Alice picks 1, c=[1], a=[1]

- Bob picks 1, a=[]

c=[1], MEX=0.

Only possibility.

So, output is 0.

From these examples, it seems like the game's score is the smallest integer that Alice cannot include in c despite her efforts.

Wait, but in the first test case, she can include both 0 and 1, so MEX is 2.

In the second test case, she can include 0 and 1, but Bob can prevent her from including 1, making MEX=1.

Wait, no, in the second test case, she can include 0,1,2, but Bob can force MEX to be 1.

Wait, I'm getting confused.

Wait, perhaps I need to think in terms of the number of times each number appears.

Let me look at the frequency of each number.

In the first test case, n=4, a=[0,0,1,1].

Counts: 0:2, 1:2.

In the second test case, n=4, a=[0,1,2,3].

Counts: 0:1,1:1,2:1,3:1.

Third test case, n=2, a=[1,1].

Counts:1:2.

Now, looking at the output:

First test case: 2

Second test case:1

Third test case:0

Is there a pattern here based on the counts?

Let me think about it.

Suppose I look at the smallest i where count[i] is less than 2.

In the first test case, counts are 0:2,1:2.

There is no i where count[i] < 2, so MEX is 2.

In the second test case, counts are 0:1,1:1,2:1,3:1.

The smallest i where count[i] < 2 is i=0, since count[0]=1 < 2.

Wait, but the output is 1, not 0.

Wait, maybe it's the smallest i where count[i] <= t, where t is something.

Wait, perhaps it's the smallest i where count[i] is 0 or 1.

Wait, in the second test case, counts are all at least 1, but count[4]=0, but n=4, so MEX is 1.

Wait, I need to think differently.

Let me consider that Alice can choose to include elements in c, and Bob can choose to remove elements.

Alice wants to maximize the MEX, which means she wants c to have as many small integers as possible.

Bob wants to minimize the MEX, so he wants to prevent Alice from including certain small integers in c.

Each turn, Alice picks an element to add to c and removes it from a.

Bob just removes an element from a.

So, for each turn, Alice can choose what to add to c, and Bob can choose what to remove.

I need to find out, after all elements are removed, what is the MEX of c, assuming both play optimally.

Let me think about the frequency of each number.

If a number i appears only once in a, then:

- If Alice picks it, it goes to c.

- If Bob picks it, it's removed without going to c.

So, for numbers that appear only once, Alice can choose to include them in c or not.

Wait, no.

Wait, if a number appears only once:

- If Alice picks it, it goes to c.

- If Bob picks it, it's removed without going to c.

So, for numbers that appear only once, Alice can include them in c by choosing to pick them, or Bob can prevent them from being in c by picking them.

Similarly, for numbers that appear twice:

- Alice can pick one and include it in c, and the other can be picked by Bob or Alice.

Wait, it's getting complicated.

Maybe I need to think in terms of the number of times each number appears.

Let me consider that for each number i, if it appears at least twice, Alice can ensure that at least one of them makes it to c.

Because Alice can pick one to add to c, and Bob can pick the other, or Alice can pick the other one to add to c.

Wait, no.

Wait, if a number appears twice:

- Alice can pick one and add to c.

- Bob can pick the other one.

Or,

- Bob can pick one, and then Alice can pick the other one to add to c.

So, in either case, Alice can ensure that one of them makes it to c.

Similarly, if a number appears only once:

- Alice can choose to pick it and add it to c.

- Or Bob can pick it and remove it, so it doesn't go to c.

So, for numbers that appear at least twice, Alice can ensure that at least one makes it to c.

For numbers that appear only once, it's a fight between Alice and Bob whether it goes to c or not.

Now, since Alice goes first, and they alternate turns, the player who picks a particular number first decides its fate.

Wait, perhaps I need to think in terms of the total number of turns.

Total number of turns is n, since in each turn, one element is removed.

Alice starts, so she has floor((n+1)/2) turns, and Bob has floor(n/2) turns.

Wait, no.

Wait, in each pair of turns (Alice and Bob), two elements are removed.

Unless n is odd, in which case Alice has one more turn.

Wait, perhaps it's better to think in terms of the number of elements each player can affect.

Wait, perhaps I need to think in terms of the number of times each number appears.

Let me consider that for each number i, if it appears k times:

- If k >=2, Alice can ensure that at least one makes it to c.

- If k ==1, then Alice and Bob will fight over it.

So, for numbers that appear at least twice, Alice can ensure they are in c.

For numbers that appear only once, it depends on who picks them.

Alice wants to include as many small i as possible, especially the ones that appear only once.

Bob wants to prevent Alice from including them.

So, for numbers that appear only once, Alice needs to pick them to include in c, and Bob will try to pick them to prevent them from going to c.

So, for each number that appears only once, Alice and Bob will compete to pick it.

Given that Alice goes first, and they alternate turns, who gets to pick a particular number depends on the turn order.

Wait, perhaps I need to think in terms of the number of such numbers that appear only once.

Let me define:

- Let S be the set of numbers that appear only once in a.

- Let T be the set of numbers that appear at least twice in a.

Then, for numbers in T, Alice can ensure that at least one of them makes it to c.

For numbers in S, it's a competition between Alice and Bob to decide whether it goes to c or not.

Given that Alice starts, and they alternate turns, the player who picks a particular number from S decides whether it goes to c or not.

So, for each number in S, Alice can choose to pick it and include it in c, or Bob can pick it and remove it without including in c.

Now, since Alice goes first, she can prioritize picking the numbers from S that she wants in c, and Bob will pick the ones he wants to exclude from c.

So, in terms of the MEX, Alice wants to include as many small numbers from S as possible, while Bob wants to prevent that.

Wait, perhaps I need to think in terms of the number of available copies.

Wait, maybe it's better to think in terms of the frequency of each number.

Let me consider that for each number i from 0 to n-1, the number of times it appears in a is count[i].

Now, Alice wants to maximize the MEX, which is the smallest missing integer in c.

Bob wants to minimize it.

So, the MEX is determined by the smallest i that is not in c.

Therefore, Alice wants to include as many small i as possible in c, while Bob wants to prevent that.

Given that, for each i, if count[i] >=2, Alice can ensure that at least one copy of i is in c.

Because she can pick one to add to c, and Bob can pick the other, but Alice can still include one.

For count[i] ==1, it's a competition between Alice and Bob to decide whether i goes to c or not.

So, for i from 0 to n:

- If count[i] >=2, Alice can ensure i is in c.

- If count[i] ==1, Alice and Bob will compete over it.

- If count[i] ==0, i is not in a, so it's not in c.

So, the MEX would be the smallest i where:

- If count[i] >=1, it depends on whether Alice can include it in c.

- If count[i] ==0, MEX is i.

Wait, no.

Wait, if count[i] ==0, i is not in a, so it's not in c, so MEX could be i.

But Alice can't include i in c if it's not in a.

Wait, but the problem says that a contains elements from 0 to less than n, so all i from 0 to n-1 may or may not be present in a.

But MEX can be up to n, because c can contain elements from 0 to n-1.

Wait, no, MEX can be any non-negative integer, but since a contains elements from 0 to n-1, c will contain some subset of these, and MEX could be from 0 to n, or even higher if some higher numbers are included, but in this problem, since a contains elements up to n-1, c will contain elements up to n-1, so MEX will be from 0 to n.

Now, back to the strategy.

I need to find the smallest i such that:

- If count[i] >=2, Alice can include it in c.

- If count[i] ==1, it depends on who picks it.

- If count[i] ==0, it's not in a, so it's not in c.

So, the MEX will be the smallest i where:

- If count[i] ==0, MEX is i.

- If count[i] ==1, and Bob picks it, then it's not in c, so MEX is i.

- If count[i] >=2, it's in c, so MEX is greater than i.

So, I need to find the smallest i where either count[i] ==0 or (count[i] ==1 and Bob picks it).

But Bob wants to minimize MEX, so he will pick i where count[i] ==1 to prevent Alice from including it, starting from smallest i.

Alice wants to maximize MEX, so she will try to include as many small i as possible.

So, for each i from 0 to n-1:

- If count[i] >=2, it's in c.

- If count[i] ==1, Alice and Bob will compete over it.

So, I need to see who can pick which i with count[i] ==1.

Given that Alice starts, and they alternate turns, the player who picks i with count[i] ==1 decides whether it goes to c or not.

So, for each i with count[i] ==1, the player who picks it first can decide its fate.

So, Alice will try to pick i with count[i] ==1 to include in c, and Bob will try to pick i with count[i] ==1 to prevent them from going to c.

So, in terms of turn order, Alice gets to pick floor((number of elements)/2) +1 elements, since she starts first.

Wait, perhaps I need to think in terms of the number of elements that appear only once.

Let me define:

- Let s be the number of elements that appear only once, i.e., count[i] ==1.

- Let t be the number of elements that appear at least twice.

Then, total elements n = s + t.

Now, the game has n turns, Alice picks on turns 1,3,5,... and Bob picks on turns 2,4,6,...

So, Alice picks floor((n+1)/2) times, and Bob picks floor(n/2) times.

But in terms of the elements that appear only once, the first s elements that appear only once will be picked by Alice if s <= floor((n+1)/2), else some will be picked by Bob.

Wait, perhaps it's better to think in terms of which i with count[i] ==1 can Alice include in c.

Let me sort the i in increasing order.

Then, for each i from 0 to n-1:

- If count[i] >=2, Alice can include it in c.

- If count[i] ==1, then Alice and Bob will compete over it.

So, Alice wants to include as many small i with count[i] ==1 as possible, while Bob wants to prevent that.

Given that Alice starts, she can pick the smallest i with count[i] ==1 on her turns.

Bob can pick the smallest i with count[i] ==1 on his turns to prevent Alice from including it.

So, the question is, for each i with count[i] ==1, who picks it first, Alice or Bob.

Given that Alice starts, she picks first, then Bob, and so on.

So, for the first floor((s+1)/2) i with count[i] ==1, Alice can pick them and include them in c.

For the remaining ceil(s/2) i with count[i] ==1, Bob can pick them and prevent them from going to c.

Wait, perhaps more precisely:

- The players pick the elements in the order of the game.

- For elements with count[i] >=2, Alice can include one in c, and Bob can pick another one.

- For elements with count[i] ==1, the player who picks it decides whether it goes to c or not.

But it's getting too complicated.

Let me look at the provided code and see if I can understand its logic.

The code is:

from collections import defaultdict

def func():

for tc in range(int(input())):

N = int(input())

a = list(map(int, input().split()))

cnt = defaultdict(int)

for i in range(N):

cnt[a[i]] += 1

t = 0

for i in range(N):

if cnt[i] == 1:

t += 1

if t >= 2 or cnt[i] == 0:

print(i)

break

So, it reads the number of test cases, then for each test case:

- Reads n and the array a.

- Counts the frequency of each element in a.

- Initializes t=0.

- Then, iterates i from 0 to n-1:

- If cnt[i] ==1, increment t.

- If t >=2 or cnt[i] ==0, print i and break.

Wait, this seems too simplistic.

In the first test case:

n=4, a=[0,0,1,1]

counts: 0:2, 1:2

So, for i from 0 to 3:

i=0: cnt[0]=2 !=1, so t remains 0.

i=1: cnt[1]=2 !=1, t remains 0.

i=2: cnt[2]=0, so cnt[i]==0, print 2 and break.

Which matches the first output, 2.

Second test case:

n=4, a=[0,1,2,3]

counts: 0:1,1:1,2:1,3:1

i=0: cnt[0]=1, t=1 (t<2 and cnt[i]!=0)

i=1: cnt[1]=1, t=2 (t>=2), print 1 and break.

Which matches the second output, 1.

Third test case:

n=2, a=[1,1]

counts:1:2

i=0: cnt[0]=0, so print 0 and break.

Which matches the third output, 0.

So, in all three examples, this code produces the correct output.

Is this logic correct in general?

Let me try to understand what this code is doing.

It seems that it's looking for the smallest i where either:

- t >=2, where t is the number of indices with count[j]==1 encountered so far.

- Or cnt[i]==0.

Then, it prints i and stops.

So, in other words, it's finding the smallest i where either:

- At least two indices before i have count[j]==1, or

- count[i]==0.

Is this equivalent to the MEX that we need?

Wait, perhaps I need to see what t represents.

t is the count of indices j from 0 to i (inclusive?) where count[j]==1.

Wait, no, in the code, it's:

for i in range(N):

if cnt[i] ==1:

t +=1

if t >=2 or cnt[i]==0:

print(i)

break

So, t is the number of indices j from 0 to i where count[j]==1.

Then, if t >=2 or cnt[i]==0, print i and break.

So, for each i from 0 to n-1:

- If count[i]==1, increment t.

- If t >=2 or count[i]==0, print i and break.

So, it's printing the smallest i where either count[i]==0 or this is the second time count[j]==1 for j <=i.

Wait, t is the number of j <=i with count[j]==1.

So, when t >=2, it prints i.

Alternatively, if count[i]==0, it prints i.

So, it's finding the smallest i where either:

- There are at least two indices j <=i with count[j]==1, or

- count[i]==0.

Is this equivalent to the MEX in the game?

Let me think about it.

From the examples:

First test case: counts 0:2,1:2.

So, for i=0: count[0]=2 !=1, t=0.

i=1: count[1]=2 !=1, t=0.

i=2: count[2]=0, so print 2.

Second test case: counts 0:1,1:1,2:1,3:1.

i=0: count[0]=1, t=1.

i=1: count[1]=1, t=2, t>=2, print 1.

Third test case: counts 0:0,1:2.

i=0: count[0]=0, print 0.

Another test case:

n=5, a=[0,1,2,2,3]

counts:0:1,1:1,2:2,3:1.

So, t= number of j<=i with count[j]==1.

i=0: count[0]=1, t=1.

i=1: count[1]=1, t=2, t>=2, print 1.

But according to the game, what should be the MEX?

Let's see:

a=[0,1,2,2,3]

Possible game:

Alice picks 0, c=[0], a=[1,2,2,3]

Bob picks 1, a=[2,2,3]

Alice picks 2, c=[0,2], a=[2,3]

Bob picks 2, a=[3]

Alice picks 2, c=[0,2,2], a=[3]

Bob picks 3, a=[]

c=[0,2,2], MEX is 1.

Alternatively:

Alice picks 2, c=[2], a=[0,1,2,3]

Bob picks 2, a=[0,1,3]

Alice picks 0, c=[2,0], a=[1,3]

Bob picks 1, a=[3]

Alice picks 3, c=[2,0,3], a=[]

c=[2,0,3], MEX is 1.

Another possible game:

Alice picks 3, c=[3], a=[0,1,2,2]

Bob picks 0, a=[1,2,2]

Alice picks 1, c=[3,1], a=[2,2]

Bob picks 2, a=[2]

Alice picks 2, c=[3,1,2], a=[]

c=[3,1,2], MEX is 0.

But in this case, MEX is 0.

Wait, but according to the code, it would output 1, because:

counts:0:1,1:1,2:2,3:1.

t=0

i=0: count[0]=1, t=1

i=1: count[1]=1, t=2, t>=2, print 1.

But in the game, MEX can be 0.

So, is the code correct?

Wait, but in the game, Bob can force MEX to be 1, as in the example above, one possible game has MEX=1.

But there is another possible game where MEX=0.

So, perhaps Bob cannot always force MEX=1, sometimes MEX=0 is possible.

Wait, I'm getting confused.

Wait, perhaps I need to think differently.

Let me consider that Alice can include all i with count[i]>=2 in c.

For i with count[i]==1, Alice and Bob compete over it.

Alice wants to include as many small i with count[i]==1 as possible.

Bob wants to prevent as many small i with count[i]==1 from being included in c.

Given that Alice starts, and they alternate turns.

So, for each i with count[i]==1, the player who picks it first decides whether it goes to c or not.

So, for the smallest i with count[i]==1, Alice can choose to include it in c, since she picks first.

Then, for the next i with count[i]==1, Bob can choose to prevent it from going to c.

Then, for the next i with count[i]==1, Alice can include it, and so on.

So, in general, Alice can include ceil(s/2) number of i with count[i]==1, where s is the number of such i.

Wait, perhaps more precisely:

- The players pick the elements in turns, Alice first.

- For elements with count[i]>=2, Alice can include one in c.

- For elements with count[i]==1, the player who picks it decides whether it goes to c or not.

So, for i with count[i]>=2, Alice can include one in c, regardless of Bob's actions.

For i with count[i]==1, it depends on who picks it first.

Since Alice starts, she can pick the smallest i with count[i]==1 and include it in c.

Then Bob picks the next smallest i with count[i]==1 and removes it.

Then Alice picks the next one and includes it in c, and so on.

So, in the end, Alice can include ceil(s/2) of the i with count[i]==1 in c.

Hence, the smallest i that is not included in c is the smallest i where:

- count[i]==0, or

- count[i]==1 and it's among the floor(s/2) smallest i with count[i]==1 that Bob picks to prevent from being in c.

Wait, perhaps I need to find the smallest i where:

- count[i]==0, or

- count[i]==1 and it's among the floor(s/2) smallest i with count[i]==1.

Wait, but I need to confirm this.

Let me consider the earlier test case:

n=5, a=[0,1,2,2,3]

counts:0:1,1:1,2:2,3:1.

s= number of i with count[i]==1: 0,1,3 -> s=3.

Alice can include ceil(3/2)=2 of them in c.

So, she can include two of 0,1,3.

Bob can prevent floor(3/2)=1 of them from being in c.

So, the smallest i that is not in c would be the smallest among the ones that Bob prevents, which is i=1.

Wait, but in the game, MEX can be 0.

Wait, perhaps I need to think differently.

Wait, maybe the MEX is the smallest i where:

- If count[i]>=2, it's in c.

- If count[i]==1, it's in c if Alice picks it, else not.

So, the MEX is the smallest i where:

- count[i]==0, or

- count[i]==1 and Bob picks it.

Given that Alice can include ceil(s/2) of the i with count[i]==1, and Bob can prevent floor(s/2) of them.

Hence, the smallest i that Bob can prevent from being in c is the floor(s/2)th smallest i with count[i]==1.

Wait, perhaps I need to sort the i with count[i]==1, and assign the first ceil(s/2) to Alice and the next floor(s/2) to Bob.

Hence, the smallest i that Bob can prevent is the ceil(s/2)th smallest i with count[i]==1.

So, the MEX would be the minimum of:

- The smallest i with count[i]==0,

- The ceil(s/2)th smallest i with count[i]==1.

Wait, perhaps.

Let me try with the earlier test case.

n=5, a=[0,1,2,2,3]

counts:0:1,1:1,2:2,3:1.

s=3.

ceil(3/2)=2.

So, Alice can include the smallest 2 i with count[i]==1: 0 and 1.

Bob can prevent the next one, which is 3.

Hence, c would contain 0 and 1, and 3 is not in c.

So, MEX would be 2.

Wait, but earlier I saw that MEX can be 0 or 1, depending on the game.

Wait, perhaps my assumption is wrong.

I need to think differently.

Let me look back at the provided code.

The code is:

for i in range(N):

if cnt[i]==1:

t +=1

if t>=2 or cnt[i]==0:

print(i)

break

Wait, but in the earlier test case, n=5, a=[0,1,2,2,3], counts:0:1,1:1,2:2,3:1.

So, for i=0: cnt[0]=1, t=1, t<2 and cnt[i]!=0, continue.

i=1: cnt[1]=1, t=2, t>=2, print 1 and break.

So, according to the code, output is 1.

But in the game, MEX can be 0 or 1, depending on how they play.

But according to the code, it's 1.

Is the code correct?

Wait, perhaps the code is finding the minimal i where either:

- There are at least two indices j<i with count[j]==1, or

- count[i]==0.

Is this equivalent to the MEX in the game?

Wait, perhaps.

Let me think.

If there are at least two indices j<i with count[j]==1, then t>=2, and the code prints i.

Alternatively, if count[i]==0, it prints i.

So, in the first test case, counts:0:2,1:2.

i=0: cnt[0]=2 !=1, t=0.

i=1: cnt[1]=2 !=1, t=0.

i=2: cnt[2]=0, print 2.

In this case, MEX is 2, which matches.

Second test case: counts:0:1,1:1,2:1,3:1.

i=0: cnt[0]=1, t=1.

i=1: cnt[1]=1, t=2, t>=2, print 1.

MEX is 1, which matches.

Third test case: counts:1:2.

i=0: cnt[0]=0, print 0.

MEX is 0, which matches.

Another test case: n=3, a=[0,0,1]

counts:0:2,1:1.

i=0: cnt[0]=2 !=1, t=0.

i=1: cnt[1]=1, t=1.

i=2: cnt[2]=0, print 2.

But in the game:

Possible game:

Alice picks 0, c=[0], a=[0,1]

Bob picks 0, a=[1]

Alice picks 1, c=[0,1], a=[]

c=[0,1], MEX=2.

Another game:

Alice picks 1, c=[1], a=[0,0]

Bob picks 0, a=[0]

Alice picks 0, c=[1,0], a=[]

c=[0,1], MEX=2.

So, MEX is 2.

According to the code:

counts:0:2,1:1.

i=0: cnt[0]=2 !=1, t=0.

i=1: cnt[1]=1, t=1.

i=2: cnt[2]=0, print 2.

Which matches.

Another test case: n=1, a=[0]

counts:0:1.

i=0: cnt[0]=1, t=1, t>=2? No.

i=1: cnt[1]=0, print 1.

But in the game:

Alice picks 0, c=[0], a=[]

MEX is 1.

So, code prints 1, which matches.

Another test case: n=3, a=[0,1,1]

counts:0:1,1:2.

i=0: cnt[0]=1, t=1.

i=1: cnt[1]=2 !=1, t=1.

i=2: cnt[2]=0, print 2.

In the game:

Alice picks 0, c=[0], a=[1,1]

Bob picks 1, a=[1]

Alice picks 1, c=[0,1], a=[]

c=[0,1], MEX=2.

Which matches.

Another test case: n=6, a=[0,0,1,1,2,2]

counts:0:2,1:2,2:2.

i=0: cnt[0]=2 !=1, t=0.

i=1: cnt[1]=2 !=1, t=0.

i=2: cnt[2]=2 !=1, t=0.

i=3: cnt[3]=0, print 3.

In the game:

Alice can include 0,1,2 in c.

c=[0,1,2], MEX=3.

Which matches.

Seems consistent.

Another test case: n=2, a=[0,1]

counts:0:1,1:1.

i=0: cnt[0]=1, t=1.

i=1: cnt[1]=1, t=2, t>=2, print 1.

In the game:

Alice picks 0, c=[0], a=[1]

Bob picks 1, a=[]

c=[0], MEX=1.

Alternatively:

Alice picks 1, c=[1], a=[0]

Bob picks 0, a=[]

c=[1], MEX=0.

So, MEX can be 0 or 1.

But according to the code, it's 1.

Is this the minimal MEX Bob can force?

Wait, Bob can force MEX to be 1 by picking 1, preventing Alice from including it.

But in one scenario, MEX is 0.

So, perhaps the code is finding the minimal i where t>=2 or cnt[i]==0, but in reality, the MEX can be lower.

So, perhaps the code is incorrect.

Wait, but in this test case, the code outputs 1, and in the game, MEX can be 0 or 1.

So, is the minimal possible MEX 0, but Bob wants to minimize it, so it's 0.

But according to the code, it's 1.

So, perhaps the code is incorrect.

Wait, but in the earlier test cases, it matched.

Wait, perhaps I need to think differently.

Wait, perhaps the code is finding the minimal i where:

- There are at least two indices j<i with count[j]==1, or

- count[i]==0.

And this corresponds to the minimal MEX that Bob can force.

Wait, perhaps it's the minimal i where:

- count[i]==0, or

- count[i]==1 and there are at least two indices j<i with count[j]==1.

But in the test case n=2, a=[0,1], counts:0:1,1:1.

i=0: cnt[0]=1, t=1.

i=1: cnt[1]=1, t=2, t>=2, print 1.

But in the game, MEX can be 0, which is lower than 1.

So, according to the code, it's 1, but in reality, MEX can be 0.

Hence, the code is incorrect.

Wait, but in the earlier test cases, it matched.

Maybe it's just luck.

Wait, in the first test case, n=4, a=[0,0,1,1], counts:0:2,1:2.

Code prints 2, which matches the MEX=2.

Second test case, n=4, a=[0,1,2,3], counts:0:1,1:1,2:1,3:1.

Code prints 1, and in the game, MEX can be 1.

Third test case, n=2, a=[1,1], counts:1:2.

Code prints 0, which matches MEX=0.

Fourth test case, n=5, a=[0,1,2,2,3], counts:0:1,1:1,2:2,3:1.

Code prints 1, and in the game, MEX can be 0 or 1.

So, in this case, the code is printing 1, but MEX can be 0.

Hence, the code is incorrect.

So, perhaps I need to find a better way.

Let me try to find a general solution.

I need to find the minimal MEX that Bob can force, given that Alice wants to maximize it.

So, in other words, find the minimal MEX over all possible plays where Alice tries to maximize MEX and Bob tries to minimize it.

This is a minimax problem.

To solve this, I need to find the minimal MEX that Bob can achieve despite Alice's efforts to maximize it.

So, I need to find, for each i from 0 to n, whether Bob can force that i is not in c, while making sure that all j<i are in c.

Wait, no.

Actually, MEX is the smallest i not in c.

So, I need to find the smallest i that is not in c, considering that Alice tries to include as many small i as possible, and Bob tries to prevent them.

Given that, perhaps I can think in terms of the number of times each i appears.

For each i:

- If count[i] >=2, Alice can ensure that i is in c.

- If count[i] ==1, Alice and Bob compete over it.

- If count[i] ==0, i is not in c.

So, for i from 0 to n-1:

- If count[i] >=2, it's in c.

- If count[i] ==1, Alice can include it if she picks it before Bob picks it.

Given that Alice starts, and they alternate turns, the player who picks i first decides whether it goes to c or not.

So, for each i with count[i]==1, the player who picks it first decides its fate.

So, to maximize MEX, Alice wants to include as many small i with count[i]==1 as possible.

Bob wants to prevent as many small i with count[i]==1 from being included in c.

Given that Alice starts, she can pick the smallest i with count[i]==1 and include it in c.

Then, Bob can pick the next smallest i with count[i]==1 and prevent it from going to c.

Then, Alice can pick the next one and include it, and so on.

Hence, Alice can include ceil(s/2) of the i with count[i]==1, where s is the number of such i.

Bob can prevent floor(s/2) of them.

So, the smallest i that is not in c would be the floor(s/2)+1 th smallest i with count[i]==1.

Wait, perhaps more precisely:

- Sort the i with count[i]==1 in increasing order: i1,i2,...,is.

- Alice can include the first ceil(s/2) of them in c.

- Bob can prevent the next floor(s/2) of them from being in c.

Hence, the smallest i not in c would be the ceil(s/2)+1 th i with count[i]==1, if it exists.

Otherwise, it would be the smallest i with count[i]==0.

Wait, perhaps I need to think in terms of who picks which i with count[i]==1.

Given that Alice starts, she can pick the smallest i with count[i]==1 and include it in c.

Then, Bob picks the next smallest i with