Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of length 2n, and it contains each integer from 1 to n exactly twice. Then there's an integer k, and I need to find two arrays, l and r, each of length 2k. 

Specifically:

- l should be a subset of the first n elements of the array (a1 to an).

- r should be a subset of the last n elements of the array (a_{n+1} to a_{2n}).

- The bitwise XOR of elements in l should be equal to the bitwise XOR of elements in r.

Also, it's guaranteed that at least one such pair exists, and I can output any one of them if there are multiple solutions.

First, I need to understand what a subset means here. It says that a subset can be obtained by deleting several elements from the sequence and rearranging them in any order. So, essentially, l and r are any collections of 2k elements from the first n and last n elements, respectively, but maintaining the order is not necessary.

My goal is to select 2k elements from the first n and 2k from the last n such that the XOR of the elements in both subsets is the same.

Given that each number from 1 to n appears exactly twice in the entire array, that means in the first n elements, some numbers from 1 to n appear once, and some appear twice, but since the total count for each number is twice, in the last n elements, the remaining instances of those numbers will be present.

Wait, no. Since each number appears exactly twice in the entire array, and the array is divided into two parts of n elements each, it's possible that some numbers appear once in the first n and once in the last n, or twice in one part and not at all in the other, but the problem says that each integer from 1 to n occurs exactly twice in a.

But the constraints say that each integer from 1 to n occurs exactly twice in a, so it's guaranteed that for each number from 1 to n, there are exactly two occurrences in the entire array.

My initial thought is that since XOR is associative and commutative, the order in which we XOR the elements doesn't matter, and XORing a number with itself results in zero.

Given that, if I can pair up elements in l and r such that their XORs cancel out, that might lead to a solution.

But I need to select subsets l and r each of size 2k, and their XORs should be equal.

An idea: since XOR is involved, and we're dealing with subsets of even size (2k), perhaps there's a way to balance the XOR values between l and r.

Wait, another thought: since each number appears exactly twice, and I need to choose 2k elements from the first n and 2k from the last n, maybe I can exploit the fact that choosing both copies of a number would result in their XOR being zero, which might help in balancing the overall XOR.

But I need to ensure that the XOR of l equals the XOR of r.

Let me consider a simple case. Suppose n=2 and k=1, with the array being [1,2,2,1]. So, first n elements are [1,2], last n elements are [2,1]. I need to choose 2 elements from the first n and 2 from the last n such that their XORs are equal.

Choosing l = [1,2], XOR is 1 XOR 2 = 3.

Choosing r = [2,1], XOR is 2 XOR 1 = 3.

So, they match.

Another example: n=6, k=1, array=[6,4,2,1,2,3,1,6,3,5,5,4].

First n elements: [6,4,2,1,2,3]

Last n elements: [1,6,3,5,5,4]

Need to choose 2 elements from the first n and 2 from the last n with equal XOR.

In the example, l=[6,4], XOR is 6 XOR 4 = 2.

r=[1,3], XOR is 1 XOR 3 = 2.

So, they match.

Another case: n=4, k=1, array=[1,2,3,4,1,2,3,4].

First n: [1,2,3,4]

Last n: [1,2,3,4]

Choose l=[1,2], XOR is 1 XOR 2 = 3.

Choose r=[1,2], XOR is 1 XOR 2 = 3.

Matches.

Last example: n=6, k=2, array=[5,1,3,3,5,1,2,6,4,6,4,2].

First n: [5,1,3,3,5,1]

Last n: [2,6,4,6,4,2]

Choose l=[5,1,3,3], XOR is 5 XOR 1 XOR 3 XOR 3 = (5 XOR 1) XOR (3 XOR 3) = 4 XOR 0 = 4.

Choose r=[6,4,2,4], XOR is 6 XOR 4 XOR 2 XOR 4 = (6 XOR 4 XOR 4) XOR 2 = (6 XOR 0) XOR 2 = 6 XOR 2 = 4.

So, they match.

From these examples, it seems that choosing pairs of identical elements could be a strategy, since XORing two identical numbers results in zero, which can help in balancing the overall XOR.

But in the general case, how can I ensure that the XOR of l equals the XOR of r?

Wait, another approach: since I need l and r to have the same XOR, that means XOR of l XOR of r should be zero, which is equivalent to XOR of (l XOR r) = 0.

But I need to choose l and r such that their XORs are equal.

Given that, perhaps I can select certain elements to make sure that the XORs match.

Let me think about the properties of XOR.

XOR is associative, commutative, and has the property that a XOR a = 0.

Given that each number appears exactly twice in the entire array, in the first n and last n elements, the distribution of these numbers affects their presence in l and r.

Wait, perhaps I can look at the XOR of all elements in the first n and the XOR of all elements in the last n.

Let me denote:

- XOR_lft = XOR of all elements in the first n elements.

- XOR_rgt = XOR of all elements in the last n elements.

Since the entire array's XOR would be XOR_lft XOR XOR_rgt, but given that each number appears exactly twice, the XOR of the entire array is zero (since each pair a XOR a = 0, and XOR is associative and commutative).

Therefore, XOR_lft XOR XOR_rgt = 0, which implies that XOR_lft = XOR_rgt.

That's an important observation.

So, the XOR of the first n elements is equal to the XOR of the last n elements.

Given that, perhaps I can use this property to select subsets l and r.

I need to choose subsets l and r, each of size 2k, such that XOR_l = XOR_r.

Given that XOR_lft = XOR_rgt, maybe I can select elements in such a way that the remaining elements in both halves have the same XOR.

Wait, perhaps I need to think in terms of selecting pairs of elements.

Another idea: since each number appears exactly twice, I can group the elements into pairs where each pair consists of the two occurrences of the same number.

Given that, I can think of the first n and last n elements as containing these pairs, possibly split across the two halves.

Wait, but the problem allows for subsets that are obtained by deleting some elements and rearranging the remaining ones, as long as they are subsets of the first n and last n elements, respectively.

Given that, perhaps I can think in terms of selecting certain pairs or elements to include in l and r.

But I need a systematic way to select l and r such that their XORs are equal.

Let me consider the following approach:

1. Identify pairs of identical elements, one in the first n and one in the last n.

2. Select k such pairs, and include both elements of each pair in either l or r.

Wait, but l has to be a subset of the first n, and r a subset of the last n.

So, if I have a pair where one element is in the first n and the other in the last n, I can include one in l and one in r.

But I need to select 2k elements for l and 2k for r.

Wait, perhaps I need to select k pairs, each consisting of two identical elements, one in the first n and one in the last n, and include one element from each pair in l and the other in r.

But then, the XOR of l and r would be the same because they contain the same elements, just from different halves.

Wait, no. If I have a pair (a, a), with one a in the first n and one in the last n, and I include one a in l and the other in r, then l and r would both have that a, so their XOR would both include a, but I need to select 2k elements for each.

Wait, perhaps I need to select k such pairs and include both elements of each pair in l or r.

But that would mean selecting 2k elements from the first n and 2k from the last n, but ensuring that the XORs match.

Wait, perhaps that's not the right way.

Let me try a different approach.

Since XOR_lft = XOR_rgt, and I need to select subsets l and r from the first n and last n respectively, each of size 2k, with XOR_l = XOR_r.

I can think of it as selecting subsets l and r such that the XOR of l and the XOR of r are equal.

Given that, perhaps I can select l and r such that the XOR of the remaining elements in the first n and last n are also equal.

Because XOR_lft = XOR_l XOR XOR_{l_remainder}, and similarly XOR_rgt = XOR_r XOR XOR_{r_remainder}.

But since XOR_lft = XOR_rgt, and I need XOR_l = XOR_r, then it follows that XOR_{l_remainder} = XOR_{r_remainder}.

So, the problem seems to have a symmetric property.

But I need a constructive way to select l and r.

Let me consider the following plan:

- Find a set of elements to include in l and r such that their XORs are equal.

- Since XOR is involved, maybe I can look for elements that can balance each other's bits.

But that seems too vague.

An alternative approach: since the problem states that at least one solution exists, and given the constraints, perhaps there's a straightforward way to select elements.

Looking back at the examples:

In the first example, n=2, k=1, array=[1,2,2,1]. Chose l=[2,1], r=[2,1].

In the second example, n=6, k=1, array=[6,4,2,1,2,3,1,6,3,5,5,4]. Chose l=[6,4], r=[1,3].

In the third example, n=4, k=1, array=[1,2,3,4,1,2,3,4]. Chose l=[1,2], r=[1,2].

In the fourth example, n=6, k=2, array=[5,1,3,3,5,1,2,6,4,6,4,2]. Chose l=[5,1,3,3], r=[6,4,2,4].

Looking at these, it seems that in some cases, choosing matching pairs works, while in others, choosing elements that have the same XOR value.

Wait, perhaps I can look at the frequency of elements in the first n and last n.

Let me consider counting how many times each number appears in the first n and last n.

Given that each number appears exactly twice in the entire array, for each number, it can appear:

- Twice in the first n.

- Twice in the last n.

- Once in the first n and once in the last n.

I need to consider these cases.

Let me denote for each number i from 1 to n:

- cnt_lft[i]: number of times i appears in the first n elements.

- cnt_rgt[i]: number of times i appears in the last n elements.

Given that, cnt_lft[i] + cnt_rgt[i] = 2 for all i from 1 to n.

Now, I need to select 2k elements from the first n and 2k from the last n such that the XOR of selected elements in both subsets is equal.

An idea: since XOR is involved, perhaps I can group elements into sets where their XOR cancels out.

Wait, perhaps I can select elements in such a way that the XOR of l and r are equal by balancing the contributions of each bit.

But that seems complicated.

An alternative idea: since XOR_lft = XOR_rgt, perhaps I can select subsets l and r such that the XOR of l is equal to the XOR of r, which should be equal to some value, and the remaining elements in both halves have the same XOR.

But I need a more concrete plan.

Let me consider selecting elements for l and r in a way that their XORs are equal.

One possible way is to select pairs of elements that have the same XOR value.

Wait, perhaps I can look at the XOR of pairs and try to match them.

But that seems too vague.

Let me consider another angle.

Suppose I select some elements for l and corresponding elements for r such that their XORs match.

But I need a systematic way to do this.

Wait, perhaps I can look at the difference in XOR if I include or exclude certain elements.

This seems too involved.

Let me consider a different approach.

Given that the problem guarantees at least one solution exists, and given the constraints, perhaps there's a simple way to select elements.

Looking back at the examples, in some cases, they choose both copies of certain numbers in l and r.

Wait, perhaps I can select k pairs of identical elements, one from the first n and one from the last n, and include them in l and r respectively.

But I need to ensure that the total number of elements in l and r is 2k each.

Wait, perhaps I can select k pairs of identical elements, with one from the first n and one from the last n, and include both elements of each pair in l and r.

But that would mean selecting 2k elements for l and 2k for r, with each pair contributing two elements to l and r.

Wait, no. If I have a pair (a, a), with one a in the first n and one in the last n, I can include a in l and a in r.

But then l would have k elements, and r would have k elements, but I need 2k elements each.

Wait, that doesn't match the required subset sizes.

So, perhaps that's not the right way.

Wait, maybe I need to select 2k elements by possibly including multiple elements from the same number's copies.

Wait, but each number appears only twice, so I have to be careful not to exceed the available copies.

Wait, actually, since each number appears exactly twice in the entire array, and I have to select from the first n and last n, I need to respect the distribution.

This is getting complicated.

Let me think differently.

Suppose I select a subset l from the first n elements and r from the last n elements, each of size 2k, such that the XOR of l equals the XOR of r.

Given that, perhaps I can iterate through the possible selections and check their XORs, but that's not efficient.

Given the constraints, n can be up to 5*10^4, and t up to 5000, so I need an efficient solution.

I need a better approach.

Let me consider the following plan:

1. Compute the XOR of all elements in the first n elements: XOR_lft.

2. Compute the XOR of all elements in the last n elements: XOR_rgt.

As previously noted, XOR_lft equals XOR_rgt.

2. Select 2k elements from the first n for l and 2k elements from the last n for r such that XOR_l = XOR_r.

3. Since XOR_lft = XOR_l XOR XOR_{l_remainder}, and similarly XOR_rgt = XOR_r XOR XOR_{r_remainder}, and XOR_lft = XOR_rgt, then XOR_l XOR XOR_{l_remainder} = XOR_r XOR XOR_{r_remainder}.

4. Given that XOR_l = XOR_r, then XOR_{l_remainder} = XOR_{r_remainder}.

So, selecting subsets l and r such that their XORs are equal is equivalent to selecting subsets such that the XOR of the remaining elements in both halves are also equal.

This seems like a symmetric requirement.

But I still need a way to construct such subsets.

Let me consider selecting elements for l and r in pairs.

Wait, perhaps I can group the elements into pairs where one element is from the first n and the other is from the last n, and they are the same number.

Given that, for each number that appears once in the first n and once in the last n, I can form a pair.

For numbers that appear twice in the first n or twice in the last n, I need to handle them differently.

Wait, perhaps I can categorize the numbers based on their distribution between the first n and last n.

Let me define:

- For each number i from 1 to n:

- If i appears once in the first n and once in the last n.

- If i appears twice in the first n and not in the last n.

- If i appears twice in the last n and not in the first n.

Wait, but since each number appears exactly twice in the entire array, the third case isn't possible.

So, for each number i:

- It can appear:

- Once in the first n and once in the last n.

- Twice in the first n.

- Twice in the last n.

Given that, I can count how many numbers fall into each category.

Let me denote:

- cnt_both: numbers that appear once in the first n and once in the last n.

- cnt_lft: numbers that appear twice in the first n.

- cnt_rgt: numbers that appear twice in the last n.

Given that, cnt_both + cnt_lft + cnt_rgt = n.

But since each number appears exactly twice, and cnt_both counts numbers that are split across the two halves, while cnt_lft and cnt_rgt count numbers that are entirely in one half.

Wait, actually, cnt_both counts the numbers that appear once in each half, so the total count for such numbers is exactly two, one in each half.

Similarly, cnt_lft counts numbers that appear twice in the first n, and cnt_rgt counts numbers that appear twice in the last n.

Given that, cnt_both + cnt_lft + cnt_rgt = n.

Now, I need to select 2k elements from the first n for l and 2k from the last n for r, such that the XOR of l equals the XOR of r.

An idea: select k pairs from the numbers that have both copies in the first n or both in the last n, and handle the numbers that have one copy in each half separately.

Wait, perhaps I can use the numbers that appear twice in one half to form pairs in l or r.

Let me think about selecting pairs of identical elements.

If I select two identical elements in l, their XOR is zero, which doesn't affect the overall XOR.

Similarly for r.

So, selecting pairs of identical elements in l or r effectively removes their contribution to the XOR.

Given that, perhaps I can select such pairs to balance the XOR.

Let me consider the following approach:

- For numbers that appear twice in the first n, I can select both copies for l, which would contribute XOR zero to l.

- Similarly, for numbers that appear twice in the last n, I can select both copies for r, which would contribute XOR zero to r.

- For numbers that appear once in the first n and once in the last n, I need to decide how to include them in l and r.

Wait, perhaps I can select pairs of identical elements to include in l or r to make their XORs match.

But I need to ensure that the total number of elements in l and r is exactly 2k each.

Let me try to formalize this.

Let me denote:

- Let S be the set of numbers that appear once in the first n and once in the last n.

- Let L be the set of numbers selected for l.

- Let R be the set of numbers selected for r.

Given that, for numbers in S, one copy is in the first n and one in the last n.

For numbers not in S (i.e., they appear twice in the first n or twice in the last n), both copies are in the first n or both are in the last n.

My goal is to select subsets l and r such that the XOR of elements in l equals the XOR of elements in r.

An idea: select k pairs of identical elements, where each pair is either from the first n or from the last n, and include them in l or r accordingly.

Wait, but selecting a pair of identical elements in l or r would contribute XOR zero, which might help in balancing the overall XOR.

But I need to ensure that the total number of elements is 2k in both l and r.

Wait, perhaps I can select some pairs to include in l and some in r, and also include some elements from S in a way that their XORs match.

This is getting complicated.

Let me consider the following plan:

1. Identify numbers that appear twice in the first n. For each such number, including both copies in l would add XOR zero to l.

2. Similarly, for numbers that appear twice in the last n, including both copies in r would add XOR zero to r.

3. For numbers that appear once in the first n and once in the last n, I need to include one in l and one in r.

Given that, perhaps I can select k such numbers from S and include one copy in l and one in r.

But then, l would have k elements from S and r would have k elements from S.

But I need 2k elements in l and 2k in r.

Wait, so I need to select 2k elements in l and 2k in r.

So, perhaps I can select k pairs of identical elements from the first n and include both in l, and select k pairs of identical elements from the last n and include both in r.

But, if I do that, l would have 2k elements (k pairs, each pair contributing two identical elements), and r would have 2k elements similarly.

Then, the XOR of l would be the XOR of k pairs, each contributing XOR zero, so XOR_l = 0.

Similarly, XOR_r = 0.

So, in this case, XOR_l = XOR_r = 0.

But, depending on the distribution of the numbers, this might not be possible, or it might not satisfy the required subset conditions.

Wait, but in the examples, sometimes the XOR is not zero.

So, perhaps selecting only pairs of identical elements is not sufficient in all cases.

Wait, perhaps I need to select some pairs and some single elements in a way that their XORs match.

This seems tricky.

Let me think differently.

Suppose I select a subset of numbers from S, say a subset T of S, and include one copy from the first n in l and one copy from the last n in r.

Then, the XOR of l would include the XOR of these selected elements from the first n, and the XOR of r would include the XOR of the corresponding elements from the last n.

Since the elements are identical, the XOR of these selected elements in l and r would be the same if I include the same numbers in both l and r.

Wait, but the elements are identical, so including the same number in l and r would make their XOR equal.

But I need to select 2k elements for l and 2k for r.

So, if I select k numbers from S, include one copy in l and one in r, that would give me k elements in l and k elements in r.

But I need 2k elements in each.

So, I need to select additional elements to reach 2k in both l and r.

Perhaps I can select pairs of identical elements from the first n and include both in l, and similarly select pairs of identical elements from the last n and include both in r.

Each such pair would contribute XOR zero to l or r.

So, if I select m such pairs in l and m such pairs in r, that would add zero to both XOR_l and XOR_r.

Then, combining with the k elements from S, the total XOR would be the XOR of the k elements from S in l and the XOR of the k elements from S in r.

Since the elements from S are identical but from different halves, their XOR values in l and r should be the same.

Wait, no. If I include one copy in l and the other in r, and if the elements are identical, then XOR_l would have the XOR of these k elements, and XOR_r would have the XOR of the same k elements, so XOR_l = XOR_r.

Then, adding the XOR zero from the pairs, the total XOR_l would still equal XOR_r.

So, this seems like a possible solution.

Let me formalize this:

- Select m pairs of identical elements from the first n, include both in l. This adds XOR zero to l.

- Select m pairs of identical elements from the last n, include both in r. This adds XOR zero to r.

- Select k numbers from S, include one copy from the first n in l and one copy from the last n in r.

- Then, XOR_l = XOR of the k selected elements from S.

- XOR_r = XOR of the same k selected elements from S.

- Therefore, XOR_l = XOR_r.

- The total number of elements in l is 2m + k.

- The total number of elements in r is 2m + k.

- We need 2m + k = 2k, which implies m = k/2.

But k can be odd, and m has to be integer, so this might not work if k is odd.

Wait, but k is given such that 1 ≤ k ≤ floor(n/2), and n can be up to 5*10^4, so k can be odd.

So, this approach has a flaw.

Wait, perhaps I need to adjust the number of pairs I select.

Let me think differently.

Suppose I select p pairs of identical elements from the first n and include both in l, contributing XOR zero to l.

Similarly, select q pairs of identical elements from the last n and include both in r, contributing XOR zero to r.

Then, select r numbers from S, include one copy in l and one in r.

Then, the total XOR_l = XOR of r selected elements from S.

Total XOR_r = XOR of r selected elements from S.

So, XOR_l = XOR_r.

And the total number of elements in l is 2p + r.

Similarly, in r, it's 2q + r.

We need 2p + r = 2k and 2q + r = 2k.

So, 2p + r = 2q + r = 2k.

This implies that 2p + r = 2q + r, which implies p = q.

So, p = q.

Let’s set p = q.

Then, 2p + r = 2k ⇒ r = 2k - 2p.

Since r has to be non-negative, 2k - 2p ≥ 0 ⇒ p ≤ k.

Also, r has to be an integer, which it is, since p is integer.

So, for a given p (0 ≤ p ≤ k), set r = 2k - 2p.

Then, select p pairs from the first n, include both in l.

Select p pairs from the last n, include both in r.

Select r = 2k - 2p numbers from S, include one copy in l and one in r.

Then, XOR_l = XOR of r selected numbers from S.

XOR_r = XOR of the same r selected numbers from S.

Hence, XOR_l = XOR_r.

This seems to work.

Now, I need to ensure that there are enough pairs to select.

Let me denote:

- Let cnt_lft_pair be the number of numbers that appear twice in the first n.

- Let cnt_rgt_pair be the number of numbers that appear twice in the last n.

- Let cnt_both be the number of numbers that appear once in the first n and once in the last n.

Given that, cnt_lft_pair + cnt_both = n.

Similarly, cnt_rgt_pair + cnt_both = n.

Because each number appears exactly twice.

Wait, no.

Wait, for each number, it can appear:

- Twice in the first n: cnt_lft_pair.

- Twice in the last n: cnt_rgt_pair.

- Once in the first n and once in the last n: cnt_both.

So, cnt_lft_pair + cnt_both = n.

Similarly, cnt_rgt_pair + cnt_both = n.

Wait, but cnt_both counts numbers that appear once in each half, so total count for such numbers is cnt_both.

While cnt_lft_pair counts numbers that appear twice in the first n, and cnt_rgt_pair counts numbers that appear twice in the last n.

Given that, the total number of unique numbers is n, so:

cnt_lft_pair + cnt_rgt_pair + cnt_both = n.

Wait, no.

Wait, actually, for each number that appears twice in the first n, it's cnt_lft_pair.

For each number that appears twice in the last n, it's cnt_rgt_pair.

For each number that appears once in the first n and once in the last n, it's cnt_both.

So, cnt_lft_pair + cnt_rgt_pair + cnt_both = n.

Yes, that's correct.

Now, to select p pairs from the first n, I need p ≤ cnt_lft_pair.

Similarly, p ≤ cnt_rgt_pair.

And r = 2k - 2p ≤ cnt_both.

Since r has to be non-negative, p ≤ k.

So, p can be from 0 to min(k, cnt_lft_pair, cnt_rgt_pair), and r = 2k - 2p ≤ cnt_both.

Wait, so I need to ensure that 2k - 2p ≤ cnt_both.

Which implies p ≥ k - cnt_both / 2.

But cnt_both is an integer, and p has to be integer.

This seems a bit messy.

To simplify, perhaps I can iterate over possible values of p from 0 to min(k, cnt_lft_pair, cnt_rgt_pair), and check if 2k - 2p ≤ cnt_both.

If such a p exists, then I can select p pairs from the first n, p pairs from the last n, and r = 2k - 2p numbers from S, include one copy in l and one in r.

This seems feasible.

But to implement this efficiently, I need to find a way to select these elements quickly.

Given the constraints on time and the input size, I need an efficient way to do this.

Let me consider sorting the elements in the first n and the last n to identify pairs.

Wait, but I need to keep track of which elements are in which half.

Wait, perhaps I can create frequency maps for the first n and the last n.

Let me try to implement this step by step.

First, for each test case:

- Read n and k.

- Read the array of 2n elements.

- Split the array into lft (first n elements) and rgt (last n elements).

- Identify cnt_lft_pair: numbers that appear twice in lft.

- Identify cnt_rgt_pair: numbers that appear twice in rgt.

- Identify cnt_both: numbers that appear once in lft and once in rgt.

To do this, I can count the frequency of each number in lft and rgt.

For each number from 1 to n:

- If it appears twice in lft, increment cnt_lft_pair.

- If it appears twice in rgt, increment cnt_rgt_pair.

- If it appears once in lft and once in rgt, increment cnt_both.

Then, for p from 0 to min(k, cnt_lft_pair, cnt_rgt_pair):

- Set r = 2k - 2p.

- If r ≤ cnt_both, then this p is feasible.

- Choose p pairs from lft, p pairs from rgt, and r numbers from S.

- Include the p pairs from lft in l (i.e., both copies).

- Include the p pairs from rgt in r (i.e., both copies).

- Include one copy from lft and one copy from rgt for each of the r numbers from S in l and r, respectively.

Then, l would have 2p + r elements, which is 2k, and r would have 2p + r elements, which is 2k, and XOR_l = XOR_r.

This seems correct.

Now, to implement this efficiently, I need to:

- Count the frequency of each number in lft and rgt.

- Identify the numbers that appear twice in lft, twice in rgt, or once in each.

- For p from 0 to min(k, cnt_lft_pair, cnt_rgt_pair):

- Check if r = 2k - 2p ≤ cnt_both.

- If yes, proceed to select p pairs from lft, p pairs from rgt, and r numbers from S.

- Output the corresponding elements for l and r.

But considering time constraints, iterating over p for each test case might be too slow if done naively.

Given that t can be up to 5000 and n up to 5*10^4, I need an efficient implementation.

Let me think about how to select the elements.

An optimization: since the problem guarantees at least one solution exists, I can choose any p that satisfies the conditions.

I can choose p as large as possible, i.e., p = min(k, cnt_lft_pair, cnt_rgt_pair), and then set r = 2k - 2p.

If r ≤ cnt_both, then proceed.

If not, decrease p and try again.

But this might not be efficient.

Wait, perhaps I can calculate the maximum p such that 2k - 2p ≤ cnt_both.

That is, p ≥ k - cnt_both / 2.

But p has to be ≤ min(k, cnt_lft_pair, cnt_rgt_pair).

This seems a bit involved.

Let me consider a different approach.

Given that XOR_lft = XOR_rgt, and I need XOR_l = XOR_r.

Let me consider that the XOR of the remaining elements in lft and rgt should also be equal.

Wait, perhaps I can select elements in l and r such that XOR_l XOR XOR_r = XOR_lft XOR XOR_rgt = 0.

Which is always true since XOR_lft = XOR_rgt.

But I need a way to construct l and r.

Let me consider another angle.

Suppose I select any subset of 2k elements from lft and any subset of 2k elements from rgt, and check if their XORs are equal.

But that's not efficient.

Given time constraints, I need a better way.

Let me consider the following approach:

- Select k pairs of identical elements, where each pair is either from lft or from rgt.

- For pairs from lft, include both elements in l.

- For pairs from rgt, include both elements in r.

- Then, select the remaining elements needed to reach 2k in l and r from the numbers in S.

Wait, but I need to ensure that the XORs match.

This seems too vague.

Let me consider that for numbers in S, including one copy in l and one in r contributes the same value to XOR_l and XOR_r.

So, if I select a set of numbers from S and include one copy in l and one in r, their XOR contributions to l and r are the same.

Then, for the remaining elements in l and r, if I select pairs from lft and rgt, respectively, their XOR contributions are zero.

Thus, the total XOR_l and XOR_r would be equal.

This seems correct.

So, to implement this:

- Identify the numbers that appear twice in lft: these are the candidates for pairs in l.

- Identify the numbers that appear twice in rgt: these are the candidates for pairs in r.

- Identify the numbers that appear once in lft and once in rgt: these are the candidates for S.

- Choose p pairs from lft and p pairs from rgt, and r = 2k - 2p numbers from S.

- Include the p pairs from lft in l, and the p pairs from rgt in r.

- Include one copy from lft and one copy from rgt for each of the r numbers from S in l and r, respectively.

This should satisfy the conditions.

Now, to implement this efficiently, I need to:

- Count the frequency of each number in lft and rgt.

- Identify the numbers that appear twice in lft, twice in rgt, and once in each.

- For each test case, find a feasible p, and select the corresponding pairs and S elements.

Given time constraints, I need an efficient way to select these elements without iterating too much.

Let me think about sorting.

If I sort lft and rgt, I can identify the pairs easily.

For example, in sorted lft, the duplicates will be adjacent.

Similarly for rgt.

For S, I can list the numbers that appear once in lft and once in rgt.

Then, for selecting p pairs from lft and p pairs from rgt, and r numbers from S.

This seems manageable.

Let me try to outline the steps in code.

For each test case:

- Read n and k.

- Read the array of 2n elements.

- Split into lft and rgt.

- Sort lft and rgt.

- Identify pairs in lft: elements that appear twice in lft.

- Identify pairs in rgt: elements that appear twice in rgt.

- Identify S: elements that appear once in lft and once in rgt.

- Determine p as min(k, number of pairs in lft, number of pairs in rgt).

- Set r = 2k - 2p.

- If r > number of S, decrease p until r ≤ number of S.

- Select p pairs from lft and include both in l.

- Select p pairs from rgt and include both in r.

- Select r numbers from S and include one copy from lft in l and one copy from rgt in r.

- Output l and r.

This seems like it could work.

I need to implement this efficiently.

Let me consider the implementation details.

- Sorting lft and rgt takes O(n log n) time per test case.

- Identifying pairs and S elements can be done in O(n) time.

- Selecting p pairs and r elements from S can be done in O(n) time.

Given that t can be up to 5000 and n up to 5*10^4, with the sum of n over all test cases up to 5*10^4, the total time should be acceptable.

Now, I need to handle the selection of elements carefully to ensure that I don't exceed the available counts.

Let me consider an example to verify this approach.

Take the first example:

n=2, k=1

array=[1,2,2,1]

lft=[1,2]

rgt=[2,1]

Sort lft: [1,2]

Sort rgt: [1,2]

Pairs in lft: 2 appears twice.

Wait, no. In lft, 1 appears once, 2 appears once.

In rgt, 2 appears once, 1 appears once.

So, cnt_lft_pair = 0

cnt_rgt_pair = 0

cnt_both = 2 (both 1 and 2 appear once in lft and once in rgt)

Set p = min(k, 0, 0) = 0

r = 2k - 2p = 2

Since cnt_both = 2 ≥ r = 2, proceed.

Select 0 pairs from lft and rgt, and select 2 numbers from S.

Include one copy from lft and one from rgt for each.

So, select 1 and 2 from S.

Include 1 and 2 in l from lft.

Include 1 and 2 in r from rgt.

So, l=[1,2], r=[1,2]

Which matches the first example.

Good.

Another example:

n=6, k=1

array=[6,4,2,1,2,3,1,6,3,5,5,4]

lft=[6,4,2,1,2,3]

rgt=[1,6,3,5,5,4]

Sort lft: [1,2,2,3,4,6]

Sort rgt: [1,3,4,5,5,6]

Pairs in lft: 2 appears twice.

Pairs in rgt: 5 appears twice.

cnt_both: numbers that appear once in lft and once in rgt: 1,3,4,6 appear once in each.

So, cnt_lft_pair = 1 (number 2)

cnt_rgt_pair = 1 (number 5)

cnt_both = 4 (numbers 1,3,4,6)

Set p = min(k,1,1)=1

r = 2k - 2p = 0

Since cnt_both =4 ≥ r=0, proceed.

Select p=1 pair from lft: select 2,2

Select p=1 pair from rgt: