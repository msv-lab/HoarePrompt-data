Alright, I have this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I need to perform exactly k operations on it. In each operation, I can select any contiguous subarray (which could even be empty) and insert the sum of that subarray anywhere in the array. My goal is to maximize the sum of the array after k such operations, and then output that sum modulo 10^9 + 7.

First, I need to understand what exactly an operation does. When I select a subarray, calculate its sum, and insert that sum back into the array, where can I insert it? The problem says "anywhere in the array," which means I can add this sum at any position I like, perhaps at the beginning, end, or in between any two elements.

My aim is to maximize the sum of the array after k operations. Since I'm allowed to perform exactly k operations, I need to figure out the best way to choose subarrays and insert their sums to achieve the highest possible sum.

Let me think about how the sum of the array changes with each operation. Suppose I have an array a = [a1, a2, ..., an]. The initial sum is S = a1 + a2 + ... + an.

In each operation, I choose a subarray a[i..j], compute its sum, and insert that sum into the array. So, the new sum becomes S + (sum of the chosen subarray).

Wait a minute, I'm adding the sum of the subarray back into the array, which means the total sum increases by that subarray's sum.

But where I insert this sum doesn't affect the total sum, right? Because I'm just adding one number to the array. So, regardless of whether I insert it at the beginning, end, or in between, the overall sum increases by the same amount.

Therefore, in each operation, I can increase the sum by choosing any subarray and inserting its sum into the array. To maximize the sum after k operations, I should choose the subarray with the maximum sum in each operation and insert it.

But is that the optimal strategy? Let's think carefully.

Suppose I have a single operation (k=1). Then, indeed, choosing the subarray with the maximum sum and inserting it would give me the maximum possible sum.

But when k > 1, things might be different. Because in each operation, I can choose any subarray of the current array and insert its sum, which then becomes part of the array for future operations.

Wait, but the array is changing with each insertion. Each time I insert a sum, the array grows by one element, which is that sum. So, in the next operation, I can choose subarrays that include these newly inserted sums.

This seems a bit recursive or iterative, where the choice in each step depends on the current state of the array.

Is there a smarter way to approach this without getting bogged down by the sequence of operations?

Let me consider the total sum after k operations. Initially, the sum is S. After the first operation, I choose a subarray with sum S1 and insert it, so the new sum is S + S1. In the second operation, I choose a subarray with sum S2 and insert it, so the new sum is S + S1 + S2, and so on, up to k operations.

So, overall, the final sum would be S + S1 + S2 + ... + Sk.

My goal is to maximize this sum, which means I need to maximize the sum S + S1 + S2 + ... + Sk.

Given that, it seems that I should choose the subarrays in such a way that the sums S1, S2, ..., Sk are as large as possible.

But there might be dependencies between the choices because the array changes with each insertion.

Alternatively, perhaps there's a way to model this that allows me to compute the maximum possible sum directly, without simulating each operation.

Let me think about the properties of the operations.

Each operation allows me to select any contiguous subarray (including empty) and insert its sum into the array.

The sum of the empty subarray is zero, which might be useful in certain cases, but probably not for maximizing the sum.

Assuming that all elements in the array are non-negative, then the maximum subarray sum would be the sum of the entire array. Inserting that sum would increase the total sum by that amount.

But if there are negative elements, I need to be careful to choose subarrays that have the maximum possible sum, possibly excluding negative parts.

Wait, perhaps I can use the concept of the maximum subarray sum.

Kadane's algorithm can find the maximum sum of a contiguous subarray in O(n) time.

But in this problem, I need to perform k operations, each time choosing a subarray and inserting its sum into the array.

I need to maximize the sum after k operations.

Let me consider a simple case.

Suppose k=1.

Then, I should choose the subarray with the maximum sum, insert it into the array, and the total sum becomes S + max_subarray_sum.

For k=2, I can choose another subarray with the maximum sum from the updated array and insert it.

But the updated array now has an extra element, which is the sum from the first operation.

I need to consider how this affects the possible subarrays for the second operation.

This seems a bit complicated to simulate step by step, especially since k can be up to 2e5 and n can be up to 2e5, and the total sum of n and k across all test cases is up to 2e5.

So, I need an efficient way to compute the maximum possible sum after k operations.

Let me think differently.

Suppose I can find the maximum possible sum that I can add in each operation, and since the operations are independent in terms of the sum added (because I'm just adding the sum of some subarray to the total sum), perhaps I can add the maximum possible subarray sum in each operation.

But is that correct? Wait, no, because the array changes after each insertion, which might affect the subarrays available in future operations.

Wait, but in reality, since I'm inserting the sum of a subarray into the array, that new element can be part of future subarrays.

But if I always choose to insert the sum of the entire array at each step, then in each operation, I'm adding the sum of the current array to the total sum.

Wait, but the array is changing because I'm inserting this sum as a new element.

Let me try with a small example.

Take n=2, k=2, a = [-4, -7].

According to the example, the output is 999999996, which is -11 modulo 10^9+7.

So, in this case, it seems that inserting zero (sum of empty subarray) twice is the best option, resulting in a sum of -4 + -7 + 0 + 0 = -11, which modulo 10^9+7 is 999999996.

But why not choose some other subarrays?

If I choose the subarray [-4], its sum is -4, and insert it, the array becomes [-4, -7, -4], sum is -15.

Then, choose the subarray [-7], sum is -7, insert it, array becomes [-4, -7, -4, -7], sum is -23.

Which is worse than inserting zero twice.

Hence, in this case, inserting zero twice is better.

Another example:

n=3, k=3, a=[2,2,8]

Sum is 12.

If I choose the entire array, sum is 12, insert it, array becomes [2,2,8,12], sum is 24.

Then choose the entire array again, sum is 24, insert it, array becomes [2,2,8,12,24], sum is 48.

Then choose the entire array again, sum is 48, insert it, array becomes [2,2,8,12,24,48], sum is 96.

Which matches the example output.

So, in this case, choosing the entire array sum in each operation maximizes the sum.

Similarly, in the first example, choosing the empty subarray (sum zero) in each operation was better because choosing any non-empty subarray would have decreased the sum due to negative elements.

Hence, the strategy seems to be:

- Find the maximum possible sum of any subarray (including the empty subarray, which has sum zero).

- In each of the k operations, choose this maximum subarray sum and insert it into the array.

- The total sum after k operations would be the initial sum plus k times the maximum subarray sum.

Wait, but in the second example, the maximum subarray sum is 12, and after three operations, the sum is 12 + 12*3 = 48, but according to the example, it's 96.

Wait, no, wait, in the second example, starting with sum 12, after first insertion of 12, sum becomes 24.

Then, the maximum subarray sum is now 24, insert it, sum becomes 48.

Then, the maximum subarray sum is now 48, insert it, sum becomes 96.

So, it's not just adding the initial maximum subarray sum k times, but rather, in each operation, the maximum subarray sum of the current array, which is increasing.

So, my previous assumption is incorrect.

So, perhaps a better strategy is:

- In each operation, find the current maximum subarray sum, insert it into the array, which increases the total sum by that amount, and also potentially increases future maximum subarray sums.

Hence, this seems like a dynamic process where the array and the possible maximum subarray sums change with each operation.

This seems complex to compute directly, especially given the constraints.

I need a smarter way to compute this efficiently.

Let me consider that in each operation, I can choose any subarray sum and insert it.

The subarray sum can be any sum of a contiguous sequence in the current array.

By inserting a subarray sum, I'm effectively adding that sum to the total sum.

I need to maximize the total sum after k operations.

Given that, perhaps I can think in terms of the maximum possible sum that can be added in each operation, considering that the array is growing with each insertion.

But this still seems tricky.

Let me think about the properties of the maximum subarray sum.

In the first example, with a = [-4, -7], the maximum subarray sum is 0 (from the empty subarray), so adding zero in each operation is the best.

In the second example, a = [2,2,8], the maximum subarray sum is 12, so adding 12 in each operation, and the array grows accordingly.

In general, it seems that in each operation, I should add the current maximum subarray sum to the total sum.

But computing this dynamically for each operation would be too slow for large k and n.

I need a way to compute this efficiently.

Let me consider that after each operation, the maximum subarray sum increases because I'm inserting a positive sum (assuming the maximum subarray sum is positive).

Wait, in the second example, starting with sum 12, after inserting 12, the new array is [2,2,8,12], and the new maximum subarray sum is 24.

Then, inserting 24, the array becomes [2,2,8,12,24], and the new maximum subarray sum is 48.

This seems like the maximum subarray sum is doubling each time.

Wait, 12, then 24, then 48, which is doubling each time.

Is this a general pattern?

Suppose I have an array with sum S and maximum subarray sum M.

After inserting M, the new sum is S + M, and the new maximum subarray sum is max(M, S + M).

Wait, no.

Wait, the new array is the original array plus the new element M.

So, the new maximum subarray sum could be the previous M, or it could be a subarray that includes the new element M.

For example, in the second test case:

Initial array: [2,2,8], sum 12, maximum subarray sum 12.

After inserting 12, array becomes [2,2,8,12], sum 24.

The maximum subarray sum is now 24 (the entire array).

Then, inserting 24, array becomes [2,2,8,12,24], sum 48.

Maximum subarray sum is now 48.

And so on.

So, it seems that in each operation, the maximum subarray sum doubles.

Because in each step, the sum of the entire array doubles.

Wait, in the first step, M=12, then after inserting M, the new sum is S + M = 12 + 12 = 24, and the new maximum subarray sum is 24.

Then, inserting 24, sum becomes 48, maximum subarray sum is 48.

So, it's doubling each time.

Hence, starting from M, after k operations, the sum would be S + M * (2^k - 1).

Wait, let's see:

Operation 0: sum = S, maximum M

Operation 1: sum = S + M, maximum M1 = 2*M

Operation 2: sum = S + M + M1 = S + M + 2*M = S + 3*M

But according to the example, it's S + M + M1 = 12 + 12 + 24 = 48, which is S + 3*M = 12 + 3*12 = 48.

Wait, 3*M = 36, plus S=12 is 48, yes.

Wait, but 2^2 -1 = 3, so M*(2^k -1) = 12*3 = 36, plus S=12, total 48.

Wait, but in the example with k=3, it should be S + M*(2^k -1) = 12 + 12*(8-1) = 12 + 84 = 96, which matches the example.

So, generalizing, sum after k operations is S + M*(2^k -1).

Wait, but in the first example, S = -4 + (-7) = -11, M = 0, so sum after k operations is -11 + 0*(2^k -1) = -11, which matches the example.

Hence, it seems that the formula is sum = S + M*(2^k -1), where M is the maximum subarray sum of the initial array.

Is this always true?

Let me check with another example.

Take n=1, k=7, a=[7]

Sum S=7, maximum subarray sum M=7.

After first operation: insert M=7, array becomes [7,7], sum=14, M=14.

Second operation: insert M=14, array becomes [7,7,14], sum=28, M=28.

And so on.

After k operations, sum should be S + M*(2^k -1) = 7 + 7*(2^7 -1) = 7 + 7*127 = 7 + 889 = 896.

Which matches one of the test cases.

Another test case: n=5, k=1, a=[4,-2,8,-12,9]

Sum S=4-2+8-12+9=7, M=12 (subarray [4,-2,8]).

According to the formula, sum after k=1 operations: 7 + 12*(2 -1) = 7 + 12 = 19.

But in the test case, it's 17.

Wait, discrepancy here.

Wait, perhaps I miscalculated M.

Let's find the maximum subarray sum for a=[4,-2,8,-12,9].

Possible subarrays:

[4] sum=4

[4,-2] sum=2

[4,-2,8] sum=10

[4,-2,8,-12] sum=-2

[4,-2,8,-12,9] sum=7

[ -2 ] sum=-2

[ -2,8 ] sum=6

[ -2,8,-12 ] sum=-6

[ -2,8,-12,9 ] sum=-3

[ 8 ] sum=8

[ 8,-12 ] sum=-4

[ 8,-12,9 ] sum=5

[ -12 ] sum=-12

[ -12,9 ] sum=-3

[ 9 ] sum=9

So, the maximum subarray sum M=10 (from [4,-2,8]).

Then, sum after k=1 operations: S + M*(2^1 -1) = 7 + 10*(1) = 17, which matches the test case.

Okay, so I had miscalculated M earlier; it's 10, not 12.

Hence, the formula seems to hold.

So, the general formula for the sum after k operations is:

sum = S + M*(2^k -1)

where S is the initial sum of the array, and M is the maximum subarray sum of the initial array.

Wait, but in the second test case, S=12, M=12, and sum after k operations is 12 + 12*(2^k -1).

But in reality, it's doubling each time.

Wait, for k=1: 12 + 12*(2 -1) = 12 + 12 = 24

For k=2: 12 + 12*(4 -1) = 12 + 36 = 48

For k=3: 12 + 12*(8 -1) = 12 + 84 = 96

Which matches the example.

Another test case: n=2, k=1, a=[1000000000,8]

Sum S=1000000008, M=1000000008

Sum after k=1 operations: 1000000008 + 1000000008*(2 -1) = 1000000008 + 1000000008 = 2000000016 % (10^9 +7) = 2000000016 - 1000000007 = 999999999, but in the example, it's 2.

Wait, discrepancy again.

Wait, perhaps I'm missing something.

Wait, in this test case, n=2, k=1, a=[1000000000,8]

Sum S=1000000008, M=1000000000 (the first element, as it's the largest subarray sum).

Then, sum after k=1 operations: S + M*(2^k -1) = 1000000008 + 1000000000*(1) = 1000000008 + 1000000000 = 2000000008 % (10^9 +7) = 2000000008 - 1000000007*2 = 2000000008 - 2000000014 = -6, which modulo 10^9+7 is 10^9 +7 -6 = 999999991, but the example output is 2.

Wait, not matching.

Wait, perhaps I'm miscalculating M.

Let's find M for a=[1000000000,8]

Possible subarrays:

[1000000000] sum=1000000000

[1000000000,8] sum=1000000008

[8] sum=8

So, M=1000000008

Then, sum after k=1 operations: S + M*(2^1 -1) = 1000000008 + 1000000008*1 = 1000000008 + 1000000008 = 2000000016 % (10^9 +7) = 2000000016 - 1000000007 = 999999999, but the example output is 2.

Wait, inconsistency here.

Perhaps my formula is incorrect.

Let me think differently.

Wait, perhaps the formula is sum = S + M * (2^k -1), but considering that M can change in each operation because the array is growing.

But in the earlier examples, it seems that M doubles each time.

Wait, in the second example, M starts at 12, then becomes 24, then 48, and so on.

So, perhaps M itself is multiplied by 2 in each operation.

Hence, sum after k operations would be S + M + 2*M + 4*M + ... + 2^{k-1}*M = S + M*(2^k -1)

Wait, but in the example with n=2, k=1, a=[1000000000,8], S=1000000008, M=1000000008, sum after k=1 operations should be S + M*(2^1 -1) = 1000000008 + 1000000008*1 = 2000000016 % (10^9 +7) = 999999999, but the example output is 2.

Wait, perhaps I'm missing something about the problem statement.

Wait, in the problem statement, it says "insert the sum of this subarray anywhere in the array."

So, when I insert M into the array, it becomes a new element in the array.

But in the second example, starting with [2,2,8], sum=12, M=12, insert 12 to get [2,2,8,12], sum=24, M=24.

Then insert 24 to get [2,2,8,12,24], sum=48, M=48.

And so on.

So, in each operation, M seems to double.

But in the test case with n=2, k=1, a=[1000000000,8], sum=1000000008, M=1000000008.

After inserting M=1000000008, the array becomes [1000000000,8,1000000008], sum=1000000008 + 1000000008 = 2000000016.

But according to the example, the output is 2, which is 2000000016 modulo 10^9+7.

Wait, 10^9+7 is 1000000007.

So, 2000000016 mod 1000000007 = 2000000016 - 1000000007*1 = 2000000016 - 1000000007 = 999999999, but the example output is 2.

Wait, perhaps I need to consider the modulo operation correctly.

Wait, 2000000016 - 1000000007 = 999999999, which is still not 2.

Wait, perhaps I'm missing something.

Wait, in the problem statement, it says "output the answer modulo 10^9 +7".

But perhaps the sum can be negative, and we need to handle negative sums correctly when taking modulo.

Wait, in the first test case, sum is -11, and -11 mod 1000000007 is -11 + 1000000007 = 999999996, which matches the example.

So, for positive sums, sum mod 1000000007 should be straightforward.

In this case, 2000000016 mod 1000000007 = 2000000016 - 1000000007*1 = 999999999, but the example output is 2.

Wait, perhaps I'm looking at the wrong test case.

Wait, in the example provided in the problem statement, for n=2, k=1, a=[1000000000,8], the output is 2.

But according to my calculation, it should be 999999999.

Wait, perhaps there's a mistake in my understanding.

Wait, perhaps the formula is sum = S + M * (2^k -1), but adjusted for the way M grows.

Wait, in the second example, M doubles each time, but perhaps in general, M after each operation is M * 2.

Wait, but in the test case with n=2, k=1, a=[1000000000,8], M=1000000008, sum after k=1 operations is S + M = 1000000008 + 1000000008 = 2000000016 mod 1000000007 = 999999999, but the example output is 2.

Wait, perhaps I'm missing that M doesn't double in each operation; perhaps it's different.

Wait, perhaps in each operation, M becomes M + inserted M.

Wait, in the second example, M=12, after inserting 12, M becomes 24.

Then, inserting 24, M becomes 48, and so on.

So, M is doubling each time.

Hence, after k operations, M = M * 2^k.

But in the test case with n=2, k=1, a=[1000000000,8], M=1000000008, after inserting 1000000008, M becomes 2*1000000008=2000000016, which mod 1000000007 is 2000000016 - 1000000007*1 = 999999999, but the example output is 2.

Wait, perhaps I need to consider that the sum after k operations is S + M * (2^k -1), but taking into account the modulo at each step.

Wait, but according to the problem, we only need to take the final sum modulo 10^9+7.

Hence, perhaps my formula is correct, and there's a mistake in my calculation for this particular test case.

Wait, perhaps I need to verify the test cases more carefully.

Looking back at the example provided in the problem statement, for n=2, k=1, a=[1000000000,8], the output is 2.

But according to my formula, sum = S + M*(2^k -1) = 1000000008 + 1000000008*(1) = 2000000016 mod 1000000007 = 2000000016 - 1000000007*1 = 999999999, but the example output is 2.

Wait, perhaps I'm missing something about how M grows.

Wait, perhaps M doesn't double each time; maybe it's not directly proportional.

Wait, perhaps in each operation, M increases by the inserted sum, but it's not simply doubling.

Wait, in the second example, starting with M=12, after inserting 12, M becomes 24, which is double.

Then, inserting 24, M becomes 48, and so on.

But in the test case with n=2, k=1, a=[1000000000,8], M=1000000008, after inserting 1000000008, M should be 2000000016, which modulo 1000000007 is 2000000016 - 1000000007*1 = 999999999, but the example output is 2.

Wait, perhaps I'm misidentifying the test case.

Wait, looking back at the input:

Input:

12

2 2

-4 -7

3 3

2 2 8

1 7

7

5 1

4 -2 8 -12 9

7 4

8 14 -9 6 0 -1 3

7 100

5 3 -8 12 -5 -9 3

6 1000

-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000

2 1

1000000000 8

5 4

0 0 0 0 0

6 10

48973 757292 58277 -38574 27475 999984

7 1

-1000 1000 -1000 1000 -1000 1000 -1000

10 10050

408293874 -3498597 7374783 295774930 -48574034 26623784 498754833 -294875830 283045804 85938045

Output:

999999996

96

896

17

351

716455332

42

2

0

897909241

0

416571966

So, for