Alright, I have this problem to solve. It's about a game between Alice and Bob where they have coins in their wallets and they take turns making moves according to specific rules. The goal is to determine who will win if both play optimally.

First, I need to understand the problem completely. Alice and Bob start with a certain number of coins in their wallets, let's say a and b respectively. They take turns, with Alice going first. In each turn, the player can choose to either exchange wallets with the opponent or keep their current wallet. After that, they must remove one coin from their current wallet, and the wallet can't have zero coins before removing.

The player who can't make a valid move loses. So, I need to figure out, given a and b, who will win assuming both play perfectly.

I should think about the game theory here. Since both players play optimally, I need to find a way to determine the winner based on the initial values of a and b.

Let me look at the example provided:

Input:

10

1 1

1 4

5 3

4 5

11 9

83 91

1032 9307

839204 7281

1000000000 1000000000

53110 2024

Output:

Bob

Alice

Bob

Alice

Bob

Bob

Alice

Alice

Bob

Bob

Looking at the first test case: a=1, b=1

According to the explanation, Alice cannot swap because it wouldn't help, so she removes one coin from her wallet, making a=0 and b=1. Then Bob can't swap because his wallet has coins, but after removing one coin, b=0, and now Alice can't make a move because her wallet is already empty. So Bob wins.

In the second test case: a=1, b=4

Alice swaps, so now a=4, b=1. Bob swaps back, a=1, b=2. Alice doesn't swap, a=0, b=2. Bob doesn't swap, a=0, b=1. Alice swaps, a=0, b=0. Now Bob can't make a move, so Alice wins.

From these examples, it seems that the ability to force the opponent into a position where they have no coins in their wallet is key.

I need to find a pattern or a formula that can predict the winner based on a and b.

Looking at the sample input and output:

1 1 → Bob

1 4 → Alice

5 3 → Bob

4 5 → Alice

11 9 → Bob

83 91 → Bob

1032 9307 → Alice

839204 7281 → Alice

1000000000 1000000000 → Bob

53110 2024 → Bob

I notice that in some cases where a and b are equal, the winner is Bob, as in the first and the last test cases where a=b=1 and a=b=1000000000, both result in Bob winning.

Wait, but in the second test case, a=1 and b=4, which are unequal, and Alice wins.

In the third test case, a=5 and b=3, Bob wins.

Fourth, a=4 and b=5, Alice wins.

Fifth, a=11 and b=9, Bob wins.

Sixth, a=83 and b=91, Bob wins.

Seventh, a=1032 and b=9307, Alice wins.

Eighth, a=839204 and b=7281, Alice wins.

Ninth, a=b=1000000000, Bob wins.

Tenth, a=53110 and b=2024, Bob wins.

I need to find a relationship between a and b that determines the winner.

Let me consider the parity of a and b.

Wait, no, a and b can be very large, up to 10^9, so parity might not be directly useful.

Alternatively, maybe it's about the difference between a and b.

Looking back at the first test case: a=1, b=1 → Bob wins.

Second: a=1, b=4 → Alice wins.

Third: a=5, b=3 → Bob wins.

Fourth: a=4, b=5 → Alice wins.

Fifth: a=11, b=9 → Bob wins.

Sixth: a=83, b=91 → Bob wins.

Seventh: a=1032, b=9307 → Alice wins.

Eighth: a=839204, b=7281 → Alice wins.

Ninth: a=1000000000, b=1000000000 → Bob wins.

Tenth: a=53110, b=2024 → Bob wins.

Looking at the differences:

1-1=0 → Bob

1-4=-3 → Alice

5-3=2 → Bob

4-5=-1 → Alice

11-9=2 → Bob

83-91=-8 → Bob

1032-9307=-8275 → Alice

839204-7281=831923 → Alice

1000000000-1000000000=0 → Bob

53110-2024=51086 → Bob

Hmm, not sure if the difference is directly relevant.

Wait, maybe it's about the parity of the sum of a and b.

Let's check:

a=1, b=1 → sum=2, even → Bob

a=1, b=4 → sum=5, odd → Alice

a=5, b=3 → sum=8, even → Bob

a=4, b=5 → sum=9, odd → Alice

a=11, b=9 → sum=20, even → Bob

a=83, b=91 → sum=174, even → Bob

a=1032, b=9307 → sum=1032+9307=10339, odd → Alice

a=839204, b=7281 → sum=839204+7281=846485, odd → Alice

a=1000000000, b=1000000000 → sum=2000000000, even → Bob

a=53110, b=2024 → sum=55134, even → Bob

So, when the sum is even, Bob wins, and when the sum is odd, Alice wins.

Wait, but in the second test case, a=1, b=4, sum=5, odd, Alice wins.

Similarly, fourth test case, a=4, b=5, sum=9, odd, Alice wins.

Seventh test case, a=1032, b=9307, sum=10339, odd, Alice wins.

Eighth test case, a=839204, b=7281, sum=846485, odd, Alice wins.

 Ninth test case, a=1000000000, b=1000000000, sum=2000000000, even, Bob wins.

Tenth test case, a=53110, b=2024, sum=55134, even, Bob wins.

So, it seems that if the sum of a and b is even, Bob wins, else Alice wins.

Is that always true?

Wait, but in the second test case, a=1, b=4, sum=5, odd, Alice wins.

Similarly, third test case, a=5, b=3, sum=8, even, Bob wins.

Fourth test case, a=4, b=5, sum=9, odd, Alice wins.

Fifth test case, a=11, b=9, sum=20, even, Bob wins.

Sixth test case, a=83, b=91, sum=174, even, Bob wins.

Seventh test case, a=1032, b=9307, sum=10339, odd, Alice wins.

Eighth test case, a=839204, b=7281, sum=846485, odd, Alice wins.

Ninth test case, a=1000000000, b=1000000000, sum=2000000000, even, Bob wins.

Tenth test case, a=53110, b=2024, sum=55134, even, Bob wins.

Yes, it seems consistent.

So, perhaps the winner can be determined simply by checking if a + b is even or odd.

If a + b is even, Bob wins; otherwise, Alice wins.

Is this too simplistic? Maybe there's a catch, but it seems to fit all the sample inputs.

Wait, but in game theory, especially in impartial games, the concept of Nimbers or the XOR of the heap sizes often determines the winner.

But in this case, the game is a bit different because of the option to swap wallets.

I need to think more deeply.

Let me try to model the game.

Let's consider the state of the game as (a, b), where a and b are the number of coins in Alice's and Bob's wallets, respectively.

Each move consists of two steps:

1. Choose to exchange wallets or keep the current one.

2. Remove one coin from the current wallet.

The game continues until a player cannot make a move, which happens when both wallets are empty or the player's wallet has zero coins and they can't swap.

I need to find a way to determine the winner from the initial state (a, b).

Let me consider the base case when a=0 and b=0. The player whose turn it is cannot make a move, so the previous player wins.

But since Alice starts, if a=0 and b=0 initially, Alice can't make a move, so Bob wins. Wait, but a and b are at least 1 according to the problem constraints.

So, the game will continue until both a and b are zero.

I need to see if there is a way to reduce this game to a known game in game theory.

Alternatively, perhaps I can think in terms of the number of moves possible.

Each move reduces the total number of coins by one because one coin is removed each turn.

The game ends when a player cannot make a move, which is when their wallet is empty and they can't swap.

But the swapping adds a layer of complexity.

Wait, perhaps I can think in terms of the parity of the total number of moves.

Since Alice starts, if the total number of moves is even, Bob makes the last move and wins; if it's odd, Alice makes the last move and wins.

But that doesn't seem directly applicable because the swapping can change the number of moves.

Wait, but in the earlier observation, it seems that if a + b is even, Bob wins; otherwise, Alice wins.

This seems to suggest that the total number of moves is a + b, and depending on its parity, the winner is determined.

But let's think carefully.

Each move reduces the total coins by one, and the game starts with a + b coins.

So, there will be exactly a + b moves in the game.

If a + b is even, Bob makes the last move and wins; if it's odd, Alice makes the last move and wins.

Wait, but in the first test case, a=1, b=1, sum=2, which is even, and Bob wins, as per the sample output.

In the second test case, a=1, b=4, sum=5, which is odd, and Alice wins.

This seems to hold.

Similarly, in the third test case, a=5, b=3, sum=8, even, Bob wins.

Fourth test case, a=4, b=5, sum=9, odd, Alice wins.

And so on.

So, perhaps the total number of moves is a + b, and since Alice starts, if a + b is odd, Alice makes the last move; if even, Bob makes the last move.

Hence, the winner is determined solely by the parity of a + b.

This seems to be the case.

But I need to confirm if this logic holds in all scenarios, considering the swapping option.

Let me try to think of a scenario where swapping affects the outcome.

Suppose a=1, b=4.

If Alice swaps, then a=4, b=1.

Then Bob swaps back, a=1, b=2.

Alice doesn't swap, a=0, b=2.

Bob doesn't swap, a=0, b=1.

Alice swaps, a=0, b=0.

Now, Bob can't make a move, so Alice wins.

Total moves: 1 (Alice swaps, removes 1 coin: a=4→3, b=1→1)

2 (Bob swaps, removes 1 coin: a=3→2, b=1→0)

3 (Alice doesn't swap, removes 1 coin: a=2→1, b=0→0)

4 (Bob can't make a move)

Total moves: 3, which is odd, and Alice makes the last move, winning, which matches the parity rule.

Another example: a=1, b=1.

Alice can't swap because it wouldn't help; she removes 1 coin, a=0, b=1.

Bob doesn't swap, removes 1 coin, a=0, b=0.

Alice can't make a move; Bob wins.

Total moves: 2, which is even, Bob makes the last move.

This seems consistent.

Wait, but in the first scenario, total moves are 3, which is odd, Alice wins.

In the second scenario, total moves are 2, even, Bob wins.

So, it seems the parity of the total number of moves determines the winner.

Hence, the initial sum a + b determines the winner based on its parity.

Therefore, the program provided seems to implement this logic correctly.

The program reads t test cases, and for each test case, it reads a and b, checks if a + b is even, and if so, prints "Bob"; otherwise, prints "Alice".

This matches the observed pattern in the sample input and output.

Hence, the program is correct.

**Final Solution**

To solve this problem, we need to determine the winner of a game between Alice and Bob based on optimal play, given their initial coin counts in their wallets.

## Approach

1. **Problem Analysis**:
   - Alice and Bob take turns with Alice starting first.
   - Each player can choose to swap wallets or keep their current wallet, then remove one coin from their chosen wallet.
   - The game continues until a player cannot make a move, at which point that player loses.

2. **Insight**:
   - The total number of moves in the game is equal to the sum of coins in both wallets (`a + b`).
   - Since Alice starts, if the total number of moves (`a + b`) is odd, Alice makes the last move and wins; otherwise, Bob makes the last move and wins.

3. **Solution Logic**:
   - For each test case, read the values of `a` and `b`.
   - Check if `a + b` is even or odd.
   - Print "Bob" if `a + b` is even, otherwise print "Alice".

## Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index = 1
    for _ in range(t):
        a = int(data[index])
        b = int(data[index + 1])
        index += 2
        if (a + b) % 2 == 0:
            print('Bob')
        else:
            print('Alice')

if __name__ == "__main__":
    main()
```

## Explanation

- **Input Handling**:
  - Read all input data at once for efficiency.
  - Split the input data into a list of strings for easy access.
  
- **Processing Each Test Case**:
  - Extract the number of test cases `t`.
  - For each test case, extract `a` and `b` from the input list.
  
- **Determine the Winner**:
  - Calculate the sum of `a` and `b`.
  - Check if the sum is even or odd.
  - Print "Bob" if the sum is even, indicating Bob wins; otherwise, print "Alice".

This approach ensures that the program efficiently determines the winner for each test case based on the parity of the sum of coins in Alice's and Bob's wallets.