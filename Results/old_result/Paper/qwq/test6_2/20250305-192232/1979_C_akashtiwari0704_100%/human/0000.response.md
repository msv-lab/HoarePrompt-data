Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n possible outcomes in a game, and for each outcome, there's a multiplier k_i. I need to bet some integer amount of coins on each outcome such that, no matter which outcome wins, the amount I get back is more than the total amount I bet on all outcomes.

First, I need to understand the constraints. For each test case, there's a number n (from 1 to 50), and then n integers k_i (from 2 to 20). The sum of n over all test cases doesn't exceed 2*10^5, which means there could be up to 10^4 test cases, each with up to 50 outcomes.

The goal is to find n integers x_i (each between 1 and 10^9) such that for every i, k_i * x_i > sum of all x_j for j from 1 to n.

Let me rephrase that: for each i, k_i * x_i > sum(x), where sum(x) is the total sum of all bets.

This seems like a system of inequalities that needs to be satisfied simultaneously.

Let me try to find a general approach.

Suppose sum(x) = S.

Then, for each i, k_i * x_i > S.

But S = sum_{j=1 to n} x_j.

So, for each i, k_i * x_i > sum_{j=1 to n} x_j.

This seems tricky. Maybe there's a way to express x_i in terms of a common variable.

Let me think about it differently. Suppose I fix S, the total sum of bets.

Then, for each i, x_i > S / k_i.

But x_i has to be integers, so x_i >= ceil(S / k_i).

But since x_i has to be integers, maybe I can find some relationship based on the least common multiple or something like that.

Wait, maybe I can consider the reciprocals.

If I rearrange the inequality k_i * x_i > S, I get x_i / S > 1 / k_i.

Summing over all i, sum(x_i / S) > sum(1 / k_i).

But sum(x_i / S) = sum(x_i) / S = 1.

So, 1 > sum(1 / k_i).

Does this give me a condition for when a solution exists?

Wait, if sum(1 / k_i) < 1, then it's possible, otherwise, it's not.

Let me check this with the sample input.

In the first test case:

n = 3

k = [3,2,7]

sum(1/k_i) = 1/3 + 1/2 + 1/7 = (14 + 21 + 6)/42 = 41/42 < 1.

And in the output, there is a solution: 27 41 12.

In the second test case:

n = 2

k = [3,3]

sum(1/k_i) = 1/3 + 1/3 = 2/3 < 1.

Output: 1 1.

In the third test case:

n = 5

k = [5,5,5,5,5]

sum(1/k_i) = 5*(1/5) = 1.

Output: -1.

Ah, so when sum(1/k_i) >=1, there is no solution.

Wait, but in the problem statement, it says "it can be shown that if a solution exists, there is always a solution that satisfies these constraints."

So, my condition seems to match: if sum(1/k_i) <1, then a solution exists; otherwise, it doesn't.

Now, how to find such x_i?

Let me look at the first test case:

n=3

k=[3,2,7]

sum(1/k_i)=41/42 <1.

They chose x=[27,41,12].

Sum S=27+41+12=80.

Check:

3*27=81 >80

2*41=82 >80

7*12=84 >80.

Perfect.

How did they choose these x_i?

Is there a method to choose them?

Let me think.

Suppose I set x_i = S / k_i + something.

Wait, from earlier, x_i > S / k_i.

So, x_i >= ceil(S / k_i).

But S is the sum of all x_j.

This seems circular.

Maybe I need to find a way to set S and x_i such that x_i >= ceil(S / k_i) for all i, and sum(x_i) = S.

This seems tricky.

Perhaps I can set x_i proportional to 1/k_i.

Let me try.

Letâ€™s define x_i = c / k_i for some constant c.

Then sum(x_i) = c * sum(1/k_i).

And for each i, k_i * x_i = k_i * (c / k_i) = c.

So, c > sum(x_i) = c * sum(1/k_i).

Thus, c > c * sum(1/k_i).

Divide both sides by c (assuming c>0), then 1 > sum(1/k_i).

This matches my earlier condition that sum(1/k_i) <1 for a solution to exist.

So, if sum(1/k_i) <1, then choosing x_i = c / k_i for some c works, as long as c > c * sum(1/k_i), which is always true when sum(1/k_i) <1.

But x_i need to be integers, so I need to choose c such that c / k_i is an integer.

Since k_i range from 2 to 20, and n can be up to 50, I need to choose c as a multiple of the least common multiple (LCM) of the k_i.

Wait, but k_i can be up to 20, and n up to 50, but t up to 10^4, and sum of n over t up to 2*10^5.

Time constraints are important, but let's see.

If I set c to be the LCM of all k_i, then c is divisible by each k_i, so x_i = c / k_i is an integer.

Then, sum(x_i) = c * sum(1/k_i).

And for each i, k_i * x_i = c.

So, I need c > sum(x_i) = c * sum(1/k_i).

Which simplifies to c > c * sum(1/k_i).

Dividing both sides by c (since c >0), 1 > sum(1/k_i), which is already satisfied.

So, this seems to work.

Now, I need to implement this.

But, I need to make sure that x_i <=10^9.

Given that c is the LCM of k_i, and k_i <=20, the LCM of numbers up to 20 is 232792560 (LCM of 1 to 20), but since k_i >=2, and n<=50, and t<=10^4, but sum of n over t <=2*10^5, it should be manageable.

Wait, but in the first test case, c = LCM of [3,2,7] = 42.

Then x_i = 42 / 3 =14, 42 /2=21, 42/7=6.

But in the sample output, x_i are [27,41,12], which are multiples of these minimal x_i.

So, perhaps the minimal solution is x_i = c / k_i, but in the sample, they chose multiples.

Maybe to satisfy some other condition, but in this approach, choosing x_i = c / k_i works.

Wait, but in the second test case:

n=2

k=[3,3]

c=3 (LCM of 3 and 3 is 3)

x_i=3/3=1 for both.

Sum S=2.

Check: 3*1=3 >2, for both outcomes.

So, it works.

In the third test case:

n=5

k=[5,5,5,5,5]

c=5

x_i=1 for all.

Sum S=5.

Check: 5*1=5, which is not greater than 5.

Wait, 5*1=5 >5? No, 5 is not greater than 5. So, it's invalid.

Hence, output is -1, which matches the sample.

So, this seems correct.

Now, in the program provided, let's see what it does.

It reads t, the number of test cases.

For each test case:

- Reads n, the number of outcomes.

- Reads n integers k_i.

- Computes the LCM of k_i.

- Sets x_i = c / k_i for each i.

- Computes sum(x_i).

- If sum(x_i) >= c, prints -1.

- Else, prints the x_i.

Wait, in the first test case, c=42, x_i=[14,21,6], sum=41, which is less than c=42.

But in the sample output, x_i=[27,41,12], sum=80, which is less than the returns of 81,82,84.

So, why isn't it outputting [14,21,6]?

Maybe because sum(x_i)=41 < c=42, but the condition is sum(x_i) < c.

Wait, but in the sample, they chose higher x_i.

Possibly to have sum(x_i) as large as possible without exceeding the minimum return.

But according to this approach, choosing x_i = c / k_i should work, and sum(x_i)=c*sum(1/k_i), which is less than c, since sum(1/k_i)<1.

So, it should be acceptable.

Maybe the sample chose different multiples to maximize sum(x_i) or for some other reason.

But the approach in the code seems correct.

Wait, but in the third test case, c=5, x_i=[1,1,1,1,1], sum=5, which is not less than c=5, so correctly outputs -1.

In the second test case, c=3, x_i=[1,1], sum=2 <3, which is correct.

So, seems correct.

But let's check if sum(x_i) < c implies that for each i, k_i*x_i > sum(x_j).

Given that sum(x_j) = sum_{j=1 to n} x_j = S.

And for each i, k_i * x_i > S.

In the approach, S = sum(x_j) = c * sum(1/k_i).

And for each i, k_i * x_i = c.

So, c > S = c * sum(1/k_i).

Which simplifies to 1 > sum(1/k_i), which is already satisfied.

Hence, this approach seems correct.

Now, in the code, it computes c as LCM of k_i.

Then sets x_i = c / k_i.

Then computes sum(x_i).

If sum(x_i) >= c, outputs -1, else outputs x_i.

Wait, in the first test case, sum(x_i)=41 < c=42, which is correct.

But in the sample, they have sum(x_i)=80 < c=81 (for k=3), but according to this approach, it's sum(x_i)=41 < c=42.

So, their sum is higher, but still valid.

Maybe multiple solutions exist.

As long as x_i >= floor(c / k_i), and sum(x_i) < c.

Wait, no.

In the approach above, x_i = c / k_i, and sum(x_i) <c.

But in the sample, they have x_i > c / k_i.

Wait, in the first test case, c=42, x_i=[14,21,6].

But in the sample, x_i=[27,41,12].

Wait, 27 >42/3=14, 41 >42/2=21, 12 >42/7=6.

So, they chose x_i > c / k_i, which still satisfies k_i * x_i > sum(x_j).

Because k_i * x_i > k_i * (c / k_i) = c > sum(x_j).

Hence, it's still valid.

So, multiple solutions exist.

The approach in the code finds the minimal x_i = c / k_i, and if sum(x_i) <c, it's valid.

But larger x_i are also acceptable, as long as sum(x_i) < min over i of (k_i * x_i).

So, the code's approach is correct.

Now, let's see if the code implements this correctly.

It reads t, then for each test case:

- Reads n

- Reads k_1 to k_n

- Computes c = LCM of k_i

- For each i, sets x_i = c / k_i

- Computes sum(x_i)

- If sum(x_i) >=c, outputs -1, else outputs x_i.

Seems correct.

But in the first test case, sum(x_i)=41 < c=42, so should output [14,21,6], but sample outputs [27,41,12].

But as discussed, both are valid.

Hence, the code is correct.

Therefore, Correctness: **True**

**Final Solution**

To solve this problem, we need to determine how to distribute coins among different outcomes in a game such that, regardless of which outcome wins, the return is greater than the total amount bet. This requires careful calculation to ensure that the bets are distributed optimally.

## Approach

1. **Understanding the Requirements**:
   - For each outcome `i`, there is a multiplier `k_i`. If outcome `i` wins, we get back `k_i * x_i` coins, where `x_i` is the amount bet on outcome `i`.
   - We need to ensure that for every possible winning outcome, the return is greater than the total sum of all bets.

2. **Key Insight**:
   - We need to find integer amounts `x_i` such that for each `i`, `k_i * x_i > sum of all x_j`.
   - This can be achieved by ensuring that the sum of all `x_j` is less than each `k_i * x_i`.

3. **Solution Strategy**:
   - Compute the Least Common Multiple (LCM) of all `k_i`. Let's denote this LCM as `c`.
   - Set each `x_i` to `c // k_i`. This ensures that `k_i * x_i = c`.
   - Check if the sum of all `x_i` is less than `c`. If it is, then this distribution is valid; otherwise, no solution exists.

4. **Edge Cases**:
   - If the sum of `1/k_i` for all `i` is greater than or equal to 1, no solution exists.
   - Ensure that all `x_i` are positive integers and within the given constraints.

## Solution Code

```python
from math import gcd

def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        k = list(map(int, input().split()))
        
        # Compute LCM of k
        def lcm(a, b):
            return a * b // gcd(a, b)
        
        c = 1
        for num in k:
            c = lcm(c, num)
        
        # Compute x_i and their sum
        x = [c // ki for ki in k]
        s = sum(x)
        
        # Check if sum is less than c
        if s >= c:
            print(-1)
        else:
            print(' '.join(map(str, x)))

if __name__ == "__main__":
    func()
```

## Explanation

1. **Reading Input**:
   - Read the number of test cases `t`.
   - For each test case, read the number of outcomes `n` and the list of multipliers `k`.

2. **Computing LCM**:
   - Define a helper function `lcm(a, b)` to compute the LCM of two numbers using the GCD.
   - Compute the LCM of all `k_i` to get `c`.

3. **Distributing Bets**:
   - Calculate each `x_i` as `c // k_i`.
   - Compute the sum `s` of all `x_i`.

4. **Checking Validity**:
   - If `s >= c`, print `-1` (no solution exists).
   - Otherwise, print the list of `x_i`.

This approach ensures that the bets are distributed optimally and meet the problem's constraints efficiently.