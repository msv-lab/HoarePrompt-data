Alright, I've got this problem to solve. Let's see what it's asking for. So, there's this queue of n people, and Kirill comes in and stands at the end, which is position n. But he doesn't like waiting, so he wants to move up in the queue to be among the first m people. To do that, he can bribe people ahead of him to swap places. Each swap has a cost associated with it, which depends on the person he's swapping with and the people in between.

Let me try to understand the problem better. Kirill is at position i, which initially is n, and he wants to reach a position j where j <= m. To swap with someone at position k, where k < i, he has to pay a_k to that person, and for everyone between k and i, he has to pay b_l for each of them.

I need to find the minimum cost for Kirill to move from position n to some position <= m.

First, I should think about how Kirill can move up in the queue. He can perform multiple swaps, each time choosing to swap with someone ahead of him, and each swap has a certain cost.

This sounds like a path-finding problem, where each position in the queue is a node, and swaps are edges with certain costs. I need to find the path from position n to some position <= m with the minimum total cost.

But maybe there's a smarter way to approach this without building a graph.

Let me consider the queue positions from 1 to n, with 1 being the front. Kirill starts at n.

He wants to reach some position j, where j <= m.

To get from n to j, he can perform swaps, each time moving closer to the front.

Each swap from i to k (k < i) costs a_k plus the sum of b_l for l from k+1 to i-1.

I need to minimize the total cost.

Hmm, this seems a bit complicated. Maybe I can think of it differently.

Perhaps I can consider the cost of moving directly from n to some position <= m, considering the costs along the way.

Wait, maybe I can model this as a dynamic programming problem.

Let me define dp[i] as the minimum cost to reach position i, where i <= m.

I need to compute dp[i] for all i from 1 to m, and then take the minimum among them.

But how do I compute dp[i]?

To reach position i, Kirill can swap with person at position i, coming from any position j where i < j <= n.

The cost of swapping from j to i would be a_i plus the sum of b_k for k from i+1 to j-1.

Wait, no. Let's see: when Kirill swaps with person at position i, he pays a_i to that person, and for each person between i and j, he pays b_k.

But I'm getting confused.

Let me try to rephrase it.

Suppose Kirill is at position j, and he wants to swap with person at position i, where i < j.

He pays a_i to person at position i, and for each person k where i < k < j, he pays b_k.

So, the total cost for this swap is a_i + sum of b_k from k=i+1 to j-1.

Yes, that makes sense.

So, to compute dp[i], I need to consider all possible positions j where i < j <= n, and take the minimum over (a_i + sum_{k=i+1}^{j-1} b_k + dp[j]).

Wait, no. Actually, if Kirill swaps from j to i, then after the swap, he is at position i, and the person he swapped with is at position j.

But I think I need to think differently.

Maybe I should consider the positions in reverse order, starting from position n down to position 1.

Let me consider processing the positions from n down to 1, keeping track of the minimum cost to reach position <= m.

Let me define dp[i] as the minimum cost to move from position i to some position <= m.

Then, dp[i] can be computed as follows:

- If i <= m, then dp[i] = 0, because Kirill is already among the first m positions.

- Otherwise, dp[i] is the minimum over all j where j < i, of (a_j + sum_{k=j+1}^{i-1} b_k + dp[j]).

Wait, no. If Kirill is at position i and swaps with position j (j < i), he pays a_j plus sum_{k=j+1}^{i-1} b_k, and then he is at position j, and needs to pay dp[j] to reach positions <= m from there.

So, dp[i] = min over j < i of (a_j + sum_{k=j+1}^{i-1} b_k + dp[j]).

This seems correct.

But computing this directly would be too slow, as n can be up to 2e5, and t is up to 1e4.

I need a smarter way to compute this.

Let me see if I can find a way to compute dp[i] efficiently.

First, observe that sum_{k=j+1}^{i-1} b_k can be precomputed using prefix sums.

Let me define prefix[k] = sum_{l=1 to k} b_l.

Then, sum_{k=j+1}^{i-1} b_k = prefix[i-1] - prefix[j].

So, dp[i] = min over j < i of (a_j + prefix[i-1] - prefix[j] + dp[j]).

This can be rearranged as:

dp[i] = min over j < i of (a_j - prefix[j] + dp[j]) + prefix[i-1].

Notice that prefix[i-1] is added after the min operation.

So, if I define temp[j] = a_j - prefix[j] + dp[j], then dp[i] = min(temp[j] for j < i) + prefix[i-1].

This seems promising.

Now, I can compute dp[i] efficiently if I can compute the minimum of temp[j] for j < i.

Since I'm processing i from 1 to n, I can keep track of the minimum temp[j] so far.

Wait, but I need to make sure that dp[j] is already computed when computing temp[j].

Wait, no, dp[j] should be computed for j < i, so if I process i from 1 to n, and keep track of the minimum of (a_j - prefix[j] + dp[j]) for j < i, then dp[i] = min_temp + prefix[i-1].

Yes, that should work.

So, I can iterate i from 1 to n:

compute dp[i] = min_temp + prefix[i-1]

update min_temp = min(min_temp, a[i] - prefix[i] + dp[i])

Wait, let's verify this.

We have temp[j] = a_j - prefix[j] + dp[j]

min_temp = min over j < i of temp[j]

dp[i] = min_temp + prefix[i-1]

Then, temp[i] = a_i - prefix[i] + dp[i] = a_i - prefix[i] + (min_temp + prefix[i-1]) = a_i - prefix[i] + min_temp + prefix[i-1]

But prefix[i] = prefix[i-1] + b_i, so -prefix[i] + prefix[i-1] = -b_i.

So, temp[i] = a_i - b_i + min_temp

Then, min_temp for the next iteration would be min(min_temp, temp[i]) = min(min_temp, a_i - b_i + min_temp)

Wait, that seems a bit messy.

Maybe there's a better way to think about this.

Alternatively, perhaps I can use a sliding window minimum, but I'm not sure.

Let me consider the base cases.

If i <= m, then dp[i] = 0.

So, for i from 1 to m, dp[i] = 0.

For i from m+1 to n, dp[i] = min over j < i of (a_j + sum_{k=j+1}^{i-1} b_k + dp[j])

But since dp[j] = 0 for j <= m, this simplifies for i > m.

Wait, dp[j] is 0 for j <= m, because Kirill is already in the desired position.

So, for i > m, dp[i] = min over j from m+1 to i-1 of (a_j + sum_{k=j+1}^{i-1} b_k + dp[j])

But dp[j] is 0 for j <= m, and for j > m, it's dp[j].

Wait, no, dp[j] is 0 for j <= m, and for j > m, it's the minimum cost to reach from j to some position <= m.

Wait, but since dp[j] for j <= m is 0, and for j > m, it's the minimum cost to reach from j to some position <= m, which would involve swapping to some position <= m or to some intermediate position.

Wait, maybe I need to think differently.

Let me consider that dp[i] is the minimum cost to move from position i to some position <= m.

Then, for i <= m, dp[i] = 0.

For i > m, dp[i] = min over j from m to i-1 of (a_j + sum_{k=j+1}^{i-1} b_k + dp[j])

But dp[j] for j <= m is 0.

So, dp[i] = min over j from m to i-1 of (a_j + sum_{k=j+1}^{i-1} b_k)

Now, sum_{k=j+1}^{i-1} b_k = prefix[i-1] - prefix[j]

So, dp[i] = min over j from m to i-1 of (a_j + prefix[i-1] - prefix[j])

This can be rearranged as:

dp[i] = prefix[i-1] + min over j from m to i-1 of (a_j - prefix[j])

So, dp[i] = prefix[i-1] + min_{m <= j <= i-1} (a_j - prefix[j])

This seems efficient to compute.

I can precompute prefix[j] for all j, and then for each i from m+1 to n, compute dp[i] as prefix[i-1] plus the minimum of (a_j - prefix[j]) for j from m to i-1.

To compute this efficiently, I can keep track of the minimum of (a_j - prefix[j]) for j from m to i-1, using a sliding window minimum.

But since m can be as large as n, and n can be up to 2e5, I need an efficient way to compute this.

Wait, m can be up to n, but in practice, for i from m+1 to n, I need to compute the minimum of (a_j - prefix[j]) for j from m to i-1.

I can maintain a variable that keeps track of the minimum (a_j - prefix[j]) for j from m to i-1, and update it as I iterate i from m+1 to n.

Yes, that should work.

So, here's the plan:

1. Read t, the number of test cases.

2. For each test case:

a. Read n and m.

b. Read array a of size n.

c. Read array b of size n.

d. If m == n, then dp[n] = 0, since Kirill is already at position <= m.

e. Else, compute prefix[j] for j from 1 to n-1.

f. Initialize dp[j] = 0 for j from 1 to m.

g. For i from m+1 to n:

- Compute dp[i] = prefix[i-1] + min_{j from m to i-1} (a_j - prefix[j])

h. Then, the answer is the minimum dp[j] for j from 1 to m.

Wait, no. Wait, Kirill wants to be in any position <= m, so he can choose to stop at any position j where j <= m.

But in the dp approach above, dp[i] is the cost to move from i to some position <= m.

But actually, in the problem, Kirill starts at position n and can perform swaps to reach any position <= m.

So, perhaps I need to compute the minimum cost to reach position n to some position <= m via a sequence of swaps.

Wait, perhaps I need to think of it as the minimum cost to rearrange Kirill to some position <= m.

Wait, maybe I need to think in terms of the final position of Kirill.

He can perform any sequence of swaps as long as he ends up in some position <= m.

I need to find the minimum cost among all possible final positions j <= m.

So, for each j from 1 to m, compute the cost to move Kirill to position j, and then take the minimum over these costs.

But computing for each j the cost to move to j would be too slow.

Wait, perhaps I can model this as a graph where each position is a node, and there are edges from i to j with cost a_j + sum_{k=j+1}^{i-1} b_k, for j < i.

Then, I need to find the minimum cost path from n to some node <= m.

But with n up to 2e5, building a graph is not feasible.

I need a better approach.

Let me consider that Kirill can perform multiple swaps.

Each swap moves him from position i to position j, paying a_j + sum_{k=j+1}^{i-1} b_k.

I need to find a sequence of swaps that minimizes the total cost.

This seems similar to finding the shortest path in a graph where edges are costs of swaps.

But again, building such a graph is not practical due to time and space constraints.

I need a smarter way.

Let me consider that Kirill can swap directly from position n to any position <= n-1, and from there to any position <= that position, and so on, until he reaches some position <= m.

But this seems too vague.

Wait, maybe I can think of it recursively.

Define dp[i] as the minimum cost to move from position i to some position <= m.

Then, dp[i] = min over j < i of (a_j + sum_{k=j+1}^{i-1} b_k + dp[j])

But as before, this is O(n^2), which is too slow for n=2e5.

I need to optimize this.

Let me consider the sum sum_{k=j+1}^{i-1} b_k.

This can be precomputed using prefix sums.

Let prefix[i] = sum_{k=1 to i} b_k.

Then, sum_{k=j+1}^{i-1} b_k = prefix[i-1] - prefix[j].

So, dp[i] = min over j < i of (a_j + prefix[i-1] - prefix[j] + dp[j])

Rearranged: dp[i] = min over j < i of (a_j - prefix[j] + dp[j]) + prefix[i-1]

Define temp[j] = a_j - prefix[j] + dp[j]

Then, dp[i] = min over j < i of temp[j] + prefix[i-1]

So, I can keep track of the minimum temp[j] for j < i, and then dp[i] = min_temp + prefix[i-1]

Then, temp[i] = a_i - prefix[i] + dp[i]

So, in code, I can iterate i from 1 to n:

if i <= m:

dp[i] = 0

temp[i] = a[i] - prefix[i] + dp[i]

min_temp = min(min_temp, temp[i])

else:

dp[i] = min_temp + prefix[i-1]

temp[i] = a[i] - prefix[i] + dp[i]

min_temp = min(min_temp, temp[i])

Then, the answer is dp[m], but actually, Kirill can choose to be in any position <= m, so the answer is the minimum dp[j] for j from 1 to m.

Wait, but in the dp definition, dp[i] is the minimum cost to move from position i to some position <= m.

But in the problem, Kirill starts at position n and wants to reach some position <= m.

So, perhaps I need to compute dp[n], which would give the minimum cost to move from n to some position <= m.

But according to the dp definition above, dp[n] would be the minimum cost to move from n to some position <= m.

But in the code above, dp[n] is computed based on min_temp, which is the minimum of temp[j] for j < n.

temp[j] = a[j] - prefix[j] + dp[j]

But dp[j] for j < n is already computed.

Wait, perhaps I need to adjust the dp definition.

I'm getting a bit confused.

Let me try to implement this step by step.

First, compute prefix[i] = sum_{k=1 to i} b_k

Initialize dp[j] = 0 for j from 1 to m

Initialize temp[j] = a[j] - prefix[j] for j from 1 to m

min_temp = min(temp[1..m])

Then, for i from m+1 to n:

dp[i] = min_temp + prefix[i-1]

temp[i] = a[i] - prefix[i] + dp[i]

min_temp = min(min_temp, temp[i])

Finally, the answer is dp[m]

Wait, but dp[m] is already 0, and Kirill can choose to stop at any position <= m, so perhaps the answer is dp[m], but actually, he might have cheaper options by stopping at positions < m.

Wait, no. dp[m] is 0, but dp[i] for i > m would be greater than or equal to 0.

Wait, perhaps I need to consider that Kirill can choose to stop at any position <= m, so the answer is the minimum dp[j] for j from 1 to m.

But according to the dp definition, dp[j] = 0 for j <= m.

Wait, that can't be right.

I think I need to adjust the dp definition.

Let me try to redefine dp[i] as the minimum cost to reach position i from position n.

Wait, that might not make sense.

Alternatively, perhaps dp[i] is the minimum cost to move from position i to some position <= m.

Then, dp[i] = min over j < i of (a_j + sum_{k=j+1}^{i-1} b_k + dp[j])

With dp[j] = 0 for j <= m.

This seems similar to what I had before.

But I need to compute dp[n], which would be the minimum cost to move from n to some position <= m.

But according to the above, dp[n] = min over j < n of (a_j + sum_{k=j+1}^{n-1} b_k + dp[j])

But dp[j] for j < n could be 0 if j <= m, or computed values otherwise.

This still seems too slow.

I need to find a way to compute dp[i] in O(1) or O(log n) time.

Let me consider that sum_{k=j+1}^{i-1} b_k = prefix[i-1] - prefix[j]

So, dp[i] = min over j < i of (a_j + prefix[i-1] - prefix[j] + dp[j])

Rearranged: dp[i] = min over j < i of (a_j - prefix[j] + dp[j]) + prefix[i-1]

Define c[j] = a_j - prefix[j] + dp[j]

Then dp[i] = min_c + prefix[i-1], where min_c is the minimum c[j] for j < i

Then, c[i] = a_i - prefix[i] + dp[i]

So, in code:

Initialize prefix[0] = 0

prefix[i] = prefix[i-1] + b[i] for i from 1 to n-1

Initialize dp[j] = 0 for j from 1 to m

Initialize min_c = min over j from 1 to m of (a[j] - prefix[j])

Then, for i from m+1 to n:

dp[i] = min_c + prefix[i-1]

c_i = a[i] - prefix[i] + dp[i]

min_c = min(min_c, c_i)

Finally, the answer is dp[n]

Wait, but in the problem, Kirill can choose to stop at any position <= m, so the answer should be the minimum dp[j] for j from 1 to m.

But according to this, dp[j] = 0 for j <= m.

Wait, perhaps I need to adjust the dp definition.

Wait, maybe dp[i] should be the minimum cost to move from position i to some position <= m, including the cost of moving from i to j and then from j to <= m.

But dp[j] for j <= m is 0, so dp[i] = min over j < i of (a_j + sum_{k=j+1}^{i-1} b_k)

Because dp[j] = 0 for j <= m.

Wait, perhaps I can set dp[j] = 0 for j <= m, and for j > m, dp[j] = min over k < j of (a_k + sum_{l=k+1}^{j-1} b_l)

Then, dp[n] would be the cost to move from n to some position <= m.

But I need to minimize over all possible final positions <= m.

Wait, perhaps I need to consider that Kirill can choose to stop at any position <= m, so the answer is the minimum over all possible paths that end at some position <= m.

This is getting too complicated.

Let me try to think differently.

Suppose Kirill moves from position n to position j1, then to j2, and so on, until he reaches some position <= m.

Each move from position i to position j (j < i) costs a_j + sum_{k=j+1}^{i-1} b_k

I need to find the minimum total cost for any sequence of moves that ends with Kirill at some position <= m.

This sounds like a shortest path problem in a graph where nodes are positions, and edges are possible swaps with their costs.

But with n up to 2e5, building such a graph is impractical.

I need a better approach.

Let me consider that Kirill can move directly from position n to any position j < n, paying a_j + sum_{k=j+1}^{n-1} b_k, and then from j to any position < j, and so on, until he reaches some position <= m.

I need to find the minimum cost among all such paths.

This seems similar to finding the minimum cost of a path in a tree, where each node can have multiple parents.

But I'm not sure.

Wait, perhaps I can model this as a functional graph where each node i has edges to all nodes j < i with the corresponding swap cost.

But again, with n=2e5, this is not feasible.

I need to find a mathematical pattern or formula to compute the minimum cost without explicitly modeling the graph.

Let me consider that the total cost to move from n to some position <= m involves summing a_j for some j's and summing b_k for the in-between positions.

Perhaps I can think in terms of selecting a subset of positions to swap with, and computing the total cost accordingly.

But I'm not sure.

Wait, maybe I can consider that Kirill needs to pay a_j for each person he swaps with, and b_k for each person between the swap positions.

This seems similar to paying a_j for each swap and b_k for each position crossed.

Wait, perhaps I can think of it as paying a_j for each swap and b_k for each position skipped.

But I'm still not seeing a clear pattern.

Let me try to look at small examples to see if I can find a pattern.

Take the first sample input:

4 2

7 3 6 9

4 3 8 5

So, n=4, m=2

a = [7,3,6,9]

b = [4,3,8,5]

Kirill starts at position 4, with a[4]=9

He can swap with position 3, paying a[3]=6 and sum_{k=4} b_k = 5, total 11, then he's at position 3.

From position 3, he can swap with position 2, paying a[2]=3 and sum_{k=3} b_k = 8, total 11, so total cost so far is 11 + 11 = 22

Or, from position 3, he can swap directly to position 1, paying a[1]=7 and sum_{k=2} b_k = 3, total 10, so total cost 11 + 10 = 21

Alternatively, from position 4, he can swap directly to position 2, paying a[2]=3 and sum_{k=3,4} b_k = 8 + 5 = 13, total 16, then from position 2, he can swap to position 1, paying a[1]=7 and sum_{k=2} b_k = 3, total 10, so total cost 16 + 10 = 26

Wait, but according to the sample output, the answer is 14, which is less than any of these.

So, perhaps there's a better sequence of swaps.

Wait, maybe from position 4, swap to position 1, paying a[1]=7 and sum_{k=2,3,4} b_k = 3 + 8 + 5 = 16, total 23, which is higher than previous options.

Wait, maybe I'm missing something.

Wait, perhaps Kirill can swap to position 3, paying a[3]=6 and sum_{k=4} b_k=5, total 11, then from position 3, swap to position 1, paying a[1]=7 and sum_{k=2} b_k=3, total 10, so total 21

But the sample output is 14, which is less than 21, so there must be a better way.

Wait, maybe from position 4, swap to position 2, paying a[2]=3 and sum_{k=3,4} b_k=8+5=13, total 16, then from position 2, swap to position 1, paying a[1]=7 and sum_{k=2} b_k=3, total 10, so total 26, which is higher than 21.

Wait, perhaps there's a better sequence.

Wait, maybe from position 4, swap to position 3, paying a[3]=6 and b[4]=5, total 11, then from position 3, swap to position 2, paying a[2]=3 and b[3]=8, total 11, so total 22

Wait, that's 22, which is higher than 21.

Wait, perhaps from position 4, swap to position 3, paying 11, then from position 3, swap to position 2, paying 11, total 22

Or from position 4, swap to position 2, paying 16, then from position 2, swap to position 1, paying 10, total 26

Or from position 4, swap to position 1, paying 23

So, the best is 21, but the sample output is 14, which is less.

So, perhaps I'm missing a better sequence.

Wait, maybe Kirill can swap directly from position 4 to position 2, paying a[2]=3 and sum_{k=3,4} b_k=8+5=13, total 16, and then he's at position 2, which is <= m, so he stops.

Total cost is 16, which is higher than 14.

Wait, how can the answer be 14?

Maybe there's