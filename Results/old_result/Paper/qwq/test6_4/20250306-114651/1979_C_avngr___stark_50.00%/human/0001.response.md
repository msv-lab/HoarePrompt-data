Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n possible outcomes in a game, and for each outcome, there's a multiplier k_i. I need to bet some integer amount of coins on each outcome. The goal is to distribute my bets in such a way that no matter which outcome wins, the amount I get back is more than the total amount I bet.

First, I need to understand the constraints. For each test case, I have n outcomes, each with its own k_i, which is the multiplier if that outcome wins. I need to choose bets x_1, x_2, ..., x_n such that for every i, k_i * x_i is greater than the sum of all bets. And I have to make sure that all x_i are at least 1 and no more than 10^9.

Looking at the example, in the first test case, n=3 and k=[3,2,7]. The solution provided is x=[27,41,12], and the total bet is 80 coins. Then, for each outcome:

- If outcome 1 wins: 3*27 = 81 > 80

- If outcome 2 wins: 2*41 = 82 > 80

- If outcome 3 wins: 7*12 = 84 > 80

So, it satisfies the condition.

In the second test case, n=2 and k=[3,3], with x=[1,1], total bet is 2 coins.

- 3*1 = 3 > 2

- 3*1 = 3 > 2

Again, it works.

In the third test case, n=5 with all k=5, and the output is -1, meaning it's impossible to find such bets.

So, I need to find a general way to determine if such bets exist and what they are.

Let me think about the mathematical formulation.

Let S be the total sum of all bets: S = x_1 + x_2 + ... + x_n

For each i, k_i * x_i > S

I can rearrange this inequality:

k_i * x_i > S

But S = x_1 + x_2 + ... + x_n

So, k_i * x_i > x_1 + x_2 + ... + x_n

I can write this as:

k_i * x_i - x_i > x_1 + x_2 + ... + x_{i-1} + x_{i+1} + ... + x_n

Which simplifies to:

x_i * (k_i - 1) > sum_{j≠i} x_j

This seems a bit messy. Maybe there's a better way to approach this.

I recall that in some optimization problems, finding such distributions involves finding a common multiple or using the least common multiple (LCM) of certain values.

Looking at the code provided, it seems to be attempting something similar.

Let's look at the code step by step.

First, it reads the number of test cases, t.

For each test case, it reads n and the list k of multipliers.

Then, it initializes m to 1 and computes m as the product of all k_i.

So, m = k1 * k2 * ... * kn

Then, it computes a list c where each c_i = m / k_i

So, c_i = m / k_i = (k1 * k2 * ... * kn) / k_i = product of all k_j where j ≠ i

Then, it computes the greatest common divisor (GCD) of all c_i using a function func_1, which is just the GCD of the list.

Then, it normalizes c_i by dividing each by the GCD: c_i = c_i / hcf

Then, it checks if the sum of c_i is greater than or equal to m / hcf. If yes, it prints -1; else, it prints the c_i.

Wait, that's interesting.

Let me see what's happening here.

First, m is the product of all k_i.

Then, c_i = m / k_i, which is the product of all k_j where j ≠ i.

Then, it computes the GCD of all c_i and divides each c_i by this GCD to get the smallest possible integers.

Then, it checks if the sum of these c_i is less than m / hcf.

If sum(c_i) < m / hcf, it outputs c_i; else, -1.

I need to verify if this logic is correct.

Let me take the first example:

n=3, k=[3,2,7]

m = 3*2*7 = 42

c = [42/3=14, 42/2=21, 42/7=6]

GCD of [14,21,6] is 1.

So, c_i remain [14,21,6]

sum(c_i)=14+21+6=41

m/hcf=42/1=42

41 < 42, so it outputs [14,21,6]

But in the sample output, it's [27,41,12]. Wait, that's different.

Hmm, maybe there are multiple solutions.

But in the code, it's outputting [14,21,6], but the sample output is [27,41,12]. Maybe the solution isn't unique, and the code is outputting a different valid solution.

Wait, in the code, it's outputting c_i, which in this case is [14,21,6], but the sample output is [27,41,12]. So, perhaps the code is incorrect because it's not matching the sample output.

Wait, maybe I misread the code.

Looking back, the code has:

if sum(c) >= m / hcf:

print(-1)

else:

for i in range(n):

print(c[i], end=' ')

print('')

In the first test case, sum(c)=41 < m/hcf=42, so it should output [14,21,6], but the sample output is [27,41,12]. So, either the sample output is just one of many possible solutions, or the code is incorrect.

I need to check if [14,21,6] is a valid solution.

Total sum S=14+21+6=41

Check each k_i * x_i:

3*14=42 >41

2*21=42 >41

7*6=42 >41

So, it's valid. So, [14,21,6] is also a valid solution. The sample output shows [27,41,12], which is another valid solution.

So, multiple solutions exist, and the code is outputting [14,21,6], which is correct. So, in this case, the code is correct.

Let's look at the second test case:

n=2, k=[3,3]

m=3*3=9

c=[9/3=3, 9/3=3]

GCD=3

c_i=[1,1]

sum(c_i)=2

m/hcf=9/3=3

2 < 3, so output [1,1], which matches the sample output.

Good.

Third test case:

n=5, k=[5,5,5,5,5]

m=5^5=3125

c=[3125/5=625] for all i

GCD=625

c_i=[1,1,1,1,1]

sum(c_i)=5

m/hcf=3125/625=5

5 >=5, so sum(c_i) >= m/hcf, output -1, which matches the sample.

Fourth test case:

n=6, k=[7,9,3,17,9,13]

m=7*9*3*17*9*13= (let's calculate this)

7*9=63

63*3=189

189*17=3213

3213*9=28917

28917*13=375921

c_i = m / k_i

c1=375921/7=53703

c2=375921/9=41769

c3=375921/3=125307

c4=375921/17=22113

c5=375921/9=41769

c6=375921/13=28917

GCD of these numbers: well, k_i are [7,9,3,17,9,13], all multipliers are coprime except for k2 and k5 being both 9.

Wait, k2 and k5 are both 9, so GCD of c_i would be ... let's see.

c1=53703, c2=41769, c3=125307, c4=22113, c5=41769, c6=28917

GCD of these numbers. Since m is 375921 and k_i are as above, hcf would be ... hard to compute manually, but let's assume it's correct.

Then, c_i divided by hcf.

Finally, sum(c_i) is compared with m/hcf.

If sum(c_i) < m/hcf, then output c_i, else -1.

In the sample output, it's a list of numbers, so presumably sum(c_i) < m/hcf.

Fifth test case:

n=3, k=[6,3,2]

m=6*3*2=36

c=[36/6=6, 36/3=12, 36/2=18]

GCD=6

c_i=[1,2,3]

sum(c_i)=6

m/hcf=36/6=6

6 >=6, so output -1, which matches the sample.

Sixth test case:

n=5, k=[9,4,6,8,3]

m=9*4*6*8*3=5184

c=[5184/9=576, 5184/4=1296, 5184/6=864, 5184/8=648, 5184/3=1728]

GCD=576

c_i=[1, 1296/576=2.25, wait, no, GCD of [576,1296,864,648,1728]

Wait, GCD of these numbers is 576.

So, c_i=[576/576=1, 1296/576=2.25, which is not integer, wait, no.

Wait, 1296 divided by 576 is 2.25, but in the code, it's using integer division, but in Python, it's using float division.

Wait, in the code, it's using int(m / k[i]), so integer division.

But, in Python 3, int(a / b) does float division and then truncates to int.

So, 1296 / 576 = 2.25, but int(2.25)=2.

Wait, but in the sample output, it's [8,18,12,9,24]

Let's see:

If c_i after dividing by hcf=576:

c1=576/576=1

c2=1296/576=2.25, but int division would make it 2

c3=864/576=1.5, int division 1

c4=648/576=1.125, int division 1

c5=1728/576=3

So, c_i=[1,2,1,1,3]

Sum=8

m/hcf=5184/576=9

8 <9, so it should output [1,2,1,1,3], but the sample output is [8,18,12,9,24], which is different.

So, again, multiple solutions are possible.

But the code is outputting [1,2,1,1,3], which seems valid:

Sum=8

Check each k_i * x_i:

9*1=9 >8

4*2=8 >=8, but it should be strictly greater than S.

Wait, 4*2=8 is not greater than 8, it's equal.

Oh, so this is a problem.

In the sample output, it's [8,18,12,9,24], which sums to 71.

Check:

9*8=72 >71

4*18=72 >71

6*12=72 >71

8*9=72 >71

3*24=72 >71

So, that's correct.

But the code's output [1,2,1,1,3] sums to 8.

Check:

9*1=9 >8

4*2=8 >=8, but it should be strictly greater than 8.

6*1=6 <8

8*1=8 >=8, not strictly greater.

3*3=9 >8

So, this doesn't satisfy the condition for some outcomes.

Hence, the code is incorrect because it allows some k_i * x_i to be equal to S, which is not allowed; it must be strictly greater than S.

In this case, for outcome 2: 4*2=8, which is equal to S=8, which violates the condition.

So, the code is incorrect.

I need to fix this.

Let me think about how to ensure that k_i * x_i > S for all i.

Maybe I need to scale up the x_i to ensure that k_i * x_i > S.

In the code, after computing c_i and normalizing by hcf, it checks if sum(c_i) < m / hcf.

But in the above example, sum(c_i)=8 and m/hcf=9, which is correct, but some k_i * x_i are equal to S.

So, perhaps I need to scale up x_i by some factor to make sure that k_i * x_i > S.

Let me consider that.

Suppose I have x_i, and S=sum(x_i).

I need k_i * x_i > S for all i.

Suppose I multiply all x_i by some factor f.

Then, S_new = f * S

And k_i * x_i_new = k_i * f * x_i

I need k_i * f * x_i > f * S

Which simplifies to k_i * x_i > S, which is the same condition.

So, scaling doesn't help.

I need another approach.

Let me think differently.

Suppose I set x_i = S / (k_i - 1)

Then, k_i * x_i = k_i * (S / (k_i -1)) = (k_i / (k_i -1)) * S

I need this to be greater than S, so:

(k_i / (k_i -1)) * S > S

Which simplifies to k_i / (k_i -1) >1, which is always true since k_i >=2.

But this seems too loose.

Alternatively, maybe I need to set x_i proportional to the product of all k_j except k_i.

That's what the code is doing.

Wait, perhaps I need to find the smallest S such that there exist x_i satisfying the conditions.

Let me consider that.

Let me denote S as the total sum: S = x_1 + x_2 + ... + x_n

And for each i, k_i * x_i > S

I can write x_i > S / k_i

But since x_i are integers, x_i >= ceil(S / k_i)

Summing over all i:

S = sum(x_i) >= sum(ceil(S / k_i) for all i)

This is a bit tricky because S is on both sides.

This seems like a non-linear inequality.

Maybe I can find a lower bound for S.

Let me assume that S >= sum(ceil(S / k_i)) for all i.

This seems complicated.

Perhaps a better way is to use the harmonic mean or something similar.

Alternatively, I can look for a feasible solution by assigning x_i proportional to some weight.

Looking back at the code, it's setting x_i = m / k_i / hcf, where m is the product of all k_j.

Wait, perhaps I need to ensure that x_i is at least m / k_i / hcf.

But in the earlier example, it didn't work because for k_i=4, x_i=2, and 4*2=8=S, which is not greater than S.

So, perhaps I need to set x_i to be slightly larger.

Let me consider setting x_i = ceil(m / k_i / hcf)

But even that might not be sufficient.

Wait, perhaps I need to set x_i = m / k_i / hcf * some factor.

Alternatively, maybe I need to set x_i = m / k_i / hcf * (S + 1)

No, that seems too vague.

Let me think about the condition again.

I need k_i * x_i > S for all i.

Which can be written as x_i > S / k_i

But since x_i are integers, x_i >= ceil(S / k_i)

So, S = sum(x_i) >= sum(ceil(S / k_i) for all i)

This seems like a circular dependency.

Maybe I can find the minimal S that satisfies this inequality.

Let me consider that.

Let me denote S_min as the minimal S that satisfies S >= sum(ceil(S / k_i) for all i)

This seems like defining S_min in terms of itself, which is tricky.

Perhaps I can use the fact that ceil(S / k_i) >= floor(S / k_i) + 1 if k_i does not divide S, and ceil(S / k_i) = floor(S / k_i) if k_i divides S.

This is getting complicated.

Maybe there's a better way.

I recall that in some problems involving inequalities like this, Bézout's identity or the Chinese Remainder Theorem is used, but I'm not sure.

Wait, perhaps I can model this as a system of inequalities and find a feasible solution.

Let me try to find x_i such that for all i, k_i * x_i > sum_{j=1 to n} x_j

I can rewrite this as:

k_i * x_i - sum_{j=1 to n} x_j > 0

Which can be rearranged to:

(k_i - 1) * x_i - sum_{j ≠ i} x_j > 0

This seems like a system of linear inequalities.

I'm not sure how to solve this directly.

Maybe I can consider expressing all x_i in terms of one variable.

But that might be too complex.

Let me consider the approach used in the code.

The code computes m as the product of all k_i.

Then, c_i = m / k_i

Then, it computes the GCD of all c_i and divides each c_i by this GCD.

Then, it checks if sum(c_i) < m / hcf.

If yes, it outputs c_i; else, -1.

In the earlier example, this didn't work because for k_i=4, x_i=2 led to k_i * x_i =8, which is equal to S=8, but it needs to be greater than S.

So, perhaps the condition should be sum(c_i) <= m / hcf - 1.

Wait, let's see.

If sum(c_i) < m / hcf, then it's okay.

But in the earlier case, sum(c_i)=8 and m/hcf=9, which satisfies 8 <9, but still, for k_i=4, 4*2=8 is equal to S=8.

So, that's not sufficient.

I need a stricter condition.

Maybe the condition should be sum(c_i) <= m / hcf - max(k_i)

Wait, that might be too strict.

Alternatively, perhaps sum(c_i) <= m / hcf - n

Not sure.

Let me think differently.

Suppose I set x_i = m / k_i / hcf

Then, k_i * x_i = k_i * (m / k_i / hcf) = m / hcf

And S = sum(x_i) = sum(m / k_i / hcf) for all i

In the earlier example, m=36, hcf=576, wait, no, hcf=576, m=5184 for that case.

Wait, in the sixth test case.

Wait, I'm getting confused.

Let me take a step back.

I need to ensure that for each i, k_i * x_i > sum(x_j for all j)

Let me consider that sum(x_j for j ≠ i) = S - x_i

So, k_i * x_i > S

But S = sum(x_j for all j)

So, k_i * x_i > S

Which can be written as x_i > S / k_i

But since x_i are integers, x_i >= ceil(S / k_i)

So, S = sum(x_j) >= sum(ceil(S / k_j) for all j)

This seems like a tricky dependency.

Maybe I can use the fact that ceil(S / k_j) >= floor(S / k_j) + (1 if k_j does not divide S else 0)

But this is getting too complicated.

Perhaps I need to find a way to make S < min(k_i * x_i) for all i.

Wait, that's the same as S < min(k_i * x_i)

But I need S < k_i * x_i for all i.

To maximize the lower bound, I need S < max(k_i * x_i)

Wait, no, I need S < k_i * x_i for all i.

I need to find x_i such that for all i, x_i > S / k_i

And S = sum(x_j)

This seems tricky.

Maybe I can use the method of least common multiple (LCM).

Wait, perhaps I can consider the LCM of (k_i -1).

No, not sure.

Let me look for an alternative approach.

I recall that in some optimization problems, finding such distributions involves finding a common multiple or using the least common multiple (LCM) of certain values.

Wait, perhaps I can consider the following:

Let me set x_i = m / k_i, where m is the LCM of all k_j.

Wait, in the code, m is the product of all k_i, which is not necessarily the LCM.

But perhaps using LCM would be better.

Let me compute m as LCM of all k_i.

Then, set x_i = m / k_i

Then, k_i * x_i = k_i * (m / k_i) = m

And S = sum(x_i) for all i = sum(m / k_i) for all i

I need m > sum(m / k_i)

Which simplifies to 1 > sum(1 / k_i)

So, if sum(1 / k_i) <1, then m > sum(m / k_i), which would satisfy the condition.

But in the sample input, for the first test case:

k=[3,2,7]

sum(1/k_i)=1/3 + 1/2 + 1/7 = (14 + 21 + 6)/42=41/42 <1

Which satisfies the condition.

In the second test case:

k=[3,3]

sum(1/k_i)=1/3 + 1/3=2/3 <1

Third test case:

k=[5,5,5,5,5]

sum(1/5)=1/5*5=1, which is not less than 1, so no solution, which matches the sample output of -1.

Fourth test case:

k=[7,9,3,17,9,13]

sum(1/7 +1/9 +1/3 +1/17 +1/9 +1/13)= let's calculate:

1/7 ≈0.1429

1/9≈0.1111

1/3≈0.3333

1/17≈0.0588

1/9≈0.1111

1/13≈0.0769

Sum≈0.1429+0.1111+0.3333+0.0588+0.1111+0.0769≈0.8341<1

So, solution exists.

Fifth test case:

k=[6,3,2]

sum(1/6 +1/3 +1/2)=1/6 +2/6 +3/6=6/6=1, which is not less than 1, so no solution, matches sample output of -1.

Sixth test case:

k=[9,4,6,8,3]

sum(1/9 +1/4 +1/6 +1/8 +1/3)=let's calculate:

1/9≈0.1111

1/4=0.25

1/6≈0.1667

1/8=0.125

1/3≈0.3333

Sum≈0.1111+0.25+0.1667+0.125+0.3333≈0.9861<1

So, solution exists.

Therefore, the condition sum(1/k_i)<1 determines if a solution exists.

If sum(1/k_i)<1, then a solution exists; else, no solution.

In such cases, setting x_i = m / k_i / hcf, where m is the LCM of all k_i, should work.

But in the code, m is the product of all k_i, which is not necessarily the LCM.

For example, in the second test case, k=[3,3], product m=9, LCM=3.

If I set m=3, then x_i=3/3=1 for both, sum=2, and 3*1=3>2, which works.

In the code, m=9, c_i=[3,3], hcf=3, c_i=[1,1], sum=2 < m/hcf=3, which also works.

So, using product works, but using LCM also works and might be more efficient.

But since m is smaller with LCM, perhaps it's better to use LCM.

But in the code, m is the product, which is always a multiple that satisfies the condition.

So, it's correct, but maybe not the minimal m.

But since the problem allows any solution with x_i <=10^9, using the product is fine, as long as m/hcf doesn't make x_i too large.

Given that n<=50 and k_i<=20, the product can be up to 20^50, which is way beyond 10^9.

Wait, but in the code, x_i = m / k_i / hcf, and m is the product of all k_j.

But in Python, integer sizes are unlimited, so it can handle large m.

But x_i must be <=10^9, as per the problem statement.

So, perhaps I need to ensure that x_i <=10^9.

In the code, it's using m as the product of all k_i, then c_i = m / k_i, then hcf is the GCD of all c_i, then c_i = c_i / hcf.

So, it's reducing the c_i by their GCD.

Then, it checks if sum(c_i) < m / hcf.

If yes, it outputs c_i; else, -1.

But in the earlier example, sum(c_i)=8 and m/hcf=9, which satisfies 8<9, but some k_i * x_i =8 which is equal to S=8, which is invalid.

So, perhaps the condition should be sum(c_i) <= m / hcf -1.

Let me check that.

In the sixth test case:

sum(c_i)=8, m/hcf=9

If I set sum(c_i) <= m/hcf -1, which is 8 <=8, which is true.

But in that case, for k_i=4, x_i=2, 4*2=8 which is equal to S=8, which is invalid.

So, perhaps even that is not sufficient.

Maybe I need to set sum(c_i) <= m/hcf - n

In the sixth test case, sum(c_i)=8, m/hcf=9, 8 <=9-5=-4, which is not true.

Wait, that doesn't make sense.

Alternatively, perhaps sum(c_i) <= m/hcf - max(ceil(m/hcf / k_i))

But this is getting too complicated.

Let me consider scaling up x_i by a factor.

Suppose I set x_i = c_i * f, where f is some integer factor.

Then, S = sum(x_i) = sum(c_i * f) = f * sum(c_i)

And for each i, k_i * x_i = k_i * c_i * f

Need k_i * c_i * f > f * sum(c_i)

Which simplifies to k_i * c_i > sum(c_i)

But this is just the same as the original condition.

So, scaling doesn't help.

I need to find the minimal f such that k_i * c_i * f > f * sum(c_i)

Which is the same as k_i * c_i > sum(c_i)

But this is independent of f.

So, if k_i * c_i > sum(c_i), then any f would satisfy.

But in the earlier example, for k_i=4, c_i=2, sum(c_i)=8, which is 4*2=8 >=8, which is not greater.

So, in this case, 4*2=8 is not greater than 8.

Hence, the condition k_i * c_i > sum(c_i) is not satisfied for k_i=4.

Hence, I need to scale up c_i.

Let me set x_i = c_i * f, and choose f such that for all i, k_i * x_i > sum(x_j)

Which is k_i * c_i * f > f * sum(c_j)

Divide both sides by f (assuming f>0):

k_i * c_i > sum(c_j)

So, f doesn't affect the inequality.

Hence, I need to choose f such that k_i * c_i * f > f * sum(c_j)

Which again reduces to k_i * c_i > sum(c_j)

Hence, if k_i * c_i > sum(c_j), then any f would work.

Otherwise, no solution exists.

But in the earlier case, for k_i=4, c_i=2, sum(c_j)=8, 4*2=8 >=8, which is invalid.

Hence, in this case, no such f exists that satisfies the condition.

Hence, in this case, the code's approach is insufficient.

I need to find a better way.

Perhaps I need to adjust c_i to ensure that for all i, k_i * c_i > sum(c_j)

Let me consider that.

Given c_i = m / k_i / hcf

I need k_i * c_i > sum(c_j)

Which is k_i * (m / k_i / hcf) > sum(m / k_j / hcf)

Simplify: m / hcf > sum(m / k_j / hcf)

Which is m > sum(m / k_j)

Which is 1 > sum(1 / k_j)

Which is the same condition as sum(1/k_j) <1

So, the condition sum(1/k_j) <1 determines if a solution exists.

And in that case, setting x_i = m / k_i / hcf, where m is the product of all k_j, and hcf is the GCD of m / k_j, should work.

But in the earlier example, it didn't work because sum(1/k_j)=41/42<1, but for k_i=4, x_i=2, and 4*2=8=S=8, which is invalid.

Wait, in that case, sum(1/k_j)=41/42<1, but it's still not sufficient to ensure that k_i * x_i > S.

So, perhaps I need to adjust x_i to ensure that k_i * x_i > S.

Let me think about setting x_i = ceil(m / k_i / hcf)

But in Python, ceil(m / k_i / hcf) with integer division is the same as -(-m // k_i) // hcf

But perhaps I need to use true floating-point division and then ceil.

Wait, in the code, it's using int(m / k_i), which is floor division.

Maybe I need to use ceil division.

But in Python, int(m / k_i) is floor division.

Wait, perhaps I need to use math.ceil(m / k_i).

But m / k_i could be a float, and x_i need to be integers.

Wait, in the code, m is integer, k_i is integer, so m / k_i is float in Python 3.

Then, int(m / k_i) is floor division.

But in the earlier example, m=36, k_i=6,3,2, so c_i=6,12,18, which is correct.

But for k_i=4, it was 1296/576=2.25, int(2.25)=2, which led to x_i=2, but 4*2=8=S=8, which is invalid.

So, perhaps I need to use ceil(m / k_i / hcf).

In Python, math.ceil(m / k_i / hcf)

But m / k_i / hcf could be a float.

So, perhaps I need to compute x_i = ceil(m / k_i / hcf)

But in the code, it's using int(m / k_i), then dividing by hcf.

Wait, perhaps I need to compute x_i = ceil(m / k_i / hcf)

But in the earlier case, m=5184, k_i=[9,4,6,8,3], hcf=576.

So, x_i = ceil(5184 / 9 / 576)=ceil(5184 / 9 / 576)=ceil(1.0)=1

x_i = ceil(5184 / 4 / 576)=ceil(2.25)=3

x_i = ceil(5184 / 6 / 576)=ceil(1.5)=2

x_i = ceil(5184 / 8 / 576)=ceil(1.125)=2

x_i = ceil(5184 / 3 / 576)=ceil(3.0)=3

Then