Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given two positive integers, n and m, and I need to find the number of ordered pairs (a, b) where 1 ≤ a ≤ n and 1 ≤ b ≤ m, with the condition that a + b is a multiple of b times the greatest common divisor (GCD) of a and b. That condition sounds a bit tricky, so I need to understand it better.

First, let's rephrase the condition: a + b should be divisible by b * GCD(a, b). In mathematical terms, that means (a + b) mod (b * GCD(a, b)) = 0.

I know that GCD(a, b) is the greatest common divisor of a and b, and it has some properties that might be useful here. For example, GCD(a, b) divides both a and b.

Let me try to simplify the condition. Let’s denote GCD(a, b) as d. So, a = d * a1 and b = d * b1, where GCD(a1, b1) = 1.

Substituting these into the condition:

a + b = d * a1 + d * b1 = d * (a1 + b1)

And b * GCD(a, b) = d * b1 * d = d^2 * b1

So, the condition becomes:

d * (a1 + b1) is divisible by d^2 * b1

Which simplifies to:

(a1 + b1) is divisible by d * b1

But since a1 and b1 are coprime (GCD(a1, b1) = 1), this condition might be easier to work with.

Wait, but I have d = GCD(a, b), and a = d * a1, b = d * b1, with GCD(a1, b1) = 1.

So, the condition is:

a + b = d * (a1 + b1)

And b * GCD(a, b) = d * b1 * d = d^2 * b1

So, d * (a1 + b1) should be divisible by d^2 * b1, which means (a1 + b1) should be divisible by d * b1.

But a1 and b1 are coprime, so a1 + b1 and b1 are not necessarily coprime, but perhaps I can find a relationship here.

Alternatively, maybe I should consider fixing b and finding for each b, how many a satisfy the condition.

Let’s fix b and find the number of a such that 1 ≤ a ≤ n and a + b is divisible by b * GCD(a, b).

This seems complicated because GCD(a, b) depends on a and b.

Maybe I can iterate over possible values of GCD(a, b). Let’s denote d = GCD(a, b). Then a = d * k and b = d * m, where GCD(k, m) = 1.

Then, a + b = d * (k + m)

And b * GCD(a, b) = d * m * d = d^2 * m

So, d(k + m) must be divisible by d^2 m, which implies that k + m must be divisible by d * m.

But since GCD(k, m) = 1, k and m are coprime, so k + m being divisible by m implies that k is divisible by m.

Wait, k + m divisible by m means k is divisible by m.

But k and m are coprime, so the only way k is divisible by m is if m = 1.

So, if m > 1, then no solutions.

Wait, that seems too strong. Let me check.

If m > 1, and k is divisible by m, but GCD(k, m) = 1, then m must be 1.

Because if m > 1 and k is divisible by m, then m divides k, but GCD(k, m) = 1 implies m = 1.

So, this suggests that for m > 1, there are no solutions.

But that can't be right, because in the sample input, when m = 3 and n = 2, the output is 3, which includes pairs like (1,1), (2,1), and (2,2). So clearly, there are solutions for m > 1.

Wait, perhaps I made a mistake in assuming that k + m divisible by d * m implies k is divisible by m.

Let me double-check that step.

We have k + m divisible by d * m.

Wait, d = GCD(a, b) = GCD(d * k, d * m) = d * GCD(k, m) = d, since GCD(k, m) = 1.

Wait, no, that's not right. GCD(d * k, d * m) = d * GCD(k, m), and since GCD(k, m) = 1, GCD(a, b) = d.

So, d = GCD(a, b).

But in the earlier step, I have k + m divisible by d * m.

But d = GCD(a, b) = d, which seems circular.

Maybe I need to approach this differently.

Let me try to consider specific values to see if I can find a pattern.

Take the first sample input: n = 1, m = 1.

Possible pair: (1,1).

Check condition: a + b = 2, b * GCD(a,b) = 1 * 1 = 1, and 2 is divisible by 1. So, it satisfies.

Second sample input: n = 2, m = 3.

Possible pairs: (1,1), (1,2), (1,3), (2,1), (2,2), (2,3).

Check each:

- (1,1): 1+1=2, 1*1=1, 2 divisible by 1 → yes

- (1,2): 1+2=3, 2*1=2, 3 not divisible by 2 → no

- (1,3): 1+3=4, 3*1=3, 4 not divisible by 3 → no

- (2,1): 2+1=3, 1*2=2, 3 not divisible by 2 → no

- (2,2): 2+2=4, 2*2=4, 4 divisible by 4 → yes

- (2,3): 2+3=5, 3*1=3, 5 not divisible by 3 → no

So, only (1,1) and (2,2) satisfy the condition. But according to the sample input, the output is 3, which contradicts my calculation. Wait, in the problem statement, it says for n=2, m=3, the output is 3, but according to my calculation, only two pairs satisfy the condition. Maybe I missed something.

Wait, in the note, it says for the fourth test case, certain pairs satisfy the conditions, but not for this test case. I need to double-check.

Wait, in the example section, it shows for the second test case (n=2, m=3), the output is 3, but according to my calculation, only two pairs satisfy the condition. Maybe there's a mistake in my reasoning.

Wait, perhaps I miscounted the pairs. Let's list all possible pairs for n=2, m=3:

(1,1), (1,2), (1,3), (2,1), (2,2), (2,3).

Now, check each:

- (1,1): 1+1=2, 1*1=1, 2 divisible by 1 → yes

- (1,2): 1+2=3, 2*1=2, 3 not divisible by 2 → no

- (1,3): 1+3=4, 3*1=3, 4 not divisible by 3 → no

- (2,1): 2+1=3, 1*2=2, 3 not divisible by 2 → no

- (2,2): 2+2=4, 2*2=4, 4 divisible by 4 → yes

- (2,3): 2+3=5, 3*1=3, 5 not divisible by 3 → no

So, only (1,1) and (2,2) satisfy the condition. But the sample output is 3 for this test case. Maybe I missed a pair.

Wait, perhaps I miscalculated for (2,1). Let's check again.

For (2,1): a=2, b=1, GCD(2,1)=1.

So, a + b = 3, b * GCD(a,b) = 1 * 1 = 1, and 3 is divisible by 1 → yes.

Wait, earlier I thought it was no, but actually, it should be yes because any number is divisible by 1.

So, (2,1) does satisfy the condition. So, total of three pairs: (1,1), (2,1), and (2,2). That matches the sample output of 3.

So, my initial mistake was in thinking that (2,1) doesn't satisfy the condition, but it does because 3 is divisible by 1.

Alright, so now I need to find a general way to count such pairs efficiently, given that n and m can be up to 2*10^6, and t can be up to 10^4, with the sum of n and m across all test cases not exceeding 2*10^6.

So, I need an efficient algorithm.

Let me try to generalize the condition.

Given a and b, with 1 ≤ a ≤ n and 1 ≤ b ≤ m, we need a + b to be divisible by b * GCD(a, b).

Let d = GCD(a, b). Then a = d * a1 and b = d * b1, where GCD(a1, b1) = 1.

Then, a + b = d * (a1 + b1)

And b * GCD(a, b) = d * b1 * d = d^2 * b1

So, d * (a1 + b1) must be divisible by d^2 * b1, which implies that a1 + b1 must be divisible by d * b1.

But a1 and b1 are coprime.

So, a1 + b1 is divisible by b1 * d.

Since a1 and b1 are coprime, b1 divides a1 + b1 only if b1 divides a1.

But a1 and b1 are coprime, so b1 can only divide a1 if b1 = 1.

Wait, but b1 divides a1 + b1 implies b1 divides a1, since b1 divides b1 * something.

But GCD(a1, b1) = 1, so b1 = 1.

Therefore, b1 must be 1.

Which means b = d * b1 = d * 1 = d.

So, b = d.

But d = GCD(a, b), and since b = d, GCD(a, b) = b, which implies that b divides a.

Therefore, the condition simplifies to b divides a.

So, the condition a + b is divisible by b * GCD(a, b) is equivalent to b divides a.

Wait, is that true?

Let me verify.

From above, we have that the condition implies that b divides a.

Is the reverse true? If b divides a, does a + b being divisible by b * GCD(a, b)?

Assume b divides a, so a = k * b for some integer k ≥ 1.

Then, a + b = k * b + b = (k + 1) * b

And b * GCD(a, b) = b * b = b^2

So, (k + 1) * b must be divisible by b^2, which implies that k + 1 must be divisible by b.

Wait, that's not necessarily true.

Wait, hold on.

If a = k * b, then a + b = (k + 1) * b

And b * GCD(a, b) = b * b = b^2

So, (k + 1) * b must be divisible by b^2, which means (k + 1) must be divisible by b.

But k + 1 is an integer, and for (k + 1) to be divisible by b, b must divide k + 1.

But k = a / b, and since a ≤ n and b ≤ m, k can be any integer from 1 up to floor(n / b).

So, for b to divide k + 1, k + 1 must be a multiple of b.

Which means k = t * b - 1 for some integer t.

But k = a / b, so a = k * b = (t * b - 1) * b = t * b^2 - b

But a must be ≤ n, so t * b^2 - b ≤ n ⇒ t ≤ (n + b) / b^2

But this seems complicated.

Wait, perhaps there's a better way to look at it.

Let me check with the sample input.

In the second sample input, n=2, m=3.

Possible b values: 1,2,3.

For each b, find a such that b divides a and 1 ≤ a ≤ n.

For b=1: a can be 1,2 → pairs (1,1), (2,1)

For b=2: a must be multiple of 2 ≤ n=2 → a=2 → pair (2,2)

For b=3: a must be multiple of 3 ≤ n=2 → no a satisfies

Total pairs: (1,1), (2,1), (2,2) → 3 pairs, which matches the sample output.

So, in this case, counting the number of pairs where b divides a is correct.

But wait, earlier I thought that the condition was equivalent to b divides a, but in the general case, is that always true?

Let me check another sample.

Take n=3, m=5.

Possible b: 1,2,3,4,5.

For b=1: a=1,2,3 → pairs (1,1),(2,1),(3,1)

For b=2: a=2 → pair (2,2)

For b=3: a=3 → pair (3,3)

For b=4: a=4, but n=3, so no

For b=5: a=5, but n=3, so no

Total pairs: (1,1),(2,1),(3,1),(2,2),(3,3) → 5 pairs

But according to the sample input, for n=3, m=5, the output is 4, not 5.

Wait, perhaps I made a mistake in counting.

Let's check the condition for each pair:

- (1,1): 1+1=2, 1*1=1, 2 divisible by 1 → yes

- (2,1): 2+1=3, 1*1=1, 3 divisible by 1 → yes

- (3,1): 3+1=4, 1*1=1, 4 divisible by 1 → yes

- (2,2): 2+2=4, 2*2=4, 4 divisible by 4 → yes

- (3,3): 3+3=6, 3*3=9, 6 not divisible by 9 → no

Ah, so (3,3) does not satisfy the condition because 6 is not divisible by 9.

So, only four pairs satisfy the condition: (1,1), (2,1), (3,1), (2,2).

I see, so my assumption that the condition is equivalent to b divides a is not entirely correct.

There must be an additional condition.

Let me revisit the earlier steps.

We have that b divides a is necessary, but not sufficient.

Wait, in the pair (3,3), b=3 divides a=3, but 3+3=6 is not divisible by 3*3=9.

So, the condition is not just b divides a, but also a + b is divisible by b * GCD(a,b) = b * b, since GCD(a,b)=b when b divides a.

So, when b divides a, GCD(a,b)=b, and the condition becomes a + b divisible by b^2.

In the pair (3,3): 3 + 3 = 6, which is not divisible by 9, so it doesn't satisfy.

In the pair (2,2): 2 + 2 = 4, which is divisible by 4, so it does satisfy.

In the pair (2,1): 2 + 1 = 3, which is divisible by 1*1=1, which is always true.

In the pair (1,1): 1 + 1 = 2, divisible by 1*1=1.

So, the condition when b divides a is that a + b is divisible by b^2.

So, I need to count pairs where b divides a and a + b is divisible by b^2.

But a divides b implies a = k * b, so a + b = k * b + b = (k + 1) * b

And b^2 divides (k + 1) * b ⇒ b divides (k + 1)

Since b divides (k + 1) * b, but we need b^2 to divide (k + 1) * b, which simplifies to b divides (k + 1).

But k = a / b, and since a ≤ n, k ≤ floor(n / b)

So, b divides k + 1, which means k + 1 is a multiple of b.

So, k = t * b - 1 for some integer t.

Thus, a = k * b = (t * b - 1) * b = t * b^2 - b

But a must be ≤ n, so t * b^2 - b ≤ n ⇒ t ≤ (n + b) / b^2

So, for each b, the number of valid a is the number of t such that t * b^2 - b ≤ n and t * b^2 - b ≥ 1.

Wait, this seems complicated.

Maybe there's a better way.

Let me think differently.

Let me fix b and find for each b, how many a satisfy the condition.

Given b, a must be such that b divides a and a + b is divisible by b^2.

Since b divides a, let a = k * b.

Then, a + b = k * b + b = (k + 1) * b

We need (k + 1) * b divisible by b^2, which simplifies to (k + 1) divisible by b.

So, k + 1 must be a multiple of b, i.e., k = t * b - 1 for some integer t ≥ 1.

Then, a = (t * b - 1) * b = t * b^2 - b

We need a ≤ n, so t * b^2 - b ≤ n ⇒ t ≤ (n + b) / b^2

And a ≥ 1, so t * b^2 - b ≥ 1 ⇒ t ≥ (1 + b) / b^2

But since b^2 ≥ 1, and b ≥ 1, t can be as low as 1.

So, for each b, the number of valid t is floor((n + b) / b^2) - ceil((1 + b) / b^2) + 1

But this seems messy.

Maybe there's a better way to compute this.

Alternatively, perhaps I can iterate over possible values of b and compute the number of a for each b that satisfy the condition.

Given that n and m can be up to 2*10^6, and t up to 10^4, I need an efficient way to compute this.

Perhaps I can precompute some values or find a mathematical formula.

Let me consider that for a given b, the number of a is floor((n + b) / b^2) - floor(b / (b^2)).

Wait, perhaps I need to think in terms of arithmetic sequences.

Alternatively, maybe I can iterate over b from 1 to m, and for each b, compute the number of a that satisfy a = t * b^2 - b for some integer t, with 1 ≤ a ≤ n.

But this seems inefficient for large n and m.

I need a smarter approach.

Let me consider that for each b, the a's that satisfy the condition are of the form a = b * (k * b - 1) for integer k ≥ 1, and a ≤ n.

So, for each b, the number of k such that b * (k * b - 1) ≤ n and k * b - 1 ≥ 1.

Simplifying, k * b^2 - b ≤ n and k * b - 1 ≥ 1.

From k * b - 1 ≥ 1, we get k ≥ (2) / b.

Since k must be an integer, k ≥ ceil(2 / b).

From k * b^2 - b ≤ n, k ≤ floor((n + b) / b^2).

So, for each b, the number of k is floor((n + b)/b^2) - ceil(2 / b) + 1.

But this still seems inefficient to compute for large m.

I need a better way.

Maybe I can iterate over possible b and compute the number of a directly.

Given that a must be a multiple of b, and a + b must be divisible by b^2.

Wait, perhaps I can consider that a must be of the form a = b * (t * b - 1) for integer t ≥ 1, as earlier.

But I need to find a better way to count this efficiently.

