Alright, I have this problem to solve. It's about a game that Alice and Bob are playing with piles of stones. The rules are a bit unique. On each turn, a player chooses a positive integer k that is less than or equal to the smallest pile and removes k stones from every non-empty pile. The player who can't make a move loses, which means all piles are empty.

Given that Alice starts first and both play optimally, I need to determine who wins for multiple test cases. Each test case has a number of piles with a certain number of stones, and I have to figure out if Alice or Bob wins.

First, I need to understand the game mechanics thoroughly. The key point is that on each turn, the player picks a k up to the size of the smallest pile and removes k stones from every pile. This is different from standard Nim games where stones are removed from a single pile.

I should think about the state of the game and how it changes with each move. The game ends when all piles are empty, and the player who makes the last possible move wins.

Let me consider some small examples to get a feel for the game.

Example 1:

- Piles: 3, 3, 3, 3, 3

- Alice can choose k=3 and remove 3 from each pile, making all piles empty. So Alice wins.

Example 2:

- Piles: 1, 7

- Alice must choose k=1 (since the smallest pile has 1 stone), removing 1 from each pile. Now piles are 0, 6.

- Bob now sees piles: 0, 6. The smallest non-empty pile is 6.

- Bob chooses k=6, removes 6 from the second pile, making it 0. So all piles are empty, and Bob wins.

Example 3:

- Piles: 1, 3, 9, 7, 4, 2, 100

- Alice can choose k=1 (smallest pile is 1), removing 1 from each pile.

- New piles: 0, 2, 8, 6, 3, 1, 99

- Now, Bob sees piles: 0,2,8,6,3,1,99. Smallest non-empty pile is 1.

- Bob chooses k=1, removes 1 from each non-empty pile.

- New piles: 0,1,7,5,2,0,98

- This seems complicated. Maybe there's a better way to approach this.

I need a more systematic way to determine the winner without simulating the entire game, especially since n can be up to 2*10^5 and t up to 10^4, with the sum of n over all test cases up to 2*10^5. Simulation is not feasible due to time constraints.

I recall that in impartial games, the concept of Nimbers or the mex function can be used to determine the winner based on the xor of the game states. But I'm not sure if this game directly translates to standard Nim.

Let me think differently. Since on each move, k stones are removed from every non-empty pile, this is equivalent to subtracting k from each pile that has at least k stones, effectively reducing the pile sizes.

Wait, this seems similar to the game of Nim where removing stones from piles affects the game state. But the standard Nim game allows removing any number of stones from a single pile, whereas here, we remove k stones from all piles that have at least k stones.

I need to find a way to reduce this game to a known game or find an invariant that can help determine the winner.

Let's consider the sequence of moves. Each move reduces the size of the piles by k, but only for piles that have at least k stones. This is similar to performing a parallel subtraction across multiple piles.

I should consider sorting the piles in ascending order. That might help in identifying patterns.

Take the earlier example:

Piles: 1,3,9,7,4,2,100

Sorted: 1,2,3,4,7,9,100

Alice chooses k=1, removes 1 from each non-empty pile:

New piles: 0,1,2,3,6,8,99

Sorted non-zero: 1,2,3,6,8,99

Bob chooses k=1, removes 1 from each non-empty pile:

New piles: 0,1,2,5,7,98

Sorted non-zero: 1,2,5,7,98

Alice chooses k=1, removes 1 from each non-empty pile:

New piles: 0,1,4,6,97

Sorted non-zero: 1,4,6,97

Bob chooses k=1, removes 1 from each non-empty pile:

New piles: 0,3,5,96

Sorted non-zero: 3,5,96

Alice chooses k=3, removes 3 from each non-empty pile:

New piles: 0,2,93

Sorted non-zero: 2,93

Bob chooses k=2, removes 2 from each non-empty pile:

New piles: 0,91

Sorted non-zero: 91

Alice chooses k=91, removes 91 from the remaining pile:

New piles: 0

Bob cannot make a move, so Alice wins.

Wait, in this example, Alice wins, but according to the sample input, it's Alice who wins for this case.

Another sample input:

Piles: 1,7

As per earlier reasoning, Alice chooses k=1, then Bob chooses k=6, and wins.

So, in this case, Bob wins.

Looking at these examples, it seems that the winner depends on some property of the pile sizes.

I need to find a general way to determine the winner based on the initial pile sizes.

Let me consider the minimal excludant (mex) concept or find a way to model this game using Nimbers.

Alternatively, perhaps there's a way to reduce this game to standard Nim game with heaps.

Wait, maybe I can think of the game in terms of the number of moves that can be made.

Each move corresponds to choosing a k that is at most the smallest pile and removing k from each pile.

This is similar to choosing a k and subtracting it from all piles, which effectively reduces the pile sizes uniformly.

Wait, perhaps I can think of the differences between piles.

Let me consider the sorted pile sizes.

Suppose I have piles sorted as a1 <= a2 <= ... <= an.

On each move, the player chooses k <= a1 (the smallest pile), and subtracts k from each ai where ai >= k.

After the move, the new pile sizes are:

- For ai < k: ai (since k cannot be subtracted)

- For ai >= k: ai - k

But since k <= a1, all piles that were non-zero remain non-zero, except those that were exactly k, which become zero.

Wait, not exactly. If ai >= k, ai becomes ai - k. Piles with ai < k remain unchanged.

Wait, no. Since k <= a1, and a1 is the smallest non-zero pile, any pile that was greater than or equal to k will have ai - k, and piles with ai < k remain unchanged.

But in the first move, if Alice chooses k = a1, then all piles that were a1 become zero, and piles that were greater than a1 become a_i - a1.

This seems similar to the game of Nim where heaps are combined in some way.

Alternatively, maybe I can think in terms of the number of stones each player can remove in total.

But that seems too vague.

Let me look for a pattern or try to find a mathematical formula that can determine the winner based on the initial pile sizes.

Given the constraints, I need an efficient solution, preferably O(n log n) per test case or better.

Looking back at the sample inputs and outputs:

Sample Input:

7

5

3 3 3 3 3

2

1 7

7

1 3 9 7 4 2 100

3

1 2 3

6

2 1 3 4 2 4

8

5 7 2 9 6 3 3 2

1

1000000000

Sample Output:

Alice

Bob

Alice

Alice

Bob

Alice

Alice

Looking at these, it seems that for some configurations, Alice wins, and for others, Bob wins.

I need to find a pattern or formula that can predict the winner based on the pile sizes.

Let me consider the minimal pile size and see if that plays a role.

In the first test case, all piles are equal, so Alice can choose k equal to the pile size and win immediately.

In the second test case, piles are 1 and 7. Alice must choose k=1, reducing the piles to 0 and 6. Then Bob chooses k=6 and wins.

In the third test case, piles are 1,3,9,7,4,2,100. As per earlier simulation, Alice wins.

In the fourth test case, piles are 1,2,3. Let's simulate:

Alice chooses k=1, reducing to 0,1,2.

Bob chooses k=1, reducing to 0,0,1.

Alice chooses k=1, reducing to 0,0,0.

So Alice wins.

In the fifth test case, piles are 2,1,3,4,2,4.

Sorted: 1,2,2,3,4,4

Alice chooses k=1, reducing to 0,1,1,2,3,3.

Bob chooses k=1, reducing to 0,0,0,1,2,2.

Alice chooses k=1, reducing to 0,0,0,0,1,1.

Bob chooses k=1, reducing to 0,0,0,0,0,0.

Bob wins.

Wait, according to the sample output, Bob wins this case.

Wait, in my simulation, Bob makes the last move and wins, which matches the sample output.

Good.

In the sixth test case, piles are 5,7,2,9,6,3,3,2.

Sorted: 2,2,3,3,5,6,7,9

Alice chooses k=2, reducing to 0,0,1,1,3,4,5,7.

Bob chooses k=1, reducing to 0,0,0,0,2,3,4,6.

Alice chooses k=2, reducing to 0,0,0,0,0,1,2,4.

Bob chooses k=1, reducing to 0,0,0,0,0,0,1,3.

Alice chooses k=1, reducing to 0,0,0,0,0,0,0,2.

Bob chooses k=2, reducing to 0,0,0,0,0,0,0,0.

Bob wins.

But according to the sample output, Alice wins this case. Hmm, maybe I made a mistake in simulation.

Let me try again.

Starting with: 5,7,2,9,6,3,3,2

Sorted: 2,2,3,3,5,6,7,9

Alice chooses k=2, reducing to 0,0,1,1,3,4,5,7.

Bob chooses k=1, reducing to 0,0,0,0,2,3,4,6.

Alice chooses k=2, reducing to 0,0,0,0,0,1,2,4.

Bob chooses k=1, reducing to 0,0,0,0,0,0,1,3.

Alice chooses k=1, reducing to 0,0,0,0,0,0,0,2.

Bob chooses k=2, reducing to 0,0,0,0,0,0,0,0.

Bob wins.

But the sample output says Alice wins. So maybe my simulation is incorrect.

Wait, perhaps there is a better move for Alice.

Let me try again.

Starting with: 2,2,3,3,5,6,7,9

Alice chooses k=2, resulting in 0,0,1,1,3,4,5,7.

Bob chooses k=1, resulting in 0,0,0,0,2,3,4,6.

Alice chooses k=2, resulting in 0,0,0,0,0,1,2,4.

Bob chooses k=1, resulting in 0,0,0,0,0,0,1,3.

Alice chooses k=1, resulting in 0,0,0,0,0,0,0,2.

Bob chooses k=2, resulting in all zeros.

Bob wins.

But sample output says Alice wins. So perhaps there's a different path where Alice can force a win.

Alternatively, maybe there's a mathematical property here that I'm missing.

Let me consider the number of distinct pile sizes.

In the first test case, all piles are equal. Alice can choose k equal to that value and win immediately.

In the second test case, two different pile sizes: 1 and 7. Alice must choose k=1, and Bob can then choose k=6 to win.

In the third test case, multiple distinct pile sizes: 1,3,9,7,4,2,100. Alice wins.

In the fourth test case, piles:1,2,3. Alice wins.

In the fifth test case, piles:2,1,3,4,2,4. Bob wins.

In the sixth test case, piles:5,7,2,9,6,3,3,2. Sample output says Alice wins.

In the seventh test case, single pile:1000000000. Alice wins by choosing k=1000000000.

So, for single pile cases, Alice always wins by taking all stones.

For multiple piles, it depends on the configuration.

I need to find a general way to determine the winner.

Let me consider the minimal excludant (mex) concept from combinatorial game theory.

Alternatively, perhaps I can think of the game in terms of Nim-heaps, where the xor of the heap sizes determines the winner.

But in standard Nim, players remove stones from a single pile, whereas here, stones are removed from all piles simultaneously.

So, standard Nim doesn't directly apply.

Let me think differently.

Suppose I consider the differences between consecutive pile sizes after sorting.

For example, in the sixth test case: 2,2,3,3,5,6,7,9

Differences: 0,1,0,2,1,1,2

Not sure if that helps.

Wait, perhaps considering the number of times each pile size appears.

In the first test case, all piles are 3: counts {3:5}

Alice wins by choosing k=3.

In the second test case, piles:1,7: counts {1:1,7:1}

Alice chooses k=1, Bob chooses k=6.

In the third test case:1,3,9,7,4,2,100: counts {1:1,2:1,3:1,4:1,7:1,9:1,100:1}

Alice wins.

In the fourth test case:1,2,3: counts {1:1,2:1,3:1}

Alice wins.

In the fifth test case:2,1,3,4,2,4: counts {1:1,2:2,3:1,4:2}

Bob wins.

In the sixth test case:2,2,3,3,5,6,7,9: counts {2:2,3:2,5:1,6:1,7:1,9:1}

Alice wins.

In the seventh test case:1000000000: counts {1000000000:1}

Alice wins.

Looking at these, it seems that when there is only one pile, Alice wins.

When there are multiple piles, it depends on the counts and values.

Perhaps I can think in terms of the number of distinct pile sizes.

In the first test case, only one distinct pile size: Alice wins.

In the second test case, two distinct pile sizes: Bob wins.

In the third test case, seven distinct pile sizes: Alice wins.

In the fourth test case, three distinct pile sizes: Alice wins.

In the fifth test case, four distinct pile sizes: Bob wins.

In the sixth test case, six distinct pile sizes: Alice wins.

In the seventh test case, one distinct pile size: Alice wins.

It seems that when the number of distinct pile sizes is odd, Alice wins, and when it's even, Bob wins.

Wait, let's check:

Test case 1: 5 piles of 3 -> 1 distinct size (odd) -> Alice wins.

Test case 2: 2 piles:1 and 7 -> 2 distinct sizes (even) -> Bob wins.

Test case 3: 7 distinct sizes -> odd -> Alice wins.

Test case 4: 3 distinct sizes -> odd -> Alice wins.

Test case 5: 4 distinct sizes -> even -> Bob wins.

Test case 6: 6 distinct sizes -> even -> Alice wins.

Wait, contradiction in test case 6: 6 distinct sizes (even) -> Alice wins.

So my hypothesis is wrong.

Wait, perhaps it's about the number of piles with the minimal size.

In test case 1: 5 piles of 3, all minimal, so 5 minimal piles.

Test case 2: 2 piles, one minimal, so 1 minimal pile.

Test case 3: 7 piles, one minimal pile.

Test case 4: 3 piles, one minimal pile.

Test case 5: 6 piles, one minimal pile.

Test case 6: 8 piles, two minimal piles.

Test case 7: 1 pile, one minimal pile.

Wait, in test case 6, there are two minimal piles of size 2.

Wait, in test case 6: piles are 5,7,2,9,6,3,3,2 -> sorted:2,2,3,3,5,6,7,9

So two minimal piles of size 2.

In test case 1: five minimal piles of size 3.

In test case 2: one minimal pile of size 1.

In test case 3: one minimal pile of size 1.

In test case 4: one minimal pile of size 1.

In test case 5: one minimal pile of size 1.

In test case 6: two minimal piles of size 2.

In test case 7: one minimal pile of size 1000000000.

Wait, perhaps it's about the number of minimal piles.

But in test case 1: five minimal piles -> Alice wins.

Test case 2: one minimal pile -> Bob wins.

Test case 3: one minimal pile -> Alice wins.

Wait, contradiction.

Wait, test case 3: minimal pile is 1, count=1 -> Alice wins.

Wait, in the simulation earlier, Alice wins, but according to my earlier hypothesis, it should be Bob.

Wait, perhaps I need to think differently.

Let me consider the game as a subtraction game where the feasible moves are determined by the minimal pile size.

Alternatively, perhaps I can model this game as a Nim game with certain heap sizes.

I recall that in Nim games, the xor of the heap sizes determines the winner.

But in this game, moves affect multiple piles simultaneously, so it's different from standard Nim.

Let me think about the game in terms of its Grundy numbers (Nimbers).

The Grundy number for a game state is the mex (minimal excludant) of the Grundy numbers of the states reachable in one move.

The game is impartial, so the Sprague-Grundy theorem applies.

If the Grundy number of the initial position is non-zero, the first player wins; otherwise, the second player wins.

But calculating Grundy numbers directly is not feasible due to the large pile sizes.

I need to find a pattern or a mathematical formula that can compute the Grundy number efficiently.

Let me try to compute the Grundy numbers for small pile configurations and see if I can find a pattern.

Consider n=1:

- Pile size a1.

- Alice can choose k from 1 to a1.

- After choosing k, the pile becomes a1 - k.

- Continue until the pile is empty.

This is equivalent to a single Nim heap of size a1.

Grundy number is a1.

But in this game, since n=1, Alice can choose k=a1 and win immediately.

So, for n=1, Alice always wins.

For n=2:

- Piles a and b, a <= b.

- Alice can choose k from 1 to a.

- After choosing k, both piles become a - k and b - k (if k <= b).

- If k > b, but k <= a, then the second pile becomes 0.

Wait, k has to be <= a, and a is <= b, so k <= a <= b.

So both piles are reduced by k.

So new piles are a - k and b - k.

This is similar to subtracting k from both a and b, provided k <= a.

This is equivalent to replacing a and b with a - k and b - k.

This seems similar to a Nim game with two heaps.

But in standard Nim, the xor of the heap sizes determines the winner.

In this case, since both heaps are reduced by the same amount, it's like moving in both heaps simultaneously.

This is reminiscent of the game of Nim with a restriction that moves in one heap require corresponding moves in the other heap.

Wait, this is similar to the game of Nim with a "Nim-difference" of zero.

But I'm not sure.

Alternatively, perhaps I can consider the difference between the piles.

Let me consider n=2, piles a and b, a <= b.

After Alice chooses k, the new piles are a - k and b - k, provided k <= a.

This continues until one of the piles reaches zero.

Wait, actually, the game ends when all piles are empty.

But in n=2, if both piles are reduced by k each turn, the game ends when both are zero.

This is equivalent to Alice and Bob reducing both piles by the same k in each turn until both reach zero.

The player who makes the last move wins.

This seems like a game where the total reduction is tracked, and the player who makes the last reduction wins.

This is similar to a game where the player who reduces the piles to zero wins.

In this case, the total number of moves is determined by the smallest pile.

Wait, in n=2, with piles a and b, a <= b.

Each move reduces both piles by k, where k <= a.

So the number of moves is equal to a, since each move reduces k up to a.

The player who makes the a-th move wins.

So, if a is odd, Alice wins; if a is even, Bob wins.

Wait, let's check with the sample input.

Sample input test case 2: n=2, piles=1,7 -> a=1, b=7.

According to this, a=1, which is odd, so Alice should win.

But according to the sample output, Bob wins.

So my hypothesis is incorrect.

Wait, perhaps I'm miscounting the number of moves.

In n=2, piles=1,7.

Alice chooses k=1, reduces both to 0 and 6.

Now, piles are 0 and 6.

Now, the smallest non-empty pile is 6.

Bob chooses k=6, reduces both to 0 and 0.

Bob wins.

So, total moves: Alice (k=1), Bob (k=6). Total moves: 2, which is even.

So, Bob makes the last move.

Wait, perhaps the parity of the number of moves determines the winner.

If the total number of moves is even, Bob wins; if odd, Alice wins.

In this case, 2 moves, even, Bob wins.

Another example: n=5, all piles=3.

Alice chooses k=3, reduces all to 0. Only one move, which is odd, so Alice wins.

Another example: n=3, piles=1,2,3.

Alice chooses k=1, reduces to 0,1,2.

Bob chooses k=1, reduces to 0,0,1.

Alice chooses k=1, reduces to 0,0,0.

Total moves: 3, which is odd, so Alice wins.

Another example: n=6, piles=2,1,3,4,2,4.

Sorted:1,2,2,3,4,4

Alice chooses k=1, reduces to 0,1,1,2,3,3.

Bob chooses k=1, reduces to 0,0,0,1,2,2.

Alice chooses k=1, reduces to 0,0,0,0,1,1.

Bob chooses k=1, reduces to 0,0,0,0,0,0.

Total moves:4, even, Bob wins.

So, it seems that the parity of the number of moves determines the winner.

If the number of moves is odd, Alice wins; if even, Bob wins.

But in the sixth test case, according to the sample output, Alice wins, but in my simulation, Bob wins.

Wait, perhaps there's a different way to count the number of moves.

Alternatively, maybe it's not simply the parity of the number of moves, but something more complex.

Let me consider that each move reduces the minimal non-zero pile by some k.

Wait, perhaps it's about the number of times the minimal pile changes.

Let me try to think differently.

Let me consider the game as a sequence of stages, where in each stage, the minimal non-zero pile size changes.

Each stage consists of moves that reduce the minimal non-zero pile to zero, and then the next minimal non-zero pile becomes the new minimal one.

Wait, perhaps it's about the number of distinct minimal pile sizes.

In the first test case, only one distinct minimal pile size: 3.

Alice chooses k=3 and wins in one move.

In the second test case, minimal pile size starts at 1.

Alice chooses k=1, reducing piles to 0 and 6.

Now, the minimal non-zero pile is 6.

Bob chooses k=6 and wins.

So, two distinct minimal pile sizes: 1 and 6.

Bob wins.

In the third test case, minimal pile size starts at 1.

Alice chooses k=1, reducing to 0,2,8,6,3,1,99.

Next minimal non-zero pile is 1.

Alice chooses k=1, reduces to 0,1,7,5,2,0,98.

Next minimal non-zero pile is 1.

Alice chooses k=1, reduces to 0,0,6,4,1,0,97.

Next minimal non-zero pile is 1.

Alice chooses k=1, reduces to 0,0,5,3,0,0,96.

Next minimal non-zero pile is 3.

Bob chooses k=3, reduces to 0,0,2,0,0,0,93.

Next minimal non-zero pile is 2.

Bob chooses k=2, reduces to 0,0,0,0,0,0,91.

Next minimal non-zero pile is 91.

Alice chooses k=91, reduces to all zeros.

Alice wins.

So, in this case, Alice wins.

Looking at the number of distinct minimal pile sizes:

Initial:1, then 1,1,1,3,2,91.

Wait, seems like multiple stages with the same minimal pile size.

Maybe counting the number of distinct minimal pile sizes isn't helpful.

This is getting too complicated.

I need a better approach.

Let me look for patterns in the sample inputs.

Sample Input:

7

5

3 3 3 3 3

2

1 7

7

1 3 9 7 4 2 100

3

1 2 3

6

2 1 3 4 2 4

8

5 7 2 9 6 3 3 2

1

1000000000

Sample Output:

Alice

Bob

Alice

Alice

Bob

Alice

Alice

Looking at the number of distinct pile sizes:

Test case 1: 1 distinct size -> Alice wins.

Test case 2: 2 distinct sizes -> Bob wins.

Test case 3: 7 distinct sizes -> Alice wins.

Test case 4: 3 distinct sizes -> Alice wins.

Test case 5: 4 distinct sizes -> Bob wins.

Test case 6: 6 distinct sizes -> Alice wins.

Test case 7: 1 distinct size -> Alice wins.

So, when the number of distinct pile sizes is odd, Alice wins; when even, Bob wins.

Wait, but test case 6 has 6 distinct sizes (2,3,5,6,7,9) -> even -> Bob should win, but sample output says Alice wins.

Contradiction.

Wait, in test case 6, there are duplicates in the pile sizes, but distinct sizes are 2,3,5,6,7,9 -> 6 distinct sizes, even -> Bob should win, but sample output says Alice wins.

So, my hypothesis is incorrect.

Alternative idea: perhaps it's about the mex of the pile sizes.

But I'm not sure.

Another idea: consider the game as a subtraction game where the feasible moves are determined by the minimal pile size.

Wait, perhaps I can think of the game in terms of the number of times the minimal pile is reduced to zero.

Let me consider that each stage corresponds to reducing the current minimal non-zero pile to zero.

Each stage consists of choosing k from 1 to the current minimal non-zero pile.

The number of stages might determine the winner.

In test case 1: only one stage (k=3), Alice wins.

In test case 2: two stages (k=1, then k=6), Bob wins.

In test case 3: multiple stages, but Alice wins.

Not sure.

This seems too vague.

Let me consider the game in terms of its binary representations or something, but that might not help.

Alternatively, perhaps I can think of the game in terms of the number of times the minimal pile can be reduced.

Wait, perhaps it's about the maximum number of times you can reduce the minimal pile to zero.

In test case 1: only one reduction (k=3).

In test case 2: two reductions (k=1, then k=6).

In test case 3: multiple reductions, ending with Alice winning.

This still doesn't give a clear pattern.

Let me try to think recursively.

Define the game state based on the current pile sizes.

If any pile is zero, it can be ignored.

So, effectively, at each move, the player chooses k up to the smallest non-zero pile and reduces each non-zero pile by k.

This is similar to choosing k and subtracting k from all non-zero piles.

The game ends when all piles are zero.

This seems like a subtraction game where moves affect multiple piles simultaneously.

I need to find a way to model this efficiently.

Given time constraints, perhaps there's a mathematical formula based on the sorted pile sizes.

Looking back at the provided code, it seems to be attempting to sort the unique pile sizes and check some condition based on the differences between consecutive sizes.

In the provided code:

- Read the number of test cases.

- For each test case:

- Read n, the number of piles.

- Read the pile sizes, sort the unique pile sizes.

- If there's only one unique pile size, Alice wins.

- If there are two unique pile sizes, Bob wins.

- Otherwise, insert a 0 at the beginning of the sorted unique pile sizes.

- Then, count the number of times the difference between consecutive pile sizes is 1.

- If the count is odd, Bob wins; else, Alice wins.

Wait, that's not exactly what the code does.

Looking at the code:

nums = set(input().split())

nums = sorted(map(int, nums))

if len(nums) == 1:

return print('Alice')

if len(nums) == 2:

return print('Bob')

nums.insert(0, 0)

cd = 0

for i in range(len(nums) - 2):

if nums[i + 1] - nums[i] == 1:

cd += 1

else:

break

if cd & 1:

return print('Bob')

else:

return print('Alice')

So, it's considering the unique pile sizes, sorting them, and then counting the number of consecutive pairs with difference 1 starting from the smallest.

If the count is odd, Bob wins; else, Alice wins.

Wait, but in the sample input, test case 3 has unique pile sizes:1,2,3,4,7,9,100

Sorted:1,2,3,4,7,9,100

Difference between consecutive:1,1,1,3,2,91

So, the first four differences are 1,1,1,3.

So, cd = 3 (since the first three differences are 1, and the fourth is 3, so the loop breaks after cd +=1 three times).

3 is odd, so according to the code, Bob should win, but the sample output says Alice wins.

Contradiction.

Wait, perhaps I misread the code.

Looking again:

nums = set(input().split())

nums = sorted(map(int, nums))

if len(nums) == 1:

return print('Alice')

if len(nums) == 2:

return print('Bob')

nums.insert(0, 0)

cd = 0

for i in range(len(nums) - 2):

if nums[i + 1] - nums[i] == 1:

cd += 1

else:

break

if cd & 1:

return print('Bob')

else:

return print('Alice')

So, for test case 3:

nums = {1,3,9,7,4,2,100}

sorted(nums) = [1,2,3,4,7,9,100]

nums.insert(0,0) => [0,1,2,3,4,7,9,100]

Then, check differences:

1-0=1 -> cd=1

2-1=1 -> cd=2

3-2=1 -> cd=3

4-3=1 -> cd=4

7-4=3 -> not 1, break

So, cd=4

4 & 1 = 0, which is even, so Alice wins.

Which matches the sample output.

Wait, in my earlier calculation, I thought cd=3, but actually, it's 4.

So, it's correct.

Similarly, in test case 6:

piles:5,7,2,9,6,3,3,2

unique sorted:2,3,5,6,7,9

insert 0: [0,2,3,5,6,7,9]

differences:2,1,2,1,1,2

So, loop:

2-0=2 !=1 -> break

cd=0, which is even, so Alice wins.

Which matches the sample output.

In test case 2:

n=2, piles=1,7

unique sorted:1,7

insert 0: [0,1,7]

difference:1,7

cd=0, even, Bob wins.

Wait, but according to the code, if len(nums)==2, it directly returns 'Bob'.

So, in test case 2, len(nums)=2, so directly 'Bob'.

In test case 6, len(nums)=6, so cd=0, even, 'Alice'.

In test case 3, len(nums)=7, cd=4, even, 'Alice'.

In test case 4, piles=1,2,3 -> len(nums)=3, cd=3, which is odd, 'Bob'.

Wait, but in my earlier simulation, Alice wins in test case 4.

Wait, perhaps there's a mistake.

Wait, in test case 4: piles=1,2,3

unique sorted:1,2,3

insert 0: [0,1,2,3]

differences:1,1,1

cd=3, which is odd, so 'Bob' according to the code.

But in my simulation, Alice wins.

Contradiction.

Wait, perhaps the code is incorrect.

In the sample output, test case 4 should be 'Alice', but according to the code, it's 'Bob'.

So, the code is incorrect for test case 4.

Wait, perhaps I made a mistake in simulation.

Let me simulate test case 4 again:

Piles:1,2,3

Alice chooses k=1, reduces to 0,1,2.

Bob chooses k=1, reduces to 0,0,1.

Alice chooses k=1, reduces to 0,0,0.

Alice makes the last move, so Alice wins.

But according to the code, len(nums)=3, cd=3 (odd), so 'Bob'.

Which contradicts the sample output of 'Alice'.

So, the code is incorrect.

Therefore, Correctness: False

**Final Answer**

\boxed{\text{False}}