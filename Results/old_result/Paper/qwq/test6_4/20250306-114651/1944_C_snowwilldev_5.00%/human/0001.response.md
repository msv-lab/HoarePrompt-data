Alright, I've got this problem to solve. Let's see what it's about. So, there are two players, Alice and Bob, playing a game on an array of size n. Alice starts with an empty array c. They take turns, with Alice going first. On Alice's turn, she picks an element from a, appends it to c, and deletes it from a. Bob, on his turn, picks an element from a, and deletes it from a. The game ends when a is empty, and the score is the MEX of c, which is the smallest non-negative integer not in c. Alice wants to maximize the score, and Bob wants to minimize it. I need to find the final score if both play optimally.

First, I need to understand what MEX is. From the description, MEX of an array is the smallest non-negative integer not present in it. For example, MEX of [2,2,1] is 0, since 0 is the smallest non-negative integer not in the array. MEX of [3,1,0,1] is 2, because 0 and 1 are present, but 2 is not. MEX of [0,3,1,2] is 4, as 0,1,2,3 are present, but 4 is not.

So, the goal is to find the MEX of array c, where c is built by Alice picking elements and adding them to c, and Bob picking elements and removing them from a. Both play optimally, Alice trying to maximize MEX, Bob trying to minimize it.

I need to think about how Alice and Bob will play. Alice wants to include elements in c that help maximize the MEX, while Bob wants to hinder that by possibly removing elements that Alice would want in c.

Let me consider some examples to get a feel for the problem.

Example 1:

Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Output:

2

1

0

In the first test case, n=4, a=[0,0,1,1]

A possible game is:

- Alice picks 1, c=[1], a=[0,0,1]

- Bob picks 0, a=[0,1]

- Alice picks 0, c=[1,0], a=[1]

- Bob picks 1, a=[]

c=[1,0], MEX is 2.

In the second test case, n=4, a=[0,1,2,3]

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob picks 3, a=[]

c=[0,2], MEX is 1.

In the third test case, n=2, a=[1,1]

- Alice picks 1, c=[1], a=[1]

- Bob picks 1, a=[]

c=[1], MEX is 0.

From these examples, it seems that the MEX depends on which numbers Alice manages to include in c.

I need to find a way to determine the optimal MEX that Alice can achieve despite Bob's attempts to minimize it.

Let me think about the game in terms of who has control over which elements end up in c.

Alice picks elements to include in c, and Bob picks elements to exclude from c by deleting them from a.

Since Alice goes first, she has the initial advantage of choosing elements to include in c.

But Bob can counter by removing elements that Alice might need to achieve a higher MEX.

I need to find a strategy where Alice can maximize the MEX, and Bob minimizes it.

Let me consider that MEX is the smallest missing non-negative integer in c.

So, to maximize MEX, Alice wants to have as many small non-negative integers in c as possible.

Conversely, Bob wants to prevent Alice from having those small integers in c.

Given that, perhaps I can think in terms of which numbers are available and how many times they appear.

Let me consider the frequency of each number in a.

If a number i appears multiple times, Alice can try to include as many as possible in c.

But Bob can interfere by removing some of them.

I need to model how Alice and Bob's turns affect the inclusion of elements in c.

Let's think in terms of the counts of each number.

Suppose I have the count of each number i in a, let's say cnt[i].

Alice wants to include as many cnt[i] in c as possible, but Bob can prevent that by removing some.

Since Alice and Bob alternate turns, and Alice starts, perhaps I can determine for each i how many times it can be included in c.

But this seems complicated.

Let me think differently.

Since MEX is the smallest missing integer in c, perhaps I can try to ensure that c contains all numbers from 0 to k, and see what's the maximum k possible.

Alice wants to maximize k, Bob wants to minimize it.

So, it's a game where both players are trying to influence the composition of c.

I need to find the final MEX when both play optimally.

Let me consider that the MEX will be the smallest i such that cnt[i] is less than a certain value determined by the number of turns.

Wait, maybe not.

Let me try to model it step by step.

Total number of turns is n, since n elements are deleted one by one.

Alice makes the first move, then Bob, then Alice, and so on.

Alice includes one element in c per her turn, and Bob excludes one element per his turn.

Wait, no. Both include an element in c on their turn, but Bob doesn't choose what goes into c, he just deletes an element from a.

Wait, no. Actually, on Alice's turn, she picks an element from a, appends it to c, and deletes it from a.

On Bob's turn, he picks an element from a, and deletes it from a.

So, Alice adds to c and deletes from a, Bob just deletes from a.

So, in total, after n turns, c will have Alice's picks, and a will be empty.

Wait, no. After n turns, a is empty, and c has Alice's picks.

But Bob also picks elements from a, but doesn't add them to c.

Wait, no. Bob picks and deletes from a, but doesn't add to c.

So, c only contains the elements that Alice picked.

So, c has Alice's picks, and a is reduced by both Alice's and Bob's picks.

But since Bob deletes from a without adding to c, effectively, Bob is choosing elements to exclude from c.

So, Bob can choose to delete elements that Alice wants to include in c.

Wait, no. Alice chooses what to include in c, and Bob chooses what to delete from a.

But Alice's choice of what to include in c is limited by what's left in a after both their turns.

Wait, no. On Alice's turn, she picks an element from a, appends it to c, and deletes it from a.

On Bob's turn, he picks an element from a, and deletes it from a.

So, c consists only of Alice's picks.

So, the final c is the set of elements that Alice chose to include.

Bob can influence c by deleting elements from a that Alice might have wanted to include.

So, Bob can prevent Alice from including certain elements by deleting them before Alice has a chance to pick them.

Given that, the game is about Alice trying to include as many low numbers as possible in c to maximize the MEX, and Bob trying to prevent that.

Wait, no, actually, Alice wants to maximize the MEX of c, which means she wants c to contain as many small numbers as possible.

Wait, actually, to maximize the MEX, Alice wants to have c contain as many small numbers as possible, but since MEX is the smallest missing, to maximize MEX, she wants to have as many consecutive small numbers in c as possible.

Wait, no. If c contains [0,1,2], MEX is 3, which is higher than if c contains [0,2], MEX is 1.

Wait, no, in [0,2], MEX is 1, which is lower than 3.

Wait, I'm getting confused.

Actually, to maximize MEX, Alice wants c to have as many small numbers as possible, so that the first missing number is as large as possible.

Wait, no. In the example, c=[1,0], MEX is 2, which is higher than c=[1], MEX=0.

So, by including 0, Alice increased the MEX.

Wait, no, in that case, c=[1,0], MEX=2, which is higher than c=[1], MEX=0.

So, including 0 helped increase the MEX.

Wait, but in another case, c=[0,1,2], MEX=3, which is higher than c=[0,1], MEX=2.

So, generally, including more small numbers increases the MEX.

Wait, but in the first example, c=[1,0], MEX=2, which is higher than c=[0,1,1], which would have MEX=2 as well, but if Alice includes only [1,1], MEX=0.

Wait, I'm getting confused.

Let me think differently.

Let me consider that the MEX of c is the smallest non-negative integer not present in c.

So, to maximize the MEX, Alice wants c to contain as many small integers as possible, in order: 0,1,2,3,...

Bob, wanting to minimize the MEX, would want to prevent Alice from including these small integers in c.

Given that, Alice will try to include the smallest possible integers in c, and Bob will try to prevent that by deleting them from a.

So, the game is about Alice trying to include the smallest integers in c, and Bob trying to delete them from a before Alice can pick them.

Given that, I need to model how many times each number can be included in c, considering the turns of Alice and Bob.

Let's consider the counts of each number in a.

Let's say cnt[i] is the count of number i in a.

Alice and Bob take turns, with Alice starting.

On each of Alice's turns, she can pick any remaining element and include it in c.

On Bob's turns, he can pick any remaining element and delete it.

Bob's goal is to minimize the MEX, so he will try to delete elements that Alice needs to achieve a higher MEX.

Alice's goal is to maximize the MEX, so she will try to include as many small numbers as possible in c.

Given that, for each number i, starting from 0, Alice wants to include as many copies as possible in c, and Bob wants to prevent that.

Let me think in terms of the number of times each i can be included in c.

For each i, if cnt[i] is the count of i in a, then the number of times i can be included in c depends on the number of turns Alice can pick i before Bob deletes it.

Since Alice and Bob alternate turns, and Alice starts, Alice can pick first.

For each i, if cnt[i] is the count, then the number of times i can be included in c is ceil(cnt[i]/2), because for every two turns, Alice can pick once (since she goes first).

Wait, perhaps.

Let me consider:

- If cnt[i] is odd, Alice can pick (cnt[i]+1)/2 times.

- If cnt[i] is even, Alice can pick cnt[i]/2 times.

Wait, no.

Actually, since Alice goes first, for cnt[i] elements, Alice can pick ceil(cnt[i]/2) times, and Bob can pick floor(cnt[i]/2) times.

So, the number of times i can be included in c is ceil(cnt[i]/2).

Wait, is that correct?

Let's see for cnt[i]=1: Alice picks it, includes it in c.

cnt[i]=2: Alice picks one, includes in c; Bob picks one, deletes it from a.

So, c has one i.

cnt[i]=3: Alice picks one, includes in c; Bob picks one, deletes; Alice picks one, includes in c.

So, c has two i's.

cnt[i]=4: Alice picks one, includes in c; Bob picks one, deletes; Alice picks one, includes in c; Bob picks one, deletes.

So, c has two i's.

So, in general, number of times i can be included in c is ceil(cnt[i]/2).

Yes, that seems correct.

So, for each i, the number of times it can be included in c is ceil(cnt[i]/2).

Now, to find the MEX of c, I need to find the smallest i such that c does not contain i.

Given that, I can iterate over i from 0 to n, and check if the number of times i is included in c is at least 1.

If ceil(cnt[i]/2) >=1, then i is included in c.

Otherwise, it's not, and i is the MEX.

Wait, no.

Actually, to have i in c, Alice needs to include at least one i in c.

Given that she can include ceil(cnt[i]/2) times, if ceil(cnt[i]/2) >=1, then i is included in c.

Otherwise, it's not.

So, the MEX is the smallest i where ceil(cnt[i]/2) ==0.

Which means cnt[i] ==0.

Wait, no.

Wait, ceil(cnt[i]/2) ==0 only if cnt[i]==0.

Because if cnt[i]>=1, ceil(cnt[i]/2) >=0.5, which is >=1.

So, the MEX is the smallest i where cnt[i]==0.

Wait, but that can't be right.

In the first example, a=[0,0,1,1], so cnt[0]=2, cnt[1]=2, cnt[2]=0, cnt[3]=0.

According to this, MEX is 2, which matches the example.

In the second example, a=[0,1,2,3], cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1.

ceil(1/2)=1, so c would have 0,1,2,3, MEX=4.

But in the example, c=[0,2], MEX=1.

Wait, that doesn't match.

Wait, perhaps my assumption is incorrect.

Wait, in the second example, n=4, a=[0,1,2,3].

A possible game is:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob picks 3, a=[]

So, c=[0,2], MEX=1.

But according to my earlier logic, since cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1, ceil(1/2)=1, so c should have 0,1,2,3, MEX=4.

But in reality, c=[0,2], MEX=1.

So, my earlier assumption is incorrect.

What's wrong here?

Oh, I see. The issue is that Alice can't necessarily include all the elements she wants.

In the second example, even though ceil(cnt[1]/2)=1, Alice might not get to pick 1, because Bob can choose to delete it.

Wait, in the second example, Bob can choose to delete 1, preventing Alice from including it in c.

So, in reality, Alice can only include elements that are not deleted by Bob.

But according to the game rules, Alice picks an element, appends it to c, and deletes it from a.

Bob picks an element, deletes it from a.

So, Bob can choose to delete elements that Alice hasn't picked yet.

In the second example, Bob deleted 1, so Alice couldn't include it in c.

Hence, c=[0,2], MEX=1.

So, in this case, even though cnt[1]=1, Alice couldn't include it in c because Bob deleted it.

Hence, my earlier assumption that ceil(cnt[i]/2) determines whether i is in c is not accurate.

I need a different approach.

Let me think in terms of the minimal i that Alice cannot include in c, despite trying to.

Since Alice goes first and wants to include small i's, and Bob tries to prevent that, the MEX would be the smallest i that Alice cannot include in c, given Bob's interference.

So, perhaps, for each i, starting from 0, check if Alice can include at least one i in c, considering Bob's moves.

If Alice can include i, proceed to the next i.

Otherwise, that i is the MEX.

To determine if Alice can include i, consider the counts of i and the turns.

If cnt[i] > 0, Alice can pick it on her turn, but Bob can also pick it.

Since Alice goes first, if cnt[i] is odd, Alice can pick the last one.

Wait, in general, Alice can pick ceil(cnt[i]/2) instances of i.

If ceil(cnt[i]/2) >=1, then Alice can include i in c.

Otherwise, she cannot.

But in the second example, for i=1, cnt[1]=1, ceil(1/2)=1, so Alice should be able to include 1 in c.

But in the example, c=[0,2], meaning Alice didn't include 1.

How is that possible?

Because Bob can choose to delete the 1 before Alice gets to pick it.

Wait, but according to the earlier game:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob picks 3, a=[]

So, Bob picked 1 before Alice could pick it.

Hence, Alice couldn't include 1 in c.

So, even though ceil(cnt[1]/2)=1, Bob was able to delete it, preventing Alice from including it.

Hence, my earlier assumption is incorrect.

So, perhaps I need to consider that for each i, if cnt[i] is even, Bob can delete all of them, preventing Alice from including any.

Wait, no.

If cnt[i] is even, Bob can delete half, and Alice can include half.

Wait, no.

Let's see:

- If cnt[i] is odd, Alice can include ceil(cnt[i]/2)= (cnt[i]+1)//2

- If cnt[i] is even, Alice can include cnt[i]/2

But in reality, Bob can choose to delete specific elements.

Wait, perhaps I need to think in terms of the total number of turns Alice gets to pick elements.

Total turns are n, Alice picks on turns 1,3,5,... and Bob picks on turns 2,4,6,...

So, if n is odd, Alice picks (n+1)//2 elements, Bob picks n//2 elements.

If n is even, Alice picks n/2 elements, Bob picks n/2 elements.

But c is only Alice's picks.

So, c has Alice's picks.

But I need to determine which elements are in c, considering that Bob can delete elements that Alice wants.

Wait, perhaps I need to consider that for each i, the number of times Alice can include i in c is ceil(cnt[i]/2), and Bob can prevent Alice from including floor(cnt[i]/2) instances.

But in the second example, cnt[1]=1, so Alice can include ceil(1/2)=1 instance of 1.

But in the game, Bob deleted it before Alice could pick it.

Wait, no.

In the second example, cnt[1]=1, Alice should be able to pick it, but in the example game, Bob picked it before Alice could.

Wait, no, in the example game, Alice picked 0 first, then Bob picked 1, then Alice picked 2.

So, Bob picked 1 before Alice could pick it.

Hence, Alice couldn't include 1 in c.

So, even though ceil(cnt[1]/2)=1, Alice didn't get to pick it because Bob deleted it.

Hence, my earlier assumption is incorrect.

I need to think differently.

Let me consider that for each i, starting from 0, Alice will try to include i in c.

Bob will try to prevent Alice from including i in c.

Given that, for each i, starting from 0, check if Alice can include at least one i in c, despite Bob's efforts.

If Alice can include i, proceed to the next i.

Otherwise, that i is the MEX.

To determine if Alice can include i, consider the counts of i and the turns.

If cnt[i] > 0, and the number of times Alice picks before Bob can delete all i's is at least one, then Alice can include i.

Otherwise, she cannot.

Wait, perhaps I can think in terms of the number of turns Alice needs to pick i.

If cnt[i] > 0, and the position of i in the sequence of picks allows Alice to pick it before Bob can delete it, then Alice can include it.

But this seems too vague.

Let me try to formalize it.

Let me sort the elements in a in ascending order.

Then, Alice and Bob pick elements in turns, with Alice starting.

Alice will pick the smallest available i, to maximize the MEX.

Bob, to minimize the MEX, will pick the smallest available i that Alice hasn't picked yet.

Wait, no.

Actually, Bob wants to minimize the MEX, so he would want to prevent Alice from including small i's.

Hence, Bob should pick the smallest i that Alice hasn't picked yet.

Wait, but according to the rules, Bob can pick any element from a.

So, Bob can choose to delete elements that Alice wants to include.

Hence, Bob will delete the smallest i that Alice hasn't picked yet, to prevent Alice from including it.

Alice, to maximize the MEX, will try to include the smallest i's first.

Hence, it's a game where Alice is trying to include small i's, and Bob is trying to delete them to prevent Alice from including them.

Given that, for each i, starting from 0, check if Alice can include at least one i in c before Bob deletes all instances of i.

If Alice can include at least one i, then that i is in c.

Otherwise, that i is not in c, and it's the MEX.

To determine if Alice can include at least one i, consider the counts of i.

If cnt[i] is odd, Alice can include at least one i, because she picks first.

If cnt[i] is even, Bob can delete all instances of i, preventing Alice from including any.

Wait, is that correct?

Let's see:

- If cnt[i]=1: Alice picks it first, includes it in c.

- If cnt[i]=2: Alice picks one, Bob picks the other, so Alice includes one.

- If cnt[i]=3: Alice picks one, Bob picks one, Alice picks the last one, so she includes two.

- If cnt[i]=4: Alice picks one, Bob picks one, Alice picks another, Bob picks the last one, so Alice includes two.

Wait, in cnt[i]=2, Alice includes one, Bob deletes one.

In cnt[i]=4, Alice includes two, Bob deletes two.

So, in general, Alice can include ceil(cnt[i]/2) instances of i.

But in the second example, cnt[1]=1, so Alice should include one 1, but in the example, Bob deleted it before Alice could pick it.

Wait, no.

In the second example, cnt[1]=1, but in the game, Bob picked 1 before Alice could pick it.

Wait, but according to the rules, when Alice picks, she picks an element, includes it in c, and deletes it from a.

Bob picks an element, deletes it from a.

So, in the second example:

- Alice picks 0, includes in c, deletes 0 from a. Now a=[1,2,3]

- Bob picks 1, deletes it from a. Now a=[2,3]

- Alice picks 2, includes in c, deletes 2 from a. Now a=[3]

- Bob picks 3, deletes it from a. Now a=[]

Hence, c=[0,2], MEX=1.

Wait, but according to my earlier logic, cnt[1]=1, so Alice should be able to include ceil(1/2)=1 instance of 1 in c.

But in reality, Bob deleted it before Alice could pick it.

Hence, my earlier assumption is incorrect.

So, perhaps for cnt[i]=1, Alice can include it only if she picks it before Bob deletes it.

Given that Alice and Bob alternate turns, and Alice starts, Alice can pick any element first.

So, to maximize the MEX, Alice should pick the smallest available i.

Bob, to minimize the MEX, should pick the smallest available i that Alice hasn't picked yet.

Hence, in the second example:

- Alice picks 0, includes in c, deletes 0 from a. a=[1,2,3]

- Bob picks 1, deletes 1 from a. a=[2,3]

- Alice picks 2, includes in c, deletes 2 from a. a=[3]

- Bob picks 3, deletes 3 from a. a=[]

Hence, c=[0,2], MEX=1.

If Alice had picked 1 first:

- Alice picks 1, includes in c, deletes 1 from a. a=[0,2,3]

- Bob picks 0, deletes 0 from a. a=[2,3]

- Alice picks 2, includes in c, deletes 2 from a. a=[3]

- Bob picks 3, deletes 3 from a. a=[]

Hence, c=[1,2], MEX=0.

Wait, but MEX=0, which is worse for Alice, who wants to maximize MEX.

So, Alice's best strategy is to pick 0 and 2, getting MEX=1.

Wait, but in this case, MEX=1 is better than MEX=0.

Wait, no, MEX=1 is higher than MEX=0, which is what Alice wants.

Wait, in c=[1,2], MEX=0, because 0 is missing.

In c=[0,2], MEX=1, because 1 is missing.

So, MEX=1 is better for Alice than MEX=0.

Hence, in this case, picking 0 and 2 is better for Alice than picking 1 and 2.

Wait, but in the second scenario, c=[1,2], MEX=0, which is worse for Alice.

Wait, perhaps I miscalculated.

Wait, c=[1,2], MEX=0, since 0 is missing.

c=[0,2], MEX=1, since 1 is missing.

So, MEX=1 is better for Alice.

Hence, Alice should aim to include 0 in c, if possible.

But in the second example, even though cnt[0]=1, cnt[1]=1, cnt[2]=1, cnt[3]=1, Bob can delete one of them, preventing Alice from including it.

Hence, in this case, MEX=1.

Wait, perhaps the general rule is that for each i, starting from 0, if cnt[i] is 0, then MEX=i.

Otherwise, if cnt[i] >=1, Alice can include at least one i in c, unless Bob deletes all instances of i.

But in the second example, cnt[1]=1, but Bob deleted it, preventing Alice from including it.

Hence, my earlier assumption is incorrect.

I need to think differently.

Let me consider that for each i, starting from 0, if the number of times Alice can pick i is at least one, then she can include it in c.

Otherwise, it's not included, and that i is the MEX.

To determine if Alice can pick at least one i, consider the counts and the turns.

Wait, perhaps I need to consider that Alice can include ceil(cnt[i]/2) instances of i in c.

If ceil(cnt[i]/2) >=1, then Alice can include i in c.

Otherwise, she cannot.

In the second example, cnt[1]=1, ceil(1/2)=1, so Alice should be able to include 1 in c.

But in reality, Bob deleted it before Alice could pick it.

Hence, my assumption is incorrect.

Wait, perhaps I need to consider that for cnt[i]=1, Alice can include it only if the number of turns before Bob can delete it is favorable.

Wait, this is getting too complicated.

Let me look for a different approach.

Let me consider that Alice can include ceil(cnt[i]/2) instances of i in c.

Bob can delete floor(cnt[i]/2) instances of i.

Hence, if ceil(cnt[i]/2) >=1, Alice can include i in c.

Otherwise, she cannot.

In the second example, cnt[1]=1, ceil(1/2)=1, so Alice should include it.

But in reality, Bob deleted it before Alice could pick it.

Wait, no, according to the game, Bob picked 1 after Alice picked 0.

So, Alice didn't get a chance to pick 1.

Hence, my earlier assumption is incorrect.

Wait, perhaps I need to consider that Bob can delete elements that Alice hasn't picked yet.

Hence, for cnt[i]=1, Bob can delete it before Alice picks it, if he chooses to.

Hence, in this case, Alice cannot include i in c.

Wait, but according to the earlier calculation, ceil(1/2)=1, which is >=1, so Alice should be able to include it.

But in reality, Bob can delete it before Alice picks it.

Hence, my assumption is wrong.

So, perhaps the correct rule is:

For each i, if cnt[i] > 0, and cnt[i] is odd, Alice can include at least one i in c.

If cnt[i] is even, Bob can delete all instances of i, preventing Alice from including any.

Wait, in the second example, cnt[1]=1, which is odd, so Alice should include it, but in reality, Bob deleted it before Alice could pick it.

Wait, no, in the second example, cnt[1]=1, which is odd, so Alice can include it.

But in the example game, Bob deleted it before Alice could pick it.

Wait, perhaps I need to consider the sequence of picks.

Wait, perhaps I need to think in terms of the total number of turns Alice gets to pick elements.

In the second example, n=4, total turns are 4.

Alice picks on turns 1,3; Bob picks on turns 2,4.

So, Alice picks two elements, c has two elements.

Bob deletes two elements.

But in this case, Alice can pick two elements, but Bob can delete one that Alice wants.

Wait, perhaps I need to consider that for each i, if cnt[i] > floor(n/2), then Alice can include at least one i in c.

Wait, in the second example, n=4, floor(4/2)=2.

cnt[i]=1 for i=0,1,2,3.

So, cnt[i] <= floor(n/2), so Alice cannot guarantee including i in c.

Wait, but in the first turn, Alice picks 0, includes in c.

Bob picks 1, deletes it.

Alice picks 2, includes in c.

Bob picks 3, deletes it.

Hence, c=[0,2], MEX=1.

So, in this case, even though cnt[1]=1, which is <= floor(n/2)=2, Alice couldn't include it in c