Alright, I have this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform an operation at most once. This operation allows me to select three integers i, j, and x, and then set all elements from index i to j to the value x. The cost of this operation is (j - i + 1) burles. My goal is to make all elements of the array equal with the least amount of burles spent.

First, I need to understand the problem clearly. I have to make all elements in the array the same, and I can do this by potentially selecting a subset of the array and setting them to a certain value, paying a cost based on the number of elements changed.

Let me consider some examples to get a better understanding.

Example 1:

Input:

6

1 2 3 4 5 1

Output:

4

Explanation:

If I choose i=2, j=4, x=8, the array becomes [1,8,8,8,5,1]. But this doesn't make all elements equal. I need to find a way to make all elements the same with the least cost.

Wait, perhaps I need to choose a value that will make the entire array equal to that value, and find the minimal cost to do so.

Wait, but I can perform the operation only once, and in that operation, I can set a subarray to a certain value.

Alternatively, if I don't perform the operation, the cost is zero, but then all elements need to be already equal.

So, I need to decide whether to perform the operation or not, and if I do, which subarray to set to which value to minimize the cost.

Wait, but the problem says "no more than once", meaning I can choose to perform the operation zero or one time.

Let me think differently. If I perform the operation, I can set any subarray to any value, and the cost is the length of that subarray. My goal is to make the entire array equal.

So, suppose the final array should be all equal to some value y. Then, I need to set some subarrays to y, and the total cost is the sum of the lengths of those subarrays.

But I can perform the operation only once, meaning I can set only one subarray to one value.

Wait, but I can also choose not to perform the operation, which means I don't change anything.

So, if the array is already uniform, the cost is zero.

If not, I need to perform one operation to make it uniform.

Wait, but if I perform one operation, I can set a subarray to a certain value, and the rest remains as is.

So, to make the entire array equal, I need to set the entire array to one value, possibly using one operation.

Wait, but I can only perform one operation, which allows me to set one subarray to one value.

So, I need to choose a subarray and set it to a value such that, combined with the unchanged parts, the entire array becomes uniform.

Wait, that seems tricky.

Let me consider that I can set one subarray to a value x, and the rest of the array remains as is. For the entire array to be uniform, the unchanged parts must already be equal to x.

Wait, that makes sense.

So, if I choose to set a subarray to x, then all elements outside this subarray must already be equal to x.

Otherwise, if there are elements outside the subarray that are not equal to x, then the array cannot be made uniform in one operation.

So, to make the array uniform in one operation, I need to choose a value x that appears in the array, and set a subarray to x such that all elements outside this subarray are already equal to x.

Wait, but that might not cover all cases.

Alternatively, perhaps it's better to think in terms of the minimal cost to make the array uniform, either by doing nothing or by performing one operation.

Let me consider that the array can be made uniform by setting one subarray to a certain value, and the cost is the length of that subarray.

I need to find the minimal such cost.

One approach could be to find the minimal cost to make the array uniform by choosing a value x and a subarray to set to x, such that the entire array becomes x.

Alternatively, perhaps it's better to find the maximal contiguous subarray where all elements are already equal to x, and set the rest of the array to x, paying the cost of the rest.

Wait, but I can only perform one operation, which is to set one subarray to one value.

So, perhaps I need to find the minimal subarray to set so that the entire array becomes uniform.

Wait, perhaps I need to find the minimal subarray to set to a certain value x, such that the rest of the array is already equal to x.

But that seems complicated.

Let me think differently.

Suppose I choose to set the entire array to a certain value x. The cost would be n, since I'm setting all elements to x.

But I can perform only one operation, so perhaps there's a way to reduce the cost by choosing a subarray to set.

Wait, but if I set a subarray to x, the rest remains as is. For the array to be uniform, the rest must already be equal to x.

So, perhaps I should choose a value x that appears in the array, and find the minimal subarray to set to x such that the entire array becomes x.

Wait, that sounds similar to finding the minimal number of elements that are not equal to x, and set them to x.

But I can only set contiguous subarrays in one operation.

So, it's not exactly the same.

Wait, perhaps it's about finding the minimal subarray to set so that the entire array becomes uniform.

Alternatively, perhaps it's about finding the minimal number of elements that need to be changed to make the array uniform, and since I can change a subarray in one operation, the cost is the length of that subarray.

But I need to minimize the cost.

Wait, perhaps the minimal cost is equal to the size of the smallest subarray that needs to be set to make the array uniform.

But I'm not sure.

Let me consider some examples.

Example 1:

n = 6

a = [1,2,3,4,5,1]

Output: 4

Explanation: Maybe set indices 1 to 4 to 1, so the array becomes [1,1,1,1,5,1], then set indices 4 to 5 to 1, but I can only perform one operation.

Wait, but I can only perform one operation.

So, perhaps set indices 2 to 5 to 1, costing 4, resulting in [1,1,1,1,1,1].

So, cost is 4.

Is this the minimal cost?

Is there a way to do it with a lower cost?

What if I set indices 1 to 3 to 2, costing 3, but then the array becomes [2,2,2,4,5,1], which is still not uniform.

Alternatively, set indices 3 to 5 to 1, costing 3, resulting in [1,2,1,1,1,1]. Still not uniform.

Wait, perhaps setting indices 2 to 5 to 1 is the minimal cost operation to make the array uniform.

So, cost is 4.

Example 2:

n = 7

a = [1,1,1,1,1,1,1]

Output: 0

Explanation: Already uniform, so no operation needed.

Example 3:

n = 8

a = [8,8,8,1,2,8,8,8]

Output: 2

Explanation: Set indices 4 and 5 to 8, costing 2, resulting in [8,8,8,8,8,8,8,8].

Is this the minimal cost? If I set indices 4 to 5 to 8, costing 2, which makes the array uniform.

Is there a way to do it with a lower cost? Say, cost=1.

If I set index 4 to 8, costing 1, array becomes [8,8,8,8,2,8,8,8]. Still not uniform.

If I set index 5 to 8, costing 1, array becomes [8,8,8,1,8,8,8,8]. Still not uniform.

So, cost=2 is indeed minimal.

Example 4:

n = 1

a = [1]

Output: 0

Explanation: Only one element, already uniform.

Example 5:

n = 2

a = [1,2]

Output: 1

Explanation: Set index 2 to 1, costing 1, resulting in [1,1].

Alternatively, set index 1 to 2, costing 1, resulting in [2,2].

So, minimal cost is 1.

Example 6:

n = 3

a = [1,2,3]

Output: 2

Explanation: Set indices 1 to 2 to 3, costing 2, resulting in [3,3,3].

Alternatively, set indices 2 to 3 to 1, costing 2, resulting in [1,1,1].

So, minimal cost is 2.

Example 7:

n = 7

a = [4,3,2,7,1,1,3]

Output: 6

Explanation: Not sure, but presumably setting a subarray of length 6 to make the array uniform.

Example 8:

n = 9

a = [9,9,2,9,2,5,5,5,3]

Output: 7

Explanation: Not sure, but likely setting a subarray of length 7 to make the array uniform.

From these examples, it seems that the minimal cost is equal to the size of the minimal subarray that needs to be set to make the entire array uniform.

But how do I find that efficiently?

Let me think about the problem differently.

Suppose I want to make the entire array equal to a specific value x.

To do this, I need to set all elements that are not equal to x to x.

But I can only perform one operation, which is to set a contiguous subarray to x.

So, the elements that are not equal to x must be contained within one subarray.

Therefore, the minimal cost to make the array uniform to x is equal to the length of the minimal subarray that contains all elements not equal to x.

In other words, it's the length of the subarray from the first element not equal to x to the last element not equal to x.

So, for each possible x, I can find the minimal subarray that contains all elements not equal to x, and then take the minimal cost over all possible x.

But since I can only perform one operation, I need to choose the x that minimizes this cost.

Wait, but I can choose any x, not necessarily from the array.

But the problem says that x is any integer, so I can choose any x.

But to minimize the cost, I should choose an x that maximizes the number of elements already equal to x, so that the subarray to be set is minimized.

Wait, but if I choose an x that is not in the array, then no elements are equal to x, so I would need to set the entire array to x, costing n.

But I can also choose an x that is in the array, and then set the subarray that contains all elements not equal to x to x.

So, for each x, the minimal subarray to set is from the first element not equal to x to the last element not equal to x.

The length of this subarray is the minimal cost to make the array uniform to x.

So, the minimal cost is the minimal over all x of (last_not_x - first_not_x + 1).

But I need to consider that if all elements are already equal to x, then the cost is 0.

So, to minimize the cost, I should choose the x that has the maximum number of consecutive elements equal to x, and set the rest in one operation.

Wait, perhaps I need to find the maximal contiguous subarray where all elements are equal to some x, and then set the rest of the array to x, paying the cost of the rest.

But I need to minimize the cost, which is the length of the subarray set.

So, to minimize the cost, I need to maximize the length of the largest contiguous subarray where all elements are equal to x, and then set the rest to x.

Wait, no.

Wait, if I choose x and there is a contiguous subarray where all elements are already x, then I need to set the rest of the array to x.

The cost would be the length of the rest of the array.

But I need to minimize this cost.

So, I need to maximize the length of the contiguous subarray where all elements are equal to x, and then set the rest to x, paying the cost of the rest.

Wait, but that would mean that the minimal cost is n - max_length, where max_length is the length of the longest contiguous subarray with all elements equal to x, over all x.

But actually, it's a bit different.

Because, to make the entire array equal to x, I need to set all elements not equal to x to x in one operation.

These elements must form a single contiguous subarray.

So, for each x, I need to find the minimal subarray that contains all elements not equal to x.

If all elements are already x, then the subarray to set is empty, cost is 0.

If there are elements not equal to x, then the minimal subarray containing all of them is from the first not x to the last not x.

So, for each x, the cost is (last_not_x - first_not_x + 1).

I need to choose x such that this cost is minimized.

But I need to make sure that all not x elements are contained within this subarray.

Wait, actually, if I set the subarray from first_not_x to last_not_x to x, then all elements outside this subarray are already x, and inside the subarray, I set them to x, so the entire array becomes x.

So, yes, for each x, the cost is (last_not_x - first_not_x + 1).

Then, the minimal cost is the minimal over all x of (last_not_x - first_not_x + 1).

But I need to consider that if there are multiple disjoint groups of not x elements, setting one subarray won't cover all of them.

Wait, but in this problem, since I can set only one subarray, I need to make sure that all not x elements are contained within one subarray.

So, for each x, I need to find the minimal subarray that contains all not x elements.

Which is from the first not x to the last not x.

So, for each x, the cost is (last_not_x - first_not_x + 1).

Then, the minimal cost is the minimal over all x of (last_not_x - first_not_x + 1).

But I need to make sure that all not x elements are within this subarray.

Wait, but if there are not x elements that are not contiguous, then it's impossible to cover them with one subarray.

Wait, no, the subarray from first_not_x to last_not_x will cover all not x elements, even if they are not contiguous.

So, for each x, the minimal subarray that contains all not x elements is from the first not x to the last not x.

So, the cost is (last_not_x - first_not_x + 1).

Then, the minimal cost is the minimal over all x of (last_not_x - first_not_x + 1).

But I need to consider that if all elements are already x, then first_not_x and last_not_x don't exist, so the cost is 0.

So, I need to handle that case separately.

Therefore, for each x, if all elements are x, cost is 0.

Otherwise, cost is (last_not_x - first_not_x + 1).

Then, the minimal cost is the minimal over all x of these costs.

But to compute this efficiently, I need an efficient way to find, for each x, the first and last positions where elements are not x.

But since n can be up to 2e5 and t up to 1e4, I need an efficient solution.

Wait, but the total sum of n over all test cases is up to 2e5, so it's manageable.

So, here's an approach:

For each test case:

- Read n and the array a.

- If the array is already uniform, output 0.

- Else, for each possible x, compute the minimal subarray that contains all not x elements, which is (last_not_x - first_not_x + 1), and take the minimal over all x.

But iterating over all x is not efficient, since x can be any integer.

But the problem states that 1 ≤ a_i ≤ n, so x can be from 1 to n.

So, I can iterate over x from 1 to n, and compute the minimal subarray for each x.

But this would be O(n^2) in the worst case, which is too slow for n up to 2e5.

I need a better approach.

Is there a way to find the minimal cost without iterating over each x?

Let me think differently.

Suppose I choose to make the entire array equal to the first element, a[0].

Then, I need to set a subarray from the first element not equal to a[0] to the last element not equal to a[0] to a[0].

The cost would be (last_not_a0 - first_not_a0 + 1).

Similarly, if I choose to make the entire array equal to the last element, a[n-1].

Then, the cost would be (last_not_a(n-1) - first_not_a(n-1) + 1).

But I need to choose x such that this cost is minimized.

Wait, perhaps I can choose x to be the most frequent value in a contiguous segment.

But that seems complicated.

Wait, perhaps I can consider the minimal cost to make the array uniform as n minus the maximal number of consecutive elements that are equal.

Wait, not quite.

Wait, if I can find the maximal number of consecutive equal elements in the array, then setting the rest to that value would make the entire array equal.

The cost would be n minus the length of the longest contiguous subarray with equal elements.

But is that correct?

Let me check with the examples.

Example 1:

n = 6

a = [1,2,3,4,5,1]

The longest contiguous subarray with equal elements is of length 1 for each element.

So, n - 1 = 5, but the output is 4.

So, that doesn't match.

Hence, this approach is incorrect.

Alternative approach needed.

Wait, perhaps I need to find the minimal cost over all possible x.

For each x, find the minimal subarray that contains all not x elements.

Then, minimal cost is the minimal over all x of (last_not_x - first_not_x + 1).

But computing this for each x separately is too slow.

Is there a way to optimize this?

Wait, perhaps I can find the minimal over all x of (last_not_x - first_not_x + 1).

But maybe there's a way to find the minimal such cost without iterating over each x.

Let me think about it.

Suppose I sort the array and find the minimal distance between the first and last not x elements.

But sorting would mess up the indices.

Wait, perhaps I need to look for the minimal window that covers all non-x elements.

But that seems too slow.

Wait, perhaps I can find the minimal cost as the minimal over all possible choices of subarrays such that setting that subarray to any x makes the entire array equal to x.

Wait, that seems vague.

Let me think about it differently.

Suppose I fix the subarray to set, and then choose x accordingly.

If I set a subarray from i to j to x, then to make the entire array equal to x, all elements outside this subarray must already be equal to x.

So, for a given subarray i to j, I need to choose x such that all elements outside i to j are equal to x.

But that seems complicated.

Alternatively, perhaps I can choose x to be the value that appears the most in the array, and then set a subarray to x such that the rest of the array is already x.

Wait, but if I choose x as the most frequent value, and there are multiple subarrays that need to be set to x, but I can only set one subarray.

Wait, perhaps choosing x as the value that has the longest contiguous subarray of equal values.

Then, the cost would be n minus the length of that subarray.

But in the first example, the longest contiguous subarray of equal values is 1 (since all elements are unique), n - 1 = 5, but the output is 4.

So, that doesn't match.

Hence, this approach is incorrect.

I need to find another way.

Let me consider that the minimal cost is equal to the size of the minimal subarray that needs to be set to make the entire array equal.

So, I need to find the smallest subarray such that, when set to a certain value, the entire array becomes equal.

So, I need to find a subarray where, if I set it to a certain value, all elements outside this subarray are already equal to that value.

So, for a subarray from i to j, I need to choose x such that all elements before i and after j are equal to x.

Wait, but in one operation, I can only set one subarray to one value.

So, perhaps I need to find the minimal subarray that, when set to a certain x, makes the entire array equal to x.

So, for a given subarray i to j, I need to choose x such that all elements outside i to j are equal to x.

If such an x exists, then the cost is (j - i + 1).

Otherwise, it's impossible with that subarray.

So, for each possible subarray i to j, I need to check if there exists an x such that all elements before i and after j are equal to x.

If yes, then the cost is (j - i + 1).

I need to find the minimal such cost over all possible subarrays.

But this seems too slow, as it would be O(n^2).

I need a better approach.

Wait, perhaps I can find the minimal j - i + 1 such that all elements outside i to j are equal to some x.

So, for each subarray i to j, check if all elements before i are equal to some x and all elements after j are equal to the same x.

Wait, but I can choose x independently.

Wait, perhaps I need to find the minimal j - i + 1 such that all elements before i are equal to some x and all elements after j are equal to the same x.

Then, set the subarray i to j to x.

So, the cost is (j - i + 1).

I need to find the minimal such cost.

But this seems still too slow.

Is there a way to find the minimal j - i + 1 such that all elements before i and after j are equal to some x?

Wait, perhaps I can find the prefix and suffix where the elements are equal to some x, and then set the middle part to x.

So, find the longest prefix that has all elements equal to x, and the longest suffix that has all elements equal to x, and then set the middle subarray to x.

The cost would be n - (prefix_length + suffix_length - overlap).

But I need to maximize prefix_length + suffix_length - overlap to minimize the cost.

This seems complicated.

Wait, perhaps I need to find the minimal j - i + 1 such that all elements before i and after j are equal to some x.

So, for each possible i and j, find if there exists an x such that a[1] to a[i-1] are x and a[j+1] to a[n] are x.

If yes, then the cost is (j - i + 1).

I need to find the minimal such cost.

But again, this seems too slow for n up to 2e5.

I need a smarter way.

Let me consider that the array can be divided into a prefix and a suffix that are equal to some x, and the middle part is the subarray to set to x.

So, I need to find the minimal length of the middle part such that the prefix and suffix are equal to some x.

So, I need to find i and j such that a[1] to a[i] are equal to x, a[j+1] to a[n] are equal to x, and