Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, and I can perform a specific operation on any element that's at least 10. The operation allows me to delete that element and insert its digits in the same position. For example, if I have [12, 3, 45, 67] and I apply the operation to the third element, 45, it becomes [12, 3, 4, 5, 67]. Another example is [2, 10], applying the operation to the second element gives [2, 1, 0].

My task is to determine if it's possible to make the array sorted in non-decreasing order by performing this operation any number of times, possibly zero.

First, I need to understand what it means for an array to be sorted in non-decreasing order. It means that each element is less than or equal to the next element in the array. For example, [1, 2, 2, 3, 4] is sorted in non-decreasing order, but [1, 3, 2] is not.

Now, the operation allows me to split any number that is at least 10 into its individual digits. So, 12 becomes 1 and 2, 45 becomes 4 and 5, and so on. I can perform this operation any number of times on any qualifying element.

I need to figure out if, by splitting some or all of these numbers, I can arrange the array so that it's sorted in non-decreasing order.

Let me look at the examples provided to understand better.

First test case:

4

12 3 45 67

After splitting 12, it becomes [1, 2, 3, 45, 67]. This is sorted because 1 ≤ 2 ≤ 3 ≤ 45 ≤ 67. So, the answer is YES.

Second test case:

3

12 28 5

If I split 12, it becomes [1, 2, 28, 5]. This is not sorted because 2 > 5.

If I split 28, it becomes [12, 2, 2, 8, 5]. Still not sorted.

If I split both 12 and 28, it becomes [1, 2, 2, 8, 5]. Again, 8 > 5, so not sorted.

If I split 5, but 5 is less than 10, so I can't split it. So, no matter what I do, I can't get a sorted array. Hence, the answer is NO.

Third test case:

2

0 0

It's already sorted, so no need to perform any operations. The answer is YES.

From these examples, it seems that splitting numbers can help rearrange the array to be sorted, but there are limitations based on the digits of the numbers.

Now, let's think about how to approach this problem systematically.

One way is to consider all possible ways of splitting the numbers that are at least 10 and check if any of these configurations result in a sorted array.

However, considering all possible combinations could be computationally expensive, especially since n can be up to 50, and each number can have up to 2 digits. So, we need a more efficient way.

Let me think about the properties of the array after splitting.

When we split a number, we insert its digits in place of the number itself. So, for example, 12 becomes 1 and 2, which are smaller than 12, and 45 becomes 4 and 5, which are smaller than 45.

This suggests that splitting a number can only decrease the value in that position, or rather, replace the number with smaller digits.

Wait, but in the first example, splitting 12 from [12, 3, 45, 67] to [1, 2, 3, 45, 67], the array becomes sorted. Here, 1 and 2 are smaller than 12, so the array is sorted.

In the second example, splitting 12 to [1, 2, 28, 5], 1 and 2 are smaller than 12, but 28 is larger than 5, so it's not sorted.

If I split 28 to [1, 2, 2, 8, 5], which is not sorted because 8 > 5.

So, it seems that splitting numbers can help in making the array sorted, but it's not always possible.

I need to find a way to decide whether it's possible to split some numbers to make the array sorted.

One idea is to try to split numbers in a way that the resulting array is sorted.

But how?

Maybe I can think of it as building the smallest possible array by splitting numbers and see if that smallest array is sorted.

Wait, perhaps I can consider the array after fully splitting all numbers that are at least 10 into their digits.

For example, in the first test case, if I split 12 and 45 and 67, I get [1, 2, 3, 4, 5, 6, 7], which is sorted.

But in the second test case, splitting 12 and 28 gives [1, 2, 2, 8, 5], which is not sorted.

But in the third test case, no splitting is needed since the array is already sorted.

So, perhaps the approach is to fully split all numbers that are at least 10 and see if the resulting array is sorted.

But wait, in the first test case, I didn't need to split all numbers to make it sorted. I only split 12, and the array became sorted.

So, maybe I don't need to fully split all numbers, just some of them.

This seems tricky.

Let me think differently.

Suppose I have the array [a1, a2, ..., an]. I need to ensure that a1 <= a2 <= ... <= an after some operations.

Each operation allows me to replace a number ai (if ai >= 10) with its digits.

So, for each position, ai can be either kept as it is (if ai < 10 or choose not to split), or split into its digits.

I need to choose for each ai >= 10 whether to split it or not, in such a way that the resulting array is sorted.

This sounds like a decision problem where for each ai >= 10, I have two choices: split or not split.

But with n up to 50, and each having two choices, that's 2^50 possibilities, which is too large to check exhaustively.

So, I need a smarter approach.

Maybe I can think in terms of the maximum value I can have at each position if I choose to split or not split.

Wait, perhaps dynamic programming could be useful here.

Let's consider dp[i], which represents the maximum value in the array up to the i-th position after performing operations.

But I'm not sure.

Let me consider the process step by step.

I need to ensure that for each position i, the element at i is less than or equal to the element at i+1.

So, starting from the left, I need to make sure that each element is less than or equal to the next one.

If I have ai > ai+1, and ai >= 10, I can try splitting ai to see if that helps.

But splitting ai can insert multiple digits in place of ai, which can affect the comparison with ai+1.

This seems complicated.

Maybe another approach is to consider the fully split array and see if it's sorted.

But in the first test case, splitting only 12 was enough to make it sorted, without splitting 45 and 67.

So, fully splitting all numbers might not be necessary, and it could lead to a longer array that is sorted, but perhaps there's a shorter way.

Wait, perhaps I should consider the array after all possible splits, meaning splitting all numbers that are >=10 into their digits, and then check if this fully split array can be sorted.

But in the first test case, fully splitting all numbers would give [1,2,3,4,5,6,7], which is sorted, but splitting only 12 gives [1,2,3,45,67], which is also sorted.

In the second test case, fully splitting gives [1,2,2,8,5], which is not sorted, and splitting only 12 gives [1,2,28,5], which is not sorted, and splitting only 28 gives [12,2,8,5], which is not sorted, and splitting both gives [1,2,2,8,5], which is not sorted.

So, in this case, since no configuration is sorted, the answer is NO.

In the third test case, the array is already sorted, so no need to split anything.

So, perhaps the approach is to fully split the array and see if the resulting array is sorted.

But in the first test case, splitting only some numbers was enough to make it sorted.

So, maybe I need to check if there exists any split configuration that is sorted.

But checking all possible configurations is not feasible due to time constraints.

Is there a better way to approach this?

Let me consider that splitting a number ai >=10 into its digits decreases its value, since digits are always less than 10, and ai >=10.

Wait, not necessarily. For example, splitting 12 gives 1 and 2, which are both less than 12, but splitting 28 gives 2 and 8, which are both less than 28.

So, splitting a number ai >=10 always replaces it with digits that are less than 10.

Therefore, splitting ai >=10 will always result in digits that are less than 10.

So, in the array, after splitting some numbers, some elements will be less than 10, and some will remain as they are if not split.

Now, to make the array sorted in non-decreasing order, for each position i, ai <= ai+1.

So, I need to choose whether to split ai or not, based on the value of ai+1.

Wait, perhaps I can iterate through the array and decide for each ai whether to split it or not, based on the next element.

Let's try to think of an algorithm.

Start from the beginning of the array.

For each position i from 1 to n-1:

If ai > ai+1, and ai >=10, then split ai into its digits.

Insert the digits in place of ai.

Then, check if the new array is sorted.

But this seems too simplistic, and may not work in all cases.

Let me try this with the first test case.

Array: [12, 3, 45, 67]

Check a1=12 and a2=3.

12 > 3, and 12 >=10, so split 12 into 1 and 2.

New array: [1, 2, 3, 45, 67]

Now, check if this array is sorted.

1 <=2 <=3 <=45 <=67, which is true.

So, YES.

In the second test case:

Array: [12, 28, 5]

Check a1=12 and a2=28.

12 <=28, so no need to split.

Then, check a2=28 and a3=5.

28 >5, and 28 >=10, so split 28 into 2 and 8.

New array: [12, 2, 8, 5]

Now, check if this array is sorted.

12 <=12, but 12 >2, which is not true.

So, need to split 12 as well.

Split 12 into 1 and 2.

New array: [1, 2, 2, 8, 5]

Check if sorted: 1 <=2 <=2 <=8 <=5.

Wait, 8 >5, which is not true.

So, still not sorted.

Is there another way to split?

What if I split only a2=28 into 2 and 8, and keep a1=12 as is, which gives [12,2,8,5], which is not sorted.

If I split a1=12 into 1 and 2, and keep a2=28 as is, which gives [1,2,28,5], which is not sorted.

If I split both a1=12 and a2=28, which gives [1,2,2,8,5], which is not sorted.

If I don't split a2=28, but only split a1=12, which is the case above.

It seems that no configuration leads to a sorted array.

Hence, the answer is NO.

In the third test case:

Array: [0,0]

Already sorted, so YES.

So, perhaps the approach is to iterate through the array, and whenever ai > ai+1 and ai >=10, split ai into its digits, and repeat this process until the array is sorted or no more splits can be made.

But this seems like a greedy approach, and it might not always work.

In the first test case, splitting a1=12 once was enough to make the array sorted.

In the second test case, splitting a1=12 and then a2=28 didn't make it sorted.

But maybe there are cases where splitting one element requires splitting another element subsequently.

This could get complicated.

Is there a better way?

Let me consider that splitting a number ai >=10 into its digits can be seen as replacing ai with its digits, which are all less than 10.

So, after splitting, the only elements in the array that are >=10 are those that were not split.

Therefore, in the final array, all elements are less than 10, unless they were not split.

Wait, but splitting is optional, so some elements can remain >=10 if they are not split.

But the problem allows splitting any number of times, but it's not clear if splitting can be done multiple times on the same element.

But since splitting is only allowed on elements >=10, and splitting replaces them with digits <10, you can't split the same element multiple times.

So, for each element >=10, you have two choices: split it once or don't split it.

Now, to make the array sorted, I need to choose for each ai >=10 whether to split it or not, such that the resulting array is sorted.

This sounds like a graph where each ai >=10 has two possibilities: split or not split, and I need to find a path where the sequence is sorted.

But this seems too abstract.

Is there a way to model this problem more simply?

Let me consider that after all possible splits, the array consists of elements that are either the original ai <10, or the digits of ai if ai >=10.

So, the final array will consist only of single-digit numbers.

Wait, no. Because if I don't split some ai >=10, they remain as they are.

So, the final array can have elements that are either single digits or numbers >=10.

But in the examples, we see that splitting can introduce single digits.

Now, to make the array sorted, I need to have a non-decreasing sequence.

So, perhaps I can consider all possible combinations of splitting or not splitting for each ai >=10, and check if any of these combinations result in a sorted array.

But as mentioned earlier, with n=50, this is not feasible due to time constraints.

I need a smarter way.

Let me consider that splitting a number ai >=10 can only help in making the array sorted if the digits are smaller than the next element or the previous element, depending on the position.

Wait, perhaps I can iterate through the array and ensure that for each position, if ai >=10 and ai > ai+1, then I must split ai.

But in the first test case, splitting a1=12 was enough to make the array sorted.

In the second test case, splitting a1=12 and a2=28 didn't make it sorted.

So, maybe I need to ensure that after splitting, the maximum digit of ai is less than or equal to ai+1.

But this seems too vague.

Let me think differently.

Suppose I fully split the array, meaning I split all ai >=10 into their digits, and then check if the resulting array is sorted.

In the first test case, fully splitting gives [1,2,3,4,5,6,7], which is sorted.

In the second test case, fully splitting gives [1,2,2,8,5], which is not sorted.

In the third test case, no splitting is needed since the array is already sorted.

So, perhaps the answer is to fully split the array and check if the resulting array is sorted.

But in the first test case, splitting only a1=12 was enough to make it sorted.

So, is it sufficient to check if the fully split array is sorted?

Wait, but in the first test case, splitting only a1=12 was enough, but splitting all numbers would also result in a sorted array.

So, perhaps if the fully split array is sorted, then it's possible to make the array sorted by splitting some numbers.

But is the converse true? That is, if the fully split array is sorted, does that mean that there exists a way to split some numbers to make the array sorted?

In the first test case, the fully split array is sorted, and indeed, splitting only a1=12 was enough.

In the second test case, the fully split array is not sorted, and neither are any other configurations.

So, perhaps checking if the fully split array is sorted is a sufficient condition.

But is it necessary?

Let me think of a case where the fully split array is not sorted, but there exists a way to split some numbers to make the array sorted.

Is that possible?

Let's consider an example.

Suppose the array is [15, 2, 3].

If I fully split it, I get [1,5,2,3], which is not sorted.

But if I only split 15, I get [1,5,2,3], which is not sorted.

Alternatively, if I don't split 15, the array is [15,2,3], which is not sorted.

So, in this case, the fully split array is not sorted, and there's no way to make it sorted by splitting some numbers.

Another example: [10, 1, 2].

Fully splitting gives [1,0,1,2], which is not sorted.

If I split only 10, I get [1,0,1,2], which is not sorted.

If I don't split 10, the array is [10,1,2], which is not sorted.

So, again, the fully split array is not sorted, and there's no way to make it sorted.

Now, consider [11,11,11].

Fully splitting gives [1,1,1,1,1,1], which is sorted.

Splitting only one 11 gives [1,1,11,11], which is sorted.

So, in this case, both fully splitting and splitting only one element lead to a sorted array.

So, it seems that if the fully split array is sorted, then there exists a way to make the array sorted by splitting some numbers.

And if the fully split array is not sorted, then there is no way to make the array sorted by splitting some numbers.

Is this always true?

Let me think of a case where the fully split array is not sorted, but there's a way to split some numbers to make it sorted.

Suppose the array is [20, 1, 10].

Fully splitting gives [2,0,1,1,0], which is not sorted.

If I split only 20, I get [2,0,1,10].

Is this sorted? 0 <=1 <=2 <=10, but 0 is before 2, which breaks the non-decreasing order.

If I split only 10, I get [20,1,1,0], which is not sorted.

If I don't split any, [20,1,10], which is not sorted.

So, in this case, no configuration is sorted, matching that the fully split array is not sorted.

Another example: [12, 1, 10].

Fully splitting gives [1,2,1,1,0], which is not sorted.

Splitting only 12 gives [1,2,1,10], which is not sorted.

Splitting only 10 gives [12,1,1,0], which is not sorted.

Splitting both gives [1,2,1,1,0], which is not sorted.

Not splitting any gives [12,1,10], which is not sorted.

So, again, consistent with the fully split array not being sorted.

So, it seems that checking if the fully split array is sorted is a sufficient condition to determine if there exists a way to make the array sorted by splitting some numbers.

Therefore, my approach will be:

1. Fully split the array by splitting all elements that are >=10 into their digits.

2. Check if the resulting array is sorted in non-decreasing order.

3. If it is sorted, then output YES; otherwise, output NO.

This should work efficiently since n is up to 50, and splitting each number into at most 2 digits won't be too time-consuming.

Now, let's think about how to implement this.

I need a function to split a number into its digits, if it's >=10.

For example, 12 -> [1,2], 45 -> [4,5], 67 -> [6,7], etc.

I need to apply this function to each element in the array and collect all the digits in order.

Then, check if this resulting list is sorted.

Wait, but in the first test case, fully splitting [12,3,45,67] gives [1,2,3,4,5,6,7], which is sorted.

In the second test case, fully splitting [12,28,5] gives [1,2,2,8,5], which is not sorted.

In the third test case, no splitting is needed since all elements are <10 and already sorted.

Now, I need to implement this logic.

But looking back at the given program, it seems to be attempting something different.

Let's look at the provided program:

t = int(input())

for i in range(t):

n = int(input())

list1 = list(map(int, input().split()))

for p in range(1, len(list1)):

if list1[p - 1] > list1[p] and list1[p - 1] > 10:

a = list1[p - 1]

list1.pop(p - 1)

list1.insert(p - 1, a // 10)

list1.insert(p, a % 10)

if func_1(list1):

print('Yes')

else:

print('No')

def func_1(lst):

sorted_lst = sorted(lst)

return lst == sorted_lst

So, in this program, for each test case, it reads n and the list of integers.

Then, it iterates from the second element to the end of the list.

For each element at position p, if list1[p-1] > list1[p] and list1[p-1] >10, it splits list1[p-1] into its tens and units digits and inserts them back into the list at the same position.

Then, it checks if the modified list is sorted using func_1, which checks if the list is equal to its sorted version.

If it is sorted, it prints 'Yes'; otherwise, 'No'.

Wait, but in the first test case, [12,3,45,67], after splitting 12, it becomes [1,2,3,45,67], which is sorted, so it should print 'Yes'.

In the second test case, [12,28,5], splitting 12 gives [1,2,28,5], which is not sorted, and splitting 28 gives [1,2,2,8,5], which is not sorted, so it should print 'No'.

In the third test case, [0,0], it's already sorted, so it should print 'Yes'.

So, it seems to work for the examples.

But is this approach correct in general?

Wait, in the first loop, it only attempts to split list1[p-1] if list1[p-1] > list1[p] and list1[p-1] >10.

It splits only once, and then checks if the list is sorted.

But in some cases, maybe multiple splits are needed.

But in the first test case, splitting once is enough.

In the second test case, splitting once doesn't help, and splitting multiple times might not help either.

So, perhaps this approach works.

But I'm not entirely sure.

Let me think of a case where this approach might fail.

Suppose the array is [20, 1, 10].

Fully splitting gives [2,0,1,1,0], which is not sorted.

The given program would split 20 because 20 >1 and 20>10, so it splits 20 into 2 and 0, resulting in [2,0,1,10].

This is not sorted, so it would print 'No', which is correct.

Another case: [12, 3, 45, 67], which is the first test case, correctly handled.

Another case: [11,11,11], fully splitting gives [1,1,1,1,1,1], which is sorted.

The program would split the first 11, resulting in [1,1,11,11], which is sorted, so it would print 'Yes', which is correct.

Another case: [15,2,3], fully splitting gives [1,5,2,3], which is not sorted.

The program would split 15 because 15>2 and 15>10, resulting in [1,5,2,3], which is not sorted, so it would print 'No', which is correct.

Seems okay.

But let's think of a more complicated case.

Consider [19, 2, 20].

Fully splitting