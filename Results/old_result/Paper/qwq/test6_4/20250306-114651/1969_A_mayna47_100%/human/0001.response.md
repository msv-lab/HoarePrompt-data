Alright, I have this problem to solve. Monocarp wants to throw a party and invite some of his friends, but there are specific conditions about who comes to the party based on who gets invited and their best friends. It sounds a bit tricky, but let's break it down step by step.

First, let's understand the problem. Monocarp has n friends, and he wants at least 2 of them to come to his party. Each friend has a best friend, and this best friend relationship is represented by p_i, which means the best friend of friend i is friend p_i. The problem says that all p_i are distinct and p_i is not equal to i, so no one is their own best friend, and each friend has a unique best friend.

Now, the condition for a friend to come to the party is that both the friend and their best friend receive an invitation. So, if I invite friend i, but I don't invite their best friend p_i, friend i won't come to the party. But interestingly, if I invite both friend i and their best friend p_i, then friend i will come, regardless of whether p_i's best friend is invited or not.

The goal is to find the minimum number of invitations Monocarp has to send so that at least 2 friends come to the party.

Let's look at the example provided to understand better.

In the first test case:

n = 5

p = [3, 1, 2, 5, 4]

So, friend 1's best friend is 3, friend 2's best friend is 1, friend 3's best friend is 2, friend 4's best friend is 5, and friend 5's best friend is 4.

Monocarp sends invitations to friends [1, 2, 4, 5]. Now, let's see who comes:

- Friend 1: invited and their best friend 3 is also invited, so friend 1 comes.

- Friend 2: invited and their best friend 1 is also invited, so friend 2 comes.

- Friend 3: not invited, so doesn't come.

- Friend 4: invited and their best friend 5 is also invited, so friend 4 comes.

- Friend 5: invited and their best friend 4 is also invited, so friend 5 comes.

But according to the explanation, only friends 2, 4, and 5 come. Wait, maybe I misread. Let's check again.

In the example, it says Monocarp sends invitations to [1, 2, 4, 5], and friends [2, 4, 5] come. Friend 1 won't come because his best friend 3 didn't receive an invitation. Wait, but 3 was invited, right? No, wait, Monocarp sent invitations to [1, 2, 4, 5], but friend 3 was not invited. So, friend 1 requires both themselves and their best friend 3 to be invited, but 3 was not invited, so friend 1 doesn't come. Friend 2 was invited and their best friend 1 was invited, so friend 2 comes. Friend 4 was invited and their best friend 5 was invited, so friend 4 comes. Friend 5 was invited and their best friend 4 was invited, so friend 5 comes. Friend 3 was not invited, so doesn't come.

So, friends 2, 4, and 5 come. That makes sense.

Now, the problem is to find the minimum number of invitations needed so that at least 2 friends come.

Looking at the provided program:

t = int(input())

for i in range(t):

func_1()

def func_1():

n = int(input())

v = [0] * (n + 1)

v = [0] + list(map(int, input().split()))

for i in range(1, n + 1):

if v[v[i]] == i:

print(2)

return

print(3)

So, the program reads the number of test cases t, and for each test case, it calls func_1(). In func_1(), it reads n and the list p_i, adjusts the indexing by adding a 0 at the beginning, and then checks for each friend i if v[v[i]] == i. If this condition is true for any i, it prints 2 and returns; otherwise, it prints 3.

Wait, why is it checking v[v[i]] == i? Let's think about what this means.

v[i] is the best friend of friend i.

v[v[i]] is the best friend of the best friend of friend i.

So, v[v[i]] == i means that friend i and friend v[i] are best friends of each other. In other words, they have a mutual best friend relationship.

So, if there exists at least one pair of friends who are each other's best friends, then the minimum number of invitations needed is 2, because Monocarp can invite both friends in the pair, and both will come to the party.

Otherwise, if no such pair exists, then Monocarp needs to invite at least 3 friends to ensure that at least 2 come to the party.

Wait, is that always true?

Let's think about it.

If there is a mutual pair, i and j, where j is i's best friend and i is j's best friend, then by inviting both i and j, both will come because each has their best friend invited.

So, in this case, inviting 2 friends is sufficient to have 2 friends come to the party.

Now, if there is no such mutual pair, what happens?

Let's consider the second test case:

n = 4

p = [2, 3, 4, 1]

So, friend 1's best friend is 2, friend 2's best friend is 3, friend 3's best friend is 4, and friend 4's best friend is 1.

In this case, there are no mutual best friends. If Monocarp invites any two friends, say 1 and 2, then:

- Friend 1: invited and best friend 2 is invited, so friend 1 comes.

- Friend 2: invited and best friend 3 is not invited, so friend 2 does not come.

- Friend 3: not invited, so doesn't come.

- Friend 4: not invited, so doesn't come.

So, only friend 1 comes.

If Monocarp invites friends 1, 2, and 3:

- Friend 1: invited and best friend 2 is invited, so friend 1 comes.

- Friend 2: invited and best friend 3 is invited, so friend 2 comes.

- Friend 3: invited and best friend 4 is not invited, so friend 3 does not come.

- Friend 4: not invited, so doesn't come.

So, friends 1 and 2 come, which satisfies the condition of at least 2 friends coming.

Similarly, inviting friends 2, 3, and 4 would result in friends 2 and 3 coming.

So, in this case, it's not possible to have at least 2 friends come with only 2 invitations, but it is possible with 3 invitations.

Therefore, the program's logic seems correct: if there exists at least one mutual best friend pair, then 2 invitations are sufficient; otherwise, 3 are needed.

But is this always the case? Let's consider another example.

Third test case:

n = 2

p = [2, 1]

Here, friends 1 and 2 are each other's best friends. So, if Monocarp invites both, both will come. So, inviting 2 friends is sufficient.

Which matches the program's output.

Now, let's think about whether there could be a case where even if there are mutual best friend pairs, inviting only 2 friends is not sufficient.

Wait, no. If there is a mutual pair, inviting both will make both come, as per the condition.

Alternatively, if there are no mutual best friend pairs, is 3 always sufficient?

Let's consider a scenario with n=3:

p = [2, 3, 1]

So, friend 1's best friend is 2, friend 2's best friend is 3, and friend 3's best friend is 1.

There are no mutual best friend pairs here because none of them have a best friend who has them as their best friend back.

So, if Monocarp invites any two friends, say 1 and 2:

- Friend 1: invited, best friend 2 is invited, so friend 1 comes.

- Friend 2: invited, best friend 3 is not invited, so friend 2 does not come.

- Friend 3: not invited, so doesn't come.

Only friend 1 comes.

If he invites 1 and 3:

- Friend 1: invited, best friend 2 is not invited, so doesn't come.

- Friend 3: invited, best friend 1 is invited, so friend 3 comes.

Only friend 3 comes.

If he invites 2 and 3:

- Friend 2: invited, best friend 3 is invited, so friend 2 comes.

- Friend 3: invited, best friend 1 is not invited, so doesn't come.

Only friend 2 comes.

So, in this case, inviting any two friends only results in one friend coming. Therefore, Monocarp needs to invite all three to have at least two friends come.

For example, inviting 1, 2, and 3:

- Friend 1: invited, best friend 2 is invited, so comes.

- Friend 2: invited, best friend 3 is invited, so comes.

- Friend 3: invited, best friend 1 is invited, so comes.

All three come.

Thus, in cases without mutual best friend pairs, inviting three friends is sufficient to have at least two come.

Now, is there any case where inviting three is not sufficient?

Consider n=4:

p = [2, 3, 4, 2]

Wait, but p_i must be distinct and p_i != i.

Wait, in this case, p = [2, 3, 4, 2] would have p_1=2, p_2=3, p_3=4, p_4=2.

But p_i must be distinct, so p_1=2 and p_4=2 would violate the distinct condition.

Wait, the problem says all p_i are distinct, so p = [2, 3, 4, 1] would be valid.

In this case, it's a cycle: 1 -> 2 -> 3 -> 4 -> 1.

If Monocarp invites any three friends, say 1, 2, 3:

- Friend 1: invited, best friend 2 is invited, so comes.

- Friend 2: invited, best friend 3 is invited, so comes.

- Friend 3: invited, best friend 4 is not invited, so doesn't come.

- Friend 4: not invited, so doesn't come.

Only friends 1 and 2 come.

Similarly, inviting 2, 3, 4:

- Friend 2: invited, best friend 3 is invited, so comes.

- Friend 3: invited, best friend 4 is invited, so comes.

- Friend 4: invited, best friend 2 is invited, so comes.

All three come.

So, in this case, inviting three can result in either two or three friends coming, depending on who is invited.

But in the previous n=3 case, inviting three results in all three coming.

So, in general, if there are no mutual best friend pairs, inviting three friends is sufficient to have at least two come.

Now, is there a case where inviting two is sufficient even without mutual best friend pairs? Let's consider:

n=4

p = [2, 1, 4, 3]

Here, friends 1 and 2 are mutual best friends, and friends 3 and 4 are mutual best friends.

So, if Monocarp invites friends 1 and 2, both will come.

Similarly, inviting friends 3 and 4 will make both come.

But according to the program, if there exists at least one mutual pair, it prints 2.

If there are multiple mutual pairs, it still prints 2.

Which is correct.

Now, what if there are no mutual best friend pairs?

n=4

p = [2, 3, 1, 4]

Here, friend 1's best friend is 2, friend 2's best friend is 3, friend 3's best friend is 1, and friend 4's best friend is 4.

Wait, but p_i != i, so p_4 cannot be 4.

Let's correct it:

n=4

p = [2, 3, 4, 1]

So, friend 1's best friend is 2, friend 2's best friend is 3, friend 3's best friend is 4, friend 4's best friend is 1.

No mutual best friend pairs.

In this case, inviting any two friends results in only one coming, as we saw earlier.

Inviting three friends is sufficient to have at least two come.

Hence, the program's logic seems correct.

Now, let's look at the program again.

t = int(input())

for i in range(t):

func_1()

def func_1():

n = int(input())

v = [0] * (n + 1)

v = [0] + list(map(int, input().split()))

for i in range(1, n + 1):

if v[v[i]] == i:

print(2)

return

print(3)

So, it reads t, the number of test cases, then for each test case, it calls func_1().

In func_1(), it reads n and the list p_i, adjusts the indexing by creating a list v with v[0]=0 and v[i]=p_i for i from 1 to n.

Then, it loops through each friend i from 1 to n and checks if v[v[i]] == i, meaning if friend i and friend v[i] are mutual best friends.

If such a pair exists, it prints 2 and returns.

If no such pair exists after checking all friends, it prints 3.

This seems correct based on our earlier reasoning.

But is there any edge case where this logic fails?

Let's consider n=2 with mutual best friends:

n=2

p=[2,1]

The program will check v[v[1]] == v[2] ==1, which matches i=1.

So, it prints 2, which is correct.

Another case:

n=2

p=[2,1]

Again, mutual best friends, prints 2.

Now, n=3 with no mutual best friends:

n=3

p=[2,3,1]

Check v[v[1]] == v[2] ==3 !=1, so no.

v[v[2]] == v[3] ==1 !=2, no.

v[v[3]] == v[1] ==2 !=3, no.

So, prints 3, which is correct.

Another case:

n=4

p=[2,3,4,1]

Check:

v[v[1]] == v[2] ==3 !=1

v[v[2]] == v[3] ==4 !=2

v[v[3]] == v[4] ==1 !=3

v[v[4]] == v[1] ==2 !=4

No mutual pairs, prints 3, which is correct.

Another case with multiple mutual pairs:

n=4

p=[2,1,4,3]

Check:

v[v[1]] == v[2] ==1 ==i=1

So, prints 2, which is correct.

Seems like the logic holds for these cases.

Is there any case where there are mutual pairs, but the program doesn't detect them?

Let's try n=4, p=[2,1,3,4]

Check:

v[v[1]] == v[2] ==1 ==i=1 → mutual pair.

v[v[2]] == v[1] ==2 ==i=2 → mutual pair.

v[v[3]] == v[3] ==3 !=i=3 → not mutual.

v[v[4]] == v[4] ==4 !=i=4 → not mutual.

So, prints 2, which is correct.

Another case: n=3, p=[2,1,3]

Check:

v[v[1]] == v[2] ==1 ==i=1 → mutual pair.

So, prints 2.

Wait, but according to earlier reasoning, in n=3 without mutual pairs, it should print 3.

Wait, in this case, n=3, p=[2,1,3], v[v[1]] == v[2] ==1 ==i=1, which is a mutual pair, so prints 2.

But in the earlier n=3 case, p=[2,3,1], v[v[1]] == v[2] ==3 !=1, no mutual pair, so prints 3.

Yes, that makes sense.

So, the program seems correct.

I don't see any flaws in the logic.

Therefore, the given program is correct.

**Final Answer**

\[\boxed{\text{True}}\]

