Alright, I have this problem to solve. It involves a game between Alice and Bob on an array, and I need to determine the final score based on their optimal plays. Let's break this down step by step.

First, understanding the game mechanics:

- There's an array `a` of size `n`, and Alice starts with an empty array `c`.

- Players take turns, with Alice going first.

- On Alice's turn, she picks an element from `a`, appends it to `c`, and deletes it from `a`.

- On Bob's turn, he picks an element from `a`, deletes it from `a`, but does not add it to `c`.

- The game ends when `a` is empty, and the score is the MEX of `c`. MEX is the smallest non-negative integer not present in `c`.

- Alice wants to maximize the MEX, and Bob wants to minimize it.

My task is to find the final MEX when both play optimally.

Okay, so MEX is about finding the smallest missing number in `c`. To maximize MEX, Alice would want to include as many small numbers in `c` as possible, preferably in order starting from 0. Bob, on the other hand, wants to minimize MEX, so he'll try to hinder Alice's efforts.

Let me think about how the game progresses.

Each turn:

- Alice picks an element to add to `c` and removes it from `a`.

- Bob picks an element to remove from `a`, without adding it to `c`.

So, effectively, Alice is controlling what goes into `c`, and Bob is controlling what gets removed from `a` without affecting `c`.

The game continues until `a` is empty.

I need to model their optimal strategies.

Let's consider some examples to get a better understanding.

Example 1:

Input:

4

0 0 1 1

Possible game:

- Alice picks 1, c=[1], a=[0,0,1]

- Bob picks 0, a=[0,1]

- Alice picks 0, c=[1,0], a=[1]

- Bob picks 1, a=[]

Final c: [1,0], MEX is 2.

Example 2:

Input:

4

0 1 2 3

Possible game:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob picks 3, a=[]

Final c: [0,2], MEX is 1.

Wait, but in this case, Alice could have picked 1 instead, leading to c=[0,1], MEX=2.

But Bob wants to minimize MEX, so perhaps he can force a lower MEX.

Alternative game:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob picks 3, a=[]

Final c: [0,2], MEX=1.

Another game:

- Alice picks 1, c=[1], a=[0,2,3]

- Bob picks 0, a=[2,3]

- Alice picks 2, c=[1,2], a=[3]

- Bob picks 3, a=[]

Final c: [1,2], MEX=0.

Wait, but Alice can pick 0 instead.

Seems complicated.

I need a better approach.

Let me think in terms of available numbers and who can control their inclusion in `c`.

Alice wants as many small numbers in `c` as possible, while Bob wants to prevent that.

Given that Alice can choose what to add to `c`, and Bob can choose what to remove from `a`, Bob can influence what options Alice has in future turns.

I need to find a way to simulate their optimal decisions.

Maybe I can think in terms of the frequency of each number in the array.

Let's consider the frequency of each number from 0 to n.

For each number i from 0 to n:

- If frequency is 0, it's not in a, so MEX could be i.

- If frequency is 1, Alice can pick it once, and Bob can't prevent it.

- If frequency is 2, Alice can pick one, and Bob can pick the other, or vice versa.

Wait, but Bob can only pick one per turn, and Alice picks one and adds to c.

I need a better way to model this.

Perhaps I should consider the number of times each number appears, and how many times Alice can include them in c.

Let's try to think in terms of available moves.

Total turns: n turns, Alice and Bob alternate, Alice starts.

Number of moves:

- Alice: ceil(n/2) moves

- Bob: floor(n/2) moves

Wait, no. In each turn, one element is removed from a, regardless of who plays.

Wait, no. Both players remove one element each turn, but Alice also adds to c.

Wait, the problem says:

- Alice's turn: pick from a, append to c, delete from a.

- Bob's turn: pick from a, delete from a.

So, per turn:

- One element is removed from a.

- Alice's turn: also adds to c.

So, total turns: n turns, alternating starting with Alice.

Total moves:

- Alice: ceil(n/2) turns

- Bob: floor(n/2) turns

But this depends on whether n is odd or even.

Wait, more precisely:

- If n is even: Alice has n/2 turns, Bob has n/2 turns.

- If n is odd: Alice has (n+1)/2 turns, Bob has (n-1)/2 turns.

Because Alice starts.

Okay, now, in each of Alice's turns, she picks an element to add to c.

Bob, in his turns, picks elements to remove from a, without adding to c.

So, Bob can choose to remove elements that Alice might want to add to c.

Alice wants to include as many small numbers in c as possible.

Bob wants to prevent that.

So, in terms of MEX, which is the smallest missing number in c, Alice wants to include 0,1,2,... up to as high as possible.

Bob wants to force Alice to miss some smaller numbers.

I need to find the smallest i such that, even with optimal play, Alice cannot include i in c.

Wait, perhaps I should think in terms of availability.

For each number i from 0 to n:

- Count how many times i appears in a.

- Alice needs to include i in c at least once to keep MEX higher than i.

- Bob can try to prevent Alice from including i in c.

Let's consider the frequency of i:

- If freq[i] >= 1, Alice can include it in c, unless Bob interferes.

- But Bob can only remove one instance per turn.

Wait, more carefully:

- Suppose freq[i] = k.

- Alice needs to include at least one in c.

- Bob can try to prevent this by removing as many as possible.

But Alice has some turns to pick elements, and Bob has some turns to remove elements.

I need to model this interaction.

Let me think in terms of the number of times Alice can pick elements she wants versus the number of times Bob can interfere.

Let's consider for each i from 0 to n:

- If freq[i] == 0: i is not in a, so MEX is i.

- If freq[i] == 1: Alice can pick it in her turn, adding it to c, provided Bob doesn't pick it.

- But Bob might pick it to prevent Alice from adding it.

Wait, Bob can pick it to remove it from a, but Alice can choose to pick it before Bob does.

This seems complicated.

Maybe I should think in terms of who has the majority of moves.

Total turns: n turns, Alice has ceil(n/2) turns, Bob has floor(n/2) turns.

Wait, perhaps in terms of the number of available choices for Alice.

Wait, maybe I should think in terms of the number of times each number appears and who can control their inclusion in c.

Let me consider the frequency of each number.

Suppose I sort the frequencies by the number i.

I need to ensure that for each i, Alice can include it in c at least once.

Bob will try to prevent that.

So, for each i, freq[i] is the number of copies available in a.

Alice and Bob take turns removing elements.

Alice can choose to add to c or not, but she prefers to add to maximize MEX.

Wait, no, Alice always adds to c when she picks an element.

Bob just removes elements without adding to c.

Wait, more carefully:

- Alice's move: pick an element from a, add it to c, remove it from a.

- Bob's move: pick an element from a, remove it from a.

So, in terms of controlling what goes into c, Alice chooses what to add.

Bob can choose to remove elements that Alice might want to add.

But once Alice picks an element and adds it to c, it's in c.

Bob can't undo that.

So, for each i, the number of times i is in c depends on how many times Alice picks it.

Bob can reduce the number of times i is available for Alice to pick.

Let me formalize this.

Let freq[i] be the frequency of i in a.

Alice and Bob will play n turns.

In each turn:

- Alice picks an element, adds it to c, removes it from a.

- Bob picks an element, removes it from a.

So, in total, per turn, two elements are removed from a (one by Alice, one by Bob).

Wait, no.

Wait, each turn consists of one player picking one element.

Alice's turn:

- Pick one element from a, add to c, remove from a.

Bob's turn:

- Pick one element from a, remove from a.

So, per full turn (Alice and Bob), two elements are removed from a.

Unless n is odd, in which case Alice has one more turn.

Wait, more precisely:

- Total turns: n turns, alternating starting with Alice.

- So, number of Alice's turns: ceil(n/2)

- Number of Bob's turns: floor(n/2)

In each of Alice's turns, she picks one element to add to c and removes it from a.

In each of Bob's turns, he picks one element to remove from a.

So, in total, Alice adds ceil(n/2) elements to c.

But which elements she adds depends on her choices and Bob's interference.

I need to determine, with their optimal plays, what will be the MEX of c.

I need to find the smallest i such that, despite Alice's efforts, i is not in c.

Let me consider the frequency of each i.

For each i from 0 to n:

- If freq[i] == 0: i is not in a, so MEX is i.

- If freq[i] == 1: Alice can pick it in her turn, but Bob might pick it in his turn.

Wait, but Bob picks after Alice.

Wait, turns alternate, Alice first.

So, the sequence of picks depends on the order of turns.

This seems too involved.

Maybe I can think in terms of the number of times Alice can pick a particular i before it's removed by Bob.

Wait, perhaps in terms of the number of times Alice can pick i before it's all removed.

Let me consider that.

For each i:

- freq[i] is the number of copies in a.

- Alice and Bob take turns picking elements.

- Alice picks first.

- Alice can choose to pick i and add it to c.

- Bob can choose to pick i and remove it from a.

I need to find, for each i, whether Alice can manage to include at least one i in c.

If she can, then i is in c, and MEX is higher.

If she can't, then i is not in c, and MEX is i.

So, for each i, I need to determine if Alice can include at least one i in c, despite Bob's attempts to remove it.

Let's model this.

Let's consider the picks in order.

Alice picks first, then Bob, and so on.

For each i:

- freq[i] is the number of copies available initially.

- Each time Alice picks i, she adds it to c.

- Each time Bob picks i, it's removed from a.

- Alice wants to maximize the number of i's in c.

- Bob wants to minimize the number of i's in c.

For Alice to get at least one i into c, she needs to pick it before all i's are removed by Bob.

Let's think in terms of the number of times i is picked by Alice and Bob.

Let’s define:

- A_i: number of times Alice picks i.

- B_i: number of times Bob picks i.

Then, A_i + B_i <= freq[i]

Alice wants A_i >= 1.

Bob wants A_i == 0.

Given that Alice and Bob play optimally.

I need to find, for each i, whether A_i >=1 is possible.

Wait, but their picks are interleaved.

This seems complex.

Maybe I can think in terms of the game being a race to pick i.

Since Alice picks first, she has the first chance to pick i.

If freq[i] >=1, Alice can pick it in her turn and add it to c.

Bob can't prevent it because he picks after Alice.

Wait, but if freq[i] ==1, and Alice doesn't pick it, Bob can pick it in his turn, removing it from a.

So, if Alice doesn't pick i when it's available, Bob can remove it.

Hence, for freq[i] ==1:

- If Alice picks it, it goes to c.

- If Alice doesn't pick it, Bob can pick it and remove it from a.

Hence, for freq[i] ==1, Alice must pick it in her turn to include it in c.

If freq[i] >=2, Alice can pick one, and even if Bob picks one, there's still one left, so Alice can pick it again in her next turn.

Wait, no.

If freq[i] ==2:

- Alice picks one, adds to c.

- Bob picks one, removes it.

- Now, no more i's left.

So, Alice has included one i in c.

Wait, but Bob can pick the other i, removing it.

But Alice has already picked one and added it to c.

So, in this case, Alice has included one i in c.

Hence, for freq[i] >=1, Alice can always include at least one i in c, provided she picks it before Bob picks all the remaining i's.

Wait, more carefully:

- For freq[i] ==1:

- Alice can pick it in her turn and add to c.

- If Alice doesn't pick it, Bob can pick it and remove it from a, so it doesn't go to c.

Hence, for freq[i] ==1, Alice can choose to include it in c or not.

- For freq[i] >=2:

- Alice can pick one and add to c.

- Bob can pick one and remove it.

- But since freq[i] >=2, there's at least one left for Alice to pick again.

Wait, no.

If freq[i] ==2:

- Alice picks one, adds to c.

- Bob picks one, removes it.

- Now, no more i's left.

Hence, Alice has included one i in c.

Similarly, for freq[i] >=3:

- Alice picks one, adds to c.

- Bob picks one, removes it.

- Still one left.

- Alice picks the remaining one, adds to c.

Hence, Alice can include one or more i's in c, depending on the frequency.

Wait, but Bob can try to minimize the number of i's in c.

In the case of freq[i] >=2, Alice can include at least one i in c, regardless of Bob's actions.

Because even if Bob picks one, Alice can pick one and add it to c.

Hence, for freq[i] >=1, Alice can always include at least one i in c, provided she plays optimally.

Wait, no.

Wait, for freq[i] ==1:

- Alice can choose to pick it and include it in c.

- Or, she can choose not to pick it, in which case Bob can pick it and remove it.

Hence, for freq[i] ==1, Alice can choose whether i is in c or not.

But she wants to maximize MEX, so she wants to include as many small i's as possible.

Wait, but Bob wants to minimize MEX, so he wants to prevent Alice from including some small i's.

Hence, Bob will try to force Alice to miss some small i's.

Wait, perhaps I need to consider the overall game strategy.

Let me try to think differently.

Let's consider that Alice wants to include as many small numbers as possible in c, in order to maximize MEX.

Bob wants to prevent that, to minimize MEX.

Hence, Bob will try to remove elements that Alice wants to include in c.

But since Alice picks first, she has some advantage.

Let me consider the following approach:

- Sort the array a.

- Simulate the game where Alice always picks the smallest available number to include in c, and Bob tries to prevent that.

But this might be too simplistic.

Alternatively, think in terms of available numbers and their frequencies.

Let me consider that for each number i from 0 to n:

- If freq[i] >=1, Alice can include it in c, unless Bob can prevent it.

But from earlier reasoning, for freq[i] >=1, Alice can always include it in c by picking it in her turn before Bob picks it.

Hence, Alice can include all i's with freq[i] >=1 in c.

Wait, but that can't be right, because in the example:

4

0 0 1 1

MEX is 2, meaning 0 and 1 are in c, which matches freq[0]=2 and freq[1]=2.

Another example:

4

0 1 2 3

MEX is 1, meaning only 0 is in c.

Wait, in this case, MEX is 1, meaning 0 is in c, but 1 is not.

Wait, but according to my earlier reasoning, if freq[1]=1, Alice can include it in c.

But in this case, MEX is 1, meaning 1 is not in c.

Hence, my earlier reasoning is flawed.

Hence, I need a better strategy.

Let me consider that Alice can include in c all numbers i with freq[i] >=2, and can choose to include numbers with freq[i]==1.

Bob can prevent Alice from including some numbers with freq[i]==1.

Hence, the MEX will be the smallest i such that freq[i]==1 and Bob can force Alice not to include it in c.

Wait, perhaps more precisely:

- For freq[i] >=2, Alice can always include at least one in c.

- For freq[i] ==1, Alice can choose to include it or not.

- Bob can force Alice not to include some freq[i]==1 by picking them.

Hence, the MEX will be the smallest i such that freq[i]==0 or (freq[i]==1 and Bob can pick it before Alice does).

But since Alice picks first, she can choose to pick freq[i]==1 to include in c.

Hence, perhaps MEX is the smallest i with freq[i]==0.

But in the first example:

4

0 0 1 1

freq[0]=2, freq[1]=2, freq[2]=0, freq[3]=0

MEX is 2, which matches.

In the second example:

4

0 1 2 3

freq[0]=1, freq[1]=1, freq[2]=1, freq[3]=1

MEX is 1, meaning 0 is in c, 1 is not.

Wait, but according to my hypothesis, MEX should be the smallest i with freq[i]==0, which is 4.

But in the example, MEX is 1.

Hence, my hypothesis is incorrect.

I need to think differently.

Let me consider the number of available turns Alice has to pick elements.

Total turns: n turns, Alice has ceil(n/2) turns.

In each of Alice's turns, she picks one element to add to c.

Hence, she can include up to ceil(n/2) elements in c.

But she wants to include as many small numbers as possible.

Bob wants to prevent that.

Hence, Bob will try to remove elements that Alice wants to include.

Wait, perhaps I can think in terms of the number of times Alice can pick elements before Bob removes them.

But this seems too vague.

Let me consider the frequency of each number and see how many times Alice can include them.

Let me try to think in terms of the number of times Alice can pick a particular number before Bob removes all copies.

For a number i:

- freq[i] copies available.

- Alice and Bob take turns picking elements.

- Alice picks first.

- Each time Alice picks i, she includes it in c.

- Each time Bob picks i, it's removed from a.

I need to find if Alice can include at least one i in c.

Let’s model this as a game where Alice and Bob take turns picking elements, and I need to see if Alice can pick i at least once before all i's are removed.

For freq[i] >=1:

- If freq[i] is odd, Alice can pick one and include it in c, even if Bob picks the rest.

- If freq[i] is even, Bob can pick the last one, preventing Alice from picking it.

Wait, no.

Wait, for freq[i] >=1:

- If freq[i] is odd, Alice can pick one and include it in c, because she picks first.

- If freq[i] is even, Bob can pick the last one, preventing Alice from picking it.

Hence, for freq[i] odd, Alice can include it in c.

For freq[i] even, Bob can prevent Alice from including it in c.

Hence, for freq[i] >=1:

- If freq[i] is odd, Alice can include i in c.

- If freq[i] is even, Bob can prevent Alice from including i in c.

Wait, but in the first example:

4

0 0 1 1

freq[0]=2 (even), freq[1]=2 (even)

Hence, Bob can prevent Alice from including 0 and 1 in c.

But in the example, c=[0,1], MEX=2.

Wait, that contradicts.

Hence, my assumption is wrong.

Wait, perhaps I need to consider that Alice has more turns if n is odd.

Wait, in the first example, n=4, which is even.

Hence, Alice has 2 turns, Bob has 2 turns.

freq[0]=2, freq[1]=2

Possible game:

- Alice picks 0, c=[0], a=[0,1,1]

- Bob picks 0, a=[1,1]

- Alice picks 1, c=[0,1], a=[1]

- Bob picks 1, a=[]

Hence, c=[0,1], MEX=2.

Another possible game:

- Alice picks 1, c=[1], a=[0,0,1]

- Bob picks 0, a=[0,1]

- Alice picks 0, c=[1,0], a=[1]

- Bob picks 1, a=[]

Again, c=[1,0], MEX=2.

So, in both cases, MEX=2.

Hence, even though freq[i] is even, Alice can still include both 0 and 1 in c.

Hence, my previous assumption is incorrect.

Let me try again.

Perhaps I need to consider the total number of available turns and the frequencies.

Wait, perhaps I can think in terms of the number of times Alice can pick elements before Bob removes them.

But it's getting too convoluted.

Let me look for a different approach.

I recall that MEX is about the smallest missing number in c.

Hence, to maximize MEX, Alice wants to include as many small numbers as possible in c.

Bob wants to minimize MEX, so he wants to prevent Alice from including some small numbers.

Hence, the MEX will be the smallest number that Alice cannot include in c despite her best efforts.

So, for each i from 0 to n:

- If Alice can include i in c, then MEX is greater than i.

- If Alice cannot include i in c, then MEX is i.

Hence, I need to find the smallest i such that Alice cannot include i in c.

From earlier analysis, it seems that if freq[i] >=1, Alice can include it in c.

But the examples suggest otherwise.

Wait, in the second example:

4

0 1 2 3

freq[0]=1, freq[1]=1, freq[2]=1, freq[3]=1

Possible game:

- Alice picks 0, c=[0], a=[1,2,3]

- Bob picks 1, a=[2,3]

- Alice picks 2, c=[0,2], a=[3]

- Bob picks 3, a=[]

Final c: [0,2], MEX=1

Hence, MEX is 