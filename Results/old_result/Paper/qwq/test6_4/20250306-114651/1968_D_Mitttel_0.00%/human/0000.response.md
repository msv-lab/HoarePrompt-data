Alright, I've got this problem to solve. It's about determining who wins a game between Bodya and Sasha based on their scores after a certain number of turns. They start at different positions in a permutation, and each turn they can choose to stay or move to another position based on the permutation. The goal is to maximize their scores by collecting points from the positions they land on.

First, I need to understand the problem completely. We have a permutation p of length n, and an array a of the same length, where a[i] represents the points gained when landing on position i. Both players start at positions PB and PS respectively, and they play k turns simultaneously.

Each turn, both players decide independently whether to stay or move to the position specified by the permutation p. After k turns, the one with the higher total points wins. If they have the same points, it's a draw.

My task is to determine the winner or if it's a draw, assuming both players play optimally to maximize their scores.

Let me think about how to approach this.

First, since both players make decisions simultaneously and independently, their choices don't directly affect each other. So, I can consider each player's path separately and compute their maximum possible scores.

The key is to find, for each player, the optimal sequence of moves (stay or move) over k turns to maximize their total points.

Given that n can be up to 2e5 and k up to 1e9, I need an efficient algorithm, probably O(n log n) or better per test case, considering t can be up to 1e4.

But t=1e4 and n=2e5, with sum of n over all test cases up to 2e5, so overall time should be O(2e5 * log(2e5)) or similar.

Now, thinking about how to model the movement.

Each player is on a position, and each turn they can choose to stay or move to p[current_position].

This seems like a graph where positions are nodes, and there's an edge from x to p[x].

Since p is a permutation, the graph will consist of disjoint cycles.

For example, if p = [2, 1, 4, 3], then there are two cycles: 1->2->1 and 3->4->3.

In such a structure, if a player is on a cycle, they will keep looping within that cycle.

Given that, perhaps I can analyze the cycles and determine the optimal path for each player within their respective cycles.

Wait, but players can choose to stay or move each turn, so it's not just following the cycle.

They have a choice each turn: stay or move.

So, it's more like they can choose to stay put and collect a[x] again, or move to p[x] and collect a[p[x]].

But, since a[x] can be any positive integer, including large values, they might have different incentives to stay or move based on the a values.

I need to find, for each player, the sequence of choices (stay or move) over k turns that maximizes their total a[x] collected.

Given that k can be up to 1e9, it's impossible to simulate each turn individually.

Hence, I need to find a way to compute the maximum possible score for each player in an optimized way.

Let me consider the structure of the permutation.

As p is a permutation, its graph is a collection of cycles.

Each player starts at a certain position, which is part of exactly one cycle.

I need to consider the cycle that each player is in and how their choices interact with the cycle.

But, since they can choose to stay or move each turn, it's not just following the cycle.

They can choose to stay and collect a[x] multiple times, or move to p[x], and so on.

Wait, but if they stay, they collect a[x], and if they move, they go to p[x] and collect a[p[x]], but they choose each turn.

So, it's like each turn they can decide to collect a[x] and stay, or collect a[p[x]] and move.

Wait, no.

Actually, the problem says:

- First, their score increases by a[x], where x is their current position.

- Then, they choose to either stay at x or move to p[x].

So, each turn, they first collect a[x], then decide to stay or move.

Hence, the next turn, they are either still at x (if they chose to stay) or at p[x] (if they chose to move).

Given that, over k turns, each player has a sequence of positions, and at each turn, they collect a[x] of the current position.

I need to maximize the sum of a[x] over k turns for each player.

Given that n can be up to 2e5 and k up to 1e9, I need a way to compute this efficiently.

Let me consider modeling this as a graph where each position is a node, and there are two outgoing edges: one for staying (loop edge) and one for moving (edge to p[x]).

But with n=2e5, building such a graph explicitly is not feasible.

Alternatively, since the graph has a specific structure due to the permutation, perhaps I can exploit that.

Let me think differently.

For each player, starting at position x, each turn they can choose to stay at x and collect a[x], or move to p[x] and collect a[p[x]] in the next turn.

Wait, no.

Actually, each turn, they are at position x, collect a[x], then choose to stay at x or move to p[x].

So, in the next turn, if they stayed, they are still at x and collect a[x] again, or if they moved, they are now at p[x] and will collect a[p[x]] in the next turn.

Hence, for each player, the sequence of positions over k turns is determined by their choices to stay or move.

Given that, I need to find the sequence of positions that maximizes the sum of a[x] over k turns.

This sounds like a dynamic programming problem.

Let me consider DP for one player.

Define DP[x][t] as the maximum score at position x after t turns.

Then, DP[x][t] = a[x] + max(DP[x][t-1], DP[p[x]][t-1])

Because at each turn, after collecting a[x], they choose to stay at x or move to p[x].

But with k up to 1e9, this is not feasible to compute directly.

I need a smarter way.

Let me consider that for each player, the positions they can be in are limited by the cycle they are in.

Since p is a permutation, the graph is a set of cycles, and within each cycle, the positions repeat in a cycle.

Hence, for each player, their possible positions over time are determined by the cycle they are in.

Wait, but they can choose to stay or move each turn, so it's not just following the cycle.

However, the cycle structure imposes some periodicity that I can exploit.

Perhaps I can find the optimal path within the cycle for each player.

Let me try to model this.

First, find the cycle that each player is in.

For example, starting at x, follow p[x], p[p[x]], etc., until returning to x.

Letâ€™s say the cycle length is L.

Then, within the cycle, the positions repeat every L steps if they keep moving.

However, they can choose to stay put in any turn, which breaks the pure cyclic movement.

Hence, I need to consider all possible combinations of staying and moving within the cycle.

This seems complicated.

Let me think differently.

Suppose I fix a player and try to maximize their score over k turns.

At each turn, they have a choice: stay and collect a[x] again, or move to p[x] and collect a[p[x]] in the next turn.

This resembles choosing between collecting a[x] repeatedly or traversing the cycle and collecting a[p[x]], a[p[p[x]]], etc.

I need to maximize the sum of a[x] over k turns.

I recall that in such problems, the optimal strategy often involves identifying the best cycle to follow and potentially staying put to collect high a[x] values.

Wait, perhaps I can compute the maximum possible score by considering the best combination of staying and moving.

Let me consider that for a player starting at x, they can choose to stay for some turns, collecting a[x] multiple times, or move to p[x] and start collecting a[p[x]], and so on.

But with k up to 1e9, I need a way to compute this efficiently.

Perhaps I can precompute the maximum possible score for each position, considering the cycle structure.

Wait, maybe I can model this as a Markov Decision Process, where each state is a position, and actions are "stay" or "move".

But again, with n up to 2e5, this seems inefficient.

Let me consider that for each player, the optimal strategy would be to stay at the position with the highest a[x] in their cycle, but they might need to move through other positions to reach it.

However, since they can choose to stay or move each turn, they can choose to stay at any position they've been to before.

But they have to make decisions simultaneously, and they have to make exactly k moves.

This seems tricky.

Let me try to think in terms of graphs.

Each position x has two options:

1. Stay at x, collect a[x], and remain at x for the next turn.

2. Move to p[x], collect a[x], and then be at p[x] for the next turn.

Hence, for each position x, there are two edges:

- Stay: x -> x with cost a[x]

- Move: x -> p[x] with cost a[x]

Wait, actually, the cost is collected when arriving at the position, before choosing to stay or move.

Wait, no, according to the problem:

- First, collect a[x]

- Then, choose to stay or move.

Hence, it's more like:

- At the start of the turn, you are at x

- Collect a[x]

- Choose to stay at x or move to p[x]

- The next turn, you are at the chosen position.

Hence, in graph terms:

- From x, you can choose to go to x (stay) or to p[x] (move)

- Each choice has a cost of a[x], since that's collected before choosing.

Wait, but actually, the cost is collected at the current position before choosing where to go.

Hence, the edge cost is a[x], and the choice determines the next position.

Hence, in graph terms:

- From x, there are two outgoing edges:

- x -> x with cost a[x] (stay)

- x -> p[x] with cost a[x] (move)

Hence, it's like a graph where each node has two outgoing edges, both with cost a[x].

But this seems problematic because the cost is collected when arriving at the position, not when leaving.

Wait, perhaps I need to model it differently.

Let me think in terms of dynamic programming.

Define DP[x][t] as the maximum score at position x after t turns.

Then, DP[x][t] = a[x] + max(DP[x][t-1], DP[p[x]][t-1])

Because at turn t, they are at x, collect a[x], then choose to stay at x or move to p[x] for the next turn.

Hence, DP[x][t] = a[x] + max(DP[x][t-1], DP[p[x]][t-1])

But with k up to 1e9, this is not feasible to compute directly.

I need a better way to compute this.

Let me consider that for each player, the sequence of positions they can be in is determined by their choices to stay or move.

Given that, perhaps I can find a way to represent the possible sequences in terms of cycles or linear paths.

Wait, but since they can choose to stay or move each turn, their path is not constrained to follow the permutation cycle; they can choose to stay put for any number of turns.

This complicates things.

Let me consider that if a player chooses to stay at x for all k turns, their total score would be k * a[x].

Alternatively, if they choose to move every turn, their total score would be the sum of a[x], a[p[x]], a[p[p[x]]], and so on, up to k steps along the permutation cycle.

But they can choose any combination of staying and moving.

Hence, their path can be any sequence of positions where each step is either staying at the current position or moving to the next position in the permutation.

I need to maximize the sum of a[x] over k turns.

Let me consider that in each turn, the player can choose to stay and collect a[x], or move to p[x] and collect a[p[x]] in the next turn.

This seems similar to choosing between collecting a[x] repeatedly or traversing the permutation cycle and collecting a[p[x]], a[p[p[x]]], etc.

Hence, the optimal strategy would be to stay at the position with the highest a[x] possible.

But since they can choose to move to p[x] and then choose to stay there, they can effectively choose any position in their cycle to stay at.

Wait, but they have to make exactly k moves, and each move is a choice to stay or move.

Hence, for each player, the optimal strategy is to find the position in their cycle with the highest a[x], and stay there for all k turns.

But, they might need to move through other positions to reach that position.

Hence, the optimal strategy is to reach the position with the maximum a[x] in their cycle as quickly as possible, and then stay there for the remaining turns.

Wait, but they can choose to stay or move each turn independently, so they can choose to stay at any position at any time.

Hence, they can choose to stay at the best position in their cycle from the first turn, if it's their starting position, or reach it in a certain number of moves and then stay there.

Wait, no, they can choose to stay or move each turn, but moving means going to p[x], not necessarily towards the best position.

Wait, p is a permutation, so the graph is a set of cycles.

Hence, by moving, they traverse the cycle.

But they can choose to stay at any position in the cycle by choosing to stay for some turns.

Hence, the optimal strategy is to find the position in the cycle with the maximum a[x], and then stay there for as many turns as possible.

To maximize the score, they should spend as many of the k turns as possible collecting the highest possible a[x].

Hence, they should reach the position with the maximum a[x] in their cycle as quickly as possible, and then stay there for the remaining turns.

Wait, but they can choose to stay or move each turn independently, so they don't necessarily need to reach it quickly; they can choose to stay at any position in the cycle at any time.

Wait, but if they choose to stay at a position, they collect a[x] and remain there for the next turn.

If they choose to move, they collect a[x] and then move to p[x] for the next turn.

Hence, they can choose to stay at any position in the cycle in any turn, but they have to follow the sequence of moves they choose.

It's a bit confusing.

Let me try to formalize it.

Letâ€™s define the sequence of positions for a player over k turns.

Let x0 be the starting position.

At turn 1:

- Collect a[x0]

- Choose to stay at x0 or move to p[x0]

- End up at x1 = x0 (if stay) or p[x0] (if move)

At turn 2:

- Collect a[x1]

- Choose to stay at x1 or move to p[x1]

- End up at x2 = x1 (if stay) or p[x1] (if move)

And so on, up to turn k.

The goal is to choose, for each turn, whether to stay or move, to maximize the sum of a[x] over k turns.

Given that, I need to find the sequence of choices that maximizes the sum.

Given the structure of the permutation, the positions repeat in cycles.

Hence, the possible sequences are constrained by the cycle structure, but with the option to stay at any position in the cycle in any turn.

I need to find a way to compute the maximum possible sum for each player.

Let me consider that for each player, the positions they can be in over k turns are constrained by their choices.

But with k up to 1e9, I need a way to compute this efficiently.

Perhaps I can find, for each cycle, the maximum a[x] in that cycle, and then have the player stay at that position for as many turns as possible.

But they might need to spend some turns moving to that position.

Wait, but since they can choose to stay or move each turn independently, they can choose to stay at the best position in the cycle from any turn.

Hence, the optimal strategy is to stay at the position with the maximum a[x] in their cycle for all k turns.

Wait, but they might not start at that position, and they need to reach it by moving.

But since they can choose to stay or move each turn, they can choose to move to p[x] in one turn, and then choose to stay at p[x] for the remaining turns.

Hence, the optimal strategy is:

- Choose to move to the position with the maximum a[x] in their cycle as quickly as possible.

- Then, stay at that position for the remaining turns.

But since they can choose to stay or move each turn independently, they can choose to move directly to the best position and then stay there.

Wait, no, not necessarily, because moving to p[x] might not be the best position.

Hence, perhaps the optimal strategy is to identify the position in their cycle with the maximum a[x], and then choose to move to that position and stay there for all remaining turns.

But they might need to move through several positions to reach it.

Wait, but since they can choose to stay or move each turn independently, they can choose to move to p[x], then choose to stay at p[x], or move again to p[p[x]], and so on.

Hence, they can reach any position in their cycle within a certain number of moves.

But to maximize the sum, they should spend as many turns as possible at the position with the highest a[x].

Hence, the optimal strategy is to reach the position with the maximum a[x] in their cycle and stay there for the remaining turns.

The question is, how many turns does it take to reach that position?

Well, since they can choose to move or stay each turn independently, they can choose to move directly to the best position in one move and then stay there.

Wait, but moving to p[x] might not be the best position; it could be several steps away.

Wait, no, they can choose to move to p[x], and then from p[x] choose to stay or move again, and so on.

Hence, they can reach any position in their cycle in a number of moves equal to their distance in the cycle.

But to maximize the sum, they should minimize the number of turns spent moving to the best position.

Hence, the optimal strategy is to reach the best position in their cycle as quickly as possible and then stay there.

Given that, I can precompute for each player the position with the maximum a[x] in their cycle, and then compute the minimum number of moves required to reach that position from their starting position.

Then, in the remaining turns, they can stay at that position and collect a[x] repeatedly.

Hence, the total score would be:

- Sum of a[x] for each turn spent moving to the best position.

- Plus, (k - number of moves to reach the best position) * a[best_position]

Wait, but actually, while moving to the best position, they are collecting a[x] at each step.

Hence, I need to compute the sum of a[x] along the path from the starting position to the best position, and then add the a[best_position] for the remaining turns.

But this seems similar to the DP approach, which is too slow for large k.

Is there a better way?

Let me consider that in the cycle, the positions repeat every cycle length.

Hence, I can model the movement within the cycle and find the optimal path.

But this still seems complicated.

Wait, perhaps I can model the movement as a graph where each node has two outgoing edges: stay and move.

Then, find the path of length k with the maximum sum of a[x].

But with n up to 2e5 and k up to 1e9, this is not feasible.

I need a smarter approach.

Let me consider that for each player, their possible positions over k turns can be represented as a sequence of choices: stay or move.

This sequence can be modeled as a binary sequence of length k, where 0 means stay and 1 means move.

Hence, there are 2^k possible sequences, which is too large.

Hence, I need a way to compute the maximum sum efficiently.

Wait, perhaps I can model this as a linear recurrence.

Given that DP[x][t] = a[x] + max(DP[x][t-1], DP[p[x]][t-1])

This is similar to a linear recurrence, but with k up to 1e9, I need a way to compute it in logarithmic time.

I recall that such recurrences can be solved using matrix exponentiation.

Yes, perhaps I can represent this recurrence using matrix exponentiation.

Let me try to model it.

For each position x, define a vector V_x[t] = [DP[x][t], DP[p[x]][t]]

Then, the recurrence is:

DP[x][t] = a[x] + max(DP[x][t-1], DP[p[x]][t-1])

DP[p[x]][t] = a[p[x]] + max(DP[p[x]][t-1], DP[p[p[x]]][t-1])

This seems like a max-plus system, which is related to tropical semirings.

But matrix exponentiation in the max-plus algebra is possible using the concept of the Kleene star or other methods.

However, implementing this for n up to 2e5 and k up to 1e9 seems too time-consuming, especially since t can be up to 1e4.

I need a better approach.

Let me consider that in the optimal strategy, the player will eventually reach the position with the maximum a[x] in their cycle and stay there.

Hence, the total score would be the sum of a[x] along the path to the best position, plus the a[best_position] multiplied by the remaining turns.

But I need to compute this efficiently.

Let me try to formalize this.

For each player:

1. Find the cycle that contains their starting position.

2. Find the position x_max in the cycle with the maximum a[x].

3. Compute the minimal number of moves required to reach x_max from the starting position.

4. Compute the sum of a[x] along the path from the starting position to x_max.

5. Compute the remaining turns after reaching x_max.

6. Add the a[x_max] multiplied by the remaining turns.

This seems plausible.

Hence, for each player, I need to:

- Find the cycle containing their starting position.

- Find the position with the maximum a[x] in that cycle.

- Find the minimal number of moves to reach that position from the starting position.

- Compute the sum along the path.

- Compute the remaining turns and add a[x_max] multiplied by those turns.

But I need to make sure that this is indeed the optimal strategy.

Wait, perhaps there are better strategies where the player oscillates between multiple positions to maximize the sum, but intuitively, staying at the best position for as many turns as possible seems optimal.

Assuming that's the case, I can proceed with this approach.

Hence, for each player, I need to:

- Find their cycle.

- Find x_max in the cycle.

- Find the minimal number of moves to reach x_max from their starting position.

- Compute the sum of a[x] along that path.

- Add (k - number of moves) * a[x_max]

This should give the maximum possible score for each player.

Then, compare the scores of Bodya and Sasha to determine the winner.

Now, I need to implement this efficiently.

Given that n can be up to 2e5 and t up to 1e4, with the sum of n over all test cases up to 2e5, I need an efficient way to find cycles and compute the required values.

First, I can find all the cycles in the permutation p.

To do this, I can perform a graph traversal (DFS or BFS) to identify the cycles.

Since p is a permutation, the graph is a collection of disjoint cycles.

I can assign each position to its cycle and find x_max for each cycle.

Then, for each player, I can find their cycle and x_max.

Next, for each player, I need to find the minimal number of moves to reach x_max from their starting position.

Given that they can choose to stay or move each turn, the minimal number of moves to reach x_max is the minimal number of moves required, considering that they can choose to stay in any position.

Wait, actually, since they can choose to move or stay each turn independently, they can choose to move directly to x_max in one move, if x_max is reachable from their current position by moving.

But, x_max might not be directly reachable by moving once; it might require several moves.

Hence, I need to find the distance from the starting position to x_max in the cycle