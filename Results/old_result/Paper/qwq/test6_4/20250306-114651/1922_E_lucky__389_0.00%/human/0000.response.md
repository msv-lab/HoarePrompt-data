Alright, I've got this problem to solve. Let's see what it's asking for. So, I need to find an array of integers, with length at most 200, such that the number of increasing subsequences in it is exactly equal to a given number X, where X can be up to 10^18. If it's not possible to create such an array, I should output -1. The array elements can be anywhere from -10^9 to 10^9.

First, I need to understand what an increasing subsequence is. From the problem statement, it's a sequence obtained by removing some elements from the array without changing the order of the remaining elements, and the remaining elements are strictly increasing. Also, even if two subsequences have the same values but are from different positions in the array, they are considered different.

So, for example, if I have an array like [1, 2, 1], the increasing subsequences are:

- Empty subsequence

- [1]

- [2]

- [1] (from the second position)

- [1,2]

- [1,1] (but this is not strictly increasing, so it should be excluded)

- [2,1] (not increasing)

So, only [1], [2], [1], and [1,2] are increasing subsequences. That makes a total of 4 increasing subsequences.

Wait, but according to the problem, if two subsequences have the same elements but from different positions, they are considered different. So in this case, there are two [1]'s, one from each position.

Wait, but in my earlier count, I have two [1]'s, but [1,1] is not strictly increasing, so it should be excluded.

So total increasing subsequences are:

- Empty

- [1] (first position)

- [1] (second position)

- [2]

- [1,2]

That's 5 in total.

But according to the problem, the empty subsequence is also considered increasing, so that should be included.

Wait, in the problem, it says "Note that an empty subsequence is also increasing." So, in my earlier count, I should have included the empty subsequence, making it 5 in total.

But in my earlier thought, I had 4, but actually, it should be 5, including the empty one.

Wait, let's recount for [1,2,1]:

- Empty

- [1] (first position)

- [1] (second position)

- [2]

- [1,2]

Total 5, which matches.

Okay, good.

Now, the task is, for a given X, find an array with at most 200 elements such that the number of increasing subsequences is exactly X.

I need to find such an array for each test case, given T test cases.

Constraints:

- T is up to 1000, which is manageable.

- X can be up to 10^18, which is a very large number, so I need an efficient way to construct the array.

Also, the array elements can be from -10^9 to 10^9, so a wide range.

I need to minimize the length of the array, but it's already constrained to be at most 200.

I need to think about how to construct such an array.

First, I need to understand how the number of increasing subsequences is calculated.

Let me think about the properties of increasing subsequences.

Given an array, each subsequence is a subset of the elements in order, and it's increasing if each element is strictly greater than the previous one in the subsequence.

Also, as per the problem, different positions make different subsequences even if values are the same.

So, it's about the positions, not just the values.

Wait, but in the count, it's based on the positions.

So, the total number of increasing subsequences, including the empty one, is X.

So, X can be from 2 to 10^18.

Wait, X starts from 2 because X is at least 2.

So, the minimal X is 2, which probably corresponds to an array with one element, since an array with zero elements would have only one subsequence, the empty one, but X starts from 2.

Wait, but an array with one element has:

- Empty subsequence

- The single element

So, total of 2 increasing subsequences.

Yes, that matches.

Similarly, an array with two elements:

- Empty

- First element

- Second element

- If they are in increasing order, [first, second]

So, up to 4 increasing subsequences.

If the second element is less than or equal to the first, then [first, second] is not increasing, so only 3 increasing subsequences.

So, for two elements:

- If a1 < a2, then 4 increasing subsequences: empty, a1, a2, [a1,a2]

- If a1 >= a2, then 3 increasing subsequences: empty, a1, a2

So, to maximize the number of increasing subsequences, I should have a1 < a2.

Similarly, for three elements, to maximize, I should have them strictly increasing, giving 8 increasing subsequences: empty, each single element, each pair, and the full trio.

Wait, for three strictly increasing elements, the increasing subsequences are:

- Empty

- Each single element: 3

- Each pair: 3

- The full trio: 1

Total: 1 + 3 + 3 + 1 = 8

Yes.

Similarly, for n elements strictly increasing, the number of increasing subsequences is 2^n (including the empty one).

Wait, but in the problem, X starts from 2, which corresponds to n=1.

For n=2, it's 4.

n=3, 8.

So, in general, for n strictly increasing elements, the number of increasing subsequences is 2^n.

But the problem allows for any array with at most 200 elements, not necessarily strictly increasing.

But if I can only use up to 200 elements, and X can be up to 10^18, which is much larger than 2^60 (which is about 10^18), but 2^60 is 1.1529215e+18, which is larger than 10^18.

Wait, 2^60 = 1,152,921,504,606,846,976, which is indeed larger than 10^18=1,000,000,000,000,000,000.

But 2^60 is about 1.153e+18, which is still less than 10^18.

Wait, no, 2^60 is approximately 1.153e+18, which is still less than 10^18.

Wait, no, 2^60 is approximately 1.1529215e+18, which is less than 10^18.

Wait, but 2^63 is 8.589934592e+18, which is larger than 10^18.

But the problem allows X up to 10^18, which is 1e18.

But 2^60 is about 1.153e18, which is larger than 1e18.

Wait, 2^60 is 1,152,921,504,606,846,976, which is larger than 1e18=1,000,000,000,000,000,000.

Wait, no, 1e18 is 1,000,000,000,000,000,000, and 2^60 is 1,152,921,504,606,846,976, which is indeed larger than 1e18.

Wait, but 2^60 is approximately 1.153e18, which is larger than 1e18.

Wait, but 2^60 is actually less than 1e18.

Wait, no, 2^60 is 1,152,921,504,606,846,976, which is larger than 1,000,000,000,000,000,000 (1e18).

Wait, no, 1e18 is 1,000,000,000,000,000,000, and 2^60 is 1,152,921,504,606,846,976, which is larger.

Wait, but 2^60 is indeed larger than 1e18.

Wait, no, 2^60 is approximately 1.153e18, which is larger than 1e18.

Wait, but 2^60 is actually 1,152,921,504,606,846,976, which is larger than 1,000,000,000,000,000,000.

Wait, but 2^60 is indeed larger than 1e18.

Wait, perhaps I need to double-check.

Wait, 2^60 is 1,152,921,504,606,846,976, which is larger than 1,000,000,000,000,000,000 (1e18).

So, with n=60, 2^n=2^60=1.153e18, which is larger than 1e18.

But the problem allows X up to 1e18, which is 1,000,000,000,000,000,000.

So, with n=60, I can represent X up to 2^60-1=1,152,921,504,606,846,975, which is larger than 1e18.

But the problem allows X up to 1e18, which is 1,000,000,000,000,000,000.

Wait, but 2^60 is approximately 1.153e18, which is larger than 1e18.

Wait, but 2^60 is 1,152,921,504,606,846,976, which is larger than 1e18.

Wait, but the problem allows X up to 1e18, which is 1,000,000,000,000,000,000.

Wait, but 2^60 is larger than that, so it's fine.

Wait, but in the problem, X can be up to 1e18, and 2^60 is larger than that, so I need to handle X up to 1e18.

But the array can have at most 200 elements, which can represent up to 2^200 increasing subsequences, which is way larger than 1e18.

So, in terms of representing X, it's manageable.

But I need to find a way to construct an array with at most 200 elements that has exactly X increasing subsequences.

I need to think about how to construct such an array.

First, I need to understand how the number of increasing subsequences can be calculated for a general array, not necessarily strictly increasing.

In the case where the array is strictly increasing, the number of increasing subsequences is 2^n, where n is the length of the array.

But in general, for any array, it's more complicated.

I need to find a way to construct an array where the number of increasing subsequences is exactly X.

I need to think about how to represent X in terms of the array.

One approach is to think in terms of binary representation.

Since 2^n represents the number of increasing subsequences for a strictly increasing array of length n, I can try to represent X in terms of sums of powers of 2.

Wait, but X is the total number of increasing subsequences, which includes the empty one.

So, if I have a strictly increasing array of length n, the number of increasing subsequences is 2^n.

But if I have parts of the array that are not strictly increasing, then some subsequences won't be increasing.

I need to find a way to combine different parts of the array to get exactly X increasing subsequences.

Wait, maybe I can think of the array as consisting of several strictly increasing segments, and the total number of increasing subsequences is the product of the number of increasing subsequences in each segment.

Wait, but I'm not sure if that's correct.

Wait, actually, if the array is divided into segments where each segment is strictly increasing, and there are no increasing subsequences that span across multiple segments, then maybe the total number of increasing subsequences is the product of the number of increasing subsequences in each segment.

But I need to think carefully.

Wait, for example, take an array [1,2,3,5,4].

Here, [1,2,3,5] is strictly increasing, and [4] is单独的一个元素.

The increasing subsequences are:

- Empty

- [1]

- [2]

- [3]

- [5]

- [4]

- [1,2]

- [1,3]

- [1,5]

- [2,3]

- [2,5]

- [3,5]

- [1,2,3]

- [1,2,5]

- [1,3,5]

- [2,3,5]

- [1,2,3,5]

- [1,2,4]

- [1,3,4]

- [1,5,4] (not increasing)

- [2,5,4] (not increasing)

- [2,3,4]

So, some increasing subsequences span across different segments.

This seems complicated.

Maybe I need a different approach.

Another idea: try to construct the array in such a way that the number of increasing subsequences can be calculated easily.

Perhaps by repeating elements in a specific pattern.

Wait, perhaps I can use the fact that adding a new element to the array can potentially double the number of increasing subsequences, if the new element is larger than all previous elements.

Wait, but that's only if the array is strictly increasing.

In general, adding a new element that is larger than all previous elements will double the number of increasing subsequences, because for each existing increasing subsequence, I can choose to include or exclude the new element.

Wait, but actually, it's not exactly doubling.

Wait, for example, if I have an array of length n with strictly increasing elements, and I add a new element that is larger than all of them, then the number of increasing subsequences becomes 2^{n+1}.

Because for each of the 2^n existing subsequences, I can choose to include or exclude the new element, and since it's larger than all, including it will still keep the subsequence increasing.

So, in that case, the number of increasing subsequences doubles.

Wait, but 2^{n+1} is double 2^n.

Yes, so adding a larger element doubles the number of increasing subsequences.

So, starting from an empty array, adding a first element gives 2 subsequences (empty and the element itself).

Adding a second element larger than the first gives 4 subsequences, and so on.

So, to represent X as the number of increasing subsequences, I can think of X as a sum of powers of 2.

Wait, but X includes the empty subsequence, so it's actually 2^n for a strictly increasing array of length n.

Wait, but in general, for a non-strictly increasing array, it's more complicated.

Wait, perhaps I can think in terms of binary representation of X.

If X is a power of 2, say X=2^n, then I can create a strictly increasing array of length n.

If X is not a power of 2, then I need to find a combination of such segments.

Wait, perhaps I can represent X as a sum of powers of 2, and each power of 2 corresponds to a strictly increasing segment.

But I need to ensure that there are no increasing subsequences that span across multiple segments.

How can I achieve that?

One way is to make sure that the elements in later segments are smaller than or equal to the previous segments, so that no increasing subsequence can span across them.

Wait, but that would prevent any subsequence from spanning across segments.

Wait, for example, if I have two segments: the first is strictly increasing, and the second is strictly increasing but all elements are smaller than the first segment's minimum.

Then, no increasing subsequence can span across both segments.

In this case, the total number of increasing subsequences would be the product of the number of increasing subsequences in each segment.

Wait, but actually, since the second segment is smaller than the first, any subsequence that includes elements from both segments cannot be increasing, because the elements from the second segment are smaller than the first.

So, in this case, the total number of increasing subsequences is the product of the number of increasing subsequences in each segment.

Wait, is that true?

Let's see.

Suppose I have two segments:

- First segment: [1,2,3], which has 2^3=8 increasing subsequences.

- Second segment: [0,1], which has 2^2=4 increasing subsequences.

Total increasing subsequences:

- Subsequences entirely within the first segment: 8

- Subsequences entirely within the second segment: 4

- Subsequences spanning both segments: none, because any subsequence that includes elements from both would not be increasing.

So, total increasing subsequences: 8 * 4 = 32.

Wait, but 8 * 4 = 32, but 8 + 4 = 12, which is less than 32.

Wait, but in reality, the total number of increasing subsequences is 8 + 4 = 12, since no subsequences span both segments.

But according to the multiplication, it's 32, which is not matching.

Wait, perhaps my assumption is wrong.

Wait, perhaps when segments are separated in such a way that no increasing subsequence can span across them, the total number of increasing subsequences is the product of the number of increasing subsequences in each segment.

But in my earlier count, it's 8 + 4 = 12, not 32.

Wait, perhaps I'm misunderstanding.

Wait, maybe it's the sum, not the product.

Wait, in my example, it's 8 + 4 = 12.

But according to the product, it's 8 * 4 = 32, which doesn't match.

So, perhaps it's the sum.

But in reality, since no subsequences span both segments, it should be the sum of the increasing subsequences in each segment, minus 1 for the empty subsequence, because the empty subsequence is counted in both.

Wait, no.

Wait, the empty subsequence is only counted once.

Wait, in the first segment, there are 8 subsequences, including the empty one.

In the second segment, there are 4 subsequences, including the empty one.

When combining two segments with no overlapping increasing subsequences, the total number of increasing subsequences should be (8 - 1) + (4 - 1) + 1 = 8 + 4 - 1 = 11.

Wait, but actually, in my earlier count, I had 8 + 4 = 12, which includes the empty subsequence only once.

Wait, perhaps I need to think differently.

Wait, perhaps the total number of increasing subsequences is the product of the number of increasing subsequences in each segment.

But in my earlier example, that doesn't hold.

Wait, maybe it's the product if the segments are independent, meaning no overlapping subsequences.

In my earlier example, since no increasing subsequence can span both segments, the total number should indeed be the product of the number of increasing subsequences in each segment.

But according to my count, it's 8 + 4 = 12, not 32.

Wait, perhaps I need to think differently.

Wait, perhaps the total number of increasing subsequences is the product of (number of increasing subsequences in each segment -1) +1.

Wait, that is, if I have segments A and B, with a and b increasing subsequences respectively, then total increasing subsequences are (a -1)*(b -1) +1.

Wait, in my earlier example:

a = 8, b = 4

Then (8 -1)*(4 -1) +1 = 7*3 +1 = 22, which is still not matching my earlier count of 12.

Wait, perhaps this approach is incorrect.

Maybe I need to consider that when segments are separated and no increasing subsequence can span across them, the total number of increasing subsequences is simply the product of the number of increasing subsequences in each segment.

So, in my earlier example, it should be 8 * 4 = 32.

But according to my manual count, it's only 8 + 4 = 12.

Wait, perhaps I'm missing some subsequences.

Wait, perhaps I need to consider that in the combined array, any increasing subsequence can be formed by choosing any subsequence from the first segment and any subsequence from the second segment, and concatenating them.

But only if the last element of the first subsequence is smaller than the first element of the second subsequence.

Wait, but in my earlier setup, the second segment has elements smaller than the first segment, so no such concatenation is possible.

Hence, the total number of increasing subsequences is indeed the sum of the increasing subsequences in each segment.

So, in that case, it's 8 + 4 = 12.

But according to the product rule, it's 32, which doesn't match.

So, perhaps the total number of increasing subsequences is not the product, but the sum.

Wait, but I need to verify this.

Let's consider another example.

Take two segments:

- First segment: [1,2], which has 4 increasing subsequences: empty, [1], [2], [1,2]

- Second segment: [0], which has 2 increasing subsequences: empty, [0]

Total increasing subsequences in the combined array [1,2,0]:

- Empty

- [1]

- [2]

- [1,2]

- [0]

- [1,0] (not increasing)

- [2,0] (not increasing)

So, only 5 increasing subsequences: empty, [1], [2], [1,2], [0]

But according to the sum rule, it should be 4 + 2 = 6, but in reality, it's 5.

Wait, this is inconsistent.

Wait, perhaps the total number of increasing subsequences is the sum of the increasing subsequences in each segment minus the empty subsequence counted multiple times.

In the first example, with two segments having 8 and 4 increasing subsequences respectively, including the empty one, the total should be 8 + 4 -1 = 11, but in reality, it's 5 in the smaller example.

Wait, in the smaller example, sum is 4 + 2 =6, minus one for the empty subsequence, which would be 5, which matches the manual count.

Similarly, in the first example, it should be 8 +4 -1=11, but earlier I thought it was 12, but perhaps I was wrong.

Wait, perhaps the formula is sum of the increasing subsequences in each segment minus 1 (for the empty subsequence).

In the smaller example, it's 4 +2 -1=5, which matches.

In the first example, it's 8 +4 -1=11, but earlier I thought it was 8 +4=12, but perhaps I missed some.

Wait, perhaps I need to think differently.

Wait, perhaps the total number of increasing subsequences is the product of (number of increasing subsequences in each segment).

Wait, in the smaller example, 4 *2=8, but in reality, it's 5.

Wait, doesn't match.

Wait, perhaps it's the product of (number of increasing subsequences in each segment -1) +1.

So, (4-1)*(2-1)+1=3*1+1=4, which is not matching.

Wait, perhaps it's more complicated.

Maybe I