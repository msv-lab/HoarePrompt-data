Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array x with elements x_2 to x_n, and I need to find an array a with elements a_1 to a_n that satisfies two conditions:

1. Each a_i is between 1 and 10^9.

2. For each i from 2 to n, x_i equals a_i modulo a_{i-1}.

And I need to find any such array a that meets these conditions.

First, I need to understand what "modulo" means. Modulo is the remainder when one number is divided by another. So, x_i = a_i % a_{i-1} means that when a_i is divided by a_{i-1}, the remainder is x_i.

Okay, so for each pair (a_{i-1}, a_i), the remainder when a_i is divided by a_{i-1} is x_i.

I need to find values for a_1 to a_n that satisfy this for all i from 2 to n.

Let's look at the example given:

Input:

5

4

2 4 1

3

1 1

6

4 2 5 1 2

2

500

3

1 5

Output:

3 5 4 9

2 5 11

5 14 16 5 11 24

501 500

2 7 5

So, for the first test case, n=4 and x=[2,4,1]. The output is a=[3,5,4,9].

Let's verify this:

a_2 % a_1 = 5 % 3 = 2, which matches x_2=2.

a_3 % a_2 = 4 % 5 = 4, which matches x_3=4.

a_4 % a_3 = 9 % 4 = 1, which matches x_4=1.

Looks good.

Now, how can I generalize this to find such an array a for any given x?

I need to find a_1, a_2, ..., a_n such that for each i from 2 to n, a_i % a_{i-1} = x_i.

I need to choose a_1 first, then a_2 based on a_1 and x_2, then a_3 based on a_2 and x_3, and so on.

Let me think about how to choose a_1.

a_1 can be any number between 1 and 10^9, but it affects a_2 through the modulo operation.

Given that x_2 = a_2 % a_1, I can choose a_1 to be greater than x_2, so that a_2 = k*a_1 + x_2 for some integer k >= 0.

But a_2 also needs to satisfy a_3 % a_2 = x_3, and so on.

This seems a bit tricky.

Let me consider choosing a_1 to be x_2 + 1. That way, a_2 can be a multiple of a_1 plus x_2.

For example, in the first test case, a_1=3 (which is x_2=2 +1), and a_2=5, which is 1*3 + 2=5.

Then a_3=4, which is 4 % 5 =4, which is x_3=4.

Then a_4=9, which is 9 %4=1, which is x_4=1.

This seems to work.

Let me see if this approach works in general.

Suppose I set a_1 = x_2 + 1.

Then, set a_2 = a_1 + x_2.

Wait, in the first test case, a_2=5, which is a_1=3 + x_2=2, so 3+2=5.

Then, for a_3, I need a_3 % a_2 = x_3=4.

So, a_3 %5=4.

I can set a_3 = a_2 + x_3 =5+4=9, but 9%5=4, which is correct.

Wait, but in the output, a_3=4, which is also 4%5=4, which works.

So, both a_3=4 and a_3=9 would work, but in the example, they chose a_3=4.

Wait, but a_3=4 is less than a_2=5, which is fine because 4%5=4.

Similarly, a_4=9 %4=1, which matches x_4=1.

So, in this case, choosing a_1=x_2+1, and then a_i = a_{i-1} + x_i works, but in the example, they chose a_i = something else sometimes.

Maybe I need to choose a_i in a way that a_i >= x_i and a_i < a_{i-1} + x_i or something like that.

Wait, perhaps I need to make sure that a_i is greater than or equal to x_i, and that a_i % a_{i-1} = x_i.

Wait, actually, a_i can be less than a_{i-1}, as long as a_i % a_{i-1} = x_i.

For example, if a_i < a_{i-1}, then a_i % a_{i-1} = a_i.

So, in that case, x_i should be equal to a_i.

That's what happened in the first test case: a_3=4 < a_2=5, and x_3=4.

Similarly, a_4=9 > a_3=4, and 9%4=1, which is x_4=1.

So, one way to approach this is to choose a_1 = x_2 + 1, as in the first test case.

Then, for each subsequent a_i, set a_i = a_{i-1} + x_i.

But wait, in the first test case, if I set a_1=3, a_2=3+2=5, a_3=5+4=9, a_4=9+1=10.

But in the example, they have a_3=4, which is less than a_2=5, and still satisfies 4%5=4.

So, their choice is also valid.

So, perhaps there are multiple possible solutions, and I can choose any one.

The problem says "find any array a that satisfies the conditions."

So, as long as I choose a_i such that a_i % a_{i-1} = x_i, and 1 <= a_i <= 10^9, it's acceptable.

Now, I need to find a way to choose a_i that is systematic and works for all cases.

Let me try to think of a general approach.

I can start by choosing a_1 to be x_2 + 1, as in the first test case.

Then, for a_2, set a_2 = a_1 + x_2.

This ensures that a_2 % a_1 = x_2, because (a_1 + x_2) % a_1 = x_2 % a_1 = x_2 (since x_2 < a_1).

Then, for a_3, set a_3 = a_2 + x_3.

Then a_3 % a_2 = (a_2 + x_3) % a_2 = x_3 % a_2 = x_3 (since x_3 < a_2).

Wait, but x_3 might not be less than a_2.

Wait, actually, x_i can be up to 500, and a_2 could be larger or smaller than x_3.

Wait, no, in the input, x_i can be up to 500, and a_2 is set to a_1 + x_2, where a_1 = x_2 + 1, so a_2 = x_2 + 1 + x_2 = 2*x_2 +1.

If x_2 is up to 500, then a_2 is up to 1001.

But n can be up to 500, and t is up to 10^4, but the sum of n over all test cases is up to 2*10^5.

But in any case, a_2 could be larger or smaller than x_3.

Wait, but x_i is up to 500, and a_1 is x_2 +1, which is up to 501.

Then a_2 = a_1 + x_2 = 501 + 500 = 1001.

Then a_3 = a_2 + x_3 =1001 + up to 500=1501, and so on.

But I need to make sure that a_i <=10^9, which is fine since 500*500=250,000, which is way below 10^9.

But in the first test case, they chose a_3=4, which is less than a_2=5, and it still satisfies 4%5=4.

So, their choice works, but my approach of setting a_i = a_{i-1} + x_i also works, as shown above.

So, I can choose either way.

But perhaps choosing a_i = a_{i-1} + x_i is simpler and always works.

Let me verify this with the second test case.

Second test case:

n=3, x=[1,1]

According to my approach:

Set a_1 = x_2 +1 =1+1=2

Then a_2 = a_1 + x_2 =2+1=3

a_3 = a_2 + x_3 =3+1=4

So, a=[2,3,4]

Check:

3%2=1, which matches x_2=1

4%3=1, which matches x_3=1

Which is correct.

But in the example, they have a=[2,5,11]

Which also works:

5%2=1, 11%5=1

So, multiple solutions are possible.

Hence, my approach seems valid.

Let me try the third test case:

n=6, x=[4,2,5,1,2]

Set a_1 = x_2 +1 =4+1=5

a_2 =5 +4=9

a_3=9 +2=11

a_4=11 +5=16

a_5=16 +1=17

a_6=17 +2=19

So, a=[5,9,11,16,17,19]

Check:

9%5=4, 11%9=2, 16%11=5, 17%16=1, 19%17=2

All match.

But in the example, they have a=[5,14,16,5,11,24]

Wait, that seems different.

Let's check:

14%5=4, 16%14=2, 5%16=5, 11%5=1, 24%11=2

All match.

So, again, multiple solutions.

My approach works.

Fourth test case:

n=2, x=[500]

Set a_1 =500 +1=501

a_2=501 +500=1001

Check:1001%501=1001-2*501=1001-1002=-1, but that can't be.

Wait, no, 1001 - 2*501=1001-1002=-1, but modulo should be non-negative.

Wait, 1001 divided by 501 is 2 times, with remainder 1001 - 2*501= -1, but modulo is always non-negative and less than the divisor.

Wait, but in integers, 1001 %501=1001 - 2*501= -1, but since modulo is always non-negative, it should be 501 -1=500.

Wait, but 2*501=1002, which is greater than 1001, so 1001 -1*501=500.

Yes, so 1001%501=500, which matches x_2=500.

Hence, a=[501,1001] is a valid solution.

But in the example, they have a=[501,500]

Let's check:

500%501=500, which matches x_2=500.

So, that also works.

Hence, their choice is a=[501,500], which is also valid.

So, again, multiple solutions.

Hence, my approach works.

Fifth test case:

n=3, x=[1,5]

Set a_1=1+1=2

a_2=2+1=3

a_3=3+5=8

Check:

3%2=1, 8%3=2, which does not match x_3=5.

Wait, but x_3=5.

So, 8%3=2, which does not match x_3=5.

Wait, that's a problem.

Wait, perhaps I need to adjust my approach.

In this case, setting a_i = a_{i-1} + x_i doesn't work for all cases.

Because in this case, a_3=8, and 8%3=2, but x_3=5.

So, that doesn't match.

But according to the problem constraints, x_i can be up to 500, and a_{i-1} can be up to 10^9.

But in this case, a_{i-1} is 3, and x_i is 5, which is greater than a_{i-1}.

Wait, but a_i % a_{i-1} should equal x_i.

If x_i >= a_{i-1}, then a_i must be such that a_i % a_{i-1} = x_i.

But if x_i >= a_{i-1}, then a_i must be at least a_{i-1} + (x_i - a_{i-1} * floor(x_i / a_{i-1})).

Wait, that seems complicated.

Perhaps a better way is:

If x_i < a_{i-1}, then a_i can be x_i, or a_{i-1} + x_i, or 2*a_{i-1} + x_i, etc.

But if x_i >= a_{i-1}, then a_i must be x_i + k*a_{i-1}, for some integer k >=1.

Wait, but in the fifth test case, x_3=5 and a_2=3.

Since 5 >=3, a_3 must be 5 + k*3 for some integer k >=1.

So, a_3 could be 5, 8, 11, 14, etc.

But 5 %3=2, 8%3=2, 11%3=2, 14%3=2, which is not equal to x_3=5.

Wait, but x_3=5 is greater than a_2=3, which is not possible because a_i % a_{i-1} can't be greater than or equal to a_{i-1}.

Wait, unless a_i is greater than or equal to a_{i-1}.

Wait, but in this case, 5 %3=2, which is less than 3, but x_3=5 is greater than 3.

So, there's a mistake here.

Wait, no, a_i % a_{i-1} must equal x_i, and x_i can be up to 500, while a_{i-1} can be chosen appropriately.

Wait, but in the fifth test case, x_3=5 and a_2=3.

So, a_3 %3 must be 5, but 5 >=3, which is impossible because a_i % a_{i-1} is always less than a_{i-1}.

Wait, but in the example, they have a=[2,7,5]

Wait, a_1=2, a_2=7, a_3=5

Check:

7%2=1, which should be x_2=1.

5%7=5, which should be x_3=5.

So, that works.

But according to my previous approach, setting a_1=x_2+1=1+1=2, a_2=2+1=3, a_3=3+5=8, but 8%3=2, which doesn't match x_3=5.

So, my approach fails in this case.

Hence, I need a better way to choose a_i.

Let me think again.

Given that x_i = a_i % a_{i-1}, and a_i % a_{i-1} is always in the range [0, a_{i-1}-1], unless a_i < a_{i-1}, in which case a_i % a_{i-1} = a_i.

But in the fifth test case, x_3=5 and a_2=3.

If a_3 < a_2=3, then a_3 %3 =a_3, so a_3=5 is not possible because 5 >3.

If a_3 >=3, then a_3 %3 can be 0,1, or 2.

But x_3=5, which is greater than 3, so it's impossible to have a_3 %3=5.

Wait, but in the example, they have a_3=5, which is greater than a_2=7.

Wait, no, in their solution, a_2=7 and a_3=5, so a_3 < a_2, hence a_3 %7=5, which matches x_3=5.

Ah, so in their solution, a_3=5 < a_2=7, so a_3 %7=5.

That works because a_3 < a_{i-1} implies a_3 % a_{i-1} = a_3.

So, to make a_i % a_{i-1} = x_i, if x_i >= a_{i-1}, I can set a_i =x_i, provided that x_i < a_{i-1}.

Wait, but x_i can be up to 500, and a_{i-1} can be chosen accordingly.

Wait, perhaps I need to choose a_{i-1} > x_i to make a_i =x_i.

In the fifth test case, to have a_3 %7=5, they set a_3=5 <7, so 5%7=5.

That works.

So, in general, for each i from 2 to n:

- If x_i < a_{i-1}, I can set a_i =x_i.

- If x_i >= a_{i-1}, I need to set a_i =x_i +k*a_{i-1}, for some integer k>=1.

But in the fifth test case, x_3=5 and a_2=7.

Since x_3 < a_2, set a_3 =x_3=5.

Which works as 5%7=5.

So, in general:

For each i from 2 to n:

- If x_i < a_{i-1}, set a_i =x_i.

- Else, set a_i =x_i + a_{i-1}.

Wait, but in the fourth test case, x_i=500 and a_{i-1}=501.

Since x_i < a_{i-1}, set a_i =x_i=500.

Then, a_i % a_{i-1} =500%501=500, which matches x_i=500.

Alternatively, set a_i =500 +501=1001, which also satisfies 1001%501=500.

So, both options work.

Hence, a general approach is:

- Set a_1 =x_2 +1.

- For each i from 2 to n:

- If x_i < a_{i-1}, set a_i =x_i.

- Else, set a_i =x_i + a_{i-1}.

This should work.

Let me verify this with the fifth test case.

n=3, x=[1,5]

Set a_1 =1+1=2.

Then, for i=2:

x_2=1 < a_1=2, so set a_2=1.

Then, for i=3:

x_3=5 < a_2=1? No, 5 >=1, so set a_3=5 +1=6.

Check:

a_2 % a_1 =1%2=1, matches x_2=1.

a_3 % a_2 =6%1=0, which does not match x_3=5.

Wait, that's not matching.

Wait, perhaps I need to adjust the condition.

Wait, in the fifth test case, if I set a_1=2, a_2=1, then a_3=6.

But 6%1 is undefined, because modulo by zero is not allowed, but in programming, 6%1=0.

But in the example, they have a_1=2, a_2=7, a_3=5.

Wait, how did they get a_2=7?

According to my approach, a_1=x_2 +1=1+1=2, then a_2=2 +1=3, a_3=3 +5=8.

But as seen earlier, that doesn't work for x_3=5.

So, perhaps my approach is flawed.

Let me think differently.

Suppose I set a_1 to be greater than all x_i.

Since x_i <=500, set a_1=501.

Then, for each i from 2 to n:

Set a_i = a_{i-1} + x_i.

This way, a_i > a_{i-1}, and a_i % a_{i-1} =x_i.

But in the fifth test case, x=[1,5], set a_1=501, a_2=501+1=502, a_3=502+5=507.

Check:

502%501=1, which matches x_2=1.

507%502=5, which matches x_3=5.

Perfect.

Similarly, in the fourth test case, x=[500], set a_1=501, a_2=501+500=1001.

1001%501=1001-2*501=1001-1002=-1, but in modulo, it's 501 -1=500.

Hence, matches x_2=500.

In the third test case, x=[4,2,5,1,2], set a_1=501, a_2=501+4=505, a_3=505+2=507, a_4=507+5=512, a_5=512+1=513, a_6=513+2=515.

Check:

505%501=4, 507%505=2, 512%507=5, 513%512=1, 515%513=2.

All match.

In the second test case, x=[1,1], set a_1=501, a_2=501+1=502, a_3=502+1=503.

Check:502%501=1,503%502=1.

Matches.

In the first test case, x=[2,4,1], set a_1=501, a_2=501+2=503, a_3=503+4=507, a_4=507+1=508.

Check:503%501=2,507%503=4,508%507=1.

Matches.

So, setting a_1 to a value greater than all x_i ensures that a_i > a_{i-1}, and a_i % a_{i-1} =x_i.

Given that x_i <=500, setting a_1=501 works.

But in the example, for the fifth test case, they have a_1=2, a_2=7, a_3=5.

Which also works, as shown earlier.

So, setting a_1=x_2 +1 seems to work in some cases, but not all, as seen in the fifth test case initially.

But setting a_1 to a value greater than all x_i always works.

Since n can be up to 500, and x_i up to 500, setting a_1=501 is safe.

But in the example, they have a_1=2 in the fifth test case, which is less than x_3=5, but they set a_3=5 < a_2=7, which works.

So, their approach is different.

But my approach of setting a_1=501 and then a_i=a_{i-1} +x_i works for all cases.

Hence, I can implement this approach.

But perhaps I can make a_i smaller by choosing a_1=x_2 +1 and then adjusting a_i accordingly.

But to keep it simple, setting a_1=501 works.

But in the problem constraints, a_i can be up to 10^9, and 501 +500*499=501+249500=250,000, which is way below 10^9.

Hence, it's safe.

But to optimize, perhaps I can set a_1 to x_2 +1, and then for each a_i, set a_i=a_{i-1} +x_i.

But as seen in the fifth test case, this doesn't work if x_i >=a_{i-1}.

Wait, but if I set a_1=x_2 +1, and then a_i=a_{i-1} +x_i, it should work because a_{i-1} >x_i.

Wait, in the fifth test case, x_2=1, so a_1=2.

Then a_2=2+1=3.

a_3=3+5=8.

But 8%3=2, which doesn't match x_3=5.

So, this approach fails here.

Hence, I need a better way.

Let me think again.

Given that x_i = a_i % a_{i-1}.

If a_i >= a_{i-1}, then a_i % a_{i-1} = a_i - floor(a_i / a_{i-1}) * a_{i-1}.

But this seems complicated.

An easier way is:

- If a_i < a_{i-1}, then a_i % a_{i-1} = a_i.

- If a_i >= a_{i-1}, then a_i % a_{i-1} = a_i - floor(a_i / a_{i-1}) * a_{i-1}.

But I need a_i % a_{i-1} =x_i.

So, to satisfy this, I can choose a_i such that:

- If x_i < a_{i-1}, then set a_i =x_i +k*a_{i-1}, for any integer k >=0.

- If x_i >= a_{i-1}, then it's impossible unless a_{i-1} divides (a_i -x_i).

But in the fifth test case, x_i=5 and a_{i-1}=3.

So, set a_i =5 +k*3, for k >=1.

So, a_i could be 5,8,11,14,...

But 5%3=2, which is not equal to x_i=5.

Wait, but x_i=5 >= a_{i-1}=3, which should be impossible, but in the example, they have a_i=5, which is less than a_{i-1}=7, and 5%7=5, which matches x_i=5.

Wait, but in this case, a_i=5 < a_{i-1}=7, so a_i % a_{i-1} =a_i=5, which matches x_i=5.

So, in this case, it's allowed to have a_i < a_{i-1}, as long as a_i =x_i.

Hence, a general approach is:

- Choose a_1 =x_2 +1.

- For each i from 2 to n:

- If x_i < a_{i-1}, set a_i =x_i.

- Else, set a_i =x_i + a_{i-1}.

But in the fifth test case, x_i=5 and a_{i-1}=3, which is x_i > a_{i-1}, so set a_i=5+3=8.

But 8%3=2, which doesn't match x_i=5.

So, this approach fails.

Hence, I need to adjust the approach.

An alternative approach is:

- Set a_1 =x_2 +1.

- Set a_2 =a_1 +x_2.

- For i from 3 to n:

- Set a_i =a_{i-1} +x_i.

This works as long as x_i < a_{i-1}.

But in the fifth test case, x_i=5 and a_{i-1}=3, which is x_i > a_{i-1}, so it fails.

Hence, I need to ensure that a_{i-1} > x_i for all i from 2 to n.

To ensure this, I need to choose a_1 > max(x_i).

Given that n can be up to 500 and x_i up to 500, setting a_1 to be greater than 500 is safe.

Hence, set a_1 =501.

Then, set a_i =a_{i-1} +x_i for i from 2 to n.

This ensures that a_i > a_{i-1}, and a_i % a_{i-1} =x_i.

This works for all test cases.

In the fifth test case, set a_1=501, a_2=501+1=502, a_3=502+5=507.

Check:

502%501=1, 507%502=5.

Which matches x_2=1, x_3=5.

Hence, this approach is correct.

In the fourth test case, set a_1=501, a_2=501+500=1001.

1001%501=500, which matches x_2=500.

In the third test case, set a_1=501, a_2=501+4=505, a_3=505+2=507, a_4=507+5=512, a_5=512+1=513, a_6=513+2=515.

Check:

505%501=4, 507%505=2, 512%507=5, 513%512=1, 515%513=2.

All match.

In the second test case, set a_1=501, a_2=501+1=502, a_3=502+1=503.

Check:502%501=1,503%502=1.

Matches x_2=1, x_3=1.

In the first test case, set a_1=501, a_2=501+2=503, a_3=503+4=507, a_4=507+1=508.

Check:503%501=2,507%503=4,508%507=1.

All match.

Hence, setting a_1=501 and a_i=a_{i-1} +x_i for i from 2 to n works.

But in the example, for the fifth test case, they have a_1=2, a_2=7, a_3=5.

Which also works, as shown earlier.

So, their approach is different.

But my approach is simpler and always works.

Hence, I can implement this.

Now, looking at the given program:

def func_1(arr, n):

ans = [0] * n

ans[0] = arr[0] + 1

for i in range(n - 2):

ans[i + 1] = arr[i] + ans[i]

if ans[i + 1] < arr[i + 1]:

while ans[i + 1] <= arr[i + 1]:

ans[i + 1] += ans[i]

ans[-1] = ans[-2] + arr[-1]

return ans

So, it sets a_1 =x_2 +1.

Then, for each i from 2 to n-1, sets a_i =x_{i-1} +a_{i-1}.

If a_i < x_i, it adds a_{i-1} repeatedly until a_i > x_i.

Finally, sets a_n =a_{n-1} +x_n.

Let me check this with the fifth test case.

n=3, x=[1,5]

Set a_1=1+1=2.

Set a_2=1 +2=3.

Since 3 <5, it enters the while loop and adds a_{i-1}=2 until a_i >5.

So, a_2=3+2=5.

Now, 5 >5, which is not true, so it stops.

Then, set a_3=5 +5=10.

Check:

a_2 % a_1 =5%2=1, which matches x_2=1.

a_3 % a_2 =10%5=0, which does not match x_3=5.

Hence, this approach fails in this case.

Wait, but in the example, they have a_1=2, a_2=7, a_3=5.

Which works.

But according to the code, it sets a_1=2, a_2=1+2=3, then since 3 <5, it adds 2 until a_2 >5.

So, a_2=3+2=5.

5 <=5, so adds again a_2=5+2=7.

Now, 7 >5, so stops.

Then, sets a_3=7 +5=12.

Check:

7%2=3, which should be x_2=1, but 3 !=1.

Wait, that doesn't match.

Wait, perhaps there's a mistake in the code.

Looking back at the code:

for i in range(n - 2):

ans[i + 1] = arr[i] + ans[i]

if ans[i + 1] < arr[i + 1]:

while ans[i + 1] <= arr[i + 1]:

ans[i + 1] += ans[i]

ans[-1] = ans[-2] + arr[-1]

In the fifth test case, n=3, arr=[1,5]

So, i ranges from 0 to 0 (n-2=1, so range(1)).

Set ans[1]=1 +2=3.

Since 3 <5, enter while loop.

ans[1] +=2, so ans[1]=5.

Now, 5 <=5, so add again ans[1]+=2, so ans[1]=7.

Now, 7 >5, so exit loop.

Then, set ans[2]=7 +5=12.

Check:

7%2=3, which should be x_2=1, but 3 !=1.

Hence, this doesn't work.

But in the example, they have a_1=2, a_2=7, a_3=5.

Which works because:

7%2=1,5%7=5.

But according to the code, it sets a_3=12, which is incorrect.

Hence, the code is wrong.

Wait, perhaps I misread the code.

Looking again:

for i in range(n - 2):

ans[i + 1] = arr[i] + ans[i]

if ans[i + 1] < arr[i + 1]:

while ans[i + 1] <= arr[i + 1]:

ans[i + 1] += ans[i]

ans[-1] = ans[-2] + arr[-1]

In the fifth test case:

n=3, arr=[1,5]

So, i from 0 to 0.

Set ans[1]=1 +2=3.

Since 3 <5, enter while loop.

ans[1] +=2, so ans[1]=5.

Now, 5 <=5, so add again ans[1]+=2, so ans[1]=7.

Now, 7 >5, exit loop.

Then, set ans[2]=7 +5=12.

Hence, a=[2,7,12].

Check:

7%2=1, which matches x_2=1.

12%7=5, which matches x_3=5.

Wait, yes, 12%7=5.

So, it works.

I must have miscalculated earlier.

So, a=[2,7,12] works.

Similarly, in the example, they have a=[2,7,5], which also works.

So, the code actually works.

Hence, the given program is correct.

Therefore, Correctness: **True**

**Final Answer**

\[ \boxed{\text{See explanation}} \]