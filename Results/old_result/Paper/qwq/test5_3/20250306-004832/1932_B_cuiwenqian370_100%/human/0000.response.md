Alright, I have this problem to solve. Let's understand what's being asked. There are n signs of the apocalypse, each occurring every a_i years. The signs must occur sequentially, meaning each sign must happen strictly after the previous one. I need to find out in which year the nth sign will occur, which marks the beginning of the apocalypse.

First, I need to parse the input. The input consists of multiple test cases. The first line is t, the number of test cases. For each test case, there's an integer n, the number of signs, followed by n integers representing the periodicity of each sign.

My goal is to, for each test case, determine the year in which the nth sign occurs, considering that each sign must happen strictly after the previous one.

Let me think about how the signs occur. Each sign i occurs in years that are multiples of a_i, like a_i, 2*a_i, 3*a_i, and so on. But they must occur sequentially, meaning that after the first sign occurs in year a_1, I start waiting for the second sign in year a_1 + 1, and so on.

So, for each sign after the first, I need to find the smallest year that is greater than the year the previous sign occurred and is a multiple of the current sign's period.

Let's formalize this. Let's say the year the first sign occurs is year a_1. Then, for the second sign, I need the smallest year greater than a_1 that is a multiple of a_2. Similarly, for the third sign, I need the smallest year greater than the year the second sign occurred that is a multiple of a_3, and so on.

So, for each sign from the second to the nth, I need to calculate the smallest multiple of a_i that is greater than the year the previous sign occurred.

Mathematically, if y_{i-1} is the year the (i-1)th sign occurred, then the year the ith sign occurs is the smallest y_i such that y_i > y_{i-1} and y_i is a multiple of a_i.

To find y_i, given y_{i-1} and a_i, I can use the formula:

y_i = ((y_{i-1} + 1 + a_i - 1) // a_i) * a_i

This formula finds the smallest multiple of a_i that is greater than y_{i-1}.

Let me verify this formula with an example.

Take the first test case from the example:

n = 6

a = [3, 2, 4, 5, 9, 18]

Start with the first sign: y_1 = 3

For the second sign:

y_2 = ((3 + 1 + 2 - 1) // 2) * 2 = (4 // 2) * 2 = 2 * 2 = 4

Wait, but according to the explanation, the second sign should occur in year 4, which is correct.

For the third sign:

y_3 = ((4 + 1 + 4 - 1) // 4) * 4 = (5 // 4) * 4 = 2 * 4 = 8

According to the example, this is correct.

Fourth sign:

y_4 = ((8 + 1 + 5 - 1) // 5) * 5 = (13 // 5) * 5 = 3 * 5 = 15

Wait, but in the example, it says the fourth sign occurs in year 10. Hmm, there's a discrepancy here. Let's check the example explanation again.

In the example explanation:

- First sign in year 3

- Second sign in year 4

- Third sign in year 8

- Fourth sign in year 10 (waiting for year 5 to pass, but according to my calculation, it should be year 15. Wait, maybe I misread.)

Wait, perhaps I need to consider that the waiting starts from x+1, where x is the year the previous sign occurred.

Let me re-examine the formula.

Given that the previous sign occurred in year x, I need to find the smallest year y such that y > x and y is a multiple of a_i.

The formula y_i = ((x + 1 + a_i - 1) // a_i) * a_i ensures that y_i is the smallest multiple of a_i greater than x.

In the fourth sign example:

x = 8

a_i = 5

y_i = ((8 + 1 + 5 - 1) // 5) * 5 = (13 // 5) * 5 = 3 * 5 = 15

But the example says it's year 10. Wait, perhaps I need to adjust the formula.

Wait, maybe it's y_i = ceil((x + 1) / a_i) * a_i

In Python, that's y_i = ((x + 1) + a_i - 1) // a_i * a_i

Let's compute again for x=8, a_i=5:

y_i = ((8 + 1) + 5 - 1) // 5 * 5 = (14 // 5) * 5 = 3 * 5 = 15

But the example says year 10. There's a mistake here.

Wait, perhaps I need to consider that the signs can occur in the same year as the previous one, as long as it's strictly after it. But since they are periodic, and the waiting starts from x+1, perhaps I need to find the smallest multiple of a_i that is greater than or equal to x+1.

Wait, in the example, for the fourth sign:

Previous sign year x = 8

a_i = 5

Possible occurrences of the fourth sign: 5, 10, 15, ...

The smallest occurrence greater than 8 is 10. So y_i should be 10.

Wait, so the formula should be the smallest multiple of a_i that is greater than x.

So, y_i = ceil((x + 1) / a_i) * a_i

In Python, y_i = ((x + 1) + a_i - 1) // a_i * a_i

For x=8, a_i=5:

y_i = ((8 + 1) + 5 - 1) // 5 * 5 = (14 // 5) * 5 = 3 * 5 = 15

But according to the example, it should be 10. So there's inconsistency here.

Wait, maybe the formula is y_i = ceil((x + 1) / a_i) * a_i

In this case, ceil((8 + 1)/5) * 5 = ceil(9/5) * 5 = ceil(1.8) * 5 = 2 * 5 = 10, which matches the example.

But in Python, ((x + 1) + a_i - 1) // a_i * a_i would be ((9) + 5 - 1) // 5 * 5 = 13 // 5 * 5 = 3 * 5 = 15, which doesn't match.

Wait, perhaps it's ((x + 1) + a_i - 1) // a_i * a_i

Wait, in Python, the floor division // rounds down, so ((x + 1) + a_i - 1) // a_i * a_i should give the smallest multiple of a_i greater than or equal to x + 1.

Wait, but in the example, for x=8, a_i=5, it should be 10, but according to the formula, it's 15. There's a mistake.

Wait, let's compute ((8 + 1) + 5 - 1) // 5 * 5 = (9 + 5 - 1) // 5 * 5 = 13 // 5 * 5 = 2 * 5 = 10. Wait, 13 // 5 is 2, 2 * 5 is 10. So it should be 10.

Wait, perhaps I miscalculated earlier. Let me confirm:

((8 + 1) + 5 - 1) // 5 * 5 = (9 + 5 - 1) // 5 * 5 = 13 // 5 * 5 = 2 * 5 = 10.

Yes, that's correct. So y_i = 10, which matches the example.

I must have made an error in earlier calculations.

So, the formula is correct: y_i = ((y_{i-1} + 1 + a_i - 1) // a_i) * a_i

Now, looking at the provided program:

It reads all input at once, splits it into a list, and processes it accordingly.

It reads t, the number of test cases, then for each test case, reads n and then n integers for a.

It initializes last_year to a[0], which is correct for the first sign.

Then, for each subsequent sign from 1 to n-1, it calculates the next_year using the formula:

next_year = (last_year + 1 + a[i] - 1) // a[i] * a[i]

and sets last_year to next_year.

Finally, it collects all results and prints them.

This seems to match the logic I derived.

Let me verify with the first test case:

n = 6

a = [3, 2, 4, 5, 9, 18]

Initialize last_year = 3

For i=1:

next_year = (3 + 1 + 2 - 1) // 2 * 2 = (5) // 2 * 2 = 2 * 2 = 4

last_year = 4

For i=2:

next_year = (4 + 1 + 4 - 1) // 4 * 4 = (8) // 4 * 4 = 2 * 4 = 8

last_year = 8

For i=3:

next_year = (8 + 1 + 5 - 1) // 5 * 5 = (13) // 5 * 5 = 3 * 5 = 15

Wait, earlier I thought it should be 10, but according to the formula, it's 15.

But in the example, it's said to be 10.

Wait, perhaps I'm missing something.

Wait, in the example explanation, it says:

- Wait for the fourth sign in the 10th year (since year 5 have already passed)

Wait, perhaps there's a mistake in the example explanation or in my interpretation.

According to the formula, it should be 15, but the example says 10.

Wait, maybe the waiting starts from x+1, but the sign can occur in x+1 if it's a multiple of a_i.

Wait, in this case, for x=8, a_i=5, the smallest multiple of 5 greater than 8 is 10, so y_i=10.

So, the formula should be y_i = ceil((x + 1) / a_i) * a_i

In Python, that's ((x + 1) + a_i - 1) // a_i * a_i

So, for x=8, a_i=5:

y_i = ((9) + 5 - 1) // 5 * 5 = 13 // 5 * 5 = 2 * 5 = 10

Yes, it's 10.

Earlier, I must have miscalculated.

So, the formula is correct, and the program implements it correctly.

Therefore, the given program is correct.

**Final Answer**

\[ \boxed{36} \]