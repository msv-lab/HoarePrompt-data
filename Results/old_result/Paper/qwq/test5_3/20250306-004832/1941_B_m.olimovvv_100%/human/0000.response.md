Alright, I've got this problem to solve. Let's see what it's about. So, Rudolf has an array of n integers, and he can perform a specific operation on it any number of times. The operation involves choosing an index i (where 2 ≤ i ≤ n-1) and modifying the elements at positions i-1, i, and i+1 by subtracting 1, 2, and 1 respectively. The goal is to determine whether it's possible to make all elements of the array zero using this operation.

First, I need to understand the operation clearly. So, for any chosen i (between 2 and n-1), I can subtract 1 from a[i-1], subtract 2 from a[i], and subtract 1 from a[i+1]. This can be done any number of times, and I can choose different i's in different operations.

I need to find out if, after some sequence of these operations, all elements in the array become zero.

Let me think about this in terms of linear algebra or system of equations. Each operation corresponds to subtracting a specific vector from the array. For each i, the operation vector is:

- ... 0, -1, -2, -1, 0, ...

with -1 at positions i-1 and i+1, and -2 at position i.

So, the problem reduces to whether the vector representing the initial array can be expressed as a linear combination of these operation vectors.

Given that, I need to check if the initial array is in the span of these operation vectors.

But dealing with linear algebra might be too slow for large n, especially since n can be up to 2*10^5 and t up to 10^4, with the sum of n over all test cases up to 2*10^5.

I need a more efficient way to check this.

Let me consider the differences between consecutive elements. Maybe looking at the differences can give me some insight.

Let's look at the differences between consecutive elements:

d[i] = a[i] - a[i-1] for i from 1 to n-1.

But I'm not sure if that directly helps.

Wait, maybe I can model this as a system where each operation affects certain elements, and see if I can solve for the number of times each operation is applied.

But with n up to 2*10^5, solving a system of equations for each test case isn't feasible.

I need a smarter approach.

Let me consider the total sum of the array. Each operation reduces the total sum by 1 + 2 + 1 = 4. So, if the initial sum isn't divisible by 4, it's impossible to make all elements zero.

Wait, but that's not necessarily true. Because operations can be applied multiple times, and the reductions are not independent; they overlap.

Wait, actually, no. Each operation reduces the sum by 4, but if operations overlap, the reductions might not be additive. So, perhaps sum needs to be divisible by 4, but I'm not sure.

Let me check with the sample input.

First sample input:

n=5, a=[1,3,5,5,2]

Sum is 1+3+5+5+2=16, which is divisible by 4. And the answer is YES.

Second sample input:

n=5, a=[2,4,4,5,1]

Sum is 2+4+4+5+1=16, same as above, but answer is NO.

So, sum being divisible by 4 is not sufficient.

Hmm.

I need another approach.

Let me think about the operations in reverse. Instead of subtracting from the array, think about adding to it. If I start from all zeros, and apply the operations in reverse, adding 1 to a[i-1], 2 to a[i], and 1 to a[i+1], then the problem is to see if the initial array can be built by such operations.

But that seems similar to the original problem.

Wait, maybe I can model this as a system where each operation affects a range of elements, and see if I can reach the initial array.

But again, that seems too slow for large n.

Let me consider the prefix sum.

Compute the prefix sum of the array.

Let's say s[i] = a[0] + a[1] + ... + a[i-1].

Then, look at the differences in the prefix sums.

Wait, maybe that's not directly helpful.

Let me consider the operation in terms of how it affects the array.

Each operation subtracts 1 from a[i-1], 2 from a[i], and 1 from a[i+1].

So, if I perform k operations at position i, it's like subtracting k from a[i-1], 2k from a[i], and k from a[i+1].

But since operations can be applied multiple times, it's like having variables k_i for each i from 2 to n-1, and setting up equations based on that.

So, for each position j from 1 to n:

- a[j] - (k_j + k_{j+1}) = 0, where k_j is the number of operations at position j.

Wait, maybe I need to define k_i as the number of operations applied at position i.

Then, for each position j:

- If j=1: a[j] - k_2 = 0

- If j=2: a[j] - 2k_2 - k_3 = 0

- If j=3: a[j] - 2k_3 - k_4 = 0

- ...

- If j=n-1: a[j] - 2k_{n-1} - k_n = 0

- If j=n: a[j] - k_n = 0

Wait, that might not be accurate.

Actually, for each position j:

- a[j] minus the contributions from operations that affect it should be zero.

- Operations at position i affect positions i-1, i, and i+1.

So, for position j:

- If j=1: a[j] - k_2 = 0

- If j=2: a[j] - 2k_2 - k_3 = 0

- If j=3: a[j] - 2k_3 - k_4 = 0

- ...

- If j=n-1: a[j] - 2k_{n-1} - k_n = 0

- If j=n: a[j] - k_n = 0

Wait, but in the operation, k_i affects a[i-1], a[i], and a[i+1].

So, for j from 1 to n:

- For j=1: a[1] - k_2 = 0

- For j=2: a[2] - 2k_2 - k_3 = 0

- ...

- For j=n-1: a[n-1] - 2k_{n-1} - k_n = 0

- For j=n: a[n] - k_n = 0

So, this gives us a system of equations:

1. a[1] - k_2 = 0

2. a[2] - 2k_2 - k_3 = 0

3. a[3] - 2k_3 - k_4 = 0

...

n-1. a[n-1] - 2k_{n-1} - k_n = 0

n. a[n] - k_n = 0

I need to solve for k_2, k_3, ..., k_n.

This is a system of n equations with n variables.

I can try to solve it step by step.

From equation 1: k_2 = a[1]

From equation n: k_n = a[n]

From equation n-1: a[n-1] - 2k_{n-1} - k_n = 0 => k_{n-1} = (a[n-1] - k_n)/2 = (a[n-1] - a[n])/2

Similarly, from equation n-2: a[n-2] - 2k_{n-2} - k_{n-1} = 0 => k_{n-2} = (a[n-2] - k_{n-1})/2

And so on, up to k_3.

But wait, k_2 is directly a[1], and k_n is a[n], and then I can compute k_{n-1}, k_{n-2}, etc., recursively.

But I need to ensure that all k_i are non-negative integers, since the number of operations can't be negative.

Also, since a_i can be up to 1e9 and n up to 2e5, I need an efficient way to compute this.

This seems promising.

Let me try with the first sample input.

n=5, a=[1,3,5,5,2]

So,

k_2 = a[1] = 1

k_5 = a[5] = 2

k_4 = (a[4] - k_5)/2 = (5 - 2)/2 = 3/2 = 1.5, which is not an integer. Wait, but in the problem, a_i are integers, and operations are integer operations, so k_i should be integers.

But here, k_4 is 1.5, which is not integer. That can't be.

But in the sample input, the answer is YES. So, maybe my approach is incorrect.

Wait, perhaps I need to adjust the equations.

Let me try another approach.

Let me consider the differences between consecutive elements.

Define d[i] = a[i] - a[i-1] for i from 1 to n, with a[0] = 0.

Wait, a[0] is not defined, but maybe I can assume a[0] = 0.

Then, d[1] = a[1] - 0 = a[1]

d[2] = a[2] - a[1]

...

d[n] = a[n] - a[n-1]

Now, consider how an operation affects the differences.

An operation at position i subtracts 1 from a[i-1], 2 from a[i], and 1 from a[i+1].

So, d[i] = a[i] - a[i-1] becomes (a[i] - 2) - (a[i-1] - 1) = (a[i] - 2) - (a[i-1] - 1) = a[i] - a[i-1] -1

Similarly, d[i+1] = a[i+1] - a[i] becomes (a[i+1] -1) - (a[i] -2) = a[i+1] - a[i] +1

And d[i+2] = a[i+2] - a[i+1} remains the same.

Wait, perhaps this is getting too complicated.

Let me try another way.

I recall that in some problems involving operations on consecutive elements, prefix sum or suffix sum can be useful.

Let me try to compute prefix sums.

Let s[i] = a[1] + a[2] + ... + a[i]

Then, an operation at position i affects s[i], s[i+1], and s[i+2].

Wait, maybe not directly helpful.

Let me consider that each operation reduces s[i] by 1, s[j] by 2, and s[k] by 1.

Wait, perhaps I need to think differently.

Let me consider that the operations can be seen as a way to reduce the array in a specific pattern, and I need to find if I can reduce it to zero.

Another idea: maybe I can model this as a system where I need to satisfy certain conditions on the array elements.

Looking back at the equations I set up earlier:

k_2 = a[1]

k_5 = a[5]

k_4 = (a[4] - k_5)/2 = (5 - 2)/2 = 1.5, which is not integer, but in the sample input, it's possible to reach zero.

So, perhaps my initial approach is incorrect.

Let me look for another pattern.

Let me consider that the operations can be applied in such a way that they propagate through the array.

Starting from one end, I can try to make elements zero step by step.

But I need a more concrete plan.

Let me consider trying to make the first element zero first.

To make a[1] zero, I need to apply operations that subtract from a[1]. The only operations that affect a[1] are those at i=2, since they subtract 1 from a[1].

So, to make a[1] zero, I need to apply k operations at i=2 such that k = a[1].

So, k = a[1].

Then, these k operations will also subtract 2*k from a[2] and k from a[3].

So, after applying k operations at i=2, the new array becomes:

a[1] - k = 0

a[2] - 2*k

a[3] - k

and the rest remain the same.

Then, I can move to a[2].

I need to make a[2] zero after the operations at i=2.

But a[2] is now a[2] - 2*k, where k = a[1].

So, a[2] - 2*a[1]

If this is negative, it's impossible.

If it's zero or positive, I can proceed.

Then, for a[3], I need to consider operations at i=3, which will subtract 1 from a[2], 2 from a[3], and 1 from a[4].

But a[2] has already been adjusted by the operations at i=2.

This seems like a sequential process where I process each position one by one, applying operations to make the current position zero, and seeing the effect on the next positions.

This sounds like a greedy approach.

Let me try this with the first sample input.

n=5, a=[1,3,5,5,2]

Step 1: Make a[1]=0 by applying k=a[1]=1 operation at i=2.

After this:

a[1] = 1 - 1 = 0

a[2] = 3 - 2*1 = 1

a[3] = 5 - 1 = 4

a[4] = 5

a[5] = 2

Now, array is [0,1,4,5,2]

Step 2: Make a[2]=0 by applying k=a[2]=1 operation at i=3.

After this:

a[2] = 1 - 2*1 = -1

Wait, a[2] becomes -1, which is negative. That's not allowed, as operations can't make elements negative before making them zero.

This suggests that my greedy approach might not be working here.

Wait, maybe I need to adjust the number of operations based on the remaining elements.

Alternatively, perhaps I need to consider the cumulative effects.

Let me try another approach.

Suppose I have the array [a1, a2, a3, a4, a5]

I need to make a1=0, a2=0, a3=0, a4=0, a5=0 using operations that subtract (1,2,1) from any a[i-1], a[i], a[i+1] for 2 ≤ i ≤ n-1.

I need to see if there exists a sequence of such operations that can zero out the entire array.

This seems like solving a system of linear equations over the integers.

But with n up to 2e5, I need a more efficient way.

Let me consider the operations as vectors in R^n, and see if the vector a is in the span of these operation vectors.

But again, this is too slow for large n.

I need a smarter way.

Let me consider the fact that operations can be applied multiple times, and that they overlap.

Maybe I can model this as a system where each operation affects a range, and find if the sum of these operations can cover the initial array.

But I need a better plan.

Let me look back at the problem and see if there is a pattern or invariant that I can exploit.

Suppose I look at the array as a whole and see what constraints must hold for it to be possible to zero it out.

First, as I thought earlier, the sum of the array must be equal to 4 times the number of operations applied.

But in the first sample input, sum is 16, and it's possible, but in the second sample input, sum is 16, and it's not possible.

So, sum being divisible by 4 is not sufficient.

Wait, maybe I need to look at other properties.

Let me consider the prefix sums.

Define s[i] = a[1] + a[2] + ... + a[i]

Then, an operation at position i affects s[i], s[i+1], and s[i+2].

Specifically, it subtracts 1 from s[i], 2 from s[i+1], and 1 from s[i+2].

Wait, actually, s[i] is the sum up to a[i], so an operation at i affects s[i] by subtracting 1, s[i+1] by subtracting 2, and s[i+2] by subtracting 1.

But I'm not sure if this helps directly.

Let me consider the differences between s[i] before and after an operation.

An operation at i subtracts 1 from s[i], 2 from s[i+1], and 1 from s[i+2].

So, s[i] becomes s[i] -1

s[i+1] becomes s[i+1] -2

s[i+2] becomes s[i+2] -1

And s[j] remains the same for j > i+2.

I need to make s[i] = 0 for all i.

This seems complicated.

Let me try to find another way.

I recall that in some problems, operations that affect multiple elements can be handled by setting up a system of equations or using difference arrays.

Wait, maybe difference arrays can be useful here.

Let me define d[i] = a[i] - a[i-1], with a[0] = 0.

Then, the operation at i corresponds to subtracting 1 from a[i-1], 2 from a[i], and 1 from a[i+1].

So, d[i] = a[i] - a[i-1]

After the operation at i, d[i] becomes (a[i] - 2) - (a[i-1] -1) = a[i] - a[i-1] -1 = d[i] -1

Similarly, d[i+1] becomes (a[i+1] -1) - (a[i] -2) = a[i+1] - a[i] +1 = d[i+1] +1

So, operation at i decreases d[i] by 1 and increases d[i+1] by 1.

This is interesting.

So, each operation at i adjusts d[i] and d[i+1].

I need to make all a[i] = 0, which implies that all d[i] = 0, since a[0] = 0 and a[i] = sum of d[j] from j=1 to i.

So, I need to transform the initial d[i] to all zeros using these operations.

Each operation at i subtracts 1 from d[i] and adds 1 to d[i+1].

This looks like I can move "deficits" from d[i] to d[i+1].

Let me see.

Starting from d[1] to d[n].

I need to make d[1] to d[n] all zero.

Each operation decreases d[i] and increases d[i+1].

So, to make d[1] = 0, I need to perform d[1] operations at i=1 (but i starts at 2), wait, i goes from 2 to n-1.

Wait, operations are only possible at i from 2 to n-1.

So, operations at i=2 affect d[2] and d[3], operations at i=3 affect d[3] and d[4], and so on.

So, I can adjust d[2] and d[3] via operations at i=2, d[3] and d[4] via i=3, and so on.

I need to make d[1] to d[n] all zero.

But operations only affect d[i] for i from 2 to n-1.

Wait, operations at i=2 affect d[2] and d[3], operations at i=3 affect d[3] and d[4], and so on.

So, d[1] cannot be directly affected by any operation, since operations start at i=2.

Therefore, d[1] must already be zero, because there's no way to change it.

Similarly, d[n] can be affected by operations at i=n-1, which decrease d[n-1] and increase d[n].

Wait, but d[n] is affected only by operations at i=n-1.

So, to make d[n] = 0, I need to adjust it via operations at i=n-1.

Similarly, d[n-1] can be affected by operations at i=n-1 and i=n-2.

Wait, but operations at i=n-1 affect d[n-1] and d[n].

So, I can adjust d[n-1] and d[n] by choosing the number of operations at i=n-1.

Similarly, d[n-2] can be affected by operations at i=n-2 and i=n-1.

This seems a bit involved.

But first, d[1] must be zero, because no operation affects it.

So, if d[1] != 0, it's impossible.

Similarly, for d[2], I can adjust it by operations at i=2, which decrease d[2] and increase d[3].

Then, d[3] can be adjusted by operations at i=2 and i=3, and so on.

This seems like a chain where each operation affects two consecutive d[i].

This is getting complicated.

Let me think differently.

Let me consider that operations can be used to propagate values through the array.

I need to find a way to make all elements zero by propagating reductions through the array.

But I'm still stuck.

Let me look back at the provided program and see what it's doing.

The program is:

def func():

for _ in range(int(input())):

a = int(input())

b = list(map(int, input().split()))

for i in range(0, a - 2):

if b[i] < 0:

print('NO')

break

b[i + 1] -= b[i] * 2

b[i + 2] -= b[i]

b[i] -= b[i]

else:

if b[-1] != 0 or b[-2] != 0:

print('NO')

else:

print('YES')

So, for each test case, it reads n and the array b.

Then, it iterates from i=0 to i=n-3.

In each iteration, if b[i] < 0, it prints 'NO' and breaks.

Otherwise, it updates b[i+1] by subtracting b[i]*2 and b[i+2] by subtracting b[i], and sets b[i] to zero.

After the loop, if b[n-1] and b[n-2] are both zero, it prints 'YES'; otherwise, 'NO'.

So, it's trying to process the array from the start, making each b[i] zero by adjusting b[i+1] and b[i+2] accordingly.

This seems like a greedy approach where it sequentially makes elements zero starting from the beginning.

Let me test this with the first sample input.

n=5, b=[1,3,5,5,2]

Iteration i=0:

b[0]=1 >=0

b[1] -= 1*2 => b[1]=3-2=1

b[2] -= 1 => b[2]=5-1=4

b[0]=0

Now, b=[0,1,4,5,2]

Iteration i=1:

b[1]=1 >=0

b[2] -= 1*2 => b[2]=4-2=2

b[3] -=1 => b[3]=5-1=4

b[1]=0

Now, b=[0,0,2,4,2]

Iteration i=2:

b[2]=2 >=0

b[3] -=2*2 => b[3]=4-4=0

b[4] -=2 => b[4]=2-2=0

b[2]=0

Now, b=[0,0,0,0,0]

Since b[-1]=0 and b[-2]=0, it prints 'YES'.

This matches the sample output.

Let's check the second sample input.

n=5, b=[2,4,4,5,1]

Iteration i=0:

b[0]=2 >=0

b[1] -=2*2 => b[1]=4-4=0

b[2] -=2 => b[2]=4-2=2

b[0]=0

Now, b=[0,0,2,5,1]

Iteration i=1:

b[1]=0 >=0

b[2] -=0*2 => b[2]=2-0=2

b[3] -=0 => b[3]=5-0=5

b[1]=0

Now, b=[0,0,2,5,1]

Iteration i=2:

b[2]=2 >=0

b[3] -=2*2 => b[3]=5-4=1

b[4] -=2 => b[4]=1-2=-1

b[2]=0

Now, b=[0,0,0,1,-1]

After the loop, b[-1]=-1 and b[-2]=1, which are not zero, so it prints 'NO'.

This matches the sample output.

Another sample input:

n=5, b=[0,1,3,3,1]

Iteration i=0:

b[0]=0 >=0

b[