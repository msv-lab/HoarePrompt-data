Alright, I've got this problem to solve. Let's see what it's about. There are two players, Alice and Bob, playing a game on an array of integers. Alice starts with an empty array c. In each turn, Alice picks an element from a, appends it to c, and deletes it from a. Bob, on his turn, picks an element from a, and just deletes it from a. The game ends when a is empty, and the score is the MEX of c, which is the smallest non-negative integer not in c.

Alice wants to maximize the MEX, and Bob wants to minimize it. Both play optimally. I need to find the final score given that.

First, I need to understand what MEX is. MEX of an array is the smallest non-negative integer not present in it. For example, MEX of [0,1,2] is 3, MEX of [0,1,3] is 2, and MEX of [1,2,3] is 0.

So, in this game, Alice is trying to make c have as many small non-negative integers as possible, to maximize the MEX. Bob, however, is trying to hinder Alice by removing elements from a that could potentially be useful to Alice.

Given that Alice and Bob play optimally, I need to simulate their decisions or find a way to calculate the final MEX.

Let me consider the process step by step.

1. The game starts with Alice choosing an element to add to c and remove from a.

2. Then Bob chooses an element to remove from a.

3. They alternate turns until a is empty.

4. The MEX of c is calculated based on the final content of c.

I need to think about how Alice and Bob's choices affect the final MEX.

First, note that Alice can choose which elements to include in c, but Bob can remove elements that Alice might need.

Let me consider that the MEX is determined by the absence of a particular number in c. So, to maximize the MEX, Alice wants to include as many of the smaller numbers as possible in c.

Bob, on the other hand, wants to minimize the MEX, so he wants to prevent Alice from including certain numbers in c by removing them from a.

Given that, I need to model their interactions.

Let's think about the total number of times each number is present in a.

Suppose a number x appears cnt[x] times in a.

Alice and Bob take turns, with Alice starting. In each turn, Alice picks an element to add to c and remove from a, and Bob removes an element from a.

So, for each number x, the number of times it's available to be chosen is cnt[x].

Now, Alice wants to include x in c as much as possible, especially the smaller x's.

Bob wants to prevent Alice from including certain x's by removing them.

I need to find out, for each x, whether Alice can include it in c, given Bob's interference.

Let's consider that for each x, Alice needs to include it in c at least once if possible.

But Bob can remove some occurrences of x, making it harder for Alice.

I need to model this interaction.

Let me think in terms of the number of times each number is present.

Suppose I have counts of each number in a.

For example, for a = [0,0,1,1], counts are: 0:2, 1:2.

Alice and Bob take turns, with Alice starting.

Alice chooses one element to add to c and remove from a.

Bob then removes one element from a.

They alternate until a is empty.

So, for n=4, there are 4 turns: Alice, Bob, Alice, Bob.

After first Alice's turn: c has one element, a has 3 elements.

Bob removes one element, a has 2 elements.

Alice removes one element and adds it to c, a has 1 element.

Bob removes the last element.

Final c has two elements.

In this case, c could be [0,1], MEX is 2.

But according to the example, it's 2.

Another example: n=4, a=[0,1,2,3]. MEX is 1.

And n=2, a=[1,1], MEX is 0.

I need to find a general way to calculate the MEX based on their optimal plays.

Let me try to find a pattern or a formula.

First, I need to see how many times Alice can include each number x in c.

Given that Bob can remove elements, he can try to prevent Alice from including certain numbers.

But Alice can also choose which elements to include.

I need to find a way to maximize the MEX by Alice, while Bob tries to minimize it.

I recall that in game theory, such scenarios can be modeled using the concept of "Nimbers" or "grundy numbers", but I'm not sure if that's directly applicable here.

Alternatively, maybe I can think in terms of the parity of the counts.

Wait, let's think differently.

Let's consider that the total number of elements is n.

Alice and Bob take turns, with Alice starting.

Total turns: n.

Alice's turns: ceil(n/2)

Bob's turns: floor(n/2)

Wait, no.

In total, there are n elements.

Each turn, one element is removed.

So, total turns: n.

Alice's turns: ceil(n/2)

Bob's turns: floor(n/2)

Wait, in the first example, n=4.

Alice's turns: 1,3

Bob's turns: 2,4

So, Alice chooses elements on turns 1 and 3.

Bob removes elements on turns 2 and 4.

At the end, c has elements chosen by Alice on her two turns.

So, c has ceil(n/2) elements.

Wait, but in the first example, c has [1,0], which are chosen by Alice on her two turns.

So, c has ceil(n/2) elements.

But, in the second example, n=4, c would have two elements, but the MEX is 1.

Wait, but in that case, a=[0,1,2,3], c could be [0,1], MEX is 2.

But according to the example, it's 1.

Wait, perhaps I misread.

Wait, no, the output is 2,1,0 for the three test cases.

Wait, in the first test case, output is 2.

Second test case, n=4, a=[0,1,2,3], output is 1.

Third test case, n=2, a=[1,1], output is 0.

Wait, in the second test case, how can the MEX be 1 if c could be [0,1], which has MEX 2?

Wait, perhaps I'm misunderstanding something.

Wait, perhaps I need to consider that Bob can force the MEX to be lower.

In the second test case, n=4, a=[0,1,2,3].

Possible sequence:

Alice chooses 0, c=[0], a=[1,2,3]

Bob removes 1, a=[2,3]

Alice chooses 2, c=[0,2], a=[3]

Bob removes 3, a=[]

Final c=[0,2], MEX is 1.

Alternatively, Alice could choose 1 and 3, c=[1,3], MEX is 0.

But the output is 1, so perhaps in optimal play, MEX is 1.

Wait, but according to the output, it's 1.

So, perhaps in optimal play, c=[0,2], MEX=1.

Wait, but MEX of [0,2] is actually 1, since 1 is missing.

Wait, no, MEX of [0,2] is 1, because 0 is present, 1 is not present.

Wait, yes, that's correct.

So, in this case, Alice chooses 0 and 2, c=[0,2], MEX=1.

But she could have chosen 0 and 1, c=[0,1], MEX=2.

But Bob can prevent that.

Wait, how?

Wait, in the sequence I described earlier, Bob removes 1 after Alice chooses 0.

So, a=[1,2,3] becomes [2,3] after Bob removes 1.

Then Alice chooses 2, c=[0,2], a=[3], Bob removes 3.

So, c=[0,2], MEX=1.

Alternatively, if Alice chooses 1 first, then:

Alice chooses 1, c=[1], a=[0,2,3]

Bob removes 0, a=[2,3]

Alice chooses 2, c=[1,2], a=[3]

Bob removes 3, a=[]

Final c=[1,2], MEX=0.

Which is worse for Alice.

So, in the first sequence, c=[0,2], MEX=1.

In the second sequence, c=[1,2], MEX=0.

So, Bob can force MEX to be 1 by removing 1 after Alice chooses 0.

If Alice chooses 0 first, Bob removes 1, then Alice chooses 2, and Bob removes 3.

So, c=[0,2], MEX=1.

Hence, the optimal MEX is 1.

I see.

So, in this game, Bob can influence which elements Alice can choose by removing certain elements.

So, to generalize, I need to find, for each x from 0 to some maximum, whether Alice can include x in c, despite Bob's removals.

If Alice can include all x from 0 to k in c, then MEX is k+1.

Otherwise, MEX is the smallest x not included in c.

I need to find the smallest x that Alice cannot include in c, even with optimal play.

Wait, perhaps I need to think in terms of the counts of each x.

Let me consider that.

Suppose I have counts of each x in a.

Alice wants to include as many x as possible in c, starting from x=0.

Bob wants to prevent Alice from including certain x's.

Given that, for each x, the number of times it appears in a is cnt[x].

Alice and Bob take turns, with Alice starting.

Each turn, Alice chooses an element to include in c and remove from a.

Bob chooses an element to remove from a.

So, for each x, the number of times it's available is cnt[x].

I need to see how many of these cnt[x] can Alice include in c.

Given that Bob can remove elements, he can choose to remove elements that Alice wants.

But Alice chooses first each turn.

Wait, perhaps I can model this as a game where Alice tries to include x in c, and Bob tries to prevent it.

For each x, I need to see if Alice can include it in c, given that Bob can remove some occurrences.

Wait, maybe I can think in terms of the number of times Alice can choose x before Bob can remove all remaining x's.

Wait, perhaps it's better to iterate through x from 0 to some maximum, and check if Alice can include x in c.

To do that, I need to see if, for x, the count cnt[x] is greater than the number of times Bob can remove x.

But I need to model their interactions properly.

Let me consider the total number of turns Alice gets to choose elements.

Total elements: n.

Total turns: n.

Alice's turns: ceil(n/2).

Bob's turns: floor(n/2).

Wait, in Python, since n is an integer, ceil(n/2) is (n+1)//2.

Floor(n/2) is n//2.

So, Alice gets (n+1)//2 turns to choose and include elements in c.

Bob gets n//2 turns to remove elements.

But Bob removes elements that Alice didn't choose.

Wait, no.

Actually, on Alice's turn, she chooses an element to include in c and removes it from a.

On Bob's turn, he chooses an element to remove from a.

So, in total, Alice includes (n+1)//2 elements in c.

Bob removes n//2 elements from a.

But some of Bob's removals can be elements that Alice hasn't chosen yet.

So, the final c has (n+1)//2 elements, chosen by Alice, and some elements removed by Bob that are not in c.

I need to find the MEX of c, which is the smallest non-negative integer not in c.

So, I need to maximize the MEX for Alice, considering Bob's interference.

Wait, perhaps I can think in terms of the total available counts of each x, and how Alice and Bob's choices affect them.

Let me try to think differently.

Suppose I sort the unique x in a, and for each x, I have cnt[x].

I need to see how many of these x Alice can include in c.

Given that Bob can remove elements, including those that Alice wants.

Wait, maybe I can iterate through x from 0 to max possible, and for each x, check if Alice can include it in c.

To do that, I need to see if the number of times x appears in a is greater than the number of times Bob can remove it.

But Bob can remove elements on his turns, which are n//2 turns.

But Bob can choose to remove any element, not necessarily x.

So, Bob can choose to remove elements that Alice wants to include.

So, for Alice to include x, she needs to choose x before Bob removes all remaining x's.

Wait, perhaps I can think in terms of the number of times Alice can choose x before Bob removes all remaining x's.

But this seems complicated.

Let me consider that Alice has (n+1)//2 choices to include elements in c.

She wants to include as many small x's as possible.

Bob wants to prevent that by removing elements that Alice might want to include.

Given that, perhaps I can find the minimal x that Alice cannot include in c, given Bob's removals.

Wait, perhaps I can iterate through x from 0 to max possible, and for each x, check if Alice can include it in c.

To do that, I need to see if, considering the counts of x and the number of turns Alice has, Alice can include x before Bob removes all remaining x's.

This seems tricky.

Let me think about it differently.

Suppose I have the counts of each x in a.

I can iterate through x from 0 to max possible, and try to see if Alice can include x in c.

To maximize the MEX, Alice wants to include x=0, x=1, ..., up to some k.

Bob wants to prevent that.

So, for each x, I need to see if Alice can include x in c, given that Bob can remove elements.

Wait, perhaps I can think in terms of the number of times Alice can choose x before Bob removes all remaining x's.

Let me define, for each x, the number of times Alice can include x as min(cnt[x], ceil(cnt[x]/2)).

Wait, no.

Wait, if cnt[x] is the number of times x appears in a.

Alice can include floor((cnt[x]+1)/2) times, since she gets ceil(n/2) turns.

But this might not be directly applicable.

Wait, perhaps I need to consider for each x, the number of times Alice can include x is floor(cnt[x] / 2) + (1 if cnt[x] % 2 == 1 else 0).

Wait, no.

Wait, let's think about it.

For a given x, with cnt[x] occurrences.

Alice and Bob take turns, with Alice starting.

Each time Alice chooses x, she includes it in c and removes it from a.

Bob can choose to remove x or other elements.

To maximize the number of x's in c, Alice will choose x as much as possible.

Bob will choose to remove x to minimize the number of x's in c.

So, for each x, the number of times Alice can include x is ceil(cnt[x]/2).

Because for every two turns, Alice can include one x (she chooses x, Bob removes x).

If cnt[x] is odd, Alice can include one more.

Wait, let's see with an example.

Suppose cnt[x] = 3.

Turns:

1. Alice chooses x, includes in c, removes from a. Remaining x: 2.

2. Bob removes x. Remaining x: 1.

3. Alice chooses x, includes in c, removes from a. Remaining x: 0.

So, Alice includes x twice.

Which is ceil(3/2) = 2.

Another example, cnt[x] = 4.

Turns:

1. Alice chooses x, includes in c, removes from a. Remaining x: 3.

2. Bob removes x. Remaining x: 2.

3. Alice chooses x, includes in c, removes from a. Remaining x: 1.

4. Bob removes x. Remaining x: 0.

Alice includes x twice, which is ceil(4/2) = 2.

So, in general, for each x, Alice can include ceil(cnt[x]/2) instances of x in c.

Given that, for each x, the number of times it appears in c is ceil(cnt[x]/2).

So, the final c will have, for each x, ceil(cnt[x]/2) occurrences.

But since MEX is about the presence of x in c, not the number of occurrences, we just need to know if x is present in c at least once.

So, for each x, if ceil(cnt[x]/2) >= 1, then x is in c.

Else, x is not in c.

Hence, x is in c if cnt[x] >= 2*floor(cnt[x]/2) + 1, which is equivalent to cnt[x] >= 1.

Wait, no.

Wait, ceil(cnt[x]/2) >=1 if cnt[x] >=2.

Wait, no.

Ceil(1/2)=1, which is >=1.

Ceil(0/2)=0, which is <1.

So, for cnt[x] >=1, ceil(cnt[x]/2) >=1.

Wait, but ceil(1/2)=1, ceil(2/2)=1, ceil(3/2)=2, etc.

So, ceil(cnt[x]/2) >=1 if cnt[x] >=1.

Wait, but ceil(0/2)=0.

So, if cnt[x] >=1, then ceil(cnt[x]/2) >=1.

Hence, for any x with cnt[x] >=1, Alice can include at least one in c.

Wait, but according to the earlier example, for cnt[x]=1, Alice can include ceil(1/2)=1, which is >=1.

For cnt[x]=0, ceil(0/2)=0, which is <1.

So, if cnt[x] >=1, Alice can include x in c.

But wait, in the second test case, n=4, a=[0,1,2,3], counts are all 1.

So, for each x in [0,1,2,3], cnt[x]=1.

Then, ceil(1/2)=1, so Alice can include each x at least once.

So, c would have [0,1,2,3], MEX should be 4.

But according to the example, output is 1.

Wait, that contradicts.

So, perhaps my assumption is wrong.

Wait, perhaps I need to consider that Bob can remove other elements, not necessarily the ones Alice wants.

Wait, no, Bob can remove any element from a on his turn.

He doesn't have to remove x.

So, in the earlier example, n=4, a=[0,1,2,3], cnt[x]=1 for each x.

Alice chooses 0, c=[0], a=[1,2,3]

Bob removes 1, a=[2,3]

Alice chooses 2, c=[0,2], a=[3]

Bob removes 3, a=[]

Final c=[0,2], MEX=1.

Alternatively, Alice could choose 1 and 3, but then c=[1,3], MEX=0.

But in optimal play, Bob can force MEX to be 1.

So, my earlier assumption is incorrect.

So, perhaps Alice cannot include all x's, even if cnt[x]>=1.

Because Bob can remove elements that Alice hasn't chosen yet.

So, perhaps I need to consider the order in which Alice chooses elements.

Wait, maybe I need to think in terms of the total number of elements Alice can choose, and see which x's she can include.

Given that Alice gets ceil(n/2) choices, she can choose ceil(n/2) elements to include in c.

Bob gets floor(n/2) removals.

But Bob can remove elements that Alice hasn't chosen yet.

So, to maximize MEX, Alice should choose the smallest possible x's.

Bob, to minimize MEX, would want to prevent Alice from choosing certain x's.

Wait, perhaps I can sort the unique x's and see which ones Alice can include.

Let me try to think differently.

Suppose I sort the unique x's in ascending order.

Then, Alice tries to include the smallest x's possible.

Bob tries to prevent that.

Given that, for each x, I need to see if Alice can include it in c.

To do that, I need to see if the number of times x appears in a is enough for Alice to include it, considering Bob's removals.

Wait, perhaps I can iterate through x from 0 to max possible, and for each x, check if cnt[x] - floor(cnt[x]/2) >=1.

Wait, no.

Wait, cnt[x] is the total occurrences of x in a.

Alice can include ceil(cnt[x]/2) times.

But MEX only cares about whether x is present in c at least once.

So, for x to be in c, ceil(cnt[x]/2) >=1, which is true if cnt[x] >=1.

But in the earlier example, n=4, a=[0,1,2,3], cnt[x]=1 for each x.

Then, ceil(1/2)=1, so Alice can include each x once.

But according to the optimal play, c can be [0,2], MEX=1.

So, MEX is not 4 as I thought earlier.

So, perhaps my assumption is incorrect.

Wait, maybe I need to consider that Alice can include ceil(cnt[x]/2) for each x, but the total number of elements she can include is ceil(n/2).

So, she needs to choose which x's to include, prioritizing the smaller x's.

Bob can remove elements to prevent Alice from including certain x's.

Wait, perhaps I need to calculate, for each x, the minimal number of times Alice can include x, given Bob's removals.

This seems complicated.

Let me look for a different approach.

I recall that in some games, the final result can be determined by the parity of certain counts.

Wait, perhaps I can think in terms of the number of times each x appears, and how Alice and Bob's turns affect the inclusion in c.

Wait, maybe I can consider that for each x, if cnt[x] is odd, Alice can include one, and if cnt[x] is even, Alice can include floor(cnt[x]/2).

Wait, in the earlier example, cnt[x]=1 for all x, which is odd, so Alice can include one for each x.

But in optimal play, Bob can force some x's not to be included in c.

Hence, perhaps I need to consider that for x's with cnt[x]=1, Bob can prevent Alice from including it by removing another x that Alice wants.

Wait, I'm getting confused.

Let me try to think in terms of the total number of elements Alice can include.

Total elements Alice includes: ceil(n/2).

So, in n=4, ceil(4/2)=2.

So, c has 2 elements.

In n=3, ceil(3/2)=2.

So, c has 2 elements.

In n=2, ceil(2/2)=1.

So, c has 1 element.

Given that, I need to select ceil(n/2) elements from a, considering Bob's removals.

Alice wants to select the smallest possible x's to maximize the MEX.

Bob wants to force higher x's to minimize the MEX.

So, perhaps I can sort the unique x's in ascending order, and try to include as many as possible in c.

But Bob can remove elements to prevent that.

Wait, perhaps I can iterate through x from 0 to max possible, and for each x, check if Alice can include it in c.

To do that, I need to see if, after considering the counts and Bob's removals, Alice can include x.

This seems too vague.

Let me look for a pattern in the sample inputs.

First test case:

n=4, a=[0,0,1,1]

Counts: 0:2, 1:2.

Alice can include ceil(2/2)=1 for x=0, and ceil(2/2)=1 for x=1.

So, c can have [0,1], MEX=2.

Which matches the first output.

Second test case:

n=4, a=[0,1,2,3]

Counts: 0:1,1:1,2:1,3:1.

Alice can include ceil(1/2)=1 for each x.

But in optimal play, c can be [0,2], MEX=1.

Wait, but according to my earlier assumption, Alice can include [0,1,2,3], but c has only ceil(n/2)=2 elements.

So, she can include only two.

Hence, MEX is 1.

Wait, but in this case, she can choose [0,1], MEX=2.

But Bob can force it to be [0,2], MEX=1.

Hence, the minimal MEX is 1.

Third test case:

n=2, a=[1,1]

Counts:1:2.

Alice can include ceil(2/2)=1.

So, c=[1], MEX=0.

Which matches the third output.

So, perhaps the MEX is the smallest x that Alice cannot include in c, considering Bob's removals.

Given that, perhaps I can iterate through x from 0 to some maximum, and for each x, check if Alice can include it in c.

If she can, include it, and proceed to the next x.

If not, that's the MEX.

To check if Alice can include x in c, I need to see if, after considering Bob's removals, she can include x.

Wait, perhaps I can think in terms of the number of times x appears, and the number of times Bob can remove it.

For x to be included in c, Alice needs to choose it at least once before Bob removes all remaining x's.

Given that, for x to be included, cnt[x] - floor(cnt[x]/2) >=1.

Wait, cnt[x] is the total count.

Alice can include ceil(cnt[x]/2).

So, if ceil(cnt[x]/2) >=1, then x can be included.

But in the second test case, for x=0,1,2,3, cnt[x]=1, ceil(1/2)=1, so Alice can include each x once.

But in optimal play, Bob can force c to be [0,2], excluding 1 and 3.

Hence, MEX is 1.

Wait, perhaps I need to consider the total number of elements Alice can include, and select the smallest x's possible.

So, Alice wants to include the smallest x's, and Bob wants to prevent that.

Hence, the MEX would be the smallest x that Alice cannot include in c.

Given that, perhaps I can sort the unique x's in ascending order, and try to include as many as possible, up to ceil(n/2).

But, Bob can remove elements to prevent Alice from including certain x's.

Wait, perhaps I can sort the unique x's, and for each x, check if Alice can include it.

If she can, include it, and proceed to the next x.

If not, that's the MEX.

But I need to formalize how to check if Alice can include x.

Wait, perhaps I can calculate the number of elements Alice can include before x.

If the number of elements she can include before x is less than x, then MEX is x.

Wait, maybe not.

This is getting too convoluted.

Let me look for a different approach.

I recall that in some games, the final result can be determined by the XOR of certain values, but I don't think that's applicable here.

Wait, perhaps I can think in terms of the frequency of each number and how it affects the MEX.

Let me consider that Alice can include ceil(cnt[x]/2) for each x.

Hence, in c, for each x, the count is ceil(cnt[x]/2).

Then, to find MEX, I need to find the smallest x not in c, i.e., ceil(cnt[x]/2)=0.

But ceil(cnt[x]/2)=0 only when cnt[x]=0.

So, if cnt[x]=0, then x is not in c.

Hence, MEX is the smallest x with cnt[x]=0.

But in the second test case, cnt[x]=1 for x=0,1,2,3.

So, ceil(1/2)=1, so x=0,1,2,3 are all in c.

But according to the optimal play, c can be [0,2], missing x=1.

Hence, MEX is 1.

So, my assumption is incorrect.

Hence, perhaps Alice cannot include all x's even if cnt[x]>=1.

Because Bob can remove elements in such a way that Alice cannot include all x's.

Hence, perhaps I need to consider the minimal x that Alice cannot include, given Bob's removals.

Wait, perhaps I can iterate through x from 0 to max possible, and for each x, check if Alice can include it.

To do that, I need to see if, after considering Bob's removals, Alice can choose x before Bob removes all x's.

This seems too vague.

Let me think differently.

Suppose I have a list of unique x's sorted in ascending order.

Then, Alice will try to include the smallest x's possible.

Bob will try to prevent that by removing elements that Alice wants.

Hence, the MEX would be the smallest x that Alice cannot include in c, given Bob's removals.

So, perhaps I can iterate through x from 0 upwards, and for each x, check if Alice can include it.

To check if Alice can include x, I need to see if, after Bob's removals, Alice can choose x.

Wait, perhaps I can think in terms of the number of times x appears and the number of times Bob can remove it.

For x to be included in c, Alice needs to choose it at least once before Bob removes all remaining x's.

Given that, for x to be included, cnt[x] - (floor(cnt[x]/2)) >=1.

Because Alice can include ceil(cnt[x]/2), and Bob can remove floor(cnt[x]/2).

Wait, total removals for x are floor(cnt[x]/2), by Bob.

Hence, remaining for Alice is cnt[x] - floor(cnt[x]/2).

If that's >=1, then Alice can include x.

Wait, but in the second test case, cnt[x]=1 for each x.

So, cnt[x] - floor(1/2) = 1 - 0 =1 >=1, so Alice can include x.

But according to the optimal play, Bob can force c to be [0,2], excluding 1 and 3.

Hence, MEX is 1.

So, my assumption is still incorrect.

Wait, perhaps I need to consider the total number of elements Alice can include and see which x's she can include within that limit.

Given that Alice can include ceil(n/2) elements, she needs to choose the smallest x's possible.

Bob can remove elements to prevent Alice from including certain x's.

Hence, perhaps I can sort the unique x's in ascending order and try to include as many as possible within ceil(n/2).

But Bob can remove elements to prevent that.

Wait, perhaps I can calculate the minimal x that Alice cannot include, given that she can include ceil(n/2) elements.

But this seems too vague.

Let me try to think in terms of the frequency counts.

Suppose I have frequencies of each x.

Then, for each x, Alice can include ceil(cnt[x]/2).

But in reality, she might include fewer if she needs to include smaller x's.

Wait, perhaps I need to iterate through x from 0 upwards, and for each x, check if Alice can include it.

If she can, include it, and subtract one from cnt[x].

Then, proceed to the next x.

Stop when Alice can't include any more x's.

The smallest x that Alice cannot include is the MEX.

But I need to consider Bob's removals.

Wait, perhaps I can calculate the total number of elements Alice can include, which is ceil(n/2), and try to include the smallest x's possible.

But Bob can remove elements to prevent Alice from including certain x's.

Hence, perhaps I need to sort the unique x's in ascending order and try to include as many as possible within ceil(n/2).

But Bob can remove elements to make it harder.

This seems too vague.

Let me look for a different approach.

I recall that in some games, the final result can be determined by the number of elements and their frequencies.

Wait, perhaps I can think in terms of the number of times Alice can include each x, and see which x's she can include within her total choices.

Given that Alice can include ceil(cnt[x]/2) for each x, but she has a total of ceil(n/2) choices to make.

Hence, she needs to allocate her choices to include as many small x's as possible.

So, perhaps I can sort the unique x's in ascending order and try to include them one by one, allocating the necessary choices.

Wait, this sounds promising.

Let me formalize it.

Let me sort the unique x's in ascending order: x1 < x2 < x3 < ... < xk.

Then, for each x_i, the number of choices Alice needs to include it is ceil(cnt[x_i]/2).

So, for each x_i, Alice needs ceil(cnt[x_i]/2) choices to include it.

She has a total of ceil(n/2) choices.

So, she needs to allocate her choices to include as many x_i's as possible, starting from the smallest x_i.

Hence, I can iterate through x_i from smallest to largest, and for each x_i, allocate ceil(cnt[x_i]/2) choices to include it.

Once her total choices allocated reach ceil(n/2), she can't include any more x_i's.

The smallest x_i that she cannot include is the