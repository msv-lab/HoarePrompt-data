Alright, I've got this problem to solve. Let's see what it's asking for. So, I have n sticks, each with a length of 2 raised to the power of a_i, where a_i is given for each stick. I need to choose exactly 3 sticks and form a non-degenerate triangle with them. A non-degenerate triangle means that the area is greater than 0, which implies that the sum of any two sides must be greater than the third side. Basically, it's the triangle inequality theorem.

So, my task is to count how many ways I can pick 3 sticks that satisfy the triangle inequality. The input consists of multiple test cases, and for each test case, I have n and a list of a_i values.

First, I need to understand the properties of the stick lengths. Since the lengths are of the form 2^a_i, and a_i can range from 0 to n, the lengths are powers of 2, which are distinct and non-negative.

I recall that for any three lengths to form a triangle, the sum of the two smaller lengths must be greater than the largest length. Given that the lengths are powers of 2, maybe there are some properties I can exploit here.

Let me think about the properties of powers of 2. Powers of 2 are strictly increasing: 2^0 = 1, 2^1 = 2, 2^2 = 4, and so on. An important property is that for any three distinct powers of 2, say 2^a, 2^b, and 2^c where a < b < c, the sum of the two smaller ones is 2^a + 2^b. Since a < b, 2^a + 2^b = 2^a (1 + 2^{b-a}) = 2^a (1 + 2^k), where k = b - a > 0. But 2^a (1 + 2^k) < 2^b (since 1 + 2^k < 2^k * 2 = 2^{k+1}, but I'm not sure if this helps directly.

Wait, maybe I should consider that for powers of 2, the largest side will always be less than the sum of the other two if they are different powers. But hold on, 2^0 + 2^1 = 1 + 2 = 3, which is greater than 2^1 = 2, but 2^0 + 2^1 is greater than 2^1. Similarly, 2^1 + 2^2 = 2 + 4 = 6, which is greater than 2^2 = 4. It seems that for any three distinct powers of 2, the sum of the two smaller ones is always greater than the largest one.

Wait, but that can't be right because if I take 2^0 + 2^1 = 1 + 2 = 3, which is greater than 2^1 = 2, but what if I have 2^0 + 2^0 = 1 + 1 = 2, which is equal to 2^1 = 2, but in this problem, all a_i are distinct because they are indexed differently. Wait, no, a_i can be the same according to the problem: 0 ≤ a_i ≤ n, and n can be up to 3*10^5, but a_i can be repeated.

Wait, actually, a_i can be the same, so lengths can be the same. For example, in the first test case, a_i are all 1's, so all sticks have length 2^1 = 2. So, in this case, any three sticks will form a triangle since all sides are equal: 2 + 2 > 2, which is true.

So, in general, if all three sticks have the same length, say 2^k, then 2^k + 2^k > 2^k, which is true as long as 2*2^k > 2^k, which simplifies to 2^k > 0, which is always true for k ≥ 0.

But what if the lengths are different? Let's say I have three sticks with lengths 2^a, 2^b, and 2^c, where a ≤ b ≤ c. Then, the condition for forming a triangle is 2^a + 2^b > 2^c.

Now, since a ≤ b ≤ c, 2^a ≤ 2^b ≤ 2^c. So, 2^a + 2^b ≤ 2*2^b = 2^{b+1}. Now, for 2^a + 2^b > 2^c to hold, we need 2^{b+1} > 2^c, which implies b+1 > c, or c < b+1.

So, the condition for forming a triangle is c < b + 1.

Since a ≤ b ≤ c, and c < b + 1, and since a, b, c are integers, this implies that c ≤ b.

But wait, since a ≤ b ≤ c, and c < b + 1, the only possibility is c ≤ b.

But if c ≤ b, and b ≤ c, then c = b.

So, this would imply that b = c.

Wait, but a ≤ b = c.

So, in this case, we have two sticks of length 2^b and one stick of length 2^a, where a ≤ b.

But earlier, I saw that if a = b = c, then it forms a triangle.

But according to this, as long as c < b + 1, which in integer terms means c ≤ b, it's okay.

So, if a ≤ b ≤ c and c ≤ b, then c = b.

So, in this case, we have a ≤ b = c.

Now, we need to ensure that a + b > c, which is 2^a + 2^b > 2^c.

But since c = b, this becomes 2^a + 2^b > 2^b.

Well, 2^a > 0, so yes, it's always true.

Therefore, as long as a ≤ b = c, it forms a triangle.

Similarly, if a < b = c, it still holds.

Now, what if a < b < c, but c < b + 1?

Wait, but since c is an integer, and c < b + 1 implies c ≤ b.

But c ≤ b contradicts a < b < c.

Wait, no, if a < b < c and c < b + 1, then since c is an integer, c ≤ b, which contradicts c > b.

Therefore, the only way to have a < b < c and c < b + 1 is impossible.

Hence, the only way to form a triangle when a ≤ b ≤ c is when c ≤ b, which implies c = b.

Therefore, in this problem, for the lengths to form a triangle, the maximum length must be less than or equal to the second maximum length.

Wait, but if c = b, then 2^a + 2^b > 2^c = 2^b, which simplifies to 2^a > 0, which is always true.

Therefore, as long as the maximum length is less than or equal to the sum of the other two, which in this case is always true when the maximum is equal to one of the other sides.

So, in other words, for any three sticks where the maximum length is less than or equal to the sum of the other two, which in this case, given the properties of powers of 2, boils down to the maximum length being less than or equal to the second maximum length.

Wait, but that seems off.

Wait, perhaps I need to think differently.

Let me consider that for powers of 2, the sum of any two distinct powers is always greater than the largest one, because 2^a + 2^b > 2^max(a,b), unless a = b.

Wait, no, if a = b, then 2^a + 2^b = 2^{a+1}, which is greater than 2^a.

So, in any case, as long as a ≤ b ≤ c and c < b + 1, which in integer terms is c ≤ b, then 2^a + 2^b > 2^c.

But earlier, I saw that c ≤ b implies c = b, since a ≤ b ≤ c and c ≤ b implies c = b.

Therefore, in this problem, for the sticks to form a triangle, the maximum length must be equal to the second maximum length.

Wait, but that seems too restrictive.

Let me think of an example.

Take n = 4, a_i = [3,2,1,3].

So, lengths are [8,4,2,8].

Now, possible triplets:

(8,4,2): 4 + 2 = 6 < 8 → doesn't form a triangle.

(8,4,8): 4 + 8 > 8 → forms a triangle.

(8,2,8): 2 + 8 > 8 → forms a triangle.

(4,2,8): 2 + 4 = 6 < 8 → doesn't form a triangle.

So, only two valid triplets: (8,4,8) and (8,2,8).

But according to my earlier conclusion, only when the maximum is equal to the second maximum.

Wait, in (8,4,8), the maximum is 8, and the second maximum is also 8.

In (8,2,8), maximum is 8, second maximum is also 8.

In (4,2,8), maximum is 8, second maximum is 4, and 4 + 2 < 8, so doesn't form a triangle.

So, it seems that when the maximum is equal to the second maximum, it forms a triangle, unless the smallest is too small.

But in this case, even if the smallest is small, as long as the two larger ones are equal, it forms a triangle.

Wait, but in this specific case, 2^a + 2^b > 2^c when c = b.

Because 2^a + 2^b > 2^c = 2^b, and since a ≤ b, 2^a > 0, so 2^a + 2^b > 2^b.

Therefore, it always holds when c = b.

So, in other words, for any three sticks where the two largest are equal, it forms a triangle.

But what if the two largest are different?

Wait, in the example above, (8,4,8), two sticks are 8 and one is 4.

But 4 + 8 > 8, which is true.

Similarly, 8 + 8 > 4, and 8 + 4 > 8.

So, it forms a triangle.

But according to my earlier reasoning, it's only when c = b.

Wait, but in this case, c = 8 and b = 8.

So, it fits.

But what if c = b?

Let me consider another example.

Suppose n = 3, a_i = [1,2,3].

Lengths: 2,4,8.

As we saw earlier, 2 + 4 = 6 > 8? No, 6 < 8, so doesn't form a triangle.

Similarly, n = 1, a_i = [1], only one stick, can't form a triangle.

n = 3, a_i = [1,2,2].

Lengths: 2,4,4.

Check 2 + 4 > 4 → 6 > 4, true.

4 + 4 > 2 → 8 > 2, true.

2 + 4 > 4 → 6 > 4, true.

So, forms a triangle.

Similarly, n = 4, a_i = [2,2,2,3].

Lengths: 4,4,4,8.

Check triplets:

(4,4,4): forms a triangle.

(4,4,8): 4 + 4 = 8 → not greater than 8, so doesn't form a triangle.

(4,4,8): same.

(4,4,8): same.

So, only one valid triplet: (4,4,4).

Wait, but according to my earlier conclusion, when c = b, it forms a triangle, unless a is too small.

But in this case, a = 4, b = 4, c = 8, but 4 + 4 = 8, which is not greater than 8.

Wait, that's interesting.

So, in this case, c = b, but a + b = c, which is not greater than c.

Wait, but earlier I thought that as long as c = b, it forms a triangle, but this is a counterexample.

Wait, no, in this case, c = b, but a + b = c, which is not greater than c.

Wait, but in the problem, a_i can be repeated, but the exponents can lead to a + b = c.

So, in this case, when c = b, and a < b, then a + b = a + b, which may or may not be greater than c.

Wait, but in this specific case, a = b = c, then a + b = 2b, which is greater than c = b, since 2b > b.

But in the case where a < b = c, a + b may or may not be greater than c.

Wait, but in the example above, a = 4, b = 4, c = 8, but a + b = 4 + 4 = 8, which is not greater than c = 8.

So, in this case, it doesn't form a triangle.

Wait, but according to the earlier reasoning, when c = b, it should form a triangle.

But in this case, it doesn't.

So, perhaps my earlier reasoning is incomplete.

Let me think again.

Given a ≤ b ≤ c and c ≤ b, which implies c = b.

Then, a + b > c becomes a + b > b, which simplifies to a > 0, which is always true since a_i ≥ 0 and 2^a > 0.

But in the example above, a = 4, b = 4, c = 8, which corresponds to a_i = [2,2,3].

So, a = 2, b = 2, c = 3.

Wait, but 2^2 + 2^2 = 4 + 4 = 8, which is equal to 2^3 = 8.

So, 4 + 4 = 8, which is not greater than 8.

Hence, it doesn't form a triangle.

But according to my earlier reasoning, c = b implies c ≤ b, which should mean c = b, and a + b > c should be a + b > b, which is a > 0.

But in this case, a = b = c, but 2^a + 2^b = 2^{b+1}, which may or may not be greater than 2^c, depending on the values.

Wait, hold on.

If c = b, then a + b > c becomes a + b > b, which is a > 0.

But in terms of exponents, if c = b, then 2^a + 2^b > 2^c becomes 2^a + 2^b > 2^b, which simplifies to 2^a > 0, which is always true.

But in reality, if a < b = c, then 2^a + 2^b = 2^a + 2^b.

But in the example above, a = 2, b = 2, c = 3, which corresponds to lengths 4,4,8.

4 + 4 = 8, which is not greater than 8.

Wait, but according to the exponents, a = 2, b = 2, c = 3, and 2^a + 2^b = 2^2 + 2^2 = 4 + 4 = 8, which is equal to 2^c = 2^3 = 8.

So, it doesn't satisfy the strict inequality 2^a + 2^b > 2^c.

Hence, it doesn't form a triangle.

But according to the earlier reasoning, a + b > c implies a > 0, which is true, but in terms of exponents, it's not sufficient.

So, perhaps I need to consider the exponents more carefully.

Let me consider the exponents.

Given a ≤ b ≤ c, we need to have 2^a + 2^b > 2^c.

I can write this inequality in terms of exponents.

First, 2^a + 2^b > 2^c.

If a < b, then 2^a + 2^b = 2^a (1 + 2^{b-a}) = 2^a * (1 + 2^k), where k = b - a > 0.

So, 2^a * (1 + 2^k) > 2^c.

But c ≥ b, so c ≥ b > a.

So, 2^a * (1 + 2^k) > 2^c ≥ 2^b = 2^{a + k}.

So, 2^a * (1 + 2^k) > 2^{a + k}.

Divide both sides by 2^a: 1 + 2^k > 2^k.

Which simplifies to 1 > 0, which is always true.

Hence, as long as a < b ≤ c, the inequality holds.

But wait, in the earlier example, a = 2, b = 2, c = 3, which has a = b < c, and in that case, 2^a + 2^b = 2^b + 2^b = 2^{b+1}.

So, 2^{b+1} > 2^c.

Which implies b + 1 > c.

So, in this case, c < b + 1.

In the example, c = 3 and b = 2, so 3 < 3, which is not true.

Hence, it doesn't form a triangle.

So, in this case, a = b < c, and c < b + 1.

But c = 3 and b = 2, so c = b + 1, which is not less than b + 1.

Hence, it doesn't satisfy the inequality.

Therefore, the condition should be c < b + 1.

So, in general, for a ≤ b ≤ c, the condition for forming a triangle is c < b + 1.

In terms of exponents, c < b + 1.

Given that a ≤ b ≤ c, and c < b + 1.

So, c ≤ b.

But c ≥ b, so c = b.

Hence, c = b.

Therefore, for a ≤ b ≤ c and c = b, which implies a ≤ b = c.

But in this case, 2^a + 2^b = 2^a + 2^b.

If a < b = c, then 2^a + 2^b = 2^a + 2^b.

And 2^a + 2^b > 2^c = 2^b.

Which simplifies to 2^a > 0, which is always true.

But in the earlier counterexample, a = b = c, which is possible if a_i are equal.

Wait, no, in the counterexample, a = b < c, specifically a = b = 2, c = 3.

So, a < b = c is not holding because a = b.

Wait, in that case, a = b = c, which implies a = b = c.

But in terms of exponents, if a = b = c, then 2^a + 2^b = 2^{a+1}, and 2^c = 2^a.

So, 2^{a+1} > 2^a, which is true.

Hence, it forms a triangle.

But in the earlier example, a = 2, b = 2, c = 3, which is a = b < c.

In this case, 2^a + 2^b = 2^{a+1} = 2^{3} = 8, and 2^c = 8, so 8 > 8 is false.

Hence, it doesn't form a triangle.

Wait, but according to c < b + 1, c < b + 1 implies c < 2 + 1 = 3, which would mean c < 3.

But in this case, c = 3, which is not less than 3.

Hence, it doesn't satisfy the condition.

Therefore, the condition is c < b + 1.

So, in general, for a ≤ b ≤ c, the condition for forming a triangle is c < b + 1.

Hence, in terms of exponents, for a ≤ b ≤ c, the triplet forms a triangle if c < b + 1.

Therefore, in the code, we need to count the number of triplets where c < b + 1, given a ≤ b ≤ c.

Now, to implement this efficiently, considering the constraints (t up to 10^4 and n up to 3*10^5 with sum of n over all t <= 3*10^5), we need an efficient way to count such triplets.

One way is to sort the a_i in non-decreasing order, then for each c, find the number of pairs (a,b) where a ≤ b ≤ c and c < b + 1.

Wait, but c < b + 1 implies c ≤ b, since c and b are integers.

But c ≤ b and a ≤ b.

So, essentially, we need to count the number of triplets where a ≤ b ≥ c.

Wait, but a ≤ b ≤ c and c ≤ b implies c = b.

Hence, we need to count the number of triplets where a ≤ b = c.

So, for each value of b, count the number of a's ≤ b and the number of c's = b.

Then, for each b, the number of ways is choose(number of a's ≤ b, 1) * choose(number of c's = b, 2).

Because we need to choose one a ≤ b and two c's equal to b.

Wait, but in terms of exponents, it's a bit tricky.

Let me think differently.

Let me sort the a_i in non-decreasing order.

Then, for each c, find the number of pairs (a,b) where a ≤ b ≤ c and c < b + 1.

Given that a ≤ b ≤ c and c < b + 1, which implies c ≤ b.

But c ≤ b and a ≤ b, with c = b.

Hence, a ≤ b = c.

So, for each b = c, count the number of a's ≤ b.

Hence, for each b, count the number of a's ≤ b, and then multiply by the number of ways to choose two c's equal to b.

So, for each unique b, count the number of a's ≤ b and the frequency of b.

Then, for each b, add freq_b * (freq_b - 1) / 2 * count_a_leq_b to the result.

But we have to make sure that a ≤ b.

Wait, but a ≤ b, and b = c.

So, for each b, count_a_leq_b is the number of a's ≤ b.

Then, the number of ways to choose two c's equal to b is freq_b * (freq_b - 1) / 2.

Then, for each b, add count_a_leq_b * (freq_b * (freq_b - 1) / 2) to the result.

This seems correct.

But in the earlier example, n = 4, a_i = [3,2,1,3].

Sorted a_i = [1,2,3,3].

So, b = 3, freq_b = 2.

count_a_leq_b = number of a's ≤ 3, which is all of them: 4.

So, res += 4 * (2 * 1 / 2) = 4 * 1 = 4.

But in reality, there are only 2 valid triplets.

So, this approach overcounts.

Wait, perhaps I need to adjust it.

Alternatively, perhaps it's better to consider combinations where at least two sticks have the same exponent.

Wait, but in the example above, (8,4,8): here, two sticks have a_i=3 and one has a_i=2.

Similarly, (8,2,8): same as above.

So, in this case, for b=3, freq_b=2, count_a_leq_b=3 (since a_i=1,2,3 ≤ 3).

So, res += 3 * (2 * 1 / 2) = 3 * 1 = 3.

But in reality, there are only 2 triplets.

Still not matching.

Hence, perhaps this approach is incorrect.

Let me think differently.

Let me consider frequency counts of each a_i.

Let freq[x] be the frequency of a_i = x.

Then, the number of ways to choose three sticks with a_i = x is freq[x] choose 3.

Similarly, the number of ways to choose two sticks with a_i = x and one with a_i = y, where y < x and x < x + 1.

Wait, but it's getting complicated.

Alternatively, perhaps it's better to iterate over all possible triplets and check the condition, but that would be O(n^3), which is too slow.

Given the constraints, I need a faster approach.

Let me consider sorting the a_i in non-decreasing order.

Then, for each c, find the number of pairs (a,b) where a ≤ b ≤ c and c < b + 1.

Wait, c < b + 1 implies c ≤ b.

Hence, a ≤ b = c.

So, for each b = c, count the number of a's ≤ b.

Hence, if I group the a_i by their value, I can precompute the prefix sums of the frequencies.

Let me try to implement this idea.

First, sort the a_i in non-decreasing order.

Compute the frequency of each a_i.

Then, for each unique a_i, say x, count the number of a's ≤ x.

This is the prefix sum up to x.

Then, for each x, the number of ways is freq[x] choose 2 * (prefix[x] - freq[x]).

Wait, no.

Wait, for each x, the number of ways to choose two c's equal to x and one a ≤ x is choose(freq[x], 2) * (prefix[x] - freq[x]).

But in the earlier example, a_i = [1,2,3,3].

Sorted.

freq[1] = 1

freq[2] = 1

freq[3] = 2

prefix[1] = 1

prefix[2] = 2

prefix[3] = 4

Then, for x=3, choose(2,2) * (4 - 2) = 1 * 2 = 2.

Which matches the expected answer of 2.

Perfect.

Similarly, for x=2, choose(1,2) * (2 - 1) = 0 * 1 = 0.

For x=1, choose(1,2) * (1 - 1) = 0 * 0 = 0.

Hence, total res = 2.

Similarly, for n=7, a_i=[1,1,1,1,1,1,1], sorted a_i=[1,1,1,1,1,1,1].

freq[1]=7

prefix[1]=7

choose(7,2) * (7 - 7) = 21 * 0 = 0.

But according to the problem, in this case, any three sticks form a triangle.

Wait, that's a problem.

Wait, in this case, all a_i=1, so all lengths are 2^1=2.

Hence, any three sticks have lengths 2,2,2.

Which satisfies 2 + 2 > 2, so they form a triangle.

Hence, the number of ways should be choose(7,3)=35.

But according to the above formula, it's 0.

Hence, the formula is missing something.

Wait, perhaps I need to adjust the formula.

Wait, in this case, a=b=c=1.

So, c=b=1, and a ≤ b=1.

Hence, for x=1, freq[1]=7, prefix[1]=7.

Then, choose(7,2)*(7-7)=21*0=0.

But it should be choose(7,3)=35.

So, the formula is incomplete.

Hence, perhaps I need to consider the case where a ≤ b = c.

In this case, when a < b = c, use the previous formula.

But when a = b = c, add choose(freq[x],3).

So, for each x, res += choose(freq[x],3) + choose(freq[x],2) * (prefix[x] - freq[x]).

In the first test case, x=1, freq[1]=7, prefix[1]=7.

choose(7,3)=35 + choose(7,2)*(7-7)=21*0=0.

Hence, res=35.

In the second test case, x=1: freq[1]=1, prefix[1]=1.

choose(1,3)=0 + choose(1,2)*(1-1)=0*0=0.

x=2: freq[1]=1, prefix[2]=2.

choose(1,3)=0 + choose(1,2)*(2-1)=0*1=0.

x=3: freq[2]=2, prefix[3]=4.

choose(2,3)=0 + choose(2,2)*(4-2)=1*2=2.

Hence, total res=0+0+2=2.

Which matches the expected output.

Perfect.

Hence, the correct formula is:

For each unique x in a_i, sorted in non-decreasing order:

res += choose(freq[x],3) + choose(freq[x],2) * (prefix[x] - freq[x])

Where prefix[x] is the total number of a_i ≤ x.

This way, we account for both the cases where a < b = c and a = b = c.

Now, to implement this efficiently, I can sort the a_i and compute prefix sums.

Then, iterate through each unique x, compute freq[x], and add choose(freq[x],3) + choose(freq[x],2) * (prefix[x] - freq[x]) to the result.

Given that n can be up to 3*10^5 and t up to 10^4, with sum of n over t ≤ 3*10^5, this should be efficient enough.

Now, let's look at the given code and see if it implements this correctly.

Looking at the code:

def func_1(test_cases):

results = []

for _ in range(test_cases):

n = int(input())

num_list = list(map(int, input().split()))

num_of_lens = {}

for x in num_list:

if x in num_of_lens:

num_of_lens[x] += 1

else:

num_of_lens[x] = 1

res = 0

total_count = 0

for cnt in num_of_lens.values():

if cnt >= 3:

res += cnt * (cnt - 1) * (cnt - 2) // 6

if cnt >= 2:

res += cnt * (cnt - 1) // 2 * total_count

total_count += cnt

results.append(res)

for result in results:

print(result)

So, it reads the test cases, for each test case, reads n and the list of a_i.

Then, it counts the frequency of each a_i using a dictionary num_of_lens.

Then, initializes res=0 and total_count=0.

Then, iterates over the frequencies (cnt):

If cnt >= 3, adds choose(cnt,3) to res.

If cnt >= 2, adds choose(cnt,2) * total_count to res.

Then, adds cnt to total_count.

Finally, appends res to results.

After processing all test cases