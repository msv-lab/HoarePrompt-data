Alright, I have this problem to solve. Let's read it carefully.

We have a village with n houses, and the villagers want to build a big road that divides the village into left and right sides. Each resident wants to live on either the left or the right side, represented by a sequence a1 to an, where 0 means left and 1 means right.

The road can be built between any two houses, or before the first house or after the last house. So, the positions where the road can be built are from position 0 (before the first house) to position n (after the last house).

For each possible position i where the road is built, the houses from 1 to i are on the left side, and the houses from i+1 to n are on the right side.

The goal is to choose the position i such that:

- At least half of the residents on the left side are satisfied with being on the left side (i.e., have a_j = 0).

- At least half of the residents on the right side are satisfied with being on the right side (i.e., have a_j = 1).

Additionally, among all such positions that satisfy these conditions, we want the one where the road is as close as possible to the middle of the village. Specifically, we want to minimize the absolute difference between i and n/2. If there are multiple positions with the same minimum difference, we choose the smaller i.

Input:

- The first line contains the number of test cases t.

- For each test case:

- The first line contains an integer n (3 ≤ n ≤ 3*10^5).

- The second line contains a string of length n consisting of 0s and 1s, representing the preferences of the residents.

Constraints:

- The sum of n over all test cases does not exceed 3*10^5.

Output:

- For each test case, output a single integer i representing the position after which the road should be built. If the road should be built before the first house, output 0.

Example:

Input:

7

3

101

6

010111

6

011001

3

000

3

110

3

001

4

1100

Output:

2

3

2

3

0

1

0

Explanation for the first test case:

n = 3, s = "101"

- If road is built at position 0 (before the first house):

Left side: no houses

Right side: houses 1,0,1

Need at least ceil(3/2) = 2 ones on the right side. We have two ones, so it's acceptable.

- If road is built at position 1 (after the first house):

Left side: house 1 (wants right), so 0 satisfied (need at least ceil(1/2) = 1), which is not acceptable.

Right side: houses 0,1 (one wants left, one wants right), so one satisfied (ceil(2/2) = 1), which is acceptable.

But left side is not acceptable, so this position is invalid.

- If road is built at position 2:

Left side: houses 1,0 (one wants right, one wants left), so one satisfied (ceil(2/2) = 1), acceptable.

Right side: house 1 (wants right), one satisfied (ceil(1/2) = 1), acceptable.

- If road is built at position 3:

Left side: houses 1,0,1 (two wants right, one wants left), two satisfied (ceil(3/2) = 2), acceptable.

Right side: no houses.

So positions 2 and 3 are acceptable.

Among these, position 2 is closer to n/2 = 1.5 than position 3.

So the answer is 2.

Approach:

To solve this problem, we need to find the optimal position to build the road such that the number of satisfied residents on each side meets the given conditions, and the road is as close as possible to the middle of the village.

### Approach

1. **Initialization**:
   - Read the number of test cases.
   - For each test case, read the number of houses \( n \) and the string representing the preferences of the residents.

2. **Precompute Prefix Sums**:
   - Calculate prefix sums for the number of zeros (0) and ones (1) on the left and right sides of the road for all possible positions.

3. **Check Conditions**:
   - For each possible position \( i \) (from 0 to n), check if at least half of the residents on each side are satisfied with their side.
   - Track the position that minimizes the absolute difference from the middle of the village.

4. **Output the Result**:
   - Print the optimal position for each test case.

### Solution Code

```python
def func():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    t = int(data[idx])
    idx += 1
    for _ in range(t):
        n = int(data[idx])
        idx += 1
        s = data[idx]
        idx += 1
        # Precompute prefix sums
        prefix_zero = [0] * (n + 1)
        prefix_one = [0] * (n + 1)
        for i in range(n):
            if s[i] == '0':
                prefix_zero[i + 1] = prefix_zero[i] + 1
                prefix_one[i + 1] = prefix_one[i]
            else:
                prefix_zero[i + 1] = prefix_zero[i]
                prefix_one[i + 1] = prefix_one[i] + 1
        # Find the optimal position
        min_diff = float('inf')
        best_i = -1
        for i in range(n + 1):
            left_size = i
            right_size = n - i
            left_zeros = prefix_zero[i]
            right_ones = prefix_one[n] - prefix_one[i]
            # Check conditions
            if left_size == 0:
                left_satisfied = True
            else:
                left_satisfied = left_zeros >= (left_size + 1) // 2
            if right_size == 0:
                right_satisfied = True
            else:
                right_satisfied = right_ones >= (right_size + 1) // 2
            if left_satisfied and right_satisfied:
                current_diff = abs(i - (n / 2))
                if current_diff < min_diff:
                    min_diff = current_diff
                    best_i = i
                elif current_diff == min_diff:
                    best_i = min(best_i, i)
        print(best_i)

if __name__ == "__main__":
    func()
```

### Explanation

1. **Initialization**:
   - Read the input values and initialize variables.

2. **Prefix Sum Calculation**:
   - Use prefix sums to efficiently calculate the number of zeros and ones on the left and right sides for any position \( i \).

3. **Condition Checking**:
   - For each position \( i \), calculate the number of satisfied residents on both sides.
   - Check if the number of satisfied residents meets or exceeds half of the residents on each side.
   - Track the position \( i \) that minimizes the absolute difference from \( n/2 \).

4. **Output**:
   - Print the optimal position \( i \) for each test case.

This approach ensures that the solution is efficient and scalable, given the constraints.