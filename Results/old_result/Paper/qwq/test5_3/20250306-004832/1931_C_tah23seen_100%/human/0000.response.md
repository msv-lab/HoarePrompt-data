Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I can perform an operation at most once. This operation involves selecting three integers: i, j, and x, where 1 â‰¤ i â‰¤ j â‰¤ n, and then setting all elements from index i to j to the value x. The cost of this operation is (j - i + 1) burles, which is basically the number of elements being set to x.

My goal is to make all elements of the array equal, and I need to find the least amount of burles I have to spend to achieve this. It's guaranteed that I can always make all elements equal, so I don't need to worry about cases where it's impossible.

First, I need to understand what's the best strategy here. Since I can perform the operation at most once, I need to choose the subarray [i, j] in such a way that setting it to x minimizes the cost, and after this operation, all elements in the array are equal.

Let me think about what it means for all elements to be equal after at most one operation. There are a few scenarios to consider:

1. **All elements are already equal:** In this case, I don't need to perform any operation, so the cost is 0.

2. **Elements are not all equal, but I can make them equal by setting a certain subarray to a particular value x.** Here, I need to choose i, j, and x such that after setting arr[i..j] to x, all elements become equal, and the cost (j - i + 1) is minimized.

I need to find the minimum cost among all possible operations that can make the array uniform.

Let me consider some examples to get a better understanding.

**Example 1:**

Input:

6

1 2 3 4 5 1

Output:

4

Explanation:

If I set arr[2..4] to 8, the array becomes [1,8,8,8,5,1]. But this doesn't make all elements equal. So, this might not be the optimal choice.

Wait, the sample input shows that for this array, the output is 4. So, perhaps there's a better way.

Let me think differently. Maybe instead of choosing x as a new value not in the array, I can choose x to be one of the existing values in the array.

For instance, if I choose to set arr[1..5] to 1, the array becomes [1,1,1,1,1,1], with a cost of 5. But apparently, there's a better way since the output is 4.

Wait, maybe setting arr[2..5] to 1 would make [1,1,1,1,1,1], with a cost of 4. That seems to match the sample output.

So, in this case, setting the subarray from index 2 to 5 (1-based indexing) to 1 costs 4 burles and makes the entire array equal to 1.

**Example 2:**

Input:

7

1 1 1 1 1 1 1

Output:

0

Explanation:

All elements are already equal, so no operation is needed.

**Example 3:**

Input:

8

8 8 8 1 2 8 8 8

Output:

2

Explanation:

Here, if I set arr[4..5] to 8, the array becomes [8,8,8,8,8,8,8,8], with a cost of 2.

**Example 4:**

Input:

1

1

Output:

0

Explanation:

Only one element, already equal.

**Example 5:**

Input:

2

1 2

Output:

1

Explanation:

Set arr[1..1] to 2, making the array [2,2], with a cost of 1.

Alternatively, set arr[2..2] to 1, making [1,1], with a cost of 1.

So, the minimal cost is 1.

**Example 6:**

Input:

3

1 2 3

Output:

2

Explanation:

Set arr[1..2] to 3, making [3,3,3], with a cost of 2.

Alternatively, set arr[2..3] to 1, making [1,1,1], with a cost of 2.

So, minimal cost is 2.

**Example 7:**

Input:

7

4 3 2 7 1 1 3

Output:

6

Explanation:

Not sure, but perhaps setting arr[1..6] to 1, making [1,1,1,1,1,1,3], and then since all elements are not equal, but according to the problem, one operation is enough. Wait, the output is 6, which is the cost of setting arr[1..6] to 1.

**Example 8:**

Input:

9

9 9 2 9 2 5 5 5 3

Output:

7

Explanation:

Not sure, but perhaps setting arr[3..9] to 9, making [9,9,9,9,9,9,9,9,9], with a cost of 7.

Wait, but the output is 7, which matches this.

From these examples, it seems that the strategy is to find a subarray to set to a value such that the remaining elements are already equal to that value, or to set the subarray in such a way that all elements become equal.

But I need a more concrete approach.

Let me consider that after the operation, all elements should be equal to some value x. Then, I need to choose a subarray [i, j] and set arr[i..j] to x, such that all elements outside this subarray are already equal to x, and the elements inside the subarray can be set to x with a cost of (j - i + 1).

So, to minimize the cost, I need to maximize the number of elements that are already equal to x, so that the subarray I need to set is as small as possible.

Wait, but I can choose x to be any integer, not necessarily existing in the array.

Hmm.

Wait, the problem states that I can choose x to be any integer, but in the constraints, a_i >=1 and a_i <=n, so x can be in that range.

But, to minimize the cost, perhaps choosing x to be the most frequent value in the array would be beneficial.

Wait, but in the first example, the array is [1,2,3,4,5,1], and setting arr[2..4] to 1 would make [1,1,1,1,5,1], and then set arr[5] to 1 in another operation, but I can only perform one operation.

Wait, no, in the first example, setting arr[2..5] to 1 makes [1,1,1,1,1,1], with a cost of 4.

So, in this case, x is 1.

Another approach: find the largest subarray where the elements are already equal to x, and set the remaining elements to x.

Wait, but I can only perform one operation.

Wait, perhaps it's better to think in terms of making the entire array equal to x, and finding the minimal cost to do so with at most one operation.

Let me consider that I want the final array to be all x.

Then, I need to set some subarray to x, and the rest should already be x.

So, the cost is the length of the subarray that needs to be set to x.

To minimize this, I need to maximize the number of elements that are already x.

So, the minimal cost is n - frequency of x in the array.

But wait, no. Because if I set a subarray to x, the elements outside that subarray must already be x.

Wait, no. Let me think again.

Suppose I choose to make the entire array equal to x.

I can set a subarray [i,j] to x, and the elements outside this subarray must already be x.

So, the cost is (j - i + 1), and I need to choose [i,j] such that all elements outside [i,j] are already x.

To minimize the cost, I need to maximize the length of the subarray [i,j] that needs to be set to x, but in reality, to minimize the cost, I need to minimize (j - i + 1), which means minimizing the subarray length.

Wait, that doesn't make sense.

Wait, actually, to minimize the cost, I need to minimize the length of the subarray that needs to be set.

But, I need to ensure that after setting this subarray to x, all elements in the array are x.

So, the elements outside this subarray must already be x.

Therefore, to minimize the cost, I need to maximize the number of elements that are already x, so that the subarray I need to set is as small as possible.

Therefore, for a given x, the minimal cost is n - frequency(x), because I need to set all elements that are not x to x.

But wait, with only one operation, I can set a subarray to x, and the elements outside that subarray must already be x.

So, the minimal cost is the size of the subarray that needs to be set to x, which is n - the number of elements that are already x.

Wait, but that seems incorrect because in the first example, n=6, frequency of 1 is 2, so n - frequency(1) = 4, which matches the sample output.

Similarly, in example 5, n=2, frequency of 1 is 1, so n -1 =1, which matches the output.

In example 6, n=3, frequency of 1 is 1, so n-1=2, which matches.

In example 7, n=7, frequency of 1 is 2, so n-2=5, but the output is 6. Hmm, that doesn't match.

Wait, perhaps I'm missing something.

Wait, in example 7, array is [4,3,2,7,1,1,3], frequency of 1 is 2, so n - frequency(1) =5, but output is 6.

So, perhaps choosing x=1 is not optimal.

Wait, but the output is 6, which is larger than n - max frequency.

Wait, maybe I need to choose x to be the value that maximizes the frequency, but in this case, frequency of 1 is 2, frequency of 3 is 2, frequency of 2 is 1, frequency of 4 is 1, frequency of 7 is 1.

So, choosing x=1 or x=3 both give n -2 =5, but the output is 6.

Wait, maybe I'm miscalculating something.

Wait, perhaps I need to consider that the subarray I set to x should cover all elements that are not equal to x.

Wait, that makes more sense.

So, to make the entire array equal to x, I need to set all elements that are not x to x.

But I can only perform one operation, which is setting a contiguous subarray to x.

Therefore, I need to choose a subarray [i,j] such that all elements outside [i,j] are already x.

So, to minimize the cost, which is (j - i +1), I need to maximize the number of elements that are already x, and minimize the subarray that needs to be set.

Wait, but in example 7, if I choose x=1, then I need to set all elements from index 1 to 5 to 1, which is a subarray of length 5, but the output is 6.

Wait, maybe I need to set a larger subarray.

Wait, perhaps I need to set from index 1 to 6, which has length 6, making the array [1,1,1,1,1,1,3], but then I still have to set the last element to 1 in another operation, but I can only perform one operation.

Wait, perhaps I'm misunderstanding the problem.

Wait, the problem allows at most one operation, meaning I can perform the operation zero or one time.

So, if I perform zero operations, that's only possible if the array is already uniform.

If I perform one operation, I can set any subarray to x, and the cost is the length of the subarray.

My goal is to make the entire array equal to x after at most one operation.

So, I can choose to perform zero operations if the array is already uniform, or one operation otherwise.

Therefore, the minimal cost is zero if the array is already uniform, or the minimal cost among all possible x and subarrays [i,j] such that setting arr[i..j] to x makes the entire array equal to x.

Wait, perhaps I need to find, for each possible x, the minimal subarray [i,j] such that all elements outside [i,j] are already equal to x, and then choose the x and [i,j] that minimizes (j - i +1).

Then, among all possible x, choose the one that gives the smallest (j - i +1).

In the first example, for x=1, I need to set arr[2..5] to 1, which has length 4.

For x=2, I need to set arr[1..4] and arr[6..6] to 2, but I can only perform one operation, so that's not possible.

Wait, no. For x=2, the elements that are not 2 are at positions 1,5,6.

So, to make the entire array equal to 2, I need to set arr[1,5,6] to 2.

But I can only set one subarray to 2.

So, I need to choose a subarray that covers all non-2 elements.

The non-2 elements are at positions 1,5,6.

So, to cover positions 1,5,6 with one subarray, I would need to set arr[1..6] to 2, which has length 6.

Then, the array becomes [2,2,2,2,2,2], which is uniform.

So, the cost is 6.

But in the first example, the output is 4, which is better than 6, so choosing x=1 is better.

Wait, but for x=1, I only need to set arr[2..5] to 1, which covers positions 2,3,4,5, making the array [1,1,1,1,1,1], with a cost of 4.

Similarly, for x=5, non-5 elements are positions 1,2,3,4,6, which would require setting arr[1..6] to 5, with a cost of 6.

So, choosing x=1 is better.

Hence, for each x, I need to find the minimal subarray that covers all non-x elements.

Wait, but in the seventh example, choosing x=1 gives a cost of 5, but the output is 6.

Wait, perhaps I need to choose x to be the value that appears the most, but in example 7, choosing x=1 gives a cost of 5, but the output is 6.

Wait, maybe I'm miscalculating.

Wait, in example 7, array is [4,3,2,7,1,1,3].

If I choose x=1, non-1 elements are at positions 1,2,3,4,5,7.

So, to cover positions 1,2,3,4,5,7 with one subarray, I would need to set arr[1..7] to 1, which has length 7.

But according to the sample output, it's 6.

Wait, but output is 6, which is less than 7.

So, perhaps there's a better way.

Wait, maybe choosing x=3.

Non-3 elements are at positions 1,3,4,5,6.

So, to cover positions 1,3,4,5,6 with one subarray, I would need to set arr[1..6] to 3, which has length 6.

Then, the array becomes [3,3,3,3,3,3,3], which is uniform.

Hence, the cost is 6, which matches the sample output.

So, in this case, choosing x=3 is better than choosing x=1.

Wait, but according to my earlier logic, for x=1, I need to set arr[1..7] to 1, which costs 7, but for x=3, setting arr[1..6] to 3 costs 6.

Hence, the minimal cost is 6.

So, my earlier assumption that choosing x with the highest frequency isn't always optimal.

Wait, in this case, frequency of 1 and 3 are both 2.

So, perhaps choosing x=3 is better because the non-3 elements are clustered in a smaller subarray.

Hence, I need to find, for each x, the minimal subarray [i,j] that covers all non-x elements.

Then, the cost is (j - i +1).

Then, among all x, choose the one with the minimal (j - i +1).

So, to implement this, for each x, find the minimal subarray that covers all positions where arr[k] != x.

This can be done by finding the minimal window that includes all non-x elements.

But, finding this for each x separately seems inefficient, especially since n can be up to 2e5 and t up to 1e4.

I need a more efficient approach.

Let me consider that in order to make the entire array equal to x, I need to set a subarray that covers all positions where arr[k] != x.

So, for each x, the minimal subarray to cover all non-x elements is the minimal window that includes all arr[k] != x.

To find this minimal window for each x separately would be too slow for the given constraints.

Is there a smarter way to approach this?

Let me think differently.

Suppose I fix the subarray [i,j], and set it to some x.

Then, all elements outside [i,j] must already be equal to x.

So, for the subarray [i,j], x must be equal to the value of all elements outside [i,j].

Hence, x must be the value that all elements outside [i,j] have.

But, in general, elements outside [i,j] can have different values, but to make them all equal, they must all be equal to x.

Wait, but if I set [i,j] to x, then the elements outside [i,j] must already be x.

So, to choose [i,j], all elements outside [i,j] must be equal to x.

Hence, all elements outside [i,j] must be equal to each other.

So, for a given subarray [i,j], the elements outside [i,j] must be all equal.

Hence, to make all elements equal, I need to choose [i,j] such that all elements outside [i,j] are already equal.

Then, set [i,j] to the value of the elements outside [i,j].

The cost is (j - i +1).

So, to minimize the cost, I need to minimize (j - i +1), which means choosing the smallest possible [i,j].

But, the smallest [i,j] would be when [i,j] is as small as possible.

Wait, but I need to choose [i,j] such that all elements outside [i,j] are equal.

So, perhaps I can find the minimal subarray [i,j] such that all elements outside [i,j] are equal.

Then, set [i,j] to that equal value.

Hence, the cost is (j - i +1).

To minimize this, I need to minimize (j - i +1), which is equivalent to minimizing the length of [i,j].

But, I need to ensure that all elements outside [i,j] are equal.

So, perhaps I can find the minimal subarray to remove such that the remaining elements are all equal.

This sounds similar to finding the minimal subarray to remove to make the remaining array consist of equal elements.

Hence, the minimal cost is the minimal length of such a subarray.

So, for each test case, I need to find the minimal length of a subarray [i,j] such that all elements outside [i,j] are equal.

If all elements are already equal, then the cost is 0.

Otherwise, I need to find the minimal (j - i +1) such that all elements outside [i,j] are equal.

To implement this efficiently, I need an efficient way to find, for each possible window size, if there exists a window [i,j] such that all elements outside [i,j] are equal.

But this seems inefficient for the given constraints.

An alternative approach is to find the minimal window size such that all elements outside this window are equal.

To do this efficiently, I can consider the following:

- Find the minimal i and maximal j such that all elements from 1 to i and from j to n are equal.

- Then, the minimal window to set is from i+1 to j-1.

Wait, perhaps not.

Let me think differently.

Suppose I fix the left boundary i, and find the minimal j such that all elements from j to n are equal to the elements from 1 to i.

Wait, maybe not.

Another way is to find the prefix and suffix where all elements are equal, and then the window to set is between the end of the prefix and the start of the suffix.

For example, in [1,2,3,4,5,1], the prefix where all elements are equal to the first element is [1], and the suffix where all elements are equal to the last element is [1], so the window to set is from index 2 to 5, with length 4.

In [8,8,8,1,2,8,8,8], the prefix is [8,8,8], and the suffix is [8,8,8], so the window is from index 4 to 5, with length 2.

In [4,3,2,7,1,1,3], the prefix is [4], and the suffix is [3], which are different, so I need to set the entire middle part from index 1 to 7, with length 7.

Wait, but the sample output is 6, so perhaps this approach is incorrect.

Wait, in [4,3,2,7,1,1,3], if I set [1,6] to 3, making [3,3,3,3,3,3,3], with a cost of 6.

So, in this case, the prefix is [4], the suffix is [3], and the window is [1,6], which has length 6.

Hence, the minimal cost is 6.

Similarly, in [1,2,3,4,5,1], prefix is [1], suffix is [1], so window is [2,5], length 4.

In [8,8,8,1,2,8,8,8], prefix is [8,8,8], suffix is [8,8,8], so window is [4,5], length 2.

In [1], prefix and suffix are [1], so window is empty, cost 0.

In [1,2], prefix is [1], suffix is [2], so window is [1,2], length 2.

Wait, but according to the sample, for [1,2], the output is 1, not 2.

Wait, perhaps I need to choose x to be one of the existing elements.

Wait, in [1,2], if I set [1,1] to 2, cost is 1, making [2,2].

Alternatively, set [2,2] to 1, cost is 1, making [1,1].

Hence, minimal cost is 1.

So, in this case, choosing x to be one of the existing elements and setting the other element to x with cost 1 is better than setting the entire array to x with cost 2.

Wait, but according to my earlier approach, the prefix is [1], suffix is [2], so the window is [1,2], with length 2, but the minimal cost is 1.

So, my earlier approach is incorrect.

Hence, I need a different strategy.

Let me consider that if the first and last elements are equal, then I can set a window that covers all elements that are not equal to the first/last element.

Otherwise, if the first and last elements are different, I need to choose x to be one of them and set the window accordingly.

So, perhaps:

- If arr[0] == arr[n-1], then find the minimal window that covers all elements that are not equal to arr[0].

- Else, if arr[0] != arr[n-1], then I need to choose x to be either arr[0] or arr[n-1], and set the window accordingly.

Wait, but in the sample input where arr=[4,3,2,7,1,1,3], arr[0]=4, arr[n-1]=3, different, so I need to choose x to be either 4 or 3.

- If x=4, then I need to set all elements from arr[1] to arr[6] to 4, which has length 6.

- If x=3, set arr[1] to arr[6] to 3, which has length 6.

But the sample output is 6, which matches.

Wait, but earlier I thought setting arr[1..6] to 3 gives cost 6, which makes [3,3,3,3,3,3,3], which is uniform.

Alternatively, is there a way to make it uniform with cost less than 6?

Wait, no, because if I choose x=1, then I need to set arr[1..4] and arr[7] to 1, but I can only perform one operation.

Hence, I need to set arr[1..7] to 1, which has length 7, which is worse than 6.

Hence, 6 is the minimal cost.

So, perhaps my initial approach is correct.

Hence, the approach is:

- If arr[0] == arr[n-1], then find the minimal window that covers all elements that are not equal to arr[0].

- Else, if arr[0] != arr[n-1], then choose x to be arr[0] or arr[n-1], and set the window to cover all elements that are not equal to x, and take the minimal among these choices.

To implement this efficiently, I can do the following:

- If arr[0] == arr[n-1], then find the leftmost position where arr[i] != arr[0], and the rightmost position where arr[j] != arr[0], then the minimal window is from i to j, with length j - i +1.

- If arr[0] != arr[n-1], then:

- Choose x=arr[0], find the leftmost position where arr[i] != arr[0], and set the window from i to n-1.

- Choose x=arr[n-1], find the rightmost position where arr[j] != arr[n-1], and set the window from 0 to j.

- Then, take the minimal between these two options.

In the earlier example, arr=[4,3,2,7,1,1,3], arr[0]=4, arr[n-1]=3, different.

- Choose x=4: find the leftmost i where arr[i] != 4, which is i=1, set window from i=1 to n-1=6, length 6.

- Choose x=3: find the rightmost j where arr[j] != 3, which is j=5, set window from 0 to j=5, length 6.

- Hence, minimal cost is 6.

In [1,2], arr[0]=1, arr[1]=2, different.

- Choose x=1: find i=1, set window from 1 to 1, length 1.

- Choose x=2: find j=0, set window from 0 to 0, length 1.

- Minimal cost is 1.

In [1,2,3], arr[0]=1, arr[2]=3, different.

- Choose x=1: find i=1, set window from 1 to 2, length 2.

- Choose x=3: find j=1, set window from 0 to 1, length 2.

- Minimal cost is 2.

In [8,8,8,1,2,8,8,8], arr[0]=8, arr[7]=8, same.

- Find leftmost i where arr[i] !=8, which is i=3.

- Find rightmost j where arr[j] !=8, which is j=5.

- Set window from 3 to 5, length 3.

- But in the sample, the output is 2.

Wait, perhaps I need to set window from i to j, and the cost is j - i +1.

In [8,8,8,1,2,8,8,8], i=3, j=5, j - i +1 =3, but sample output is 2.

Wait, perhaps I need to set window from i to j-1, making j - i =2.

Wait, no, the sample output is 2, which is j - i =3 -1 =2.

Wait, j - i +1=3, but sample output is 2.

Wait, perhaps I need to set window from i to j, but calculate cost as max(j - i +1,0).

Wait, no, sample output is 2, but according to this, it's 3.

Wait, perhaps I'm miscalculating.

Wait, in [8,8,8,1,2,8,8,8], if I set [4,5] to 8, then the array becomes [8,8,8,8,8,8,8,8], which is uniform, with cost 2.

Wait, but according to my earlier logic, i=3, j=5, so setting [3,5] to 8, which is arr[3..5] = [1,2,8], set to 8, cost 3.

But, if I set [4,5] to 8, which is arr[4..5] = [2,8], set to 8, cost 2.

Wait, in 0-based indexing, arr[3..5] is indices 3,4,5.

Setting arr[4..5] to 8, which is indices 4 and 5, cost 2.

Hence, the minimal window is from i=4 to j=5, with length 2.

So, perhaps I need to adjust my approach.

Hence, in the case where arr[0] == arr[n-1], I need to find the leftmost i and rightmost j where arr[i] != arr[0] and arr[j] != arr[0], and then set the window from i to j, with length j - i +1.

But in this example, arr[0]=8, arr[n-1]=8, so find leftmost i where arr[i] !=8, which is i=3, and rightmost j where arr[j] !=8, which is j=5.

Then, set window from i=3 to j=5, length 3.

But in reality, I can set a smaller window, from i=4 to j=5, length 2.

Hence, my earlier approach is not correct.

So, I need a better way to find the minimal window in the case where arr[0] == arr[n-1].

Perhaps, in this case, I need to find the minimal window that covers all positions where arr[k] != arr[0].

To find this minimal window, I can find the leftmost i where arr[i] != arr[0], and the rightmost j where arr[j] != arr[0], and then set the window from i to j.

But in the sample, this gives i=3, j=5, window length 3, but there is a better way by setting only arr[4..5] to 8, which has length 2.

So, perhaps I need to find the minimal window that covers all arr[k] != arr[0], but allow some of them to be set outside the window as long as they are set to arr[0].

Wait, no, I can only perform one operation.

Wait, maybe I need to find the minimal window such that all arr[k] != arr[0] are covered by this window.

In other words, find the minimal window that includes all non-arr[0] elements.

This is equivalent to finding the smallest window that contains all the positions where arr[k] != arr[0].

In the sample [8,8,8,1,2,8,8,8], arr[0]=8, non-8 elements are at positions 3 and 4.

Hence, the minimal window that covers positions 3 and 4 is from 3 to 4, which is arr[3..4], set to 8, with cost 2.

Hence, the minimal cost is 2, which matches the sample output.

So, my earlier approach was incorrect; I need to find the minimal window that covers all positions where arr[k] != arr[0].

To find this minimal window, I can iterate through the array and collect all positions where arr[k] != arr[0].

Then, find the minimal window that covers these positions.

If there are no such positions, the cost is 0.

If there is only one such position, the cost is 1.

If there are multiple such positions, the minimal window is from the leftmost to the rightmost such position.

Wait, but in the earlier example, positions are 3 and 4, so from 3 to 4, which is length 2.

Hence, the minimal window is from the leftmost non-arr[0] to the rightmost non-arr[0].

Hence, in this case, i=leftmost non-arr[0], j=rightmost non-arr[0], and set [i,j] to arr[0], with cost j - i +1.

Similarly, in [4,3,2,7,1,1,3], arr[0]=4, non-4 elements are positions 1,2,3,4,5,6.

Hence, minimal window is from 1 to 6, with length 6.

In [1,2], arr[0]=1, non-1 element is position 1, so set [1,1] to 1, cost 1.

In [1,2,3], arr[0]=1, non-1 elements are positions 1,2, so set [1,2] to 1, cost 2.

In [8,8,8,1,2,8,8,8], arr[0]=8, non-8 elements are positions 3,4, so set [3,4] to 8, cost 2.

In [1,2,3,4,5,1], arr[0]=1, non-1 elements are positions 2,3,4, so set [2,4] to 1, cost 3.

Wait, but in the sample, it's 4.

Wait, arr=[1,2,3,4,5,1], arr[0]=1, non-1 elements are positions 1,2,3,4.

So, set [1,4] to 1, cost 4.

Hence, minimal cost is 4.

Wait, but earlier I thought setting [2,5] to 1 gives cost 4, but setting [1,4] to 1 also gives cost 4.

Wait, in 0-based indexing, positions are:

arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5, arr[5]=1.

Non-1 elements are at positions 1,2,3,4.

Hence, set arr[1..4] to 1, cost 4.

Hence, it's consistent.

So, in summary, when arr[0] == arr[n-1], the minimal cost is j - i +1, where i is the leftmost position where arr[k] != arr[0], and j is the rightmost position where arr[k] != arr[0].

If arr[0] != arr[n-1], then I need to choose x to be either arr[0] or arr[n-1], and compute the minimal cost accordingly.

Hence, the approach is:

- If arr[0] == arr[n-1]:

- Find leftmost i where arr[i] != arr[0].

- Find rightmost j where arr[j] != arr[0].

- The minimal cost is j - i +1 (if i <= j), else 0.

- Else (arr[0] != arr[n-1]):

- Option 1: choose x=arr[0]

- Find rightmost j where arr[j] != arr[0]

- The cost is j - 0 +1 = j +1

- Option 2: choose x=arr[n-1]

- Find leftmost i where arr[i] != arr[n-1]

- The cost is n - i

- Take the minimal between option 1 and option 2.

In the earlier example [8,8,8,1,2,8,8,8], arr[0]=8, arr[n-1]=8, same.

- leftmost i where arr[i] !=8 is i=3

- rightmost j where arr[j] !=8 is j=4

- cost is 4 - 3 +1 =2

Which matches the sample output.

In [4,3,2,7,1,1,3], arr[0]=4, arr[6]=3, different.

- Option 1: x=4

- rightmost j where arr[j] !=4 is j=6

- cost is 6 -0 +1=7

- Option 2: x=3

- leftmost i where arr[i] !=3 is i=1

- cost is 7 -1=6

- Minimal cost is 6

Which matches the sample output.

In [1,2], arr[0]=1, arr[1]=2, different.

- Option 1: x=1

- rightmost j where arr[j] !=1 is j=1

- cost is 1 -0 +1=2

- Option 2: x=2

- leftmost i where arr[i] !=2 is i=0

- cost is 2 -0=2

- Minimal cost is 2, but sample output is 1.

Wait, but according to the sample, the output is 1.

Hence, my approach is still incorrect.

Wait, perhaps I need to adjust how I calculate the cost when arr[0] != arr[n-1].

In [1,2], choosing x=1:

- Set arr[1] to 1, cost 1.

Choosing x=2:

- Set arr[0] to 2, cost 1.

Hence, minimal cost is 1.

So, in this case, the minimal cost is min(n - i, j +1), where i is leftmost != x, j is rightmost != x.

Hence, perhaps I need to find, for x=arr[0], the minimal window that covers all positions where arr[k] != arr[0], which is from leftmost != arr[0] to rightmost != arr[0].

Similarly, for x=arr[n-1], from leftmost != arr[n-1] to rightmost != arr[n-1].

Wait, but in [1,2], for x=1, leftmost !=1 is i=1, rightmost !=1 is j=1, so cost is 1 -1 +1=1.

Similarly, for x=2, leftmost !=2 is i=0, rightmost !=2 is j=0, cost is 0 -0 +1=1.

Hence, minimal cost is 1, which matches the sample.

In [4,3,2,7,1,1,3], for x=4:

leftmost !=4 is i=1, rightmost !=4 is j=6, cost is 6 -1 +1=6.

For x=3:

leftmost !=3 is i=0, rightmost !=3 is j=5, cost=5 -0 +1=6.

Hence, minimal cost is 6.

In [8,8,8,1,2,8,8,8], for x=8:

leftmost !=8 is i=3, rightmost !=8 is j=5, cost=5 -3 +1=3.

But in the sample, the output is 2.

Wait, according to earlier reasoning, setting [4,5] to 8 gives cost 2.

Hence, my approach is missing something.

Wait, perhaps I need to set the window from leftmost !=x to rightmost !=x, but in the sample, setting [4,5] to 8 gives cost 2, which is better than 3.

Hence, my approach is not accurate.

So, perhaps I need to find, for x=arr[0], the minimal window that covers all positions where arr[k] != x.

Similarly for x=arr[n-1].

Then, among these two options, take the minimal cost.

But, in [8,8,8,1,2,8,8,8], for x=8, the positions where arr[k] !=8 are positions 3 and 4.

Hence, the minimal window that covers positions 3 and 4 is [3,4], with cost 2.

Similarly, in [4,3,2,7,1,1,3], for x=4, positions !=4 are 1,2,3,4,5,6.

Hence, minimal window is [1,6], cost 6.

For x=3, positions !=3 are 0,1,2,3,4,5.

Hence, minimal window is [0,5], cost 6.

Hence, minimal cost is 6.

In [1,2], for x=1, positions !=1 are position 1.

Hence, minimal window is [1,1], cost 1.

For x=2, positions !=2 are position 0.

Hence, minimal window is [0,0], cost 1.

Hence, minimal cost is 1.

In [1,2,3], for x=1, positions !=1 are 1,2.

Hence, minimal window is [1,2], cost 2.

For x=3, positions !=3 are 0,1.

Hence, minimal window is [0,1], cost 2.

Hence, minimal cost is 2.

In [8,8,8,1,2,8,8,8], for x=8, positions !=8 are 3,4.

Hence, minimal window is [3,4], cost 2.

Hence, the correct minimal cost is 2.

So, in general, for each possible x (which can be arr[0] or arr[n-1]), find the minimal window that covers all positions where arr[k] !=x.

Then, take the minimal cost among these options.

Hence, the approach is:

- If arr[0] == arr[n-1]:

- Find all positions where arr[k] != arr[0].

- Find the minimal window that covers all these positions.

- Else:

- Option 1: choose x=arr[0]

- Find all positions where arr[k] != arr[0].

- Find the minimal window that covers all these positions.

- Option 2: choose x=arr[n-1]

- Find all positions where arr[k] != arr[n-1].

- Find the minimal window that covers all these positions.

- Take the minimal cost between option 1 and option 2.

To find the minimal window