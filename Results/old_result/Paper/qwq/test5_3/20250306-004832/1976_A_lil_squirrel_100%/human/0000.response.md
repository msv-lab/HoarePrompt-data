Alright, I've got this problem to check if a given password is strong based on specific conditions. Let's break it down.

First, the conditions for a strong password are:

1. It should consist only of lowercase Latin letters and digits.

2. There should be no digit that comes after a letter (so, after each letter, there should be either another letter or the string ends).

3. All digits should be sorted in non-decreasing order.

4. All letters should be sorted in non-decreasing order.

The program needs to handle multiple test cases, each with a password of length n, where n is between 1 and 20, and it's guaranteed that the password consists only of lowercase letters and digits.

Looking at the provided program:

- It reads the number of test cases, t.

- For each test case, it reads n and the password.

- It calls func_1(n, password) and prints the result.

Now, let's look into func_1:

- It separates the password into letters and digits.

- It checks if the letters are sorted in non-decreasing order.

- It checks if the digits are sorted in non-decreasing order.

- It checks if there is any digit that comes after a letter in the password.

- If all these conditions are satisfied, it returns 'YES'; otherwise, 'NO'.

Let's see if this aligns with the problem requirements.

Condition 1: Only lowercase letters and digits.

- The problem states that the input passwords will only contain lowercase letters and digits, so we don't need to handle invalid characters.

Condition 2: No digit should come after a letter.

- The program checks for this by iterating through the password and ensuring that there is no letter followed by a digit.

- This seems correct.

Condition 3: Digits should be sorted in non-decreasing order.

- The program collects all digits and checks if they are sorted.

- This seems correct.

Condition 4: Letters should be sorted in non-decreasing order.

- Similarly, it collects all letters and checks if they are sorted.

- This seems correct.

Looking at the example in the problem:

Test case 1:

n = 4

password = "12ac"

- Letters: 'a', 'c' → sorted

- Digits: '1', '2' → sorted

- No digit comes after a letter

- Should return 'YES'

Test case 2:

n = 5

password = "123wa"

- Letters: 'w', 'a' → not sorted ('a' should come before 'w')

- Digits: '1', '2', '3' → sorted

- No digit comes after a letter (since 'a' comes after digits)

- Should return 'NO' because letters are not sorted

Test case 3:

n = 9

password = "allllmost"

- Letters: 'a', 'l', 'l', 'l', 'l', 'm', 'o', 's', 't' → sorted

- Digits: none

- Should return 'YES'

Test case 4:

n = 5

password = "ac123"

- Letters: 'a', 'c' → sorted

- Digits: '1', '2', '3' → sorted

- But 'c' is followed by '1', which violates condition 2

- Should return 'NO'

Test case 5:

n = 6

password = "011679"

- Letters: none

- Digits: '0', '1', '1', '6', '7', '9' → sorted

- Should return 'YES'

Now, looking back at the program:

- It separates letters and digits and checks if they are sorted individually.

- It also checks if there is any letter followed by a digit in the password.

- This seems to cover all the conditions.

But wait, in condition 2, it says "there should be no digit that comes after a letter", meaning that if there is a letter, any digit that appears after it in the string should not be present.

In the program, it checks for any instance where a letter is followed immediately by a digit. However, the condition says "there should be no digit that comes after a letter", which might imply that no digit should appear after any letter in the entire string, not just immediately after.

Wait, that might be a misunderstanding.

Let's look at the problem statement again:

"there should be no digit that comes after a letter (so, after each letter, there is either another letter or the string ends)"

The example explains that after each letter, there should be either another letter or the string should end. So, no digit should follow a letter.

In the password "ac123", 'c' is followed by '1', which is a digit after a letter, hence it's invalid.

In the password "12ac", digits come first, then letters, and there are no digits after letters, so it's valid.

So, the program's check seems correct: it iterates through the password and checks if there is any letter followed immediately by a digit.

But to ensure, let's consider another example.

Suppose the password is "a1b2c3".

- Letters: 'a', 'b', 'c' → sorted

- Digits: '1', '2', '3' → sorted

- But 'a' is followed by '1', 'b' is followed by '2', 'c' is followed by '3'

- According to condition 2, this should be invalid because digits are coming after letters.

Wait, but in this case, letters and digits are interleaved.

According to condition 2, there should be no digit that comes after a letter, meaning that once a letter appears, no digit should appear after it in the string.

So, in "a1b2c3", digits '1', '2', '3' come after letters 'a', 'b', 'c' respectively.

Hence, it should be invalid.

Similarly, in "1a2b3c", 'a' comes after '1', 'b' after '2', 'c' after '3'.

According to condition 2, as long as no digit comes after a letter, this should be invalid because 'a' comes after '1', which is a digit coming before a letter, but the condition specifies that after a letter, there should be no digit.

Wait, the condition is: "there should be no digit that comes after a letter".

In "1a2b3c", 'a' is after '1', 'b' is after '2', 'c' is after '3'.

So, in this case, digits are before letters, which should be acceptable as long as no digit comes after a letter.

But according to the condition, it should be allowed.

Wait, maybe I'm misinterpreting.

Let me read the condition again carefully:

"there should be no digit that comes after a letter (so, after each letter, there is either another letter or the string ends)"

So, after any letter, the next character should be either another letter or the string should end.

In "1a2b3c":

- '1' is followed by 'a' (letter after digit)

- 'a' is followed by '2' (digit after letter) → invalid

- '2' is followed by 'b' (letter after digit)

- 'b' is followed by '3' (digit after letter) → invalid

- '3' is followed by 'c' (letter after digit)

- 'c' is the end

So, in "1a2b3c", there are instances where a letter is followed by a digit ('a' followed by '2', 'b' followed by '3'), which violates condition 2.

Hence, it should be invalid.

Similarly, in "a1b2c3", 'a' followed by '1', 'b' followed by '2', 'c' followed by '3' → invalid.

In "123abc", '3' is followed by 'a' → invalid.

In "abc123", 'c' is followed by '1' → invalid.

In "123", all digits, no letters → valid.

In "abc", all letters → valid.

In "1a2b3c", as above, invalid.

So, the program's check seems correct: it iterates through the password and checks if there is any letter followed immediately by a digit.

If such a pair exists, it returns 'NO'; otherwise, 'YES'.

Additionally, it checks if the letters and digits are sorted separately.

Looking back at the provided program:

def func_1(n, password):

letters = []

digits = []

for ch in password:

if ch.isdigit():

digits.append(ch)

else:

letters.append(ch)

if letters != sorted(letters):

return 'NO'

if digits != sorted(digits):

return 'NO'

for i in range(len(password) - 1):

if password[i].isalpha() and password[i + 1].isdigit():

return 'NO'

return 'YES'

This seems to cover all the conditions.

But wait, there is a potential issue here.

In the checks for sorted letters and digits, it's using the sorted function on the lists of letters and digits.

However, sorted function in Python sorts in ascending order, which is what we want for non-decreasing order.

But, we need to make sure that the letters and digits are sorted within their own groups.

Wait, but in the problem, it says "all letters should be sorted in non-decreasing order" and "all digits should be sorted in non-decreasing order".

So, separately sorting letters and digits is correct.

Additionally, condition 2 says "there should be no digit that comes after a letter", meaning that all letters should appear before any digits in the password.

Wait, but looking back, the condition is: "there should be no digit that comes after a letter (so, after each letter, there is either another letter or the string ends)".

So, this implies that all digits, if present, must come before any letters in the password.

In other words, the password should have all digits first, followed by all letters, and within each group, they should be sorted.

So, in "12ac", digits '1','2' are sorted and letters 'a','c' are sorted, and all digits come before any letters.

In "123wa", digits '1','2','3' are sorted, letters 'w','a' are not sorted ('a' should come before 'w'), so 'NO'.

In "allllmost", all letters are sorted, no digits, so 'YES'.

In "ac123", letters 'a','c' are sorted, digits '1','2','3' are sorted, but since a letter is followed by a digit, it's invalid, so 'NO'.

In "011679", all digits are sorted, no letters, so 'YES'.

Given this, perhaps there's a simpler way to check.

If we ensure that all digits come before any letters in the password, and within the digits and letters, they are sorted.

So, we can iterate through the password:

- If we encounter a letter before any digit, it's invalid.

- Once we encounter a letter, all subsequent characters must be letters and in non-decreasing order.

- All digits must be before any letters and sorted among themselves.

Wait, but the condition is that there should be no digit after a letter, which implies that all digits must come before any letters.

So, the password structure should be: [sorted digits][sorted letters]

Any deviation from this structure should result in 'NO'.

Given this, perhaps the program can be simplified.

But let's verify if the provided program correctly implements this logic.

In func_1:

- It separates letters and digits into two lists and checks if each list is sorted.

- Then, it checks if there is any letter followed immediately by a digit in the password.

- If any such pair exists, it returns 'NO'; otherwise, 'YES'.

Wait, but in the password "123abc", which should be valid, there are digits '123' followed by letters 'abc', both sorted, and no letter is followed by a digit, so it should return 'YES'.

In "abc123", letters 'abc' are followed by digits '123', which should be invalid because digits come after letters.

But according to the program:

- letters = ['a','b','c'], which is sorted.

- digits = ['1','2','3'], which is sorted.

- It will iterate through the password and find 'c' followed by '1', which is a letter followed by a digit, so it should return 'NO'.

Which is correct, as "abc123" is invalid because digits come after letters.

Another example: "1a2b3c"

- letters = ['a','b','c'], sorted.

- digits = ['1','2','3'], sorted.

- It will find 'a' followed by '2', 'b' followed by '3', so it should return 'NO'.

Which is correct.

Another example: "a1b2c3"

- letters = ['a','b','c'], sorted.

- digits = ['1','2','3'], sorted.

- It will find 'a' followed by '1', 'b' followed by '2', 'c' followed by '3'.

- According to the program, it will return 'NO' because there are letters followed by digits.

- But according to the condition, digits should not come after letters, which in this case, digits are after letters, so 'NO' is correct.

Wait, but in "a1b2c3", 'a' is followed by '1', which is a digit after a letter, so it's invalid.

Hence, the program seems to be correctly implementing the conditions.

An alternative way could be:

- Find the first letter in the password.

- Ensure that all characters after that are letters.

- Ensure that digits, if present, are all before any letters.

- Ensure that digits are sorted and letters are sorted.

But the provided program seems to handle it correctly.

Hence, I would say that the given program is correct.

**Final Answer**

\[\boxed{\text{Yes}}\]

