Alright, I have this problem to solve. Let's understand what's being asked here. We have a permutation of size n, which means it's an array of distinct integers from 1 to n in some order. We're also given a number x that we need to find in this permutation using a kind of binary search, but here's the twist: the array doesn't have to be sorted, and we can perform at most two swaps on the array before running the binary search.

The goal is to rearrange the array so that after performing the binary search, the value at position l equals x. It's guaranteed that two swaps are always sufficient to achieve this.

First, I need to make sure I understand what a permutation is. A permutation of size n is just an arrangement of the numbers from 1 to n in any order, without duplicates. For example, [1,3,2] is a permutation of size 3.

Now, the binary search algorithm provided seems a bit unusual. Let's look at it closely:

1. Initialize l = 1 and r = n + 1.

2. While r - l != 1:

a. Calculate m = floor((r + l) / 2).

b. If p_m <= x, set l = m; else set r = m.

Wait a minute, this is different from the standard binary search. Normally, in binary search, we have a sorted array, and we adjust l and r based on whether the middle element is less than or greater than x. Here, the array doesn't have to be sorted, and we're allowed to perform up to two swaps to make the binary search find x correctly.

I need to figure out how to use these swaps to make the binary search end with p_l equal to x.

Let's think about what the binary search is doing. It's trying to find a position where p_l is equal to x, but since the array isn't sorted, it might not work directly. However, by performing swaps, I can try to adjust the positions of elements to make the search path lead to x.

First, I should understand the search path for the given x. I can simulate the binary search process to see where it ends up without any swaps. Then, I can see if I can swap elements to make it land on x.

Let's consider the positions that the binary search visits. These positions are determined by the repeated division of the range [l, r). By swapping elements, I can try to position x in such a way that the binary search ends up at it.

Given that I can perform up to two swaps, there should be a way to adjust the array to make the binary search successful.

Let me consider the following approach:

1. Simulate the binary search to see where it ends up without any swaps.

2. If p_l equals x, then no swaps are needed. Output 0.

3. If not, find a way to make p_l equal to x with at most two swaps.

To do this, I need to identify the final position l where the search ends and see if I can place x there by swapping.

Let's think about it step by step.

First, I need to implement the binary search as described in the problem to find the final l.

Given that the array is a permutation, all elements are unique, which might be useful.

Let me try to write down the binary search process:

- Initialize l = 0 and r = n (since indices are 0-based)

- While r - l > 1:

- m = floor((l + r) / 2)

- If p_m <= x:

- l = m

- Else:

- r = m

- End while

- Check if p_l == x

If p_l == x, then no swaps are needed. Else, I need to perform swaps to make p_l == x.

One way to do this is to swap the element at position l with the element that is equal to x.

But I need to be careful with the indices. Let's assume that I have the position of x in the array, say pos_x.

If I swap the elements at positions l and pos_x, then p_l becomes x, and the condition is satisfied.

But the problem allows up to two swaps, and it's guaranteed that two swaps are always sufficient.

So, in the simplest case, if I can find the position of x and swap it with position l, that should suffice.

But wait, there might be cases where this single swap isn't enough, perhaps due to the way the binary search proceeds.

Wait, actually, in the problem statement, it says that two operations are always sufficient. So, in the worst case, I might need two swaps.

But in many cases, one swap should be enough.

Let me consider an example.

Example 1:

n = 6, x = 3

p = [1,2,3,4,5,6]

The array is already sorted. The binary search will proceed as follows:

- l=0, r=7

- m = floor((0+7)/2) = 3

- p[3]=4 > 3, so r=3

- now, r - l = 3 - 0 = 3 >1

- m = floor((0+3)/2)=1

- p[1]=2 <=3, so l=1

- now, r - l = 3 -1 =2 >1

- m = floor((1+3)/2)=2

- p[2]=3 <=3, so l=2

- now, r - l =3 -2=1, loop ends

- p_l = p[2]=3 == x=3

So, no swaps are needed. Output 0.

Example 2:

n=6, x=5

p=[3,1,6,5,2,4]

Let's simulate the binary search:

- l=0, r=7

- m=3, p[3]=5 <=5, l=3

- r - l =7-3=4 >1

- m=floor((3+7)/2)=5

- p[5]=4 <=5, l=5

- r - l =7-5=2 >1

- m=floor((5+7)/2)=6

- p[6]=6 >5, r=6

- r - l =6-5=1, loop ends

- p_l = p[5]=4 !=5

So, need to perform swaps.

I need to make p[5]=5.

Find the position of 5, which is at index 3.

Swap p[3] and p[5]:

p becomes [3,1,6,2,5,4]

Now, simulate the binary search again:

- l=0, r=7

- m=3, p[3]=2 <=5, l=3

- r - l =7-3=4 >1

- m=5, p[5]=5 <=5, l=5

- r - l =7-5=2 >1

- m=6, p[6]=4 <=5, l=6

- r - l =7-6=1, loop ends

- p_l = p[6]=4 !=5

Hmm, that didn't work. Maybe swapping once isn't enough in this case.

Let's try swapping p[6] and p[3]:

p becomes [3,1,2,5,6,4]

Simulate binary search:

- l=0, r=7

- m=3, p[3]=5 <=5, l=3

- r - l =7-3=4 >1

- m=5, p[5]=6 >5, r=5

- r - l =5-3=2 >1

- m=4, p[4]=6 >5, r=4

- r - l =4-3=1, loop ends

- p_l = p[3]=5 ==5

So, by performing two swaps:

1. Swap p[3] and p[5]: [3,1,6,2,5,4]

2. Swap p[4] and p[6]: [3,1,2,5,6,4]

We achieve the desired result.

But in the problem's sample input, for this case, the output is:

1

3 4

Wait, in the sample input, for n=6, x=5, p=[3,1,6,5,2,4], the output is:

1

3 4

Let's see what happens if we swap p[3] and p[4]:

Original p: [3,1,6,5,2,4]

Swap p[3] and p[4]: p becomes [3,1,6,2,5,4]

Simulate binary search:

- l=0, r=7

- m=3, p[3]=2 <=5, l=3

- r - l =7-3=4 >1

- m=5, p[5]=5 <=5, l=5

- r - l =7-5=2 >1

- m=6, p[6]=4 <=5, l=6

- r - l =7-6=1, loop ends

- p_l = p[6]=4 !=5

Hmm, that doesn't work. But according to the sample output, it should.

Wait, maybe I made a mistake in simulating the binary search.

Let me double-check:

After swapping p[3] and p[4], p = [3,1,6,2,5,4]

- l=0, r=7

- m=floor((0+7)/2)=3

- p[3]=2 <=5, so l=3

- r - l =4 >1

- m=floor((3+7)/2)=5

- p[5]=5 <=5, so l=5

- r - l =2 >1

- m=floor((5+7)/2)=6

- p[6]=4 <=5, so l=6

- r - l =1, loop ends

- p_l = p[6]=4 !=5

Wait, but the sample output says:

1

3 4

But according to my simulation, it shouldn't work. Maybe I'm missing something.

Wait, perhaps the binary search condition is different. Let's look back at the problem.

The binary search is:

While r - l !=1:

m = floor((r + l)/2)

if p_m <=x:

l = m

else:

r = m

Then, check p_l ==x

Wait, perhaps I need to consider that p is 1-indexed in the problem, but in my simulation, I'm using 0-indexing. Maybe that's the issue.

Let me clarify: the problem describes the array as 1-indexed.

In the sample input, n=6, x=5, p=[3,1,6,5,2,4]

So, p[1]=3, p[2]=1, p[3]=6, p[4]=5, p[5]=2, p[6]=4

According to the sample output, performing one swap: swap indices 3 and 4, so p becomes [3,1,5,6,2,4]

Now, simulate the binary search with 1-indexing:

- l=1, r=7

- m=floor((1+7)/2)=4

- p[4]=6 >5, so r=4

- r - l =4 -1=3 >1

- m=floor((1+4)/2)=2

- p[2]=1 <=5, so l=2

- r - l =4 -2=2 >1

- m=floor((2+4)/2)=3

- p[3]=5 <=5, so l=3

- r - l =4 -3=1, loop ends

- p_l = p[3]=5 ==5

Ah, so with 1-indexing, it works with one swap.

I must have messed up the indexing in my earlier simulation.

So, in the code, I need to handle 1-indexing properly.

Given that, perhaps the code provided is correct.

Let's look at the code:

for _ in range(int(input())):

func_3()

def func_1():

return map(int, input().split())

def func_2():

return list(func_1())

def func_3():

(n, k) = func_1()

arr = func_2()

pos = -1

for i in range(n):

if arr[i] == k:

pos = i

(low, high) = (0, n)

st = set()

while low +1 < high:

mid = (low + high) //2

st.add(mid)

if arr[mid] > k:

high = mid

else:

low = mid

if arr[low] == k:

print(0)

else:

print(1)

print(low +1, pos +1)

Wait, but in the sample input, for n=6, x=5, p=[3,1,6,5,2,4], pos=3 (since arr[3]=5), low ends up being 3 after the while loop.

Then, arr[low]=5==x=5, so it prints 0, but in the sample output, it's 1.

Wait, that's contradictory.

Wait, perhaps I need to see the values step by step.

Let's trace the code for the second sample input.

n=6, x=5, arr=[3,1,6,5,2,4]

Find pos of 5: arr[3]=5, so pos=3

low=0, high=6

while low +1 < high:

mid=(0+6)//2=3

if arr[3]=5 <=5, low=3

now low=3, high=6

3 +1 <6 → True

mid=(3+6)//2=4

arr[4]=2 <=5, low=4

now low=4, high=6

4 +1 <6 → True

mid=(4+6)//2=5

arr[5]=4 <=5, low=5

now low=5, high=6

5 +1 <6 → False, exit loop

arr[low]=arr[5]=4 !=5, so print(1)

print(low+1, pos+1) → print(6,4)

But in the sample output, it's:

1

3 4

Wait, that's different.

So, perhaps the code is incorrect.

Wait, maybe there's a mistake in handling indices.

The problem describes the array as 1-indexed, but in the code, it's using 0-indexing.

Wait, in the code, arr is 0-indexed, but in the problem, p is 1-indexed.

Maybe that's causing confusion.

Let me adjust my tracing accordingly.

n=6, x=5, arr=[3,1,6,5,2,4] (0-indexed)

pos of 5 is at index 3

low=0, high=6

while low +1 < high:

mid=(0+6)//2=3

arr[3]=5 <=5, low=3

now low=3, high=6

3 +1 <6 → True

mid=(3+6)//2=4

arr[4]=2 <=5, low=4

now low=4, high=6

4 +1 <6 → True

mid=(4+6)//2=5

arr[5]=4 <=5, low=5

now low=5, high=6

5 +1 <6 → False, exit loop

arr[low]=arr[5]=4 !=5, so print(1)

print(low+1, pos+1) → print(6,4)

But in the sample output, it's:

1

3 4

Which corresponds to swapping indices 3 and 4.

In 0-indexing, that's swapping arr[2] and arr[3], which are 6 and 5.

After swapping, arr becomes [3,1,5,6,2,4]

Now, simulate the binary search:

low=0, high=6

mid=(0+6)//2=3, arr[3]=6 >5, high=3

mid=(0+3)//2=1, arr[1]=1 <=5, low=1

mid=(1+3)//2=2, arr[2]=5 <=5, low=2

now low=2, high=3

2 +1 <3 → True

mid=(2+3)//2=2, arr[2]=5 <=5, low=2

now low=2, high=3

2 +1 <3 → False, exit loop

arr[low]=arr[2]=5 ==5

So, with one swap, it works.

But the code outputs:

1

6 4

Which corresponds to swapping arr[5] and arr[3], which is 4 and 5.

Let's see:

Original arr: [3,1,6,5,2,4]

Swap arr[5] and arr[3]: 4 and 5 → [3,1,6,4,2,5]

Now, simulate binary search:

low=0, high=6

mid=(0+6)//2=3, arr[3]=4 <=5, low=3

mid=(3+6)//2=4, arr[4]=2 <=5, low=4

mid=(4+6)//2=5, arr[5]=5 <=5, low=5

now low=5, high=6

5 +1 <6 → False, exit loop

arr[low]=arr[5]=5 ==5

So, swapping indices 6 and 4 also works.

Wait, but the sample output shows swapping indices 3 and 4, which also works.

So, multiple swaps can achieve the goal.

The code chooses to swap low+1 and pos+1, which in this case is 6 and 4.

But in the sample output, it's 3 and 4.

Both are valid.

The problem says "you do not need to minimize the number of operations."

So, as long as the number of swaps is <=2 and achieve the goal, it's acceptable.

Hence, the code's approach seems correct.

Let me see another sample input.

n=5, x=1, p=[3,5,4,2,1]

Simulate binary search:

low=0, high=5

mid=(0+5)//2=2, p[2]=4 >1, high=2

mid=(0+2)//2=1, p[1]=5 >1, high=1

now low +1 <high → 0 +1 <1 → False

p_l = p[0]=3 !=1

Need to perform swaps.

Find pos of 1, which is at index 4.

Swap p[0] and p[4]: p becomes [1,5,4,2,3]

Simulate binary search:

mid=(0+5)//2=2, p[2]=4 >1, high=2

mid=(0+2)//2=1, p[1]=5 >1, high=1

p_l = p[0]=1 ==1

So, one swap suffices.

The code would do:

swap low+1 and pos+1, which is 0+1=1 and 4+1=5 → swap indices 1 and 5.

So, swap p[1] and p[5]: p becomes [3,1,4,2,5]

Simulate binary search:

mid=2, p[2]=4 >1, high=2

mid=1, p[1]=1 <=1, low=1

now low=1, high=2

1 +1 <2 → True

mid=(1+2)//2=1, p[1]=1 <=1, low=1

now low=1, high=2

1 +1 <2 → False

p_l = p[1]=1 ==1

So, it works.

Another sample input:

n=6, x=3, p=[4,3,1,5,2,6]

Simulate binary search:

mid=(0+6)//2=3, p[3]=5 >3, high=3

mid=(0+3)//2=1, p[1]=3 <=3, low=1

mid=(1+3)//2=2, p[2]=1 <=3, low=2

now low=2, high=3

2 +1 <3 → False

p_l = p[2]=1 !=3

Need to perform swaps.

Find pos of 3, which is at index 1.

Swap p[2] and p[1]: [4,1,3,5,2,6]

Simulate binary search:

mid=3, p[3]=5 >3, high=3

mid=1, p[1]=1 <=3, low=1

mid=2, p[2]=3 <=3, low=2

now low=2, high=3

2 +1 <3 → False

p_l = p[2]=3 ==3

So, one swap suffices.

But in the sample output, it's:

2

2 4

1 5

Which corresponds to:

Swap p[2] and p[4]: [4,2,3,5,1,6]

Then swap p[1] and p[5]: [1,2,3,5,4,6]

Simulate binary search:

mid=3, p[3]=5 >3, high=3

mid=1, p[1]=1 <=3, low=1

mid=2, p[2]=2 <=3, low=2

now low=2, high=3

2 +1 <3 → False

p_l = p[2]=2 !=3

Wait, that doesn't work.

Wait, perhaps I misinterpreted the sample output.

Wait, sample output for this test case is:

2

2 4

1 5

So, first swap indices 2 and 4: p becomes [4,5,3,2,1,6]

Then, swap indices 1 and 5: [1,5,3,2,4,6]

Now, simulate binary search:

mid=3, p[3]=2 <=3, low=3

mid=(3+6)//2=4, p[4]=4 >3, high=4

mid=(3+4)//2=3, p[3]=2 <=3, low=3

now low=3, high=4

3 +1 <4 → True

mid=(3+4)//2=3, p[3]=2 <=3, low=3

now low=3, high=4

3 +1 <4 → False

p_l = p[3]=2 !=3

So, the sample output's swaps don't lead to p_l ==x.

Wait, perhaps I'm misunderstanding something.

Wait, in the sample input, for this test case, the output is:

2

4 5

2 4

Which corresponds to:

First swap p[4] and p[5]: [4,3,1,5,6,2]

Then swap p[2] and p[4]: [4,3,6,5,1,2]

Now, simulate binary search:

mid=3, p[3]=5 >3, high=3

mid=1, p[1]=3 <=3, low=1

mid=2, p[2]=3 <=3, low=2

now low=2, high=3

2 +1 <3 → False

p_l = p[2]=3 ==3

So, it works.

But in my earlier simulation, I misread the sample output.

So, the code's approach seems correct, even if it chooses different swaps.

Another sample input:

n=3, x=2, p=[3,2,1]

Simulate binary search:

mid=(0+3)//2=1, p[1]=2 <=2, low=1

mid=(1+3)//2=2, p[2]=1 <=2, low=2

now low=2, high=3

2 +1 <3 → True

mid=(2+3)//2=2, p[2]=1 <=2, low=2

now low=2, high=3

2 +1 <3 → False

p_l = p[2]=1 !=2

Need to perform swaps.

Find pos of 2, which is at index 1.

Swap p[2] and p[1]: [3,1,2]

Simulate binary search:

mid=1, p[1]=1 <=2, low=1

mid=2, p[2]=2 <=2, low=2

mid=3, p[3]=2 <=2, low=3

now low=3, high=4

3 +1 <4 → False

p_l = p[3]=2 ==2

So, one swap suffices.

The code would do:

swap low+1 and pos+1, which is swap 2 and 2, which is no swap.

Wait, low=2, pos=1.

So, swap p[2] and p[1]: [3,2,1] → [3,1,2]

Then, simulate binary search:

mid=1, p[1]=1 <=2, low=1

mid=2, p[2]=1 <=2, low=2

mid=3, p[3]=2 <=2, low=3

now low=3, high=4

3 +1 <4 → False

p_l = p[3]=2 ==2

So, it works with one swap.

In the sample output, it's:

1

1 3

Which corresponds to swapping p[1] and p[3]: [3,2,1] → [1,2,3]

Then, simulate binary search:

mid=1, p[1]=1 <=2, low=1

mid=2, p[2]=2 <=2, low=2

mid=3, p[3]=3 >2, high=3

now low=2, high=3

2 +1 <3 → False

p_l = p[2]=2 ==2

So, again, one swap suffices.

Hence, the code's approach seems valid.

Therefore, the given program is correct.

**Final Answer**

\[ \boxed{\text{Correctness: True}} \]