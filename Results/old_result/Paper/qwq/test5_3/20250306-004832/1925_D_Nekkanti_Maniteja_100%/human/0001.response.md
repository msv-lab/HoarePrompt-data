Alright, I've got this problem to solve. Let's see what it's asking for. There are n children in a class, and m pairs among them are friends with some friendship value. The teacher goes on k excursions, and for each excursion, she randomly chooses a pair of children. If the pair are friends, their friendship value increases by 1 for all subsequent excursions. Pairs who are not friends have a friendship value of 0, which never changes.

I need to find the expected value of the sum of friendship values of all k pairs chosen for the excursions, and express it as p/q where p and q are coprime, and then compute p * q^{-1} mod (10^9 + 7).

First, I need to understand the process:

1. There are n children, so the total number of possible pairs is n*(n-1)/2.

2. Out of these, m pairs are friends with initial friendship values f_i.

3. For each excursion, a pair is chosen uniformly at random from all possible pairs.

4. If the chosen pair are friends, their friendship value increases by 1 for all future excursions.

5. The friendship value of non-friend pairs is always 0 and never changes.

6. I need to find the expected sum of the friendship values at the time of choosing each pair over k excursions.

Let me try to model this.

Let’s denote the friendship values as follows:

- For friend pairs: initial value f_i, and it increases by 1 for each time they are chosen in future excursions.

- For non-friend pairs: friendship value is always 0.

But wait, the problem says that for each excursion, the friendship value is considered at the time of being chosen, and if they are friends, their friendship value increases by 1 for all subsequent excursions.

So, for each excursion, the friendship value of the chosen pair is f_i plus the number of times they have been chosen in previous excursions.

Wait, no. The problem says: "If a pair of children who are friends is chosen, their friendship value increases by 1 for all subsequent excursions."

So, when a friend pair is chosen, their friendship value increases by 1 for future excursions, but for the current excursion, their friendship value is still f_i.

Wait, no: "their friendship value increases by 1 for all subsequent excursions (the teacher can choose a pair of children more than once). The friendship value of a pair who are not friends is considered 0, and it does not change for subsequent excursions."

So, when a friend pair is chosen in an excursion, their friendship value increases by 1 for all future excursions, but for the current excursion, their friendship value is still f_i.

And non-friend pairs always have friendship value 0, which never changes.

So, I need to compute the expected sum of the friendship values of all k pairs chosen, where each pair is chosen independently and uniformly at random, and the friendship values of friend pairs increase by 1 after each time they are chosen.

This seems like a problem involving expectations and some kind of recursive relationship due to the increasing friendship values.

Let me try to think about it step by step.

First, let's consider that in each excursion, a pair is chosen uniformly at random from all possible pairs.

Total number of possible pairs is c = n*(n-1)/2.

Out of these, m are friend pairs, each with an initial friendship value f_i.

Non-friend pairs have friendship value 0, which never changes.

Now, for each excursion, the chosen pair's friendship value is added to the sum, and if they are friends, their friendship value increases by 1 for all subsequent excursions.

I need to find the expected sum of these friendship values over k excursions.

Let me think about the expectation.

Since each excursion is independent, perhaps I can model the expected increase per excursion and then sum them up.

Wait, but the friendship values change over time, so it's not entirely independent.

Let me consider the following approach:

Let’s denote E[t] as the expected sum of friendship values up to time t.

Then, E[t] = E[t-1] + expected friendship value chosen at time t.

But this seems a bit too involved, and I need to consider the dependencies between excursions.

Alternatively, perhaps I can think in terms of the linearity of expectation.

Linearity of expectation holds even if the random variables are dependent, so maybe I can use that.

Let me define X_j as the friendship value of the pair chosen in the j-th excursion.

Then, the total sum S = X_1 + X_2 + ... + X_k.

By linearity of expectation, E[S] = E[X_1] + E[X_2] + ... + E[X_k].

Now, I need to compute E[X_j] for each j from 1 to k.

But the problem is that the friendship values can increase over time, so E[X_j] depends on previous choices.

Wait, but since each excursion chooses a pair independently and uniformly at random, perhaps E[X_j] is the same for all j.

Is that correct?

Wait, no. Because the friendship values can increase over time, so later excursions could have higher friendship values if friend pairs are chosen multiple times.

But let's think carefully.

Each time a friend pair is chosen, their friendship value increases by 1 for all subsequent excursions.

But for the current excursion, their friendship value is still f_i, not f_i plus the increments.

Wait, no, let's read the problem again: "If a pair of children who are friends have a friendship value of f_i. If a pair of children who are friends is chosen, their friendship value increases by 1 for all subsequent excursions."

So, at the time of choosing the pair, their friendship value is f_i, and after that, it becomes f_i + 1 for future excursions.

So, for the current excursion, it's f_i, and for future excursions, it's f_i + 1 if they are chosen again.

So, in E[X_j], it's the expected friendship value at the time of choosing, which is f_i for the chosen pair if they are friends, and 0 if they are not.

But since the friendship values can increase over time, I need to account for the number of times each friend pair has been chosen before.

This seems complicated.

Maybe I can think in terms of the expected number of times each friend pair is chosen in k excursions.

Let me consider that.

Let’s denote for each friend pair i, with initial friendship value f_i, and let’s say it’s chosen t_i times in k excursions.

Then, the total sum S = sum over all excursions of the friendship value at the time of choosing.

For a friend pair i, each time it's chosen, its friendship value at the time of choosing is f_i plus the number of times it has been chosen before.

Wait, no.

Wait, initially, friendship value is f_i.

Each time it's chosen, its friendship value increases by 1 for all subsequent excursions.

So, for the first time it's chosen, its friendship value is f_i.

For the second time, it's f_i + 1.

For the third time, it's f_i + 2, and so on.

Wait, no.

Wait, let's think carefully.

Initial friendship value for friend pair i is f_i.

Each time it's chosen, its friendship value increases by 1 for all subsequent excursions.

So, the friendship value at the time of choosing is f_i plus the number of times it has been chosen before.

Wait, yes.

If a pair has been chosen t times before the current choice, then its friendship value at the current choice is f_i + t.

And then after this choice, it increases by 1 for future choices.

So, yes, at the time of choosing, it's f_i + t, and then it becomes f_i + t + 1 for future choices.

So, for a friend pair i that is chosen t_i times in k excursions, the total contribution to S is sum_{s=0}^{t_i-1} (f_i + s).

Because the first time it's chosen, t=0, so f_i + 0.

Second time, t=1, so f_i + 1.

And so on, up to the t_i-th time, t=t_i-1, so f_i + (t_i - 1).

So, the total for pair i is t_i * f_i + sum_{s=0}^{t_i-1} s = t_i * f_i + (t_i * (t_i - 1)) / 2.

But wait, sum_{s=0}^{t_i-1} s = (t_i * (t_i - 1)) / 2, yes.

So, total for pair i is t_i * f_i + (t_i * (t_i - 1)) / 2.

Similarly, for non-friend pairs, their friendship value is always 0.

So, the total sum S = sum over all friend pairs i of (t_i * f_i + (t_i * (t_i - 1)) / 2).

Now, I need to find the expectation of S.

So, E[S] = sum over all friend pairs i of E[t_i * f_i + (t_i * (t_i - 1)) / 2].

This seems a bit messy, but maybe I can find E[t_i] and E[t_i^2] to compute this.

Let me see.

First, let's find E[t_i], the expected number of times pair i is chosen in k excursions.

Since each excursion chooses a pair uniformly at random, and there are c = n*(n-1)/2 pairs, the probability of choosing pair i in any single excursion is 1/c.

Since the choices are independent, the number of times pair i is chosen follows a binomial distribution with parameters k and p = 1/c.

Therefore, E[t_i] = k / c.

Similarly, E[t_i^2] = Var[t_i] + (E[t_i])^2 = (k * (1/c) * (1 - 1/c)) + (k / c)^2.

But this seems complicated, and I have to sum over all friend pairs.

Wait, maybe there's a better way.

Let me think about the expectation E[S].

Since S is the sum over k excursions of the friendship value at the time of choosing, and each excursion chooses a pair uniformly at random, perhaps I can compute the expected friendship value for a single excursion and then multiply by k.

But is that valid? Wait, no, because the friendship values change over time.

So, the expectation is not simply k times the expected friendship value of a single excursion, because the friendship values are dependent on previous choices.

So, that approach won't work.

Alternatively, perhaps I can model this as a Markov process, where the state is the current friendship values of all pairs, and then compute the expected sum over k steps.

But that seems too complicated, especially given the constraints.

Let me think differently.

Let’s consider that for each friend pair i, the total contribution to S is sum_{s=0}^{t_i-1} (f_i + s), where t_i is the number of times pair i is chosen.

So, E[S] = sum over all friend pairs i of E[t_i * f_i + (t_i * (t_i - 1)) / 2].

This can be rewritten as sum over all friend pairs i of (f_i * E[t_i] + (E[t_i^2] - E[t_i]) / 2).

Wait, yes, because t_i * (t_i - 1) = t_i^2 - t_i.

So, sum over all friend pairs i of (f_i * E[t_i] + (E[t_i^2] - E[t_i]) / 2).

Now, I need to compute E[t_i] and E[t_i^2].

As earlier, E[t_i] = k / c, where c = n*(n-1)/2.

And E[t_i^2] = Var[t_i] + (E[t_i])^2 = k * (1/c) * (1 - 1/c) + (k / c)^2.

So, E[t_i^2] = k / c * (1 - 1/c) + (k / c)^2 = k / c - (k / c^2) + (k / c)^2.

Wait, but (k / c)^2 is already included in the variance formula.

Wait, actually, Var[t_i] = k * (1/c) * (1 - 1/c), and E[t_i^2] = Var[t_i] + (E[t_i])^2 = k / c + k * (1 - 1/c) / c.

Wait, no, Var[t_i] = k * (1/c) * (1 - 1/c), and E[t_i^2] = Var[t_i] + (E[t_i])^2 = k / c + (k / c)^2.

Wait, no, Var[t_i] = k * (1/c) * (1 - 1/c), and E[t_i^2] = Var[t_i] + (E[t_i])^2 = k / c + (k / c)^2.

Wait, but I think I made a mistake.

Actually, for a binomial random variable t_i ~ Binomial(k, 1/c), E[t_i] = k / c, and Var[t_i] = k * (1/c) * (1 - 1/c).

Therefore, E[t_i^2] = Var[t_i] + (E[t_i])^2 = k / c + (k / c)^2.

So, E[t_i^2] = k / c + (k / c)^2.

Therefore, E[S] = sum over all friend pairs i of (f_i * E[t_i] + (E[t_i^2] - E[t_i]) / 2).

Simplify:

E[S] = sum over all friend pairs i of (f_i * (k / c) + (k / c + (k / c)^2 - k / c) / 2).

Wait, that simplifies to:

E[S] = sum over all friend pairs i of (f_i * (k / c) + ((k / c)^2) / 2).

Wait, let's double-check:

E[t_i^2] - E[t_i] = (k / c + (k / c)^2) - (k / c) = (k / c)^2.

Therefore, (E[t_i^2] - E[t_i]) / 2 = (k / c)^2 / 2.

So, E[S] = sum over all friend pairs i of (f_i * (k / c) + (k / c)^2 / 2).

Now, sum over all friend pairs i of f_i is just the sum of all f_i, let's call it A.

And sum over all friend pairs i of 1 is m, the number of friend pairs.

Therefore, E[S] = A * (k / c) + m * ((k / c)^2) / 2.

So, E[S] = (A * k) / c + (m * k^2) / (2 * c^2).

Now, c = n*(n-1)/2, so c^2 = (n*(n-1)/2)^2.

Therefore, E[S] = (A * k) / (n*(n-1)/2) + (m * k^2) / (2 * (n*(n-1)/2)^2).

Simplify:

E[S] = (2 * A * k) / (n*(n-1)) + (m * k^2) / (2 * (n*(n-1)/2)^2) = (2 * A * k) / (n*(n-1)) + (m * k^2) / (2 * (n*(n-1)/2)^2).

Wait, simplify the denominator of the second term:

2 * (n*(n-1)/2)^2 = 2 * (n^2*(n-1)^2)/4 = (n^2*(n-1)^2)/2.

Therefore, E[S] = (2 * A * k) / (n*(n-1)) + (m * k^2) / ((n^2*(n-1)^2)/2) = (2 * A * k) / (n*(n-1)) + (2 * m * k^2) / (n^2*(n-1)^2).

So, E[S] = (2 * A * k) / (n*(n-1)) + (2 * m * k^2) / (n^2*(n-1)^2).

Now, I need to compute this expression and then find p and q such that E[S] = p/q, where p and q are coprime, and then compute p * q^{-1} mod (10^9 + 7).

First, I need to express E[S] as a fraction.

Let’s denote c = n*(n-1)/2.

Then, c^2 = (n*(n-1)/2)^2.

So, E[S] = (2 * A * k) / (n*(n-1)) + (2 * m * k^2) / (n^2*(n-1)^2).

This can be written as:

E[S] = (2 * A * k * c) / c^2 + (2 * m * k^2) / (2 * c^2) = (2 * A * k * c + 2 * m * k^2) / (2 * c^2) = (2 * A * k * c + 2 * m * k^2) / (2 * c^2) = (A * k * c + m * k^2) / (c^2).

Wait, no, let's not complicate it.

I have E[S] = (2 * A * k) / (n*(n-1)) + (2 * m * k^2) / (n^2*(n-1)^2).

Let me find a common denominator for these two terms.

The common denominator is n^2*(n-1)^2.

So, E[S] = [(2 * A * k * n*(n-1)) + (2 * m * k^2)] / (n^2*(n-1)^2).

Wait, no.

Wait, (2 * A * k) / (n*(n-1)) = (2 * A * k * n*(n-1)) / (n^2*(n-1)^2).

Wait, no, that's not correct.

Wait, (2 * A * k) / (n*(n-1)) = (2 * A * k * n*(n-1)) / (n*(n-1) * n*(n-1)) = (2 * A * k * n*(n-1)) / (n^2*(n-1)^2).

And (2 * m * k^2) / (n^2*(n-1)^2) remains the same.

Therefore, E[S] = [2 * A * k * n*(n-1) + 2 * m * k^2] / (n^2*(n-1)^2).

So, numerator is 2 * A * k * n*(n-1) + 2 * m * k^2.

Denominator is n^2*(n-1)^2.

Therefore, E[S] = [2 * k * (A * n*(n-1) + m * k)] / (n^2*(n-1)^2).

Wait, no, that's not correct.

Wait, 2 * A * k * n*(n-1) + 2 * m * k^2 = 2 * k * (A * n*(n-1) + m * k).

Wait, no, 2 * A * k * n*(n-1) + 2 * m * k^2 = 2 * k * (A * n*(n-1) + m * k).

Yes, that's correct.

Therefore, E[S] = 2 * k * (A * n*(n-1) + m * k) / (n^2*(n-1)^2).

Simplify this fraction to its lowest terms and then compute p * q^{-1} mod (10^9 + 7).

Now, I need to implement this in code.

First, read t test cases.

For each test case:

- Read n, m, k.

- Read m lines, each containing a_i, b_i, f_i.

- Compute c = n*(n-1)/2.

- Compute A = sum of all f_i.

- Compute numerator = 2 * k * (A * n*(n-1) + m * k).

- Compute denominator = n^2 * (n-1)^2.

- Simplify numerator and denominator to their lowest terms.

- Compute p and q such that E[S] = p/q.

- Compute p * q^{-1} mod (10^9 + 7).

I need to handle large numbers and modular inverse.

Given that n can be up to 1e5 and m up to 1e5, and t up to 5e4, I need to make sure that the code is efficient.

Also, the sum of n and m over all test cases does not exceed 1e5, and the sum of k over all test cases does not exceed 2e5, so that's manageable.

Let me think about how to compute the modular inverse.

In Python, I can use the built-in pow function with exponent -1 modulo M, where M = 10^9 + 7.

But before that, I need to compute numerator and denominator.

Also, since n and n-1 might be large, I need to compute n*(n-1)/2, but make sure there's no integer overflow.

In Python, integers can be arbitrarily large, so that's fine.

But for efficiency, I need to compute the fraction and simplify it.

Wait, actually, I can compute numerator and denominator, then compute gcd of numerator and denominator, divide both by gcd to get p and q, and then compute p * q^{-1} mod M.

But since M is prime, I can compute q^{-1} mod M using pow(q, M-2, M), and then compute (p * q_inv) mod M.

But to avoid computing gcd, I can directly compute (numerator * pow(denominator, M-2, M)) % M.

But I need to make sure that denominator and M are coprime, which they are since M is prime and denominator is a square of n*(n-1), which is less than M.

Wait, n can be up to 1e5, so n^2*(n-1)^2 can be up to around 1e10, which is less than M^2, but M is 1e9 + 7, which is larger than n^2*(n-1)^2 for n <= 1e5.

Wait, no, 1e5^2 * (1e5 - 1)^2 = (1e10) * (1e10) = 1e20, which is much larger than M = 1e9 + 7.

But in modular arithmetic, we can compute (numerator * pow(denominator, M-2, M)) % M directly.

So, in code, I can compute numerator and denominator, then compute denominator_inv = pow(denominator, M-2, M), and then (numerator * denominator_inv) % M.

But I need to make sure that denominator is not zero modulo M, but since M is prime and denominator is n^2*(n-1)^2, which is non-zero for n >=2 and M > n^2*(n-1)^2, which it is for n <=1e5.

Wait, M = 1e9 + 7, and n <=1e5, so n^2*(n-1)^2 <= (1e5)^2 * (1e5)^2 = 1e20, which is larger than M, but since we're computing modulo M, denominator mod M is non-zero.

So, it should be fine.

Now, let's think about implementing this.

But wait, in the code provided, it seems to have a different approach.

Let me look at the given code:

def func():

for i in range(int(input())):

n, m, k = map(int, input().split())

M = 10 ** 9 + 7

c = pow(n * (n - 1) // 2, -1, M)

s = 0

a = 0

for i in range(m):

u, v