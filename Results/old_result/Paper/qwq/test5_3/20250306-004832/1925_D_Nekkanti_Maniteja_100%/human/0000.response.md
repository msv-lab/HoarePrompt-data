Alright, I have this problem to solve. Let's read it carefully.

There are n children in a class, and m pairs among them are friends with a friendship value f_i. The teacher goes on k excursions, and for each excursion, she chooses a pair of children randomly and equiprobably. If the chosen pair are friends, their friendship value increases by 1 for all subsequent excursions. Pairs who are not friends have a friendship value of 0 that doesn't change.

I need to find the expected value of the sum of friendship values of all k pairs chosen for the excursions, considering that the friendship values can increase over time.

The answer should be in the form of p/q where p and q are coprime, and I need to compute p * q^{-1} mod (10^9 + 7).

First, let's understand the problem step by step.

1. **Understanding the setup:**

   - There are n children.

   - There are m pairs of friends, each with an initial friendship value f_i.

   - There are k excursions, and for each excursion, a pair of children is chosen randomly and equiprobably.

   - If the chosen pair are friends, their friendship value increases by 1 for all subsequent excursions.

   - Pairs that are not friends have a friendship value of 0, which never changes.

2. **Objective:**

   - Compute the expected sum of the friendship values of the pairs chosen over k excursions.

3. **Key points:**

   - Pairs are chosen randomly and independently.

   - Friendship values can increase over time if friends are chosen.

   - Need to compute the expected sum of friendship values at the time of choice for each excursion.

4. **Approach:**

   - Since pairs are chosen independently, the expected sum is the sum of the expected friendship values for each excursion.

   - For each excursion, the expected friendship value is the sum over all possible pairs of the probability of choosing that pair multiplied by its friendship value at that excursion.

   - However, since pairs are chosen independently, the friendship values can change based on previous choices, making this dependent on the sequence of choices.

   - This seems complex due to the dependency introduced by the increasing friendship values.

5. **Simplifying the approach:**

   - Let's consider linearity of expectation. Even though the friendship values can change based on previous choices, the expected value for each excursion can be computed independently.

   - For each excursion, the expected friendship value is the sum over all possible pairs of the probability of choosing that pair times its expected friendship value at that excursion.

   - Given that pairs are chosen independently, perhaps we can find a way to compute the expected friendship value for each pair at each excursion and sum them up.

6. **Modeling the problem:**

   - Let’s denote the friendship value of pair (u, v) at excursion t as f_{u,v}(t).

   - Initially, f_{u,v}(0) = f_i if (u, v) are friends, else 0.

   - If pair (u, v) is chosen at excursion t, then f_{u,v}(t') = f_{u,v}(t'-1) + 1 for all t' > t.

   - Since pairs are chosen independently, the increments are based on whether they are chosen in previous excursions.

7. **Computing the expected sum:**

   - The total sum S = sum over t=1 to k of f_{chosen_pair}(t).

   - We need E[S] = sum over t=1 to k of E[f_{chosen_pair}(t)].

   - For each t, E[f_{chosen_pair}(t)] = sum over all pairs p of P(p is chosen at t) * E[f_p(t)].

   - Since pairs are chosen equiprobably, P(p is chosen at t) = 1/C, where C is the total number of possible pairs, C = n(n-1)/2.

   - Therefore, E[S] = sum over t=1 to k of (sum over all pairs p of (1/C) * E[f_p(t)]).

   - This simplifies to E[S] = (1/C) * sum over t=1 to k of sum over all pairs p of E[f_p(t)].

8. **Simplifying further:**

   - Let’s denote S_t = sum over all pairs p of E[f_p(t)].

   - Then E[S] = (1/C) * sum over t=1 to k of S_t.

   - Now, we need to compute S_t for each t from 1 to k.

9. **Computing S_t:**

   - For non-friend pairs, f_p(t) = 0 for all t.

   - For friend pairs, f_p(t) starts at f_i and increases by 1 each time the pair is chosen in previous excursions.

   - Let’s denote N_p as the number of times pair p is chosen in the first t-1 excursions.

   - Then, f_p(t) = f_i + N_p.

   - Therefore, E[f_p(t)] = f_i + E[N_p].

   - Since pairs are chosen independently, E[N_p] = (t-1) * P(p is chosen in a single excursion) = (t-1)/C.

   - Therefore, E[f_p(t)] = f_i + (t-1)/C.

   - For non-friend pairs, E[f_p(t)] = 0.

   - Therefore, S_t = sum over friend pairs p of (f_i + (t-1)/C).

   - S_t = sum over friend pairs p of f_i + (t-1)/C * m.

   - Let’s denote sum_f = sum over friend pairs p of f_i.

   - Then, S_t = sum_f + (t-1)/C * m.

10. **Putting it all together:**

    - E[S] = (1/C) * sum over t=1 to k of S_t.

    - E[S] = (1/C) * sum over t=1 to k of (sum_f + (t-1)/C * m).

    - E[S] = (1/C) * [k * sum_f + (sum over t=1 to k of (t-1)) * m / C].

    - sum over t=1 to k of (t-1) = sum over s=0 to k-1 of s = (k-1)*k/2.

    - Therefore, E[S] = (1/C) * [k * sum_f + ((k-1)*k/2) * m / C].

11. **Simplifying E[S]:**

    - E[S] = (1/C) * [k * sum_f + (k*(k-1)/2) * m / C].

    - This seems a bit messy. Maybe there's a better way to approach this.

12. **Alternative approach:**

    - Perhaps consider that for each friend pair p, the expected contribution to the total sum is the sum over t=1 to k of P(p is chosen at t) * E[f_p(t)].

    - Since P(p is chosen at t) = 1/C.

    - And E[f_p(t)] = f_i + (number of times p is chosen in previous excursions).

    - But this seems similar to the earlier approach.

13. **Another perspective:**

    - Let’s think about the total sum S being the sum over k excursions of f_p(t) where p is the pair chosen at excursion t.

    - Since pairs are chosen independently, perhaps we can find the expected value for each excursion separately and then sum them up.

    - For each excursion t, E[f_p(t)] = sum over all pairs p of P(p is chosen at t) * E[f_p(t)].

    - Again, P(p is chosen at t) = 1/C.

    - So E[f_p(t)] = (1/C) * sum over all pairs p of E[f_p(t)].

    - But this seems circular. Maybe I need to find a better way to compute E[f_p(t)].

14. **Modeling f_p(t):**

    - For a friend pair p, f_p(t) = f_i + number of times p is chosen in the first t-1 excursions.

    - Let X_p be the number of times p is chosen in the first t-1 excursions.

    - Then f_p(t) = f_i + X_p.

    - E[f_p(t)] = f_i + E[X_p].

    - Since each excursion chooses p with probability 1/C, X_p follows a binomial distribution with parameters t-1 and 1/C.

    - Therefore, E[X_p] = (t-1)/C.

    - Hence, E[f_p(t)] = f_i + (t-1)/C.

15. **Computing E[S]:**

    - E[S] = sum over t=1 to k of E[f_p(t)] where p is the pair chosen at t.

    - Since p is chosen randomly at each t, E[f_p(t)] = sum over all pairs p of P(p is chosen at t) * E[f_p(t)].

    - P(p is chosen at t) = 1/C.

    - Therefore, E[f_p(t)] = (1/C) * sum over all pairs p of E[f_p(t)].

    - For friend pairs, E[f_p(t)] = f_i + (t-1)/C.

    - For non-friend pairs, E[f_p(t)] = 0.

    - Therefore, E[f_p(t)] = (1/C) * [sum over friend pairs p of (f_i + (t-1)/C)].

    - Let’s denote sum_f = sum over friend pairs p of f_i.

    - Then, E[f_p(t)] = (1/C) * [sum_f + m*(t-1)/C].

    - Therefore, E[S] = sum over t=1 to k of E[f_p(t)] = sum over t=1 to k of (1/C) * [sum_f + m*(t-1)/C].

    - E[S] = (1/C) * [k * sum_f + m/C * sum over t=1 to k of (t-1)].

    - sum over t=1 to k of (t-1) = (k*(k-1))/2.

    - Therefore, E[S] = (1/C) * [k * sum_f + m/C * (k*(k-1))/2].

    - Simplifying, E[S] = (k * sum_f)/C + m*(k*(k-1))/(2*C^2).

16. **Final expression for E[S]:**

    - E[S] = (k * sum_f)/C + (m * k * (k-1)) / (2 * C^2).

    - Where C = n*(n-1)/2.

17. **Implementing the solution:**

    - For each test case, read n, m, k.

    - Compute C = n*(n-1)/2.

    - Compute sum_f = sum of f_i for all m friend pairs.

    - Compute E[S] = (k * sum_f)/C + (m * k * (k-1)) / (2 * C^2).

    - Since we need to compute p/q mod (10^9 + 7), we need to handle large numbers and modular inverses.

18. **Handling modular arithmetic:**

    - We need to compute E[S] modulo 10^9 + 7, where E[S] is a fraction p/q.

    - We need to compute p * q^{-1} mod (10^9 + 7), where q^{-1} is the modular inverse of q modulo 10^9 + 7.

    - We can compute modular inverses using Fermat's Little Theorem, since 10^9 + 7 is prime.

    - a^{-1} mod M = a^{M-2} mod M.

19. **Implementing the formula:**

    - Compute C = n*(n-1)//2.

    - Compute sum_f = sum of f_i for all m friend pairs.

    - Compute E[S] = (k * sum_f)/C + (m * k * (k-1)) / (2 * C^2).

    - To handle modular arithmetic, compute each term separately with modular inverses.

    - Let’s denote M = 10^9 + 7.

    - Compute inv_C = C^{M-2} mod M.

    - Compute inv_C2 = (C^2)^{M-2} mod M.

    - Compute first_term = (k * sum_f * inv_C) mod M.

    - Compute second_term = (m * k * (k-1) * inv_C2 * inv2) mod M, where inv2 = 2^{M-2} mod M.

    - Finally, E[S] = (first_term + second_term) mod M.

20. **Optimizations:**

    - Since sum over all test cases of n and m is up to 10^5, and sum of k is up to 2*10^5, the per test case time should be O(m + k), but since m and n are up to 10^5, we need an efficient implementation.

    - Precompute modular inverses if necessary.

21. **Implementing the function:**

    - Read the number of test cases t.

    - For each test case:

        - Read n, m, k.

        - Compute C = n*(n-1)//2.

        - Compute sum_f = sum of f_i for all m friend pairs.

        - Compute inv_C = pow(C, M-2, M).

        - Compute inv_C2 = pow(C*C, M-2, M).

        - Compute inv2 = pow(2, M-2, M).

        - Compute first_term = (k * sum_f * inv_C) % M.

        - Compute second_term = (m * k * (k-1) * inv_C2 * inv2) % M.

        - Compute E[S] = (first_term + second_term) % M.

        - Print E[S].

22. **Checking with sample inputs:**

    - For the first sample input:

        - n=100, m=0, k=24.

        - C=100*99/2=4950.

        - sum_f=0.

        - E[S] = (24*0)/4950 + (0*24*23)/(2*4950^2) = 0.

        - Output: 0.

    - For the second sample input:

        - n=2, m=1, k=10.

        - C=1.

        - sum_f=10.

        - E[S] = (10*10)/1 + (1*10*9)/(2*1^2) = 100 + 45 = 145.

        - But in the note, it's 55. Seems discrepancy.

    - Wait, perhaps I have a mistake in the formula.

23. **Revisiting the formula:**

    - Let’s re-examine the formula.

    - E[S] = sum over t=1 to k of E[f_p(t)].

    - E[f_p(t)] = sum over all pairs p of P(p is chosen at t) * E[f_p(t)].

    - For friend pairs, E[f_p(t)] = f_i + (number of times p is chosen in previous excursions).

    - But the number of times p is chosen in previous excursions is the number of times p is chosen in t-1 excursions.

    - Let’s denote X_p,t = number of times p is chosen in the first t-1 excursions.

    - Then f_p(t) = f_i + X_p,t.

    - Therefore, E[f_p(t)] = f_i + E[X_p,t].

    - E[X_p,t] = (t-1)/C.

    - Therefore, E[f_p(t)] = f_i + (t-1)/C.

    - Then, E[S] = sum over t=1 to k of sum over all pairs p of P(p is chosen at t) * E[f_p(t)].

    - Since P(p is chosen at t) = 1/C, E[S] = sum over t=1 to k of (1/C) * sum over all pairs p of E[f_p(t)].

    - sum over all pairs p of E[f_p(t)] = sum over friend pairs p of (f_i + (t-1)/C).

    - Let sum_f = sum over friend pairs p of f_i.

    - Therefore, sum over all pairs p of E[f_p(t)] = sum_f + m*(t-1)/C.

    - Therefore, E[S] = sum over t=1 to k of (1/C) * [sum_f + m*(t-1)/C].

    - E[S] = sum over t=1 to k of (sum_f / C + m*(t-1)/(C^2)).

    - E[S] = k * (sum_f / C) + m/(C^2) * sum over t=1 to k of (t-1).

    - sum over t=1 to k of (t-1) = (k*(k-1))/2.

    - Therefore, E[S] = (k * sum_f)/C + (m * k * (k-1))/(2 * C^2).

    - This seems consistent with the earlier formula.

24. **Checking with sample input 2:**

    - n=2, m=1, k=10.

    - C=1.

    - sum_f=10.

    - E[S] = (10*10)/1 + (1*10*9)/(2*1^2) = 100 + 45 = 145.

    - But according to the note, it's 55.

    - There must be a mistake in the approach.

25. **Reevaluating the approach:**

    - Maybe the mistake is in assuming that E[f_p(t)] for the chosen pair p at time t is the sum over all pairs of P(p is chosen) * E[f_p(t)].

    - Actually, since p is chosen at t, E[f_p(t)] is E[f_p(t)] for the chosen p.

    - Perhaps I need to think differently.

26. **Alternative approach using linearity of expectation:**

    - For each friend pair p, define X_p,t as an indicator variable that is 1 if p is chosen at excursion t, and 0 otherwise.

    - Then, f_p(t) = f_i + sum over s=1 to t-1 of X_p,s.

    - Therefore, E[f_p(t)] = f_i + sum over s=1 to t-1 of E[X_p,s].

    - E[X_p,s] = P(p is chosen at s) = 1/C.

    - So E[f_p(t)] = f_i + (t-1)/C.

    - Now, E[S] = sum over t=1 to k of E[f_p(t)] where p is the pair chosen at t.

    - Since p is chosen randomly at each t, E[f_p(t)] = sum over all pairs p of P(p is chosen at t) * E[f_p(t)].

    - Which is the same as before.

    - So E[S] = sum over t=1 to k of (1/C * sum over all pairs p of E[f_p(t)]).

    - sum over all pairs p of E[f_p(t)] = sum over friend pairs p of (f_i + (t-1)/C).

    - sum_f + m*(t-1)/C.

    - Therefore, E[S] = sum over t=1 to k of (1/C * (sum_f + m*(t-1)/C)).

    - E[S] = sum over t=1 to k of (sum_f / C + m*(t-1)/(C*C)).

    - E[S] = k * (sum_f / C) + m/(C*C) * sum over t=1 to k of (t-1).

    - sum over t=1 to k of (t-1) = k*(k-1)/2.

    - Therefore, E[S] = (k * sum_f)/C + (m * k * (k-1))/(2 * C^2).

    - This seems consistent, but sample input 2 doesn't match.

27. **Rechecking sample input 2:**

    - n=2, m=1, k=10.

    - C=1.

    - sum_f=10.

    - E[S] = (10*10)/1 + (1*10*9)/(2*1^2) = 100 + 45 = 145.

    - But according to the note, it's 55.

    - There must be a misunderstanding in the problem.

28. **Re-reading the problem:**

    - "If a pair of children who are friends is chosen, their friendship value increases by 1 for all subsequent excursions."

    - "The friendship value of a pair who are not friends is considered 0, and it does not change for subsequent excursions."

    - "Find the expected value of the sum of friendship values of all k pairs chosen for the excursions (at the time of being chosen)."

    - Key point: The friendship value is considered at the time of being chosen.

29. **Revisiting E[f_p(t)]:**

    - At time t, when pair p is chosen, its friendship value is f_p(t) = f_i + number of times p was chosen in previous excursions.

    - Let’s denote N_p(t-1) as the number of times p was chosen in the first t-1 excursions.

    - Then f_p(t) = f_i + N_p(t-1).

    - Therefore, E[f_p(t)] = f_i + E[N_p(t-1)].

    - E[N_p(t-1)] = (t-1)/C.

    - So E[f_p(t)] = f_i + (t-1)/C.

    - Now, E[S] = sum over t=1 to k of E[f_p(t)] where p is the pair chosen at t.

    - Since p is chosen randomly at each t, E[f_p(t)] = sum over all pairs p of P(p is chosen at t) * E[f_p(t)].

    - P(p is chosen at t) = 1/C.

    - Therefore, E[f_p(t)] = (1/C) * sum over all pairs p of E[f_p(t)].

    - For friend pairs, E[f_p(t)] = f_i + (t-1)/C.

    - For non-friend pairs, E[f_p(t)] = 0.

    - Therefore, E[f_p(t)] = (1/C) * [sum over friend pairs p of (f_i + (t-1)/C)].

    - sum over friend pairs p of f_i = sum_f.

    - sum over friend pairs p of (t-1)/C = m*(t-1)/C.

    - Therefore, E[f_p(t)] = (1/C) * [sum_f + m*(t-1)/C].

    - Therefore, E[S] = sum over t=1 to k of E[f_p(t)] = sum over t=1 to k of (1/C * sum_f + m*(t-1)/(C*C))).

    - E[S] = k * (sum_f / C) + m/(C*C) * sum over t=1 to k of (t-1).

    - sum over t=1 to k of (t-1) = k*(k-1)/2.

    - Therefore, E[S] = (k * sum_f)/C + (m * k * (k-1))/(2 * C^2).

    - This seems consistent, but sample input 2 suggests otherwise.

30. **Rechecking sample input 2:**

    - n=2, m=1, k=10.

    - C=1.

    - sum_f=10.

    - E[S] = (10 * 10)/1 + (1 * 10 * 9)/(2 * 1^2) = 100 + 45 = 145.

    - But according to the note, it's 55.

    - There must be a mistake in the understanding.

31. **Reconsidering the problem:**

    - Let's simulate the process for k=10, n=2, m=1, sum_f=10.

    - There is only one possible pair, p=(1,2), with f_p=10.

    - At each excursion, p is chosen with probability 1.

    - So, f_p increases by 1 after each choice.

    - Therefore, f_p at each excursion t is 10 + (number of times p was chosen in previous excursions).

    - At t=1: f_p=10.

    - At t=2: f_p=10 + 1 (since p was chosen at t=1).

    - At t=3: f_p=10 + 2.

    - ...

    - At t=10: f_p=10 + 9.

    - Therefore, sum S = 10 + 11 + 12 + ... + 19 = 10*10 + (0+1+2+...+9) = 100 + 45 = 145.

    - But according to the note, it's 55.

    - Wait, perhaps I misread the note.

32. **Checking the note again:**

    - "For the second test case, there is only one pair possible (1,2) and its friendship value is initially 1, so each turn they are picked and their friendship value increases by 1. Therefore, the total sum is 1 + 2 + 3 + … + 10 = 55."

    - Wait, in this case, n=2, m=1, k=10.

    - But in the input, f_i=10.

    - Wait, in the second test case, input is:

        - 2 1 10

        - 1 2 10

    - So, f_i=10.

    - But in the note, it says "initially 1", but in the input, f_i=10.

    - Maybe I misread the note.

33. **Re-reading the note:**

    - "For the second test case, there is only one pair possible (1,2) and its friendship value is initially 1, so each turn they are picked and their friendship value increases by 1. Therefore, the total sum is 1 + 2 + 3 + … + 10 = 55."

    - Wait, in the input, f_i=10.

    - Perhaps the note is referring to a different test case.

34. **Looking back at the sample input:**

    - Sample input:

        - 4

        - 100 0 24

        - 2 1 10

        - 1 2 1

        - 3 1 2

        - 2 1 1

        - 5 2 4

        - 1 2 25

        - 3 2 24

    - So, the second test case is:

        - 2 1 10

        - 1 2 1

    - Wait, m=1, but the friendship value f_i=1.

    - So, in this case, sum_f=1.

    - C=1.

    - E[S] = (10 * 1)/1 + (1 * 10 * 9)/(2 * 1^2) = 10 + 45 = 55.

    - Which matches the note.

    - Earlier, I misread the input.

35. **Correcting the earlier mistake:**

    - In the second test case, f_i=1, not 10.

    - So, sum_f=1.

    - Therefore, E[S] = (10*1)/1 + (1*10*9)/(2*1^2) = 10 + 45 = 55.

    - Which matches the note.

    - Earlier, I misread the input and thought f_i=10.

36. **Continuing with the correct understanding:**

    - The formula E[S] = (k * sum_f)/C + (m * k * (k-1))/(2 * C^2) seems correct.

    - Now, to implement this, need to handle large numbers and modular inverses.

    - Define M = 10^9 + 7.

    - Compute C = n*(n-1)//2.

    - Compute sum_f = sum of f_i for all m friend pairs.

    - Compute inv_C = pow(C, M-2, M).

    - Compute inv_C2 = pow(C*C, M-2, M).

    - Compute inv2 = pow(2, M-2, M).

    - Compute first_term = (k * sum_f * inv_C) % M.

    - Compute second_term = (m * k * (k-1) * inv_C2 * inv2) % M.

    - Compute E[S] = (first_term + second_term) % M.

    - Print E[S].

37. **Implementing the function:**

    - Read t.

    - For each test case:

        - Read n, m, k.

        - C = n*(n-1)//2.

        - sum_f = sum of f_i for m friend pairs.

        - inv_C = pow(C, M-2, M).

        - inv_C2 = pow(C*C, M-2, M).

        - inv2 = pow(2, M-2, M).

        - first_term = (k * sum_f * inv_C) % M.

        - second_term = (m * k * (k-1) * inv_C2 * inv2) % M.

        - E_S = (first_term + second_term) % M.

        - Print E_S.

38. **Testing with sample inputs:**

    - First test case:

        - n=100, m=0, k=24.

        - C=4950.

        - sum_f=0.

        - inv_C = pow(4950, 10**9+5, 10**9+7).

        - first_term = (24 * 0 * inv_C) % M = 0.

        - second_term = (0 * 24 * 23 * inv_C2 * inv2) % M = 0.

        - E_S = 0.

        - Matches sample output.

    - Second test case:

        - n=2, m=1, k=10.

        - C=1.

        - sum_f=1.

        - inv_C = 1.

        - inv_C2 = 1.

        - inv2 = 500000004.

        - first_term = (10 * 1 * 1) % M = 10.

        - second_term = (1 * 10 * 9 * 1 * 500000004) % M = 90 * 500000004 % M.

        - 90 * 500000004 = 45000000360 % M = 45.

        - E_S = (10 + 45) % M = 55.

        - Matches sample output.

    - Third and fourth test cases can be similarly verified.

39. **Implementing the function in code:**

    - Define M = 10**9 + 7.

    - For each test case:

        - Read n, m, k.

        - C = n*(n-1)//2.

        - sum_f = sum of f_i for m friend pairs.

        - inv_C = pow(C, M-2, M).

        - inv_C2 = pow(C*C, M-2, M).

        - inv2 = pow(2, M-2, M).

        - first_term = (k * sum_f * inv_C) % M.

        - second_term = (m * k * (k-1) * inv_C2 * inv2) % M.

        - E_S = (first_term + second_term) % M.

        - Print E_S.

40. **Final solution code:**

    ```python

    def main():

        import sys

        input = sys.stdin.read

        data = input().split()

        ptr = 0

        t = int(data[ptr])

        ptr += 1

        M = 10**9 + 7

        for _ in range(t):

            n = int(data[ptr])

            m = int(data[ptr+1])

            k = int(data[ptr+2])

            ptr += 3

            C = n * (n - 1) // 2

            sum_f = 0

            for _ in range(m):

                a = int(data[ptr])

                b = int(data[ptr+1])

                f = int(data[ptr+2])

                ptr += 3

                sum_f += f

            inv_C = pow(C, M - 2, M)

            inv_C2 = pow(C * C, M - 2, M)

            inv2 = pow(2, M - 2, M)

            first_term = (k * sum_f * inv_C) % M

            second_term = (m * k * (k - 1) * inv_C2 * inv2) % M

            E_S = (first_term + second_term) % M

            print(E_S)

    if __name__ == "__main__":

        main()

    ```

**Final Solution**

To solve this problem, we need to calculate the expected sum of friendship values for pairs of children chosen during excursions, considering that friendship values increase over time.

### Approach

1. **Understanding the Problem:**
   - There are `n` children and `m` pairs of friends with initial friendship values.
   - The teacher chooses pairs randomly for `k` excursions.
   - If a chosen pair are friends, their friendship value increases by 1 for all subsequent excursions.

2. **Key Insights:**
   - Use linearity of expectation to compute the expected sum of friendship values.
   - Calculate the expected friendship value for each excursion and sum them up.

3. **Mathematical Formulation:**
   - Let `C` be the total number of possible pairs: `C = n * (n - 1) / 2`.
   - Let `sum_f` be the sum of initial friendship values of the `m` friend pairs.
   - For each excursion `t`, the expected friendship value is:
     \[
     E[\text{sum of friendship values}] = \frac{k \cdot \text{sum\_f}}{C} + \frac{m \cdot k \cdot (k - 1)}{2 \cdot C^2}
     \]

4. **Modular Arithmetic:**
   - Compute the result modulo `10^9 + 7` using modular inverses.

### Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    ptr = 0
    t = int(data[ptr])
    ptr += 1
    M = 10**9 + 7
    for _ in range(t):
        n = int(data[ptr])
        m = int(data[ptr+1])
        k = int(data[ptr+2])
        ptr += 3
        C = n * (n - 1) // 2
        sum_f = 0
        for _ in range(m):
            a = int(data[ptr])
            b = int(data[ptr+1])
            f = int(data[ptr+2])
            ptr += 3
            sum_f += f
        inv_C = pow(C, M - 2, M)
        inv_C2 = pow(C * C, M - 2, M)
        inv2 = pow(2, M - 2, M)
        first_term = (k * sum_f * inv_C) % M
        second_term = (m * k * (k - 1) * inv_C2 * inv2) % M
        E_S = (first_term + second_term) % M
        print(E_S)

if __name__ == "__main__":
    main()
```

### Explanation

1. **Reading Input:**
   - Read the number of test cases `t`.
   - For each test case, read `n`, `m`, and `k`.
   - Read the friend pairs and their initial friendship values.

2. **Calculations:**
   - Compute `C`, the total number of possible pairs.
   - Sum the initial friendship values of the `m` friend pairs.
   - Compute modular inverses for `C`, `C^2`, and `2`.
   - Calculate the two terms of the expected sum formula.
   - Sum the terms and take modulo `10^9 + 7`.

3. **Output:**
   - Print the result for each test case.

This approach ensures efficient computation within the constraints, leveraging mathematical expectations and modular arithmetic for correctness.