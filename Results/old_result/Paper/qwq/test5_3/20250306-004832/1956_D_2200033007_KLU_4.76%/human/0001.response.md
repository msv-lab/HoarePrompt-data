Alright, I've got this problem to solve. Let's see what it's asking for. So, Nene gave me an array of integers, and I can perform a specific operation on it multiple times to maximize the sum of the array. The operation involves choosing a subarray, computing its MEX, and then setting all elements in that subarray to that MEX value. I need to do this in a way that the sum of the array is as large as possible, and I can perform this operation up to 5*10^5 times, but I don't need to minimize the number of operations, just not exceed the limit.

First, I need to understand what MEX is. MEX stands for "minimum excludant," which is the smallest non-negative integer not present in a given set. For example, the MEX of [0, 1, 3] is 2, because 0 and 1 are present, but 2 is not.

So, the operation allows me to choose any subarray, compute its MEX, and then set all elements in that subarray to that MEX value. I can do this up to 5*10^5 times, but I don't have to use all of them; I just need to make sure that I don't exceed that number.

The constraints say that n can be up to 18, which is relatively small, so I don't need to worry about time constraints too much. Also, a_i can be up to 10^7, which is quite large, but since n is small, it should be manageable.

Looking at the examples:

In the first example:

n = 2

a = [0, 1]

After one operation on the entire array, MEX of [0,1] is 2, so set both elements to 2, resulting in [2,2], sum is 4.

They say it's impossible to get a larger sum.

In the second example:

n = 3

a = [1,3,9]

No operations are needed because the sum is already 13, which is the maximum possible.

In the third example:

n = 4

a = [1,100,2,1]

They perform two operations:

First operation on a[3], MEX of [2] is 0, so set a[3] to 0, array becomes [1,100,0,1]

Second operation on a[3:4], MEX of [0,1] is 2, set both to 2, resulting in [1,100,2,2], sum is 105.

They say it's impossible to get a larger sum.

In the fourth example:

n = 1

a = [0]

Perform one operation: MEX of [0] is 1, set to 1, sum is 1.

Okay, so from these examples, it seems that the goal is to strategically choose subarrays to operate on in order to increase the values in the array, but somehow, in some cases, no operations are needed because the sum is already maximized.

I need to find a way to maximize the sum of the array using these operations.

First, I need to think about what effect these operations have.

When I choose a subarray and set all its elements to its MEX, I'm essentially replacing the subarray with a new value that is the smallest non-negative integer not present in the original subarray.

So, for example, if I have a subarray [0,1], MEX is 2, which is larger than both 0 and 1, so setting both to 2 increases the sum.

But, if I have a subarray [0,1,2], MEX is 3, which is larger than any element in the subarray, so setting all to 3 increases the sum.

However, if I have a subarray [0,1,2,3], MEX is 4, still larger, but maybe there are better choices.

Wait, but in the second example, [1,3,9], the MEX is 0, since 0 is not present, but setting all to 0 would decrease the sum, which is why no operation is performed.

So, in some cases, performing an operation can decrease the sum, which is not desirable.

Hence, I need to be careful about which subarrays I choose to operate on.

I need a strategy to select subarrays such that setting them to their MEX increases the sum as much as possible.

Let me think about the properties of MEX.

Given a set of numbers, MEX is the smallest non-negative integer not in the set.

So, for any set of numbers, MEX is always greater than any number in the set that is less than MEX, and it's the smallest such number.

For example, if the subarray contains [0,1,3], MEX is 2, which is greater than 0 and 1, but less than 3.

Wait, but in this case, setting [0,1,3] to 2 would increase 0 and 1 to 2, but decrease 3 to 2.

So, the sum changes from 0+1+3=4 to 2+2+2=6, which is an increase of 2.

Similarly, in the first example, [0,1] to [2,2], sum increases from 1 to 4.

In the third example, first operation on a single element [2], MEX is 0, so setting it to 0 decreases the sum, but then another operation on [0,1] to [2,2], which increases the sum.

Wait, but in the third example, their operations lead to a final sum of 105, which is higher than the initial sum.

Wait, what was the initial sum in the third example?

a = [1,100,2,1], sum is 1+100+2+1=104.

After first operation on a[3], which is 2, MEX of [2] is 0, set to 0, array becomes [1,100,0,1], sum is 1+100+0+1=102.

Then, operation on a[3:4], which is [0,1], MEX is 2, set to 2, array becomes [1,100,2,2], sum is 1+100+2+2=105.

So, overall, the sum increased from 104 to 105.

But, if I had operated on different subarrays, maybe I could have gotten a higher sum?

Let's see.

Is there a way to make some elements even larger?

For example, could I have operated on [1,100,2], compute MEX, set them all to MEX, and see what happens?

Let's try:

Subarray [1,100,2], MEX is 0, since 0 is not present.

Setting all to 0, array becomes [0,0,0,1], sum is 1, which is worse.

Or, subarray [1,100], MEX is 0, set to 0, array becomes [0,0,2,1], sum is 3.

Not better.

Or, subarray [100,2,1], MEX is 0, set to 0, array becomes [1,0,0,0], sum is 1.

Worse.

So, in this case, the operations they provided lead to a sum of 105, which is better than the initial sum of 104, and seems to be the maximum possible.

In the second example, [1,3,9], MEX is 0, but setting all to 0 decreases the sum to 0, which is worse than the initial 13, so no operation is performed.

Hence, in some cases, performing an operation can decrease the sum, so I need to be careful to only perform operations that increase the sum.

But, in the third example, the first operation decreases the sum from 104 to 102, but the second operation increases it to 105, which is still higher than the initial sum.

So, sometimes, it might be beneficial to perform operations that temporarily decrease the sum if later operations can increase it further.

But, this seems complicated to manage, especially since n is small (n <= 18), so maybe I can find an optimal strategy.

Let me think differently.

What is the maximum possible sum I can achieve?

Well, each element in the array can be set to some non-negative integer, but there are constraints based on the MEX operations.

I need to find an array where each subarray's MEX doesn't contradict the values in the array.

This seems tricky.

Wait, perhaps I can think in terms of the overall MEX of the entire array.

But, no, because MEX is defined for any subarray, and operations can be performed on any subarray.

I need a way to maximize each element individually, considering the constraints from the MEX operations on various subarrays.

This seems like a problem that can be modeled using graph theory or some kind of constraint propagation.

Given that n is small (n <= 18), maybe I can model this as a flow network or use some kind of dynamic programming.

Alternatively, perhaps I can think of the final array values as variables that need to satisfy certain conditions based on the MEX operations.

Wait, perhaps I can consider the final value of each element and ensure that for every subarray, the MEX is consistent with the values in the subarray.

But this seems too broad.

Let me consider that each element in the final array can be set to any value, but subject to the constraints imposed by the MEX operations.

But it's not clear how to model this.

Maybe I need to consider that for each subarray, if I set it to its MEX, then the MEX should be less than or equal to the maximum possible value in that subarray.

Wait, no, MEX is the smallest missing non-negative integer in the subarray, so it's greater than any value less than MEX in the subarray.

This is getting complicated.

Perhaps a better approach is to consider that the final array should be such that for any subarray, the MEX is at least as large as the current value in the array, considering the operations performed.

But I'm not sure.

Let me think about the problem differently.

Suppose I fix the final array and try to see if it's achievable through some sequence of operations.

Given that I can perform up to 5*10^5 operations, which is much larger than n, I can assume that I can perform as many operations as needed, as long as it's less than or equal to 5*10^5.

But n is small (n <= 18), so even if I need to perform operations exponential in n, it's still manageable because 2^18 is around 262,000, which is less than 5*10^5.

So, perhaps I can consider all possible subarrays and their MEX operations, and see how they affect the array.

But that seems too time-consuming and not efficient.

Let me consider that each operation allows me to set a subarray to its MEX, and I can do this multiple times.

I need to find a sequence of such operations that maximizes the sum of the array.

Perhaps I can start by considering the entire array and performing the operation on it, then recursively applying the operation on subarrays where it's beneficial.

But I need a better strategy than that.

Let me consider that MEX is a function that depends on the minimal missing integer in the subarray.

So, for a subarray with all elements greater than or equal to some value, its MEX will be less than or equal to that value.

Wait, no.

Actually, MEX is the smallest non-negative integer not present in the subarray.

So, if a subarray contains all integers from 0 to k except some, then MEX would be the smallest missing one.

But it's not straightforward.

Maybe I need to look for a way to maximize each element individually, considering the constraints from the subarrays that include that element.

Given that n is small, maybe I can model this as a constraint satisfaction problem, where each position has a variable representing its final value, and there are constraints based on the MEX operations on subarrays.

But I'm not sure how to implement that.

Alternatively, perhaps I can think in terms of dynamic programming, where I consider the array positions one by one and keep track of some state that represents the MEX constraints.

But again, it's not clear.

Let me consider the problem in terms of the final array values.

Suppose I have the final array a_1, a_2, ..., a_n.

For any subarray a_l to a_r, the MEX of that subarray should be at least the value of a_l to a_r, because if I perform an operation on that subarray, it would set all elements to the MEX, but since the array is already set to that value, it doesn't change.

Wait, that might not be accurate.

Actually, the MEX of any subarray in the final array should be greater than or equal to the maximum value in that subarray plus one, because if the MEX is x, then all values from 0 to x-1 are present in the subarray, and x is not present.

But in our case, after operations, the subarray is set to a single value, say y, so the MEX of that subarray would be y if y is not present, but since all elements are y, MEX would be the smallest number not equal to y.

Wait, no.

If all elements in the subarray are y, then the MEX is the smallest non-negative integer not equal to y.

But MEX is defined as the smallest non-negative integer not present in the set.

So, if all elements are y, then MEX is the smallest z not equal to y.

But z could be less than y or greater than y, depending on y.

This seems confusing.

Perhaps I need to think differently.

Let me consider that after performing operations, the array is divided into segments where each segment has the same value, and the operations are performed on those segments.

But I need to maximize the sum, so I need to set as many elements as possible to the highest possible values.

But I need to ensure that the MEX constraints are satisfied.

This is getting too vague.

Let me look back at the examples to get some insights.

In the first example:

n=2, a=[0,1]

Operation on [1,2], MEX is 2, set both to 2, sum=4.

No other operation can be performed because MEX of [1,2] is now 0 (since 0 and 1 are not present, but MEX is defined as the smallest non-negative integer not present in the set, which is 0, but in this case, it's already present, wait no.

Wait, if the array is [2,2], then the MEX of [1,2] is 0, since 0 is not present.

But according to the operation, setting [1,2] to MEX would set both to 0, but in the example, they set both to 2.

Wait, perhaps I'm misunderstanding the MEX definition in this context.

Wait, no, in the first operation, when the array is [0,1], MEX is 2, so set both to 2.

Then, in the next operation, if I choose [1,2], MEX is 0, because 0 is not present, but setting both to 0 would decrease the sum, which is not desirable.

Hence, no more operations are performed.

So, in this case, performing one operation increases the sum, and further operations are not beneficial.

In the second example, [1,3,9], MEX of the entire array is 0, since 0 is not present.

Setting all to 0 would decrease the sum to 0, which is worse than 13, so no operation is performed.

In the third example, [1,100,2,1], they perform two operations:

First, on [3], MEX is 0, set to 0, array becomes [1,100,0,1]

Then, on [3,4], MEX is 2, set to 2, array becomes [1,100,2,2], sum=105.

Alternatively, if I perform operations differently, would I get a higher sum?

Let's try.

What if I perform operation on [2,3,4], which is [100,2,1], MEX is 0, set all to 0, array becomes [1,0,0,0], sum=1, which is worse.

Or, operation on [1,2], which is [1,100], MEX is 0, set to 0, array becomes [0,0,2,1], sum=3.

Still worse than initial sum.

So, their operations leading to 105 seem optimal.

In the fourth example, n=1, a=[0], operation on [1,1], MEX is 1, set to 1, sum=1.

That's the maximum possible.

So, in general, it seems that performing operations on subarrays where setting them to MEX increases the sum is beneficial, but need to be careful not to decrease the sum overall.

Given that n is small, maybe I can consider all possible final arrays and check if they are achievable through some sequence of operations.

But that seems too time-consuming.

Alternatively, perhaps I can model this as a graph where nodes represent possible values for each position, and edges represent the possibility of performing operations that set subarrays to their MEX.

But this seems too complicated.

Let me consider that for the final array, for any subarray, the MEX should be equal to the value to which the subarray was set in the last operation performed on it.

But I'm getting lost.

Maybe I need to look for a different approach.

Given that n is small, perhaps I can consider the final value of each element and ensure that it's consistent with the MEX operations performed on the subarrays containing that element.

Wait, perhaps I can think in terms of upper bounds for each element.

For each element, its final value cannot exceed the MEX of any subarray containing that element.

But that's not accurate.

Actually, when you perform an operation on a subarray, you set all elements in that subarray to the MEX of that subarray.

So, in the final array, for any subarray, if you perform an operation on it, it should not increase the sum, meaning that the MEX of that subarray should not be greater than the minimum value in the subarray.

Wait, that might not hold.

Let me think differently.

Suppose I fix the final array, and I need to ensure that for any subarray, if I compute its MEX, it should be equal to the value to which that subarray was set in the last operation performed on it.

But this seems too vague.

Perhaps I need to consider that in the final array, for any subarray, the MEX should be greater than or equal to some value based on the subarray's elements.

This is getting too abstract.

Let me try to think about the problem in terms of the maximum possible value each element can take, considering the constraints from the subarrays it belongs to.

Each element is part of multiple subarrays: from position i to j, for all 1 <= i <= j <= n.

For each such subarray, performing an operation sets all elements in it to the MEX of the original subarray.

So, in the final array, each element's value is determined by the last operation performed on any subarray containing that element.

Given that operations can overlap, it's complex to track.

Maybe I need to consider that the final value of an element is the maximum MEX of any operation performed on any subarray containing that element.

But MEX depends on the original values in the subarray, not the final ones.

This is getting too tangled.

Perhaps I need to accept that finding the exact maximum sum is non-trivial and look for a heuristic approach that maximizes the sum without necessarily finding the absolute optimal in all cases.

Given that n is small, maybe I can greedily select subarrays to operate on, choosing those that offer the most significant increase in sum.

For example, find a subarray where setting it to its MEX increases the sum the most, perform that operation, and repeat until no more operations can increase the sum.

But this could be time-consuming if I have to check all possible subarrays multiple times.

Given that n is up to 18, the total number of subarrays is n*(n+1)/2, which is around 170 for n=18, which is manageable.

So, perhaps I can implement a greedy approach where I repeatedly select the subarray that, when operated on, provides the maximum possible increase in sum, and perform that operation, updating the array accordingly, and repeat this process until no operation can increase the sum.

This seems feasible.

To implement this, I need to:

1. Compute the MEX for all possible subarrays based on the current array values.

2. For each subarray, calculate the sum difference if I perform the operation on it (i.e., set all elements in the subarray to its MEX).

3. Select the subarray that gives the maximum sum increase, perform the operation, and update the array.

4. Repeat steps 1-3 until no subarray can be found where performing the operation increases the sum.

5. Collect all the operations performed and output the final sum and the sequence of operations.

Given that n is small, and the number of operations is limited to 5*10^5, which is way more than enough for n=18, this should work.

But, to optimize, I need to make sure that I don't perform too many operations, as it could be slow despite n being small.

So, perhaps I can optimize the selection of subarrays by prioritizing those with the largest possible MEX values.

Alternatively, I can think about sorting the subarrays based on the potential sum increase and pick the one with the highest increase first.

This sounds similar to a greedy algorithm.

Let me try to outline this algorithm more formally.

Algorithm:

1. Initialize an empty list to store operations.

2. While True:

a. Compute the MEX for all possible subarrays based on the current array values.

b. For each subarray, calculate the sum difference if the operation is performed.

c. If there exists at least one subarray where the sum difference is positive, select the one with the maximum sum difference, perform the operation, update the array, and add the operation to the list.

d. If no such subarray exists, break the loop.

3. Calculate the final sum of the array and output it along with the number of operations and the list of operations.

This seems correct, but I need to ensure that it converges in a reasonable number of operations.

Given that n is small, and the number of possible subarrays is manageable, this should be fine.

But, to make it efficient, I need an efficient way to compute the MEX for all subarrays.

Computing MEX for all subarrays naively would take O(n^3), which for n=18 is about 5,832 operations, which is acceptable.

But perhaps I can optimize it further.

Alternatively, since n is small, I can precompute all subarrays and store their MEX values, updating them as I perform operations.

Wait, but MEX depends on the current values in the subarray, so I need to recalculate it after each operation.

This could be time-consuming if I perform many operations.

Maybe I need to find a smarter way.

Let me consider that the final value of each element is determined by the last operation that included it.

So, if I can assign to each element the maximum possible value that can be set to it through some operation, considering the constraints from overlapping operations.

But this seems too vague.

Alternatively, perhaps I can model this as a graph where nodes represent possible values for each position, and edges represent compatibility based on MEX constraints from subarrays.

But this might be overkill.

Given time constraints, perhaps I should implement the greedy algorithm and see if it works for the sample inputs.

Let's try applying this algorithm to the first sample input.

Sample Input 1:

n=2

a=[0,1]

Possible subarrays:

[1]: [0], MEX is 1

[2]: [1], MEX is 0

[1,2]: [0,1], MEX is 2

Possible operations:

- Operation on [1], set a[1] to 1, array becomes [1,1], sum=2

- Operation on [2], set a[2] to 0, array becomes [0,0], sum=0

- Operation on [1,2], set both to 2, array becomes [2,2], sum=4

Among these, the operation on [1,2] gives the maximum sum increase to 4.

So, perform this operation, and the array becomes [2,2].

Now, recalculate MEX for all subarrays:

[1]: [2], MEX is 0

[2]: [2], MEX is 0

[1,2]: [2,2], MEX is 0

Possible operations:

- Operation on [1], set a[1] to 0, array becomes [0,2], sum=2

- Operation on [2], set a[2] to 0, array becomes [2,0], sum=2

- Operation on [1,2], set both to 0, array becomes [0,0], sum=0

None of these operations increase the sum, so stop.

Final sum is 4, which matches the sample output.

Good.

Let's try the third sample input.

Sample Input 3:

n=4

a=[1,100,2,1]

Possible operations:

- Operation on [1], MEX is 0, set to 0, array becomes [0,100,2,1], sum=103

- Operation on [2], MEX is 0, set to 0, [1,0,