Alright, I've got this problem to solve. Let's see what it's asking for. So, Bob has a bakery, and on the opening day, he baked n buns that he wants to sell. Normally, each bun costs a coins, but to attract customers, he's running a promotion.

The promotion works like this: Bob chooses some integer k (between 0 and the smaller of n or b) and sells the first k buns at a modified price. The price for the i-th bun (where i goes from 1 to k) is (b - i + 1) coins. The remaining (n - k) buns are sold at the usual price of a coins each.

My task is to help Bob determine the maximum profit he can make by choosing the best k for this promotion.

First, I need to understand the promotion clearly. If Bob chooses k = 0, he sells all n buns at the usual price a coins each. So, the total profit would be n * a.

If he chooses k = 1, he sells the first bun for b coins and the remaining (n - 1) buns at a coins each. So, the total profit would be b + (n - 1) * a.

If he chooses k = 2, the first bun is sold for b coins, the second for (b - 1) coins, and the remaining (n - 2) buns at a coins each. So, the total profit is b + (b - 1) + (n - 2) * a.

I see a pattern here. For a general k, the profit would be the sum of the first k terms of an arithmetic sequence starting from b and decreasing by 1 each time, plus (n - k) * a.

So, the profit for a given k is:

sum from i=1 to k of (b - i + 1) + (n - k) * a

Let me simplify this sum.

The sum of the first k terms of the sequence is:

sum_{i=1 to k} (b - i + 1) = sum_{i=1 to k} (b + 1 - i) = k*(b + 1) - sum_{i=1 to k} i = k*(b + 1) - k*(k + 1)/2

So, profit_k = k*(b + 1) - k*(k + 1)/2 + (n - k)*a

Let me double-check this formula.

Wait, actually, the i-th bun is sold for (b - i + 1), so for i from 1 to k, the prices are b, (b-1), (b-2), ..., (b - k + 1).

So, the sum of these prices is the sum of an arithmetic series from b to (b - k + 1).

The sum of an arithmetic series is (number of terms)/2 * (first term + last term).

So, sum = k/2 * (b + (b - k + 1)) = k/2 * (2b - k + 1)

Therefore, profit_k = (k/2)*(2b - k + 1) + (n - k)*a

Wait, let's compare this with my earlier formula.

Earlier, I had:

profit_k = k*(b + 1) - k*(k + 1)/2 + (n - k)*a

Let me simplify that:

k*(b + 1) - k*(k + 1)/2 + (n - k)*a = k*b + k - (k^2 + k)/2 + n*a - k*a = k*b + k - (k^2)/2 - k/2 + n*a - k*a

Wait, this seems more complicated than the other formula.

Let me stick with the sum formula I derived later:

profit_k = (k/2)*(2b - k + 1) + (n - k)*a

This seems simpler.

So, to maximize profit, I need to choose k between 0 and min(n, b) that maximizes this expression.

Now, since k can be up to 10^9 and t can be up to 10^4, I need an efficient way to compute this for each test case.

Let me see if there's a way to find the optimal k without checking all possible k values.

Given that k can be up to 10^9, iterating through all possibilities is not feasible.

Let me see if the profit function is concave or convex, or if it has some monotonicity that I can exploit.

Looking at profit_k = (k/2)*(2b - k + 1) + (n - k)*a

Let me expand this:

profit_k = (k*(2b - k + 1))/2 + n*a - k*a

Simplify:

= (2b*k - k^2 + k)/2 + n*a - k*a

= (2b*k)/2 - (k^2)/2 + k/2 + n*a - k*a

= b*k - (k^2)/2 + k/2 + n*a - k*a

Combine like terms:

= n*a + k*(b + 1/2 - a) - (k^2)/2

This is a quadratic in terms of k: - (k^2)/2 + k*(b + 0.5 - a) + n*a

Since the coefficient of k^2 is negative (-1/2), this is a downward-opening parabola, meaning it has a maximum at its vertex.

In general, for a quadratic function f(k) = c*k^2 + d*k + e, the maximum/minimum occurs at k = -d/(2*c).

Here, c = -1/2, d = (b + 0.5 - a), so the vertex is at k = -(b + 0.5 - a)/(2*(-1/2)) = (b + 0.5 - a)/1 = b + 0.5 - a

But k has to be an integer between 0 and min(n, b), so I can consider rounding b + 0.5 - a to the nearest integer and checking within the bounds.

However, since b and a can be up to 10^9, and n up to 10^9, I need to ensure that this approach is accurate and efficient.

Alternatively, since the profit function is quadratic in k and downward-opening, I can perform a binary search over k to find the maximum profit.

Given that k can be up to 10^9, binary search seems suitable as it would take at most log2(10^9) which is about 30 steps per test case.

Given that t can be up to 10^4, and each test case would require up to 30 steps, this should be efficient enough.

So, I'll implement a binary search over k to find the maximum profit.

Let me outline the steps:

1. For each test case, read n, a, b.

2. Set the search range for k from 0 to min(n, b).

3. Use binary search to find the k that maximizes profit_k.

4. Calculate the profit for the found k and output it.

Now, to implement the binary search, I need a way to compare profits for different k values.

In the binary search, I'll maintain a low and high pointer, and repeatedly choose the middle k and decide whether to go left or right based on how the profit changes.

Specifically, for each mid k, I'll compute profit_k and profit_{k+1}, and if profit_{k+1} > profit_k, I'll search in the higher half (k+1 to high), else in the lower half (low to k-1).

This way, I can converge to the optimal k.

I need to handle the cases where k = 0 or k = min(n, b), making sure not to go out of bounds.

Also, I need to handle cases where n, a, or b are 0, but according to the problem, n, a, b are at least 1.

Wait, the constraints say 1 <= n, a, b <= 10^9, so I don't need to worry about 0.

Let me also consider some examples to verify my approach.

Take the first example:

n = 4, a = 4, b = 5

Possible k values: 0, 1, 2, 3, 4 (but min(n, b) = 4)

For k = 0: profit = 4*4 = 16

k = 1: 5 + 4*3 = 5 + 12 = 17

k = 2: 5 + 4 + 4*2 = 9 + 8 = 17

k = 3: 5 + 4 + 3 + 4*1 = 12 + 4 = 16

k = 4: 5 + 4 + 3 + 2 = 14

So, the maximum is 17, achieved at k = 1 and k = 2.

My binary search should find one of these k values.

Another example:

n = 5, a = 5, b = 9

k from 0 to 5

k=0: 25

k=1:9 + 20 =29

k=2:9+8 +15=32

k=3:9+8+7 +10=34

k=4:9+8+7+6 +5=35

k=5:9+8+7+6+5=35

So, maximum is 35 for k=4 and k=5.

Another example:

n=10, a=10, b=5

k from 0 to 5

k=0:100

k=1:5 + 90 =95

k=2:5+4 +80=89

k=3:5+4+3 +70=82

k=4:5+4+3+2 +60=74

k=5:5+4+3+2+1 +50=65

So, maximum is 100 for k=0.

This matches the third test case in the note.

So, my approach seems correct.

Now, to implement this efficiently, I need to code the profit function correctly.

Let me define profit_k = sum of first k terms of the sequence from b to b - k +1 + (n - k)*a

As I earlier derived, profit_k = (k/2)*(2*b - k +1) + (n - k)*a

I need to ensure that this is correctly implemented, considering that k can be up to 10^9 and n up to 10^9, so I need to handle large numbers properly.

Also, since t can be up to 10^4, I need to make sure that the code is optimized.

In the provided program, there's a func_1 that computes this:

def func_1(k, n, a, b):

return k * b - k * (k - 1) // 2 + (n - k) * a

Wait, this seems different from my formula.

Wait, let's see:

My formula: (k/2)*(2b - k +1) + (n - k)*a

Their formula: k*b - k*(k - 1)//2 + (n - k)*a

Let me expand their formula:

k*b - k*(k - 1)/2 + (n - k)*a

This is similar to what I had earlier:

k*b - k*(k - 1)/2 + n*a - k*a

Which simplifies to:

k*b - k*(k - 1)/2 + n*a - k*a

Wait, is this equal to my formula?

Let me compare:

My formula: b*k - k^2/2 + k/2 + n*a - k*a

Their formula: b*k - k*(k - 1)/2 + n*a - k*a

Simplify their formula:

b*k - (k^2 - k)/2 + n*a - k*a = b*k - k^2/2 + k/2 + n*a - k*a

Which matches my formula.

So, func_1 is correctly implemented.

Now, in func_2, they perform a binary search between low=0 and high=min(n, b).

Which is correct.

Then, in the loop, they calculate profit_mid and profit_next, and update max_profit.

They also decide whether to go left or right based on whether profit_next > profit_mid.

This seems correct for finding the maximum.

Wait, but in a standard binary search for maximum, we need to find the point where the function stops increasing and starts decreasing.

So, we need to find the k where profit_k >= profit_{k+1}, and profit_k >= profit_{k-1}.

In the provided code, they check if profit_next > profit_mid, and if so, set low = mid + 1, else high = mid - 1.

This seems correct because if profit_next > profit_mid, then the maximum must be in the higher half, else in the lower half.

Also, they keep updating max_profit with the current profit_mid.

Finally, they return max_profit.

This seems correct.

Let me check with the first example:

n=4, a=4, b=5

k from 0 to 4

profits: 16,17,17,16,14

So, maximum is 17.

The binary search would start with low=0, high=4, mid=2

profit_mid = 17, profit_next=17 >17 is False, so high=1

Then low=0, high=1, mid=0

profit_mid=16, profit_next=17>16, so low=1+1=2

Now low=2, high=1, loop ends.

Max_profit is 17.

Correct.

Second example:

n=5, a=5, b=9

k from 0 to 5

profits:25,29,32,34,35,35

low=0, high=5, mid=2

profit_mid=32, profit_next=34>32, so low=3

Then low=3, high=5, mid=4

profit_mid=35, profit_next=35 not >, so high=3-1=2

Then low=3, high=2, loop ends.

Max_profit is 35.

Correct.

Third example:

n=10, a=10, b=5

k from 0 to 5

profits:100,95,89,82,74,65

low=0, high=5, mid=2

profit_mid=89, profit_next=82<89, so high=1

Then low=0, high=1, mid=0

profit_mid=100, profit_next=95<100, so high=-1

Loop ends.

Max_profit is 100.

Correct.

Seems like the approach works.

Therefore, the given program is correct.

**Final Answer**

\[ \boxed{\text{See explanation for the solution code.}} \]

**Correctness: True**