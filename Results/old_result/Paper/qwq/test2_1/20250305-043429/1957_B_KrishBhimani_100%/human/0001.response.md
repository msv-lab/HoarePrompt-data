Alright, I have this problem to solve. Let's see what it's asking for. So, I'm given two integers, n and k. I need to construct a sequence of n non-negative integers that sum up to k. Additionally, I have to maximize the number of 1s in the binary representation of the bitwise OR of all these numbers in the sequence.

First, I need to understand what bitwise OR does. Bitwise OR takes two numbers and performs the OR operation on each pair of corresponding bits. For example, 1 OR 2 is 3 because in binary, 1 is 01 and 2 is 10, and OR'ing them gives 11, which is 3.

So, the goal is to have the bitwise OR of all the numbers in the sequence have as many 1s in its binary representation as possible.

Let me think about how to approach this.

Given that I have to maximize the number of 1s in the binary representation of the OR of all the numbers, I need to set as many bits as possible in the OR operation.

Since OR combines the bits, a bit in the final result will be 1 if at least one of the numbers in the sequence has that bit set to 1.

So, to maximize the number of 1s in the OR, I need to have as many different bits set to 1 across all the numbers in the sequence.

But there's a constraint: the sum of all the numbers in the sequence must be k.

So, I need to distribute the sum k among n numbers such that as many different bits are set across these numbers as possible.

Let me consider an example to get a better understanding.

Take the second test case from the example:

n = 2, k = 3

Possible sequences:

- [1, 2]: sum is 3, and 1 | 2 = 3, which in binary is 11, having two 1s.

- [0, 3]: sum is 3, and 0 | 3 = 3, same as above.

- [3, 0]: same as above.

- [1, 2]: same as above.

So, in this case, the maximum number of 1s in the OR is 2.

Another example:

n = 1, k = 5

Sequence: [5], and 5 in binary is 101, which has two 1s.

Another sequence is not possible since n=1.

Third example:

n = 2, k = 5

Possible sequences:

- [5,0]: 5 | 0 = 5, which is 101 in binary, two 1s.

- [1,4]: 1 | 4 = 5, same as above.

- [2,3]: 2 | 3 = 3, which is 11 in binary, two 1s.

- [3,2]: same as above.

So, the maximum number of 1s in the OR is two.

Wait, but in the problem statement, for n=2 and k=5, the output is [5,0], which has two 1s in the OR.

But in the fourth test case:

n=6, k=51

Output: [3,1,1,32,2,12]

Let's see:

3 is 00003 (binary 11)

1 is 00001 (binary 01)

1 is 00001 (binary 01)

32 is 00032 (binary 100000)

2 is 00002 (binary 10)

12 is 00012 (binary 1100)

OR'ing all these together:

Starting with 0:

- OR 3: 011

- OR 1: 011

- OR 1: still 011

- OR 32: 100000 | 011 is 100011

- OR 2: 100011 | 10 is 100011

- OR 12: 100011 | 1100 is 101111

Binary 101111 has five 1s.

So, the OR result has five 1s.

I need to maximize this number of 1s.

So, the strategy seems to be to distribute the sum k among n numbers in such a way that as many different bits are set to 1 across these numbers.

But I also have to ensure that the sum is exactly k.

Let me think about how to maximize the number of 1s in the OR.

Each number in the sequence can set certain bits in the OR.

To maximize the number of 1s in the OR, I need to set as many unique bits as possible across all the numbers.

In other words, I need to have as many bits set to 1 in the final OR result.

Since OR combines the bits, a bit in the OR will be 1 if at least one number in the sequence has that bit set to 1.

Therefore, to maximize the number of 1s in the OR, I need to have as many different bits set across the sequence as possible.

Given that, I should try to set the smallest possible numbers that cover as many unique bits as possible.

Wait, but the numbers have to sum up to k.

So, I need to distribute the sum k among n numbers, ensuring that as many unique bits are set across these numbers.

One approach could be to assign the smallest possible numbers that set new bits.

For example, start with 1 (binary 1), then 2 (binary 10), then 4 (binary 100), and so on, assigning the smallest possible numbers that set new bits, until I've assigned n numbers that sum to k.

But I might need to adjust the last number to make sure the sum is exactly k.

Wait, but in the second test case, n=2, k=3, the output is [1,2], which sets bits 0 and 1.

Another way is to assign numbers that are powers of two, as they set only one bit each.

But if n is larger than the number of bits in k, that might not be possible.

Wait, but I need to maximize the number of 1s in the OR, which corresponds to maximizing the number of unique bits set across all numbers.

So, ideally, I would assign numbers that each set a unique bit.

But, if n is larger than the number of bits in k, I have to handle that.

Wait, what's the number of bits in k?

k can be up to 1e9, which is 30 bits.

But in the problem, they say to maximize the number of 1s in the OR, which is the number of unique bits set across all numbers.

So, to maximize that, I need to have as many unique bits set as possible.

Given that, I should try to assign numbers that each set a unique bit, up to the number of bits in k.

But I need to ensure that the sum is k.

So, perhaps the strategy is:

- Assign the first n-1 numbers as small as possible, each setting a unique bit.

- Assign the last number as k minus the sum of the first n-1 numbers.

This way, the OR will have at least n-1 unique bits set, plus any additional bits set in the last number.

But I need to make sure that the first n-1 numbers set unique bits.

Wait, but if n-1 is larger than the number of bits in k, this might not be possible.

Alternatively, perhaps I should assign the first few numbers to cover as many unique bits as possible, and then adjust the last number to make the sum k.

Wait, perhaps there's a better way.

Let me look at the provided program and see what it's doing.

The program is:

def func():

for _ in range(int(input())):

l1 = input().split()

(n, k) = list(map(int, l1))

if n == 1:

print(k)

else:

arr = []

k0 = k

i = 0

ans = []

temp = 1

while True:

if temp * 2 < k:

temp *= 2

i += 1

else:

break

ans.append((1 << i) - 1)

ans.append(k - sum(ans))

ans += [0] * (n - len(ans))

print(*ans)



So, for each test case, it reads n and k.

If n is 1, it simply prints k.

Else, it initializes some variables and enters a loop where it seems to find the largest number less than k that is one less than a power of two, i.e., (1 << i) - 1.

Wait, let's see.

It sets temp to 1 and doubles it until temp * 2 is no longer less than k.

So, it finds the largest temp such that temp * 2 < k.

Then, temp is set to the largest power of two less than k.

Wait, temp starts at 1 and is doubled until temp * 2 is not less than k.

So, the loop exits when temp * 2 >= k.

Then, it sets ans to contain (1 << i) - 1, which is temp - 1, I think.

Wait, temp is set to the largest power of two less than k.

Wait, temp is doubled until temp * 2 >= k.

So, temp is the largest power of two where temp * 2 < k.

Then, (1 << i) - 1 is temp, since temp is 1 shifted left by i times.

Wait, actually, temp is set to 1 and doubled until temp * 2 >= k.

So, temp is the largest power of two that is less than k.

Then, (1 << i) - 1 is temp, since temp is 1 << i.

Wait, no, 1 << i is temp, and (1 << i) - 1 is all bits up to i-1 set to 1.

Wait, I'm getting confused.

Let me see with an example.

Take n=2, k=3.

temp starts at 1.

temp * 2 = 2 < 3, so temp = 2, i=1.

Then, temp * 2 = 4 >= 3, so loop exits.

ans.append((1<<1)-1 = 2-1=1)

ans.append(3 - 1 = 2)

So, ans = [1,2], which matches the sample output.

Another example: n=2, k=5.

temp=1, temp*2=2<5, temp=2, i=1.

temp=2, temp*2=4<5, temp=4, i=2.

temp=4, temp*2=8>=5, loop exits.

ans.append((1<<2)-1=3)

ans.append(5 - 3 =2)

So, ans=[3,2]

But in the sample output, it's [5,0], which is also correct.

So, both [5,0] and [3,2] are acceptable since both have two 1s in the OR.

So, the program seems to be working correctly for these cases.

Another example: n=6, k=51.

temp=1, temp*2=2<51, temp=2, i=1.

temp=2, temp*2=4<51, temp=4, i=2.

temp=4, temp*2=8<51, temp=8, i=3.

temp=8, temp*2=16<51, temp=16, i=4.

temp=16, temp*2=32<51, temp=32, i=5.

temp=32, temp*2=64>=51, loop exits.

ans.append((1<<5)-1=31)

ans.append(51 - 31 =20)

Then, ans += [0] * (6-2)=4 zeros.

So, ans=[31,20,0,0,0,0]

But in the sample output, it's [3,1,1,32,2,12], which sums to 51 and OR is 101111, which has five 1s.

Wait, but [31,20,0,0,0,0], OR is 31 | 20 | 0 | 0 | 0 | 0 = 31 | 20 = 31 OR 20.

31 is 11111, 20 is 10100, OR is 11111, which is 31, which has five 1s.

So, that matches the sample output in terms of the number of 1s in OR.

So, the program seems to be correct.

But let's see if there are cases where it might not be optimal.

Suppose n=3, k=7.

temp=1, temp*2=2<7, temp=2, i=1.

temp=2, temp*2=4<7, temp=4, i=2.

temp=4, temp*2=8>=7, loop exits.

ans.append((1<<2)-1=3)

ans.append(7 - 3=4)

ans += [0] * (3-2)=1 zero.

So, ans=[3,4,0]

OR is 3 | 4 | 0 = 7, which is 111 in binary, three 1s.

But, is there a better sequence?

Let's see: [1,2,4], sum is 7.

OR is 1 | 2 | 4 = 7, same as above.

[3,4,0], OR is 7.

So, same number of 1s.

Another sequence: [7,0,0], OR is 7, same as above.

So, all give three 1s.

Is there a way to get more than three 1s in the OR?

Well, binary 7 is 111, which has three 1s.

So, that's the maximum possible.

Another example: n=4, k=10.

temp=1, temp*2=2<10, temp=2, i=1.

temp=2, temp*2=4<10, temp=4, i=2.

temp=4, temp*2=8<10, temp=8, i=3.

temp=8, temp*2=16>=10, loop exits.

ans.append((1<<3)-1=7)

ans.append(10 -7=3)

ans += [0]*(4-2)=2 zeros.

So, ans=[7,3,0,0]

OR is 7 | 3 | 0 | 0 = 7, which is 111, three 1s.

Is there a better sequence?

Let's see: [1,2,4,3], sum is 1+2+4+3=10.

OR is 1 | 2 | 4 | 3 = 7, same as above.

[5,5,0,0], OR is 5 | 5 | 0 | 0 = 5, which is 101, two 1s, worse.

So, [7,3,0,0] is better.

Another sequence: [1,2,3,4], OR is 1 | 2 | 3 | 4 = 7, same as above.

So, seems like three is the maximum.

Another example: n=1, k=1.

Just output 1.

OR is 1, which has one 1.

Is that correct? Yes.

Another example: n=5, k=1.

Have to distribute sum 1 among 5 numbers.

Possible sequence: [1,0,0,0,0]

OR is 1 | 0 | 0 | 0 | 0 = 1, which has one 1.

Is there a way to get more than one 1 in the OR?

Suppose [1,1,0,0,0], OR is 1, same.

[1,0,0,0,0], same.

Seems like one is the maximum.

So, the program would do:

temp=1, temp*2=2>=1, loop exits.

ans.append((1<<0)-1=0)

ans.append(1 - 0=1)

ans += [0]*(5-2)=3 zeros.

So, ans=[0,1,0,0,0]

OR is 0 | 1 | 0 | 0 | 0 = 1, which is correct.

Seems correct.

Another edge case: n=2, k=1.

ans.append((1<<0)-1=0)

ans.append(1 - 0=1)

So, [0,1], OR is 1, which is correct.

Another edge case: n=1, k=0.

But k is >=1 as per the problem, so k=0 is not possible.

Wait, k >=1.

Wait, no, k >=1 is not necessarily the case, but in the problem statement, k >=1.

Wait, looking back: "1 ≤ k ≤10^9"

So, k >=1.

So, no issue.

Another case: n=4, k=15.

temp=1, temp*2=2<15, temp=2, i=1.

temp=2, temp*2=4<15, temp=4, i=2.

temp=4, temp*2=8<15, temp=8, i=3.

temp=8, temp*2=16>=15, loop exits.

ans.append((1<<3)-1=7)

ans.append(15-7=8)

ans += [0]*(4-2)=2 zeros.

So, [7,8,0,0]

OR is 7 | 8 | 0 | 0 = 15, which is 1111, four 1s.

Is that the maximum?

Yes, because 15 is 1111 in binary, which has four 1s.

Another sequence: [1,2,4,8], sum is 15, OR is 1 | 2 | 4 | 8 = 15, same as above.

So, four 1s is the maximum.

Seems correct.

Another case: n=3, k=6.

temp=1, temp*2=2<6, temp=2, i=1.

temp=2, temp*2=4<6, temp=4, i=2.

temp=4, temp*2=8>=6, loop exits.

ans.append((1<<2)-1=3)

ans.append(6-3=3)

ans += [0]*(3-2)=1 zero.

So, [3,3,0]

OR is 3 | 3 | 0 = 3, which is 11, two 1s.

Is there a better sequence?

Let's see: [1,2,3], sum is 6, OR is 1 | 2 | 3 = 3, same as above.

[2,2,2], OR is 2, which is 10, one 1.

[4,2,0], OR is 4 | 2 | 0 = 6, which is 110, two 1s.

[5,1,0], OR is 5 | 1 | 0 = 5 | 1 | 0 = 5, which is 101, two 1s.

So, two is the maximum.

Hence, the program's output [3,3,0] is correct.

Seems like the program is working correctly for these cases.

But let's see if there's any case where it might not be optimal.

Suppose n=2, k=6.

Program:

temp=1, temp*2=2<6, temp=2, i=1.

temp=2, temp*2=4<6, temp=4, i=2.

temp=4, temp*2=8>=6, loop exits.

ans.append((1<<2)-1=3)

ans.append(6-3=3)

So, [3,3]

OR is 3 | 3 =3, which is 11, two 1s.

Is there a better sequence?

[1,5], OR is 1 | 5 =5, which is 101, two 1s.

[2,4], OR is 2 | 4 =6, which is 110, two 1s.

[0,6], OR is 0 | 6 =6, which is 110, two 1s.

Seems like two is the maximum.

So, [3,3] is correct.

Another case: n=3, k=7.

Program:

temp=1, temp*2=2<7, temp=2, i=1.

temp=2, temp*2=4<7, temp=4, i=2.

temp=4, temp*2=8>=7, loop exits.

ans.append((1<<2)-1=3)

ans.append(7-3=4)

ans += [0]*(3-2)=1 zero.

So, [3,4,0]

OR is 3 | 4 | 0 =7, which is 111, three 1s.

Is that the maximum?

Yes, because 7 is 111 in binary.

Any other sequence like [1,2,4], OR is 7, same as above.

So, seems correct.

I can't find a case where the program fails.

Hence, I conclude that the program is correct.

**Final Answer**

\[ \boxed{\text{Correct}} \]