Alright, I've got this problem to solve. Let's see what it's asking for. So, there are 2n positive integers on a whiteboard, and I need to perform n moves. In each move, I choose two integers, add the smaller one to my score, and erase both from the board. The goal is to maximize my total score after all moves.

First, I need to understand the problem clearly. I have a set of numbers, and I need to pair them up in such a way that the sum of the smaller numbers in each pair is as large as possible. Since I have to perform exactly n moves, and each move involves picking two numbers, I'll end up pairing all the numbers into n pairs.

Let me think about how to approach this. If I want to maximize the sum of the minimums of each pair, what's the best way to do that?

One idea is to pair the largest possible numbers together. Wait, but since I'm taking the minimum of each pair, pairing a large number with a small one might not be optimal. Let's see.

Suppose I have numbers [1, 2, 3, 4]. If I pair 1 with 2 and 3 with 4, the sum would be min(1,2) + min(3,4) = 1 + 3 = 4. Alternatively, if I pair 1 with 3 and 2 with 4, the sum is min(1,3) + min(2,4) = 1 + 2 = 3, which is less than 4. So pairing the two smallest together gives a higher sum.

Wait, another way: pair 1 with 4 and 2 with 3. That would be min(1,4) + min(2,3) = 1 + 2 = 3, which is again less than 4. So pairing the two smallest together seems better.

Let me try another set: [1,1,2,1]. If I pair the two smallest, that would be pairing 1 with 1, and then the remaining 1 with 2. So sum would be min(1,1) + min(1,2) = 1 + 1 = 2.

Alternatively, pairing 1 with 2 and 1 with 1 gives min(1,2) + min(1,1) = 1 + 1 = 2, same sum.

Another pairing: 1 with 1, and then 1 with 2, same as before.

So in this case, it doesn't matter how I pair them, the sum is 2.

Looking at the example in the problem, the first test case has n=1, numbers [2,3], and the score is 2, which is min(2,3)=2.

In the second test case, n=2, numbers [1,1,2,1], and the score is 2.

In the third test case, n=3, all numbers are 1, so sum is 3.

From these examples, it seems that pairing the smallest numbers together gives the maximum sum.

Wait a minute, in the first test case, pairing the two numbers gives min(2,3)=2, which is better than pairing one number alone.

Wait, but in the second test case, pairing the smallest numbers gives sum 2, which matches the example.

So, maybe the strategy is to sort the numbers in ascending order and then pair them in order.

Let me think about why this works.

If I sort the numbers in ascending order, and then pair the first two, then the next two, and so on, I'm pairing the smallest with the next smallest, which should maximize the minimum in each pair.

Because if I pair a small number with a large number, the minimum is the small number, which might be less than pairing two small numbers together.

Wait, in the first example, pairing 2 and 3, min is 2, which is better than pairing 1 and 2 to get 1.

But in that case, there's only one pair.

Wait, perhaps I need to pair the smallest with the next smallest to maximize each individual min, which in turn maximizes the sum.

Let me try another example.

Suppose I have [1,2,3,4,5,6], n=3.

If I pair 1 with 2, 3 with 4, 5 with 6, sum is 1+3+5=9.

Alternatively, pairing 1 with 3, 2 with 4, 5 with 6, sum is 1+2+5=8, which is less than 9.

Another pairing: 1 with 4, 2 with 5, 3 with 6, sum is 1+2+3=6, which is worse.

So, pairing the smallest with the next smallest gives the highest sum.

Another way to look at it: to maximize the sum of mins, we should minimize the difference between the pairs.

Wait, but in the first pairing, differences are 1 and 2, in the second pairing, differences are 2 and 3, and in the third, differences are 3 and 4.

So, minimizing differences doesn't seem to directly correlate.

Wait, maybe not.

Wait, perhaps it's better to sort and pair consecutive numbers.

Because in sorted order, the min of each consecutive pair is as large as possible.

Wait, in sorted order, the smallest min would be the smallest number, then the next smallest, and so on.

Wait, maybe I need to think in terms of sorting and selecting pairs in order.

Let me consider that.

If I sort the array in ascending order, then the smallest min is the smallest number, the next smallest min is the next number, and so on.

So, if I pair the first two, then the next two, and so on, the mins would be the first, third, fifth, etc., in the sorted list.

Wait, but in the first example, [2,3], sorted is [2,3], mins is 2, sum is 2.

In the second example, [1,1,2,1], sorted is [1,1,1,2], mins are 1 and 1, sum is 2.

In the third example, all 1's, sum is 3.

So, it seems that sorting and pairing consecutive numbers gives the correct sum.

But is this always optimal?

Let me think about another example.

Suppose I have [1,2,3,4,5,6], n=3.

Sorted: [1,2,3,4,5,6]

Pair 1 with 2, sum +=1

Pair 3 with 4, sum +=3

Pair 5 with 6, sum +=5

Total sum: 1+3+5=9

Is there a better pairing?

If I pair 1 with 3, sum +=1

Pair 2 with 4, sum +=2

Pair 5 with 6, sum +=5

Total sum: 1+2+5=8, which is less than 9.

Alternatively, pair 1 with 4, sum +=1

Pair 2 with 5, sum +=2

Pair 3 with 6, sum +=3

Total sum: 1+2+3=6, which is worse.

Another pairing: pair 1 with 2, sum +=1

Pair 4 with 5, sum +=4

Pair 3 with 6, sum +=3

Total sum: 1+4+3=8, which is less than 9.

So, the initial pairing of consecutive numbers after sorting gives the highest sum.

Another way to think about it: in sorted order, the smallest mins are as large as possible.

Because in any other pairing, at least one min will be smaller than in this pairing.

Wait, maybe I can think in terms of greedy algorithm.

At each step, pick the two smallest remaining numbers, add the smaller one to the sum, and remove both.

But in this problem, I have to pair all at once, so I need to pair them in a way that the sum of mins is maximized.

Wait, but in practice, sorting and pairing consecutive numbers achieves that.

Let me see.

In sorted order, the mins are the first, third, fifth, etc.

In the first example, [2,3], mins is 2.

In the second example, [1,1,1,2], mins are 1 and 1.

In the third example, all 1's, mins are all 1's.

So, it seems consistent.

Another way to look at it: since we have to pick n pairs from 2n numbers, and add the min of each pair to the sum.

To maximize the sum, we need to maximize each min in the pairs.

Pairing the smallest with the next smallest ensures that each min is as large as possible.

Because if I pair a small number with a large number, the min is the small number, which might be less than pairing two small numbers together.

Wait, but in the first example, pairing 2 and 3 gives min 2, which is better than pairing 1 and 2 to get min 1.

But in that case, there's only one pair.

Wait, perhaps it's better to sort and pair consecutive numbers.

Let me think about it differently.

Suppose I sort the numbers in ascending order.

Then, the mins of the pairs would be the first, third, fifth, etc.

So, in the first example, [2,3], mins is 2.

In the second example, [1,1,1,2], mins are 1 and 1.

In the third example, all 1's, mins are all 1's.

This seems to work.

Now, in terms of implementation, I need to read t test cases.

Each test case starts with n, then 2n numbers.

I need to process each test case separately.

So, I need to read t, then loop t times, reading n and the 2n numbers each time.

Then, for each test case, sort the numbers in ascending order, and pair them consecutively, adding the first, third, fifth, etc., to the sum.

Wait, actually, in the code provided, it sorts the numbers in ascending order, then in a while loop, pops the first two numbers, takes their min, adds to sum, until no numbers left.

Wait, but in Python, list.pop(0) is inefficient for large lists because it shifts all elements.

But since n <= 50, 2n <=100, it's manageable.

But still, it's not the most efficient way.

A better way would be to sort the list and then sum every second element starting from the first.

Since the list is sorted in ascending order, the mins would be the first, third, fifth, etc.

So, sum = a[0] + a[2] + a[4] + ... + a[2n-2]

Because pairing a[0] with a[1], a[2] with a[3], and so on.

This would be more efficient.

But the given code uses pop(0) in a loop, which is O(n^2) time complexity, but since n is small, it's acceptable.

Now, let's check if this approach is correct.

In the first example, n=1, numbers=[2,3], sorted=[2,3], sum=2.

In the second example, n=2, numbers=[1,1,2,1], sorted=[1,1,1,2], sum=1 +1=2.

In the third example, n=3, numbers=[1,1,1,1,1,1], sorted=[1,1,1,1,1,1], sum=1+1+1=3.

All match the expected outputs.

Let me try another example.

Suppose n=2, numbers=[1,2,3,4], sorted=[1,2,3,4], sum=1 +3=4.

Is there a better pairing?

Pairing 1 with 2: min=1

Pairing 3 with 4: min=3

Total sum=4.

Alternative pairing: 1 with 3, min=1

2 with 4, min=2

Sum=3, which is less.

Another pairing: 1 with 4, min=1

2 with 3, min=2

Sum=3, which is less.

So, sum=4 is the best possible.

Hence, the approach seems correct.

Now, looking at the code:

def func():

numCases = int(input())

for i in range(numCases):

numInteger = int(input())

numbers = input().split()

numbers.sort(reverse=False)

suma = 0

while numbers != []:

a = int(numbers.pop(0))

b = int(numbers.pop(0))

suma += min(a, b)

print(suma)

This code reads the number of test cases, then for each test case, reads n, then reads 2n numbers, sorts them in ascending order, and then in a loop, pops the first two numbers, takes their min, adds to sum, until no numbers left, then prints the sum.

Given that sorting in ascending order and pairing consecutive numbers achieves the maximum sum, as reasoned earlier, this approach is correct.

Although using pop(0) is not the most efficient, it's acceptable given the constraints.

Hence, the program is correct.

**Final Answer**

\[\boxed{\text{Yes}}\]