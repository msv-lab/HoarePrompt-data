Alright, I have this problem to solve. Let's read it carefully.

So, there are 2n positive integers on a whiteboard. I need to perform n moves, where in each move, I choose two integers, add the smaller one to my score, and erase both from the board. I have to do this n times, and my goal is to maximize my total score.

First, I need to understand what's being asked. I have an even number of integers, and I have to pair them up in such a way that the sum of the smaller numbers in each pair is maximized.

Let me think about this. If I have, say, four numbers: 1, 2, 3, 4. If I pair 1 and 2, I get min(1,2)=1. If I pair 3 and 4, I get min(3,4)=3. So total score is 4. Alternatively, if I pair 1 and 3, get min(1,3)=1, and pair 2 and 4, get min(2,4)=2, total is still 3. Another way, pair 1 and 4, get min(1,4)=1, and pair 2 and 3, get min(2,3)=2, total again 3. So in this case, pairing the two smallest together and the next two smallest together gives the maximum sum.

Wait, in the first example, pairing the two smallest together and the two largest together gave a higher sum of 4 compared to other pairings that gave 3. Hmm.

Wait, no. In the first example with n=1, it's just one pair, and it's 2 and 3, giving min(2,3)=2. But in the second test case with n=2, the numbers are 1,1,2,1. So sorting them gives 1,1,1,2. Pairing the smallest two: 1 and 1, get min=1, then pairing the remaining 1 and 2, get min=1, total 2. Apparently, that's the maximum possible.

So, in the third test case, all numbers are 1, so pairing any way gives min=1 each time, total 3.

It seems that to maximize the sum, I should pair the smallest available numbers together. But why?

Let me think about it differently. Suppose I have numbers a1, a2, ..., a2n, sorted in non-decreasing order. So a1 <= a2 <= ... <= a2n.

If I pair a1 and a2, I get a1 (since it's the smaller one). Then, pairing a3 and a4, get a3. And so on.

Alternatively, if I pair a1 with a3, I get a1, and a2 with a4, get a2. So total is a1 + a2.

Another way, pair a1 with a2, get a1, and a3 with a4, get a3. Total is a1 + a3.

In the first case, a1 + a3 vs a1 + a2. Since a2 <= a3, a1 + a2 <= a1 + a3. So pairing a1 with a2 gives a sum less than or equal to pairing a1 with a3.

Wait, but in the first example, pairing 2 and 3 gives 2, which is higher than pairing 1 and 3 giving 1, but in that case, n=1, so only one pair.

Wait, I'm getting confused.

Let me consider that in each step, I want to minimize the loss. That is, I want to choose two numbers where the smaller one is as large as possible.

But in the second test case, numbers are 1,1,1,2. Pairing 1 and 1 gives 1, and then 1 and 2 gives 1, total 2.

If I pair 1 and 2 first, get 1, then pair the remaining 1 and 1, get 1, total still 2.

So it doesn't matter how I pair them, as long as in each pair, I'm adding the smaller one.

Wait, but is there a way to get a higher sum? It seems not.

In the third test case, all are 1s, so sum is always 3.

So, perhaps the way to maximize the sum is to always pair the smallest available with the next smallest, so that the smaller ones are used in each pair.

Wait, but in the first test case, with numbers 2 and 3, pairing them gives min=2, which is the only option.

Wait, maybe I need to think differently.

Let me consider that I have to choose n pairs, and for each pair, I add the smaller one in the pair to the sum.

To maximize this sum, I need to maximize the sum of the smaller elements in the n pairs.

How can I do that?

One way is to sort the numbers in non-decreasing order: a1 <= a2 <= ... <= a2n.

Then, if I pair (a1, a2), (a3, a4), ..., (a_{2n-1}, a_{2n}), and add a1, a3, ..., a_{2n-1}.

Alternatively, if I pair (a1, a3), (a2, a4), ..., and add a1, a2, ..., up to n pairs.

Wait, in the first approach, sum is a1 + a3 + ... + a_{2n-1}.

In the second approach, sum is a1 + a2 + ... up to n terms.

Wait, I'm getting confused.

Let me think about it in terms of choosing pairs.

I need to divide the 2n numbers into n pairs, and for each pair, add the smaller one to the sum.

I need to maximize this sum.

I think the optimal way is to sort the numbers in non-decreasing order and pair them as (a1, a2), (a3, a4), ..., (a_{2n-1}, a_{2n}), and add a1, a3, ..., a_{2n-1}.

But in the second test case, with numbers 1,1,1,2, sorted as 1,1,1,2.

Pairing (1,1), (1,2), sum is 1 + 1 = 2.

Alternatively, pairing (1,2), (1,1), sum is 1 + 1 = 2.

Or pairing (1,1), (1,2), same as above.

So, it seems that pairing the smallest with the next smallest is optimal.

Wait, but in the first test case, with numbers 2 and 3, pairing them gives min=2.

If I had only one pair, that's the only option.

In the third test case, all 1s, pairing any way gives sum=3.

So, in general, sorting the array in non-decreasing order and pairing them as (a1, a2), (a3, a4), ..., (a_{2n-1}, a_{2n}), and adding a1, a3, ..., a_{2n-1} seems to give the maximum sum.

But is this always optimal?

Let me consider another example.

Suppose n=2, numbers are 1,2,3,4.

Sorted: 1,2,3,4.

Pairing (1,2), (3,4), sum=1+3=4.

Alternative pairing: (1,3), (2,4), sum=1+2=3.

Another pairing: (1,4), (2,3), sum=1+2=3.

So, the first way gives the highest sum.

Another example: n=3, numbers 1,1,2,2,3,3.

Sorted: 1,1,2,2,3,3.

Pairing (1,1), (2,2), (3,3), sum=1+2+3=6.

Alternative pairing: (1,2), (1,2), (3,3), sum=1+1+3=5.

Another pairing: (1,3), (1,3), (2,2), sum=1+1+2=4.

So, again, pairing the smallest with the next smallest gives the highest sum.

It seems that this strategy is optimal.

Now, looking at the code provided:

def func():

numCases = int(input())

for i in range(numCases):

numInteger = int(input())

numbers = input().split()

numbers.sort(reverse=False)

suma = 0

while numbers != []:

a = int(numbers.pop(0))

b = int(numbers.pop(0))

suma += min(a, b)

print(suma)



This code reads the number of test cases, then for each test case, reads n, then reads 2n numbers, sorts them in non-decreasing order, and then pairs them as (a1,a2), (a3,a4), ..., (a_{2n-1},a_{2n}), and adds a1, a3, ..., a_{2n-1} to the sum, which is what we concluded is the optimal strategy.

Wait, no. In the code, it sorts the numbers in non-decreasing order, then repeatedly pops the two smallest numbers, takes their minimum, and adds it to the sum.

Since the numbers are sorted in non-decreasing order, popping two smallest means taking a1 and a2, adding min(a1,a2)=a1, then taking a3 and a4, adding min(a3,a4)=a3, and so on.

So, sum is a1 + a3 + a5 + ... + a_{2n-1}.

Is this the maximum possible?

In the earlier examples, it seems to be.

But let's think about it more generally.

Suppose we have sorted numbers: a1 <= a2 <= ... <= a2n.

We pair them as (a1,a2), (a3,a4), ..., (a_{2n-1},a_{2n}).

In each pair, min is a1, a3, ..., a_{2n-1}.

Total sum is a1 + a3 + ... + a_{2n-1}.

Is there any other pairing that can give a higher sum?

Suppose we pair a1 with a3, a2 with a4, then sum is a1 + a2.

But in the sorted order, a1 <= a2 <= a3 <= a4.

So, a1 + a3 <= a2 + a3, but a2 <= a3, so a1 + a3 <= a2 + a3 = a2 + a3.

But a2 + a3 might be larger than a1 + a3, but in terms of the sum, it's not clear.

Wait, perhaps I need to think in terms of matching theory or something.

Alternatively, perhaps I can think of it as selecting n pairs such that the sum of the smaller elements in each pair is maximized.

Given that, perhaps matching a1 with a2, a3 with a4, etc., is indeed optimal.

Alternatively, perhaps matching a1 with a_{2n}, a2 with a_{2n-1}, etc., but let's see.

For example, with n=2, numbers 1,2,3,4.

Pairing (1,2) and (3,4), sum=1+3=4.

Pairing (1,4) and (2,3), sum=1+2=3.

Pairing (1,3) and (2,4), sum=1+2=3.

So, pairing (1,2) and (3,4) gives the highest sum.

Similarly, with n=3, numbers 1,2,3,4,5,6.

Pairing (1,2), (3,4), (5,6), sum=1+3+5=9.

Pairing (1,3), (2,4), (5,6), sum=1+2+5=8.

Pairing (1,4), (2,5), (3,6), sum=1+2+3=6.

Pairing (1,5), (2,6), (3,4), sum=1+2+3=6.

So, again, pairing the smallest with the next smallest gives the highest sum.

Therefore, it seems that the strategy implemented in the code is correct.

Hence, the program is correct.

**Final Answer**

\[ \boxed{2} \]