Alright, I've got this problem to solve. Let's see what it's asking for. So, I have an array of integers, and I need to perform exactly K operations on it. In each operation, I can select any contiguous subarray (which could even be empty) and insert the sum of that subarray anywhere in the array. My goal is to maximize the sum of the array after K operations, and since the sum can be very large, I need to output it modulo 10^9 + 7.

First, I need to understand what exactly an operation does. When I select a subarray, calculate its sum, and insert that sum back into the array, where can I insert it? The problem says "anywhere in the array," which means I can add this sum at any position I like, perhaps even at the beginning or the end.

Let me think about what happens when I perform such an operation. If I select a subarray with a positive sum and insert it into the array, I'm effectively adding that sum to the total sum of the array. If the subarray has a negative sum, adding it would decrease the total sum, which is not desirable since I want to maximize the sum. So, intuitively, I should always choose subarrays with the maximum possible sum.

Wait, but I can also choose an empty subarray, which has a sum of zero. Adding zero won't change the sum of the array. So, in some cases, maybe choosing an empty subarray is better than choosing a negative subarray.

Let me consider a simple example to get a better understanding. Suppose I have an array [1, -2, 3], and K=1. If I choose the subarray [3], whose sum is 3, and insert it into the array, say after the first element, the new array becomes [1, 3, -2, 3], with a sum of 5. Alternatively, if I choose the subarray [1, -2, 3], sum is 2, and insert it at the beginning, the new array is [2, 1, -2, 3], sum is 4. So, in this case, choosing the subarray with the maximum sum and inserting it in a way that maximizes the total sum is key.

But how do I generalize this? I need a strategy that works for any array and any K.

I recall that in array problems, especially those involving selecting subarrays, the concept of the maximum subarray sum often comes into play. Maybe I can compute the maximum sum of any subarray in the array and then somehow use that in my operations.

Let me formalize this. Let's denote S as the initial sum of the array. Then, in each operation, I can choose a subarray with sum X and insert it into the array, which adds X to the total sum.

So, after K operations, the total sum would be S + X1 + X2 + ... + XK, where each Xi is the sum of some subarray chosen in the i-th operation.

My aim is to maximize this sum, so I need to choose Xi to be as large as possible for each operation.

If I always choose the subarray with the maximum possible sum in each operation, that seems optimal.

But how do I find the maximum sum of any subarray in the array? I can use Kadane's algorithm for that, which efficiently finds the maximum subarray sum.

Wait, but in each operation, after inserting the sum, the array changes, so the maximum subarray sum might also change.

Hmm, that complicates things. I need to think about how the array evolves with each operation.

Let's consider that in each operation, I can choose any subarray, compute its sum, and insert that sum back into the array. Importantly, where I insert it can affect the array's structure, but since I can choose any position, perhaps the exact position isn't crucial if I'm only interested in the sum.

Let me think differently. Suppose I don't worry about where I insert the sum, but only about what sum I'm adding. If I always choose the maximum possible subarray sum and insert it somewhere, that should be optimal.

But is that always true? Let's test it with an example.

Take the array [1, -2, 3], K=2.

Initial sum S = 1 + (-2) + 3 = 2.

First operation: choose subarray [3], sum=3, insert it somewhere. Now, sum becomes 2 + 3 = 5.

Second operation: again, choose subarray [3], sum=3, insert it. Sum becomes 5 + 3 = 8.

Is there a better way? Suppose in the first operation, I choose [1, -2, 3], sum=2, insert it. Now, array is, say, [2, 1, -2, 3], sum=4.

Then, second operation: choose [3], sum=3, insert it. Sum becomes 4 + 3 = 7, which is less than the previous approach.

So, choosing the maximum subarray sum each time seems better.

Another example: [-1, -2], K=1.

Initial sum S = -3.

If I choose the empty subarray, sum=0, insert it. Sum remains -3.

If I choose any subarray, sum is negative, so adding it would make the sum even smaller, which is worse.

So, in this case, choosing the empty subarray is better.

Wait, but the problem says "insert the sum of this subarray anywhere in the array," and the sum can be zero. So, in cases where all subarrays have negative sums, choosing the empty subarray with sum zero is the way to go.

So, perhaps, in general, in each operation, I should choose the maximum possible subarray sum, and if that is negative, choose the empty subarray with sum zero.

But wait, in the first operation, I can choose the maximum subarray sum and insert it into the array, which increases the total sum.

In the next operation, the array has changed because I inserted a new element, so the maximum subarray sum might be different.

But perhaps there's a pattern here.

Let me consider that after inserting a sum, the array grows by one element, which is the sum inserted.

So, if I have an array of size N, after K operations, the array will have size N + K.

But calculating the maximum subarray sum after each insertion seems too time-consuming, especially since N and K can be up to 2*10^5, and T can be up to 10^4, with the total sum of N and K across all test cases being up to 2*10^5.

I need a more efficient approach.

Let me think about the sum after K operations.

Initially, sum = S.

After the first operation, sum = S + X1, where X1 is the sum of the chosen subarray.

After the second operation, sum = S + X1 + X2, where X2 is the sum of another chosen subarray.

And so on, up to K operations.

So, overall, sum = S + X1 + X2 + ... + XK.

To maximize this sum, I need to maximize the sum of X1 to XK.

Given that each Xi is the sum of some subarray of the current array, and I can choose where to insert it, perhaps there's a way to express this sum in terms of the initial array and the operations performed.

Wait a minute, perhaps I can think of it recursively.

After the first operation, I add the maximum subarray sum to the array.

Then, in the second operation, I can again add the maximum subarray sum, which might have changed because I added a new element.

But this seems complicated to compute directly.

Let me consider that after the first operation, I add the maximum subarray sum, say M1, to the array.

Then, in the second operation, the array has increased by one element, which is M1.

So, the new maximum subarray sum could be either the previous M1, or a new subarray that includes the newly added M1.

But this seems messy to compute for large K.

Is there a better way to model this?

Let me consider that in each operation, I can add any subarray sum, but to maximize the total sum, I should always add the largest possible subarray sum available at that moment.

If I can find a way to compute what that largest subarray sum is after each operation, perhaps there's a pattern or a formula that can be used.

Alternatively, maybe I can find a way to compute the maximum possible sum after K operations in a more direct manner.

Let me think about the initial sum S.

Then, in each operation, I can add some X, where X is the sum of a subarray.

To maximize the sum, I should choose X to be as large as possible each time.

The largest possible X is the maximum subarray sum of the current array.

But as I add larger and larger sums, the array grows, and potentially, the maximum subarray sum also grows.

Wait, perhaps I can find a way to express the maximum sum after K operations in terms of the initial sum and some multiple of the maximum subarray sum.

But it's not straightforward.

Let me consider that after each operation, I can add the maximum subarray sum to the array, and that this new element can be part of future subarrays.

But this seems too vague.

Maybe I need to think differently.

Let me consider that in each operation, I can choose any subarray, compute its sum, and insert that sum into the array.

Importantly, the sum of the array increases by exactly that sum.

So, if I choose a subarray with sum X and insert it into the array, the array's sum becomes S + X.

Then, in the next operation, I can choose another subarray with sum Y and insert it, making the sum S + X + Y, and so on up to K operations.

Therefore, the total sum after K operations is S + X1 + X2 + ... + XK, where each Xi is the sum of some subarray chosen in the i-th operation.

My goal is to maximize S + X1 + X2 + ... + XK.

To maximize this, I need to maximize the sum of X1 to XK.

Now, what is the maximum possible sum I can get from choosing K subarrays and adding their sums to S?

But there's a dependency because the choice of subarrays in earlier operations affects the array for later operations.

This seems complicated.

Is there a way to decouple these operations?

Wait, perhaps I can find a way to choose subarrays in such a way that the sum added in each operation is independent of previous operations.

If I can ensure that each Xi is independent of the previous operations, then I can simply maximize each Xi separately.

But in reality, inserting a new sum into the array can affect the possible subarrays in future operations.

However, maybe there's a way to choose subarrays such that the inserted sums don't interfere with each other.

Let me consider that if I choose a subarray in one operation and insert its sum at a certain position, in the next operation, I can choose a different subarray that doesn't overlap with the newly inserted element, thus keeping the subarrays independent.

But this might not always be optimal.

Alternatively, perhaps I can choose to always insert the sum at the end of the array, so that each new sum is a separate element that doesn't affect the previous subarrays.

Wait, but subarrays are contiguous, so inserting a new sum at the end would make it a separate element, and to include it in a subarray, I would have to either include it alone or together with some preceding elements.

This still seems a bit tangled.

Let me try to think of it differently.

Suppose that in each operation, I can add any real number to the array, but I have to choose it such that it's equal to the sum of some subarray.

But that's not accurate; I have to choose a sum of some subarray that currently exists in the array.

Wait, but I can choose any contiguous subarray, including empty, and insert its sum anywhere.

So, perhaps, in each operation, I can add any value that is equal to the sum of some contiguous subarray that currently exists.

But this seems too vague.

Let me consider that the maximum sum I can add in each operation is equal to the maximum subarray sum of the current array.

So, if I can compute the maximum subarray sum after each operation, I can plan accordingly.

But computing this for each operation separately would be too slow for large K.

I need a smarter way.

Let me consider that after the first operation, I add the maximum subarray sum to the array.

Then, in the second operation, the array has an additional element, which is the sum added in the first operation.

So, the new maximum subarray sum could be either the previous maximum subarray sum or the newly added sum, or a combination of both.

But it's not clear.

Wait, perhaps I can think in terms of dynamic programming.

Let me denote M_k as the maximum sum after K operations.

Then, M_k = S + X1 + X2 + ... + XK, where each Xi is the sum of some subarray in the array after i-1 operations.

But I need a way to express M_k in terms of M_{k-1}.

Perhaps M_k = M_{k-1} + max_subarray_sum(M_{k-1}).

But this seems recursive and might not be directly helpful.

Wait, maybe I can find a pattern or a mathematical formula.

Let me consider that in each operation, I can add the maximum subarray sum of the current array.

Suppose that the maximum subarray sum doesn't change after each operation.

Then, M_k = S + k * max_subarray_sum.

But that's not necessarily true, because adding a new element can potentially change the maximum subarray sum.

However, perhaps in some cases, it remains constant.

Let me consider an array where all elements are positive.

Then, the maximum subarray sum is the sum of the entire array.

If I add this sum to the array, the new maximum subarray sum would be the sum of the entire new array, which is S + S = 2*S.

Then, in the next operation, I can add 2*S to the array, making the new sum S + S + 2*S = 4*S.

Wait, this seems exponential.

Wait, let's see:

Initial sum S.

First operation: add S (sum of the array), so new sum is S + S = 2*S.

Second operation: add 2*S (new sum of the array), so new sum is 2*S + 2*S = 4*S.

Third operation: add 4*S, so new sum is 4*S + 4*S = 8*S.

So, it seems like the sum doubles with each operation.

But is this always the case?

Wait, in this case, because the array is all positive, the maximum subarray sum is the sum of the entire array, which increases with each operation.

But what if the array has negative elements?

Let me consider an array with both positive and negative elements.

Suppose array is [1, -2, 3].

Initial sum S = 1 + (-2) + 3 = 2.

Maximum subarray sum is 3 (the subarray [3]).

First operation: add 3, sum becomes 2 + 3 = 5.

Now, the array is [1, -2, 3, 3].

Maximum subarray sum is 3 (subarrays [3] or [3,3] sum to 6, but [3,3] is better).

Wait, but [3,3] sum to 6, which is larger.

So, in the second operation, I can add 6, making the sum 5 + 6 = 11.

Wait, but according to my earlier assumption, it should double, but here it doesn't.

Wait, perhaps my assumption is wrong.

In the first operation, I added 3, making the array [1, -2, 3, 3], sum=5.

Then, in the second operation, the maximum subarray sum is 6 ([3,3]), so adding 6 makes the sum 5 + 6 = 11.

In the third operation, the array is [1, -2, 3, 3, 6], sum=11.

The maximum subarray sum could be 6 or [3,3,6]=12, so adding 12 makes sum 11 + 12 = 23.

This doesn't follow a simple doubling pattern.

So, perhaps my initial assumption was incorrect.

Let me try to find a general pattern.

Suppose that after each operation, the maximum subarray sum is equal to the sum of the largest subarray possible, which may include the newly added elements.

If I can find a way to compute the maximum subarray sum after each operation, perhaps I can find a recurrence relation for the sum after K operations.

But this seems too vague.

Let me consider that in each operation, I can add any sum that is a sum of a subarray of the current array.

So, perhaps the best strategy is to always add the maximum possible sum that is achievable by any subarray at that point.

If I can find a way to compute what that maximum sum is after each operation, that would be ideal.

But again, this seems too slow for large K.

Wait, maybe I can find a way to express the sum after K operations in terms of the initial sum and some multiple of the maximum subarray sum.

Let me denote:

- S: initial sum

- M: maximum subarray sum

Then, in the first operation, I can add M, making the sum S + M

In the second operation, the new maximum subarray sum could be M or larger, depending on the array.

But if I always add M, then the sum would be S + k*M

But in reality, M can increase with each operation if I add sums that allow for larger subarrays.

So, perhaps S + k*M is a lower bound, but the actual sum can be larger.

Wait, perhaps there's a way to model this growth.

Let me consider that in each operation, I can add the current maximum subarray sum, which could be influenced by the previously added sums.

This seems too recursive.

Maybe I need to find the maximum possible sum that can be achieved after K operations by always choosing the best possible subarray sum to add at each step.

But this seems too vague.

Let me think about the problem differently.

Suppose that in each operation, I can choose any contiguous subarray, compute its sum, and insert that sum anywhere in the array.

This insertion increases the array's sum by exactly that sum.

So, to maximize the sum after K operations, I need to choose K subarrays whose sums, when added together, give the maximum possible total.

But the choice in each operation affects the array for the next operations.

This seems too interdependent.

Is there a way to decouple these operations?

Wait, perhaps I can model this as adding K additional elements, each being the sum of some subarray of the current array, chosen optimally.

But again, this seems too vague.

Let me consider that in each operation, I can add any sum that is equal to the sum of some subarray of the current array.

So, perhaps I can find the maximum possible sum that can be achieved by adding K times the maximum possible sum available at each step.

But since the maximum sum can change with each addition, this is tricky.

Wait, perhaps there's a way to find a fixed sum that I can add in each operation.

Let me consider that after the first operation, I add the maximum subarray sum, say M.

Then, in the second operation, I can add M again, if the array still has a subarray with sum M.

But if I add M again, the array's sum becomes S + M + M = S + 2*M.

Similarly, in the third operation, I can add M again, making the sum S + 3*M.

This suggests that the sum after K operations is S + K*M.

But in reality, M can change with each operation if I add sums that allow for larger subarrays.

So, perhaps S + K*M is a lower bound, but the actual sum can be higher.

Let me consider an example.

Take the array [1, -2, 3], K=2.

Initial sum S = 2.

Maximum subarray sum M = 3.

If I add M in the first operation, sum becomes 2 + 3 = 5.

In the second operation, the array is [1, -2, 3, 3], and the maximum subarray sum is 6 ([3,3]).

So, adding 6, the sum becomes 5 + 6 = 11.

So, in this case, sum after K operations is S + M + 2*M = S + 3*M.

Wait, but according to the earlier lower bound, it's S + K*M = S + 2*M = 7, but in reality, it's 11.

So, my lower bound is not tight.

Let me see another example.

Array [1, 1], K=2.

Initial sum S = 2.

Maximum subarray sum M = 2.

First operation: add M=2, sum becomes 4.

Second operation: array is [1,1,2], M=3 ([1,1,2]), add 3, sum becomes 7.

So, sum after K operations is S + M + 2*M = 2 + 2 + 4 = 8, but in reality, it's 7.

Wait, that's less than the expected 8.

So, perhaps S + K*M is not always achievable.

Wait, maybe I need to think differently.

Let me consider that in each operation, I can add any sum that is at least M, but potentially more.

But this seems too vague.

Let me consider that after each operation, I can add a sum that is up to twice the previous M.

Wait, in the first example, M=3, then in the second operation, M=6, which is twice the previous M.

Is there a pattern here?

Wait, 3 is the maximum subarray sum of the initial array.

After adding 3, the array becomes [1,-2,3,3], and the maximum subarray sum is 6, which is 2*M.

Then, in the next operation, the maximum subarray sum could be 2*M, and so on.

So, perhaps in each operation, the maximum subarray sum doubles.

But in the second example, [1,1], M=2, after adding 2, the array becomes [1,1,2], and the maximum subarray sum is 4, which is 2*M.

Then, in the next operation, M=4, and so on.

So, perhaps in general, after the first operation, the maximum subarray sum doubles in each subsequent operation.

If that's the case, then the sum after K operations would be S + M + 2*M + 4*M + ... + 2^{K-1}*M.

This is a geometric series: S + M * (2^K - 1).

So, the total sum would be S + M * (2^K - 1).

But does this hold in general?

Let's check with the first example.

Array [1,-2,3], S=2, M=3, K=2.

Sum = 2 + 3*(2^2 - 1) = 2 + 3*3 = 11, which matches the earlier calculation.

In the second example, [1,1], S=2, M=2, K=2.

Sum = 2 + 2*(2^2 - 1) = 2 + 2*3 = 8, but earlier I got 7.

Wait, there's a discrepancy.

In the second example, after the first operation, sum becomes 4.

In the second operation, the array is [1,1,2], and the maximum subarray sum is 4, so adding 4 makes the sum 8.

But earlier, I thought it was 7, but that was incorrect.

So, indeed, sum after K operations is S + M*(2^K - 1).

This seems promising.

Let me try another example.

Array [-1,-2], S=-3.

Maximum subarray sum M=0 (from the empty subarray).

So, sum after K operations is -3 + 0*(2^K - 1) = -3, which matches the earlier reasoning.

Another example: array [0,0,0], S=0.

M=0.

Sum after K operations is 0 + 0*(2^K - 1) = 0, which makes sense.

Another example: array [5], K=3.

S=5, M=5.

Sum after K operations: 5 + 5*(2^3 - 1) = 5 + 5*7 = 40.

Is this correct?

First operation: add 5, sum=10.

Second operation: array is [5,5], M=10.

Add 10, sum=20.

Third operation: array is [5,5,10], M=20.

Add 20, sum=40.

Yes, matches the formula.

So, it seems that the formula S + M*(2^K - 1) works in these cases.

Wait, but in the second example, [1,1], S=2, M=2.

Sum after K=2 operations: 2 + 2*(2^2 - 1) = 2 + 2*3 = 8.

Which matches the corrected earlier calculation.

So, perhaps this formula is general.

Let me try to see why this works.

In the first operation, I add M, making the sum S + M.

In the second operation, the maximum subarray sum is now 2*M, so I add 2*M, making the sum S + M + 2*M = S + 3*M.

In the third operation, the maximum subarray sum is 4*M, so I add 4*M, making the sum S + 3*M + 4*M = S + 7*M.

And so on, following the pattern S + M*(2^K - 1).

This seems to fit the examples I've tried.

But is this always the case?

Let me consider an array with negative and positive elements.

Take array [4, -2, 8, -12, 9], K=1.

S=4 + (-2) + 8 + (-12) + 9 = 7.

M is the maximum subarray sum, which is 4 + (-2) + 8 = 10.

So, sum after K=1 operation: 7 + 10 = 17, which matches the example output.

Wait, in the example, it's given as 17, which matches S + M*(2^1 - 1) = 7 + 10*1 = 17.

Good.

Another example: array [8,14,-9,6,0,-1,3], K=4.

S=8 + 14 + (-9) + 6 + 0 + (-1) + 3 = 21.

M is the maximum subarray sum, which is 8 + 14 + (-9) + 6 + 0 + (-1) + 3 = 21.

So, sum after K=4 operations: 21 + 21*(2^4 - 1) = 21 + 21*15 = 21 + 315 = 336.

But in the example output, it's 351.

Wait, discrepancy here.

Wait, perhaps I miscalculated M.

Let me compute M for [8,14,-9,6,0,-1,3].

Possible subarrays:

- [8]: 8

- [8,14]: 22

- [8,14,-9]: 13

- [8,14,-9,6]: 19

- [8,14,-9,6,0]: 19

- [8,14,-9,6,0,-1]: 18

- [8,14,-9,6,0,-1,3]: 21

- [14]: 14

- [14,-9]: 5

- [14,-9,6]: 11

- [14,-9,6,0]: 11

- [14,-9,6,0,-1]: 10

- [14,-9,6,0,-1,3]: 13

- [-9]: -9

- [-9,6]: -3

- [-9,6,0]: -3

- [-9,6,0,-1]: -4

- [-9,6,0,-1,3]: -1

- [6]: 6

- [6,0]: 6

- [6,0,-1]: 5

- [6,0,-1,3]: 8

- [0]: 0

- [0,-1]: -1

- [0,-1,3]: 2

- [-1]: -1

- [-1,3]: 2

- [3]: 3

The maximum subarray sum M is 22 ([8,14]).

So, sum after K=4 operations: S + M*(2^K - 1) = 21 + 22*(15) = 21 + 330 = 351, which matches the example output.

Earlier, I miscalculated M as 21, but actually it's 22.

So, the formula seems to hold.

Another example: array [5,3,-8,12,-5,-9,3], K=100.

S=5 + 3 + (-8) + 12 + (-5) + (-9) + 3 = (5+3=8, 8-8=0, 0+12=12, 12-5=7, 7-9=-2, -2+3=1). So, S=1.

M is the maximum subarray sum.

Possible subarrays:

- [5]:5

- [5,3]:8

- [5,3,-8]:0

- [5,3,-8,12]:12

- [5,3,-8,12,-5]:7

- [5,3,-8,12,-5,-9):-2

- [5,3,-8,12,-5,-9,3]:1

- [3]:3

- [3,-8):-5

- [3,-8,12]:7

- [3,-8,12,-5]:4

- [3,-8,12,-5,-9):-9

- [3,-8,12,-5,-9,3):-6

- [-8]:-8

- [-8,12]:4

- [-8,12,-5]:-1

- [-8,12,-5,-9):-14

- [-8,12,-5,-9,3):-11

- [12]:12

- [12,-5]:7

- [12,-5,-9):-2

- [12,-5,-9,3]:1

- [-5]:-5

- [-5,-9):-14

- [-5,-9,3):-11

- [-9]:-9

- [-9,3):-6

- [3]:3

So, the maximum subarray sum M is 12.

Sum after K=100 operations: S + M*(2^K - 1) = 1 + 12*(2^100 - 1).

This number is enormous, but since we need to take modulo 10^9 + 7, it's manageable.

But in practice, computing 2^100 modulo 10^9 + 7 is feasible.

So, the formula seems to hold in this case as well.

Another example: array [-1000000000, -1000000000, -1000000000, -1000000000, -1000000000, -1000000000], K=1000.

S=-6*10^9.

M=0 (from empty subarray).

Sum after K operations: -6*10^9 + 0*(2^1000 - 1) = -6*10^9.

But in the example output, it's 42, which is -6*10^9 modulo 10^9 + 7.

Wait, -6*10^9 modulo 10^9 + 7.

Since 10^9 + 7 is 1000000007, -6*10^9 is -6000000000.

To compute -6000000000 mod 1000000007, we can add 1000000007 enough times to make it positive.

-6000000000 + 6*1000000007 = -6000000000 + 6000000042 = 42.

So, indeed, the sum is 42, which matches the formula S + M*(2^K - 1) = -6*10^9 + 0*(2^1000 - 1) = -6*10^9, which modulo 10^9 + 7 is 42.

So, the formula holds in this case as well.

Another example: array [1000000000, 8], K=1.

S=1000000008.

M=1000000000 (from subarray [1000000000]).

Sum after K=1 operation: S + M*(2^1 - 1) = 1000000008 + 1000000000*(1) = 2000000008.

Modulo 10^9 + 7, 2000000008 mod 1000000007 = 2000000008 - 1000000007 = 999999991.

But in the example output, it's 2.

Wait, discrepancy here.

Wait, in the example output, for this test case, it's 2.

Wait, perhaps I misread the example.

Wait, looking back at the example input and output:

Input:

12

2 2

-4 -7

3 3

2 2 8

1 7

7

5 1

4 -2 8 -12 9

7 4

8 14 -9 6 0 -1 3

7 100

5 3 -8 12 -5 -9 3

6 1000

-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000

2 1

1000000000 8

5 4

0 0 0 0 0

6 10

48973 757292 58277 -38574 27475 999984

7 1

-1000 1000 -1000 1000 -1000 1000 -1000

10 10050

408293874 -3498597 7374783 295774930 -48574034 26623784 498754833 -294875830 283045804 85938045

Output:

999999996

96

896

17

351

716455332

42

2

0

897909241

0

416571966

Wait, the test case with array [1000000000, 8], K=1, output is 2.

But according to my formula, it should be 999999991.

Wait, perhaps I'm missing something.

Wait, maybe the maximum subarray sum is not 1000000000, but higher.

Wait, in the array [1000000000, 8], the maximum subarray sum is 1000000000.

So, sum after K=1 operation: S + M = 1000000008 + 1000000000 = 2000000008.

Modulo 10^9 + 7, 2000000008 - 1000000007 = 999999991.

But the example output is 2.

Wait, perhaps I need to consider that when I insert M into the array, it becomes a new element, and the maximum subarray sum could be M or the original M, but in this case, it seems inconsistent with the example output.

Wait, maybe