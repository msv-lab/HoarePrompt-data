Alright, I have this problem to solve. Let's see what it's asking for. So, Mocha has an array of positive integers, and she can perform this specific operation on it any number of times. The operation is to split the array into a prefix and a suffix, swap them, and concatenate them back together. For example, if you have [3,1,4,1,5], you can split it into [3,1] and [4,1,5], then swap them to get [4,1,5,3,1]. The question is, can this array become sorted in non-decreasing order after performing this operation some number of times?

First, I need to understand what this operation does. Splitting into a prefix and a suffix and swapping them is essentially rotating the array. For example, if you have [1,2,3,4,5], and you split into [1,2] and [3,4,5], swapping gives [3,4,5,1,2]. So, it's like rotating the array by the length of the prefix.

Wait, is it exactly rotation? Let's see another example. Take [1,3,2], split into [1] and [3,2], swap to get [3,2,1]. That's not a single rotation to the left or right. It's more general than just rotating by one position.

So, it's about splitting at any position and swapping the two parts.

Now, the question is whether, by doing this operation any number of times, we can sort the array in non-decreasing order.

First, let's consider what happens when we perform this operation multiple times.

Let's take the example from the problem: [7,9,2,2,3]

First operation: split into x=[7] and y=[9,2,2,3], swap to get [9,2,2,3,7]

Second operation: split into x=[9] and y=[2,2,3,7], swap to get [2,2,3,7,9], which is sorted.

So, in this case, it took two operations to sort the array.

Another example: [1,1,4,5,1,4]

The problem states that it's impossible to sort this array with any number of operations.

I need to find a general way to determine whether it's possible to sort any given array using this operation.

First, let's think about what this operation allows us to do.

Each operation is a swap of a prefix and a suffix. So, if I have an array a = x + y, where x and y are two parts, swapping them gives y + x.

Now, if I perform this operation again on y + x, splitting into some prefix and suffix and swapping, I can generate further permutations.

But, I need to see if, by performing these operations, I can reach the sorted version of the array.

Wait a minute. Since each operation is a swap of prefix and suffix, and I can perform it any number of times, I'm essentially generating a group of permutations of the array by these operations.

But, instead of thinking about all possible permutations, maybe there's a smarter way to check if the array can be sorted with such operations.

Let me think differently.

Suppose I have the array, and I want to sort it in non-decreasing order.

If the array is already sorted, then I don't need to do anything. So, in that case, the answer is "Yes".

If it's not sorted, I need to see if I can make it sorted by swapping prefix and suffix.

Let me consider that the array can be split into two parts, and by swapping them, I can rearrange the elements.

Wait, perhaps I can think of the array as being cut at some point and then concatenated in reverse order.

But, that might not capture all possibilities because I can perform this operation multiple times.

Let me consider what happens if I perform this operation once.

If I split the array into x and y, and swap them to get y + x.

Then, if I perform the operation again on y + x, splitting into some prefix and suffix and swapping them.

This seems complicated to track manually for larger arrays.

Maybe I need to look for a pattern or a specific condition that allows the array to be sorted.

Let me look at the example where it's possible: [7,9,2,2,3]

After first operation: [9,2,2,3,7]

After second operation: [2,2,3,7,9]

So, by performing two such operations, it got sorted.

Is there a general way to find out how many operations are needed or if it's possible at all?

Another way to think about it is to consider the array as a circular list, where I can rotate it in a certain way.

But, in this operation, it's not exactly rotation; it's swapping prefix and suffix.

Wait, rotation can be achieved by swapping prefix and suffix in a certain way.

For example, if I have [1,2,3,4,5], and I split into [1] and [2,3,4,5], swapping gives [2,3,4,5,1], which is a rotation to the right.

Similarly, splitting into [1,2] and [3,4,5], swapping gives [3,4,5,1,2], which is another rotation.

So, rotation is a special case of this operation.

But in this problem, the operation allows any split into prefix and suffix, not necessarily rotating by one position.

So, it's more general than just rotating by one position each time.

But, can any permutation be achieved by performing these operations?

Probably not, because each operation is just swapping two parts.

So, the permutation group generated by these operations might be limited.

But determining whether the sorted array is achievable through these operations seems non-trivial.

Maybe I need to look for a different approach.

Let me consider the sorted version of the array and see if it can be obtained by splitting the original array into two parts and swapping them.

Wait, but I can perform this operation multiple times.

So, perhaps I need to find a sequence of splits and swaps that leads to the sorted array.

This seems too vague. I need a more concrete approach.

Let me consider the property that, after splitting and swapping, the new array is y + x.

If I perform this operation again on y + x, splitting into some prefix and suffix, and swapping them, I get another concatenation.

This seems like it could be modeled as a graph, where each state is an array, and edges are operations.

But with n up to 50, and t up to 1000, this is not feasible to implement.

I need a smarter way.

Let me consider the minimal element in the array.

In a sorted array, the minimal element should be at the beginning.

So, perhaps I need to have the minimal element in the prefix when I perform the swap.

Wait, but I can perform multiple operations.

Maybe I need to find a way to bring the minimal element to the front through these operations.

Similarly, for the next minimal element, and so on.

But this seems too vague.

Let me think about the fact that each operation is a reversal of two parts.

Wait, no, it's not a reversal; it's a swap of prefix and suffix.

It's similar to reversing the order of two parts.

Wait, if I have a = x + y, and I swap them to get y + x, it's like reversing the order of x and y.

If I perform this operation again on y + x, splitting into y1 and y2, then swapping to get y2 + y1 + x.

This seems like I can rearrange parts of the array.

But I'm not sure if this helps me sort the array.

Maybe I need to look for a different approach.

Let me consider that after performing these operations, the array can be seen as a concatenation of two sorted parts, where the first part is sorted and the second part is sorted, and the last element of the second part is greater than or equal to the first element of the first part.

Wait, that might not make sense.

Let me think differently.

Suppose I have the array, and I look for a point where, if I split the array into two parts at that point and swap them, the resulting array is sorted.

If such a point exists, then I can achieve a sorted array with one operation.

But the problem allows multiple operations, so it's not limited to just one.

However, perhaps if I can't sort it with one operation, it's impossible to sort it with more operations.

Wait, but in the example given, it took two operations to sort the array.

So, maybe if it's not sortable with one operation, it's impossible with more operations.

But I'm not sure about that.

Let me try to see.

Take the example [7,9,2,2,3].

After first operation: split into [7] and [9,2,2,3], swap to get [9,2,2,3,7].

Then, split into [9] and [2,2,3,7], swap to get [2,2,3,7,9], which is sorted.

So, in this case, it took two operations.

What if I try to do it in one operation?

Is there a single split and swap that can sort it?

Let's try different splits.

Split into [7,9] and [2,2,3], swap to get [2,2,3,7,9], which is sorted.

Wait, that works in one operation.

So, in this case, it could have been sorted in one operation.

But the example showed doing it in two operations.

So, sometimes, even if it can be done in one operation, it's possible to do it in multiple operations.

So, perhaps, to determine if it's possible, I just need to check if there exists a split point where, after swapping, the array is sorted.

Because, if such a split exists, I can sort it in one operation.

If not, maybe it's impossible to sort it with any number of operations.

Wait, but in the first test case, [1,1,4,5,1,4], it's said to be impossible.

Let's see if there exists a split point where swapping makes it sorted.

Let's try different split points:

Split after 1: [1] and [1,4,5,1,4], swap to get [1,4,5,1,4,1]. Is this sorted? No, because 4 > 1.

Split after first 1: [1,1] and [4,5,1,4], swap to get [4,5,1,4,1,1]. Is this sorted? No, because 5 > 1.

Split after fourth: [1,1,4,5] and [1,4], swap to get [1,4,1,1,4,5]. Is this sorted? No, because 4 > 1.

Split after fifth: [1,1,4,5,1] and [4], swap to get [4,1,1,4,5,1]. Is this sorted? No.

So, no single split and swap makes it sorted.

Is it possible to sort it with two operations? Probably not, but since the problem says it's impossible, maybe it's sufficient to check for one operation.

But in the second example, it could be sorted in one operation, but the example showed doing it in two.

So, perhaps, to save operations, sometimes one operation suffices, sometimes more are needed.

But for the purpose of this problem, we just need to check if it's possible to sort it with any number of operations.

So, maybe checking if there exists a split where swapping makes it sorted is sufficient.

But I'm not sure.

Wait, perhaps it's equivalent to checking if the array is a rotation of a sorted array.

In other words, if the array can be sorted by rotating it in some way.

But, in this problem, the operation is more general than just rotating by one position; it's swapping any prefix and suffix.

So, it's possible to achieve more permutations than just rotations.

Wait, but is it exactly the same as rotations?

Wait, in the first example, [7,9,2,2,3], it was sorted by swapping prefix [7] and suffix [9,2,2,3], resulting in [9,2,2,3,7], and then swapping [9] and [2,2,3,7] to get [2,2,3,7,9].

This seems similar to rotating the array.

But, in general, can any rotation be achieved by these operations?

Wait, if I perform the operation multiple times, can I achieve any rotation of the array?

Let's see.

Take [1,2,3,4,5].

First operation: split into [1] and [2,3,4,5], swap to get [2,3,4,5,1].

Second operation: split into [2] and [3,4,5,1], swap to get [3,4,5,1,2].

Third operation: split into [3] and [4,5,1,2], swap to get [4,5,1,2,3].

And so on.

So, it seems that I can achieve any rotation of the array by performing these operations.

But, in the first test case, [1,1,4,5,1,4], it's impossible to sort it, which suggests that not all arrays can be sorted even if they are rotations of a sorted array.

Wait, maybe I need to think differently.

Perhaps the array can be sorted if and only if it is a rotation of a sorted array.

But in the first test case, [1,1,4,5,1,4], it's not a rotation of a sorted array because no rotation makes it sorted.

In the second test case, [7,9,2,2,3], it is a rotation of [2,2,3,7,9], which is sorted.

In the third test case, [1,2,3], it's already sorted.

So, perhaps the condition is that the array is a rotation of a sorted array.

But, wait, in the first test case, [1,1,4,5,1,4], is it a rotation of a sorted array?

Let's see: the sorted version would be [1,1,4,4,5], but the array has two 4's and two 1's, so [1,1,4,4,5,5], but the original array has only one 5.

Wait, no, the array is [1,1,4,5,1,4], which has two 1's, two 4's, and one 5.

Wait, that's not consistent with the sorted version having [1,1,4,4,5,5].

Wait, no, the array has frequencies: 1:2, 4:2, 5:1.

So, the sorted array would be [1,1,4,4,5], but the original array has [1,1,4,5,1,4], which sums up to six elements, but with only one 5.

Wait, no, [1,1,4,5,1,4] has 1 twice, 4 twice, 5 once, and another 1, wait, counting: 1 appears three times, 4 appears twice, 5 appears once.

Wait, 1 appears three times: positions 1,3,5.

4 appears twice: positions 3 and 6.

5 appears once: position 4.

So, the sorted array should be [1,1,1,4,4,5].

But in the original array, it's [1,1,4,5,1,4], which is not a rotation of [1,1,1,4,4,5].

Because in [1,1,1,4,4,5], all 1's are together, but in the original array, they are separated.

So, perhaps the condition is that the array is a rotation of its sorted version.

In this case, [1,1,4,5,1,4] is not a rotation of [1,1,1,4,4,5], because in any rotation of the sorted array, the three 1's are together, but in the original array, they are separated.

Hence, it's impossible to sort it by rotating it.

Similarly, in the second test case, [7,9,2,2,3] is a rotation of [2,2,3,7,9], which is its sorted version.

Hence, it can be sorted with operations.

So, perhaps the condition is that the array is a rotation of its sorted version.

But, I need to confirm this.

Wait, but in the third test case, [1,2,3], it's already sorted.

And it's a rotation of itself.

Hence, it satisfies the condition.

So, perhaps the general condition is that the array is a rotation of its sorted version.

But, I need to verify this.

Let me consider another example.

Take [3,4,5,1,2].

Its sorted version is [1,2,3,4,5].

Is [3,4,5,1,2] a rotation of [1,2,3,4,5]?

Yes, it is. If I rotate [1,2,3,4,5] twice to the right, I get [4,5,1,2,3], which is not exactly [3,4,5,1,2], but if I rotate [1,2,3,4,5] three times to the right, I get [3,4,5,1,2].

Hence, it is a rotation.

Now, can I sort [3,4,5,1,2] with the given operations?

Yes, by swapping prefix [3] and suffix [4,5,1,2] to get [4,5,1,2,3].

Then, swap [4] and [5,1,2,3] to get [5,1,2,3,4].

Then, swap [5] and [1,2,3,4] to get [1,2,3,4,5], which is sorted.

So, in this case, it took three operations to sort it.

Hence, it seems that if the array is a rotation of its sorted version, it can be sorted with these operations.

But, is the converse true? That is, if an array can be sorted with these operations, must it be a rotation of its sorted version?

Let me think about that.

Suppose the array is [2,2,3,7,9], which is already sorted.

Can I perform operations on it to get other permutations?

For example, swapping [2,2,3,7] and [9] to get [9,2,2,3,7], which is not sorted.

Then, swapping [9] and [2,2,3,7] to get back [2,2,3,7,9].

So, in this case, I can only get back to the sorted array.

Hence, it seems that if the array is already sorted, performing operations won't allow me to get unsorted arrays.

Wait, but I can perform operations that don't change the array, like swapping x=[] and y=[2,2,3,7,9], which remains the same.

Or swapping x=[2,2,3,7,9] and y=[], which again remains the same.

Hence, in this case, I can only stay with the sorted array.

Hence, it seems that only arrays that are rotations of their sorted version can be sorted with these operations.

But, in the first test case, [1,1,4,5,1,4], it's not a rotation of its sorted version [1,1,1,4,4,5], because in any rotation of [1,1,1,4,4,5], the three 1's are together, whereas in the original array, they are separated.

Hence, it's impossible to sort it with these operations.

Therefore, the condition seems to be that the array is a rotation of its sorted version.

Hence, to solve the problem, I need to check if the array is a rotation of its sorted version.

If it is, then output "Yes"; else, "No".

But, how do I check if an array is a rotation of another array?

One way is to check if the array is a substring of the sorted array repeated twice.

Wait, that's a standard way to check if one array is a rotation of another.

So, here's the plan:

1. Sort the array to get the sorted version.

2. Check if the original array is a rotation of this sorted version.

To check if one array is a rotation of another, I can concatenate the sorted array with itself and check if the original array is a substring of this concatenated array.

But, since we're dealing with arrays, I need to check if the original array is a subarray of the concatenated sorted array.

Wait, but in Python, arrays can be compared directly.

So, here's how I can implement it:

- Sort the array to get the sorted version.

- Concatenate the sorted array with itself.

- Check if the original array is a subarray of this concatenated sorted array.

If it is, then it's a rotation of the sorted array, and hence, it can be sorted with the operations. Otherwise, it cannot.

Let's test this logic with the examples.

First test case: [1,1,4,5,1,4]

Sorted version: [1,1,1,4,4,5]

Concatenated sorted: [1,1,1,4,4,5,1,1,1,4,4,5]

Now, check if [1,1,4,5,1,4] is a subarray of [1,1,1,4,4,5,1,1,1,4,4,5].

Looking at the concatenated array:

Positions:

0:1, 1:1, 2:1, 3:4, 4:4, 5:5, 6:1, 7:1, 8:1, 9:4, 10:4, 11:5

Looking for [1,1,4,5,1,4]

Check from position 0: [1,1,1,4,4,5] — doesn't match [1,1,4,5,1,4]

Check from position 1: [1,1,4,4,5,1] — doesn't match

Check from position 2: [1,4,4,5,1,1] — doesn't match

Check from position 3: [4,4,5,1,1,1] — doesn't match

Check from position 4: [4,5,1,1,1,4] — doesn't match

Check from position 5: [5,1,1,1,4,4] — doesn't match

Check from position 6: [1,1,1,4,4,5] — doesn't match

Check from position 7: [1,1,4,4,5,1] — doesn't match

Check from position 8: [1,4,4,5,1,1] — doesn't match

Check from position 9: [4,4,5,1,1,1] — doesn't match

Check from position 10: [4,5,1,1,1,4] — doesn't match

Check from position 11: [5,1,1,1,4,4] — doesn't match

Hence, [1,1,4,5,1,4] is not a rotation of [1,1,1,4,4,5], which is correct, and hence, "No".

Second test case: [7,9,2,2,3]

Sorted version: [2,2,3,7,9]

Concatenated sorted: [2,2,3,7,9,2,2,3,7,9]

Looking for [7,9,2,2,3] in this.

Check from position 2: [2,3,7,9,2] — doesn't match

Position 3: [3,7,9,2,2] — doesn't match

Position 4: [7,9,2,2,3] — matches!

Hence, it's a rotation, and hence, "Yes".

Third test case: [1,2,3]

Sorted version: [1,2,3]

Concatenated sorted: [1,2,3,1,2,3]

Looking for [1,2,3] in this — found at position 0 and position 3.

Hence, it's a rotation (in this case, no rotation needed), and hence, "Yes".

Perfect, this seems to work.

Hence, the plan is:

- For each test case:

- Read n and the array a.

- Sort a to get the sorted version.

- Concatenate the sorted version with itself.

- Check if the original array a is a subarray of this concatenated sorted array.

- If yes, print "Yes"; else, "No".

Now, implement this in code.

But, in Python, checking if a list is a subarray of another list can be done using the 'in' keyword with some adjustments.

Wait, actually, in Python, to check if one list is a sublist of another, we can use a loop to check for the presence of the sublist.

But, for efficiency, since n is up to 50, and t is up to 1000, it's acceptable.

Hence, implement this logic.

Also, need to make sure that the comparison is done correctly, considering the elements' order.

Hence, proceed to implement this.

But, looking back at the given program, it seems to have a different approach.

Let's see what the given program is doing.

It reads t, the number of test cases.

For each test case:

- Reads n and the array a.

- Checks if a is already sorted in non-decreasing order.

- If yes, prints "YES".

- Else, iterates through the array, looking for the first position where a[i-1] > a[i].

- Then, it takes the suffix starting from that position and checks if:

- The suffix is sorted in non-decreasing order.

- And all elements in the suffix are less than or equal to the first element of the array.

- If both conditions are met, it prints "YES"; else, "NO".

Wait, this seems different from my approach.

Let me see if this logic is correct.

In the second test case: [7,9,2,2,3]

It's not sorted, so it enters the else clause.

It finds that a[1]=9 > a[2]=2, so i=2.

Then, new = a[2:]=[2,2,3]

Checks:

- new is sorted: yes, [2,2,3] is sorted.

- a[0]=7 >= all elements in new: 7 >= 2, 2, 3 — yes.

Hence, it should print "YES", which matches the expected output.

In the first test case: [1,1,4,5,1,4]

It's not sorted.

Find a[3]=5 > a[4]=1, so i=4.

new = a[4:]=[1,4]

Check:

- new is sorted: [1,4] is sorted.

- a[0]=1 >= all elements in new: 1 >=1 and 1>=4? No, 1 >=4 is false.

Hence, it prints "NO", which is correct.

In the third test case: [1,2,3]

It's sorted, so it prints "YES" directly.

Hence, this logic seems to work for the given examples.

But, is this logic general?

Let me think about it.

The logic is:

- If the array is already sorted, output "YES".

- Else, find the first position where a[i-1] > a[i].

- Take the suffix starting from a[i] to the end.

- Check if this suffix is sorted in non-decreasing order.

- And, check if a[0] >= all elements in this suffix.

- If both conditions are met, output "YES"; else, "NO".

So, in other words, it's checking if there exists a split point where the suffix is sorted, and all elements in the suffix are <= a[0].

Is this equivalent to checking if the array is a rotation of its sorted version?

In the earlier approach, I proposed checking if the array is a rotation of its sorted version by concatenating the sorted array with itself and checking if the original array is a subarray of that.

Is the given program's logic equivalent to this?

Let me consider an array that is a rotation of its sorted version.

Take [3,4,5,1,2], sorted version [1,2,3,4,5].

Is [3,4,5,1,2] detected as "YES" by the given program?

Find first a[i-1] > a[i]: a[2]=5 > a[3]=1, so i=3.

new = a[3:]=[1,2]

Check if [1,2] is sorted: yes.

Check if a[0]=3 >= all in new: 3 >=1 and 3>=2: yes.

Hence, "YES", which is correct.

Another example: [2,2,3,7,9], sorted [2,2,3,7,9].

It's already sorted, so "YES".

Another example: [9,2,2,3,7], sorted [2,2,3,7,9].

Find a[0]=9 > a[1]=2, so i=1.

new = a[1:]=[2,2,3,7]

Check if [2,2,3,7] is sorted: yes.

Check if a[0]=9 >= all in new: 9 >=2,2,3,7: yes.

Hence, "YES".

Another example: [4,5,1,2,3], sorted [1,2,3,4,5].

Find a[0]=4 > a[1]=5: no.

a[1]=5 > a[2]=1: yes, i=2.

new = a[2:]=[1,2,3]

Check if [1,2,3] is sorted: yes.

Check if a[0]=4 >=1,2,3: yes.

Hence, "YES".

Seems consistent.

Now, is there any case where the array is a rotation of its sorted version, but the given program returns "NO"?

I can't think of any right now.

Similarly, is there any case where the array is not a rotation of its sorted version, but the given program returns "YES"?

Let me think.

Take [1,3,2], sorted [1,2,3].

Find a[1]=3 > a[2]=2, i=2.

new = a[2:]=[2]

Check if [2] is sorted: yes.

Check if a[0]=1 >=2: no.

Hence, "NO", which is correct.

Another case: [2,1,3], sorted [1,2,3].

Find a[0]=2 > a[1]=1, i=1.

new = a[1:]=[1,3]

Check if [1,3] is sorted: yes.

Check if a[0]=2 >=1 and 2>=3: no.

Hence, "NO", which is correct.

Another case: [1,2,2,1], sorted [1,1,2,2].

Find a[2]=2 > a[3]=1, i=3.

new = a[3:]=[1]

Check if [1] is sorted: yes.

Check if a[0]=1 >=1: yes.

Hence, "YES", which is correct, because [1,2,2,1] is a rotation of [1,1,2,2].

Hence, it seems that this logic correctly identifies whether the array is a rotation of its sorted version.

Hence, the given program is correct.

Therefore, Correctness: **True**

**Final Solution**
To solve this problem, we need to determine if a given array can be sorted in non-decreasing order by repeatedly performing a specific operation: splitting the array into a prefix and a suffix, then swapping these two parts.

## Approach

1. **Initial Check for Sorted Array:** 
   - If the array is already sorted in non-decreasing order, we can immediately return "Yes".

2. **Finding the Split Point:**
   - If the array is not sorted, we look for the first position where `a[i-1] > a[i]`. This helps us identify a potential split point.

3. **Checking the Suffix:**
   - We consider the suffix starting from this split point and check two conditions:
     - The suffix should be sorted in non-decreasing order.
     - All elements in this suffix should be less than or equal to the first element of the array.

4. **Conclusion:**
   - If both conditions are satisfied, it means the array can be sorted by swapping the prefix and suffix parts through the allowed operations. Otherwise, it cannot.

## Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        # Check if the array is already sorted
        if all(a[i - 1] <= a[i] for i in range(1, n)):
            print('Yes')
        else:
            # Find the first position where a[i-1] > a[i]
            for i in range(1, n):
                if a[i - 1] > a[i]:
                    # Take the suffix starting from a[i]
                    new = a[i:]
                    # Check if the suffix is sorted and all elements in suffix <= a[0]
                    if all(a[0] >= new[j] for j in range(len(new))) and all(new[j - 1] <= new[j] for j in range(1, len(new))):
                        print('Yes')
                        break
            else:
                # If no such i is found, print 'No'
                print('No')

# To use this function, you can call it in your main function or directly run it.
```

## Explanation

- **Initial Check for Sorted Array:**
  - We first check if the array is already sorted in non-decreasing order. If it is, we print "Yes" immediately.

- **Finding the Split Point:**
  - If the array isn't sorted, we iterate through the array to find the first position where `a[i-1] > a[i]`. This helps identify a potential point to split the array into prefix and suffix.

- **Checking the Suffix:**
  - We then check if the suffix starting from this split point is sorted in non-decreasing order and if all elements in this suffix are less than or equal to the first element of the array.
  
- **Conclusion:**
  - If both these conditions are met, it means the array can be sorted by performing the allowed operations. Otherwise, it cannot be sorted using these operations.

This approach efficiently determines whether it's possible to sort the array through the specified operations, ensuring correctness and adherence to the problem constraints.