Alright, I've got this problem to solve. Let's see what it's about. There are n cows with unique ratings, and they're participating in a coding tournament. Each cow has a distinct rating, and they're initially positioned in a line based on their index. So, cow 1 is at position 1, cow 2 at position 2, and so on up to cow n at position n.

The tournament works like this: It starts with a match between the cow in position 1 and the cow in position 2. The winner of that match then plays against the cow in position 3, and this continues until all cows have competed. The winner of each match is the cow with the higher rating.

Now, I own cow k, and I don't care about winning the entire tournament. Instead, I want my cow to win as many matches as possible. I have the option to swap my cow with another cow in the line, or I can choose not to do anything. My goal is to maximize the number of wins for my cow.

First, I need to understand how the tournament progresses and how my cow can win the most matches. Let's think about the initial setup without any swaps.

In the initial setup, the tournament proceeds as follows:

1. Match 1: Position 1 vs Position 2

2. Match 2: Winner of Match 1 vs Position 3

3. Match 3: Winner of Match 2 vs Position 4

...

n-1. Match n-1: Winner of Match n-2 vs Position n

In each match, the cow with the higher rating wins.

My cow is initially at position k. I need to see how many matches it can win in this setup. But I also have the option to swap my cow with another cow once, to potentially set up a better sequence of matches.

Let me consider the example provided to get a better understanding.

Example 1:

Input:

3

6 1

12 10 14 11 8 3

Output:

1

Explanation:

No swap is needed. Cow 1 (rating 12) vs Cow 2 (rating 10): Cow 1 wins.

Then Cow 1 (rating 12) vs Cow 3 (rating 14): Cow 1 loses.

So, cow 1 wins only 1 match.

Example 2:

Input:

6 5

7 2 727 10 12 13

Output:

2

Explanation:

Swap cow 5 (rating 12) with cow 3 (rating 727).

So now the sequence is: 7, 2, 12, 10, 727, 13

Match 1: Position 1 (7) vs Position 2 (2): Position 1 wins.

Match 2: Winner (7) vs Position 3 (12): Position 3 wins.

Match 3: Position 3 (12) vs Position 4 (10): Position 3 wins.

Match 4: Position 3 (12) vs Position 5 (727): Position 5 wins.

So, cow 5 (now at position 3) wins 2 matches.

Example 3:

Input:

2 2

1000000000 1

Output:

0

Explanation:

Cow 2 (rating 1) vs Cow 1 (rating 1000000000): Cow 1 wins.

So, cow 2 wins 0 matches.

From these examples, it seems that swapping can potentially place my cow in a position where it can win more matches by avoiding stronger opponents early on or by being in a position where it can win against weaker opponents.

Let me try to generalize this.

First, I need to understand how the tournament progresses based on the positions. The tournament is essentially a single-elimination tournament where each match is between the current winner and the next cow in line.

If I don't swap, my cow is at position k, and it will participate in the tournament at that position. I need to simulate the tournament to see how many matches it can win.

But since the tournament is structured in a specific way, maybe there's a smarter way to calculate the number of wins without simulating the entire tournament.

Let me think about the path my cow needs to take to win matches.

If my cow is at position k, it will first play against the winner of the previous matches up to position k-1.

To maximize its wins, I need to ensure that the cows it faces have lower ratings than its own.

But since the ratings are unique, there is a definitive order of strength among the cows.

I need to find a position where my cow can avoid stronger cows as much as possible, so it can win more matches.

Wait, but the tournament structure is such that my cow has to face the cumulative winner up to that point.

So, perhaps the key is to place my cow in a position where the cumulative winner up to that point has a lower rating than my cow, and to maximize the number of such positions.

But this seems a bit vague. Let me try to think differently.

Suppose I fix the position where my cow is placed, either by swapping or by keeping it in its original position. Then, I need to determine how many matches it can win from that position.

To do that, I need to know the sequence of opponents it will face.

In the tournament structure, the opponent in each match is the next cow in line, and the winner proceeds to the next match.

Wait, no. Actually, in the problem statement, it says:

- The first match is between position 1 and position 2.

- Then, each subsequent match is between the winner of the previous match and the next cow in line.

So, it's a bit different from what I initially thought.

Let me try to rephrase this.

- Match 1: Position 1 vs Position 2. The winner is the one with the higher rating.

- Match 2: Winner of Match 1 vs Position 3.

- Match 3: Winner of Match 2 vs Position 4.

- And so on, until Match n-1: Winner of Match n-2 vs Position n.

So, effectively, it's a tournament where each match is between the current champion (winner of the previous match) and the next cow in line.

My goal is to maximize the number of wins for my cow, potentially by swapping its position once.

First, I need to understand how many wins my cow can achieve in the original position.

Then, consider the effect of swapping it with another position and see if that increases the number of wins.

I need an efficient way to do this, considering the constraints: t ≤ 10^4 test cases, n ≤ 10^5, and the sum of n over all test cases does not exceed 10^5.

So, per test case, I need an O(n) solution, but since n can be up to 10^5 and t up to 10^4, but the sum of n over all test cases is 10^5, it should be manageable.

Let me focus on one test case.

Given n, k, and the list of ratings a1 to an.

First, I need to consider the original position of my cow, which is position k, with rating a_k.

I need to simulate the tournament to see how many matches my cow can win staying in position k.

Then, consider swapping my cow with another position, say position p, and see if that increases the number of wins.

I need to choose p optimally to maximize the number of wins for my cow.

But since I can only swap once, I need to find the best position to place my cow to maximize its wins.

Let me think about the tournament structure more carefully.

The tournament proceeds as follows:

- Start with position 1 vs position 2.

- The winner faces position 3.

- The winner of that faces position 4.

- And so on, until position n.

So, it's like a bracket where each match is between the current champion and the next cow in line.

My cow can only win matches if it is the current champion when it's time for its match.

Given that, if my cow is at position m, it will face the winner of the previous m-1 matches.

So, to win at position m, my cow needs to have a higher rating than the winner of the first m-1 matches.

Moreover, if it wins at position m, it will then face position m+1, and so on.

So, the number of wins for my cow is determined by how many consecutive positions it can defeat the winner up to that point.

Wait, but it's not exactly consecutive, because the winner up to position m-1 is the one facing position m.

I need to find out who the winner up to position m-1 is, and see if my cow at position m can defeat that winner.

This seems tricky.

Maybe I need to precompute the winner up to each position.

Let me try that.

Define w[m] as the winner of the first m matches.

Then, w[1] is the winner between position 1 and position 2.

w[2] is the winner between w[1] and position 3.

And so on.

Then, my cow at position k can win matches starting from position k, provided that it can defeat w[k-1].

The number of wins is the number of positions m starting from k where a_k > w[m-1].

But how do I compute w[m] efficiently?

I can compute w[m] in O(n) time by iterating from m=1 to m=n-1.

But n can be up to 1e5, and t up to 1e4, but sum of n over all test cases is 1e5, so it should be fine.

Wait, but in the function provided, it seems like there's a function func_1(a) that takes the list of ratings, but it doesn't seem to directly compute w[m].

Let me look at the provided program.

for _ in range(int(input())):

(n, k) = list(map(int, input().split()))

l = list(map(int, input().split()))

k -= 1

print(func_1(l))

def func_1(a):

x = a[k]

ind = []

c = 0

for i in range(n):

if a[i] > x:

ind.append(i)

c += 1

if c == 2:

break

if k == 14:

print(ind)

if ind == []:

return n - 1

if len(ind) == 1:

if ind[0] == 0:

return k - 1

if ind[0] > k:

return ind[0] - 1

return max(k - ind[0], ind[0] - 1)

if ind[0] == 0:

return min(ind[1] - 1, k - 1)

if k > ind[1]:

return max(ind[0] - 1, ind[1] - ind[0])

return max(ind[0] - 1, k - ind[0])

This seems a bit convoluted. Let's try to understand what it's doing.

First, it finds the positions of the cows with ratings higher than my cow's rating, up to the first two such cows.

Then, based on these positions, it calculates the number of wins.

But I'm not sure about the logic behind it.

Let me try to think differently.

Suppose I fix the position of my cow to be m.

Then, the number of wins for my cow is the number of positions from m to n where my cow can defeat the winner up to position m-1.

Wait, but to compute that, I need to know who the winner up to position m-1 is.

So, perhaps I need to precompute the winner up to each position.

Let me try to precompute w[m], the winner up to the first m matches.

Initialize w[1] as the winner between position 1 and 2.

Then w[2] is the winner between w[1] and position 3.

And so on.

Once I have w[m] for all m from 1 to n-1, then for my cow at position k, the number of wins is the number of positions m starting from k where a_k > w[m-1].

Wait, but w[m-1] is the winner up to position m-1.

So, for my cow at position k, it will play against w[k-1] (if k > 1), and then w[k], and so on.

But I need to think carefully.

Actually, if my cow is at position k, it will first play against w[k-1], which is the winner up to position k-1.

If it wins, it becomes the new champion and plays against position k+1, and so on.

So, the number of wins is the number of positions m starting from k where a_k > w[m-1].

But w[m-1] is the winner up to position m-1.

Wait, but in the tournament structure, w[m] is the winner up to position m.

So, for my cow at position k, the number of wins is the number of m from k to n where a_k > w[m-1].

But I need to compute w[m] for m from 1 to n-1.

Let me try to compute w[m].

Initialize w[1] as max(a[0], a[1]).

Wait, no.

Actually, w[1] is the winner between position 1 and 2, so w[1] = max(a[0], a[1]).

w[2] is the winner between w[1] and position 3, which is max(w[1], a[2]).

And so on.

Wait a minute, it seems that w[m] is simply the maximum of a[0] to a[m].

Because each w[m] is the maximum of the previous w[m-1] and a[m].

So, w[m] = max(a[0], a[1], ..., a[m]) for m from 0 to n-1.

Wait, but indices are from 0 to n-1.

So, w[m] = max(a[0] to a[m]).

Yes, that makes sense.

Therefore, w[m] is the maximum of the first m+1 cows.

Now, for my cow at position k, the number of wins is the number of positions m from k to n-1 where a_k > w[m-1].

Wait, but w[m-1] is the maximum of a[0] to a[m-1].

So, for my cow at position k, to win at position m, it needs a_k > w[m-1].

But w[m-1] is the maximum of a[0] to a[m-1].

So, for m >= k, w[m-1] is the maximum of a[0] to a[m-1], which includes a[k-1].

Wait, but m starts from k.

So, for m = k, w[m-1] = w[k-1] = max(a[0] to a[k-1]).

So, my cow at position k can win at position m if a_k > w[m-1].

But w[m-1] is the maximum of a[0] to a[m-1].

So, if a_k > w[m-1], then my cow can win at position m.

But since w[m-1] is increasing with m, once w[m-1] >= a_k, my cow can no longer win at position m.

Therefore, the number of wins for my cow at position k is the number of positions m from k to n-1 where a_k > w[m-1].

Which is equivalent to finding the largest m such that a_k > w[m-1].

Since w[m-1] is increasing, I can binary search for the first m where w[m-1] >= a_k, and then the number of wins is m - k.

Wait, more precisely, the number of wins is the number of m from k to n-1 where a_k > w[m-1].

Given that w[m-1] is increasing, I can find the largest m where a_k > w[m-1], and the number of such m is m - k.

To find m, I can perform a binary search on m from k to n-1 to find the largest m where a_k > w[m-1].

But computing w[m-1] for each m would be too slow, since n can be up to 1e5.

So, I need a smarter way.

Wait, since w[m-1] is the maximum of a[0] to a[m-1], and it's increasing, I can precompute w[m] for all m.

Then, perform a binary search on m to find the largest m where a_k > w[m-1].

Yes, that should work.

So, steps:

1. Precompute w[m] = max(a[0] to a[m]) for m from 0 to n-1.

2. For my cow at position k, perform a binary search on m from k to n-1 to find the largest m where a_k > w[m-1].

3. The number of wins is m - k.

But I also have the option to swap my cow with another position once.

So, I need to consider all possible positions to place my cow and find the position that maximizes the number of wins.

But since n can be up to 1e5, and t up to 1e4, but sum of n over all test cases is 1e5, I need an efficient way to compute this.

Let me think about it.

First, without swapping, the number of wins for my cow at position k is as described above.

Now, if I swap my cow with another position p, then my cow is at position p, and the cow that was at position p is now at position k.

But I need to maximize the number of wins for my cow, so I need to consider where to place my cow optimally.

Wait, but when I swap, I'm moving my cow to position p, and the cow that was at p moves to position k.

But in terms of maximizing my cow's wins, I only care about where my cow is placed; I don't care about where the other cow is moved.

So, effectively, I can choose to place my cow at any position from 1 to n, and the rest of the cows remain in their positions.

Wait, no. When I swap my cow with another position, I'm swapping the positions of my cow and another cow.

So, if I swap my cow at position k with position p, then my cow is now at position p, and the cow that was at position p is now at position k.

But for maximizing my cow's wins, I need to consider the new sequence after the swap.

But this seems a bit complicated.

Maybe there's a better way to think about it.

Let me consider that I can choose to place my cow at any position, and the rest of the cows remain in their original positions.

This is not exactly correct, because swapping my cow with position p means that the cow at p moves to position k.

But perhaps for the purpose of maximizing my cow's wins, I can treat it as placing my cow at position p and the cow at p being at position k.

But this seems messy.

Let me try to think differently.

Suppose I fix the position m where I place my cow.

Then, I need to compute the number of wins for my cow at position m.

To compute that, I need to know the winner up to position m-1, which is w[m-1], and see if a_k > w[m-1].

If a_k > w[m-1], then my cow wins at position m.

Then, it becomes the new champion and faces position m+1.

I need to repeat this until my cow loses.

So, the number of wins is the number of positions m from m to n where a_k > w[m-1].

But w[m-1] is the maximum of a[0] to a[m-1].

Wait, but if I place my cow at position m, then the sequence of winners up to m-1 is based on the original positions, except that position k now has the cow that was at position m.

So, actually, w[m-1] needs to be recomputed based on the swapped positions.

This seems complicated.

Maybe instead of swapping, I can consider inserting my cow at position m and adjusting the sequence accordingly.

But this seems too time-consuming.

Let me consider that I can choose to place my cow at any position, and the rest of the cows remain in their positions.

Then, I need to find the position m that maximizes the number of wins for my cow.

Given that, I can precompute w[m] as the maximum of a[0] to a[m], and then for each possible m, compute the number of wins if my cow is at position m.

But this is not entirely accurate because swapping affects the sequence.

Wait, maybe I can consider that swapping my cow with position p only affects positions p and k.

So, in the new sequence, position p has my cow, and position k has the cow that was at position p.

Then, w[m] needs to be recomputed based on this new sequence.

This seems too involved.

Perhaps I need to find a smarter way to compute the maximum number of wins without explicitly swapping.

Let me think about the original problem again.

I need to maximize the number of wins for my cow, potentially by swapping it with another position.

I need to find the best position to place my cow to maximize its wins.

Let me consider that the number of wins for my cow at position m is equal to the number of positions from m to n where a_k > w[m-1].

But w[m-1] is the maximum of a[0] to a[m-1].

So, the number of wins is the largest m where a_k > max(a[0] to a[m-1]).

Wait, but m starts from k.

Actually, m starts from the position where my cow is placed.

This is getting confusing.

Let me try to think in terms of the maximum prefix.

If I place my cow at position m, then the number of wins is the number of positions from m to n where a_k > w[m-1], where w[m-1] is the maximum of a[0] to a[m-1].

But in this case, since w[m-1] is increasing, the number of wins is the largest m where a_k > w[m-1].

So, I can perform a binary search on m to find the largest m where a_k > w[m-1].

Then, the number of wins is m - k.

Wait, but m is the position, and k is the original position.

But I need to consider that I can swap my cow to any position.

So, I need to choose m optimally to maximize m - k, given that a_k > w[m-1].

But this seems off.

Let me try to think differently.

Suppose I fix the position m where I place my cow.

Then, the number of wins is the number of positions from m to n where a_k > w[m-1].

But w[m-1] is the maximum of a[0] to a[m-1].

So, if a_k > w[m-1], my cow can win against the current champion and proceed.

Then, it becomes the new champion with rating a_k, and the next opponent is position m+1.

So, the number of wins is the number of positions from m to n where a_k > w[m-1], and a_k > a[m], a_k > a[m+1], and so on.

Wait, no.

Actually, once my cow becomes the champion, it will face position m+1, and to win, it needs a_k > a[m], and so on.

But this seems similar to finding how many consecutive positions my cow can defeat, starting from position m.

But considering that the champion is the winner up to m-1, which is w[m-1], and if a_k > w[m-1], then my cow becomes the new champion.

Then, it faces position m+1, and to win, it needs a_k > a[m+1], and so on.

Wait, I'm getting tangled up.

Maybe I need to consider that the number of wins for my cow at position m is equal to the number of positions from m to n where a_k > w[m-1].

But w[m-1] is the maximum of a[0] to a[m-1].

So, if a_k > w[m-1], then my cow can win at position m, become the new champion with rating a_k, and then face position m+1.

To win against position m+1, it needs a_k > a[m+1].

But since w[m] = max(a[0] to a[m]), and w[m] >= w[m-1], it's getting complicated.

Perhaps I need to find the right position m where w[m-1] < a_k, and then the number of wins is the number of positions where a_k > a[m], a_k > a[m+1], and so on.

But this still seems messy.

Let me consider that the number of wins for my cow at position m is equal to the number of positions from m to n where a_k > max(a[0] to a[m-1]).

Because to win at position m, my cow needs to have a higher rating than the current champion, which is w[m-1] = max(a[0] to a[m-1]).

Then, if a_k > w[m-1], it wins and becomes the new champion with rating a_k.

Then, to win at position m+1, it needs a_k > a[m+1], but since w[m] = max(a[0] to a[m]), which is max(w[m-1], a[m]), and so on.

This seems too convoluted.

Maybe I need to find a different approach.

Let me consider that in the sequence, the number of wins for my cow is determined by how many initial cows have ratings lower than its own, up to the point where it faces a cow with a higher rating.

Wait, perhaps I can think in terms of the number of cows with lower ratings before it.

But no, because the tournament structure is specific, and it's not just about the number of cows with lower ratings before it.

I need to consider the cumulative maximum up to each position.

Let me try to precompute w[m] = max(a[0] to a[m]) for m from 0 to n-1.

Then, for my cow at position k, the number of wins is the number of positions m from k to n where a_k > w[m-1].

Assuming m starts from k, and w[m-1] is known.

So, I can find the largest m where a_k > w[m-1], and the number of wins is m - k.

To find m, I can perform a binary search on m from k to n-1 to find the largest m where a_k > w[m-1].

Since w[m-1] is increasing, this is feasible.

Similarly, if I choose to swap my cow to position p, then I need to compute the number of wins for my cow at position p, which is the number of m from p to n where a_k > w[m-1], where w[m-1] is computed based on the swapped positions.

But swapping affects w[m-1] because the sequence changes at positions p and k.

This seems complicated.

Maybe I can consider that swapping my cow to position p only affects the positions p and k, and then recomputing w[m-1] accordingly.

But this still seems time-consuming.

Let me see if there's a pattern or a formula that can simplify this.

Looking back at the provided code, it seems to find the positions of the cows with ratings higher than my cow's rating, up to the first two such cows.

Then, based on these positions, it calculates the number of wins.

Let me see what it's doing.

def func_1(a):

x = a[k]

ind = []

c = 0

for i in range(n):

if a[i] > x:

ind.append(i)

c += 1

if c == 2:

break

if k == 14:

print(ind)

if ind == []:

return n - 1

if len(ind) == 1:

if ind[0] == 0:

return k - 1

if ind[0] > k:

return ind[0] - 1

return max(k - ind[0], ind[0] - 1)

if ind[0] == 0:

return min(ind[1] - 1, k - 1)

if k > ind[1]:

return max(ind[0] - 1, ind[1] - ind[0])

return max(ind[0] - 1, k - ind[0])

So, it finds the positions of cows with ratings higher than my cow's rating, up to the first two such cows.

Then, based on these positions, it returns different values.

I need to understand why it's doing this.

I think the idea is to find the positions of the cows stronger than my cow, because these are the cows that can potentially beat my cow.

So, if there are no such cows, then my cow can win all matches from its position to the end.

Hence, if ind is empty, return n - 1.

If there is one such cow, then its position affects how many wins my cow can achieve.

Similarly, if there are two such cows, their positions affect the number of wins.

But I need to verify this logic.

Let me consider the first example:

n=6, k=1, a=[12,10,14,11,8,3]

My cow is at position 1 (index 0), with rating 12.

Cows with higher ratings than 12 are at positions 3 (14) and 4 (11).

Wait, no, position 3 has 14, position 4 has 11.

So, ind=[2] (since index starts from 0).

Wait, but according to the code, it finds positions where a[i] > x, up to the first two such cows.

So, in this case, a[2]=14 > 12, so ind=[2], c=1.

Since c < 2, it stops.

Then, len(ind)==1, and ind[0]=2 > k=1, so it returns ind[0]-1=1.

Which is correct, as in the example, the number of wins is 1.

In the second example:

n=6, k=5, a=[7,2,727,10,12,13]

My cow is at position 5 (index 4), with rating 12.

Cows with higher ratings than 12 are at positions 3 (727) and possibly others.

ind would be [2] (index 2 with 727), c=1.

Then, len(ind)==1, ind[0]=2 < k=5, so it returns max(k - ind[0], ind[0] -1 )=max(5-2,2-1)=max(3,1)=3.

But in the example, by swapping to position 3, the number of wins is 2.

This seems inconsistent.

Wait, perhaps I misread the code.

Looking back, in the code, it's checking conditions based on ind and k.

Wait, perhaps the code is incorrect.

Wait, but in the example, swapping to position 3 gives 2 wins, but according to the code, it returns 3, which is incorrect.

So, maybe the code is wrong.

Wait, but the problem says to print the maximum number of wins, considering swapping or not swapping.

In the second example, swapping to position 3 gives 2 wins, which matches the output.

But according to the code, it returns 3, which doesn't match.

Wait, perhaps I'm misunderstanding.

Wait, in the second example, n=6, k=5, a=[7,2,727,10,12,13]

My cow is at position 5 (index 4), rating=12.

Cows with higher ratings are at position 3 (727).

So, ind=[2] (index 2), c=1.

Then, len(ind)==1, ind[0]=2 < k=5, so it returns max(5-2, 2-1)=max(3,1)=3.

But in reality, by swapping to position 3, my cow has rating 12, and the sequence becomes:

Position 1:7, Position 2:2, Position 3:12, Position 4:10, Position 5:727, Position 6:13.

Then, tournament proceeds as:

Match 1: Position 1 (7) vs Position 2 (2): Position 1 wins.

Match 2: Position 1 (7) vs Position 3 (12): Position 3 wins.

Match 3: Position 3 (12) vs Position 4 (10): Position 3 wins.

Match 4: Position 3 (12) vs Position 5 (727): Position 5 wins.

So, my cow at position 3 wins 2 matches.

But according to the code, it returns 3, which is incorrect.

Wait, perhaps I miscounted.

Wait, in this scenario, my cow wins 2 matches: Match 2 and Match 3.

But according to the code, it returns 3, which doesn't match.

So, perhaps the code is incorrect.

Wait, perhaps I misread the code.

Looking back, in the code, it's func_1(a), but in the loop, it's func_1(l), which is the list of ratings.

But in the function, it uses a[k], assuming k is global.

But in the code, k is defined in the loop, so it should be accessible in func_1.

But in the second example, it returns 3, but the correct answer is 2.

So, perhaps the code is wrong.

Wait, maybe I need to understand the logic behind the code.

Looking back, the code finds positions where a[i] > x = a[k], up to the first two such positions.

Then, based on these positions, it computes the number of wins.

But in the second example, it seems to return 3, which is incorrect.

Wait, but in the output, it's 2, not 3.

Wait, perhaps I misread the code.

Wait, in the second example, swapping to position 3 gives 2 wins, which matches the output.

But according to the code, for the second example, it returns 3, which doesn't match the output.

Wait, perhaps I'm misunderstanding how the code works.

Wait, perhaps the code is different from what I think.

Looking back, in the second example, n=6, k=5, a=[7,2,727,10,12,13]

ind = [2], since a[2]=727 > 12.

Then, len(ind)==1, ind[0]=2 < k=5, so it returns max(5-2, 2-1)=max(3,1)=3.

But in reality, by swapping to position 3 (index 2), my cow can win 2 matches.

So, the code is incorrect in this case.

Wait, but in the output, it's 2, which suggests that the code might be different.

Wait, perhaps there's a mistake in the code.

Looking back, in the code, it's func_1(l), but in my earlier analysis, I assumed it was func_1(a).

Wait, perhaps there's a mistake in the code provided.

Looking back, the code is:

def func_1(a):

x = a[k]

ind = []

c = 0

for i in range(n):

if a[i] > x:

ind.append(i)

c += 1

if c == 2:

break

if k == 14:

print(ind)

if ind == []:

return n - 1

if len(ind) == 1:

if ind[0] == 0:

return k - 1

if ind[0] > k:

return ind[0] - 1

return max(k - ind[0], ind[0] - 1)

if ind[0] == 0:

return min(ind[1] - 1, k - 1)

if k > ind[1]:

return max(ind[0] - 1, ind[1] - ind[0])

return max(ind[0] - 1, k - ind[0])

But in the second example, it returns 3, but the correct answer is 2.

So, perhaps the code is incorrect.

Wait, perhaps I need to fix the code.

Alternatively, maybe I need to think differently.

Let me consider that the number of wins for my cow at position m is equal to the number of positions from m to n where a_k > w[m-1], where w[m-1] is the maximum of a[0] to a[m-1].

So, to maximize the number of wins, I need to choose m such that a_k > w[m-1], and m is as large as possible.

Wait, but m needs to be from k to n.

Wait, no, m is the position where I place my cow.

So, I need to choose m optimally.

Wait, perhaps I can choose m to be the smallest m where w[m-1] < a_k, and then the number of wins is the number of positions from m to n where a_k > w[m-1].

But this still seems unclear.

Let me try to think about the best position to place my cow.

If I place my cow at position m, it will first face the winner up to position m-1, which is w[m-1].

If a_k > w[m-1], it wins and becomes the champion, then faces position m+1.

To maximize the number of wins, I need to choose m such that:

- w[m-1] < a_k

- a_k > a[m], a_k > a[m+1], and so on, for as many positions as possible.

But this seems too vague.

Maybe I need to consider that the number of wins is equal to the number of positions from m to n where a_k is greater than the maximum of a[0] to a[m-1].

So, for each m, the number of wins is the largest p where for all m to p, a_k > w[m-1].

But w[m-1] is the maximum of a[0] to a[m-1].

So, if m increases, w[m-1] also increases.

Therefore, there will be a point where a_k <= w[m-1], and my cow can no longer win.

So, the number of wins is the number of m to p where a_k > w[m-1].

Since w[m-1] is increasing, I can find the largest m where a_k > w[m-1].

To maximize the number of wins, I need to choose m such that m - k is maximized, subject to a_k > w[m-1].

Wait, but m needs to be at least k.

Wait, actually, m is the position where I place my cow, so m can be any position from 1 to n.

But I need to consider that swapping my cow to position m affects the sequence.

This is getting too complicated.

Perhaps I need to accept that the provided code is incorrect and find the right approach.

Let me try to think differently.

Suppose I don't swap my cow; it stays at position k.

Then, the number of wins is the number of positions from k to n where a_k > w[m-1], where w[m-1] is the maximum of a[0] to a[m-1].

Similarly, if I swap my cow to position p, then the sequence changes:

- The cow at position p moves to position k.

- My cow moves to position p.

Then, w[m-1] needs to be recomputed based on this new sequence.

This seems too time-consuming.

Maybe I can consider that swapping my cow to position p only affects positions p and k, and then compute w[m-1] accordingly.

But this still seems messy.

Let me consider that the number of wins for my cow at position p is equal to the number of positions from p to n where a_k > w[m-1], where w[m-1] is the maximum of a[0] to a[m-1] in the new sequence.

But in the new sequence, a[p] = a_k, and a[k] = a[p].

So, w[m-1] is the maximum of a[0] to a[m-1], with a[p] = a_k and a[k] = a[p].

This is getting too involved.

Perhaps I need to find a different approach.

Let me consider that the number of wins for my cow is determined by how many cows before it have higher ratings than it.

But in the tournament structure, it's not just about the cows before it; it's about the cumulative maximum up to each position.

Wait, perhaps I can consider that my cow can win matches until it faces a cow with a higher rating than itself.

So, the number of wins is the number of cows with lower ratings before the first cow with a higher rating.

But this seems similar to the concept of next greater element.

Yes, perhaps I can use the next greater element concept.

So, for my cow at position k, I can find the number of wins as the distance to the next cow with a higher rating than it.

Similarly, if I swap it with another position, I can find the next greater element from that position.

Wait, but I can only swap once, so I need to choose the best position to place my cow to maximize its wins.

So, perhaps I need to find the position where the distance to the next higher rating is maximized, considering that I can place my cow there.

But this might not be entirely accurate, because the tournament structure is cumulative.

Wait, perhaps I need to find the position where the cumulative maximum up to m-1 is less than a_k, and m is as large as possible.

Then, the number of wins is m - k.

To maximize m - k, I need to choose m such that w[m-1] < a_k, and m is as large as possible.

Given that w[m-1] is increasing, I can perform a binary search on m to find the largest m where w[m-1] < a_k.

So, precompute w[m-1] for m from 1 to n.

Then, for each possible position p, perform a binary search to find the largest m where w[m-1] < a_k.

But this is O(n log n), which is too slow for the constraints.

Wait, but n can be up to 1e5, and t up to 1e4, but the sum of n over all test cases is 1e5, so it should be manageable.

But I need a better approach.

Let me think differently.

Suppose I fix the position p where I place my cow.

Then, the number of wins is the number of positions from p to n where a_k > w[m-1], where w[m-1] is the maximum of a[0] to a[m-1] in the new sequence.

But this is too slow.

Maybe I need to consider that w[m-1] is the maximum of a[0] to a[m-1], and if I place my cow at position p, then for m from p to n, w