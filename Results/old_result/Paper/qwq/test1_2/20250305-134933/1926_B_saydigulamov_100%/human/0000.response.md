Alright, I've got this problem to solve. Let's see what it's asking for. So, Vladislav has a binary square grid of n by n cells, and on this grid, there's either a triangle or a square made up of '1's. I need to determine which shape is drawn based on the grid provided.

First, I need to understand what constitutes a triangle and a square in this context.

For a triangle:

- It's made up of k rows (where k > 1), and each row has 2*i - 1 '1's, where i is the row number. So, the first row has 1 '1', the second has 3 '1's, and so on.

- These '1's are centered in such a way that they form a triangle. Also, an upside-down triangle is also valid, but not one rotated by 90 degrees.

For a square:

- It's made up of k rows (k > 1), and each row has k '1's, all aligned in the same columns, meaning they are at an equal distance from the left edge.

Given that the grid is n by n, and n can be from 2 to 10, it's manageable in terms of size.

The input consists of multiple test cases, up to 100, each with a grid size n and the grid itself.

The output should be "SQUARE" or "TRIANGLE" for each test case, indicating which shape is drawn.

Looking at the provided program:

def func():

a = int(input())

for i in range(a):

k = []

for _ in range(int(input())):

b = input()

if '1' in b:

k.append(b.count('1'))

if k[0] == k[1]:

print('SQUARE')

else:

print('TRIANGLE')

So, the function reads the number of test cases, then for each test case, it reads n and then n lines of the grid. It seems to collect the count of '1's in each row that contains at least one '1', and then checks if the first two counts are equal to decide if it's a square or a triangle.

Wait a minute, this seems too simplistic. Let's think about it.

For a square, every row in the shape should have the same number of '1's, aligned in the same columns. So, if it's a square of size k, then k rows, each with k '1's, all in the same k columns.

For a triangle, the number of '1's increases with each row, specifically 1, 3, 5, etc., for a normal triangle, or decreases for an upside-down triangle.

So, in the program, it's collecting the counts of '1's in rows that have at least one '1', and then checking if the first two counts are equal to decide between square and triangle.

Is this sufficient?

Let's consider some examples.

Example 1:

Input:

3

000

011

011

Output:

SQUARE

In this case, the '1's form a 2x2 square in the bottom-right corner. The counts of '1's in rows with '1's are 2 and 2. So, k = [2, 2]. Since k[0] == k[1], it's a square.

Example 2:

Input:

4

0000

0000

0100

1110

Output:

TRIANGLE

Here, the '1's form a triangle:

Row 3: '0100' -> 1 '1'

Row 4: '1110' -> 3 '1's

So, k = [1, 3]. Since k[0] != k[1], it's a triangle.

Example 3:

Input:

2

11

11

Output:

SQUARE

Counts: [2, 2] -> SQUARE

Example 4:

Input:

5

00111

00010

00000

00000

00000

Output:

TRIANGLE

Counts: [3,1] -> TRIANGLE

Example 5:

Input:

10

0000000000

0000000000

0000000000

0000000000

0000000000

1111111110

0111111100

0011111000

0001110000

0000100000

Output:

TRIANGLE

Counts: [9,8,6,4,1] -> Not equal in first two, so TRIANGLE

Example 6:

Input:

3

111

111

111

Output:

SQUARE

Counts: [3,3,3] -> SQUARE

Wait, but according to the problem, the grid contains exactly one triangle or one square consisting of '1's, and it's guaranteed that the shape size is greater than 1.

In the program, it only checks the first two counts. Is this always sufficient?

Let's think about potential edge cases.

Case 1: A square with k=2 in a n=3 grid.

Possible grid:

000

011

011

Counts: [2,2]

Correctly identified as SQUARE.

Case 2: A triangle with k=2 in a n=3 grid.

Possible grid:

000

010

111

Counts: [1,3]

Correctly identified as TRIANGLE.

Case 3: A square with k=3 in a n=3 grid.

111

111

111

Counts: [3,3,3]

The program would check only the first two, which are equal, correctly identifying it as SQUARE.

Case 4: An upside-down triangle with k=3 in a n=4 grid.

0010

0111

1111

0000

Counts: [1,3,4]

First two are different, correctly identifying it as TRIANGLE.

Case 5: A triangle with k=1 is invalid since k > 1, so no need to worry about single-row triangles.

Case 6: A square with k=1 is also invalid.

Given that the shape size is guaranteed to be greater than 1, and the grid contains exactly one shape, either a square or a triangle.

Is there any scenario where a square has the first two row counts equal, but the subsequent rows differ?

No, because in a square, all rows should have the same number of '1's.

Similarly, in a triangle, the row counts increase or decrease, so the first two rows would have different counts.

Wait, in an upside-down triangle, the counts decrease.

For example:

Row 1: 3 '1's

Row 2: 1 '1'

This would have k=[3,1], which are different, correctly identifying it as TRIANGLE.

So, in all cases, if it's a square, all row counts are equal, and if it's a triangle, the row counts are increasing or decreasing.

Therefore, checking only the first two row counts seems sufficient because:

- For a square, all row counts must be equal.

- For a triangle, the row counts change from row to row.

But, to be thorough, I should consider if there's any square where the first two row counts could be equal, but subsequent rows differ.

Wait, no. In a square, all rows must have the same number of '1's, aligned in the same columns.

Similarly, in a triangle, the number of '1's changes per row.

Hence, checking only the first two rows should be enough to determine the shape.

If the first two rows have the same number of '1's, it's likely a square, and if they differ, it's a triangle.

Given that the grid size is small (n <= 10), and the number of test cases is manageable (t <= 100), this approach seems efficient enough.

Additionally, the program only collects rows that contain at least one '1', which makes sense because the shape may not start from the first row.

In conclusion, the provided program correctly identifies whether the shape is a square or a triangle based on the counts of '1's in the rows containing '1's.

Therefore, the program is correct.

**Final Answer**

\[ \boxed{\text{True}} \]