Alright, I've got this problem to solve. Let's see what it's asking for. So, there are n signs of the apocalypse, and each sign appears every a_i years. The signs have to occur sequentially, meaning that after the first sign appears, we start waiting for the second sign in the next year, and so on, until the nth sign appears.

First, I need to understand how the signs occur. Each sign i occurs in years that are multiples of a_i, like a_i, 2*a_i, 3*a_i, and so on. But according to the problem, the signs must occur sequentially, meaning that after the first sign occurs in year x, we start looking for the second sign in year x+1, and it has to be the first occurrence of the second sign after x.

Wait, that seems a bit confusing. Let me look at the example to get a better understanding.

In the first example:

n = 6

a = [3, 2, 4, 5, 9, 18]

And the output is 36.

Let's see what's happening here.

- The first sign occurs in years 3, 6, 9, 12, etc.

- Let's say it occurs in year 3.

- Then we start looking for the second sign from year 4 onwards.

- The second sign occurs in years 2, 4, 6, 8, etc.

- So the first occurrence after year 3 is in year 4.

- Now, from year 5 onwards, we look for the third sign, which occurs in years 4, 8, 12, etc.

- The first occurrence after year 4 is in year 8.

- From year 9 onwards, look for the fourth sign, which occurs in years 5, 10, 15, etc.

- The first occurrence after year 8 is in year 10.

- From year 11 onwards, look for the fifth sign, which occurs in years 9, 18, 27, etc.

- The first occurrence after year 10 is in year 18.

- From year 19 onwards, look for the sixth sign, which occurs in years 18, 36, 54, etc.

- The first occurrence after year 18 is in year 36.

So, the nth sign occurs in year 36.

Okay, so the idea is that for each sign, we need to find the smallest year greater than the previous sign's year where this sign occurs.

So, for sign i, find the smallest year > year of sign i-1 where year % a_i == 0.

Wait, but in the example, for the second sign, it's a_2 = 2, and the first sign was in year 3, so we look for the smallest year >=4 where year % 2 ==0, which is 4.

Similarly, for the third sign, a_3=4, and previous year is 4, so next year to look is 5 onwards, but 5 is not divisible by 4, so next is 8.

And so on.

So, the general approach is:

- Initialize year =0

- For each sign from 1 to n:

- Find the smallest year > current year where year % a_i ==0

- Update year to this new year

- Output the year when the nth sign occurs.

Now, how to implement this efficiently, especially since n can be up to 100 and a_i can be up to 1e6, and t can be up to 1000, so we need an efficient solution.

Let's think about how to find the smallest year > current_year where year % a_i ==0.

If current_year is the year after the previous sign, then the next year where a_i occurs is:

- If current_year % a_i ==0, then current_year

- Else, current_year + (a_i - current_year % a_i)

But since we need year > current_year, if current_year % a_i ==0, we need to take current_year + a_i.

So, in general, year = current_year + ((a_i - current_year % a_i) % a_i)

Wait, better to think as:

if current_year % a_i ==0:

year = current_year + a_i

else:

year = current_year + (a_i - current_year % a_i)

This ensures that year is the smallest year > current_year where year % a_i ==0.

Let's test this with the first example:

Initialize year=0

For sign 1, a_1=3

0 %3 !=0, so year=0 + (3-0)=3

For sign 2, a_2=2

3 %2 !=0, so year=3 + (2-3%2)=3 + (2-1)=4

For sign 3, a_3=4

4 %4 ==0, so year=4 +4=8

For sign 4, a_4=5

8 %5 !=0, so year=8 + (5-8%5)=8 + (5-3)=10

For sign 5, a_5=9

10 %9 !=0, so year=10 + (9-10%9)=10 + (9-1)=18

For sign 6, a_6=18

18 %18 ==0, so year=18 +18=36

Yes, matches the example.

So, this seems correct.

Now, let's see if there's a way to optimize this.

Given that n can be up to 100 and t up to 1000, and a_i up to 1e6, we need an efficient way to compute this.

The above method seems O(n*t), which should be acceptable since n<=100 and t<=1000.

Now, looking at the given program:

def func():

t = int(input())

for _ in range(t):

n = int(input())

a = list(map(int, input().split()))

year = 0

for ai in a:

year += year % ai or ai

print(year)

Wait, this looks different from what I thought.

Let's see what this does.

It initializes year=0

Then for each ai in a:

year += year % ai or ai

What does "year % ai or ai" mean?

In Python, "or" returns the first truthy value or the last falsy value.

So, if year % ai is not zero, it's truthy, so year += year % ai

Else, year += ai

Wait, is that correct?

Let's see with the first example:

year=0

a=[3,2,4,5,9,18]

First ai=3

0%3=0, so year += 0 or 3 => 0 or 3 => 3, so year=3

Second ai=2

3%2=1, so year +=1, year=4

Third ai=4

4%4=0, so year +=0 or 4 =>4, so year=8

Fourth ai=5

8%5=3, so year +=3, year=11

Wait, but in the example, it should be 10, not 11.

Wait, perhaps it's not correct.

Wait, in the earlier manual calculation, for a_4=5 and current_year=8:

Since 8%5=3 !=0, so year=8 + (5-3)=10

But according to the code, year += year%ai or ai, which would be year +=3, so year=11, which is different from 10.

So, this seems incorrect.

Wait, maybe I misread the code.

Wait, no, year += year%ai or ai

In Python, "or" has lower precedence than "+=", so it's year += (year%ai or ai)

So, yes, as I thought.

So, in this case, year=8, ai=5, 8%5=3, which is truthy, so year +=3, year=11

But according to the correct calculation, it should be 10.

So, the code is wrong.

Wait, but maybe I'm misunderstanding something.

Let me check with the first test case.

First test case:

n=6

a=[3,2,4,5,9,18]

According to the code:

year=0

year +=0 or3 => year=3

year +=3%2 or2 =>1 or2 =>1, year=4

year +=4%4 or4 =>0 or4 =>4, year=8

year +=8%5 or5 =>3 or5 =>3, year=11

year +=11%9 or9 =>2 or9 =>2, year=13

year +=13%18 or18 =>13 or18 =>13, year=26

But according to the example, it should be 36, but the code outputs 26, which is incorrect.

Wait, but in the example, it's 36.

So, the code is incorrect.

Wait, but perhaps there's a mistake in my understanding.

Wait, in the code, year += year%ai or ai

Which is equivalent to:

if year % ai:

year += year % ai

else:

year += ai

But according to the correct logic, it should be:

if year % ai ==0:

year += ai

else:

year += ai - (year % ai)

Which is different from what the code is doing.

In the code, it's adding year%ai if it's not zero, else adding ai.

But according to the correct logic, it should be adding ai - (year % ai) if year % ai !=0, else adding ai.

Which is not the same as the code.

So, the code is incorrect.

Wait, let's see with the first test case:

year=0

a=3: 0%3=0, so year +=3, year=3

a=2: 3%2=1, so year +=1, year=4

a=4:4%4=0, so year +=4, year=8

a=5:8%5=3, so year +=3, year=11

a=9:11%9=2, so year +=2, year=13

a=18:13%18=13, so year +=13, year=26

But according to the correct calculation, it should be 36.

So, the code is wrong.

Wait, perhaps it's a mistake in the code.

Let me check with another example.

Take n=5, a=[1,2,3,4,5]

According to the code:

year=0

a=1:0%1=0, year +=1, year=1

a=2:1%2=1, year +=1, year=2

a=3:2%3=2, year +=2, year=4

a=4:4%4=0, year +=4, year=8

a=5:8%5=3, year +=3, year=11

But according to the correct calculation:

Start with year=0

a1=1: year=1 (since 0%1==0, so year=0+1=1)

a2=2:1%2=1, so year=1 + (2-1)=2

a3=3:2%3=2, so year=2 + (3-2)=3

a4=4:3%4=3, so year=3 + (4-3)=4

a5=5:4%5=4, so year=4 + (5-4)=5

So, correct year is 5, but the code outputs 11, which is wrong.

Hence, the code is incorrect.

Another example:

n=5, a=[1,1,1,1,1]

According to the code:

year=0

a=1:0%1=0, year +=1, year=1

a=1:1%1=0, year +=1, year=2

a=1:2%1=0, year +=1, year=3

a=1:3%1=0, year +=1, year=4

a=1:4%1=0, year +=1, year=5

Which matches the correct calculation, as each sign occurs every 1 year, so the 5th sign occurs in year 5.

But according to the example, the output is 5 for this case, which matches the code's output.

Wait, but in the previous case, the code gave wrong output.

Wait, perhaps there are multiple test cases where the code gives correct output for some and incorrect for others.

But since at least one test case gives incorrect output, the code is incorrect.

Hence, Correctness: False

**Final Solution**

To solve this problem, we need to determine the year in which the nth sign occurs, considering that each sign occurs at periodic intervals and must occur sequentially after the previous sign.

## Approach

1. **Understanding the Problem:**
   - Each sign occurs at multiples of its period.
   - We need to find the smallest year for each sign to occur sequentially, i.e., after the previous sign has occurred.

2. **Key Insight:**
   - For each sign, calculate the smallest year greater than the current year that is a multiple of the sign's period.

3. **Algorithm:**
   - Initialize the year to 0.
   - For each sign's period in the list:
     - If the current year is already a multiple of the period, add the period to the year.
     - Otherwise, calculate the next multiple of the period that is greater than the current year and set the year to that value.
   - Output the final year after processing all signs.

## Solution Code

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        year = 0
        for ai in a:
            if year % ai == 0:
                year += ai
            else:
                year += ai - (year % ai)
        print(year)

func()
```

## Explanation

1. **Reading Input:**
   - Read the number of test cases `t`.
   - For each test case, read the number of signs `n` and their periods `a`.

2. **Processing Each Test Case:**
   - Initialize `year` to 0.
   - For each period `ai` in the list of periods:
     - If `year` is a multiple of `ai`, add `ai` to `year` to get the next occurrence.
     - If `year` is not a multiple of `ai`, calculate the smallest year greater than `year` that is a multiple of `ai` and set `year` to that value.
   
3. **Output:**
   - Print the final `year` for each test case, which is the year when the nth sign occurs.

This approach ensures that we correctly compute the year in which all n signs will occur sequentially, adhering to their periodicities.