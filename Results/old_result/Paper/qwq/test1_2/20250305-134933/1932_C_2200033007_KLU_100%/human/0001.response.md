Alright, I've got this problem to solve. Let's see what it's asking for. So, I'm given an array of integers, a positive integer m, and a string of commands consisting of 'L's and 'R's. For each command, I need to output the product of all elements in the array modulo m, and then remove either the leftmost or the rightmost element from the array, depending on whether the command is 'L' or 'R'.

First, I need to understand what the problem is really asking. I have to process a series of commands in order, and for each command:

1. Calculate the product of all current elements in the array, take that product modulo m, and output it.

2. Remove either the leftmost or the rightmost element from the array, based on whether the command is 'L' or 'R'.

And I have to do this for multiple test cases, with the guarantee that the total sum of n across all test cases doesn't exceed 2*10^5, which is 200,000. So, efficiency is key here.

Let me think about how to approach this. The straightforward way would be, for each command, to calculate the product of the current array modulo m, output it, and then remove the appropriate element. However, calculating the product from scratch every time would be inefficient, especially since n can be up to 2*10^5 and t can be up to 10^4, but with the sum of n across all test cases being up to 2*10^5.

So, I need a smarter way to handle the product calculations. One way to optimize this is to precompute the product of all elements in the array modulo m, and then, as I remove elements, divide the product by the removed element and take modulo m again. But, division in modular arithmetic is not straightforward because m might not be prime, and I might not have modular inverses for all possible divisors.

Wait, actually, in general, division in modular arithmetic is tricky when m is not prime because not all elements have inverses. So, I need to find another way.

Let me consider the sequence of operations. Since I'm removing elements one by one, either from the left or the right, the array is being reduced step by step until it's empty. So, at each step, the array is getting smaller by one element.

I need to find a way to compute the product of the current array modulo m efficiently at each step.

Another idea: since I'm removing elements in a specific order specified by the string s, I can determine in advance which elements are going to be removed in which order. Maybe I can find a way to compute the product of the remaining elements at each step without having to recalculate the product from scratch each time.

Wait a minute, perhaps I can compute the product of all elements initially, then, as I remove elements according to the commands, I can divide the current product by the removed element, but as I said earlier, division in modular arithmetic is tricky.

Alternatively, maybe I can compute the product in a way that allows me to remove factors easily. But again, division is an issue.

Let me think differently. Maybe I can process the commands in reverse order. That is, start from the end, when the array has only one element, and work backwards, keeping track of the product as I add elements back in.

Wait, but the problem requires me to output the product modulo m at each step before removing an element. So, if I process in reverse, I might be able to build up the product step by step.

Let me try to formalize this.

Suppose I have the sequence of commands: s = s1 s2 ... sn

At step 1:

- Output product of all elements modulo m

- Remove the element specified by s1 ('L' or 'R')

At step 2:

- Output product of the remaining elements modulo m

- Remove the element specified by s2 ('L' or 'R'), from the current array, etc.

So, if I process this forwards, it's tricky because the product changes with each removal.

But if I process backwards, starting from the last step, where only one element is left:

- At the last step, the array has only one element, so the product is that element modulo m.

- At the second-to-last step, the array has two elements, and I'm about to remove one of them to get to the last step.

- So, the product at the second-to-last step is the product of the two elements modulo m.

- And so on, building up the product as I go backwards.

Wait, but actually, if I process backwards, I can keep track of the product of the elements that have not been removed yet.

Let me try to think of it this way:

- Start from the end, where the array is empty, and the product is 1 (since the product of an empty set is 1).

- Then, as I add elements back in, according to the reverse of the commands, I can multiply the current product by the added element, modulo m.

- But I need to output the product at each step before removing the element, which corresponds to adding the element back in when processing backwards.

This might be a way to compute the products efficiently.

Let me try to outline the steps:

1. Read the number of test cases, t.

2. For each test case:

a. Read n and m.

b. Read the array a of n integers.

c. Read the string s of n commands.

d. Initialize an empty list to store the answers for each command.

e. Simulate the process:

i. Start with an empty array.

ii. Iterate through the commands in reverse order.

iii. For each command, add the corresponding element back into the array and update the product.

iv. Store the product modulo m for each step.

f. Output the answers in the correct order.

Wait, but I need to make sure that when I add elements back in, I'm adding them in the correct positions, according to the commands.

Let me think about how to simulate this.

If I have the sequence of commands, s = s1 s2 ... sn

Processing forwards:

- Start with the full array a.

- For each command s_i:

- Output product of current a modulo m.

- Remove the leftmost element if s_i == 'L', or the rightmost if s_i == 'R'.

Processing backwards:

- Start with an empty array.

- For each command s_n to s1:

- Add the corresponding element back into the array, either on the left or on the right.

- Compute the product of the current array modulo m.

- Since we're building the array backwards, we need to store the products in reverse order and then reverse them back at the end to get the correct sequence.

Wait, but I need to make sure that when I add elements back in, I'm adding them in the positions that correspond to the removals.

Let me consider an example to see if this approach works.

Take the first example from the problem:

n = 4, m = 6

a = [3, 1, 4, 2]

s = "LRRL"

Processing forwards:

- Initial a: [3,1,4,2]

- Product: 3*1*4*2 = 24 % 6 = 0

- Remove leftmost (L): remove 3, a becomes [1,4,2]

- Product: 1*4*2 = 8 % 6 = 2

- Remove rightmost (R): remove 2, a becomes [1,4]

- Product: 1*4 = 4 % 6 = 4

- Remove rightmost (R): remove 4, a becomes [1]

- Product: 1 % 6 = 1

- Remove leftmost (L): remove 1, a becomes empty

So, the output is: 0 2 4 1

Now, let's try to simulate backwards:

Start with an empty array, product = 1

Reverse of s: "LRRL"

Process each command in reverse:

1. Command 'L' (which corresponds to the last command 'L' in the original sequence):

- Add the leftmost element of the original array that hasn't been added yet.

- In the original array, a = [3,1,4,2]

- In reverse processing, we start from the end.

Wait, I'm getting confused here.

Perhaps a better way is to use two pointers to keep track of which elements are still in the array.

Let me try to implement this idea.

Initialize two pointers, l and r, pointing to the start and end of the array.

As I process each command:

- If the command is 'L', remove the element at l and increment l.

- If the command is 'R', remove the element at r and decrement r.

At each step, calculate the product of the elements from l to r.

But calculating the product from scratch each time would be too slow for n up to 2*10^5.

I need a smarter way.

Another idea: precompute prefix and suffix products.

Let me precompute prefix products and suffix products modulo m.

Define prefix[i] = a[0] * a[1] * ... * a[i-1] % m

Define suffix[j] = a[j] * a[j+1] * ... * a[n-1] % m

Then, for a given l and r, the product of a[l] to a[r] is prefix[r] * suffix[l] / (a[l] * a[r]) % m, but again, division is tricky.

Wait, actually, in modular arithmetic, division is not straightforward unless m is prime or we have inverses.

Given that m can be any positive integer up to 10^4, I can't assume that all elements have inverses.

So, I need another approach.

Let me consider that at each step, the array is being reduced by removing either the leftmost or the rightmost element, as specified by the commands.

So, perhaps I can keep track of the current product as I remove elements, but again, removing an element would require me to divide the product by that element, which is problematic in modular arithmetic.

Another idea: since we're dealing with product modulo m, and m can be up to 10^4, but n can be up to 2*10^5, the product can be very large, but we're taking modulo m at each step.

Wait, but even with modulo m, if m is up to 10^4, and a[i] are up to 10^4, then the product can still be up to (10^4)^2 = 10^8, which is manageable in Python.

But no, with n up to 2*10^5, the product could be up to (10^4)^(2*10^5), which is way too big to handle directly. Hence, I need a smarter way.

Let me consider that in each step, I need the product of the current array modulo m.

And the array is being reduced by removing one element at a time, either from the left or the right.

So, perhaps I can keep track of the product so far, and update it as I remove elements.

But again, removing an element would require division in modular arithmetic, which is tricky.

Wait, maybe I can precompute the product of all elements, and then divide by the product of removed elements, but again, division is an issue.

Another idea: since m is up to 10^4, which is small, perhaps I can factorize m into its prime factors and handle each prime power separately, then use the Chinese Remainder Theorem to combine the results.

But this seems too complicated for this problem, and might not necessarily solve the division issue.

Let me consider that in modular arithmetic, if m is not prime, but a is invertible modulo m, then I can divide by a by multiplying by its inverse.

But not all a are invertible modulo m, so this approach has limitations.

Wait, perhaps I can handle the product incrementally, keeping track of the product modulo m, and when removing an element, if that element is coprime with m, then I can divide by it by multiplying by its inverse.

But again, this doesn't work for all cases, as some elements may not be coprime with m.

This seems too error-prone and inefficient.

Let me consider another approach.

Since the problem allows me to assume valid inputs as described in the problem description, and n can be up to 2*10^5, I need an efficient solution, preferably O(n) per test case.

Looking back at the initial idea of processing the commands in reverse, maybe I can make it work.

Let me try to simulate the reverse process.

Suppose I have an empty array, and I'm going to add elements back in, according to the reverse of the commands.

In the reverse process:

- Start with an empty array, product = 1

- For each command in reverse order:

- If the command is 'L', it means that in the forward process, we removed the leftmost element, so in the reverse process, we're adding an element to the left.

- If the command is 'R', in the forward process, we removed the rightmost element, so in reverse, we're adding an element to the right.

- At each step, I add an element back into the array, and compute the new product.

- The product at each step in the reverse process corresponds to the product just before the removal in the forward process.

Wait, but I need to output the product before removal in the forward process.

In the reverse process, I'm building up the array step by step, and the product at each step in reverse corresponds to the product after adding an element back.

This seems confusing.

Let me try to think differently.

Suppose I have a list of commands, and I know which elements are being removed in which order.

I can determine, for each step, which elements are still in the array, and compute their product modulo m.

But with n up to 2*10^5, this needs to be done efficiently.

Wait, perhaps using prefix and suffix products in a smart way.

Let me consider that the array is being reduced by removing either the leftmost or the rightmost element, according to the commands.

So, at each step, the array is a substring of the original array, either from l to r, and l and r are being adjusted based on the commands.

If I can keep track of the current l and r, and compute the product of a[l..r] modulo m, that would be ideal.

But again, computing the product from scratch each time is too slow.

Another idea: precompute the product of all subarrays using a sliding window approach.

But with n up to 2*10^5, and m up to 10^4, I need something more efficient.

Wait, perhaps I can precompute the product of all prefixes and suffixes, and then use those to compute the product of any subarray.

But as I thought earlier, combining them would require division, which is problematic in modular arithmetic.

Let me think about the properties of modular arithmetic.

If m is not prime, and I don't have inverses for all elements, division isn't straightforward.

Is there another way to handle this?

Wait, maybe I can compute the product of all elements, and keep track of the product of removed elements, and then divide the total product by the product of removed elements.

But again, division is tricky.

Another idea: since we're dealing with product modulo m, and m can be up to 10^4, perhaps I can compute the product modulo m at each step, but in a way that allows me to efficiently update the product as elements are removed.

But I don't see a clear way to do this without division.

Let me consider that in some cases, m might be composite, and I might need to handle different cases based on the factors of m.

But this seems too complicated.

Wait, perhaps I can use the fact that m is small, up to 10^4, and precompute some values related to m, like its prime factors, but I'm not sure.

This seems like a dead end.

Let me look back at the problem statement to see if I'm missing something.

"Process all n commands in the order they are written in the string s. Processing a command is done as follows:

First, output the remainder of the product of all elements of the array a when divided by m.

Then, if the command is 'L', remove the leftmost element from the array a, if the command is 'R', remove the rightmost element from the array a."

"Note that after each move, the length of the array a decreases by 1, and after processing all commands, it will be empty."

"Write a program that will process all commands in the order they are written in the string s (from left to right)."

Given that, I need to simulate the process as described.

Given the constraints, I need an efficient way to compute the product modulo m at each step.

I need to find a way to update the product efficiently as elements are removed from either end.

Wait, perhaps I can maintain two products: one for the left part and one for the right part, and combine them appropriately.

But I'm not sure.

Another idea: since the array is being reduced by removing elements from either end, perhaps the remaining array is always a subarray that can be represented by two pointers, l and r.

So, at each step, I have l and r, and the current array is a[l..r].

I need to compute the product of a[l] to a[r] modulo m.

Then, based on the command, I either remove a[l] (if 'L') or a[r] (if 'R'), and adjust l or r accordingly.

But computing the product from scratch each time is too slow.

Is there a way to update the product efficiently when removing an element?

If I could store the prefix products and suffix products, I could compute the product of a[l..r] as prefix[r+1] * suffix[l] modulo m, but this would require division, which is problematic.

Wait, perhaps I can store the prefix products and suffix products without taking modulo m, but keep them as integers, and then compute the product modulo m when needed.

But with m up to 10^4 and a[i] up to 10^4, the product can be very large, and storing prefix and suffix products without modulo m would be impractical.

This seems too memory-intensive and slow.

Let me consider that m is small, up to 10^4, and n is up to 2*10^5.

Maybe I can handle the product modulo m in a smart way.

Wait, perhaps I can handle the product in parts, considering the prime factors of m, and then use the Chinese Remainder Theorem to combine the results.

But this seems too complicated for this problem, and might not necessarily solve the division issue.

Another idea: since m is small, up to 10^4, perhaps I can compute the product modulo m directly, but in a way that allows me to remove elements efficiently.

But I don't see a clear way to do this.

Let me consider that in each step, I need to compute the product of the current array modulo m, and then remove an element.

If I can find a way to update the product when removing an element without division, that would be ideal.

Wait, perhaps I can keep track of the product and the removed elements separately, and adjust the product accordingly.

But again, without division, I'm not sure how to do this.

Let me think differently.

Suppose I collect all the commands first and see the order in which elements are removed.

Then, I can determine, for each step, which elements are still in the array, and compute their product modulo m.

But with n up to 2*10^5, this needs to be done efficiently, preferably in linear time.

Is there a way to simulate the process in O(n) time per test case?

Let me consider that the sequence of removals defines a specific order in which elements are removed.

So, I can simulate the removal process using two pointers, l and r, and keep track of which elements are removed at each step.

But again, computing the product at each step would be too slow if done naively.

Wait, perhaps I can precompute the product of all elements, and then, as I remove elements, I can keep track of the product of removed elements, and somehow adjust the current product accordingly.

But again, this would require division, which is problematic.

Another idea: since m is small, up to 10^4, perhaps I can compute the product modulo m in a way that allows me to remove factors efficiently.

But I don't see a straightforward way to do this.

Let me consider that in modular arithmetic, multiplication is associative and commutative, so the order of multiplication doesn't matter.

So, perhaps I can compute the product in any order, as long as I take the modulo m at each step.

But in this problem, the order is specified by the sequence of removals.

Wait, perhaps I can process the commands in reverse order, building up the array step by step, and keeping track of the product at each step.

Then, I can output the products in reverse order.

Let me try to formalize this.

Start with an empty array, product = 1.

Then, for each command in reverse order:

- If the command is 'L', it means that in the forward process, we removed the leftmost element, so in the reverse process, we're adding an element to the left.

- If the command is 'R', in the forward process, we removed the rightmost element, so in reverse, we're adding an element to the right.

- At each step, add the corresponding element to the array, either on the left or on the right, and update the product by multiplying the new element.

- Since we're building the array in reverse, we need to collect the products in reverse order and then reverse them to get the correct sequence.

This seems promising.

Let me try this with the first example.

n = 4, m = 6

a = [3,1,4,2]

s = "LRRL"

Reverse of s: "LRRL"

Start with an empty array, product = 1

Process 'L':

- Add 3 to the left (since 'L' means removing from the left in the forward process)

- Array becomes [3], product = 1 * 3 % 6 = 3

Process 'R':

- Add 2 to the right (since 'R' means removing from the right in the forward process)

- Array becomes [3,2], product = 3 * 2 % 6 = 6 % 6 = 0

Process 'R':

- Add 4 to the right

- Array becomes [3,2,4], product = 0 * 4 % 6 = 0

Process 'L':

- Add 1 to the left

- Array becomes [1,3,2,4], product = 0 * 1 % 6 = 0

So, the products in reverse order are: 0,0,0,3

But in the correct output, it's 0,2,4,1

This doesn't match. So, my approach is flawed.

What's wrong here?

I think I misinterpreted the reverse process.

Let me think again.

In the forward process:

- Start with [3,1,4,2]

- Output product: 3*1*4*2 = 24 % 6 = 0

- Remove 'L': remove 3, array becomes [1,4,2]

- Output product: 1*4*2 = 8 % 6 = 2

- Remove 'R': remove 2, array becomes [1,4]

- Output product: 1*4 = 4 % 6 = 4

- Remove 'R': remove 4, array becomes [1]

- Output product: 1 % 6 = 1

- Remove 'L': remove 1, array becomes empty

So, outputs are: 0,2,4,1

In the reverse process:

- Start with an empty array, product = 1

- Process 'L' (which corresponds to adding 1 to the left)

- Array becomes [1], product = 1 * 1 % 6 = 1

- Process 'R' (adding 4 to the right)

- Array becomes [1,4], product = 1 * 4 % 6 = 4

- Process 'R' (adding 2 to the right)

- Array becomes [1,4,2], product = 4 * 2 % 6 = 8 % 6 = 2

- Process 'L' (adding 3 to the left)

- Array becomes [3,1,4,2], product = 2 * 3 % 6 = 6 % 6 = 0

So, the products in reverse order are: 0,2,4,1, which matches the correct output.

Wait, in my earlier attempt, I had products in reverse order as 0,0,0,3, which didn't match, but now I see that I made a mistake in calculating the product in the reverse process.

Let me correct that.

Start with an empty array, product = 1

Process 'L': add 1 to the left, array = [1], product = 1 * 1 % 6 = 1

Process 'R': add 2 to the right, array = [1,2], product = 1 * 2 % 6 = 2

Process 'R': add 4 to the right, array = [1,2,4], product = 2 * 4 % 6 = 8 % 6 = 2

Process 'L': add 3 to the left, array = [3,1,2,4], product = 2 * 3 % 6 = 6 % 6 = 0

So, the products in reverse order are: 0,2,2,1

But the correct output is 0,2,4,1

This doesn't match. So, there's still something wrong with this approach.

Wait, perhaps I'm adding elements to the wrong sides.

Let me think again.

In the forward process:

- Start with [3,1,4,2]

- Remove 'L' (3), then 'R' (2), then 'R' (4), then 'L' (1)

In the reverse process:

- Start with an empty array

- Add 1 to the left (since the last removal was 'L', adding back to the left)

- Then add 4 to the left (since the third removal was 'R', adding back to the right)

- Then add 2 to the left (since the second removal was 'R', adding back to the right)

- Then add 3 to the left (since the first removal was 'L', adding back to the left)

Wait, this is getting confusing.

Perhaps a better way is to use two dequeues or lists to keep track of the left and right parts.

Let me try to implement this idea step by step.

Initialize two empty lists: left and right.

Then, iterate through the commands in reverse order.

For each command in reverse:

- If the command is 'L', add the corresponding element to the left list.

- If the command is 'R', add the corresponding element to the right list.

- Update the product by multiplying the new element.

- Append the current product modulo m to a list.

Then, reverse the list of products to get the correct order.

Wait, but I need to ensure that when I add elements to left or right, I'm simulating the addition back into the array correctly.

Let me try with the first example.

n = 4, m = 6

a = [3,1,4,2]

s = "LRRL"

Reverse of s: "LRRL"

Elements to add back: 1,2,4,3 (assuming original indices)

Initialize:

left = []

right = []

product = 1

Initialize a list to store products.

Process 'L' (add 1 to the left):

left = [1]

product = 1 * 1 % 6 = 1

products = [1]

Process 'R' (add 4 to the right):

right = [4]

product = 1 * 4 % 6 = 4

products = [1,4]

Process 'R' (add 2 to the right):

right = [4,2]

product = 4 * 2 % 6 = 8 % 6 = 2

products = [1,4,2]

Process 'L' (add 3 to the left):

left = [3,1]

right = [4,2]

product = 2 * 3 % 6 = 6 % 6 = 0

products = [1,4,2,0]

Then, reverse products to get [0,2,4,1], which matches the correct output.

Yes, this seems to work.

So, the approach is:

- Read t test cases.

- For each test case:

- Read n and m.

- Read the array a.

- Read the string s.

- Initialize left and right as empty lists.

- Initialize product = 1

- Initialize a list to store products.

- Iterate through the commands in reverse order:

- If the command is 'L', add the next element to the left list.

- If the command is 'R', add the next element to the right list.

- Update the product by multiplying the new element, modulo m.

- Append the product to the products list.

- Reverse the products list to get the correct order.

- Output the products separated by spaces.

This should work efficiently, as each test case is processed in O(n) time, and the total sum of n across all test cases is up to 2*10^5, which is acceptable.

Let me try this approach with another example to verify.

Take the second example from the problem:

n = 5, m = 1

a = [1,1,1,1,1]

s = "LLLLL"

Reverse of s: "LLLLL"

Elements to add back: 1,1,1,1,1

Initialize:

left = []

right = []

product = 1

products = []

Process 'L' (add 1 to the left):

left = [1]

product = 1 * 1 % 1 = 0

products = [0]

Process 'L' (add 1 to the left):

left = [1,1]

product = 0 * 1 % 1 = 0

products = [0,0]

Process 'L' (add 1 to the left):

left = [1,1,1]

product = 0 * 1 % 1 = 0

products = [0,0,0]

Process 'L' (add 1 to the left):

left = [1,1,1,1]

product = 0 * 1 % 1 = 0

products = [0,0,0,0]

Process 'L' (add 1 to the left):

left = [1,1,1,1,1]

product = 0 * 1 % 1 = 0

products = [0,0,0,0,0]

Reverse products: [0,0,0,0,0], which matches the correct output.

Good.

Another example:

n = 6, m = 8

a = [1,2,3,4,5,6]

s = "RLLLRR"

Reverse of s: "RLLLR"

Elements to add back: 6,5,4,3,2,1

Initialize:

left = []

right = []

product = 1

products = []

Process 'R' (add 6 to the right):

right = [6]

product = 1 * 6 % 8 = 6

products = [6]

Process 'L' (add 2 to the left):

left = [2]

right = [6]

product = 6 * 2 % 8 = 12 % 8 = 4

products = [6,4]

Process 'L' (add 3 to the left):

left = [3,2]

right = [6]

product = 4 * 3 % 8 = 12 % 8 = 4

products = [6,4,4]

Process 'L' (add 4 to the left):

left = [4,3,2]

right = [6]

product = 4 * 4 % 8 = 16 % 8 = 0

products = [6,4,4,0]

Process 'R' (add 5 to the right):

right = [6,5]

product = 0 * 5 % 8 = 0

products = [6,4,4,0,0]

Process 'R' (add 1 to the right):

right = [6,5,1]

product = 0 * 1 % 8 = 0

products = [6,4,4,0,0,0]

Reverse products: [0,0,0,4,4,6]

But the correct output is 0 0 0 4 4 4

Hmm, there's a discrepancy here.

Wait, perhaps I'm assigning the elements to add back incorrectly.

In the reverse process, for each command in reverse:

- If the command is 'R', add the element to the right.

- If the command is 'L', add the element to the left.

But I need to make sure that the elements are being added back in the correct order.

Wait, perhaps I need to keep track of an index to pick the elements to add back.

Let me try again.

n = 6, m = 8

a = [1,2,3,4,5,6]

s = "RLLLRR"

Reverse of s: "RLLLR"

Wait, no, s has 6 commands, so reverse should be 6 commands too.

Wait, s = "RLLLRR", reverse is "RRLLLL"

Wait, in the problem, s is of length n, and commands are processed from left to right.

In the reverse process, I need to process from right to left.

So, reverse of s is "RRLLLL"

Elements to add back: starting from the last command 'R', add a[5]=6, then 'R' add a[4]=5, etc.

So, reverse of s is "RRLLLL"

Elements to add back: a[5]=6, a[4]=5, a[3]=4, a[2]=3, a[1]=2, a[0]=1

Initialize:

left = []

right = []

product = 1

products = []

Process 'R' (add 6 to the right):

right = [6]

product = 1 * 6 % 8 = 6

products = [6]

Process 'R' (add 5 to the right):

right = [6,5]

product = 6 * 5 % 8 = 30 % 8 = 6

products = [6,6]

Process 'L' (add 2 to the left):

left = [2]

right = [6,5]

product = 6 * 2 % 8 = 12 % 8 = 4

products = [6,6,4]

Process 'L' (add 3 to the left):

left = [3,2]

right = [6,5]

product = 4 * 3 % 8 = 12 % 8 = 4

products = [6,6,4,4]

Process 'L' (add 4 to the left):

left = [4,3,2]

right = [6,5]

product = 4 * 4 % 8 = 16 % 8 = 0

products = [6,6,4,4,0]

Process 'L' (add 1 to the left):

left = [1,4,3,2]

right = [6,5]

product = 0 * 1 % 8 = 0

products = [6,6,4,4,0,0]

Then, reverse products to get [0,0,4,4,6,6], but the correct output is 0 0 0 4 4 4

This doesn't match. So, there's still an error in this approach.

Wait, perhaps I need to adjust how I'm updating the product.

Let me think differently.

Maybe I should keep track of the current product, and when adding an element back, multiply it to the product.

But in the above example, it's not giving the correct sequence.

Alternatively, perhaps I should consider the order in which elements are being added back and ensure that the product reflects the correct current array.

Wait, perhaps I need to maintain the product of the current array, which is the product of left and right lists.

But since left and right are separate, I need to compute the product of all elements in left and right.

Wait, perhaps I need to keep track of the product of left and right separately and then multiply them together.

Let me try that.

Initialize:

left_product = 1

right_product = 1

products = []

Reverse s = "RRLLLL"

Elements to add back: 6,5,4,3,2,1

Process 'R':

- Add 6 to the right

- right_product = 1 * 6 % 8 = 6

- product = left_product * right_product % 8 = 1 * 6 % 8 = 6

- products = [6]

Process 'R':

- Add 5 to the right

- right_product = 6 * 5 % 8 = 30 % 8 = 6

- product = 1 * 6 % 8 = 6

- products = [6,6]

Process 'L':

- Add 4 to the left

- left_product = 1 * 4 % 8 = 4

- product = 4 * 6 % 8 = 24 % 8 = 0

- products = [6,6,0]

Process 'L':

- Add 3 to the left

- left_product = 4 * 3 % 8 = 12 % 8 = 4

- product = 4 * 6 % 8 = 24 % 8 = 0

- products = [6,6,0,0]

Process 'L':

- Add 2 to the left

- left_product = 4 * 2 % 8 = 8 % 8 = 0

- product = 0 * 6 % 8 = 0

- products = [6,6,0,0,0]

Process 'L':

- Add 1 to the left

- left_product = 0 * 1 % 8 = 0

- product = 0 * 6 % 8 = 0

- products = [6,6,0,0,0,0]

Then, reverse products to get [0,0,0,0,6,6], but the correct output is 0 0 0 4 4 4

Still not matching.

This suggests that my approach is flawed.

Perhaps I need to consider that the product is the product of all elements in the current array, which is left + right.

But in this approach, I'm treating left and right as separate products, which might not be correct.

Wait, perhaps I need to compute the product of the concatenation of left and right.

But how to do that efficiently?

This seems complicated.

Let me consider a different approach.

Since the problem allows t up to 10^4 and n up to 2*10^5, but with the sum of n across all test cases up to 2*10^5, I need an O(n) solution per test case.

Given that, perhaps I can precompute the product of all elements, and then, as I remove elements, keep track of the product divided by the removed elements.

But again, division in modular arithmetic is tricky.

Another idea: since m is small, up to 10^4, perhaps I can compute the product modulo m, and keep track of the exponents of each prime factor in m.

Then, when removing an element, I can adjust the exponents accordingly.

But this seems too involved for this problem.

Let me consider that in the forward process, at each step, the product is the product of the current array modulo m.

So, perhaps I can simulate the forward process, keeping track of the product, but updating it appropriately when removing elements.

But again, removing elements would require division, which is problematic.

Wait, perhaps I can handle the removal of elements by keeping track of the product and the removed elements separately, and then compute the product modulo m by dividing out the removed elements.

But without division, I'm stuck.

Another idea: since m is small, I can precompute the multiplicative inverses for all elements that are coprime with m.

Then, for elements that are coprime with m, I can divide by them by multiplying by their inverses.

For elements that are not coprime with m, I need to handle them differently.

Wait, perhaps I can separate the product into parts that are coprime with m and parts that are not.

But this seems too complicated.

Let me consider that in the forward process, I can keep track of the product modulo m, and when removing an element, if that element is coprime with m, I can divide by it using its inverse; otherwise, I have to handle it differently.

But this still doesn't solve the general case.

Given the time constraints, perhaps the intended solution is to process the commands in reverse, building up the array and computing the product as we go, as I tried earlier.

Even though it didn't give the correct results in my earlier attempts, maybe I made mistakes in simulating the process.

Let me try again with the third example.

n = 6, m = 8

a = [1,2,3,4,5,6]

s = "RLLLRR"

Reverse s = "RRLLLL"

Elements to add back: 6,5,4,3,2,1

Initialize:

left = []

right = []

product = 1

products = []

Process 'R' (add 6 to the right):

right = [6]

product = 1 * 6 % 8 = 6

products = [6]

Process 'R' (add 5 to the right):

right = [6,5]

product = 6 * 5 % 8 = 30 % 8 = 6

products = [6,6]

Process 'L' (add 4 to the left):

left = [4]

right = [6,5]

product = 6 * 4 % 8 = 24 % 8 = 0

products = [6,6,0]

Process 'L' (add 3 to the left):

left = [3,4]

right = [6,5]

product = 0 * 3 % 8 = 0

products = [6,6,0,0]

Process 'L' (add 2 to the left):

left = [2,3,4]

right = [6,5]

product = 0 * 2 % 8 = 0

products = [6,6,0,0,0]

Process 'L' (add 1 to the left):

left = [1,2,3,4]

right = [6,5]

product = 0 * 1 % 8 = 0

products = [6,6,0,0,0,0]

Then, reverse products to get [0,0,0,0,6,6], but the correct output is 0 0 0 4 4 4

This still doesn't match, so there must be an error in this approach.

Perhaps I need to compute the product of left and right separately and then combine them appropriately.

Let me try to compute the product as left_product * right_product % m.

Initialize:

left_product = 1

right_product = 1

products = []

Process 'R' (add 6 to the right):

right = [6]

right_product = 1 * 6 % 8 = 6

product = left_product * right_product % 8 = 1 * 6 % 8 = 6

products = [6]

Process 'R' (add 5 to the right):

right = [6,5]

right_product = 6 * 5 % 8 = 30 % 8 = 6

product = 1 * 6 % 8 = 6

products = [6,6]

Process 'L' (add 4 to the left):

left = [4]

right = [6,5]

left_product = 1 * 4 % 8 = 4

product = 4 * 6 % 8 = 24 %