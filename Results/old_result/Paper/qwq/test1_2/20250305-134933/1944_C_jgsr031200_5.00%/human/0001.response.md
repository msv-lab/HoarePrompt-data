Alright, I have this problem to solve. It's about a game played by Alice and Bob on an array of integers. The array is of size n, and they take turns playing, with Alice starting first. The game ends when the array is empty, and the score is defined as the MEX of the array c that Alice builds. MEX is the smallest non-negative integer not present in the array.

So, Alice wants to maximize the score, and Bob wants to minimize it. Both play optimally, meaning they do the best they can to achieve their goal given the opponent is also playing optimally.

First, I need to understand the game mechanics:

1. Alice's turn: She picks an element from a, appends it to c, and deletes it from a.

2. Bob's turn: He picks an element from a, and deletes it from a.

The game alternates between them until a is empty.

The final score is the MEX of c, which is the smallest non-negative integer not in c.

My task is to find the final score if both play optimally.

Given that both play optimally, I need to model their strategies accordingly.

Let me consider some examples to get a feel for the problem.

Example 1:

Input:

3

4

0 0 1 1

4

0 1 2 3

2

1 1

Output:

2

1

0

Let's analyze the first test case:

n = 4

a = [0, 0, 1, 1]

Possible sequence of moves:

- Alice picks 1, a becomes [0, 0, 1], c = [1]

- Bob picks 0, a becomes [0, 1], c = [1]

- Alice picks 0, a becomes [1], c = [1, 0]

- Bob picks 1, a becomes empty, c = [1, 0]

MEX of c = [1, 0] is 2, which matches the sample output.

Another possible sequence:

- Alice picks 0, a becomes [0, 1, 1], c = [0]

- Bob picks 1, a becomes [0, 1], c = [0]

- Alice picks 1, a becomes [0], c = [0, 1]

- Bob picks 0, a becomes empty, c = [0, 1]

MEX is still 2.

Seems like regardless of how they play, MEX is 2.

Wait, but Bob wants to minimize the MEX, so maybe there's a way for Bob to force a lower MEX.

Let me think differently.

What determines the MEX of c? It's the smallest non-negative integer not in c.

So, to maximize MEX, Alice wants c to contain as many small non-negative integers as possible.

Bob, wanting to minimize MEX, would want to prevent Alice from picking certain numbers.

Given that Alice can pick any number from a and append it to c, while Bob can only delete a number from a.

Wait, no: Bob also picks a number from a and deletes it.

So, in each turn:

- Alice picks a number from a, appends it to c, and deletes it from a.

- Bob picks a number from a, deletes it from a.

So, in total, in each full turn (Alice and Bob), two elements are removed from a.

Eventually, when a is empty, c contains some elements that Alice has chosen.

The question is: what is the MEX of c when both play optimally.

Given that, I need to model their strategies.

Let me consider that the game is about selecting elements for c in a way that affects the MEX.

I need to consider that Alice wants to maximize MEX, which might not be intuitive at first.

Wait, actually, to maximize MEX, Alice wants c to have as many small non-negative integers as possible.

Wait, no: to maximize MEX, Alice wants c to have all integers from 0 to k-1, where k is the MEX.

So, higher k means c has all integers from 0 to k-1.

Alice wants the highest possible k, Bob wants the lowest possible k.

Given that, I need to see how their moves affect the composition of c.

But, Bob can interfere by removing elements from a, making them unavailable for Alice to pick.

I need to model this game to find the optimal outcome.

This seems complex. Maybe I can think in terms of the frequency of each number in a.

Let me consider the frequency of each number in a.

Letâ€™s sort the numbers and see their frequencies.

Suppose I have counts of each number.

I need to see how Alice and Bob's moves affect the counts.

Wait, perhaps I can think in terms of who has the controlling move.

But it's not immediately clear.

Let me consider the total number of moves.

Each full turn consists of Alice and Bob each making a move, provided a has at least one element.

So, for n elements, there will be floor(n/2) full turns, and if n is odd, an extra move by Alice.

In each full turn:

- Alice picks an element for c and removes it from a.

- Bob picks an element to remove from a.

So, in each full turn, one element goes to c, and one is removed from a.

After floor(n/2) full turns, if n is odd, Alice makes one more move, adding one more element to c.

So, the total number of elements in c at the end is ceil(n/2).

Wait, let's see:

- For each full turn: Alice adds one to c, Bob removes one from a.

- If n is odd, there's an extra move by Alice, adding one more to c.

So, total elements in c: ceil(n/2).

But, the specific elements in c depend on their choices.

Alice wants to maximize MEX of c, which is the smallest missing integer in c.

Bob wants to minimize it.

So, Bob will try to prevent Alice from having certain numbers in c.

Wait, but Bob can only choose which elements to remove from a, not directly from c.

Wait, no: Bob picks an element from a and deletes it from a.

So, Bob can remove elements from a, making them unavailable for Alice to pick.

Alice, on her turn, picks an element from a, appends it to c, and deletes it from a.

So, Bob can remove elements that Alice might want, thereby forcing her to pick other elements.

This interaction is key.

I need to model this interaction to find the optimal MEX.

This seems like a game theory problem where both players have strategic choices.

I need to find a way to compute the optimal MEX given that both play optimally.

Let me consider a simpler case.

Suppose a contains only 0s and 1s.

For example, a = [0, 0, 1, 1], as in the first sample.

Total elements: 4.

Number of elements in c: ceil(4/2) = 2.

So, c will have 2 elements.

Possible c:

- [0, 0]

- [0, 1]

- [1, 1]

MEX:

- [0, 0]: MEX is 1

- [0, 1]: MEX is 2

- [1, 1]: MEX is 0

Alice wants to maximize MEX, so she would aim for MEX=2.

Bob wants to minimize MEX, so he would try to prevent that.

In the sample, the output is 2, meaning Alice succeeds in getting MEX=2.

How?

Alice can pick one 0 and one 1, resulting in c=[0,1], MEX=2.

Bob cannot prevent this if Alice plays optimally.

In the second sample:

n=4

a=[0,1,2,3]

Possible c with ceil(4/2)=2 elements.

Possible c:

- [0,1]

- [0,2]

- [0,3]

- [1,2]

- [1,3]

- [2,3]

MEX:

- [0,1]: MEX=2

- [0,2]: MEX=1

- [0,3]: MEX=1

- [1,2]: MEX=0

- [1,3]: MEX=0

- [2,3]: MEX=0

Alice wants to maximize MEX, so she would choose [0,1] with MEX=2.

But the output is 1.

Wait, that doesn't match.

Wait, perhaps I'm misunderstanding.

Wait, in the second sample, output is 1.

Wait, perhaps Alice cannot always get MEX=2.

Wait, maybe in this case, Bob can interfere.

Let me think step by step.

n=4

a=[0,1,2,3]

First move: Alice picks, say, 0, appends to c=[0], removes 0 from a, which becomes [1,2,3]

Bob's turn: He picks, say, 1, removes it from a, a becomes [2,3]

Alice's turn: Picks 2, appends to c=[0,2], removes 2 from a, a becomes [3]

Bob's turn: Picks 3, removes it, a becomes empty

c=[0,2], MEX=1

Alternatively, if Alice picks 1 first:

Alice picks 1, c=[1], a=[0,2,3]

Bob picks 0, removes it, a=[2,3]

Alice picks 2, c=[1,2], a=[3]

Bob picks 3, removes it, a empty

c=[1,2], MEX=0

Another scenario:

Alice picks 2 first:

c=[2], a=[0,1,3]

Bob picks 1, a=[0,3]

Alice picks 0, c=[2,0], a=[3]

Bob picks 3, a empty

c=[2,0], MEX=1

Another scenario:

Alice picks 3 first:

c=[3], a=[0,1,2]

Bob picks 1, a=[0,2]

Alice picks 0, c=[3,0], a=[2]

Bob picks 2, a empty

c=[3,0], MEX=1

So, in all these scenarios, the MEX is either 0 or 1.

The sample output is 1, which is higher than 0.

So, perhaps 1 is the best possible MEX that Alice can achieve against Bob's optimal play.

Wait, but in one scenario, c=[1,2], MEX=0.

So, Bob can force MEX=0 by choosing certain elements.

But the sample output is 1, so perhaps there's a better strategy for Alice.

Wait, maybe I missed something.

Wait, perhaps the game ends when a is empty, and c has ceil(n/2) elements.

In this case, ceil(4/2)=2, so c has 2 elements.

In all possible combinations, the possible MEX values are 0 or 1.

So, perhaps the minimal possible MEX that Alice can achieve, given Bob's interference, is 1.

Hence, the output is 1.

In the third sample:

n=2

a=[1,1]

First move: Alice picks 1, c=[1], a=[1]

Bob picks 1, removes it, a empty

c=[1], MEX=0

Hence, output is 0.

So, in this case, Alice can only achieve MEX=0.

Given that, I need to generalize this logic.

I need to find, given the frequencies of numbers in a, and the turns, what is the optimal MEX that Alice can achieve.

This seems tricky.

Let me think about the frequencies.

Suppose I have counts of each number.

For example, in the first sample:

n=4

a=[0,0,1,1]

counts:

0:2

1:2

In the second sample:

n=4

a=[0,1,2,3]

counts:

0:1

1:1

2:1

3:1

In the third sample:

n=2

a=[1,1]

counts:

1:2

Now, I need to see how Alice and Bob's moves affect the counts.

Alice wants to maximize MEX, which means she wants to have as many small integers in c as possible.

Bob wants to minimize MEX, meaning he wants to prevent Alice from having small integers in c.

Given that, Bob will try to remove elements that Alice wants, or perhaps manipulate the counts in a way that limits Alice's choices.

This seems like a zero-sum game, and perhaps can be modeled using game theory concepts.

I need to find a way to compute the optimal MEX.

Let me consider that the game is about selecting elements for c, with Alice trying to include as many small integers as possible, and Bob trying to prevent that.

Given that, perhaps I can model it as a selection process where Alice and Bob have opposing goals.

I need to find a way to compute the minimal MEX that Alice can achieve, given Bob's interference.

Wait, no: Alice wants to maximize MEX, Bob wants to minimize it.

Wait, actually, the problem is to find the final score if both play optimally.

Given that, I need to find the MEX that results when both play optimally.

Given that Alice starts and both play optimally, I need to find the equilibrium MEX.

This is getting complicated.

Let me consider a different approach.

Suppose I sort the array a in ascending order.

Then, I can try to build c in a way that maximizes the MEX.

But Bob is interfering by removing elements.

I need to consider their moves carefully.

Wait, perhaps I can think in terms of the number of times each number appears in a.

For example, if a number x appears cnt[x] times in a, then Alice can potentially pick it up to cnt[x] times, but Bob can also remove it.

I need to model how many times Alice can include each number in c.

Given that, perhaps for each number x, I can compute how many times it can be included in c, considering Bob's removals.

Then, I can see what MEX c can achieve.

This seems promising.

Let me formalize this.

Let cnt[x] be the frequency of x in a.

Both Alice and Bob can choose to pick x from a.

Alice picks x and adds it to c, while Bob just picks x and removes it.

So, for each x, the number of times it ends up in c is the number of times Alice picks it minus the number of times Bob picks it.

Wait, no: once an element is picked by either player, it's removed from a.

So, for each x, the number of times it can be picked is cnt[x].

Each time Alice picks x, it's added to c; each time Bob picks x, it's just removed.

So, for each x, the number of times it ends up in c is the number of times Alice picks it.

But Bob can choose to remove x, reducing cnt[x].

So, for each x, the number of times Alice can pick it is the initial cnt[x] minus the number of times Bob picks it.

But Bob can choose to pick x or other elements.

This seems too vague.

Let me consider pairing Alice's picks and Bob's picks.

In each full turn (Alice and Bob), Alice picks one element for c, and Bob picks one element to remove.

So, in each full turn, one element is added to c, and one is removed.

If n is even, there are n/2 full turns, and c has n/2 elements.

If n is odd, there are floor(n/2) full turns and one extra move by Alice, so c has ceil(n/2) elements.

Given that, I can think of the game as Alice selecting ceil(n/2) elements from a, and Bob trying to influence which elements Alice can select.

Wait, but Bob can remove elements that Alice might want, making them unavailable.

This is still tricky.

Let me consider that the game is equivalent to Alice selecting ceil(n/2) elements from a, with Bob trying to minimize the MEX of c.

But it's not exactly that, because Bob can remove elements that Alice might pick.

Wait, perhaps I can model it as Alice selecting a subset of size ceil(n/2) from a, and Bob trying to minimize the MEX of that subset.

But that's not accurate, because Bob can remove elements, affecting which elements Alice can pick.

This is getting too convoluted.

Let me try to think differently.

Suppose I sort the array a in ascending order.

Then, I can try to build c in a way that includes as many small numbers as possible.

But Bob can interfere by removing elements that Alice wants.

I need to find a way to maximize the MEX, considering Bob's interference.

Wait, maybe I can iterate through the numbers starting from 0 and check if Alice can include them in c.

For each number x, I can check if Alice can ensure that x is in c, despite Bob's removals.

If Alice can ensure that x is in c, then MEX will be greater than x.

Otherwise, MEX is x.

So, I need to find the smallest x such that Alice cannot ensure x is in c.

This seems like a minimax problem.

Let me formalize this.

Define that the MEX is k if all numbers from 0 to k-1 are in c, and k is not in c.

Alice wants k to be as large as possible, Bob wants it to be as small as possible.

So, the game is about selecting a subset c of size ceil(n/2) from a, with Bob trying to minimize the MEX of c.

I need to find the MEX when both play optimally.

This is similar to a game where Alice is trying to collect as many small numbers as possible, and Bob is trying to prevent her from doing so.

Given that, perhaps I can model it as a selection process where Alice and Bob take turns picking elements, with Bob having the power to remove elements that Alice might want.

This seems too vague.

Let me consider the following approach:

- Sort the array a in ascending order.

- For each number x starting from 0, check if Alice can ensure that x is included in c.

- If she can, then MEX is greater than x; otherwise, MEX is x.

So, I need to find the smallest x such that Alice cannot include x in c, no matter how she plays, given Bob's optimal play.

Wait, actually, since Alice wants to maximize MEX, she wants to include as many small numbers as possible.

Bob wants to minimize MEX, so he wants to prevent Alice from including some small numbers.

So, for each x, I need to see if Alice can include x in c, despite Bob's removals.

If for some x, Alice cannot include x in c, then that x is the MEX.

So, I need to find the smallest x where Alice cannot include x in c.

To do that, I need to compute, for each x, the maximum number of times Alice can include x in c, given Bob's removals.

If for some x, Alice cannot include at least one instance of x in c, then MEX is x.

So, I need to compute, for each x, the number of times Alice can include x in c.

Given that, perhaps I can compute, for each x, the number of times Alice can pick x, considering Bob's removals.

Let me formalize this.

Let cnt[x] be the frequency of x in a.

Letâ€™s consider that Alice and Bob take turns picking elements.

Alice picks an element and adds it to c, Bob picks an element and removes it.

I need to see how many times Alice can include x in c.

Wait, perhaps I can think in terms of the number of times x appears in a and how Bob can remove them.

Suppose cnt[x] is the frequency of x.

Alice wants to include as many x as possible in c, but Bob can remove some of them.

Each time Alice picks x, it goes to c; each time Bob picks x, it's removed from a.

So, for each x, the number of times Alice can include x in c is cnt[x] minus the number of times Bob picks x.

But Bob will try to minimize the number of x in c, so he will pick x as much as possible to remove it.

So, Bob will pick x as much as possible to prevent Alice from including it in c.

Therefore, the number of times Alice can include x in c is cnt[x] minus the number of times Bob picks x.

But Bob can pick up to floor(n/2) times (since he moves after Alice in each full turn).

Wait, no: total moves are n, Alice moves ceil(n/2) times, Bob moves floor(n/2) times.

So, Bob can pick up to floor(n/2) elements.

But he wants to minimize the number of x in c.

So, for each x, the number of times Alice can include x in c is cnt[x] minus the number of times Bob picks x.

But Bob will pick x as much as possible to reduce cnt[x].

So, the minimal number of x in c is cnt[x] - min(cnt[x], floor(n/2)).

Wait, no: Bob can pick up to floor(n/2) elements, but he might choose to pick other elements.

He wants to minimize the number of x in c.

So, he will pick x as much as possible to reduce cnt[x].

Therefore, the number of times Alice can include x in c is cnt[x] - the number of times Bob picks x.

But Bob will pick x min(cnt[x], floor(n/2)) times.

Wait, but he might not be able to pick x that many times if cnt[x] is less.

So, the number of times Bob can pick x is min(cnt[x], floor(n/2)).

Therefore, the number of times Alice can include x in c is cnt[x] - min(cnt[x], floor(n/2)).

So, for each x, Alice can include max(cnt[x] - min(cnt[x], floor(n/2)), 0) times.

Wait, but this seems off.

Let me think differently.

Total elements to be picked by Alice: ceil(n/2).

Total elements to be picked by Bob: floor(n/2).

So, Alice picks ceil(n/2) elements, Bob picks floor(n/2).

So, for each x, the number of times Alice can pick x is cnt[x] - the number of times Bob picks x.

But Bob will pick x as much as possible to minimize the number of x in c.

So, Bob will pick x min(cnt[x], floor(n/2)) times.

Therefore, the number of times Alice can pick x is cnt[x] - min(cnt[x], floor(n/2)).

So, for each x, Alice can include max(cnt[x] - min(cnt[x], floor(n/2)), 0) elements in c.

Now, for each x, to have at least one in c, we need that max(cnt[x] - min(cnt[x], floor(n/2)), 0) >=1.

Wait, but this seems too simplistic.

Let me verify with the first sample.

n=4, ceil(n/2)=2, floor(n/2)=2.

x=0: cnt[0]=2, min(cnt[0], floor(n/2))=2, so Alice can include max(2-2,0)=0.

But in reality, Alice can include 1 or 2 elements of 0 in c.

Wait, this contradicts.

So, perhaps my earlier assumption is wrong.

Let me think differently.

Letâ€™s consider that Alice picks ceil(n/2) elements, and Bob picks floor(n/2) elements.

So, the total elements picked are n.

Alice chooses which elements go into c.

Bob chooses which elements to remove.

Wait, no: Bob removes elements from a, but Alice chooses which elements to include in c from the remaining a.

This is getting too tangled.

Let me consider that the game is equivalent to Alice selecting ceil(n/2) elements from a, with Bob trying to minimize the MEX of c.

So, I need to find the minimal MEX that Alice can achieve, given that Bob is trying to minimize it.

This seems like a game where Alice is trying to maximize MEX, and Bob is trying to minimize it.

Given that, I need to find the equilibrium MEX where neither can do better.

This is similar to finding the minimal MEX that Alice can guarantee, given Bob's interference.

To model this, perhaps I can iterate through possible MEX values and check if Alice can achieve a MEX greater than or equal to k.

Then, find the maximal k where Alice can achieve MEX >=k.

Alternatively, find the minimal k where Bob can prevent Alice from achieving MEX >=k.

This seems promising.

Let me formalize this.

Define that the MEX is k if all numbers from 0 to k-1 are in c, and k is not in c.

Alice wants to maximize k, Bob wants to minimize it.

So, for each k, I can check if Alice can ensure that all numbers from 0 to k-1 are in c.

If she can, then MEX >=k.

Otherwise, MEX <k.

So, I need to find the smallest k where Alice cannot ensure that all numbers from 0 to k-1 are in c.

This is essentially finding the minimal k where Bob can prevent Alice from having all numbers from 0 to k-1 in c.

To check if Alice can have all numbers from 0 to k-1 in c, I need to see if, for each x in 0 to k-1, Alice can include at least one x in c.

Given that, perhaps I can compute, for each x, the minimal number of times Alice can include x in c, considering Bob's removals.

Then, check if for all x in 0 to k-1, this minimal number is at least 1.

If so, then Alice can achieve MEX >=k.

Otherwise, not.

So, I need to compute, for each x, the minimal number of times Alice can include x in c.

Given that, perhaps I can model it as a game where Alice selects elements to include in c, and Bob selects elements to remove from a.

I need to find a way to compute, for each x, how many times Alice can include x in c, considering Bob's removals.

This seems too abstract.

Let me consider a different approach.

Suppose I sort the numbers in a in ascending order.

Then, I can try to build c in a way that includes as many small numbers as possible.

But Bob can interfere by removing elements that Alice wants.

So, perhaps I can iterate through the numbers in ascending order and try to include them in c.

For each number x, I can check if Alice can include at least one x in c.

If she can, then MEX is greater than x; otherwise, it's x.

So, I need to find the smallest x where Alice cannot include x in c.

To do that, I need to see how Bob can prevent Alice from including x in c.

Given that, perhaps I can compute the number of times x appears in a and how many times Bob can remove them.

Wait, perhaps I can think in terms of the number of times Alice can pick x before Bob removes all instances of x.

Let me formalize this.

Let cnt[x] be the frequency of x in a.

Bob can pick floor(n/2) elements to remove.

He wants to minimize the number of x in c, so he will try to remove x as much as possible.

Therefore, the number of x that Alice can include in c is cnt[x] - the number of times Bob removes x.

But Bob will remove x min(cnt[x], floor(n/2)) times.

So, the number of x that Alice can include is cnt[x] - min(cnt[x], floor(n/2)).

If this is greater than or equal to 1, then Alice can include at least one x in c.

Otherwise, she cannot.

So, for each x, if cnt[x] - min(cnt[x], floor(n/2)) >=1, then Alice can include x in c.

Otherwise, she cannot.

Therefore, the MEX is the smallest x where cnt[x] - min(cnt[x], floor(n/2)) <1.

Wait, but in the first sample:

n=4, floor(n/2)=2

x=0: cnt[0]=2, 2 - min(2,2)=0 <1, so MEX=0?

But in the sample, MEX=2.

This contradicts.

So, my earlier assumption is wrong.

Hence, perhaps this approach is incorrect.

Let me think differently.

Letâ€™s consider that Alice picks ceil(n/2) elements to include in c, and Bob picks floor(n/2) elements to remove from a.

So, the elements in c are those picked by Alice.

Bob can choose to remove any elements from a, including those that Alice wants.

So, Bob can strategically remove elements that Alice wants to include in c.

Therefore, Alice needs to ensure that she can include certain elements despite Bob's removals.

This seems like a selection game where Alice wants to select a subset with certain properties, and Bob is trying to make it difficult.

Given that, perhaps I can model it using the idea of available moves and required selections.

Wait, maybe I can think in terms of the number of times each number appears and how many times Alice can pick them before Bob removes them.

Let me consider that for each number x, the number of times Alice can include x in c is cnt[x] - the number of times Bob removes x.

Bob will try to minimize the number of x in c, so he will remove x as much as possible.

Therefore, the minimal number of x in c is cnt[x] - the number of times Bob removes x.

But Bob can remove up to floor(n/2) elements in total.

He wants to distribute his removals to minimize the number of x in c for small x.

So, to minimize MEX, Bob should prioritize removing elements that Alice wants, i.e., small x.

Wait, but Bob can only remove elements from a, not directly from c.

But by removing elements from a, he affects what Alice can pick.

So, for each x, the number of times Alice can pick x is cnt[x] minus the number of times Bob removes x.

But Bob can remove up to floor(n/2) elements, and he will try to remove elements that Alice wants, i.e., small x.

Therefore, for each x, the number of times Alice can pick x is cnt[x] minus the number of times Bob removes x.

But Bob will allocate his removals to minimize the number of x in c.

This seems too vague to compute directly.

Let me consider a greedy approach.

Suppose I sort the numbers in a in ascending order.

Then, I can try to include as many small numbers as possible in c.

But Bob can interfere by removing elements that Alice wants.

So, perhaps I can iterate through x from 0 to max(a), and for each x, check if Alice can include at least one x in c.

If she can, then MEX is greater than x; otherwise, it's x.

To check if Alice can include at least one x in c, I need to see if, after Bob removes floor(n/2) elements, there is at least one x left that Alice can pick.

Wait, but Bob removes floor(n/2) elements, and Alice picks ceil(n/2) elements.

But Alice picks first, then Bob, alternately.

So, it's not exactly that Bob removes floor(n/2) elements; it's that Bob makes floor(n/2) moves, each time removing one element.

Similarly, Alice makes ceil(n/2) moves, each time picking one element for c and removing it.

So, in total, ceil(n/2) + floor(n/2) = n elements are removed.

But Alice decides which elements go into c.

Wait, no: Alice picks an element, adds it to c, and removes it from a.

Bob picks an element and removes it from a.

So, in each full turn (Alice and Bob), two elements are removed: one goes to c, one is removed.

If n is odd, Alice has one extra move, adding one more element to c.

So, total elements in c: ceil(n/2).

Now, to maximize MEX, Alice wants c to contain as many small integers as possible.

Bob wants to minimize MEX, so he wants to prevent Alice from having small integers in c.

Given that, perhaps I can model this as a game where Alice tries to collect small integers, and Bob tries to deny her access to them.

I need to find a way to compute the minimal MEX that Alice can achieve, given Bob's interference.

This seems too abstract.

Let me consider that the game is equivalent to Alice selecting ceil(n/2) elements from a, with Bob trying to minimize the MEX of those selected elements.

So, I need to find the minimal MEX that Alice can achieve, considering Bob's removals.

Wait, perhaps I can think in terms of the number of times each x appears in a and how many times Bob can remove them.

Let me consider that for each x, the number of times Alice can include x in c is cnt[x] minus the number of times Bob removes x.

But Bob will try to minimize the number of x in c, so he will remove x as much as possible.

Given that, for each x, the number of times Alice can include x in c is cnt[x] minus the number of times Bob removes x.

But Bob has floor(n/2) moves to remove elements.

He will allocate his removals to minimize the number of x in c for small x.

This seems too vague to compute directly.

Let me consider that Bob will remove the elements that Alice wants the most, i.e., small x.

So, for each x, the number of times Alice can include x in c is cnt[x] minus the number of times Bob removes x.

But Bob will prioritize removing small x to minimize MEX.

Therefore, Bob will allocate his floor(n/2) removals to minimize the number of small x in c.

This is still too vague.

Let me try to think differently.

Suppose I iterate through x from 0 to max(a), and for each x, check if Alice can include at least one x in c, given Bob's optimal removals.

If she can, then MEX is greater than x; otherwise, it's x.

So, for each x, I need to see if Alice can ensure that at least one x is included in c, despite Bob's removals.

To do that, I need to see if the number of x in a is greater than the number of times Bob can remove them.

Specifically, if cnt[x] > floor(n/2), then Alice can include at least one x in c, because even if Bob removes floor(n/2) elements, there will still be some x left for Alice to pick.

If cnt[x] <= floor(n/2), then Bob can potentially remove all x, making it impossible for Alice to include x in c.

Wait, but this isn't entirely accurate.

Because Alice gets to pick ceil(n/2) elements.

So, if cnt[x] > floor(n/2), then Alice can include at least one x in c, because Bob can only remove floor(n/2) elements.

Wait, but this seems similar to what I thought earlier.

Wait, no: Bob removes floor(n/2) elements, but Alice picks ceil(n/2) elements.

Wait, actually, total elements removed are n: ceil(n/2) by Alice and floor(n/2) by Bob.

Wait, no: Alice picks ceil(n/2) elements for c and removes them from a; Bob picks floor(n/2) elements and removes them from a.

So, total elements removed are ceil(n/2) + floor(n/2) = n.

So, for each x, the number of times it can be picked by Alice is cnt[x] minus the number of times Bob removes it.

But Bob can remove up to floor(n/2) elements.

He will try to remove x as much as possible to prevent Alice from including it in c.

Therefore, the number of x that Alice can include in c is cnt[x] - the number of times Bob removes x.

But Bob will allocate his floor(n/2) removals to minimize the number of x in c for small x.

So, for x from 0 to k-1, Bob will try to remove as many x as possible.

Therefore, for each x, the number of x that Alice can include is cnt[x] - the number of times Bob removes x.

But this is too vague.

Let me consider that Bob can remove up to floor(n/2) elements, and he will prioritize removing elements that Alice wants, i.e., small x.

Therefore, for each x from 0 to k-1, Alice needs to have at least one x in c.

To have at least one x in c, cnt[x] - number of times Bob removes x >=1.

But Bob will try to make cnt[x] - number of times he removes x as small as possible.

Wait, perhaps I can model this as an allocation game.

Let me consider that Alice needs to have at least one of each x from 0 to k-1 in c.

Bob needs to prevent that.

So, for a given k, I can check if Alice can have all x from 0 to k-1 in c, despite Bob's removals.

To do that, I need to see if, after Bob removes floor(n/2) elements, there are still at least one of each x from 0 to k-1 remaining in a, which Alice can pick for c.

Wait, but Alice picks ceil(n/2) elements, and Bob picks floor(n/2) elements.

So, perhaps I can think in terms of the remaining elements after Bob's removals.

But this seems too convoluted.

Let me consider that the minimal MEX is the smallest x where cnt[0..x] <= floor(n/2).

Wait, perhaps not.

Wait, in the first sample:

n=4, floor(n/2)=2

cnt[0]=2, cnt[1]=2

For x=0: cnt[0]=2 > floor(n/2)=2? No, cnt[0]=2 == floor(n/2)=2.

So, cnt[0] - floor(n/2)=0.

So, Alice cannot include 0 in c.

But in reality, she can.

Wait, but according to earlier logic, cnt[0] - floor(n/2)=0, which is not >=1.

But in reality, she can include 0 in c.

So, this contradicts.

Hence, my earlier assumption is wrong.

Wait, perhaps I need to consider that Alice picks first.

So, she can pick one element, then Bob removes one, and so on.

So, perhaps Alice can pick one 0 and one 1, while Bob removes one 0 and one 1.

Then, c=[0,1], MEX=2.

But according to my earlier logic, cnt[0] - floor(n/2)=0, which is not >=1, so Alice cannot include 0.

But in reality, she can.

Hence, my earlier assumption is incorrect.

So, perhaps I need to think differently.

Let me consider that Alice can include x in c if cnt[x] > 0, and she picks it before Bob removes all instances of x.

So, for each x, Alice can include at least one x in c if she picks it before Bob removes all cnt[x] elements.

Given that, perhaps I can sort the numbers in a in ascending order and try to include as many small x as possible.

But Bob can remove elements to prevent Alice from including certain x.

This seems too vague.

Let me consider that Alice can include x in c if cnt[x] > number of times Bob removes x.

Bob will try to minimize the number of x in c, so he will remove x as much as possible.

Therefore, for each x, the number of times Alice can include x in c is cnt[x] - the number of times Bob removes x.

But Bob has floor(n/2) removals to allocate.

He will allocate his removals to minimize the number of small x in c.

Therefore, he will remove as many small x as possible.

So, for each x from 0 to k-1, the number of times Bob removes x is min(cnt[x], floor(n/2)).

But he has to distribute his floor(n/2) removals among all x.

This seems too vague to compute directly.

Let me consider that Bob can remove up to floor(n/2) elements, and he will remove elements that maximize the number of small x removed.

Therefore, he will remove as many small x as possible.

So, for each x from 0 to k-1, if cnt[x] <= number of removals Bob allocates to x, then Alice cannot include x in c.

Otherwise, she can.

So, for a given k, if for all x from 0 to k-1, cnt[x] > removals allocated to x, then Alice can include all x from 0 to k-1 in c.

Otherwise, she cannot.

Bob will try to allocate his removals to minimize k.

This seems like a minimax problem.

To solve this, perhaps I can iterate k from 0 upwards and find the smallest k where Bob can prevent Alice from including all x from 0 to k-1 in c.

To do that, I need to compute the total removals Bob needs to allocate to prevent Alice from including at least one of each x from 0 to k-1.

So, for each x from 0 to k-1, Bob needs to remove cnt[x] elements to prevent Alice from including any x in c.

But if cnt[x] <= removals allocated to x, then Alice cannot include x in c.

Bob has floor(n/2) removals to allocate among all x.

So, to prevent Alice from including all x from 0 to k-1, Bob needs to allocate removals such that for at least one x in 0 to k-1, removals allocated to x >= cnt[x].

Therefore, the minimal k where this is possible is the MEX.

So, I need to find the smallest k where sum_{x=0}^{k-1} cnt[x] <= floor(n/2).

Because if sum_{x=0}^{k-1} cnt[x] <= floor(n/2), then Bob can allocate his floor(n/2) removals to remove all x from 0 to k-1, preventing Alice from including any of them in c.

Hence, MEX would be k.

Wait, but in the first sample:

n=4, floor(n/2)=2

cnt[0]=2, cnt[1]=2

sum_{x=0}^{0} cnt[x]=2 <=2, so k=1.

But the sample output is 2.

Wait, that doesn't match.

Wait, perhaps I have a mistake.

Wait, sum_{x=0}^{0} cnt[x]=2 <= floor(n/2)=2, so k=1.

But the MEX in the sample is 2.

So, according to this, MEX would be 1, but it's 2.

Hence, my assumption is incorrect.

So, perhaps the condition is different.

Let me think differently.

Suppose I sort the numbers in a in ascending order.

Then, I can try to include as many small numbers as possible in c.

But Bob can remove elements to prevent that.

So, perhaps I can iterate through x from 0 to max(a), and for each x, check if Alice can include at least one x in c.

To check that, I need to see if, after Bob removes floor(n/2) elements, there is at least one x left for Alice to pick.

But this seems similar to what I thought earlier.

Wait, perhaps I need to consider the order of selections.

Let me consider that Alice picks first, then Bob, alternately, until a is empty.

So, in each full turn, Alice picks one element for c and removes it; Bob picks one element and removes it.

So, in each full turn, two elements are removed: one goes to c, one is removed.

If n is odd, Alice has one extra move.

So, total elements in c: ceil(n/2).

Now, to maximize MEX, Alice wants c to contain as many small numbers as possible.

Bob wants to minimize MEX, so he wants to prevent Alice from including small numbers in c.

Given that, perhaps I can model this as a game where Alice tries to collect small numbers, and Bob tries to deny her access to them.

This seems too abstract.

Let me consider that the game is equivalent to Alice selecting ceil(n/2) elements from a, with Bob trying to minimize the MEX of those selected elements.

So, I need to find the minimal MEX that Alice can achieve, given Bob's interference.

This seems similar to a game where Alice is trying to maximize the MEX, and Bob is trying to minimize it.

Given that, perhaps I can use