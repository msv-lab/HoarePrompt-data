Alright, I've got this problem here. Let's see what it's asking for. So, there are n disks in a plane, each with integer coordinates for centers and positive integer radii. The key points are:

1. No two disks overlap in a region of positive area, but they can be tangent to each other.

2. I need to determine if it's possible to change the radii of these disks such that:

   a. Disks that were tangent remain tangent.

   b. No two disks overlap in a region of positive area.

   c. The sum of all radii strictly decreases.

And the new radii can be any positive real numbers, not necessarily integers, and the centers stay fixed.

First, I need to understand what it means for disks to be tangent. If two disks are tangent, it means they touch at exactly one point. So, the distance between their centers is equal to the sum of their radii.

So, if two disks are tangent, their radii must adjust in such a way that they still touch at exactly one point after the change. That means the sum of their new radii should still equal the distance between their centers.

On the other hand, disks that were not tangent before should not overlap after the change, meaning the sum of their new radii should be less than or equal to the distance between their centers.

Additionally, the sum of all radii should strictly decrease.

I need to find out if such a set of new radii exists.

Let me think about this in terms of constraints.

Let's denote the original radii as r1, r2, ..., rn.

The new radii will be r1', r2', ..., rn'.

Constraints:

1. For tangent disks i and j: r_i' + r_j' = distance between centers of i and j.

2. For non-tangent disks i and j: r_i' + r_j' ≤ distance between centers of i and j.

3. Sum of r1' + r2' + ... + rn' < sum of r1 + r2 + ... + rn.

My goal is to find r1', r2', ..., rn' that satisfy all these conditions.

First, I need to model the relationships between the radii based on the tangency.

Let's consider the disks and their tangencies as a graph, where disks are nodes, and tangencies are edges.

In this graph, the edges represent equality constraints on the sum of radii.

For example, if disks i and j are tangent, then r_i' + r_j' = d_ij, where d_ij is the distance between centers i and j.

For non-tangent disks, there's an inequality: r_i' + r_j' ≤ d_ij.

But inequalities are trickier to handle than equalities.

I need to find a way to handle both the equality constraints and the inequality constraints, while also ensuring that the sum of radii decreases.

This seems like a system of linear equations and inequalities.

One approach could be to use linear programming to minimize the sum of radii while satisfying the constraints, but that might be too slow for n up to 1000.

Is there a smarter way to approach this?

Let me think about the equality constraints first.

If two disks are tangent, their radii are linked by an equality: r_i' + r_j' = d_ij.

If there are multiple tangencies, these equalities might form connected components where the radii are related through a system of equations.

Within a connected component defined by tangencies, the radii are interdependent.

Let's consider one connected component.

Suppose I have a connected component of k disks, with tangency relationships forming a graph.

In this graph, each edge represents an equality r_i' + r_j' = d_ij.

This system of equations can be represented in matrix form.

Let’s say I have variables r1', r2', ..., rk'.

Each equality r_i' + r_j' = d_ij can be written as r_i' + r_j' - d_ij = 0.

This is a system of linear equations.

The number of equations is equal to the number of tangencies in the component.

The number of variables is k.

In general, such a system might have a unique solution, no solution, or infinitely many solutions, depending on the ranks of the coefficient matrix and the augmented matrix.

But in this case, since the disks are positioned such that no two overlap in positive area, the system should be consistent.

Assuming the system is consistent, it will have a solution.

If there are more variables than equations, there will be free variables, and the system will have infinitely many solutions.

In such a case, I can choose some radii freely within certain bounds, subject to the equality constraints.

But I also have the inequality constraints for non-tangent disks: r_i' + r_j' ≤ d_ij.

These inequalities need to hold for pairs of disks that are not tangent.

Additionally, I need to ensure that all radii are positive real numbers.

Given the complexity of handling all these constraints directly, perhaps there's a smarter way to approach this problem.

Let me consider the dual graph of the disks based on tangencies.

Each disk is a node, and an edge exists between two nodes if their disks are tangent.

This graph can have multiple connected components.

Within each connected component, the equality constraints link the radii together.

I can fix one radius in each component and solve for the others.

For example, in a connected component with k disks, I can choose one disk as a reference and express all other radii in terms of this reference radius.

Then, I can adjust the reference radius to minimize the sum of radii while satisfying the inequality constraints with non-tangent disks.

This seems manageable.

Let me try to formalize this.

Consider one connected component with k disks.

Choose one disk as the reference, say disk 1, with r1'.

Express all other radii in terms of r1' using the equality constraints.

Then, substitute these expressions into the inequality constraints involving non-tangent disks.

This will give me inequalities in terms of r1'.

Solve for r1' such that all inequalities hold, and r1' is positive.

Then, compute the sum of radii in terms of r1' and find the minimum possible sum.

Repeat this for each connected component.

Finally, sum up the minimum sums from all components and check if the total is strictly less than the original sum.

But wait, there might be interactions between different connected components through non-tangent disks.

For example, two disks from different components might not be tangent, so their radii must satisfy r_i' + r_j' ≤ d_ij.

This complicates things because it introduces constraints between different components.

So, perhaps I need to consider the entire graph at once.

Alternatively, maybe I can treat each connected component separately, assuming that the components are independent.

But that might not be the case due to the inequality constraints between disks from different components.

Hmm.

Let me think differently.

Suppose I fix the radii of one connected component and consider how it affects the radii of other components through the inequality constraints.

This could get quite involved.

Is there a better way?

Let me consider the dual graph again.

If two disks are tangent, they are connected in the graph.

If they are not tangent, they are not connected directly.

But their radii are still constrained by the inequality r_i' + r_j' ≤ d_ij.

I need to ensure that, even though they are in different components, their radii don't violate this inequality.

This seems tricky.

Maybe I can think in terms of assigning weights to the disks such that the sum decreases, while respecting the tangency and non-overlapping conditions.

Wait a minute.

I recall that in graph theory, when dealing with equality constraints, it's sometimes useful to consider the system as a system of equations and analyze its solution space.

In particular, I can look at the rank of the system and determine the degrees of freedom.

But perhaps that's too general.

Let me consider a smaller example to get some intuition.

Take the first sample input:

5 disks:

1. (0,2), r=1

2. (0,0), r=1

3. (4,-3), r=4

4. (11,0), r=3

5. (11,5), r=2

From the explanation, it seems that in this configuration, it's possible to decrease the sum of radii by 0.5.

How did they arrive at that?

Probably by adjusting the radii of some disks while keeping the tangencies intact and ensuring no overlaps.

In the first sample, disks 1 and 2 are tangent, disks 2 and 3 are tangent, disks 3 and 4 are tangent, and disks 4 and 5 are tangent, forming a chain.

So the connected component includes all five disks.

Then, they decreased the radii of disks 1 and 3 by 0.5 each and increased the radius of disk 2 by 0.5.

This results in a net decrease of 0.5 in the sum of radii.

But why was this possible?

Because in the system of equations defined by the tangencies, there was some flexibility to adjust the radii in this way without violating the constraints.

Now, in the second sample, it's not possible to decrease the sum of radii while maintaining the tangencies and non-overlapping conditions.

Looking at the second sample:

4 disks:

1. (2,2), r=2

2. (7,2), r=3

3. (7,7), r=2

4. (2,7), r=3

This forms a sort of square with disks at each corner, tangent to their adjacent disks.

In this case, it's not possible to decrease the sum of radii without violating the tangencies or causing overlaps.

So, what's the difference between these two cases?

In the first sample, there was a chain of tangencies, allowing for some adjustment in radii, while in the second sample, the arrangement is more rigid, not allowing such adjustments.

Perhaps the key is to check if the graph of tangencies is bipartite.

Wait, that might be a lead.

In graph theory, a graph is bipartite if its vertices can be divided into two disjoint sets such that no two graph vertices within the same set are adjacent.

If the tangency graph is bipartite, maybe it's possible to adjust the radii in a way that decreases the sum, and if it's not bipartite, it's not possible.

But I need to verify this intuition.

Let's consider the first sample: a chain of five disks, each tangent to the next.

This forms a path graph, which is bipartite.

In the second sample, the tangency graph forms a cycle of length 4, which is also bipartite.

Wait, but in the second sample, it's not possible to decrease the sum of radii.

So, maybe being bipartite is not the deciding factor.

Wait, perhaps I need to consider the parity of cycles or something else.

Let me think differently.

Suppose I assign variables to the radii: r1', r2', ..., rn'.

For each tangency between disks i and j, I have the equation r_i' + r_j' = d_ij.

For non-tangent disks i and j, I have the inequality r_i' + r_j' ≤ d_ij.

I need to minimize the sum of r1' + r2' + ... + rn', subject to these constraints, and check if the minimum is less than the original sum.

This is an optimization problem with linear constraints.

In linear programming terms, it's a linear programming problem.

However, for n up to 1000, solving a linear program directly might be too slow.

I need a smarter approach.

Let me consider the equality constraints first.

Suppose I have a connected component in the tangency graph.

Within this component, the equality constraints form a system that can be solved to express all radii in terms of one reference radius.

Then, the inequality constraints with disks outside the component must be satisfied.

But this seems too vague.

Let me try to model this system more formally.

Consider one connected component with k disks and t tangencies.

The system of equations is:

For each tangency between disks i and j: r_i' + r_j' = d_ij.

This is a system of t equations with k variables.

The solution space is k - rank of the coefficient matrix.

If the coefficient matrix is of rank k - 1, then the solution space is one-dimensional, and radii can be expressed in terms of one reference radius.

In general, the rank of the coefficient matrix for this system is k - 1, assuming the graph is connected.

This is similar to the number of independent radii in a connected component.

So, in a connected component with k disks, there is one degree of freedom.

I can choose one reference radius and express all others in terms of it.

Then, I can plug these expressions into the inequality constraints involving non-tangent disks.

This way, I can find the feasible range for the reference radius that satisfies all inequalities.

After that, I can compute the sum of radii in terms of the reference radius and find its minimum value.

If the minimum sum is less than the original sum, then it's possible.

Otherwise, it's not.

But I need to do this efficiently for n up to 1000.

Let me consider implementing this approach step by step.

First, build the tangency graph: nodes are disks, edges are tangencies.

Find all connected components in this graph.

For each connected component, solve the system of equality constraints to express all radii in terms of one reference radius.

Then, handle the inequality constraints with disks from other components.

This seems manageable.

But it's still quite involved.

Is there a simpler way?

Wait, perhaps I can consider the difference between the new and original radii.

Let’s define delta_i = r_i' - r_i for each disk i.

Then, the conditions become:

For tangent disks i and j: delta_i + delta_j = 0.

For non-tangent disks i and j: delta_i + delta_j ≤ d_ij - (r_i + r_j).

Also, the sum of delta_i over all i < 0.

This reformulates the problem in terms of delta_i.

Now, for tangent disks, delta_i = -delta_j.

This means that in a connected component, all delta_i are multiples of each other.

Wait, more precisely, in a connected component, all delta_i are equal up to a sign, depending on their connectivity.

This sounds similar to assigning values to nodes in a graph such that adjacent nodes have opposite values.

This is reminiscent of a bipartition of the graph.

If the connected component is bipartite, then it might be possible to assign delta_i such that the sum decreases.

Wait, perhaps I need to assign delta_i = c * coef_i, where coef_i is either 1 or -1, depending on the bipartition.

Then, for tangent disks i and j, delta_i + delta_j = c*(coef_i + coef_j) = 0, which requires coef_i = -coef_j.

This is exactly the condition for the graph to be bipartite.

So, if the connected component is bipartite, I can assign coef_i alternately as 1 and -1 along the edges.

Then, delta_i = c * coef_i, where c is a common factor.

Then, the sum of delta_i is c * sum(coef_i).

To have the sum of radii decrease, I need sum(delta_i) < 0.

That is, c * sum(coef_i) < 0.

Now, I need to choose c such that all constraints are satisfied.

Additionally, I need to ensure that the new radii are positive, i.e., r_i' = r_i + delta_i > 0.

Also, for non-tangent disks, delta_i + delta_j ≤ d_ij - (r_i + r_j).

Given that delta_i = c * coef_i and delta_j = c * coef_j, this becomes c*(coef_i + coef_j) ≤ d_ij - (r_i + r_j).

Now, since coef_i and coef_j are either both same or opposite depending on their connection in the graph, but since they are not connected directly, I need to consider their relative coefficients.

This seems complicated.

Perhaps I need to consider each connected component separately and then handle the inequalities between different components.

But handling inequalities between different components might be tricky.

Is there a way to decouple the components?

Wait, maybe if all connected components are bipartite, then it's possible to assign coefficients such that the sum of radii decreases.

But in the second sample, the tangency graph is a cycle of length 4, which is bipartite, but it's not possible to decrease the sum of radii.

Wait, that contradicts my earlier thought.

So, being bipartite is not sufficient.

Wait, perhaps I need to consider more carefully.

Let me look back at the first sample.

In the first sample, the connected component is a path of 5 nodes, which is bipartite.

They were able to decrease the sum of radii.

In the second sample, the connected component is a cycle of 4 nodes, which is bipartite, but they couldn't decrease the sum.

So, being bipartite isn't enough.

There must be another condition.

Let me think about the sum of coefficients in each connected component.

In the first sample, they chose coefficients alternately along the path, say +1, -1, +1, -1, +1.

Then, sum(coef) = +1 -1 +1 -1 +1 = +1.

To have sum(delta_i) < 0, they need c * sum(coef) < 0, which implies c < 0.

But they also need to ensure that r_i' = r_i + delta_i > 0.

Given that delta_i = c * coef_i, and c < 0, then for coef_i = +1, delta_i < 0, and for coef_i = -1, delta_i > 0.

This means that for coef_i = +1, radii decrease, and for coef_i = -1, radii increase.

In the first sample, they decreased radii of disks 1 and 3 and increased radius of disk 2, which aligns with coef_i = +1 for disks 1,3,5 and coef_i = -1 for disks 2,4.

Now, to minimize the sum, they chose c as small as possible (since sum(delta_i) = c * sum(coef) = c * 1 < 0, so c < 0).

But they also need to ensure that r_i' > 0, which means r_i + c * coef_i > 0.

For coef_i = +1: r_i + c > 0 ⇒ c > -r_i.

For coef_i = -1: r_i - c > 0 ⇒ c < r_i.

So, c needs to satisfy:

c > -min(r_i for coef_i = +1)

c < min(r_i for coef_i = -1)

In the first sample, min(r_i for coef_i = +1) is 1 (disks 1,3,5)

min(r_i for coef_i = -1) is 1 (disk 2)

So, c > -1 and c < 1.

Since sum(delta_i) = c * 1 < 0, c < 0.

So, c is in (-1, 0).

Thus, c can be -0.5, for example.

Then, delta_i for coef_i = +1 is -0.5, and for coef_i = -1 is +0.5.

This leads to the adjustments described in the sample.

Now, the sum of radii decreases by |c| * sum(coef), which is |c| * 1 = 0.5.

Similarly, in the second sample, the connected component is a cycle of 4 nodes.

If I try to assign coefficients alternately: +1, -1, +1, -1.

Then sum(coef) = +1 -1 +1 -1 = 0.

Then sum(delta_i) = c * 0 = 0, which does not satisfy sum(delta_i) < 0.

So, in this case, it's impossible to have a decrease in the sum.

Hence, in the second sample, the answer is 'NO'.

Therefore, for a connected component, if it's bipartite and sum(coef) != 0, then it's possible to choose c < 0 to make sum(delta_i) < 0.

Otherwise, if sum(coef) == 0, then sum(delta_i) = 0, and it's not possible to decrease the sum.

So, in summary:

- For each connected component, if it's bipartite and sum(coef) != 0, then it's possible to decrease the sum of radii for that component.

- If all connected components satisfy this condition, then the overall sum can be decreased.

- Additionally, need to ensure that the new radii are positive and satisfy the inequality constraints with non-tangent disks.

Wait, but in the first sample, they only adjusted one connected component, and it was enough to decrease the sum.

In the second sample, the single connected component had sum(coef) = 0, so it was impossible.

So, perhaps the general condition is that there exists at least one connected component that is bipartite and sum(coef) != 0.

Then, it's possible to decrease the sum by adjusting that component's radii, while keeping the radii of other components unchanged.

This would suffice to make the overall sum decrease.

Is this always true?

Wait, but I need to ensure that adjusting one component doesn't violate the inequality constraints with disks from other components.

In other words, when I adjust the radii in one component, I need to make sure that the new radii still satisfy r_i' + r_j' ≤ d_ij for all non-tangent pairs (i,j), where i and j are in different components.

This seems complicated to handle in general.

However, in practice, if I adjust one component while keeping others fixed, and ensure that the adjustments don't violate the inequalities with other components, it might be possible.

But to keep it simple, perhaps I can assume that adjusting one bipartite component with sum(coef) != 0 doesn't affect the inequalities with other components, as long as the adjustments are small enough.

In the first sample, they decreased some radii and increased others within the component, which likely doesn't affect the inequalities with other components, given that the original configuration already satisfies them.

Therefore, perhaps it's sufficient to check if there exists at least one connected component that is bipartite and has sum(coef) != 0.

If so, then it's possible to decrease the sum of radii.

Otherwise, it's not possible.

This seems like a feasible approach.

Hence, the algorithm would be:

1. Build the tangency graph, where nodes are disks and edges are tangencies.

2. Find all connected components.

3. For each connected component, check if it's bipartite.

   - If it's bipartite, assign coefficients coef_i = 1 or -1 alternately.

   - Compute sum(coef) for the component.

   - If sum(coef) != 0, then it's possible to decrease the sum of radii for this component.

4. If there exists at least one such component, output 'YES'; else, 'NO'.

This seems efficient enough for n up to 1000.

Now, to implement this, I need to:

- Build the adjacency list for the tangency graph.

- Perform DFS or BFS to find connected components and check bipartiteness.

- For each bipartite component, compute sum(coef) and check if it's non-zero.

- If any such component exists, output 'YES'; else, 'NO'.

I need to be careful with the bipartition assignment.

In DFS, I can assign coef_i = 1 or -1 based on the depth of the node in the traversal.

Alternatively, I can keep a visited array with values 1 and -1.

I need to ensure that adjacent nodes have opposite coefficients.

Also, need to handle the case where the component is not bipartite, i.e., if there is an odd cycle.

In such cases, it's not possible to assign coefficients consistently, so I should treat such components as not bipartite.

Wait, but in the problem statement, it's given that no two disks overlap in a region of positive area, only tangencies are allowed, so the graph shouldn't have any odd cycles that would make it non-bipartite.

Wait, no, a cycle of even length is bipartite, but a cycle of odd length is not.

In the second sample, the cycle is of length 4, which is even, so it's bipartite, and sum(coef) = 0, which matches the sample.

In the first sample, the component is a path (which is bipartite), and sum(coef) != 0.

Hence, this approach seems consistent with the samples.

Therefore, I can proceed with this algorithm.

Now, to implement this in code:

- Read n.

- Read the coordinates and radii of n disks.

- Compute the distance between centers of each pair of disks.

- For each pair, check if they are tangent: (x_i - x_j)^2 + (y_i - y_j)^2 == (r_i + r_j)^2.

- Build the adjacency list based on tangencies.

- For each connected component:

   - Perform DFS to check bipartiteness and compute sum(coef).

   - If bipartite and sum(coef) != 0, set a flag to True.

- After processing all components, output 'YES' if the flag is True, else 'NO'.

I need to implement DFS carefully to handle the bipartition and sum(coef).

I should also ensure that the graph is correctly built and that I handle all n disks properly.

Edge cases to consider:

- n = 1: single disk, can decrease its radius as long as it remains positive.

  - In this case, the component is bipartite (trivially), and sum(coef) = 1 != 0.

  - So, it's possible to decrease the sum of radii.

- n = 2: two disks that are tangent.

  - sum(coef) = 1 + (-1) = 0, so not possible to decrease the sum.

- n = 2: two disks that are not tangent.

  - They are in separate components, each with sum(coef) != 0, so possible to decrease each component's sum independently.

Wait, but in this case, they are separate components, and I can adjust each component's radii independently, as long as the inequality constraints between components are satisfied.

But in practice, since they are not connected, I can adjust each component's radii without affecting the other.

Hence, if any component is bipartite with sum(coef) != 0, I can decrease its sum.

Hence, in the general case, I need to check for each connected component whether it's bipartite and sum(coef) != 0.

If any component satisfies this, then 'YES'; else, 'NO'.

I think this is the correct approach.

Now, I'll proceed to implement this algorithm in code.

## Final Solution
To solve this problem, we need to determine if it is possible to adjust the radii of given disks such that the sum of their radii strictly decreases, while maintaining tangency where present and avoiding overlaps otherwise. 

### Approach

1. **Graph Construction**:
    - Represent disks as nodes in a graph.
    - Connect two nodes with an edge if their disks are tangent to each other.

2. **Connected Components Analysis**:
    - For each connected component in the graph:
        - Check if the component is bipartite.
        - If bipartite, compute the sum of coefficients assigned to nodes in one partition.

3. **Feasibility Check**:
    - If any connected component is bipartite and the sum of coefficients for one partition is non-zero, it is possible to decrease the sum of radii while maintaining the given conditions.

### Solution Code

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    idx = 0
    n = int(data[idx])
    idx += 1
    x = [0] * n
    y = [0] * n
    r = [0] * n
    for i in range(n):
        x[i] = int(data[idx])
        idx += 1
        y[i] = int(data[idx])
        idx += 1
        r[i] = int(data[idx])
        idx += 1
    
    adj = [[] for _ in range(n)]
    for i in range(n):
        for j in range(i + 1, n):
            dx = x[i] - x[j]
            dy = y[i] - y[j]
            dist_sq = dx * dx + dy * dy
            rad_sum_sq = (r[i] + r[j]) ** 2
            if dist_sq == rad_sum_sq:
                adj[i].append(j)
                adj[j].append(i)
    
    visited = [False] * n
    coef = [0] * n
    ok = False
    
    def dfs(node, c):
        nonlocal tot, bipartite
        visited[node] = True
        coef[node] = c
        tot += c
        for neighbor in adj[node]:
            if not visited[neighbor]:
                dfs(neighbor, -c)
            else:
                if coef[neighbor] != -c:
                    bipartite = False
    
    for i in range(n):
        if not visited[i]:
            tot = 0
            bipartite = True
            dfs(i, 1)
            if bipartite and tot != 0:
                ok = True
                break
    
    if ok:
        print('YES')
    else:
        print('NO')

if __name__ == "__main__":
    main()
```

### Explanation

1. **Graph Construction**:
    - We build an adjacency list where each disk is a node, and an edge exists between two nodes if their disks are tangent.

2. **Connected Components Analysis**:
    - We use Depth-First Search (DFS) to traverse each connected component.
    - During DFS, we assign coefficients of 1 and -1 alternately to nodes to check if the component is bipartite.
    - We compute the sum of these coefficients for each bipartite component.

3. **Feasibility Check**:
    - If any connected component is bipartite and the sum of coefficients is non-zero, we can adjust radii to decrease the total sum while maintaining tangency and non-overlap conditions.