Alright, I've got this problem to solve. Let's see what it's asking for. So, Farmer John has a permutation p of numbers from 0 to n-1, and he gives Bessie an array a, where each a_i is calculated as the MEX of the first i elements of p minus p_i. My job is to reconstruct the permutation p from the array a.

First, I need to understand what MEX means. MEX stands for "minimum excluded," which is the smallest non-negative integer not present in a given list. For example, MEX of [1, 2, 3] is 0 because 0 is the smallest non-negative integer not in the list. MEX of [3, 1, 0] is 2, since 0 and 1 are present, but 2 is not.

So, for each position i in the permutation p, a_i = MEX(p_1 to p_i) - p_i. I need to find p given a.

The problem says that there is at least one valid p for the given a, so I don't have to worry about invalid inputs.

Let me think about how to approach this. Since p is a permutation, each number from 0 to n-1 appears exactly once in p. I need to find which number goes in each position based on the a array.

Let's consider the first element p_1. The MEX of just p_1 is the smallest non-negative integer not equal to p_1. If p_1 is 0, then MEX is 1; if p_1 is 1, MEX is 0; if p_1 is 2, MEX is 0, and so on.

Wait, no. MEX of a single element list is 0 if 0 is not in the list, otherwise it's the smallest missing integer.

Wait, actually, MEX of [x] where x is any non-negative integer: if x is 0, MEX is 1; if x is not 0, MEX is 0. Because MEX is the smallest non-negative integer not in the list.

Wait, no. MEX of [x] is 0 if x is not 0, because 0 is the smallest non-negative integer not in the list. If x is 0, then MEX is 1, since 0 is in the list already.

So, for p_1:

a_1 = MEX(p_1) - p_1

If p_1 = 0, then MEX(p_1) = 1, so a_1 = 1 - 0 = 1

If p_1 = 1, then MEX(p_1) = 0, so a_1 = 0 - 1 = -1

If p_1 = 2, then MEX(p_1) = 0, so a_1 = 0 - 2 = -2

And so on.

So, for the first element, a_1 can be either 1 (if p_1 = 0) or negative values depending on p_1.

Now, for the second element p_2:

a_2 = MEX(p_1, p_2) - p_2

MEX of p_1 and p_2 is the smallest non-negative integer not in {p_1, p_2}.

Similarly, for subsequent elements.

I need to find p_i for each i based on a_i and the MEX values.

This seems a bit tricky. Let's think about how MEX changes as we add more elements.

I know that MEX is always a non-negative integer, and it's the smallest missing number in the list so far.

Given that a_i = MEX(p_1 to p_i) - p_i, I can rearrange this to p_i = MEX(p_1 to p_i) - a_i.

So, p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) depends on the p_j's up to i, which includes p_i itself.

This seems a bit circular. Maybe I need to find a way to compute MEX incrementally.

Let me consider the order in which elements are added.

As I build the permutation step by step, I can keep track of which numbers have been used so far.

Let's try to simulate this process.

Initialize a set to keep track of used numbers.

Start with an empty list for p.

For each position i from 1 to n:

- Compute MEX of p_1 to p_i.

- Given a_i = MEX(p_1 to p_i) - p_i, so p_i = MEX(p_1 to p_i) - a_i.

But MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

Wait, but p_i is part of p_1 to p_i, so this seems circular.

Maybe I need to think differently.

Let me consider that MEX(p_1 to p_i) is some value, say m.

Then, p_i = m - a_i.

So, p_i = m - a_i.

But m is the smallest non-negative integer not in p_1 to p_i.

So, p_i must be equal to m - a_i.

But p_i must be a number between 0 and n-1, and it must not have been used before.

This seems complicated.

Let me think about the example given.

In the first case:

n = 5

a = [1, 1, -2, 1, 2]

The correct p is [0, 1, 4, 2, 3]

Let's verify:

p_1 = 0

MEX(p_1) = MEX([0]) = 1

a_1 = 1 - 0 = 1

p_2 = 1

MEX(p_1, p_2) = MEX([0,1]) = 2

a_2 = 2 - 1 = 1

p_3 = 4

MEX(p_1,p_2,p_3) = MEX([0,1,4]) = 2

a_3 = 2 - 4 = -2

p_4 = 2

MEX(p_1 to p_4) = MEX([0,1,4,2]) = 3

a_4 = 3 - 2 = 1

p_5 = 3

MEX(p_1 to p_5) = MEX([0,1,4,2,3]) = 5

a_5 = 5 - 3 = 2

So, a = [1,1,-2,1,2]

This matches the example.

Now, how can I reconstruct p from a?

Let me try to find a pattern or a way to compute p_i based on a_i and perhaps some accumulated information.

I need to keep track of which numbers have been used in p so far, because p is a permutation, so each number appears exactly once.

Also, MEX is the smallest non-negative integer not in p_1 to p_i.

So, perhaps I can keep track of the available numbers, i.e., numbers from 0 to n-1 that haven't been used yet.

Let me try to build p step by step.

Initialize:

- used = empty set

- available numbers = [0,1,2,3,4] for n=5

For i=1:

- a_1 = 1

- MEX(p_1) = MEX([p_1]) = smallest non-negative integer not in [p_1]

- Let's say p_1 = x

- Then MEX([x]) = 0 if x != 0, else 1

- So, a_1 = MEX([x]) - x = 1

- If x = 0, MEX([0]) = 1, so a_1 = 1 - 0 = 1

- If x = 1, MEX([1]) = 0, so a_1 = 0 - 1 = -1

- If x = 2, MEX([2]) = 0, so a_1 = 0 - 2 = -2

- And so on.

- Given a_1 = 1, possible x is 0, because 1 - 0 = 1

- So, p_1 = 0

- used = {0}

- available = {1,2,3,4}

For i=2:

- a_2 = 1

- MEX(p_1,p_2) = smallest non-negative integer not in [0, p_2]

- Let p_2 = y

- If y = 1, MEX([0,1]) = 2, so a_2 = 2 - 1 = 1

- If y = 2, MEX([0,2]) = 1, so a_2 = 1 - 2 = -1

- If y = 3, MEX([0,3]) = 1, so a_2 = 1 - 3 = -2

- And so on.

- Given a_2 = 1, possible y is 1, because 2 - 1 = 1

- So, p_2 = 1

- used = {0,1}

- available = {2,3,4}

For i=3:

- a_3 = -2

- MEX(p_1,p_2,p_3) = smallest non-negative integer not in [0,1,p_3]

- Let p_3 = z

- If z = 2, MEX([0,1,2]) = 3, so a_3 = 3 - 2 = 1

- If z = 3, MEX([0,1,3]) = 2, so a_3 = 2 - 3 = -1

- If z = 4, MEX([0,1,4]) = 2, so a_3 = 2 - 4 = -2

- Given a_3 = -2, z = 4

- So, p_3 = 4

- used = {0,1,4}

- available = {2,3}

For i=4:

- a_4 = 1

- MEX(p_1 to p_4) = smallest non-negative integer not in [0,1,4,p_4]

- Let p_4 = w

- If w = 2, MEX([0,1,4,2]) = 3, so a_4 = 3 - 2 = 1

- If w = 3, MEX([0,1,4,3]) = 2, so a_4 = 2 - 3 = -1

- Given a_4 = 1, w = 2

- So, p_4 = 2

- used = {0,1,4,2}

- available = {3}

For i=5:

- a_5 = 2

- MEX(p_1 to p_5) = smallest non-negative integer not in [0,1,4,2,p_5]

- Let p_5 = v

- If v = 3, MEX([0,1,4,2,3]) = 5, so a_5 = 5 - 3 = 2

- So, p_5 = 3

- used = {0,1,4,2,3}

- available = empty

So, p = [0,1,4,2,3]

This matches the example.

From this, it seems like for each step, given a_i, I can determine p_i based on the MEX of the previous elements and the value of a_i.

Let me try to generalize this.

At each step i:

- I have the used set of numbers: the p_j for j from 1 to i-1

- I need to choose p_i from the available numbers (0 to n-1 not in used)

- I know a_i = MEX(p_1 to p_i) - p_i

- So, p_i = MEX(p_1 to p_i) - a_i

But MEX(p_1 to p_i) is the smallest non-negative integer not in p_1 to p_i.

Wait, p_i is part of p_1 to p_i, so this seems circular.

Is there a way to compute MEX(p_1 to p_i) without knowing p_i?

Hmm.

Wait, perhaps I can consider that MEX(p_1 to p_i) is the smallest non-negative integer not in the set of p_1 to p_{i-1} and p_i.

But p_i is unknown.

This seems tricky.

Let me think differently.

Let me consider that MEX(p_1 to p_i) is some value m.

Then, p_i = m - a_i.

But m is the smallest non-negative integer not in p_1 to p_i.

So, m is not in p_1 to p_i, which includes p_i.

So, m is not equal to p_i.

Therefore, m != p_i = m - a_i, which implies a_i != 0.

But a_i can be negative or positive, depending on m and p_i.

This seems too vague.

Maybe I need to find a way to find m such that m - p_i = a_i, and m is the MEX of p_1 to p_i.

Wait, no. a_i = MEX - p_i, so p_i = MEX - a_i.

I need to find p_i such that p_i = m - a_i, and m is the smallest non-negative integer not in p_1 to p_i.

This still seems circular.

Let me try to find another approach.

Perhaps I can keep track of the MEX as I build the permutation.

Initialize MEX as 0.

For each step i:

- Find p_i such that a_i = MEX - p_i.

- Update the used set.

- Update the MEX.

But how do I update the MEX?

The MEX is the smallest non-negative integer not used so far.

Wait, no. Not necessarily. The MEX is the smallest non-negative integer not in p_1 to p_i.

So, as I add p_i, if p_i is equal to the current MEX, then MEX increases by 1.

Wait, no. If p_i is equal to the current MEX, then the new MEX is the next integer.

But it's complicated because p_i can be anything not used before.

Maybe I need to iterate and keep track of the used numbers and compute MEX accordingly.

Let me try to implement this step by step for the first test case.

n = 5

a = [1,1,-2,1,2]

Initialize:

used = set()

mex = 0

p = []

Step 1:

a_1 = 1

p_1 = mex - a_1 = 0 - 1 = -1

But p_1 has to be between 0 and 4. This can't be -1. So this approach is wrong.

Wait, perhaps I need to find p_i such that p_i = mex - a_i, and mex is the MEX of p so far.

But this seems circular.

Let me think differently.

Let me consider that mex = a_i + p_i

Since a_i = mex - p_i, then mex = a_i + p_i

But mex is the smallest non-negative integer not in p_1 to p_i.

So, for each i, mex = a_i + p_i

But mex is determined by the set of p_1 to p_i.

This seems tricky.

Wait, perhaps I can iterate through a and keep track of the used numbers and compute mex accordingly.

Let me try that.

Initialize:

used = set()

mex = 0

p = []

For i=1 to n:

while mex in used:

mex += 1

# Now, a_i = mex - p_i

# So, p_i = mex - a_i

p_i = mex - a_i

# Ensure p_i is not already used

if p_i not in used:

p.append(p_i)

used.add(p_i)

else:

# This should not happen, as per problem statement

pass

Let's try this with the first test case.

n=5, a=[1,1,-2,1,2]

Initialize:

used = {}

mex = 0

p = []

i=1:

while 0 in used: no

p_1 = 0 - 1 = -1

But -1 is not in 0 to 4, invalid.

Wait, this can't be right.

This suggests that my approach is flawed.

Wait, perhaps I need to adjust how I compute mex.

Let me think again.

In the first step, mex should be the smallest non-negative integer not in p so far.

At step 1, p is empty, so mex=0.

Then p_1 = 0 - 1 = -1, which is invalid.

But in the example, p_1=0, which is valid.

Wait, perhaps I need to find p_i such that p_i = mex - a_i, and ensure p_i is not used and is within 0 to n-1.

So, in step 1:

mex=0

p_1 = 0 - 1 = -1, invalid.

But in the example, p_1=0, which would require that mex - p_1 = a_1 => 0 - 0 = 0, but a_1=1.

Wait, that doesn't match.

Wait, in the example, p_1=0, mex=1, a_1=1.

So, a_1 = mex - p_1 = 1 - 0 = 1, which matches.

But according to my earlier approach, I thought mex was 0, but in reality, mex is 1 when p_1=0.

So, my assumption that mex=0 at step 1 is wrong.

Wait, mex is the smallest non-negative integer not in p_1 to p_i.

At step 1, p_1=0, so mex=1.

At step 2, p_1=0, p_2=1, so mex=2.

At step 3, p_1=0, p_2=1, p_3=4, so mex=2.

Wait, but mex should be 2, since 0 and 1 are used.

Wait, no, with p_1=0, p_2=1, p_3=4, the smallest missing is 2.

Wait, but in step 3, a_3=-2, which is mex - p_3 => 2 - p_3 = -2 => p_3 = 4, which matches.

So, mex is increasing as numbers are used.

Wait, perhaps I need to keep track of the current mex and update it as I add numbers.

Let me try to formalize this.

Initialize:

used = set()

current_mex = 0

p = []

For each a_i in a:

while current_mex in used:

current_mex += 1

# Now, mex = current_mex

# a_i = mex - p_i => p_i = mex - a_i

p_i = current_mex - a_i

# Ensure p_i is not used and 0 <= p_i <= n-1

if p_i not in used and 0 <= p_i <= n-1:

p.append(p_i)

used.add(p_i)

else:

# This should not happen, as per problem statement

pass

Let's try this with the first test case.

n=5, a=[1,1,-2,1,2]

Initialize:

used = {}

current_mex = 0

p = []

i=1, a_1=1:

while 0 in used: no

p_1 = 0 - 1 = -1, which is invalid.

Wait, -1 is not between 0 and 4.

This suggests that current_mex needs to be adjusted.

Wait, perhaps I need to find the correct mex such that p_i is valid.

Wait, maybe I need to iterate current_mex until I find a p_i that is valid.

Wait, perhaps I need to compute mex differently.

Let me think about another approach.

Since p is a permutation, each p_i is unique and in 0 to n-1.

I can keep track of used numbers.

At each step, I can compute mex as the smallest non-negative integer not in used.

Then, p_i = mex - a_i.

If p_i is within 0 to n-1 and not used, I can use it.

Otherwise, something is wrong.

But in the first step, if I set mex=0, p_1=0 -1=-1, which is invalid.

But in the example, p_1=0, which corresponds to mex=1.

Wait, in the first step, mex should be 1 if p_1=0.

Wait, but according to the earlier calculation, if p_1=0, mex=1.

So, perhaps mex is not starting from 0.

Wait, actually, mex is determined based on the current p.

Wait, maybe I need to iterate and compute mex dynamically.

Let me try to simulate this.

Initialize:

used = set()

current_mex = 0

p = []

For each a_i in a:

while current_mex in used:

current_mex += 1

# Now, current_mex is the smallest non-negative integer not used

# a_i = current_mex - p_i => p_i = current_mex - a_i

p_i = current_mex - a_i

# Check if p_i is valid: 0 <= p_i <= n-1 and p_i not in used

if 0 <= p_i <= n-1 and p_i not in used:

p.append(p_i)

used.add(p_i)

else:

# This should not happen, as per problem statement

pass

Let's try this with the first test case.

n=5, a=[1,1,-2,1,2]

Initialize:

used = {}

current_mex = 0

p = []

i=1, a_1=1:

while 0 in used: no

p_1 = 0 - 1 = -1, invalid.

But in the example, p_1=0.

Wait, perhaps I need to set current_mex to the next available mex based on used.

Wait, maybe I need to find the smallest mex such that p_i is valid.

Let me try adjusting the approach.

Initialize:

used = set()

current_mex = 0

p = []

For each a_i in a:

# Find p_i such that a_i = mex - p_i, and p_i is not used and 0 <= p_i <= n-1

# p_i = mex - a_i

# But mex is the smallest non-negative integer not in used.

while current_mex in used:

current_mex += 1

# Now, current_mex is the smallest non-negative integer not in used.

# So, p_i = current_mex - a_i

p_i = current_mex - a_i

# Check if p_i is valid

if 0 <= p_i <= n-1 and p_i not in used:

p.append(p_i)

used.add(p_i)

else:

# Find the next available mex that makes p_i valid.

# Since the problem guarantees a solution exists, we can adjust mex accordingly.

# Perhaps p_i is the smallest available number that satisfies p_i = mex - a_i.

# But this seems too vague.

pass

This is getting complicated.

Let me consider another approach.

Since p is a permutation, each p_i is unique and from 0 to n-1.

I can try to build p step by step, ensuring that at each step, p_i is consistent with a_i.

At each step i:

- Compute mex of p_1 to p_i

- Check if p_i = mex - a_i

- Ensure p_i is not used before and is between 0 and n-1

But this still seems circular.

Wait, perhaps I can iterate through a and assign p_i accordingly, keeping track of used numbers and the current mex.

Let me try to implement this in code, step by step.

Initialize:

used = [False] * n

current_mex = 0

p = []

for each a_i in a:

# Find p_i such that a_i = mex - p_i

# p_i = mex - a_i

# Ensure p_i is between 0 and n-1 and not used

while current_mex in used:

current_mex += 1

# Now, current_mex is the smallest non-negative integer not used

p_i = current_mex - a_i

if 0 <= p_i < n and not used[p_i]:

p.append(p_i)

used[p_i] = True

else:

# This should not happen, as per problem statement

pass

Let's test this with the first test case.

n=5, a=[1,1,-2,1,2]

Initialize:

used = [False, False, False, False, False]

current_mex = 0

p = []

i=1, a_1=1:

while 0 in used: no

p_1 = 0 - 1 = -1, invalid.

But in the example, p_1=0.

Wait, perhaps I need to adjust current_mex based on p_i.

Wait, maybe I need to set p_i to the smallest available number that satisfies p_i = mex - a_i.

Let me try to adjust the approach.

Initialize:

used = [False] * n

current_mex = 0

p = []

for each a_i in a:

# Find p_i such that p_i = mex - a_i

# But mex is the smallest non-negative integer not in used.

# So, p_i = mex - a_i

# We need to find mex such that p_i is available.

# Perhaps iterate mex starting from current_mex until p_i is valid.

while True:

p_i = current_mex - a_i

if 0 <= p_i < n and not used[p_i]:

p.append(p_i)

used[p_i] = True

break

else:

current_mex += 1

This seems promising.

Let's try it with the first test case.

n=5, a=[1,1,-2,1,2]

Initialize:

used = [False, False, False, False, False]

current_mex = 0

p = []

i=1, a_1=1:

p_i = 0 - 1 = -1, invalid.

current_mex +=1 => current_mex=1

p_i =1 -1=0, which is 0, available.

p=[0]

used[0]=True

i=2, a_2=1:

p_i=0 -1= -1, invalid.

current_mex=1

p_i=1 -1=0, already used.

current_mex +=1 => current_mex=2

p_i=2 -1=1, available.

p=[0,1]

used[1]=True

i=3, a_3=-2:

p_i=2 - (-2)=4, available.

p=[0,1,4]

used[4]=True

i=4, a_4=1:

p_i=2 -1=1, already used.

current_mex +=1 => current_mex=3

p_i=3 -1=2, available.

p=[0,1,4,2]

used[2]=True

i=5, a_5=2:

p_i=3 -2=1, already used.

current_mex +=1 => current_mex=4

p_i=4 -2=2, already used.

current_mex +=1 => current_mex=5

p_i=5 -2=3, available.

p=[0,1,4,2,3]

used[3]=True

This matches the example.

Great, so this approach seems to work.

Let me formalize it.

Algorithm:

1. Initialize a list `used` of size n with all False.

2. Initialize `current_mex` to 0.

3. Initialize an empty list `p` for the permutation.

4. For each a_i in a:

a. While True:

i. Calculate p_i = current_mex - a_i.

ii. If p_i is within [0, n-1] and not used, append p_i to p and set used[p_i] to True. Break the loop.

iii. Else, increment current_mex by 1.

5. Output the list p.

This ensures that at each step, p_i is chosen such that it satisfies p_i = mex - a_i, and mex is the smallest non-negative integer not in the used set.

Now, considering the constraints:

- t <= 10^4

- n <= 2*10^5

- Sum of n over all test cases <= 2*10^5

So, the total time complexity should be O(sum of n) = O(2*10^5), which is acceptable.

Edge Cases to consider:

- n=1: Simplest case.

- All a_i same.

- a_i causing p_i to be 0 or n-1.

- a_i causing current_mex to be large.

But the problem states that at least one valid p exists for the given a, so I don't need to handle invalid cases.

Let me test this approach with another example.

Second test case:

n=5

a=[1,1,1,1,1]

The output is [0,1,2,3,4]

Let's verify:

p_1=0

mex=1 (since p_1=0)

a_1=1-0=1

p_2=1

mex=2 (since p_1=0, p_2=1)

a_2=2-1=1

p_3=2

mex=3 (since p_1=0, p_2=1, p_3=2)

a_3=3-2=1

p_4=3

mex=4

a_4=4-3=1

p_5=4

mex=5

a_5=5-4=1

So, a=[1,1,1,1,1]

Which matches the output.

Another test case:

n=3

a=[-2,1,2]

Output: [2,0,1]

Let's verify:

p_1=2

mex=0 (since 0 not in [2])

a_1=0 - 2 = -2

p_2=0

mex=1 (since [2,0])

a_2=1 - 0 = 1

p_3=1

mex=2 (since [2,0,1])

a_3=2 - 1 = 1

Wait, but according to the output, a_3=2, but according to my calculation, a_3=1.

Wait, that can't be right.

Wait, in the note, it says:

"For the third test case, p = [2, 0, 1] is one possible output.

a will then be calculated as a_1 = MEX(2) - 2 = 0 - 2 = -2, a_2 = MEX(2,0) - 0 = 1 - 0 = 1, a_3 = MEX(2,0,1) - 1 = 3 - 1 = 2."

Wait, a_3=3 -1=2, which matches the output.

I must have miscalculated.

So, p_1=2

mex=0 (since 0 not in [2])

a_1=0 -2 = -2

p_2=0

mex=1 (since [2,0])

a_2=1 -0 =1

p_3=1

mex=3 (since [2,0,1]), because 0 and 1 are used, but 2 is already used, so mex=3.

a_3=3 -1=2

Yes, that matches.

So, my earlier approach works here as well.

Hence, the algorithm seems correct.

Now, let's look at the given program and see if it implements this logic correctly.

Looking at the code:

for _ in range(int(input())):

func_1()

def func_1():

n = int(input())

arr = list(map(int, input().split()))

mex = []

minn = 0

used = {}

for i in range(n):

if arr[i] > 0:

mex.append(minn)

used[minn] = True

while minn in used:

minn += 1

else:

mex.append(abs(arr[i] - minn))

used[abs(arr[i] - minn)] = True

for itm in mex:

print(itm, end=' ')

print()

So, it defines func_1 to handle each test case.

It reads n and arr.

Then, it initializes mex as an empty list and minn as 0.

used is a dictionary to keep track of used numbers.

Then, for each a_i in arr:

- If a_i > 0:

- Append minn to mex

- Mark minn as used

- Increment minn until minn is not used

- Else (a_i <= 0):

- Append abs(a_i - minn) to mex

- Mark abs(a_i - minn) as used

- (minn is not updated in this case)

Then, print the mex list.

Wait, but according to my earlier reasoning, I need to compute p_i based on current_mex and a_i.

But in this code, it's computing mex as either minn (if a_i > 0) or abs(a_i - minn) (if a_i <= 0).

This seems different from what I thought.

Let me see if this corresponds to the correct logic.

In my approach, I had:

- Initialize used as empty set

- current_mex = 0

- For each a_i:

- While current_mex in used, increment current_mex

- p_i = current_mex - a_i

- If p_i is valid and not used, use it; else, increment current_mex and try again

But in the given code, it's directly appending minn to mex when a_i > 0, and abs(a_i - minn) when a_i <= 0.

This seems too simplistic and not aligned with the logic I derived.

Moreover, in my approach, mex is not the output; p is the output.

But in the given code, it's outputting mex.

Wait, but in the problem statement, the output should be p, the permutation.

But in the code, it's outputting mex, which is assigned either minn or abs(a_i - minn).

This seems incorrect.

Wait, perhaps there's a misunderstanding.

Let me check the example.

First test case:

n=5

a=[1,1,-2,1,2]

According to the code:

mex = []

minn=0

used={}

i=1, a_1=1 >0:

mex.append(0)

used[0]=True

while 0 in used: minn=1

i=2, a_2=1 >0:

mex.append(1)

used[1]=True

while 1 in used: minn=2

i=3, a_3=-2 <=0:

mex.append(abs(-2 - 2)=4)

used[4]=True

i=4, a_4=1 >0:

mex.append(2)

used[2]=True

while 2 in used: minn=3

i=5, a_5=2 <=0:

mex.append(abs(2 - 3)=1)

But 1 is already in used, so perhaps it's different.

Wait, used={0:True,1:True,4:True,2:True}, then a_5=2 <=0:

mex.append(abs(2 - 3)=1), but 1 is already used.

But in the code, it just appends abs(a_i - minn) regardless of whether it's used or not.

Wait, but in the example, p should be [0,1,4,2,3], but according to this code, mex would be [0,1,4,2,1], but it should output p, not mex.

This seems incorrect.

Wait, perhaps mex in the code is actually p.

But in the first test case, p should be [0,1,4,2,3], but according to the code, it's outputting [0,1,4,2,1], which is incorrect.

Hence, the given code is incorrect.

Wait, but the problem says to output p, the permutation, but the code is outputting mex, which is not p.

Moreover, in the code, mex is being built based on a_i > 0 or not, which doesn't align with the correct logic.

Hence, the given program is incorrect.

**Final Answer**

\[ \boxed{\text{Incorrect}} \]