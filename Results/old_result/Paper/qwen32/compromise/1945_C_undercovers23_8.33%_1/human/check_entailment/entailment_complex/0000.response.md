### Reasoning:

Let's analyze the provided code step-by-step to determine its correctness based on the problem description.

1. **Initialization and Input Reading:**
   - The code correctly reads the number of test cases `t`.
   - For each test case, it reads the number of houses `n` and the string `s` representing the preferences of the residents.

2. **Calculation of Thresholds:**
   - The variable `pk` is calculated as `n // 2`, which is used later to determine the closest position to the middle of the village.

3. **Counting Zeros and Ones:**
   - The code counts the total number of '1's (`o`) and '0's (`z`) in the string `s`.

4. **Iterating Over Possible Split Points:**
   - The code iterates through all possible split points `i` from `0` to `n-2` (since the road can be placed between any two consecutive houses).
   - For each split point, it updates the count of '0's (`zero`) and '1's (`one`) on the left side.
   - It calculates the percentage of '0's and '1's on the left and right sides, respectively.
     - `zero_perc` is the percentage of '0's on the left side.
     - `one_perc` is the percentage of '1's on the right side.
   - It checks if both percentages are at least 50%. If so, it adds the current split point `i + 1` to the list `lst`.

5. **Finding the Optimal Split Point:**
   - The code finds the split point in `lst` that is closest to the middle of the village (`pk`).
   - If multiple split points have the same distance to the middle, it selects the smallest one.
   - If no valid split point is found, it checks the entire village as a whole:
     - If the majority of residents prefer the right side (`c1 >= 50`), it sets the split point to `0` (before the first house).
     - Otherwise, it sets the split point to `n` (after the last house).

6. **Output:**
   - The code prints the optimal split point for each test case.

### Issues Identified:

- **Percentage Calculation:** The code calculates `zero_perc` and `one_perc` as percentages multiplied by 100, which is unnecessary and can lead to incorrect results due to floating-point precision issues. Instead, it should directly compare the counts to the required thresholds without converting to percentages.
- **Threshold Comparison:** The code uses `math.ceil` to round up the counts, but it should compare the counts directly to the rounded-up thresholds. Specifically, `zero` should be compared to `math.ceil(i + 1) / 2` and `o - one` should be compared to `math.ceil(n - i - 1) / 2`.

### Corrected Code Snippet:

```python
import math

def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        s = input()
        pk = n // 2
        o = s.count('1')
        z = s.count('0')
        zero, one = 0, 0
        lst = []
        mini = float('inf')
        
        for i in range(n - 1):
            if s[i] == '0':
                zero += 1
            else:
                one += 1
            if zero >= math.ceil((i + 1) / 2) and (o - one) >= math.ceil((n - i - 1) / 2):
                lst.append(i + 1)
        
        for ele in lst:
            mini = min(mini, abs(pk - ele))
        
        final = [elem for elem in lst if abs(pk - elem) == mini]
        
        if not final:
            c1 = o * 100 // n
            if c1 >= 50:
                final.append(0)
            else:
                final.append(n)
        
        print(final[0])

func()
```

### Conclusion:

The original code has logical errors in the way it calculates and compares the percentages. The corrected version addresses these issues by comparing the counts directly to the rounded-up thresholds.

**Correctness: False**

The original code is incorrect due to the flawed percentage calculation and comparison logic. The corrected version provided above fixes these issues.