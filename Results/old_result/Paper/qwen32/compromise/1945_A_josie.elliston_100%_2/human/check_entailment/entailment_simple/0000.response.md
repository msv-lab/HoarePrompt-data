### Reasoning:

To determine the correctness of the program, we need to analyze the logic of the two functions `func_1` and `func_2` and how they handle the given problem constraints.

1. **Function `func_1(extroverts, universals)`**:
   - **Purpose**: This function calculates the minimum number of tents required to accommodate the extroverts and universals under the condition that each extrovert must be in a tent with exactly two others.
   - **Logic**:
     - If `extroverts % 3 != 0`, it means the number of extroverts is not a multiple of 3. In this case, we need to check if we can complete the groups of three by using universals.
     - If the remainder of `extroverts` when divided by 3 (i.e., `extroverts % 3`) plus the number of universals is less than 3, it's impossible to form the required groups, and the function returns `None`.
     - Otherwise, it calculates the minimum number of tents required by taking the ceiling of `(extroverts + universals) / 3`. This effectively groups as many extroverts as possible in groups of three and uses universals to fill any remaining spots.

2. **Function `func_2(introverts, extroverts, universals)`**:
   - **Purpose**: This function calculates the total number of tents required for all participants, considering the introverts, extroverts, and universals.
   - **Logic**:
     - It first calls `func_1(extroverts, universals)` to get the number of tents required for extroverts and universals.
     - If `func_1` returns `None`, it means it's impossible to accommodate the extroverts and universals according to their preferences, so the function returns `-1`.
     - Otherwise, it adds the number of tents required for introverts (which is equal to the number of introverts since each introvert must be in a tent alone) to the result from `func_1` and returns this sum.

### Analysis of the Example Test Cases:

- **Test Case 1**: `1 2 3`
  - `func_1(2, 3)` returns `2` because `(2 + 3) / 3` is `1.67`, and the ceiling of `1.67` is `2`.
  - `func_2(1, 2, 3)` returns `1 + 2 = 3`.

- **Test Case 2**: `1 4 1`
  - `func_1(4, 1)` returns `None` because `4 % 3 = 1` and `1 + 1 < 3`.
  - `func_2(1, 4, 1)` returns `-1`.

- **Test Case 3**: `1 4 2`
  - `func_1(4, 2)` returns `2` because `(4 + 2) / 3` is `2`.
  - `func_2(1, 4, 2)` returns `1 + 2 = 3`.

- **Test Case 4**: `1 1 1`
  - `func_1(1, 1)` returns `None` because `1 % 3 = 1` and `1 + 1 < 3`.
  - `func_2(1, 1, 1)` returns `-1`.

- **Test Case 5**: `1 3 2`
  - `func_1(3, 2)` returns `1` because `3 / 3` is `1`.
  - `func_2(1, 3, 2)` returns `1 + 1 = 2`.

- **Test Case 6**: `19 7 18`
  - `func_1(7, 18)` returns `8` because `(7 + 18) / 3` is `8.33`, and the ceiling of `8.33` is `9`.
  - `func_2(19, 7, 18)` returns `19 + 9 = 28`.

- **Test Case 7**: `0 0 0`
  - `func_1(0, 0)` returns `0`.
  - `func_2(0, 0, 0)` returns `0 + 0 = 0`.

- **Test Case 8**: `7 0 0`
  - `func_1(0, 0)` returns `0`.
  - `func_2(7, 0, 0)` returns `7 + 0 = 7`.

- **Test Case 9**: `0 24 0`
  - `func_1(24, 0)` returns `8` because `24 / 3` is `8`.
  - `func_2(0, 24, 0)` returns `0 + 8 = 8`.

- **Test Case 10**: `1000000000 1000000000 1000000000`
  - `func_1(1000000000, 1000000000)` returns `666666667` because `(1000000000 + 1000000000) / 3` is `666666666.67`, and the ceiling of `666666666.67` is `666666667`.
  - `func_2(1000000000, 1000000000, 1000000000)` returns `1000000000 + 666666667 = 1666666667`.

### Conclusion:
The program correctly handles the given problem constraints and produces the expected results for the provided test cases.

**Correctness: True**