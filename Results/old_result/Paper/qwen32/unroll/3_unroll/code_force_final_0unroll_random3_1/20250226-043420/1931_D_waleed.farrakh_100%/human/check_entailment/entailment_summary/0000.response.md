### Reasoning:

To determine if the program is correct, we need to ensure that the functions `func_1` and `func_2` together satisfy the problem requirements.

1. **Function `func_2`**:
   - This function reads the input from standard input, parses it into test cases, and then calls `func_1` to process these test cases.
   - It correctly reads the number of test cases `t`, and for each test case, it reads `n`, `x`, `y`, and the array `arr`.
   - It then passes the test cases to `func_1` and prints the results.

2. **Function `func_1`**:
   - This function processes each test case to count the number of "beautiful" pairs.
   - It uses a dictionary `freq` to keep track of the frequency of pairs of remainders `(rx, ry)` where `rx` is the remainder of `-a % x` and `ry` is the remainder of `a % y`.
   - For each element `a` in the array, it calculates the remainders `rx` and `ry`.
   - If the pair `(rx, ry)` has been seen before, it adds the frequency of this pair to the count of beautiful pairs.
   - It then updates the frequency of the current pair `(a % x, a % y)` in the dictionary.
   - The function returns the count of beautiful pairs for each test case.

### Verification:

- The calculation of `rx` as `(-a % x + x) % x` ensures that the remainder is always non-negative, which is consistent with the problem's requirement.
- The logic of checking if `(rx, ry)` is in `freq` and updating the count ensures that we are correctly counting pairs where both conditions (divisibility by `x` and `y`) are satisfied.
- The use of a dictionary to keep track of frequencies allows the function to efficiently count the pairs in linear time relative to the size of the array.

### Conclusion:

Both functions work together to correctly solve the problem as described. The input parsing and test case handling in `func_2` are correct, and the logic for counting beautiful pairs in `func_1` is also correct.

### Correctness:

Correctness: **True**