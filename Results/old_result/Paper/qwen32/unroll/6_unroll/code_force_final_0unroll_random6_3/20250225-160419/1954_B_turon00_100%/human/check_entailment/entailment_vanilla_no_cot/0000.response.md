Correctness: **False**

The given program does not correctly determine the minimum number of elements that need to be removed to make the array stop being beautiful. The logic in the program is flawed because it only considers contiguous segments of the same number and does not properly account for the rules of the operation allowed to maintain the "beautiful" property of the array.

The correct approach involves checking the longest contiguous segment of the same number and determining if removing elements from outside this segment can make the array stop being beautiful. The provided program does not handle this correctly and may incorrectly return -1 in cases where elements can be removed to break the beautiful property.

Here is a corrected version of the program:

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().strip().split()))
        
        # Find the longest contiguous segment of the same number
        max_len = 0
        current_len = 1
        
        for i in range(1, n):
            if a[i] == a[i - 1]:
                current_len += 1
            else:
                max_len = max(max_len, current_len)
                current_len = 1
        max_len = max(max_len, current_len)
        
        # If the entire array is the same, we cannot make it non-beautiful by removing elements
        if max_len == n:
            print(-1)
        else:
            print(n - max_len)

func()
```

This corrected version finds the longest contiguous segment of the same number and calculates the minimum number of elements to remove by subtracting the length of this segment from the total length of the array. If the entire array is the same, it returns -1.