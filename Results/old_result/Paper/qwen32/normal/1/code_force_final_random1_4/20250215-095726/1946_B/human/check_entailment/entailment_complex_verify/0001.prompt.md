
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
You have an array a of n integers.

You perform exactly k operations on it. In one operation, you select any
contiguous subarray of the array a (possibly empty) and insert the sum of this
subarray anywhere in the array.

Your task is to find the maximum possible sum of the array after k such
operations.

As this number can be very large, output the answer modulo 10^9 + 7 .

Reminder: the remainder of a number x modulo p is the smallest non-negative y
such that there exists an integer q and x = p \cdot q + y .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains two integers n and k (1 \le n, k \le
2 \cdot 10^5 ) — the length of the array a and the number of operations,
respectively.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n
(-10^9 \le a_i \le 10^9 ) — the array a itself.

It is guaranteed that the sum of the values of n and k for all test cases does
not exceed 2 \cdot 10^5 .

Output

For each test, output a single integer — the maximum sum of the array that can
be obtained after k operations modulo 10^9 + 7 .

Example

Input

    12
    
    2 2
    
    -4 -7
    
    3 3
    
    2 2 8
    
    1 7
    
    7
    
    5 1
    
    4 -2 8 -12 9
    
    7 4
    
    8 14 -9 6 0 -1 3
    
    7 100
    
    5 3 -8 12 -5 -9 3
    
    6 1000
    
    -1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000
    
    2 1
    
    1000000000 8
    
    5 4
    
    0 0 0 0 0
    
    6 10
    
    48973 757292 58277 -38574 27475 999984
    
    7 1
    
    -1000 1000 -1000 1000 -1000 1000 -1000
    
    10 10050
    
    408293874 -3498597 7374783 295774930 -48574034 26623784 498754833 -294875830 283045804 85938045

Output

    999999996
    96
    896
    17
    351
    716455332
    42
    2
    0
    897909241
    0
    416571966
    
Note

In the first test case, it is advantageous to take an empty subarray of the
array twice and insert the sum of the empty subarray (zero) anywhere, then the
sum of the resulting array will be (-4) + (-7) + 0 + 0 = -11 , modulo 10^9 + 7
this is 999\,999\,996 .

In the second test case, it is advantageous to take the sum of the entire
array three times and place it anywhere in the array, then one of the possible
sequences of actions: [2, 2, 8 ] \rightarrow [2, 2, 8, 12 ] \rightarrow [2, 2,
8, 12, 24 ] \rightarrow [2, 2, 8, 12, 24, 48 ], the sum of the final array is
2 + 2 + 8 + 12 + 24 + 48 = 96 .

In the fourth test case, it is advantageous to take a subarray of the array
consisting of the first three numbers (i.e. consisting of the numbers 4, -2
and 8 ) and insert its sum at the beginning of the array, thereby obtaining
the array [10, 4, -2, 8, -12, 9 ], the sum of this array is 17 .

In the seventh test case, it will always be advantageous for us to take an
empty subarray of the array. In this case, the sum of the resulting array will
not differ from the sum of the original. The answer will be the sum of the
original array, taken modulo — 42 , because (-6 \cdot (10^9 + 7) + 42 =
-6\,000\,000\,000) .

- Program: 
def func():
    t = int(input())
    for j in range(t):
        b = input().split()
        n = int(b[0])
        k = int(b[1])
        l = list(map(int, input().split()))
        suf = []
        suf.append(0)
        for i in range(n):
            suf.append(suf[i] + l[i])
        smin = [0]
        for i in range(n):
            if suf[i + 1] < smin[i]:
                smin.append(suf[i + 1])
            else:
                smin.append(smin[i])
        sm = -111
        for i in range(n + 1):
            if suf[i] - smin[i] > sm or sm == -111:
                sm = suf[i] - smin[i]
        sm = 2 ** k * sm - sm
        sm += suf[n]
        if sm < 0:
            a = abs(sm) // (10 ** 9 + 7)
            sm += (a + 1) * (10 ** 9 + 7)
        else:
            sm = sm % (10 ** 9 + 7)
        print(sm)



- Annotated Code: 
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 10^4. For each test case, n and k are integers such that 1 ≤ n, k ≤ 2 · 10^5, and a is a list of n integers where -10^9 ≤ a_i ≤ 10^9. The sum of the values of n and k for all test cases does not exceed 2 · 10^5.
def func():
    t = int(input())
    for j in range(t):
        b = input().split()
        
        n = int(b[0])
        
        k = int(b[1])
        
        l = list(map(int, input().split()))
        
        suf = []
        
        suf.append(0)
        
        for i in range(n):
            suf.append(suf[i] + l[i])
        
        smin = [0]
        
        for i in range(n):
            if suf[i + 1] < smin[i]:
                smin.append(suf[i + 1])
            else:
                smin.append(smin[i])
        
        sm = -111
        
        for i in range(n + 1):
            if suf[i] - smin[i] > sm or sm == -111:
                sm = suf[i] - smin[i]
        
        sm = 2 ** k * sm - sm
        
        sm += suf[n]
        
        if sm < 0:
            a = abs(sm) // (10 ** 9 + 7)
            sm += (a + 1) * (10 ** 9 + 7)
        else:
            sm = sm % (10 ** 9 + 7)
        
        print(sm)
        
    #State: A sequence of integers, each representing the result of processing one test case.
#Overall this is what the function does:The function processes multiple test cases, each consisting of integers `n` and `k`, and a list `a` of `n` integers. For each test case, it calculates a specific value based on the elements of the list and the given integers, applies transformations involving `k`, and outputs the result modulo \(10^9 + 7\).


Beggining of Original Assessment: 
Let's analyze the given Python program step-by-step to determine if it correctly solves the problem described.

### Problem Analysis

The goal is to maximize the sum of an array `a` after performing `k` operations where each operation involves selecting a contiguous subarray, computing its sum, and inserting this sum anywhere in the array. The final result should be computed modulo \(10^9 + 7\).

### Key Observations

1. **Maximizing Subarray Sum**: To maximize the sum of the array after `k` operations, we need to identify the maximum possible subarray sum that can be repeatedly added.
2. **Prefix and Suffix Sums**: The program calculates suffix sums (`suf`) and minimum prefix sums (`smin`) to determine the maximum subarray sum efficiently using Kadane's algorithm.
3. **Doubling the Maximum Subarray Sum**: The maximum subarray sum (`sm`) is then doubled `k` times and subtracted once to account for the initial state before any operations.
4. **Modulo Operation**: Finally, the result is adjusted to ensure it falls within the range defined by the modulo \(10^9 + 7\).

### Program Analysis

1. **Reading Input**: The program reads multiple test cases, each with an array `a` of length `n` and `k` operations.
2. **Suffix Sum Calculation**: It calculates the suffix sums of the array, which helps in determining the cumulative sums up to each position.
3. **Minimum Prefix Sum Calculation**: It also calculates the minimum prefix sums, which helps in identifying the smallest cumulative sum encountered so far.
4. **Maximum Subarray Sum Calculation**: Using the suffix and minimum prefix sums, the program identifies the maximum subarray sum (`sm`).
5. **Doubling the Maximum Subarray Sum**: The program computes the potential new sum by doubling the maximum subarray sum `k` times and subtracting the original maximum subarray sum.
6. **Adjusting for Modulo**: The final sum is adjusted to ensure it is within the range defined by the modulo \(10^9 + 7\).

### Issues in the Program

1. **Incorrect Doubling Mechanism**: The line `sm = 2 ** k * sm - sm` is incorrect. This line attempts to double the maximum subarray sum `k` times, but it does not correctly account for the repeated addition of the maximum subarray sum. Instead, it should compute `(2 ** k - 1) * sm` to account for the `k` additions of the maximum subarray sum.
2. **Handling Negative Sums**: The program does not handle negative sums correctly. If the maximum subarray sum is negative, it should not be used to increase the sum of the array. Instead, the sum of the entire array should be considered if all subarray sums are negative.
3. **Modulo Operation**: While the program includes a modulo operation, it does not handle negative results correctly. The modulo operation should ensure the result is non-negative.

### Corrected Approach

1. **Calculate Maximum Subarray Sum**: Use Kadane's algorithm to find the maximum subarray sum.
2. **Compute New Sum**: If the maximum subarray sum is positive, compute the new sum as `(2 ** k - 1) * sm + suf[n]`. Otherwise, use the sum of the entire array.
3. **Apply Modulo**: Ensure the final result is within the range defined by the modulo \(10^9 + 7\).

### Conclusion

Given the issues identified, the program is not correct as it stands. Therefore, the correctness of the given program is:

Correctness: **False**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

