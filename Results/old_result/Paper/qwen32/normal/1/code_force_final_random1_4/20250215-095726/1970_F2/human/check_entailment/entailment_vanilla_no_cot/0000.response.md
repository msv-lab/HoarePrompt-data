Correctness: **False**

There are several issues with the provided code:

1. **Incorrect handling of catching the Quaffle**: The line `quidditch[1] == mo[0]` should be `quidditch[1] = mo[0]`. The current code is performing a comparison instead of an assignment.

2. **Incorrect logic for throwing the Quaffle**: The code checks if the player's position is in the goals for both teams (`if players[mo[0]] in goals['R']:` and `if players[mo[0]] in goals['B']:`). However, these conditions will never be true because `players[mo[0]]` returns a tuple representing the player's position, and `goals['R']` and `goals['B']` are lists of tuples representing the positions of the goals. Instead, the code should check if the player's position matches any of the goal positions.

3. **Incorrect handling of scoring in the wrong goal**: The code does not handle the scenario where a player scores in their own goal. It should check if the player's team matches the goal's team before updating the score.

4. **Incorrect placement of the Quaffle after scoring**: The code incorrectly places the Quaffle at the player's position if they scored in their own goal. It should always place the Quaffle at the middle of the field after a goal is scored.

5. **Handling of the Bludger**: The code correctly identifies when a player is eliminated by the Bludger, but it does not handle the case where the Bludger itself moves. The Bludger should also be able to move according to the input, and if it moves to a cell occupied by a player, that player should be eliminated.

Here is a corrected version of the code addressing these issues:

```python
(n, m) = [int(x) for x in input().split()]
players = dict()
goals = {'B': [], 'R': []}
mouvements = {'L': (-1, 0), 'R': (1, 0), 'U': (0, -1), 'D': (0, 1)}
middle = ((m + 1) // 2, (n + 1) // 2)
quidditch = [middle, '']
(pointsb, pointsr) = (0, 0)
for y in range(n):
    s = input().split()
    for x in range(m):
        if s[x] == '..':
            continue
        elif s[x] == '.Q':
            quidditch[0] = (x, y)
        elif s[x] == 'RG':
            goals['R'].append((x, y))
        elif s[x] == 'BG':
            goals['B'].append((x, y))
        else:
            players[s[x]] = (x, y)
moves = int(input())
for i in range(moves):
    mo = input().split()
    if mo[0] == '.Q':
        quidditch[0] = func_1(quidditch[0], mouvements[mo[1]])
    elif mo[0] == '.B':
        players[mo[0]] = func_1(players[mo[0]], mouvements[mo[1]])
        elimines = []
        for (k, v) in players.items():
            if k != '.B' and v == players['.B']:
                elimines.append(k)
        elimines.sort()
        for c in elimines:
            print(i, c, 'ELIMINATED')
            if quidditch[1] == c:
                quidditch = [players[c], '']
            del players[c]
    elif mo[1] in 'ULDR':
        players[mo[0]] = func_1(players[mo[0]], mouvements[mo[1]])
        if '.B' in players and players[mo[0]] == players['.B']:
            print(i, mo[0], 'ELIMINATED')
            if quidditch[1] == mo[0]:
                quidditch = [players[mo[0]], '']
            del players[mo[0]]
    elif mo[1] == 'C':
        quidditch[1] = mo[0]
    elif mo[1] == 'T':
        quidditch[1] = ''
        pos = players[mo[0]]
        if pos in goals['R']:
            if mo[0][0] == 'B':
                pointsb += 1
                print(i, 'BLUE GOAL')
            else:
                pointsr += 1
                print(i, 'RED GOAL')
            quidditch[0] = middle
        elif pos in goals['B']:
            if mo[0][0] == 'R':
                pointsr += 1
                print(i, 'RED GOAL')
            else:
                pointsb += 1
                print(i, 'BLUE GOAL')
            quidditch[0] = middle
print('FINAL SCORE:', pointsr, pointsb)

def func_1(a, b):
    (x, y) = a
    (dx, dy) = b
    return (x + dx, y + dy)
```

This corrected version addresses the issues mentioned above.