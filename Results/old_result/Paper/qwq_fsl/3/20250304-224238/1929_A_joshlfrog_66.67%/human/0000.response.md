Alright, I've got this task to verify the correctness of a given Python program based on a problem description. The program is supposed to maximize the "beauty" of an array after rearranging its elements. The beauty is defined as the sum of (a_i - a_{i-1}) for all i from 2 to n.

First, I need to understand the problem completely. So, Sasha has an array of numbers, and he can rearrange them in any order he wants. The beauty is calculated by taking each pair of consecutive elements in the array and subtracting the previous element from the current one, then summing up all those differences.

Let me think about what this actually means. If I have an array like [a, b, c], the beauty would be (b - a) + (c - b) = c - a. Wait, that simplifies to just the difference between the last and the first element in the array. Is that always the case?

Let me try with a different array, say [1, 2, 3]. The beauty would be (2 - 1) + (3 - 2) = 1 + 1 = 2, which is 3 - 1 = 2. Okay, it seems to hold.

Let me try another one: [5, 3, 7]. Beauty would be (3 - 5) + (7 - 3) = (-2) + 4 = 2, which is 7 - 5 = 2. Again, it's the difference between the last and the first element in the arranged array.

Wait a minute, in the first test case of the example:

Input:

3

2 1 3

Output:

2

According to the program, it's calculating x - y, where x is the maximum value in the array and y is the minimum value in the array. In this case, x = 3 and y = 1, so x - y = 2, which matches the example output.

In the second test case:

Input:

3

69 69 69

Output:

0

Here, x = 69 and y = 69, so x - y = 0, which matches.

Third test case:

Input:

5

100 54 80 43 90

Output:

57

x = 100, y = 43, x - y = 57.

Fourth test case:

Input:

4

3 4 3 3

Output:

1

x = 4, y = 3, x - y = 1.

Fifth test case:

Input:

2

2 1

Output:

1

x = 2, y = 1, x - y = 1.

So, in all these examples, the program is correctly calculating x - y and producing the expected output.

Now, is this always the case? Does the beauty of the array always equal the difference between the maximum and minimum values in the array, regardless of how you arrange the elements?

Let me think about it more generally. Suppose I have an array of n elements. I can arrange them in any order. Let's say I arrange them in such a way that the array is sorted in ascending order: a1 ≤ a2 ≤ a3 ≤ ... ≤ an.

Then, the beauty would be (a2 - a1) + (a3 - a2) + ... + (an - a_{n-1}) = an - a1.

Alternatively, if I arrange them in descending order: a1 ≥ a2 ≥ a3 ≥ ... ≥ an.

Then, the beauty would be (a2 - a1) + (a3 - a2) + ... + (an - a_{n-1}) = an - a1.

Wait, it's the same as above.

Wait, in both cases, it's an - a1, which is the difference between the maximum and minimum values.

But is there a way to arrange the array to get a larger beauty?

Let me try to think of an arrangement that might give a larger sum.

Take the array [1, 2, 3]. As we saw, any arrangement gives beauty = 2.

But what if I arrange it as [2, 1, 3]? Then beauty = (1 - 2) + (3 - 1) = (-1) + 2 = 1, which is less than 2.

Or [3, 1, 2]: beauty = (1 - 3) + (2 - 1) = (-2) + 1 = -1, which is even less.

Or [1, 3, 2]: beauty = (3 - 1) + (2 - 3) = 2 + (-1) = 1, still less than 2.

So, in this case, the maximum beauty is indeed 2, which is an - a1 = 3 - 1 = 2.

Another example: [5, 3, 7].

Arranged in ascending order: [3, 5, 7], beauty = (5 - 3) + (7 - 5) = 2 + 2 = 4, which is 7 - 3 = 4.

But earlier I calculated it as 2. Wait, in the earlier calculation, I had [5, 3, 7], beauty = 2, but according to this, it should be 4.

Wait, in the earlier calculation, I think I made a mistake. Let me check the earlier calculation.

Wait, in the earlier part, I had [5, 3, 7], beauty = (3 - 5) + (7 - 3) = (-2) + 4 = 2.

But if I arrange it as [3, 5, 7], beauty = (5 - 3) + (7 - 5) = 2 + 2 = 4, which is better.

Wait, but the program is calculating x - y, which would be 7 - 3 = 4, which matches this arrangement.

So, the maximum beauty is indeed 4 in this case.

Wait, but in the earlier calculation, I thought it was 2, but that was for a different arrangement.

So, the program is calculating x - y, which is the maximum possible beauty, achieved by arranging the array in ascending or descending order.

Wait, but in the problem statement, it says "rearrange its elements in any way", and the beauty is the sum of (a_i - a_{i-1}) for i from 2 to n.

And in the example, for [2, 1, 3], the output is 2, which matches 3 - 1 = 2.

Similarly, for [69, 69, 69], it's 0, which is 69 - 69 = 0.

For [100, 54, 80, 43, 90], it's 100 - 43 = 57.

For [3, 4, 3, 3], it's 4 - 3 = 1.

For [2, 1], it's 2 - 1 = 1.

So, in all these cases, the program is correctly calculating x - y, which seems to be the maximum beauty.

But is there any case where this doesn't hold?

Let me think about an array with negative numbers.

Suppose the array is [ -1, -2, -3 ].

If I arrange it as [ -3, -2, -1 ], beauty = ( -2 - (-3) ) + ( -1 - (-2) ) = 1 + 1 = 2, which is -1 - (-3) = 2.

If I arrange it as [ -1, -2, -3 ], beauty = ( -2 - (-1) ) + ( -3 - (-2) ) = -1 + (-1) = -2, which is worse.

So, the maximum beauty is 2, which is x - y = -1 - (-3) = 2.

Another case: [ -1, 0, 1 ].

Arranged as [ -1, 0, 1 ], beauty = (0 - (-1)) + (1 - 0) = 1 + 1 = 2, which is 1 - (-1) = 2.

Arranged as [1, 0, -1], beauty = (0 - 1) + (-1 - 0) = (-1) + (-1) = -2, which is worse.

So, again, x - y gives the maximum beauty.

What if the array has duplicates?

For example, [1, 1, 1, 2].

Arranged as [1, 1, 1, 2], beauty = (1 - 1) + (1 - 1) + (2 - 1) = 0 + 0 + 1 = 1, which is 2 - 1 = 1.

Arranged as [2, 1, 1, 1], beauty = (1 - 2) + (1 - 1) + (1 - 1) = (-1) + 0 + 0 = -1, which is worse.

So, again, x - y is the maximum beauty.

What if the array is already in sorted order?

For example, [1, 2, 3, 4, 5].

Arranged as is, beauty = (2 - 1) + (3 - 2) + (4 - 3) + (5 - 4) = 1 + 1 + 1 + 1 = 4, which is 5 - 1 = 4.

So, again, x - y is the maximum beauty.

What if the array is sorted in descending order?

For example, [5, 4, 3, 2, 1].

Beauty = (4 - 5) + (3 - 4) + (2 - 3) + (1 - 2) = (-1) + (-1) + (-1) + (-1) = -4, which is worse than 5 - 1 = 4.

So, arranging in ascending order gives the maximum beauty.

Wait, but the program is just calculating x - y, without needing to arrange the array in any specific way, because it's realizing that the maximum beauty is simply x - y.

Is this always the case?

Let me see.

Suppose I have an array with both positive and negative numbers.

For example, [ -2, 0, 3, 5, -1 ].

Arranged in ascending order: [ -2, -1, 0, 3, 5 ], beauty = (-1 - (-2)) + (0 - (-1)) + (3 - 0) + (5 - 3) = 1 + 1 + 3 + 2 = 7, which is 5 - (-2) = 7.

Arranged in descending order: [5, 3, 0, -1, -2], beauty = (3 - 5) + (0 - 3) + (-1 - 0) + (-2 - (-1)) = (-2) + (-3) + (-1) + (-1) = -7, which is worse.

Another arrangement: [ -2, 5, -1, 0, 3 ], beauty = (5 - (-2)) + (-1 - 5) + (0 - (-1)) + (3 - 0) = 7 + (-6) + 1 + 3 = 5, which is less than 7.

Another arrangement: [ -1, 0, 3, 5, -2 ], beauty = (0 - (-1)) + (3 - 0) + (5 - 3) + (-2 - 5) = 1 + 3 + 2 + (-7) = -1, which is worse.

So, the maximum beauty is indeed x - y = 5 - (-2) = 7.

Therefore, it seems that no matter how you arrange the array, the maximum beauty you can achieve is x - y, where x is the maximum value and y is the minimum value in the array.

This is because when you arrange the array in ascending order, the sum of (a_i - a_{i-1}) for i from 2 to n collapses to a_n - a_1, which is x - y.

Any other arrangement may give a lower or equal value, but never higher than x - y.

Therefore, the program is correct in calculating x - y as the maximum beauty for each test case.

Given that, I can conclude that the program is correct.

But to be thorough, let's check the constraints.

Constraints:

- t (number of test cases): 1 ≤ t ≤ 500

- n (length of array): 2 ≤ n ≤ 100

- array elements: 1 ≤ a_i ≤ 10^9

The program reads t, then for each test case, reads n and then the array.

It initializes x to 0 and y to 100000000.

Then, for each element in the array, it updates x to be the maximum value found so far and y to be the minimum value found so far.

Finally, it prints x - y.

This seems correct.

Edge cases to consider:

1. All elements are the same:

   - Input: 3

     69 69 69

   - Output: 0

   - As in the example, which is correct.

2. Array with minimum and maximum values:

   - Input: 2

     1 1000000000

   - Output: 999999999

3. Array with negative and positive numbers:

   - Input: 4

     -100 0 100 200

   - Output: 200 - (-100) = 300

4. Array with duplicates:

   - Input: 5

     5 5 5 5 5

   - Output: 0

5. Array with only two elements:

   - Input: 2

     1 2

   - Output: 1

All these seem to be handled correctly by the program.

Therefore, I can confidently say that the program is correct.

**Final Answer**

\[ \boxed{\text{Correctness: } \text{True}} \]