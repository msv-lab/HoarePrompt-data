Alright, I have this task to verify the correctness of a given Python program based on a problem description. If the program meets the requirements for every potential case, I should print "True"; otherwise, "False". I need to think step-by-step and consider if there are any edge cases or scenarios where the program might fail.

First, let's understand the problem. We have n containers of water, each containing a certain amount of water. The sum of all water amounts is divisible by n, meaning the average amount per container is an integer. My task is to determine whether it's possible to make the amount of water in all containers the same by only pouring water from a container with a lower index to one with a higher index.

So, the operation allowed is pouring any amount of water from container i to container j, where i < j. I can perform this operation any number of times.

The program provided is:

```

def func():

    t = int(input())

    for _ in range(t):

        n = int(input())

        nums = list(map(int, input().strip().split()))

        last = nums[-1]

        curr = 0

        for i in nums:

            if i != 0:

                curr += i - last

        if curr == 0:

            print('YES')

        else:

            print('NO')

```

I need to verify if this program correctly determines whether it's possible to equalize the water in all containers using the allowed operations.

Let's analyze the program step by step.

1. It reads the number of test cases, t.

2. For each test case, it reads n (number of containers) and then the list of a_i (water in each container).

3. It sets `last` to the last element of the list (`nums[-1]`).

4. It initializes `curr` to 0.

5. It iterates through each element in `nums`:

- If the element is not zero, it adds `i - last` to `curr`.

6. If `curr` equals 0, it prints 'YES'; otherwise, it prints 'NO'.

Hmm, this seems a bit simplistic. Let's see if this logic holds up.

First, since the sum of a_i is divisible by n, the target amount for each container is sum(a_i)/n. Let's call this target amount `target`.

The program seems to be trying to adjust the water levels by pouring from lower-indexed containers to higher-indexed ones, but its implementation appears flawed.

Let's consider the third test case from the example:

Input:

5

4 5 2 1 3

According to the note, we can perform the following operations:

- Pour 1 unit from container 1 to container 4: [4-1=3, 5, 2, 1+1=2, 3] → [3,5,2,2,3]

- Pour 1 unit from container 2 to container 3: [3,5-1=4,2+1=3,2,3]

- Pour 1 unit from container 2 to container 4: [3,4-1=3,3,2+1=3,3]

Now, all containers have 3 units.

Let's see what the program does with this input.

n = 5

nums = [4,5,2,1,3]

last = 3

curr = 0

For i in nums:

if i != 0:

curr += i - 3

So:

4 - 3 = 1

5 - 3 = 2

2 - 3 = -1

1 - 3 = -2

3 - 3 = 0 (but since i != 0, it's included)

So curr = 1 + 2 + (-1) + (-2) + 0 = 0

Therefore, it prints 'YES', which matches the expected output.

Another test case:

n=2

a=[1,3]

According to the problem, sum is 4, which is divisible by 2, target is 2.

We need to make both containers have 2.

Possible operations:

- Pour 1 unit from container 1 to container 2: [1-1=0, 3+1=4]

Wait, that's not helpful. We need to pour from a lower index to a higher one, so from 1 to 2.

But after pouring 1 unit from 1 to 2, we get [0,4], which is worse.

We can't pour from 2 to 1 because i < j is required.

So, it's impossible, and the program should print 'NO', which matches the expected output.

Now, let's think about another test case.

Suppose n=3

a=[0,0,0]

Sum is 0, which is divisible by 3.

Target is 0.

All containers already have the target amount, so 'YES'.

According to the program:

last = 0

curr = 0

For i in nums:

i != 0: (none), so curr remains 0

Thus, prints 'YES', which is correct.

Another test case:

n=1

a=[43]

Sum is 43, divisible by 1.

Target is 43.

Already equal, 'YES'.

Program would handle this correctly.

Another test case:

n=4

a=[1,2,3,4]

Sum is 10, which is divisible by 4. Target is 2.5, but since we're dealing with integers and the problem states that the sum is divisible by n, I assume that the target is an integer. Wait, but 10 is not divisible by 4 without a remainder. Wait, but in the problem statement, it says "the sum of a_i is divisible by n", which in this case, 10 is not divisible by 4 since 10/4 = 2.5, which is not an integer. So maybe I need to double-check the problem statement.

Looking back:

"It is guaranteed that the sum of a_i in each test case does not exceed 2⋅10^9. Also, the sum of a_i is divisible by n."

So, sum(a_i) is divisible by n, meaning sum(a_i) % n == 0.

In the earlier test case, sum=10 and n=4, but 10 % 4 == 2, which is not zero. So this test case wouldn't occur because the problem guarantees that sum(a_i) is divisible by n.

Another test case:

n=3

a=[1,1,1]

Sum=3, divisible by 3. Target=1.

Already equal, 'YES'.

Program would handle this correctly.

Another test case:

n=4

a=[2,2,2,2]

Sum=8, divisible by 4. Target=2.

Already equal, 'YES'.

Program would handle this correctly.

Let's think of a case where it's possible to equalize.

n=3

a=[0,3,0]

Sum=3, divisible by 3. Target=1.

Operations:

- Pour from 2 to 1: [0+1=1, 3-1=2, 0]

- Pour from 2 to 3: [1, 2-1=1, 0+1=1]

Now, all have 1. So, 'YES'.

According to the program:

last=0

curr = 0 for i=0 (0-0=0)

       +1 for i=3 (3-0=3)

       +0 for i=0 (0-0=0)

So curr=0+3+0=3 !=0, so it would print 'NO', which is incorrect because it's possible to equalize.

Ah, so here's a case where the program fails.

n=3

a=[0,3,0]

Program outputs 'NO', but it should be 'YES'.

So, Correctness: **False**.

I have found a test case where the program gives the wrong answer.

Therefore, the program is incorrect.

## Final Solution
To solve this problem, we need to determine if it is possible to make the amount of water in all containers the same by only pouring water from a container with a lower index to one with a higher index.

### Approach
1. **Understand the Problem:**
   - We have `n` containers arranged in a line, each containing some units of water.
   - We can pour water from container `i` to container `j` only if `i < j`.
   - The sum of all water in containers is divisible by `n`, ensuring an integer target value for each container.

2. **Key Insight:**
   - The operation allows pouring water only from a left container to a right one.
   - We need to check if we can redistribute the water such that each container ends up with the same amount.

3. **Algorithm:**
   - Calculate the target amount of water each container should have, which is the total sum divided by `n`.
   - Traverse the list of containers, keeping track of the cumulative surplus or deficit from the target.
   - If at any point the cumulative surplus is negative, it means we need more water than what is available from the previous containers, and it's impossible to reach the target.

4. **Implementation:**
   - For each test case, compute the target value.
   - Iterate through the containers, maintaining a running sum of the differences from the target.
   - If the running sum ever becomes negative, output 'NO' for that test case. Otherwise, output 'YES'.

### Solution Code
```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        nums = list(map(int, input().strip().split()))
        target = sum(nums) // n
        surplus = 0
        possible = True
        for num in nums:
            surplus += num - target
            if surplus < 0:
                possible = False
                break
        print('YES' if possible else 'NO')

func()
```

### Explanation
- **Step 1:** Read the number of test cases `t`.
- **Step 2:** For each test case, read `n` and the list of water amounts `nums`.
- **Step 3:** Calculate the target amount of water each container should have.
- **Step 4:** Initialize `surplus` to track the cumulative difference from the target.
- **Step 5:** Iterate through each container:
  - Update `surplus` by adding the difference between the current container's water and the target.
  - If `surplus` becomes negative at any point, it means we cannot fulfill the target, so set `possible` to `False` and break.
- **Step 6:** Print 'YES' if it's possible to equalize the water levels, otherwise 'NO'.

This approach ensures that we are only pouring water from left to right and that we can achieve the target distribution without any intermediate deficits.