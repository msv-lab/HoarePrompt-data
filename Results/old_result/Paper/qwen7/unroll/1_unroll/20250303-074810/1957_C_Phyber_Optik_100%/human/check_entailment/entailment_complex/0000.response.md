Reasoning:

1. **Problem Understanding**: The problem requires calculating the number of different final configurations of rooks on an \(n \times n\) chessboard after \(k\) moves, where each move is mirrored by the computer unless the move is along the diagonal. The solution uses dynamic programming to precompute the number of configurations for smaller board sizes up to \(300,000\).

2. **Dynamic Programming Initialization**: The function `func_1` initializes the DP array `dp` with base cases for \(dp[1] = 1\) and \(dp[2] = 3\). It then iterates through values from 3 to \(n\) and calculates the number of configurations using the recurrence relation \(dp[i] = (dp[i - 1] + 2 \times (i - 1) \times dp[i - 2]) \mod 1000000007\).

3. **Main Logic**: In the main part of the code, for each test case, it reads the board size \(n\) and the number of moves \(k\). It then collects the positions of the rooks placed so far in a set called `invalid`. The number of valid positions left on the board is \(n - |invalid|\). The final number of configurations is derived from the precomputed `dp` array using `dp[n - len(invalid)]`.

4. **Edge Cases**: The code handles edge cases correctly by ensuring that the number of configurations is at least 1 even if all positions are invalid.

5. **Modulo Operation**: The use of modulo \(1000000007\) ensures that the result fits within standard integer limits and handles large numbers appropriately.

Given the above analysis, the provided code appears to correctly implement the logic required to solve the problem as described.

Correctness: **True**