
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
You are given two integers n and k . Find a sequence a of non-negative
integers of size at most 25 such that the following conditions hold.

  * There is no subsequence of a with a sum of k . 
  * For all 1 \le v \le n where v \ne k , there is a subsequence of a with a sum of v . 

A sequence b is a subsequence of a if b can be obtained from a by the deletion
of several (possibly, zero or all) elements, without changing the order of the
remaining elements. For example, [5, 2, 3] is a subsequence of [1, 5, 7, 8, 2,
4, 3] .

It can be shown that under the given constraints, a solution always exists.

Input

The first line of the input contains a single integer t (1 \le t \le 1000 ) —
the number of test cases. The description of the test cases follows.

Each test case consists of a single line containing two integers n and k (2
\le n \le 10^6 , 1 \le k \le n ) — the parameters described above.

It is guaranteed that the sum of n over all test cases does not exceed 10^7 .

Output

The first line of output for each test case should contain a single integer m
(1 \le m \le 25 ) — the size of your chosen sequence.

The second line of output for each test case should contain m integers a_i (0
\le a_i \le 10^9 ) — the elements of your chosen sequence.

If there are multiple solutions, print any.

Example

Input

    5
    
    2 2
    
    6 1
    
    8 8
    
    9 3
    
    10 7

Output

    1
    1
    5
    2 3 4 5 6
    7
    1 1 1 1 1 1 1
    4
    7 1 4 1
    4
    1 2 8 3
    
Note

In the first example, we just need a subsequence that adds up to 1 , but not
one that adds up to 2 . So the array a=[1] suffices.

In the second example, all elements are greater than k=1 , so no subsequence
adds up to 1 . Every other integer between 1 and n is present in the array, so
there is a subsequence of size 1 adding up to each of those numbers.

# Annotated Functions:
import bisect
import collections
import heapq
import math
import sys
from sys import maxsize
import heapq

p2D = lambda x: print(*x, sep='\n')
if __name__ == '__main__':
    func_15()

#Function 1:
#State of the program right berfore the function call: None of the variables in the function signature are provided in the given code snippet. The function does not take any arguments and reads input from stdin using `sys.stdin.buffer.readline()`.
def func_1():
    return int(sys.stdin.buffer.readline())
    #The program returns an integer read from standard input.
#Overall this is what the function does:The function reads an integer from standard input and returns it.

#Function 2:
#State of the program right berfore the function call: None of the variables `t`, `n`, and `k` are mentioned in the provided function signature. The function `func_2()` reads input from standard input but does not take any arguments.
def func_2():
    return map(int, sys.stdin.buffer.readline().split())
    #The program returns a map object containing integer values split from the first line of input provided via standard input.
#Overall this is what the function does:The function reads a line of input from standard input, splits it into individual integer values, and returns a map object containing these integers.

#Function 3:
#State of the program right berfore the function call: None of the variables in the function signature are provided in the given code snippet. The function `func_3` reads input from standard input (stdin) and returns a list of integers. The input format is expected to be a single line containing space-separated integers representing the values of `t`, `n`, and `k` for each test case.
def func_3():
    return list(map(int, sys.stdin.buffer.readline().split()))
    #The program returns a list of integers read from standard input, which is a single line containing space-separated integers representing the values of t, n, and k for each test case.
#Overall this is what the function does:The function reads a single line of space-separated integers from standard input, converts them to a list of integers, and returns this list. The list contains the values of `t`, `n`, and `k` for each test case.

#Function 4:
#State of the program right berfore the function call: rows_number is a positive integer such that 1 <= rows_number <= 25.
def func_4(rows_number):
    return [func_3() for _ in range(rows_number)]
    #A list of length `rows_number` containing the results of calling `func_3()` for each element in the range from 0 to `rows_number-1`
#Overall this is what the function does:The function accepts a positive integer `rows_number` (between 1 and 25) and returns a list of length `rows_number`. Each element in the returned list is the result of calling `func_3()` with the corresponding index (ranging from 0 to `rows_number-1`).

#Function 5:
#State of the program right berfore the function call: None of the variables in the provided function contribute to solving the problem described. The function `func_5()` reads a line from standard input and returns it after stripping the trailing newline, but it does not take any parameters related to the problem.
def func_5():
    return sys.stdin.buffer.readline().rstrip()
    #The program reads a line from standard input, strips the trailing newline character, and returns it.
#Overall this is what the function does:The function reads a line from standard input, removes the trailing newline character, and returns the modified line.

#Function 6:
#State of the program right berfore the function call: None of the variables in the provided function signature match those in the problem description. The function `func_6()` reads a line from standard input, decodes it from bytes to a string, and returns it after stripping the trailing newline. However, the function does not take any arguments related to the problem, such as `t`, `n`, or `k`.
def func_6():
    return sys.stdin.buffer.readline().rstrip().decode()
    #The program reads a line from standard input, decodes it from bytes to a string, and removes the trailing newline before returning it.
#Overall this is what the function does:The function reads a line from standard input, decodes it from bytes to a string, and removes the trailing newline before returning the resulting string.

#Function 7:
#State of the program right berfore the function call: t is an integer such that 1 <= t <= 1000, and for each test case, n and k are integers satisfying 2 <= n <= 10^6 and 1 <= k <= n.
def func_7():
    return [int(i) for i in input().split()]
    #The program returns a list of integers, where each integer is obtained from the input split by spaces. The length of the list is determined by the number of integers provided in the input.
#Overall this is what the function does:The function reads a line of space-separated integers from the standard input and returns them as a list. The length of the list corresponds to the number of integers provided in the input.

#Function 8:
#State of the program right berfore the function call: rows is a positive integer such that 1 <= rows <= 25.
def func_8(rows):
    return [func_7() for _ in range(rows)]
    #A list of length rows, where each element is the result of calling func_7()
#Overall this is what the function does:The function `func_8` accepts a positive integer `rows` (where 1 ≤ rows ≤ 25) and returns a list of length `rows`. Each element in the list is the result of calling another function `func_7()` one time for each element in the list.

#Function 9:
#State of the program right berfore the function call: None of the variables in the function signature are used within the function. The function does not take any parameters and its purpose seems unrelated to solving the given problem.
def func_9():
    return input()
    #The program returns the user's input from the input() function call.
#Overall this is what the function does:The function accepts no parameters and returns the user's input from the `input()` function call.

#Function 10:
#State of the program right berfore the function call: None of the variables in the function signature are used within the function. The function simply returns an integer input from the user.
def func_10():
    return int(input())
    #The program returns an integer input from the user
#Overall this is what the function does:The function accepts no parameters and returns an integer input provided by the user.

#Function 11:
#State of the program right berfore the function call: None of the variables in the function signature are provided in the code snippet. The function does not take any parameters.
def func_11():
    return input().split()
    #The program returns a list of strings obtained by splitting the input received from the user.
#Overall this is what the function does:The function does not accept any parameters and returns a list of strings obtained by splitting a string input received from the user.

#Function 12:
#State of the program right berfore the function call: d is a dictionary where keys are integers and values are lists of integers; processing is a list of zeros and ones with the same length as the maximum value in d.keys() + 1; da is an integer key from the dictionary d; rank is a list of integers with the same length as the maximum value in d.keys() + 1.
def func_12(d, processing, da, rank):
    tmp = 10 ** 9
    if (len(d[da]) == 1) :
        return 1
        #The program returns 1
    #State: Postcondition: `tmp` is 1000000000, `d` is a dictionary where keys are integers and values are lists of integers, `processing` is a list of zeros and ones with the same length as the maximum value in `d.keys()` + 1, `da` is an integer key from the dictionary `d`, `rank` is a list of integers with the same length as the maximum value in `d.keys()` + 1, and the length of `d[da]` is greater than 1.
    for di in d[da]:
        if processing[di - 1] == 0:
            processing[di - 1] = 1
            tmp = min(tmp, func_12(d, processing, di, rank))
            processing[di - 1] = 0
        
    #State: `tmp` is updated to the minimum value of `func_12(d, processing, di, rank)` for all `di` in `d[da]` where `processing[di - 1]` is 0, `d` remains unchanged, `processing` is modified such that for each `di` in `d[da]` where `processing[di - 1]` was 0, it is set to 1 during the loop and then reset to 0 after the loop, `da` remains unchanged, `rank` remains unchanged, and the length of `d[da]` is greater than 1.
    rank[da - 1] = tmp + 1
    return tmp + 1
    #The program returns a value which is `tmp + 1`, where `tmp` is the minimum value of `func_12(d, processing, di, rank)` for all `di` in `d[da]` where `processing[di - 1]` is 0.
#Overall this is what the function does:The function accepts a dictionary `d` where keys are integers and values are lists of integers, a list `processing` of zeros and ones with the same length as the maximum value in `d.keys() + 1`, an integer `da` which is a key from the dictionary `d`, and a list `rank` of integers with the same length as the maximum value in `d.keys() + 1`. It returns 1 if the length of `d[da]` is 1. Otherwise, it recursively calculates the minimum value of `func_12(d, processing, di, rank)` for all `di` in `d[da]` where `processing[di - 1]` is 0, updates `tmp` to this minimum value, and sets `rank[da - 1]` to `tmp + 1`. The function ultimately returns `tmp + 1`.

#Function 13:
#State of the program right berfore the function call: a and b are non-negative integers such that b != 0 and a >= b.
def func_13(a, b):
    if (b == 0) :
        x = 1
        y = 0
        return x, y, a
        #The program returns (1, 0, a)
    #State: a and b are non-negative integers such that b != 0 and a >= b
    x, y, g = func_13(b, a % b)
    return y, x - a // b * y, g
    #The program returns y, x - a // b * y, and g, where y, x, and g are the results of func_13(b, a % b)
#Overall this is what the function does:The function accepts two non-negative integers, `a` and `b`, where `b` is not zero. It returns a tuple containing three values: either `(1, 0, a)` when `b` is zero (which cannot happen due to the precondition), or `y, x - a // b * y, and g`, where `y, x, and g` are the results of recursively calling itself with `b` and `a % b`. The function ultimately computes and returns values related to the greatest common divisor (GCD) of `a` and `b` using the Euclidean algorithm.

#Function 14:
#State of the program right berfore the function call: n and k are integers such that 2 ≤ n ≤ 10^6 and 1 ≤ k ≤ n.
def func_14():
    n, k = func_7()
    b = bin(n)[2:]
    l = len(b)
    if (k == 1) :
        if (n == 2) :
            return '1\n2'
            #The program returns the string '1\n2'
        #State: `n` is an integer between 2 and \(10^6\), `k` is 1, `k` is an integer between 1 and `n`, `b` is a binary string representation of `n` without the '0b' prefix, `l` is the length of `b`, and `n` is not equal to 2
        ans = [2, 3]
        for i in range(2, l):
            ans.append(2 ** i)
            
        #State: Output State: `n` is an integer between 2 and \(10^6\), `k` is 1, `b` is a binary string representation of `n` without the '0b' prefix, `l` is the length of `b`, `ans` is `[2, 3, 4, 8, 16, ..., 2^(l-1)]`, and `n` is not equal to 2.
        #
        #Explanation: The loop iterates from `i = 2` to `i = l-1` (since `range(2, l)` generates numbers starting from 2 up to but not including `l`). For each iteration, it appends `2 ** i` to the list `ans`. Therefore, `ans` will contain `[2, 3]` plus all powers of 2 from \(2^2\) to \(2^{l-1}\).
    else :
        bk = bin(k)[2:]
        ans = []
        lk = len(bk)
        for i in range(lk - 1):
            ans.append(2 ** i)
            
        #State: Output State: `ans` is a list containing the elements [1, 2, 4].
        ans.append(k - 1 - sum(ans))
        ans.append(k + 1)
        ans.append(2 * k + 1)
        for i in range(lk, l):
            ans.append(2 ** i)
            
        #State: ans is a list containing the elements [1, 2, 4, 3, k + 1, 2 * k + 1, 2
    #State: `n` is an integer between 2 and \(10^6\), `k` is an integer between 1 and `n`, `b` is a binary string representation of `n` without the '0b' prefix, `l` is the length of `b`, and `ans` is either `[2, 3, 4, 8, 16, ..., 2^(l-1)]` if `k` is 1, or `[1, 2, 4, 3, k + 1, 2 * k + 1, 2` followed by the remaining elements of the original `ans` list if `k` is not 1.
    return str(len(ans)) + '\n' + ' '.join(map(str, ans))
    #The program returns a string containing the length of the list `ans` followed by a space-separated string of its elements.
#Overall this is what the function does:The function accepts no parameters and returns either the string '1\n2' or a string containing the length of the list `ans` followed by a space-separated string of its elements. If `k` is 1, it returns '1\n2'. Otherwise, it constructs a list `ans` based on the binary representation of `n` and `k`, and then returns a string with the length of `ans` and its elements in a space-separated format.

#Function 15:
#State of the program right berfore the function call: func_10() returns an integer representing the number of test cases (t), and for each test case, func_14() returns an integer pair (n, k) where 2 ≤ n ≤ 10^6 and 1 ≤ k ≤ n.
def func_15():
    for _ in range(func_10()):
        sys.stdout.write(str(func_14()) + '\n')
        
    #State: A series of integer pairs (n, k) printed on separate lines, with the number of pairs equal to the value returned by func_10(). Each pair (n, k) satisfies 2 ≤ n ≤ 10^6 and 1 ≤ k ≤ n.
#Overall this is what the function does:The function accepts no parameters and returns nothing. It reads the number of test cases from `func_10()`, then for each test case, it prints an integer pair `(n, k)` obtained from `func_14()` to the standard output. The integer pair `(n, k)` for each test case satisfies `2 ≤ n ≤ 10^6` and `1 ≤ k ≤ n`. After completing all test cases, the function ends with no return value.




# Your response:
Reasoning:  
Correctness: **True** or **False**

