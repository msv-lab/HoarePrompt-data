Reasoning:

1. **Input Parsing**: The program correctly parses the number of test cases `t`, and for each test case, it reads the values of `n`, `m`, and `k`. This part is correct.

2. **Modulo Operation Initialization**: The constant `M` is set to \(10^9 + 7\), which is correct for handling large numbers modulo a prime number.

3. **Combinatorial Inverse Calculation**: The variable `c` is calculated as the modular inverse of the total number of possible unordered pairs of children, which is \(\frac{n \cdot (n - 1)}{2}\). This is done using `pow(n * (n - 1) // 2, -1, M)`, which is the correct way to compute the modular inverse.

4. **Sum Calculation**: The variable `a` accumulates the sum of all friendship values from the input. This is done correctly.

5. **Expected Value Calculation**: The loop that calculates `s` iterates `k` times and adds to `s` the expression `c * i * c * m + c * a`. This expression is derived from the expected value calculation for each excursion. Specifically, the term `c * i * c * m` accounts for the probability of picking a friend pair and the term `c * a` accounts for the initial sum of friendship values. This is mathematically sound.

6. **Output**: The final result `s % M` is printed, which is the correct way to output the result modulo \(10^9 + 7\).

Given the above analysis, the program logic and the steps taken to solve the problem are correct.

Correctness: **True**