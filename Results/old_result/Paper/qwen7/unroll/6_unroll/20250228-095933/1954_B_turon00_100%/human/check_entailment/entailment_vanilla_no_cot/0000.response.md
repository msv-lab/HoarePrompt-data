Correctness: **False**

### Explanation:
The provided solution does not correctly solve the problem. The logic in the given code does not account for the specific condition required to make the array non-beautiful by removing the minimum number of elements. Here’s why the current solution is incorrect:

1. **Incorrect Logic for Finding Minimum Removals**: The current logic counts consecutive elements that are the same and finds the minimum count among these segments. However, this does not necessarily lead to the minimum number of removals needed to break the "beautiful" property of the array.

2. **Handling of Test Cases**: The solution fails to handle cases where the array can be made non-beautiful by removing just one element, which is a valid scenario as shown in the example.

To correctly solve this problem, you need to identify the longest segment where the array remains "beautiful" and then calculate the minimum number of elements to remove to break this property. Here’s a corrected version of the solution:

```python
def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().strip().split()))
        
        # Find the longest segment where the array remains beautiful
        max_beautiful_length = 0
        current_length = 1
        
        for i in range(1, n-1):
            if a[i-1] == a[i+1]:
                current_length += 1
            else:
                max_beautiful_length = max(max_beautiful_length, current_length)
                current_length = 1
        
        max_beautiful_length = max(max_beautiful_length, current_length)
        
        # If the entire array is beautiful, we need to remove n-1 elements to break it
        if max_beautiful_length == n:
            print(-1)
        else:
            print(n - max_beautiful_length)

func()
```

This solution correctly identifies the longest segment where the array remains "beautiful" and calculates the minimum number of elements to remove to break this property.