### Reasoning:

1. **Input Handling**: The program correctly reads the number of test cases `t`, and for each test case, it reads `n` and `k`, followed by the list of integers `c`.

2. **Frequency Calculation**: The program calculates the frequency of each unique number in the list `c` using `p = [l.count(j) for j in set(l)]`. This step is correct as it ensures that each unique number's count is computed only once.

3. **Condition Check**: The program checks if the maximum frequency of any number (`max(p)`) is greater than or equal to `k`. If this condition is met, it prints `k - 1`. Otherwise, it prints `n`.

4. **Edge Cases**:
   - When `max(p) >= k`, the program correctly prints `k - 1`. This is because we can always reduce the number of cards by `k - 1` for each group of `k` identical cards.
   - When `max(p) < k`, the program correctly prints `n`. This is because no group of `k` identical cards exists, and thus, no reduction is possible.

5. **Output**: The program outputs the correct values for each test case based on the logic described.

Given the problem statement and the annotated program, the logic implemented in the function is correct and handles all the specified cases appropriately.

### Correctness:
**True**