Given the problem description, we will create comprehensive test cases to ensure the robustness, reliability, and scalability of the solution. Here are the test cases:

### Test 1: Single Vertex Tree
**Objective**: Verify the basic functionality when there is only one vertex in the tree.

**Input**:
```
1
1
```
**Output**:
```
1
1 0
```
**Explanation**: With only one vertex, no operations are needed since the vertex is already colored black initially.

### Test 2: Two Vertex Tree
**Objective**: Verify the basic functionality when there are exactly two vertices in the tree.

**Input**:
```
1
2
1 2
```
**Output**:
```
2
1 0
2 0
```
**Explanation**: The first operation colors vertex 1 black, and the second operation colors vertex 2 black. Alternatively, the operations could be (1, 0) and (2, 0).

### Test 3: Simple Path Tree
**Objective**: Verify the basic functionality when the tree forms a simple path.

**Input**:
```
1
4
1 2
2 3
3 4
```
**Output**:
```
2
1 1
4 1
```
**Explanation**: The first operation colors vertices 2 and 3 black, and the second operation colors vertices 1 and 4 black.

### Test 4: Star Tree
**Objective**: Verify the basic functionality when the tree is a star (one central vertex connected to all other vertices).

**Input**:
```
1
5
1 2
1 3
1 4
1 5
```
**Output**:
```
2
1 1
2 0
```
**Explanation**: The first operation colors vertices 2, 3, 4, and 5 black, and the second operation colors vertex 1 black.

### Test 5: Balanced Binary Tree
**Objective**: Verify the basic functionality when the tree is balanced and has a specific structure.

**Input**:
```
1
7
1 2
1 3
2 4
2 5
3 6
3 7
```
**Output**:
```
3
1 2
4 1
6 1
```
**Explanation**: The first operation colors vertices 2 and 3 black, the second operation colors vertices 4 and 5 black, and the third operation colors vertices 6 and 7 black.

### Test 6: Unbalanced Tree
**Objective**: Verify the basic functionality when the tree is unbalanced.

**Input**:
```
1
7
1 2
2 3
3 4
4 5
5 6
6 7
```
**Output**:
```
2
1 1
7 1
```
**Explanation**: The first operation colors vertices 2, 3, 4, 5, and 6 black, and the second operation colors vertex 7 black.

### Test 7: Complete Binary Tree
**Objective**: Verify the basic functionality when the tree is a complete binary tree.

**Input**:
```
1
7
1 2
1 3
2 4
2 5
3 6
3 7
```
**Output**:
```
3
1 2
4 1
6 1
```
**Explanation**: The first operation colors vertices 2 and 3 black, the second operation colors vertices 4 and 5 black, and the third operation colors vertices 6 and 7 black.

### Test 8: Random Tree Structure
**Objective**: Verify the basic functionality when the tree has a random structure.

**Input**:
```
1
7
1 2
1 3
2 4
3 5
4 6
5 7
```
**Output**:
```
3
1 2
4 1
5 1
```
**Explanation**: The first operation colors vertices 2 and 3 black, the second operation colors vertices 4 and 5 black, and the third operation colors vertices 6 and 7 black.

### Test 9: Large Tree
**Objective**: Verify the basic functionality when the tree is large but still within the constraints.

**Input**:
```
1
10
1 2
1 3
2 4
2 5
3 6
3 7
4 8
4 9
5 10
```
**Output**:
```
4
1 3
6 2
8 1
10 1
```
**Explanation**: The first operation colors vertices 2 and 3 black, the second operation colors vertices 4 and 5 black, the third operation colors vertices 6 and 7 black, and the fourth operation colors vertices 8, 9, and 10 black.

### Test 10: Degenerate Tree (Single Edge)
**Objective**: Verify the basic functionality when the tree consists of a single edge.

**Input**:
```
1
4
1 2
2 3
3 4
```
**Output**:
```
2
1 1
4 1
```
**Explanation**: The first operation colors vertices 2 and 3 black, and the second operation colors vertices 1 and 4 black.

These test cases cover a wide range of scenarios from simple to complex tree structures, ensuring the solution is robust and reliable.