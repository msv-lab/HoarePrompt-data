Reasoning:

1. **Dynamic Programming Initialization**: The provided code initializes the `dp` array with `-1` for all indices and then calls `func_1(300000)` to populate the `dp` array. This function correctly sets up the base cases and iterates to fill the `dp` array using the given recurrence relation.

2. **Input Handling**: The code reads the number of test cases `t`, and for each test case, it reads the dimensions of the chessboard `n` and the number of moves `k`. It also reads the positions of the rooks placed so far, adding them to a set `invalid`.

3. **Configuration Calculation**: For each test case, the code calculates the number of valid positions left on the board by subtracting the number of invalid positions (those already occupied by rooks) from `n`. It then prints the value of `dp[n - len(invalid)]`, which represents the number of ways to place the remaining rooks without any two attacking each other, modulo \(10^9 + 7\).

4. **Recurrence Relation**: The recurrence relation used in `func_1` is correct for calculating the number of ways to place non-attacking rooks on an \(n \times n\) board. Specifically, the relation `dp[i] = (dp[i - 1] + 2 * (i - 1) * dp[i - 2]) % 1000000007` correctly accounts for the placement of rooks in a manner that ensures no two rooks attack each other.

Given the above points, the provided program correctly implements the logic required to solve the problem as described.

Correctness: **True**