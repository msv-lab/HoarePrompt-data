#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 2⋅10^4. Each test case consists of n and x, where 1 ≤ x ≤ n ≤ 2⋅10^5, and a permutation p of length n consisting of distinct integers from 1 to n.
def func_1():
    return map(int, input().split())
    #The program returns a map object containing two integers, which are the values of variables 'x' and 't' separated by a space, converted to integers.
#Overall this is what the function does:The function reads two integers from user input, separated by a space, converts them to integers, and returns a map object containing these two integers.

#State of the program right berfore the function call: t is a positive integer representing the number of test cases, and each test case consists of two integers n and x where 1 ≤ x ≤ n ≤ 2⋅10^5, followed by a permutation p of size n consisting of distinct integers from 1 to n.
def func_2():
    return list(func_1())
    #The program returns a list generated by func_1(), which is not defined in the given information.
#Overall this is what the function does:The function does not accept any parameters and returns a list generated by calling `func_1()`, which is not defined in the given information. The returned list is the final state of the program after the function concludes.

#State of the program right berfore the function call: n is a positive integer representing the length of the permutation array arr, k is an integer such that 1 ≤ k ≤ n, and arr is a permutation of integers from 1 to n.
def func_3():
    n, k = func_1()
    arr = func_2()
    pos = -1
    for i in range(n):
        if arr[i] == k:
            pos = i
        
    #State: pos is 3, n is a positive integer, k is an integer such that 1 ≤ k ≤ n, arr is the result of the function func_2() call, and i is n.
    low, high = 0, n
    st = set()
    while low + 1 < high:
        mid = (low + high) // 2
        
        st.add(mid)
        
        if arr[mid] > k:
            high = mid
        else:
            low = mid
        
    #State: Output State: `low` is either 0 or one of the previously calculated `mid` values, `high` is either `n` or one of the previously calculated `mid` values, `mid` is the final calculated midpoint value from the last iteration, `pos` is 3, `k` is an integer such that 1 ≤ k ≤ n, `arr` is the result of the function `func_2()` call, and `i` is n; `st` is a set containing all the unique `mid` values calculated during the loop iterations.
    #
    #Explanation: After all iterations of the loop, the variable `low` will be the smallest index where `arr[low]` is greater than or equal to `k`, or it will be 0 if no such index exists. Similarly, `high` will be the largest index where `arr[high]` is less than `k`, or it will be `n` if no such index exists. The variable `mid` will hold the final calculated midpoint value from the last iteration of the loop. The variable `st` will contain all the unique midpoint values calculated during the loop iterations. The values of `pos`, `k`, `arr`, and `i` remain unchanged as they are not affected by the loop.
    if (arr[low] == k) :
        print(0)
        #This is printed: 0
    else :
        print(1)
        #This is printed: 1
        print(low + 1, pos + 1)
        #This is printed: low + 1, 4
    #State: `low` is the smallest index where `arr[low]` is greater than or equal to `k`, or it is 0 if no such index exists, `high` is the largest index where `arr[high]` is less than `k`, or it is `n` if no such index exists, `mid` is the final calculated midpoint value from the last iteration of the loop, `pos` is 3, `k` is an integer such that 1 ≤ k ≤ n, `arr` is the result of the function `func_2()` call, `i` is n, `st` is a set containing all the unique `mid` values calculated during the loop iterations, and `arr[low]` is equal to `k` if `arr[low]` is equal to `k`, otherwise `arr[low]` is not equal to `k`.
#Overall this is what the function does:The function processes a permutation array `arr` of length `n` and an integer `k` (where 1 ≤ k ≤ n). It first finds the position of `k` in the array. Then, it uses binary search to determine the smallest index `low` where `arr[low]` is greater than or equal to `k`, or 0 if no such index exists. If `arr[low]` equals `k`, it prints `0`. Otherwise, it prints `1`, `low + 1`, and `pos + 1`, where `pos` is the initial position of `k` found earlier. The function does not return any value but modifies the output through print statements.

