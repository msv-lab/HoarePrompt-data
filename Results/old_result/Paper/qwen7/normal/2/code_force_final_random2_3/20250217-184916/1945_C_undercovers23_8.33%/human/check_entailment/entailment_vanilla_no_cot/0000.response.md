Correctness: **False**

### Explanation:

The given program has several issues that prevent it from correctly solving the problem:

1. **Incorrect Calculation of Percentages:**
   - The program calculates `zero_perc` and `one_perc` as percentages but then uses these values to check if they are greater than or equal to 50. This is unnecessary and incorrect because the problem specifies using the ceiling function directly on the counts, not percentages.

2. **Handling of Even and Odd `n`:**
   - The program incorrectly handles the case when `n` is even. It sets `pk` to `n // 2`, which is correct, but the logic should be consistent regardless of whether `n` is even or odd.

3. **Sorting and Selecting the Optimal Position:**
   - The program sorts the list `final` and selects the smallest element. However, the problem specifies that if there are multiple positions with the same minimum distance, the smaller index should be chosen. The current implementation does not ensure this.

4. **Final Decision Logic:**
   - The final decision logic to handle cases where no valid position is found is incorrect. It should directly append the appropriate boundary (0 or `n`) without sorting.

Here is a corrected version of the program:

```python
import math

def find_optimal_position():
    t = int(input())
    for _ in range(t):
        n = int(input())
        s = input()
        sl = list(s)
        o = sl.count('1')
        z = sl.count('0')
        
        zero, one = 0, 0
        lst = []
        mini = float('inf')
        
        for i in range(n - 1):
            if sl[i] == '0':
                zero += 1
            else:
                one += 1
            
            if math.ceil(zero * 2 / (i + 1)) >= 1 and math.ceil(one * 2 / (n - i - 1)) >= 1:
                lst.append(i + 1)
        
        if not lst:
            # If no valid position is found, check the boundaries
            if math.ceil(z * 2 / n) >= 1:
                print(0)
            else:
                print(n)
        else:
            mini = min(abs(n // 2 - pos) for pos in lst)
            final = [pos for pos in lst if abs(n // 2 - pos) == mini]
            print(min(final))

find_optimal_position()
```

This corrected version ensures that the program correctly calculates the required positions and handles the edge cases appropriately.