Reasoning:

1. **Understanding the Problem**: The problem involves processing a series of operations on an initially empty array `a`. Operations can either append a single integer or append multiple copies of the current array. The goal is to answer queries about the `k-th` element of the resulting array after all operations.

2. **Analysis of `func_1`**:
   - The function correctly handles appending elements to the array when the operation type is 1.
   - However, the function incorrectly handles the extension of the array when the operation type is 2. Instead of extending the array with `x` copies of itself, the function only repeats the existing elements in the array, which does not reflect the intended behavior.
   - The function then incorrectly calculates the `k-th` element using modulo operation, which might not always give the correct position due to the incorrect array construction.

3. **Analysis of `func_2`**:
   - The function correctly reads the input for multiple test cases.
   - It calls `func_1` with the appropriate parameters and prints the results.

Given these points, the core issue lies in `func_1`, where the array is not correctly extended based on the operation type 2. Therefore, the function will not produce the correct array state for further processing.

Correctness: **False**

To fix this, the function should correctly extend the array by appending `x` copies of the current array when the operation type is 2. Here is a corrected version of `func_1`:

```python
def func_1(n, operations, queries):
    array = []
    for (op_type, value) in operations:
        if op_type == 1:
            array.append(value)
        else:
            array.extend(array * value)
    
    result = []
    for k in queries:
        result.append(array[(k - 1) % len(array)])
    
    return result
```

This corrected function ensures that the array is properly extended when the operation type is 2, and the `k-th` element is correctly determined using the modulo operation.