#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 10^4. For each test case, n and k are integers such that 1 ≤ n ≤ 2⋅10^5 and 0 ≤ k ≤ n. a is a list of n integers such that 1 ≤ a_i ≤ 10^9, and b is a list of n integers such that 1 ≤ b_i ≤ 10^9.
def func_1():
    return int(putin())
    #The program returns an integer value generated by the function putin() for each test case.
#Overall this is what the function does:The function processes multiple test cases internally, each consisting of integers t, n, k, a (a list of n integers), and b (a list of n integers). For each test case, it calls the function `putin()` to generate an integer value, which it then returns.

#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 10^4. For each test case, n and k are integers such that 1 ≤ n ≤ 2⋅10^5 and 0 ≤ k ≤ n. a is a list of n integers such that 1 ≤ a_i ≤ 10^9. b is a list of n integers such that 1 ≤ b_i ≤ 10^9.
def func_2():
    return map(int, putin().split())
    #The program returns a map object containing integers split from the input string.
#Overall this is what the function does:The function processes an input string by splitting it and converting each element into an integer, returning a map object of these integers.

#State of the program right berfore the function call: main_ar is a list of tuples, where each tuple contains two integers (a_i, b_i); sec_arr is a list of integers. Additionally, the length of main_ar is n, and the length of sec_arr is also n.
def func_3(main_ar, sec_arr):
    sub_summ = 0
    for val_a in sec_arr:
        sub_summ += val_a[0]
        
    #State: Output State: `sub_summ` is the sum of all elements in `sec_arr`, where each element is accessed using `val_a[0]`.
    #
    #This means that after the loop has executed all its iterations, `sub_summ` will contain the sum of the first element (`val_a[0]`) from each sublist in `sec_arr`. The condition for the loop to execute all iterations is that `sec_arr` must have at least as many elements as there are iterations, which in this case is the total number of sublists in `sec_arr`.
    for val_b in main_ar:
        if val_b[0] + val_b[1] >= 0:
            sub_summ += val_b[0] + val_b[1]
        
    #State: `sub_summ` is the sum of `val_b[0] + val_b[1]` for all sublists in `main_ar` where `val_b[0] + val_b[1]` is greater than or equal to 0.
    return sub_summ
    #The program returns `sub_summ`, which is the sum of `val_b[0] + val_b[1]` for all sublists in `main_ar` where `val_b[0] + val_b[1]` is greater than or equal to 0.
#Overall this is what the function does:The function accepts two parameters: `main_ar`, a list of tuples where each tuple contains two integers, and `sec_arr`, a list of integers. Both lists have the same length. It calculates and returns `sub_summ`, which is the sum of the first element of each tuple in `main_ar` plus the second element of the tuple, but only if their sum is greater than or equal to zero.

