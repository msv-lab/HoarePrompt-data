
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with some output hints that summarize the program's functionality.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided output hints to systematically evaluate the program's behavior and reasoning. Based on the program, the output hints the problem description and the original assessment, determine the final correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the output hints support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Vladislav has n cards numbered 1, 2, \dots, n . He wants to lay them down in a
row as follows:

  * First, he lays down all the odd-numbered cards from smallest to largest. 
  * Next, he lays down all cards that are twice an odd number from smallest to largest (i.e. 2 multiplied by an odd number). 
  * Next, he lays down all cards that are 3 times an odd number from smallest to largest (i.e. 3 multiplied by an odd number). 
  * Next, he lays down all cards that are 4 times an odd number from smallest to largest (i.e. 4 multiplied by an odd number). 
  * And so on, until all cards are laid down. 

What is the k -th card he lays down in this process? Once Vladislav puts a
card down, he cannot use that card again.

Input

The first line contains an integer t (1 \leq t \leq 5 \cdot 10^4 ) — the
number of test cases.

The only line of each test case contains two integers n and k (1 \leq k \leq n
\leq 10^9 ) — the number of cards Vlad has, and the position of the card you
need to output.

Output

For each test case, output a single integer — the k -th card Vladislav lays
down.

Example

Input

    11
    
    7 1
    
    7 2
    
    7 3
    
    7 4
    
    7 5
    
    7 6
    
    7 7
    
    1 1
    
    34 14
    
    84 19
    
    1000000000 1000000000

Output

    1
    3
    5
    7
    2
    6
    4
    1
    27
    37
    536870912
    
Note

In the first seven test cases, n=7 . Vladislav lays down the cards as follows:

  * First — all the odd-numbered cards in the order 1 , 3 , 5 , 7 . 
  * Next — all cards that are twice an odd number in the order 2 , 6 . 
  * Next, there are no remaining cards that are 3 times an odd number. (Vladislav has only one of each card.) 
  * Next — all cards that are 4 times an odd number, and there is only one such card: 4 . 
  * There are no more cards left, so Vladislav stops. 

Thus the order of cards is 1 , 3 , 5 , 7 , 2 , 6 , 4 .
Program:
```
def func():
    t = int(input())
    for _ in range(t):
        (n, k) = map(int, input().split())
        n_back = n
        s = (n + 1) // 2
        n = (n + 1) // 2
        m = 1
        while s < k:
            if n == 0:
                s = n_back
                n = 1
                break
            m *= 2
            n //= 2
            s += n
        print((2 * (k - (s - n)) - 1) * m)


```
Original Assessment: Let's analyze the given program step by step to determine its correctness.

### Step-by-Step Analysis

1. **Initialization**:
   - `t` is read as the number of test cases.
   - For each test case, `n` and `k` are read as the number of cards and the position of the card we need to find, respectively.

2. **Variables Initialization**:
   - `n_back` is initialized to `n`, which will be used later to reset `n`.
   - `s` is calculated as `(n + 1) // 2`, representing the count of odd-numbered cards.
   - `n` is updated to `(n + 1) // 2`, effectively reducing the problem to the number of odd-numbered cards.
   - `m` is set to `1`, which will be used to multiply the final result.
   - `n` is halved to represent the reduction in the number of multiples of 2, 3, etc., of the odd numbers.

3. **Loop**:
   - The loop continues as long as `s < k`.
   - If `n` becomes zero, it means we have exhausted all possibilities for the current multiple (2, 3, 4, ...), and we reset `s` to `n_back` and update `n` to `1` to start with the next multiple.
   - `m` is doubled in each iteration, representing the next multiple (2, 4, 8, ...).
   - `n` is halved in each iteration, updating the count of remaining cards for the next multiple.
   - `s` is updated by adding `n` to itself, representing the cumulative count of cards laid down.

4. **Final Calculation**:
   - After the loop, the formula `(2 * (k - (s - n)) - 1) * m` is used to calculate the `k-th` card.
   - The term `(2 * (k - (s - n)) - 1)` computes the actual value of the card.
   - Multiplying by `m` gives the final position of the card considering the multiple.

### Verification

To verify the correctness, let's consider the example provided:

- **Example 1**: `n = 7`, `k = 1`
  - Odd cards: 1, 3, 5, 7
  - The 1st card is 1.
  - The program correctly outputs 1.

- **Example 2**: `n = 7`, `k = 2`
  - Odd cards: 1, 3, 5, 7
  - Cards that are twice an odd number: 2, 6
  - The 2nd card is 3.
  - The program correctly outputs 3.

- **Example 3**: `n = 7`, `k = 3`
  - Odd cards: 1, 3, 5, 7
  - Cards that are twice an odd number: 2, 6
  - The 3rd card is 5.
  - The program correctly outputs 5.

- **Example 4**: `n = 7`, `k = 4`
  - Odd cards: 1, 3, 5, 7
  - Cards that are twice an odd number: 2, 6
  - The 4th card is 7.
  - The program correctly outputs 7.

- **Example 5**: `n = 7`, `k = 5`
  - Odd cards: 1, 3, 5, 7
  - Cards that are twice an odd number: 2, 6
  - The 5th card is 2.
  - The program correctly outputs 2.

- **Example 6**: `n = 7`, `k = 6`
  - Odd cards: 1, 3, 5, 7
  - Cards that are twice an odd number: 2, 6
  - The 6th card is 6.
  - The program correctly outputs 6.

- **Example 7**: `n = 7`, `k = 7`
  - Odd cards: 1, 3, 5, 7
  - Cards that are twice an odd number: 2, 6
  - The 7th card is 4.
  - The program correctly outputs 4.

- **Example 8**: `n = 1`, `k = 1`
  - The only card is 1.
  - The program correctly outputs 1.

- **Example 9**: `n = 34`, `k = 14`
  - The 14th card is 27 (the 7th odd number).
  - The program correctly outputs 27.

- **Example 10**: `n = 84`, `k = 19`
  - The 19th card is 37 (the 10th odd number).
  - The program correctly outputs 37.

- **Example 11**: `n = 1000000000`, `k = 1000000000`
  - The 1000000000th card is \(2^{30} = 536870912\).
  - The program correctly outputs 536870912.

Given the examples and the logic of the program, it appears to correctly implement the required sequence of laying out the cards.

### Conclusion

Correctness: **True**

Now we are giving you the output hints that summarize the code functionality and might give you examples of some of the cases that the code is not working correctly. Make sure that the output hints make sense. Also we assume that the input will be valid and will not cause any errors in the program. 
So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Output hints: The function processes up to 50,000 test cases, where each test case consists of three integers: `n`, `k`, and an implicit `t`. For each test case, it calculates and prints a result based on the formula `(2 * (k - (s - n)) - 1) * m`. After processing all test cases, the function outputs a series of integers corresponding to the calculated results for each test case.

Does the original Assessment make sense based on the problem description and the provided code. 
Based on the output hints, the program  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the output hints provide a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
