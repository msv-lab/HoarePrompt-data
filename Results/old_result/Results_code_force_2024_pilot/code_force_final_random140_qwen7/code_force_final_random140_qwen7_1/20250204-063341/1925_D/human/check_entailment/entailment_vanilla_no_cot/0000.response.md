Correctness: **False**

### Explanation:
The given program has several issues that make it incorrect for solving the problem:

1. **Incorrect Calculation of Expected Values:**
   - The program calculates the expected value using a formula that doesn't correctly model the problem. Specifically, it incorrectly computes the numerator and denominator without considering the probability of picking each pair.
   
2. **Incorrect Handling of Pairs:**
   - The program sums the friendship values directly from the input, but it should consider the probability of picking each pair in each excursion. The current approach does not account for the fact that pairs are chosen randomly with equal probability.

3. **GCD and Modular Inversion:**
   - While the use of `math.gcd` and modular inversion (`pow(den, -1, MOD)`) is correct, these operations are applied to an incorrect numerator and denominator.

4. **Probability Consideration:**
   - The expected value calculation should consider the probability of picking each pair in each excursion. The current implementation does not incorporate this probability.

### Correct Approach:
To solve the problem correctly, you need to calculate the expected value for each pair of friends and non-friends separately and then sum them up. Hereâ€™s a corrected version of the program:

```python
import math

def func():
    MOD = 1000000007
    T = int(input())
    for _ in range(T):
        n, m, k = map(int, input().split())
        pairs = {}
        
        # Read the pairs and their friendship values
        for _ in range(m):
            a, b, f = map(int, input().split())
            if (a, b) not in pairs:
                pairs[(a, b)] = f
            else:
                pairs[(a, b)] += f
        
        # Calculate the expected value for each pair
        expected_value = 0
        for (a, b), f in pairs.items():
            # Probability of picking the pair in one excursion
            prob_pick_once = 2 / (n * (n - 1))
            # Expected value contribution of this pair
            expected_value += f * (k * prob_pick_once + (k * (k - 1) / 2) * (prob_pick_once ** 2))
        
        # Print the result modulo MOD
        print(int(expected_value % MOD))

# Call the function
func()
```

This corrected version correctly calculates the expected value by considering the probability of picking each pair in each excursion and handles the modular arithmetic properly.