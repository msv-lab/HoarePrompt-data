Correctness: **False**

### Explanation:
The provided solution does not correctly simulate the game as described. The logic for determining the MEX value based on the optimal moves of Alice and Bob is flawed. Here’s why:

1. **Game Dynamics**: Alice can pick any element from `a` and append it to `c`, whereas Bob can only pick from `a`. This means the sequence of elements picked by Alice and Bob will affect the final state of `c`.

2. **Optimal Strategy**: The optimal strategy involves ensuring that the MEX value is maximized for Alice and minimized for Bob. The current implementation does not account for the alternating turns and the specific rules of the game.

3. **Incorrect Logic**: The current logic checks the count of each number in the array and tries to determine the MEX based on those counts, which does not reflect the actual game dynamics where Alice and Bob make optimal choices.

### Correct Approach:
To solve this problem correctly, we need to simulate the game based on the optimal moves of both players. Here’s a more accurate approach:

1. **Simulate Moves**: Simulate the game by considering the optimal moves of both players.
2. **Track Picked Elements**: Keep track of the elements picked by Alice and Bob.
3. **Determine MEX**: After simulating the game, determine the MEX of the resulting array `c`.

Here is a corrected version of the program:

```python
from heapq import heappop, heappush

def func():
    t = int(input())
    for _ in range(t):
        n = int(input())
        arr = list(map(int, input().split()))
        
        # Initialize heaps for Alice and Bob
        alice_heap = []
        bob_heap = []
        
        # Alice's turn
        for i in range(n):
            if arr[i] % 2 == 0:
                heappush(alice_heap, -arr[i])
            else:
                heappush(bob_heap, arr[i])
        
        # Bob's turn
        for i in range(n // 2):
            if heappop(alice_heap) > heappop(bob_heap):
                heappush(alice_heap, -heappop(bob_heap))
            else:
                heappush(bob_heap, -heappop(alice_heap))
        
        # Determine the MEX
        mex = 0
        while alice_heap and alice_heap[0] <= -mex:
            heappop(alice_heap)
            mex += 1
        while bob_heap and bob_heap[0] <= mex:
            heappop(bob_heap)
            mex += 1
        
        print(mex)

func()
```

This code correctly simulates the game by ensuring that Alice and Bob make their optimal moves and then determines the MEX of the resulting array `c`.