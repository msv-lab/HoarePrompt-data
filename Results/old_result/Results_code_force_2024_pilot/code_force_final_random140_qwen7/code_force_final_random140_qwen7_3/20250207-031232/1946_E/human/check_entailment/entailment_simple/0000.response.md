### Reasoning:

1. **Input Parsing and Initial Checks**:
   - The program correctly reads the number of test cases and processes each one.
   - It checks if the last index of the prefix maximums matches the first index of the suffix maximums, and if the first prefix maximum is 1 and the last suffix maximum is \( n \). If these conditions are not met, it prints 0, which is correct according to the problem statement.

2. **Combinatorial Calculations**:
   - The program uses combinatorial calculations to determine the number of valid permutations. Specifically, it calculates combinations using the `func_2` function, which in turn calls `func_1`.
   - The logic for calculating combinations is correct. For a given segment of the permutation, the program calculates how many ways there are to place the remaining elements while respecting the constraints of the prefix and suffix maximums.

3. **Modulo Operation**:
   - The program performs all necessary operations under modulo \(10^9 + 7\), which is correct to handle large numbers.

4. **Recursive Function `func_1`**:
   - The recursive function `func_1` correctly implements the extended Euclidean algorithm to find the modular inverse, which is used in the combination calculation.
   - The base cases and recursive steps are implemented correctly.

5. **Combination Calculation with `func_2`**:
   - The function `func_2` correctly uses the result of `func_1` to calculate the combination and returns the result modulo \(10^9 + 7\).

Given that the program correctly handles all aspects of the problem, including input parsing, combinatorial calculations, and modulo operations, and that the logic is sound, the program appears to be correct.

### Conclusion:
Correctness: **True**