The variable in the loop head is `curr`, so we can only adjust that one. According to the code, whether the loop can execute depends on the variable `curr`. If `curr` is not equal to `-1`, the loop can execute again. At the end of the last iteration, `curr` is set to the predecessor of `end` as found in the `prev` dictionary, and `end` must not be `-1`. For the loop to execute one more time, `curr` must still point to a valid predecessor, which means `curr` should not be `-1`.

State: **After all iterations, `node` will be the last processed node from `que` or `end` if it was reached, and `que` will be empty. The `prev` dictionary will have entries for all nodes that were reachable from `start` and not previously in `prev`, mapping each node to its predecessor in the path. If `end` was reached, the loop will have terminated early when `node` became `end`. All other variables (`n`, `m`, `edges`, `graph`, `i`, `dsu`, `_min_edge`, `start`, `end`) remain unchanged. `path` is now a list containing `[end]`. `curr` is set to the predecessor of `end` as found in the `prev` dictionary, and `curr` must not be `-1`.**