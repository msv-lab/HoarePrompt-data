
Given a Python loop, an initial execution state, and the output states after the first 3 iterations of the loop, determine the output state after all the executions of the loop have finished. 

You must adhere to the text format: Output State: **output state.**

Initial State: t is a positive integer (1 ≤ t ≤ 5000), T is an input integer, representing the number of test cases. Each test case consists of two integers n and k (2 ≤ n ≤ 50000, 1 ≤ k ≤ ⌊n/2⌋), and a list a of 2n integers (1 ≤ a_i ≤ n) where each integer from 1 to n appears exactly twice. The sum of n over all test cases does not exceed 50000.
Code of the loop:
for _ in range(T):
    n, k = map(int, input().split())
    lst = list(map(int, input().split()))
    lft = lst[:n]
    rgt = lst[n:]
    ldb = []
    rdb = []
    sng = []
    lft.sort()
    rgt.sort()
    if lft[0] != lft[1]:
        sng.append(lft[0])
    for i in range(1, n):
        if lft[i] == lft[i - 1]:
            ldb.append(lft[i])
        elif i == n - 1 or lft[i] != lft[i + 1]:
            sng.append(lft[i])
    for i in range(1, n):
        if rgt[i] == rgt[i - 1]:
            rdb.append(rgt[i])
    sz = 0
    for elem in ldb:
        if 2 * k - sz >= 2:
            print(elem, elem, end=' ')
            sz += 2
        else:
            break
    for elem in sng:
        if sz >= 2 * k:
            break
        print(elem, end=' ')
        sz += 1
    print()
    sz = 0
    for elem in rdb:
        if 2 * k - sz >= 2:
            print(elem, elem, end=' ')
            sz += 2
        else:
            break
    for elem in sng:
        if sz >= 2 * k:
            break
        print(elem, end=' ')
        sz += 1
    print()


The output state after the loop executes the first 3 of times includes what needed to be true for the loop to execute at least that number of times:

Output State after the loop executes 1 time: `sz` is 2 * k, `sng` is a non-empty iterable with elements remaining, and the loop has printed the first `2 * k - 1` elements from `sng`.

**Output State after the loop executes 2 times**: `i` is `n - 1`, `n` is an input integer greater than 1, `k` is an input integer, `lst` is a list of integers provided by the user, `lft` is the first `n` elements of `lst` and is now sorted in ascending order, `rgt` is the elements of `lst` starting from index `n` to the end and is now sorted in ascending order, `ldb` contains all elements from `lft` that are equal to their previous element, `sng` contains all elements from `lft` that are either the last element of `lft` or different from their next element, `rdb` contains all elements from `rgt` that are equal to their previous element, `sz` is the minimum value between `2 * k` and the total number of elements in `rdb` multiplied by 2 plus the number of elements printed from `sng`. The loop will stop either when all elements in `sng` have been processed or when `sz` reaches or exceeds `2 * k`.

**Output State after the loop executes 3 times**: `i` is `n - 1`, `n` is an input integer greater than 1, `rdb` must contain at least one element, `sz` is the maximum even number such that `2 * k - sz >= 2` holds true, or `sz` is the last value before the condition fails, `k`, `lst`, `lft`, `rgt`, `_` remain unchanged, `ldb` must be a non-empty list, `sng` has been fully iterated over, meaning it has no more elements left to process.




What is the ouput state after the loop executes all the iterations? Change the values of only the variables in the loop head and body.The state of the other variables in the precondition that are not affected by the loop head and body must remain unchanged.
In your response strictly use the format: Output State: **the output state you calculate.**, and describe this output state in Natural language easily understandable by humans.

