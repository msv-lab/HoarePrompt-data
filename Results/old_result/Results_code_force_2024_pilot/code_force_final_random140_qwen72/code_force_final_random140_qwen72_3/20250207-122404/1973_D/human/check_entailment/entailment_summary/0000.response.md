### Reasoning:

1. **Function `func_1`**:
   - This function sends a query to the judge and receives the smallest integer `r` such that `f(l, r) = x`, or `n + 1` if no such `r` exists.
   - It correctly handles the interaction by flushing the output and reading the response.
   - The function ensures that the returned value `ret` is non-negative, which is a reasonable check.

2. **Function `func_2`**:
   - This function sends the final answer `m` to the judge and expects a confirmation (`1` for correct, `-1` for incorrect).
   - It correctly handles the interaction by flushing the output and reading the response.
   - The function asserts that the response is `1`, which is appropriate for ensuring the correctness of the answer.

3. **Function `func_3`**:
   - This function reads the values of `n` and `k` from the input.
   - It attempts to find the largest possible value `i` such that `func_1(1, i * n)` returns `n`. This step is crucial for finding the maximum possible value of `m`.
   - It then iterates over possible values of `i` from `n // k` down to `1`, calculating `m` as `i * max_val`.
   - For each `m`, it uses `func_1` to check if the subarrays can be split such that `f(1, c_1) = f(c_1 + 1, c_2) = ... = f(c_{k-1}+1, n) = m`.
   - If such a split is found, it calls `func_2(m)` and returns. If no such `m` is found, it calls `func_2(-1)`.

4. **Function `func_4`**:
   - This function reads the number of test cases `t` and calls `func_3` for each test case.
   - It correctly handles the interaction by calling `func_3` multiple times.

### Conclusion:
The program appears to correctly implement the logic required to solve the problem. Each function performs its intended role, and the overall structure of the program aligns with the problem description. The interactions with the judge are handled appropriately, and the program should be able to handle multiple test cases as specified.

Therefore, the program is correct.

**Correctness: True**