#State of the program right berfore the function call: cast is a callable that can convert string inputs to a specified type, typically int or float.
def func_1(cast):
    return map(cast, input().split())
    #The program returns an iterator that applies the `cast` function (which can convert strings to a specified type, typically int or float) to each element of the list generated by splitting the user's input string.
#Overall this is what the function does:The function `func_1` accepts a single parameter `cast`, which is expected to be a callable capable of converting string inputs to a specified type (such as `int` or `float`). It reads a line of input from the user, splits the input into a list of substrings based on whitespace, and returns an iterator that applies the `cast` function to each substring. The final state of the program includes an iterator ready to yield the converted values when iterated over.

#State of the program right berfore the function call: arr is a list of integers, and predicate is a function that takes an integer and returns a boolean.
def func_2(arr, predicate):
    l, r = 0, len(arr)
    while l + 1 < r:
        mid = (l + r) // 2
        
        if predicate(arr[mid]):
            l = mid
        else:
            r = mid
        
    #State: `arr` is a list of integers, `predicate` is a function that takes an integer and returns a boolean, `l` and `r` are such that `l + 1 >= r`. The final value of `l` is the largest index in `arr` for which `predicate(arr[l])` is true, or `l` is the last index before `r` where `predicate(arr[l])` is false.
    if predicate(arr[l]) :
        return l
        #The program returns the largest index `l` in the list `arr` for which `predicate(arr[l])` is true, or if no such index exists, it returns the last index before `r` where `predicate(arr[l])` is false.
    #State: *`arr` is a list of integers, `predicate` is a function that takes an integer and returns a boolean, `l` and `r` are such that `l + 1 >= r`. The final value of `l` is the largest index in `arr` for which `predicate(arr[l])` is true, or `l` is the last index before `r` where `predicate(arr[l])` is false. Additionally, `predicate(arr[l])` is false.
    return None
    #The program returns None.
#Overall this is what the function does:The function `func_2` accepts a list of integers `arr` and a predicate function `predicate`. It returns the largest index `l` in `arr` for which `predicate(arr[l])` is true. If no such index exists, it returns the last index before `r` where `predicate(arr[l])` is false. If neither condition is met, it returns `None`. The function does not modify the input list `arr` or the predicate function `predicate`.

#State of the program right berfore the function call: n and q are integers such that 2 ≤ n ≤ 2 · 10^5 and 1 ≤ q ≤ 2 · 10^5. a is a list of n integers where 0 ≤ a_i < 2^30. l and r are integers such that 1 ≤ l < r ≤ n.
def func_3():
    n, q = func_1(int)
    a = list(func_1(int))
    x = [0]
    inds = defaultdict(list)
    inds[0].append(0)
    for i in a:
        x.append(x[-1] ^ i)
        
        inds[x[-1]].append(len(x) - 1)
        
    #State: After all iterations of the loop, `a` remains a non-empty list of integers, `n` and `q` are updated to the values returned by `func_1(int)`, `l` and `r` are integers such that 1 ≤ l < r ≤ n, `x` is a list containing the elements `[0, x_1, x_2, ..., x_m]` where each `x_i` is the result of the XOR operation between the previous element in `x` and the corresponding element in `a`, and `inds` is a defaultdict of lists where each key is an element from `x` and the value is a list of indices where that element appears in `x`.
    for i in range(q):
        l, r = func_1(int)
        
        if x[l - 1] == x[r]:
            print('Yes')
            continue
        
        lower = func_2(inds[x[r]], lambda arg: arg < l) or -1
        
        upper = func_2(inds[x[l - 1]], lambda arg: arg <= r)
        
        lower = inds[x[r]][lower + 1]
        
        upper = inds[x[l - 1]][upper]
        
        if upper > lower and l <= upper <= r and l <= lower <= r:
            print('Yes')
        else:
            print('No')
        
    #State: After all iterations of the loop, `a` remains a non-empty list of integers, `n` and `q` are updated to the values returned by `func_1(int)` where `q` has been fully decremented to 0, `l` and `r` are the final values returned by `func_1(int)` during the last iteration, `x` is a list containing the elements `[0, x_1, x_2, ..., x_m]` where each `x_i` is the result of the XOR operation between the previous element in `x` and the corresponding element in `a`, `inds` is a defaultdict of lists where each key is an element from `x` and the value is a list of indices where that element appears in `x`, `i` is `q-1` (the total number of iterations minus one), `lower` is the next index in `inds[x[r]]` after the highest index in `inds[x[r]]` that is less than `l` or -1 if no such index exists, `upper` is the value of `inds[x[l - 1]][upper]`. The conditions for `upper` and `lower` will depend on the final values of `l` and `r` and whether they satisfy the conditions within the loop's if-else statements.
#Overall this is what the function does:The function `func_3` processes a series of queries on a list of integers. It takes no explicit parameters but internally uses `func_1` to obtain the values of `n` (the length of the list `a`), `q` (the number of queries), and the list `a` itself. For each query, it receives two integers `l` and `r` (1 ≤ l < r ≤ n). The function computes a prefix XOR array `x` and a dictionary `inds` mapping each unique XOR value to its indices in `x`. For each query, it checks if the XOR of the subarray `a[l-1:r]` is zero or if there exist indices within the subarray that satisfy certain conditions. If these conditions are met, it prints 'Yes'; otherwise, it prints 'No'. After processing all queries, the function does not return any value, but it has printed the results for each query.

