DEBUG - Start Task 1978_A
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-coder-32b-instruct
DEBUG - description: Alice has n books. The 1 -st book contains a_1 pages, the 2 -nd book contains
a_2 pages, \ldots , the n -th book contains a_n pages. Alice does the
following:

  * She divides all the books into two non-empty piles. Thus, each book ends up in exactly one of the two piles.
  * Alice reads one book with the highest number in each pile.

Alice loves reading very much. Help her find the maximum total number of pages
she can read by dividing the books into two piles.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 500 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \le n \le 100
) — the number of books Alice has.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the number of pages in each book.

Output

For each test case, output a single integer — the maximum number of pages
Alice can read.

Example

Input

    5
    
    2
    
    1 1
    
    4
    
    2 3 3 1
    
    5
    
    2 2 3 2 2
    
    2
    
    10 3
    
    3
    
    1 2 3

Output

    2
    4
    5
    13
    5
    
Note

In the first test case, Alice can put book number 1 in the first pile, and
book number 2 in the second pile. Then she will read a_1 + a_2 = 1 + 1 = 2
pages.

In the second test case, Alice can put books with numbers 2 and 3 in the first
pile, and books with numbers 1 and 4 in the second pile. Then she will read
the book with the highest number 3 from the first pile, and the book with the
highest number 4 from the second pile. Then she will read a_3 + a_4 = 3 + 1 =
4 pages.
DEBUG - Correctness: {'tester': 'Failed'}
DEBUG - Start Task 1930_B
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-coder-32b-instruct
DEBUG - description: You are given a positive integer n .

Find a permutation^\dagger p of length n such that there do not exist two
distinct indices i and j (1 \leq i, j < n ; i \neq j ) such that p_i divides
p_j and p_{i+1} divides p_{j+1} .

Refer to the Notes section for some examples.

Under the constraints of this problem, it can be proven that at least one p
exists.

^\dagger A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (3 \leq n \leq
10^5 ) — the length of the permutation p .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output p_1, p_2, \ldots, p_n .

If there are multiple solutions, you may output any one of them.

Example

Input

    2
    
    4
    
    3

Output

    4 1 2 3
    1 2 3
    
Note

In the first test case, p=[4,1,2,3] is a valid permutation. However, the
permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and
j=3 . Then p_1=1 divides p_3=3 and p_2=2 divides p_4=4 . Note that the
permutation p=[3, 4, 2, 1] is also not a valid permutation as we can choose
i=3 and j=2 . Then p_3=2 divides p_2=4 and p_4=1 divides p_3=2 .

In the second test case, p=[1,2,3] is a valid permutation. In fact, all 6
permutations of length 3 are valid.
DEBUG - Correctness: {'tester': 'Failed'}
DEBUG - Start Task 1926_E
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-coder-32b-instruct
DEBUG - description: Vladislav has n cards numbered 1, 2, \dots, n . He wants to lay them down in a
row as follows:

  * First, he lays down all the odd-numbered cards from smallest to largest. 
  * Next, he lays down all cards that are twice an odd number from smallest to largest (i.e. 2 multiplied by an odd number). 
  * Next, he lays down all cards that are 3 times an odd number from smallest to largest (i.e. 3 multiplied by an odd number). 
  * Next, he lays down all cards that are 4 times an odd number from smallest to largest (i.e. 4 multiplied by an odd number). 
  * And so on, until all cards are laid down. 

What is the k -th card he lays down in this process? Once Vladislav puts a
card down, he cannot use that card again.

Input

The first line contains an integer t (1 \leq t \leq 5 \cdot 10^4 ) — the
number of test cases.

The only line of each test case contains two integers n and k (1 \leq k \leq n
\leq 10^9 ) — the number of cards Vlad has, and the position of the card you
need to output.

Output

For each test case, output a single integer — the k -th card Vladislav lays
down.

Example

Input

    11
    
    7 1
    
    7 2
    
    7 3
    
    7 4
    
    7 5
    
    7 6
    
    7 7
    
    1 1
    
    34 14
    
    84 19
    
    1000000000 1000000000

Output

    1
    3
    5
    7
    2
    6
    4
    1
    27
    37
    536870912
    
Note

In the first seven test cases, n=7 . Vladislav lays down the cards as follows:

  * First — all the odd-numbered cards in the order 1 , 3 , 5 , 7 . 
  * Next — all cards that are twice an odd number in the order 2 , 6 . 
  * Next, there are no remaining cards that are 3 times an odd number. (Vladislav has only one of each card.) 
  * Next — all cards that are 4 times an odd number, and there is only one such card: 4 . 
  * There are no more cards left, so Vladislav stops. 

Thus the order of cards is 1 , 3 , 5 , 7 , 2 , 6 , 4 .
DEBUG - Correctness: {'tester': 'Failed'}
DEBUG - Start Task 1946_C
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-coder-32b-instruct
DEBUG - description: You are given a tree with n vertices.

Your task is to find the maximum number x such that it is possible to remove
exactly k edges from this tree in such a way that the size of each remaining
connected component^{\dagger} is at least x .

^{\dagger} Two vertices v and u are in the same connected component if there
exists a sequence of numbers t_1, t_2, \ldots, t_k of arbitrary length k ,
such that t_1 = v , t_k = u , and for each i from 1 to k - 1 , vertices t_i
and t_{i+1} are connected by an edge.

Input

Each test consists of several sets of input data. The first line contains a
single integer t (1 \le t \le 10^4 ) — the number of sets of input data. This
is followed by a description of the sets of input data.

The first line of each set of input data contains two integers n and k (1 \le
k < n \le 10^5 ) — the number of vertices in the tree and the number of edges
to be removed.

Each of the next n - 1 lines of each set of input data contains two integers v
and u (1 \le v, u \le n ) — the next edge of the tree.

It is guaranteed that the sum of the values of n for all sets of input data
does not exceed 10^5 .

Output

For each set of input data, output a single line containing the maximum number
x such that it is possible to remove exactly k edges from the tree in such a
way that the size of each remaining connected component is at least x .

Example

Input

    6
    
    5 1
    
    1 2
    
    1 3
    
    3 4
    
    3 5
    
    2 1
    
    1 2
    
    6 1
    
    1 2
    
    2 3
    
    3 4
    
    4 5
    
    5 6
    
    3 1
    
    1 2
    
    1 3
    
    8 2
    
    1 2
    
    1 3
    
    2 4
    
    2 5
    
    3 6
    
    3 7
    
    3 8
    
    6 2
    
    1 2
    
    2 3
    
    1 4
    
    4 5
    
    5 6

Output

    2
    1
    3
    1
    1
    2
    
Note

The tree in the first set of input data:

![](https://espresso.codeforces.com/799bacd3be0dda357800fdfc3eadbf38ab259c51.png)

After removing the edge 1 — 3 , the tree will look as follows:

![](https://espresso.codeforces.com/a59ae10eeac1212e1e56fc7fe5f6a47764269104.png)

The tree has split into two connected components. The first component consists
of two vertices: 1 and 2 . The second connected component consists of three
vertices: 3, 4 and 5 . In both connected components, there are at least two
vertices. It can be shown that the answer 3 is not achievable, so the answer
is 2 .
DEBUG - Correctness: {'tester': 'Failed'}
DEBUG - Start Task 1978_B
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-coder-32b-instruct
DEBUG - description: Bob decided to open a bakery. On the opening day, he baked n buns that he can
sell. The usual price of a bun is a coins, but to attract customers, Bob
organized the following promotion:

  * Bob chooses some integer k (0 \le k \le \min(n, b) ).
  * Bob sells the first k buns at a modified price. In this case, the price of the i -th (1 \le i \le k ) sold bun is (b - i + 1) coins.
  * The remaining (n - k) buns are sold at a coins each.

Note that k can be equal to 0 . In this case, Bob will sell all the buns at a
coins each.

Help Bob determine the maximum profit he can obtain by selling all n buns.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains three integers n , a , and b (1 \le
n, a, b \le 10^9 ) — the number of buns, the usual price of a bun, and the
price of the first bun to be sold at a modified price.

Output

For each test case, output a single integer — the maximum profit that Bob can
obtain.

Example

Input

    7
    
    4 4 5
    
    5 5 9
    
    10 10 5
    
    5 5 11
    
    1000000000 1000000000 1000000000
    
    1000000000 1000000000 1
    
    1000 1 1000

Output

    17
    35
    100
    45
    1000000000000000000
    1000000000000000000
    500500
    
Note

In the first test case, it is optimal for Bob to choose k = 1 . Then he will
sell one bun for 5 coins, and three buns at the usual price for 4 coins each.
Then the profit will be 5 + 4 + 4 + 4 = 17 coins.

In the second test case, it is optimal for Bob to choose k = 5 . Then he will
sell all the buns at the modified price and obtain a profit of 9 + 8 + 7 + 6 +
5 = 35 coins.

In the third test case, it is optimal for Bob to choose k = 0 . Then he will
sell all the buns at the usual price and obtain a profit of 10 \cdot 10 = 100
coins.
DEBUG - Correctness: {'tester': 'Failed'}
DEBUG - Start Task 1919_C
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-coder-32b-instruct
DEBUG - description: You are given an array a of size n . You will do the following process to
calculate your penalty:

  1. Split array a into two (possibly empty) subsequences^\dagger s and t such that every element of a is either in s or t^\ddagger . 
  2. For an array b of size m , define the penalty p(b) of an array b as the number of indices i between 1 and m - 1 where b_i < b_{i + 1} . 
  3. The total penalty you will receive is p(s) + p(t) . 

If you perform the above process optimally, find the minimum possible penalty
you will receive.

^\dagger A sequence x is a subsequence of a sequence y if x can be obtained
from y by the deletion of several (possibly, zero or all) elements.

^\ddagger Some valid ways to split array a=[3,1,4,1,5] into (s,t) are
([3,4,1,5],[1]) , ([1,1],[3,4,5]) and ([\,],[3,1,4,1,5]) while some invalid
ways to split a are ([3,4,5],[1]) , ([3,1,4,1],[1,5]) and ([1,3,4],[5,1]) .

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1\le n\le 2\cdot
10^5 ) — the size of the array a .

The second line contains n integers a_1, a_2, \ldots, a_n (1 \le a_i \le n ) —
the elements of the array a .

It is guaranteed that the sum of n over all test cases does not exceed 2\cdot
10^5 .

Output

For each test case, output a single integer representing the minimum possible
penalty you will receive.

Example

Input

    5
    
    5
    
    1 2 3 4 5
    
    8
    
    8 2 3 1 1 7 4 3
    
    5
    
    3 3 3 3 3
    
    1
    
    1
    
    2
    
    2 1

Output

    3
    1
    0
    0
    0
    
Note

In the first test case, a possible way to split a is s=[2,4,5] and t=[1,3] .
The penalty is p(s)+p(t)=2 + 1 =3 .

In the second test case, a possible way to split a is s=[8,3,1] and
t=[2,1,7,4,3] . The penalty is p(s)+p(t)=0 + 1 =1 .

In the third test case, a possible way to split a is s=[\,] and t=[3,3,3,3,3]
. The penalty is p(s)+p(t)=0 + 0 =0 .
DEBUG - Correctness: {'tester': 'Failed'}
DEBUG - Start Task 1930_A
