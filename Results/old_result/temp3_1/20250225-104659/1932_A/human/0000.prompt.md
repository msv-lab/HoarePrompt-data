
Your task is to generate a Python script with assertions to test the correctness of a given Python program, based on the provided problem description. Assume valid inputs as described in the problem description.

The output must be a complete Python script with assertions that verify the program’s correctness. Do not execute the program yourself; just provide the test code.

If the program defines a function, import it and test it by calling the function directly with arguments and using assertions on its return values.

If the program does not define functions but executes directly, use the following helper function to automate input/output capture and execute `program.py` safely:

import io
import sys

def run_program_with_captured_io(input_data):
    original_stdin = sys.stdin
    original_stdout = sys.stdout

    try:
        sys.stdin = io.StringIO(input_data)
        captured_output = io.StringIO()
        sys.stdout = captured_output

        with open("program.py", "r", encoding="utf-8") as f:
            code = f.read()
            exec(code, {})

        return captured_output.getvalue().strip()
    
    finally:
        sys.stdin = original_stdin
        sys.stdout = original_stdout


# Problem:
During your journey through computer universes, you stumbled upon a very
interesting world. It is a path with n consecutive cells, each of which can
either be empty, contain thorns, or a coin. In one move, you can move one or
two cells along the path, provided that the destination cell does not contain
thorns (and belongs to the path). If you move to the cell with a coin, you
pick it up.

![](https://espresso.codeforces.com/34bd88a4aba4a1ae98e5681455c4a47900b7b9a8.png)
Here, green arrows correspond to legal moves, and the red arrow corresponds to
an illegal move.

You want to collect as many coins as possible. Find the maximum number of
coins you can collect in the discovered world if you start in the leftmost
cell of the path.

Input

The first line of input contains a single integer t (1 \le t \le 1000 ) — the
number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 50 )
— the length of the path.

The second line of each test case contains a string of n characters, the
description of the path. The character '.' denotes an empty cell, '@' denotes
a cell with a coin, and '*' denotes a cell with thorns. It is guaranteed that
the first cell is empty.

Output

For each test case, output a single integer, the maximum number of coins you
can collect.

Example

Input

    3
    
    10
    
    .@@*@.**@@
    
    5
    
    .@@@@
    
    15
    
    .@@..@***..@@@*

Output

    3
    4
    3
    
Note

The picture for the first example is in the problem statement.

Here is the picture for the second example:

![](https://espresso.codeforces.com/68fd7116585f37e79535fbc164a552cc8e148b75.png)

And here is the picture for the third example:

![](https://espresso.codeforces.com/1695fc45669a1bf1d6e1b3d4901cdd3cda38273c.png)

# Program:
def func():
    for _ in range(int(input())):
        len = int(input())
        s = list(input())
        ret = 0
        thorn = 0
        for i in s:
            if i == '@':
                thorn = 0
                ret += 1
            elif i == '*':
                thorn += 1
                if thorn == 2:
                    break
            else:
                thorn = 0
        print(ret)



# Your response:
```python
# Include necessary imports if any
# Assume the provided program is saved as 'program.py' and can be imported from the same dir.

#if there is a specific function we can call import it
from program import *
#otherwise use the run_program_with_captured_io(input_data) function to run the program and capture the output

# Write your test cases below
# Each test case should include assertions based on the problem description
# Example:
# assert function_name(input) == expected_output

# or if the program is a script we must execute 
# input_data = "input data"
# expected_output = "expected output"
# assert run_program_with_captured_io(input_data) == expected_output 
# Add multiple test cases to ensure correctness across edge cases


# End of script
```
