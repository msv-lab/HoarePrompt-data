
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Let's imagine the surface of Mars as an infinite coordinate plane. Initially,
the rover Perseverance-2 and the helicopter Ingenuity-2 are located at the
point with coordinates (0, 0) . A set of instructions s consisting of n
instructions of the following types was specially developed for them:

  * N: move one meter north (from point (x, y) to (x, y + 1) ); 
  * S: move one meter south (from point (x, y) to (x, y - 1) ); 
  * E: move one meter east (from point (x, y) to (x + 1, y) ); 
  * W: move one meter west (from point (x, y) to (x - 1, y) ). 

Each instruction must be executed either by the rover or by the helicopter.
Moreover, each device must execute at least one instruction. Your task is to
distribute the instructions in such a way that after executing all n
instructions, the helicopter and the rover end up at the same point, or
determine that this is impossible.

Input

The first line of input contains t (1 \leq t \leq 10^4 ) — the number of test
cases.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of instructions.

The second line of each test case contains a string s of length n consisting
of the characters 'N', 'S', 'E', 'W' — the sequence of instructions.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10 ^ 5 .

Output

For each test case, if the required distribution of instructions exists,
output a string p of length n consisting of the characters 'R', 'H'. If the i
-th operation should be executed by the rover, then p_i=\text{R} , if the i
-th operation should be executed by the helicopter, then p_i=\text{H} . If
there are multiple solutions, output any of them.

Otherwise, output NO.

Example

Input

    10
    
    6
    
    NENSNE
    
    3
    
    WWW
    
    6
    
    NESSWS
    
    2
    
    SN
    
    2
    
    WE
    
    4
    
    SSNN
    
    4
    
    WESN
    
    2
    
    SS
    
    4
    
    EWNN
    
    4
    
    WEWE

Output

    RRHRRH
    NO
    HRRHRH
    NO
    NO
    RHRH
    RRHH
    RH
    RRRH
    RRHH

Note

Let's consider the first example: the string S = \texttt{NENSNE} . One of the
possible solutions, shown in the figure below, is p = \texttt{RRHRRH} , using
which both the rover and the helicopter will end up one meter north and one
meter east.

![](https://espresso.codeforces.com/bb4cbb5897ef7ab4afcc336d45457d0bb9d07c2c.png)

For WWW, the solution is impossible.

- Program: 
import sys

input = sys.stdin.read
data = input().split()
t = int(data[0])
index = 1
results = []
for _ in range(t):
    n = int(data[index])
    index += 1
    s = data[index]
    index += 1
    results.append(func_1(n, s))
print('\n'.join(results))

def func_1(n, s):
    count_north = 0
    count_south = 0
    count_east = 0
    count_west = 0
    for char in s:
        if char == 'N':
            count_north += 1
        elif char == 'S':
            count_south += 1
        elif char == 'E':
            count_east += 1
        else:
            count_west += 1
    if count_north != count_south or count_east != count_west:
        return 'NO'
    result = []
    i = 0
    while i < len(s):
        if s[i] == 'N' or s[i] == 'S':
            if s[i] == 'N':
                result.append('R')
                count_north -= 1
            else:
                result.append('H')
                count_south -= 1
            i += 1
        elif s[i] == 'E' or s[i] == 'W':
            if s[i] == 'E':
                result.append('R')
                count_east -= 1
            else:
                result.append('H')
                count_west -= 1
            i += 1
    return ''.join(result)



- Annotated Code: 
import sys

input = sys.stdin.read
data = input().split()
t = int(data[0])
index = 1
results = []
for _ in range(t):
    n = int(data[index])
    index += 1
    s = data[index]
    index += 1
    results.append(func_1(n, s))
print('\n'.join(results))

#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 2 \cdot 10^5, and s is a string consisting of 'N', 'S', 'E', 'W' with length n. Additionally, there are t test cases such that 1 ≤ t ≤ 10^4, and the sum of n over all test cases does not exceed 2 \cdot 10^5.
def func_1(n, s):
    count_north = 0
    count_south = 0
    count_east = 0
    count_west = 0
    for char in s:
        if char == 'N':
            count_north += 1
        elif char == 'S':
            count_south += 1
        elif char == 'E':
            count_east += 1
        else:
            count_west += 1
        
    #State of the program after the  for loop has been executed: `count_north` is the number of 'N' characters in the string `s`, `count_south` is the number of 'S' characters in the string `s`, `count_east` is the number of 'E' characters in the string `s`, `count_west` is the number of 'W' characters in the string `s`, `n` is an integer such that \(1 \leq n \leq 2 \cdot 10^5\), `s` is a string consisting of 'N', 'S', 'E', 'W' with length `n`, `t` is an integer such that \(1 \leq t \leq 10^4\).
    if (count_north != count_south or count_east != count_west) :
        return 'NO'
        #The program returns 'NO'
    #State of the program after the if block has been executed: Postcondition: `count_north` is the number of 'N' characters in the string `s`, `count_south` is the number of 'S' characters in the string `s`, `count_east` is the number of 'E' characters in the string `s`, `count_west` is the number of 'W' characters in the string `s`, `n` is an integer such that \(1 \leq n \leq 2 \cdot 10^5\), `s` is a string consisting of 'N', 'S', 'E', 'W' with length `n`, `t` is an integer such that \(1 \leq t \leq 10^4\). Additionally, `count_north == count_south` and `count_east == count_west`.
    result = []
    i = 0
    while i < len(s):
        if s[i] == 'N' or s[i] == 'S':
            if s[i] == 'N':
                result.append('R')
                count_north -= 1
            else:
                result.append('H')
                count_south -= 1
            i += 1
        elif s[i] == 'E' or s[i] == 'W':
            if s[i] == 'E':
                result.append('R')
                count_east -= 1
            else:
                result.append('H')
                count_west -= 1
            i += 1
        
    #State of the program after the loop has been executed: `i` is equal to `len(s)`, `result` is a list containing 'R' and 'H' based on the values in `s`, `count_north` and `count_south` are equal if all 'N' and 'S' characters were processed, and `count_east` and `count_west` are equal if all 'E' and 'W' characters were processed. If there are remaining 'N' or 'S' characters, `count_north` will be one more than `count_south`, and if there are remaining 'E' or 'W' characters, `count_east` will be one more than `count_west`.
    return ''.join(result)
    #The program returns a string created by joining the elements in the list 'result', which contains 'R' and 'H' based on the values in 's'
#Overall this is what the function does:The function `func_1` accepts two parameters: `n` and `s`. 

- `n` is an integer such that \(1 \leq n \leq 2 \cdot 10^5\).
- `s` is a string consisting of 'N', 'S', 'E', 'W' with length `n`.

The function first counts the occurrences of 'N', 'S', 'E', and 'W' in the string `s`. It then checks if the counts of 'N' and 'S' are equal and the counts of 'E' and 'W' are equal. If these conditions are not met, it returns 'NO'.

If the conditions are met, it constructs a new string based on the characters in `s`. For each 'N' in `s`, it appends 'R' to the result list and decreases the count of 'N'. For each 'S' in `s`, it appends 'H' to the result list and decreases the count of 'S'. Similarly, for each 'E' in `s`, it appends 'R' to the result list and decreases the count of 'E'. For each 'W' in `s`, it appends 'H' to the result list and decreases the count of 'W'. After processing all characters, it returns a string created by joining the elements in the result list.


Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided program does not handle the requirement that each device must execute at least one instruction. For example, consider the input `1` for the number of test cases and `1` for the number of instructions, with the string `N`. According to the problem description, the solution should include at least one 'R' and one 'H', but the current implementation does not ensure this. Instead, it simply checks if the counts of 'N' and 'S' and 'E' and 'W' are equal and returns 'NO' if they are not. This fails to distribute the instructions correctly to satisfy the condition that each device executes at least one instruction.

To fix this, the program should explicitly ensure that both 'R' and 'H' are included in the result if the conditions are met. Here is a modified version of the function that ensures this:

```python
def func_1(n, s):
    count_north = 0
    count_south = 0
    count_east = 0
    count_west = 0
    for char in s:
        if char == 'N':
            count_north += 1
        elif char == 'S':
            count_south += 1
        elif char == 'E':
            count_east += 1
        else:
            count_west += 1
    if count_north != count_south or count_east != count_west:
        return 'NO'
    
    result = []
    i = 0
    while i < len(s):
        if s[i] == 'N' or s[i] == 'S':
            if s[i] == 'N':
                result.append('R')
                count_north -= 1
            else:
                result.append('H')
                count_south -= 1
            i += 1
        elif s[i] == 'E' or s[i] == 'W':
            if s[i] == 'E':
                result.append('R')
                count_east -= 1
            else:
                result.append('H')
                count_west -= 1
            i += 1
    
    # Ensure each device executes at least one instruction
    if 'R' not in result:
        result[0] = 'R'
    if 'H' not in result:
        result[-1] = 'H'
    
    return ''.join(result)
```

This modification ensures that the function adheres to the requirement that each device must execute at least one instruction.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

