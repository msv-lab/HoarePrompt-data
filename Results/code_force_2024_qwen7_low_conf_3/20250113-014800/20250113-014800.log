DEBUG - Start Task 325
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: This is the easy version of the problem. The only difference between the two
versions is the constraint on t and n . You can make hacks only if both
versions of the problem are solved.

For a binary^\dagger pattern p and a binary string q , both of length m , q is
called p -good if for every i (1 \leq i \leq m ), there exist indices l and r
such that:

  * 1 \leq l \leq i \leq r \leq m , and 
  * p_i is a mode^\ddagger of the string q_l q_{l+1} \ldots q_{r} . 

For a pattern p , let f(p) be the minimum possible number of \mathtt{1} s in a
p -good binary string (of the same length as the pattern).

You are given a binary string s of size n . Find

In other words, you need to sum the values of f over all \frac{n(n+1)}{2}
substrings of s .

^\dagger A binary pattern is a string that only consists of characters
\mathtt{0} and \mathtt{1} .

^\ddagger Character c is a mode of string t of length m if the number of
occurrences of c in t is at least \lceil \frac{m}{2} \rceil . For example,
\mathtt{0} is a mode of \mathtt{010} , \mathtt{1} is not a mode of
\mathtt{010} , and both \mathtt{0} and \mathtt{1} are modes of \mathtt{011010}
.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 100
) — the length of the binary string s .

The second line of each test case contains a binary string s of length n
consisting of only characters \mathtt{0} and \mathtt{1} .

It is guaranteed that the sum of n^2 over all test cases does not exceed 10^4
.

Output

For each test case, output the sum of values of f over all substrings of s .

Example

Input

    4
    
    1
    
    1
    
    2
    
    10
    
    5
    
    00000
    
    20
    
    11110110000000111111

Output

    1
    2
    0
    346
    
Note

In the first test case, the only \mathtt{1} -good string is \mathtt{1} . Thus,
f(\mathtt{1})=1 .

In the second test case, f(\mathtt{10})=1 because \mathtt{01} is \mathtt{10}
-good, and \mathtt{00} is not \mathtt{10} -good. Thus, the answer is
f(\mathtt{1})+f(\mathtt{10})+f(\mathtt{0}) = 1 + 1 + 0 = 2 .

In the third test case, f equals to 0 for all 1 \leq i \leq j \leq 5 . Thus,
the answer is 0 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 326
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There are 2n positive integers written on a whiteboard. Being bored, you
decided to play a one-player game with the numbers on the whiteboard.

You start with a score of 0 . You will increase your score by performing the
following move exactly n times:

  * Choose two integers x and y that are written on the whiteboard. 
  * Add \min(x,y) to your score. 
  * Erase x and y from the whiteboard. 

Note that after performing the move n times, there will be no more integers
written on the whiteboard.

Find the maximum final score you can achieve if you optimally perform the n
moves.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 5000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \leq n \leq 50
) — the number of integers written on the whiteboard is 2n .

The second line of each test case contains 2n integers a_1,a_2,\ldots,a_{2n}
(1 \leq a_i \leq 10^7 ) — the numbers written on the whiteboard.

Output

For each test case, output the maximum final score that you can achieve.

Example

Input

    3
    
    1
    
    2 3
    
    2
    
    1 1 2 1
    
    3
    
    1 1 1 1 1 1

Output

    2
    2
    3
    
Note

In the first test case, you can only make one move. You select x=2 and y=3 ,
and your score will be \min(x,y)=2 .

In the second test case, the following is a sequence of moves that achieves a
final score of 2 :

  * In the first move, select x=1 and y=1 . Then, add \min(x,y)=1 to the score. After erasing x and y , the integers left on the whiteboard are 1 and 2 . 
  * In the second move, select x=1 and y=2 . Then, add \min(x,y)=1 to the score. After removing x and y , no more integers will be left on the whiteboard. 

It can be proved that it is not possible to get a score greater than 2 .

In the third test case, you will perform the move thrice, adding 1 to the
score each time.
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 155
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: [Rammstein - Ausländer](https://youtu.be/3eEA6H_y1VI)

ඞ

There are m baskets placed along a circle, numbered from 1 to m in clockwise
order (basket m is next to basket 1 ). Furthermore, there are n balls, where
ball i is initially placed in basket a_i , and no basket contains more than
one ball.

Alice is allowed to perform the following operation, which always takes
exactly one second whether you move/throw a ball or not:

  * Alice chooses an integer i between 1 and n uniformly at random. 
  * If ball i was thrown away before, do nothing. 
  * Otherwise, ball i is moved from the basket currently containing it to the next basket (in clockwise order). If the target basket currently contains another ball j , throw ball j away. 

She repeats this operation until there is exactly one ball left. Calculate the
expected time needed (in seconds) for Alice to end the process.

It can be proven that the answer can be represented as a rational number
\frac{p}{q} with coprime p and q . You need to output p \cdot q^{-1} \bmod
10^9 + 7 . It can be proven that 10^9 + 7 \nmid q .

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains two integers n and m (1 \le n \le 3
\cdot 10^5, n \le m \le 10^9 ) — the number of balls and the number of
baskets.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le m , a_i 's are pairwise distinct) — the initial position of each
ball.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, print one integer: the expected amount of time (in
seconds) Alice needs to end the process, modulo 10^9 + 7 .

Example

Input

    5
    
    3 10
    
    5 1 4
    
    2 15
    
    15 1
    
    6 6
    
    1 2 3 4 5 6
    
    6 9
    
    6 5 4 3 2 1
    
    1 100
    
    69

Output

    600000042
    14
    35
    333333409
    0
    
Note

In the first test case, Alice could have proceeded as follows (we define a_i =
-1 if ball i has been thrown out):

  * Initially, a = [5, 1, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 2 . After this, a = [5, 2, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 3 . After this, a = [5, 3, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 4 . As basket 4 previously contains ball 3 , this ball is thrown out. After this, a = [5, 4, -1] . 
  * Alice chooses i = 3 with probability \frac{1}{3} . Ball 3 has already been thrown out, so nothing happens. After this, a = [5, 4, -1] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 5 , which throws out ball 1 . After this, a = [-1, 5, -1] , and the process ends. 

The answer for this test case is \frac{189}{5} .

The answer for the second test case is 14 (note that these two balls are next
to each other).

The answer for the third test case is 35 .

The answer for the fourth test case is \frac{220}{3} .

In the fifth test case, as there is only one ball initially, the answer is 0 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 117
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have a horizontal strip of n cells. Each cell is either white or black.

You can choose a continuous segment of cells once and paint them all white.
After this action, all the black cells in this segment will become white, and
the white ones will remain white.

What is the minimum length of the segment that needs to be painted white in
order for all n cells to become white?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 10 )
— the length of the strip.

The second line of each test case contains a string s , consisting of n
characters, each of which is either 'W' or 'B'. The symbol 'W' denotes a white
cell, and 'B' — a black one. It is guaranteed that at least one cell of the
given strip is black.

Output

For each test case, output a single number — the minimum length of a
continuous segment of cells that needs to be painted white in order for the
entire strip to become white.

Example

Input

    8
    
    6
    
    WBBWBW
    
    1
    
    B
    
    2
    
    WB
    
    3
    
    BBW
    
    4
    
    BWWB
    
    6
    
    BWBWWB
    
    6
    
    WWBBWB
    
    9
    
    WBWBWWWBW

Output

    4
    1
    1
    2
    4
    6
    4
    7
    
Note

In the first test case of the example for the strip "WBBWBW", the minimum
length of the segment to be repainted white is 4 . It is necessary to repaint
to white the segment from the 2 -nd to the 5 -th cell (the cells are numbered
from 1 from left to right).
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 227
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given two integers x and y .

Output two integers: the minimum of x and y , followed by the maximum of x and
y .

Input

The first line contains a single integer t (1 \leq t \leq 100 ) — the number
of test cases.

The only line of each test case contains two space-separated integers x and y
(0 \leq x, y \leq 9 ).

Output

For each test case, output two integers: the minimum of x and y , followed by
the maximum of x and y .

Example

Input

    10
    
    1 9
    
    8 4
    
    1 4
    
    3 4
    
    2 0
    
    2 4
    
    6 9
    
    3 3
    
    0 0
    
    9 9

Output

    1 9
    4 8
    1 4
    3 4
    0 2
    2 4
    6 9
    3 3
    0 0
    9 9
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 234
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 27
ERROR - Error: Error code: 400 - {'error': {'code': 'RequestTimeOut', 'param': None, 'message': 'Request timed out, please try again later.', 'type': 'RequestTimeOut'}, 'id': 'chatcmpl-a1c96b83-dc82-9eca-a750-cd35eae81218', 'request_id': 'a1c96b83-dc82-9eca-a750-cd35eae81218'}
DEBUG - Start Task 313
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: n ships set out to explore the depths of the ocean. The ships are numbered
from 1 to n and follow each other in ascending order; the i -th ship has a
durability of a_i .

The Kraken attacked the ships k times in a specific order. First, it attacks
the first of the ships, then the last, then the first again, and so on.

Each attack by the Kraken reduces the durability of the ship by 1 . When the
durability of the ship drops to 0 , it sinks and is no longer subjected to
attacks (thus the ship ceases to be the first or last, and the Kraken only
attacks the ships that have not yet sunk). If all the ships have sunk, the
Kraken has nothing to attack and it swims away.

For example, if n=4 , k=5 , and a=[1, 2, 4, 3] , the following will happen:

  1. The Kraken attacks the first ship, its durability becomes zero and now a = [2, 4, 3] ; 
  2. The Kraken attacks the last ship, now a = [2, 4, 2] ; 
  3. The Kraken attacks the first ship, now a = [1, 4, 2] ; 
  4. The Kraken attacks the last ship, now a = [1, 4, 1] ; 
  5. The Kraken attacks the first ship, its durability becomes zero and now a = [4, 1] . 

How many ships were sunk after the Kraken's attack?

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains two integers n and k (1 \le n \le 2
\cdot 10^5 , 1 \le k \le 10^{15} ) — the number of ships and how many times
the Kraken will attack the ships.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (1
\le a_i \le 10^9 ) — the durability of the ships.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output the number of ships sunk by the Kraken on a
separate line.

Example

Input

    6
    
    4 5
    
    1 2 4 3
    
    4 6
    
    1 2 4 3
    
    5 20
    
    2 7 1 8 2
    
    2 2
    
    3 2
    
    2 15
    
    1 5
    
    2 7
    
    5 2

Output

    2
    3
    5
    0
    2
    2
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 202
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have a strip of paper with a binary string s of length n . You can fold
the paper in between any pair of adjacent digits.

A set of folds is considered valid if after the folds, all characters that are
on top of or below each other match. Note that all folds are made at the same
time, so the characters don't have to match in between folds.

For example, these are valid foldings of s = \mathtt{110110110011} and s =
\mathtt{01110} :

![](https://espresso.codeforces.com/a961dc7cc221603a7d5a488247ba5439ce7444da.png)

The length of the folded strip is the length seen from above after all folds
are made. So for the two above examples, after the folds shown above, the
lengths would be 7 and 3 , respectively.

Notice that for the above folding of s = \mathtt{01110} , if we made either of
the two folds on their own, that would not be a valid folding. However,
because we don't check for validity until all folds are made, this folding is
valid.

After performing a set of valid folds, what is the minimum length strip you
can form?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le
2\cdot 10^5 ) — the size of the strip.

The second line of each test case contains a string s of n characters '0' and
'1' — a description of the digits on the strip.

It is guaranteed that the sum of n over all test cases does not exceed 2\cdot
10^5 .

Output

For each test case, output a single integer — the minimum possible length of
the strip after a valid folding.

Example

Input

    6
    
    6
    
    101101
    
    1
    
    0
    
    12
    
    110110110011
    
    5
    
    01110
    
    4
    
    1111
    
    2
    
    01

Output

    3
    1
    3
    3
    1
    2
    
Note

For the first example case, one optimal folding is to fold the strip in the
middle, which produces a strip of length 3.

The third and fourth example cases correspond to the images above. Note that
the folding shown above for s = \mathtt{110110110011} is not of minimal
length.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 117
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have a horizontal strip of n cells. Each cell is either white or black.

You can choose a continuous segment of cells once and paint them all white.
After this action, all the black cells in this segment will become white, and
the white ones will remain white.

What is the minimum length of the segment that needs to be painted white in
order for all n cells to become white?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 10 )
— the length of the strip.

The second line of each test case contains a string s , consisting of n
characters, each of which is either 'W' or 'B'. The symbol 'W' denotes a white
cell, and 'B' — a black one. It is guaranteed that at least one cell of the
given strip is black.

Output

For each test case, output a single number — the minimum length of a
continuous segment of cells that needs to be painted white in order for the
entire strip to become white.

Example

Input

    8
    
    6
    
    WBBWBW
    
    1
    
    B
    
    2
    
    WB
    
    3
    
    BBW
    
    4
    
    BWWB
    
    6
    
    BWBWWB
    
    6
    
    WWBBWB
    
    9
    
    WBWBWWWBW

Output

    4
    1
    1
    2
    4
    6
    4
    7
    
Note

In the first test case of the example for the strip "WBBWBW", the minimum
length of the segment to be repainted white is 4 . It is necessary to repaint
to white the segment from the 2 -nd to the 5 -th cell (the cells are numbered
from 1 from left to right).
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 338
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Alice and Bob have bought a ribbon consisting of n parts. Now they want to
paint it.

First, Alice will paint every part of the ribbon into one of m colors. For
each part, she can choose its color arbitrarily.

Then, Bob will choose at most k  parts of the ribbon and repaint them into the
same color (he chooses the affected parts and the color arbitrarily).

Bob would like all parts to have the same color. However, Alice thinks that
this is too dull, so she wants to paint the ribbon in such a way that Bob
cannot make all parts have the same color.

Is it possible to paint the ribbon in such a way?

Input

The first line contains one integer t (1 \le t \le 1000 ) — the number of test
cases.

Each test case consists of one line containing three integers n , m and k (1
\le m, k \le n \le 50 ) — the number of parts, the number of colors and the
number of parts Bob can repaint, respectively.

Output

For each test case, print YES if Alice can paint the ribbon so that Bob cannot
make all parts have the same color. Otherwise, print NO.

You can print every letter in any register. For example, Yes, yes, yEs will
all be recognized as positive answer.

Example

Input

    5
    
    1 1 1
    
    5 1 1
    
    5 2 1
    
    5 2 2
    
    5 5 3

Output

    NO
    NO
    YES
    NO
    YES
    
Note

In the first test case, a ribbon consists of 1 part. So all its parts will
always have the same color.

In the second test case, there is only 1 color.

In the third test case, Alice can paint the ribbon as follows: [1, 2, 1, 2, 1]
. It's impossible to change the color of at most 1 part so that all parts have
the same color.

In the fourth test case, no matter how Alice paints the ribbon, Bob will
always be able to repaint 2 parts so that all parts have the same color.

In the fifth test case, Alice can paint the ribbon as follows: [1, 2, 3, 4, 5]
. It's impossible to change the color of at most 3 parts so that all parts
have the same color.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 266
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There is a grid, consisting of 2 rows and n columns. The rows are numbered
from 1 to 2 from top to bottom. The columns are numbered from 1 to n from left
to right. Each cell of the grid contains an arrow pointing either to the left
or to the right. No arrow points outside the grid.

There is a robot that starts in a cell (1, 1) . Every second, the following
two actions happen one after another:

  1. Firstly, the robot moves left, right, down or up (it can't try to go outside the grid, and can't skip a move); 
  2. then it moves along the arrow that is placed in the current cell (the cell it ends up after its move). 

Your task is to determine whether the robot can reach the cell (2, n) .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer (2 \le n \le 2
\cdot 10^5 ).

The second line contains a string consisting of exactly n characters < and/or
> — the first row of the grid.

The third line contains a string consisting of exactly n characters < and/or >
— the second row of the grid.

Additional constraints on the input:

  * n is even; 
  * there are no arrows pointing outside the grid; 
  * the sum of n over all test cases doesn't exceed 2 \cdot 10^5 . 

Output

For each test case, print YES if the robot can reach the cell (2, n) ;
otherwise, print NO.

You can print each letter in any case. For example, yes, Yes, YeS will all be
recognized as positive answer.

Example

Input

    4
    
    4
    
    >><<
    
    >>><
    
    2
    
    ><
    
    ><
    
    4
    
    >>><
    
    >><<
    
    6
    
    >><<><
    
    ><>>><

Output

    YES
    YES
    NO
    YES
    
Note

In the first example, one of the possible paths looks as follows: (1, 1)
\rightarrow (1, 2) \rightarrow (1, 3) \rightarrow (2, 3) \rightarrow (2, 4) .

In the second example, one of the possible paths looks as follows: (1, 1)
\rightarrow (2, 1) \rightarrow (2, 2) .

In the third example, there is no way to reach the cell (2, 4) .

In the fourth example, one of the possible paths looks as follows: (1, 1)
\rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (1, 2) \rightarrow (1, 3)
\rightarrow (2, 3) \rightarrow (2, 4) \rightarrow (2, 5) \rightarrow (2, 6) .
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 215
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Bob decided to open a bakery. On the opening day, he baked n buns that he can
sell. The usual price of a bun is a coins, but to attract customers, Bob
organized the following promotion:

  * Bob chooses some integer k (0 \le k \le \min(n, b) ).
  * Bob sells the first k buns at a modified price. In this case, the price of the i -th (1 \le i \le k ) sold bun is (b - i + 1) coins.
  * The remaining (n - k) buns are sold at a coins each.

Note that k can be equal to 0 . In this case, Bob will sell all the buns at a
coins each.

Help Bob determine the maximum profit he can obtain by selling all n buns.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains three integers n , a , and b (1 \le
n, a, b \le 10^9 ) — the number of buns, the usual price of a bun, and the
price of the first bun to be sold at a modified price.

Output

For each test case, output a single integer — the maximum profit that Bob can
obtain.

Example

Input

    7
    
    4 4 5
    
    5 5 9
    
    10 10 5
    
    5 5 11
    
    1000000000 1000000000 1000000000
    
    1000000000 1000000000 1
    
    1000 1 1000

Output

    17
    35
    100
    45
    1000000000000000000
    1000000000000000000
    500500
    
Note

In the first test case, it is optimal for Bob to choose k = 1 . Then he will
sell one bun for 5 coins, and three buns at the usual price for 4 coins each.
Then the profit will be 5 + 4 + 4 + 4 = 17 coins.

In the second test case, it is optimal for Bob to choose k = 5 . Then he will
sell all the buns at the modified price and obtain a profit of 9 + 8 + 7 + 6 +
5 = 35 coins.

In the third test case, it is optimal for Bob to choose k = 0 . Then he will
sell all the buns at the usual price and obtain a profit of 10 \cdot 10 = 100
coins.
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 299
ERROR - Error: pop from empty list
DEBUG - Start Task 29
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The two versions are different problems. You may want to read both versions.
You can make hacks only if both versions are solved.

You are given two positive integers n , m .

Calculate the number of ordered pairs (a, b) satisfying the following
conditions:

  * 1\le a\le n , 1\le b\le m ; 
  * a+b is a multiple of b \cdot \gcd(a,b) . 

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\le t\le 10^4 ). The description of the test cases follows.

The first line of each test case contains two integers n , m (1\le n,m\le 2
\cdot 10^6 ).

It is guaranteed that neither the sum of n nor the sum of m over all test
cases exceeds 2 \cdot 10^6 .

Output

For each test case, print a single integer: the number of valid pairs.

Example

Input

    6
    
    1 1
    
    2 3
    
    3 5
    
    10 8
    
    100 1233
    
    1000000 1145141

Output

    1
    3
    4
    14
    153
    1643498
    
Note

In the first test case, only (1,1) satisfies the conditions.

In the fourth test case,
(1,1),(2,1),(2,2),(3,1),(4,1),(5,1),(6,1),(6,2),(6,3),(7,1),(8,1),(9,1),(10,1),(10,2)
satisfy the conditions.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 164
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There is a game where you need to move through a labyrinth. The labyrinth
consists of n platforms, connected by m passages.

Each platform is at some level l_i , an integer number from 0 to H - 1 . In a
single step, if you are currently on platform i , you can stay on it, or move
to another platform j . To move to platform j they have to be connected by the
passage, and their levels have to be the same, namely l_i = l_j .

After each step, the levels of all platforms change. The new level of platform
i is calculated as l'_i = (l_i + s_i) \bmod H , for all i .

You start on platform 1 . Find the minimum number of steps you need to get to
platform n .

Input

The first line of input contains a single integer t (1 \le t \le 10^4 ) — the
number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains three integers n , m , and H (2 \le
n \le 10^5 , 1 \le m \le 10^5 , 1 \le H \le 10^9 ).

The second line contains n integers l_i , the initial level of each platform
(0 \le l_i \le H-1 ).

The third line contains n integers s_i , the change of level for each platform
(0 \le s_i \le H-1 ).

Next m lines contain a description of the passages. Each passage is described
as a pair of integers — the platforms, connected by the passage. There is at
most one passage connecting each pair of platforms, and there is no passage
connecting a platform to itself.

The sum of n for all tests does not exceed 10^5 , the sum of m for all tests
does not exceed 10^5 .

Output

For each test case, print a single integer, the minimum number of steps needed
to get from platform 1 to platform n .

If it is impossible to get to platform n , print -1 .

Example

Input

    3
    
    3 3 10
    
    1 9 4
    
    2 3 0
    
    1 2
    
    3 2
    
    1 3
    
    2 1 10
    
    1 2
    
    4 6
    
    1 2
    
    8 7 25
    
    22 14 5 3 10 14 11 1
    
    9 5 4 10 7 16 18 18
    
    2 8
    
    6 3
    
    3 5
    
    7 5
    
    2 6
    
    1 4
    
    4 7

Output

    6
    -1
    52
    
Note

This is how levels of the platforms change, and what actions we need to
perform in the first example.

| Platform 1| Platform 2| Platform 3| Action  
---|---|---|---|---  
Step 1| 1| 9| 4| Stay on the platform 1  
Step 2| 3| 2| 4| Stay on the platform 1  
Step 3| 5| 5| 4| Move to the platform 2  
Step 4| 7| 8| 4| Stay on the platform 2  
Step 5| 9| 1| 4| Stay on the platform 2  
Step 6| 1| 4| 4| Move to the platform 3
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 163
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There is a fun game where you need to feed cats that come and go. The level of
the game consists of n steps. There are m cats; the cat i is present in steps
from l_i to r_i , inclusive. In each step, you can feed all the cats that are
currently present or do nothing.

If you feed the same cat more than once, it will overeat, and you will
immediately lose the game. Your goal is to feed as many cats as possible
without causing any cat to overeat.

Find the maximum number of cats you can feed.

Formally, you need to select several integer points from the segment from 1 to
n in such a way that among given segments, none covers two or more of the
selected points, and as many segments as possible cover one of the selected
points.

Input

The first line of input contains a single integer t (1 \le t \le 10^4 ) — the
number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains two integers n and m (1 \le n \le
10^6 , 1 \le m\le 2\cdot 10^5 ).

The i -th of the next m lines contains a pair of integers l_i and r_i (1 \le
l_i \le r_i \le n ).

The sum of n for all tests does not exceed 10^6 , the sum of m for all tests
does not exceed 2\cdot 10^5 .

Output

For each test case, print a single integer, the maximum number of cats you can
feed.

Example

Input

    3
    
    15 6
    
    2 10
    
    3 5
    
    2 4
    
    7 7
    
    8 12
    
    11 11
    
    1000 1
    
    1 1000
    
    5 10
    
    1 2
    
    3 4
    
    3 4
    
    3 4
    
    3 4
    
    1 1
    
    1 2
    
    3 3
    
    3 4
    
    3 4

Output

    5
    1
    10
    
Note

In the first example, one of the ways to feed five cats is to feed at steps 4
and 11 .

  * At step 4 , cats 1 , 2 , and 3 will be fed.
  * At step 11 , cats 5 and 6 will be fed.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 209
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Jay managed to create a problem of difficulty x and decided to make it the
second problem for Codeforces Round #921.

But Yash fears that this problem will make the contest highly unbalanced, and
the coordinator will reject it. So, he decided to break it up into a
problemset of n sub-problems such that the difficulties of all the sub-
problems are a positive integer and their sum is equal to x .

The coordinator, Aleksey, defines the balance of a problemset as the
[GCD](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the
difficulties of all sub-problems in the problemset.

Find the maximum balance that Yash can achieve if he chooses the difficulties
of the sub-problems optimally.

Input

The first line of input contains a single integer t (1\leq t\leq 10^3 )
denoting the number of test cases.

Each test case contains a single line of input containing two integers x
(1\leq x\leq 10^8 ) and n (1\leq n\leq x ).

Output

For each test case, print a single line containing a single integer denoting
the maximum balance of the problemset Yash can achieve.

Example

Input

    3
    
    10 3
    
    5 5
    
    420 69

Output

    2
    1
    6
    
Note

For the first test case, one possible way is to break up the problem of
difficulty 10 into a problemset having three problems of difficulties 4 , 2
and 4 respectively, giving a balance equal to 2 .

For the second test case, there is only one way to break up the problem of
difficulty 5 into a problemset of 5 problems with each problem having a
difficulty 1 giving a balance equal to 1 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 69
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You can never buy enough happiness, so here we go again! In this version, you
can only buy h_i = 1 unit of happiness each month, but the number of months is
hugely increased. We are in the realm of quantum happiness and time dilation.

Being a physicist, Charlie likes to plan his life in simple and precise terms.

For the next m months, starting with no money, Charlie will work hard and earn
x pounds per month. For the i -th month (1 \le i \le m) , there'll be a single
opportunity of paying cost c_i pounds to obtain one unit of happiness. You
cannot buy more than one unit each month.

Borrowing is not allowed. Money earned in the i -th month can only be spent in
a later j -th month (j>i ).

Since physicists don't code, help Charlie find the maximum reachable units of
happiness.

Input

The first line of the input contains t (1 \leq t \leq 10^4 ) — the number of
test cases.

The first line of each test case contains two integers, m and x (1 \le m \le 2
\cdot 10^5 , 1 \le x \le 10^3 ) — the total number of months and the monthly
salary.

The second line of each test case contains m integers c_1, c_2, \dots, c_m (1
\leq c_i \leq 10^3 ) — the cost of one unit of happiness for each month.

It is guaranteed that sum of m over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output one integer — the maximal amount of happiness
Charlie can get.

Example

Input

    6
    
    3 3
    
    2 2 2
    
    6 5
    
    2 2 8 2 6 8
    
    6 4
    
    4 10 3 8 6 10
    
    2 1
    
    1 1
    
    4 1
    
    4 1 3 1
    
    4 2
    
    1 3 4 3

Output

    2
    4
    3
    1
    2
    1
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 57
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: In a well-known school, a physical education lesson took place. As usual,
everyone was lined up and asked to settle in "the first–k -th" position.

As is known, settling in "the first–k -th" position occurs as follows: the
first k people have numbers 1, 2, 3, \ldots, k , the next k - 2 people have
numbers k - 1, k - 2, \ldots, 2 , the next k people have numbers 1, 2, 3,
\ldots, k , and so on. Thus, the settling repeats every 2k - 2 positions.
Examples of settling are given in the "Note" section.

The boy Vasya constantly forgets everything. For example, he forgot the number
k described above. But he remembers the position he occupied in the line, as
well as the number he received during the settling. Help Vasya understand how
many natural numbers k fit under the given constraints.

Note that the settling exists if and only if k > 1 . In particular, this means
that the settling does not exist for k = 1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 100 ) — the number of test cases. This is followed by
the description of the test cases.

The only line of each test case contains two integers n and x (1 \le x < n \le
10^9 ) — Vasya's position in the line and the number Vasya received during the
settling.

Output

For each test case, output a single integer — the number of different k that
fit under the given constraints.

It can be proven that under the given constraints, the answer is finite.

Example

Input

    5
    
    10 2
    
    3 1
    
    76 4
    
    100 99
    
    1000000000 500000000

Output

    4
    1
    9
    0
    1
    
Note

In the first test case, k equals 2, 3, 5, 6 are suitable.

An example of settling for these k :

k / №| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10   
---|---|---|---|---|---|---|---|---|---|---  
2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2   
3 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 | 2   
5 | 1 | 2 | 3 | 4 | 5 | 4 | 3 | 2 | 1 | 2   
6 | 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 | 3 | 2   
  
In the second test case, k = 2 is suitable.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 182
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given two binary strings a and b . A binary string is a string
consisting of the characters '0' and '1'.

Your task is to determine the maximum possible number k such that a prefix of
string a of length k is a subsequence of string b .

A sequence a is a subsequence of a sequence b if a can be obtained from b by
the deletion of several (possibly, zero or all) elements.

Input

The first line consists of a single integer t (1 \le t \le 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and m (1\le n,m \le 2
\cdot 10^5 ) — the length of string a and the length of string b ,
respectively.

The second line of each test case contains a binary string a of length n .

The third line of each test case contains a binary string b of length m .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 . Similarly, the sum of values m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single number — the maximum k , such that the
first k characters of a form a subsequence of b .

Example

Input

    6
    
    5 4
    
    10011
    
    1110
    
    3 3
    
    100
    
    110
    
    1 3
    
    1
    
    111
    
    4 4
    
    1011
    
    1111
    
    3 5
    
    100
    
    11010
    
    3 1
    
    100
    
    0

Output

    2
    2
    1
    1
    3
    0
    
Note

In the first example, the string '10 ' is a subsequence of
'1\color{red}11\color{red}0 ' but the string '100 ' is not. So the answer is 2
.

In the fifth example, a ='100 ', b ='1\color{red}{10}1\color{red}0 ', whole
string a is a subsequence of string b . So the answer is 3 .

In the sixth example, string b does not contain '1 ' so the answer is 0 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 65
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Three friends gathered to play a few games of chess together.

In every game, two of them play against each other. The winner gets 2 points
while the loser gets 0 , and in case of a draw, both players get 1 point each.
Note that the same pair of players could have played any non-negative number
of times (possibly zero). It is also possible that no games were played at
all.

You've been told that their scores after all the games were played were p_1 ,
p_2 and p_3 . Additionally, it is guaranteed that p_1 \leq p_2 \leq p_3 holds.

Find the maximum number of draws that could have happened and print it. If
there isn't any way to obtain p_1 , p_2 and p_3 as a result of a non-negative
number of games between the three players, print -1 instead.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of the test cases follows.

The first line of each test case contains three integers p_1 , p_2 and p_3 (0
\leq p_1 \leq p_2 \leq p_3 \leq 30 ) — the scores of the three players, sorted
non-decreasingly.

Output

For each testcase, print one number — the maximum possible number of draws
that could've happened, or -1 if the scores aren't consistent with any valid
set of games and results.

Example

Input

    7
    
    0 0 0
    
    0 1 1
    
    1 1 1
    
    1 1 2
    
    3 3 3
    
    3 4 5
    
    1 1 10

Output

    0
    1
    -1
    2
    -1
    6
    2
    
Note

In the first example, no games were played at all, so no draws could occur
either.

For the second example, exactly one game occurred between the second and the
third player and it ended in draw, so the answer is 1 .

It's easy to see that there's no set of games achieving the scores in third
example, so the answer for it is -1 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 121
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: This is an interactive problem.

This is the game version of the problem. Note that the solution of this
problem may or may not share ideas with the solution of the solo version. You
can solve and get points for both versions independently.

Alice and Bob are playing a game. The game starts with a positive integer n ,
with players taking turns. On each turn of the game, the following sequence of
events takes place:

  * The player having the integer p breaks it into two integers p_{1} and p_{2} , where 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . 
  * If no such p_{1} , p_{2} exist, the player loses. 
  * Otherwise, the opponent does either select the integer p_{1} or p_{2} . 
  * The game continues with the selected integer. The opponent will try to break it. 

As Alice, your goal is to win. You can execute a maximum of 63 break
operations. You have the choice to play first or second. The system will act
for Bob.

Here \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \leq t \leq 1000 ) — the number of test cases.

The only line of each test case contains a single integer n (1 \leq n \leq
10^{18} ) — the number the game starts with.

Interaction

For each test case, the interaction begins by reading the integer n .

After reading n , print a single line containing either "first" or "second",
denoting what you want to play as (as first or second correspondingly).

On Alice's turn, you are required to print two positive integers, p_{1} and
p_{2} such that 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} =
p . Here, p equals one of the two integers printed by Bob in the previous
turn. If no turn has occurred previously, p is equal to n . If Alice cannot
perform a break operation, print "0 0" to receive a Wrong answer verdict.

On Bob's turn, you should read two integers, p_{1} and p_{2} such that 0 \lt
p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . Here, p equals
one of the two integers printed by Alice in the previous turn. If no turn has
occurred previously, p is equal to n . If Bob cannot perform a break operation
p_{1} = 0 and p_2 = 0 in which case you should proceed to the next test case.

If any break operation performed by Alice is invalid, the interactor prints
"-1 -1" and your code should promptly exit to receive a wrong answer verdict.

If Alice performs 63 turns and Bob can still execute a break operation on the
current integers, the interactor prints "-1 -1", and your code should promptly
exit to receive a wrong answer verdict.

After printing a query, do not forget to output the end of line and flush the
output. Otherwise, you will get Idleness limit exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

In this problem, hacks are disabled.

Example

Input

    4
    1
    
    0 0
    3
    
    0 0
    13
    
    3 4
    
    0 0
    777777770001
    
    0 0

Output

    second
    
    first
    2 1
    
    first
    10 7
    
    1 2
    
    first
    777777770000 1

Note

Explanation for the interaction.

Interactor / Bob| Alice| Explanation  
---|---|---  
4| | t   
1| | n for the first test case  
| second| Alice chooses to go second  
0 0| | Bob says he cannot break p = 1   
3| | n for the second test case  
| first| Alice chooses to go first  
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
13| | n for the third test case  
| first| Alice chooses to go first  
| 10 7| Alice breaks p = 13 into p_1 = 10 and p_2 = 7  
3 4| | Bob breaks p = 7 into p_1 = 3 and p_2 = 4   
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
777777770001| | n for the fourth test case  
| first| Alice chooses to go first  
| 777777770000 1| Alice breaks p = 777\,777\,770\,001 into p_1 =
777\,777\,770\,000 and p_2 = 1  
0 0| | Bob says he cannot perform break operation.  
  
This table is for explanation only and does not reflect the actual behavior of
the interactor.

Note that in the last test case Bob could choose p_1 and perform a break
operation but he gave up.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 290
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: This afternoon, you decided to enjoy the first days of Spring by taking a walk
outside. As you come near the Quidditch field, you hear screams. Once again,
there is a conflict about the score: the two teams are convinced that they won
the game! To prevent this problem from happening one more time, you decide to
get involved in the refereeing of the matches.

Now, you will stay in the stadium to watch the game and count the score. At
the end of the game, you will decide the winner.

Today, two teams are competing: the red Gryffindor (R) and the blue Ravenclaw
(B) team. Each team is composed of P players (1 \leq P \leq 10 ).

The field is a rectangle of N lines and M columns (3 \leq N, M \leq 99 , N and
M are odd). All the positions are integers, and several entities are allowed
to be at the same position in the field. At the beginning of the game, the
field contains goals for the two teams (each team can own between one and five
goals), the players, and exactly one Quaffle. Other types of balls will be
available in the harder versions of the problem.

A game is composed of T steps (0 \leq T \leq 10000 ). At each step, one entity
on the field (a player or a ball) performs one action. All entities can move.
A player can also catch a ball or throw the Quaffle that it is carrying. To
catch a ball, a player must be located on the same cell as it. The Quaffle
does not perform any action while it is being carried; it only follows the
movements of the player. If a player carrying the Quaffle decides to throw it,
the Quaffle is simply put at the current position of the player.

To win a point, a player must leave the Quaffle at a goal of the other team.
When it does, the team of the player wins one point, and the Quaffle instantly
moves to the middle of the field (the cell at the (M+1)/2 -th column of the
(N+1)/2 -th line of the field, starting from 1). There is no goal in the
middle of the field. If a player puts the ball in its own goal, the other team
wins the point.

Input

On the first line, the integers N and M .

The description of the field follows: N lines of M pairs of characters
separated by spaces. Each pair of characters represents a position on the
field. It can be either:

  * .. to represent an empty cell 
  * R0, ..., R9, B0, ..., B9 to represent a player. The first character is the team of the player, and the second is the number of the player in the team. Each pair of characters is unique, but it is not guaranteed that all the pairs appear in the grid. 
  * RG or BG to represent a goal. The blue team tries to put the ball in a red goal (RG) while the red team tries to put the ball in a blue goal (BG). 
  * .Q to represent the Quaffle, which is the ball that the players use to score goals. 

The next line contains T , the number of steps that compose the game. T lines
follow, each describing one action. It contains several pieces of information
separated by a space. First, a pair of characters representing the entity that
must perform the action. Second, the description of the action:

  * U, D, L, R indicate that the entity moves on the grid. It can move to the top of the grid (U), to the bottom (D), to the left (L), or to the right (R). Each entity moves by only one cell at a time. 
  * C indicates that the player catches the ball (only a player can catch a ball). Then, there is a space followed by a pair of characters: the description of the ball caught by the player. This information is needed since in the next versions of the problem, several balls may be in the same cell. 
  * T indicates that the player throws the Quaffle that it is carrying. 

All the actions performed by the entities are guaranteed to be valid: the
players stay in the field, don't catch a ball if they are not in the same
cell, don't release the Quaffle if they are not carrying it, ...

Output

You must output the description of the main events of the game, one event per
line. More precisely:

  * Each time a team scores, you must print t RED GOAL or t BLUE GOAL, depending on the team who scored, where t is the current time (the position of the action in the list of actions, starting from 0). In the case where a player scores in the wrong goal (a red player scores in the red goal, or a blue player scores in the blue goal), you must print the name of the team who wins one point, that is, the other team. 

The events must be printed in ascending order of t.

At the end of the game, you must print the final score as: FINAL SCORE: r b,
where r is the score of the red team and b is the score of the blue team.

Examples

Input

    5 5
    
    .. R1 .. B1 ..
    
    RG .. .. .. BG
    
    RG R0 .Q B0 BG
    
    RG .. .. .. BG
    
    .. R2 .. B2 ..
    
    13
    
    B2 U
    
    B2 U
    
    B2 L
    
    B2 C .Q
    
    B2 L
    
    B2 L
    
    B2 T
    
    R0 R
    
    R0 C .Q
    
    R0 D
    
    R0 R
    
    R0 R
    
    R0 T

Output

    6 BLUE GOAL
    12 RED GOAL
    FINAL SCORE: 1 1
    
Input

    3 5
    
    .. .. R0 .. ..
    
    RG .. .Q .. BG
    
    .. .. B0 .. ..
    
    12
    
    R0 D
    
    R0 C .Q
    
    R0 R
    
    R0 T
    
    R0 D
    
    B0 R
    
    B0 U
    
    B0 C .Q
    
    B0 L
    
    B0 L
    
    B0 L
    
    B0 T

Output

    11 BLUE GOAL
    FINAL SCORE: 0 1
    
Input

    3 5
    
    .. .. R0 .. ..
    
    RG .. .Q .. BG
    
    .. .. B0 .. ..
    
    5
    
    R0 D
    
    R0 C .Q
    
    R0 L
    
    R0 L
    
    R0 T

Output

    4 BLUE GOAL
    FINAL SCORE: 0 1
    
Note

In the first example, a blue player goes to the middle of the grid, at the
position of the Quaffle. He takes it, goes to the goal of the red team, and
lets the ball there. He scores! The ball gets back to the middle of the field,
a red player takes it and scores too.

In the second example, the red player takes the Quaffle, move it and throw it.
The blue player catches the ball, goes to the red goal and scores.

In the third example, the red player takes the ball and scores in the goal of
their own team: the blue team wins a point.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 341
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have been asked to organize a very important art conference. The first
step is to choose the dates.

The conference must last for a certain number of consecutive days. Each day,
one lecturer must perform, and the same lecturer cannot perform more than
once.

You asked n potential lecturers if they could participate in the conference.
Lecturer i indicated that they could perform on any day from l_i to r_i
inclusive.

A certain segment of days can be chosen as the conference dates if there is a
way to assign an available lecturer to each day of the segment, assigning each
lecturer to no more than one day.

For each k from 1 to n , find how many ways there are to choose a segment of k
consecutive days as the conference dates.

Input

The first line of input contains one integer n — the number of potential
lecturers (1 \le n \le 2 \cdot 10^5 ).

Each of the next n lines contains two integers l_i and r_i — the segment of
available days for the i th lecturer (1 \le l_i \le r_i \le 2 \cdot 10^5 ).

Output

Print n integers, where the k th number denotes the number of ways to select a
segment of k consecutive days as conference dates.

Examples

Input

    3
    
    1 2
    
    3 4
    
    5 6

Output

    6
    2
    0
    
Input

    5
    
    1 3
    
    1 3
    
    1 3
    
    1 3
    
    1 3

Output

    3
    2
    1
    0
    0
    
Note

In the first testcase, a one-day conference can be organized on any of the
days from 1 to 6 . A two-day conference can be organized from day 2 to day 3 ,
as well as from day 4 to day 5 .

In the second testcase, five lecturers can perform only from day 1 to day 3 ,
so it will not be possible to organize a conference longer than three days.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 354
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have a one-dimensional puzzle, all the elements of which need to be put in
one row, connecting with each other. All the puzzle elements are completely
white and distinguishable from each other only if they have different shapes.

Each element has straight borders at the top and bottom, and on the left and
right it has connections, each of which can be a protrusion or a recess. You
cannot rotate the elements.

You can see that there are exactly 4 types of elements. Two elements can be
connected if the right connection of the left element is opposite to the left
connection of the right element.

![](https://espresso.codeforces.com/3a4ca20f32b3885d01c9dc80911de1cfb06870fe.png)
All possible types of elements.

The puzzle contains c_1, c_2, c_3, c_4 elements of each type. The puzzle is
considered complete if you have managed to combine all elements into one long
chain. You want to know how many ways this can be done.

Input

The first line contains a single integer t (1 \le t \le 2 \cdot 10^5 ) — the
number of input test cases. The descriptions of the test cases follow.

The description of each test case contains 4 integers c_i (0 \le c_i \le 10^6
) — the number of elements of each type, respectively.

It is guaranteed that the sum of c_i for all test cases does not exceed 4
\cdot 10^6 .

Output

For each test case, print one integer — the number of possible ways to solve
the puzzle.

Two methods are considered different if there is i , such that the types of
elements at the i position in these methods differ.

Since the answer can be very large, output it modulo 998244353 .

If it is impossible to solve the puzzle, print 0 .

Example

Input

    11
    
    1 1 1 1
    
    1 2 5 10
    
    4 6 100 200
    
    900000 900000 900000 900000
    
    0 0 0 0
    
    0 0 566 239
    
    1 0 0 0
    
    100 0 100 0
    
    0 0 0 4
    
    5 5 0 2
    
    5 4 0 5

Output

    4
    66
    0
    794100779
    1
    0
    1
    0
    1
    36
    126
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 92
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: As soon as everyone in the camp fell asleep, Kirill sneaked out of the tent
and went to the Wise Oak to gather mushrooms.

It is known that there are n mushrooms growing under the Oak, each of which
has magic power v_i . Kirill really wants to make a magical elixir of maximum
strength from the mushrooms.

The strength of the elixir is equal to the product of the number of mushrooms
in it and the minimum magic power among these mushrooms. To prepare the
elixir, Kirill will sequentially pick one mushroom growing under the Oak.
Kirill can gather mushrooms in any order.

However, it's not that simple. The Wise Oak informed Kirill of a permutation
of numbers p from 1 to n . If Kirill picks only k mushrooms, then the magic
power of all mushrooms with indices p_1, p_2, \dots, p_{k - 1} will become 0 .
Kirill will not use mushrooms with zero magic power to prepare the elixir.

Your task is to help Kirill gather mushrooms in such a way that he can brew
the elixir of maximum possible strength. However, Kirill is a little scared to
stay near the oak for too long, so out of all the suitable options for
gathering mushrooms, he asks you to find the one with the minimum number of
mushrooms.

A permutation of length n is an array consisting of n different integers from
1 to n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is
not a permutation (2 appears in the array twice) and [1,3,4] is also not a
permutation (n=3 , but 4 appears in the array).

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le
200\,000 ) — the number of mushrooms.

The second line contains an array v of size n (1\le v_i \le 10^9 ) — the magic
powers of the mushrooms.

The third line contains a permutation p of numbers from 1 to n .

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2\cdot 10^5 .

Output

For each test case, output two integers separated by a space — the maximum
strength of the elixir that can be brewed and the minimum number of mushrooms
that Kirill needs to use for this.

Example

Input

    6
    
    3
    
    9 8 14
    
    3 2 1
    
    5
    
    1 2 3 4 5
    
    1 2 3 4 5
    
    6
    
    1 2 3 4 5 6
    
    6 5 4 3 2 1
    
    5
    
    1 4 6 10 10
    
    2 1 4 5 3
    
    4
    
    2 2 5 5
    
    4 2 3 1
    
    5
    
    1 2 9 10 10
    
    1 4 2 3 5

Output

    16 2
    9 3
    8 2
    20 2
    5 1
    20 2
    
Note

In the first example, you need to take the mushrooms with indices 1 and 2 , so
the strength of the elixir is equal to 2 \cdot \min(a_1, a_2) = 2 \cdot
\min(9, 8) = 2 \cdot 8 = 16 . Note that the magic power of the mushroom with
index 3 after picking two mushrooms will become 0 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 169
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: In the Master's Assistance Center, Nyam-Nyam was given a homework assignment
in informatics.

There is an array a of length n , and you want to divide it into k > 1
subsegments^{\dagger} in such a way that the \operatorname{MEX} ^{\ddagger} on
each subsegment is equal to the same integer.

Help Nyam-Nyam find any suitable division, or determine that it does not
exist.

^{\dagger} A division of an array into k subsegments is defined as k pairs of
integers (l_1, r_1), (l_2, r_2), \ldots, (l_k, r_k) such that l_i \le r_i and
for each 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 , and also l_1 = 1 and r_k =
n . These pairs represent the subsegments themselves.

^{\ddagger}\operatorname{MEX} of an array is the smallest non-negative integer
that does not belong to the array.

For example:

  * \operatorname{MEX} of the array [2, 2, 1] is 0 , because 0 does not belong to the array. 
  * \operatorname{MEX} of the array [3, 1, 0, 1] is 2 , because 0 and 1 belong to the array, but 2 does not. 
  * \operatorname{MEX} of the array [0, 3, 1, 2] is 4 , because 0 , 1 , 2 , and 3 belong to the array, but 4 does not. 

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < n ) — the elements of the array a .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer -1 if a suitable division does not
exist.

Otherwise, on the first line, output an integer k (2 \le k \le n ) — the
number of subsegments in the division.

Then output k lines — the division into subsegments. The i -th line should
contain two integers l_i and r_i (1 \le l_i \le r_i \le n ) — the boundaries
of the i -th subsegment.

The following conditions must be satisfied:

  * For all 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 ;
  * l_1 = 1 , r_k = n .

If there are multiple possible solutions, output any of them.

Example

Input

    5
    
    2
    
    0 0
    
    5
    
    0 1 2 3 4
    
    8
    
    0 1 7 1 0 1 0 3
    
    3
    
    2 2 2
    
    4
    
    0 1 2 0

Output

    2
    1 1
    2 2
    -1
    3
    1 3
    4 5
    6 8
    3
    1 1
    2 2
    3 3
    -1

Note

In the first test case, the array a can be divided into 2 subsegments with
boundaries [1, 1] and [2, 2] :

  * \operatorname{MEX} of the first subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 
  * \operatorname{MEX} of the second subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 

In the second test case, it can be proven that the required division does not
exist.

In the third test case, the array a can be divided into 3 subsegments with
boundaries [1, 3] , [4, 5] , [6, 8] :

  * \operatorname{MEX} of the first subsegment [0, 1, 7] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the second subsegment [1, 0] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the third subsegment [1, 0, 3] is 2 , as 0 and 1 belong to the subsegment, but 2 does not.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 7
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given a tree with n vertices numbered 1, 2, \ldots, n . Initially, all
vertices are colored white.

You can perform the following two-step operation:

  1. Choose a vertex v (1 \leq v \leq n ) and a distance d (0 \leq d \leq n-1 ). 
  2. For all vertices u (1 \leq u \leq n ) such that \text{dist}^\dagger(u,v)=d , color u black. 

Construct a sequence of operations to color all the nodes in the tree black
using the minimum possible number of operations. It can be proven that it is
always possible to do so using at most n operations.

^\dagger \text{dist}(x, y) denotes the number of edges on the (unique) simple
path between vertices x and y on the tree.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 200 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^3 ) — the number of vertices of the tree.

The following n - 1 lines of each test case describe the edges of the tree.
The i -th of these lines contains two integers u_i and v_i (1 \le u_i, v_i \le
n , u_i \neq v_i ), the indices of the vertices connected by the i -th edge.

It is guaranteed that the given edges form a tree.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^3 .

Output

For each test case, first output a single integer op (1 \le op \le n) , the
minimum number of operations needed to color all vertices of the tree black.

Then, output op lines, each containing 2 integers. The i -th line should
contain the values of v and d chosen for the i -th operation (1 \le v \le n ,
0 \le d \le n - 1 )

You must guarantee that at the end of op operations, all vertices are colored
black.

If there are multiple solutions, you may output any one of them.

Example

Input

    4
    
    1
    
    2
    
    1 2
    
    4
    
    1 2
    
    1 3
    
    1 4
    
    7
    
    2 7
    
    3 2
    
    6 4
    
    5 7
    
    1 6
    
    6 7

Output

    1
    1 0
    2
    1 1
    2 1
    2
    1 1
    2 1
    3
    6 1
    7 1
    2 1

Note

In the first test case, there is only one possible operation, and performing
it gives us a valid answer.

In the second test case, the first operation colors vertex 2 black, and the
second operation colors vertex 1 black. It can be shown that it is impossible
to color both vertices black in one operation, so the minimum number of
operations needed is 2 . Another possible solution is to use the 2 operations:
(u, r) = (1, 0) and (u, r) = (2, 0) .

In the third test case, the first operation colors vertices 2 , 3 and 4 black,
and the second operation colors vertex 1 black. Again, it can be shown that it
is impossible to color all vertices black in 1 operation, so the minimum
number of operations needed is 2 .

In the fourth test case, the first operation colors vertices 4 , 1 and 7
black, the second operation colors vertices 2 , 5 and 6 black while the third
operation colors vertices 3 and 7 black. Notice that it is allowed to color
vertex 7 black twice.

Thus, each node was marked at least once, with node 7 marked twice. It can be
shown that it is impossible to color all vertices black in fewer than 3 moves.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 316
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The price of one yogurt at the "Vosmiorochka" store is a burles, but there is
a promotion where you can buy two yogurts for b burles.

Maxim needs to buy exactly n yogurts. When buying two yogurts, he can choose
to buy them at the regular price or at the promotion price.

What is the minimum amount of burles Maxim should spend to buy n yogurts?

Input

The first line contains a single integer t (1 \le t \le {10}^{4} ) — the
number of test cases.

The first and only line of each test case contains three integers n , a , and
b (1 \le n \le 100 , 1 \le a, b \le 30 ) — the number of yogurts Maxim wants
to buy, the price for one yogurt, and the price for two yogurts on promotion.

Output

For each test case, print in a separate line the minimum cost of buying n
yogurts at "Vosmiorochka".

Example

Input

    4
    
    2 5 9
    
    3 5 9
    
    3 5 11
    
    4 5 11

Output

    9
    14
    15
    20
    
Note

In the third test case of the example, it is more advantageous to buy three
yogurts for 15 burles than two for 11 and one for 5 .

In the fourth test case of the example, you need to buy four yogurts, each for
5 burles.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 339
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There are n monsters standing in a row. The i -th monster has a_i health
points.

Every second, you can choose one alive monster and launch a chain lightning at
it. The lightning deals k damage to it, and also spreads to the left (towards
decreasing i ) and to the right (towards increasing i ) to alive monsters,
dealing k damage to each. When the lightning reaches a dead monster or the
beginning/end of the row, it stops. A monster is considered alive if its
health points are strictly greater than 0 .

For example, consider the following scenario: there are three monsters with
health equal to [5, 2, 7] , and k = 3 . You can kill them all in 4 seconds:

  * launch a chain lightning at the 3 -rd monster, then their health values are [2, -1, 4] ; 
  * launch a chain lightning at the 1 -st monster, then their health values are [-1, -1, 4] ; 
  * launch a chain lightning at the 3 -rd monster, then their health values are [-1, -1, 1] ; 
  * launch a chain lightning at the 3 -th monster, then their health values are [-1, -1, -2] . 

For each k from 1 to \max(a_1, a_2, \dots, a_n) , calculate the minimum number
of seconds it takes to kill all the monsters.

Input

The first line contains a single integer n (1 \le n \le 10^5 ) — the number of
monsters.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^5 )
— the health points of the i -th monster.

Output

For each k from 1 to \max(a_1, a_2, \dots, a_n) , output the minimum number of
seconds it takes to kill all the monsters.

Examples

Input

    3
    
    5 2 7

Output

    10 6 4 3 2 2 1 
    
Input

    4
    
    7 7 7 7

Output

    7 4 3 2 2 2 1 
    
Input

    10
    
    1 9 7 6 2 4 7 8 1 3

Output

    17 9 5 4 3 3 3 2 1
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 182
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given two binary strings a and b . A binary string is a string
consisting of the characters '0' and '1'.

Your task is to determine the maximum possible number k such that a prefix of
string a of length k is a subsequence of string b .

A sequence a is a subsequence of a sequence b if a can be obtained from b by
the deletion of several (possibly, zero or all) elements.

Input

The first line consists of a single integer t (1 \le t \le 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and m (1\le n,m \le 2
\cdot 10^5 ) — the length of string a and the length of string b ,
respectively.

The second line of each test case contains a binary string a of length n .

The third line of each test case contains a binary string b of length m .

It is guaranteed that the sum of values n over all test cases does not exceed
2 \cdot 10^5 . Similarly, the sum of values m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single number — the maximum k , such that the
first k characters of a form a subsequence of b .

Example

Input

    6
    
    5 4
    
    10011
    
    1110
    
    3 3
    
    100
    
    110
    
    1 3
    
    1
    
    111
    
    4 4
    
    1011
    
    1111
    
    3 5
    
    100
    
    11010
    
    3 1
    
    100
    
    0

Output

    2
    2
    1
    1
    3
    0
    
Note

In the first example, the string '10 ' is a subsequence of
'1\color{red}11\color{red}0 ' but the string '100 ' is not. So the answer is 2
.

In the fifth example, a ='100 ', b ='1\color{red}{10}1\color{red}0 ', whole
string a is a subsequence of string b . So the answer is 3 .

In the sixth example, string b does not contain '1 ' so the answer is 0 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': True, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 275
ERROR - Error: unsupported statement type: <ast.Delete object at 0x75be860256c0> del pos[ent]

DEBUG - Start Task 294
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Yarik's birthday is coming soon, and Mark decided to give him an array a of
length n .

Mark knows that Yarik loves bitwise operations very much, and he also has a
favorite number x , so Mark wants to find the maximum number k such that it is
possible to select pairs of numbers [l_1, r_1 ], [l_2, r_2 ], \ldots [l_k, r_k
], such that:

  * l_1 = 1 . 
  * r_k = n . 
  * l_i \le r_i for all i from 1 to k . 
  * r_i + 1 = l_{i + 1} for all i from 1 to k - 1 . 
  * (a_{l_1} \oplus a_{l_1 + 1} \oplus \ldots \oplus a_{r_1}) | (a_{l_2} \oplus a_{l_2 + 1} \oplus \ldots \oplus a_{r_2}) | \ldots | (a_{l_k} \oplus a_{l_k + 1} \oplus \ldots \oplus a_{r_k}) \le x , where \oplus denotes the operation of [bitwise XOR](https://en.wikipedia.org/wiki/Exclusive_or), and | denotes the operation of [bitwise OR](https://en.wikipedia.org/wiki/Logical_disjunction). 

If such k does not exist, then output -1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The following lines
contain the descriptions of the test cases.

The first line of each test case contains two integers n and x (1 \le n \le
10^5, 0 \le x < 2^{30} ) — the length of the array a and the number x
respectively.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < 2^{30} ) — the array a itself.

It is guaranteed that the sum of the values of n across all test cases does
not exceed 10^5 .

Output

For each test case, output a single integer on a separate line — the maximum
suitable number k , and -1 if such k does not exist.

Example

Input

    8
    
    3 1
    
    1 2 3
    
    2 2
    
    1 1
    
    2 2
    
    1 3
    
    2 3
    
    0 0
    
    3 2
    
    0 0 1
    
    4 2
    
    1 3 3 7
    
    2 2
    
    2 3
    
    5 0
    
    0 1 2 2 1

Output

    2
    2
    1
    2
    3
    -1
    1
    2
    
Note

In the first test case, you can take k equal to 2 and choose two segments [1, 1 ] and [2, 3 ], (1) | (2 \oplus 3) = 1 . It can be shown that 2 is the maximum possible answer.

In the second test case, the segments [1, 1 ] and [2, 2 ] are suitable, (1) | (1) = 1 . It is not possible to make more segments.

In the third test case, it is not possible to choose 2 segments, as (1) | (3) = 3 > 2 , so the optimal answer is 1 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 92
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: As soon as everyone in the camp fell asleep, Kirill sneaked out of the tent
and went to the Wise Oak to gather mushrooms.

It is known that there are n mushrooms growing under the Oak, each of which
has magic power v_i . Kirill really wants to make a magical elixir of maximum
strength from the mushrooms.

The strength of the elixir is equal to the product of the number of mushrooms
in it and the minimum magic power among these mushrooms. To prepare the
elixir, Kirill will sequentially pick one mushroom growing under the Oak.
Kirill can gather mushrooms in any order.

However, it's not that simple. The Wise Oak informed Kirill of a permutation
of numbers p from 1 to n . If Kirill picks only k mushrooms, then the magic
power of all mushrooms with indices p_1, p_2, \dots, p_{k - 1} will become 0 .
Kirill will not use mushrooms with zero magic power to prepare the elixir.

Your task is to help Kirill gather mushrooms in such a way that he can brew
the elixir of maximum possible strength. However, Kirill is a little scared to
stay near the oak for too long, so out of all the suitable options for
gathering mushrooms, he asks you to find the one with the minimum number of
mushrooms.

A permutation of length n is an array consisting of n different integers from
1 to n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is
not a permutation (2 appears in the array twice) and [1,3,4] is also not a
permutation (n=3 , but 4 appears in the array).

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le
200\,000 ) — the number of mushrooms.

The second line contains an array v of size n (1\le v_i \le 10^9 ) — the magic
powers of the mushrooms.

The third line contains a permutation p of numbers from 1 to n .

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2\cdot 10^5 .

Output

For each test case, output two integers separated by a space — the maximum
strength of the elixir that can be brewed and the minimum number of mushrooms
that Kirill needs to use for this.

Example

Input

    6
    
    3
    
    9 8 14
    
    3 2 1
    
    5
    
    1 2 3 4 5
    
    1 2 3 4 5
    
    6
    
    1 2 3 4 5 6
    
    6 5 4 3 2 1
    
    5
    
    1 4 6 10 10
    
    2 1 4 5 3
    
    4
    
    2 2 5 5
    
    4 2 3 1
    
    5
    
    1 2 9 10 10
    
    1 4 2 3 5

Output

    16 2
    9 3
    8 2
    20 2
    5 1
    20 2
    
Note

In the first example, you need to take the mushrooms with indices 1 and 2 , so
the strength of the elixir is equal to 2 \cdot \min(a_1, a_2) = 2 \cdot
\min(9, 8) = 2 \cdot 8 = 16 . Note that the magic power of the mushroom with
index 3 after picking two mushrooms will become 0 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 248
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have a square piece of paper with a side length equal to 1 unit. In one
operation, you fold each corner of the square to the center of the paper, thus
forming another square with a side length equal to \dfrac{1}{\sqrt{2}} units.
By taking this square as a new square, you do the operation again and repeat
this process a total of N times.

![](https://espresso.codeforces.com/412ebba036545f933291dce36c1d7ef46e6051c5.png)
Performing operations for N = 2 .

After performing the set of operations, you open the paper with the same side
up you started with and see some crease lines on it. Every crease line is one
of two types: a mountain or a valley. A mountain is when the paper folds
outward, and a valley is when the paper folds inward.

You calculate the sum of the length of all mountain crease lines on the paper
and call it M . Similarly, you calculate for valley crease lines and call it V
. You want to find the value of \dfrac{M}{V} .

It can be proved that this value can be represented in the form of A +
B\sqrt{2} , where A and B are rational numbers. Let this B be represented as
an irreducible fraction \dfrac{p}{q} , your task is to print p*inv(q) modulo
999\,999\,893 (note the unusual modulo), where inv(q) is the [modular
inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) of q .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \leq t \leq 10^4 ). Description of the test cases follows.

The only line of each test case contains an integer N (1 \leq N \leq 10^9 ),
the number of operations you perform on the square paper.

Output

For each test case, print on a new line the required answer.

Example

Input

    3
    
    1
    
    2
    
    3

Output

    0
    1
    714285638
    
Note

The blue lines in the given figures represent mountain crease lines, and the
green lines represent valley crease lines.

![](https://espresso.codeforces.com/ca27ca80cf535ddfa7cb1255e157dc6f43f1073c.png)|
![](https://espresso.codeforces.com/9e2d8603363c8514970f3141c639422cb347d41f.png)  
---|---  
Crease lines after 1 operation (\dfrac{M}{V} = 0) .| Crease lines after 2
operations (\dfrac{M}{V} = \sqrt{2} - 1) .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 78
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: This is an easy version of the problem; it differs from the hard version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ), the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot). Then output k non-negative integers a_1, a_2, \dots,
a_k , where:

  * a_i=0 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot does not increase (i.e., remains equal to \alpha ); 
  * a_i=1 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot increases (i.e., becomes greater than \alpha ). 

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where:

  * a_i=0 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot does not increase compared to the case when all k fountains belong to Bob; 
  * a_i=1 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot increases compared to the case when all k fountains belong to Bob. 

If you output any other positive number instead of 1 that fits into a 64-bit
signed integer type, it will also be recognized as 1 . Thus, a solution to the
hard version of this problem will also pass the tests for the easy version.

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 1 
    1
    0 0 1 1 0 0 0 0 0 
    6
    1 0 0 0 
    1
    1 1 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 156
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: [Maître Gims - Est-ce que tu m'aimes ?](https://youtu.be/6TpyRE_juyA)

ඞ

As the CEO of a startup company, you want to reward each of your k employees
with a ticket to the upcoming concert. The tickets will be on sale for n days,
and by some time travelling, you have predicted that the price per ticket at
day i will be a_i . However, to prevent ticket hoarding, the concert
organizers have implemented the following measures:

  * A person may purchase no more than m tickets per day. 
  * If a person purchases x tickets on day i , all subsequent days (i.e. from day i+1 onwards) will have their prices per ticket increased by x . 

For example, if a = [1, 3, 8, 4, 5] and you purchase 2 tickets on day 1 , they
will cost 2 in total, and the prices from day 2 onwards will become [5, 10, 6,
7] . If you then purchase 3 more tickets on day 2 , they will cost in total an
additional 15 , and the prices from day 3 onwards will become [13, 9, 10] .

Find the minimum spending to purchase k tickets.

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains three integers n , m , and k (1 \le
n \le 3 \cdot 10^5, 1 \le m \le 10^9, 1 \le k \le \min(nm, 10^9) ) — the
number of sale days, the maximum amount of ticket purchasable each day, and
the number of tickets to be bought at the end.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the price per ticket for each of the upcoming n days.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, print one integer: the minimum amount of money needed to
purchase exactly k tickets.

Example

Input

    4
    
    4 2 3
    
    8 6 4 2
    
    4 2 8
    
    8 6 4 2
    
    5 100 1
    
    10000 1 100 10 1000
    
    6 3 9
    
    5 5 5 5 5 5

Output

    10
    64
    1
    72
    
Note

In the first test case, one optimal way to buy 3 tickets is as follows:

  * Buy 0 tickets on the first day. The prices per ticket for the remaining days are [6, 4, 2] . 
  * Buy 0 tickets on the second day. The prices per ticket for the remaining days are [4, 2] . 
  * Buy 1 ticket on the third day with cost 4 . The price per ticket for the remaining day is [3] . 
  * Buy 2 tickets on the fourth day with cost 6 . 

In the second test case, there is only one way to buy 8 tickets:

  * Buy 2 tickets on the first day with cost 16 . The prices per ticket for the remaining days are [8, 6, 4] . 
  * Buy 2 tickets on the second day with cost 16 . The prices per ticket for the remaining days are [8, 6] . 
  * Buy 2 tickets on the third day with cost 16 . The price per ticket for the remaining day is [8] . 
  * Buy 2 tickets on the fourth day with cost 16 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 27
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have some cards. An integer between 1 and n is written on each card:
specifically, for each i from 1 to n , you have a_i cards which have the
number i written on them.

There is also a shop which contains unlimited cards of each type. You have k
coins, so you can buy k new cards in total, and the cards you buy can contain
any integer between 1 and n .

After buying the new cards, you rearrange all your cards in a line. The score
of a rearrangement is the number of (contiguous) subarrays of length n which
are a permutation of [1, 2, \ldots, n] . What's the maximum score you can get?

Input

Each test contains multiple test cases. The first line contains the number of
test cases t\ (1\le t\le 100) . The description of the test cases follows.

The first line of each test case contains two integers n , k (1\le n \le 2
\cdot 10^5 , 0\le k \le 10^{12} ) — the number of distinct types of cards and
the number of coins.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^{12} ) — the number of cards of type i you have at the
beginning.

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^5 .

Output

For each test case, output a single line containing an integer: the maximum
score you can get.

Example

Input

    8
    
    1 10
    
    1
    
    2 4
    
    8 4
    
    3 4
    
    6 1 8
    
    3 9
    
    7 6 2
    
    5 3
    
    6 6 7 4 6
    
    9 7
    
    7 6 1 7 6 2 4 3 3
    
    10 10
    
    1 3 1 2 1 9 3 5 7 5
    
    9 8
    
    5 8 7 5 1 3 2 9 8

Output

    11
    15
    15
    22
    28
    32
    28
    36
    
Note

In the first test case, the final (and only) array we can get is [1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1] (including 11 single 1 s), which contains 11 subarrays
consisting of a permutation of [1] .

In the second test case, we can buy 0 cards of type 1 and 4 cards of type 2 ,
and then we rearrange the cards as following: [1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
1, 2, 1, 2, 1, 2] . There are 8 subarrays equal to [1, 2] and 7 subarrays
equal to [2, 1] , which make a total of 15 subarrays which are a permutation
of [1, 2] . It can also be proved that this is the maximum score we can get.

In the third test case, one of the possible optimal rearrangements is [3, 3,
1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 3] .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 270
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The only difference with the medium version is the maximum length of the
input.

A parentheses sequence is a string consisting of characters "(" and ")", for
example "(()((".

A balanced parentheses sequence is a parentheses sequence which can become a
valid mathematical expression after inserting numbers and operations into it,
for example "(()(()))".

The balance of a parentheses sequence is defined as the number of opening
parentheses "(" minus the number of closing parentheses ")". For example, the
balance of the sequence "(()((" is 3.

A balanced parentheses sequence can also be defined as a parentheses sequence
with balance 0 such that each of its prefixes has a non-negative balance.

We define the balanced shuffle operation that takes a parentheses sequence and
returns a parentheses sequence as follows: first, for every character of the
input sequence, we compute the balance of the prefix of the sequence before
that character and write those down in a table together with the positions of
the characters in the input sequence, for example:

Prefix balance| 0| 1| 2| 1| 2| 3| 2| 1  
---|---|---|---|---|---|---|---|---  
Position| 1| 2| 3| 4| 5| 6| 7| 8  
Character| (| (| )| (| (| )| )| )  
  
Then, we sort the columns of this table in increasing order of prefix balance,
breaking ties in decreasing order of position. In the above example, we get:

Prefix balance| 0| 1| 1| 1| 2| 2| 2| 3  
---|---|---|---|---|---|---|---|---  
Position| 1| 8| 4| 2| 7| 5| 3| 6  
Character| (| )| (| (| )| (| )| )  
  
The last row of this table forms another parentheses sequence, in this case
"()(()())". This sequence is called the result of applying the balanced
shuffle operation to the input sequence, or in short just the balanced shuffle
of the input sequence.

Surprisingly, it turns out that the balanced shuffle of any balanced
parentheses sequence is always another balanced parentheses sequence (we will
omit the proof for brevity). Even more surprisingly, the balanced shuffles of
two different balanced parentheses sequences are always different, therefore
the balanced shuffle operation is a bijection on the set of balanced
parentheses sequences of any given length (we will omit this proof, too).

You are given a balanced parentheses sequence. Find its preimage: the balanced
parentheses sequence the balanced shuffle of which is equal to the given
sequence.

Input

The only line of input contains a string s consisting only of characters "("
and ")". This string is guaranteed to be a non-empty balanced parentheses
sequence with its length not exceeding 500\,000 .

Output

Print the balanced parentheses sequence t such that the balanced shuffle of t
is equal to s . It is guaranteed that the answer always exists and is unique.

Example

Input

    ()(()())
    
Output

    (()(()))
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 189
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given an integer n . You choose n cells (x_1,y_1),
(x_2,y_2),\dots,(x_n,y_n) in the grid n\times n where 1\le x_i\le n and 1\le
y_i\le n .

Let \mathcal{H} be the set of distinct Manhattan distances between any pair of
cells. Your task is to maximize the size of \mathcal{H} . Examples of sets and
their construction are given in the notes.

If there exists more than one solution, you are allowed to output any.

Manhattan distance between cells (x_1,y_1) and (x_2,y_2) equals
|x_1-x_2|+|y_1-y_2| .

Input

The first line contains a single integer t (1\le t\le 50 ) — the number of
test cases.

Each of the following t lines contains a single integer n (2\le n\le 10^3 ).

Output

For each test case, output n points which maximize the size of \mathcal{H} .
It is not necessary to output an empty line at the end of the answer for each
test case.

Example

Input

    5
    
    2
    
    3
    
    4
    
    5
    
    6

Output

    1 1
    1 2
    
    2 1
    2 3
    3 1
    
    1 1
    1 3
    4 3
    4 4
    
    1 1
    1 3
    1 4
    2 1
    5 5
    
    1 4
    1 5
    1 6
    5 2
    5 5
    6 1
    
Note

In the first testcase we have n=2 . One of the possible arrangements is:

![](https://espresso.codeforces.com/4d7adaa08c9ee5ebf2a0caba13185ac968d6bcd9.png)
The arrangement with cells located in (1,1) and (1,2) . In this case
\mathcal{H}=\\{|1-1|+|1-1|,|1-1|+|2-2|,|1-1|+|1-2|\\}=\\{0,0,1\\}=\\{0,1\\} .
Hence, the size of \mathcal{H} is 2 . It can be shown that it is the greatest
possible answer.

In the second testcase we have n=3 . The optimal arrangement is:

![](https://espresso.codeforces.com/52d127e3dbe0141bb58dbdf4158586772a208758.png)
The arrangement with cells located in (2,1) , (2,3) and (3,1) .

\mathcal{H}
=\\{|2-2|+|1-1|,|2-2|+|3-3|,|3-3|+|1-1|,|2-2|+|1-3|,|2-3|+|1-1|,|2-3|+|3-1|\\}
=\\{0,0,0,2,1,3\\} =\\{0,1,2,3\\} .

For n=4 a possible arrangement is:

![](https://espresso.codeforces.com/575a6758d1f67174ceb877b32a1e89770cd2281a.png)

For n=5 a possible arrangement is:

![](https://espresso.codeforces.com/b790401b426625982c00d04cff13aceec53918b4.png)

For n=6 a possible arrangement is:

![](https://espresso.codeforces.com/d0f498905660a67115d9f58c6cbc1439ba6e509c.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 180
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given three digits a , b , and c . Determine whether they form a
stair, a peak, or neither.

  * A stair satisfies the condition a<b<c . 
  * A peak satisfies the condition a<b>c . 

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The only line of each test case contains three digits a , b , c (0 \leq a , b
, c \leq 9 ).

Output

For each test case, output "STAIR" if the digits form a stair, "PEAK" if the
digits form a peak, and "NONE" otherwise (output the strings without quotes).

Example

Input

    7
    
    1 2 3
    
    3 2 1
    
    1 5 3
    
    3 4 1
    
    0 0 0
    
    4 1 7
    
    4 5 7

Output

    STAIR
    NONE
    PEAK
    PEAK
    NONE
    NONE
    STAIR
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 6
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There are n islands, numbered 1, 2, \ldots, n . Initially, every pair of
islands is connected by a bridge. Hence, there are a total of \frac{n (n -
1)}{2} bridges.

Everule lives on island 1 and enjoys visiting the other islands using bridges.
Dominater has the power to destroy at most k bridges to minimize the number of
islands that Everule can reach using (possibly multiple) bridges.

Find the minimum number of islands (including island 1 ) that Everule can
visit if Dominater destroys bridges optimally.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first and only line of each test case contains two integers n and k (1 \le
n \le 100 , 0 \le k \le \frac{n \cdot (n - 1)}{2} ).

Output

For each test case, output the minimum number of islands that Everule can
visit if Dominater destroys bridges optimally.

Example

Input

    6
    
    2 0
    
    2 1
    
    4 1
    
    5 10
    
    5 3
    
    4 4

Output

    2
    1
    4
    1
    5
    1
    
Note

In the first test case, since no bridges can be destroyed, all the islands
will be reachable.

In the second test case, you can destroy the bridge between islands 1 and 2 .
Everule will not be able to visit island 2 but can still visit island 1 .
Therefore, the total number of islands that Everule can visit is 1 .

In the third test case, Everule always has a way of reaching all islands
despite what Dominater does. For example, if Dominater destroyed the bridge
between islands 1 and 2 , Everule can still visit island 2 by traveling by 1
\to 3 \to 2 as the bridges between 1 and 3 , and between 3 and 2 are not
destroyed.

In the fourth test case, you can destroy all bridges since k = \frac{n \cdot
(n - 1)}{2} . Everule will be only able to visit 1 island (island 1 ).
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 52
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Petya has an array a_i of n integers. His brother Vasya became envious and
decided to make his own array of n integers.

To do this, he found m integers b_i (m\ge n ), and now he wants to choose some
n integers of them and arrange them in a certain order to obtain an array c_i
of length n .

To avoid being similar to his brother, Vasya wants to make his array as
different as possible from Petya's array. Specifically, he wants the total
difference D = \sum_{i=1}^{n} |a_i - c_i| to be as large as possible.

Help Vasya find the maximum difference D he can obtain.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 100 ) — the number of test cases. This is followed by a
description of the test cases.

The first line of each test case contains two integers n and m (1\le n\le m\le
2 \cdot 10^5 ).

The second line of each test case contains n integers a_i (1\le a_i\le 10^9 ).
The third line of each test case contains m integers b_i (1\le b_i\le 10^9 ).

It is guaranteed that in a test, the sum of m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the maximum total difference D
that can be obtained.

Example

Input

    9
    
    4 6
    
    6 1 2 4
    
    3 5 1 7 2 3
    
    3 4
    
    1 1 1
    
    1 1 1 1
    
    5 5
    
    1 2 3 4 5
    
    1 2 3 4 5
    
    2 6
    
    5 8
    
    8 7 5 8 2 10
    
    2 2
    
    4 1
    
    9 6
    
    4 6
    
    8 10 6 4
    
    3 10 6 1 8 9
    
    3 5
    
    6 5 2
    
    1 7 9 7 2
    
    5 5
    
    9 10 6 3 7
    
    5 9 2 3 9
    
    1 6
    
    3
    
    2 7 10 1 1 5

Output

    16
    0
    12
    11
    10
    23
    15
    25
    7
    
Note

In the first example, Vasya can, for example, create the array (1, 5, 7, 2) .
Then the total difference will be D = |6-1|+|1-5|+|2-7|+|4-2| = 5+4+5+2 = 16 .

In the second example, all the integers available to Vasya are equal to 1, so
he can only create the array (1, 1, 1) , for which the difference D = 0 .

In the third example, Vasya can, for example, create the array (5, 4, 3, 2, 1)
. Then the total difference will be D = |1-5|+|2-4|+|3-3|+|4-2|+|5-1| =
4+2+0+2+4 = 12 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 242
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given n positive integers x_1, x_2, \ldots, x_n and three positive
integers n_a, n_b, n_c satisfying n_a+n_b+n_c = n .

You want to split the n positive integers into three groups, so that:

  * The first group contains n_a numbers, the second group contains n_b numbers, the third group contains n_c numbers.
  * Let s_a be the sum of the numbers in the first group, s_b be the sum in the second group, and s_c be the sum in the third group. Then s_a, s_b, s_c are the sides of a triangle with positive area.

Determine if this is possible. If this is possible, find one way to do so.

Input

Each test contains multiple test cases. The first line contains an integer t
(1\le t\le 100\,000 ) — the number of test cases. The descriptions of the t
test cases follow.

The first line of each test case contains the integers n, n_a, n_b, n_c (3
\leq n \leq 200\,000, 1\leq n_a,n_b,n_c \leq n-2, n_a+n_b+n_c = n ) — the
number of integers to split into three groups, and the desired sizes of the
three groups.

The second line of each test case contains n integers x_1, x_2, \ldots, x_n (1
\leq x_i \leq 10^{9} ).

It is guaranteed that the sum of n over all test cases does not exceed
200\,000 .

Output

For each test case, print \texttt{YES} if it is possible to split the numbers
into three groups satisfying all the conditions. Otherwise, print \texttt{NO}
.

If such a split exists, then describe the three groups as follows.

On the next line, print n_a integers a_1, a_2, \ldots, a_{n_a} — the numbers
in the first group.

On the next line, print n_b integers b_1, b_2, \ldots, b_{n_b} — the numbers
in the second group.

On the next line, print n_c integers c_1, c_2, \ldots, c_{n_c} — the numbers
in the third group.

These n_a+n_b+n_c=n integers should be a permutation of x_1, x_2, \ldots, x_n
, and they should satisfy the conditions from the statement.

If there are multiple solutions, print any of them.

Example

Input

    4
    
    6 2 2 2
    
    1 1 1 1 1 1
    
    5 3 1 1
    
    1 1 1 1 1
    
    6 2 2 2
    
    1 1 1 1 1 3
    
    8 1 2 5
    
    16 1 1 1 1 1 1 12

Output

    YES
    1 1 
    1 1 
    1 1 
    NO
    NO
    YES
    16 
    12 1 
    1 1 1 1 1 
    
Note

In the first test case, we can put two 1 s into each group: the sum in each
group would be 2 , and there exists a triangle with positive area and sides 2
, 2 , 2 .

In the second and third test cases, it can be shown that there is no such way
to split numbers into groups.

In the fourth test case, we can put number 16 into the first group, with sum
16 , numbers 12 and 1 into the second group, with sum 13 , and the remaining
five 1 s into the third group, with sum 5 , as there exists a triangle with
positive area and sides 16, 13, 5 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 255
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There are n slimes placed in a line. The slimes are numbered from 1 to n in
order from left to right. The size of the i -th slime is a_i .

Every second, the following happens: exactly one slime eats one of its
neighbors and increases its size by the eaten neighbor's size. A slime can eat
its neighbor only if it is strictly bigger than this neighbor. If there is no
slime which is strictly bigger than one of its neighbors, the process ends.

For example, suppose n = 5 , a = [2, 2, 3, 1, 4] . The process can go as
follows:

  * first, the 3 -rd slime eats the 2 -nd slime. The size of the 3 -rd slime becomes 5 , the 2 -nd slime is eaten. 
  * then, the 3 -rd slime eats the 1 -st slime (they are neighbors since the 2 -nd slime is already eaten). The size of the 3 -rd slime becomes 7 , the 1 -st slime is eaten. 
  * then, the 5 -th slime eats the 4 -th slime. The size of the 5 -th slime becomes 5 , the 4 -th slime is eaten. 
  * then, the 3 -rd slime eats the 5 -th slime (they are neighbors since the 4 -th slime is already eaten). The size of the 3 -rd slime becomes 12 , the 5 -th slime is eaten. 

For each slime, calculate the minimum number of seconds it takes for this
slime to be eaten by another slime (among all possible ways the process can
go), or report that it is impossible.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer n (1 \le n \le 3
\cdot 10^5 ) — the number of slimes.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^9
).

The sum of n over all test cases doesn't exceed 3 \cdot 10^5 .

Output

For each test case, print n integers. The i -th integer should be equal to the
minimum number of seconds it takes for the i -th slime to be eaten by another
slime or -1 if it is impossible.

Example

Input

    4
    
    4
    
    3 2 4 2
    
    3
    
    1 2 3
    
    5
    
    2 2 3 1 1
    
    7
    
    4 2 3 6 1 1 8

Output

    2 1 2 1 
    1 1 -1 
    2 1 -1 1 2 
    2 1 1 3 1 1 4
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 258
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given a positive integer x . Find any array of integers a_0, a_1,
\ldots, a_{n-1} for which the following holds:

  * 1 \le n \le 32 , 
  * a_i is 1 , 0 , or -1 for all 0 \le i \le n - 1 , 
  * x = \displaystyle{\sum_{i=0}^{n - 1}{a_i \cdot 2^i}} , 
  * There does not exist an index 0 \le i \le n - 2 such that both a_{i} \neq 0 and a_{i + 1} \neq 0 . 

It can be proven that under the constraints of the problem, a valid array
always exists.

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \le t \le 10^4 ) — the number of test cases. The
description of the test cases follows.

The only line of each test case contains a single positive integer x (1 \le x
< 2^{30} ).

Output

For each test case, output two lines.

On the first line, output an integer n (1 \le n \le 32 ) — the length of the
array a_0, a_1, \ldots, a_{n-1} .

On the second line, output the array a_0, a_1, \ldots, a_{n-1} .

If there are multiple valid arrays, you can output any of them.

Example

Input

    7
    
    1
    
    14
    
    24
    
    15
    
    27
    
    11
    
    19

Output

    1
    1
    5
    0 -1 0 0 1
    6
    0 0 0 -1 0 1
    5
    -1 0 0 0 1
    6
    -1 0 -1 0 0 1
    5
    -1 0 -1 0 1
    5
    -1 0 1 0 1

Note

In the first test case, one valid array is [1] , since (1) \cdot 2^0 = 1 .

In the second test case, one possible valid array is [0,-1,0,0,1] , since (0)
\cdot 2^0 + (-1) \cdot 2^1 + (0) \cdot 2^2 + (0) \cdot 2^3 + (1) \cdot 2^4 =
-2 + 16 = 14 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 255
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There are n slimes placed in a line. The slimes are numbered from 1 to n in
order from left to right. The size of the i -th slime is a_i .

Every second, the following happens: exactly one slime eats one of its
neighbors and increases its size by the eaten neighbor's size. A slime can eat
its neighbor only if it is strictly bigger than this neighbor. If there is no
slime which is strictly bigger than one of its neighbors, the process ends.

For example, suppose n = 5 , a = [2, 2, 3, 1, 4] . The process can go as
follows:

  * first, the 3 -rd slime eats the 2 -nd slime. The size of the 3 -rd slime becomes 5 , the 2 -nd slime is eaten. 
  * then, the 3 -rd slime eats the 1 -st slime (they are neighbors since the 2 -nd slime is already eaten). The size of the 3 -rd slime becomes 7 , the 1 -st slime is eaten. 
  * then, the 5 -th slime eats the 4 -th slime. The size of the 5 -th slime becomes 5 , the 4 -th slime is eaten. 
  * then, the 3 -rd slime eats the 5 -th slime (they are neighbors since the 4 -th slime is already eaten). The size of the 3 -rd slime becomes 12 , the 5 -th slime is eaten. 

For each slime, calculate the minimum number of seconds it takes for this
slime to be eaten by another slime (among all possible ways the process can
go), or report that it is impossible.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer n (1 \le n \le 3
\cdot 10^5 ) — the number of slimes.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^9
).

The sum of n over all test cases doesn't exceed 3 \cdot 10^5 .

Output

For each test case, print n integers. The i -th integer should be equal to the
minimum number of seconds it takes for the i -th slime to be eaten by another
slime or -1 if it is impossible.

Example

Input

    4
    
    4
    
    3 2 4 2
    
    3
    
    1 2 3
    
    5
    
    2 2 3 1 1
    
    7
    
    4 2 3 6 1 1 8

Output

    2 1 2 1 
    1 1 -1 
    2 1 -1 1 2 
    2 1 1 3 1 1 4
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 215
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Bob decided to open a bakery. On the opening day, he baked n buns that he can
sell. The usual price of a bun is a coins, but to attract customers, Bob
organized the following promotion:

  * Bob chooses some integer k (0 \le k \le \min(n, b) ).
  * Bob sells the first k buns at a modified price. In this case, the price of the i -th (1 \le i \le k ) sold bun is (b - i + 1) coins.
  * The remaining (n - k) buns are sold at a coins each.

Note that k can be equal to 0 . In this case, Bob will sell all the buns at a
coins each.

Help Bob determine the maximum profit he can obtain by selling all n buns.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains three integers n , a , and b (1 \le
n, a, b \le 10^9 ) — the number of buns, the usual price of a bun, and the
price of the first bun to be sold at a modified price.

Output

For each test case, output a single integer — the maximum profit that Bob can
obtain.

Example

Input

    7
    
    4 4 5
    
    5 5 9
    
    10 10 5
    
    5 5 11
    
    1000000000 1000000000 1000000000
    
    1000000000 1000000000 1
    
    1000 1 1000

Output

    17
    35
    100
    45
    1000000000000000000
    1000000000000000000
    500500
    
Note

In the first test case, it is optimal for Bob to choose k = 1 . Then he will
sell one bun for 5 coins, and three buns at the usual price for 4 coins each.
Then the profit will be 5 + 4 + 4 + 4 = 17 coins.

In the second test case, it is optimal for Bob to choose k = 5 . Then he will
sell all the buns at the modified price and obtain a profit of 9 + 8 + 7 + 6 +
5 = 35 coins.

In the third test case, it is optimal for Bob to choose k = 0 . Then he will
sell all the buns at the usual price and obtain a profit of 10 \cdot 10 = 100
coins.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 271
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The only difference between the versions of this problem is the maximum value
of n .

Professor Vector is preparing to teach her Arithmancy class. She needs to
prepare n distinct magic words for the class. Each magic word is a string
consisting of characters X and O. A spell is a string created by concatenating
two magic words together. The power of a spell is equal to the number of its
different non-empty substrings. For example, the power of the spell XOXO is
equal to 7, because it has 7 different substrings: X, O, XO, OX, XOX, OXO and
XOXO.

Each student will create their own spell by concatenating two magic words.
Since the students are not very good at magic yet, they will choose each of
the two words independently and uniformly at random from the n words provided
by Professor Vector. It is therefore also possible that the two words a
student chooses are the same. Each student will then compute the power of
their spell, and tell it to Professor Vector. In order to check their work,
and of course to impress the students, Professor Vector needs to find out
which two magic words and in which order were concatenated by each student.

Your program needs to perform the role of Professor Vector: first, create n
distinct magic words, and then handle multiple requests where it is given the
spell power and needs to determine the indices of the two magic words, in the
correct order, that were used to create the corresponding spell.

Interaction

This is an interactive problem.

First, your program should read a single integer n (1 \le n \le 30 ), the
number of magic words to prepare. Then, it should print n magic words it has
created, one per line. The magic words must be distinct, each magic word must
have at least 1 and at most 30\cdot n characters, and each character must be
either X or O. We will denote the i -th magic word you printed as w_i (1 \le i
\le n ).

Then, your program should read a single integer q (1 \le q \le 1000 ), the
number of students in the class. Then, it should repeat the following process
q times, one per student.

For the j -th student, it should first read a single integer p_j , the power
of their spell. It is guaranteed that this number is computed by choosing two
indices u_j and v_j independently and uniformly at random between 1 and n
inclusive, concatenating w_{u_j} and w_{v_j} , and finding the number of
different non-empty substrings of the resulting string. Then, your program
must print the numbers u_j and v_j , in this order (1 \le u_j, v_j \le n ).

Note that it is not enough to find any two magic words that concatenate into a
spell with the given power. You must find the exact words used by the student
in the exact order.

Remember to flush the output stream after printing all magic words and after
printing u_j and v_j for each student.

Example

Input

Copy

    2
    
    2
    15
    
    11

Output

Copy

    XOXO
    X
    
    1 1
    
    2 1
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 17
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Define the binary encoding of a finite set of natural numbers T \subseteq
\\{0,1,2,\ldots\\} as f(T) = \sum\limits_{i \in T} 2^i . For example,
f(\\{0,2\\}) = 2^0 + 2^2 = 5 and f(\\{\\}) = 0 . Notice that f is a bijection
from all such sets to all non-negative integers. As such, f^{-1} is also
defined.

You are given an integer n along with 2^n-1 sets V_1,V_2,\ldots,V_{2^n-1} .

Find all sets S that satisfy the following constraint:

  * S \subseteq \\{0,1,\ldots,n-1\\} . Note that S can be empty. 
  * For all non-empty subsets T \subseteq \\{0,1,\ldots,n-1\\} , |S \cap T| \in V_{f(T)} . 

Due to the large input and output, both input and output will be given in
terms of binary encodings of the sets.

Input

The first line of input contains a single integer n (1 \leq n \leq 20 ).

The second line of input contains 2^n-1 integers v_1,v_2,\ldots,v_{2^n-1} (0
\leq v_i < 2^{n+1} ) — the sets V_i given in their binary encoding where V_i =
f^{-1}(v_i) .

Output

The first line of output should contain an integer k indicating the number of
possible S .

In the following k lines, you should output f(S) for all possible S in
increasing order.

Examples

Input

    3
    
    15 15 15 15 15 15 12

Output

    4
    3
    5
    6
    7
    
Input

    5
    
    63 63 63 63 6 63 63 63 63 63 63 5 63 63 63 63 63 63 8 63 63 63 63 2 63 63 63 63 63 63 63

Output

    1
    19
    
Note

In the first test case, one possible S is f^{-1}(3) = \\{0,1\\} . All the non-
empty subsets T \subseteq \\{0,1,2\\} and the corresponding |S \cap T| , f(T)
and V_f(T) are as follows:

T | |S\cap T| | f(T) | V_{f(T)}   
---|---|---|---  
\\{0\\} | 1 | 1 | \\{0,1,2,3\\}   
\\{1\\} | 1 | 2 | \\{0,1,2,3\\}   
\\{2\\} | 0 | 4 | \\{0,1,2,3\\}   
\\{0,1\\} | 2 | 3 | \\{0,1,2,3\\}   
\\{0,2\\} | 1 | 5 | \\{0,1,2,3\\}   
\\{1,2\\} | 1 | 6 | \\{0,1,2,3\\}   
\\{0,1,2\\} | 2 | 7 | \\{2,3\\}
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 40
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There is a hidden array a of size n consisting of only 1 and -1 . Let p be the
prefix sums of array a . More formally, p is an array of length n defined as
p_i = a_1 + a_2 + \ldots + a_i . Afterwards, array p is sorted in non-
decreasing order. For example, if a = [1, -1, -1, 1, 1] , then p = [1, 0, -1,
0, 1] before sorting and p = [-1, 0, 0, 1, 1] after sorting.

You are given the prefix sum array p after sorting, but you do not know what
array a is. Your task is to count the number of initial arrays a such that the
above process results in the given sorted prefix sum array p . As this number
can be large, you are only required to find it modulo 998\,244\,353 .

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 1000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 5000
) — the size of the hidden array a .

The second line of each test case contains n integers p_1, p_2, \ldots, p_n
(|p_i| \le n ) — the n prefix sums of a sorted in non-decreasing order.

It is guaranteed that p_1 \le p_2 \le \ldots \le p_n .

It is guaranteed that the sum of n over all test cases does not exceed 5000 .

Output

For each test case, output the answer modulo 998\,244\,353 .

Example

Input

    5
    
    1
    
    0
    
    1
    
    1
    
    3
    
    -1 1 2
    
    5
    
    -1 0 0 1 1
    
    5
    
    -4 -3 -3 -2 -1

Output

    0
    1
    0
    3
    1
    
Note

In the first two test cases, the only possible arrays a for n = 1 are a = [1]
and a = [-1] . Their respective sorted prefix sum arrays p are p = [1] and p =
[-1] . Hence, there is no array a that can result in the sorted prefix sum
array p = [0] and there is exactly 1 array a that can result in the sorted
prefix sum array p = [1] .

In the third test case, it can be proven that there is no array a that could
result in the sorted prefix sum array p = [-1, 1, 2] .

In the fourth test case, the 3 possible arrays a that could result in the
sorted prefix sum array p = [-1, 0, 0, 1, 1] are:

  * a = [1, -1, 1, -1, -1] . The prefix sum array before sorting is p = [1, 0, 1, 0, -1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [1, -1, -1, 1, 1] . The prefix sum array before sorting is p = [1, 0, -1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [-1, 1, 1, -1, 1] . The prefix sum array before sorting is p = [-1, 0, 1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 

For the fifth test case, the only possible array a that could result in the
sorted prefix sum array p = [-4, -3, -3, -2, -1] is a = [-1, -1, -1, -1, 1] .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 227
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given two integers x and y .

Output two integers: the minimum of x and y , followed by the maximum of x and
y .

Input

The first line contains a single integer t (1 \leq t \leq 100 ) — the number
of test cases.

The only line of each test case contains two space-separated integers x and y
(0 \leq x, y \leq 9 ).

Output

For each test case, output two integers: the minimum of x and y , followed by
the maximum of x and y .

Example

Input

    10
    
    1 9
    
    8 4
    
    1 4
    
    3 4
    
    2 0
    
    2 4
    
    6 9
    
    3 3
    
    0 0
    
    9 9

Output

    1 9
    4 8
    1 4
    3 4
    0 2
    2 4
    6 9
    3 3
    0 0
    9 9
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 77
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: This is a hard version of the problem; it differs from the easy version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ); the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot).

Then output k non-negative integers a_1, a_2, \dots, a_k , where a_i is a
value such that after Bob gives Alice the i -th fountain, the maximum size of
her plot will be \alpha + a_i .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where a_i is a value such that
after Bob gives Alice the i -th fountain, the maximum size of her plot will be
\alpha + a_i .

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 4 
    1
    0 0 1 1 0 0 0 0 0 
    6
    15 0 0 0 
    1
    2 3 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 275
ERROR - Error: unsupported statement type: <ast.Delete object at 0x75be860120e0> del players[entity]

DEBUG - Start Task 164
ERROR - Error: unsupported statement type: <ast.AnnAssign object at 0x75be86063130> adjacency_list: List[List[int]] = [[] for _ in range(num_platforms)]

DEBUG - Start Task 43
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Vladislav has a son who really wanted to go to MIT. The college dormitory at
MIT (Moldova Institute of Technology) can be represented as a tree with n
vertices, each vertex being a room with exactly one student. A tree is a
connected undirected graph with n vertices and n-1 edges.

Tonight, there are three types of students:

  * students who want to party and play music (marked with \texttt{P} ), 
  * students who wish to sleep and enjoy silence (marked with \texttt{S} ), and 
  * students who don't care (marked with \texttt{C} ). 

Initially, all the edges are thin walls which allow music to pass through, so
when a partying student puts music on, it will be heard in every room.
However, we can place some thick walls on any edges — thick walls don't allow
music to pass through them.

The university wants to install some thick walls so that every partying
student can play music, and no sleepy student can hear it.

Because the university lost a lot of money in a naming rights lawsuit, they
ask you to find the minimum number of thick walls they will need to use.

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The first line of each test case contains an integer n (2 \leq n \leq 10^5 ) —
the number of vertices in the tree.

The second line of each test case contains n-1 integers a_2, \dots , a_n (1
\leq a_i < i ) — it means there is an edge between i and a_i in the tree.

The third line of each test case contains a string s of length n consisting of
characters \texttt{P} , \texttt{S} , and \texttt{C} , denoting that student i
is of type s_i .

The sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer — the minimum number of thick
walls needed.

Example

Input

    3
    
    3
    
    1 1
    
    CSP
    
    4
    
    1 2 2
    
    PCSS
    
    4
    
    1 2 2
    
    PPSS

Output

    1
    1
    2
    
Note

In the first case, we can install one thick wall between rooms 1 and 2 , as
shown below. We cannot install 0 walls, since then the music from room 3 will
reach room 2 where a student wants to sleep, so the answer is 1 . There are
other valid solutions.

![](https://espresso.codeforces.com/7829c4a96192afbd162c82af7a2c95ff80e8daa1.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 97
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The organizing committee plans to take the participants of the Olympiad on a
hike after the tour. Currently, the number of tents needed to be taken is
being calculated. It is known that each tent can accommodate up to 3 people.

Among the participants, there are a introverts, b extroverts, and c
universals:

  * Each introvert wants to live in a tent alone. Thus, a tent with an introvert must contain exactly one person — only the introvert himself. 
  * Each extrovert wants to live in a tent with two others. Thus, the tent with an extrovert must contain exactly three people. 
  * Each universal is fine with any option (living alone, with one other person, or with two others). 

The organizing committee respects the wishes of each participant very much, so
they want to fulfill all of them.

Tell us the minimum number of tents needed to be taken so that all
participants can be accommodated according to their preferences. If it is
impossible to accommodate the participants in a way that fulfills all the
wishes, output -1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
the descriptions of the test cases.

Each test case is described by a single line containing three integers a , b ,
c (0 \le a, b, c \le 10^9 ) — the number of introverts, extroverts, and
universals, respectively.

Output

For each test case, output a single integer — the minimum number of tents, or
-1 if it is impossible to accommodate the participants.

Example

Input

    10
    
    1 2 3
    
    1 4 1
    
    1 4 2
    
    1 1 1
    
    1 3 2
    
    19 7 18
    
    0 0 0
    
    7 0 0
    
    0 24 0
    
    1000000000 1000000000 1000000000

Output

    3
    -1
    3
    -1
    3
    28
    0
    7
    8
    1666666667
    
Note

In the first test case, 1 tent will be given to the introverts, 1 tent will be
shared by two extroverts and one universal, and the last tent will be shared
by two universals. In total, 3 tents are needed.

In the second test case, three extroverts will take 1 tent, and 1 tent will be
taken by an introvert. Then, one extrovert and one universal will be left.
This extrovert will not be able to live with two others.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': '', 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 189
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given an integer n . You choose n cells (x_1,y_1),
(x_2,y_2),\dots,(x_n,y_n) in the grid n\times n where 1\le x_i\le n and 1\le
y_i\le n .

Let \mathcal{H} be the set of distinct Manhattan distances between any pair of
cells. Your task is to maximize the size of \mathcal{H} . Examples of sets and
their construction are given in the notes.

If there exists more than one solution, you are allowed to output any.

Manhattan distance between cells (x_1,y_1) and (x_2,y_2) equals
|x_1-x_2|+|y_1-y_2| .

Input

The first line contains a single integer t (1\le t\le 50 ) — the number of
test cases.

Each of the following t lines contains a single integer n (2\le n\le 10^3 ).

Output

For each test case, output n points which maximize the size of \mathcal{H} .
It is not necessary to output an empty line at the end of the answer for each
test case.

Example

Input

    5
    
    2
    
    3
    
    4
    
    5
    
    6

Output

    1 1
    1 2
    
    2 1
    2 3
    3 1
    
    1 1
    1 3
    4 3
    4 4
    
    1 1
    1 3
    1 4
    2 1
    5 5
    
    1 4
    1 5
    1 6
    5 2
    5 5
    6 1
    
Note

In the first testcase we have n=2 . One of the possible arrangements is:

![](https://espresso.codeforces.com/4d7adaa08c9ee5ebf2a0caba13185ac968d6bcd9.png)
The arrangement with cells located in (1,1) and (1,2) . In this case
\mathcal{H}=\\{|1-1|+|1-1|,|1-1|+|2-2|,|1-1|+|1-2|\\}=\\{0,0,1\\}=\\{0,1\\} .
Hence, the size of \mathcal{H} is 2 . It can be shown that it is the greatest
possible answer.

In the second testcase we have n=3 . The optimal arrangement is:

![](https://espresso.codeforces.com/52d127e3dbe0141bb58dbdf4158586772a208758.png)
The arrangement with cells located in (2,1) , (2,3) and (3,1) .

\mathcal{H}
=\\{|2-2|+|1-1|,|2-2|+|3-3|,|3-3|+|1-1|,|2-2|+|1-3|,|2-3|+|1-1|,|2-3|+|3-1|\\}
=\\{0,0,0,2,1,3\\} =\\{0,1,2,3\\} .

For n=4 a possible arrangement is:

![](https://espresso.codeforces.com/575a6758d1f67174ceb877b32a1e89770cd2281a.png)

For n=5 a possible arrangement is:

![](https://espresso.codeforces.com/b790401b426625982c00d04cff13aceec53918b4.png)

For n=6 a possible arrangement is:

![](https://espresso.codeforces.com/d0f498905660a67115d9f58c6cbc1439ba6e509c.png)
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 43
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Vladislav has a son who really wanted to go to MIT. The college dormitory at
MIT (Moldova Institute of Technology) can be represented as a tree with n
vertices, each vertex being a room with exactly one student. A tree is a
connected undirected graph with n vertices and n-1 edges.

Tonight, there are three types of students:

  * students who want to party and play music (marked with \texttt{P} ), 
  * students who wish to sleep and enjoy silence (marked with \texttt{S} ), and 
  * students who don't care (marked with \texttt{C} ). 

Initially, all the edges are thin walls which allow music to pass through, so
when a partying student puts music on, it will be heard in every room.
However, we can place some thick walls on any edges — thick walls don't allow
music to pass through them.

The university wants to install some thick walls so that every partying
student can play music, and no sleepy student can hear it.

Because the university lost a lot of money in a naming rights lawsuit, they
ask you to find the minimum number of thick walls they will need to use.

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The first line of each test case contains an integer n (2 \leq n \leq 10^5 ) —
the number of vertices in the tree.

The second line of each test case contains n-1 integers a_2, \dots , a_n (1
\leq a_i < i ) — it means there is an edge between i and a_i in the tree.

The third line of each test case contains a string s of length n consisting of
characters \texttt{P} , \texttt{S} , and \texttt{C} , denoting that student i
is of type s_i .

The sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer — the minimum number of thick
walls needed.

Example

Input

    3
    
    3
    
    1 1
    
    CSP
    
    4
    
    1 2 2
    
    PCSS
    
    4
    
    1 2 2
    
    PPSS

Output

    1
    1
    2
    
Note

In the first case, we can install one thick wall between rooms 1 and 2 , as
shown below. We cannot install 0 walls, since then the music from room 3 will
reach room 2 where a student wants to sleep, so the answer is 1 . There are
other valid solutions.

![](https://espresso.codeforces.com/7829c4a96192afbd162c82af7a2c95ff80e8daa1.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 270
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The only difference with the medium version is the maximum length of the
input.

A parentheses sequence is a string consisting of characters "(" and ")", for
example "(()((".

A balanced parentheses sequence is a parentheses sequence which can become a
valid mathematical expression after inserting numbers and operations into it,
for example "(()(()))".

The balance of a parentheses sequence is defined as the number of opening
parentheses "(" minus the number of closing parentheses ")". For example, the
balance of the sequence "(()((" is 3.

A balanced parentheses sequence can also be defined as a parentheses sequence
with balance 0 such that each of its prefixes has a non-negative balance.

We define the balanced shuffle operation that takes a parentheses sequence and
returns a parentheses sequence as follows: first, for every character of the
input sequence, we compute the balance of the prefix of the sequence before
that character and write those down in a table together with the positions of
the characters in the input sequence, for example:

Prefix balance| 0| 1| 2| 1| 2| 3| 2| 1  
---|---|---|---|---|---|---|---|---  
Position| 1| 2| 3| 4| 5| 6| 7| 8  
Character| (| (| )| (| (| )| )| )  
  
Then, we sort the columns of this table in increasing order of prefix balance,
breaking ties in decreasing order of position. In the above example, we get:

Prefix balance| 0| 1| 1| 1| 2| 2| 2| 3  
---|---|---|---|---|---|---|---|---  
Position| 1| 8| 4| 2| 7| 5| 3| 6  
Character| (| )| (| (| )| (| )| )  
  
The last row of this table forms another parentheses sequence, in this case
"()(()())". This sequence is called the result of applying the balanced
shuffle operation to the input sequence, or in short just the balanced shuffle
of the input sequence.

Surprisingly, it turns out that the balanced shuffle of any balanced
parentheses sequence is always another balanced parentheses sequence (we will
omit the proof for brevity). Even more surprisingly, the balanced shuffles of
two different balanced parentheses sequences are always different, therefore
the balanced shuffle operation is a bijection on the set of balanced
parentheses sequences of any given length (we will omit this proof, too).

You are given a balanced parentheses sequence. Find its preimage: the balanced
parentheses sequence the balanced shuffle of which is equal to the given
sequence.

Input

The only line of input contains a string s consisting only of characters "("
and ")". This string is guaranteed to be a non-empty balanced parentheses
sequence with its length not exceeding 500\,000 .

Output

Print the balanced parentheses sequence t such that the balanced shuffle of t
is equal to s . It is guaranteed that the answer always exists and is unique.

Example

Input

    ()(()())
    
Output

    (()(()))
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 267
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given a string s , consisting of lowercase Latin letters and/or
question marks.

A tandem repeat is a string of an even length such that its first half is
equal to its second half.

A string a is a substring of a string b if a can be obtained from b by the
deletion of several (possibly, zero or all) characters from the beginning and
several (possibly, zero or all) characters from the end.

Your goal is to replace each question mark with some lowercase Latin letter in
such a way that the length of the longest substring that is a tandem repeat is
maximum possible.

Input

The first line contains a single integer t (1 \le t \le 1000 ) — the number of
testcases.

The only line of each testcase contains a string s (1 \le |s| \le 5000 ),
consisting only of lowercase Latin letters and/or question marks.

The total length of the strings over all testcases doesn't exceed 5000 .

Output

For each testcase, print a single integer — the maximum length of the longest
substring that is a tandem repeat after you replace each question mark in the
string with some lowercase Latin letter.

If it's impossible to make any tandem repeat substrings in the string, print 0
.

Example

Input

    4
    
    zaabaabz
    
    ?????
    
    code?????s
    
    codeforces

Output

    6
    4
    10
    0
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 266
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There is a grid, consisting of 2 rows and n columns. The rows are numbered
from 1 to 2 from top to bottom. The columns are numbered from 1 to n from left
to right. Each cell of the grid contains an arrow pointing either to the left
or to the right. No arrow points outside the grid.

There is a robot that starts in a cell (1, 1) . Every second, the following
two actions happen one after another:

  1. Firstly, the robot moves left, right, down or up (it can't try to go outside the grid, and can't skip a move); 
  2. then it moves along the arrow that is placed in the current cell (the cell it ends up after its move). 

Your task is to determine whether the robot can reach the cell (2, n) .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains a single integer (2 \le n \le 2
\cdot 10^5 ).

The second line contains a string consisting of exactly n characters < and/or
> — the first row of the grid.

The third line contains a string consisting of exactly n characters < and/or >
— the second row of the grid.

Additional constraints on the input:

  * n is even; 
  * there are no arrows pointing outside the grid; 
  * the sum of n over all test cases doesn't exceed 2 \cdot 10^5 . 

Output

For each test case, print YES if the robot can reach the cell (2, n) ;
otherwise, print NO.

You can print each letter in any case. For example, yes, Yes, YeS will all be
recognized as positive answer.

Example

Input

    4
    
    4
    
    >><<
    
    >>><
    
    2
    
    ><
    
    ><
    
    4
    
    >>><
    
    >><<
    
    6
    
    >><<><
    
    ><>>><

Output

    YES
    YES
    NO
    YES
    
Note

In the first example, one of the possible paths looks as follows: (1, 1)
\rightarrow (1, 2) \rightarrow (1, 3) \rightarrow (2, 3) \rightarrow (2, 4) .

In the second example, one of the possible paths looks as follows: (1, 1)
\rightarrow (2, 1) \rightarrow (2, 2) .

In the third example, there is no way to reach the cell (2, 4) .

In the fourth example, one of the possible paths looks as follows: (1, 1)
\rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (1, 2) \rightarrow (1, 3)
\rightarrow (2, 3) \rightarrow (2, 4) \rightarrow (2, 5) \rightarrow (2, 6) .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 202
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have a strip of paper with a binary string s of length n . You can fold
the paper in between any pair of adjacent digits.

A set of folds is considered valid if after the folds, all characters that are
on top of or below each other match. Note that all folds are made at the same
time, so the characters don't have to match in between folds.

For example, these are valid foldings of s = \mathtt{110110110011} and s =
\mathtt{01110} :

![](https://espresso.codeforces.com/a961dc7cc221603a7d5a488247ba5439ce7444da.png)

The length of the folded strip is the length seen from above after all folds
are made. So for the two above examples, after the folds shown above, the
lengths would be 7 and 3 , respectively.

Notice that for the above folding of s = \mathtt{01110} , if we made either of
the two folds on their own, that would not be a valid folding. However,
because we don't check for validity until all folds are made, this folding is
valid.

After performing a set of valid folds, what is the minimum length strip you
can form?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le
2\cdot 10^5 ) — the size of the strip.

The second line of each test case contains a string s of n characters '0' and
'1' — a description of the digits on the strip.

It is guaranteed that the sum of n over all test cases does not exceed 2\cdot
10^5 .

Output

For each test case, output a single integer — the minimum possible length of
the strip after a valid folding.

Example

Input

    6
    
    6
    
    101101
    
    1
    
    0
    
    12
    
    110110110011
    
    5
    
    01110
    
    4
    
    1111
    
    2
    
    01

Output

    3
    1
    3
    3
    1
    2
    
Note

For the first example case, one optimal folding is to fold the strip in the
middle, which produces a strip of length 3.

The third and fourth example cases correspond to the images above. Note that
the folding shown above for s = \mathtt{110110110011} is not of minimal
length.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 343
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There is a hidden array a of n positive integers. You know that a is a
palindrome, or in other words, for all 1 \le i \le n , a_i = a_{n + 1 - i} .
You are given the sums of all but one of its distinct subarrays, in arbitrary
order. The subarray whose sum is not given can be any of the \frac{n(n+1)}{2}
distinct subarrays of a .

Recover any possible palindrome a . The input is chosen such that there is
always at least one array a that satisfies the conditions.

An array b is a subarray of a if b can be obtained from a by the deletion of
several (possibly, zero or all) elements from the beginning and several
(possibly, zero or all) elements from the end.

Input

The first line of the input contains a single integer t (1 \le t \le 200 ) —
the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n (3 \le n \le 1000
) — the size of the array a .

The next line of each test case contains \frac{n(n+1)}{2} - 1 integers s_i
(1\leq s_i \leq 10^9 ) — all but one of the subarray sums of a .

It is guaranteed that the sum of n over all test cases does not exceed 1000 .

Additional constraint on the input: There is always at least one valid
solution.

Hacks are disabled for this problem.

Output

For each test case, print one line containing n positive integers a_1, a_2,
\cdots a_n — any valid array a . Note that a must be a palindrome.

If there are multiple solutions, print any.

Example

Input

    7
    
    3
    
    1 2 3 4 1
    
    4
    
    18 2 11 9 7 11 7 2 9
    
    4
    
    5 10 5 16 3 3 13 8 8
    
    4
    
    8 10 4 6 4 20 14 14 6
    
    5
    
    1 2 3 4 5 4 3 2 1 1 2 3 2 1
    
    5
    
    1 1 2 2 2 3 3 3 3 4 5 5 6 8
    
    3
    
    500000000 1000000000 500000000 500000000 1000000000

Output

    1 2 1 
    7 2 2 7 
    3 5 5 3 
    6 4 4 6 
    1 1 1 1 1 
    2 1 2 1 2 
    500000000 500000000 500000000 
    
Note

For the first example case, the subarrays of a = [1, 2, 1] are:

  * [1] with sum 1 , 
  * [2] with sum 2 , 
  * [1] with sum 1 , 
  * [1, 2] with sum 3 , 
  * [2, 1] with sum 3 , 
  * [1, 2, 1] with sum 4 . 

So the full list of subarray sums is 1, 1, 2, 3, 3, 4 , and the sum that is
missing from the input list is 3 .

For the second example case, the missing subarray sum is 4 , for the subarray
[2, 2] .

For the third example case, the missing subarray sum is 13 , because there are
two subarrays with sum 13 ([3, 5, 5] and [5, 5, 3] ) but 13 only occurs once
in the input.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 252
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are playing a computer game. The current level of this game can be modeled
as a straight line. Your character is in point 0 of this line. There are n
monsters trying to kill your character; the i -th monster has health equal to
a_i and is initially in the point x_i .

Every second, the following happens:

  * first, you fire up to k bullets at monsters. Each bullet targets exactly one monster and decreases its health by 1 . For each bullet, you choose its target arbitrary (for example, you can fire all bullets at one monster, fire all bullets at different monsters, or choose any other combination). Any monster can be targeted by a bullet, regardless of its position and any other factors; 
  * then, all alive monsters with health 0 or less die; 
  * then, all alive monsters move 1 point closer to you (monsters to the left of you increase their coordinates by 1 , monsters to the right of you decrease their coordinates by 1 ). If any monster reaches your character (moves to the point 0 ), you lose. 

Can you survive and kill all n monsters without letting any of them reach your
character?

Input

The first line of the input contains one integer t (1 \le t \le 3 \cdot 10^4 )
— the number of test cases.

Each test case consists of three lines:

  * the first line contains two integers n and k (1 \le n \le 3 \cdot 10^5 ; 1 \le k \le 2 \cdot 10^9 ); 
  * the second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^9 ); 
  * the third line contains n integers x_1, x_2, \dots, x_n (-n \le x_1 < x_2 < x_3 < \dots < x_n \le n ; x_i \ne 0 ). 

Additional constraint on the input: the sum of n over all test cases does not
exceed 3 \cdot 10^5 .

Output

For each test case, print YES if you can kill all n monsters before they reach
your character, or NO otherwise.

You can output each letter of the answer in any case (upper or lower). For
example, the strings yEs, yes, Yes, and YES will all be recognized as positive
responses.

Example

Input

    5
    
    3 2
    
    1 2 3
    
    -1 2 3
    
    2 1
    
    1 1
    
    -1 1
    
    4 10
    
    3 4 2 5
    
    -3 -2 1 3
    
    5 3
    
    2 1 3 2 5
    
    -3 -2 3 4 5
    
    2 1
    
    1 2
    
    1 2

Output

    YES
    NO
    YES
    YES
    NO
    
Note

In the first example, you can act as follows:

  * during the 1 -st second, fire 1 bullet at the 1 -st monster and 1 bullet at the 3 -rd monster. Then the 1 -st monster dies, the 2 -nd and the 3 -rd monster move closer; 
  * during the 2 -nd second, fire 2 bullets at the 2 -nd monster. Then the 2 -nd monster dies, the 3 -rd monster moves closer; 
  * during the 3 -rd second, fire 2 bullets at the 3 -rd monster. Then the 3 -rd monster dies. 

In the second example, you can fire only 1 bullet, so you can kill only one of
the two monsters during the 1 -st second. Then, the remaining monster moves
closer and kills your character.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 341
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have been asked to organize a very important art conference. The first
step is to choose the dates.

The conference must last for a certain number of consecutive days. Each day,
one lecturer must perform, and the same lecturer cannot perform more than
once.

You asked n potential lecturers if they could participate in the conference.
Lecturer i indicated that they could perform on any day from l_i to r_i
inclusive.

A certain segment of days can be chosen as the conference dates if there is a
way to assign an available lecturer to each day of the segment, assigning each
lecturer to no more than one day.

For each k from 1 to n , find how many ways there are to choose a segment of k
consecutive days as the conference dates.

Input

The first line of input contains one integer n — the number of potential
lecturers (1 \le n \le 2 \cdot 10^5 ).

Each of the next n lines contains two integers l_i and r_i — the segment of
available days for the i th lecturer (1 \le l_i \le r_i \le 2 \cdot 10^5 ).

Output

Print n integers, where the k th number denotes the number of ways to select a
segment of k consecutive days as conference dates.

Examples

Input

    3
    
    1 2
    
    3 4
    
    5 6

Output

    6
    2
    0
    
Input

    5
    
    1 3
    
    1 3
    
    1 3
    
    1 3
    
    1 3

Output

    3
    2
    1
    0
    0
    
Note

In the first testcase, a one-day conference can be organized on any of the
days from 1 to 6 . A two-day conference can be organized from day 2 to day 3 ,
as well as from day 4 to day 5 .

In the second testcase, five lecturers can perform only from day 1 to day 3 ,
so it will not be possible to organize a conference longer than three days.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 191
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 222
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Given an integer r , find the number of lattice points that have a Euclidean
distance from (0, 0) greater than or equal to r but strictly less than r+1 .

A lattice point is a point with integer coordinates. The Euclidean distance
from (0, 0) to the point (x,y) is \sqrt{x^2 + y^2} .

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The only line of each test case contains a single integer r (1 \leq r \leq
10^5 ).

The sum of r over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer — the number of lattice points
that have an Euclidean distance d from (0, 0) such that r \leq d < r+1 .

Example

Input

    6
    
    1
    
    2
    
    3
    
    4
    
    5
    
    1984

Output

    8
    16
    20
    24
    40
    12504
    
Note

The points for the first three test cases are shown below.

![](https://espresso.codeforces.com/66c3f9d945c97358ed2f31c823ce9b70e46c6a4d.png)
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 273
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: After some recent attacks on Hogwarts Castle by the Death Eaters, the Order of
the Phoenix has decided to station n members in Hogsmead Village. The houses
will be situated on a picturesque n\times n square field. Each wizard will
have their own house, and every house will belong to some wizard. Each house
will take up the space of one square.

However, as you might know wizards are very superstitious. During the
weekends, each wizard i will want to visit the house that is exactly a_{i} (0
\leq a_{i} \leq n) away from their own house. The roads in the village are
built horizontally and vertically, so the distance between points (x_{i},
y_{i}) and (x_{j}, y_{j}) on the n\times n field is |x_{i} - x_{j}| + |y_{i} -
y_{j}| . The wizards know and trust each other, so one wizard can visit
another wizard's house when the second wizard is away. The houses to be built
will be big enough for all n wizards to simultaneously visit any house.

Apart from that, each wizard is mandated to have a view of the Hogwarts Castle
in the north and the Forbidden Forest in the south, so the house of no other
wizard should block the view. In terms of the village, it means that in each
column of the n\times n field, there can be at most one house, i.e. if the i
-th house has coordinates (x_{i}, y_{i}) , then x_{i} \neq x_{j} for all i
\neq j .

The Order of the Phoenix doesn't yet know if it is possible to place n houses
in such a way that will satisfy the visit and view requirements of all n
wizards, so they are asking for your help in designing such a plan.

If it is possible to have a correct placement, where for the i -th wizard
there is a house that is a_{i} away from it and the house of the i -th wizard
is the only house in their column, output YES, the position of houses for each
wizard, and to the house of which wizard should each wizard go during the
weekends.

If it is impossible to have a correct placement, output NO.

Input

The first line contains n (2 \leq n \leq 2\cdot 10^{5} ), the number of houses
to be built.

The second line contains n integers a_{1}, \ldots, a_{n} (0 \leq a_{i} \leq n)

Output

If there exists such a placement, output YES on the first line; otherwise,
output NO.

If the answer is YES, output n + 1 more lines describing the placement.

The next n lines should contain the positions of the houses 1 \leq x_{i},
y_{i} \leq n for each wizard.

The i -th element of the last line should contain the index of the wizard, the
house of which is exactly a_{i} away from the house of the i -th wizard. If
there are multiple such wizards, you can output any.

If there are multiple house placement configurations, you can output any.

Examples

Input

    4
    0 4 2 4
    
Output

    YES
    4 4
    1 3
    2 4
    3 1
    1 1 1 3

Input

    4
    1 3 0 1
    
Output

    YES
    2 1
    4 1
    1 1
    3 1
    3 3 3 1

Note

For the sample, the house of the 1st wizard is located at (4, 4) , of the 2nd
at (1, 3) , of the 3rd at (2, 4) , of the 4th at (3, 1) .

The distance from the house of the 1st wizard to the house of the 1st wizard
is |4 - 4| + |4 - 4| = 0 .

The distance from the house of the 2nd wizard to the house of the 1st wizard
is |1 - 4| + |3 - 4| = 4 .

The distance from the house of the 3rd wizard to the house of the 1st wizard
is |2 - 4| + |4 - 4| = 2 .

The distance from the house of the 4th wizard to the house of the 3rd wizard
is |3 - 2| + |1 - 4| = 4 .

The view and the distance conditions are satisfied for all houses, so the
placement is correct.

![](https://espresso.codeforces.com/2790cf05cadf5e6334d074a3605416ddb963947f.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 352
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There are n containers of water lined up, numbered from left to right from 1
to n . Each container can hold any amount of water; initially, the i -th
container contains a_i units of water. The sum of a_i is divisible by n .

You can apply the following operation any (possibly zero) number of times:
pour any amount of water from the i -th container to the j -th container,
where i must be less than j (i.e. i<j ). Any index can be chosen as i or j any
number of times.

Determine whether it is possible to make the amount of water in all containers
the same using this operation.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of containers with water.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (0
\le a_i \le 10^9 ) — the amounts of water in the containers. It is guaranteed
that the sum of a_i in each test case does not exceed 2 \cdot 10^9 . Also, the
sum of a_i is divisible by n .

It is guaranteed that the sum of n over all test cases in the input does not
exceed 2 \cdot 10^5 .

Output

Output t lines, each of which is the answer to the corresponding test case. As
the answer, output "YES" if it is possible to make the amount of water in all
containers the same using the described operation. Otherwise, output "NO".

You can output each letter in any case (lowercase or uppercase). For example,
the strings "yEs", "yes", "Yes", and "YES" will be accepted as a positive
answer.

Example

Input

    6
    
    1
    
    43
    
    2
    
    1 3
    
    5
    
    4 5 2 1 3
    
    3
    
    1 2 3
    
    7
    
    4 5 5 0 6 4 4
    
    7
    
    6 5 5 1 3 4 4

Output

    YES
    NO
    YES
    NO
    NO
    YES
    
Note

In the third test case of the example (a=[4, 5, 2, 1, 3] ), you can proceed as
follows:

  * pour 1 unit of water from the first vessel to the fourth, then a=[3, 5, 2, 2, 3] ; 
  * pour 1 unit of water from the second vessel to the third, then a=[3, 4, 3, 2, 3] ; 
  * pour 1 unit of water from the second vessel to the fourth, then a=[3, 3, 3, 3, 3] .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 284
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The only difference between this and the hard version is that all a_{i} are
even.

After some recent attacks on Hogwarts Castle by the Death Eaters, the Order of
the Phoenix has decided to station n members in Hogsmead Village. The houses
will be situated on a picturesque n\times n square field. Each wizard will
have their own house, and every house will belong to some wizard. Each house
will take up the space of one square.

However, as you might know wizards are very superstitious. During the
weekends, each wizard i will want to visit the house that is exactly a_{i} (0
\leq a_{i} \leq n) away from their own house. The roads in the village are
built horizontally and vertically, so the distance between points (x_{i},
y_{i}) and (x_{j}, y_{j}) on the n\times n field is |x_{i} - x_{j}| + |y_{i} -
y_{j}| . The wizards know and trust each other, so one wizard can visit
another wizard's house when the second wizard is away. The houses to be built
will be big enough for all n wizards to simultaneously visit any house.

Apart from that, each wizard is mandated to have a view of the Hogwarts Castle
in the north and the Forbidden Forest in the south, so the house of no other
wizard should block the view. In terms of the village, it means that in each
column of the n\times n field, there can be at most one house, i.e. if the i
-th house has coordinates (x_{i}, y_{i}) , then x_{i} \neq x_{j} for all i
\neq j .

The Order of the Phoenix doesn't yet know if it is possible to place n houses
in such a way that will satisfy the visit and view requirements of all n
wizards, so they are asking for your help in designing such a plan.

If it is possible to have a correct placement, where for the i -th wizard
there is a house that is a_{i} away from it and the house of the i -th wizard
is the only house in their column, output YES, the position of houses for each
wizard, and to the house of which wizard should each wizard go during the
weekends.

If it is impossible to have a correct placement, output NO.

Input

The first line contains n (2 \leq n \leq 2\cdot 10^{5} ), the number of houses
to be built.

The second line contains n integers a_{1}, \ldots, a_{n} (0 \leq a_{i} \leq n)
. All a_{i} are even.

Output

If there exists such a placement, output YES on the first line; otherwise,
output NO.

If the answer is YES, output n + 1 more lines describing the placement.

The next n lines should contain the positions of the houses 1 \leq x_{i},
y_{i} \leq n for each wizard.

The i -th element of the last line should contain the index of the wizard, the
house of which is exactly a_{i} away from the house of the i -th wizard. If
there are multiple such wizards, you can output any.

If there are multiple house placement configurations, you can output any.

Example

Input

    4
    0 4 2 4

Output

    YES
    4 4
    1 3
    2 4
    3 1
    1 1 1 3

Note

For the sample, the house of the 1st wizard is located at (4, 4) , of the 2nd
at (1, 3) , of the 3rd at (2, 4) , of the 4th at (3, 1) .

The distance from the house of the 1st wizard to the house of the 1st wizard
is |4 - 4| + |4 - 4| = 0 .

The distance from the house of the 2nd wizard to the house of the 1st wizard
is |1 - 4| + |3 - 4| = 4 .

The distance from the house of the 3rd wizard to the house of the 1st wizard
is |2 - 4| + |4 - 4| = 2 .

The distance from the house of the 4th wizard to the house of the 3rd wizard
is |3 - 2| + |1 - 4| = 4 .

The view and the distance conditions are satisfied for all houses, so the
placement is correct.

![](https://espresso.codeforces.com/2790cf05cadf5e6334d074a3605416ddb963947f.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 124
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Given an integer n , you construct an array a of n integers, where a_i = i for
all integers i in the range [1, n] . An operation on this array is defined as
follows:

  * Select three distinct indices i , j , and k from the array, and let x = a_i , y = a_j , and z = a_k . 
  * Update the array as follows: a_i = \operatorname{lcm}(y, z) , a_j = \operatorname{lcm}(x, z) , and a_k = \operatorname{lcm}(x, y) , where \operatorname{lcm} represents the least common multiple. 

Your task is to provide a possible sequence of operations, containing at most
\lfloor \frac{n}{6} \rfloor + 5 operations such that after executing these
operations, if you create a set containing the greatest common divisors (GCDs)
of all subsequences with a size greater than 1 , then all numbers from 1 to n
should be present in this set.

After all the operations a_i \le 10^{18} should hold for all 1 \le i \le n .

We can show that an answer always exists.

Input

The first line contains one integer t (1 \le t \le 10^2 ) — the number of test
cases. The description of the test cases follows.

The first and only line of each test case contains an integer n (3 \leq n \leq
3 \cdot 10^{4} ) — the length of the array.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^{4} .

Output

The first line should contain an integer k (0 \leq k \leq \lfloor \frac{n}{6}
\rfloor + 5 ) — where k is the number of operations.

The next k lines should contain the description of each operation i.e. 3
integers i , j and k , where 1 \leq i, j, k \leq n and all must be distinct.

Example

Input

    3
    
    3
    
    4
    
    7

Output

    1
    1 2 3
    1
    1 3 4
    3
    3 5 7
    5 6 7
    2 3 4

Note

In the third test case, a = [1, 2, 3, 4, 5, 6, 7] .

First operation:

i = 3 , j = 5 , k = 7

x = 3 , y = 5 , z = 7 .

a = [1, 2, \operatorname{lcm}(y,z), 4, \operatorname{lcm}(x,z), 6,
\operatorname{lcm}(x,y)] = [1, 2, \color{red}{35}, 4, \color{red}{21}, 6,
\color{red}{15}] .

Second operation:

i = 5 , j = 6 , k = 7

x = 21 , y = 6 , z = 15 .

a = [1, 2, 35, 4, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z),
\operatorname{lcm}(x,y)] = [1, 2, 35, 4, \color{red}{30}, \color{red}{105},
\color{red}{42}] .

Third operation:

i = 2 , j = 3 , k = 4

x = 2 , y = 35 , z = 4 .

a = [1, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z),
\operatorname{lcm}(x,y), 30, 105, 42] = [1, \color{red}{140}, \color{red}{4},
\color{red}{70}, 30, 105, 42] .

Subsequences whose GCD equal to i is as follows:

\gcd(a_1, a_2) = \gcd(1, 140) = 1

\gcd(a_3, a_4) = \gcd(4, 70) = 2

\gcd(a_5, a_6, a_7) = \gcd(30, 105, 42) = 3

\gcd(a_2, a_3) = \gcd(140, 4) = 4

\gcd(a_2, a_4, a_5, a_6) = \gcd(140, 70, 30, 105) = 5

\gcd(a_5, a_7) = \gcd(30, 42) = 6

\gcd(a_2, a_4, a_6, a_7) = \gcd(140, 70, 105, 42) = 7
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 243
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are designing a new video game. It has n scenarios, which the player may
play in any order, but each scenario must be played exactly once. When a
player switches from a scenario to another scenario, the game shows a
specially crafted transition video to make it all feel part of one big story.
This video is specific to a pair of scenarios, but not to their order, in
other words, the video playing when switching from scenario a to scenario b is
the same as the video playing when switching from scenario b to scenario a .
Therefore, you need to create \frac{n(n-1)}{2} different transition videos,
one for each possible pair of different scenarios.

Each transition video can be either funny or scary. It is boring to see too
many funny videos or too many scary videos in a row. Therefore, your goal is
to create the videos in such a way that no matter in which order does the
player approach the scenarios, they will never see more than \lceil
\frac{3n}{4} \rceil transition videos of the same type in a row.

You have already come up with ideas for at most \lfloor \frac{n}{2} \rfloor of
the transition videos, and therefore already know if those will be funny or
scary. Now you need to choose funny or scary for all other transition videos
in such a way that the above requirement is satisfied.

Input

The first line contains a single integer n (2 \le n \le 24 ) — the number of
scenarios in the game.

The next n lines describe the partial transition video plan. Each of those
lines contains n characters. The j -th character of the i -th line corresponds
to the transition video between the i -th and the j -th scenarios. It will be
F if the corresponding transition video will be funny, S if the corresponding
transition video will be scary, ? if the corresponding transition video is
still undecided, or . if i=j .

It is guaranteed that the i -th character of the j -th line and the j -th
character of the i -th line will be the same for all i and j . It is
guaranteed that at most \lfloor \frac{n}{2} \rfloor (n divided by 2, rounded
down) transition videos will already be decided, in other words, that at most
2\lfloor \frac{n}{2} \rfloor characters in the input will be F or S.

Output

Print n lines describing the full transition video plan in the same format as
the input. Each of those lines must contain n characters. The j -th character
of the i -th line must be F if the corresponding transition video is funny, S
if the corresponding transition video is scary, or . if i=j .

Each ? character from the input must be replaced with either F or S, and all
other characters from the input must remain unchanged. It must still hold that
the i -th character of the j -th line and the j -th character of the i -th
line are the same for all i and j .

For each permutation of the n scenarios, it must hold that the transition
videos corresponding to playing the scenarios in this order do not have more
than \lceil \frac{3n}{4} \rceil (3n divided by 4, rounded up) videos of the
same type consecutively.

If there are multiple solutions, print any of them. It can be proven that for
all inputs satisfying the constraints of this problem a solution always
exists.

Examples

Input

    5
    
    .?F??
    
    ?.???
    
    F?.S?
    
    ??S.?
    
    ????.

Output

    .FFFF
    F.FFF
    FF.SF
    FFS.F
    FFFF.

Input

    12
    
    .???????????
    
    ?.??????????
    
    ??.?????????
    
    ???.????????
    
    ????.???????
    
    ?????.??????
    
    ??????.?????
    
    ???????.????
    
    ????????.???
    
    ?????????.??
    
    ??????????.?
    
    ???????????.

Output

    .SSSFFSSSSFS
    S.SFFSFSFFFS
    SS.SFFFSSSFS
    SFS.FFSSSSFS
    FFFF.FFFFFSF
    FSFFF.SFFSFF
    SFFSFS.SSSFS
    SSSSFFS.SSFS
    SFSSFFSS.SFS
    SFSSFSSSS.FS
    FFFFSFFFFF.F
    SSSSFFSSSSF.
    
Note

In the first sample: We are allowed \lceil \frac{3\cdot 5}{4} \rceil=4
transition videos of the same type in a row, but for any permutation of the 5
scenarios the player will see only 4 transition videos in total, therefore we
can choose funny or scary freely. We must still respect the already chosen
types.

In the second sample: One of the 479001600 possible permutations of scenarios
is 1, 7, 4, 12, 9, 8, 2, 6, 10, 3, 11, 5. The player will get the following
sequence of transition videos for this permutation: SSSSSSSSSFS. Even though
this sequence has 10 scary transition videos in total, it has only 9 scary
transition videos in a row, which is the maximum allowed amount (\lceil
\frac{3\cdot 12}{4} \rceil=9 ).
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 284
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The only difference between this and the hard version is that all a_{i} are
even.

After some recent attacks on Hogwarts Castle by the Death Eaters, the Order of
the Phoenix has decided to station n members in Hogsmead Village. The houses
will be situated on a picturesque n\times n square field. Each wizard will
have their own house, and every house will belong to some wizard. Each house
will take up the space of one square.

However, as you might know wizards are very superstitious. During the
weekends, each wizard i will want to visit the house that is exactly a_{i} (0
\leq a_{i} \leq n) away from their own house. The roads in the village are
built horizontally and vertically, so the distance between points (x_{i},
y_{i}) and (x_{j}, y_{j}) on the n\times n field is |x_{i} - x_{j}| + |y_{i} -
y_{j}| . The wizards know and trust each other, so one wizard can visit
another wizard's house when the second wizard is away. The houses to be built
will be big enough for all n wizards to simultaneously visit any house.

Apart from that, each wizard is mandated to have a view of the Hogwarts Castle
in the north and the Forbidden Forest in the south, so the house of no other
wizard should block the view. In terms of the village, it means that in each
column of the n\times n field, there can be at most one house, i.e. if the i
-th house has coordinates (x_{i}, y_{i}) , then x_{i} \neq x_{j} for all i
\neq j .

The Order of the Phoenix doesn't yet know if it is possible to place n houses
in such a way that will satisfy the visit and view requirements of all n
wizards, so they are asking for your help in designing such a plan.

If it is possible to have a correct placement, where for the i -th wizard
there is a house that is a_{i} away from it and the house of the i -th wizard
is the only house in their column, output YES, the position of houses for each
wizard, and to the house of which wizard should each wizard go during the
weekends.

If it is impossible to have a correct placement, output NO.

Input

The first line contains n (2 \leq n \leq 2\cdot 10^{5} ), the number of houses
to be built.

The second line contains n integers a_{1}, \ldots, a_{n} (0 \leq a_{i} \leq n)
. All a_{i} are even.

Output

If there exists such a placement, output YES on the first line; otherwise,
output NO.

If the answer is YES, output n + 1 more lines describing the placement.

The next n lines should contain the positions of the houses 1 \leq x_{i},
y_{i} \leq n for each wizard.

The i -th element of the last line should contain the index of the wizard, the
house of which is exactly a_{i} away from the house of the i -th wizard. If
there are multiple such wizards, you can output any.

If there are multiple house placement configurations, you can output any.

Example

Input

    4
    0 4 2 4

Output

    YES
    4 4
    1 3
    2 4
    3 1
    1 1 1 3

Note

For the sample, the house of the 1st wizard is located at (4, 4) , of the 2nd
at (1, 3) , of the 3rd at (2, 4) , of the 4th at (3, 1) .

The distance from the house of the 1st wizard to the house of the 1st wizard
is |4 - 4| + |4 - 4| = 0 .

The distance from the house of the 2nd wizard to the house of the 1st wizard
is |1 - 4| + |3 - 4| = 4 .

The distance from the house of the 3rd wizard to the house of the 1st wizard
is |2 - 4| + |4 - 4| = 2 .

The distance from the house of the 4th wizard to the house of the 3rd wizard
is |3 - 2| + |1 - 4| = 4 .

The view and the distance conditions are satisfied for all houses, so the
placement is correct.

![](https://espresso.codeforces.com/2790cf05cadf5e6334d074a3605416ddb963947f.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 29
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The two versions are different problems. You may want to read both versions.
You can make hacks only if both versions are solved.

You are given two positive integers n , m .

Calculate the number of ordered pairs (a, b) satisfying the following
conditions:

  * 1\le a\le n , 1\le b\le m ; 
  * a+b is a multiple of b \cdot \gcd(a,b) . 

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\le t\le 10^4 ). The description of the test cases follows.

The first line of each test case contains two integers n , m (1\le n,m\le 2
\cdot 10^6 ).

It is guaranteed that neither the sum of n nor the sum of m over all test
cases exceeds 2 \cdot 10^6 .

Output

For each test case, print a single integer: the number of valid pairs.

Example

Input

    6
    
    1 1
    
    2 3
    
    3 5
    
    10 8
    
    100 1233
    
    1000000 1145141

Output

    1
    3
    4
    14
    153
    1643498
    
Note

In the first test case, only (1,1) satisfies the conditions.

In the fourth test case,
(1,1),(2,1),(2,2),(3,1),(4,1),(5,1),(6,1),(6,2),(6,3),(7,1),(8,1),(9,1),(10,1),(10,2)
satisfy the conditions.
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 267
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given a string s , consisting of lowercase Latin letters and/or
question marks.

A tandem repeat is a string of an even length such that its first half is
equal to its second half.

A string a is a substring of a string b if a can be obtained from b by the
deletion of several (possibly, zero or all) characters from the beginning and
several (possibly, zero or all) characters from the end.

Your goal is to replace each question mark with some lowercase Latin letter in
such a way that the length of the longest substring that is a tandem repeat is
maximum possible.

Input

The first line contains a single integer t (1 \le t \le 1000 ) — the number of
testcases.

The only line of each testcase contains a string s (1 \le |s| \le 5000 ),
consisting only of lowercase Latin letters and/or question marks.

The total length of the strings over all testcases doesn't exceed 5000 .

Output

For each testcase, print a single integer — the maximum length of the longest
substring that is a tandem repeat after you replace each question mark in the
string with some lowercase Latin letter.

If it's impossible to make any tandem repeat substrings in the string, print 0
.

Example

Input

    4
    
    zaabaabz
    
    ?????
    
    code?????s
    
    codeforces

Output

    6
    4
    10
    0
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 124
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Given an integer n , you construct an array a of n integers, where a_i = i for
all integers i in the range [1, n] . An operation on this array is defined as
follows:

  * Select three distinct indices i , j , and k from the array, and let x = a_i , y = a_j , and z = a_k . 
  * Update the array as follows: a_i = \operatorname{lcm}(y, z) , a_j = \operatorname{lcm}(x, z) , and a_k = \operatorname{lcm}(x, y) , where \operatorname{lcm} represents the least common multiple. 

Your task is to provide a possible sequence of operations, containing at most
\lfloor \frac{n}{6} \rfloor + 5 operations such that after executing these
operations, if you create a set containing the greatest common divisors (GCDs)
of all subsequences with a size greater than 1 , then all numbers from 1 to n
should be present in this set.

After all the operations a_i \le 10^{18} should hold for all 1 \le i \le n .

We can show that an answer always exists.

Input

The first line contains one integer t (1 \le t \le 10^2 ) — the number of test
cases. The description of the test cases follows.

The first and only line of each test case contains an integer n (3 \leq n \leq
3 \cdot 10^{4} ) — the length of the array.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^{4} .

Output

The first line should contain an integer k (0 \leq k \leq \lfloor \frac{n}{6}
\rfloor + 5 ) — where k is the number of operations.

The next k lines should contain the description of each operation i.e. 3
integers i , j and k , where 1 \leq i, j, k \leq n and all must be distinct.

Example

Input

    3
    
    3
    
    4
    
    7

Output

    1
    1 2 3
    1
    1 3 4
    3
    3 5 7
    5 6 7
    2 3 4

Note

In the third test case, a = [1, 2, 3, 4, 5, 6, 7] .

First operation:

i = 3 , j = 5 , k = 7

x = 3 , y = 5 , z = 7 .

a = [1, 2, \operatorname{lcm}(y,z), 4, \operatorname{lcm}(x,z), 6,
\operatorname{lcm}(x,y)] = [1, 2, \color{red}{35}, 4, \color{red}{21}, 6,
\color{red}{15}] .

Second operation:

i = 5 , j = 6 , k = 7

x = 21 , y = 6 , z = 15 .

a = [1, 2, 35, 4, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z),
\operatorname{lcm}(x,y)] = [1, 2, 35, 4, \color{red}{30}, \color{red}{105},
\color{red}{42}] .

Third operation:

i = 2 , j = 3 , k = 4

x = 2 , y = 35 , z = 4 .

a = [1, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z),
\operatorname{lcm}(x,y), 30, 105, 42] = [1, \color{red}{140}, \color{red}{4},
\color{red}{70}, 30, 105, 42] .

Subsequences whose GCD equal to i is as follows:

\gcd(a_1, a_2) = \gcd(1, 140) = 1

\gcd(a_3, a_4) = \gcd(4, 70) = 2

\gcd(a_5, a_6, a_7) = \gcd(30, 105, 42) = 3

\gcd(a_2, a_3) = \gcd(140, 4) = 4

\gcd(a_2, a_4, a_5, a_6) = \gcd(140, 70, 30, 105) = 5

\gcd(a_5, a_7) = \gcd(30, 42) = 6

\gcd(a_2, a_4, a_6, a_7) = \gcd(140, 70, 105, 42) = 7
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 52
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Petya has an array a_i of n integers. His brother Vasya became envious and
decided to make his own array of n integers.

To do this, he found m integers b_i (m\ge n ), and now he wants to choose some
n integers of them and arrange them in a certain order to obtain an array c_i
of length n .

To avoid being similar to his brother, Vasya wants to make his array as
different as possible from Petya's array. Specifically, he wants the total
difference D = \sum_{i=1}^{n} |a_i - c_i| to be as large as possible.

Help Vasya find the maximum difference D he can obtain.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 100 ) — the number of test cases. This is followed by a
description of the test cases.

The first line of each test case contains two integers n and m (1\le n\le m\le
2 \cdot 10^5 ).

The second line of each test case contains n integers a_i (1\le a_i\le 10^9 ).
The third line of each test case contains m integers b_i (1\le b_i\le 10^9 ).

It is guaranteed that in a test, the sum of m over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the maximum total difference D
that can be obtained.

Example

Input

    9
    
    4 6
    
    6 1 2 4
    
    3 5 1 7 2 3
    
    3 4
    
    1 1 1
    
    1 1 1 1
    
    5 5
    
    1 2 3 4 5
    
    1 2 3 4 5
    
    2 6
    
    5 8
    
    8 7 5 8 2 10
    
    2 2
    
    4 1
    
    9 6
    
    4 6
    
    8 10 6 4
    
    3 10 6 1 8 9
    
    3 5
    
    6 5 2
    
    1 7 9 7 2
    
    5 5
    
    9 10 6 3 7
    
    5 9 2 3 9
    
    1 6
    
    3
    
    2 7 10 1 1 5

Output

    16
    0
    12
    11
    10
    23
    15
    25
    7
    
Note

In the first example, Vasya can, for example, create the array (1, 5, 7, 2) .
Then the total difference will be D = |6-1|+|1-5|+|2-7|+|4-2| = 5+4+5+2 = 16 .

In the second example, all the integers available to Vasya are equal to 1, so
he can only create the array (1, 1, 1) , for which the difference D = 0 .

In the third example, Vasya can, for example, create the array (5, 4, 3, 2, 1)
. Then the total difference will be D = |1-5|+|2-4|+|3-3|+|4-2|+|5-1| =
4+2+0+2+4 = 12 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 325
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: This is the easy version of the problem. The only difference between the two
versions is the constraint on t and n . You can make hacks only if both
versions of the problem are solved.

For a binary^\dagger pattern p and a binary string q , both of length m , q is
called p -good if for every i (1 \leq i \leq m ), there exist indices l and r
such that:

  * 1 \leq l \leq i \leq r \leq m , and 
  * p_i is a mode^\ddagger of the string q_l q_{l+1} \ldots q_{r} . 

For a pattern p , let f(p) be the minimum possible number of \mathtt{1} s in a
p -good binary string (of the same length as the pattern).

You are given a binary string s of size n . Find

In other words, you need to sum the values of f over all \frac{n(n+1)}{2}
substrings of s .

^\dagger A binary pattern is a string that only consists of characters
\mathtt{0} and \mathtt{1} .

^\ddagger Character c is a mode of string t of length m if the number of
occurrences of c in t is at least \lceil \frac{m}{2} \rceil . For example,
\mathtt{0} is a mode of \mathtt{010} , \mathtt{1} is not a mode of
\mathtt{010} , and both \mathtt{0} and \mathtt{1} are modes of \mathtt{011010}
.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 100
) — the length of the binary string s .

The second line of each test case contains a binary string s of length n
consisting of only characters \mathtt{0} and \mathtt{1} .

It is guaranteed that the sum of n^2 over all test cases does not exceed 10^4
.

Output

For each test case, output the sum of values of f over all substrings of s .

Example

Input

    4
    
    1
    
    1
    
    2
    
    10
    
    5
    
    00000
    
    20
    
    11110110000000111111

Output

    1
    2
    0
    346
    
Note

In the first test case, the only \mathtt{1} -good string is \mathtt{1} . Thus,
f(\mathtt{1})=1 .

In the second test case, f(\mathtt{10})=1 because \mathtt{01} is \mathtt{10}
-good, and \mathtt{00} is not \mathtt{10} -good. Thus, the answer is
f(\mathtt{1})+f(\mathtt{10})+f(\mathtt{0}) = 1 + 1 + 0 = 2 .

In the third test case, f equals to 0 for all 1 \leq i \leq j \leq 5 . Thus,
the answer is 0 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 222
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Given an integer r , find the number of lattice points that have a Euclidean
distance from (0, 0) greater than or equal to r but strictly less than r+1 .

A lattice point is a point with integer coordinates. The Euclidean distance
from (0, 0) to the point (x,y) is \sqrt{x^2 + y^2} .

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The only line of each test case contains a single integer r (1 \leq r \leq
10^5 ).

The sum of r over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer — the number of lattice points
that have an Euclidean distance d from (0, 0) such that r \leq d < r+1 .

Example

Input

    6
    
    1
    
    2
    
    3
    
    4
    
    5
    
    1984

Output

    8
    16
    20
    24
    40
    12504
    
Note

The points for the first three test cases are shown below.

![](https://espresso.codeforces.com/66c3f9d945c97358ed2f31c823ce9b70e46c6a4d.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 95
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: In the evenings during the hike, Kirill and Anton decided to take out an array
of integers a of length n from their backpack and play a game with it. The
rules are as follows:

  1. Kirill chooses from 2 to (n-2) numbers and encircles them in red.
  2. Anton encircles all the remaining numbers in blue.
  3. Kirill calculates the greatest common divisor ([GCD](https://en.wikipedia.org/wiki/Greatest_common_divisor)) of all the red numbers.
  4. Anton calculates the [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) of all the blue numbers and adds the number x to the result.
  5. If the GCD of all the red numbers is strictly greater than the sum of the bitwise AND of all the blue numbers and the number x , then Kirill wins; otherwise, Anton wins.

Help Kirill to beat Anton or tell if it's impossible.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 20\,000 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains two integers n and x (4\le n \le
4\cdot 10^5 , 0 \le x \le 4\cdot 10^5 ) — the number of integers and the
number x respectively.

The second line contains an array a of length n (1 \le a_i \le 4\cdot 10^5 ).

It is guaranteed that the sum of n for all test cases does not exceed 4\cdot
10^5 . It is also guaranteed that the sum of the maximum values of a_i for
each test case does not exceed 4\cdot 10^5 .

Output

For each test case, output "YES" on the first line if the condition can be
met, on the second line, output the number of chosen numbers by Kirill and the
numbers themselves in any order separated by a space, and on the third line,
output the size of the second set and the numbers in it.

Otherwise, output "NO".

You can output each letter in any case (lowercase or uppercase). For example,
the strings "yEs", "yes", "Yes", and "YES" will be accepted as a positive
answer.

Example

Input

    8
    
    4 1
    
    4 3 1 8
    
    4 1
    
    4 5 8 4
    
    5 0
    
    1 1 1 1 1
    
    5 2
    
    31 63 127 63 31
    
    4 1
    
    1 3 3 3
    
    8 3
    
    4 3 4 1 2 2 5 3
    
    4 2
    
    1 4 3 6
    
    8 48
    
    31 61 37 15 53 26 61 12

Output

    YES
    2 4 8
    2 3 1 
    YES
    2 4 4
    2 5 8 
    NO
    YES
    2 63 63
    3 31 127 31
    YES
    2 3 3
    2 1 3
    YES
    2 4 4
    6 3 1 2 2 5 3
    YES
    2 3 6
    2 1 4 
    YES
    2 61 61
    6 31 37 15 53 26 12
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 162
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The Chaya tribe believes that there are n signs of the apocalypse. Over time,
it has been found out that the i -th sign occurs every a_i years (in years a_i
, 2 \cdot a_i , 3 \cdot a_i , \dots ).

According to the legends, for the apocalypse to happen, the signs must occur
sequentially. That is, first they wait for the first sign to occur, then
strictly after it, the second sign will occur, and so on. That is, if the i
-th sign occurred in the year x , the tribe starts waiting for the occurrence
of the (i+1) -th sign, starting from the year x+1 .

In which year will the n -th sign occur and the apocalypse will happen?

Input

The first line of the input contains a single integer t (1 \le t \le 1000 ) —
the number of test cases. Then follow the descriptions of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 100
) — the number of signs.

The second line of each test case contains n integers a_1, a_2, a_3, \dots,
a_n (1 \le a_i \le 10^6 ) — the periodicities of the signs.

Output

For each test case, output a single integer — the year in which all n signs
will occur.

Example

Input

    4
    
    6
    
    3 2 4 5 9 18
    
    5
    
    1 2 3 4 5
    
    5
    
    1 1 1 1 1
    
    6
    
    50 30 711 200 503 1006

Output

    36
    5
    5
    2012
    
Note

In the first set of input data of the example:

  * The tribe will wait for the first sign in the 3 -rd year; 
  * the tribe will wait for the second sign in the 4 -th year (since year 2 have already passed); 
  * the tribe will wait for the third sign in the 8 -th year (since the second sign has already occurred in the 4 -th year); 
  * the tribe will wait for the fourth sign in the 10 -th year (since year 5 have already passed); 
  * the tribe will wait for the fifth sign in the 18 -th year (since year 9 have already passed); 
  * the tribe will wait for the sixth sign in the 36 -th year (since the fifth sign has already occurred in the 18 -th year).
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 162
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The Chaya tribe believes that there are n signs of the apocalypse. Over time,
it has been found out that the i -th sign occurs every a_i years (in years a_i
, 2 \cdot a_i , 3 \cdot a_i , \dots ).

According to the legends, for the apocalypse to happen, the signs must occur
sequentially. That is, first they wait for the first sign to occur, then
strictly after it, the second sign will occur, and so on. That is, if the i
-th sign occurred in the year x , the tribe starts waiting for the occurrence
of the (i+1) -th sign, starting from the year x+1 .

In which year will the n -th sign occur and the apocalypse will happen?

Input

The first line of the input contains a single integer t (1 \le t \le 1000 ) —
the number of test cases. Then follow the descriptions of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 100
) — the number of signs.

The second line of each test case contains n integers a_1, a_2, a_3, \dots,
a_n (1 \le a_i \le 10^6 ) — the periodicities of the signs.

Output

For each test case, output a single integer — the year in which all n signs
will occur.

Example

Input

    4
    
    6
    
    3 2 4 5 9 18
    
    5
    
    1 2 3 4 5
    
    5
    
    1 1 1 1 1
    
    6
    
    50 30 711 200 503 1006

Output

    36
    5
    5
    2012
    
Note

In the first set of input data of the example:

  * The tribe will wait for the first sign in the 3 -rd year; 
  * the tribe will wait for the second sign in the 4 -th year (since year 2 have already passed); 
  * the tribe will wait for the third sign in the 8 -th year (since the second sign has already occurred in the 4 -th year); 
  * the tribe will wait for the fourth sign in the 10 -th year (since year 5 have already passed); 
  * the tribe will wait for the fifth sign in the 18 -th year (since year 9 have already passed); 
  * the tribe will wait for the sixth sign in the 36 -th year (since the fifth sign has already occurred in the 18 -th year).
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 326
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There are 2n positive integers written on a whiteboard. Being bored, you
decided to play a one-player game with the numbers on the whiteboard.

You start with a score of 0 . You will increase your score by performing the
following move exactly n times:

  * Choose two integers x and y that are written on the whiteboard. 
  * Add \min(x,y) to your score. 
  * Erase x and y from the whiteboard. 

Note that after performing the move n times, there will be no more integers
written on the whiteboard.

Find the maximum final score you can achieve if you optimally perform the n
moves.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 5000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \leq n \leq 50
) — the number of integers written on the whiteboard is 2n .

The second line of each test case contains 2n integers a_1,a_2,\ldots,a_{2n}
(1 \leq a_i \leq 10^7 ) — the numbers written on the whiteboard.

Output

For each test case, output the maximum final score that you can achieve.

Example

Input

    3
    
    1
    
    2 3
    
    2
    
    1 1 2 1
    
    3
    
    1 1 1 1 1 1

Output

    2
    2
    3
    
Note

In the first test case, you can only make one move. You select x=2 and y=3 ,
and your score will be \min(x,y)=2 .

In the second test case, the following is a sequence of moves that achieves a
final score of 2 :

  * In the first move, select x=1 and y=1 . Then, add \min(x,y)=1 to the score. After erasing x and y , the integers left on the whiteboard are 1 and 2 . 
  * In the second move, select x=1 and y=2 . Then, add \min(x,y)=1 to the score. After removing x and y , no more integers will be left on the whiteboard. 

It can be proved that it is not possible to get a score greater than 2 .

In the third test case, you will perform the move thrice, adding 1 to the
score each time.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 105
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Alice and Bob are playing a game. They have an array a_1, a_2,\ldots,a_n . The
game consists of two steps:

  * First, Alice will remove at most k elements from the array. 
  * Second, Bob will multiply at most x elements of the array by -1 . 

Alice wants to maximize the sum of elements of the array while Bob wants to
minimize it. Find the sum of elements of the array after the game if both
players play optimally.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains three integers n , k , and x (1 \leq
n \leq 2 \cdot 10^5 , 1 \leq x,k \leq n ) — the number of elements in the
array, the limit on the number of elements of the array that Alice can remove,
and the limit on the number of elements of the array that Bob can multiply -1
to.

The second line of each test case contains n integers a_1, a_2,\ldots, a_n (1
\leq a_i \leq 1000 ) — the elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a single integer — the sum of elements of the array
after the game if both players play optimally.

Example

Input

    8
    
    1 1 1
    
    1
    
    4 1 1
    
    3 1 2 4
    
    6 6 3
    
    1 4 3 2 5 6
    
    6 6 1
    
    3 7 3 3 32 15
    
    8 5 3
    
    5 5 3 3 3 2 9 9
    
    10 6 4
    
    1 8 2 9 3 3 4 5 3 200
    
    2 2 1
    
    4 3
    
    2 1 2
    
    1 3

Output

    0
    2
    0
    3
    -5
    -9
    0
    -1
    
Note

In the first test case, it is optimal for Alice to remove the only element of
the array. Then, the sum of elements of the array is 0 after the game is over.

In the second test case, it is optimal for Alice to not remove any elements.
Bob will then multiply 4 by -1 . So the final sum of elements of the array is
3+1+2-4=2 .

In the fifth test case, it is optimal for Alice to remove 9, 9 . Bob will then
multiply 5, 5, 3 by -1 . So the final sum of elements of the array is
-5-5-3+3+3+2=-5 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 156
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: [Maître Gims - Est-ce que tu m'aimes ?](https://youtu.be/6TpyRE_juyA)

ඞ

As the CEO of a startup company, you want to reward each of your k employees
with a ticket to the upcoming concert. The tickets will be on sale for n days,
and by some time travelling, you have predicted that the price per ticket at
day i will be a_i . However, to prevent ticket hoarding, the concert
organizers have implemented the following measures:

  * A person may purchase no more than m tickets per day. 
  * If a person purchases x tickets on day i , all subsequent days (i.e. from day i+1 onwards) will have their prices per ticket increased by x . 

For example, if a = [1, 3, 8, 4, 5] and you purchase 2 tickets on day 1 , they
will cost 2 in total, and the prices from day 2 onwards will become [5, 10, 6,
7] . If you then purchase 3 more tickets on day 2 , they will cost in total an
additional 15 , and the prices from day 3 onwards will become [13, 9, 10] .

Find the minimum spending to purchase k tickets.

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains three integers n , m , and k (1 \le
n \le 3 \cdot 10^5, 1 \le m \le 10^9, 1 \le k \le \min(nm, 10^9) ) — the
number of sale days, the maximum amount of ticket purchasable each day, and
the number of tickets to be bought at the end.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the price per ticket for each of the upcoming n days.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, print one integer: the minimum amount of money needed to
purchase exactly k tickets.

Example

Input

    4
    
    4 2 3
    
    8 6 4 2
    
    4 2 8
    
    8 6 4 2
    
    5 100 1
    
    10000 1 100 10 1000
    
    6 3 9
    
    5 5 5 5 5 5

Output

    10
    64
    1
    72
    
Note

In the first test case, one optimal way to buy 3 tickets is as follows:

  * Buy 0 tickets on the first day. The prices per ticket for the remaining days are [6, 4, 2] . 
  * Buy 0 tickets on the second day. The prices per ticket for the remaining days are [4, 2] . 
  * Buy 1 ticket on the third day with cost 4 . The price per ticket for the remaining day is [3] . 
  * Buy 2 tickets on the fourth day with cost 6 . 

In the second test case, there is only one way to buy 8 tickets:

  * Buy 2 tickets on the first day with cost 16 . The prices per ticket for the remaining days are [8, 6, 4] . 
  * Buy 2 tickets on the second day with cost 16 . The prices per ticket for the remaining days are [8, 6] . 
  * Buy 2 tickets on the third day with cost 16 . The price per ticket for the remaining day is [8] . 
  * Buy 2 tickets on the fourth day with cost 16 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 60
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given two integers x and y . A sequence a of length n is called
modular if a_1=x , and for all 1 < i \le n the value of a_{i} is either
a_{i-1} + y or a_{i-1} \bmod y . Here x \bmod y denotes the remainder from
dividing x by y .

Determine if there exists a modular sequence of length n with the sum of its
elements equal to S , and if it exists, find any such sequence.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 2 \cdot 10^4 ). The description of the test cases
follows.

The first and only line of each test case contains four integers n , x , y ,
and s (1 \le n \le 2 \cdot 10^5 , 0 \le x \le 2 \cdot 10^5 , 1 \le y \le 2
\cdot 10^5 , 0 \le s \le 2 \cdot 10^5 ) — the length of the sequence, the
parameters x and y , and the required sum of the sequence elements.

The sum of n over all test cases does not exceed 2 \cdot 10^5 , and also the
sum of s over all test cases does not exceed 2 \cdot 10^5 .

Output

For each test case, if the desired sequence exists, output "Yes" on the first
line (without quotes). Then, on the second line, output n integers a_1, a_2,
\ldots, a_n separated by a space — the elements of the sequence a . If there
are multiple suitable sequences, output any of them.

If the sequence does not exist, output "No" on a single line.

You can output each letter in any case (lowercase or uppercase). For example,
the strings "yEs", "yes", "Yes", and "YES" will be accepted as a positive
answer.

Example

Input

    3
    
    5 8 3 28
    
    3 5 3 6
    
    9 1 5 79

Output

    YES
    8 11 2 2 5 
    NO
    NO
    
Note

In the first example, the sequence [8, 11, 2, 5, 2] satisfies the conditions.
Thus, a_1 = 8 = x , a_2 = 11 = a_1 + 3 , a_3 = 2 = a_2 \bmod 3 , a_4 = 5 = a_3
+ 3 , a_5 = 2 = a_4 \bmod 3 .

In the second example, the first element of the sequence should be equal to 5
, so the sequence [2, 2, 2] is not suitable.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 121
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: This is an interactive problem.

This is the game version of the problem. Note that the solution of this
problem may or may not share ideas with the solution of the solo version. You
can solve and get points for both versions independently.

Alice and Bob are playing a game. The game starts with a positive integer n ,
with players taking turns. On each turn of the game, the following sequence of
events takes place:

  * The player having the integer p breaks it into two integers p_{1} and p_{2} , where 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . 
  * If no such p_{1} , p_{2} exist, the player loses. 
  * Otherwise, the opponent does either select the integer p_{1} or p_{2} . 
  * The game continues with the selected integer. The opponent will try to break it. 

As Alice, your goal is to win. You can execute a maximum of 63 break
operations. You have the choice to play first or second. The system will act
for Bob.

Here \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \leq t \leq 1000 ) — the number of test cases.

The only line of each test case contains a single integer n (1 \leq n \leq
10^{18} ) — the number the game starts with.

Interaction

For each test case, the interaction begins by reading the integer n .

After reading n , print a single line containing either "first" or "second",
denoting what you want to play as (as first or second correspondingly).

On Alice's turn, you are required to print two positive integers, p_{1} and
p_{2} such that 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} =
p . Here, p equals one of the two integers printed by Bob in the previous
turn. If no turn has occurred previously, p is equal to n . If Alice cannot
perform a break operation, print "0 0" to receive a Wrong answer verdict.

On Bob's turn, you should read two integers, p_{1} and p_{2} such that 0 \lt
p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . Here, p equals
one of the two integers printed by Alice in the previous turn. If no turn has
occurred previously, p is equal to n . If Bob cannot perform a break operation
p_{1} = 0 and p_2 = 0 in which case you should proceed to the next test case.

If any break operation performed by Alice is invalid, the interactor prints
"-1 -1" and your code should promptly exit to receive a wrong answer verdict.

If Alice performs 63 turns and Bob can still execute a break operation on the
current integers, the interactor prints "-1 -1", and your code should promptly
exit to receive a wrong answer verdict.

After printing a query, do not forget to output the end of line and flush the
output. Otherwise, you will get Idleness limit exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

In this problem, hacks are disabled.

Example

Input

    4
    1
    
    0 0
    3
    
    0 0
    13
    
    3 4
    
    0 0
    777777770001
    
    0 0

Output

    second
    
    first
    2 1
    
    first
    10 7
    
    1 2
    
    first
    777777770000 1

Note

Explanation for the interaction.

Interactor / Bob| Alice| Explanation  
---|---|---  
4| | t   
1| | n for the first test case  
| second| Alice chooses to go second  
0 0| | Bob says he cannot break p = 1   
3| | n for the second test case  
| first| Alice chooses to go first  
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
13| | n for the third test case  
| first| Alice chooses to go first  
| 10 7| Alice breaks p = 13 into p_1 = 10 and p_2 = 7  
3 4| | Bob breaks p = 7 into p_1 = 3 and p_2 = 4   
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
777777770001| | n for the fourth test case  
| first| Alice chooses to go first  
| 777777770000 1| Alice breaks p = 777\,777\,770\,001 into p_1 =
777\,777\,770\,000 and p_2 = 1  
0 0| | Bob says he cannot perform break operation.  
  
This table is for explanation only and does not reflect the actual behavior of
the interactor.

Note that in the last test case Bob could choose p_1 and perform a break
operation but he gave up.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 278
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: In the hard version, 2 \leq \sum n \leq 10^5 and 1 \leq \sum m \leq 5 \times
10^{5}

After a worker's strike organized by the Dementors asking for equal rights,
the prison of Azkaban has suffered some damage. After settling the spirits,
the Ministry of Magic is looking to renovate the prison to ensure that the
Dementors are kept in check. The prison consists of n prison cells and m bi-
directional corridors. The i^{th} corridor is from cells u_i to v_i . A subset
of these cells S is called a complex if any cell in S is reachable from any
other cell in S . Formally, a subset of cells S is a complex if x and y are
reachable from each other for all x, y \in S , using only cells from S on the
way. The funding required for a complex S consisting of k cells is defined as
k^2 .

As part of your Intro to Magical Interior Design course at Hogwarts, you have
been tasked with designing the prison. The Ministry of Magic has asked that
you divide the prison into 2 complexes with \textbf{exactly one corridor}
connecting them, so that the Dementors can't organize union meetings. For this
purpose, you are allowed to build bi-directional corridors. The funding
required to build a corridor between any 2 cells is c .

Due to budget cuts and the ongoing fight against the Death Eaters, you must
find the \textbf{minimum total funding} required to divide the prison as per
the Ministry's requirements or -1 if no division is possible.

Note: The total funding is the sum of the funding required for the 2 complexes
and the corridors built. If after the division, the two complexes have x and y
cells respectively and you have built a total of a corridors, the total
funding will be x^2 + y^2 + c \times a . Note that x+y=n .

Input

The first line contains one integer t (1 \leq t \leq 10^5 ) — the number of
test cases. Then t test cases follow.

The first line of each test case consists of three integers n, m and c (2 \leq
n \leq 10^5 , 1 \leq m \leq 5 \times 10^{5} , 1 \leq c \leq 10^9 )

m lines follow, each consisting of 2 integers — u_i, v_i indicating a corridor
is present between cells u_i and v_i (1 \leq u_i, v_i \leq n , u_i \neq v_i )

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

It is guaranteed that the sum of m over all test cases does not exceed 5
\times 10^5 .

It is guaranteed that there exists at most one corridor between any two cells.

Output

Print the \textbf{minimum funding} required to divide the prison as per the
Ministry's requirements or -1 if no division is possible.

Example

Input

    4
    4 6 5
    4 3
    2 3
    2 4
    1 2
    4 1
    3 1
    6 6 2
    1 4
    2 5
    3 6
    1 5
    3 5
    6 5
    6 5 7
    1 4
    2 5
    3 6
    3 5
    6 5
    7 5 4
    1 4
    3 6
    3 5
    6 5
    2 7
    
Output

    -1
    20
    25
    33
    
Note

In the first test case of the sample input, there is no way to divide the
prison according to the Ministry's requirements.

In the second test case, consider the corridor between cells 1 and 5 as the
connection between the 2 complexes consisting of \\{2, 3, 5, 6\\} and \\{1,
4\\} cells respectively. There are no new corridors built. The total funding
is 4^2 + 2^2 = 20 . You can verify this is the minimum funding required.
![](https://espresso.codeforces.com/488c4eea08add11cc82237beac3677afcab875e3.png)

In the third test case, build a corridor between 2 and 4 . Consider the
corridor between cells 1 and 5 as the connection between the 2 complexes
consisting of \\{3, 5, 6\\} and \\{1, 2, 4\\} cells respectively. The total
funding is 3^2 + 3^2 + 7 \times 1 = 25 . You can verify this is the minimum
funding required.
![](https://espresso.codeforces.com/e7d162def53b600d35b9d046999c712212f7e0f6.png)

In the fourth test case, build a corridor between 2 and 4 and between 5 and 7
. Consider the corridor between cells 5 and 7 as the connection between the 2
complexes consisting of \\{1, 2, 4, 7\\} and \\{3, 5, 6\\} cells respectively.
The total funding is 4^2 + 3^2 + 4 \times 2 = 33 . You can verify this is the
minimum funding required.
![](https://espresso.codeforces.com/d7da43c68cf5654a9468a410eba14ccbc8ac8a15.png)

Note for all test cases that there may be multiple ways to get the same
funding but there is no other division which will have a more optimal minimum
funding.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 231
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Monocarp is opening his own IT company. He wants to hire n programmers and m
testers.

There are n+m+1 candidates, numbered from 1 to n+m+1 in chronological order of
their arriving time. The i -th candidate has programming skill a_i and testing
skill b_i (a person's programming skill is different from their testing
skill). The skill of the team is the sum of the programming skills of all
candidates hired as programmers, and the sum of the testing skills of all
candidates hired as testers.

When a candidate arrives to interview, Monocarp tries to assign them to the
most suitable position for them (if their programming skill is higher, then he
hires them as a programmer, otherwise as a tester). If all slots for that
position are filled, Monocarp assigns them to the other position.

Your task is, for each candidate, calculate the skill of the team if everyone
except them comes to interview. Note that it means that exactly n+m candidates
will arrive, so all n+m positions in the company will be filled.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

Each test case consists of three lines:

  * the first line contains two integers n and m (0 \le n, m \le 2 \cdot 10^5 ; 2 \le n + m + 1 \le 2 \cdot 10^5 ) — the number of programmers and the number of testers Monocarp wants to hire, respectively; 
  * the second line contains n + m + 1 integers a_1, a_2, \dots, a_{n+m+1} (1 \le a_i \le 10^9 ), where a_i is the programming skill of the i -th candidate; 
  * the third line contains n + m + 1 integers b_1, b_2, \dots, b_{n+m+1} (1 \le b_i \le 10^9 ; b_i \ne a_i ), where b_i is the testing skill of the i -th candidate. 

Additional constraint on the input: the sum of (n + m + 1) over all test cases
doesn't exceed 2 \cdot 10^5 .

Output

For each test case, print n + m + 1 integers, where the i -th integer should
be equal to the skill of the team if everyone except the i -th candidate comes
to interview.

Example

Input

    4
    
    1 0
    
    2 1
    
    1 2
    
    0 2
    
    4 5 5
    
    5 4 1
    
    1 2
    
    2 1 5 4
    
    5 2 3 1
    
    3 1
    
    4 3 3 4 1
    
    5 5 4 5 2

Output

    1 2 
    5 6 9 
    8 11 11 12 
    13 13 13 12 15 
    
Note

Let's consider the third test case of the example:

  * if the 1 -st candidate does not arrive, the 2 -nd candidate gets hired as a tester, the 3 -rd candidate gets hired as a programmer, the 4 -th candidate gets hired as a tester. The total skill of the team will be 2 + 5 + 1 = 8 ; 
  * if the 2 -nd candidate does not arrive, the 1 -st candidate gets hired as a tester, the 3 -rd candidate gets hired as a programmer, the 4 -th candidate gets hired as a tester. The total skill of the team will be 5 + 5 + 1 = 11 ; 
  * if the 3 -rd candidate does not arrive, the 1 -st candidate gets hired as a tester, the 2 -nd candidate gets hired as a tester, the 4 -th candidate gets hired as a programmer. The total skill of the team will be 5 + 2 + 4 = 11 ; 
  * if the 4 -th candidate does not arrive, the 1 -st candidate gets hired as a tester, the 2 -nd candidate gets hired as a tester, the 3 -rd candidate gets hired as a programmer. The total skill of the team will be 5 + 2 + 5 = 12 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 271
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The only difference between the versions of this problem is the maximum value
of n .

Professor Vector is preparing to teach her Arithmancy class. She needs to
prepare n distinct magic words for the class. Each magic word is a string
consisting of characters X and O. A spell is a string created by concatenating
two magic words together. The power of a spell is equal to the number of its
different non-empty substrings. For example, the power of the spell XOXO is
equal to 7, because it has 7 different substrings: X, O, XO, OX, XOX, OXO and
XOXO.

Each student will create their own spell by concatenating two magic words.
Since the students are not very good at magic yet, they will choose each of
the two words independently and uniformly at random from the n words provided
by Professor Vector. It is therefore also possible that the two words a
student chooses are the same. Each student will then compute the power of
their spell, and tell it to Professor Vector. In order to check their work,
and of course to impress the students, Professor Vector needs to find out
which two magic words and in which order were concatenated by each student.

Your program needs to perform the role of Professor Vector: first, create n
distinct magic words, and then handle multiple requests where it is given the
spell power and needs to determine the indices of the two magic words, in the
correct order, that were used to create the corresponding spell.

Interaction

This is an interactive problem.

First, your program should read a single integer n (1 \le n \le 30 ), the
number of magic words to prepare. Then, it should print n magic words it has
created, one per line. The magic words must be distinct, each magic word must
have at least 1 and at most 30\cdot n characters, and each character must be
either X or O. We will denote the i -th magic word you printed as w_i (1 \le i
\le n ).

Then, your program should read a single integer q (1 \le q \le 1000 ), the
number of students in the class. Then, it should repeat the following process
q times, one per student.

For the j -th student, it should first read a single integer p_j , the power
of their spell. It is guaranteed that this number is computed by choosing two
indices u_j and v_j independently and uniformly at random between 1 and n
inclusive, concatenating w_{u_j} and w_{v_j} , and finding the number of
different non-empty substrings of the resulting string. Then, your program
must print the numbers u_j and v_j , in this order (1 \le u_j, v_j \le n ).

Note that it is not enough to find any two magic words that concatenate into a
spell with the given power. You must find the exact words used by the student
in the exact order.

Remember to flush the output stream after printing all magic words and after
printing u_j and v_j for each student.

Example

Input

Copy

    2
    
    2
    15
    
    11

Output

Copy

    XOXO
    X
    
    1 1
    
    2 1
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 118
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given two integers n and k (k \le n ), where k is even.

A permutation of length n is an array consisting of n distinct integers from 1
to n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is
not a permutation (as 2 appears twice in the array) and [0,1,2] is also not a
permutation (as n=3 , but 3 is not present in the array).

Your task is to construct a k -level permutation of length n .

A permutation is called k -level if, among all the sums of continuous segments
of length k (of which there are exactly n - k + 1 ), any two sums differ by no
more than 1 .

More formally, to determine if the permutation p is k -level, first construct
an array s of length n - k + 1 , where s_i=\sum_{j=i}^{i+k-1} p_j , i.e., the
i -th element is equal to the sum of p_i, p_{i+1}, \dots, p_{i+k-1} .

A permutation is called k -level if \max(s) - \min(s) \le 1 .

Find any k -level permutation of length n .

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. This is followed by the description of the test
cases.

The first and only line of each test case contains two integers n and k (2 \le
k \le n \le 2 \cdot 10^5 , k is even), where n is the length of the desired
permutation.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output any k -level permutation of length n .

It is guaranteed that such a permutation always exists given the constraints.

Example

Input

    5
    
    2 2
    
    3 2
    
    10 4
    
    13 4
    
    7 4

Output

    2 1
    1 3 2
    1 8 4 10 2 7 5 9 3 6
    4 10 1 13 5 9 2 12 6 8 3 11 7
    1 6 3 7 2 5 4
    
Note

In the second test case of the example:

  * p_1 + p_2 = 3 + 1 = 4 ; 
  * p_2 + p_3 = 1 + 2 = 3 . 

The maximum among the sums is 4 , and the minimum is 3 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 105
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Alice and Bob are playing a game. They have an array a_1, a_2,\ldots,a_n . The
game consists of two steps:

  * First, Alice will remove at most k elements from the array. 
  * Second, Bob will multiply at most x elements of the array by -1 . 

Alice wants to maximize the sum of elements of the array while Bob wants to
minimize it. Find the sum of elements of the array after the game if both
players play optimally.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains three integers n , k , and x (1 \leq
n \leq 2 \cdot 10^5 , 1 \leq x,k \leq n ) — the number of elements in the
array, the limit on the number of elements of the array that Alice can remove,
and the limit on the number of elements of the array that Bob can multiply -1
to.

The second line of each test case contains n integers a_1, a_2,\ldots, a_n (1
\leq a_i \leq 1000 ) — the elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output a single integer — the sum of elements of the array
after the game if both players play optimally.

Example

Input

    8
    
    1 1 1
    
    1
    
    4 1 1
    
    3 1 2 4
    
    6 6 3
    
    1 4 3 2 5 6
    
    6 6 1
    
    3 7 3 3 32 15
    
    8 5 3
    
    5 5 3 3 3 2 9 9
    
    10 6 4
    
    1 8 2 9 3 3 4 5 3 200
    
    2 2 1
    
    4 3
    
    2 1 2
    
    1 3

Output

    0
    2
    0
    3
    -5
    -9
    0
    -1
    
Note

In the first test case, it is optimal for Alice to remove the only element of
the array. Then, the sum of elements of the array is 0 after the game is over.

In the second test case, it is optimal for Alice to not remove any elements.
Bob will then multiply 4 by -1 . So the final sum of elements of the array is
3+1+2-4=2 .

In the fifth test case, it is optimal for Alice to remove 9, 9 . Bob will then
multiply 5, 5, 3 by -1 . So the final sum of elements of the array is
-5-5-3+3+3+2=-5 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 57
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: In a well-known school, a physical education lesson took place. As usual,
everyone was lined up and asked to settle in "the first–k -th" position.

As is known, settling in "the first–k -th" position occurs as follows: the
first k people have numbers 1, 2, 3, \ldots, k , the next k - 2 people have
numbers k - 1, k - 2, \ldots, 2 , the next k people have numbers 1, 2, 3,
\ldots, k , and so on. Thus, the settling repeats every 2k - 2 positions.
Examples of settling are given in the "Note" section.

The boy Vasya constantly forgets everything. For example, he forgot the number
k described above. But he remembers the position he occupied in the line, as
well as the number he received during the settling. Help Vasya understand how
many natural numbers k fit under the given constraints.

Note that the settling exists if and only if k > 1 . In particular, this means
that the settling does not exist for k = 1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 100 ) — the number of test cases. This is followed by
the description of the test cases.

The only line of each test case contains two integers n and x (1 \le x < n \le
10^9 ) — Vasya's position in the line and the number Vasya received during the
settling.

Output

For each test case, output a single integer — the number of different k that
fit under the given constraints.

It can be proven that under the given constraints, the answer is finite.

Example

Input

    5
    
    10 2
    
    3 1
    
    76 4
    
    100 99
    
    1000000000 500000000

Output

    4
    1
    9
    0
    1
    
Note

In the first test case, k equals 2, 3, 5, 6 are suitable.

An example of settling for these k :

k / №| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10   
---|---|---|---|---|---|---|---|---|---|---  
2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2   
3 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 | 2   
5 | 1 | 2 | 3 | 4 | 5 | 4 | 3 | 2 | 1 | 2   
6 | 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 | 3 | 2   
  
In the second test case, k = 2 is suitable.
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 45
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Vladislav has n non-negative integers, and he wants to divide all of them into
several groups so that in any group, any pair of numbers does not have
matching bit values among bits from 1 -st to 31 -st bit (i.e., considering the
31 least significant bits of the binary representation).

For an integer k , let k_2(i) denote the i -th bit in its binary
representation (from right to left, indexing from 1). For example, if k=43 ,
since 43=101011_2 , then 43_2(1)=1 , 43_2(2)=1 , 43_2(3)=0 , 43_2(4)=1 ,
43_2(5)=0 , 43_2(6)=1 , 43_2(7)=0 , 43_2(8)=0, \dots, 43_2(31)=0 .

Formally, for any two numbers x and y in the same group, the condition x_2(i)
\neq y_2(i) must hold for all 1 \leq i < 32 .

What is the minimum number of groups Vlad needs to achieve his goal? Each
number must fall into exactly one group.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains a single integer n (1 \leq n \leq 2
\cdot 10^5 ) — the total number of integers.

The second line of each test case contains n given integers a_1, \ldots, a_n
(0 \leq a_j < 2^{31} ).

The sum of n over all test cases in a test does not exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of groups
required to satisfy the condition.

Example

Input

    9
    
    4
    
    1 4 3 4
    
    2
    
    0 2147483647
    
    5
    
    476319172 261956880 2136179468 1671164475 1885526767
    
    3
    
    1335890506 811593141 1128223362
    
    4
    
    688873446 627404104 1520079543 1458610201
    
    4
    
    61545621 2085938026 1269342732 1430258575
    
    4
    
    0 0 2147483647 2147483647
    
    3
    
    0 0 2147483647
    
    8
    
    1858058912 289424735 1858058912 2024818580 1858058912 289424735 122665067 289424735

Output

    4
    1
    3
    2
    2
    3
    2
    2
    4
    
Note

In the first test case, any two numbers have the same last 31 bits, so we need
to place each number in its own group.

In the second test case, a_1=0000000000000000000000000000000_2 ,
a_2=1111111111111111111111111111111_2 so they can be placed in the same group
because a_1(i) \ne a_2(i) for each i between 1 and 31 , inclusive.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 319
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: For an array b of m non-negative integers, define f(b) as the maximum value of \max\limits_{i = 1}^{m} (b_i | x) - \min\limits_{i = 1}^{m} (b_i | x) over all possible non-negative integers x , where | is [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR).

You are given integers n and q . You start with an empty array a . Process the
following q queries:

  * v : append v to the back of a and then output f(a) . It is guaranteed that 0 \leq v < n . 

The queries are given in a modified way.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 2 \cdot 10^5 ) — the number of test cases. The
description of the test cases follows.

The first line of each test case contains two integers n and q (1 \leq n \leq
2^{22} , 1 \leq q \leq 10^6 ) — the number of queries.

The second line of each test case contains q space-separated integers
e_1,e_2,\ldots,e_q (0 \leq e_i < n ) — the encrypted values of v .

Let \mathrm{last}_i equal the output of the (i-1) -th query for i\geq 2 and
\mathrm{last}_i=0 for i=1 . Then the value of v for the i -th query is (e_i +
\mathrm{last}_i ) modulo n .

It is guaranteed that the sum of n over all test cases does not exceed 2^{22}
and the sum of q over all test cases does not exceed 10^6 .

Output

For each test case, print q integers. The i -th integer is the output of the i
-th query.

Example

Input

    2
    
    5 2
    
    1 2
    
    7 4
    
    3 1 5 2

Output

    0 2
    0 2 3 5
    
Note

In the first test case, the final a=[1,2] . For i=1 , the answer is always 0 ,
irrespective of x . For i=2 , we can select x=5 .

In the second test case, the final a=[3,1,0,5] .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 123
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Given an array a of n elements, find the maximum value of the expression:

where i , j , k , and l are four distinct indices of the array a , with 1 \le
i, j, k, l \le n .

Here |x| denotes the absolute value of x .

Input

The first line contains one integer t (1 \le t \le 500 ) — the number of test
cases. The description of the test cases follows.

The first line of each test case contains a single integer n (4 \le n \le 100
) — the length of the given array.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n
(-10^6 \le a_i \le 10^6 ).

Output

For each test case, print a single integer — the maximum value.

Example

Input

    5
    
    4
    
    1 1 1 1
    
    5
    
    1 1 2 2 3
    
    8
    
    5 1 3 2 -3 -1 10 3
    
    4
    
    3 3 1 1
    
    4
    
    1 2 2 -1

Output

    0
    6
    38
    8
    8
    
Note

In the first test case, for any selection of i , j , k , l , the answer will
be 0 . For example, |a_1 - a_2| + |a_2 - a_3| + |a_3 - a_4| + |a_4 - a_1| = |1
- 1| + |1 - 1| + |1 - 1| + |1 - 1| = 0 + 0 + 0 + 0 = 0 .

In the second test case, for i = 1 , j = 3 , k = 2 , and l = 5 , the answer
will be 6 . |a_1 - a_3| + |a_3 - a_2| + |a_2 - a_5| + |a_5 - a_1| = |1 - 2| +
|2 - 1| + |1 - 3| + |3 - 1| = 1 + 1 + 2 + 2 = 6 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 318
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given a positive integer n .

Find a permutation^\dagger p of length n such that there do not exist two
distinct indices i and j (1 \leq i, j < n ; i \neq j ) such that p_i divides
p_j and p_{i+1} divides p_{j+1} .

Refer to the Notes section for some examples.

Under the constraints of this problem, it can be proven that at least one p
exists.

^\dagger A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (3 \leq n \leq
10^5 ) — the length of the permutation p .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output p_1, p_2, \ldots, p_n .

If there are multiple solutions, you may output any one of them.

Example

Input

    2
    
    4
    
    3

Output

    4 1 2 3
    1 2 3
    
Note

In the first test case, p=[4,1,2,3] is a valid permutation. However, the
permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and
j=3 . Then p_1=1 divides p_3=3 and p_2=2 divides p_4=4 . Note that the
permutation p=[3, 4, 2, 1] is also not a valid permutation as we can choose
i=3 and j=2 . Then p_3=2 divides p_2=4 and p_4=1 divides p_3=2 .

In the second test case, p=[1,2,3] is a valid permutation. In fact, all 6
permutations of length 3 are valid.
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 97
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The organizing committee plans to take the participants of the Olympiad on a
hike after the tour. Currently, the number of tents needed to be taken is
being calculated. It is known that each tent can accommodate up to 3 people.

Among the participants, there are a introverts, b extroverts, and c
universals:

  * Each introvert wants to live in a tent alone. Thus, a tent with an introvert must contain exactly one person — only the introvert himself. 
  * Each extrovert wants to live in a tent with two others. Thus, the tent with an extrovert must contain exactly three people. 
  * Each universal is fine with any option (living alone, with one other person, or with two others). 

The organizing committee respects the wishes of each participant very much, so
they want to fulfill all of them.

Tell us the minimum number of tents needed to be taken so that all
participants can be accommodated according to their preferences. If it is
impossible to accommodate the participants in a way that fulfills all the
wishes, output -1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
the descriptions of the test cases.

Each test case is described by a single line containing three integers a , b ,
c (0 \le a, b, c \le 10^9 ) — the number of introverts, extroverts, and
universals, respectively.

Output

For each test case, output a single integer — the minimum number of tents, or
-1 if it is impossible to accommodate the participants.

Example

Input

    10
    
    1 2 3
    
    1 4 1
    
    1 4 2
    
    1 1 1
    
    1 3 2
    
    19 7 18
    
    0 0 0
    
    7 0 0
    
    0 24 0
    
    1000000000 1000000000 1000000000

Output

    3
    -1
    3
    -1
    3
    28
    0
    7
    8
    1666666667
    
Note

In the first test case, 1 tent will be given to the introverts, 1 tent will be
shared by two extroverts and one universal, and the last tent will be shared
by two universals. In total, 3 tents are needed.

In the second test case, three extroverts will take 1 tent, and 1 tent will be
taken by an introvert. Then, one extrovert and one universal will be left.
This extrovert will not be able to live with two others.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 48
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: In order to test the hypothesis about the cats, the scientists must arrange
the cats in the boxes in a specific way. Of course, they would like to test
the hypothesis and publish a sensational article as quickly as possible,
because they are too engrossed in the next hypothesis about the phone's
battery charge.

Scientists have n boxes in which cats may or may not sit. Let the current
state of the boxes be denoted by the sequence b_1, \dots, b_n : b_i = 1 if
there is a cat in box number i , and b_i = 0 otherwise.

Fortunately, the unlimited production of cats has already been established, so
in one day, the scientists can perform one of the following operations:

  * Take a new cat and place it in a box (for some i such that b_i = 0 , assign b_i = 1 ). 
  * Remove a cat from a box and send it into retirement (for some i such that b_i = 1 , assign b_i = 0 ). 
  * Move a cat from one box to another (for some i, j such that b_i = 1, b_j = 0 , assign b_i = 0, b_j = 1 ). 

It has also been found that some boxes were immediately filled with cats.
Therefore, the scientists know the initial position of the cats in the boxes
s_1, \dots, s_n and the desired position f_1, \dots, f_n .

Due to the large amount of paperwork, the scientists do not have time to solve
this problem. Help them for the sake of science and indicate the minimum
number of days required to test the hypothesis.

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
descriptions of the test cases.

Each test case consists of three lines.

The first line of each test case contains a single integer n (1 \le n \le 10^5
) — the number of boxes.

The second line of each test case contains a string s of n characters, where
the i -th character is '1' if there is a cat in the i -th box and '0'
otherwise.

The third line of each test case contains a string f of n characters, where
the i -th character is '1' if there should be a cat in the i -th box and '0'
otherwise.

It is guaranteed that in a test the sum of n over all test cases does not
exceed 10^5 .

Output

For each test case, output a single integer on a separate line — the minimum
number of operations required to obtain the desired position from the initial
position. It can be shown that a solution always exists.

Example

Input

    6
    
    5
    
    10010
    
    00001
    
    1
    
    1
    
    1
    
    3
    
    000
    
    111
    
    4
    
    0101
    
    1010
    
    3
    
    100
    
    101
    
    8
    
    10011001
    
    11111110

Output

    2
    0
    3
    2
    1
    4
    
Note

In the first test case, you can first move the cat from the first box to the
fifth, and then remove the cat from the fourth box.

In the second test case, there is nothing to do — the only cat is already
sitting in the correct box.

In the third test case of input data, it takes three days to place a cat in
each box.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 282
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The only difference between the versions of this problem is the maximum value
of n .

Professor Vector is preparing to teach her Arithmancy class. She needs to
prepare n distinct magic words for the class. Each magic word is a string
consisting of characters X and O. A spell is a string created by concatenating
two magic words together. The power of a spell is equal to the number of its
different non-empty substrings. For example, the power of the spell XOXO is
equal to 7, because it has 7 different substrings: X, O, XO, OX, XOX, OXO and
XOXO.

Each student will create their own spell by concatenating two magic words.
Since the students are not very good at magic yet, they will choose each of
the two words independently and uniformly at random from the n words provided
by Professor Vector. It is therefore also possible that the two words a
student chooses are the same. Each student will then compute the power of
their spell, and tell it to Professor Vector. In order to check their work,
and of course to impress the students, Professor Vector needs to find out
which two magic words and in which order were concatenated by each student.

Your program needs to perform the role of Professor Vector: first, create n
distinct magic words, and then handle multiple requests where it is given the
spell power and needs to determine the indices of the two magic words, in the
correct order, that were used to create the corresponding spell.

Interaction

This is an interactive problem.

First, your program should read a single integer n (1 \le n \le 1000 ), the
number of magic words to prepare. Then, it should print n magic words it has
created, one per line. The magic words must be distinct, each magic word must
have at least 1 and at most 30\cdot n characters, and each character must be
either X or O. We will denote the i -th magic word you printed as w_i (1 \le i
\le n ).

Then, your program should read a single integer q (1 \le q \le 1000 ), the
number of students in the class. Then, it should repeat the following process
q times, one per student.

For the j -th student, it should first read a single integer p_j , the power
of their spell. It is guaranteed that this number is computed by choosing two
indices u_j and v_j independently and uniformly at random between 1 and n
inclusive, concatenating w_{u_j} and w_{v_j} , and finding the number of
different non-empty substrings of the resulting string. Then, your program
must print the numbers u_j and v_j , in this order (1 \le u_j, v_j \le n ).

Note that it is not enough to find any two magic words that concatenate into a
spell with the given power. You must find the exact words used by the student
in the exact order.

Remember to flush the output stream after printing all magic words and after
printing u_j and v_j for each student.

Example

Input

Copy

    2
    
    2
    15
    
    11

Output

Copy

    XOXO
    X
    
    1 1
    
    2 1
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 282
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The only difference between the versions of this problem is the maximum value
of n .

Professor Vector is preparing to teach her Arithmancy class. She needs to
prepare n distinct magic words for the class. Each magic word is a string
consisting of characters X and O. A spell is a string created by concatenating
two magic words together. The power of a spell is equal to the number of its
different non-empty substrings. For example, the power of the spell XOXO is
equal to 7, because it has 7 different substrings: X, O, XO, OX, XOX, OXO and
XOXO.

Each student will create their own spell by concatenating two magic words.
Since the students are not very good at magic yet, they will choose each of
the two words independently and uniformly at random from the n words provided
by Professor Vector. It is therefore also possible that the two words a
student chooses are the same. Each student will then compute the power of
their spell, and tell it to Professor Vector. In order to check their work,
and of course to impress the students, Professor Vector needs to find out
which two magic words and in which order were concatenated by each student.

Your program needs to perform the role of Professor Vector: first, create n
distinct magic words, and then handle multiple requests where it is given the
spell power and needs to determine the indices of the two magic words, in the
correct order, that were used to create the corresponding spell.

Interaction

This is an interactive problem.

First, your program should read a single integer n (1 \le n \le 1000 ), the
number of magic words to prepare. Then, it should print n magic words it has
created, one per line. The magic words must be distinct, each magic word must
have at least 1 and at most 30\cdot n characters, and each character must be
either X or O. We will denote the i -th magic word you printed as w_i (1 \le i
\le n ).

Then, your program should read a single integer q (1 \le q \le 1000 ), the
number of students in the class. Then, it should repeat the following process
q times, one per student.

For the j -th student, it should first read a single integer p_j , the power
of their spell. It is guaranteed that this number is computed by choosing two
indices u_j and v_j independently and uniformly at random between 1 and n
inclusive, concatenating w_{u_j} and w_{v_j} , and finding the number of
different non-empty substrings of the resulting string. Then, your program
must print the numbers u_j and v_j , in this order (1 \le u_j, v_j \le n ).

Note that it is not enough to find any two magic words that concatenate into a
spell with the given power. You must find the exact words used by the student
in the exact order.

Remember to flush the output stream after printing all magic words and after
printing u_j and v_j for each student.

Example

Input

Copy

    2
    
    2
    15
    
    11

Output

Copy

    XOXO
    X
    
    1 1
    
    2 1
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 291
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have an array a of n integers.

You perform exactly k operations on it. In one operation, you select any
contiguous subarray of the array a (possibly empty) and insert the sum of this
subarray anywhere in the array.

Your task is to find the maximum possible sum of the array after k such
operations.

As this number can be very large, output the answer modulo 10^9 + 7 .

Reminder: the remainder of a number x modulo p is the smallest non-negative y
such that there exists an integer q and x = p \cdot q + y .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains two integers n and k (1 \le n, k \le
2 \cdot 10^5 ) — the length of the array a and the number of operations,
respectively.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n
(-10^9 \le a_i \le 10^9 ) — the array a itself.

It is guaranteed that the sum of the values of n and k for all test cases does
not exceed 2 \cdot 10^5 .

Output

For each test, output a single integer — the maximum sum of the array that can
be obtained after k operations modulo 10^9 + 7 .

Example

Input

    12
    
    2 2
    
    -4 -7
    
    3 3
    
    2 2 8
    
    1 7
    
    7
    
    5 1
    
    4 -2 8 -12 9
    
    7 4
    
    8 14 -9 6 0 -1 3
    
    7 100
    
    5 3 -8 12 -5 -9 3
    
    6 1000
    
    -1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000
    
    2 1
    
    1000000000 8
    
    5 4
    
    0 0 0 0 0
    
    6 10
    
    48973 757292 58277 -38574 27475 999984
    
    7 1
    
    -1000 1000 -1000 1000 -1000 1000 -1000
    
    10 10050
    
    408293874 -3498597 7374783 295774930 -48574034 26623784 498754833 -294875830 283045804 85938045

Output

    999999996
    96
    896
    17
    351
    716455332
    42
    2
    0
    897909241
    0
    416571966
    
Note

In the first test case, it is advantageous to take an empty subarray of the
array twice and insert the sum of the empty subarray (zero) anywhere, then the
sum of the resulting array will be (-4) + (-7) + 0 + 0 = -11 , modulo 10^9 + 7
this is 999\,999\,996 .

In the second test case, it is advantageous to take the sum of the entire
array three times and place it anywhere in the array, then one of the possible
sequences of actions: [2, 2, 8 ] \rightarrow [2, 2, 8, 12 ] \rightarrow [2, 2,
8, 12, 24 ] \rightarrow [2, 2, 8, 12, 24, 48 ], the sum of the final array is
2 + 2 + 8 + 12 + 24 + 48 = 96 .

In the fourth test case, it is advantageous to take a subarray of the array
consisting of the first three numbers (i.e. consisting of the numbers 4, -2
and 8 ) and insert its sum at the beginning of the array, thereby obtaining
the array [10, 4, -2, 8, -12, 9 ], the sum of this array is 17 .

In the seventh test case, it will always be advantageous for us to take an
empty subarray of the array. In this case, the sum of the resulting array will
not differ from the sum of the original. The answer will be the sum of the
original array, taken modulo — 42 , because (-6 \cdot (10^9 + 7) + 42 =
-6\,000\,000\,000) .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 118
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given two integers n and k (k \le n ), where k is even.

A permutation of length n is an array consisting of n distinct integers from 1
to n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is
not a permutation (as 2 appears twice in the array) and [0,1,2] is also not a
permutation (as n=3 , but 3 is not present in the array).

Your task is to construct a k -level permutation of length n .

A permutation is called k -level if, among all the sums of continuous segments
of length k (of which there are exactly n - k + 1 ), any two sums differ by no
more than 1 .

More formally, to determine if the permutation p is k -level, first construct
an array s of length n - k + 1 , where s_i=\sum_{j=i}^{i+k-1} p_j , i.e., the
i -th element is equal to the sum of p_i, p_{i+1}, \dots, p_{i+k-1} .

A permutation is called k -level if \max(s) - \min(s) \le 1 .

Find any k -level permutation of length n .

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. This is followed by the description of the test
cases.

The first and only line of each test case contains two integers n and k (2 \le
k \le n \le 2 \cdot 10^5 , k is even), where n is the length of the desired
permutation.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output any k -level permutation of length n .

It is guaranteed that such a permutation always exists given the constraints.

Example

Input

    5
    
    2 2
    
    3 2
    
    10 4
    
    13 4
    
    7 4

Output

    2 1
    1 3 2
    1 8 4 10 2 7 5 9 3 6
    4 10 1 13 5 9 2 12 6 8 3 11 7
    1 6 3 7 2 5 4
    
Note

In the second test case of the example:

  * p_1 + p_2 = 3 + 1 = 4 ; 
  * p_2 + p_3 = 1 + 2 = 3 . 

The maximum among the sums is 4 , and the minimum is 3 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 291
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have an array a of n integers.

You perform exactly k operations on it. In one operation, you select any
contiguous subarray of the array a (possibly empty) and insert the sum of this
subarray anywhere in the array.

Your task is to find the maximum possible sum of the array after k such
operations.

As this number can be very large, output the answer modulo 10^9 + 7 .

Reminder: the remainder of a number x modulo p is the smallest non-negative y
such that there exists an integer q and x = p \cdot q + y .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains two integers n and k (1 \le n, k \le
2 \cdot 10^5 ) — the length of the array a and the number of operations,
respectively.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n
(-10^9 \le a_i \le 10^9 ) — the array a itself.

It is guaranteed that the sum of the values of n and k for all test cases does
not exceed 2 \cdot 10^5 .

Output

For each test, output a single integer — the maximum sum of the array that can
be obtained after k operations modulo 10^9 + 7 .

Example

Input

    12
    
    2 2
    
    -4 -7
    
    3 3
    
    2 2 8
    
    1 7
    
    7
    
    5 1
    
    4 -2 8 -12 9
    
    7 4
    
    8 14 -9 6 0 -1 3
    
    7 100
    
    5 3 -8 12 -5 -9 3
    
    6 1000
    
    -1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000
    
    2 1
    
    1000000000 8
    
    5 4
    
    0 0 0 0 0
    
    6 10
    
    48973 757292 58277 -38574 27475 999984
    
    7 1
    
    -1000 1000 -1000 1000 -1000 1000 -1000
    
    10 10050
    
    408293874 -3498597 7374783 295774930 -48574034 26623784 498754833 -294875830 283045804 85938045

Output

    999999996
    96
    896
    17
    351
    716455332
    42
    2
    0
    897909241
    0
    416571966
    
Note

In the first test case, it is advantageous to take an empty subarray of the
array twice and insert the sum of the empty subarray (zero) anywhere, then the
sum of the resulting array will be (-4) + (-7) + 0 + 0 = -11 , modulo 10^9 + 7
this is 999\,999\,996 .

In the second test case, it is advantageous to take the sum of the entire
array three times and place it anywhere in the array, then one of the possible
sequences of actions: [2, 2, 8 ] \rightarrow [2, 2, 8, 12 ] \rightarrow [2, 2,
8, 12, 24 ] \rightarrow [2, 2, 8, 12, 24, 48 ], the sum of the final array is
2 + 2 + 8 + 12 + 24 + 48 = 96 .

In the fourth test case, it is advantageous to take a subarray of the array
consisting of the first three numbers (i.e. consisting of the numbers 4, -2
and 8 ) and insert its sum at the beginning of the array, thereby obtaining
the array [10, 4, -2, 8, -12, 9 ], the sum of this array is 17 .

In the seventh test case, it will always be advantageous for us to take an
empty subarray of the array. In this case, the sum of the resulting array will
not differ from the sum of the original. The answer will be the sum of the
original array, taken modulo — 42 , because (-6 \cdot (10^9 + 7) + 42 =
-6\,000\,000\,000) .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 1
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given an array a of length 2n , consisting of each integer from 1 to n
exactly twice.

You are also given an integer k (1 \leq k \leq \lfloor \frac{n}{2} \rfloor ).

You need to find two arrays l and r each of length \mathbf{2k} such that:

  * l is a subset^\dagger of [a_1, a_2, \ldots a_n] 
  * r is a subset of [a_{n+1}, a_{n+2}, \ldots a_{2n}] 
  * [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of elements of l is equal to the bitwise XOR of elements of r ; in other words, l_1 \oplus l_2 \oplus \ldots \oplus l_{2k} = r_1 \oplus r_2 \oplus \ldots \oplus r_{2k} 

It can be proved that at least one pair of l and r always exists. If there are
multiple solutions, you may output any one of them.

^\dagger A sequence x is a subset of a sequence y if x can be obtained by
deleting several (possibly none or all) elements of y and rearranging the
elements in any order. For example, [3,1,2,1] , [1, 2, 3] , [1, 1] and [3, 2]
are subsets of [1, 1, 2, 3] but [4] and [2, 2] are not subsets of [1, 1, 2, 3]
.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 5000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains 2 integers n and k (2 \le n \le 5
\cdot 10^4 , 1 \leq k \leq \lfloor \frac{n}{2} \rfloor ).

The second line contains 2n integers a_1, a_2, \ldots, a_{2n} (1 \le a_i \le n
). It is guaranteed that every integer from 1 to n occurs exactly twice in a .

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^4 .

Output

For each test case, output two lines.

On the first line of output, output 2k integers l_1, l_2, \ldots, l_{2k} .

On the second line of output, output 2k integers r_1, r_2, \ldots r_{2k} .

If there are multiple solutions, you may output any one of them.

Example

Input

    4
    
    2 1
    
    1 2 2 1
    
    6 1
    
    6 4 2 1 2 3 1 6 3 5 5 4
    
    4 1
    
    1 2 3 4 1 2 3 4
    
    6 2
    
    5 1 3 3 5 1 2 6 4 6 4 2

Output

    2 1
    2 1
    6 4
    1 3
    1 2
    1 2
    5 1 3 3
    6 4 2 4
    
Note

In the first test case, we choose l=[2,1] and r=[2,1] . [2, 1] is a subset of
[a_1, a_2] and [2, 1] is a subset of [a_3, a_4] , and 2 \oplus 1 = 2 \oplus 1
= 3 .

In the second test case, 6 \oplus 4 = 1 \oplus 3 = 2 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 1
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given an array a of length 2n , consisting of each integer from 1 to n
exactly twice.

You are also given an integer k (1 \leq k \leq \lfloor \frac{n}{2} \rfloor ).

You need to find two arrays l and r each of length \mathbf{2k} such that:

  * l is a subset^\dagger of [a_1, a_2, \ldots a_n] 
  * r is a subset of [a_{n+1}, a_{n+2}, \ldots a_{2n}] 
  * [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of elements of l is equal to the bitwise XOR of elements of r ; in other words, l_1 \oplus l_2 \oplus \ldots \oplus l_{2k} = r_1 \oplus r_2 \oplus \ldots \oplus r_{2k} 

It can be proved that at least one pair of l and r always exists. If there are
multiple solutions, you may output any one of them.

^\dagger A sequence x is a subset of a sequence y if x can be obtained by
deleting several (possibly none or all) elements of y and rearranging the
elements in any order. For example, [3,1,2,1] , [1, 2, 3] , [1, 1] and [3, 2]
are subsets of [1, 1, 2, 3] but [4] and [2, 2] are not subsets of [1, 1, 2, 3]
.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 5000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains 2 integers n and k (2 \le n \le 5
\cdot 10^4 , 1 \leq k \leq \lfloor \frac{n}{2} \rfloor ).

The second line contains 2n integers a_1, a_2, \ldots, a_{2n} (1 \le a_i \le n
). It is guaranteed that every integer from 1 to n occurs exactly twice in a .

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^4 .

Output

For each test case, output two lines.

On the first line of output, output 2k integers l_1, l_2, \ldots, l_{2k} .

On the second line of output, output 2k integers r_1, r_2, \ldots r_{2k} .

If there are multiple solutions, you may output any one of them.

Example

Input

    4
    
    2 1
    
    1 2 2 1
    
    6 1
    
    6 4 2 1 2 3 1 6 3 5 5 4
    
    4 1
    
    1 2 3 4 1 2 3 4
    
    6 2
    
    5 1 3 3 5 1 2 6 4 6 4 2

Output

    2 1
    2 1
    6 4
    1 3
    1 2
    1 2
    5 1 3 3
    6 4 2 4
    
Note

In the first test case, we choose l=[2,1] and r=[2,1] . [2, 1] is a subset of
[a_1, a_2] and [2, 1] is a subset of [a_3, a_4] , and 2 \oplus 1 = 2 \oplus 1
= 3 .

In the second test case, 6 \oplus 4 = 1 \oplus 3 = 2 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 252
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are playing a computer game. The current level of this game can be modeled
as a straight line. Your character is in point 0 of this line. There are n
monsters trying to kill your character; the i -th monster has health equal to
a_i and is initially in the point x_i .

Every second, the following happens:

  * first, you fire up to k bullets at monsters. Each bullet targets exactly one monster and decreases its health by 1 . For each bullet, you choose its target arbitrary (for example, you can fire all bullets at one monster, fire all bullets at different monsters, or choose any other combination). Any monster can be targeted by a bullet, regardless of its position and any other factors; 
  * then, all alive monsters with health 0 or less die; 
  * then, all alive monsters move 1 point closer to you (monsters to the left of you increase their coordinates by 1 , monsters to the right of you decrease their coordinates by 1 ). If any monster reaches your character (moves to the point 0 ), you lose. 

Can you survive and kill all n monsters without letting any of them reach your
character?

Input

The first line of the input contains one integer t (1 \le t \le 3 \cdot 10^4 )
— the number of test cases.

Each test case consists of three lines:

  * the first line contains two integers n and k (1 \le n \le 3 \cdot 10^5 ; 1 \le k \le 2 \cdot 10^9 ); 
  * the second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^9 ); 
  * the third line contains n integers x_1, x_2, \dots, x_n (-n \le x_1 < x_2 < x_3 < \dots < x_n \le n ; x_i \ne 0 ). 

Additional constraint on the input: the sum of n over all test cases does not
exceed 3 \cdot 10^5 .

Output

For each test case, print YES if you can kill all n monsters before they reach
your character, or NO otherwise.

You can output each letter of the answer in any case (upper or lower). For
example, the strings yEs, yes, Yes, and YES will all be recognized as positive
responses.

Example

Input

    5
    
    3 2
    
    1 2 3
    
    -1 2 3
    
    2 1
    
    1 1
    
    -1 1
    
    4 10
    
    3 4 2 5
    
    -3 -2 1 3
    
    5 3
    
    2 1 3 2 5
    
    -3 -2 3 4 5
    
    2 1
    
    1 2
    
    1 2

Output

    YES
    NO
    YES
    YES
    NO
    
Note

In the first example, you can act as follows:

  * during the 1 -st second, fire 1 bullet at the 1 -st monster and 1 bullet at the 3 -rd monster. Then the 1 -st monster dies, the 2 -nd and the 3 -rd monster move closer; 
  * during the 2 -nd second, fire 2 bullets at the 2 -nd monster. Then the 2 -nd monster dies, the 3 -rd monster moves closer; 
  * during the 3 -rd second, fire 2 bullets at the 3 -rd monster. Then the 3 -rd monster dies. 

In the second example, you can fire only 1 bullet, so you can kill only one of
the two monsters during the 1 -st second. Then, the remaining monster moves
closer and kills your character.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 6
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There are n islands, numbered 1, 2, \ldots, n . Initially, every pair of
islands is connected by a bridge. Hence, there are a total of \frac{n (n -
1)}{2} bridges.

Everule lives on island 1 and enjoys visiting the other islands using bridges.
Dominater has the power to destroy at most k bridges to minimize the number of
islands that Everule can reach using (possibly multiple) bridges.

Find the minimum number of islands (including island 1 ) that Everule can
visit if Dominater destroys bridges optimally.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first and only line of each test case contains two integers n and k (1 \le
n \le 100 , 0 \le k \le \frac{n \cdot (n - 1)}{2} ).

Output

For each test case, output the minimum number of islands that Everule can
visit if Dominater destroys bridges optimally.

Example

Input

    6
    
    2 0
    
    2 1
    
    4 1
    
    5 10
    
    5 3
    
    4 4

Output

    2
    1
    4
    1
    5
    1
    
Note

In the first test case, since no bridges can be destroyed, all the islands
will be reachable.

In the second test case, you can destroy the bridge between islands 1 and 2 .
Everule will not be able to visit island 2 but can still visit island 1 .
Therefore, the total number of islands that Everule can visit is 1 .

In the third test case, Everule always has a way of reaching all islands
despite what Dominater does. For example, if Dominater destroyed the bridge
between islands 1 and 2 , Everule can still visit island 2 by traveling by 1
\to 3 \to 2 as the bridges between 1 and 3 , and between 3 and 2 are not
destroyed.

In the fourth test case, you can destroy all bridges since k = \frac{n \cdot
(n - 1)}{2} . Everule will be only able to visit 1 island (island 1 ).
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 258
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given a positive integer x . Find any array of integers a_0, a_1,
\ldots, a_{n-1} for which the following holds:

  * 1 \le n \le 32 , 
  * a_i is 1 , 0 , or -1 for all 0 \le i \le n - 1 , 
  * x = \displaystyle{\sum_{i=0}^{n - 1}{a_i \cdot 2^i}} , 
  * There does not exist an index 0 \le i \le n - 2 such that both a_{i} \neq 0 and a_{i + 1} \neq 0 . 

It can be proven that under the constraints of the problem, a valid array
always exists.

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \le t \le 10^4 ) — the number of test cases. The
description of the test cases follows.

The only line of each test case contains a single positive integer x (1 \le x
< 2^{30} ).

Output

For each test case, output two lines.

On the first line, output an integer n (1 \le n \le 32 ) — the length of the
array a_0, a_1, \ldots, a_{n-1} .

On the second line, output the array a_0, a_1, \ldots, a_{n-1} .

If there are multiple valid arrays, you can output any of them.

Example

Input

    7
    
    1
    
    14
    
    24
    
    15
    
    27
    
    11
    
    19

Output

    1
    1
    5
    0 -1 0 0 1
    6
    0 0 0 -1 0 1
    5
    -1 0 0 0 1
    6
    -1 0 -1 0 0 1
    5
    -1 0 -1 0 1
    5
    -1 0 1 0 1

Note

In the first test case, one valid array is [1] , since (1) \cdot 2^0 = 1 .

In the second test case, one possible valid array is [0,-1,0,0,1] , since (0)
\cdot 2^0 + (-1) \cdot 2^1 + (0) \cdot 2^2 + (0) \cdot 2^3 + (1) \cdot 2^4 =
-2 + 16 = 14 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 86
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: [Proof Geometric Construction Can Solve All Love Affairs -
manbo-p](https://soundcloud.com/alice-law-314125270/manbo-p-proof-geometric-
construction-can-solve-all-love-affairs)

⠀

This is the hard version of the problem. The only difference between the two
versions is the constraint on y . In this version 0 \leq y \leq n - x . You
can make hacks only if both versions are solved.

Bessie has received a birthday cake from her best friend Elsie, and it came in
the form of a regular polygon with n sides. The vertices of the cake are
numbered from 1 to n clockwise. You and Bessie are going to choose some of
those vertices to cut non-intersecting diagonals into the cake. In other
words, the endpoints of the diagonals must be part of the chosen vertices.

Bessie would only like to give out pieces of cake which result in a triangle
to keep consistency. The size of the pieces doesn't matter, and the whole cake
does not have to be separated into all triangles (other shapes are allowed in
the cake, but those will not be counted).

Bessie has already chosen x of those vertices that can be used to form
diagonals. She wants you to choose no more than y other vertices such that the
number of triangular pieces of cake she can give out is maximized.

What is the maximum number of triangular pieces of cake Bessie can give out?

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case consists of three integers, n , x , and y (4
\leq n \leq 10^9 , 2 \leq x \leq \min(n, 2 \cdot 10^5) , 0 \leq y \leq n - x )
— the number of sides of the polygon, number of vertices Bessie has chosen,
and the maximum number of other vertices you can choose.

The second line consists of x distinct integers from 1 to n , representing the
vertices Bessie has chosen.

It is guaranteed the sum of x over all test cases does not exceed 2 \cdot 10^5
.

Output

For each test case, output a single integer: the maximum number of non-
intersecting triangular pieces of cake she can give out.

Example

Input

    3
    
    8 4 2
    
    1 6 2 5
    
    7 3 1
    
    6 4 3
    
    4 2 2
    
    1 3

Output

    6
    5
    2
    
Note

In test cases 1 , 2 and 3 , you can get 6 , 5 and 2 non-intersecting
triangular pieces of cake, respectively. A possible construction is shown in
the following pictures:

The green dots represent vertices that Bessie chose, the yellow dots represent
vertices that you chose, the blue lines represent diagonals that are drawn,
and the red numbers represent triangles that are counted.

![](https://espresso.codeforces.com/13b28beb7f5f0d100798f357f58c804c5314c869.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 358
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Sasha gave Anna a list a of n integers for Valentine's Day. Anna doesn't need
this list, so she suggests destroying it by playing a game.

Players take turns. Sasha is a gentleman, so he gives Anna the right to make
the first move.

  * On her turn, Anna must choose an element a_i from the list and reverse the sequence of its digits. For example, if Anna chose the element with a value of 42 , it would become 24 ; if Anna chose the element with a value of 1580 , it would become 851 . Note that leading zeros are removed. After such a turn, the number of elements in the list does not change.
  * On his turn, Sasha must extract two elements a_i and a_j (i \ne j ) from the list, concatenate them in any order and insert the result back into the list. For example, if Sasha chose the elements equal to 2007 and 19 , he would remove these two elements from the list and add the integer 200719 or 192007 . After such a turn, the number of elements in the list decreases by 1 .

Players can't skip turns. The game ends when Sasha can't make a move, i.e.
after Anna's move there is exactly one number left in the list. If this
integer is not less than 10^m (i.e., \ge 10^m ), Sasha wins. Otherwise, Anna
wins.

It can be shown that the game will always end. Determine who will win if both
players play optimally.

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

Then follows the description of the test cases.

The first line of each test case contains integers n , m (1 \le n \le 2 \cdot
10^5 , 0 \le m \le 2 \cdot 10^6 ) — the number of integers in the list and the
parameter determining when Sasha wins.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the list that Sasha gave to Anna.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output:

  * "Sasha", if Sasha wins with optimal play; 
  * "Anna", if Anna wins with optimal play. 

Example

Input

    9
    
    2 2
    
    14 2
    
    3 5
    
    9 56 1
    
    4 10
    
    1 2007 800 1580
    
    4 5
    
    5000 123 30 4
    
    10 10
    
    6 4 6 2 3 1 10 9 10 7
    
    1 1
    
    6
    
    1 1
    
    10
    
    8 9
    
    1 2 9 10 10 2 10 2
    
    4 5
    
    10 10 10 10

Output

    Sasha
    Anna
    Anna
    Sasha
    Sasha
    Anna
    Anna
    Anna
    Sasha
    
Note

Consider the first test case.

Anna can reverse the integer 2 , then Sasha can concatenate the integers 2 and
14 , obtaining the integer 214 , which is greater than 10^2 = 100 . If Anna
had reversed the integer 14 , Sasha would have concatenated the integers 41
and 2 , obtaining the integer 412 , which is greater than 10^2 = 100 . Anna
has no other possible moves, so she loses.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 251
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There is a rectangular sheet of paper with initial height n and width m . Let
the current height and width be h and w respectively. We introduce a xy
-coordinate system so that the four corners of the sheet are (0, 0), (w, 0),
(0, h) , and (w, h) . The sheet can then be cut along the lines x =
1,2,\ldots,w-1 and the lines y = 1,2,\ldots,h-1 . In each step, the paper is
cut randomly along any one of these h+w-2 lines. After each vertical and
horizontal cut, the right and bottom piece of paper respectively are
discarded.

Find the expected number of steps required to make the area of the sheet of
paper strictly less than k . It can be shown that this answer can always be
expressed as a fraction \dfrac{p}{q} where p and q are coprime integers.
Calculate p\cdot q^{-1} \bmod (10^9+7) .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 57000 ). Description of the test cases follows.

The first line of each test case contains 3 integers n , m , and k (1 \le n, m
\le 10^6 , 2 \le k \le 10^{12} ).

It is guaranteed that the sum of n and the sum of m over all test cases do not
exceed 10^6 .

Output

For each test case, print one integer — the answer to the problem.

Example

Input

    4
    
    2 4 10
    
    2 4 8
    
    2 4 2
    
    2 4 6

Output

    0
    1
    833333342
    250000003
    
Note

For the first test case, the area is already less than 10 so no cuts are
required.

For the second test case, the area is exactly 8 so any one of the 4 possible
cuts would make the area strictly less than 8 .

For the third test case, the final answer is \frac{17}{6} = 833\,333\,342\bmod
(10^9+7) .

For the fourth test case, the final answer is \frac{5}{4} = 250\,000\,003\bmod
(10^9+7) .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 46
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Vladislav has a string of length 5 , whose characters are each either
\texttt{A} or \texttt{B} .

Which letter appears most frequently: \texttt{A} or \texttt{B} ?

Input

The first line of the input contains an integer t (1 \leq t \leq 32 ) — the
number of test cases.

The only line of each test case contains a string of length 5 consisting of
letters \texttt{A} and \texttt{B} .

All t strings in a test are different (distinct).

Output

For each test case, output one letter (\texttt{A} or \texttt{B} ) denoting the
character that appears most frequently in the string.

Example

Input

    8
    
    ABABB
    
    ABABA
    
    BBBAB
    
    AAAAA
    
    BBBBB
    
    BABAA
    
    AAAAB
    
    BAAAA

Output

    B
    A
    B
    A
    B
    A
    A
    A
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 337
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There are balls of n different colors; the number of balls of the i -th color
is a_i .

The balls can be combined into groups. Each group should contain at most 2
balls, and no more than 1 ball of each color.

Consider all 2^n sets of colors. For a set of colors, let's denote its value
as the minimum number of groups the balls of those colors can be distributed
into. For example, if there are three colors with 3 , 1 and 7 balls
respectively, they can be combined into 7 groups (and not less than 7 ), so
the value of that set of colors is 7 .

Your task is to calculate the sum of values over all 2^n possible sets of
colors. Since the answer may be too large, print it modulo 998\,244\,353 .

Input

The first line contains a single integer n (1 \le n \le 5000 ) — the number of
colors.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 5000 )
— the number of balls of the i -th color.

Additional constraint on input: the total number of balls doesn't exceed 5000
.

Output

Print a single integer — the sum of values of all 2^n sets of colors, taken
modulo 998\,244\,353 .

Examples

Input

    3
    
    1 1 2

Output

    11
    
Input

    1
    
    5

Output

    5
    
Input

    4
    
    1 3 3 7

Output

    76
    
Note

Consider the first example. There are 8 sets of colors:

  * for the empty set, its value is 0 ; 
  * for the set \\{1\\} , its value is 1 ; 
  * for the set \\{2\\} , its value is 1 ; 
  * for the set \\{3\\} , its value is 2 ; 
  * for the set \\{1,2\\} , its value is 1 ; 
  * for the set \\{1,3\\} , its value is 2 ; 
  * for the set \\{2,3\\} , its value is 2 ; 
  * for the set \\{1,2,3\\} , its value is 2 . 

So, the sum of values over all 2^n sets of colors is 11 .
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 358
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Sasha gave Anna a list a of n integers for Valentine's Day. Anna doesn't need
this list, so she suggests destroying it by playing a game.

Players take turns. Sasha is a gentleman, so he gives Anna the right to make
the first move.

  * On her turn, Anna must choose an element a_i from the list and reverse the sequence of its digits. For example, if Anna chose the element with a value of 42 , it would become 24 ; if Anna chose the element with a value of 1580 , it would become 851 . Note that leading zeros are removed. After such a turn, the number of elements in the list does not change.
  * On his turn, Sasha must extract two elements a_i and a_j (i \ne j ) from the list, concatenate them in any order and insert the result back into the list. For example, if Sasha chose the elements equal to 2007 and 19 , he would remove these two elements from the list and add the integer 200719 or 192007 . After such a turn, the number of elements in the list decreases by 1 .

Players can't skip turns. The game ends when Sasha can't make a move, i.e.
after Anna's move there is exactly one number left in the list. If this
integer is not less than 10^m (i.e., \ge 10^m ), Sasha wins. Otherwise, Anna
wins.

It can be shown that the game will always end. Determine who will win if both
players play optimally.

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

Then follows the description of the test cases.

The first line of each test case contains integers n , m (1 \le n \le 2 \cdot
10^5 , 0 \le m \le 2 \cdot 10^6 ) — the number of integers in the list and the
parameter determining when Sasha wins.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the list that Sasha gave to Anna.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output:

  * "Sasha", if Sasha wins with optimal play; 
  * "Anna", if Anna wins with optimal play. 

Example

Input

    9
    
    2 2
    
    14 2
    
    3 5
    
    9 56 1
    
    4 10
    
    1 2007 800 1580
    
    4 5
    
    5000 123 30 4
    
    10 10
    
    6 4 6 2 3 1 10 9 10 7
    
    1 1
    
    6
    
    1 1
    
    10
    
    8 9
    
    1 2 9 10 10 2 10 2
    
    4 5
    
    10 10 10 10

Output

    Sasha
    Anna
    Anna
    Sasha
    Sasha
    Anna
    Anna
    Anna
    Sasha
    
Note

Consider the first test case.

Anna can reverse the integer 2 , then Sasha can concatenate the integers 2 and
14 , obtaining the integer 214 , which is greater than 10^2 = 100 . If Anna
had reversed the integer 14 , Sasha would have concatenated the integers 41
and 2 , obtaining the integer 412 , which is greater than 10^2 = 100 . Anna
has no other possible moves, so she loses.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 71
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Let's imagine the surface of Mars as an infinite coordinate plane. Initially,
the rover Perseverance-2 and the helicopter Ingenuity-2 are located at the
point with coordinates (0, 0) . A set of instructions s consisting of n
instructions of the following types was specially developed for them:

  * N: move one meter north (from point (x, y) to (x, y + 1) ); 
  * S: move one meter south (from point (x, y) to (x, y - 1) ); 
  * E: move one meter east (from point (x, y) to (x + 1, y) ); 
  * W: move one meter west (from point (x, y) to (x - 1, y) ). 

Each instruction must be executed either by the rover or by the helicopter.
Moreover, each device must execute at least one instruction. Your task is to
distribute the instructions in such a way that after executing all n
instructions, the helicopter and the rover end up at the same point, or
determine that this is impossible.

Input

The first line of input contains t (1 \leq t \leq 10^4 ) — the number of test
cases.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of instructions.

The second line of each test case contains a string s of length n consisting
of the characters 'N', 'S', 'E', 'W' — the sequence of instructions.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10 ^ 5 .

Output

For each test case, if the required distribution of instructions exists,
output a string p of length n consisting of the characters 'R', 'H'. If the i
-th operation should be executed by the rover, then p_i=\text{R} , if the i
-th operation should be executed by the helicopter, then p_i=\text{H} . If
there are multiple solutions, output any of them.

Otherwise, output NO.

Example

Input

    10
    
    6
    
    NENSNE
    
    3
    
    WWW
    
    6
    
    NESSWS
    
    2
    
    SN
    
    2
    
    WE
    
    4
    
    SSNN
    
    4
    
    WESN
    
    2
    
    SS
    
    4
    
    EWNN
    
    4
    
    WEWE

Output

    RRHRRH
    NO
    HRRHRH
    NO
    NO
    RHRH
    RRHH
    RH
    RRRH
    RRHH

Note

Let's consider the first example: the string S = \texttt{NENSNE} . One of the
possible solutions, shown in the figure below, is p = \texttt{RRHRRH} , using
which both the rover and the helicopter will end up one meter north and one
meter east.

![](https://espresso.codeforces.com/bb4cbb5897ef7ab4afcc336d45457d0bb9d07c2c.png)

For WWW, the solution is impossible.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 295
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given an array a of n integers.

The median of an array q_1, q_2, \ldots, q_k is the number p_{\lceil
\frac{k}{2} \rceil} , where p is the array q sorted in non-decreasing order.
For example, the median of the array [9, 5, 1, 2, 6] is 5 , as in the sorted
array [1, 2, 5, 6, 9] , the number at index \lceil \frac{5}{2} \rceil = 3 is 5
, and the median of the array [9, 2, 8, 3] is 3 , as in the sorted array [2,
3, 8, 9] , the number at index \lceil \frac{4}{2} \rceil = 2 is 3 .

You are allowed to choose an integer i (1 \le i \le n ) and increase a_i by 1
in one operation.

Your task is to find the minimum number of operations required to increase the
median of the array.

Note that the array a may not necessarily contain distinct numbers.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the array a .

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of operations
required to increase the median of the array.

Example

Input

    8
    
    3
    
    2 2 8
    
    4
    
    7 3 3 1
    
    1
    
    1000000000
    
    5
    
    5 5 5 4 5
    
    6
    
    2 1 2 3 1 4
    
    2
    
    1 2
    
    2
    
    1 1
    
    4
    
    5 5 5 5

Output

    1
    2
    1
    3
    2
    1
    2
    3
    
Note

In the first test case, you can apply one operation to the first number and
obtain the array [3, 2, 8] , the median of this array is 3 , as it is the
number at index \lceil \frac{3}{2} \rceil = 2 in the non-decreasing sorted
array [2, 3, 8] . The median of the original array [2, 2, 8] is 2 , as it is
the number at index \lceil \frac{3}{2} \rceil = 2 in the non-decreasing sorted
array [2, 2, 8] . Thus, the median increased (3 > 2 ) in just one operation.

In the fourth test case, you can apply one operation to each of the numbers at
indices 1, 2, 3 and obtain the array [6, 6, 6, 4, 5] , the median of this
array is 6 , as it is the number at index \lceil \frac{5}{2} \rceil = 3 in the
non-decreasing sorted array [4, 5, 6, 6, 6] . The median of the original array
[5, 5, 5, 4, 5] is 5 , as it is the number at index \lceil \frac{5}{2} \rceil
= 2 in the non-decreasing sorted array [4, 5, 5, 5, 5] . Thus, the median
increased (6 > 5 ) in three operations. It can be shown that this is the
minimum possible number of operations.

In the fifth test case, you can apply one operation to each of the numbers at
indices 1, 3 and obtain the array [3, 1, 3, 3, 1, 4] , the median of this
array is 3 , as it is the number at index \lceil \frac{6}{2} \rceil = 3 in the
non-decreasing sorted array [1, 1, 3, 3, 3, 4] . The median of the original
array [2, 1, 2, 3, 1, 4] is 2 , as it is the number at index \lceil
\frac{6}{2} \rceil = 3 in the non-decreasing sorted array [1, 1, 2, 2, 3, 4] .
Thus, the median increased (3 > 2 ) in two operations. It can be shown that
this is the minimum possible number of operations.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 234
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 71
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Let's imagine the surface of Mars as an infinite coordinate plane. Initially,
the rover Perseverance-2 and the helicopter Ingenuity-2 are located at the
point with coordinates (0, 0) . A set of instructions s consisting of n
instructions of the following types was specially developed for them:

  * N: move one meter north (from point (x, y) to (x, y + 1) ); 
  * S: move one meter south (from point (x, y) to (x, y - 1) ); 
  * E: move one meter east (from point (x, y) to (x + 1, y) ); 
  * W: move one meter west (from point (x, y) to (x - 1, y) ). 

Each instruction must be executed either by the rover or by the helicopter.
Moreover, each device must execute at least one instruction. Your task is to
distribute the instructions in such a way that after executing all n
instructions, the helicopter and the rover end up at the same point, or
determine that this is impossible.

Input

The first line of input contains t (1 \leq t \leq 10^4 ) — the number of test
cases.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of instructions.

The second line of each test case contains a string s of length n consisting
of the characters 'N', 'S', 'E', 'W' — the sequence of instructions.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10 ^ 5 .

Output

For each test case, if the required distribution of instructions exists,
output a string p of length n consisting of the characters 'R', 'H'. If the i
-th operation should be executed by the rover, then p_i=\text{R} , if the i
-th operation should be executed by the helicopter, then p_i=\text{H} . If
there are multiple solutions, output any of them.

Otherwise, output NO.

Example

Input

    10
    
    6
    
    NENSNE
    
    3
    
    WWW
    
    6
    
    NESSWS
    
    2
    
    SN
    
    2
    
    WE
    
    4
    
    SSNN
    
    4
    
    WESN
    
    2
    
    SS
    
    4
    
    EWNN
    
    4
    
    WEWE

Output

    RRHRRH
    NO
    HRRHRH
    NO
    NO
    RHRH
    RRHH
    RH
    RRRH
    RRHH

Note

Let's consider the first example: the string S = \texttt{NENSNE} . One of the
possible solutions, shown in the figure below, is p = \texttt{RRHRRH} , using
which both the rover and the helicopter will end up one meter north and one
meter east.

![](https://espresso.codeforces.com/bb4cbb5897ef7ab4afcc336d45457d0bb9d07c2c.png)

For WWW, the solution is impossible.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 46
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Vladislav has a string of length 5 , whose characters are each either
\texttt{A} or \texttt{B} .

Which letter appears most frequently: \texttt{A} or \texttt{B} ?

Input

The first line of the input contains an integer t (1 \leq t \leq 32 ) — the
number of test cases.

The only line of each test case contains a string of length 5 consisting of
letters \texttt{A} and \texttt{B} .

All t strings in a test are different (distinct).

Output

For each test case, output one letter (\texttt{A} or \texttt{B} ) denoting the
character that appears most frequently in the string.

Example

Input

    8
    
    ABABB
    
    ABABA
    
    BBBAB
    
    AAAAA
    
    BBBBB
    
    BABAA
    
    AAAAB
    
    BAAAA

Output

    B
    A
    B
    A
    B
    A
    A
    A
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 354
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have a one-dimensional puzzle, all the elements of which need to be put in
one row, connecting with each other. All the puzzle elements are completely
white and distinguishable from each other only if they have different shapes.

Each element has straight borders at the top and bottom, and on the left and
right it has connections, each of which can be a protrusion or a recess. You
cannot rotate the elements.

You can see that there are exactly 4 types of elements. Two elements can be
connected if the right connection of the left element is opposite to the left
connection of the right element.

![](https://espresso.codeforces.com/3a4ca20f32b3885d01c9dc80911de1cfb06870fe.png)
All possible types of elements.

The puzzle contains c_1, c_2, c_3, c_4 elements of each type. The puzzle is
considered complete if you have managed to combine all elements into one long
chain. You want to know how many ways this can be done.

Input

The first line contains a single integer t (1 \le t \le 2 \cdot 10^5 ) — the
number of input test cases. The descriptions of the test cases follow.

The description of each test case contains 4 integers c_i (0 \le c_i \le 10^6
) — the number of elements of each type, respectively.

It is guaranteed that the sum of c_i for all test cases does not exceed 4
\cdot 10^6 .

Output

For each test case, print one integer — the number of possible ways to solve
the puzzle.

Two methods are considered different if there is i , such that the types of
elements at the i position in these methods differ.

Since the answer can be very large, output it modulo 998244353 .

If it is impossible to solve the puzzle, print 0 .

Example

Input

    11
    
    1 1 1 1
    
    1 2 5 10
    
    4 6 100 200
    
    900000 900000 900000 900000
    
    0 0 0 0
    
    0 0 566 239
    
    1 0 0 0
    
    100 0 100 0
    
    0 0 0 4
    
    5 5 0 2
    
    5 4 0 5

Output

    4
    66
    0
    794100779
    1
    0
    1
    0
    1
    36
    126
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 171
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: In the new messenger for the students of the Master's Assistance Center,
Keftemerum, an update is planned, in which developers want to optimize the set
of messages shown to the user. There are a total of n messages. Each message
is characterized by two integers a_i and b_i . The time spent reading the set
of messages with numbers p_1, p_2, \ldots, p_k (1 \le p_i \le n , all p_i are
distinct) is calculated by the formula:

Note that the time to read a set of messages consisting of one message with
number p_1 is equal to a_{p_1} . Also, the time to read an empty set of
messages is considered to be 0 .

The user can determine the time l that he is willing to spend in the
messenger. The messenger must inform the user of the maximum possible size of
the set of messages, the reading time of which does not exceed l . Note that
the maximum size of the set of messages can be equal to 0 .

The developers of the popular messenger failed to implement this function, so
they asked you to solve this problem.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 5 \cdot 10^4 ) — the number of test cases. The
description of the test cases follows.

The first line of each test case contains two integers n and l (1 \leq n \leq
2000 , 1 \leq l \leq 10^9 ) — the number of messages and the time the user is
willing to spend in the messenger.

The i -th of the next n lines contains two integers a_i and b_i (1 \le a_i,
b_i \le 10^9 ) — characteristics of the i -th message.

It is guaranteed that the sum of n^2 over all test cases does not exceed 4
\cdot 10^6 .

Output

For each test case, output a single integer — the maximum possible size of a
set of messages, the reading time of which does not exceed l .

Example

Input

    5
    
    5 8
    
    4 3
    
    1 5
    
    2 4
    
    4 3
    
    2 3
    
    1 6
    
    4 10
    
    3 12
    
    4 8
    
    2 1
    
    2 12
    
    5 26
    
    24 7
    
    8 28
    
    30 22
    
    3 8
    
    17 17
    
    5 14
    
    15 3
    
    1000000000 998244353
    
    179 239
    
    228 1337
    
    993 1007

Output

    3
    1
    2
    1
    0
    
Note

In the first test case, you can take a set of three messages with numbers p_1
= 3 , p_2 = 2 , and p_3 = 5 . The time spent reading this set is equal to a_3
+ a_2 + a_5 + |b_3 - b_2| + |b_2 - b_5| = 2 + 1 + 2 + |4 - 5| + |5 - 3| = 8 .

In the second test case, you can take a set of one message with number p_1 = 1
. The time spent reading this set is equal to a_1 = 4 .

In the fifth test case, it can be shown that there is no such non-empty set of
messages, the reading time of which does not exceed l .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 290
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: This afternoon, you decided to enjoy the first days of Spring by taking a walk
outside. As you come near the Quidditch field, you hear screams. Once again,
there is a conflict about the score: the two teams are convinced that they won
the game! To prevent this problem from happening one more time, you decide to
get involved in the refereeing of the matches.

Now, you will stay in the stadium to watch the game and count the score. At
the end of the game, you will decide the winner.

Today, two teams are competing: the red Gryffindor (R) and the blue Ravenclaw
(B) team. Each team is composed of P players (1 \leq P \leq 10 ).

The field is a rectangle of N lines and M columns (3 \leq N, M \leq 99 , N and
M are odd). All the positions are integers, and several entities are allowed
to be at the same position in the field. At the beginning of the game, the
field contains goals for the two teams (each team can own between one and five
goals), the players, and exactly one Quaffle. Other types of balls will be
available in the harder versions of the problem.

A game is composed of T steps (0 \leq T \leq 10000 ). At each step, one entity
on the field (a player or a ball) performs one action. All entities can move.
A player can also catch a ball or throw the Quaffle that it is carrying. To
catch a ball, a player must be located on the same cell as it. The Quaffle
does not perform any action while it is being carried; it only follows the
movements of the player. If a player carrying the Quaffle decides to throw it,
the Quaffle is simply put at the current position of the player.

To win a point, a player must leave the Quaffle at a goal of the other team.
When it does, the team of the player wins one point, and the Quaffle instantly
moves to the middle of the field (the cell at the (M+1)/2 -th column of the
(N+1)/2 -th line of the field, starting from 1). There is no goal in the
middle of the field. If a player puts the ball in its own goal, the other team
wins the point.

Input

On the first line, the integers N and M .

The description of the field follows: N lines of M pairs of characters
separated by spaces. Each pair of characters represents a position on the
field. It can be either:

  * .. to represent an empty cell 
  * R0, ..., R9, B0, ..., B9 to represent a player. The first character is the team of the player, and the second is the number of the player in the team. Each pair of characters is unique, but it is not guaranteed that all the pairs appear in the grid. 
  * RG or BG to represent a goal. The blue team tries to put the ball in a red goal (RG) while the red team tries to put the ball in a blue goal (BG). 
  * .Q to represent the Quaffle, which is the ball that the players use to score goals. 

The next line contains T , the number of steps that compose the game. T lines
follow, each describing one action. It contains several pieces of information
separated by a space. First, a pair of characters representing the entity that
must perform the action. Second, the description of the action:

  * U, D, L, R indicate that the entity moves on the grid. It can move to the top of the grid (U), to the bottom (D), to the left (L), or to the right (R). Each entity moves by only one cell at a time. 
  * C indicates that the player catches the ball (only a player can catch a ball). Then, there is a space followed by a pair of characters: the description of the ball caught by the player. This information is needed since in the next versions of the problem, several balls may be in the same cell. 
  * T indicates that the player throws the Quaffle that it is carrying. 

All the actions performed by the entities are guaranteed to be valid: the
players stay in the field, don't catch a ball if they are not in the same
cell, don't release the Quaffle if they are not carrying it, ...

Output

You must output the description of the main events of the game, one event per
line. More precisely:

  * Each time a team scores, you must print t RED GOAL or t BLUE GOAL, depending on the team who scored, where t is the current time (the position of the action in the list of actions, starting from 0). In the case where a player scores in the wrong goal (a red player scores in the red goal, or a blue player scores in the blue goal), you must print the name of the team who wins one point, that is, the other team. 

The events must be printed in ascending order of t.

At the end of the game, you must print the final score as: FINAL SCORE: r b,
where r is the score of the red team and b is the score of the blue team.

Examples

Input

    5 5
    
    .. R1 .. B1 ..
    
    RG .. .. .. BG
    
    RG R0 .Q B0 BG
    
    RG .. .. .. BG
    
    .. R2 .. B2 ..
    
    13
    
    B2 U
    
    B2 U
    
    B2 L
    
    B2 C .Q
    
    B2 L
    
    B2 L
    
    B2 T
    
    R0 R
    
    R0 C .Q
    
    R0 D
    
    R0 R
    
    R0 R
    
    R0 T

Output

    6 BLUE GOAL
    12 RED GOAL
    FINAL SCORE: 1 1
    
Input

    3 5
    
    .. .. R0 .. ..
    
    RG .. .Q .. BG
    
    .. .. B0 .. ..
    
    12
    
    R0 D
    
    R0 C .Q
    
    R0 R
    
    R0 T
    
    R0 D
    
    B0 R
    
    B0 U
    
    B0 C .Q
    
    B0 L
    
    B0 L
    
    B0 L
    
    B0 T

Output

    11 BLUE GOAL
    FINAL SCORE: 0 1
    
Input

    3 5
    
    .. .. R0 .. ..
    
    RG .. .Q .. BG
    
    .. .. B0 .. ..
    
    5
    
    R0 D
    
    R0 C .Q
    
    R0 L
    
    R0 L
    
    R0 T

Output

    4 BLUE GOAL
    FINAL SCORE: 0 1
    
Note

In the first example, a blue player goes to the middle of the grid, at the
position of the Quaffle. He takes it, goes to the goal of the red team, and
lets the ball there. He scores! The ball gets back to the middle of the field,
a red player takes it and scores too.

In the second example, the red player takes the Quaffle, move it and throw it.
The blue player catches the ball, goes to the red goal and scores.

In the third example, the red player takes the ball and scores in the goal of
their own team: the blue team wins a point.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 313
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: n ships set out to explore the depths of the ocean. The ships are numbered
from 1 to n and follow each other in ascending order; the i -th ship has a
durability of a_i .

The Kraken attacked the ships k times in a specific order. First, it attacks
the first of the ships, then the last, then the first again, and so on.

Each attack by the Kraken reduces the durability of the ship by 1 . When the
durability of the ship drops to 0 , it sinks and is no longer subjected to
attacks (thus the ship ceases to be the first or last, and the Kraken only
attacks the ships that have not yet sunk). If all the ships have sunk, the
Kraken has nothing to attack and it swims away.

For example, if n=4 , k=5 , and a=[1, 2, 4, 3] , the following will happen:

  1. The Kraken attacks the first ship, its durability becomes zero and now a = [2, 4, 3] ; 
  2. The Kraken attacks the last ship, now a = [2, 4, 2] ; 
  3. The Kraken attacks the first ship, now a = [1, 4, 2] ; 
  4. The Kraken attacks the last ship, now a = [1, 4, 1] ; 
  5. The Kraken attacks the first ship, its durability becomes zero and now a = [4, 1] . 

How many ships were sunk after the Kraken's attack?

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains two integers n and k (1 \le n \le 2
\cdot 10^5 , 1 \le k \le 10^{15} ) — the number of ships and how many times
the Kraken will attack the ships.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (1
\le a_i \le 10^9 ) — the durability of the ships.

It is guaranteed that the sum of n for all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output the number of ships sunk by the Kraken on a
separate line.

Example

Input

    6
    
    4 5
    
    1 2 4 3
    
    4 6
    
    1 2 4 3
    
    5 20
    
    2 7 1 8 2
    
    2 2
    
    3 2
    
    2 15
    
    1 5
    
    2 7
    
    5 2

Output

    2
    3
    5
    0
    2
    2
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 294
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Yarik's birthday is coming soon, and Mark decided to give him an array a of
length n .

Mark knows that Yarik loves bitwise operations very much, and he also has a
favorite number x , so Mark wants to find the maximum number k such that it is
possible to select pairs of numbers [l_1, r_1 ], [l_2, r_2 ], \ldots [l_k, r_k
], such that:

  * l_1 = 1 . 
  * r_k = n . 
  * l_i \le r_i for all i from 1 to k . 
  * r_i + 1 = l_{i + 1} for all i from 1 to k - 1 . 
  * (a_{l_1} \oplus a_{l_1 + 1} \oplus \ldots \oplus a_{r_1}) | (a_{l_2} \oplus a_{l_2 + 1} \oplus \ldots \oplus a_{r_2}) | \ldots | (a_{l_k} \oplus a_{l_k + 1} \oplus \ldots \oplus a_{r_k}) \le x , where \oplus denotes the operation of [bitwise XOR](https://en.wikipedia.org/wiki/Exclusive_or), and | denotes the operation of [bitwise OR](https://en.wikipedia.org/wiki/Logical_disjunction). 

If such k does not exist, then output -1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The following lines
contain the descriptions of the test cases.

The first line of each test case contains two integers n and x (1 \le n \le
10^5, 0 \le x < 2^{30} ) — the length of the array a and the number x
respectively.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < 2^{30} ) — the array a itself.

It is guaranteed that the sum of the values of n across all test cases does
not exceed 10^5 .

Output

For each test case, output a single integer on a separate line — the maximum
suitable number k , and -1 if such k does not exist.

Example

Input

    8
    
    3 1
    
    1 2 3
    
    2 2
    
    1 1
    
    2 2
    
    1 3
    
    2 3
    
    0 0
    
    3 2
    
    0 0 1
    
    4 2
    
    1 3 3 7
    
    2 2
    
    2 3
    
    5 0
    
    0 1 2 2 1

Output

    2
    2
    1
    2
    3
    -1
    1
    2
    
Note

In the first test case, you can take k equal to 2 and choose two segments [1, 1 ] and [2, 3 ], (1) | (2 \oplus 3) = 1 . It can be shown that 2 is the maximum possible answer.

In the second test case, the segments [1, 1 ] and [2, 2 ] are suitable, (1) | (1) = 1 . It is not possible to make more segments.

In the third test case, it is not possible to choose 2 segments, as (1) | (3) = 3 > 2 , so the optimal answer is 1 .
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 317
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: A binary string s of length n is given. A binary string is a string consisting
only of the characters '1' and '0'.

You can choose an integer k (1 \le k \le n ) and then apply the following
operation any number of times: choose k consecutive characters of the string
and invert them, i.e., replace all '0' with '1' and vice versa.

Using these operations, you need to make all the characters in the string
equal to '1'.

For example, if n=5 , s=00100 , you can choose k=3 and proceed as follows:

  * choose the substring from the 1 -st to the 3 -rd character and obtain s=\color{blue}{110}00 ; 
  * choose the substring from the 3 -rd to the 5 -th character and obtain s=11\color{blue}{111} ; 

Find the maximum value of k for which it is possible to make all the
characters in the string equal to '1' using the described operations. Note
that the number of operations required to achieve this is not important.

Input

The first line contains an integer t (1 \le t \le 10^4 ) — the number of test
cases.

The first line of each test case contains an integer n (1 \le n \le 5000 ) —
the length of the string s .

The second line of each test case contains a string s of length n , consisting
of the characters '1' and '0'.

It is guaranteed that the sum of the values n^2 over all test cases in the
test does not exceed 25 \cdot 10^6 .

Output

For each test case, output the maximum integer k (1 \le k \le n ) for which it
is possible to obtain a string s consisting only of the characters '1' using
the described operations.

Example

Input

    5
    
    5
    
    00100
    
    5
    
    01000
    
    7
    
    1011101
    
    3
    
    000
    
    2
    
    10

Output

    3
    2
    4
    3
    1
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 69
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You can never buy enough happiness, so here we go again! In this version, you
can only buy h_i = 1 unit of happiness each month, but the number of months is
hugely increased. We are in the realm of quantum happiness and time dilation.

Being a physicist, Charlie likes to plan his life in simple and precise terms.

For the next m months, starting with no money, Charlie will work hard and earn
x pounds per month. For the i -th month (1 \le i \le m) , there'll be a single
opportunity of paying cost c_i pounds to obtain one unit of happiness. You
cannot buy more than one unit each month.

Borrowing is not allowed. Money earned in the i -th month can only be spent in
a later j -th month (j>i ).

Since physicists don't code, help Charlie find the maximum reachable units of
happiness.

Input

The first line of the input contains t (1 \leq t \leq 10^4 ) — the number of
test cases.

The first line of each test case contains two integers, m and x (1 \le m \le 2
\cdot 10^5 , 1 \le x \le 10^3 ) — the total number of months and the monthly
salary.

The second line of each test case contains m integers c_1, c_2, \dots, c_m (1
\leq c_i \leq 10^3 ) — the cost of one unit of happiness for each month.

It is guaranteed that sum of m over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output one integer — the maximal amount of happiness
Charlie can get.

Example

Input

    6
    
    3 3
    
    2 2 2
    
    6 5
    
    2 2 8 2 6 8
    
    6 4
    
    4 10 3 8 6 10
    
    2 1
    
    1 1
    
    4 1
    
    4 1 3 1
    
    4 2
    
    1 3 4 3

Output

    2
    4
    3
    1
    2
    1
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 343
ERROR - Error: failed to parse entailment checking response
DEBUG - Start Task 111
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Patrick calls a substring^\dagger of a binary string^\ddagger good if this
substring contains exactly one 1.

Help Patrick count the number of binary strings s such that s contains exactly
n good substrings and has no good substring of length strictly greater than k
. Note that substrings are differentiated by their location in the string, so
if s = 1010 you should count both occurrences of 10.

^\dagger A string a is a substring of a string b if a can be obtained from b
by the deletion of several (possibly, zero or all) characters from the
beginning and several (possibly, zero or all) characters from the end.

^\ddagger A binary string is a string that only contains the characters 0 and
1.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 2500 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains two integers n and k (1 \leq n \leq
2500 , 1 \leq k \leq n ) — the number of required good substrings and the
maximum allowed length of a good substring.

It is guaranteed that the sum of n over all test cases does not exceed 2500 .

Output

For each test case, output a single integer — the number of binary strings s
such that s contains exactly n good substrings and has no good substring of
length strictly greater than k . Since this integer can be too large, output
it modulo 998\,244\,353 .

Example

Input

    6
    
    1 1
    
    3 2
    
    4 2
    
    5 4
    
    6 2
    
    2450 2391

Output

    1
    3
    5
    12
    9
    259280854
    
Note

In the first test case, the only suitable binary string is 1. String 01 is not
suitable because it contains a substring 01 with length 2 > 1 .

In the second test case, suitable binary strings are 011, 110 and 111.

In the third test case, suitable binary strings are 101, 0110, 0111, 1110, and
1111.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 65
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Three friends gathered to play a few games of chess together.

In every game, two of them play against each other. The winner gets 2 points
while the loser gets 0 , and in case of a draw, both players get 1 point each.
Note that the same pair of players could have played any non-negative number
of times (possibly zero). It is also possible that no games were played at
all.

You've been told that their scores after all the games were played were p_1 ,
p_2 and p_3 . Additionally, it is guaranteed that p_1 \leq p_2 \leq p_3 holds.

Find the maximum number of draws that could have happened and print it. If
there isn't any way to obtain p_1 , p_2 and p_3 as a result of a non-negative
number of games between the three players, print -1 instead.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 500 ). The description of the test cases follows.

The first line of each test case contains three integers p_1 , p_2 and p_3 (0
\leq p_1 \leq p_2 \leq p_3 \leq 30 ) — the scores of the three players, sorted
non-decreasingly.

Output

For each testcase, print one number — the maximum possible number of draws
that could've happened, or -1 if the scores aren't consistent with any valid
set of games and results.

Example

Input

    7
    
    0 0 0
    
    0 1 1
    
    1 1 1
    
    1 1 2
    
    3 3 3
    
    3 4 5
    
    1 1 10

Output

    0
    1
    -1
    2
    -1
    6
    2
    
Note

In the first example, no games were played at all, so no draws could occur
either.

For the second example, exactly one game occurred between the second and the
third player and it ended in draw, so the answer is 1 .

It's easy to see that there's no set of games achieving the scores in third
example, so the answer for it is -1 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 296
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Some permutation of length n is guessed.

You are given the indices of its prefix maximums and suffix maximums.

Recall that a permutation of length k is an array of size k such that each
integer from 1 to k occurs exactly once.

Prefix maximums are the elements that are the maximum on the prefix ending at
that element. More formally, the element a_i is a prefix maximum if a_i > a_j
for every j < i .

Similarly, suffix maximums are defined, the element a_i is a suffix maximum if
a_i > a_j for every j > i .

You need to output the number of different permutations that could have been
guessed.

As this number can be very large, output the answer modulo 10^9 + 7 .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains three integers n, m_1 and m_2 (1 \le
m_1, m_2 \le n \le 2 \cdot 10^5 ) — the length of the permutation, the number
of prefix maximums, and the number of suffix maximums, respectively.

The second line of each test case contains m_1 integers p_1 < p_2 < \ldots <
p_{m_1} (1 \le p_i \le n ) — the indices of the prefix maximums in increasing
order.

The third line of each test case contains m_2 integers s_1 < s_2 < \ldots <
s_{m_2} (1 \le s_i \le n ) — the indices of the suffix maximums in increasing
order.

It is guaranteed that the sum of the values of n for all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer on a separate line — the number of
suitable permutations modulo 10^9 + 7 .

Example

Input

    6
    
    1 1 1
    
    1
    
    1
    
    4 2 3
    
    1 2
    
    2 3 4
    
    3 3 1
    
    1 2 3
    
    3
    
    5 3 4
    
    1 2 3
    
    2 3 4 5
    
    20 5 4
    
    1 2 3 4 12
    
    12 13 18 20
    
    6 2 3
    
    1 3
    
    3 4 6

Output

    1
    3
    1
    0
    317580808
    10
    
Note

The following permutations are suitable for the second set of input data:

  * [1, 4, 3, 2] 
  * [2, 4, 3, 1] 
  * [3, 4, 2, 1] 

The following permutations are suitable for the sixth set of input data:

  * [2, 1, 6, 5, 3, 4] 
  * [3, 1, 6, 5, 2, 4] 
  * [3, 2, 6, 5, 1, 4] 
  * [4, 1, 6, 5, 2, 3] 
  * [4, 2, 6, 5, 1, 3] 
  * [4, 3, 6, 5, 1, 2] 
  * [5, 1, 6, 4, 2, 3] 
  * [5, 2, 6, 4, 1, 3] 
  * [5, 3, 6, 4, 1, 2] 
  * [5, 4, 6, 3, 1, 2]
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 339
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There are n monsters standing in a row. The i -th monster has a_i health
points.

Every second, you can choose one alive monster and launch a chain lightning at
it. The lightning deals k damage to it, and also spreads to the left (towards
decreasing i ) and to the right (towards increasing i ) to alive monsters,
dealing k damage to each. When the lightning reaches a dead monster or the
beginning/end of the row, it stops. A monster is considered alive if its
health points are strictly greater than 0 .

For example, consider the following scenario: there are three monsters with
health equal to [5, 2, 7] , and k = 3 . You can kill them all in 4 seconds:

  * launch a chain lightning at the 3 -rd monster, then their health values are [2, -1, 4] ; 
  * launch a chain lightning at the 1 -st monster, then their health values are [-1, -1, 4] ; 
  * launch a chain lightning at the 3 -rd monster, then their health values are [-1, -1, 1] ; 
  * launch a chain lightning at the 3 -th monster, then their health values are [-1, -1, -2] . 

For each k from 1 to \max(a_1, a_2, \dots, a_n) , calculate the minimum number
of seconds it takes to kill all the monsters.

Input

The first line contains a single integer n (1 \le n \le 10^5 ) — the number of
monsters.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^5 )
— the health points of the i -th monster.

Output

For each k from 1 to \max(a_1, a_2, \dots, a_n) , output the minimum number of
seconds it takes to kill all the monsters.

Examples

Input

    3
    
    5 2 7

Output

    10 6 4 3 2 2 1 
    
Input

    4
    
    7 7 7 7

Output

    7 4 3 2 2 2 1 
    
Input

    10
    
    1 9 7 6 2 4 7 8 1 3

Output

    17 9 5 4 3 3 3 2 1
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 316
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: The price of one yogurt at the "Vosmiorochka" store is a burles, but there is
a promotion where you can buy two yogurts for b burles.

Maxim needs to buy exactly n yogurts. When buying two yogurts, he can choose
to buy them at the regular price or at the promotion price.

What is the minimum amount of burles Maxim should spend to buy n yogurts?

Input

The first line contains a single integer t (1 \le t \le {10}^{4} ) — the
number of test cases.

The first and only line of each test case contains three integers n , a , and
b (1 \le n \le 100 , 1 \le a, b \le 30 ) — the number of yogurts Maxim wants
to buy, the price for one yogurt, and the price for two yogurts on promotion.

Output

For each test case, print in a separate line the minimum cost of buying n
yogurts at "Vosmiorochka".

Example

Input

    4
    
    2 5 9
    
    3 5 9
    
    3 5 11
    
    4 5 11

Output

    9
    14
    15
    20
    
Note

In the third test case of the example, it is more advantageous to buy three
yogurts for 15 burles than two for 11 and one for 5 .

In the fourth test case of the example, you need to buy four yogurts, each for
5 burles.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 295
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given an array a of n integers.

The median of an array q_1, q_2, \ldots, q_k is the number p_{\lceil
\frac{k}{2} \rceil} , where p is the array q sorted in non-decreasing order.
For example, the median of the array [9, 5, 1, 2, 6] is 5 , as in the sorted
array [1, 2, 5, 6, 9] , the number at index \lceil \frac{5}{2} \rceil = 3 is 5
, and the median of the array [9, 2, 8, 3] is 3 , as in the sorted array [2,
3, 8, 9] , the number at index \lceil \frac{4}{2} \rceil = 2 is 3 .

You are allowed to choose an integer i (1 \le i \le n ) and increase a_i by 1
in one operation.

Your task is to find the minimum number of operations required to increase the
median of the array.

Note that the array a may not necessarily contain distinct numbers.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains a single integer n (1 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^9 ) — the array a .

It is guaranteed that the sum of the values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of operations
required to increase the median of the array.

Example

Input

    8
    
    3
    
    2 2 8
    
    4
    
    7 3 3 1
    
    1
    
    1000000000
    
    5
    
    5 5 5 4 5
    
    6
    
    2 1 2 3 1 4
    
    2
    
    1 2
    
    2
    
    1 1
    
    4
    
    5 5 5 5

Output

    1
    2
    1
    3
    2
    1
    2
    3
    
Note

In the first test case, you can apply one operation to the first number and
obtain the array [3, 2, 8] , the median of this array is 3 , as it is the
number at index \lceil \frac{3}{2} \rceil = 2 in the non-decreasing sorted
array [2, 3, 8] . The median of the original array [2, 2, 8] is 2 , as it is
the number at index \lceil \frac{3}{2} \rceil = 2 in the non-decreasing sorted
array [2, 2, 8] . Thus, the median increased (3 > 2 ) in just one operation.

In the fourth test case, you can apply one operation to each of the numbers at
indices 1, 2, 3 and obtain the array [6, 6, 6, 4, 5] , the median of this
array is 6 , as it is the number at index \lceil \frac{5}{2} \rceil = 3 in the
non-decreasing sorted array [4, 5, 6, 6, 6] . The median of the original array
[5, 5, 5, 4, 5] is 5 , as it is the number at index \lceil \frac{5}{2} \rceil
= 2 in the non-decreasing sorted array [4, 5, 5, 5, 5] . Thus, the median
increased (6 > 5 ) in three operations. It can be shown that this is the
minimum possible number of operations.

In the fifth test case, you can apply one operation to each of the numbers at
indices 1, 3 and obtain the array [3, 1, 3, 3, 1, 4] , the median of this
array is 3 , as it is the number at index \lceil \frac{6}{2} \rceil = 3 in the
non-decreasing sorted array [1, 1, 3, 3, 3, 4] . The median of the original
array [2, 1, 2, 3, 1, 4] is 2 , as it is the number at index \lceil
\frac{6}{2} \rceil = 3 in the non-decreasing sorted array [1, 1, 2, 2, 3, 4] .
Thus, the median increased (3 > 2 ) in two operations. It can be shown that
this is the minimum possible number of operations.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 169
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: In the Master's Assistance Center, Nyam-Nyam was given a homework assignment
in informatics.

There is an array a of length n , and you want to divide it into k > 1
subsegments^{\dagger} in such a way that the \operatorname{MEX} ^{\ddagger} on
each subsegment is equal to the same integer.

Help Nyam-Nyam find any suitable division, or determine that it does not
exist.

^{\dagger} A division of an array into k subsegments is defined as k pairs of
integers (l_1, r_1), (l_2, r_2), \ldots, (l_k, r_k) such that l_i \le r_i and
for each 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 , and also l_1 = 1 and r_k =
n . These pairs represent the subsegments themselves.

^{\ddagger}\operatorname{MEX} of an array is the smallest non-negative integer
that does not belong to the array.

For example:

  * \operatorname{MEX} of the array [2, 2, 1] is 0 , because 0 does not belong to the array. 
  * \operatorname{MEX} of the array [3, 1, 0, 1] is 2 , because 0 and 1 belong to the array, but 2 does not. 
  * \operatorname{MEX} of the array [0, 3, 1, 2] is 4 , because 0 , 1 , 2 , and 3 belong to the array, but 4 does not. 

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < n ) — the elements of the array a .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer -1 if a suitable division does not
exist.

Otherwise, on the first line, output an integer k (2 \le k \le n ) — the
number of subsegments in the division.

Then output k lines — the division into subsegments. The i -th line should
contain two integers l_i and r_i (1 \le l_i \le r_i \le n ) — the boundaries
of the i -th subsegment.

The following conditions must be satisfied:

  * For all 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 ;
  * l_1 = 1 , r_k = n .

If there are multiple possible solutions, output any of them.

Example

Input

    5
    
    2
    
    0 0
    
    5
    
    0 1 2 3 4
    
    8
    
    0 1 7 1 0 1 0 3
    
    3
    
    2 2 2
    
    4
    
    0 1 2 0

Output

    2
    1 1
    2 2
    -1
    3
    1 3
    4 5
    6 8
    3
    1 1
    2 2
    3 3
    -1

Note

In the first test case, the array a can be divided into 2 subsegments with
boundaries [1, 1] and [2, 2] :

  * \operatorname{MEX} of the first subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 
  * \operatorname{MEX} of the second subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 

In the second test case, it can be proven that the required division does not
exist.

In the third test case, the array a can be divided into 3 subsegments with
boundaries [1, 3] , [4, 5] , [6, 8] :

  * \operatorname{MEX} of the first subsegment [0, 1, 7] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the second subsegment [1, 0] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the third subsegment [1, 0, 3] is 2 , as 0 and 1 belong to the subsegment, but 2 does not.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 231
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Monocarp is opening his own IT company. He wants to hire n programmers and m
testers.

There are n+m+1 candidates, numbered from 1 to n+m+1 in chronological order of
their arriving time. The i -th candidate has programming skill a_i and testing
skill b_i (a person's programming skill is different from their testing
skill). The skill of the team is the sum of the programming skills of all
candidates hired as programmers, and the sum of the testing skills of all
candidates hired as testers.

When a candidate arrives to interview, Monocarp tries to assign them to the
most suitable position for them (if their programming skill is higher, then he
hires them as a programmer, otherwise as a tester). If all slots for that
position are filled, Monocarp assigns them to the other position.

Your task is, for each candidate, calculate the skill of the team if everyone
except them comes to interview. Note that it means that exactly n+m candidates
will arrive, so all n+m positions in the company will be filled.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

Each test case consists of three lines:

  * the first line contains two integers n and m (0 \le n, m \le 2 \cdot 10^5 ; 2 \le n + m + 1 \le 2 \cdot 10^5 ) — the number of programmers and the number of testers Monocarp wants to hire, respectively; 
  * the second line contains n + m + 1 integers a_1, a_2, \dots, a_{n+m+1} (1 \le a_i \le 10^9 ), where a_i is the programming skill of the i -th candidate; 
  * the third line contains n + m + 1 integers b_1, b_2, \dots, b_{n+m+1} (1 \le b_i \le 10^9 ; b_i \ne a_i ), where b_i is the testing skill of the i -th candidate. 

Additional constraint on the input: the sum of (n + m + 1) over all test cases
doesn't exceed 2 \cdot 10^5 .

Output

For each test case, print n + m + 1 integers, where the i -th integer should
be equal to the skill of the team if everyone except the i -th candidate comes
to interview.

Example

Input

    4
    
    1 0
    
    2 1
    
    1 2
    
    0 2
    
    4 5 5
    
    5 4 1
    
    1 2
    
    2 1 5 4
    
    5 2 3 1
    
    3 1
    
    4 3 3 4 1
    
    5 5 4 5 2

Output

    1 2 
    5 6 9 
    8 11 11 12 
    13 13 13 12 15 
    
Note

Let's consider the third test case of the example:

  * if the 1 -st candidate does not arrive, the 2 -nd candidate gets hired as a tester, the 3 -rd candidate gets hired as a programmer, the 4 -th candidate gets hired as a tester. The total skill of the team will be 2 + 5 + 1 = 8 ; 
  * if the 2 -nd candidate does not arrive, the 1 -st candidate gets hired as a tester, the 3 -rd candidate gets hired as a programmer, the 4 -th candidate gets hired as a tester. The total skill of the team will be 5 + 5 + 1 = 11 ; 
  * if the 3 -rd candidate does not arrive, the 1 -st candidate gets hired as a tester, the 2 -nd candidate gets hired as a tester, the 4 -th candidate gets hired as a programmer. The total skill of the team will be 5 + 2 + 4 = 11 ; 
  * if the 4 -th candidate does not arrive, the 1 -st candidate gets hired as a tester, the 2 -nd candidate gets hired as a tester, the 3 -rd candidate gets hired as a programmer. The total skill of the team will be 5 + 2 + 5 = 12 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 155
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: [Rammstein - Ausländer](https://youtu.be/3eEA6H_y1VI)

ඞ

There are m baskets placed along a circle, numbered from 1 to m in clockwise
order (basket m is next to basket 1 ). Furthermore, there are n balls, where
ball i is initially placed in basket a_i , and no basket contains more than
one ball.

Alice is allowed to perform the following operation, which always takes
exactly one second whether you move/throw a ball or not:

  * Alice chooses an integer i between 1 and n uniformly at random. 
  * If ball i was thrown away before, do nothing. 
  * Otherwise, ball i is moved from the basket currently containing it to the next basket (in clockwise order). If the target basket currently contains another ball j , throw ball j away. 

She repeats this operation until there is exactly one ball left. Calculate the
expected time needed (in seconds) for Alice to end the process.

It can be proven that the answer can be represented as a rational number
\frac{p}{q} with coprime p and q . You need to output p \cdot q^{-1} \bmod
10^9 + 7 . It can be proven that 10^9 + 7 \nmid q .

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains two integers n and m (1 \le n \le 3
\cdot 10^5, n \le m \le 10^9 ) — the number of balls and the number of
baskets.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le m , a_i 's are pairwise distinct) — the initial position of each
ball.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, print one integer: the expected amount of time (in
seconds) Alice needs to end the process, modulo 10^9 + 7 .

Example

Input

    5
    
    3 10
    
    5 1 4
    
    2 15
    
    15 1
    
    6 6
    
    1 2 3 4 5 6
    
    6 9
    
    6 5 4 3 2 1
    
    1 100
    
    69

Output

    600000042
    14
    35
    333333409
    0
    
Note

In the first test case, Alice could have proceeded as follows (we define a_i =
-1 if ball i has been thrown out):

  * Initially, a = [5, 1, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 2 . After this, a = [5, 2, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 3 . After this, a = [5, 3, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 4 . As basket 4 previously contains ball 3 , this ball is thrown out. After this, a = [5, 4, -1] . 
  * Alice chooses i = 3 with probability \frac{1}{3} . Ball 3 has already been thrown out, so nothing happens. After this, a = [5, 4, -1] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 5 , which throws out ball 1 . After this, a = [-1, 5, -1] , and the process ends. 

The answer for this test case is \frac{189}{5} .

The answer for the second test case is 14 (note that these two balls are next
to each other).

The answer for the third test case is 35 .

The answer for the fourth test case is \frac{220}{3} .

In the fifth test case, as there is only one ball initially, the answer is 0 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 191
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given an n \times n chessboard where you and the computer take turns
alternatingly to place white rooks & black rooks on the board respectively.
While placing rooks, you have to ensure that no two rooks attack each other.
Two rooks attack each other if they share the same row or column regardless of
color.

A valid move is placing a rook on a position (r , c ) such that it doesn't
attack any other rook.

You start first, and when you make a valid move in your turn, placing a white
rook at position (r , c ), the computer will mirror you and place a black rook
at position (c , r ) in its turn. If r = c , then the computer can't mirror
your move, and skips its turn.

You have already played k moves with the computer (the computer tries to
mirror these moves too), and you must continue playing the game until there
are no valid moves remaining. How many different final configurations are
possible when you continue the game after the k moves? It is guaranteed that
the k moves and the implied computer moves are valid. Since the answer may be
large, print it modulo 10^9+7 .

Two configurations are considered different if there exists a coordinate (r ,
c ) which has a rook in one configuration, but not in the other or the color
of the rook on the coordinate is different.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains two integers n and k (1 \leq n \leq
3 \cdot 10^5 , 0 \leq k \leq n ) — the size of the chessboard and the number
of moves you have already played respectively.

Each of the next k lines of the test case contains two integers r_i and c_i ,
denoting the i -th move you made.

It is guaranteed that the k moves and the implied computer moves are valid.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, output a single integer on a new line — the total number
of possible final configurations modulo 10^9+7 .

Example

Input

    3
    
    4 1
    
    1 2
    
    8 1
    
    7 6
    
    1000 4
    
    4 4
    
    952 343
    
    222 333
    
    90 91

Output

    3
    331
    671968183
    
Note

In the first test case, we have a 4 \times 4 grid and you've already played 1
move. After you and the computer play a turn, we have a white rook at (1 , 2
), and a black rook at (2 , 1 ). There are three possible configurations from
this state —

  1. You place a white rook at (3 , 4 ) and the computer places a black rook at (4 , 3 ) as a response. 
  2. You place a white rook at (4 , 3 ) and the computer places a black rook at (3 , 4 ) as a response. 
  3. You place a white rook at (3 , 3 ) and then at (4 , 4 ), or the other way around. They both result in the same configuration. 

![](https://espresso.codeforces.com/e7812b315860201676eb89d5690dd84b3eb85862.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 209
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Jay managed to create a problem of difficulty x and decided to make it the
second problem for Codeforces Round #921.

But Yash fears that this problem will make the contest highly unbalanced, and
the coordinator will reject it. So, he decided to break it up into a
problemset of n sub-problems such that the difficulties of all the sub-
problems are a positive integer and their sum is equal to x .

The coordinator, Aleksey, defines the balance of a problemset as the
[GCD](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the
difficulties of all sub-problems in the problemset.

Find the maximum balance that Yash can achieve if he chooses the difficulties
of the sub-problems optimally.

Input

The first line of input contains a single integer t (1\leq t\leq 10^3 )
denoting the number of test cases.

Each test case contains a single line of input containing two integers x
(1\leq x\leq 10^8 ) and n (1\leq n\leq x ).

Output

For each test case, print a single line containing a single integer denoting
the maximum balance of the problemset Yash can achieve.

Example

Input

    3
    
    10 3
    
    5 5
    
    420 69

Output

    2
    1
    6
    
Note

For the first test case, one possible way is to break up the problem of
difficulty 10 into a problemset having three problems of difficulties 4 , 2
and 4 respectively, giving a balance equal to 2 .

For the second test case, there is only one way to break up the problem of
difficulty 5 into a problemset of 5 problems with each problem having a
difficulty 1 giving a balance equal to 1 .
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 123
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Given an array a of n elements, find the maximum value of the expression:

where i , j , k , and l are four distinct indices of the array a , with 1 \le
i, j, k, l \le n .

Here |x| denotes the absolute value of x .

Input

The first line contains one integer t (1 \le t \le 500 ) — the number of test
cases. The description of the test cases follows.

The first line of each test case contains a single integer n (4 \le n \le 100
) — the length of the given array.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n
(-10^6 \le a_i \le 10^6 ).

Output

For each test case, print a single integer — the maximum value.

Example

Input

    5
    
    4
    
    1 1 1 1
    
    5
    
    1 1 2 2 3
    
    8
    
    5 1 3 2 -3 -1 10 3
    
    4
    
    3 3 1 1
    
    4
    
    1 2 2 -1

Output

    0
    6
    38
    8
    8
    
Note

In the first test case, for any selection of i , j , k , l , the answer will
be 0 . For example, |a_1 - a_2| + |a_2 - a_3| + |a_3 - a_4| + |a_4 - a_1| = |1
- 1| + |1 - 1| + |1 - 1| + |1 - 1| = 0 + 0 + 0 + 0 = 0 .

In the second test case, for i = 1 , j = 3 , k = 2 , and l = 5 , the answer
will be 6 . |a_1 - a_3| + |a_3 - a_2| + |a_2 - a_5| + |a_5 - a_1| = |1 - 2| +
|2 - 1| + |1 - 3| + |3 - 1| = 1 + 1 + 2 + 2 = 6 .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 299
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have been offered to play a game. In this game, there are n possible
outcomes, and for each of them, you must bet a certain integer amount of
coins. In the event that the i -th outcome turns out to be winning, you will
receive back the amount of coins equal to your bet on that outcome, multiplied
by k_i . Note that exactly one of the n outcomes will be winning.

Your task is to determine how to distribute the coins in such a way that you
will come out ahead in the event of any winning outcome. More formally, the
total amount of coins you bet on all outcomes must be strictly less than the
number of coins received back for each possible winning outcome.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 50 )
— the number of outcomes.

The second line of each test case contains n integers k_1,k_2,\ldots,k_n (2
\le k_i \le 20 ) — the multiplier for the amount of coins if the i -th outcome
turns out to be winning.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output -1 if there is no way to distribute the coins as
required. Otherwise, output n integers x_1, x_2,\ldots, x_n (1 \le x_i \le
10^{9} ) — your bets on the outcomes.

It can be shown that if a solution exists, there is always a solution that
satisfies these constraints.

If there are multiple suitable solutions, output any of them.

Example

Input

    6
    
    3
    
    3 2 7
    
    2
    
    3 3
    
    5
    
    5 5 5 5 5
    
    6
    
    7 9 3 17 9 13
    
    3
    
    6 3 2
    
    5
    
    9 4 6 8 3

Output

    27 41 12 
    1 1 
    -1
    1989 1547 4641 819 1547 1071 
    -1
    8 18 12 9 24
    
Note

In the first test case, the coins can be distributed as follows: 27 coins on
the first outcome, 41 coins on the second outcome, 12 coins on the third
outcome. Then the total amount of coins bet on all outcomes is 27 + 41 + 12 =
80 coins. If the first outcome turns out to be winning, you will receive back
3 \cdot 27 = 81 coins, if the second outcome turns out to be winning, you will
receive back 2 \cdot 41 = 82 coins, if the third outcome turns out to be
winning, you will receive back 7 \cdot 12 = 84 coins. All these values are
strictly greater than 80 .

In the second test case, one way is to bet one coin on each of the outcomes.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 8
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: A string t is said to be k -good if there exists at least one
substring^\dagger of length k which is not a palindrome^\ddagger . Let f(t)
denote the sum of all values of k such that the string t is k -good.

You are given a string s of length n . You will have to answer q of the
following queries:

  * Given l and r (l < r ), find the value of f(s_ls_{l + 1}\ldots s_r) . 

^\dagger A substring of a string z is a contiguous segment of characters from
z . For example, "\mathtt{defor} ", "\mathtt{code} " and "\mathtt{o} " are all
substrings of "\mathtt{codeforces} " while "\mathtt{codes} " and "\mathtt{aaa}
" are not.

^\ddagger A palindrome is a string that reads the same backwards as forwards.
For example, the strings "\texttt{z} ", "\texttt{aa} " and "\texttt{tacocat} "
are palindromes while "\texttt{codeforces} " and "\texttt{ab} " are not.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 2 \cdot 10^4 ) — the number of test cases. The
description of the test cases follows.

The first line of each test case contains two integers n and q (2 \le n \le 2
\cdot 10^5, 1 \le q \le 2 \cdot 10^5 ), the size of the string and the number
of queries respectively.

The second line of each test case contains the string s . It is guaranteed the
string s only contains lowercase English characters.

The next q lines each contain two integers, l and r (1 \le l < r \le n ).

It is guaranteed the sum of n and the sum of q both do not exceed 2 \cdot 10^5
.

Output

For each query, output f(s_ls_{l + 1}\ldots s_r) .

Example

Input

    5
    
    4 4
    
    aaab
    
    1 4
    
    1 3
    
    3 4
    
    2 4
    
    3 2
    
    abc
    
    1 3
    
    1 2
    
    5 4
    
    pqpcc
    
    1 5
    
    4 5
    
    1 3
    
    2 4
    
    2 1
    
    aa
    
    1 2
    
    12 1
    
    steponnopets
    
    1 12

Output

    9
    0
    2
    5
    5
    2
    14
    0
    2
    5
    0
    65
    
Note

In the first query of the first test case, the string is \mathtt{aaab} .
\mathtt{aaab} , \mathtt{aab} and \mathtt{ab} are all substrings that are not
palindromes, and they have lengths 4 , 3 and 2 respectively. Thus, the string
is 2 -good, 3 -good and 4 -good. Hence, f(\mathtt{aaab}) = 2 + 3 + 4 = 9 .

In the second query of the first test case, the string is \mathtt{aaa} . There
are no non-palindromic substrings. Hence, f(\mathtt{aaa}) = 0 .

In the first query of the second test case, the string is \mathtt{abc} .
\mathtt{ab} , \mathtt{bc} and \mathtt{abc} are all substrings that are not
palindromes, and they have lengths 2 , 2 and 3 respectively. Thus, the string
is 2 -good and 3 -good. Hence, f(\mathtt{abc}) = 2 + 3 = 5 . Note that even
though there are 2 non-palindromic substrings of length 2 , we count it only
once.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': False}
DEBUG - Start Task 180
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given three digits a , b , and c . Determine whether they form a
stair, a peak, or neither.

  * A stair satisfies the condition a<b<c . 
  * A peak satisfies the condition a<b>c . 

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The only line of each test case contains three digits a , b , c (0 \leq a , b
, c \leq 9 ).

Output

For each test case, output "STAIR" if the digits form a stair, "PEAK" if the
digits form a peak, and "NONE" otherwise (output the strings without quotes).

Example

Input

    7
    
    1 2 3
    
    3 2 1
    
    1 5 3
    
    3 4 1
    
    0 0 0
    
    4 1 7
    
    4 5 7

Output

    STAIR
    NONE
    PEAK
    PEAK
    NONE
    NONE
    STAIR
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 273
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: After some recent attacks on Hogwarts Castle by the Death Eaters, the Order of
the Phoenix has decided to station n members in Hogsmead Village. The houses
will be situated on a picturesque n\times n square field. Each wizard will
have their own house, and every house will belong to some wizard. Each house
will take up the space of one square.

However, as you might know wizards are very superstitious. During the
weekends, each wizard i will want to visit the house that is exactly a_{i} (0
\leq a_{i} \leq n) away from their own house. The roads in the village are
built horizontally and vertically, so the distance between points (x_{i},
y_{i}) and (x_{j}, y_{j}) on the n\times n field is |x_{i} - x_{j}| + |y_{i} -
y_{j}| . The wizards know and trust each other, so one wizard can visit
another wizard's house when the second wizard is away. The houses to be built
will be big enough for all n wizards to simultaneously visit any house.

Apart from that, each wizard is mandated to have a view of the Hogwarts Castle
in the north and the Forbidden Forest in the south, so the house of no other
wizard should block the view. In terms of the village, it means that in each
column of the n\times n field, there can be at most one house, i.e. if the i
-th house has coordinates (x_{i}, y_{i}) , then x_{i} \neq x_{j} for all i
\neq j .

The Order of the Phoenix doesn't yet know if it is possible to place n houses
in such a way that will satisfy the visit and view requirements of all n
wizards, so they are asking for your help in designing such a plan.

If it is possible to have a correct placement, where for the i -th wizard
there is a house that is a_{i} away from it and the house of the i -th wizard
is the only house in their column, output YES, the position of houses for each
wizard, and to the house of which wizard should each wizard go during the
weekends.

If it is impossible to have a correct placement, output NO.

Input

The first line contains n (2 \leq n \leq 2\cdot 10^{5} ), the number of houses
to be built.

The second line contains n integers a_{1}, \ldots, a_{n} (0 \leq a_{i} \leq n)

Output

If there exists such a placement, output YES on the first line; otherwise,
output NO.

If the answer is YES, output n + 1 more lines describing the placement.

The next n lines should contain the positions of the houses 1 \leq x_{i},
y_{i} \leq n for each wizard.

The i -th element of the last line should contain the index of the wizard, the
house of which is exactly a_{i} away from the house of the i -th wizard. If
there are multiple such wizards, you can output any.

If there are multiple house placement configurations, you can output any.

Examples

Input

    4
    0 4 2 4
    
Output

    YES
    4 4
    1 3
    2 4
    3 1
    1 1 1 3

Input

    4
    1 3 0 1
    
Output

    YES
    2 1
    4 1
    1 1
    3 1
    3 3 3 1

Note

For the sample, the house of the 1st wizard is located at (4, 4) , of the 2nd
at (1, 3) , of the 3rd at (2, 4) , of the 4th at (3, 1) .

The distance from the house of the 1st wizard to the house of the 1st wizard
is |4 - 4| + |4 - 4| = 0 .

The distance from the house of the 2nd wizard to the house of the 1st wizard
is |1 - 4| + |3 - 4| = 4 .

The distance from the house of the 3rd wizard to the house of the 1st wizard
is |2 - 4| + |4 - 4| = 2 .

The distance from the house of the 4th wizard to the house of the 3rd wizard
is |3 - 2| + |1 - 4| = 4 .

The view and the distance conditions are satisfied for all houses, so the
placement is correct.

![](https://espresso.codeforces.com/2790cf05cadf5e6334d074a3605416ddb963947f.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 318
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are given a positive integer n .

Find a permutation^\dagger p of length n such that there do not exist two
distinct indices i and j (1 \leq i, j < n ; i \neq j ) such that p_i divides
p_j and p_{i+1} divides p_{j+1} .

Refer to the Notes section for some examples.

Under the constraints of this problem, it can be proven that at least one p
exists.

^\dagger A permutation of length n is an array consisting of n distinct
integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a
permutation, but [1,2,2] is not a permutation (2 appears twice in the array),
and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^3 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (3 \leq n \leq
10^5 ) — the length of the permutation p .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output p_1, p_2, \ldots, p_n .

If there are multiple solutions, you may output any one of them.

Example

Input

    2
    
    4
    
    3

Output

    4 1 2 3
    1 2 3
    
Note

In the first test case, p=[4,1,2,3] is a valid permutation. However, the
permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and
j=3 . Then p_1=1 divides p_3=3 and p_2=2 divides p_4=4 . Note that the
permutation p=[3, 4, 2, 1] is also not a valid permutation as we can choose
i=3 and j=2 . Then p_3=2 divides p_2=4 and p_4=1 divides p_3=2 .

In the second test case, p=[1,2,3] is a valid permutation. In fact, all 6
permutations of length 3 are valid.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 248
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You have a square piece of paper with a side length equal to 1 unit. In one
operation, you fold each corner of the square to the center of the paper, thus
forming another square with a side length equal to \dfrac{1}{\sqrt{2}} units.
By taking this square as a new square, you do the operation again and repeat
this process a total of N times.

![](https://espresso.codeforces.com/412ebba036545f933291dce36c1d7ef46e6051c5.png)
Performing operations for N = 2 .

After performing the set of operations, you open the paper with the same side
up you started with and see some crease lines on it. Every crease line is one
of two types: a mountain or a valley. A mountain is when the paper folds
outward, and a valley is when the paper folds inward.

You calculate the sum of the length of all mountain crease lines on the paper
and call it M . Similarly, you calculate for valley crease lines and call it V
. You want to find the value of \dfrac{M}{V} .

It can be proved that this value can be represented in the form of A +
B\sqrt{2} , where A and B are rational numbers. Let this B be represented as
an irreducible fraction \dfrac{p}{q} , your task is to print p*inv(q) modulo
999\,999\,893 (note the unusual modulo), where inv(q) is the [modular
inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) of q .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \leq t \leq 10^4 ). Description of the test cases follows.

The only line of each test case contains an integer N (1 \leq N \leq 10^9 ),
the number of operations you perform on the square paper.

Output

For each test case, print on a new line the required answer.

Example

Input

    3
    
    1
    
    2
    
    3

Output

    0
    1
    714285638
    
Note

The blue lines in the given figures represent mountain crease lines, and the
green lines represent valley crease lines.

![](https://espresso.codeforces.com/ca27ca80cf535ddfa7cb1255e157dc6f43f1073c.png)|
![](https://espresso.codeforces.com/9e2d8603363c8514970f3141c639422cb347d41f.png)  
---|---  
Crease lines after 1 operation (\dfrac{M}{V} = 0) .| Crease lines after 2
operations (\dfrac{M}{V} = \sqrt{2} - 1) .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': True}
DEBUG - Start Task 45
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Vladislav has n non-negative integers, and he wants to divide all of them into
several groups so that in any group, any pair of numbers does not have
matching bit values among bits from 1 -st to 31 -st bit (i.e., considering the
31 least significant bits of the binary representation).

For an integer k , let k_2(i) denote the i -th bit in its binary
representation (from right to left, indexing from 1). For example, if k=43 ,
since 43=101011_2 , then 43_2(1)=1 , 43_2(2)=1 , 43_2(3)=0 , 43_2(4)=1 ,
43_2(5)=0 , 43_2(6)=1 , 43_2(7)=0 , 43_2(8)=0, \dots, 43_2(31)=0 .

Formally, for any two numbers x and y in the same group, the condition x_2(i)
\neq y_2(i) must hold for all 1 \leq i < 32 .

What is the minimum number of groups Vlad needs to achieve his goal? Each
number must fall into exactly one group.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains a single integer n (1 \leq n \leq 2
\cdot 10^5 ) — the total number of integers.

The second line of each test case contains n given integers a_1, \ldots, a_n
(0 \leq a_j < 2^{31} ).

The sum of n over all test cases in a test does not exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of groups
required to satisfy the condition.

Example

Input

    9
    
    4
    
    1 4 3 4
    
    2
    
    0 2147483647
    
    5
    
    476319172 261956880 2136179468 1671164475 1885526767
    
    3
    
    1335890506 811593141 1128223362
    
    4
    
    688873446 627404104 1520079543 1458610201
    
    4
    
    61545621 2085938026 1269342732 1430258575
    
    4
    
    0 0 2147483647 2147483647
    
    3
    
    0 0 2147483647
    
    8
    
    1858058912 289424735 1858058912 2024818580 1858058912 289424735 122665067 289424735

Output

    4
    1
    3
    2
    2
    3
    2
    2
    4
    
Note

In the first test case, any two numbers have the same last 31 bits, so we need
to place each number in its own group.

In the second test case, a_1=0000000000000000000000000000000_2 ,
a_2=1111111111111111111111111111111_2 so they can be placed in the same group
because a_1(i) \ne a_2(i) for each i between 1 and 31 , inclusive.
DEBUG - Correctness: {'naive': True, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': True, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 243
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: You are designing a new video game. It has n scenarios, which the player may
play in any order, but each scenario must be played exactly once. When a
player switches from a scenario to another scenario, the game shows a
specially crafted transition video to make it all feel part of one big story.
This video is specific to a pair of scenarios, but not to their order, in
other words, the video playing when switching from scenario a to scenario b is
the same as the video playing when switching from scenario b to scenario a .
Therefore, you need to create \frac{n(n-1)}{2} different transition videos,
one for each possible pair of different scenarios.

Each transition video can be either funny or scary. It is boring to see too
many funny videos or too many scary videos in a row. Therefore, your goal is
to create the videos in such a way that no matter in which order does the
player approach the scenarios, they will never see more than \lceil
\frac{3n}{4} \rceil transition videos of the same type in a row.

You have already come up with ideas for at most \lfloor \frac{n}{2} \rfloor of
the transition videos, and therefore already know if those will be funny or
scary. Now you need to choose funny or scary for all other transition videos
in such a way that the above requirement is satisfied.

Input

The first line contains a single integer n (2 \le n \le 24 ) — the number of
scenarios in the game.

The next n lines describe the partial transition video plan. Each of those
lines contains n characters. The j -th character of the i -th line corresponds
to the transition video between the i -th and the j -th scenarios. It will be
F if the corresponding transition video will be funny, S if the corresponding
transition video will be scary, ? if the corresponding transition video is
still undecided, or . if i=j .

It is guaranteed that the i -th character of the j -th line and the j -th
character of the i -th line will be the same for all i and j . It is
guaranteed that at most \lfloor \frac{n}{2} \rfloor (n divided by 2, rounded
down) transition videos will already be decided, in other words, that at most
2\lfloor \frac{n}{2} \rfloor characters in the input will be F or S.

Output

Print n lines describing the full transition video plan in the same format as
the input. Each of those lines must contain n characters. The j -th character
of the i -th line must be F if the corresponding transition video is funny, S
if the corresponding transition video is scary, or . if i=j .

Each ? character from the input must be replaced with either F or S, and all
other characters from the input must remain unchanged. It must still hold that
the i -th character of the j -th line and the j -th character of the i -th
line are the same for all i and j .

For each permutation of the n scenarios, it must hold that the transition
videos corresponding to playing the scenarios in this order do not have more
than \lceil \frac{3n}{4} \rceil (3n divided by 4, rounded up) videos of the
same type consecutively.

If there are multiple solutions, print any of them. It can be proven that for
all inputs satisfying the constraints of this problem a solution always
exists.

Examples

Input

    5
    
    .?F??
    
    ?.???
    
    F?.S?
    
    ??S.?
    
    ????.

Output

    .FFFF
    F.FFF
    FF.SF
    FFS.F
    FFFF.

Input

    12
    
    .???????????
    
    ?.??????????
    
    ??.?????????
    
    ???.????????
    
    ????.???????
    
    ?????.??????
    
    ??????.?????
    
    ???????.????
    
    ????????.???
    
    ?????????.??
    
    ??????????.?
    
    ???????????.

Output

    .SSSFFSSSSFS
    S.SFFSFSFFFS
    SS.SFFFSSSFS
    SFS.FFSSSSFS
    FFFF.FFFFFSF
    FSFFF.SFFSFF
    SFFSFS.SSSFS
    SSSSFFS.SSFS
    SFSSFFSS.SFS
    SFSSFSSSS.FS
    FFFFSFFFFF.F
    SSSSFFSSSSF.
    
Note

In the first sample: We are allowed \lceil \frac{3\cdot 5}{4} \rceil=4
transition videos of the same type in a row, but for any permutation of the 5
scenarios the player will see only 4 transition videos in total, therefore we
can choose funny or scary freely. We must still respect the already chosen
types.

In the second sample: One of the 479001600 possible permutations of scenarios
is 1, 7, 4, 12, 9, 8, 2, 6, 10, 3, 11, 5. The player will get the following
sequence of transition videos for this permutation: SSSSSSSSSFS. Even though
this sequence has 10 scary transition videos in total, it has only 9 scary
transition videos in a row, which is the maximum allowed amount (\lceil
\frac{3\cdot 12}{4} \rceil=9 ).
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 296
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Some permutation of length n is guessed.

You are given the indices of its prefix maximums and suffix maximums.

Recall that a permutation of length k is an array of size k such that each
integer from 1 to k occurs exactly once.

Prefix maximums are the elements that are the maximum on the prefix ending at
that element. More formally, the element a_i is a prefix maximum if a_i > a_j
for every j < i .

Similarly, suffix maximums are defined, the element a_i is a suffix maximum if
a_i > a_j for every j > i .

You need to output the number of different permutations that could have been
guessed.

As this number can be very large, output the answer modulo 10^9 + 7 .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains three integers n, m_1 and m_2 (1 \le
m_1, m_2 \le n \le 2 \cdot 10^5 ) — the length of the permutation, the number
of prefix maximums, and the number of suffix maximums, respectively.

The second line of each test case contains m_1 integers p_1 < p_2 < \ldots <
p_{m_1} (1 \le p_i \le n ) — the indices of the prefix maximums in increasing
order.

The third line of each test case contains m_2 integers s_1 < s_2 < \ldots <
s_{m_2} (1 \le s_i \le n ) — the indices of the suffix maximums in increasing
order.

It is guaranteed that the sum of the values of n for all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer on a separate line — the number of
suitable permutations modulo 10^9 + 7 .

Example

Input

    6
    
    1 1 1
    
    1
    
    1
    
    4 2 3
    
    1 2
    
    2 3 4
    
    3 3 1
    
    1 2 3
    
    3
    
    5 3 4
    
    1 2 3
    
    2 3 4 5
    
    20 5 4
    
    1 2 3 4 12
    
    12 13 18 20
    
    6 2 3
    
    1 3
    
    3 4 6

Output

    1
    3
    1
    0
    317580808
    10
    
Note

The following permutations are suitable for the second set of input data:

  * [1, 4, 3, 2] 
  * [2, 4, 3, 1] 
  * [3, 4, 2, 1] 

The following permutations are suitable for the sixth set of input data:

  * [2, 1, 6, 5, 3, 4] 
  * [3, 1, 6, 5, 2, 4] 
  * [3, 2, 6, 5, 1, 4] 
  * [4, 1, 6, 5, 2, 3] 
  * [4, 2, 6, 5, 1, 3] 
  * [4, 3, 6, 5, 1, 2] 
  * [5, 1, 6, 4, 2, 3] 
  * [5, 2, 6, 4, 1, 3] 
  * [5, 3, 6, 4, 1, 2] 
  * [5, 4, 6, 3, 1, 2]
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 144
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Monocarp wants to throw a party. He has n friends, and he wants to have at
least 2 of them at his party.

The i -th friend's best friend is p_i . All p_i are distinct, and for every i
\in [1, n] , p_i \ne i .

Monocarp can send invitations to friends. The i -th friend comes to the party
if both the i -th friend and the p_i -th friend receive an invitation (note
that the p_i -th friend doesn't have to actually come to the party). Each
invitation is sent to exactly one of the friends.

For example, if p = [3, 1, 2, 5, 4] , and Monocarp sends invitations to the
friends [1, 2, 4, 5] , then the friends [2, 4, 5] will come to the party. The
friend 1 won't come since his best friend didn't receive an invitation; the
friend 3 won't come since he didn't receive an invitation.

Calculate the minimum number of invitations Monocarp has to send so that at
least 2  friends come to the party.

Input

The first line contains one integer t (1 \le t \le 5000 ) — the number of test
cases.

Each test case consists of two lines:

  * the first line contains one integer n (2 \le n \le 50 ) — the number of friends; 
  * the second line contains n integers p_1, p_2, \dots, p_n (1 \le p_i \le n ; p_i \ne i ; all p_i are distinct). 

Output

Print one integer — the minimum number of invitations Monocarp has to send.

Example

Input

    3
    
    5
    
    3 1 2 5 4
    
    4
    
    2 3 4 1
    
    2
    
    2 1

Output

    2
    3
    2
    
Note

In the first testcase, Monocarp can send invitations to friends 4 and 5 . Both
of them will come to the party since they are each other's best friends, and
both of them have invitations.

In the second testcase, Monocarp can send invitations to friends 1, 2 and 3 ,
for example. Then friends 1 and 2 will attend: friend 1 and his best friend 2
have invitations, friend 2 and his best friend 3 have invitations. Friend 3
won't attend since his friend 4 doesn't have an invitation. It's impossible to
send invitations to fewer than 3 friends in such a way that at least 2 come.

In the third testcase, Monocarp can send invitations to both friends 1 and 2 ,
and both of them will attend.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': False, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': False, 'simple_verify': True, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 338
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: Alice and Bob have bought a ribbon consisting of n parts. Now they want to
paint it.

First, Alice will paint every part of the ribbon into one of m colors. For
each part, she can choose its color arbitrarily.

Then, Bob will choose at most k  parts of the ribbon and repaint them into the
same color (he chooses the affected parts and the color arbitrarily).

Bob would like all parts to have the same color. However, Alice thinks that
this is too dull, so she wants to paint the ribbon in such a way that Bob
cannot make all parts have the same color.

Is it possible to paint the ribbon in such a way?

Input

The first line contains one integer t (1 \le t \le 1000 ) — the number of test
cases.

Each test case consists of one line containing three integers n , m and k (1
\le m, k \le n \le 50 ) — the number of parts, the number of colors and the
number of parts Bob can repaint, respectively.

Output

For each test case, print YES if Alice can paint the ribbon so that Bob cannot
make all parts have the same color. Otherwise, print NO.

You can print every letter in any register. For example, Yes, yes, yEs will
all be recognized as positive answer.

Example

Input

    5
    
    1 1 1
    
    5 1 1
    
    5 2 1
    
    5 2 2
    
    5 5 3

Output

    NO
    NO
    YES
    NO
    YES
    
Note

In the first test case, a ribbon consists of 1 part. So all its parts will
always have the same color.

In the second test case, there is only 1 color.

In the third test case, Alice can paint the ribbon as follows: [1, 2, 1, 2, 1]
. It's impossible to change the color of at most 1 part so that all parts have
the same color.

In the fourth test case, no matter how Alice paints the ribbon, Bob will
always be able to repaint 2 parts so that all parts have the same color.

In the fifth test case, Alice can paint the ribbon as follows: [1, 2, 3, 4, 5]
. It's impossible to change the color of at most 3 parts so that all parts
have the same color.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 241
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: This problem has an attachment. You can use it to simulate and visualize the
movements of the amoeba.

Amoeba Amanda lives inside a rectangular grid of square pixels. Her body
occupies some of these pixels. Other pixels may be either free or blocked.
Amanda moves across the grid using the so-called amoeboid movement. In each
step of such a movement, her body first shrinks by one pixel (one pixel of the
body is removed and becomes free), and then grows at a different place (one
previously-free pixel is added to the body).

To prevent structural damage, Amanda's body always occupies a connected region
of pixels, which means that any pair of pixels forming the body can be
connected by a sequence of adjacent pixels without ever leaving the body. Two
pixels are considered adjacent if they share a common side (each pixel has at
most 4 neighbours). The body remains connected even during the movement,
including the moment after removing a pixel and before adding another one.

Your task is to help Amanda find her way around. Given her initial position
and desired final position, suggest a sequence of valid moves leading from the
former to the latter.

![](https://espresso.codeforces.com/8d732857e67e5cd7cb6a0af1ed34584572413ddc.png)
Illustration of sample 1 : The filled shape is the initial position, the
dotted region is the final position.

Input

The first line contains two integers r and c (1\le r,c \le 50 ) — the size of
the rectangular grid in pixels.

The next r lines contain c characters each, describing the initial position of
Amanda. Each of those characters is either a dot \texttt{.} denoting a free
pixel, an asterisk \texttt{*} denoting Amanda's body, or an \texttt{X}
denoting a blocked pixel which may never be occupied.

The next line is empty.

The next r lines describe the desired final position in the same format as the
initial position.

It is guaranteed that:

  * The number of pixels forming Amanda's body is the same in both positions, and it is at least 2. 
  * The body of Amanda is connected in the initial position. 
  * The body of Amanda is connected in the final position. 
  * The blocked pixels do not change between the descriptions of the initial and final position, their placement is exactly the same in both positions. 

Output

Print \texttt{YES} if it is possible for Amanda to go from the initial
position to the final one. Otherwise, print \texttt{NO} .

If it is possible, on the next line print one integer m (0\le m\le 10\,000 ) —
the number of moves to execute.

The following m lines must contain four integer coordinates each: i_1 , j_1 ,
i_2 , j_2 (1\le i_1,i_2\le r , 1\le j_1,j_2\le c ). These four coordinates
specify one move, meaning that the pixel at i_1 -th row and j_1 -th column is
first removed from the body. Then, (i_2,j_2) must designate a different
location where one pixel is added.

The sequence should consist only of valid moves and after the last move,
Amanda's body should occupy the desired final position.

If there are multiple solutions, print any of them.

Under the assumptions of this problem, it can be proven that if it is possible
for Amanda to go from the initial position to the desired final one, then it
is possible to do it with at most 10\,000 moves.

Examples

Input

    5 8
    
    .******.
    
    **.X**..
    
    *******.
    
    **.X**..
    
    .******.
    
    .******.
    
    ...X****
    
    .*******
    
    ...X****
    
    .******.

Output

    YES
    5
    3 1 3 8
    2 1 2 8
    4 1 4 8
    2 2 4 7
    4 2 2 7
    
Input

    2 5
    
    *.X..
    
    **X..
    
    ..X**
    
    ..X*.

Output

    NO
    
Note

In the first sample, Amanda executes 5 moves to reach the final position, as
shown in the figure below.

![](https://espresso.codeforces.com/04b7bb193a243e0eaf83952861f5275e04543407.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 163
ERROR - Error: unsupported statement type: <ast.Global object at 0x75be85f5f9d0> global skipper, acc

DEBUG - Start Task 352
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: There are n containers of water lined up, numbered from left to right from 1
to n . Each container can hold any amount of water; initially, the i -th
container contains a_i units of water. The sum of a_i is divisible by n .

You can apply the following operation any (possibly zero) number of times:
pour any amount of water from the i -th container to the j -th container,
where i must be less than j (i.e. i<j ). Any index can be chosen as i or j any
number of times.

Determine whether it is possible to make the amount of water in all containers
the same using this operation.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of containers with water.

The second line of each test case contains n integers a_1, a_2, \dots, a_n (0
\le a_i \le 10^9 ) — the amounts of water in the containers. It is guaranteed
that the sum of a_i in each test case does not exceed 2 \cdot 10^9 . Also, the
sum of a_i is divisible by n .

It is guaranteed that the sum of n over all test cases in the input does not
exceed 2 \cdot 10^5 .

Output

Output t lines, each of which is the answer to the corresponding test case. As
the answer, output "YES" if it is possible to make the amount of water in all
containers the same using the described operation. Otherwise, output "NO".

You can output each letter in any case (lowercase or uppercase). For example,
the strings "yEs", "yes", "Yes", and "YES" will be accepted as a positive
answer.

Example

Input

    6
    
    1
    
    43
    
    2
    
    1 3
    
    5
    
    4 5 2 1 3
    
    3
    
    1 2 3
    
    7
    
    4 5 5 0 6 4 4
    
    7
    
    6 5 5 1 3 4 4

Output

    YES
    NO
    YES
    NO
    NO
    YES
    
Note

In the third test case of the example (a=[4, 5, 2, 1, 3] ), you can proceed as
follows:

  * pour 1 unit of water from the first vessel to the fourth, then a=[3, 5, 2, 2, 3] ; 
  * pour 1 unit of water from the second vessel to the third, then a=[3, 4, 3, 2, 3] ; 
  * pour 1 unit of water from the second vessel to the fourth, then a=[3, 3, 3, 3, 3] .
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': False, 'default_verify': True, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 77
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: This is a hard version of the problem; it differs from the easy version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ); the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot).

Then output k non-negative integers a_1, a_2, \dots, a_k , where a_i is a
value such that after Bob gives Alice the i -th fountain, the maximum size of
her plot will be \alpha + a_i .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where a_i is a value such that
after Bob gives Alice the i -th fountain, the maximum size of her plot will be
\alpha + a_i .

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 4 
    1
    0 0 1 1 0 0 0 0 0 
    6
    15 0 0 0 
    1
    2 3 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': True, 'default_no_fsl_verify': True}
DEBUG - Start Task 48
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: In order to test the hypothesis about the cats, the scientists must arrange
the cats in the boxes in a specific way. Of course, they would like to test
the hypothesis and publish a sensational article as quickly as possible,
because they are too engrossed in the next hypothesis about the phone's
battery charge.

Scientists have n boxes in which cats may or may not sit. Let the current
state of the boxes be denoted by the sequence b_1, \dots, b_n : b_i = 1 if
there is a cat in box number i , and b_i = 0 otherwise.

Fortunately, the unlimited production of cats has already been established, so
in one day, the scientists can perform one of the following operations:

  * Take a new cat and place it in a box (for some i such that b_i = 0 , assign b_i = 1 ). 
  * Remove a cat from a box and send it into retirement (for some i such that b_i = 1 , assign b_i = 0 ). 
  * Move a cat from one box to another (for some i, j such that b_i = 1, b_j = 0 , assign b_i = 0, b_j = 1 ). 

It has also been found that some boxes were immediately filled with cats.
Therefore, the scientists know the initial position of the cats in the boxes
s_1, \dots, s_n and the desired position f_1, \dots, f_n .

Due to the large amount of paperwork, the scientists do not have time to solve
this problem. Help them for the sake of science and indicate the minimum
number of days required to test the hypothesis.

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. This is followed by
descriptions of the test cases.

Each test case consists of three lines.

The first line of each test case contains a single integer n (1 \le n \le 10^5
) — the number of boxes.

The second line of each test case contains a string s of n characters, where
the i -th character is '1' if there is a cat in the i -th box and '0'
otherwise.

The third line of each test case contains a string f of n characters, where
the i -th character is '1' if there should be a cat in the i -th box and '0'
otherwise.

It is guaranteed that in a test the sum of n over all test cases does not
exceed 10^5 .

Output

For each test case, output a single integer on a separate line — the minimum
number of operations required to obtain the desired position from the initial
position. It can be shown that a solution always exists.

Example

Input

    6
    
    5
    
    10010
    
    00001
    
    1
    
    1
    
    1
    
    3
    
    000
    
    111
    
    4
    
    0101
    
    1010
    
    3
    
    100
    
    101
    
    8
    
    10011001
    
    11111110

Output

    2
    0
    3
    2
    1
    4
    
Note

In the first test case, you can first move the cat from the first box to the
fifth, and then remove the cat from the fourth box.

In the second test case, there is nothing to do — the only cat is already
sitting in the correct box.

In the third test case of input data, it takes three days to place a cat in
each box.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': False, 'default': False, 'default_no_fsl': False, 'simple_verify': False, 'complex_verify': False, 'default_verify': False, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 86
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: [Proof Geometric Construction Can Solve All Love Affairs -
manbo-p](https://soundcloud.com/alice-law-314125270/manbo-p-proof-geometric-
construction-can-solve-all-love-affairs)

⠀

This is the hard version of the problem. The only difference between the two
versions is the constraint on y . In this version 0 \leq y \leq n - x . You
can make hacks only if both versions are solved.

Bessie has received a birthday cake from her best friend Elsie, and it came in
the form of a regular polygon with n sides. The vertices of the cake are
numbered from 1 to n clockwise. You and Bessie are going to choose some of
those vertices to cut non-intersecting diagonals into the cake. In other
words, the endpoints of the diagonals must be part of the chosen vertices.

Bessie would only like to give out pieces of cake which result in a triangle
to keep consistency. The size of the pieces doesn't matter, and the whole cake
does not have to be separated into all triangles (other shapes are allowed in
the cake, but those will not be counted).

Bessie has already chosen x of those vertices that can be used to form
diagonals. She wants you to choose no more than y other vertices such that the
number of triangular pieces of cake she can give out is maximized.

What is the maximum number of triangular pieces of cake Bessie can give out?

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case consists of three integers, n , x , and y (4
\leq n \leq 10^9 , 2 \leq x \leq \min(n, 2 \cdot 10^5) , 0 \leq y \leq n - x )
— the number of sides of the polygon, number of vertices Bessie has chosen,
and the maximum number of other vertices you can choose.

The second line consists of x distinct integers from 1 to n , representing the
vertices Bessie has chosen.

It is guaranteed the sum of x over all test cases does not exceed 2 \cdot 10^5
.

Output

For each test case, output a single integer: the maximum number of non-
intersecting triangular pieces of cake she can give out.

Example

Input

    3
    
    8 4 2
    
    1 6 2 5
    
    7 3 1
    
    6 4 3
    
    4 2 2
    
    1 3

Output

    6
    5
    2
    
Note

In test cases 1 , 2 and 3 , you can get 6 , 5 and 2 non-intersecting
triangular pieces of cake, respectively. A possible construction is shown in
the following pictures:

The green dots represent vertices that Bessie chose, the yellow dots represent
vertices that you chose, the blue lines represent diagonals that are drawn,
and the red numbers represent triangles that are counted.

![](https://espresso.codeforces.com/13b28beb7f5f0d100798f357f58c804c5314c869.png)
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': True, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': True, 'complex_verify': True, 'default_verify': True, 'simple_no_fsl_verify': False, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
DEBUG - Start Task 78
DEBUG - Dataset: codeforces2024
DEBUG - model_created: human
DEBUG - model_run: qwen2.5-7b-instruct
DEBUG - description: This is an easy version of the problem; it differs from the hard version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ), the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot). Then output k non-negative integers a_1, a_2, \dots,
a_k , where:

  * a_i=0 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot does not increase (i.e., remains equal to \alpha ); 
  * a_i=1 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot increases (i.e., becomes greater than \alpha ). 

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where:

  * a_i=0 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot does not increase compared to the case when all k fountains belong to Bob; 
  * a_i=1 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot increases compared to the case when all k fountains belong to Bob. 

If you output any other positive number instead of 1 that fits into a 64-bit
signed integer type, it will also be recognized as 1 . Thus, a solution to the
hard version of this problem will also pass the tests for the easy version.

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 1 
    1
    0 0 1 1 0 0 0 0 0 
    6
    1 0 0 0 
    1
    1 1 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.
DEBUG - Correctness: {'naive': False, 'naive_no_fsl': True, 'simple': False, 'complex': True, 'default': False, 'default_no_fsl': True, 'simple_verify': False, 'complex_verify': True, 'default_verify': False, 'simple_no_fsl_verify': True, 'complex_no_fsl_verify': False, 'default_no_fsl_verify': False}
