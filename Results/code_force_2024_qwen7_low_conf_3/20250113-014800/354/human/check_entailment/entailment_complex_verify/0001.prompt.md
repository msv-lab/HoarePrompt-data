
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
You have a one-dimensional puzzle, all the elements of which need to be put in
one row, connecting with each other. All the puzzle elements are completely
white and distinguishable from each other only if they have different shapes.

Each element has straight borders at the top and bottom, and on the left and
right it has connections, each of which can be a protrusion or a recess. You
cannot rotate the elements.

You can see that there are exactly 4 types of elements. Two elements can be
connected if the right connection of the left element is opposite to the left
connection of the right element.

![](https://espresso.codeforces.com/3a4ca20f32b3885d01c9dc80911de1cfb06870fe.png)
All possible types of elements.

The puzzle contains c_1, c_2, c_3, c_4 elements of each type. The puzzle is
considered complete if you have managed to combine all elements into one long
chain. You want to know how many ways this can be done.

Input

The first line contains a single integer t (1 \le t \le 2 \cdot 10^5 ) — the
number of input test cases. The descriptions of the test cases follow.

The description of each test case contains 4 integers c_i (0 \le c_i \le 10^6
) — the number of elements of each type, respectively.

It is guaranteed that the sum of c_i for all test cases does not exceed 4
\cdot 10^6 .

Output

For each test case, print one integer — the number of possible ways to solve
the puzzle.

Two methods are considered different if there is i , such that the types of
elements at the i position in these methods differ.

Since the answer can be very large, output it modulo 998244353 .

If it is impossible to solve the puzzle, print 0 .

Example

Input

    11
    
    1 1 1 1
    
    1 2 5 10
    
    4 6 100 200
    
    900000 900000 900000 900000
    
    0 0 0 0
    
    0 0 566 239
    
    1 0 0 0
    
    100 0 100 0
    
    0 0 0 4
    
    5 5 0 2
    
    5 4 0 5

Output

    4
    66
    0
    794100779
    1
    0
    1
    0
    1
    36
    126

- Program: 

#Function 1:
def func_1(c1, c2, c3, c4):
    MOD = 998244353
    dp = [[0 for _ in range(4)] for _ in range(max(c1, c2, c3, c4) + 1)]
    dp[0][0] = 1
    for i in range(1, max(c1, c2, c3, c4) + 1):
        if i <= c1:
            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]) % MOD
        if i <= c2:
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2] + dp[i - 1][3]) % MOD
        if i <= c3:
            dp[i][2] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][3]) % MOD
        if i <= c4:
            dp[i][3] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD
    total_ways = sum(dp[max(c1, c2, c3, c4)]) % MOD
    return total_ways

#Function 2:
def func_2():
    MOD = 998244353
    t = int(input())
    results = []
    for _ in range(t):
        (c1, c2, c3, c4) = map(int, input().split())
        result = func_1(c1, c2, c3, c4)
        results.append(result)
    for result in results:
        print(result)



- Annotated Code: 
if __name__ == '__main__':
    func_2()

#Function 1:
#State of the program right berfore the function call: c1, c2, c3, c4 are non-negative integers such that 0 <= c1, c2, c3, c4 <= 10^6 and the sum of the elements in each test case does not exceed 4 * 10^6.
def func_1(c1, c2, c3, c4):
    MOD = 998244353
    dp = [[(0) for _ in range(4)] for _ in range(max(c1, c2, c3, c4) + 1)]
    dp[0][0] = 1
    for i in range(1, max(c1, c2, c3, c4) + 1):
        if i <= c1:
            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]) % MOD
        
        if i <= c2:
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2] + dp[i - 1][3]) % MOD
        
        if i <= c3:
            dp[i][2] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][3]) % MOD
        
        if i <= c4:
            dp[i][3] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD
        
    #State of the program after the  for loop has been executed: Output State: **`i` is equal to `max(c1, c2, c3, c4) + 1`, `dp[max(c1, c2, c3, c4) + 1][0]` is \(((dp[max(c1, c2, c3, c4)][1] + dp[max(c1, c2, c3, c4)][2] + dp[max(c1, c2, c3, c4)][3]) \% MOD\), `dp[max(c1, c2, c3, c4) + 1][1]` is \(((dp[max(c1, c2, c3, c4)][0] + dp[max(c1, c2, c3, c4)][2] + dp[max(c1, c2, c3, c4)][3]) \% MOD\), `dp[max(c1, c2, c3, c4) + 1][2]` is \(((dp[max(c1, c2, c3, c4)][0] + dp[max(c1, c2, c3, c4)][1] + dp[max(c1, c2, c3, c4)][3]) \% MOD\), `dp[max(c1, c2, c3, c4) + 1][3]` is \(((dp[max(c1, c2, c3, c4)][0] + dp[max(c1, c2, c3, c4)][1] + dp[max(c1, c2, c3, c4)][2]) \% MOD\), and all other `dp[i][j]` where `i > max(c1, c2, c3, c4)` and `0 ≤ j ≤ 3` are equal to \(((dp[0][0] + dp[0][2] + dp[0][3]) \% MOD\).
    #
    #Explanation:
    #- The loop iterates from `i = 1` to `i = max(c1, c2, c3, c4)`.
    #- For each iteration, the loop updates the `dp` table based on the conditions `i <= c1`, `i <= c2`, `i <= c3`, and `i <= c4`.
    #- After the loop completes, `i` will be equal to `max(c1, c2, c3, c4) + 1`.
    #- The values of `dp[i][0]`, `dp[i][1]`, `dp[i][2]`, and `dp[i][3]` will be the cumulative sums computed during the loop, modulo `MOD`.
    #- All other `dp[i][j]` where `i > max(c1, c2, c3, c4)` will be reset to \(((dp[0][0] + dp[0][2] + dp[0][3]) \% MOD\), as no further updates are made beyond `i = max(c1, c2, c3, c4)`.
    total_ways = sum(dp[max(c1, c2, c3, c4)]) % MOD
    return total_ways
    #The program returns total_ways which is the sum of dp[max(c1, c2, c3, c4)][0], dp[max(c1, c2, c3, c4)][1], dp[max(c1, c2, c3, c4)][2], and dp[max(c1, c2, c3, c4)][3], modulo MOD.
#Overall this is what the function does:The function `func_1` accepts four non-negative integer parameters `c1`, `c2`, `c3`, and `c4`. It constructs a dynamic programming table `dp` to compute the number of ways to achieve a certain state based on the given constraints. The table `dp` is initialized such that `dp[0][0] = 1`, indicating one way to achieve a state with zero items using zero counts. The function then iterates through possible values up to `max(c1, c2, c3, c4)` and updates the table according to specific conditions. After the loop, the function calculates the sum of the last row of the `dp` table (`dp[max(c1, c2, c3, c4)]`) and returns this sum modulo `998244353`. The function handles edge cases where some `ci` values are zero, ensuring that the corresponding entries in the `dp` table are correctly updated based on the remaining `ci` values.

#Function 2:
#State of the program right berfore the function call: c1, c2, c3, and c4 are non-negative integers representing the number of elements of each type, where 0 <= c1, c2, c3, c4 <= 10^6.
def func_2():
    MOD = 998244353
    t = int(input())
    results = []
    for _ in range(t):
        c1, c2, c3, c4 = map(int, input().split())
        
        result = func_1(c1, c2, c3, c4)
        
        results.append(result)
        
    #State of the program after the  for loop has been executed: `c1` is an input integer, `c2` is an input integer, `c3` is an input integer, `c4` is an input integer, `MOD` is 998244353, `t` is 0, `results` is a list containing the return values of `func_1(c1, c2, c3, c4)` executed `t` times.
    for result in results:
        print(result)
        
    #State of the program after the  for loop has been executed: `c1` is an input integer, `c2` is an input integer, `c3` is an input integer, `c4` is an input integer, `MOD` is 998244353, `t` is 1, `results` is a list containing the return values of `func_1(c1, c2, c3, c4)` executed `t` times.
#Overall this is what the function does:The function `func_2` reads multiple sets of four non-negative integers (c1, c2, c3, c4) from standard input, calls another function `func_1` with these integers, collects the results in a list, and prints each result. The function does not accept any parameters and does not return a value. The final state of the program includes the list of results after processing all inputs, the modulus constant `MOD` set to 998244353, and the variable `t` set to the number of input sets processed. Potential edge cases include when `t` is 0, in which case no results are collected or printed. Additionally, the function assumes valid integer inputs within the specified range; handling of invalid inputs such as non-integer or out-of-range values is not addressed in the provided code.




Beggining of Original Assessment: 
Reasoning:
1. **Problem Understanding**: The problem involves constructing a one-dimensional chain using elements of four different types, where each type can appear multiple times. Each element can connect to another only if their adjacent connections are opposites. The goal is to calculate the number of ways to form a single continuous chain using all available elements.
2. **Dynamic Programming Approach**: The solution uses dynamic programming to track the number of ways to construct a chain of length `i` using elements of the four types. This approach correctly models the constraints and the rules for connections between elements.
3. **Initialization and State Transitions**:
   - `dp[i][j]` represents the number of ways to construct a chain of length `i` ending with element type `j`.
   - The initial state `dp[0][0] = 1` means there's one way to have a chain of length 0 (an empty chain).
   - For each element type, the transition updates the count of ways to form chains ending with that type, considering the valid connections from previous states.
4. **Boundary Conditions and Constraints**:
   - The function correctly handles the boundary conditions and constraints by checking if the current index is within the bounds of the available elements (`i <= c1`, `i <= c2`, etc.).
   - The result is calculated modulo `998244353` to handle large numbers.
5. **Input Handling**: Function `func_2` reads the input and processes each test case, calling `func_1` for each and collecting the results. It then prints the results for each test case.

Given the above reasoning, the program appears to correctly implement the logic required to solve the problem as described.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

