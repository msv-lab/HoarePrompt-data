
You are a program verifier. Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the programâ€™s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
The two versions are different problems. You may want to read both versions.
You can make hacks only if both versions are solved.

You are given two positive integers n , m .

Calculate the number of ordered pairs (a, b) satisfying the following
conditions:

  * 1\le a\le n , 1\le b\le m ; 
  * a+b is a multiple of b \cdot \gcd(a,b) . 

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1\le t\le 10^4 ). The description of the test cases follows.

The first line of each test case contains two integers n , m (1\le n,m\le 2
\cdot 10^6 ).

It is guaranteed that neither the sum of n nor the sum of m over all test
cases exceeds 2 \cdot 10^6 .

Output

For each test case, print a single integer: the number of valid pairs.

Example

Input

    6
    
    1 1
    
    2 3
    
    3 5
    
    10 8
    
    100 1233
    
    1000000 1145141

Output

    1
    3
    4
    14
    153
    1643498
    
Note

In the first test case, only (1,1) satisfies the conditions.

In the fourth test case,
(1,1),(2,1),(2,2),(3,1),(4,1),(5,1),(6,1),(6,2),(6,3),(7,1),(8,1),(9,1),(10,1),(10,2)
satisfy the conditions.

# Functions with Execution Summary:
Function number 1 :
 Code:
 '''
def func_1(a, b):
    while b != 0:
        (a, b) = (b, a % b)
    return a
''' 

 Output hints for function1:  The function `func_1` accepts two positive integer parameters `a` and `b`, where \(1 \leq a \leq n\) and \(1 \leq b \leq m\), and returns their greatest common divisor (GCD). The function uses the Euclidean algorithm to compute the GCD iteratively until `b` becomes zero, at which point `a` holds the GCD of the initial values of `a` and `b`. After the function completes, `a` is the GCD of the initial `a` and `b`, and `b` is set to 0. This process handles all edge cases, including when one of the inputs is 1 or when `a` and `b` are equal. There are no missing functionalities in the provided code.
Function number 2 :
 Code:
 '''
def func_2(n, m):
    count = 0
    for a in range(1, n + 1):
        for b in range(1, m + 1):
            if (a + b) % (b * func_1(a, b)) == 0:
                count += 1
    return count
''' 

 Output hints for function2:  The function `func_2` accepts two positive integers `n` and `m` as parameters, where \(1 \leq n, m \leq 2 \times 10^6\). It iterates over all pairs of integers `(a, b)` where \(1 \leq a \leq n\) and \(1 \leq b \leq m\). For each pair, it checks if the condition \((a + b) \% (b \times \text{func}_1(a, b)) == 0\) holds true. If the condition is met, it increments the counter `count`. After evaluating all possible pairs, the function returns the final value of `count`, which represents the total number of times the given condition was satisfied. The function does not handle any edge cases explicitly within its body, but the condition \((a + b) \% (b \times \text{func}_1(a, b)) == 0\) could potentially fail due to the value returned by `func_1(a, b)`. However, the function itself does not provide any additional logic to handle invalid values returned by `func_1(a, b)`.


# Your response:
Reasoning:  
Correctness: **True** or **False**

