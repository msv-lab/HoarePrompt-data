
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
You have some cards. An integer between 1 and n is written on each card:
specifically, for each i from 1 to n , you have a_i cards which have the
number i written on them.

There is also a shop which contains unlimited cards of each type. You have k
coins, so you can buy k new cards in total, and the cards you buy can contain
any integer between 1 and n .

After buying the new cards, you rearrange all your cards in a line. The score
of a rearrangement is the number of (contiguous) subarrays of length n which
are a permutation of [1, 2, \ldots, n] . What's the maximum score you can get?

Input

Each test contains multiple test cases. The first line contains the number of
test cases t\ (1\le t\le 100) . The description of the test cases follows.

The first line of each test case contains two integers n , k (1\le n \le 2
\cdot 10^5 , 0\le k \le 10^{12} ) — the number of distinct types of cards and
the number of coins.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le 10^{12} ) — the number of cards of type i you have at the
beginning.

It is guaranteed that the sum of n over all test cases does not exceed 5 \cdot
10^5 .

Output

For each test case, output a single line containing an integer: the maximum
score you can get.

Example

Input

    8
    
    1 10
    
    1
    
    2 4
    
    8 4
    
    3 4
    
    6 1 8
    
    3 9
    
    7 6 2
    
    5 3
    
    6 6 7 4 6
    
    9 7
    
    7 6 1 7 6 2 4 3 3
    
    10 10
    
    1 3 1 2 1 9 3 5 7 5
    
    9 8
    
    5 8 7 5 1 3 2 9 8

Output

    11
    15
    15
    22
    28
    32
    28
    36
    
Note

In the first test case, the final (and only) array we can get is [1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1] (including 11 single 1 s), which contains 11 subarrays
consisting of a permutation of [1] .

In the second test case, we can buy 0 cards of type 1 and 4 cards of type 2 ,
and then we rearrange the cards as following: [1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
1, 2, 1, 2, 1, 2] . There are 8 subarrays equal to [1, 2] and 7 subarrays
equal to [2, 1] , which make a total of 15 subarrays which are a permutation
of [1, 2] . It can also be proved that this is the maximum score we can get.

In the third test case, one of the possible optimal rearrangements is [3, 3,
1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 3] .

- Program: 
def func_1(cards, coins):
    n = len(cards)
    max_score = 0
    for i in range(1, n + 1):
        num_cards = cards[i - 1]
        if num_cards > 0:
            remaining_coins = coins - (n - num_cards)
            if remaining_coins >= 0:
                score = num_cards * n
                remaining_cards = [c for c in cards if c != i]
                remaining_cards.append(remaining_coins)
                score += func_1(remaining_cards, remaining_coins)
                max_score = max(max_score, score)
    return max_score



- Annotated Code: 
#State of the program right berfore the function call: cards is a list of n integers representing the initial number of cards of each type, and coins is a non-negative integer representing the number of coins available for buying additional cards. Each integer in cards is between 1 and 10^12, inclusive, and n is between 1 and 2 * 10^5.
def func_1(cards, coins):
    n = len(cards)
    max_score = 0
    for i in range(1, n + 1):
        num_cards = cards[i - 1]
        
        if num_cards > 0:
            remaining_coins = coins - (n - num_cards)
            if remaining_coins >= 0:
                score = num_cards * n
                remaining_cards = [c for c in cards if c != i]
                remaining_cards.append(remaining_coins)
                score += func_1(remaining_cards, remaining_coins)
                max_score = max(max_score, score)
        
    #State of the program after the  for loop has been executed: Let's analyze the given loop and determine the final state of the variables after all iterations of the loop have finished.
    #
    #### Initial State:
    #- `cards` is a list of \( n \) integers representing the initial number of cards of each type.
    #- `coins` is a non-negative integer representing the number of coins available for buying additional cards.
    #- `max_score` is 0.
    #
    #### Loop Code:
    #```python
    #for i in range(1, n + 1):
    #    num_cards = cards[i - 1]
    #    if num_cards > 0:
    #        remaining_coins = coins - (n - num_cards)
    #        if remaining_coins >= 0:
    #            score = num_cards * n
    #            remaining_cards = [c for c in cards if c != i]
    #            remaining_cards.append(remaining_coins)
    #            score += func_1(remaining_cards, remaining_coins)
    #            max_score = max(max_score, score)
    #```
    #
    #### Step-by-Step Analysis:
    #
    #1. **Understanding the Loop Logic:**
    #   - The loop iterates over each index \( i \) from 1 to \( n \).
    #   - For each iteration, it checks if the number of cards of the current type (`num_cards`) is greater than 0.
    #   - If `num_cards` is greater than 0, it calculates the remaining coins after buying \( n - num_cards \) more cards.
    #   - If the remaining coins are non-negative, it calculates the score based on the current number of cards and the function `func_1`.
    #   - It updates `max_score` with the maximum of the current `max_score` and the calculated `score`.
    #
    #2. **Final State After All Iterations:**
    #   - After all iterations, the loop will have considered each type of card (from 1 to \( n \)) where the number of cards is greater than 0.
    #   - The `max_score` will be the highest score achieved across all iterations where the conditions were met.
    #
    #### Final Output State:
    #
    #- `i` will be \( n \) because the loop will iterate up to \( n \) if all conditions are met.
    #- `n` must be greater than 0.
    #- `cards` will remain the same as the initial list since no modifications are made to the original list inside the loop.
    #- `coins` will remain the same as the initial value since no modifications are made to the original value inside the loop.
    #- `max_score` will be the highest score obtained from all valid iterations where the conditions were met.
    #
    #Thus, the final output state is:
    #
    #**Output State:**
    #- `i` is `n`, `n` must be greater than 0, `cards` is a list of `n` integers, `coins` is a non-negative integer, `max_score` is the maximum score obtained from all valid iterations where the conditions were met.
    return max_score
    #max_score is the maximum score obtained from all valid iterations where the conditions were met, `i` is `n`, `n` must be greater than 0, `cards` is a list of `n` integers, `coins` is a non-negative integer
#Overall this is what the function does:The function `func_1` accepts a list `cards` containing `n` integers representing the initial number of cards of each type, and a non-negative integer `coins` representing the number of coins available for buying additional cards. The function recursively calculates the maximum score possible by considering each type of card individually. For each type of card, it checks if buying more cards of that type is feasible with the current coins. If so, it calculates a score and recursively calls itself with the updated state (reduced coins and modified card count). The function keeps track of the maximum score achieved and returns this value.


Beggining of Original Assessment: 
Reasoning:

The provided function `func_1` attempts to recursively calculate the maximum score by trying to add more cards of a specific type and then calculating the score for the remaining cards. However, there are several issues with the logic and approach of the function:

1. **Incorrect Base Case and Recursive Logic**: The function does not handle the base case properly and does not consider the constraints effectively. It tries to add cards of a specific type and then recursively calculate the score for the remaining cards, but it does not ensure that the number of coins is correctly used and the result is maximized.

2. **Overcomplicating the Problem**: The problem requires maximizing the score by buying up to `k` additional cards and arranging them optimally. The recursive approach in the provided function is overly complex and does not guarantee the optimal solution. Instead, a dynamic programming approach or a greedy algorithm might be more suitable for this problem.

3. **Handling Edge Cases**: The function does not handle edge cases such as when `k` is zero or when there are no additional cards to buy (`num_cards == n`). It also does not account for the fact that buying extra cards of a certain type could help fill gaps in the sequence to form more valid subarrays.

Given these issues, the provided function does not correctly solve the problem as stated. A more appropriate approach would involve a different algorithm, likely involving dynamic programming to keep track of the number of valid subarrays as the cards are rearranged.

Correctness: **False**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

