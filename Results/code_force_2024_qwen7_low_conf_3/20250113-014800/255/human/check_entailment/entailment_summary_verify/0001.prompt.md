
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the programâ€™s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
There are n slimes placed in a line. The slimes are numbered from 1 to n in
order from left to right. The size of the i -th slime is a_i .

Every second, the following happens: exactly one slime eats one of its
neighbors and increases its size by the eaten neighbor's size. A slime can eat
its neighbor only if it is strictly bigger than this neighbor. If there is no
slime which is strictly bigger than one of its neighbors, the process ends.

For example, suppose n = 5 , a = [2, 2, 3, 1, 4] . The process can go as
follows:

  * first, the 3 -rd slime eats the 2 -nd slime. The size of the 3 -rd slime becomes 5 , the 2 -nd slime is eaten. 
  * then, the 3 -rd slime eats the 1 -st slime (they are neighbors since the 2 -nd slime is already eaten). The size of the 3 -rd slime becomes 7 , the 1 -st slime is eaten. 
  * then, the 5 -th slime eats the 4 -th slime. The size of the 5 -th slime becomes 5 , the 4 -th slime is eaten. 
  * then, the 3 -rd slime eats the 5 -th slime (they are neighbors since the 4 -th slime is already eaten). The size of the 3 -rd slime becomes 12 , the 5 -th slime is eaten. 

For each slime, calculate the minimum number of seconds it takes for this
slime to be eaten by another slime (among all possible ways the process can
go), or report that it is impossible.

Input

The first line contains a single integer t (1 \le t \le 10^4 ) â€” the number of
test cases.

The first line of each test case contains a single integer n (1 \le n \le 3
\cdot 10^5 ) â€” the number of slimes.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^9
).

The sum of n over all test cases doesn't exceed 3 \cdot 10^5 .

Output

For each test case, print n integers. The i -th integer should be equal to the
minimum number of seconds it takes for the i -th slime to be eaten by another
slime or -1 if it is impossible.

Example

Input

    4
    
    4
    
    3 2 4 2
    
    3
    
    1 2 3
    
    5
    
    2 2 3 1 1
    
    7
    
    4 2 3 6 1 1 8

Output

    2 1 2 1 
    1 1 -1 
    2 1 -1 1 2 
    2 1 1 3 1 1 4

- Program:
import bisect

for _ in range(int(input())):
    func_1()

def func_1():
    n = int(input())
    arr = list(map(int, input().split()))
    pref = [arr[i] for i in range(n)]
    for i in range(1, n):
        pref[i] += pref[i - 1]
    ind = -1
    ans = [10 ** 9 for i in range(n)]
    for i in range(n):
        curr = pref[i] - 2 * arr[i]
        ind1 = bisect.bisect_left(pref, curr)
        ind = min(ind, ind1)
        if ind >= 0 and curr > 0:
            ans[i] = i - ind
        if i - 1 >= 0 and arr[i] != arr[i - 1]:
            if arr[i] < arr[i - 1]:
                ans[i] = 1
                ind = i
    ind = n
    for i in range(n - 1, -1, -1):
        curr = pref[i] + arr[i] + 1
        ind1 = bisect.bisect_left(pref, curr)
        ind = max(ind, ind1)
        if ind < n and curr <= pref[-1]:
            ans[i] = min(ans[i], ind - i)
        if i + 1 < n and arr[i] != arr[i + 1]:
            if arr[i] < arr[i + 1]:
                ans[i] = 1
                ind = i
    for i in range(n):
        if ans[i] == 10 ** 9:
            ans[i] = -1
    print(*ans)



- Function Summary: 
The function processes an input list `arr` of length `n` to generate a list `ans` of the same length. The function computes the prefix sums of `arr` and then iterates through the list to determine the minimum distance to a prefix sum that meets certain conditions. Specifically:

1. It calculates the prefix sums of `arr` and stores them in the list `pref`.
2. It initializes `ans` as a list of `n` elements, each set to a very large number (`10

Beggining of Original Assessment: 
Reasoning:  
The provided Python program attempts to solve the problem of determining the minimum number of seconds it takes for each slime to be eaten by another slime. Let's break down the logic of the program and verify if it correctly implements the solution based on the problem statement.

1. **Input Handling**: The program correctly reads the number of test cases and processes each test case individually.
2. **Prefix Sum Calculation**: The program calculates the prefix sum array `pref`, where `pref[i]` represents the cumulative size of all slimes up to index `i`. This is used to efficiently determine when a slime can eat another slime.
3. **Forward Pass**: During the forward pass, the program tries to find the earliest possible time a slime at position `i` can be eaten by checking if any previous slime can eat it. It uses binary search (`bisect_left`) to find the appropriate position in the prefix sum array.
4. **Backward Pass**: Similarly, during the backward pass, the program checks if a slime can be eaten by a future slime. This ensures that we cover all possible scenarios.
5. **Edge Cases**: The program handles edge cases such as slimes with the same size by setting their answer to 1, indicating they will be eaten immediately.

The program iterates through each slime and uses binary search to efficiently find the nearest possible eater, ensuring the solution is computed within the required constraints.

However, upon closer inspection, the logic for calculating the minimum number of seconds for each slime to be eaten seems to have some flaws. Specifically, the logic for updating the `ind` variable and the final check for eating conditions might not accurately reflect the problem's requirements. Additionally, the program does not explicitly handle the scenario where no slime can eat another, leading to potential incorrect outputs.

Given these observations, the provided program does not fully satisfy the requirements of the problem as described. Therefore, the correctness of the given program is False.

Correctness: **False**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

