
You are a program verifier. Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Vladislav has n non-negative integers, and he wants to divide all of them into
several groups so that in any group, any pair of numbers does not have
matching bit values among bits from 1 -st to 31 -st bit (i.e., considering the
31 least significant bits of the binary representation).

For an integer k , let k_2(i) denote the i -th bit in its binary
representation (from right to left, indexing from 1). For example, if k=43 ,
since 43=101011_2 , then 43_2(1)=1 , 43_2(2)=1 , 43_2(3)=0 , 43_2(4)=1 ,
43_2(5)=0 , 43_2(6)=1 , 43_2(7)=0 , 43_2(8)=0, \dots, 43_2(31)=0 .

Formally, for any two numbers x and y in the same group, the condition x_2(i)
\neq y_2(i) must hold for all 1 \leq i < 32 .

What is the minimum number of groups Vlad needs to achieve his goal? Each
number must fall into exactly one group.

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains a single integer n (1 \leq n \leq 2
\cdot 10^5 ) — the total number of integers.

The second line of each test case contains n given integers a_1, \ldots, a_n
(0 \leq a_j < 2^{31} ).

The sum of n over all test cases in a test does not exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer — the minimum number of groups
required to satisfy the condition.

Example

Input

    9
    
    4
    
    1 4 3 4
    
    2
    
    0 2147483647
    
    5
    
    476319172 261956880 2136179468 1671164475 1885526767
    
    3
    
    1335890506 811593141 1128223362
    
    4
    
    688873446 627404104 1520079543 1458610201
    
    4
    
    61545621 2085938026 1269342732 1430258575
    
    4
    
    0 0 2147483647 2147483647
    
    3
    
    0 0 2147483647
    
    8
    
    1858058912 289424735 1858058912 2024818580 1858058912 289424735 122665067 289424735

Output

    4
    1
    3
    2
    2
    3
    2
    2
    4
    
Note

In the first test case, any two numbers have the same last 31 bits, so we need
to place each number in its own group.

In the second test case, a_1=0000000000000000000000000000000_2 ,
a_2=1111111111111111111111111111111_2 so they can be placed in the same group
because a_1(i) \ne a_2(i) for each i between 1 and 31 , inclusive.

# Functions with Execution Summary:
if __name__ == '__main__':
    func_3()

Function number 1 :
 Code:
 '''
def func_1(x, y):
    for i in range(1, 32):
        if x >> i - 1 & 1 == y >> i - 1 & 1:
            return False
    return True
''' 

 Output hints for function1:  The function `func_1` accepts two parameters `x` and `y`, both non-negative integers less than \(2^{31}\). It checks whether the binary representation of `x` is identical to the binary representation of `y`. If all corresponding bits of `x` and `y` match, the function returns `True`; otherwise, it returns `False`. The function iterates through all 31 bits (from 0 to 30) of the integers `x` and `y`, comparing each bit. If any bit differs, the function immediately returns `False`. If all bits match, the function returns `True`.
Function number 2 :
 Code:
 '''
def func_2(n, integers):
    groups = []
    for num in integers:
        placed = False
        for group in groups:
            if func_1(num, group[0]):
                group.append(num)
                placed = True
                break
        if not placed:
            groups.append([num])
    return len(groups)
''' 

 Output hints for function2:  The function `func_2` accepts two parameters: `n` (a positive integer) and `integers` (a list of non-negative integers). It processes the `integers` list to form groups based on a specific condition defined by the function `func_1`. For each integer in the `integers` list, it checks whether the integer can be added to an existing group using `func_1`. If the integer can be added to an existing group, it is appended to that group; otherwise, a new group is created. After processing all integers, the function returns the total number of groups formed. Potential edge cases include empty input lists or `n` being zero, in which case no groups would be formed and the function would return 0. There is no missing functionality as per the provided code.
Function number 3 :
 Code:
 '''
def func_3():
    t = int(input())
    for _ in range(t):
        n = int(input())
        integers = list(map(int, input().split()))
        print(func_2(n, integers))
''' 

 Output hints for function3:  The function processes multiple test cases. For each test case, it reads an integer `t` representing the number of test cases, then reads an integer `n` representing the length of the list `integers`, followed by a list of `n` non-negative integers. It calls the function `func_2(n, integers)` to process the list and prints the result of each test case. After executing the function for all test cases, the final state of the program includes the output of `func_2(n, integers)` for each test case.


# Your response:
Reasoning:  
Correctness: **True** or **False**

