
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Patrick calls a substring^\dagger of a binary string^\ddagger good if this
substring contains exactly one 1.

Help Patrick count the number of binary strings s such that s contains exactly
n good substrings and has no good substring of length strictly greater than k
. Note that substrings are differentiated by their location in the string, so
if s = 1010 you should count both occurrences of 10.

^\dagger A string a is a substring of a string b if a can be obtained from b
by the deletion of several (possibly, zero or all) characters from the
beginning and several (possibly, zero or all) characters from the end.

^\ddagger A binary string is a string that only contains the characters 0 and
1.

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 2500 ) — the number of test cases. The description of
the test cases follows.

The only line of each test case contains two integers n and k (1 \leq n \leq
2500 , 1 \leq k \leq n ) — the number of required good substrings and the
maximum allowed length of a good substring.

It is guaranteed that the sum of n over all test cases does not exceed 2500 .

Output

For each test case, output a single integer — the number of binary strings s
such that s contains exactly n good substrings and has no good substring of
length strictly greater than k . Since this integer can be too large, output
it modulo 998\,244\,353 .

Example

Input

    6
    
    1 1
    
    3 2
    
    4 2
    
    5 4
    
    6 2
    
    2450 2391

Output

    1
    3
    5
    12
    9
    259280854
    
Note

In the first test case, the only suitable binary string is 1. String 01 is not
suitable because it contains a substring 01 with length 2 > 1 .

In the second test case, suitable binary strings are 011, 110 and 111.

In the third test case, suitable binary strings are 101, 0110, 0111, 1110, and
1111.

- Program: 
MOD = 998244353
t = int(input())
for _ in range(t):
    (n, k) = map(int, input().split())
    print(func_1(n, k))

def func_1(n, k):
    dp = [[0] * (n + 1) for _ in range(k + 1)]
    dp[1][1] = 1
    for i in range(2, k + 1):
        for j in range(1, n + 1):
            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % MOD
    result = sum((dp[i][n] for i in range(1, k + 1))) % MOD
    return result



- Annotated Code: 
MOD = 998244353
t = int(input())
for _ in range(t):
    (n, k) = map(int, input().split())
    print(func_1(n, k))

#State of the program right berfore the function call: n and k are integers such that 1 <= n <= 2500 and 1 <= k <= n, and the sum of all n values over all test cases does not exceed 2500.
def func_1(n, k):
    dp = [([0] * (n + 1)) for _ in range(k + 1)]
    dp[1][1] = 1
    for i in range(2, k + 1):
        for j in range(1, n + 1):
            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % MOD
        
    #State of the program after the  for loop has been executed: `i` is `k + 1`, `k` is a positive integer, `n` is a positive integer, `dp[i][j]` is the cumulative sum of binomial coefficients modulo `MOD` for all `j` from 1 to `n` for all valid `i` where `1 <= i <= k`.
    result = sum(dp[i][n] for i in range(1, k + 1)) % MOD
    return result
    #The program returns result which is the sum of dp[i][n] for all i from 1 to k modulo MOD



Beggining of Original Assessment: 
Reasoning:

The program is designed to solve the problem of counting the number of binary strings that contain exactly `n` good substrings and have no good substring of length strictly greater than `k`. To verify the correctness of the program, we need to analyze its logic and compare it with the expected solution.

1. **Initialization**: The program initializes a DP table `dp` where `dp[i][j]` represents the number of binary strings of length `i` that contain exactly `j` good substrings.

2. **Base Case**: `dp[1][1] = 1` means there is exactly one way to form a string of length 1 with one good substring (which is "1").

3. **DP Table Filling**:
   - For each length `i` from 2 to `k`, the program updates the DP table based on whether the new character added is '0' or '1'.
   - If the last character is '0', the number of good substrings remains the same as the previous length.
   - If the last character is '1', the number of good substrings increases by 1.

4. **Result Calculation**: The final result is calculated by summing up the values in the DP table for lengths from 1 to `k` and having exactly `n` good substrings.

5. **Modulo Operation**: Since the result can be very large, it is taken modulo `998244353`.

Given the problem constraints and the approach used, the program appears to correctly implement the dynamic programming solution to count the desired binary strings. The logic for updating the DP table and calculating the final result seems appropriate.

Therefore, the given program is correct.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

