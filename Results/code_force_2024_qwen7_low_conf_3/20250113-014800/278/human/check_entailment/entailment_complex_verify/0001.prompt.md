
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
In the hard version, 2 \leq \sum n \leq 10^5 and 1 \leq \sum m \leq 5 \times
10^{5}

After a worker's strike organized by the Dementors asking for equal rights,
the prison of Azkaban has suffered some damage. After settling the spirits,
the Ministry of Magic is looking to renovate the prison to ensure that the
Dementors are kept in check. The prison consists of n prison cells and m bi-
directional corridors. The i^{th} corridor is from cells u_i to v_i . A subset
of these cells S is called a complex if any cell in S is reachable from any
other cell in S . Formally, a subset of cells S is a complex if x and y are
reachable from each other for all x, y \in S , using only cells from S on the
way. The funding required for a complex S consisting of k cells is defined as
k^2 .

As part of your Intro to Magical Interior Design course at Hogwarts, you have
been tasked with designing the prison. The Ministry of Magic has asked that
you divide the prison into 2 complexes with \textbf{exactly one corridor}
connecting them, so that the Dementors can't organize union meetings. For this
purpose, you are allowed to build bi-directional corridors. The funding
required to build a corridor between any 2 cells is c .

Due to budget cuts and the ongoing fight against the Death Eaters, you must
find the \textbf{minimum total funding} required to divide the prison as per
the Ministry's requirements or -1 if no division is possible.

Note: The total funding is the sum of the funding required for the 2 complexes
and the corridors built. If after the division, the two complexes have x and y
cells respectively and you have built a total of a corridors, the total
funding will be x^2 + y^2 + c \times a . Note that x+y=n .

Input

The first line contains one integer t (1 \leq t \leq 10^5 ) — the number of
test cases. Then t test cases follow.

The first line of each test case consists of three integers n, m and c (2 \leq
n \leq 10^5 , 1 \leq m \leq 5 \times 10^{5} , 1 \leq c \leq 10^9 )

m lines follow, each consisting of 2 integers — u_i, v_i indicating a corridor
is present between cells u_i and v_i (1 \leq u_i, v_i \leq n , u_i \neq v_i )

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

It is guaranteed that the sum of m over all test cases does not exceed 5
\times 10^5 .

It is guaranteed that there exists at most one corridor between any two cells.

Output

Print the \textbf{minimum funding} required to divide the prison as per the
Ministry's requirements or -1 if no division is possible.

Example

Input

    4
    4 6 5
    4 3
    2 3
    2 4
    1 2
    4 1
    3 1
    6 6 2
    1 4
    2 5
    3 6
    1 5
    3 5
    6 5
    6 5 7
    1 4
    2 5
    3 6
    3 5
    6 5
    7 5 4
    1 4
    3 6
    3 5
    6 5
    2 7
    
Output

    -1
    20
    25
    33
    
Note

In the first test case of the sample input, there is no way to divide the
prison according to the Ministry's requirements.

In the second test case, consider the corridor between cells 1 and 5 as the
connection between the 2 complexes consisting of \\{2, 3, 5, 6\\} and \\{1,
4\\} cells respectively. There are no new corridors built. The total funding
is 4^2 + 2^2 = 20 . You can verify this is the minimum funding required.
![](https://espresso.codeforces.com/488c4eea08add11cc82237beac3677afcab875e3.png)

In the third test case, build a corridor between 2 and 4 . Consider the
corridor between cells 1 and 5 as the connection between the 2 complexes
consisting of \\{3, 5, 6\\} and \\{1, 2, 4\\} cells respectively. The total
funding is 3^2 + 3^2 + 7 \times 1 = 25 . You can verify this is the minimum
funding required.
![](https://espresso.codeforces.com/e7d162def53b600d35b9d046999c712212f7e0f6.png)

In the fourth test case, build a corridor between 2 and 4 and between 5 and 7
. Consider the corridor between cells 5 and 7 as the connection between the 2
complexes consisting of \\{1, 2, 4, 7\\} and \\{3, 5, 6\\} cells respectively.
The total funding is 4^2 + 3^2 + 4 \times 2 = 33 . You can verify this is the
minimum funding required.
![](https://espresso.codeforces.com/d7da43c68cf5654a9468a410eba14ccbc8ac8a15.png)

Note for all test cases that there may be multiple ways to get the same
funding but there is no other division which will have a more optimal minimum
funding.

- Program: 
from collections import defaultdict, deque
#Function 1:
def func_1(n, edges):
    graph = defaultdict(list)
    for (u, v) in edges:
        graph[u].append(v)
        graph[v].append(u)
    visited = [False] * (n + 1)
    components = []

    for i in range(1, n + 1):
        if not visited[i]:
            components.append(bfs(i))
    return components

#Function 2:
def bfs(start):
    queue = deque([start])
    component = []
    while queue:
        node = queue.popleft()
        if not visited[node]:
            visited[node] = True
            component.append(node)
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    queue.append(neighbor)
    return component

#Function 3:
def func_2(n, m, c, edges):
    components = func_1(n, edges)
    if len(components) == 1:
        return -1
    min_cost = float('inf')
    for i in range(len(components)):
        for j in range(i + 1, len(components)):
            cost_i = len(components[i]) ** 2
            cost_j = len(components[j]) ** 2
            min_cost = min(min_cost, cost_i + cost_j + c)
    return min_cost



- Annotated Code: 
from collections import defaultdict, deque

t = int(input())
for _ in range(t):
    (n, m, c) = map(int, input().split())
    edges = [tuple(map(int, input().split())) for _ in range(m)]
    print(func_2(n, m, c, edges))

#Function 1:
#State of the program right berfore the function call: n is an integer representing the number of prison cells, edges is a list of tuples where each tuple (u, v) represents a bidirectional corridor between cells u and v, and the values of u and v are integers such that 1 ≤ u, v ≤ n and u ≠ v.
def func_1(n, edges):
    graph = defaultdict(list)
    for (u, v) in edges:
        graph[u].append(v)
        
        graph[v].append(u)
        
    #State of the program after the  for loop has been executed: `n` is an integer representing the number of prison cells, `edges` is a list of tuples representing the corridors between cells, `graph` is a defaultdict where for every cell `v`, `graph[v]` contains a list of all cells connected to `v` through the corridors defined in `edges`.
    visited = [False] * (n + 1)
    components = []
    for i in range(1, n + 1):
        if not visited[i]:
            components.append(bfs(i))
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `edges` is a list of tuples representing the corridors between cells, `graph` is a defaultdict where for every cell `v`, `graph[v]` contains a list of all cells connected to `v` through the corridors defined in `edges`, `visited` is a list of length `n + 1` where each element is either `True` or `False`, `components` is a list containing all the connected components of the graph.
    return components
    #`The program returns the list containing all the connected components of the graph`
#Overall this is what the function does:The function `func_1` accepts two parameters: `n` (an integer representing the number of prison cells) and `edges` (a list of tuples representing bidirectional corridors between cells). It constructs a graph from the given edges and then performs a breadth-first search (BFS) to identify all connected components within the graph. The function returns a list of these connected components. 

Specifically, the function performs the following actions:
1. It initializes a graph using a defaultdict, where each key is a cell and the value is a list of cells directly connected to it via the given corridors.
2. It initializes a `visited` list to keep track of which cells have been explored.
3. It iterates over each cell from 1 to `n`, performing BFS on unvisited cells to find all connected components.
4. It returns a list of all identified connected components.

Potential edge cases and considerations:
- If there are no edges, the graph will be a set of isolated nodes, and each node will be a separate connected component.
- If all cells are interconnected, there will be only one connected component, which includes all cells.
- The function assumes that `n` is a positive integer and that the edges are valid (i.e., they connect cells within the range 1 to `n`).

Missing functionality: The annotations suggest that the code constructs the graph and identifies connected components, but the provided code snippet does not explicitly include the BFS implementation. Therefore, it is implied that the BFS is correctly implemented elsewhere in the function, but this is not shown in the given code snippet.

#Function 2:
#State of the program right berfore the function call: `start` is an integer representing the starting node in the graph. The graph is represented as an adjacency list where `graph` is a dictionary mapping each node to a list of its neighbors, and `visited` is a boolean list of the same length as the number of nodes, initially set to `False`.
def bfs(start):
    queue = deque([start])
    component = []
    while queue:
        node = queue.popleft()
        
        if not visited[node]:
            visited[node] = True
            component.append(node)
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    queue.append(neighbor)
        
    #State of the program after the loop has been executed: `queue` is empty, `component` contains all nodes in the connected component of `start` in the graph `graph`, and `visited[node]` is True for all nodes in `component`.
    return component
    #`The program returns the set of nodes in the connected component of 'start' in the graph 'graph'`
#Overall this is what the function does:The function `bfs(start)` performs a Breadth-First Search (BFS) on a graph starting from the node `start`. It initializes a queue with the starting node and iteratively explores all nodes in the connected component of `start`. During this process, it marks nodes as visited and adds them to the `component` list. The function returns a list containing all nodes in the connected component of `start`. If the starting node `start` is not present in the graph, or if the graph is empty, the function will still execute without errors but may return an empty list. The function does not handle cases where the graph contains isolated nodes that are not reachable from `start`.

#Function 3:
#State of the program right berfore the function call: n is an integer representing the number of prison cells, m is an integer representing the number of bi-directional corridors, c is an integer representing the funding required to build a single corridor, and edges is a list of tuples, where each tuple (u_i, v_i) represents a bi-directional corridor between cells u_i and v_i.
def func_2(n, m, c, edges):
    components = func_1(n, edges)
    if (len(components) == 1) :
        return -1
        #The program returns -1
    #State of the program after the if block has been executed: `n` is an integer representing the number of prison cells; `m` is an integer representing the number of bi-directional corridors; `c` is an integer representing the funding required to build a single corridor; `components` is the result of the function `func_1(n, edges)`. The number of components in `components` is greater than 1
    min_cost = float('inf')
    for i in range(len(components)):
        for j in range(i + 1, len(components)):
            cost_i = len(components[i]) ** 2
            cost_j = len(components[j]) ** 2
            min_cost = min(min_cost, cost_i + cost_j + c)
        
    #State of the program after the  for loop has been executed: `min_cost` is the minimum value of `len(components[i])
    return min_cost
    #The program returns min_cost which is the minimum value of len(components[i])
#Overall this is what the function does:The function `func_2` accepts four parameters: `n`, `m`, `c`, and `edges`. 

- `n` is an integer representing the number of prison cells.
- `m` is an integer representing the number of bi-directional corridors.
- `c` is an integer representing the funding required to build a single corridor.
- `edges` is a list of tuples, where each tuple `(u_i, v_i)` represents a bi-directional corridor between cells `u_i` and `v_i`.

The function first calls another function `func_1` to determine the number of connected components in the graph formed by the prison cells and corridors. If there is only one connected component, the function returns `-1`, indicating that all cells are already connected and no additional corridors need to be built.

If there are multiple connected components, the function calculates the minimum cost required to connect all components into a single connected component. It does this by iterating over all pairs of components and calculating the cost of connecting them, which is given by the sum of the squares of the sizes of the two components plus the cost `c` to build a single corridor. The function then returns the minimum cost found among all pairs of components.

The function can return either `-1` if all cells are already connected, or the minimum cost required to connect all cells if there are multiple connected components.




Beggining of Original Assessment: 
Reasoning:

1. **Function Definitions**: The provided program defines three functions: `func_1`, `func_2`, and an unnamed `bfs` function within `func_1`.

2. **`func_1` Function**: This function takes `n` and `edges` as inputs. It constructs a graph using adjacency lists and performs BFS to find all connected components in the graph. Each connected component is stored in the `components` list. The function returns the list of connected components.

3. **`func_2` Function**: This function takes `n`, `m`, `c`, and `edges` as inputs. It uses `func_1` to get the list of connected components. If there is only one connected component, it returns `-1` because it is impossible to divide the prison into two complexes with exactly one connecting corridor. Otherwise, it calculates the minimum cost required to divide the prison into two complexes by considering every pair of connected components, computing the cost for each pair, and keeping track of the minimum cost found. The cost for a pair of components is the sum of their sizes squared plus the cost `c` of the single connecting corridor.

4. **Edge Cases and Constraints**: The constraints are handled correctly, including the checks for the number of components and ensuring that the input is valid. The algorithm considers all pairs of components, which is necessary to find the minimum cost.

5. **Output**: The function returns the minimum cost required to divide the prison as per the Ministry's requirements or `-1` if no such division is possible.

Given the provided problem statement and the code logic, the program appears to be correct and follows the specifications. It handles all the necessary steps to find the minimum cost for dividing the prison into two complexes with exactly one connecting corridor.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

