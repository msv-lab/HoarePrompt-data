
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You can never buy enough happiness, so here we go again! In this version, you
can only buy h_i = 1 unit of happiness each month, but the number of months is
hugely increased. We are in the realm of quantum happiness and time dilation.

Being a physicist, Charlie likes to plan his life in simple and precise terms.

For the next m months, starting with no money, Charlie will work hard and earn
x pounds per month. For the i -th month (1 \le i \le m) , there'll be a single
opportunity of paying cost c_i pounds to obtain one unit of happiness. You
cannot buy more than one unit each month.

Borrowing is not allowed. Money earned in the i -th month can only be spent in
a later j -th month (j>i ).

Since physicists don't code, help Charlie find the maximum reachable units of
happiness.

Input

The first line of the input contains t (1 \leq t \leq 10^4 ) — the number of
test cases.

The first line of each test case contains two integers, m and x (1 \le m \le 2
\cdot 10^5 , 1 \le x \le 10^3 ) — the total number of months and the monthly
salary.

The second line of each test case contains m integers c_1, c_2, \dots, c_m (1
\leq c_i \leq 10^3 ) — the cost of one unit of happiness for each month.

It is guaranteed that sum of m over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, output one integer — the maximal amount of happiness
Charlie can get.

Example

Input

    6
    
    3 3
    
    2 2 2
    
    6 5
    
    2 2 8 2 6 8
    
    6 4
    
    4 10 3 8 6 10
    
    2 1
    
    1 1
    
    4 1
    
    4 1 3 1
    
    4 2
    
    1 3 4 3

Output

    2
    4
    3
    1
    2
    1
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
t = int(input())
for _ in range(t):
    (m, x) = map(int, input().split())
    costs = list(map(int, input().split()))
    print(func_1(m, x, costs))

#State of the program right berfore the function call: m is a positive integer representing the total number of months, x is a positive integer representing the monthly salary, and costs is a list of positive integers where costs[i] represents the cost to obtain one unit of happiness in the i-th month.
def func_1(m, x, costs):
    costs.sort(reverse=True)
    earnings = 0
    happiness = []
    for i in range(1, m + 1):
        earnings += x
        
        while costs and costs[-1] <= earnings:
            earnings -= costs[-1]
            happiness.append(1)
            costs.pop()
        
    #State of the program after the  for loop has been executed: ### Analysis and Determination of the Output State
    #
    #Given the initial state and the loop code, let's break down the loop's behavior and determine the final state of the variables after the loop has executed.
    #
    ##### Initial State:
    #- `m` is a positive integer representing the total number of months.
    #- `x` is a positive integer representing the monthly salary.
    #- `costs` is a list of positive integers sorted in descending order.
    #- `earnings` is 0.
    #- `happiness` is an empty list.
    #
    ##### Loop Code:
    #```python
    #for i in range(1, m + 1):
    #    earnings += x
    #    while costs and costs[-1] <= earnings:
    #        earnings -= costs[-1]
    #        happiness.append(1)
    #        costs.pop()
    #```
    #
    ##### Step-by-Step Analysis:
    #
    #1. **Loop Execution**:
    #   - The loop iterates from `i = 1` to `i = m`.
    #   - In each iteration, `earnings` is increased by `x`.
    #   - A `while` loop checks if the last element of `costs` is less than or equal to `earnings`.
    #     - If true, `earnings` is reduced by the last element of `costs`.
    #     - `happiness` appends a `1`.
    #     - The last element of `costs` is popped.
    #   - This process continues until the `while` loop condition is false.
    #
    #2. **Final State**:
    #   - After the loop completes, `i` will be `m`.
    #   - `earnings` will be the final value after adding `x` for each month and subtracting elements from `costs` as long as they are less than or equal to `earnings`.
    #   - `costs` will be an empty list because all elements will have been popped.
    #   - `happiness` will be a list containing `m` ones, as the `while` loop runs `m` times.
    #
    #3. **Edge Case: No Elements in `costs`**:
    #   - If `costs` is initially empty, the `while` loop will never run, and `earnings` will simply increase by `x*m`.
    #
    #### Final Output State:
    #
    #- `i` is `m`.
    #- `earnings` is the sum of `x` added for each month minus the sum of all elements in `costs` that were less than or equal to `earnings`.
    #- `costs` is an empty list.
    #- `m` remains the same.
    #- `x` remains the same.
    #- `happiness` is a list containing `m` ones.
    #
    #**Output State:**
    #```
    #Output State: i` is `m`, `earnings` is the final value after adding `x` for each month and subtracting elements from `costs` that are less than or equal to `earnings`, `costs` is an empty list, `m` remains the same, `x` remains the same, `happiness` is a list containing `m` ones.
    #```
    return len(happiness)
    #The program returns `m`, which is the number of months, and `happiness` is a list containing `m` ones.

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
