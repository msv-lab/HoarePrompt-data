
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
There are balls of n different colors; the number of balls of the i -th color
is a_i .

The balls can be combined into groups. Each group should contain at most 2
balls, and no more than 1 ball of each color.

Consider all 2^n sets of colors. For a set of colors, let's denote its value
as the minimum number of groups the balls of those colors can be distributed
into. For example, if there are three colors with 3 , 1 and 7 balls
respectively, they can be combined into 7 groups (and not less than 7 ), so
the value of that set of colors is 7 .

Your task is to calculate the sum of values over all 2^n possible sets of
colors. Since the answer may be too large, print it modulo 998\,244\,353 .

Input

The first line contains a single integer n (1 \le n \le 5000 ) — the number of
colors.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 5000 )
— the number of balls of the i -th color.

Additional constraint on input: the total number of balls doesn't exceed 5000
.

Output

Print a single integer — the sum of values of all 2^n sets of colors, taken
modulo 998\,244\,353 .

Examples

Input

    3
    
    1 1 2

Output

    11
    
Input

    1
    
    5

Output

    5
    
Input

    4
    
    1 3 3 7

Output

    76
    
Note

Consider the first example. There are 8 sets of colors:

  * for the empty set, its value is 0 ; 
  * for the set \\{1\\} , its value is 1 ; 
  * for the set \\{2\\} , its value is 1 ; 
  * for the set \\{3\\} , its value is 2 ; 
  * for the set \\{1,2\\} , its value is 1 ; 
  * for the set \\{1,3\\} , its value is 2 ; 
  * for the set \\{2,3\\} , its value is 2 ; 
  * for the set \\{1,2,3\\} , its value is 2 . 

So, the sum of values over all 2^n sets of colors is 11 .

- Program: 
n = int(input())
a = list(map(int, input().split()))
result = func_1(n, a)
print(result)

def func_1(n, a):
    MOD = 998244353
    total_value = 0
    for mask in range(1 << n):
        max_balls = 0
        for i in range(n):
            if mask & 1 << i != 0:
                max_balls = max(max_balls, a[i])
        total_value = (total_value + max_balls) % MOD
    return total_value



- Annotated Code: 
n = int(input())
a = list(map(int, input().split()))
result = func_1(n, a)
print(result)

#State of the program right berfore the function call: n is an integer such that 1 <= n <= 5000, and a is a list of n integers where 1 <= a_i <= 5000 for each i, and the sum of all elements in a does not exceed 5000.
def func_1(n, a):
    MOD = 998244353
    total_value = 0
    for mask in range(1 << n):
        max_balls = 0
        
        for i in range(n):
            if mask & 1 << i != 0:
                max_balls = max(max_balls, a[i])
        
        total_value = (total_value + max_balls) % MOD
        
    #State of the program after the  for loop has been executed: `total_value` is the sum of the maximum values for each possible subset of the list `a`, modulo `998244353`, `max_balls` is the maximum value found in the array `a` for indices where the corresponding bit in `mask` is set to 1, and `i` is `n`.
    return total_value
    #The program returns total_value which is the sum of the maximum values for each possible subset of the list 'a', modulo 998244353
#Overall this is what the function does:The function `func_1` accepts two parameters: `n`, an integer such that 1 ≤ n ≤ 5000, and `a`, a list of `n` integers where 1 ≤ a_i ≤ 5000 for each i, and the sum of all elements in `a` does not exceed 5000. It iterates over all possible subsets of the list `a` using bit masking. For each subset, it finds the maximum value among the elements whose corresponding bit in the subset's bitmask is set to 1. It then sums these maximum values and returns the result modulo 998244353. The function handles all possible subsets of the list `a`, including the empty subset, which contributes a value of 0 to the sum. There are no missing functionalities in the given code, and the postcondition accurately reflects the state of the program after the function executes.


Beggining of Original Assessment: 
Reasoning:  
To verify the correctness of the given program, we need to analyze whether it correctly implements the logic described in the problem statement.

### Key Points to Verify:
1. **Mask Representation**: The program uses a bitmask to represent each subset of colors.
2. **Calculation of `max_balls`**: For each subset, it calculates the maximum number of balls among the selected colors.
3. **Summing Values**: It sums up these maximum values for all subsets.
4. **Modulo Operation**: The result is taken modulo \(998,244,353\).

### Analysis:
- **Bitmask Iteration**: The loop `for mask in range(1 << n):` iterates over all possible subsets of the colors. This is correct because \(1 << n\) gives the total number of subsets including the empty set.
- **Mask Condition Check**: `if mask & 1 << i != 0:` checks if the \(i\)-th bit of the mask is set, meaning the \(i\)-th color is included in the subset. This condition is used to determine which colors are part of the current subset.
- **Max Calculation**: `max_balls = max(max_balls, a[i])` correctly finds the maximum number of balls among the selected colors.
- **Summation**: `total_value = (total_value + max_balls) % MOD` accumulates the sum of the maximum values for all subsets.
- **Modulo Operation**: Using `% MOD` ensures that the final result is within the required bounds.

Given the problem constraints and the logic implemented in the code, the program appears to follow the correct approach to solve the problem.

### Conclusion:
The program correctly implements the logic described in the problem statement and handles the constraints appropriately.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

