
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given two integers x and y . A sequence a of length n is called
modular if a_1=x , and for all 1 < i \le n the value of a_{i} is either
a_{i-1} + y or a_{i-1} \bmod y . Here x \bmod y denotes the remainder from
dividing x by y .

Determine if there exists a modular sequence of length n with the sum of its
elements equal to S , and if it exists, find any such sequence.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 2 \cdot 10^4 ). The description of the test cases
follows.

The first and only line of each test case contains four integers n , x , y ,
and s (1 \le n \le 2 \cdot 10^5 , 0 \le x \le 2 \cdot 10^5 , 1 \le y \le 2
\cdot 10^5 , 0 \le s \le 2 \cdot 10^5 ) — the length of the sequence, the
parameters x and y , and the required sum of the sequence elements.

The sum of n over all test cases does not exceed 2 \cdot 10^5 , and also the
sum of s over all test cases does not exceed 2 \cdot 10^5 .

Output

For each test case, if the desired sequence exists, output "Yes" on the first
line (without quotes). Then, on the second line, output n integers a_1, a_2,
\ldots, a_n separated by a space — the elements of the sequence a . If there
are multiple suitable sequences, output any of them.

If the sequence does not exist, output "No" on a single line.

You can output each letter in any case (lowercase or uppercase). For example,
the strings "yEs", "yes", "Yes", and "YES" will be accepted as a positive
answer.

Example

Input

    3
    
    5 8 3 28
    
    3 5 3 6
    
    9 1 5 79

Output

    YES
    8 11 2 2 5 
    NO
    NO
    
Note

In the first example, the sequence [8, 11, 2, 5, 2] satisfies the conditions.
Thus, a_1 = 8 = x , a_2 = 11 = a_1 + 3 , a_3 = 2 = a_2 \bmod 3 , a_4 = 5 = a_3
+ 3 , a_5 = 2 = a_4 \bmod 3 .

In the second example, the first element of the sequence should be equal to 5
, so the sequence [2, 2, 2] is not suitable.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
t = int(input())
for _ in range(t):
    (n, x, y, s) = map(int, input().split())
    result = func_1(n, x, y, s)
    if result:
        print('Yes')
        print(' '.join(map(str, result)))
    else:
        print('No')

#State of the program right berfore the function call: n is a positive integer, x and y are non-negative integers, and s is a non-negative integer such that 1 <= n <= 2 * 10^5, 0 <= x <= 2 * 10^5, 1 <= y <= 2 * 10^5, and 0 <= s <= 2 * 10^5.
def func_1(n, x, y, s):
    sequence = [x]
    current_sum = x
    for i in range(1, n):
        if current_sum + y <= s and (s - current_sum - y) % y == 0:
            sequence.append(sequence[-1] + y)
            current_sum += y
        else:
            sequence.append(sequence[-1] % y)
            current_sum += sequence[-1]
        
        if current_sum > s:
            return None
        
    #State of the program after the  for loop has been executed: `n` must be greater than 0, `x` is a non-negative integer, `y` is a non-negative integer, `s` is a non-negative integer, `sequence` is a list where the first element is `x`, and each subsequent element depends on the previous element and the conditions checked within the loop. Specifically, each element in the sequence after the first one is either `sequence[-1] + y` or `sequence[-1] % y` based on whether adding `y` to `current_sum` would exceed `s` or not. `current_sum` is the cumulative sum of the elements in `sequence`. If at any point `current_sum` exceeds `s`, the sequence is reset to `[x, x % y]` and `current_sum` is reset to `x + (x % y)` if this condition occurs.
    if (current_sum == s) :
        return sequence
        #`sequence` is [x, x % y] and `current_sum` is x + (x % y) because the cumulative sum of the elements in `sequence` equals `s` and no further elements were added to `sequence` before `current_sum` exceeded `s`
    else :
        return None
        #None

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
