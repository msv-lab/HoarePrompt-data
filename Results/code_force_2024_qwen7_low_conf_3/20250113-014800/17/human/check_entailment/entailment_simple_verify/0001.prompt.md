
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Define the binary encoding of a finite set of natural numbers T \subseteq
\\{0,1,2,\ldots\\} as f(T) = \sum\limits_{i \in T} 2^i . For example,
f(\\{0,2\\}) = 2^0 + 2^2 = 5 and f(\\{\\}) = 0 . Notice that f is a bijection
from all such sets to all non-negative integers. As such, f^{-1} is also
defined.

You are given an integer n along with 2^n-1 sets V_1,V_2,\ldots,V_{2^n-1} .

Find all sets S that satisfy the following constraint:

  * S \subseteq \\{0,1,\ldots,n-1\\} . Note that S can be empty. 
  * For all non-empty subsets T \subseteq \\{0,1,\ldots,n-1\\} , |S \cap T| \in V_{f(T)} . 

Due to the large input and output, both input and output will be given in
terms of binary encodings of the sets.

Input

The first line of input contains a single integer n (1 \leq n \leq 20 ).

The second line of input contains 2^n-1 integers v_1,v_2,\ldots,v_{2^n-1} (0
\leq v_i < 2^{n+1} ) — the sets V_i given in their binary encoding where V_i =
f^{-1}(v_i) .

Output

The first line of output should contain an integer k indicating the number of
possible S .

In the following k lines, you should output f(S) for all possible S in
increasing order.

Examples

Input

    3
    
    15 15 15 15 15 15 12

Output

    4
    3
    5
    6
    7
    
Input

    5
    
    63 63 63 63 6 63 63 63 63 63 63 5 63 63 63 63 63 63 8 63 63 63 63 2 63 63 63 63 63 63 63

Output

    1
    19
    
Note

In the first test case, one possible S is f^{-1}(3) = \\{0,1\\} . All the non-
empty subsets T \subseteq \\{0,1,2\\} and the corresponding |S \cap T| , f(T)
and V_f(T) are as follows:

T | |S\cap T| | f(T) | V_{f(T)}   
---|---|---|---  
\\{0\\} | 1 | 1 | \\{0,1,2,3\\}   
\\{1\\} | 1 | 2 | \\{0,1,2,3\\}   
\\{2\\} | 0 | 4 | \\{0,1,2,3\\}   
\\{0,1\\} | 2 | 3 | \\{0,1,2,3\\}   
\\{0,2\\} | 1 | 5 | \\{0,1,2,3\\}   
\\{1,2\\} | 1 | 6 | \\{0,1,2,3\\}   
\\{0,1,2\\} | 2 | 7 | \\{2,3\\}

- Program: 
import itertools

print('Test Case 1:')
func_1(3, [15] * 7)
print('\nTest Case 2:')
func_1(5, [63] * 16)

def func_1(n, V):
    V = [bin(i)[2:] for i in V]
    S = []
    for i in range(2 ** n):
        s = bin(i)[2:]
        if len(s) < n:
            s = '0' * (n - len(s)) + s
        valid = True
        for j in range(n):
            if s[j] == '1':
                sub_s = s[:j] + s[j + 1:]
                if not any((sub_s.count('1') == int(v, 2) for v in V)):
                    valid = False
                    break
        if valid:
            S.append(bin(int(s, 2) + 1)[2:])
    S.sort()
    print(len(S))
    for s in S:
        print(int(s, 2))



- Annotated Code: 
import itertools

print('Test Case 1:')
func_1(3, [15] * 7)
print('\nTest Case 2:')
func_1(5, [63] * 16)

#State of the program right berfore the function call: n is an integer such that 1 <= n <= 20, and V is a list of 2^n - 1 integers where each integer v_i satisfies 0 <= v_i < 2^(n+1), representing the sets V_i in their binary encoding where V_i = f^{-1}(v_i).
def func_1(n, V):
    V = [bin(i)[2:] for i in V]
    S = []
    for i in range(2 ** n):
        s = bin(i)[2:]
        
        if len(s) < n:
            s = '0' * (n - len(s)) + s
        
        valid = True
        
        for j in range(n):
            if s[j] == '1':
                sub_s = s[:j] + s[j + 1:]
                if not any(sub_s.count('1') == int(v, 2) for v in V):
                    valid = False
                    break
        
        if valid:
            S.append(bin(int(s, 2) + 1)[2:])
        
    #State of the program after the  for loop has been executed: `S` contains all binary strings of length `n` that satisfy the given conditions, `s` is an empty string, `valid` is `False`, `i` is `2
    S.sort()
    print(len(S))
    for s in S:
        print(int(s, 2))
        
    #State of the program after the  for loop has been executed: `S` is a non-empty sorted list of binary strings, `s` is the last (or any) element of `S`, `valid` is `False`, `i` is the length of `S` + 1; each binary string in `S` has been converted to its integer representation and printed.



Beggining of Original Assessment: 
Reasoning:

Let's analyze the provided program to see if it correctly implements the logic required to solve the given problem.

1. **Function Definition and Input Handling**:
   - The function `func_1` takes two arguments: `n` and `V`. This matches the problem description.
   - `V` is converted from integers to binary strings. This step is necessary for easier manipulation of binary representations.

2. **Iterating Over Possible Sets S**:
   - A loop runs over all possible subsets of `{0, 1, ..., n-1}` by iterating over binary strings of length `n`.
   - Each subset is represented as a binary string, and if the string length is less than `n`, it pads the string with leading zeros.

3. **Checking Validity of Subset S**:
   - For each bit position `j` in the subset representation (`s`), if the bit at position `j` is `1`, it checks whether the count of `1`s in the subset without the `j`-th bit matches any value in `V` at index `f(T)`, where `T` is the subset without the `j`-th bit.
   - If a match is found, the subset `S` is considered valid.

4. **Collecting Valid Subsets**:
   - Valid subsets are collected in the list `S`.

5. **Sorting and Outputting Results**:
   - The list `S` is sorted and printed. Each element is the binary representation of the subset, which is converted back to an integer before printing.

Given this analysis, the provided program seems to follow the correct logic for solving the problem. It iterates through all possible subsets, checks the condition for each subset, and outputs the valid subsets in the correct format.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

