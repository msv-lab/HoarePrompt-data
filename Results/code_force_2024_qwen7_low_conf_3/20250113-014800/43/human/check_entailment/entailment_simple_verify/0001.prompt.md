
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Vladislav has a son who really wanted to go to MIT. The college dormitory at
MIT (Moldova Institute of Technology) can be represented as a tree with n
vertices, each vertex being a room with exactly one student. A tree is a
connected undirected graph with n vertices and n-1 edges.

Tonight, there are three types of students:

  * students who want to party and play music (marked with \texttt{P} ), 
  * students who wish to sleep and enjoy silence (marked with \texttt{S} ), and 
  * students who don't care (marked with \texttt{C} ). 

Initially, all the edges are thin walls which allow music to pass through, so
when a partying student puts music on, it will be heard in every room.
However, we can place some thick walls on any edges — thick walls don't allow
music to pass through them.

The university wants to install some thick walls so that every partying
student can play music, and no sleepy student can hear it.

Because the university lost a lot of money in a naming rights lawsuit, they
ask you to find the minimum number of thick walls they will need to use.

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The first line of each test case contains an integer n (2 \leq n \leq 10^5 ) —
the number of vertices in the tree.

The second line of each test case contains n-1 integers a_2, \dots , a_n (1
\leq a_i < i ) — it means there is an edge between i and a_i in the tree.

The third line of each test case contains a string s of length n consisting of
characters \texttt{P} , \texttt{S} , and \texttt{C} , denoting that student i
is of type s_i .

The sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer — the minimum number of thick
walls needed.

Example

Input

    3
    
    3
    
    1 1
    
    CSP
    
    4
    
    1 2 2
    
    PCSS
    
    4
    
    1 2 2
    
    PPSS

Output

    1
    1
    2
    
Note

In the first case, we can install one thick wall between rooms 1 and 2 , as
shown below. We cannot install 0 walls, since then the music from room 3 will
reach room 2 where a student wants to sleep, so the answer is 1 . There are
other valid solutions.

![](https://espresso.codeforces.com/7829c4a96192afbd162c82af7a2c95ff80e8daa1.png)

- Program: 
def func():
    for _ in range(int(input())):
        n = int(input())
        fa = [-1] + list(map(int, input().split()))
        S = input()
        (dp1, dp2) = ([0] * (n + 1), [0] * (n + 1))
        for i in range(n - 1, -1, -1):
            if S[i] == 'S':
                dp1[i] = float('inf')
            elif S[i] == 'P':
                dp2[i] = float('inf')
            p = fa[i] - 1
            if p != -1:
                dp1[p] += min(dp1[i], dp2[i] + 1)
                dp2[p] += min(dp1[i] + 1, dp2[i])
        print(min(dp1[0], dp2[0]))



- Annotated Code: 
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 1000. For each test case, n is an integer such that 2 ≤ n ≤ 10^5, a list of n-1 integers a_2, ..., a_n such that 1 ≤ a_i < i, and a string s of length n consisting of characters 'P', 'S', and 'C'. The sum of n over all test cases does not exceed 10^5.
def func():
    for _ in range(int(input())):
        n = int(input())
        
        fa = [-1] + list(map(int, input().split()))
        
        S = input()
        
        dp1, dp2 = [0] * (n + 1), [0] * (n + 1)
        
        for i in range(n - 1, -1, -1):
            if S[i] == 'S':
                dp1[i] = float('inf')
            elif S[i] == 'P':
                dp2[i] = float('inf')
            p = fa[i] - 1
            if p != -1:
                dp1[p] += min(dp1[i], dp2[i] + 1)
                dp2[p] += min(dp1[i] + 1, dp2[i])
        
        print(min(dp1[0], dp2[0]))
        
    #State of the program after the  for loop has been executed: `n` is an integer such that 2 ≤ `n` ≤ 10^5, `fa` is a list of length `n + 1` where the first element is -1 and the next `n` elements are integers from the input representing parent nodes, `S` is a string of length `n` consisting of characters 'P', 'S', and 'C', `dp1` and `dp2` are lists of length `n + 1` initialized to `float('inf')`, `dp1[0]` and `dp2[0]` are the minimum values between paths in the tree starting from the root node considering the constraints given by the string `S`, and the output of the print statement is the minimum value between `dp1[0]` and `dp2[0]`.



Beggining of Original Assessment: 
Reasoning:

To verify the correctness of the provided solution, let's break down the logic of the program step by step and compare it with the problem statement.

1. **Input Parsing**: The program correctly parses the number of test cases, the number of vertices `n`, the parent array `fa`, and the string `S` indicating the type of each student.

2. **Dynamic Programming Setup**: The program initializes two arrays `dp1` and `dp2` to store the minimum number of walls required when ending with a 'S' student and a 'P' student, respectively.

3. **Backward DP Calculation**:
   - For each node `i` starting from the last node (i.e., leaf nodes) to the root, the program updates `dp1[i]` and `dp2[i]` based on the values of its parent node `p`.
   - If the current student `i` is a 'S' student, `dp1[i]` is set to infinity because we do not want any music to reach this student.
   - If the current student `i` is a 'P' student, `dp2[i]` is set to infinity because we want to ensure music reaches this student.
   - For each child `i`, the parent `p` updates its `dp1` and `dp2` values based on the minimum cost of keeping music out (`dp1`) or in (`dp2`) from its child `i`.

4. **Result Calculation**: The final result for each test case is the minimum value between `dp1[0]` and `dp2[0]`, representing the minimum number of walls required.

Let's analyze if this approach correctly solves the problem:
- The program correctly identifies that placing a wall between a 'P' and a 'S' student ensures that the music does not reach the 'S' student while still allowing it to reach other 'P' students.
- By using dynamic programming in a backward manner, the program ensures that the minimum number of walls required is computed efficiently.

Given the problem constraints and the logical steps taken by the program, it appears that the provided solution is correct.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

