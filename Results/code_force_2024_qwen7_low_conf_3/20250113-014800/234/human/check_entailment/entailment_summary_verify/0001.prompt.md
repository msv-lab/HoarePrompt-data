
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8

- Program:
import sys
#Function 1:
def func_1():
    return list(map(int, input().split()))

#Function 2:
def func_2():
    return int(input())

#Function 3:
def func_3():
    return map(int, input().split())

#Function 4:
def func_4():
    return input().strip()

#Function 5:
def func_5():
    (n, q) = func_3()
    (l, r) = (func_1(), func_1())
    nodes = [None] * (n + 1)
    for i in range(q):
        (le, ri) = (nodes[l[i]], nodes[r[i]])
        if le:
            lri = le.ri
            ri = nodes[r[i]] = ListNode(r[i])
            if lri:
                le.ri = lri.le = ri
                (ri.le, ri.ri) = (le, lri)
            else:
                (le.ri, ri.le) = (ri, le)
        elif ri:
            rle = ri.le
            le = nodes[l[i]] = ListNode(l[i])
            if rle:
                rle.ri = ri.le = le
                (le.le, le.ri) = (rle, ri)
            else:
                (le.ri, ri.le) = (ri, le)
        else:
            nodes[l[i]] = ListNode(l[i])
            nodes[r[i]] = ListNode(r[i])
            (nodes[l[i]].ri, nodes[r[i]].le) = (nodes[r[i]], nodes[l[i]])
    a = []
    for i in range(1, n + 1):
        if nodes[i]:
            while nodes[i].le:
                i = nodes[i].le.v
            a.append(i)
            while nodes[i].ri:
                i = nodes[i].ri.v
                a.append(i)
            break
    seg = [0] * (n + 1)
    seg[a[0]] += 1
    seg[a[q]] += 1
    for i in range(q):
        seg[max(a[i], a[i + 1])] += 1
    ans = 1
    cnt = 0
    for i in range(n, 0, -1):
        if nodes[i]:
            cnt += seg[i]
        else:
            ans *= cnt
            ans %= m
            cnt += 1
    return ans



- Function Summary: 
Output hints for function number 5 : The function `func_5` accepts four parameters: `n` (the number of nodes), `q` (the number of operations), `l` (a list of left indices), and `r` (a list of right indices). It constructs a doubly linked list based on these indices and then performs a series of operations to compute a final value `ans`.

The function first initializes a doubly linked list using the indices from lists `l` and `r`. Each node in the list is a `ListNode` object containing values from 1 to `n`. The function then traverses the list to create a sequence `a` of unique node values starting from the smallest index and moving through both directions until no more nodes can be visited.

Next, it constructs a segment array `seg` by counting the occurrences of transitions between consecutive values in `a`. Specifically, for each pair of consecutive values in `a`, it increments the count at the maximum value of the pair.

Finally, the function iterates backward through the segment array `seg` to compute the value of `ans` by multiplying counts of segments and applying modulo operation. The function returns the final value of `ans`.

Potential edge cases and missing functionality:
1. The function assumes that `l` and `r` are valid lists of indices within the range [1, n]. If `l` or `r` contain invalid indices, the function would raise an error.
2. The function does not handle the case where `l[i] == r[i]` for any `i`, which could lead to incorrect segmentation.
3. The function does not validate the initial values of `n` and `q` beyond checking their bounds.+


Beggining of Original Assessment: 
### Reasoning:

1. **Understanding the Problem**: The problem requires determining if a given set of operations (splitting and recording the maximum elements in the left and right parts) can be derived from some permutation of size `n`. We need to count the number of valid permutations that can produce the given sequences `[l_1, l_2, ..., l_q]` and `[r_1, r_2, ..., r_q]`.

2. **Analyzing the Code**:
   - The code reads input values and initializes necessary variables.
   - It uses a linked list (`ListNode`) to manage the merging process during operations.
   - The logic for splitting and managing nodes is complex but follows the problem's description closely.
   - Segments (`seg`) are used to keep track of overlaps between the splits.
   - Finally, the code calculates the number of valid permutations using the counts stored in the `seg` array.

3. **Key Components**:
   - **Node Management**: The code effectively manages nodes to simulate the splitting operations.
   - **Segment Array**: The `seg` array helps in counting overlaps, which are crucial for calculating the number of valid permutations.
   - **Modulo Operation**: The result is taken modulo \(998244353\) as required by the problem statement.

4. **Verification**:
   - The code seems to correctly implement the steps described in the problem.
   - The logic for handling node splits and overlaps is consistent with the problem's requirements.
   - The final calculation of valid permutations also appears to follow the expected approach.

5. **Edge Cases**:
   - The additional constraint that at least one permutation exists simplifies the validation process since we only need to check if the logic is sound rather than proving the existence of a specific permutation.

### Conclusion:
Based on the analysis, the provided Python program correctly implements the logic required to solve the problem as described.

### Correctness:
Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

