
You are a program verifier. Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8

# Functions with Execution Summary:
import sys

input = sys.stdin.readline
class ListNode:

    def __init__(self, v=0):
        self.le = self.ri = None
        self.v = v
m = 998244353
print(func_5())

Function number 1 :
 Code:
 '''
def func_1():
    return list(map(int, input().split()))
''' 

 Output hints for function1:  The function `func_1()` reads `q` integers from user input and returns them as a list. Each integer in the returned list is guaranteed to be between 1 and `n` inclusive. The function assumes that the input is provided in the format of `q` space-separated integers. If the input does not conform to this format, the `map` function will raise a `ValueError`. There are no additional error handling mechanisms included in the provided code to manage such cases.
Function number 2 :
 Code:
 '''
def func_2():
    return int(input())
''' 

 Output hints for function2:  The function accepts an integer input provided by the user through the `input()` function and returns that integer. The function does not perform any additional operations on the input value. The state of the program after the function concludes is that it has returned the integer input provided by the user. There are no potential edge cases mentioned in the annotations, and the code does exactly what the annotations suggest.
Function number 3 :
 Code:
 '''
def func_3():
    return map(int, input().split())
''' 

 Output hints for function3:  The function reads a sequence of space-separated integers from the standard input, expecting the integers to represent values for `n`, `q`, `l`, and `r` based on the given constraints (1 ≤ q < n ≤ 3 × 10^5, and each element in `l` and `r` is between 1 and n). It then returns a map object containing these integers. There are no specific actions performed by the function other than reading the input and splitting it into integers. This means the function assumes the input format is correct and does not handle any errors related to incorrect input format or invalid values.
Function number 4 :
 Code:
 '''
def func_4():
    return input().strip()
''' 

 Output hints for function4:  The function `func_4()` does not accept any parameters as described in the annotations and the provided code only contains a single return statement that reads a string input from the user, strips it of leading and trailing whitespace, and returns it. There is no processing of `n`, `q`, `l`, or `r` as mentioned in the annotations. The function accepts user input, which must be provided through standard input, and returns the input as a string with any extra spaces removed. If no input is provided or the input is not a string, the function will still attempt to strip the whitespace, potentially leading to unexpected behavior if non-string data types are passed.
Function number 5 :
 Code:
 '''
def func_5():
    (n, q) = func_3()
    (l, r) = (func_1(), func_1())
    nodes = [None] * (n + 1)
    for i in range(q):
        (le, ri) = (nodes[l[i]], nodes[r[i]])
        if le:
            lri = le.ri
            ri = nodes[r[i]] = ListNode(r[i])
            if lri:
                le.ri = lri.le = ri
                (ri.le, ri.ri) = (le, lri)
            else:
                (le.ri, ri.le) = (ri, le)
        elif ri:
            rle = ri.le
            le = nodes[l[i]] = ListNode(l[i])
            if rle:
                rle.ri = ri.le = le
                (le.le, le.ri) = (rle, ri)
            else:
                (le.ri, ri.le) = (ri, le)
        else:
            nodes[l[i]] = ListNode(l[i])
            nodes[r[i]] = ListNode(r[i])
            (nodes[l[i]].ri, nodes[r[i]].le) = (nodes[r[i]], nodes[l[i]])
    a = []
    for i in range(1, n + 1):
        if nodes[i]:
            while nodes[i].le:
                i = nodes[i].le.v
            a.append(i)
            while nodes[i].ri:
                i = nodes[i].ri.v
                a.append(i)
            break
    seg = [0] * (n + 1)
    seg[a[0]] += 1
    seg[a[q]] += 1
    for i in range(q):
        seg[max(a[i], a[i + 1])] += 1
    ans = 1
    cnt = 0
    for i in range(n, 0, -1):
        if nodes[i]:
            cnt += seg[i]
        else:
            ans *= cnt
            ans %= m
            cnt += 1
    return ans
''' 

 Output hints for function5:  The function `func_5` accepts four parameters: `n` (the number of nodes), `q` (the number of operations), `l` (a list of left indices), and `r` (a list of right indices). It constructs a doubly linked list based on these indices and then performs a series of operations to compute a final value `ans`.

The function first initializes a doubly linked list using the indices from lists `l` and `r`. Each node in the list is a `ListNode` object containing values from 1 to `n`. The function then traverses the list to create a sequence `a` of unique node values starting from the smallest index and moving through both directions until no more nodes can be visited.

Next, it constructs a segment array `seg` by counting the occurrences of transitions between consecutive values in `a`. Specifically, for each pair of consecutive values in `a`, it increments the count at the maximum value of the pair.

Finally, the function iterates backward through the segment array `seg` to compute the value of `ans` by multiplying counts of segments and applying modulo operation. The function returns the final value of `ans`.

Potential edge cases and missing functionality:
1. The function assumes that `l` and `r` are valid lists of indices within the range [1, n]. If `l` or `r` contain invalid indices, the function would raise an error.
2. The function does not handle the case where `l[i] == r[i]` for any `i`, which could lead to incorrect segmentation.
3. The function does not validate the initial values of `n` and `q` beyond checking their bounds.


# Your response:
Reasoning:  
Correctness: **True** or **False**

