
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

I am giving you some examples to understand the task better. Then I am giving you your task.
# Example 1

Problem description: Write a python function to identify non-prime numbers.
Program:
```
def is_not_prime(n):
    if n < 2:
        return True
    for i in range(2, n):
        if n % i == 0:
            return True
    return False
```
Example Answer 1:
Correctness: **True**.

# Example 2

Problem description: Write a python function to count all the substrings starting and ending with same characters.
Program:
```
def count_Substring_With_Equal_Ends(s):
    count = 0
    for i in range(len(s)-1):
        for j in range(i,len(s)-1):
            if s[i] == s[j+1]:
                count += 1
    return count
```

Example Answer 2:
Correctness: **False**.

# Example 3

Problem description: Write a function to perform binary search of a number in an list
Program:
```
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid
        else:
            right = mid - 1
    if arr[left] == target:
        return left
    return -1
```
Example answer 3:
Correctness: **False**.

# Your task:
Problem description: This is an interactive problem.

This is the game version of the problem. Note that the solution of this
problem may or may not share ideas with the solution of the solo version. You
can solve and get points for both versions independently.

Alice and Bob are playing a game. The game starts with a positive integer n ,
with players taking turns. On each turn of the game, the following sequence of
events takes place:

  * The player having the integer p breaks it into two integers p_{1} and p_{2} , where 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . 
  * If no such p_{1} , p_{2} exist, the player loses. 
  * Otherwise, the opponent does either select the integer p_{1} or p_{2} . 
  * The game continues with the selected integer. The opponent will try to break it. 

As Alice, your goal is to win. You can execute a maximum of 63 break
operations. You have the choice to play first or second. The system will act
for Bob.

Here \oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \leq t \leq 1000 ) — the number of test cases.

The only line of each test case contains a single integer n (1 \leq n \leq
10^{18} ) — the number the game starts with.

Interaction

For each test case, the interaction begins by reading the integer n .

After reading n , print a single line containing either "first" or "second",
denoting what you want to play as (as first or second correspondingly).

On Alice's turn, you are required to print two positive integers, p_{1} and
p_{2} such that 0 \lt p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} =
p . Here, p equals one of the two integers printed by Bob in the previous
turn. If no turn has occurred previously, p is equal to n . If Alice cannot
perform a break operation, print "0 0" to receive a Wrong answer verdict.

On Bob's turn, you should read two integers, p_{1} and p_{2} such that 0 \lt
p_{1} \lt p , 0 \lt p_{2} \lt p and p_{1} \oplus p_{2} = p . Here, p equals
one of the two integers printed by Alice in the previous turn. If no turn has
occurred previously, p is equal to n . If Bob cannot perform a break operation
p_{1} = 0 and p_2 = 0 in which case you should proceed to the next test case.

If any break operation performed by Alice is invalid, the interactor prints
"-1 -1" and your code should promptly exit to receive a wrong answer verdict.

If Alice performs 63 turns and Bob can still execute a break operation on the
current integers, the interactor prints "-1 -1", and your code should promptly
exit to receive a wrong answer verdict.

After printing a query, do not forget to output the end of line and flush the
output. Otherwise, you will get Idleness limit exceeded. To do this, use:

  * fflush(stdout) or cout.flush() in C++; 
  * System.out.flush() in Java; 
  * flush(output) in Pascal; 
  * stdout.flush() in Python; 
  * see the documentation for other languages. 

In this problem, hacks are disabled.

Example

Input

    4
    1
    
    0 0
    3
    
    0 0
    13
    
    3 4
    
    0 0
    777777770001
    
    0 0

Output

    second
    
    first
    2 1
    
    first
    10 7
    
    1 2
    
    first
    777777770000 1

Note

Explanation for the interaction.

Interactor / Bob| Alice| Explanation  
---|---|---  
4| | t   
1| | n for the first test case  
| second| Alice chooses to go second  
0 0| | Bob says he cannot break p = 1   
3| | n for the second test case  
| first| Alice chooses to go first  
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
13| | n for the third test case  
| first| Alice chooses to go first  
| 10 7| Alice breaks p = 13 into p_1 = 10 and p_2 = 7  
3 4| | Bob breaks p = 7 into p_1 = 3 and p_2 = 4   
| 1 2| Alice breaks p = 3 into p_1 = 1 and p_2 = 2  
0 0| | Bob says he cannot break p = 1 or p = 2   
777777770001| | n for the fourth test case  
| first| Alice chooses to go first  
| 777777770000 1| Alice breaks p = 777\,777\,770\,001 into p_1 =
777\,777\,770\,000 and p_2 = 1  
0 0| | Bob says he cannot perform break operation.  
  
This table is for explanation only and does not reflect the actual behavior of
the interactor.

Note that in the last test case Bob could choose p_1 and perform a break
operation but he gave up.
Program:
```
def func():
    for _ in range(int(input())):
        n = int(input())
        if bin(n).count('1') & 1:
            print('second')
        else:
            print('first')
            l = int(bin(n)[3:], 2)
            print(n ^ l, l)
        while True:
            (a, b) = map(int, input().split())
            if a == b:
                break
            n = b if bin(a).count('1') & 1 else a
            l = int(bin(n)[3:], 2)
            print(n ^ l, l)


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
