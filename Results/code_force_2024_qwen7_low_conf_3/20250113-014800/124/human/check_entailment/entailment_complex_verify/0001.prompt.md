
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Given an integer n , you construct an array a of n integers, where a_i = i for
all integers i in the range [1, n] . An operation on this array is defined as
follows:

  * Select three distinct indices i , j , and k from the array, and let x = a_i , y = a_j , and z = a_k . 
  * Update the array as follows: a_i = \operatorname{lcm}(y, z) , a_j = \operatorname{lcm}(x, z) , and a_k = \operatorname{lcm}(x, y) , where \operatorname{lcm} represents the least common multiple. 

Your task is to provide a possible sequence of operations, containing at most
\lfloor \frac{n}{6} \rfloor + 5 operations such that after executing these
operations, if you create a set containing the greatest common divisors (GCDs)
of all subsequences with a size greater than 1 , then all numbers from 1 to n
should be present in this set.

After all the operations a_i \le 10^{18} should hold for all 1 \le i \le n .

We can show that an answer always exists.

Input

The first line contains one integer t (1 \le t \le 10^2 ) — the number of test
cases. The description of the test cases follows.

The first and only line of each test case contains an integer n (3 \leq n \leq
3 \cdot 10^{4} ) — the length of the array.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^{4} .

Output

The first line should contain an integer k (0 \leq k \leq \lfloor \frac{n}{6}
\rfloor + 5 ) — where k is the number of operations.

The next k lines should contain the description of each operation i.e. 3
integers i , j and k , where 1 \leq i, j, k \leq n and all must be distinct.

Example

Input

    3
    
    3
    
    4
    
    7

Output

    1
    1 2 3
    1
    1 3 4
    3
    3 5 7
    5 6 7
    2 3 4

Note

In the third test case, a = [1, 2, 3, 4, 5, 6, 7] .

First operation:

i = 3 , j = 5 , k = 7

x = 3 , y = 5 , z = 7 .

a = [1, 2, \operatorname{lcm}(y,z), 4, \operatorname{lcm}(x,z), 6,
\operatorname{lcm}(x,y)] = [1, 2, \color{red}{35}, 4, \color{red}{21}, 6,
\color{red}{15}] .

Second operation:

i = 5 , j = 6 , k = 7

x = 21 , y = 6 , z = 15 .

a = [1, 2, 35, 4, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z),
\operatorname{lcm}(x,y)] = [1, 2, 35, 4, \color{red}{30}, \color{red}{105},
\color{red}{42}] .

Third operation:

i = 2 , j = 3 , k = 4

x = 2 , y = 35 , z = 4 .

a = [1, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z),
\operatorname{lcm}(x,y), 30, 105, 42] = [1, \color{red}{140}, \color{red}{4},
\color{red}{70}, 30, 105, 42] .

Subsequences whose GCD equal to i is as follows:

\gcd(a_1, a_2) = \gcd(1, 140) = 1

\gcd(a_3, a_4) = \gcd(4, 70) = 2

\gcd(a_5, a_6, a_7) = \gcd(30, 105, 42) = 3

\gcd(a_2, a_3) = \gcd(140, 4) = 4

\gcd(a_2, a_4, a_5, a_6) = \gcd(140, 70, 30, 105) = 5

\gcd(a_5, a_7) = \gcd(30, 42) = 6

\gcd(a_2, a_4, a_6, a_7) = \gcd(140, 70, 105, 42) = 7

- Program: 
import sys

def func_1():
    input = sys.stdin.read
    data = input().split()
    ans1 = [8]
    ans2 = [[[2, 6, 8], [3, 5, 7]]]
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        index += 1
        if n in ans1:
            ans = ans2[ans1.index(n)]
            results.append(f'{len(ans)}')
            for x in ans:
                results.append(' '.join(map(str, x)))
            continue
        ans = []
        pos = 0
        ost = []
        for i in range(3, n - 1, 4):
            if i > n // 2 - 2:
                ans.append([i, i + 1, i + 2])
                pos = i + 2
        for i in range(pos + 1, n + 1):
            if (i % 2 != 0 or i % 4 == 0) and i > n // 2:
                ost.append(i)
        per = n
        if (n - 1) % 4 == 2:
            per = n - 1
        elif (n - 2) % 4 == 2:
            per = n - 2
        elif (n - 3) % 4 == 2:
            per = n - 3
        for i in range(per, n // 2, -12):
            if i > n // 2:
                if i > 8:
                    ans.append([i, i - 4, i - 8])
                else:
                    ost.append(i)
        if len(ost) == 1:
            ans.append([1, 2, ost[0]])
        elif len(ost) == 2:
            ans.append([1, ost[1], ost[0]])
        elif len(ost) == 3:
            ans.append([ost[0], ost[1], ost[2]])
        elif len(ost) == 4:
            ans.append([1, ost[0], ost[1]])
            ans.append([2, ost[2], ost[3]])
        results.append(f'{len(ans)}')
        for x in ans:
            results.append(' '.join(map(str, x)))
    sys.stdout.write('\n'.join(results) + '\n')



- Annotated Code: 
import sys

#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 10^2, and for each test case, n is an integer such that 3 ≤ n ≤ 3⋅10^4. Additionally, the length of the array a is n, and a_i = i for all integers i in the range [1, n]. All operations must ensure that after executing the specified number of operations, the greatest common divisors (GCDs) of all subsequences with a size greater than 1 cover all numbers from 1 to n, and all elements in the array a must satisfy a_i ≤ 10^{18}.
def func_1():
    input = sys.stdin.read
    data = input().split()
    ans1 = [8]
    ans2 = [[[2, 6, 8], [3, 5, 7]]]
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        
        index += 1
        
        if n in ans1:
            ans = ans2[ans1.index(n)]
            results.append(f'{len(ans)}')
            for x in ans:
                results.append(' '.join(map(str, x)))
            continue
        
        ans = []
        
        pos = 0
        
        ost = []
        
        for i in range(3, n - 1, 4):
            if i > n // 2 - 2:
                ans.append([i, i + 1, i + 2])
                pos = i + 2
        
        for i in range(pos + 1, n + 1):
            if (i % 2 != 0 or i % 4 == 0) and i > n // 2:
                ost.append(i)
        
        per = n
        
        if (n - 1) % 4 == 2:
            per = n - 1
        elif (n - 2) % 4 == 2:
            per = n - 2
        elif (n - 3) % 4 == 2:
            per = n - 3
        
        for i in range(per, n // 2, -12):
            if i > n // 2:
                if i > 8:
                    ans.append([i, i - 4, i - 8])
                else:
                    ost.append(i)
        
        if len(ost) == 1:
            ans.append([1, 2, ost[0]])
        elif len(ost) == 2:
            ans.append([1, ost[1], ost[0]])
        elif len(ost) == 3:
            ans.append([ost[0], ost[1], ost[2]])
        elif len(ost) == 4:
            ans.append([1, ost[0], ost[1]])
            ans.append([2, ost[2], ost[3]])
        
        results.append(f'{len(ans)}')
        
        for x in ans:
            results.append(' '.join(map(str, x)))
        
    #State of the program after the  for loop has been executed: `t` is the initial value, `n` is the last value read from `data[index]`, `index` is `2 + t`, `results` is a list containing the string representations of all elements in `ans` from all iterations of the loop.
    sys.stdout.write('\n'.join(results) + '\n')
#Overall this is what the function does:The function processes multiple test cases where each test case specifies an integer \( n \). For each \( n \), it generates a set of subsequence pairs that ensure the greatest common divisor (GCD) of all subsequences with a size greater than 1 covers all numbers from 1 to \( n \). The function then outputs these results in a specific format. The function does not accept any parameters and reads inputs from standard input. After processing all test cases, it writes the results to standard output.

Specifically, the function performs the following steps:
1. Reads the number of test cases \( t \) and initializes the result list.
2. For each test case, reads the value of \( n \).
3. Checks if \( n \) is in a predefined list `ans1` and uses corresponding precomputed results from `ans2` if found.
4. If not, constructs a set of subsequence pairs based on specific rules:
   - If \( n \) is small enough, directly adds specific subsequence pairs.
   - Handles larger \( n \) values by breaking them into smaller segments and applying the construction rules.
5. Ensures the constructed subsequence pairs cover all numbers from 1 to \( n \).
6. Formats and writes the results to standard output in a specified format, including the number of subsequence pairs and the pairs themselves.

Potential edge cases and missing functionality:
- The function assumes \( n \) is always within the valid range [3, 3 * 10^4].
- It handles specific cases for \( n \) when \( n - 1 \mod 4 = 2 \), \( n - 2 \mod 4 = 2 \), and \( n - 3 \mod 4 = 2 \).
- It ensures that all subsequence pairs are valid and cover all numbers from 1 to \( n \).
- It handles cases where \( n \) might be very large but guarantees that all elements in the resulting subsequence pairs do not exceed \( 10^{18} \).

The function does not explicitly handle invalid inputs or out-of-range values for \( n \), and it relies on predefined lists `ans1` and `ans2` to provide results for certain values of \( n \).


Beggining of Original Assessment: 
Reasoning:

To determine if the provided program is correct, we need to check whether it meets the problem's requirements:

1. **Number of Operations**: The program should perform at most \(\lfloor \frac{n}{6} \rfloor + 5\) operations.
2. **Output Format**: The output should list the number of operations followed by the indices involved in each operation.
3. **Result Verification**: After performing the operations, the set of GCDs of all subsequences with a size greater than 1 should contain all numbers from 1 to \(n\).
4. **Constraints**: All elements of the array should be less than or equal to \(10^{18}\) after the operations.

Let's analyze the code:

- **Input Reading**: The function reads the input correctly and processes it.
- **Operations Generation**: The logic for generating operations is somewhat complex but follows the constraints and requirements. It ensures that the number of operations is controlled and within the limit.
- **Output Generation**: The output format matches the required format.
- **Handling Specific Cases**: The code handles specific cases like small values of \(n\) and ensures that the operations are performed in a way that the final array will meet the requirement.

Given the constraints and the nature of the operations, the code seems to follow the problem's guidelines and should produce the correct output for the given constraints.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

