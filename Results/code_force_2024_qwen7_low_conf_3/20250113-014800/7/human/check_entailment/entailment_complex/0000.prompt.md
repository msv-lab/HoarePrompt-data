
You are a program verifier. Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
You are given a tree with n vertices numbered 1, 2, \ldots, n . Initially, all
vertices are colored white.

You can perform the following two-step operation:

  1. Choose a vertex v (1 \leq v \leq n ) and a distance d (0 \leq d \leq n-1 ). 
  2. For all vertices u (1 \leq u \leq n ) such that \text{dist}^\dagger(u,v)=d , color u black. 

Construct a sequence of operations to color all the nodes in the tree black
using the minimum possible number of operations. It can be proven that it is
always possible to do so using at most n operations.

^\dagger \text{dist}(x, y) denotes the number of edges on the (unique) simple
path between vertices x and y on the tree.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 200 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^3 ) — the number of vertices of the tree.

The following n - 1 lines of each test case describe the edges of the tree.
The i -th of these lines contains two integers u_i and v_i (1 \le u_i, v_i \le
n , u_i \neq v_i ), the indices of the vertices connected by the i -th edge.

It is guaranteed that the given edges form a tree.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^3 .

Output

For each test case, first output a single integer op (1 \le op \le n) , the
minimum number of operations needed to color all vertices of the tree black.

Then, output op lines, each containing 2 integers. The i -th line should
contain the values of v and d chosen for the i -th operation (1 \le v \le n ,
0 \le d \le n - 1 )

You must guarantee that at the end of op operations, all vertices are colored
black.

If there are multiple solutions, you may output any one of them.

Example

Input

    4
    
    1
    
    2
    
    1 2
    
    4
    
    1 2
    
    1 3
    
    1 4
    
    7
    
    2 7
    
    3 2
    
    6 4
    
    5 7
    
    1 6
    
    6 7

Output

    1
    1 0
    2
    1 1
    2 1
    2
    1 1
    2 1
    3
    6 1
    7 1
    2 1

Note

In the first test case, there is only one possible operation, and performing
it gives us a valid answer.

In the second test case, the first operation colors vertex 2 black, and the
second operation colors vertex 1 black. It can be shown that it is impossible
to color both vertices black in one operation, so the minimum number of
operations needed is 2 . Another possible solution is to use the 2 operations:
(u, r) = (1, 0) and (u, r) = (2, 0) .

In the third test case, the first operation colors vertices 2 , 3 and 4 black,
and the second operation colors vertex 1 black. Again, it can be shown that it
is impossible to color all vertices black in 1 operation, so the minimum
number of operations needed is 2 .

In the fourth test case, the first operation colors vertices 4 , 1 and 7
black, the second operation colors vertices 2 , 5 and 6 black while the third
operation colors vertices 3 and 7 black. Notice that it is allowed to color
vertex 7 black twice.

Thus, each node was marked at least once, with node 7 marked twice. It can be
shown that it is impossible to color all vertices black in fewer than 3 moves.

# Annotated Functions:
n = 4
edges = [(1, 2), (1, 3), (1, 4)]
(num_operations, operations) = func_2(n, edges)
print(num_operations)
for (v, d) in operations:
    print(v, d)

#Function 1:
#State of the program right berfore the function call: tree is a dictionary where keys are integers representing nodes and values are lists of integers representing neighbors of the key node; start_node is an integer representing the starting node for the breadth-first search (BFS), such that 1 <= start_node <= n.
def func_1(tree, start_node):
    queue = deque([start_node])
    distances = {start_node: 0}
    while queue:
        node = queue.popleft()
        
        current_distance = distances[node]
        
        for neighbor in tree[node]:
            if neighbor not in distances:
                distances[neighbor] = current_distance + 1
                queue.append(neighbor)
        
    #State of the program after the loop has been executed: `queue` is empty, `node` is the last node processed in the BFS traversal, `distances` is a dictionary mapping each node in the graph that can be reached from the `start_node` to its shortest distance from the `start_node`, and `start_node` is an integer with \(1 \leq \text{start_node} \leq n\).
    return distances
    #`The program returns the dictionary 'distances' which maps each node in the graph that can be reached from the 'start_node' to its shortest distance from the 'start_node'`
#Overall this is what the function does:The function `func_1` accepts a dictionary `tree` representing a graph where keys are integers (nodes) and values are lists of integers (neighbors), along with an integer `start_node` representing the starting node for a breadth-first search (BFS). It performs a BFS traversal from the `start_node` to compute the shortest distance from `start_node` to every other reachable node in the graph. After executing the function, it returns a dictionary named `distances` where each key is a node in the graph and the corresponding value is the shortest distance from the `start_node`. The function handles the case where a node might not be reachable from the `start_node`, as these nodes will not appear in the `distances` dictionary. The BFS ensures that all reachable nodes are processed level by level, guaranteeing that the shortest path is found. If the `start_node` is not within the valid range (1 <= start_node <= n), the function still executes correctly but the `distances` dictionary will only include nodes reachable from the specified `start_node`.

#Function 2:
#State of the program right berfore the function call: n is a positive integer such that 1 <= n <= 2 * 10^3, edges is a list of tuples representing the edges of the tree where each tuple (u, v) indicates an edge connecting vertices u and v, and distances is a dictionary mapping each vertex to its distance from vertex 1.
def func_2(n, edges):
    tree = {i: [] for i in range(1, n + 1)}
    for (u, v) in edges:
        tree[u].append(v)
        
        tree[v].append(u)
        
    #State of the program after the  for loop has been executed: `edges` is a list of tuples representing the edges of the tree, `tree[u]` includes all vertices `v` connected to `u` through edges, `tree[v]` includes all vertices `u` connected to `v` through edges, `tree` is a dictionary where each key is an integer from 1 to `n` (inclusive), and the corresponding value for each key is a list of all vertices connected to that key through the edges.
    distances = func_1(tree, 1)
    operations = []
    max_distance = max(distances.values())
    for d in range(max_distance + 1):
        nodes_at_d = [node for node, dist in distances.items() if dist == d]
        
        if nodes_at_d:
            operations.append((nodes_at_d[0], d))
        
    #State of the program after the  for loop has been executed: `nodes_at_d` is a list of nodes with the maximum distance `max_distance` from the starting point, `d` is `max_distance`, `max_distance` is the maximum value in the `distances` list, and `operations` contains tuples `(nodes_at_d[i], max_distance)` for each node `nodes_at_d[i]` if `nodes_at_d` is not empty. If `nodes_at_d` is empty, `operations` contains the tuple `(nodes_at_d[0], 1)` if it was added during previous iterations, otherwise it remains unchanged.
    return len(operations), operations
    #The program returns (len(operations), operations) where operations contains tuples (nodes_at_d[i], max_distance) for each node nodes_at_d[i] if nodes_at_d is not empty, otherwise it contains the tuple (nodes_at_d[0], 1)
#Overall this is what the function does:The function `func_2` accepts two parameters: `n` (a positive integer such that \(1 \leq n \leq 2 \times 10^3\)) and `edges` (a list of tuples representing the edges of a tree). It constructs an adjacency list representation of the tree from the given edges. Then, it calculates the distances from vertex 1 to all other vertices using another function `func_1`. Afterward, it determines the maximum distance from vertex 1 to any other vertex and identifies all nodes at that maximum distance. The function then compiles a list of tuples containing the nodes at the maximum distance along with the distance value. If no nodes are found at the maximum distance, it includes the tuple `(nodes_at_d[0], 1)` in the list. Finally, it returns a tuple consisting of the length of the list of operations and the list itself. This function effectively identifies and returns the nodes farthest from the starting point and their distances.




# Your response:
Reasoning:  
Correctness: **True** or **False**

