
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
You are given a tree with n vertices numbered 1, 2, \ldots, n . Initially, all
vertices are colored white.

You can perform the following two-step operation:

  1. Choose a vertex v (1 \leq v \leq n ) and a distance d (0 \leq d \leq n-1 ). 
  2. For all vertices u (1 \leq u \leq n ) such that \text{dist}^\dagger(u,v)=d , color u black. 

Construct a sequence of operations to color all the nodes in the tree black
using the minimum possible number of operations. It can be proven that it is
always possible to do so using at most n operations.

^\dagger \text{dist}(x, y) denotes the number of edges on the (unique) simple
path between vertices x and y on the tree.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 200 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^3 ) — the number of vertices of the tree.

The following n - 1 lines of each test case describe the edges of the tree.
The i -th of these lines contains two integers u_i and v_i (1 \le u_i, v_i \le
n , u_i \neq v_i ), the indices of the vertices connected by the i -th edge.

It is guaranteed that the given edges form a tree.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^3 .

Output

For each test case, first output a single integer op (1 \le op \le n) , the
minimum number of operations needed to color all vertices of the tree black.

Then, output op lines, each containing 2 integers. The i -th line should
contain the values of v and d chosen for the i -th operation (1 \le v \le n ,
0 \le d \le n - 1 )

You must guarantee that at the end of op operations, all vertices are colored
black.

If there are multiple solutions, you may output any one of them.

Example

Input

    4
    
    1
    
    2
    
    1 2
    
    4
    
    1 2
    
    1 3
    
    1 4
    
    7
    
    2 7
    
    3 2
    
    6 4
    
    5 7
    
    1 6
    
    6 7

Output

    1
    1 0
    2
    1 1
    2 1
    2
    1 1
    2 1
    3
    6 1
    7 1
    2 1

Note

In the first test case, there is only one possible operation, and performing
it gives us a valid answer.

In the second test case, the first operation colors vertex 2 black, and the
second operation colors vertex 1 black. It can be shown that it is impossible
to color both vertices black in one operation, so the minimum number of
operations needed is 2 . Another possible solution is to use the 2 operations:
(u, r) = (1, 0) and (u, r) = (2, 0) .

In the third test case, the first operation colors vertices 2 , 3 and 4 black,
and the second operation colors vertex 1 black. Again, it can be shown that it
is impossible to color all vertices black in 1 operation, so the minimum
number of operations needed is 2 .

In the fourth test case, the first operation colors vertices 4 , 1 and 7
black, the second operation colors vertices 2 , 5 and 6 black while the third
operation colors vertices 3 and 7 black. Notice that it is allowed to color
vertex 7 black twice.

Thus, each node was marked at least once, with node 7 marked twice. It can be
shown that it is impossible to color all vertices black in fewer than 3 moves.

- Program: 

#Function 1:
def func_1(tree, start_node):
    from collections import deque
    queue = deque([start_node])
    distances = {start_node: 0}
    while queue:
        node = queue.popleft()
        current_distance = distances[node]
        for neighbor in tree[node]:
            if neighbor not in distances:
                distances[neighbor] = current_distance + 1
                queue.append(neighbor)
    return distances

#Function 2:
def func_2(n, edges):
    tree = {i: [] for i in range(1, n + 1)}
    for (u, v) in edges:
        tree[u].append(v)
        tree[v].append(u)
    distances = func_1(tree, 1)
    operations = []
    max_distance = max(distances.values())
    for d in range(max_distance + 1):
        nodes_at_d = [node for (node, dist) in distances.items() if dist == d]
        if nodes_at_d:
            operations.append((nodes_at_d[0], d))
    return (len(operations), operations)



- Annotated Code: 
n = 4
edges = [(1, 2), (1, 3), (1, 4)]
(num_operations, operations) = func_2(n, edges)
print(num_operations)
for (v, d) in operations:
    print(v, d)

#Function 1:
#State of the program right berfore the function call: tree is a dictionary where keys are integers representing nodes and values are lists of integers representing neighbors of the key node; start_node is an integer representing the starting node for the breadth-first search (BFS), such that 1 <= start_node <= n.
def func_1(tree, start_node):
    queue = deque([start_node])
    distances = {start_node: 0}
    while queue:
        node = queue.popleft()
        
        current_distance = distances[node]
        
        for neighbor in tree[node]:
            if neighbor not in distances:
                distances[neighbor] = current_distance + 1
                queue.append(neighbor)
        
    #State of the program after the loop has been executed: `queue` is empty, `node` is the last node processed in the BFS traversal, `distances` is a dictionary mapping each node in the graph that can be reached from the `start_node` to its shortest distance from the `start_node`, and `start_node` is an integer with \(1 \leq \text{start_node} \leq n\).
    return distances
    #`The program returns the dictionary 'distances' which maps each node in the graph that can be reached from the 'start_node' to its shortest distance from the 'start_node'`

#Function 2:
#State of the program right berfore the function call: n is a positive integer such that 1 <= n <= 2 * 10^3, edges is a list of tuples representing the edges of the tree where each tuple (u, v) indicates an edge connecting vertices u and v, and distances is a dictionary mapping each vertex to its distance from vertex 1.
def func_2(n, edges):
    tree = {i: [] for i in range(1, n + 1)}
    for (u, v) in edges:
        tree[u].append(v)
        
        tree[v].append(u)
        
    #State of the program after the  for loop has been executed: `edges` is a list of tuples representing the edges of the tree, `tree[u]` includes all vertices `v` connected to `u` through edges, `tree[v]` includes all vertices `u` connected to `v` through edges, `tree` is a dictionary where each key is an integer from 1 to `n` (inclusive), and the corresponding value for each key is a list of all vertices connected to that key through the edges.
    distances = func_1(tree, 1)
    operations = []
    max_distance = max(distances.values())
    for d in range(max_distance + 1):
        nodes_at_d = [node for node, dist in distances.items() if dist == d]
        
        if nodes_at_d:
            operations.append((nodes_at_d[0], d))
        
    #State of the program after the  for loop has been executed: `nodes_at_d` is a list of nodes with the maximum distance `max_distance` from the starting point, `d` is `max_distance`, `max_distance` is the maximum value in the `distances` list, and `operations` contains tuples `(nodes_at_d[i], max_distance)` for each node `nodes_at_d[i]` if `nodes_at_d` is not empty. If `nodes_at_d` is empty, `operations` contains the tuple `(nodes_at_d[0], 1)` if it was added during previous iterations, otherwise it remains unchanged.
    return len(operations), operations
    #The program returns (len(operations), operations) where operations contains tuples (nodes_at_d[i], max_distance) for each node nodes_at_d[i] if nodes_at_d is not empty, otherwise it contains the tuple (nodes_at_d[0], 1)




Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided program does not correctly implement the solution for coloring all nodes in a tree black using the minimum number of operations. Specifically, the program `func_2` calculates distances from a start node (node 1 in this case) but does not ensure that all nodes are colored black with the minimum number of operations. Here’s why:

1. **Incorrect Calculation of Operations**: The program calculates distances from node 1 and then iterates over these distances to select nodes. However, it does not guarantee that the selected nodes will cover all nodes in the tree. For instance, consider a tree where the structure is more complex than just a straight chain. For example, a star graph (a central node connected to all other nodes).

2. **Example Test Case Failing**:
   - Consider a star graph with 4 nodes where node 1 is the center and nodes 2, 3, and 4 are connected to node 1. The distances calculated from node 1 will be:
     - Node 1: 0
     - Nodes 2, 3, 4: 1
   - According to the program, it would select node 1 (distance 0) and nodes 2, 3, 4 (distance 1). This will indeed color all nodes, but it is not the optimal solution. The optimal solution would be to choose node 1 (distance 0) and then choose one of the leaf nodes (distance 1), which will also color all nodes in one additional step.

Given these points, the program does not guarantee the minimum number of operations in all cases, hence it is incorrect.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

