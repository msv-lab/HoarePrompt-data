
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
You are given a tree with n vertices numbered 1, 2, \ldots, n . Initially, all
vertices are colored white.

You can perform the following two-step operation:

  1. Choose a vertex v (1 \leq v \leq n ) and a distance d (0 \leq d \leq n-1 ). 
  2. For all vertices u (1 \leq u \leq n ) such that \text{dist}^\dagger(u,v)=d , color u black. 

Construct a sequence of operations to color all the nodes in the tree black
using the minimum possible number of operations. It can be proven that it is
always possible to do so using at most n operations.

^\dagger \text{dist}(x, y) denotes the number of edges on the (unique) simple
path between vertices x and y on the tree.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 200 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^3 ) — the number of vertices of the tree.

The following n - 1 lines of each test case describe the edges of the tree.
The i -th of these lines contains two integers u_i and v_i (1 \le u_i, v_i \le
n , u_i \neq v_i ), the indices of the vertices connected by the i -th edge.

It is guaranteed that the given edges form a tree.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^3 .

Output

For each test case, first output a single integer op (1 \le op \le n) , the
minimum number of operations needed to color all vertices of the tree black.

Then, output op lines, each containing 2 integers. The i -th line should
contain the values of v and d chosen for the i -th operation (1 \le v \le n ,
0 \le d \le n - 1 )

You must guarantee that at the end of op operations, all vertices are colored
black.

If there are multiple solutions, you may output any one of them.

Example

Input

    4
    
    1
    
    2
    
    1 2
    
    4
    
    1 2
    
    1 3
    
    1 4
    
    7
    
    2 7
    
    3 2
    
    6 4
    
    5 7
    
    1 6
    
    6 7

Output

    1
    1 0
    2
    1 1
    2 1
    2
    1 1
    2 1
    3
    6 1
    7 1
    2 1

Note

In the first test case, there is only one possible operation, and performing
it gives us a valid answer.

In the second test case, the first operation colors vertex 2 black, and the
second operation colors vertex 1 black. It can be shown that it is impossible
to color both vertices black in one operation, so the minimum number of
operations needed is 2 . Another possible solution is to use the 2 operations:
(u, r) = (1, 0) and (u, r) = (2, 0) .

In the third test case, the first operation colors vertices 2 , 3 and 4 black,
and the second operation colors vertex 1 black. Again, it can be shown that it
is impossible to color all vertices black in 1 operation, so the minimum
number of operations needed is 2 .

In the fourth test case, the first operation colors vertices 4 , 1 and 7
black, the second operation colors vertices 2 , 5 and 6 black while the third
operation colors vertices 3 and 7 black. Notice that it is allowed to color
vertex 7 black twice.

Thus, each node was marked at least once, with node 7 marked twice. It can be
shown that it is impossible to color all vertices black in fewer than 3 moves.

- Program: 

#Function 1:
def func_1(tree, start_node):
    from collections import deque
    queue = deque([start_node])
    distances = {start_node: 0}
    while queue:
        node = queue.popleft()
        current_distance = distances[node]
        for neighbor in tree[node]:
            if neighbor not in distances:
                distances[neighbor] = current_distance + 1
                queue.append(neighbor)
    return distances

#Function 2:
def func_2(n, edges):
    tree = {i: [] for i in range(1, n + 1)}
    for (u, v) in edges:
        tree[u].append(v)
        tree[v].append(u)
    distances = func_1(tree, 1)
    operations = []
    max_distance = max(distances.values())
    for d in range(max_distance + 1):
        nodes_at_d = [node for (node, dist) in distances.items() if dist == d]
        if nodes_at_d:
            operations.append((nodes_at_d[0], d))
    return (len(operations), operations)



- Annotated Code: 
n = 4
edges = [(1, 2), (1, 3), (1, 4)]
(num_operations, operations) = func_2(n, edges)
print(num_operations)
for (v, d) in operations:
    print(v, d)

#Function 1:
#State of the program right berfore the function call: tree is a dictionary where keys are integers representing nodes and values are lists of integers representing neighbors of the key node; start_node is an integer representing the starting node for the breadth-first search (BFS), such that 1 <= start_node <= n.
def func_1(tree, start_node):
    queue = deque([start_node])
    distances = {start_node: 0}
    while queue:
        node = queue.popleft()
        
        current_distance = distances[node]
        
        for neighbor in tree[node]:
            if neighbor not in distances:
                distances[neighbor] = current_distance + 1
                queue.append(neighbor)
        
    #State of the program after the loop has been executed: `queue` is empty, `node` is the last node processed in the BFS traversal, `distances` is a dictionary mapping each node in the graph that can be reached from the `start_node` to its shortest distance from the `start_node`, and `start_node` is an integer with \(1 \leq \text{start_node} \leq n\).
    return distances
    #`The program returns the dictionary 'distances' which maps each node in the graph that can be reached from the 'start_node' to its shortest distance from the 'start_node'`

#Function 2:
#State of the program right berfore the function call: n is a positive integer such that 1 <= n <= 2 * 10^3, edges is a list of tuples representing the edges of the tree where each tuple (u, v) indicates an edge connecting vertices u and v, and distances is a dictionary mapping each vertex to its distance from vertex 1.
def func_2(n, edges):
    tree = {i: [] for i in range(1, n + 1)}
    for (u, v) in edges:
        tree[u].append(v)
        
        tree[v].append(u)
        
    #State of the program after the  for loop has been executed: `edges` is a list of tuples representing the edges of the tree, `tree[u]` includes all vertices `v` connected to `u` through edges, `tree[v]` includes all vertices `u` connected to `v` through edges, `tree` is a dictionary where each key is an integer from 1 to `n` (inclusive), and the corresponding value for each key is a list of all vertices connected to that key through the edges.
    distances = func_1(tree, 1)
    operations = []
    max_distance = max(distances.values())
    for d in range(max_distance + 1):
        nodes_at_d = [node for node, dist in distances.items() if dist == d]
        
        if nodes_at_d:
            operations.append((nodes_at_d[0], d))
        
    #State of the program after the  for loop has been executed: `nodes_at_d` is a list of nodes with the maximum distance `max_distance` from the starting point, `d` is `max_distance`, `max_distance` is the maximum value in the `distances` list, and `operations` contains tuples `(nodes_at_d[i], max_distance)` for each node `nodes_at_d[i]` if `nodes_at_d` is not empty. If `nodes_at_d` is empty, `operations` contains the tuple `(nodes_at_d[0], 1)` if it was added during previous iterations, otherwise it remains unchanged.
    return len(operations), operations
    #The program returns (len(operations), operations) where operations contains tuples (nodes_at_d[i], max_distance) for each node nodes_at_d[i] if nodes_at_d is not empty, otherwise it contains the tuple (nodes_at_d[0], 1)




Beggining of Original Assessment: 
### Reasoning:

To determine if the provided Python program is correct, we need to analyze whether the functions `func_1` and `func_2` correctly implement the logic described in the problem statement.

1. **Function `func_1`:**
   - This function performs a breadth-first search (BFS) to compute the shortest distances from a given start node to all other nodes in the tree.
   - The BFS is implemented correctly using a queue to traverse the tree level by level.
   - The distances are stored in the `distances` dictionary, which maps each node to its distance from the start node.

2. **Function `func_2`:**
   - This function constructs an adjacency list representation of the tree from the given edges.
   - It then calls `func_1` to get the distances from node 1 to all other nodes.
   - The maximum distance from node 1 to any other node is calculated.
   - The function then iterates over all possible distances from 0 to the maximum distance.
   - For each distance `d`, it collects all nodes that are exactly `d` distance away from the root node.
   - If there are such nodes, it adds an operation to color those nodes black and appends `(v, d)` to the `operations` list.

Let's verify if this approach meets the requirements:
- The BFS in `func_1` ensures that the distances are computed correctly.
- The construction of the tree in `func_2` and the collection of nodes at each distance ensure that all nodes are eventually colored black.
- The operations generated will color all nodes with the minimum number of steps because each operation targets nodes at a specific distance from the root, ensuring that all nodes are eventually covered without redundant coloring.

Given the above analysis, the functions appear to correctly implement the required logic to solve the problem.

### Conclusion:
**Correctness: True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

