
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
This is an easy version of the problem; it differs from the hard version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ), the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot). Then output k non-negative integers a_1, a_2, \dots,
a_k , where:

  * a_i=0 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot does not increase (i.e., remains equal to \alpha ); 
  * a_i=1 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot increases (i.e., becomes greater than \alpha ). 

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where:

  * a_i=0 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot does not increase compared to the case when all k fountains belong to Bob; 
  * a_i=1 , if after Bob gives Alice the i -th fountain, the maximum possible size of Alice's plot increases compared to the case when all k fountains belong to Bob. 

If you output any other positive number instead of 1 that fits into a 64-bit
signed integer type, it will also be recognized as 1 . Thus, a solution to the
hard version of this problem will also pass the tests for the easy version.

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 1 
    1
    0 0 1 1 0 0 0 0 0 
    6
    1 0 0 0 
    1
    1 1 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.

- Program: 
def func():
    t = int(input())
    for z in range(t):
        (n, m, k) = map(int, input().split())
        c = []
        for i in range(k):
            (x, y) = map(int, input().split())
            c.append((y, x, i))
        c.sort()
        f = [(1, 0, 0)]
        s = 0
        answer = [0] * k
        for i in range(k):
            if c[i][1] > f[-1][1]:
                s += (c[i][0] - 1) * (c[i][1] - f[-1][1])
                f.append((c[i][0], c[i][1], c[i][2]))
        answer[f[-1][2]] = 1
        for i in range(1, len(f) - 1):
            if f[i][0] < f[i + 1][0]:
                answer[f[i][2]] = 1
        print(s + (n - f[-1][1]) * m)
        print(*answer)



- Annotated Code: 
#State of the program right berfore the function call: t is an integer such that 1 <= t <= 10^4. Each test case consists of n, m, and k, where 2 <= n, m <= 10^9 and 2 <= k <= 2 * 10^5. There are k pairs of integers r_i and c_i, where 1 <= r_i <= n and 1 <= c_i <= m, representing the coordinates of fountains. All fountains have distinct positions, and no fountain is at (n, 1).
def func():
    t = int(input())
    for z in range(t):
        n, m, k = map(int, input().split())
        
        c = []
        
        for i in range(k):
            x, y = map(int, input().split())
            c.append((y, x, i))
        
        c.sort()
        
        f = [(1, 0, 0)]
        
        s = 0
        
        answer = [0] * k
        
        for i in range(k):
            if c[i][1] > f[-1][1]:
                s += (c[i][0] - 1) * (c[i][1] - f[-1][1])
                f.append((c[i][0], c[i][1], c[i][2]))
        
        answer[f[-1][2]] = 1
        
        for i in range(1, len(f) - 1):
            if f[i][0] < f[i + 1][0]:
                answer[f[i][2]] = 1
        
        print(s + (n - f[-1][1]) * m)
        
        print(*answer)
        
    #State of the program after the  for loop has been executed: `total` is 0, `i` is `len(f) - 1`, `c` is a list of `k` tuples sorted by the first element, `n` is the last new input integer, `m` is the last new input integer, `k` is the last new input integer, `x` is the last first integer input, `y` is the last second integer input, `s` is the accumulated sum of \((c[i][0] - 1) * (c[i][1] - f[-1][1])\) for all `i` where \(c[i][1] > f[-1][1]\), `f` is a list of tuples from `c` that satisfy the condition \(c[i][1] > f[-1][1]\), and `answer` is a list of `k` zeros with multiple elements set to 1 based on the indices `f[i][2]` where the condition `f[i][0] < f[i + 1][0]` is true; the output of the program is `s + (n - f[-1][1]) * m`.
#Overall this is what the function does:The function processes `t` test cases, where `t` is an integer such that \(1 \leq t \leq 10^4\). For each test case, it accepts three integers `n`, `m`, and `k` with specified ranges, and `k` pairs of integers representing fountain coordinates. The function then calculates and prints two outputs for each test case:
1. A sum `s` which is the result of the expression \((c[i][0] - 1) * (c[i][1] - f[-1][1])\) for all `i` where \(c[i][1] > f[-1][1]\).
2. A list `answer` of length `k` where each element is 1 if the corresponding fountain index satisfies certain conditions, and 0 otherwise.
Specifically, the function sorts the fountain coordinates by the first element, iterates through them to calculate `s`, and updates the `answer` list based on the relative positions of the fountains. After processing all test cases, the function prints the total sum `s` plus the product of `n - f[-1][1]` and `m`, followed by the `answer` list.


Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided program does not correctly implement the logic required to solve the problem. Specifically, the program attempts to calculate the maximum size of Alice's plot by considering the positions of the fountains and the boundaries of the field. However, the implementation does not correctly handle the scenario where a fountain might increase the size of Alice's plot.

To illustrate the issue, consider the following test case:

```
3 3 3
1 2
2 1
2 3
```

The expected output for this case would be:
```
4
0 1 0
```

Here, the maximum size of Alice's plot without any fountains is 4 (if she starts from the top-left corner and goes to the bottom-right corner). Giving the fountain at (2, 3) to Alice would allow her to include the entire column 3 in her plot, increasing the size to 4. However, the current implementation does not correctly account for this scenario.

In the given program, the variable `s` is calculated based on the positions of the fountains and the boundaries, but it does not properly update the `answer` array to reflect the increased size of Alice's plot when a fountain is given to her. Specifically, the logic for updating the `answer` array and calculating the final size of Alice's plot is flawed.

Thus, the program does not correctly handle all potential cases and fails to provide the correct output for some scenarios.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

