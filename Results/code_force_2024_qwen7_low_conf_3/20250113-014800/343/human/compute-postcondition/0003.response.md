To determine which states need to be adjusted for the loop to execute one more time, we need to analyze the condition of the `while` loop:

The loop condition is:
\[ \text{len(smallList)} > 0 \text{ and } \text{bigList}[-1] == \text{smallList}[-1] \]

This means the loop will continue as long as:
1. The length of `smallList` is greater than 0.
2. The last element of `bigList` is equal to the last element of `smallList`.

Given the current state:
- `bigList` is a list of integers with its last element removed.
- `smallList` is a list of integers with its last element removed.

Let's break down the conditions:
1. **Length of `smallList`**: Since `smallList` has its last element removed, its length is currently `len(smallList)` (which is `len(smallList) - 1` from the previous state). For the loop to continue, this length must still be greater than 0. Therefore, `smallList` must have at least one element left.
2. **Equality of Last Elements**: For the loop to continue, the last element of `bigList` must be equal to the last element of `smallList`.

To satisfy these conditions for the next iteration:
- `smallList` must have at least one element remaining.
- The last element of `bigList` must be equal to the last element of `smallList`.

Since the problem states that both lists had their last elements removed, for the loop to continue, we need to ensure:
- `smallList` has at least one element remaining.
- The last element of `bigList` is equal to the last element of `smallList`.

Thus, the state adjustments needed are:
- `smallList` must have at least one element remaining.
- The last element of `bigList` must be equal to the last element of `smallList`.

So, the final state adjustment is:
State: **`bigList` is a list of integers with its last element removed; `smallList` is a list of integers with its last element removed, and the last element of `bigList` must be equal to the last element of `smallList` and `smallList` must have at least one element remaining**