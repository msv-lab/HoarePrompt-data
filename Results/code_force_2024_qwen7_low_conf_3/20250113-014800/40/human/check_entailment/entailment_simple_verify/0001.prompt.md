
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
There is a hidden array a of size n consisting of only 1 and -1 . Let p be the
prefix sums of array a . More formally, p is an array of length n defined as
p_i = a_1 + a_2 + \ldots + a_i . Afterwards, array p is sorted in non-
decreasing order. For example, if a = [1, -1, -1, 1, 1] , then p = [1, 0, -1,
0, 1] before sorting and p = [-1, 0, 0, 1, 1] after sorting.

You are given the prefix sum array p after sorting, but you do not know what
array a is. Your task is to count the number of initial arrays a such that the
above process results in the given sorted prefix sum array p . As this number
can be large, you are only required to find it modulo 998\,244\,353 .

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 1000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 5000
) — the size of the hidden array a .

The second line of each test case contains n integers p_1, p_2, \ldots, p_n
(|p_i| \le n ) — the n prefix sums of a sorted in non-decreasing order.

It is guaranteed that p_1 \le p_2 \le \ldots \le p_n .

It is guaranteed that the sum of n over all test cases does not exceed 5000 .

Output

For each test case, output the answer modulo 998\,244\,353 .

Example

Input

    5
    
    1
    
    0
    
    1
    
    1
    
    3
    
    -1 1 2
    
    5
    
    -1 0 0 1 1
    
    5
    
    -4 -3 -3 -2 -1

Output

    0
    1
    0
    3
    1
    
Note

In the first two test cases, the only possible arrays a for n = 1 are a = [1]
and a = [-1] . Their respective sorted prefix sum arrays p are p = [1] and p =
[-1] . Hence, there is no array a that can result in the sorted prefix sum
array p = [0] and there is exactly 1 array a that can result in the sorted
prefix sum array p = [1] .

In the third test case, it can be proven that there is no array a that could
result in the sorted prefix sum array p = [-1, 1, 2] .

In the fourth test case, the 3 possible arrays a that could result in the
sorted prefix sum array p = [-1, 0, 0, 1, 1] are:

  * a = [1, -1, 1, -1, -1] . The prefix sum array before sorting is p = [1, 0, 1, 0, -1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [1, -1, -1, 1, 1] . The prefix sum array before sorting is p = [1, 0, -1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [-1, 1, 1, -1, 1] . The prefix sum array before sorting is p = [-1, 0, 1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 

For the fifth test case, the only possible array a that could result in the
sorted prefix sum array p = [-4, -3, -3, -2, -1] is a = [-1, -1, -1, -1, 1] .

- Program: 

#Function 1:
def func_1(n, p):
    dp = [0] * (2 * n + 1)
    offset = n
    dp[offset] = 1
    for i in range(1, n + 1):
        new_dp = [0] * (2 * n + 1)
        for j in range(2 * n + 1):
            if dp[j] > 0:
                if j + 1 <= 2 * n:
                    new_dp[j + 1] = (new_dp[j + 1] + dp[j]) % MOD
                if j - 1 >= 0:
                    new_dp[j - 1] = (new_dp[j - 1] + dp[j]) % MOD
        dp = new_dp
    final_sum = p[-1] + offset
    return dp[final_sum]

#Function 2:
def func_2():
    import sys
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        index += 1
        p = list(map(int, data[index:index + n]))
        index += n
        result = func_1(n, p)
        results.append(result)
    for res in results:
        print(res)



- Annotated Code: 
MOD = 998244353
if __name__ == '__main__':
    func_2()

#Function 1:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 5000, and p is a list of n integers where |p[i]| ≤ n for all 0 ≤ i < n, representing the sorted prefix sums of some hidden array a consisting of only 1 and -1.
def func_1(n, p):
    dp = [0] * (2 * n + 1)
    offset = n
    dp[offset] = 1
    for i in range(1, n + 1):
        new_dp = [0] * (2 * n + 1)
        
        for j in range(2 * n + 1):
            if dp[j] > 0:
                if j + 1 <= 2 * n:
                    new_dp[j + 1] = (new_dp[j + 1] + dp[j]) % MOD
                if j - 1 >= 0:
                    new_dp[j - 1] = (new_dp[j - 1] + dp[j]) % MOD
        
        dp = new_dp
        
    #State of the program after the  for loop has been executed: `n` is an integer such that \(1 \leq n \leq 5000\), `p` is a list of `n` integers where \(|p[i]| \leq n\) for all \(0 \leq i < n\), `offset` is equal to `n`, `new_dp` is a list of length \(2 \times n + 1\) holding the cumulative sum of the values of `dp[k]` for all `k` where `dp[k] > 0`, and `dp` is a list of length \(2 \times n + 1\) holding the same elements as `new_dp`.
    final_sum = p[-1] + offset
    return dp[final_sum]
    #The program returns dp[final_sum], where final_sum is p[-1] + n

#Function 2:
#State of the program right berfore the function call: t is a positive integer indicating the number of test cases, n is a positive integer such that 1 <= n <= 5000 indicating the size of the hidden array a for each test case, and p is a list of n integers where |pi| <= n and p is sorted in non-decreasing order.
def func_2():
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        
        index += 1
        
        p = list(map(int, data[index:index + n]))
        
        index += n
        
        result = func_1(n, p)
        
        results.append(result)
        
    #State of the program after the  for loop has been executed: `t` is a positive integer equal to the initial value of `int(data[1])`, `n` is a positive integer such that 1 <= n <= 5000, `p` is a list of `n` integers where |pi| <= n and `p` is sorted in non-decreasing order, `data` is a list of strings representing the input split by spaces, `index` is the final value of `index + n * t`, `results` is a list containing the return values of `func_1(n, p)` for each iteration of the loop, `result` is the return value of `func_1(n, p)` for the last iteration.
    for res in results:
        print(res)
        
    #State of the program after the  for loop has been executed: `results` is a list containing the return values of `func_1(n, p)` for each iteration of the loop, `res` is unchanged and equal to the last element of `results`.




Beggining of Original Assessment: 
### Reasoning:

Let's analyze the given code step-by-step to determine its correctness.

1. **Function `func_1`**:
   - This function aims to simulate the construction of the prefix sum array \( p \) before sorting.
   - It uses dynamic programming to compute the number of ways to construct a prefix sum array that matches the given sorted prefix sum array \( p \).
   - The state `dp[i]` represents the number of ways to achieve a prefix sum of \( i - n \) (since we start with an offset `n`).

2. **Dynamic Programming Transition**:
   - For each element in the prefix sum array \( p \), the function updates the DP table to account for adding or subtracting one from the current prefix sum.
   - Specifically, if `dp[j]` is non-zero, it means there are ways to reach a prefix sum of \( j - n \). The next possible prefix sums would be \( j - 1 \) and \( j + 1 \), each contributing to the next state.

3. **Final Sum Calculation**:
   - The final sum `final_sum` is calculated as \( p[-1] + n \), which corresponds to the last element in the original unsorted prefix sum array.
   - The function returns the value in `dp[final_sum]`, which should give the number of ways to construct the original array \( a \) that results in the given sorted prefix sum array \( p \).

4. **Function `func_2`**:
   - This function reads input from standard input, processes multiple test cases, and calls `func_1` for each test case.
   - It reads the number of test cases \( t \), the size of the array \( n \), and the sorted prefix sum array \( p \) for each test case.
   - It processes each test case by calling `func_1` and stores the result.
   - Finally, it prints the results for each test case.

### Correctness Analysis:

- **Input Handling**: The function correctly handles reading input and splitting it into individual test cases.
- **DP Table Initialization**: The DP table is initialized properly with an offset of `n`.
- **DP Transition Logic**: The transition logic in `func_1` is correct for simulating the prefix sum construction.
- **Final Sum Calculation**: The calculation of `final_sum` is correct and aligns with the problem statement.
- **Output**: The output is correctly formatted and modulo \( 998244353 \) is applied as required.

Given the analysis, the provided program correctly implements the solution for the given problem statement.

### Conclusion:

**Correctness: True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

