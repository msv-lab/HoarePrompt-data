
You are a program verifier. Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
This is a hard version of the problem; it differs from the easy version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ); the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot).

Then output k non-negative integers a_1, a_2, \dots, a_k , where a_i is a
value such that after Bob gives Alice the i -th fountain, the maximum size of
her plot will be \alpha + a_i .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where a_i is a value such that
after Bob gives Alice the i -th fountain, the maximum size of her plot will be
\alpha + a_i .

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 4 
    1
    0 0 1 1 0 0 0 0 0 
    6
    15 0 0 0 
    1
    2 3 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.

# Annotated Functions:
import math

if __name__ == '__main__':
    func_2()

#Function 1:
#State of the program right berfore the function call: fountain is a tuple containing two integers (r, c) representing the coordinates of a fountain on the field, n and m are integers representing the dimensions of the field where 2 <= n, m <= 10^9.
def func_1(fountain, n, m):
    r, c = fountain
    diagonal_distance = abs(r + c - (n + 1))
    return max(diagonal_distance // 2, 0)
    #max(abs(r + c - (n + 1)) // 2, 0)
#Overall this is what the function does:The function `func_1` accepts a tuple `fountain` containing the coordinates `(r, c)` of a fountain on a field with dimensions `n` by `m`, and returns the calculated value based on the formula `max(abs(r + c - (n + 1)) // 2, 0)`. 

This function calculates the maximum of zero and half of the absolute difference between the sum of the fountain's coordinates `(r + c)` and the sum of the field's dimensions `(n + 1)`, rounded down to the nearest integer. The function handles the case where the result could be negative by ensuring it is at least zero. There are no explicit edge cases mentioned in the annotations or code, but it implicitly handles the minimum possible value of zero for the result. The function does not modify any external state and only uses the provided parameters to compute its output.

#Function 2:
#State of the program right berfore the function call: t is an integer representing the number of test cases, n and m are integers such that 2 ≤ n, m ≤ 10^9, k is an integer such that 2 ≤ k ≤ 2·10^5, r and c are integers such that 1 ≤ r ≤ n and 1 ≤ c ≤ m, and each (r, c) represents the coordinates of a fountain in the field.
def func_2():
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        
        m = int(data[index + 1])
        
        k = int(data[index + 2])
        
        index += 3
        
        alpha = (n * m + 1) // 2
        
        additional_areas = []
        
        for __ in range(k):
            r = int(data[index])
            c = int(data[index + 1])
            index += 2
            additional_areas.append(func_1((r, c), n, m))
        
        results.append((alpha, additional_areas))
        
    #State of the program after the  for loop has been executed: `t` is the original integer value of `data[0]`, `n` is the integer value of `data[index - (2 * k)]`, `m` is the integer value of `data[index - (2 * k) - 1]`, `k` is 0, `r` is the integer value of `data[index - (k-1)*2]`, `c` is the integer value of `data[(index - (k-1)*2) + 1]`, `alpha = (n \times m + 1) // 2`, `additional_areas` is a list containing the results of `func_1((r, c), n, m)` for each iteration, `results` is a list containing tuples `(alpha, additional_areas)` for each iteration.
    for result in results:
        alpha, additional_areas = result
        
        print(alpha)
        
        print(' '.join(map(str, additional_areas)))
        
    #State of the program after the  for loop has been executed: `results` is a list containing tuples, where each tuple contains an `alpha` and a list `additional_areas` representing the results of `func_1((r, c), n, m)` for each iteration; `alpha` is the value calculated as `(n \times m + 1) // 2` for the original values of `n` and `m` from the initial state; `additional_areas` is a list of results obtained from calling `func_1((r, c), n, m)` for each iteration; the console prints the string representation of `additional_areas` elements joined by a space for each iteration.
#Overall this is what the function does:The function processes a series of test cases, where each test case involves validating grid dimensions \(n\) and \(m\), and the number of fountains \(k\) within those dimensions. For each test case, it reads the coordinates of fountains \((r, c)\) and calculates two values: the total number of fountains in the grid plus one, halved, and the additional areas affected by each fountain. These values are stored in a list for each test case. After processing all test cases, the function prints the calculated values for each test case, including the total number of fountains and the additional areas affected by each fountain. Potential edge cases include invalid input values for \(t\), \(n\), \(m\), \(k\), \(r\), and \(c\), which would result in an error message being printed.




# Your response:
Reasoning:  
Correctness: **True** or **False**

