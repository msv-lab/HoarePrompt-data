
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
In the Master's Assistance Center, Nyam-Nyam was given a homework assignment
in informatics.

There is an array a of length n , and you want to divide it into k > 1
subsegments^{\dagger} in such a way that the \operatorname{MEX} ^{\ddagger} on
each subsegment is equal to the same integer.

Help Nyam-Nyam find any suitable division, or determine that it does not
exist.

^{\dagger} A division of an array into k subsegments is defined as k pairs of
integers (l_1, r_1), (l_2, r_2), \ldots, (l_k, r_k) such that l_i \le r_i and
for each 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 , and also l_1 = 1 and r_k =
n . These pairs represent the subsegments themselves.

^{\ddagger}\operatorname{MEX} of an array is the smallest non-negative integer
that does not belong to the array.

For example:

  * \operatorname{MEX} of the array [2, 2, 1] is 0 , because 0 does not belong to the array. 
  * \operatorname{MEX} of the array [3, 1, 0, 1] is 2 , because 0 and 1 belong to the array, but 2 does not. 
  * \operatorname{MEX} of the array [0, 3, 1, 2] is 4 , because 0 , 1 , 2 , and 3 belong to the array, but 4 does not. 

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < n ) — the elements of the array a .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer -1 if a suitable division does not
exist.

Otherwise, on the first line, output an integer k (2 \le k \le n ) — the
number of subsegments in the division.

Then output k lines — the division into subsegments. The i -th line should
contain two integers l_i and r_i (1 \le l_i \le r_i \le n ) — the boundaries
of the i -th subsegment.

The following conditions must be satisfied:

  * For all 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 ;
  * l_1 = 1 , r_k = n .

If there are multiple possible solutions, output any of them.

Example

Input

    5
    
    2
    
    0 0
    
    5
    
    0 1 2 3 4
    
    8
    
    0 1 7 1 0 1 0 3
    
    3
    
    2 2 2
    
    4
    
    0 1 2 0

Output

    2
    1 1
    2 2
    -1
    3
    1 3
    4 5
    6 8
    3
    1 1
    2 2
    3 3
    -1

Note

In the first test case, the array a can be divided into 2 subsegments with
boundaries [1, 1] and [2, 2] :

  * \operatorname{MEX} of the first subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 
  * \operatorname{MEX} of the second subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 

In the second test case, it can be proven that the required division does not
exist.

In the third test case, the array a can be divided into 3 subsegments with
boundaries [1, 3] , [4, 5] , [6, 8] :

  * \operatorname{MEX} of the first subsegment [0, 1, 7] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the second subsegment [1, 0] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the third subsegment [1, 0, 3] is 2 , as 0 and 1 belong to the subsegment, but 2 does not.

- Program: 
test_cases = int(input())
for _ in range(test_cases):
    size = int(input())
    arr = list(map(int, input().split()))
    mex = func_1(arr)
    if mex == 0:
        print(2)
        print(1, 1)
        print(2, size)
        continue
    cnt = 0
    start = 0
    segments = []
    num_set = set()
    for i in range(size):
        if arr[i] < mex:
            num_set.add(arr[i])
        if len(num_set) == mex:
            segments.append((start + 1, i + 1))
            start = i + 1
            num_set.clear()
    if num_set:
        segments[-1] = (segments[-1][0], size)
    if len(segments) < 2:
        print(-1)
    else:
        print(len(segments))
        for seg in segments:
            print(seg[0], seg[1])

def func_1(arr):
    num_set = set(arr)
    mex = 0
    while mex in num_set:
        mex += 1
    return mex



- Annotated Code: 
test_cases = int(input())
for _ in range(test_cases):
    size = int(input())
    arr = list(map(int, input().split()))
    mex = func_1(arr)
    if mex == 0:
        print(2)
        print(1, 1)
        print(2, size)
        continue
    cnt = 0
    start = 0
    segments = []
    num_set = set()
    for i in range(size):
        if arr[i] < mex:
            num_set.add(arr[i])
        if len(num_set) == mex:
            segments.append((start + 1, i + 1))
            start = i + 1
            num_set.clear()
    if num_set:
        segments[-1] = (segments[-1][0], size)
    if len(segments) < 2:
        print(-1)
    else:
        print(len(segments))
        for seg in segments:
            print(seg[0], seg[1])

#State of the program right berfore the function call: arr is a list of integers where the length of the list is at least 2 and each element is in the range [0, len(arr) - 1].
def func_1(arr):
    num_set = set(arr)
    mex = 0
    while mex in num_set:
        mex += 1
        
    #State of the program after the loop has been executed: Let's analyze the loop step by step to determine the final state of the variables after the loop has executed.
    #
    #### Initial State:
    #- `arr` is a list of integers where the length of the list is at least 2 and each element is in the range [0, len(arr) - 1].
    #- `num_set` is a set containing the unique elements from `arr`.
    #- `mex` is `0`.
    #
    #### Loop Code:
    #```python
    #while mex in num_set:
    #    mex += 1
    #```
    #
    #### Analysis:
    #
    #1. **First Iteration**:
    #   - `mex` starts at `0`.
    #   - Since `0` is in `num_set`, the loop executes.
    #   - `mex` is incremented to `1`.
    #
    #2. **Second Iteration**:
    #   - `mex` is now `1`.
    #   - Since `1` is in `num_set`, the loop executes.
    #   - `mex` is incremented to `2`.
    #
    #3. **Third Iteration**:
    #   - `mex` is now `2`.
    #   - Since `2` is in `num_set`, the loop executes.
    #   - `mex` is incremented to `3`.
    #
    #4. **General Pattern**:
    #   - After `k` iterations, `mex` is `k`.
    #   - The loop continues as long as `mex` is in `num_set`.
    #
    #5. **Final Iteration**:
    #   - Let's denote the maximum value in `num_set` as `max_val`.
    #   - Once `mex` reaches `max_val + 1`, `mex` will no longer be in `num_set`, and the loop will terminate.
    #
    #### Conclusion:
    #After the loop terminates, `mex` will be the smallest non-negative integer not present in `num_set`.
    #
    #### Output State:
    #- `mex` is the smallest non-negative integer not present in `num_set`.
    #- `num_set` remains unchanged as it is only used to check the presence of `mex`.
    #
    #Thus, the final output state is:
    #**Output State: `mex` is the smallest non-negative integer not present in `num_set`, `num_set` remains unchanged.**
    return mex
    #`mex` is the smallest non-negative integer not present in `num_set`, `num_set` remains unchanged
#Overall this is what the function does:The function `func_1` accepts a list `arr` of integers where each element is in the range [0, len(arr) - 1] and the length of the list is at least 2. It computes the smallest non-negative integer that is not present in the set of unique elements derived from `arr`. The function returns this integer, which is stored in the variable `mex`. The set `num_set`, which contains the unique elements from `arr`, remains unchanged throughout the function's execution. This process involves initializing `num_set` with the unique elements from `arr`, then incrementing `mex` until it finds the smallest non-negative integer not present in `num_set`.


Beggining of Original Assessment: 
Reasoning:
To verify the correctness of the given program, let's break down its logic and compare it against the problem requirements.

1. **Initialization**: The program correctly reads the number of test cases and processes each test case one by one.
2. **Finding MEX**: The function `func_1` correctly calculates the MEX of the array. It checks each integer starting from 0 until it finds the smallest non-negative integer not present in the array.
3. **Segmentation Logic**:
   - If the MEX is 0, the array can trivially be split into two segments where each segment contains only 0, which has a MEX of 1.
   - Otherwise, the program iterates through the array to find segments where the MEX is equal to the calculated MEX value.
   - A `num_set` keeps track of numbers encountered so far. When `num_set` contains all numbers up to the MEX, a new segment is started.
   - If at the end, there are still numbers left in `num_set`, they are added to the last segment.
   - Segments are stored in a list and printed accordingly.
4. **Output Handling**:
   - If no valid segmentation exists, `-1` is printed.
   - Otherwise, the number of segments and their boundaries are printed.

Let's analyze the provided examples:

- **Example 1**: Array `[0, 0]`. MEX is 1. It can be split into `[0]` and `[0]`, both having MEX 1. The program outputs `2 1 1 2 2`, which is correct.
- **Example 2**: Array `[0, 1, 2, 3, 4]`. MEX is 5, which is greater than the array length. No valid segmentation exists, and the program correctly outputs `-1`.
- **Example 3**: Array `[0, 1, 7, 1, 0, 1, 0, 3]`. MEX is 2. The array can be split into `[0, 1, 7]`, `[1, 0]`, and `[1, 0, 3]`, all having MEX 2. The program outputs `3 1 3 4 5 6 8`, which is correct.
- **Example 4**: Array `[2, 2, 2]`. MEX is 0. It can be split into `[2]` and `[2, 2]`, both having MEX 1. The program outputs `2 1 1 2 2`, which is correct.
- **Example 5**: Array `[0, 1, 2, 0]`. MEX is 3. The array can be split into `[0, 1, 2]` and `[0]`, both having MEX 3. The program outputs `3 1 3 4 4`, which is correct.

Given the thorough analysis, the program correctly handles all the test cases and adheres to the problem requirements.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

