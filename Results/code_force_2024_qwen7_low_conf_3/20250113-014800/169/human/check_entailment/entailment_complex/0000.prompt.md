
You are a program verifier. Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
In the Master's Assistance Center, Nyam-Nyam was given a homework assignment
in informatics.

There is an array a of length n , and you want to divide it into k > 1
subsegments^{\dagger} in such a way that the \operatorname{MEX} ^{\ddagger} on
each subsegment is equal to the same integer.

Help Nyam-Nyam find any suitable division, or determine that it does not
exist.

^{\dagger} A division of an array into k subsegments is defined as k pairs of
integers (l_1, r_1), (l_2, r_2), \ldots, (l_k, r_k) such that l_i \le r_i and
for each 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 , and also l_1 = 1 and r_k =
n . These pairs represent the subsegments themselves.

^{\ddagger}\operatorname{MEX} of an array is the smallest non-negative integer
that does not belong to the array.

For example:

  * \operatorname{MEX} of the array [2, 2, 1] is 0 , because 0 does not belong to the array. 
  * \operatorname{MEX} of the array [3, 1, 0, 1] is 2 , because 0 and 1 belong to the array, but 2 does not. 
  * \operatorname{MEX} of the array [0, 3, 1, 2] is 4 , because 0 , 1 , 2 , and 3 belong to the array, but 4 does not. 

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 10^4 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (2 \le n \le 10^5
) — the length of the array a .

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < n ) — the elements of the array a .

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer -1 if a suitable division does not
exist.

Otherwise, on the first line, output an integer k (2 \le k \le n ) — the
number of subsegments in the division.

Then output k lines — the division into subsegments. The i -th line should
contain two integers l_i and r_i (1 \le l_i \le r_i \le n ) — the boundaries
of the i -th subsegment.

The following conditions must be satisfied:

  * For all 1 \le j \le k - 1 , l_{j + 1} = r_j + 1 ;
  * l_1 = 1 , r_k = n .

If there are multiple possible solutions, output any of them.

Example

Input

    5
    
    2
    
    0 0
    
    5
    
    0 1 2 3 4
    
    8
    
    0 1 7 1 0 1 0 3
    
    3
    
    2 2 2
    
    4
    
    0 1 2 0

Output

    2
    1 1
    2 2
    -1
    3
    1 3
    4 5
    6 8
    3
    1 1
    2 2
    3 3
    -1

Note

In the first test case, the array a can be divided into 2 subsegments with
boundaries [1, 1] and [2, 2] :

  * \operatorname{MEX} of the first subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 
  * \operatorname{MEX} of the second subsegment [0] is 1 , as 0 belongs to the subsegment, but 1 does not. 

In the second test case, it can be proven that the required division does not
exist.

In the third test case, the array a can be divided into 3 subsegments with
boundaries [1, 3] , [4, 5] , [6, 8] :

  * \operatorname{MEX} of the first subsegment [0, 1, 7] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the second subsegment [1, 0] is 2 , as 0 and 1 belong to the subsegment, but 2 does not. 
  * \operatorname{MEX} of the third subsegment [1, 0, 3] is 2 , as 0 and 1 belong to the subsegment, but 2 does not.

# Annotated Program:
test_cases = int(input())
for _ in range(test_cases):
    size = int(input())
    arr = list(map(int, input().split()))
    mex = func_1(arr)
    if mex == 0:
        print(2)
        print(1, 1)
        print(2, size)
        continue
    cnt = 0
    start = 0
    segments = []
    num_set = set()
    for i in range(size):
        if arr[i] < mex:
            num_set.add(arr[i])
        if len(num_set) == mex:
            segments.append((start + 1, i + 1))
            start = i + 1
            num_set.clear()
    if num_set:
        segments[-1] = (segments[-1][0], size)
    if len(segments) < 2:
        print(-1)
    else:
        print(len(segments))
        for seg in segments:
            print(seg[0], seg[1])

#State of the program right berfore the function call: arr is a list of integers where the length of the list is at least 2 and each element is in the range [0, len(arr) - 1].
def func_1(arr):
    num_set = set(arr)
    mex = 0
    while mex in num_set:
        mex += 1
        
    #State of the program after the loop has been executed: Let's analyze the loop step by step to determine the final state of the variables after the loop has executed.
    #
    #### Initial State:
    #- `arr` is a list of integers where the length of the list is at least 2 and each element is in the range [0, len(arr) - 1].
    #- `num_set` is a set containing the unique elements from `arr`.
    #- `mex` is `0`.
    #
    #### Loop Code:
    #```python
    #while mex in num_set:
    #    mex += 1
    #```
    #
    #### Analysis:
    #
    #1. **First Iteration**:
    #   - `mex` starts at `0`.
    #   - Since `0` is in `num_set`, the loop executes.
    #   - `mex` is incremented to `1`.
    #
    #2. **Second Iteration**:
    #   - `mex` is now `1`.
    #   - Since `1` is in `num_set`, the loop executes.
    #   - `mex` is incremented to `2`.
    #
    #3. **Third Iteration**:
    #   - `mex` is now `2`.
    #   - Since `2` is in `num_set`, the loop executes.
    #   - `mex` is incremented to `3`.
    #
    #4. **General Pattern**:
    #   - After `k` iterations, `mex` is `k`.
    #   - The loop continues as long as `mex` is in `num_set`.
    #
    #5. **Final Iteration**:
    #   - Let's denote the maximum value in `num_set` as `max_val`.
    #   - Once `mex` reaches `max_val + 1`, `mex` will no longer be in `num_set`, and the loop will terminate.
    #
    #### Conclusion:
    #After the loop terminates, `mex` will be the smallest non-negative integer not present in `num_set`.
    #
    #### Output State:
    #- `mex` is the smallest non-negative integer not present in `num_set`.
    #- `num_set` remains unchanged as it is only used to check the presence of `mex`.
    #
    #Thus, the final output state is:
    #**Output State: `mex` is the smallest non-negative integer not present in `num_set`, `num_set` remains unchanged.**
    return mex
    #`mex` is the smallest non-negative integer not present in `num_set`, `num_set` remains unchanged
#Overall this is what the function does:The function `func_1` accepts a list `arr` of integers where each element is in the range [0, len(arr) - 1] and the length of the list is at least 2. It computes the smallest non-negative integer that is not present in the set of unique elements derived from `arr`. The function returns this integer, which is stored in the variable `mex`. The set `num_set`, which contains the unique elements from `arr`, remains unchanged throughout the function's execution. This process involves initializing `num_set` with the unique elements from `arr`, then incrementing `mex` until it finds the smallest non-negative integer not present in `num_set`.

# Your response:
Reasoning:  
Correctness: **True** or **False**

