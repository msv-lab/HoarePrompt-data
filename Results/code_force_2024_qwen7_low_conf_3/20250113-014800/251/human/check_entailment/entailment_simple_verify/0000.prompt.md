
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
There is a rectangular sheet of paper with initial height n and width m . Let
the current height and width be h and w respectively. We introduce a xy
-coordinate system so that the four corners of the sheet are (0, 0), (w, 0),
(0, h) , and (w, h) . The sheet can then be cut along the lines x =
1,2,\ldots,w-1 and the lines y = 1,2,\ldots,h-1 . In each step, the paper is
cut randomly along any one of these h+w-2 lines. After each vertical and
horizontal cut, the right and bottom piece of paper respectively are
discarded.

Find the expected number of steps required to make the area of the sheet of
paper strictly less than k . It can be shown that this answer can always be
expressed as a fraction \dfrac{p}{q} where p and q are coprime integers.
Calculate p\cdot q^{-1} \bmod (10^9+7) .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 57000 ). Description of the test cases follows.

The first line of each test case contains 3 integers n , m , and k (1 \le n, m
\le 10^6 , 2 \le k \le 10^{12} ).

It is guaranteed that the sum of n and the sum of m over all test cases do not
exceed 10^6 .

Output

For each test case, print one integer — the answer to the problem.

Example

Input

    4
    
    2 4 10
    
    2 4 8
    
    2 4 2
    
    2 4 6

Output

    0
    1
    833333342
    250000003
    
Note

For the first test case, the area is already less than 10 so no cuts are
required.

For the second test case, the area is exactly 8 so any one of the 4 possible
cuts would make the area strictly less than 8 .

For the third test case, the final answer is \frac{17}{6} = 833\,333\,342\bmod
(10^9+7) .

For the fourth test case, the final answer is \frac{5}{4} = 250\,000\,003\bmod
(10^9+7) .

- Program: 

#Function 1:
def func_1():
    import sys
    input = sys.stdin.read
    data = input().split()
    MOD = 1000000007
    idx = 0
    t = int(data[idx])
    idx += 1
    results = []
    for _ in range(t):
        n = int(data[idx])
        m = int(data[idx + 1])
        k = int(data[idx + 2])
        idx += 3
        (low, high) = (0, max(n, m) * 20)
        answer = high
        while low <= high:
            mid = (low + high) // 2
            if func_2(n, m, k, mid):
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        p = answer
        q = 1
        q_inv = pow(q, MOD - 2, MOD)
        result = p * q_inv % MOD
        results.append(result)
    for res in results:
        print(res)

#Function 2:
def func_2(n, m, k, steps):
    import math
    (h, w) = (n, m)
    for _ in range(steps):
        if h > w:
            h = max(h // 2, 1)
        else:
            w = max(w // 2, 1)
        if h * w < k:
            return True
    return h * w < k



- Annotated Code: 
if __name__ == '__main__':
    func_1()

#Function 1:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 57000; n and m are integers such that 1 ≤ n, m ≤ 10^6; k is an integer such that 2 ≤ k ≤ 10^{12}; and the sum of n and the sum of m over all test cases do not exceed 10^6.
def func_1():
    input = sys.stdin.read
    data = input().split()
    MOD = 1000000007
    idx = 0
    t = int(data[idx])
    idx += 1
    results = []
    for _ in range(t):
        n = int(data[idx])
        
        m = int(data[idx + 1])
        
        k = int(data[idx + 2])
        
        idx += 3
        
        low, high = 0, max(n, m) * 20
        
        answer = high
        
        while low <= high:
            mid = (low + high) // 2
            if func_2(n, m, k, mid):
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        
        p = answer
        
        q = 1
        
        q_inv = pow(q, MOD - 2, MOD)
        
        result = p * q_inv % MOD
        
        results.append(result)
        
    #State of the program after the  for loop has been executed: `t` is 0, `n` is the integer value of `data[idx]`, `m` is the integer value of `data[idx + 1]`, `idx` is the original value plus `3 * t`, `low` and `high` are final values based on the binary search process for each iteration, `answer` is the smallest integer `x` such that `func_2(n, m, k, x)` returns `True` for each iteration, `p` is equal to the final value of `answer` for each iteration, `q` is 1, `q_inv` is 1, `result` is `p % MOD` for each iteration, `results` is a list containing `result` for each iteration, `k` is the integer value of `data[idx + 2]` for each iteration.
    for res in results:
        print(res)
        
    #State of the program after the  for loop has been executed: `results` is a list containing all the computed results for each iteration, `res` is the last element of `results` that was printed, `res` remains unchanged after being printed, `results` has a length equal to the number of iterations of the loop.

#Function 2:
#State of the program right berfore the function call: n, m, and k are positive integers such that 1 ≤ n, m ≤ 10^6 and 2 ≤ k ≤ 10^12. The variables h and w represent the current height and width of the sheet after each cut, initialized to n and m respectively. steps is a non-negative integer representing the number of steps taken to reduce the area.
def func_2(n, m, k, steps):
    h, w = n, m
    for _ in range(steps):
        if h > w:
            h = max(h // 2, 1)
        else:
            w = max(w // 2, 1)
        
        if h * w < k:
            return True
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `m` is a positive integer, `k` is a positive integer such that \(2 \leq k \leq 10^{12}\), `h` and `w` are each halved (but at least one remains as 1 if it becomes 0.5 or less) until `h * w < k` or the loop reaches its maximum number of steps, `steps` is the number of times the loop has executed, and `h * w` is greater than or equal to `k` unless the function returns True.
    return h * w < k
    #`The program returns True if h * w is less than k, otherwise it returns False`




Beggining of Original Assessment: 
Correctness: **False**

Explanation: The program does not correctly implement the logic required to solve the problem. Specifically, the function `func_2` does not accurately calculate the expected number of steps required to make the area of the sheet of paper strictly less than `k`. 

In `func_2`, the logic for reducing the dimensions of the paper (`h` and `w`) is flawed. Instead of simulating random cuts along the lines `x = 1, 2, ..., w-1` and `y = 1, 2, ..., h-1`, the function incorrectly reduces the dimensions by half at each step, which does not reflect the randomness required by the problem statement. 

For example, consider the test case `2 4 8`. The correct approach would involve simulating random cuts, but the current implementation simply reduces the dimensions by half until the area is less than `k`, which is not a valid representation of the randomness required.

To fix this, the program needs to simulate random cuts, keeping track of the number of steps taken, and ensuring that the final area is strictly less than `k`.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

