
You are a program verifier. Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
There is a rectangular sheet of paper with initial height n and width m . Let
the current height and width be h and w respectively. We introduce a xy
-coordinate system so that the four corners of the sheet are (0, 0), (w, 0),
(0, h) , and (w, h) . The sheet can then be cut along the lines x =
1,2,\ldots,w-1 and the lines y = 1,2,\ldots,h-1 . In each step, the paper is
cut randomly along any one of these h+w-2 lines. After each vertical and
horizontal cut, the right and bottom piece of paper respectively are
discarded.

Find the expected number of steps required to make the area of the sheet of
paper strictly less than k . It can be shown that this answer can always be
expressed as a fraction \dfrac{p}{q} where p and q are coprime integers.
Calculate p\cdot q^{-1} \bmod (10^9+7) .

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 57000 ). Description of the test cases follows.

The first line of each test case contains 3 integers n , m , and k (1 \le n, m
\le 10^6 , 2 \le k \le 10^{12} ).

It is guaranteed that the sum of n and the sum of m over all test cases do not
exceed 10^6 .

Output

For each test case, print one integer — the answer to the problem.

Example

Input

    4
    
    2 4 10
    
    2 4 8
    
    2 4 2
    
    2 4 6

Output

    0
    1
    833333342
    250000003
    
Note

For the first test case, the area is already less than 10 so no cuts are
required.

For the second test case, the area is exactly 8 so any one of the 4 possible
cuts would make the area strictly less than 8 .

For the third test case, the final answer is \frac{17}{6} = 833\,333\,342\bmod
(10^9+7) .

For the fourth test case, the final answer is \frac{5}{4} = 250\,000\,003\bmod
(10^9+7) .

# Annotated Functions:
if __name__ == '__main__':
    func_1()

#Function 1:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 57000; n and m are integers such that 1 ≤ n, m ≤ 10^6; k is an integer such that 2 ≤ k ≤ 10^{12}; and the sum of n and the sum of m over all test cases do not exceed 10^6.
def func_1():
    input = sys.stdin.read
    data = input().split()
    MOD = 1000000007
    idx = 0
    t = int(data[idx])
    idx += 1
    results = []
    for _ in range(t):
        n = int(data[idx])
        
        m = int(data[idx + 1])
        
        k = int(data[idx + 2])
        
        idx += 3
        
        low, high = 0, max(n, m) * 20
        
        answer = high
        
        while low <= high:
            mid = (low + high) // 2
            if func_2(n, m, k, mid):
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        
        p = answer
        
        q = 1
        
        q_inv = pow(q, MOD - 2, MOD)
        
        result = p * q_inv % MOD
        
        results.append(result)
        
    #State of the program after the  for loop has been executed: `t` is 0, `n` is the integer value of `data[idx]`, `m` is the integer value of `data[idx + 1]`, `idx` is the original value plus `3 * t`, `low` and `high` are final values based on the binary search process for each iteration, `answer` is the smallest integer `x` such that `func_2(n, m, k, x)` returns `True` for each iteration, `p` is equal to the final value of `answer` for each iteration, `q` is 1, `q_inv` is 1, `result` is `p % MOD` for each iteration, `results` is a list containing `result` for each iteration, `k` is the integer value of `data[idx + 2]` for each iteration.
    for res in results:
        print(res)
        
    #State of the program after the  for loop has been executed: `results` is a list containing all the computed results for each iteration, `res` is the last element of `results` that was printed, `res` remains unchanged after being printed, `results` has a length equal to the number of iterations of the loop.
#Overall this is what the function does:The function reads input from stdin, processes `t` test cases, and computes a result for each test case based on given integers `n`, `m`, and `k`. For each test case, it performs a binary search to find the smallest integer `x` such that `func_2(n, m, k, x)` returns `True`. It then calculates a result using modular arithmetic and appends it to a list of results. Finally, it prints each result. Potential edge cases include the input constraints (1 ≤ t ≤ 57000, 1 ≤ n, m ≤ 10^6, 2 ≤ k ≤ 10^{12}) and the condition that the sum of `n` and `m` over all test cases does not exceed 10^6. The function also includes a missing annotation for the `func_2` function call, which should be described as performing some boolean check based on the input parameters `n`, `m`, `k`, and `mid`.

#Function 2:
#State of the program right berfore the function call: n, m, and k are positive integers such that 1 ≤ n, m ≤ 10^6 and 2 ≤ k ≤ 10^12. The variables h and w represent the current height and width of the sheet after each cut, initialized to n and m respectively. steps is a non-negative integer representing the number of steps taken to reduce the area.
def func_2(n, m, k, steps):
    h, w = n, m
    for _ in range(steps):
        if h > w:
            h = max(h // 2, 1)
        else:
            w = max(w // 2, 1)
        
        if h * w < k:
            return True
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `m` is a positive integer, `k` is a positive integer such that \(2 \leq k \leq 10^{12}\), `h` and `w` are each halved (but at least one remains as 1 if it becomes 0.5 or less) until `h * w < k` or the loop reaches its maximum number of steps, `steps` is the number of times the loop has executed, and `h * w` is greater than or equal to `k` unless the function returns True.
    return h * w < k
    #`The program returns True if h * w is less than k, otherwise it returns False`
#Overall this is what the function does:The function `func_2` accepts four parameters: `n`, `m`, `k`, and `steps`. It initializes `h` and `w` to the values of `n` and `m`, respectively. The function then enters a loop that iterates up to `steps` times, halving either `h` or `w` (whichever is larger) in each iteration, ensuring that both `h` and `w` remain at least 1. After the loop, the function checks if the product of `h` and `w` is less than `k`.

If the loop completes without the product of `h` and `w` being less than `k`, the function returns `False`. However, due to the postconditions provided, there are three cases where the function returns `True`:

1. If `h > w` and `h` is halved in the first iteration.
2. If `w > h` and `w` is halved in the first iteration.
3. If `h * w` becomes less than `k` during the loop.

Therefore, the function returns `True` if any of the first three cases occur or if the product of `h` and `w` is less than `k` after the loop. If none of these conditions are met, it returns `False`.




# Your response:
Reasoning:  
Correctness: **True** or **False**

