
You are a program verifier. Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Some permutation of length n is guessed.

You are given the indices of its prefix maximums and suffix maximums.

Recall that a permutation of length k is an array of size k such that each
integer from 1 to k occurs exactly once.

Prefix maximums are the elements that are the maximum on the prefix ending at
that element. More formally, the element a_i is a prefix maximum if a_i > a_j
for every j < i .

Similarly, suffix maximums are defined, the element a_i is a suffix maximum if
a_i > a_j for every j > i .

You need to output the number of different permutations that could have been
guessed.

As this number can be very large, output the answer modulo 10^9 + 7 .

Input

Each test consists of several test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. Then follows the
description of the test cases.

The first line of each test case contains three integers n, m_1 and m_2 (1 \le
m_1, m_2 \le n \le 2 \cdot 10^5 ) — the length of the permutation, the number
of prefix maximums, and the number of suffix maximums, respectively.

The second line of each test case contains m_1 integers p_1 < p_2 < \ldots <
p_{m_1} (1 \le p_i \le n ) — the indices of the prefix maximums in increasing
order.

The third line of each test case contains m_2 integers s_1 < s_2 < \ldots <
s_{m_2} (1 \le s_i \le n ) — the indices of the suffix maximums in increasing
order.

It is guaranteed that the sum of the values of n for all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a single integer on a separate line — the number of
suitable permutations modulo 10^9 + 7 .

Example

Input

    6
    
    1 1 1
    
    1
    
    1
    
    4 2 3
    
    1 2
    
    2 3 4
    
    3 3 1
    
    1 2 3
    
    3
    
    5 3 4
    
    1 2 3
    
    2 3 4 5
    
    20 5 4
    
    1 2 3 4 12
    
    12 13 18 20
    
    6 2 3
    
    1 3
    
    3 4 6

Output

    1
    3
    1
    0
    317580808
    10
    
Note

The following permutations are suitable for the second set of input data:

  * [1, 4, 3, 2] 
  * [2, 4, 3, 1] 
  * [3, 4, 2, 1] 

The following permutations are suitable for the sixth set of input data:

  * [2, 1, 6, 5, 3, 4] 
  * [3, 1, 6, 5, 2, 4] 
  * [3, 2, 6, 5, 1, 4] 
  * [4, 1, 6, 5, 2, 3] 
  * [4, 2, 6, 5, 1, 3] 
  * [4, 3, 6, 5, 1, 2] 
  * [5, 1, 6, 4, 2, 3] 
  * [5, 2, 6, 4, 1, 3] 
  * [5, 3, 6, 4, 1, 2] 
  * [5, 4, 6, 3, 1, 2]

# Functions with Execution Summary:
if __name__ == '__main__':
    func_1()

Function number 1 :
 Code:
 '''
def func_1():
    import sys
    input = sys.stdin.read
    data = input().split()
    MOD = 10 ** 9 + 7
    index = 0
    T = int(data[index])
    index += 1
    results = []
    for _ in range(T):
        (n, k) = (int(data[index]), int(data[index + 1]))
        index += 2
        a = list(map(int, data[index:index + n]))
        index += n
        initial_sum = sum(a) % MOD

        max_subarray_sum = kadane(a)
        if max_subarray_sum > 0:
            result = (initial_sum + k * max_subarray_sum) % MOD
        else:
            result = initial_sum % MOD
        results.append(result)
    for result in results:
        print(result)
''' 

 Output hints for function1:  The function processes a series of test cases. For each test case, it reads two integers \( n \) and \( k \), and a list \( a \) of \( n \) integers. It calculates the initial sum of the elements in \( a \) modulo \( 10^9 + 7 \). Then, it finds the maximum subarray sum of \( a \) using Kadane's algorithm. If the maximum subarray sum is positive, the function computes the result as \( (\text{initial sum} + k \times \text{max subarray sum}) \mod (10^9 + 7) \); otherwise, it simply takes the initial sum modulo \( 10^9 + 7 \). The function collects these results for all test cases and prints them. The function handles up to \( 2 \times 10^5 \) elements across all test cases.
Function number 2 :
 Code:
 '''
def kadane(arr):
    max_ending_here = max_so_far = arr[0]
    for x in arr[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
''' 

 Output hints for function2:  The function `kadane` accepts a list of integers `arr` and computes the maximum sum of any contiguous subarray within the input list. It returns this maximum subarray sum. The function iterates through the list while maintaining two variables: `max_ending_here`, which keeps track of the maximum subarray sum ending at the current position, and `max_so_far`, which stores the maximum subarray sum found so far. If the current element alone is greater than the sum of the current element and `max_ending_here`, then `max_ending_here` is updated to the current element. Otherwise, `max_ending_here` is updated to the sum of the current element and `max_ending_here`. The function also handles edge cases such as when all elements in the list are negative, in which case `max_so_far` will be the largest (least negative) number in the list.


# Your response:
Reasoning:  
Correctness: **True** or **False**

