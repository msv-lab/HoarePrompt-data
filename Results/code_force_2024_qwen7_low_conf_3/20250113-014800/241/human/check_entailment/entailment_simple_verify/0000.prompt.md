
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
This problem has an attachment. You can use it to simulate and visualize the
movements of the amoeba.

Amoeba Amanda lives inside a rectangular grid of square pixels. Her body
occupies some of these pixels. Other pixels may be either free or blocked.
Amanda moves across the grid using the so-called amoeboid movement. In each
step of such a movement, her body first shrinks by one pixel (one pixel of the
body is removed and becomes free), and then grows at a different place (one
previously-free pixel is added to the body).

To prevent structural damage, Amanda's body always occupies a connected region
of pixels, which means that any pair of pixels forming the body can be
connected by a sequence of adjacent pixels without ever leaving the body. Two
pixels are considered adjacent if they share a common side (each pixel has at
most 4 neighbours). The body remains connected even during the movement,
including the moment after removing a pixel and before adding another one.

Your task is to help Amanda find her way around. Given her initial position
and desired final position, suggest a sequence of valid moves leading from the
former to the latter.

![](https://espresso.codeforces.com/8d732857e67e5cd7cb6a0af1ed34584572413ddc.png)
Illustration of sample 1 : The filled shape is the initial position, the
dotted region is the final position.

Input

The first line contains two integers r and c (1\le r,c \le 50 ) — the size of
the rectangular grid in pixels.

The next r lines contain c characters each, describing the initial position of
Amanda. Each of those characters is either a dot \texttt{.} denoting a free
pixel, an asterisk \texttt{*} denoting Amanda's body, or an \texttt{X}
denoting a blocked pixel which may never be occupied.

The next line is empty.

The next r lines describe the desired final position in the same format as the
initial position.

It is guaranteed that:

  * The number of pixels forming Amanda's body is the same in both positions, and it is at least 2. 
  * The body of Amanda is connected in the initial position. 
  * The body of Amanda is connected in the final position. 
  * The blocked pixels do not change between the descriptions of the initial and final position, their placement is exactly the same in both positions. 

Output

Print \texttt{YES} if it is possible for Amanda to go from the initial
position to the final one. Otherwise, print \texttt{NO} .

If it is possible, on the next line print one integer m (0\le m\le 10\,000 ) —
the number of moves to execute.

The following m lines must contain four integer coordinates each: i_1 , j_1 ,
i_2 , j_2 (1\le i_1,i_2\le r , 1\le j_1,j_2\le c ). These four coordinates
specify one move, meaning that the pixel at i_1 -th row and j_1 -th column is
first removed from the body. Then, (i_2,j_2) must designate a different
location where one pixel is added.

The sequence should consist only of valid moves and after the last move,
Amanda's body should occupy the desired final position.

If there are multiple solutions, print any of them.

Under the assumptions of this problem, it can be proven that if it is possible
for Amanda to go from the initial position to the desired final one, then it
is possible to do it with at most 10\,000 moves.

Examples

Input

    5 8
    
    .******.
    
    **.X**..
    
    *******.
    
    **.X**..
    
    .******.
    
    .******.
    
    ...X****
    
    .*******
    
    ...X****
    
    .******.

Output

    YES
    5
    3 1 3 8
    2 1 2 8
    4 1 4 8
    2 2 4 7
    4 2 2 7
    
Input

    2 5
    
    *.X..
    
    **X..
    
    ..X**
    
    ..X*.

Output

    NO
    
Note

In the first sample, Amanda executes 5 moves to reach the final position, as
shown in the figure below.

![](https://espresso.codeforces.com/04b7bb193a243e0eaf83952861f5275e04543407.png)

- Program: 
from collections import deque
#Function 1:
def func_1(grid, r, c, visited, i1, j1, i2, j2):
    if i2 < 0 or i2 >= r or j2 < 0 or (j2 >= c):
        return False
    if grid[i2][j2] == '*' or visited[i2][j2]:
        return False
    connected_pixels = 0
    for (di, dj) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
        (ni, nj) = (i2 + di, j2 + dj)
        if 0 <= ni < r and 0 <= nj < c and (grid[ni][nj] == '*'):
            connected_pixels += 1
    if connected_pixels < 2:
        return False
    return True

#Function 2:
def func_2(grid, r, c, initial_position, final_position):
    visited = [[False] * c for _ in range(r)]
    q = deque()
    q.append(initial_position)
    visited[initial_position[0]][initial_position[1]] = True
    parent = {}
    while q:
        current_position = q.popleft()
        if current_position == final_position:
            break
        (i, j) = current_position
        for (di, dj) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            (ni, nj) = (i + di, j + dj)
            if func_1(grid, r, c, visited, i, j, ni, nj):
                visited[ni][nj] = True
                q.append((ni, nj))
                parent[ni, nj] = (i, j)
    if final_position not in parent:
        return None
    moves = []
    current_position = final_position
    while current_position != initial_position:
        parent_position = parent[current_position]
        moves.append((parent_position[0] + 1, parent_position[1] + 1, current_position[0] + 1, current_position[1] + 1))
        current_position = parent_position
    moves.reverse()
    return moves

#Function 3:
def func_3():
    (r, c) = map(int, input().split())
    initial_grid = [input() for _ in range(r)]
    input()
    final_grid = [input() for _ in range(r)]
    initial_position = None
    final_position = None
    for i in range(r):
        for j in range(c):
            if initial_grid[i][j] == '*':
                initial_position = (i, j)
            if final_grid[i][j] == '*':
                final_position = (i, j)
    moves = func_2(initial_grid, r, c, initial_position, final_position)
    if moves:
        print('YES')
        print(len(moves))
        for move in moves:
            print(*move)
    else:
        print('NO')



- Annotated Code: 
from collections import deque

if __name__ == '__main__':
    func_3()

#Function 1:
#State of the program right berfore the function call: grid is a 2D list representing the rectangular grid, where each element is a string of length c containing characters '.', '*', or 'X'. r and c are positive integers representing the dimensions of the grid. i1 and j1 are the row and column indices of the pixel to be removed from Amanda's body, and i2 and j2 are the row and column indices of the new pixel to be added to Amanda's body. visited is a 2D boolean list of the same dimensions as grid, indicating whether each pixel has been visited during the movement process.
def func_1(grid, r, c, visited, i1, j1, i2, j2):
    if (i2 < 0 or i2 >= r or j2 < 0 or j2 >= c) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: grid is a 2D list representing the rectangular grid, where each element is a string of length c containing characters '.', '*', or 'X'. r and c are positive integers representing the dimensions of the grid. i1 and j1 are the row and column indices of the pixel to be removed from Amanda's body, and i2 and j2 are the row and column indices of the new pixel to be added to Amanda's body. visited is a 2D boolean list of the same dimensions as grid, indicating whether each pixel has been visited during the movement process. i2 is within the bounds of the grid (0 ≤ i2 < r and 0 ≤ j2 < c)
    if (grid[i2][j2] == '*' or visited[i2][j2]) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: grid is a 2D list representing the rectangular grid, where each element is a string of length c containing characters '.', '*', or 'X'. r and c are positive integers representing the dimensions of the grid. i1 and j1 are the row and column indices of the pixel to be removed from Amanda's body, and i2 and j2 are the row and column indices of the new pixel to be added to Amanda's body. visited is a 2D boolean list of the same dimensions as grid, indicating whether each pixel has been visited during the movement process. i2 is within the bounds of the grid (0 ≤ i2 < r and 0 ≤ j2 < c). grid[i2][j2] is neither '*' nor a visited pixel.
    connected_pixels = 0
    for (di, dj) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
        ni, nj = i2 + di, j2 + dj
        
        if 0 <= ni < r and 0 <= nj < c and grid[ni][nj] == '*':
            connected_pixels += 1
        
    #State of the program after the  for loop has been executed: `connected_pixels` is the count of adjacent cells (up, down, left, right) to `(i2, j2)` that are marked with '*', `i2` is the original value of `i2`, `j2` is the original value of `j2`, `di` is -1, `dj` is 0, `ni` is `i2 - 1`, `nj` is `j2`, `di` is 1, `dj` is 0, `ni` is `i2 + 1`, `nj` is `j2`, `di` is 0, `dj` is 1, `ni` is `i2`, `nj` is `j2 + 1`, `di` is 0, `dj` is -1, `ni` is `i2`, `nj` is `j2 - 1`, `grid` is a 2D list representing the rectangular grid, `r` and `c` are positive integers, and the grid must contain at least one element, `visited` is a 2D boolean list of the same dimensions as `grid`, indicating whether each pixel has been visited during the movement process, and `grid[i2][j2]` is neither '*' nor a visited pixel.
    if (connected_pixels < 2) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: `connected_pixels` is the count of adjacent cells (up, down, left, right) to `(i2, j2)` that are marked with '*', `i2` is the original value of `i2`, `j2` is the original value of `j2`, `di` is -1, `dj` is 0, `ni` is `i2 - 1`, `nj` is `j2`, `di` is 1, `dj` is 0, `ni` is `i2 + 1`, `nj` is `j2`, `di` is 0, `dj` is 1, `ni` is `i2`, `nj` is `j2 + 1`, `di` is 0, `dj` is -1, `ni` is `i2`, `nj` is `j2 - 1`, `grid` is a 2D list representing the rectangular grid, `r` and `c` are positive integers, and the grid must contain at least one element, `visited` is a 2D boolean list of the same dimensions as `grid`, indicating whether each pixel has been visited during the movement process, and `grid[i2][j2]` is either not marked with '*' or is a visited pixel, and `connected_pixels` is greater than or equal to 2
    return True
    #The program returns True

#Function 2:
#State of the program right berfore the function call: grid is a 2D list of strings representing the rectangular grid, where each string represents a row of the grid and contains '.' (free pixel), '*' (Amanda's body), or 'X' (blocked pixel). r and c are positive integers indicating the dimensions of the grid. initial_position and final_position are tuples of two positive integers indicating the starting and ending coordinates of Amanda's body as (row_index, column_index).
def func_2(grid, r, c, initial_position, final_position):
    visited = [([False] * c) for _ in range(r)]
    q = deque()
    q.append(initial_position)
    visited[initial_position[0]][initial_position[1]] = True
    parent = {}
    while q:
        current_position = q.popleft()
        
        if current_position == final_position:
            break
        
        i, j = current_position
        
        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            ni, nj = i + di, j + dj
            if func_1(grid, r, c, visited, i, j, ni, nj):
                visited[ni][nj] = True
                q.append((ni, nj))
                parent[ni, nj] = i, j
        
    #State of the program after the loop has been executed: `grid` is a 2D list of strings representing the grid, `r` and `c` are positive integers indicating the dimensions of the grid, `initial_position` and `final_position` are tuples indicating the starting and ending coordinates, `visited` is a 2D list marking the visited positions, `q` is a deque containing all positions that can be reached from `final_position` based on the movement directions specified by `[(1, 0), (-1, 0), (0, 1), (0, -1)]`, `parent` is a dictionary mapping each position in `q` to its parent position, all positions reachable from `final_position` and all positions that can reach `initial_position` are marked in `visited` and `parent`, and `current_position` is the last position dequeued from `q`.
    if (final_position not in parent) :
        return None
        #The program returns None
    #State of the program after the if block has been executed: `grid` is a 2D list of strings representing the grid, `r` and `c` are positive integers indicating the dimensions of the grid, `initial_position` and `final_position` are tuples indicating the starting and ending coordinates, `visited` is a 2D list marking the visited positions, `q` is a deque containing all positions that can be reached from `final_position` based on the movement directions specified by `[(1, 0), (-1, 0), (0, 1), (0, -1)]`, `parent` is a dictionary mapping each position in `q` to its parent position, all positions reachable from `final_position` and all positions that can reach `initial_position` are marked in `visited` and `parent`, and `current_position` is the last position dequeued from `q`. The final position is not in the `parent` dictionary.
    moves = []
    current_position = final_position
    while current_position != initial_position:
        parent_position = parent[current_position]
        
        moves.append((parent_position[0] + 1, parent_position[1] + 1, 
            current_position[0] + 1, current_position[1] + 1))
        
        current_position = parent_position
        
    #State of the program after the loop has been executed: `grid` is a 2D list of strings representing the grid, `r` and `c` are positive integers indicating the dimensions of the grid, `initial_position` and `final_position` are tuples indicating the starting and ending coordinates, `visited` is a 2D list marking the visited positions, `q` is a deque containing all positions that can be reached from `final_position` based on the movement directions specified by `[(1, 0), (-1, 0), (0, 1), (0, -1)]`, `parent` is a dictionary mapping each position in `q` to its parent position, all positions reachable from `final_position` and all positions that can reach `initial_position` are marked in `visited` and `parent`, `current_position` is `initial_position`, `parent_position` is the parent of the `initial_position`, and `moves` is a list containing a sequence of tuples representing the path from `final_position` to `initial_position`.
    moves.reverse()
    return moves
    #`The program returns moves which is a list containing a reversed sequence of tuples representing the path from final_position to initial_position`

#Function 3:
#State of the program right berfore the function call: r and c are integers such that 1 ≤ r, c ≤ 50. initial_grid and final_grid are 2D lists of strings, where each string represents a row of the grid and contains characters '.', '*', and 'X'. initial_position and final_position are tuples representing the coordinates of Amanda's body in the initial and final positions, respectively. The coordinates are zero-based indices, with (0, 0) being the top-left corner of the grid.
def func_3():
    r, c = map(int, input().split())
    initial_grid = [input() for _ in range(r)]
    input()
    final_grid = [input() for _ in range(r)]
    initial_position = None
    final_position = None
    for i in range(r):
        for j in range(c):
            if initial_grid[i][j] == '*':
                initial_position = i, j
            if final_grid[i][j] == '*':
                final_position = i, j
        
    #State of the program after the  for loop has been executed: `i` is `r`, `j` is `c - 1`, `initial_position` is either undefined or the position of the last `'*'` found in `initial_grid`, `final_position` is either undefined or the position of the last `'*'` found in `final_grid`, `initial_grid` is a 2D list of strings with `r` rows, `final_grid` is a 2D list of strings with `r` rows, and `c` is a non-negative integer.
    moves = func_2(initial_grid, r, c, initial_position, final_position)
    if moves :
        print('YES')
        print(len(moves))
        for move in moves:
            print(*move)
            
        #State of the program after the  for loop has been executed: `moves` is an empty list, `print(*move)` has been executed for each element in the original `moves` list, and all elements of `moves` have been printed.
    else :
        print('NO')
    #State of the program after the if-else block has been executed: *`i` is `r`, `j` is `c - 1`, `initial_position` is either undefined or the position of the last `'*'` found in `initial_grid`, `final_position` is either undefined or the position of the last `'*'` found in `final_grid`, `initial_grid` is a 2D list of strings with `r` rows, `final_grid` is a 2D list of strings with `r` rows, `c` is a non-negative integer, and `moves` is the result of calling `func_2(initial_grid, r, c, initial_position, final_position)`. If `moves` is a non-empty list, then `print(*move)` has been executed for each element in the original `moves` list, and all elements of `moves` have been printed. If `moves` is falsy (e.g., an empty list), the string 'NO' is printed to the console.




Beggining of Original Assessment: 
Correctness: **False**.

Explanation: The program attempts to solve the problem but does not fully meet the requirements. Specifically, the function `func_1` checks if a move is valid, but it does not ensure that the resulting body remains connected. This is a critical requirement as per the problem statement. Additionally, the function `func_2` does not correctly simulate the amoeboid movement because it only checks if a pixel can be added to the body but does not actually perform the shrinking and growing process correctly. Therefore, the program cannot guarantee that Amanda's body will remain connected during the movement, and thus, it may fail for certain inputs.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

