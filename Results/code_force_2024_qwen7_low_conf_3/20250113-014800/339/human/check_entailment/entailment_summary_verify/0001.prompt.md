
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
There are n monsters standing in a row. The i -th monster has a_i health
points.

Every second, you can choose one alive monster and launch a chain lightning at
it. The lightning deals k damage to it, and also spreads to the left (towards
decreasing i ) and to the right (towards increasing i ) to alive monsters,
dealing k damage to each. When the lightning reaches a dead monster or the
beginning/end of the row, it stops. A monster is considered alive if its
health points are strictly greater than 0 .

For example, consider the following scenario: there are three monsters with
health equal to [5, 2, 7] , and k = 3 . You can kill them all in 4 seconds:

  * launch a chain lightning at the 3 -rd monster, then their health values are [2, -1, 4] ; 
  * launch a chain lightning at the 1 -st monster, then their health values are [-1, -1, 4] ; 
  * launch a chain lightning at the 3 -rd monster, then their health values are [-1, -1, 1] ; 
  * launch a chain lightning at the 3 -th monster, then their health values are [-1, -1, -2] . 

For each k from 1 to \max(a_1, a_2, \dots, a_n) , calculate the minimum number
of seconds it takes to kill all the monsters.

Input

The first line contains a single integer n (1 \le n \le 10^5 ) — the number of
monsters.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^5 )
— the health points of the i -th monster.

Output

For each k from 1 to \max(a_1, a_2, \dots, a_n) , output the minimum number of
seconds it takes to kill all the monsters.

Examples

Input

    3
    
    5 2 7

Output

    10 6 4 3 2 2 1 
    
Input

    4
    
    7 7 7 7

Output

    7 4 3 2 2 2 1 
    
Input

    10
    
    1 9 7 6 2 4 7 8 1 3

Output

    17 9 5 4 3 3 3 2 1

- Program:
def func():
    N = int(input())
    ans = []
    a = [int(x) for x in input().split()]
    b = [(i, a[i]) for i in range(len(a))]
    S = sorted(b, key=lambda x: x[1])
    m = max(a)
    bits = [0] + [1] * N + [0]
    wtr = [[] for q in range(N)]
    f = []
    g = 1
    last = 0
    for (i, num) in S:
        for e in range(num - last):
            f.append(g)
        last = num
        bits[i + 1] = 0
        g += bits[i] + bits[i + 2] - 1
    for d in range(1, m + 1):
        print(sum([f[d * x] for x in range(1 + (m - 1) // d)]), end=' ')



- Function Summary: 
The function processes a list of integers `a` of length `n` (where \(1 \leq n \leq 10^5\)) and each integer in the list satisfies \(1 \leq a_i \leq 10^5\). It first sorts the indices of the list `a` based on the values in `a`. Then, it initializes several auxiliary lists and variables. During the first for loop, it populates the list `f` with a specific value `g` and updates the `bits` list. Finally, it prints the sum of selected elements from the list `f` for each divisor `d` of `m`, where `m` is the maximum value in the original list `a`.

Beggining of Original Assessment: 
Reasoning:

1. **Input Parsing**: The program correctly parses the input to get `N` (number of monsters) and an array `a` containing the health points of each monster.
2. **Sorting**: It sorts the monsters based on their health points using `b = [(i, a[i]) for i in range(len(a))]` and `S = sorted(b, key=lambda x: x[1])`. This is correct as it helps in processing monsters starting from the weakest.
3. **Initialization of Variables**: Variables `bits`, `wtr`, `f`, `g`, and `last` are initialized correctly for further computations.
4. **Processing Loop**: The loop iterates over the sorted list of monsters. For each monster, it appends to the list `f` based on the difference between the current health point and the last processed health point. This ensures that the list `f` is populated with the correct values for the number of steps required to eliminate monsters.
5. **Final Calculation and Output**: The program calculates the minimum number of seconds required to kill all monsters for each `k` from 1 to `m` (maximum health point) using the formula `sum([f[d * x] for x in range(1 + (m - 1) // d)])` and prints the result.

The program logic appears to be correct and follows the problem statement accurately. However, there are a few minor improvements that could be made for clarity and correctness:

- The variable names `f` and `g` could be more descriptive.
- The list `wtr` is not used in the final calculation, so it can be removed to simplify the code.

Given these observations, the program is correctly implementing the solution to the problem.

Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

