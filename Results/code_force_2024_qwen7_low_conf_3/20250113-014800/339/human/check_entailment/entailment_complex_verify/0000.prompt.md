
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
There are n monsters standing in a row. The i -th monster has a_i health
points.

Every second, you can choose one alive monster and launch a chain lightning at
it. The lightning deals k damage to it, and also spreads to the left (towards
decreasing i ) and to the right (towards increasing i ) to alive monsters,
dealing k damage to each. When the lightning reaches a dead monster or the
beginning/end of the row, it stops. A monster is considered alive if its
health points are strictly greater than 0 .

For example, consider the following scenario: there are three monsters with
health equal to [5, 2, 7] , and k = 3 . You can kill them all in 4 seconds:

  * launch a chain lightning at the 3 -rd monster, then their health values are [2, -1, 4] ; 
  * launch a chain lightning at the 1 -st monster, then their health values are [-1, -1, 4] ; 
  * launch a chain lightning at the 3 -rd monster, then their health values are [-1, -1, 1] ; 
  * launch a chain lightning at the 3 -th monster, then their health values are [-1, -1, -2] . 

For each k from 1 to \max(a_1, a_2, \dots, a_n) , calculate the minimum number
of seconds it takes to kill all the monsters.

Input

The first line contains a single integer n (1 \le n \le 10^5 ) — the number of
monsters.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^5 )
— the health points of the i -th monster.

Output

For each k from 1 to \max(a_1, a_2, \dots, a_n) , output the minimum number of
seconds it takes to kill all the monsters.

Examples

Input

    3
    
    5 2 7

Output

    10 6 4 3 2 2 1 
    
Input

    4
    
    7 7 7 7

Output

    7 4 3 2 2 2 1 
    
Input

    10
    
    1 9 7 6 2 4 7 8 1 3

Output

    17 9 5 4 3 3 3 2 1

- Program: 
def func():
    N = int(input())
    ans = []
    a = [int(x) for x in input().split()]
    b = [(i, a[i]) for i in range(len(a))]
    S = sorted(b, key=lambda x: x[1])
    m = max(a)
    bits = [0] + [1] * N + [0]
    wtr = [[] for q in range(N)]
    f = []
    g = 1
    last = 0
    for (i, num) in S:
        for e in range(num - last):
            f.append(g)
        last = num
        bits[i + 1] = 0
        g += bits[i] + bits[i + 2] - 1
    for d in range(1, m + 1):
        print(sum([f[d * x] for x in range(1 + (m - 1) // d)]), end=' ')



- Annotated Code: 
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and a is a list of n integers where each integer a_i satisfies 1 ≤ a_i ≤ 10^5.
def func():
    N = int(input())
    ans = []
    a = [int(x) for x in input().split()]
    b = [(i, a[i]) for i in range(len(a))]
    S = sorted(b, key=lambda x: x[1])
    m = max(a)
    bits = [0] + [1] * N + [0]
    wtr = [[] for q in range(N)]
    f = []
    g = 1
    last = 0
    for (i, num) in S:
        for e in range(num - last):
            f.append(g)
        
        last = num
        
        bits[i + 1] = 0
        
        g += bits[i] + bits[i + 2] - 1
        
    #State of the program after the  for loop has been executed: `f` is a list containing `m` elements, each equal to `g` after the loop; `last` is equal to `m`; `bits` is updated such that `bits[i + 1] = 0` for each index `i` corresponding to an executed iteration of the inner loop; `g` is `g + bits[i] + bits[i + 2] - 1` for each executed iteration of the inner loop. If the loop does not execute, `f` remains an empty list, `last` is `0`, `bits` remains as initially defined, and `g` is `1`.
    for d in range(1, m + 1):
        print(sum([f[d * x] for x in range(1 + (m - 1) // d)]), end=' ')
        
    #State of the program after the  for loop has been executed: `f` is a list containing `m` elements, each equal to `g`, `last` is `m`, `bits` remains as initially defined, `g` is `1`, and `m` is at least `1`. The loop does not execute further because `d` starts from `1` and goes up to `m+1`, and for `d=m+1`, there are no valid `x` values in the range `0` to `(m-1)//d` since `(m-1)//(m+1)` is always `0`. Therefore, the sum of selected elements from `f` is `0`.
#Overall this is what the function does:The function processes a list of integers `a` of length `n` (where \(1 \leq n \leq 10^5\)) and each integer in the list satisfies \(1 \leq a_i \leq 10^5\). It first sorts the indices of the list `a` based on the values in `a`. Then, it initializes several auxiliary lists and variables. During the first for loop, it populates the list `f` with a specific value `g` and updates the `bits` list. Finally, it prints the sum of selected elements from the list `f` for each divisor `d` of `m`, where `m` is the maximum value in the original list `a`.


Beggining of Original Assessment: 
Correctness: **False**.

Explanation: The given program does not correctly calculate the minimum number of seconds required to kill all the monsters for each value of \( k \). Specifically, the logic for calculating the minimum number of seconds is flawed. Here’s a detailed analysis:

1. **Incorrect Calculation of Minimum Seconds**: The program uses a segmented approach to calculate the minimum seconds required to kill all monsters, but it doesn't accurately handle the spreading effect of the chain lightning. It seems to focus more on the number of segments needed rather than the actual sequence of kills which would minimize the time.

2. **Example Analysis**:
   - For the input `3` followed by `5 2 7`, the expected output is `10 6 4 3 2 2 1`. However, the program's output is not matching this expectation. For instance, the calculation for \( k = 3 \) is incorrect because it doesn’t properly account for the spread of damage.

3. **Detailed Example**:
   - Consider the scenario with three monsters having health `[5, 2, 7]` and \( k = 3 \). The correct steps would be:
     1. Kill the 3rd monster with one strike, leaving health `[5, 2, 4]`.
     2. Kill the 1st monster with one strike, leaving health `[-1, 2, 4]`.
     3. Kill the 3rd monster again with one strike, leaving health `[-1, 2, 1]`.
     4. Kill the 3rd monster one more time, leaving health `[-1, -1, -2]`.

   - The total time taken is 4 seconds, not the output produced by the given program.

Given these issues, the program does not meet the problem requirements for every potential case, hence the correctness is **False**.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

