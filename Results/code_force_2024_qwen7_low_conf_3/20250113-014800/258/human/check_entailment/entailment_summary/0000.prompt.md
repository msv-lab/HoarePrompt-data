
You are a program verifier. Your task is to determine if a given Python program is correct based on the provided problem description and its execution summary. You can use the execution summary as a guide to understand the program’s behavior. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.

# Problem:
You are given a positive integer x . Find any array of integers a_0, a_1,
\ldots, a_{n-1} for which the following holds:

  * 1 \le n \le 32 , 
  * a_i is 1 , 0 , or -1 for all 0 \le i \le n - 1 , 
  * x = \displaystyle{\sum_{i=0}^{n - 1}{a_i \cdot 2^i}} , 
  * There does not exist an index 0 \le i \le n - 2 such that both a_{i} \neq 0 and a_{i + 1} \neq 0 . 

It can be proven that under the constraints of the problem, a valid array
always exists.

Input

Each test contains multiple test cases. The first line of input contains a
single integer t (1 \le t \le 10^4 ) — the number of test cases. The
description of the test cases follows.

The only line of each test case contains a single positive integer x (1 \le x
< 2^{30} ).

Output

For each test case, output two lines.

On the first line, output an integer n (1 \le n \le 32 ) — the length of the
array a_0, a_1, \ldots, a_{n-1} .

On the second line, output the array a_0, a_1, \ldots, a_{n-1} .

If there are multiple valid arrays, you can output any of them.

Example

Input

    7
    
    1
    
    14
    
    24
    
    15
    
    27
    
    11
    
    19

Output

    1
    1
    5
    0 -1 0 0 1
    6
    0 0 0 -1 0 1
    5
    -1 0 0 0 1
    6
    -1 0 -1 0 0 1
    5
    -1 0 -1 0 1
    5
    -1 0 1 0 1

Note

In the first test case, one valid array is [1] , since (1) \cdot 2^0 = 1 .

In the second test case, one possible valid array is [0,-1,0,0,1] , since (0)
\cdot 2^0 + (-1) \cdot 2^1 + (0) \cdot 2^2 + (0) \cdot 2^3 + (1) \cdot 2^4 =
-2 + 16 = 14 .

# Program:
def func_1(x):
    if x == 1:
        return [1]
    bits = []
    while x > 0:
        bit = x & 1
        bits.append(bit)
        x >>= 1
    n = len(bits)
    a = [0] * n
    for i in range(n - 1):
        if bits[i]:
            a[i] = 1
        if bits[i + 1]:
            a[i + 1] = -1
    return a





# Execution Summary:
The function `func_1` accepts a positive integer `x` such that \(1 \leq x < 2^{30}\). It returns either a list containing only the element `[1]` if `x` is 1, or a list `a` of length `n`, where each element `a[i]` is 1 if the `i-th` bit from the least significant bit (LSB) to the most significant bit (MSB) of `x` is True, and `a[i+1]` is -1 if the `(i+1)-th` bit is True. The list `a` is derived from the reversed bit representation of `x`.

The function processes the integer `x` by first checking if it is 1. If so, it returns `[1]`. Otherwise, it extracts the bits of `x` into a list `bits`, reverses them, and then constructs the list `a` based on these bits. Specifically, for each bit in `bits`, if the current bit is 1, the corresponding element in `a` is set to 1; if the next bit is 1, the next element in `a` is set to -1. The final state of the program after the function concludes is that it returns the constructed list `a`, which represents the bit pattern of `x` in a specific manner as described.


# Your response:
Reasoning:  
Correctness: **True** or **False**

