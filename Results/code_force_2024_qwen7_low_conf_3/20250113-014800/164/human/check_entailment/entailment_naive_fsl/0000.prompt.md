
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

I am giving you some examples to understand the task better. Then I am giving you your task.
# Example 1

Problem description: Write a python function to identify non-prime numbers.
Program:
```
def is_not_prime(n):
    if n < 2:
        return True
    for i in range(2, n):
        if n % i == 0:
            return True
    return False
```
Example Answer 1:
Correctness: **True**.

# Example 2

Problem description: Write a python function to count all the substrings starting and ending with same characters.
Program:
```
def count_Substring_With_Equal_Ends(s):
    count = 0
    for i in range(len(s)-1):
        for j in range(i,len(s)-1):
            if s[i] == s[j+1]:
                count += 1
    return count
```

Example Answer 2:
Correctness: **False**.

# Example 3

Problem description: Write a function to perform binary search of a number in an list
Program:
```
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid
        else:
            right = mid - 1
    if arr[left] == target:
        return left
    return -1
```
Example answer 3:
Correctness: **False**.

# Your task:
Problem description: There is a game where you need to move through a labyrinth. The labyrinth
consists of n platforms, connected by m passages.

Each platform is at some level l_i , an integer number from 0 to H - 1 . In a
single step, if you are currently on platform i , you can stay on it, or move
to another platform j . To move to platform j they have to be connected by the
passage, and their levels have to be the same, namely l_i = l_j .

After each step, the levels of all platforms change. The new level of platform
i is calculated as l'_i = (l_i + s_i) \bmod H , for all i .

You start on platform 1 . Find the minimum number of steps you need to get to
platform n .

Input

The first line of input contains a single integer t (1 \le t \le 10^4 ) — the
number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains three integers n , m , and H (2 \le
n \le 10^5 , 1 \le m \le 10^5 , 1 \le H \le 10^9 ).

The second line contains n integers l_i , the initial level of each platform
(0 \le l_i \le H-1 ).

The third line contains n integers s_i , the change of level for each platform
(0 \le s_i \le H-1 ).

Next m lines contain a description of the passages. Each passage is described
as a pair of integers — the platforms, connected by the passage. There is at
most one passage connecting each pair of platforms, and there is no passage
connecting a platform to itself.

The sum of n for all tests does not exceed 10^5 , the sum of m for all tests
does not exceed 10^5 .

Output

For each test case, print a single integer, the minimum number of steps needed
to get from platform 1 to platform n .

If it is impossible to get to platform n , print -1 .

Example

Input

    3
    
    3 3 10
    
    1 9 4
    
    2 3 0
    
    1 2
    
    3 2
    
    1 3
    
    2 1 10
    
    1 2
    
    4 6
    
    1 2
    
    8 7 25
    
    22 14 5 3 10 14 11 1
    
    9 5 4 10 7 16 18 18
    
    2 8
    
    6 3
    
    3 5
    
    7 5
    
    2 6
    
    1 4
    
    4 7

Output

    6
    -1
    52
    
Note

This is how levels of the platforms change, and what actions we need to
perform in the first example.

| Platform 1| Platform 2| Platform 3| Action  
---|---|---|---|---  
Step 1| 1| 9| 4| Stay on the platform 1  
Step 2| 3| 2| 4| Stay on the platform 1  
Step 3| 5| 5| 4| Move to the platform 2  
Step 4| 7| 8| 4| Stay on the platform 2  
Step 5| 9| 1| 4| Stay on the platform 2  
Step 6| 1| 4| 4| Move to the platform 3
Program:
```
from collections import deque

t = int(input())
for _ in range(t):
    (n, m, H) = map(int, input().split())
    levels = list(map(int, input().split()))
    changes = list(map(int, input().split()))
    passages = [tuple(map(int, input().split())) for _ in range(m)]
    result = func_1(n, m, H, levels, changes, passages)
    print(result)

def func_1(n, m, H, levels, changes, passages):
    graph = [[] for _ in range(n)]
    for (u, v) in passages:
        graph[u - 1].append(v - 1)
        graph[v - 1].append(u - 1)
    queue = deque([(0, 0)])
    visited = set([(0, levels[0])])
    while queue:
        (current_platform, steps) = queue.popleft()
        if current_platform == n - 1:
            return steps
        for next_platform in graph[current_platform]:
            if levels[current_platform] == levels[next_platform]:
                next_state = (next_platform, (levels[next_platform] + changes[next_platform]) % H)
                if next_state not in visited:
                    visited.add(next_state)
                    queue.append((next_platform, steps + 1))
        levels[current_platform] = (levels[current_platform] + changes[current_platform]) % H
    return -1


```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
