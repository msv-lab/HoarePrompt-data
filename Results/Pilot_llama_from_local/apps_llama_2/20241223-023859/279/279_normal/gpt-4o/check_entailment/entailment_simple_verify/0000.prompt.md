
You have been assigned the role of a program verifier. Given a python program and a problem description, we have performed an initial assessment of the program's correctness. We also provide the reasoning behind our assessment. 
We are additionally providing you with the program again but this time we are providing you with an annotated version of the program. This annotated version provides the state of the program at different points in the program.
Your task is to analyze the problem description, the program, and the original assessment. Use the provided annotated version to systematically evaluate the program's behavior and reasoning. Based on the annotations and the problem description, determine the correctness of the program.

Provide a final assessment of the program's correctness as follows:

If the program meets the problem description and the annotations support the correctness, output: Final: **True**
If the program does not meet the problem description, output: Final: **False**
Focus on evidence from the annotations and the original assesment to justify your conclusion. Avoid assumptions or unnecessary changes unless clearly supported by the facts.

You need to strictly follow the format Final: **True or False**.

# Your task:
Problem description: Pavel cooks barbecue. There are n skewers, they lay on a brazier in a row, each on one of n positions. Pavel wants each skewer to be cooked some time in every of n positions in two directions: in the one it was directed originally and in the reversed direction.

Pavel has a plan: a permutation p and a sequence b_1, b_2, ..., b_{n}, consisting of zeros and ones. Each second Pavel move skewer on position i to position p_{i}, and if b_{i} equals 1 then he reverses it. So he hope that every skewer will visit every position in both directions.

Unfortunately, not every pair of permutation p and sequence b suits Pavel. What is the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements? Note that after changing the permutation should remain a permutation as well.

There is no problem for Pavel, if some skewer visits some of the placements several times before he ends to cook. In other words, a permutation p and a sequence b suit him if there is an integer k (k ≥ 2n), so that after k seconds each skewer visits each of the 2n placements.

It can be shown that some suitable pair of permutation p and sequence b exists for any n.


-----Input-----

The first line contain the integer n (1 ≤ n ≤ 2·10^5) — the number of skewers.

The second line contains a sequence of integers p_1, p_2, ..., p_{n} (1 ≤ p_{i} ≤ n) — the permutation, according to which Pavel wants to move the skewers.

The third line contains a sequence b_1, b_2, ..., b_{n} consisting of zeros and ones, according to which Pavel wants to reverse the skewers.


-----Output-----

Print single integer — the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements.


-----Examples-----
Input
4
4 3 2 1
0 1 1 1

Output
2

Input
3
2 3 1
0 0 0

Output
1



-----Note-----

In the first example Pavel can change the permutation to 4, 3, 1, 2.

In the second example Pavel can change any element of b to 1.
Program:
```
func_1()

def func_1():
    import sys
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    p = list(map(int, data[1:n + 1]))
    b = list(map(int, data[n + 1:2 * n + 1]))
    visited = [False] * n
    cycles = []
    for i in range(n):
        if not visited[i]:
            cycle = []
            x = i
            while not visited[x]:
                visited[x] = True
                cycle.append(x)
                x = p[x] - 1
            cycles.append(cycle)
    no_reverse_components = sum((all((b[x] == 0 for x in cycle)) for cycle in cycles))
    if len(cycles) == 1:
        print(0)
    else:
        print(no_reverse_components if no_reverse_components > 0 else 1)


```
Original Assessment: Correctness: **True**

The provided program seems to correctly calculate the minimum total number of elements in the given permutation p and the given sequence b that Pavel needs to change so that every skewer will visit each of 2n placements.

Here's a breakdown of how the program works:

1. It reads the input: the number of skewers n, the permutation p, and the sequence b.

2. It initializes a visited array to keep track of the skewers that have been visited.

3. It identifies the cycles in the permutation p by iterating through the skewers and following the permutation until it reaches a skewer that has already been visited.

4. It counts the number of cycles where no skewer is reversed (i.e., all elements in the cycle have b[i] = 0). This is stored in the variable no_reverse_components.

5. If there is only one cycle, it means that all skewers are connected, and no changes are needed. In this case, the program prints 0.

6. If there are multiple cycles, the program checks if there are any cycles where no skewer is reversed. If there are, it prints the number of such cycles, because changing the sequence b in any of these cycles would connect them. If there are no such cycles, it prints 1, because changing the permutation in any one of the cycles would connect them.

The program seems to correctly handle all the cases mentioned in the problem description. It also passes the provided examples, which suggests that it is working as expected.

However, without further analysis or testing, it's impossible to be 100% certain that the program is correct for all possible inputs. But based on the provided information, the program appears to be correct.

Now we are giving you an annotated version of the code describing states at different parts of the program. Make sure that the annotations make sense. 
Also we assume that the input of the program will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program is still correct since we assume the user will always provide a valid input. It will also not be a problem for example if for input the program expects a  positive integer and the program does not handle the case when the input is negative or zero.
Annotated code:
func_1()

#State of the program right berfore the function call: There is a positive integer n, a list of integers p = [p_1, p_2,..., p_{n}] where for all i, 1 <= p_i <= n and p is a permutation, and a list of integers b = [b_1, b_2,..., b_{n}] where for all i, b_i is either 0 or 1.
def func_1():
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    p = list(map(int, data[1:n + 1]))
    b = list(map(int, data[n + 1:2 * n + 1]))
    visited = [False] * n
    cycles = []
    for i in range(n):
        if not visited[i]:
            cycle = []
            x = i
            while not visited[x]:
                visited[x] = True
                cycle.append(x)
                x = p[x] - 1
            cycles.append(cycle)
        
    #State of the program after the  for loop has been executed: `n` is an integer, `i` is `n-1`, `p` and `b` are lists of `n` integers, `data` is a list of strings, `visited` is a list of boolean values indicating visited nodes, and `cycles` is a list of lists representing cycles or paths within the graph.
    no_reverse_components = sum(all(b[x] == 0 for x in cycle) for cycle in cycles)
    if (len(cycles) == 1) :
        print(0)
    else :
        print(no_reverse_components if no_reverse_components > 0 else 1)
    #State of the program after the if-else block has been executed: *`n` is an integer, `i` is `n-1`, `p` and `b` are lists of `n` integers, `data` is a list of strings, `visited` is a list of boolean values indicating visited nodes, `cycles` is a list of lists representing cycles or paths within the graph, and `no_reverse_components` is the sum of all cycles in `cycles` where all elements in the cycle are equal to 0 in `b`. If the number of cycles is 1, then 0 has been printed. Otherwise, if `no_reverse_components` is greater than 0, then `no_reverse_components` has been printed; otherwise, 1 has been printed.


Does the original Assessment make sense based on the problem description and the provided code. Based on the annotated version of the code  and your reasoning, provide a refined assessment of the program's correctness, either mintaining the original assessment or changing it if the annotated version provides a different perspective.
Use all the information available to you to determine  the final correctness of the program based on the problem description. 
You need to strictly follow the format Final: **True or False**. If you believe the program is correct then Final: **True**. If you believe the program is incorrect then Final: **False**.
If you keep the original assessment then you need to provide a reason why you think the original assessment is accurate. If you change the original assessment then you need to provide a reason why you think the original assessment is not accurate.
