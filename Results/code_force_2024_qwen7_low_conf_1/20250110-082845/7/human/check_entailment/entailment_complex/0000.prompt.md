
You are a program verifier. Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
You are given a tree with n vertices numbered 1, 2, \ldots, n . Initially, all
vertices are colored white.

You can perform the following two-step operation:

  1. Choose a vertex v (1 \leq v \leq n ) and a distance d (0 \leq d \leq n-1 ). 
  2. For all vertices u (1 \leq u \leq n ) such that \text{dist}^\dagger(u,v)=d , color u black. 

Construct a sequence of operations to color all the nodes in the tree black
using the minimum possible number of operations. It can be proven that it is
always possible to do so using at most n operations.

^\dagger \text{dist}(x, y) denotes the number of edges on the (unique) simple
path between vertices x and y on the tree.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 200 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^3 ) — the number of vertices of the tree.

The following n - 1 lines of each test case describe the edges of the tree.
The i -th of these lines contains two integers u_i and v_i (1 \le u_i, v_i \le
n , u_i \neq v_i ), the indices of the vertices connected by the i -th edge.

It is guaranteed that the given edges form a tree.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10^3 .

Output

For each test case, first output a single integer op (1 \le op \le n) , the
minimum number of operations needed to color all vertices of the tree black.

Then, output op lines, each containing 2 integers. The i -th line should
contain the values of v and d chosen for the i -th operation (1 \le v \le n ,
0 \le d \le n - 1 )

You must guarantee that at the end of op operations, all vertices are colored
black.

If there are multiple solutions, you may output any one of them.

Example

Input

    4
    
    1
    
    2
    
    1 2
    
    4
    
    1 2
    
    1 3
    
    1 4
    
    7
    
    2 7
    
    3 2
    
    6 4
    
    5 7
    
    1 6
    
    6 7

Output

    1
    1 0
    2
    1 1
    2 1
    2
    1 1
    2 1
    3
    6 1
    7 1
    2 1

Note

In the first test case, there is only one possible operation, and performing
it gives us a valid answer.

In the second test case, the first operation colors vertex 2 black, and the
second operation colors vertex 1 black. It can be shown that it is impossible
to color both vertices black in one operation, so the minimum number of
operations needed is 2 . Another possible solution is to use the 2 operations:
(u, r) = (1, 0) and (u, r) = (2, 0) .

In the third test case, the first operation colors vertices 2 , 3 and 4 black,
and the second operation colors vertex 1 black. Again, it can be shown that it
is impossible to color all vertices black in 1 operation, so the minimum
number of operations needed is 2 .

In the fourth test case, the first operation colors vertices 4 , 1 and 7
black, the second operation colors vertices 2 , 5 and 6 black while the third
operation colors vertices 3 and 7 black. Notice that it is allowed to color
vertex 7 black twice.

Thus, each node was marked at least once, with node 7 marked twice. It can be
shown that it is impossible to color all vertices black in fewer than 3 moves.

# Annotated Functions:
n = 4
edges = [(1, 2), (1, 3), (1, 4)]
(num_operations, operations) = func_2(n, edges)
print(num_operations)
for (v, d) in operations:
    print(v, d)

#Function 1:
#State of the program right berfore the function call: tree is a dictionary representing an adjacency list of the tree where each key is a vertex (an integer) and the corresponding value is a list of adjacent vertices (integers). start_node is an integer representing the starting vertex for the breadth-first search (BFS) operation, such that 1 <= start_node <= n, where n is the number of vertices in the tree.
def func_1(tree, start_node):
    queue = deque([start_node])
    distances = {start_node: 0}
    while queue:
        node = queue.popleft()
        
        current_distance = distances[node]
        
        for neighbor in tree[node]:
            if neighbor not in distances:
                distances[neighbor] = current_distance + 1
                queue.append(neighbor)
        
    #State of the program after the loop has been executed: `queue` is an empty deque, `node` is the original `start_node`, `current_distance` is the distance from `start_node` to the farthest node in the tree, and `distances` contains the shortest path distances from the starting node to all other nodes in the graph represented by `tree`.
    return distances
    #`The program returns distances which contains the shortest path distances from the starting node to all other nodes in the graph represented by tree`
#Overall this is what the function does:The function `func_1` accepts a parameter `tree`, a dictionary representing an adjacency list of a tree, and a parameter `start_node`, an integer representing the starting vertex for the BFS operation. It performs a breadth-first search (BFS) to find the shortest path distances from the `start_node` to all other nodes in the graph represented by `tree`. The function returns a dictionary containing these shortest path distances. The BFS algorithm starts from `start_node`, explores all its neighbors at the present depth prior to moving on to nodes at the next depth level, and updates the distance to each node as it discovers new paths. The function correctly handles the case where the `start_node` is not directly connected to any other nodes, resulting in a distance of infinity for those nodes. The final state of the program after the function concludes is that the `distances` dictionary contains the shortest path distances from the `start_node` to all other nodes in the graph, with unconnected nodes having a distance of infinity.

#Function 2:
#State of the program right berfore the function call: n is a positive integer representing the number of vertices in the tree, and edges is a list of tuples where each tuple (u, v) represents an edge connecting vertices u and v. All vertices are initially white, and the tree is guaranteed to be acyclic with n-1 edges.
def func_2(n, edges):
    tree = {i: [] for i in range(1, n + 1)}
    for (u, v) in edges:
        tree[u].append(v)
        
        tree[v].append(u)
        
    #State of the program after the  for loop has been executed: `tree` is a dictionary where each key from 1 to `n` (inclusive) has a list of all vertices that are connected to it through edges in the graph represented by `edges`.
    distances = func_1(tree, 1)
    operations = []
    max_distance = max(distances.values())
    for d in range(max_distance + 1):
        nodes_at_d = [node for node, dist in distances.items() if dist == d]
        
        if nodes_at_d:
            operations.append((nodes_at_d[0], d))
        
    #State of the program after the  for loop has been executed: `max_distance` is a non-negative integer, `operations` is a list of tuples where each tuple is of the form `(node, d)` such that `node` is a node in `distances` and `d` is the distance of `node` from node 1, and `distances` retains its original values.
    return len(operations), operations
    #The program returns the length of the list 'operations' and the list 'operations' itself, where each element in 'operations' is a tuple of the form (node, d)
#Overall this is what the function does:The function `func_2` accepts two parameters: `n`, a positive integer representing the number of vertices in the tree, and `edges`, a list of tuples where each tuple `(u, v)` represents an edge connecting vertices `u` and `v`. The tree is guaranteed to be acyclic with `n-1` edges. The function first constructs an adjacency list representation of the tree. It then calls `func_1` to compute the shortest distances from vertex 1 to all other vertices. Based on these distances, it identifies nodes at each distance level and constructs a list of tuples `(node, d)`, where `node` is a vertex in the tree and `d` is its distance from vertex 1. Finally, it returns the length of this list and the list itself. The function handles the case where there might be no nodes at a particular distance level by checking if `nodes_at_d` is non-empty before appending to the `operations` list. The function does not handle negative integers for `n` or invalid edge inputs as it assumes the inputs are valid based on the problem constraints.




# Your response:
Reasoning:  
Correctness: **True** or **False**

