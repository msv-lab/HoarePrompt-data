
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: A string t is said to be k -good if there exists at least one
substring^\dagger of length k which is not a palindrome^\ddagger . Let f(t)
denote the sum of all values of k such that the string t is k -good.

You are given a string s of length n . You will have to answer q of the
following queries:

  * Given l and r (l < r ), find the value of f(s_ls_{l + 1}\ldots s_r) . 

^\dagger A substring of a string z is a contiguous segment of characters from
z . For example, "\mathtt{defor} ", "\mathtt{code} " and "\mathtt{o} " are all
substrings of "\mathtt{codeforces} " while "\mathtt{codes} " and "\mathtt{aaa}
" are not.

^\ddagger A palindrome is a string that reads the same backwards as forwards.
For example, the strings "\texttt{z} ", "\texttt{aa} " and "\texttt{tacocat} "
are palindromes while "\texttt{codeforces} " and "\texttt{ab} " are not.

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 2 \cdot 10^4 ) â€” the number of test cases. The
description of the test cases follows.

The first line of each test case contains two integers n and q (2 \le n \le 2
\cdot 10^5, 1 \le q \le 2 \cdot 10^5 ), the size of the string and the number
of queries respectively.

The second line of each test case contains the string s . It is guaranteed the
string s only contains lowercase English characters.

The next q lines each contain two integers, l and r (1 \le l < r \le n ).

It is guaranteed the sum of n and the sum of q both do not exceed 2 \cdot 10^5
.

Output

For each query, output f(s_ls_{l + 1}\ldots s_r) .

Example

Input

    5
    
    4 4
    
    aaab
    
    1 4
    
    1 3
    
    3 4
    
    2 4
    
    3 2
    
    abc
    
    1 3
    
    1 2
    
    5 4
    
    pqpcc
    
    1 5
    
    4 5
    
    1 3
    
    2 4
    
    2 1
    
    aa
    
    1 2
    
    12 1
    
    steponnopets
    
    1 12

Output

    9
    0
    2
    5
    5
    2
    14
    0
    2
    5
    0
    65
    
Note

In the first query of the first test case, the string is \mathtt{aaab} .
\mathtt{aaab} , \mathtt{aab} and \mathtt{ab} are all substrings that are not
palindromes, and they have lengths 4 , 3 and 2 respectively. Thus, the string
is 2 -good, 3 -good and 4 -good. Hence, f(\mathtt{aaab}) = 2 + 3 + 4 = 9 .

In the second query of the first test case, the string is \mathtt{aaa} . There
are no non-palindromic substrings. Hence, f(\mathtt{aaa}) = 0 .

In the first query of the second test case, the string is \mathtt{abc} .
\mathtt{ab} , \mathtt{bc} and \mathtt{abc} are all substrings that are not
palindromes, and they have lengths 2 , 2 and 3 respectively. Thus, the string
is 2 -good and 3 -good. Hence, f(\mathtt{abc}) = 2 + 3 = 5 . Note that even
though there are 2 non-palindromic substrings of length 2 , we count it only
once.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
T = int(input())
for _ in range(T):
    (n, q) = map(int, input().split())
    s = input().strip()
    p1 = [0] * (n + 2)
    p2 = [0] * (n + 2)
    for i in range(n + 1, -1, -1):
        if i >= n:
            p1[i] = p2[i] = i
        else:
            if i + 1 < n and s[i] != s[i + 1]:
                p1[i] = i
            else:
                p1[i] = p1[i + 1]
            if i + 2 < n and s[i] != s[i + 2]:
                p2[i] = i
            else:
                p2[i] = p2[i + 1]
    pal = func_1(n, s)
    for __ in range(q):
        (l, r) = map(int, input().split())
        l -= 1
        r -= 1
        length = r - l + 1
        if p1[l] >= r:
            print(0)
            continue
        if p2[l] >= r - 1:
            k = length // 2
            print(k * (k + 1))
            continue
        ans = length * (length + 1) // 2 - 1
        if pal[l + r] >= length // 2:
            ans -= length
        print(ans)

#State of the program right berfore the function call: n is a positive integer representing the length of the string s, and s is a string consisting of lowercase English letters.
def func_1(n, s):
    if (n == 0) :
        return []
        #The program returns an empty list
    #State of the program after the if block has been executed: `n` is a positive integer representing the length of the string `s`, and `s` is a string consisting of lowercase English letters. The length of `s` is greater than 0
    res = [0] * (2 * n - 1)
    l, r = -1, -1
    for z in range(2 * n - 1):
        i = (z + 1) // 2
        
        j = z // 2
        
        p = 0 if i >= r else min(r - i, res[2 * (l + r) - z])
        
        while j + p + 1 < n and i - p - 1 >= 0:
            if s[j + p + 1] != s[i - p - 1]:
                break
            p += 1
        
        if j + p > r:
            l, r = i - p, j + p
        
        res[z] = p
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `s` is a string consisting of lowercase English letters with length `n`, `res` is a list of `2 * n - 1` elements containing the lengths of the longest palindromic substrings centered at each position in `s`, `l` is the left boundary of the longest palindromic substring found during the loop, `r` is the right boundary of the longest palindromic substring found during the loop, `i` is always set to \((z + 1) // 2\) and `j` is set to \(z // 2\) for each iteration of the loop, and the loop executes exactly `2 * n - 1` times.
    return res
    #`The program returns a list 'res' of 2*n - 1 elements containing the lengths of the longest palindromic substrings centered at each position in 's'`

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
