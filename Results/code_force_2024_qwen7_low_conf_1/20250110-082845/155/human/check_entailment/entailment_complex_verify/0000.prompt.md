
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
[Rammstein - Ausländer](https://youtu.be/3eEA6H_y1VI)

ඞ

There are m baskets placed along a circle, numbered from 1 to m in clockwise
order (basket m is next to basket 1 ). Furthermore, there are n balls, where
ball i is initially placed in basket a_i , and no basket contains more than
one ball.

Alice is allowed to perform the following operation, which always takes
exactly one second whether you move/throw a ball or not:

  * Alice chooses an integer i between 1 and n uniformly at random. 
  * If ball i was thrown away before, do nothing. 
  * Otherwise, ball i is moved from the basket currently containing it to the next basket (in clockwise order). If the target basket currently contains another ball j , throw ball j away. 

She repeats this operation until there is exactly one ball left. Calculate the
expected time needed (in seconds) for Alice to end the process.

It can be proven that the answer can be represented as a rational number
\frac{p}{q} with coprime p and q . You need to output p \cdot q^{-1} \bmod
10^9 + 7 . It can be proven that 10^9 + 7 \nmid q .

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains two integers n and m (1 \le n \le 3
\cdot 10^5, n \le m \le 10^9 ) — the number of balls and the number of
baskets.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le m , a_i 's are pairwise distinct) — the initial position of each
ball.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, print one integer: the expected amount of time (in
seconds) Alice needs to end the process, modulo 10^9 + 7 .

Example

Input

    5
    
    3 10
    
    5 1 4
    
    2 15
    
    15 1
    
    6 6
    
    1 2 3 4 5 6
    
    6 9
    
    6 5 4 3 2 1
    
    1 100
    
    69

Output

    600000042
    14
    35
    333333409
    0
    
Note

In the first test case, Alice could have proceeded as follows (we define a_i =
-1 if ball i has been thrown out):

  * Initially, a = [5, 1, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 2 . After this, a = [5, 2, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 3 . After this, a = [5, 3, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 4 . As basket 4 previously contains ball 3 , this ball is thrown out. After this, a = [5, 4, -1] . 
  * Alice chooses i = 3 with probability \frac{1}{3} . Ball 3 has already been thrown out, so nothing happens. After this, a = [5, 4, -1] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 5 , which throws out ball 1 . After this, a = [-1, 5, -1] , and the process ends. 

The answer for this test case is \frac{189}{5} .

The answer for the second test case is 14 (note that these two balls are next
to each other).

The answer for the third test case is 35 .

The answer for the fourth test case is \frac{220}{3} .

In the fifth test case, as there is only one ball initially, the answer is 0 .

- Program: 
def func():
    MOD = 10 ** 9 + 7
    inv_2 = (MOD + 1) // 2
    inv_3 = pow(3, MOD - 2, MOD)
    tc = int(input())
    for _ in range(tc):
        (n, m) = map(int, input().split())
        a = sorted(list(map(int, input().split())))
        inv_m = pow(m, MOD - 2, MOD)
        ans = 0
        for i in range(n):
            dist = (a[(i + 1) % n] - a[i]) % m
            prob_last = dist * inv_m % MOD
            expected_getting_moved = n * inv_2 % MOD
            expected_time = (m * m - dist * dist) * inv_3 % MOD
            ans += prob_last * expected_getting_moved % MOD * expected_time % MOD
            ans %= MOD
        print(ans)



- Annotated Code: 
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 10^4. For each test case, n and m are integers such that 1 ≤ n ≤ 3 ⋅ 10^5 and n ≤ m ≤ 10^9, and a is a list of n integers such that 1 ≤ a_i ≤ m and all a_i's are pairwise distinct.
def func():
    MOD = 10 ** 9 + 7
    inv_2 = (MOD + 1) // 2
    inv_3 = pow(3, MOD - 2, MOD)
    tc = int(input())
    for _ in range(tc):
        n, m = map(int, input().split())
        
        a = sorted(list(map(int, input().split())))
        
        inv_m = pow(m, MOD - 2, MOD)
        
        ans = 0
        
        for i in range(n):
            dist = (a[(i + 1) % n] - a[i]) % m
            prob_last = dist * inv_m % MOD
            expected_getting_moved = n * inv_2 % MOD
            expected_time = (m * m - dist * dist) * inv_3 % MOD
            ans += prob_last * expected_getting_moved % MOD * expected_time % MOD
            ans %= MOD
        
        print(ans)
        
    #State of the program after the  for loop has been executed: `t` is an integer such that \(1 \leq t \leq 10^4\); `a` is a sorted list of `n` integers such that \(1 \leq a_i \leq m\) and all `a_i`'s are pairwise distinct; `MOD` is \(10^9 + 7\); `inv_2` is \(500000000\); `inv_3` is \(3^{(10^9 + 6)} \mod (10^9 + 7)\); `tc` is the number of times the loop has executed; `m` is the last integer read from input; `inv_m` is \(m^{(MOD - 2)} \mod MOD\); `ans` is the cumulative sum of \((dist \times inv_m \mod MOD) \times (n \times inv_2 \mod MOD) \times ((m \times m - dist \times dist) \times inv_3 \mod MOD) \mod MOD\) for all iterations from 0 to `n-1`, modulo `MOD`; `n` is the last integer read from input; `dist` is \((a[(i + 1) \% n] - a[i]) \% m\), `prob_last` is \((dist \times inv_m) \% MOD\), `expected_getting_moved` is \(n \times inv_2 \% MOD\), `expected_time` is \(((m \times m - dist \times dist) \times inv_3) \mod MOD\); `ans` is within the range 0 to `MOD-1`.
#Overall this is what the function does:The function processes multiple test cases, where for each test case, it reads integers `n` and `m`, and a list `a` of `n` distinct integers. It calculates and prints a cumulative value `ans` based on specific computations involving these inputs. Specifically, for each element in the list `a`, it computes a distance between consecutive elements (considering circular order), calculates probabilities and expected values related to these distances, and sums up these values modulo \(10^9 + 7\). The final `ans` is the sum of these computations for all test cases and is printed at the end. Potential edge cases include handling the modulo arithmetic correctly and ensuring that the list `a` is indeed sorted and contains distinct integers. The function does not handle invalid input directly; it assumes valid input as per the problem constraints.


Beggining of Original Assessment: 
Correctness: **False**

Explanation: The program does not handle the case where the initial positions of the balls create a circular pattern such that the distance between consecutive balls is the same. For instance, consider the following input:

- Test case with `n = 4` and `m = 6`, and initial positions `a = [1, 3, 5, 2]`.

In this case, the distances between consecutive balls are:
- From ball 1 to ball 3: 2 steps.
- From ball 3 to ball 5: 2 steps.
- From ball 5 to ball 2: 4 steps.

The program calculates the expected time based on these distances but does not correctly account for the circular nature of the problem. Specifically, the calculation of `dist` does not consider the circular arrangement, leading to an incorrect expected time.

To correctly solve this problem, the program needs to account for the circular arrangement of the baskets and the fact that moving a ball to the next basket might throw away another ball, which in turn affects the expected time calculation.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

