
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
[Rammstein - Ausländer](https://youtu.be/3eEA6H_y1VI)

ඞ

There are m baskets placed along a circle, numbered from 1 to m in clockwise
order (basket m is next to basket 1 ). Furthermore, there are n balls, where
ball i is initially placed in basket a_i , and no basket contains more than
one ball.

Alice is allowed to perform the following operation, which always takes
exactly one second whether you move/throw a ball or not:

  * Alice chooses an integer i between 1 and n uniformly at random. 
  * If ball i was thrown away before, do nothing. 
  * Otherwise, ball i is moved from the basket currently containing it to the next basket (in clockwise order). If the target basket currently contains another ball j , throw ball j away. 

She repeats this operation until there is exactly one ball left. Calculate the
expected time needed (in seconds) for Alice to end the process.

It can be proven that the answer can be represented as a rational number
\frac{p}{q} with coprime p and q . You need to output p \cdot q^{-1} \bmod
10^9 + 7 . It can be proven that 10^9 + 7 \nmid q .

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains two integers n and m (1 \le n \le 3
\cdot 10^5, n \le m \le 10^9 ) — the number of balls and the number of
baskets.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le m , a_i 's are pairwise distinct) — the initial position of each
ball.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, print one integer: the expected amount of time (in
seconds) Alice needs to end the process, modulo 10^9 + 7 .

Example

Input

    5
    
    3 10
    
    5 1 4
    
    2 15
    
    15 1
    
    6 6
    
    1 2 3 4 5 6
    
    6 9
    
    6 5 4 3 2 1
    
    1 100
    
    69

Output

    600000042
    14
    35
    333333409
    0
    
Note

In the first test case, Alice could have proceeded as follows (we define a_i =
-1 if ball i has been thrown out):

  * Initially, a = [5, 1, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 2 . After this, a = [5, 2, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 3 . After this, a = [5, 3, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 4 . As basket 4 previously contains ball 3 , this ball is thrown out. After this, a = [5, 4, -1] . 
  * Alice chooses i = 3 with probability \frac{1}{3} . Ball 3 has already been thrown out, so nothing happens. After this, a = [5, 4, -1] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 5 , which throws out ball 1 . After this, a = [-1, 5, -1] , and the process ends. 

The answer for this test case is \frac{189}{5} .

The answer for the second test case is 14 (note that these two balls are next
to each other).

The answer for the third test case is 35 .

The answer for the fourth test case is \frac{220}{3} .

In the fifth test case, as there is only one ball initially, the answer is 0 .

- Program: 
def func():
    MOD = 10 ** 9 + 7
    inv_2 = (MOD + 1) // 2
    inv_3 = pow(3, MOD - 2, MOD)
    tc = int(input())
    for _ in range(tc):
        (n, m) = map(int, input().split())
        a = sorted(list(map(int, input().split())))
        inv_m = pow(m, MOD - 2, MOD)
        ans = 0
        for i in range(n):
            dist = (a[(i + 1) % n] - a[i]) % m
            prob_last = dist * inv_m % MOD
            expected_getting_moved = n * inv_2 % MOD
            expected_time = (m * m - dist * dist) * inv_3 % MOD
            ans += prob_last * expected_getting_moved % MOD * expected_time % MOD
            ans %= MOD
        print(ans)



- Annotated Code: 
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 10^4. For each test case, n and m are integers such that 1 ≤ n ≤ 3 ⋅ 10^5 and n ≤ m ≤ 10^9, and a is a list of n integers such that 1 ≤ a_i ≤ m and all a_i's are pairwise distinct.
def func():
    MOD = 10 ** 9 + 7
    inv_2 = (MOD + 1) // 2
    inv_3 = pow(3, MOD - 2, MOD)
    tc = int(input())
    for _ in range(tc):
        n, m = map(int, input().split())
        
        a = sorted(list(map(int, input().split())))
        
        inv_m = pow(m, MOD - 2, MOD)
        
        ans = 0
        
        for i in range(n):
            dist = (a[(i + 1) % n] - a[i]) % m
            prob_last = dist * inv_m % MOD
            expected_getting_moved = n * inv_2 % MOD
            expected_time = (m * m - dist * dist) * inv_3 % MOD
            ans += prob_last * expected_getting_moved % MOD * expected_time % MOD
            ans %= MOD
        
        print(ans)
        
    #State of the program after the  for loop has been executed: `t` is an integer such that \(1 \leq t \leq 10^4\); `a` is a sorted list of `n` integers such that \(1 \leq a_i \leq m\) and all `a_i`'s are pairwise distinct; `MOD` is \(10^9 + 7\); `inv_2` is \(500000000\); `inv_3` is \(3^{(10^9 + 6)} \mod (10^9 + 7)\); `tc` is the number of times the loop has executed; `m` is the last integer read from input; `inv_m` is \(m^{(MOD - 2)} \mod MOD\); `ans` is the cumulative sum of \((dist \times inv_m \mod MOD) \times (n \times inv_2 \mod MOD) \times ((m \times m - dist \times dist) \times inv_3 \mod MOD) \mod MOD\) for all iterations from 0 to `n-1`, modulo `MOD`; `n` is the last integer read from input; `dist` is \((a[(i + 1) \% n] - a[i]) \% m\), `prob_last` is \((dist \times inv_m) \% MOD\), `expected_getting_moved` is \(n \times inv_2 \% MOD\), `expected_time` is \(((m \times m - dist \times dist) \times inv_3) \mod MOD\); `ans` is within the range 0 to `MOD-1`.
#Overall this is what the function does:The function processes multiple test cases, where for each test case, it reads integers `n` and `m`, and a list `a` of `n` distinct integers. It calculates and prints a cumulative value `ans` based on specific computations involving these inputs. Specifically, for each element in the list `a`, it computes a distance between consecutive elements (considering circular order), calculates probabilities and expected values related to these distances, and sums up these values modulo \(10^9 + 7\). The final `ans` is the sum of these computations for all test cases and is printed at the end. Potential edge cases include handling the modulo arithmetic correctly and ensuring that the list `a` is indeed sorted and contains distinct integers. The function does not handle invalid input directly; it assumes valid input as per the problem constraints.


Beggining of Original Assessment: 
Reasoning:
To verify the correctness of the given Python program, we need to ensure it follows the problem statement and computes the expected time correctly according to the provided operations and constraints.

### Problem Statement Recap:
1. There are `n` balls and `m` baskets arranged in a circle.
2. Each ball is initially placed in a unique basket.
3. Alice performs an operation where she randomly selects a ball, moves it to the next basket if possible, and if the next basket contains another ball, she discards the ball in the next basket.
4. This process continues until only one ball remains.
5. We need to calculate the expected time until this condition is met, and output \( p \cdot q^{-1} \mod (10^9 + 7) \), where \(\frac{p}{q}\) is the simplified form of the expected time.

### Program Analysis:
1. **Initialization**: The program initializes constants `MOD`, `inv_2`, and `inv_3`.
   - `MOD = 10^9 + 7`
   - `inv_2` and `inv_3` are modular inverses used for calculations.
2. **Reading Input**:
   - `tc`: Number of test cases.
   - For each test case, `n` and `m` are read, and the positions of the balls are stored in `a`.
3. **Processing Each Test Case**:
   - `inv_m`: Modular inverse of `m`.
   - `ans`: Variable to accumulate the expected time.
   - Loop through each ball index `i`:
     - Calculate the distance `dist` between consecutive balls in the circular arrangement.
     - `prob_last`: Probability of the last ball being the ball selected (considering circular nature).
     - `expected_getting_moved`: Expected time for a ball to be moved.
     - `expected_time`: Contribution to the total expected time.
     - Update `ans` with the contributions from each ball.

### Key Points to Verify:
1. **Modular Arithmetic**: The program uses modular arithmetic (`% MOD`) throughout, which is correct for handling large numbers.
2. **Distance Calculation**: The distance calculation `(a[(i + 1) % n] - a[i]) % m` correctly handles the circular nature of the baskets.
3. **Probabilities and Expectations**: The formulas for `prob_last`, `expected_getting_moved`, and `expected_time` are derived correctly from the problem's requirements.
4. **Modular Inverses**: The use of modular inverses (`inv_2` and `inv_3`) is appropriate for division in modular arithmetic.
5. **Output Format**: The final result is printed correctly in the required format.

Given the detailed analysis and the adherence to the problem constraints, the provided program appears to be correct.

### Conclusion:
Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

