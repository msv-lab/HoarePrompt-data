
You are a program verifier. Your task is to determine if a given Python program is correct based on the provided problem description and its execution summary. You can use the execution summary as a guide to understand the program’s behavior. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.

# Problem:
[Rammstein - Ausländer](https://youtu.be/3eEA6H_y1VI)

ඞ

There are m baskets placed along a circle, numbered from 1 to m in clockwise
order (basket m is next to basket 1 ). Furthermore, there are n balls, where
ball i is initially placed in basket a_i , and no basket contains more than
one ball.

Alice is allowed to perform the following operation, which always takes
exactly one second whether you move/throw a ball or not:

  * Alice chooses an integer i between 1 and n uniformly at random. 
  * If ball i was thrown away before, do nothing. 
  * Otherwise, ball i is moved from the basket currently containing it to the next basket (in clockwise order). If the target basket currently contains another ball j , throw ball j away. 

She repeats this operation until there is exactly one ball left. Calculate the
expected time needed (in seconds) for Alice to end the process.

It can be proven that the answer can be represented as a rational number
\frac{p}{q} with coprime p and q . You need to output p \cdot q^{-1} \bmod
10^9 + 7 . It can be proven that 10^9 + 7 \nmid q .

Input

Each test contains multiple test cases. The first line contains an integer t
(1 \le t \le 10^4 ) — the number of test cases. The description of the test
cases follows.

The first line of each test case contains two integers n and m (1 \le n \le 3
\cdot 10^5, n \le m \le 10^9 ) — the number of balls and the number of
baskets.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\le a_i \le m , a_i 's are pairwise distinct) — the initial position of each
ball.

It is guaranteed that the sum of n over all test cases does not exceed 3 \cdot
10^5 .

Output

For each test case, print one integer: the expected amount of time (in
seconds) Alice needs to end the process, modulo 10^9 + 7 .

Example

Input

    5
    
    3 10
    
    5 1 4
    
    2 15
    
    15 1
    
    6 6
    
    1 2 3 4 5 6
    
    6 9
    
    6 5 4 3 2 1
    
    1 100
    
    69

Output

    600000042
    14
    35
    333333409
    0
    
Note

In the first test case, Alice could have proceeded as follows (we define a_i =
-1 if ball i has been thrown out):

  * Initially, a = [5, 1, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 2 . After this, a = [5, 2, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 3 . After this, a = [5, 3, 4] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 4 . As basket 4 previously contains ball 3 , this ball is thrown out. After this, a = [5, 4, -1] . 
  * Alice chooses i = 3 with probability \frac{1}{3} . Ball 3 has already been thrown out, so nothing happens. After this, a = [5, 4, -1] . 
  * Alice chooses i = 2 with probability \frac{1}{3} , and ball 2 is moved to basket 5 , which throws out ball 1 . After this, a = [-1, 5, -1] , and the process ends. 

The answer for this test case is \frac{189}{5} .

The answer for the second test case is 14 (note that these two balls are next
to each other).

The answer for the third test case is 35 .

The answer for the fourth test case is \frac{220}{3} .

In the fifth test case, as there is only one ball initially, the answer is 0 .

# Program:
def func():
    MOD = 10 ** 9 + 7
    inv_2 = (MOD + 1) // 2
    inv_3 = pow(3, MOD - 2, MOD)
    tc = int(input())
    for _ in range(tc):
        (n, m) = map(int, input().split())
        a = sorted(list(map(int, input().split())))
        inv_m = pow(m, MOD - 2, MOD)
        ans = 0
        for i in range(n):
            dist = (a[(i + 1) % n] - a[i]) % m
            prob_last = dist * inv_m % MOD
            expected_getting_moved = n * inv_2 % MOD
            expected_time = (m * m - dist * dist) * inv_3 % MOD
            ans += prob_last * expected_getting_moved % MOD * expected_time % MOD
            ans %= MOD
        print(ans)





# Execution Summary:
The function processes multiple test cases, where for each test case, it reads integers `n` and `m`, and a list `a` of `n` distinct integers. It calculates and prints a cumulative value `ans` based on specific computations involving these inputs. Specifically, for each element in the list `a`, it computes a distance between consecutive elements (considering circular order), calculates probabilities and expected values related to these distances, and sums up these values modulo \(10^9 + 7\). The final `ans` is the sum of these computations for all test cases and is printed at the end. Potential edge cases include handling the modulo arithmetic correctly and ensuring that the list `a` is indeed sorted and contains distinct integers. The function does not handle invalid input directly; it assumes valid input as per the problem constraints.


# Your response:
Reasoning:  
Correctness: **True** or **False**

