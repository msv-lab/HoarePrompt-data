### Reasoning:

To solve this problem, we need to determine the largest `k` such that by inverting substrings of length `k`, we can turn the entire string into '1's.

Here's a breakdown of the logic in the provided code:

1. **Function `func_1`:**
   - This function takes the length of the string `n` and the string `s`.
   - It first checks if the string `s` already consists entirely of '1's. If so, it returns `n`.
   - It then iterates through all possible lengths `k` from 1 to `n` and checks if the number of '0's in the string is divisible by `k`. This is because each `k`-length substring inversion must be able to cover all '0's evenly.
   - The function returns the largest `k` that satisfies the condition.

2. **Function `func_2`:**
   - This function reads input from stdin, processes multiple test cases, and calls `func_1` for each test case.
   - It reads the total number of test cases `t`.
   - For each test case, it extracts the length `n` and the string `s`, then calls `func_1` to get the result and stores it.
   - Finally, it prints the results for all test cases.

### Analysis:

- **Correctness of `func_1`:**
  - The logic in `func_1` correctly identifies the largest `k` that allows for the transformation of the string into '1's by checking divisibility conditions.
  - The loop checks all possible `k` values up to `n`, ensuring the largest valid `k` is found.
  - The condition `zero_count % k == 0` ensures that the `k`-length substrings can cover all '0's evenly.

- **Correctness of `func_2`:**
  - The function correctly reads input, processes each test case, and calls `func_1` appropriately.
  - It handles multiple test cases efficiently by reading all inputs at once and processing them in a loop.

Given that both functions follow the logic described in the problem statement and handle inputs correctly, the provided program is **correct**.

### Conclusion:

Correctness: **True**