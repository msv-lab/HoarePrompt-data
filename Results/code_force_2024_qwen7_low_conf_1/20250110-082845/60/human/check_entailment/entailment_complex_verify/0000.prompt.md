
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
You are given two integers x and y . A sequence a of length n is called
modular if a_1=x , and for all 1 < i \le n the value of a_{i} is either
a_{i-1} + y or a_{i-1} \bmod y . Here x \bmod y denotes the remainder from
dividing x by y .

Determine if there exists a modular sequence of length n with the sum of its
elements equal to S , and if it exists, find any such sequence.

Input

Each test contains multiple test cases. The first line contains the number of
test cases t (1 \le t \le 2 \cdot 10^4 ). The description of the test cases
follows.

The first and only line of each test case contains four integers n , x , y ,
and s (1 \le n \le 2 \cdot 10^5 , 0 \le x \le 2 \cdot 10^5 , 1 \le y \le 2
\cdot 10^5 , 0 \le s \le 2 \cdot 10^5 ) — the length of the sequence, the
parameters x and y , and the required sum of the sequence elements.

The sum of n over all test cases does not exceed 2 \cdot 10^5 , and also the
sum of s over all test cases does not exceed 2 \cdot 10^5 .

Output

For each test case, if the desired sequence exists, output "Yes" on the first
line (without quotes). Then, on the second line, output n integers a_1, a_2,
\ldots, a_n separated by a space — the elements of the sequence a . If there
are multiple suitable sequences, output any of them.

If the sequence does not exist, output "No" on a single line.

You can output each letter in any case (lowercase or uppercase). For example,
the strings "yEs", "yes", "Yes", and "YES" will be accepted as a positive
answer.

Example

Input

    3
    
    5 8 3 28
    
    3 5 3 6
    
    9 1 5 79

Output

    YES
    8 11 2 2 5 
    NO
    NO
    
Note

In the first example, the sequence [8, 11, 2, 5, 2] satisfies the conditions.
Thus, a_1 = 8 = x , a_2 = 11 = a_1 + 3 , a_3 = 2 = a_2 \bmod 3 , a_4 = 5 = a_3
+ 3 , a_5 = 2 = a_4 \bmod 3 .

In the second example, the first element of the sequence should be equal to 5
, so the sequence [2, 2, 2] is not suitable.

- Program: 
t = int(input())
for _ in range(t):
    (n, x, y, s) = map(int, input().split())
    result = func_1(n, x, y, s)
    if result:
        print('Yes')
        print(' '.join(map(str, result)))
    else:
        print('No')

def func_1(n, x, y, s):
    sequence = [x]
    current_sum = x
    for i in range(1, n):
        if current_sum + y <= s and (s - current_sum - y) % y == 0:
            sequence.append(sequence[-1] + y)
            current_sum += y
        else:
            sequence.append(sequence[-1] % y)
            current_sum += sequence[-1]
        if current_sum > s:
            return None
    if current_sum == s:
        return sequence
    else:
        return None



- Annotated Code: 
t = int(input())
for _ in range(t):
    (n, x, y, s) = map(int, input().split())
    result = func_1(n, x, y, s)
    if result:
        print('Yes')
        print(' '.join(map(str, result)))
    else:
        print('No')

#State of the program right berfore the function call: n is a positive integer such that 1 <= n <= 2 * 10^5, x and y are non-negative integers such that 0 <= x <= 2 * 10^5 and 1 <= y <= 2 * 10^5, and s is a non-negative integer such that 0 <= s <= 2 * 10^5.
def func_1(n, x, y, s):
    sequence = [x]
    current_sum = x
    for i in range(1, n):
        if current_sum + y <= s and (s - current_sum - y) % y == 0:
            sequence.append(sequence[-1] + y)
            current_sum += y
        else:
            sequence.append(sequence[-1] % y)
            current_sum += sequence[-1]
        
        if current_sum > s:
            return None
        
    #State of the program after the  for loop has been executed: `n` is a positive integer such that \(1 \leq n \leq 2 \times 10^5\), `x` retains its original value, `y` retains its original value, `s` retains its original value, `sequence` is a list of length `n` starting with `[x]` and then follows the pattern based on the condition logic, and `current_sum` is the sum of the sequence according to the loop logic.
    if (current_sum == s) :
        return sequence
        #The program returns the list `sequence` which starts with `[x]` and follows the specified pattern based on the given condition logic
    else :
        return None
        #None
#Overall this is what the function does:The function `func_1` accepts four parameters: `n`, `x`, `y`, and `s`. It constructs a sequence starting with `x` and follows a specific pattern based on the given condition logic. The function checks if the sum of the sequence can reach exactly `s` within `n` steps. If the sum equals `s` after `n` steps, it returns the constructed sequence; otherwise, it returns `None`.

- `n` is a positive integer such that \(1 \leq n \leq 2 \times 10^5\).
- `x` is a non-negative integer such that \(0 \leq x \leq 2 \times 10^5\).
- `y` is a non-negative integer such that \(1 \leq y \leq 2 \times 10^5\).
- `s` is a non-negative integer such that \(0 \leq s \leq 2 \times 10^5\).

The function iterates `n-1` times, each time appending either `sequence[-1] + y` or `sequence[-1] % y` to the sequence, depending on whether adding `y` keeps the current sum within `s`. If at any point the sum exceeds `s`, the function immediately returns `None`.

After executing the loop, if the sum of the sequence equals `s`, the function returns the constructed sequence; otherwise, it returns `None`.

Potential edge cases include:
- If `y` is zero, the function will always append `x % y` (which is `x`) and the sum will never increase, potentially leading to an infinite loop unless `x` is zero.
- If `s` is zero, the function will only return `None` unless `x` is also zero.
- If `n` is one, the function will return `[x]` if `x` is less than or equal to `s` and `x` is not zero; otherwise, it will return `None`.

The final state of the program after the function concludes is:
- `n` remains unchanged and satisfies \(1 \leq n \leq 2 \times 10^5\).
- `x` remains unchanged and satisfies \(0 \leq x \leq 2 \times 10^5\).
- `y` remains unchanged and satisfies \(1 \leq y \leq 2 \times 10^5\).
- `s` remains unchanged and satisfies \(0 \leq s \leq 2 \times 10^5\).
- `sequence` is a list of length `n` starting with `[x]` and follows the specified pattern based on the given condition logic, or `None` if the sum exceeds `s` or cannot reach `s` within `n` steps.


Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided program does not handle all potential cases correctly. Specifically, the logic for generating the sequence is flawed. Let's consider the following test case:

**Input:**
```
5 8 3 28
```

The program should generate a sequence of length 5 starting with 8, where each element is either the previous element plus 3 or the previous element modulo 3, and the sum of the sequence should be 28.

However, the program logic is not robust enough to ensure that the generated sequence meets all conditions. For example, when generating the sequence, the program sometimes appends `sequence[-1] % y` without considering whether adding `y` would still allow reaching the required sum `s`.

Let's manually construct a valid sequence for the input:
- Start with `8`.
- Next, we can choose `8 + 3 = 11`.
- Then, `11 % 3 = 2`.
- Next, `2 + 3 = 5`.
- Finally, `5 + 3 = 8`.

So, a valid sequence could be `[8, 11, 2, 5, 8]`. However, the program does not guarantee this construction.

To validate this, let's run the program with the input and observe the output:

**Program Output:**
```
YES
8 11 2 5 8
```

While this sequence works for this particular case, the program does not handle all possible cases correctly. Consider another case where `y` is very large compared to `x` and `s`:

**Input:**
```
1 1 100000 1
```

The program should generate a sequence of length 1 starting with 1, but the current implementation might fail to produce the correct sequence because it relies on the sequence sum condition without properly managing the sequence generation logic.

Given these issues, the program is not fully correct and hence the output is **False**.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

