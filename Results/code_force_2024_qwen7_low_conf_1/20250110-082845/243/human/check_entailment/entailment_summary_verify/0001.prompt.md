
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
You are designing a new video game. It has n scenarios, which the player may
play in any order, but each scenario must be played exactly once. When a
player switches from a scenario to another scenario, the game shows a
specially crafted transition video to make it all feel part of one big story.
This video is specific to a pair of scenarios, but not to their order, in
other words, the video playing when switching from scenario a to scenario b is
the same as the video playing when switching from scenario b to scenario a .
Therefore, you need to create \frac{n(n-1)}{2} different transition videos,
one for each possible pair of different scenarios.

Each transition video can be either funny or scary. It is boring to see too
many funny videos or too many scary videos in a row. Therefore, your goal is
to create the videos in such a way that no matter in which order does the
player approach the scenarios, they will never see more than \lceil
\frac{3n}{4} \rceil transition videos of the same type in a row.

You have already come up with ideas for at most \lfloor \frac{n}{2} \rfloor of
the transition videos, and therefore already know if those will be funny or
scary. Now you need to choose funny or scary for all other transition videos
in such a way that the above requirement is satisfied.

Input

The first line contains a single integer n (2 \le n \le 24 ) — the number of
scenarios in the game.

The next n lines describe the partial transition video plan. Each of those
lines contains n characters. The j -th character of the i -th line corresponds
to the transition video between the i -th and the j -th scenarios. It will be
F if the corresponding transition video will be funny, S if the corresponding
transition video will be scary, ? if the corresponding transition video is
still undecided, or . if i=j .

It is guaranteed that the i -th character of the j -th line and the j -th
character of the i -th line will be the same for all i and j . It is
guaranteed that at most \lfloor \frac{n}{2} \rfloor (n divided by 2, rounded
down) transition videos will already be decided, in other words, that at most
2\lfloor \frac{n}{2} \rfloor characters in the input will be F or S.

Output

Print n lines describing the full transition video plan in the same format as
the input. Each of those lines must contain n characters. The j -th character
of the i -th line must be F if the corresponding transition video is funny, S
if the corresponding transition video is scary, or . if i=j .

Each ? character from the input must be replaced with either F or S, and all
other characters from the input must remain unchanged. It must still hold that
the i -th character of the j -th line and the j -th character of the i -th
line are the same for all i and j .

For each permutation of the n scenarios, it must hold that the transition
videos corresponding to playing the scenarios in this order do not have more
than \lceil \frac{3n}{4} \rceil (3n divided by 4, rounded up) videos of the
same type consecutively.

If there are multiple solutions, print any of them. It can be proven that for
all inputs satisfying the constraints of this problem a solution always
exists.

Examples

Input

    5
    
    .?F??
    
    ?.???
    
    F?.S?
    
    ??S.?
    
    ????.

Output

    .FFFF
    F.FFF
    FF.SF
    FFS.F
    FFFF.

Input

    12
    
    .???????????
    
    ?.??????????
    
    ??.?????????
    
    ???.????????
    
    ????.???????
    
    ?????.??????
    
    ??????.?????
    
    ???????.????
    
    ????????.???
    
    ?????????.??
    
    ??????????.?
    
    ???????????.

Output

    .SSSFFSSSSFS
    S.SFFSFSFFFS
    SS.SFFFSSSFS
    SFS.FFSSSSFS
    FFFF.FFFFFSF
    FSFFF.SFFSFF
    SFFSFS.SSSFS
    SSSSFFS.SSFS
    SFSSFFSS.SFS
    SFSSFSSSS.FS
    FFFFSFFFFF.F
    SSSSFFSSSSF.
    
Note

In the first sample: We are allowed \lceil \frac{3\cdot 5}{4} \rceil=4
transition videos of the same type in a row, but for any permutation of the 5
scenarios the player will see only 4 transition videos in total, therefore we
can choose funny or scary freely. We must still respect the already chosen
types.

In the second sample: One of the 479001600 possible permutations of scenarios
is 1, 7, 4, 12, 9, 8, 2, 6, 10, 3, 11, 5. The player will get the following
sequence of transition videos for this permutation: SSSSSSSSSFS. Even though
this sequence has 10 scary transition videos in total, it has only 9 scary
transition videos in a row, which is the maximum allowed amount (\lceil
\frac{3\cdot 12}{4} \rceil=9 ).

- Program:
def func():
    n = int(input())
    a = [0] * (n + 1)
    b = [0] * (n + 1)
    xx = ['']
    for i in range(1, n + 1):
        x = input()
        for j in range(1, n + 1):
            if x[j - 1] == 'F':
                a[i] += 1
                a[j] += 1
            elif x[j - 1] == 'S':
                b[i] += 1
                b[j] += 1
        xx.append(x)
    sa = []
    sb = []
    for i in range(1, n + 1):
        if a[i] > 0 and b[i] == 0:
            sa.append(i)
        if b[i] > 0 and a[i] == 0:
            sb.append(i)
    if len(sa) >= len(sb):
        t = len(sa)
        for i in range(1, n + 1):
            if a[i] == 0 and b[i] == 0:
                sa.append(i)
        for i in range(1, n + 1):
            nx = ''
            for j in range(1, n + 1):
                if xx[i][j - 1] != '?':
                    nx += xx[i][j - 1]
                elif i in sa[:n // 4 - 1] or j in sa[:n // 4 - 1]:
                    nx += 'F'
                else:
                    nx += 'S'
            print(nx)
    else:
        for i in range(1, n + 1):
            if a[i] == 0 and b[i] == 0:
                sb.append(i)
        for i in range(1, n + 1):
            nx = ''
            for j in range(1, n + 1):
                if xx[i][j - 1] != '?':
                    nx += xx[i][j - 1]
                elif i in sb[:n // 4 - 1] or j in sb[:n // 4 - 1]:
                    nx += 'S'
                else:
                    nx += 'F'
            print(nx)



- Function Summary: 
The function processes an input consisting of \( n \) lines, each containing \( n \) characters that represent transition videos between scenarios. These characters can be 'F' (funny), 'S' (scary), '?' (indicating a undecided transition video), or '.' (no transition video needed). The function calculates counts of 'F' and 'S' characters up to each scenario and then determines two lists, `sa` and `sb`, based on these counts. Depending on the relative sizes of `sa` and `sb`, it either assigns values to `sa` or `sb`. Finally, the function constructs and prints a new set of transition videos for each scenario, ensuring that the number of scary videos does not exceed the number of funny videos by more than a quarter of the total scenarios. If the counts of 'F' and 'S' characters do not allow such construction, the function ensures that the number of funny videos does not exceed the number of scary videos by more than a quarter.

Beggining of Original Assessment: 
### Reasoning:

Let's analyze the given Python program `func()` step-by-step to verify its correctness:

1. **Input Handling**:
   - The function reads an integer `n` which represents the number of scenarios.
   - It initializes two arrays `a` and `b` to keep track of the count of funny and scary transition videos, respectively.
   - It also initializes an empty list `xx` to store the input strings representing the current state of the transition videos.

2. **Processing Input**:
   - For each of the `n` lines of input, the program processes the string character by character.
   - If a character is 'F', it increments the count of funny videos for both scenarios involved.
   - If a character is 'S', it increments the count of scary videos for both scenarios involved.
   - The program stores the processed string in the list `xx`.

3. **Initialization of Lists**:
   - Two lists `sa` and `sb` are initialized to store indices of scenarios where only funny or only scary videos are decided, respectively.
   - The program iterates over the scenarios and checks if a scenario has only funny or only scary videos decided. If so, it appends the index to the respective list.

4. **Decision Logic**:
   - The program decides whether to add more funny or scary videos.
   - If the length of `sa` is greater than or equal to `sb`, it chooses to add more funny videos by ensuring that the scenarios with undecided videos are filled with funny videos if they are among the first `n//4 - 1` scenarios.
   - Otherwise, it chooses to add more scary videos by ensuring that the scenarios with undecided videos are filled with scary videos if they are among the first `n//4 - 1` scenarios.

5. **Output Generation**:
   - For each scenario, the program generates a new string `nx` by checking if the original input character is known ('F' or 'S') or unknown ('?').
   - If unknown, it decides the value based on the rules defined in the decision logic.
   - The generated string `nx` is printed for each scenario.

### Verification:

1. **Edge Cases**:
   - The program handles edge cases like when the input is fully decided or partially decided.
   - It ensures that the constraints of the problem are met by filling the undecided videos in a way that no more than `⌈3n/4⌉` videos of the same type appear consecutively for any permutation of scenarios.

2. **Correctness**:
   - The logic of filling the undecided videos is correct because it ensures that the constraints are met while making minimal changes to the given input.
   - The program correctly identifies the scenarios that need to be filled and fills them in a way that satisfies the requirement.

3. **Compliance**:
   - The program adheres to the problem statement and constraints, ensuring that the output meets the specified requirements.

### Conclusion:

The given Python program `func()` correctly implements the logic to generate the full transition video plan based on the constraints provided. Therefore, the program is correct.

### Correctness:
**True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

