
You are a program verifier. Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8

# Functions with Execution Summary:
import sys

input = sys.stdin.readline
class ListNode:

    def __init__(self, v=0):
        self.le = self.ri = None
        self.v = v
m = 998244353
print(func_5())

Function number 1 :
 Code:
 '''
def func_1():
    return list(map(int, input().split()))
''' 

 Output hints for function1:  The function `func_1()` reads a single line of input from the user, expecting `q` pairs of integers, each pair separated by a space. It then splits the input string into individual tokens, converts each token to an integer, and returns a list of these integers. Each pair of integers in the returned list corresponds to elements of lists `l` and `r`. The function assumes that the input format is strictly followed; if the input does not match the expected format, the behavior is undefined. Potential edge cases include incorrect formatting, non-integer values, or an incorrect number of pairs.
Function number 2 :
 Code:
 '''
def func_2():
    return int(input())
''' 

 Output hints for function2:  The function `func_2` does not accept any parameters and prompts the user to input an integer. The function then returns this integer. There are no edge cases mentioned in the annotations, and the code does not contain any missing functionality beyond what is described. The final state of the program after the function concludes is that it has returned an integer input from the user.
Function number 3 :
 Code:
 '''
def func_3():
    return map(int, input().split())
''' 

 Output hints for function3:  The function reads input from the standard input, expecting `n` and `q` followed by `q` pairs of integers `l_i` and `r_i`. It then returns a map object containing `q` pairs of integers, where each pair corresponds to the split input values, ensuring that `1 ≤ l_i ≤ n` and `1 ≤ r_i ≤ n` for all `1 ≤ i ≤ q`. The function does not perform any additional processing on the input values beyond splitting and returning them. If the input does not conform to the specified constraints, the behavior is undefined.
Function number 4 :
 Code:
 '''
def func_4():
    return input().strip()
''' 

 Output hints for function4:  The function `func_4()` does not accept any parameters and instead reads a single line of input from the user, strips any leading or trailing whitespace, and returns it as a string. The function does not use the parameters `n`, `q`, `l`, and `r` mentioned in the annotations. There are no actions performed using these parameters within the function. This implies that the function is designed to read user input and process it without any external inputs or lists as described in the annotations. The final state of the program after the function concludes is that it returns the user's input as a string, stripped of any leading or trailing whitespace.
Function number 5 :
 Code:
 '''
def func_5():
    (n, q) = func_3()
    (l, r) = (func_1(), func_1())
    nodes = [None] * (n + 1)
    for i in range(q):
        (le, ri) = (nodes[l[i]], nodes[r[i]])
        if le:
            lri = le.ri
            ri = nodes[r[i]] = ListNode(r[i])
            if lri:
                le.ri = lri.le = ri
                (ri.le, ri.ri) = (le, lri)
            else:
                (le.ri, ri.le) = (ri, le)
        elif ri:
            rle = ri.le
            le = nodes[l[i]] = ListNode(l[i])
            if rle:
                rle.ri = ri.le = le
                (le.le, le.ri) = (rle, ri)
            else:
                (le.ri, ri.le) = (ri, le)
        else:
            nodes[l[i]] = ListNode(l[i])
            nodes[r[i]] = ListNode(r[i])
            (nodes[l[i]].ri, nodes[r[i]].le) = (nodes[r[i]], nodes[l[i]])
    a = []
    for i in range(1, n + 1):
        if nodes[i]:
            while nodes[i].le:
                i = nodes[i].le.v
            a.append(i)
            while nodes[i].ri:
                i = nodes[i].ri.v
                a.append(i)
            break
    seg = [0] * (n + 1)
    seg[a[0]] += 1
    seg[a[q]] += 1
    for i in range(q):
        seg[max(a[i], a[i + 1])] += 1
    ans = 1
    cnt = 0
    for i in range(n, 0, -1):
        if nodes[i]:
            cnt += seg[i]
        else:
            ans *= cnt
            ans %= m
            cnt += 1
    return ans
''' 

 Output hints for function5:  The function `func_5` accepts four parameters: `n`, `q`, `l`, and `r`. Here, `n` and `q` are positive integers such that `1 ≤ q < n ≤ 3 ⋅ 10^5`, `l` is a list of `q` positive integers, and `r` is another list of `q` positive integers. The function constructs a doubly linked list structure based on the elements in `l` and `r` and updates the `nodes` list accordingly. After constructing the linked list, it traverses the list to identify a sequence of nodes and collects their indices in the list `a`. Then, it updates the `seg` list based on the indices in `a`. Finally, it calculates the product of `(cnt + seg[i])` for all iterations where `nodes[i]` is `True` modulo `m`, where `cnt` is the count of iterations where `nodes[i]` is `True`, and returns this value as `ans`.

Potential edge cases and missing functionality:
1. If `q == 0`, the `nodes` list remains unchanged, and the subsequent steps involving `a`, `seg`, and `ans` are skipped.
2. The code assumes that the `ListNode` class is defined elsewhere and has attributes `.v`, `.le`, and `.ri`.
3. The function `func_1()` is called twice to get the `l` and `r` lists, but its implementation is not shown, and no default behavior is specified if `func_1()` returns invalid data.


# Your response:
Reasoning:  
Correctness: **True** or **False**

