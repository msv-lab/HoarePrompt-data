
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8

- Program: 
import sys
#Function 1:
def func_1():
    return list(map(int, input().split()))

#Function 2:
def func_2():
    return int(input())

#Function 3:
def func_3():
    return map(int, input().split())

#Function 4:
def func_4():
    return input().strip()

#Function 5:
def func_5():
    (n, q) = func_3()
    (l, r) = (func_1(), func_1())
    nodes = [None] * (n + 1)
    for i in range(q):
        (le, ri) = (nodes[l[i]], nodes[r[i]])
        if le:
            lri = le.ri
            ri = nodes[r[i]] = ListNode(r[i])
            if lri:
                le.ri = lri.le = ri
                (ri.le, ri.ri) = (le, lri)
            else:
                (le.ri, ri.le) = (ri, le)
        elif ri:
            rle = ri.le
            le = nodes[l[i]] = ListNode(l[i])
            if rle:
                rle.ri = ri.le = le
                (le.le, le.ri) = (rle, ri)
            else:
                (le.ri, ri.le) = (ri, le)
        else:
            nodes[l[i]] = ListNode(l[i])
            nodes[r[i]] = ListNode(r[i])
            (nodes[l[i]].ri, nodes[r[i]].le) = (nodes[r[i]], nodes[l[i]])
    a = []
    for i in range(1, n + 1):
        if nodes[i]:
            while nodes[i].le:
                i = nodes[i].le.v
            a.append(i)
            while nodes[i].ri:
                i = nodes[i].ri.v
                a.append(i)
            break
    seg = [0] * (n + 1)
    seg[a[0]] += 1
    seg[a[q]] += 1
    for i in range(q):
        seg[max(a[i], a[i + 1])] += 1
    ans = 1
    cnt = 0
    for i in range(n, 0, -1):
        if nodes[i]:
            cnt += seg[i]
        else:
            ans *= cnt
            ans %= m
            cnt += 1
    return ans



- Annotated Code: 
import sys

input = sys.stdin.readline
class ListNode:

    def __init__(self, v=0):
        self.le = self.ri = None
        self.v = v
m = 998244353
print(func_5())

#Function 1:
#State of the program right berfore the function call: n and q are integers such that 1 ≤ q < n ≤ 3 ⋅ 10^5, and l and r are lists of integers where l contains q integers such that 1 ≤ l_i ≤ n and r contains q integers such that 1 ≤ r_i ≤ n.
def func_1():
    return list(map(int, input().split()))
    #The program returns a list of integers created by mapping int to the split input, where the input consists of q pairs of integers each pair separated by a space and representing elements of lists l and r

#Function 2:
#State of the program right berfore the function call: n and q are integers such that 1 ≤ q < n ≤ 3 × 10^5, l is a list of q integers where 1 ≤ li ≤ n for all 1 ≤ i ≤ q, and r is a list of q integers where 1 ≤ ri ≤ n for all 1 ≤ i ≤ q.
def func_2():
    return int(input())
    #The program returns an integer input from the user

#Function 3:
#State of the program right berfore the function call: n and q are integers such that 1 ≤ q < n ≤ 3 × 10^5, and l and r are lists of q integers each, where 1 ≤ l_i ≤ n and 1 ≤ r_i ≤ n for all 1 ≤ i ≤ q.
def func_3():
    return map(int, input().split())
    #The program returns a map object containing q pairs of integers (each pair corresponds to the split input values), where 1 ≤ l_i ≤ n and 1 ≤ r_i ≤ n for all 1 ≤ i ≤ q

#Function 4:
#State of the program right berfore the function call: n and q are integers such that 1 ≤ q < n ≤ 3 ⋅ 10^5, l is a list of q integers where 1 ≤ l_i ≤ n for all 1 ≤ i ≤ q, and r is a list of q integers where 1 ≤ r_i ≤ n for all 1 ≤ i ≤ q.
def func_4():
    return input().strip()
    #The program returns a string that is stripped of leading and trailing whitespace, which was input by the user

#Function 5:
#State of the program right berfore the function call: n and q are positive integers such that 1 ≤ q < n ≤ 3 ⋅ 10^5. l is a list of q positive integers where 1 ≤ l_i ≤ n, and r is a list of q positive integers where 1 ≤ r_i ≤ n.
def func_5():
    n, q = func_3()
    l, r = func_1(), func_1()
    nodes = [None] * (n + 1)
    for i in range(q):
        le, ri = nodes[l[i]], nodes[r[i]]
        
        if le:
            lri = le.ri
            ri = nodes[r[i]] = ListNode(r[i])
            if lri:
                le.ri = lri.le = ri
                ri.le, ri.ri = le, lri
            else:
                le.ri, ri.le = ri, le
        elif ri:
            rle = ri.le
            le = nodes[l[i]] = ListNode(l[i])
            if rle:
                rle.ri = ri.le = le
                le.le, le.ri = rle, ri
            else:
                le.ri, ri.le = ri, le
        else:
            nodes[l[i]] = ListNode(l[i])
            nodes[r[i]] = ListNode(r[i])
            nodes[l[i]].ri, nodes[r[i]].le = nodes[r[i]], nodes[l[i]]
        
    #State of the program after the  for loop has been executed: `nodes` is a list of length `n + 1` where each index from 0 to `n` contains a `ListNode` object or `None`. For each index `i` in the range `l[0]` to `l[q-1]` and `r[0]` to `r[q-1]`, `nodes[l[i]]` and `nodes[r[i]]` are ListNode objects with specific relationships defined. If the loop did not execute at all (i.e., `q == 0`), `nodes` remains a list of length `n + 1` containing `None` values. `n` is a positive integer, `q` is a positive integer such that `1 ≤ q < n`, `l` and `r` are lists of integers returned by `func_1()`.
    a = []
    for i in range(1, n + 1):
        if nodes[i]:
            while nodes[i].le:
                i = nodes[i].le.v
            a.append(i)
            while nodes[i].ri:
                i = nodes[i].ri.v
                a.append(i)
            break
        
    #State of the program after the  for loop has been executed: `nodes` is a list of length `n + 1` where each index from 0 to `n` contains a `ListNode` object or `None`. `a` is a list containing the indices of the nodes that were visited until the loop breaks. If the loop does not execute at all, then `a` remains an empty list.
    seg = [0] * (n + 1)
    seg[a[0]] += 1
    seg[a[q]] += 1
    for i in range(q):
        seg[max(a[i], a[i + 1])] += 1
        
    #State of the program after the  for loop has been executed: `q` is a non-negative integer, `i` is `q`, `seg[max(a[i], a[i + 1])]` is incremented by 1 for every iteration of the loop, and `seg` is a list of length `n + 1` where each element is `0` except for the element at the index specified by `a[0]`, which is `2`.
    ans = 1
    cnt = 0
    for i in range(n, 0, -1):
        if nodes[i]:
            cnt += seg[i]
        else:
            ans *= cnt
            ans %= m
            cnt += 1
        
    #State of the program after the  for loop has been executed: `q` is a non-negative integer, `i` is 0, `seg[max(a[i], a[i + 1])]` is incremented by 1 for every iteration of the loop, and `seg` is a list of length `n + 1` where each element is `0` except for the element at the index specified by `a[0]`, which is `2`; `ans` is the product of `(cnt + seg[i])` for all iterations where `nodes[i]` is `True` modulo `m`, and `cnt` is the count of iterations where `nodes[i]` is `True`.
    return ans
    #The program returns ans, which is the product of (cnt + seg[i]) for all iterations where nodes[i] is True modulo m, and cnt is the count of iterations where nodes[i] is True




Beggining of Original Assessment: 
Correctness: **False**

Explanation: The given program does not correctly implement the solution for counting the number of valid permutations. The main issue lies in the way the linked list is being used and the logic for updating the `seg` array.

1. **Linked List Construction**: The program constructs a linked list to keep track of the splits but does not handle the logic correctly for updating the linked list during each operation. Specifically, the `ListNode` class is not defined in the provided code, making it impossible to fully understand how the splits are managed.

2. **Seg Array Update**: The `seg` array is intended to keep track of the frequency of elements, but the logic for updating this array is incorrect. The program only increments `seg` at specific points without ensuring that the counts are accurate for all possible splits.

3. **Edge Cases**: The program does not handle all edge cases, such as when a split results in a single-element array, or when the maximum elements in the left and right parts do not match the given `l_i` and `r_i`.

To illustrate the problem, consider the following example:

- **Input**:
  ```
  6 3
  6 4 4
  5 5 2
  ```

- **Expected Output**: 30 (as given in the problem statement)

However, the provided program does not produce the correct output. For instance, the logic for updating the `seg` array and the linked list is flawed, leading to incorrect counts.

Given these issues, the program does not correctly implement the solution for all potential cases, hence the correctness is **False**.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

