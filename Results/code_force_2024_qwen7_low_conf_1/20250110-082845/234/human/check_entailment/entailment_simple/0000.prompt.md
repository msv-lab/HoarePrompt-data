
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
import sys

input = sys.stdin.readline
class ListNode:

    def __init__(self, v=0):
        self.le = self.ri = None
        self.v = v
m = 998244353
print(func_5())

#Function 1:
#State of the program right berfore the function call: n and q are integers such that 1 ≤ q < n ≤ 3 ⋅ 10^5, and l and r are lists of integers where l contains q integers such that 1 ≤ l_i ≤ n and r contains q integers such that 1 ≤ r_i ≤ n.
def func_1():
    return list(map(int, input().split()))
    #The program returns a list of integers created by mapping int to the split input, where the input consists of q pairs of integers each pair separated by a space and representing elements of lists l and r

#Function 2:
#State of the program right berfore the function call: n and q are integers such that 1 ≤ q < n ≤ 3 × 10^5, l is a list of q integers where 1 ≤ li ≤ n for all 1 ≤ i ≤ q, and r is a list of q integers where 1 ≤ ri ≤ n for all 1 ≤ i ≤ q.
def func_2():
    return int(input())
    #The program returns an integer input from the user

#Function 3:
#State of the program right berfore the function call: n and q are integers such that 1 ≤ q < n ≤ 3 × 10^5, and l and r are lists of q integers each, where 1 ≤ l_i ≤ n and 1 ≤ r_i ≤ n for all 1 ≤ i ≤ q.
def func_3():
    return map(int, input().split())
    #The program returns a map object containing q pairs of integers (each pair corresponds to the split input values), where 1 ≤ l_i ≤ n and 1 ≤ r_i ≤ n for all 1 ≤ i ≤ q

#Function 4:
#State of the program right berfore the function call: n and q are integers such that 1 ≤ q < n ≤ 3 ⋅ 10^5, l is a list of q integers where 1 ≤ l_i ≤ n for all 1 ≤ i ≤ q, and r is a list of q integers where 1 ≤ r_i ≤ n for all 1 ≤ i ≤ q.
def func_4():
    return input().strip()
    #The program returns a string that is stripped of leading and trailing whitespace, which was input by the user

#Function 5:
#State of the program right berfore the function call: n and q are positive integers such that 1 ≤ q < n ≤ 3 ⋅ 10^5. l is a list of q positive integers where 1 ≤ l_i ≤ n, and r is a list of q positive integers where 1 ≤ r_i ≤ n.
def func_5():
    n, q = func_3()
    l, r = func_1(), func_1()
    nodes = [None] * (n + 1)
    for i in range(q):
        le, ri = nodes[l[i]], nodes[r[i]]
        
        if le:
            lri = le.ri
            ri = nodes[r[i]] = ListNode(r[i])
            if lri:
                le.ri = lri.le = ri
                ri.le, ri.ri = le, lri
            else:
                le.ri, ri.le = ri, le
        elif ri:
            rle = ri.le
            le = nodes[l[i]] = ListNode(l[i])
            if rle:
                rle.ri = ri.le = le
                le.le, le.ri = rle, ri
            else:
                le.ri, ri.le = ri, le
        else:
            nodes[l[i]] = ListNode(l[i])
            nodes[r[i]] = ListNode(r[i])
            nodes[l[i]].ri, nodes[r[i]].le = nodes[r[i]], nodes[l[i]]
        
    #State of the program after the  for loop has been executed: `nodes` is a list of length `n + 1` where each index from 0 to `n` contains a `ListNode` object or `None`. For each index `i` in the range `l[0]` to `l[q-1]` and `r[0]` to `r[q-1]`, `nodes[l[i]]` and `nodes[r[i]]` are ListNode objects with specific relationships defined. If the loop did not execute at all (i.e., `q == 0`), `nodes` remains a list of length `n + 1` containing `None` values. `n` is a positive integer, `q` is a positive integer such that `1 ≤ q < n`, `l` and `r` are lists of integers returned by `func_1()`.
    a = []
    for i in range(1, n + 1):
        if nodes[i]:
            while nodes[i].le:
                i = nodes[i].le.v
            a.append(i)
            while nodes[i].ri:
                i = nodes[i].ri.v
                a.append(i)
            break
        
    #State of the program after the  for loop has been executed: `nodes` is a list of length `n + 1` where each index from 0 to `n` contains a `ListNode` object or `None`. `a` is a list containing the indices of the nodes that were visited until the loop breaks. If the loop does not execute at all, then `a` remains an empty list.
    seg = [0] * (n + 1)
    seg[a[0]] += 1
    seg[a[q]] += 1
    for i in range(q):
        seg[max(a[i], a[i + 1])] += 1
        
    #State of the program after the  for loop has been executed: `q` is a non-negative integer, `i` is `q`, `seg[max(a[i], a[i + 1])]` is incremented by 1 for every iteration of the loop, and `seg` is a list of length `n + 1` where each element is `0` except for the element at the index specified by `a[0]`, which is `2`.
    ans = 1
    cnt = 0
    for i in range(n, 0, -1):
        if nodes[i]:
            cnt += seg[i]
        else:
            ans *= cnt
            ans %= m
            cnt += 1
        
    #State of the program after the  for loop has been executed: `q` is a non-negative integer, `i` is 0, `seg[max(a[i], a[i + 1])]` is incremented by 1 for every iteration of the loop, and `seg` is a list of length `n + 1` where each element is `0` except for the element at the index specified by `a[0]`, which is `2`; `ans` is the product of `(cnt + seg[i])` for all iterations where `nodes[i]` is `True` modulo `m`, and `cnt` is the count of iterations where `nodes[i]` is `True`.
    return ans
    #The program returns ans, which is the product of (cnt + seg[i]) for all iterations where nodes[i] is True modulo m, and cnt is the count of iterations where nodes[i] is True


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
