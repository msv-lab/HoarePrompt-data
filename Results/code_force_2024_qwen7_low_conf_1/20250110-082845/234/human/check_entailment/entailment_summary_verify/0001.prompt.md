
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Initially, we had one array, which was a permutation of size n (an array of
size n where each integer from 1 to n appears exactly once).

We performed q operations. During the i -th operation, we did the following:

  * choose any array we have with at least 2 elements; 
  * split it into two non-empty arrays (prefix and suffix); 
  * write two integers l_i and r_i , where l_i is the maximum element in the left part which we get after the split, and r_i is the maximum element in the right part; 
  * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. 

For example, suppose the initial array was [6, 3, 4, 1, 2, 5] , and we
performed the following operations:

  1. choose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1, 2, 5] . Then we write l_1 = 6 and r_1 = 5 , and the arrays we have are [6, 3] and [4, 1, 2, 5] ; 
  2. choose the array [4, 1, 2, 5] and split it into [4, 1, 2] and [5] . Then we write l_2 = 4 and r_2 = 5 , and the arrays we have are [6, 3] , [4, 1, 2] and [5] ; 
  3. choose the array [4, 1, 2] and split it into [4] and [1, 2] . Then we write l_3 = 4 and r_3 = 2 , and the arrays we have are [6, 3] , [4] , [1, 2] and [5] . 

You are given two integers n and q , and two sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] . A permutation of size n is called valid if we can
perform q operations and produce the given sequences [l_1, l_2, \dots, l_q]
and [r_1, r_2, \dots, r_q] .

Calculate the number of valid permutations.

Input

The first line contains two integers n and q (1 \le q < n \le 3 \cdot 10^5 ).

The second line contains q integers l_1, l_2, \dots, l_q (1 \le l_i \le n ).

The third line contains q integers r_1, r_2, \dots, r_q (1 \le r_i \le n ).

Additional constraint on the input: there exists at least one permutation
which can produce the given sequences [l_1, l_2, \dots, l_q] and [r_1, r_2,
\dots, r_q] .

Output

Print one integer — the number of valid permutations, taken modulo 998244353 .

Examples

Input

    6 3
    
    6 4 4
    
    5 5 2

Output

    30
    
Input

    10 1
    
    10
    
    9

Output

    1814400
    
Input

    4 1
    
    2
    
    4

Output

    8

- Program:
import sys
#Function 1:
def func_1():
    return list(map(int, input().split()))

#Function 2:
def func_2():
    return int(input())

#Function 3:
def func_3():
    return map(int, input().split())

#Function 4:
def func_4():
    return input().strip()

#Function 5:
def func_5():
    (n, q) = func_3()
    (l, r) = (func_1(), func_1())
    nodes = [None] * (n + 1)
    for i in range(q):
        (le, ri) = (nodes[l[i]], nodes[r[i]])
        if le:
            lri = le.ri
            ri = nodes[r[i]] = ListNode(r[i])
            if lri:
                le.ri = lri.le = ri
                (ri.le, ri.ri) = (le, lri)
            else:
                (le.ri, ri.le) = (ri, le)
        elif ri:
            rle = ri.le
            le = nodes[l[i]] = ListNode(l[i])
            if rle:
                rle.ri = ri.le = le
                (le.le, le.ri) = (rle, ri)
            else:
                (le.ri, ri.le) = (ri, le)
        else:
            nodes[l[i]] = ListNode(l[i])
            nodes[r[i]] = ListNode(r[i])
            (nodes[l[i]].ri, nodes[r[i]].le) = (nodes[r[i]], nodes[l[i]])
    a = []
    for i in range(1, n + 1):
        if nodes[i]:
            while nodes[i].le:
                i = nodes[i].le.v
            a.append(i)
            while nodes[i].ri:
                i = nodes[i].ri.v
                a.append(i)
            break
    seg = [0] * (n + 1)
    seg[a[0]] += 1
    seg[a[q]] += 1
    for i in range(q):
        seg[max(a[i], a[i + 1])] += 1
    ans = 1
    cnt = 0
    for i in range(n, 0, -1):
        if nodes[i]:
            cnt += seg[i]
        else:
            ans *= cnt
            ans %= m
            cnt += 1
    return ans



- Function Summary: 
Output hints for function number 5 : The function `func_5` accepts four parameters: `n`, `q`, `l`, and `r`. Here, `n` and `q` are positive integers such that `1 ≤ q < n ≤ 3 ⋅ 10^5`, `l` is a list of `q` positive integers, and `r` is another list of `q` positive integers. The function constructs a doubly linked list structure based on the elements in `l` and `r` and updates the `nodes` list accordingly. After constructing the linked list, it traverses the list to identify a sequence of nodes and collects their indices in the list `a`. Then, it updates the `seg` list based on the indices in `a`. Finally, it calculates the product of `(cnt + seg[i])` for all iterations where `nodes[i]` is `True` modulo `m`, where `cnt` is the count of iterations where `nodes[i]` is `True`, and returns this value as `ans`.

Potential edge cases and missing functionality:
1. If `q == 0`, the `nodes` list remains unchanged, and the subsequent steps involving `a`, `seg`, and `ans` are skipped.
2. The code assumes that the `ListNode` class is defined elsewhere and has attributes `.v`, `.le`, and `.ri`.
3. The function `func_1()` is called twice to get the `l` and `r` lists, but its implementation is not shown, and no default behavior is specified if `func_1()` returns invalid data.+


Beggining of Original Assessment: 
### Reasoning:

To verify the correctness of the given Python program, let's break down the solution step-by-step and check if it aligns with the problem statement.

1. **Problem Understanding:**
   - We start with a permutation of size `n`.
   - We perform `q` operations, each involving splitting an array into two non-empty parts and recording the maximum values of the left (`l_i`) and right (`r_i`) parts.
   - We need to determine if a given sequence of `l_i` and `r_i` can be produced by performing these operations on some permutation of size `n`.

2. **Program Analysis:**
   - The program reads input values and initializes data structures.
   - It uses a linked list to simulate the merging and splitting operations.
   - It iterates through the given sequences `l` and `r`, updating the linked list accordingly.
   - After processing all operations, it constructs the final permutation and calculates the number of valid permutations using segment tree updates and combinatorial calculations.

3. **Key Components:**
   - **Linked List Construction:** The program uses a linked list to keep track of the current state of the permutation after each operation.
   - **Segment Tree Updates:** The segment tree is used to count the number of times each element appears in the final permutation.
   - **Combinatorial Calculation:** The program calculates the number of valid permutations by considering the frequency of each element in the final permutation.

4. **Validation:**
   - The program handles the constraints and examples provided correctly.
   - The logic for updating the linked list and segment tree matches the problem requirements.
   - The combinatorial calculation ensures that all valid permutations are counted.

Given the detailed analysis, the program appears to correctly implement the logic required to solve the problem.

### Correctness:

**True**

The given program is correct based on the provided problem description and the detailed analysis.

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

