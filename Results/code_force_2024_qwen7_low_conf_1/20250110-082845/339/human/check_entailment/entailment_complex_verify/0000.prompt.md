
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
There are n monsters standing in a row. The i -th monster has a_i health
points.

Every second, you can choose one alive monster and launch a chain lightning at
it. The lightning deals k damage to it, and also spreads to the left (towards
decreasing i ) and to the right (towards increasing i ) to alive monsters,
dealing k damage to each. When the lightning reaches a dead monster or the
beginning/end of the row, it stops. A monster is considered alive if its
health points are strictly greater than 0 .

For example, consider the following scenario: there are three monsters with
health equal to [5, 2, 7] , and k = 3 . You can kill them all in 4 seconds:

  * launch a chain lightning at the 3 -rd monster, then their health values are [2, -1, 4] ; 
  * launch a chain lightning at the 1 -st monster, then their health values are [-1, -1, 4] ; 
  * launch a chain lightning at the 3 -rd monster, then their health values are [-1, -1, 1] ; 
  * launch a chain lightning at the 3 -th monster, then their health values are [-1, -1, -2] . 

For each k from 1 to \max(a_1, a_2, \dots, a_n) , calculate the minimum number
of seconds it takes to kill all the monsters.

Input

The first line contains a single integer n (1 \le n \le 10^5 ) — the number of
monsters.

The second line contains n integers a_1, a_2, \dots, a_n (1 \le a_i \le 10^5 )
— the health points of the i -th monster.

Output

For each k from 1 to \max(a_1, a_2, \dots, a_n) , output the minimum number of
seconds it takes to kill all the monsters.

Examples

Input

    3
    
    5 2 7

Output

    10 6 4 3 2 2 1 
    
Input

    4
    
    7 7 7 7

Output

    7 4 3 2 2 2 1 
    
Input

    10
    
    1 9 7 6 2 4 7 8 1 3

Output

    17 9 5 4 3 3 3 2 1

- Program: 
def func():
    N = int(input())
    ans = []
    a = [int(x) for x in input().split()]
    b = [(i, a[i]) for i in range(len(a))]
    S = sorted(b, key=lambda x: x[1])
    m = max(a)
    bits = [0] + [1] * N + [0]
    wtr = [[] for q in range(N)]
    f = []
    g = 1
    last = 0
    for (i, num) in S:
        for e in range(num - last):
            f.append(g)
        last = num
        bits[i + 1] = 0
        g += bits[i] + bits[i + 2] - 1
    for d in range(1, m + 1):
        print(sum([f[d * x] for x in range(1 + (m - 1) // d)]), end=' ')



- Annotated Code: 
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and a is a list of n integers where 1 ≤ a_i ≤ 10^5 for all 1 ≤ i ≤ n.
def func():
    N = int(input())
    ans = []
    a = [int(x) for x in input().split()]
    b = [(i, a[i]) for i in range(len(a))]
    S = sorted(b, key=lambda x: x[1])
    m = max(a)
    bits = [0] + [1] * N + [0]
    wtr = [[] for q in range(N)]
    f = []
    g = 1
    last = 0
    for (i, num) in S:
        for e in range(num - last):
            f.append(g)
        
        last = num
        
        bits[i + 1] = 0
        
        g += bits[i] + bits[i + 2] - 1
        
    #State of the program after the  for loop has been executed: `N` is an integer equal to the input value within the range 1 to \(10^5\); `a` is a list of `N` integers where each integer is between 1 and \(10^5\); `ans` is an empty list; `b` is a list of tuples where each tuple consists of an index `i` and the corresponding value `a[i]`; `S` is a list of tuples where each tuple consists of an index `i` and the corresponding value `a[i]`, sorted in ascending order by the value `a[i]`; `m` is the maximum value in the list `a`; `bits` is a list of length `N + 2` starting with `0`, followed by `N` elements set to `1`, and ending with `0`, with all elements except the first and the last set to `0`; `wtr` is a list of `N` empty lists; `f` is a list of `N + 2` elements, with the first `N + 1` elements being ones and the last element being `g`; `g` is either 0, 1, or 2; `last` is `m`.
    for d in range(1, m + 1):
        print(sum([f[d * x] for x in range(1 + (m - 1) // d)]), end=' ')
        
    #State of the program after the  for loop has been executed: `total` is 0, `a` is a list of N integers where each integer is between 1 and \(10^5\), `ans` is an empty list, `b` is a list of tuples where each tuple consists of an index `i` and the corresponding value `a[i]`, `S` is a list of tuples where each tuple consists of an index `i` and the corresponding value `a[i]`, sorted in ascending order by the value `a[i]`, `m` is the maximum value in the list `a`, `bits` is a list of length `N + 2` starting with `0`, followed by `N` elements set to `1`, and ending with `0`, with all elements except the first and the last set to `0`, `wtr` is a list of `N` empty lists, `f` is a list of `N + 2` elements with the first `N + 1` elements being ones and the last element being `g`, `g` is either 0, 1, or 2, `last` is `m`, and the printed value for each iteration `i` is the sum of the elements in `f` at indices from `d*i` to `(d-1)*(i+1)` inclusive.
#Overall this is what the function does:The function accepts an integer `n` and a list `a` of `n` integers, and performs the following operations:
1. It reads the integer `N` and the list `a` from standard input.
2. It constructs a list `b` of tuples containing each index `i` and the corresponding value `a[i]`.
3. It sorts the list `b` based on the values of `a`.
4. It determines the maximum value `m` in the list `a`.
5. It initializes a bit array `bits` and a list `wtr` of empty lists.
6. It iterates through the sorted list `S` and updates the bit array `bits` and another list `f` based on the differences between consecutive elements.
7. It prints the cumulative sums of the elements in the list `f` for each divisor of the maximum value `m`.


Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided program does not correctly implement the logic required to solve the problem. Specifically, the program does not properly handle the calculation of the minimum number of seconds needed to kill all monsters for each value of `k`. The logic used in the program does not accurately simulate the spread of the chain lightning and the reduction of monster health over time.

One issue is that the program does not correctly update the `bits` array to reflect the spread of the chain lightning. The `bits` array is initialized incorrectly and the logic for updating it does not account for the proper spread of damage to adjacent monsters. Additionally, the program does not correctly handle the scenario where a monster is killed by the chain lightning but the lightning still spreads further to other monsters.

To demonstrate this, consider the following input:
```
3
5 2 7
```

The expected output should be:
```
10 6 4 3 2 2 1
```

However, running the provided program with this input will produce incorrect results due to the issues mentioned above. Therefore, the program is incorrect.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

