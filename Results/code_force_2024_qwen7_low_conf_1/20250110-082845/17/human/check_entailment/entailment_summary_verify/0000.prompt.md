
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
Define the binary encoding of a finite set of natural numbers T \subseteq
\\{0,1,2,\ldots\\} as f(T) = \sum\limits_{i \in T} 2^i . For example,
f(\\{0,2\\}) = 2^0 + 2^2 = 5 and f(\\{\\}) = 0 . Notice that f is a bijection
from all such sets to all non-negative integers. As such, f^{-1} is also
defined.

You are given an integer n along with 2^n-1 sets V_1,V_2,\ldots,V_{2^n-1} .

Find all sets S that satisfy the following constraint:

  * S \subseteq \\{0,1,\ldots,n-1\\} . Note that S can be empty. 
  * For all non-empty subsets T \subseteq \\{0,1,\ldots,n-1\\} , |S \cap T| \in V_{f(T)} . 

Due to the large input and output, both input and output will be given in
terms of binary encodings of the sets.

Input

The first line of input contains a single integer n (1 \leq n \leq 20 ).

The second line of input contains 2^n-1 integers v_1,v_2,\ldots,v_{2^n-1} (0
\leq v_i < 2^{n+1} ) — the sets V_i given in their binary encoding where V_i =
f^{-1}(v_i) .

Output

The first line of output should contain an integer k indicating the number of
possible S .

In the following k lines, you should output f(S) for all possible S in
increasing order.

Examples

Input

    3
    
    15 15 15 15 15 15 12

Output

    4
    3
    5
    6
    7
    
Input

    5
    
    63 63 63 63 6 63 63 63 63 63 63 5 63 63 63 63 63 63 8 63 63 63 63 2 63 63 63 63 63 63 63

Output

    1
    19
    
Note

In the first test case, one possible S is f^{-1}(3) = \\{0,1\\} . All the non-
empty subsets T \subseteq \\{0,1,2\\} and the corresponding |S \cap T| , f(T)
and V_f(T) are as follows:

T | |S\cap T| | f(T) | V_{f(T)}   
---|---|---|---  
\\{0\\} | 1 | 1 | \\{0,1,2,3\\}   
\\{1\\} | 1 | 2 | \\{0,1,2,3\\}   
\\{2\\} | 0 | 4 | \\{0,1,2,3\\}   
\\{0,1\\} | 2 | 3 | \\{0,1,2,3\\}   
\\{0,2\\} | 1 | 5 | \\{0,1,2,3\\}   
\\{1,2\\} | 1 | 6 | \\{0,1,2,3\\}   
\\{0,1,2\\} | 2 | 7 | \\{2,3\\}

- Program:
import itertools

print('Test Case 1:')
func_1(3, [15] * 7)
print('\nTest Case 2:')
func_1(5, [63] * 16)

def func_1(n, V):
    V = [bin(i)[2:] for i in V]
    S = []
    for i in range(2 ** n):
        s = bin(i)[2:]
        if len(s) < n:
            s = '0' * (n - len(s)) + s
        valid = True
        for j in range(n):
            if s[j] == '1':
                sub_s = s[:j] + s[j + 1:]
                if not any((sub_s.count('1') == int(v, 2) for v in V)):
                    valid = False
                    break
        if valid:
            S.append(bin(int(s, 2) + 1)[2:])
    S.sort()
    print(len(S))
    for s in S:
        print(int(s, 2))



- Function Summary: 
The function `func_1` accepts an integer `n` (where \(1 \leq n \leq 20\)) and a list `V` of \(2^n - 1\) integers, each satisfying \(0 \leq v_i < 2^{n+1}\). It generates and returns all valid binary strings of length `n` based on the given conditions. Specifically, a binary string `s` of length `n` is considered valid if there exists a binary string `v` in `V` such that the count of '1's in `s` excluding one position equals the integer value of `v`. The function sorts the resulting list of valid binary strings and prints the length of this list followed by each integer value of the binary strings.

Beggining of Original Assessment: 
Correctness: **False**

Explanation: The provided program does not correctly implement the logic required to solve the problem. Specifically, the logic for checking whether a subset \( S \) satisfies the condition for all non-empty subsets \( T \subseteq \{0,1,\ldots,n-1\} \) is flawed.

Let's analyze a specific example to illustrate the issue:

For \( n = 3 \), the program is given the following values for \( V \):
\[ V = [15, 15, 15, 15, 15, 15, 12] \]

The expected output is:
\[ \{3, 5, 6, 7\} \]

However, the program will output:
\[ \{1, 2, 4, 8\} \]

Let's consider the subset \( S = \{1\} \). The binary encoding of \( S \) is \( 100_2 = 4 \).

For \( S = \{1\} \):
- The non-empty subsets \( T \) of \( \{0,1,2\} \) are:
  - \( \{0\} \): \( |S \cap T| = 0 \) and \( f(T) = 1 \). \( V_1 = 15 \), which includes 0.
  - \( \{1\} \): \( |S \cap T| = 1 \) and \( f(T) = 2 \). \( V_2 = 15 \), which includes 1.
  - \( \{2\} \): \( |S \cap T| = 0 \) and \( f(T) = 4 \). \( V_4 = 15 \), which includes 0.
  - \( \{0,1\} \): \( |S \cap T| = 1 \) and \( f(T) = 3 \). \( V_3 = 15 \), which includes 1.
  - \( \{0,2\} \): \( |S \cap T| = 0 \) and \( f(T) = 5 \). \( V_5 = 15 \), which includes 0.
  - \( \{1,2\} \): \( |S \cap T| = 1 \) and \( f(T) = 6 \). \( V_6 = 15 \), which includes 1.
  - \( \{0,1,2\} \): \( |S \cap T| = 1 \) and \( f(T) = 7 \). \( V_7 = 12 \), which includes 0.

All these conditions are satisfied, but the program incorrectly marks \( S = \{1\} \) as invalid because it checks if the intersection size matches \( V_{f(T)} \) for all subsets \( T \) and finds no subset where the intersection size is exactly \( V_{f(T)} \).

This example shows that the program does not correctly handle the constraints of the problem, hence the program is incorrect.

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

