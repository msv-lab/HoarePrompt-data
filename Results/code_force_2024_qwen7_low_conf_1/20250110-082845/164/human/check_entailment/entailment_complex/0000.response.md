### Reasoning:

1. **Problem Understanding**: The problem involves moving through a labyrinth of platforms with specific rules for movement and level changes. The goal is to find the minimum number of steps required to move from platform 1 to platform n.

2. **Graph Construction**: The function correctly constructs an undirected graph using the `passages` information, where each platform is represented by an index and edges connect platforms with the same initial level.

3. **Breadth-First Search (BFS)**: The BFS algorithm is used to explore the graph starting from platform 1. The state of each node in the BFS is represented by a tuple containing the platform index and its current level after applying the changes.

4. **Level Update**: After visiting a platform, the function updates its level correctly using the formula `(levels[current_platform] + changes[current_platform]) % H`.

5. **Visited States**: The function keeps track of visited states using a set to ensure no state is processed more than once, which helps in avoiding infinite loops due to cyclic graphs.

6. **Edge Cases**: The function handles the case where it's impossible to reach the target platform by returning `-1` if the queue becomes empty without reaching the target platform.

7. **Input Handling**: The function correctly handles multiple test cases by iterating over them using a loop.

Given these points, the function appears to implement the logic correctly as per the problem statement and the provided example.

### Correctness:
**True**