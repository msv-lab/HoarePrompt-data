
You are a program verifier. Your task is to determine if a given Python program is correct based on the provided problem description and its execution summary. You can use the execution summary as a guide to understand the program’s behavior. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.

# Problem:
There is a game where you need to move through a labyrinth. The labyrinth
consists of n platforms, connected by m passages.

Each platform is at some level l_i , an integer number from 0 to H - 1 . In a
single step, if you are currently on platform i , you can stay on it, or move
to another platform j . To move to platform j they have to be connected by the
passage, and their levels have to be the same, namely l_i = l_j .

After each step, the levels of all platforms change. The new level of platform
i is calculated as l'_i = (l_i + s_i) \bmod H , for all i .

You start on platform 1 . Find the minimum number of steps you need to get to
platform n .

Input

The first line of input contains a single integer t (1 \le t \le 10^4 ) — the
number of test cases. Then the descriptions of the test cases follow.

The first line of each test case contains three integers n , m , and H (2 \le
n \le 10^5 , 1 \le m \le 10^5 , 1 \le H \le 10^9 ).

The second line contains n integers l_i , the initial level of each platform
(0 \le l_i \le H-1 ).

The third line contains n integers s_i , the change of level for each platform
(0 \le s_i \le H-1 ).

Next m lines contain a description of the passages. Each passage is described
as a pair of integers — the platforms, connected by the passage. There is at
most one passage connecting each pair of platforms, and there is no passage
connecting a platform to itself.

The sum of n for all tests does not exceed 10^5 , the sum of m for all tests
does not exceed 10^5 .

Output

For each test case, print a single integer, the minimum number of steps needed
to get from platform 1 to platform n .

If it is impossible to get to platform n , print -1 .

Example

Input

    3
    
    3 3 10
    
    1 9 4
    
    2 3 0
    
    1 2
    
    3 2
    
    1 3
    
    2 1 10
    
    1 2
    
    4 6
    
    1 2
    
    8 7 25
    
    22 14 5 3 10 14 11 1
    
    9 5 4 10 7 16 18 18
    
    2 8
    
    6 3
    
    3 5
    
    7 5
    
    2 6
    
    1 4
    
    4 7

Output

    6
    -1
    52
    
Note

This is how levels of the platforms change, and what actions we need to
perform in the first example.

| Platform 1| Platform 2| Platform 3| Action  
---|---|---|---|---  
Step 1| 1| 9| 4| Stay on the platform 1  
Step 2| 3| 2| 4| Stay on the platform 1  
Step 3| 5| 5| 4| Move to the platform 2  
Step 4| 7| 8| 4| Stay on the platform 2  
Step 5| 9| 1| 4| Stay on the platform 2  
Step 6| 1| 4| 4| Move to the platform 3

# Program:
from collections import deque

t = int(input())
for _ in range(t):
    (n, m, H) = map(int, input().split())
    levels = list(map(int, input().split()))
    changes = list(map(int, input().split()))
    passages = [tuple(map(int, input().split())) for _ in range(m)]
    result = func_1(n, m, H, levels, changes, passages)
    print(result)

def func_1(n, m, H, levels, changes, passages):
    graph = [[] for _ in range(n)]
    for (u, v) in passages:
        graph[u - 1].append(v - 1)
        graph[v - 1].append(u - 1)
    queue = deque([(0, 0)])
    visited = set([(0, levels[0])])
    while queue:
        (current_platform, steps) = queue.popleft()
        if current_platform == n - 1:
            return steps
        for next_platform in graph[current_platform]:
            if levels[current_platform] == levels[next_platform]:
                next_state = (next_platform, (levels[next_platform] + changes[next_platform]) % H)
                if next_state not in visited:
                    visited.add(next_state)
                    queue.append((next_platform, steps + 1))
        levels[current_platform] = (levels[current_platform] + changes[current_platform]) % H
    return -1





# Execution Summary:
The function `func_1` accepts parameters `n`, `m`, `H`, `levels`, `changes`, and `passages` and returns either the number of steps taken to reach the last platform (`n-1`) or `-1` if it is impossible to reach the last platform. It constructs a graph from the given `passages` and uses a breadth-first search (BFS) algorithm to find the shortest path from the first platform (index 0) to the last platform, taking into account the changes in levels and applying a modulus operation with `H`. If a valid path is found, the function returns the number of steps required to reach the last platform. If no valid path exists, it returns `-1`. Potential edge cases include scenarios where the starting platform and the target platform have the same initial level and changes, or where the graph is disconnected.


# Your response:
Reasoning:  
Correctness: **True** or **False**

