
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and one or more function summaries of the code. A function summary describing a function's output states and return values.

Task:
1. Analyze the problem description, the program code, and the function summary(ies). Assume valid inputs.
2. Use the summary(ies) to systematically evaluate the program’s behavior and reasoning. Use it (them) to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.



- Problem description: 
There is a hidden array a of size n consisting of only 1 and -1 . Let p be the
prefix sums of array a . More formally, p is an array of length n defined as
p_i = a_1 + a_2 + \ldots + a_i . Afterwards, array p is sorted in non-
decreasing order. For example, if a = [1, -1, -1, 1, 1] , then p = [1, 0, -1,
0, 1] before sorting and p = [-1, 0, 0, 1, 1] after sorting.

You are given the prefix sum array p after sorting, but you do not know what
array a is. Your task is to count the number of initial arrays a such that the
above process results in the given sorted prefix sum array p . As this number
can be large, you are only required to find it modulo 998\,244\,353 .

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 1000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 5000
) — the size of the hidden array a .

The second line of each test case contains n integers p_1, p_2, \ldots, p_n
(|p_i| \le n ) — the n prefix sums of a sorted in non-decreasing order.

It is guaranteed that p_1 \le p_2 \le \ldots \le p_n .

It is guaranteed that the sum of n over all test cases does not exceed 5000 .

Output

For each test case, output the answer modulo 998\,244\,353 .

Example

Input

    5
    
    1
    
    0
    
    1
    
    1
    
    3
    
    -1 1 2
    
    5
    
    -1 0 0 1 1
    
    5
    
    -4 -3 -3 -2 -1

Output

    0
    1
    0
    3
    1
    
Note

In the first two test cases, the only possible arrays a for n = 1 are a = [1]
and a = [-1] . Their respective sorted prefix sum arrays p are p = [1] and p =
[-1] . Hence, there is no array a that can result in the sorted prefix sum
array p = [0] and there is exactly 1 array a that can result in the sorted
prefix sum array p = [1] .

In the third test case, it can be proven that there is no array a that could
result in the sorted prefix sum array p = [-1, 1, 2] .

In the fourth test case, the 3 possible arrays a that could result in the
sorted prefix sum array p = [-1, 0, 0, 1, 1] are:

  * a = [1, -1, 1, -1, -1] . The prefix sum array before sorting is p = [1, 0, 1, 0, -1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [1, -1, -1, 1, 1] . The prefix sum array before sorting is p = [1, 0, -1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [-1, 1, 1, -1, 1] . The prefix sum array before sorting is p = [-1, 0, 1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 

For the fifth test case, the only possible array a that could result in the
sorted prefix sum array p = [-4, -3, -3, -2, -1] is a = [-1, -1, -1, -1, 1] .

- Program:

#Function 1:
def func_1(n, p):
    dp = [0] * (2 * n + 1)
    offset = n
    dp[offset] = 1
    for i in range(1, n + 1):
        new_dp = [0] * (2 * n + 1)
        for j in range(2 * n + 1):
            if dp[j] > 0:
                if j + 1 <= 2 * n:
                    new_dp[j + 1] = (new_dp[j + 1] + dp[j]) % MOD
                if j - 1 >= 0:
                    new_dp[j - 1] = (new_dp[j - 1] + dp[j]) % MOD
        dp = new_dp
    final_sum = p[-1] + offset
    return dp[final_sum]

#Function 2:
def func_2():
    import sys
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        index += 1
        p = list(map(int, data[index:index + n]))
        index += n
        result = func_1(n, p)
        results.append(result)
    for res in results:
        print(res)



- Function Summary: 
Output hints for function number 2 : The function `func_2` reads multiple test cases from standard input, where each test case consists of an integer `t` followed by an integer `n` and a list `p` of `n` integers sorted in non-decreasing order. For each test case, it calls another function `func_1` with `n` and `p` as arguments, stores the result, and then prints the result after processing all test cases. The function does not return any value; instead, it prints the output directly. If `t` is less than `n`, it processes up to `t` test cases; otherwise, it processes all `n` test cases. An edge case to consider is when `t` is exactly equal to `n`, in which case it will process exactly `t` test cases. There is no missing functionality in the provided code; however, the function assumes that the input is correctly formatted and does not handle invalid inputs.+


Beggining of Original Assessment: 
Reasoning:
The given program attempts to solve the problem by using dynamic programming (DP) to count the number of possible arrays `a` that would produce the given sorted prefix sum array `p`. Here's a detailed analysis:

1. **Function `func_1`:**
   - The function initializes a DP array `dp` of size `2 * n + 1` with all elements set to 0, except for the middle element (`offset`) which is set to 1.
   - It then iterates over the range from 1 to `n`, updating the `dp` array based on the previous values. This involves adding the value at the current position to the positions one step to the left and right, effectively simulating the effect of adding a `1` or `-1` to the prefix sum array.
   - Finally, it calculates the `final_sum` based on the last element of `p` and returns the corresponding value in the `dp` array.

2. **Function `func_2`:**
   - This function reads input from standard input, processes it to extract the number of test cases and the data for each test case, and calls `func_1` for each test case.
   - It then prints the results for each test case.

### Verification:
- **Correctness of `func_1`:**
  - The logic of `func_1` is correct in terms of how it simulates the addition of `1` and `-1` to the prefix sums and updates the DP table accordingly.
  - However, there are a few potential issues to consider:
    - The modulo operation is correctly applied at each step to avoid overflow.
    - The offset calculation and the final sum calculation seem appropriate for the problem.
  - The function correctly handles the prefix sums and their sorting.

- **Correctness of `func_2`:**
  - The function reads input correctly and processes it to call `func_1` for each test case.
  - It then prints the results, which is expected behavior.

### Edge Cases and Constraints:
- The constraints are handled correctly, as the code reads up to `5000` elements per test case and the total number of elements across all test cases does not exceed `5000`.
- The modulo operation ensures that the result fits within the required limit.

### Conclusion:
After analyzing the code, it appears that the logic and handling of the problem are correct, and the implementation meets the requirements specified in the problem statement.

**Correctness: **True**

End of Original Assessment

Your Response:

Reasoning: [Your explanation]
Final: **True** or **False**

