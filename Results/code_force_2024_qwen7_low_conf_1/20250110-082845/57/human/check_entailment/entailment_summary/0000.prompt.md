
You are a program verifier. Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
In a well-known school, a physical education lesson took place. As usual,
everyone was lined up and asked to settle in "the first–k -th" position.

As is known, settling in "the first–k -th" position occurs as follows: the
first k people have numbers 1, 2, 3, \ldots, k , the next k - 2 people have
numbers k - 1, k - 2, \ldots, 2 , the next k people have numbers 1, 2, 3,
\ldots, k , and so on. Thus, the settling repeats every 2k - 2 positions.
Examples of settling are given in the "Note" section.

The boy Vasya constantly forgets everything. For example, he forgot the number
k described above. But he remembers the position he occupied in the line, as
well as the number he received during the settling. Help Vasya understand how
many natural numbers k fit under the given constraints.

Note that the settling exists if and only if k > 1 . In particular, this means
that the settling does not exist for k = 1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \leq t \leq 100 ) — the number of test cases. This is followed by
the description of the test cases.

The only line of each test case contains two integers n and x (1 \le x < n \le
10^9 ) — Vasya's position in the line and the number Vasya received during the
settling.

Output

For each test case, output a single integer — the number of different k that
fit under the given constraints.

It can be proven that under the given constraints, the answer is finite.

Example

Input

    5
    
    10 2
    
    3 1
    
    76 4
    
    100 99
    
    1000000000 500000000

Output

    4
    1
    9
    0
    1
    
Note

In the first test case, k equals 2, 3, 5, 6 are suitable.

An example of settling for these k :

k / №| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10   
---|---|---|---|---|---|---|---|---|---|---  
2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2   
3 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 | 2   
5 | 1 | 2 | 3 | 4 | 5 | 4 | 3 | 2 | 1 | 2   
6 | 1 | 2 | 3 | 4 | 5 | 6 | 5 | 4 | 3 | 2   
  
In the second test case, k = 2 is suitable.

# Functions with Execution Summary:
Function number 1 :
 Code:
 '''
def func_1(n, x):
    count = 0
    k = 2
    while 2 * k - 2 <= n:
        cycle_length = 2 * k - 2
        position_in_cycle = (n - 1) % cycle_length + 1
        if position_in_cycle <= k:
            expected_number = position_in_cycle
        else:
            expected_number = 2 * k - position_in_cycle
        if expected_number == x:
            count += 1
        k += 1
    return count
''' 

 Output hints for function1:  The function `func_1` accepts two parameters `n` and `x`, both of which are positive integers such that \(1 \leq x < n \leq 10^9\). It iterates through values of `k` starting from 2 until \(2k - 2 > n\). During each iteration, it calculates the `cycle_length` as \(2k - 2\) and determines the `position_in_cycle` using \((n - 1) \% (2k - 2) + 1\). Based on the value of `position_in_cycle`, it calculates the `expected_number` either as `position_in_cycle` if `position_in_cycle` is less than or equal to `k`, or as \(2k - \text{position_in_cycle}\) otherwise. If `expected_number` equals `x`, it increments the `count` variable. After the loop completes, the function returns the `count`, which represents the total number of times `expected_number` equals `x` during the loop iterations.
Function number 2 :
 Code:
 '''
def func_2():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n = int(data[index])
        x = int(data[index + 1])
        index += 2
        results.append(func_1(n, x))
    for result in results:
        print(result)
''' 

 Output hints for function2:  The function processes a series of test cases, where each test case consists of two integers `n` and `x`. For each test case, it calls the `func_1(n, x)` function and stores the result in a list `results`. After processing all test cases, it prints the results in order. The function reads the input from standard input, where the first line contains the number of test cases `t`, followed by `t` lines, each containing two space-separated integers `n` and `x`.

Potential edge cases and missing functionality:
1. The function assumes that the input format is correct and that there are enough elements in the `data` list to process all test cases. If there are fewer than `2 * t` elements in the `data` list, the function will raise an `IndexError`.
2. The function does not handle invalid input (e.g., non-integer values, negative integers, or `x` not being less than `n`). It relies on the caller to ensure that the input is valid.
3. The function does not perform any error checking on the results returned by `func_1(n, x)`. It simply appends the results to the `results` list and prints them.


# Your response:
Reasoning:  
Correctness: **True** or **False**

