
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Yarik's birthday is coming soon, and Mark decided to give him an array a of
length n .

Mark knows that Yarik loves bitwise operations very much, and he also has a
favorite number x , so Mark wants to find the maximum number k such that it is
possible to select pairs of numbers [l_1, r_1 ], [l_2, r_2 ], \ldots [l_k, r_k
], such that:

  * l_1 = 1 . 
  * r_k = n . 
  * l_i \le r_i for all i from 1 to k . 
  * r_i + 1 = l_{i + 1} for all i from 1 to k - 1 . 
  * (a_{l_1} \oplus a_{l_1 + 1} \oplus \ldots \oplus a_{r_1}) | (a_{l_2} \oplus a_{l_2 + 1} \oplus \ldots \oplus a_{r_2}) | \ldots | (a_{l_k} \oplus a_{l_k + 1} \oplus \ldots \oplus a_{r_k}) \le x , where \oplus denotes the operation of [bitwise XOR](https://en.wikipedia.org/wiki/Exclusive_or), and | denotes the operation of [bitwise OR](https://en.wikipedia.org/wiki/Logical_disjunction). 

If such k does not exist, then output -1 .

Input

Each test consists of multiple test cases. The first line contains a single
integer t (1 \le t \le 10^4 ) — the number of test cases. The following lines
contain the descriptions of the test cases.

The first line of each test case contains two integers n and x (1 \le n \le
10^5, 0 \le x < 2^{30} ) — the length of the array a and the number x
respectively.

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (0
\le a_i < 2^{30} ) — the array a itself.

It is guaranteed that the sum of the values of n across all test cases does
not exceed 10^5 .

Output

For each test case, output a single integer on a separate line — the maximum
suitable number k , and -1 if such k does not exist.

Example

Input

    8
    
    3 1
    
    1 2 3
    
    2 2
    
    1 1
    
    2 2
    
    1 3
    
    2 3
    
    0 0
    
    3 2
    
    0 0 1
    
    4 2
    
    1 3 3 7
    
    2 2
    
    2 3
    
    5 0
    
    0 1 2 2 1

Output

    2
    2
    1
    2
    3
    -1
    1
    2
    
Note

In the first test case, you can take k equal to 2 and choose two segments [1, 1 ] and [2, 3 ], (1) | (2 \oplus 3) = 1 . It can be shown that 2 is the maximum possible answer.

In the second test case, the segments [1, 1 ] and [2, 2 ] are suitable, (1) | (1) = 1 . It is not possible to make more segments.

In the third test case, it is not possible to choose 2 segments, as (1) | (3) = 3 > 2 , so the optimal answer is 1 .
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
import sys

input = sys.stdin.read
data = input().split()
t = int(data[0])
index = 1
test_cases = []
for _ in range(t):
    n = int(data[index])
    x = int(data[index + 1])
    a = list(map(int, data[index + 2:index + 2 + n]))
    test_cases.append((n, x, a))
    index += 2 + n
results = func_1(t, test_cases)
for result in results:
    print(result)

#State of the program right berfore the function call: t is a positive integer representing the number of test cases, and test_cases is a list of tuples. Each tuple contains two integers n and x, followed by a list of n integers representing the array a. The length of each array a is n, and 0 ≤ n ≤ 10^5, 0 ≤ x < 2^30, and 0 ≤ a_i < 2^30 for all i. Additionally, the sum of the values of n across all test cases does not exceed 10^5.
def func_1(t, test_cases):
    results = []
    for case in test_cases:
        n, x, a = case
        
        prefix_xor = [0] * (n + 1)
        
        for i in range(1, n + 1):
            prefix_xor[i] = prefix_xor[i - 1] ^ a[i - 1]
        
        current_xor = 0
        
        segment_count = 0
        
        valid = False
        
        for i in range(1, n + 1):
            current_xor ^= a[i - 1]
            if current_xor | prefix_xor[n] <= x:
                segment_count += 1
                current_xor = 0
                valid = True
        
        if valid:
            results.append(segment_count)
        else:
            results.append(-1)
        
    #State of the program after the  for loop has been executed: `current_xor` is 0 if the condition `current_xor | prefix_xor[n] <= x` is met for any segment, otherwise it is the result of XORing all elements from `a[0]` to `a[n-1]`. `valid` is `True` if the condition is met for at least one segment, otherwise it is `False`. `segment_count` is the number of segments where the condition `current_xor | prefix_xor[n] <= x` is true. `results` contains the `segment_count` for each valid segment found, otherwise it contains `-1`. `t`, `test_cases`, `n`, `x`, `a`, and `case` remain unchanged.
    return results
    #`results` which contains the `segment_count` for each valid segment found, otherwise it contains `-1`

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  
Also we assume that the input will be valid and will not cause any errors in the program. So for example if the program is supposed to accept a list but does not handle the case when the input is not a list or an empty list then the program isstill correct since we assume the user will always provide a valid input. The same if we expecta positive integer and the program does not handle the case when the input is negative or zero.
Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
