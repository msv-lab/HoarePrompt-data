
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Vladislav has a son who really wanted to go to MIT. The college dormitory at
MIT (Moldova Institute of Technology) can be represented as a tree with n
vertices, each vertex being a room with exactly one student. A tree is a
connected undirected graph with n vertices and n-1 edges.

Tonight, there are three types of students:

  * students who want to party and play music (marked with \texttt{P} ), 
  * students who wish to sleep and enjoy silence (marked with \texttt{S} ), and 
  * students who don't care (marked with \texttt{C} ). 

Initially, all the edges are thin walls which allow music to pass through, so
when a partying student puts music on, it will be heard in every room.
However, we can place some thick walls on any edges — thick walls don't allow
music to pass through them.

The university wants to install some thick walls so that every partying
student can play music, and no sleepy student can hear it.

Because the university lost a lot of money in a naming rights lawsuit, they
ask you to find the minimum number of thick walls they will need to use.

Input

The first line contains a single integer t (1 \leq t \leq 1000 ) — the number
of test cases.

The first line of each test case contains an integer n (2 \leq n \leq 10^5 ) —
the number of vertices in the tree.

The second line of each test case contains n-1 integers a_2, \dots , a_n (1
\leq a_i < i ) — it means there is an edge between i and a_i in the tree.

The third line of each test case contains a string s of length n consisting of
characters \texttt{P} , \texttt{S} , and \texttt{C} , denoting that student i
is of type s_i .

The sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer — the minimum number of thick
walls needed.

Example

Input

    3
    
    3
    
    1 1
    
    CSP
    
    4
    
    1 2 2
    
    PCSS
    
    4
    
    1 2 2
    
    PPSS

Output

    1
    1
    2
    
Note

In the first case, we can install one thick wall between rooms 1 and 2 , as
shown below. We cannot install 0 walls, since then the music from room 3 will
reach room 2 where a student wants to sleep, so the answer is 1 . There are
other valid solutions.

![](https://espresso.codeforces.com/7829c4a96192afbd162c82af7a2c95ff80e8daa1.png)

- Program: 
def func():
    for _ in range(int(input())):
        n = int(input())
        fa = [-1] + list(map(int, input().split()))
        S = input()
        (dp1, dp2) = ([0] * (n + 1), [0] * (n + 1))
        for i in range(n - 1, -1, -1):
            if S[i] == 'S':
                dp1[i] = float('inf')
            elif S[i] == 'P':
                dp2[i] = float('inf')
            p = fa[i] - 1
            if p != -1:
                dp1[p] += min(dp1[i], dp2[i] + 1)
                dp2[p] += min(dp1[i] + 1, dp2[i])
        print(min(dp1[0], dp2[0]))



- Annotated Code: 
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 1000. For each test case, n is an integer such that 2 ≤ n ≤ 10^5, a list of integers a_2, ..., a_n is provided such that 1 ≤ a_i < i, indicating the edges in the tree, and a string s of length n consisting of characters 'P', 'S', and 'C' indicating the type of each student. The sum of n over all test cases does not exceed 10^5.
def func():
    for _ in range(int(input())):
        n = int(input())
        
        fa = [-1] + list(map(int, input().split()))
        
        S = input()
        
        dp1, dp2 = [0] * (n + 1), [0] * (n + 1)
        
        for i in range(n - 1, -1, -1):
            if S[i] == 'S':
                dp1[i] = float('inf')
            elif S[i] == 'P':
                dp2[i] = float('inf')
            p = fa[i] - 1
            if p != -1:
                dp1[p] += min(dp1[i], dp2[i] + 1)
                dp2[p] += min(dp1[i] + 1, dp2[i])
        
        print(min(dp1[0], dp2[0]))
        
    #State of the program after the  for loop has been executed: t is an integer such that 1 ≤ t ≤ 1000, for each test case: n is an integer such that 2 ≤ n ≤ 10^5, fa is a list of integers where fa[i] (0-indexed) is the parent of node i+1 in the tree, S is a string of length n consisting of characters 'P', 'S', and 'C', dp1 and dp2 are lists of integers where dp1[i] represents the minimum cost to reach a leaf node starting from node i (considering only paths through nodes marked 'P' or 'S'), and dp2[i] represents the same but considering only paths through nodes marked 'S' or 'P'. After processing all test cases, the output of the print statement is the minimum of dp1[0] and dp2[0].



Beggining of Original Assessment: 
Reasoning:

To verify the correctness of the given Python program, let's analyze the problem step-by-step and compare it with the solution provided.

1. **Problem Understanding**: The goal is to determine the minimum number of thick walls needed to ensure that partying students can play music without sleepy students hearing it. The solution uses dynamic programming (DP) to achieve this.

2. **Dynamic Programming (DP) Array Initialization**: 
   - `dp1[i]` represents the minimum number of walls required if the music should reach the ith node but not block it.
   - `dp2[i]` represents the minimum number of walls required if the music should not reach the ith node.

3. **Base Case**: For the leaf nodes (nodes with only one child), the initial values of `dp1` and `dp2` are set based on whether the student is a partygoer (`P`) or a sleeper (`S`).

4. **DP Transition**: The program iterates backward from the last node to the root, updating `dp1` and `dp2` for each node based on its parent node. The transition logic ensures that the minimum number of walls is computed considering both scenarios: allowing or blocking music at the current node.

5. **Output**: The final result is the minimum value between `dp1[0]` and `dp2[0]`, representing the overall minimum number of walls needed to satisfy the conditions.

Let's check the example provided in the problem statement to validate the logic:

### Example Breakdown:
- **Test Case 1**:
  - Tree structure: \(3\) nodes, edges: \(1-2\), \(2-3\).
  - Students' types: `CSP` (node 1: C, node 2: S, node 3: P).
  - The optimal solution is to put a wall between nodes 1 and 2, making the output `1`.

- **Test Case 2**:
  - Tree structure: \(4\) nodes, edges: \(1-2\), \(2-3\), \(2-4\).
  - Students' types: `PCSS` (node 1: P, node 2: C, node 3: S, node 4: S).
  - The optimal solution is to put a wall between nodes 2 and 3, making the output `1`.

- **Test Case 3**:
  - Tree structure: \(4\) nodes, edges: \(1-2\), \(2-3\), \(2-4\).
  - Students' types: `PPSS` (node 1: P, node 2: P, node 3: S, node 4: S).
  - The optimal solution is to put walls between nodes 1 and 2, and nodes 2 and 3, making the output `2`.

Given these examples and the provided code, the logic correctly implements the dynamic programming approach to solve the problem as described. Therefore, the program appears to be correct.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

