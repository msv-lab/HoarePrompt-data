
You are given a programming problem description and a function that contributes to the solution of this problem. The total solution compromises of multiple functions and this is just one of them. 
From the problem description, and based on the variables used in the signature of this specific function, extract a description of the values of the variables in the function signature and the relationship between them. We refer to this description as precondition. Print the precondition following the word "Precondition", and surrounded with double asterisks (**). Follow these examples:
Remember the function given may not solve the problem directly but perform a side functionality that contributes to the total solution. Include information only about the variables in the function signature.
# Example 1

Problem description: write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].
Program:
```
def min_cost(cost, m, n):
	tc = [[0 for x in range(C)] for x in range(R)]
	tc[0][0] = cost[0][0]
	for i in range(1, m+1):
		tc[i][0] = tc[i-1][0] + cost[i][0]
	for j in range(1, n+1):
		tc[0][j] = tc[0][j-1] + cost[0][j]
	for i in range(1, m+1):
		for j in range(1, n+1):
			tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]
	return tc[m][n]
```

Precondition: **cost is a 2D list of non-negative integers, m and n are non-negative integers such that 0 <= m < len(cost) and 0 <= n < len(cost[0]).**

# Example 2

Problem description: Write a function to find the similar elements from the given two tuple lists.
Program:
```
def are_similar(elem, elem1):
  if elem == elem1:
    return True
  else:
    return False
```

Precondition: **elem1 and elem are values of any type and value**
# Example 3

Problem description: Write a python function to identify if 2 consecutive integers in a list are not prime".
Program:
```
import math
def is_not_prime(n):
    result = False
    for i in range(2,int(math.sqrt(n)) + 1):
        if n % i == 0:
            result = True
    return result
```

Precondition: **n is an integer greater than 1.**

# Example 4

Problem description: Write a function to find the largest integers from a given list of numbers using heap queue algorithm.
Program:
```
import heapq as hq
def heap_queue_largest(nums,n):
  largest_nums = hq.nlargest(n, nums)
  return largest_nums
```

Precondition: **nums is a list of integers, and n is a non-negative integer such that 0 <= n <= len(nums).**


# Your task

Problem description: The only difference between the versions of this problem is the maximum value
of n .

Professor Vector is preparing to teach her Arithmancy class. She needs to
prepare n distinct magic words for the class. Each magic word is a string
consisting of characters X and O. A spell is a string created by concatenating
two magic words together. The power of a spell is equal to the number of its
different non-empty substrings. For example, the power of the spell XOXO is
equal to 7, because it has 7 different substrings: X, O, XO, OX, XOX, OXO and
XOXO.

Each student will create their own spell by concatenating two magic words.
Since the students are not very good at magic yet, they will choose each of
the two words independently and uniformly at random from the n words provided
by Professor Vector. It is therefore also possible that the two words a
student chooses are the same. Each student will then compute the power of
their spell, and tell it to Professor Vector. In order to check their work,
and of course to impress the students, Professor Vector needs to find out
which two magic words and in which order were concatenated by each student.

Your program needs to perform the role of Professor Vector: first, create n
distinct magic words, and then handle multiple requests where it is given the
spell power and needs to determine the indices of the two magic words, in the
correct order, that were used to create the corresponding spell.

Interaction

This is an interactive problem.

First, your program should read a single integer n (1 \le n \le 30 ), the
number of magic words to prepare. Then, it should print n magic words it has
created, one per line. The magic words must be distinct, each magic word must
have at least 1 and at most 30\cdot n characters, and each character must be
either X or O. We will denote the i -th magic word you printed as w_i (1 \le i
\le n ).

Then, your program should read a single integer q (1 \le q \le 1000 ), the
number of students in the class. Then, it should repeat the following process
q times, one per student.

For the j -th student, it should first read a single integer p_j , the power
of their spell. It is guaranteed that this number is computed by choosing two
indices u_j and v_j independently and uniformly at random between 1 and n
inclusive, concatenating w_{u_j} and w_{v_j} , and finding the number of
different non-empty substrings of the resulting string. Then, your program
must print the numbers u_j and v_j , in this order (1 \le u_j, v_j \le n ).

Note that it is not enough to find any two magic words that concatenate into a
spell with the given power. You must find the exact words used by the student
in the exact order.

Remember to flush the output stream after printing all magic words and after
printing u_j and v_j for each student.

Example

Input

Copy

    2
    
    2
    15
    
    11

Output

Copy

    XOXO
    X
    
    1 1
    
    2 1
Program:
```
def func_3(magic_words, power):
    for i in range(len(magic_words)):
        for j in range(len(magic_words)):
            spell = magic_words[i] + magic_words[j]
            if func_2(spell) == power:
                return (i + 1, j + 1)
    return (-1, -1)
```

