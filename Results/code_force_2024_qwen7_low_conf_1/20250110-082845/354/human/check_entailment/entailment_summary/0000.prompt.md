
You are a program verifier. Your task is to determine if a given Python program is correct the based on the provided problem description and the execution summaries of its functions. You can use the execution summaries as a guides to understand the program’s behavior. Assume valid inputs as described in the problem.
The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.
First explain your reasoning then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
You have a one-dimensional puzzle, all the elements of which need to be put in
one row, connecting with each other. All the puzzle elements are completely
white and distinguishable from each other only if they have different shapes.

Each element has straight borders at the top and bottom, and on the left and
right it has connections, each of which can be a protrusion or a recess. You
cannot rotate the elements.

You can see that there are exactly 4 types of elements. Two elements can be
connected if the right connection of the left element is opposite to the left
connection of the right element.

![](https://espresso.codeforces.com/3a4ca20f32b3885d01c9dc80911de1cfb06870fe.png)
All possible types of elements.

The puzzle contains c_1, c_2, c_3, c_4 elements of each type. The puzzle is
considered complete if you have managed to combine all elements into one long
chain. You want to know how many ways this can be done.

Input

The first line contains a single integer t (1 \le t \le 2 \cdot 10^5 ) — the
number of input test cases. The descriptions of the test cases follow.

The description of each test case contains 4 integers c_i (0 \le c_i \le 10^6
) — the number of elements of each type, respectively.

It is guaranteed that the sum of c_i for all test cases does not exceed 4
\cdot 10^6 .

Output

For each test case, print one integer — the number of possible ways to solve
the puzzle.

Two methods are considered different if there is i , such that the types of
elements at the i position in these methods differ.

Since the answer can be very large, output it modulo 998244353 .

If it is impossible to solve the puzzle, print 0 .

Example

Input

    11
    
    1 1 1 1
    
    1 2 5 10
    
    4 6 100 200
    
    900000 900000 900000 900000
    
    0 0 0 0
    
    0 0 566 239
    
    1 0 0 0
    
    100 0 100 0
    
    0 0 0 4
    
    5 5 0 2
    
    5 4 0 5

Output

    4
    66
    0
    794100779
    1
    0
    1
    0
    1
    36
    126

# Functions with Execution Summary:
if __name__ == '__main__':
    func_2()

Function number 1 :
 Code:
 '''
def func_1(c1, c2, c3, c4):
    MOD = 998244353
    dp = [[0 for _ in range(4)] for _ in range(max(c1, c2, c3, c4) + 1)]
    dp[0][0] = 1
    for i in range(1, max(c1, c2, c3, c4) + 1):
        if i <= c1:
            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]) % MOD
        if i <= c2:
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2] + dp[i - 1][3]) % MOD
        if i <= c3:
            dp[i][2] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][3]) % MOD
        if i <= c4:
            dp[i][3] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD
    total_ways = sum(dp[max(c1, c2, c3, c4)]) % MOD
    return total_ways
''' 

 Output hints for function1:  - If any of `c1`, `c2`, `c3`, or `c4` is zero, the corresponding entries in the `dp` table will not be updated because the conditions `if i <= c1`, etc., will not be met. However, since the initial value `dp[0][0]` is set to 1, the sum of the last row will still correctly represent the total number of ways, as long as at least one of `c1`, `c2`, `c3`, or `c4` is non-zero.
Function number 2 :
 Code:
 '''
def func_2():
    MOD = 998244353
    t = int(input())
    results = []
    for _ in range(t):
        (c1, c2, c3, c4) = map(int, input().split())
        result = func_1(c1, c2, c3, c4)
        results.append(result)
    for result in results:
        print(result)
''' 

 Output hints for function2:  The function `func_2` processes multiple test cases, where each test case consists of four non-negative integers `c1`, `c2`, `c3`, and `c4`. For each test case, it calls the function `func_1(c1, c2, c3, c4)` to compute a result, which is then stored in a list `results`. After processing all test cases, it prints each result from the `results` list. The function accepts a single positive integer `t` representing the number of test cases and returns no explicit value (though it modifies the `results` list internally). The state of the program after the function concludes includes the `results` list containing the computed results for each test case.


# Your response:
Reasoning:  
Correctness: **True** or **False**

