
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
Let's imagine the surface of Mars as an infinite coordinate plane. Initially,
the rover Perseverance-2 and the helicopter Ingenuity-2 are located at the
point with coordinates (0, 0) . A set of instructions s consisting of n
instructions of the following types was specially developed for them:

  * N: move one meter north (from point (x, y) to (x, y + 1) ); 
  * S: move one meter south (from point (x, y) to (x, y - 1) ); 
  * E: move one meter east (from point (x, y) to (x + 1, y) ); 
  * W: move one meter west (from point (x, y) to (x - 1, y) ). 

Each instruction must be executed either by the rover or by the helicopter.
Moreover, each device must execute at least one instruction. Your task is to
distribute the instructions in such a way that after executing all n
instructions, the helicopter and the rover end up at the same point, or
determine that this is impossible.

Input

The first line of input contains t (1 \leq t \leq 10^4 ) — the number of test
cases.

The first line of each test case contains a single integer n (1 \le n \le 2
\cdot 10^5 ) — the number of instructions.

The second line of each test case contains a string s of length n consisting
of the characters 'N', 'S', 'E', 'W' — the sequence of instructions.

It is guaranteed that the sum of n over all test cases does not exceed 2 \cdot
10 ^ 5 .

Output

For each test case, if the required distribution of instructions exists,
output a string p of length n consisting of the characters 'R', 'H'. If the i
-th operation should be executed by the rover, then p_i=\text{R} , if the i
-th operation should be executed by the helicopter, then p_i=\text{H} . If
there are multiple solutions, output any of them.

Otherwise, output NO.

Example

Input

    10
    
    6
    
    NENSNE
    
    3
    
    WWW
    
    6
    
    NESSWS
    
    2
    
    SN
    
    2
    
    WE
    
    4
    
    SSNN
    
    4
    
    WESN
    
    2
    
    SS
    
    4
    
    EWNN
    
    4
    
    WEWE

Output

    RRHRRH
    NO
    HRRHRH
    NO
    NO
    RHRH
    RRHH
    RH
    RRRH
    RRHH

Note

Let's consider the first example: the string S = \texttt{NENSNE} . One of the
possible solutions, shown in the figure below, is p = \texttt{RRHRRH} , using
which both the rover and the helicopter will end up one meter north and one
meter east.

![](https://espresso.codeforces.com/bb4cbb5897ef7ab4afcc336d45457d0bb9d07c2c.png)

For WWW, the solution is impossible.

- Program: 
import sys

input = sys.stdin.read
data = input().split()
t = int(data[0])
index = 1
results = []
for _ in range(t):
    n = int(data[index])
    index += 1
    s = data[index]
    index += 1
    results.append(func_1(n, s))
print('\n'.join(results))

def func_1(n, s):
    count_north = 0
    count_south = 0
    count_east = 0
    count_west = 0
    for char in s:
        if char == 'N':
            count_north += 1
        elif char == 'S':
            count_south += 1
        elif char == 'E':
            count_east += 1
        else:
            count_west += 1
    if count_north != count_south or count_east != count_west:
        return 'NO'
    result = []
    i = 0
    while i < len(s):
        if s[i] == 'N' or s[i] == 'S':
            if s[i] == 'N':
                result.append('R')
                count_north -= 1
            else:
                result.append('H')
                count_south -= 1
            i += 1
        elif s[i] == 'E' or s[i] == 'W':
            if s[i] == 'E':
                result.append('R')
                count_east -= 1
            else:
                result.append('H')
                count_west -= 1
            i += 1
    return ''.join(result)



- Annotated Code: 
import sys

input = sys.stdin.read
data = input().split()
t = int(data[0])
index = 1
results = []
for _ in range(t):
    n = int(data[index])
    index += 1
    s = data[index]
    index += 1
    results.append(func_1(n, s))
print('\n'.join(results))

#State of the program right berfore the function call: n is a positive integer representing the number of instructions, and s is a string of length n consisting of the characters 'N', 'S', 'E', 'W' representing the sequence of instructions.
def func_1(n, s):
    count_north = 0
    count_south = 0
    count_east = 0
    count_west = 0
    for char in s:
        if char == 'N':
            count_north += 1
        elif char == 'S':
            count_south += 1
        elif char == 'E':
            count_east += 1
        else:
            count_west += 1
        
    #State of the program after the  for loop has been executed: `n` is a positive integer representing the number of instructions, `s` is a string of length `n` consisting of the characters 'N', 'S', 'E', 'W', `count_north` is the number of 'N' in the string `s`, `count_south` is the number of 'S' in the string `s`, `count_east` is the number of 'E' in the string `s`, `count_west` is the number of 'W' in the string `s`.
    if (count_north != count_south or count_east != count_west) :
        return 'NO'
        #The program returns 'NO'
    #State of the program after the if block has been executed: `n` is a positive integer representing the number of instructions, `s` is a string of length `n` consisting of the characters 'N', 'S', 'E', 'W', `count_north` is the number of 'N' in the string `s`, `count_south` is the number of 'S' in the string `s`, `count_east` is the number of 'E' in the string `s`, `count_west` is the number of 'W' in the string `s`. `count_north` equals `count_south` and `count_east` equals `count_west`
    result = []
    i = 0
    while i < len(s):
        if s[i] == 'N' or s[i] == 'S':
            if s[i] == 'N':
                result.append('R')
                count_north -= 1
            else:
                result.append('H')
                count_south -= 1
            i += 1
        elif s[i] == 'E' or s[i] == 'W':
            if s[i] == 'E':
                result.append('R')
                count_east -= 1
            else:
                result.append('H')
                count_west -= 1
            i += 1
        
    #State of the program after the loop has been executed: `n` is a positive integer, `s` is a string of length `n` consisting of the characters 'N', 'S', 'E', 'W', `result` is a list containing only 'R' or 'H' based on the final character processed in the string, `i` is `len(s)`, `count_north` equals `count_south` and is non-negative, `count_east` equals `count_west` or `count_west - 1` and is non-negative, `count_north` and `count_south` represent the number of remaining 'N' and 'S' respectively, `count_east` and `count_west` represent the number of remaining 'E' and 'W' respectively, and the loop executes exactly `n` times.
    return ''.join(result)
    #The program returns a string consisting of 'R' or 'H' based on the final character processed in the string 's'



Beggining of Original Assessment: 
Reasoning:
1. The program reads the input correctly, splitting it into lines and extracting the necessary information.
2. The `func_1` function checks if the number of north ('N') and south ('S') movements are equal and if the number of east ('E') and west ('W') movements are equal. This is a crucial step because for the rover and helicopter to meet at the same point, they must collectively perform the same number of north-south and east-west moves.
3. If these counts are not equal, the function returns 'NO', indicating that the instructions cannot be distributed to make the rover and helicopter end up at the same point.
4. If the counts are equal, the function proceeds to distribute the instructions. It tries to assign 'N' and 'S' moves to the rover first, followed by 'E' and 'W' moves to the rover. If there are remaining 'N' or 'S' moves after assigning some to the rover, those are assigned to the helicopter. Similarly, for 'E' and 'W' moves.
5. The program constructs the result string and returns it, which is correct based on the logic applied.

Given the above points, the program logic seems to handle all the cases appropriately as per the problem statement.

Correctness: **True**

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

