
You are a program verifier. Your task is to evaluate the correctness of a Python program based on a given problem description, the program code, an initial assessment, and an annotated version of the code. The annotations describe the program's state at key points.

Task:
1. Analyze the problem description, the program code, and the original assessment. Assume valid inputs.
2. Use the annotated version to systematically evaluate the program’s behavior and reasoning. Use the annotations to validate or challenge the original assessment.
3. Decide whether to maintain or overturn the original assessment based on the evidence.

Reason about the code and explain if the  original assessment was accurate or inaccurate.
Then provide the final evaluation Final: **True** if the given program is correct  or Final: **False** if the given program is incorrect.

- Problem description: 
This is a hard version of the problem; it differs from the easy version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ); the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot).

Then output k non-negative integers a_1, a_2, \dots, a_k , where a_i is a
value such that after Bob gives Alice the i -th fountain, the maximum size of
her plot will be \alpha + a_i .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where a_i is a value such that
after Bob gives Alice the i -th fountain, the maximum size of her plot will be
\alpha + a_i .

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 4 
    1
    0 0 1 1 0 0 0 0 0 
    6
    15 0 0 0 
    1
    2 3 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.

- Program: 
import math
#Function 1:
def func_1(fountain, n, m):
    (r, c) = fountain
    diagonal_distance = abs(r + c - (n + 1))
    return max(diagonal_distance // 2, 0)

#Function 2:
def func_2():
    import sys
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        m = int(data[index + 1])
        k = int(data[index + 2])
        index += 3
        alpha = (n * m + 1) // 2
        additional_areas = []
        for __ in range(k):
            r = int(data[index])
            c = int(data[index + 1])
            index += 2
            additional_areas.append(func_1((r, c), n, m))
        results.append((alpha, additional_areas))
    for result in results:
        (alpha, additional_areas) = result
        print(alpha)
        print(' '.join(map(str, additional_areas)))



- Annotated Code: 
import math

if __name__ == '__main__':
    func_2()

#Function 1:
#State of the program right berfore the function call: fountain is a tuple of two integers (r, c) representing the coordinates of a fountain on the field, n and m are integers representing the dimensions of the field such that 2 <= n, m <= 10^9.
def func_1(fountain, n, m):
    r, c = fountain
    diagonal_distance = abs(r + c - (n + 1))
    return max(diagonal_distance // 2, 0)
    #`The program returns max(abs(r + c - (n + 1)) // 2, 0)`

#Function 2:
#State of the program right berfore the function call: t is a positive integer indicating the number of test cases; n, m, and k are positive integers such that 2 ≤ n, m ≤ 10^9 and 2 ≤ k ≤ 2 * 10^5; for each test case, r and c are positive integers representing the row and column of a fountain, with 1 ≤ r ≤ n and 1 ≤ c ≤ m, and all fountain positions are unique and none of them is (n, 1).
def func_2():
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        
        m = int(data[index + 1])
        
        k = int(data[index + 2])
        
        index += 3
        
        alpha = (n * m + 1) // 2
        
        additional_areas = []
        
        for __ in range(k):
            r = int(data[index])
            c = int(data[index + 1])
            index += 2
            additional_areas.append(func_1((r, c), n, m))
        
        results.append((alpha, additional_areas))
        
    #State of the program after the  for loop has been executed: `t` is a positive integer, `index` is `2 + t * 2 + 3`, `results` is a list of tuples, each tuple contains `alpha` and `additional_areas`; `alpha` is \((n * m + 1) // 2\) for each tuple, where `n` and `m` are the integers corresponding to the first two elements of the `data` list for each tuple; `additional_areas` is a list containing the results of `func_1((r, c), n, m)` for each fountain position \((r, c)\) provided in the `data` list for each tuple; `r` and `c` are the integers corresponding to the fountain positions in the `data` list for each tuple.
    for result in results:
        alpha, additional_areas = result
        
        print(alpha)
        
        print(' '.join(map(str, additional_areas)))
        
    #State of the program after the  for loop has been executed: `t` is a positive integer, `index` is \(2 + (t + |results| - 1) \times 2 + 3\), `results` is a list of tuples, `alpha` is the first element of the last tuple in `results`, `additional_areas` is the second element of the last tuple in `results`, and `alpha` is printed for each tuple in `results`.




Beggining of Original Assessment: 
Correctness: **False**

Explanation: The program does not correctly calculate the maximum size of Alice's plot when Bob gives her a fountain. Specifically, the function `func_1` used to calculate the additional area Alice gains when given a fountain does not account for the actual constraints and possible configurations of the fountains and the field boundaries.

For instance, consider a simple case where the field is 2x2, and there are 3 fountains at positions (1,1), (1,2), and (2,2). According to the problem statement, the maximum size of Alice's plot without any fountains is 1. When Bob gives Alice the fountain at (1,1), the correct additional area Alice can gain would be 1 (since she can now include this fountain in her path). However, the program incorrectly calculates the additional area using a diagonal distance approach which does not accurately reflect the possible configurations and movements within the grid.

This discrepancy indicates that the program does not fully meet the requirements of the problem description for every potential case. Therefore, the program is considered incorrect.

End of Original Assessment

Your Response: 
Reasoning: [Your explanation] 
Final: **True** or **False**

