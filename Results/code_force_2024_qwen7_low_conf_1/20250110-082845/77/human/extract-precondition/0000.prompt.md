
You are given a programming problem description and a function that contributes to the solution of this problem. The total solution compromises of multiple functions and this is just one of them. 
From the problem description, and based on the variables used in the signature of this specific function, extract a description of the values of the variables in the function signature and the relationship between them. We refer to this description as precondition. Print the precondition following the word "Precondition", and surrounded with double asterisks (**). Follow these examples:
Remember the function given may not solve the problem directly but perform a side functionality that contributes to the total solution. Include information only about the variables in the function signature.
# Example 1

Problem description: write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].
Program:
```
def min_cost(cost, m, n):
	tc = [[0 for x in range(C)] for x in range(R)]
	tc[0][0] = cost[0][0]
	for i in range(1, m+1):
		tc[i][0] = tc[i-1][0] + cost[i][0]
	for j in range(1, n+1):
		tc[0][j] = tc[0][j-1] + cost[0][j]
	for i in range(1, m+1):
		for j in range(1, n+1):
			tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]
	return tc[m][n]
```

Precondition: **cost is a 2D list of non-negative integers, m and n are non-negative integers such that 0 <= m < len(cost) and 0 <= n < len(cost[0]).**

# Example 2

Problem description: Write a function to find the similar elements from the given two tuple lists.
Program:
```
def are_similar(elem, elem1):
  if elem == elem1:
    return True
  else:
    return False
```

Precondition: **elem1 and elem are values of any type and value**
# Example 3

Problem description: Write a python function to identify if 2 consecutive integers in a list are not prime".
Program:
```
import math
def is_not_prime(n):
    result = False
    for i in range(2,int(math.sqrt(n)) + 1):
        if n % i == 0:
            result = True
    return result
```

Precondition: **n is an integer greater than 1.**

# Example 4

Problem description: Write a function to find the largest integers from a given list of numbers using heap queue algorithm.
Program:
```
import heapq as hq
def heap_queue_largest(nums,n):
  largest_nums = hq.nlargest(n, nums)
  return largest_nums
```

Precondition: **nums is a list of integers, and n is a non-negative integer such that 0 <= n <= len(nums).**


# Your task

Problem description: This is a hard version of the problem; it differs from the easy version only
by the question. The easy version only needs you to print whether some values
are non-zero or not. The hard version needs you to print the exact values.

Alice and Bob are dividing the field. The field is a rectangle of size n
\times m (2 \le n, m \le 10^9 ); the rows are numbered from 1 to n from top to
bottom, and the columns are numbered from 1 to m from left to right. The cell
at the intersection of row r and column c is denoted as (r, c ).

Bob has k (2 \le k \le 2 \cdot 10^5 ) fountains, all of them are located in
different cells of the field. Alice is responsible for dividing the field, but
she must meet several conditions:

  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field. 
  * Alice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob. 
  * Alice will own the part that includes the cell (n, 1 ). 
  * Bob will own the part that includes the cell (1, m ). 

Alice wants to divide the field in such a way as to get as many cells as
possible.

Bob wants to keep ownership of all the fountains, but he can give one of them
to Alice. First, output the integer \alpha — the maximum possible size of
Alice's plot, if Bob does not give her any fountain (i.e., all fountains will
remain on Bob's plot).

Then output k non-negative integers a_1, a_2, \dots, a_k , where a_i is a
value such that after Bob gives Alice the i -th fountain, the maximum size of
her plot will be \alpha + a_i .

Input

The first line contains a single integer t (1 \le t \le 10^4 ) — the number of
test cases.

The first line of each test case contains three integers n , m , and k (2 \le
n, m \le 10^9 , 2 \le k \le 2 \cdot 10^5 ) — the field sizes and the number of
fountains, respectively.

Then follow k lines, each containing two numbers r_i and c_i (1 \le r_i \le n
, 1 \le c_i \le m ) — the coordinates of the cell with the i -th fountain. It
is guaranteed that all cells are distinct and none of them is (n, 1 ).

It is guaranteed that the sum of k over all test cases does not exceed 2 \cdot
10^5 .

Output

For each test case, first output \alpha — the maximum size of the plot that
can belong to Alice if Bob does not give her any of the fountains. Then output
k non-negative integers a_1, a_2, \dots, a_k , where a_i is a value such that
after Bob gives Alice the i -th fountain, the maximum size of her plot will be
\alpha + a_i .

Example

Input

    5
    
    2 2 3
    
    1 1
    
    1 2
    
    2 2
    
    5 5 4
    
    1 2
    
    2 2
    
    3 4
    
    4 3
    
    2 5 9
    
    1 2
    
    1 5
    
    1 1
    
    2 2
    
    2 4
    
    2 5
    
    1 4
    
    2 3
    
    1 3
    
    6 4 4
    
    6 2
    
    1 3
    
    1 4
    
    1 2
    
    3 4 5
    
    2 1
    
    3 2
    
    1 4
    
    1 3
    
    2 4

Output

    1
    1 0 1 
    11
    0 1 0 4 
    1
    0 0 1 1 0 0 0 0 0 
    6
    15 0 0 0 
    1
    2 3 0 0 0 
    
Note

Below are the images for the second example:

![](https://espresso.codeforces.com/1097a3c831bcbd4e6363a26497eb7991ad8ac903.png)
The indices of the fountains are labeled in green. The cells belonging to
Alice are marked in blue.

Note that if Bob gives Alice fountain 1 or fountain 3 , then that fountain
cannot be on Alice's plot.
Program:
```
def func_2():
    import sys
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        m = int(data[index + 1])
        k = int(data[index + 2])
        index += 3
        alpha = (n * m + 1) // 2
        additional_areas = []
        for __ in range(k):
            r = int(data[index])
            c = int(data[index + 1])
            index += 2
            additional_areas.append(func_1((r, c), n, m))
        results.append((alpha, additional_areas))
    for result in results:
        (alpha, additional_areas) = result
        print(alpha)
        print(' '.join(map(str, additional_areas)))
```

