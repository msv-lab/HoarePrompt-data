
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Rng is going to a festival.

The name of the festival is given to you as a string S, which ends with `FESTIVAL`, from input. Answer the question: "Rng is going to a festival of what?" Output the answer.

Here, assume that the name of "a festival of s" is a string obtained by appending `FESTIVAL` to the end of s. For example, `CODEFESTIVAL` is a festival of `CODE`.

Constraints

* 9 \leq |S| \leq 50
* S consists of uppercase English letters.
* S ends with `FESTIVAL`.

Input

Input is given from Standard Input in the following format:


S


Output

Print the answer to the question: "Rng is going to a festival of what?"

Examples

Input

CODEFESTIVAL


Output

CODE


Input

CODEFESTIVALFESTIVAL


Output

CODEFESTIVAL


Input

YAKINIKUFESTIVAL


Output

YAKINIKU
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: S is a string consisting of uppercase English letters, with a length between 9 and 50 characters, and it ends with the substring 'FESTIVAL'.
def func():
    n = int(input())
    s = input()
    res = []
    count = 0
    if (s[0] == '1') :
        one = 1
    else :
        one = 0
    #State of the program after the if-else block has been executed: *`S` is a string consisting of uppercase English letters, with a length between 9 and 50 characters, and it ends with the substring 'FESTIVAL'; `n` is an input integer; `s` is an input string; `res` is an empty list; `count` is 0. If the first character of `s` is '1', then `one` is set to 1. Otherwise, if the first character of `s` is not '1', then `one` is set to 0.
    temp = []
    tar = 0
    for i in range(1, n - 1):
        if s[i - 1:i + 2] == '101':
            tar = 1
            temp.append(one)
            one = 0
        else:
            if s[i] == '0' and tar == 1:
                temp.append(one)
                res.append(temp.copy())
                temp = []
                tar = 0
            if s[i] == '1':
                one += 1
            else:
                one = 0
        
    #State of the program after the  for loop has been executed: `S` is a string consisting of uppercase English letters, `n` is greater than 2, `s` is an input string, `res` is a list containing sub-lists of counts of '1's before '101' sequences, `temp` is an empty list, `count` remains 0, `one` is the count of consecutive '1's at the end of the string `s`, and `tar` is 0.
    if (s[-1] == '1') :
        one += 1
    #State of the program after the if block has been executed: *`S` is a string consisting of uppercase English letters, `n` is greater than 2, `s` is an input string, `res` is a list containing sub-lists of counts of '1's before '101' sequences, `temp` is an empty list, `count` remains 0, `one` is incremented by 1, `tar` is 0, and the last character of `s` is '1'.
    if (tar == 1) :
        temp.append(one)
        res.append(temp.copy())
    #State of the program after the if block has been executed: *`S` is a string consisting of uppercase English letters, `n` is greater than 2, `s` is an input string, `res` contains an additional sub-list copied from `temp` and remains unchanged, `temp` remains unchanged, `count` remains 0, `one` is incremented by 1, `tar` is set to 1, and the last character of `s` is '1' if `tar` was originally 1.
    for x in res:
        temp = 0
        
        m = len(x)
        
        f = []
        
        if m == 2:
            temp = max(x[0], x[1])
        
        if m == 3:
            temp = max(x[0], x[1], x[2])
        
        if m == 4:
            temp = max(x[0] + x[2], x[3] + max(x[0], x[1]))
        
        if m >= 5:
            f.append([x[0], x[1]])
            f.append([x[1], max(x[2], x[0])])
            f.append(x[0] + x[2], x[3] + f[0])
            for i in range(3, m - 1):
                f.append(x[i] + max(f[i - 2][0], f[i - 3][0]))
                f.append(x[i + 1] + max(f[i - 2][0], f[i - 2][1]))
            temp = max(f[-1][0], f[-1][1], f[-2][0])
        
        count += temp
        
    #State of the program after the  for loop has been executed: `count` is the sum of all calculated `temp` values for each element in `res`, `res` is a list that may contain strings of varying lengths, and `f` is a list that has been populated during iterations but does not affect the final state.
    print(count)
#Overall this is what the function does:The function reads an integer `n` and a string `s` consisting of uppercase English letters with a length between 9 and 50 characters, ending with 'FESTIVAL'. It counts the occurrences of '1's that appear before each occurrence of the substring '101' and sums certain calculated maximum values based on these occurrences. Finally, it prints the total sum of these calculated values. The function does not return any value but instead outputs the result directly.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
