
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: A direced graph is strongly connected if every two nodes are reachable from each other. In a strongly connected component of a directed graph, every two nodes of the component are mutually reachable.

Constraints

* 1 ≤ |V| ≤ 10,000
* 0 ≤ |E| ≤ 30,000
* 1 ≤ Q ≤ 100,000

Input

A directed graph G(V, E) and a sequence of queries where each query contains a pair of nodes u and v.


|V| |E|
s0 t0
s1 t1
:
s|E|-1 t|E|-1
Q
u0 v0
u1 v1
:
uQ-1 vQ-1


|V| is the number of nodes and |E| is the number of edges in the graph. The graph nodes are named with the numbers 0, 1,..., |V|-1 respectively.

si and ti represent source and target nodes of i-th edge (directed).

ui and vi represent a pair of nodes given as the i-th query.

Output

For each query, pinrt "1" if the given nodes belong to the same strongly connected component, "0" otherwise.

Example

Input

5 6
0 1
1 0
1 2
2 4
4 3
3 2
4
0 1
0 3
2 3
3 4


Output

1
0
1
1
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: frm is a list of tuples representing directed edges in a graph, where each tuple (s, t) contains non-negative integers s and t such that 0 <= s, t < |V|, and to is a list of tuples representing queries where each tuple (u, v) contains non-negative integers u and v such that 0 <= u, v < |V|. The number of vertices |V| is between 1 and 10,000, the number of edges |E| is between 0 and 30,000, and the number of queries Q is between 1 and 100,000.
def func_1(frm, to):
    g[frm].append(to)
    rg[to].append(frm)

#Function 2:
#State of the program right berfore the function call: now is an integer representing the current node in the graph, used is a set of integers representing the nodes already visited, and back_track is a boolean indicating whether to track the path back to the starting node.
def func_2(now, used, back_track):
    used[now] = True
    for nx in g[now]:
        if not used[nx]:
            func_2(nx, used, back_track)
        
    #State of the program after the  for loop has been executed: `now` is the current node, `used` includes all nodes that have been visited in the graph, `back_track` remains unchanged.
    back_track.append(now)

#Function 3:
#State of the program right berfore the function call: now is an integer representing the current node, num_cmp is an integer representing the number of strongly connected components, used is a list of boolean values indicating whether each node has been visited, and cmp is a list where each index corresponds to a node and holds the component number to which the node belongs.
def func_3(now, num_cmp, used, cmp):
    used[now] = True
    cmp[now] = num_cmp
    for nx in rg[now]:
        if not used[nx]:
            func_3(nx, num_cmp, used, cmp)
        
    #State of the program after the  for loop has been executed: `now` is an integer representing the current node, `num_cmp` is an integer representing the number of strongly connected components, `used[now]` is True, `used[nx]` is True for all neighbors `nx` of `now`, and `cmp[now]` is assigned the value of `num_cmp`.

#Function 4:
#State of the program right berfore the function call: n is a tuple containing a directed graph represented by a list of edges where each edge is a pair of integers (source, target), and a list of queries where each query is a pair of integers (u, v). The number of nodes |V| in the graph is inferred from the edges, and must satisfy 1 ≤ |V| ≤ 10,000; the number of edges |E| must satisfy 0 ≤ |E| ≤ 30,000; and the number of queries Q must satisfy 1 ≤ Q ≤ 100,000.
def func_4(n):
    used = [False] * n
    back_track = []
    cmp = [-1] * n
    for v in xrange(n):
        if not used[v]:
            func_2(v, used, back_track)
        
    #State of the program after the  for loop has been executed: `used` is a list where the values corresponding to the visited nodes are set to True, `back_track` may contain values based on the execution of `func_2`, `cmp` is a list of -1 values, `n` is the total number of nodes, and `v` is not relevant after the loop completes.
    used = [False] * n
    num_cmp = 0
    for v in back_track[::-1]:
        if not used[v]:
            func_3(v, num_cmp, used, cmp)
            num_cmp += 1
        
    #State of the program after the  for loop has been executed: `used` is a list of `n` elements indicating which elements have been processed (some may be set to True), `num_cmp` is the count of elements processed, `back_track` is a list with at least as many elements as `num_cmp`, and `v` is the last element processed from `back_track`.
    return num_cmp, cmp
    #The program returns the count of elements processed, num_cmp, along with the variable cmp, whose value is not specified in the initial state


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
