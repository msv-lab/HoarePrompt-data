
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Hanh lives in a shared apartment. There are n people (including Hanh) living there, each has a private fridge. 

n fridges are secured by several steel chains. Each steel chain connects two different fridges and is protected by a digital lock. The owner of a fridge knows passcodes of all chains connected to it. A fridge can be open only if all chains connected to it are unlocked. For example, if a fridge has no chains connected to it at all, then any of n people can open it.

<image> For exampe, in the picture there are n=4 people and 5 chains. The first person knows passcodes of two chains: 1-4 and 1-2. The fridge 1 can be open by its owner (the person 1), also two people 2 and 4 (acting together) can open it.

The weights of these fridges are a_1, a_2, …, a_n. To make a steel chain connecting fridges u and v, you have to pay a_u + a_v dollars. Note that the landlord allows you to create multiple chains connecting the same pair of fridges. 

Hanh's apartment landlord asks you to create exactly m steel chains so that all fridges are private. A fridge is private if and only if, among n people living in the apartment, only the owner can open it (i.e. no other person acting alone can do it). In other words, the fridge i is not private if there exists the person j (i ≠ j) that the person j can open the fridge i.

For example, in the picture all the fridges are private. On the other hand, if there are n=2 fridges and only one chain (which connects them) then both fridges are not private (both fridges can be open not only by its owner but also by another person).

Of course, the landlord wants to minimize the total cost of all steel chains to fulfill his request. Determine whether there exists any way to make exactly m chains, and if yes, output any solution that minimizes the total cost. 

Input

Each test contains multiple test cases. The first line contains the number of test cases T (1 ≤ T ≤ 10). Then the descriptions of the test cases follow.

The first line of each test case contains two integers n, m (2 ≤ n ≤ 1000, 1 ≤ m ≤ n) — the number of people living in Hanh's apartment and the number of steel chains that the landlord requires, respectively.

The second line of each test case contains n integers a_1, a_2, …, a_n (0 ≤ a_i ≤ 10^4) — weights of all fridges.

Output

For each test case:

  * If there is no solution, print a single integer -1. 
  * Otherwise, print a single integer c — the minimum total cost. The i-th of the next m lines contains two integers u_i and v_i (1 ≤ u_i, v_i ≤ n, u_i ≠ v_i), meaning that the i-th steel chain connects fridges u_i and v_i. An arbitrary number of chains can be between a pair of fridges. 



If there are multiple answers, print any.

Example

Input


3
4 4
1 1 1 1
3 1
1 2 3
3 3
1 2 3


Output


8
1 2
4 3
3 2
4 1
-1
12
3 2
1 2
3 1
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: The function processes multiple test cases where each test case consists of two integers n (2 ≤ n ≤ 1000) and m (1 ≤ m ≤ n), followed by a list of n integers representing the weights of the fridges (0 ≤ a_i ≤ 10^4).
def func_1():
    n, m = list(map(int, le.pop().split()))
    a = list(map(int, le.pop().split()))
    if (m < n or n == 2) :
        af.append(-1)
        return None
        #The program returns None, indicating no value is returned.
    #State of the program after the if block has been executed: *`n` is assigned an integer value from the input, `m` is assigned an integer value from the input, `a` is a list of integers derived from the last element of `le`. It is not the case that `m` is less than `n` and `n` is not equal to 2, which means `m` is greater than or equal to `n` and `n` is not equal to 2.
    af.append(2 * sum(a))
    for k in range(n):
        af.append(str(k + 1) + ' ' + str((k + 1) % n + 1))
        
    #State of the program after the  for loop has been executed: `n` is an integer, `k` is `n - 1` if `n` > 0, `af` contains `n` strings of the format 'i (i % n + 1)' for i from 1 to n, and `af` includes the initial element which is `2 * sum(a)`

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
