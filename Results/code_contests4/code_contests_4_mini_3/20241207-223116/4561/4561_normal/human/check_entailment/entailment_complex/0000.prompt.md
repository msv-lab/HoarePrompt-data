
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: By 2312 there were n Large Hadron Colliders in the inhabited part of the universe. Each of them corresponded to a single natural number from 1 to n. However, scientists did not know what activating several colliders simultaneously could cause, so the colliders were deactivated.

In 2312 there was a startling discovery: a collider's activity is safe if and only if all numbers of activated colliders are pairwise relatively prime to each other (two numbers are relatively prime if their greatest common divisor equals 1)! If two colliders with relatively nonprime numbers are activated, it will cause a global collapse.

Upon learning this, physicists rushed to turn the colliders on and off and carry out all sorts of experiments. To make sure than the scientists' quickness doesn't end with big trouble, the Large Hadron Colliders' Large Remote Control was created. You are commissioned to write the software for the remote (well, you do not expect anybody to operate it manually, do you?).

Initially, all colliders are deactivated. Your program receives multiple requests of the form "activate/deactivate the i-th collider". The program should handle requests in the order of receiving them. The program should print the processed results in the format described below.

To the request of "+ i" (that is, to activate the i-th collider), the program should print exactly one of the following responses: 

  * "Success" if the activation was successful. 
  * "Already on", if the i-th collider was already activated before the request. 
  * "Conflict with j", if there is a conflict with the j-th collider (that is, the j-th collider is on, and numbers i and j are not relatively prime). In this case, the i-th collider shouldn't be activated. If a conflict occurs with several colliders simultaneously, you should print the number of any of them. 



The request of "- i" (that is, to deactivate the i-th collider), should receive one of the following responses from the program: 

  * "Success", if the deactivation was successful. 
  * "Already off", if the i-th collider was already deactivated before the request. 



You don't need to print quotes in the output of the responses to the requests.

Input

The first line contains two space-separated integers n and m (1 ≤ n, m ≤ 105) — the number of colliders and the number of requests, correspondingly.

Next m lines contain numbers of requests, one per line, in the form of either "+ i" (without the quotes) — activate the i-th collider, or "- i" (without the quotes) — deactivate the i-th collider (1 ≤ i ≤ n).

Output

Print m lines — the results of executing requests in the above given format. The requests should be processed in the order, in which they are given in the input. Don't forget that the responses to the requests should be printed without quotes.

Examples

Input

10 10
+ 6
+ 10
+ 5
- 10
- 5
- 6
+ 10
+ 3
+ 6
+ 3


Output

Success
Conflict with 6
Success
Already off
Success
Success
Success
Success
Conflict with 10
Already on

Note

Note that in the sample the colliders don't turn on after the second and ninth requests. The ninth request could also receive response "Conflict with 3".
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: n is a positive integer representing the number of colliders, and m is a positive integer representing the number of requests, where each request is in the form of "+ i" or "- i" and 1 <= i <= n.
def func_1(n):
    prim[1] = 1
    for i in range(2, n):
        if not prim[i]:
            for j in range(i, n, i):
                prim[j] = i
        
    #State of the program after the  for loop has been executed: `n` is a positive integer greater than 2, `m` is a positive integer, `prim[i]` is the smallest prime number that divides `i` for all `i` from 2 to `n-1`, and `prim[1]` is 1.
#Overall this is what the function does:The function accepts a positive integer `n`, initializes a list of smallest prime factors for integers from 2 to `n-1`, but does not process any requests or update the state of colliders as described in the annotations.

#Function 2:
#State of the program right berfore the function call: x is a tuple where the first element is a positive integer n (the number of colliders) and the second element is a positive integer m (the number of requests), followed by m strings representing the requests in the form of either "+ i" or "- i" (1 ≤ i ≤ n).
def func_2(x):
    fac = []
    while x > 1:
        div = prim[x]
        
        fac.append(div)
        
        while x % div == 0:
            x //= div
        
    #State of the program after the loop has been executed: `x` is a tuple where the first element is reduced to a value that is not divisible by any remaining elements in `prim`, `fac` contains all the prime factors of the original first element of `x` in the order they were found, and `x` has been fully factored.
    return fac
    #The program returns the list of prime factors 'fac' of the original first element of the tuple 'x', in the order they were found.
#Overall this is what the function does:The function accepts a tuple `x` where the first element is a positive integer and returns a list of its prime factors in the order they were discovered. The function does not process the second part of the tuple which includes requests, hence it only focuses on factoring the first integer. If the input integer is 1 or less, it will return an empty list since there are no prime factors for such values.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.