
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You're given a tree with n vertices.

Your task is to determine the maximum possible number of edges that can be removed in such a way that all the remaining connected components will have even size.

Input

The first line contains an integer n (1 ≤ n ≤ 10^5) denoting the size of the tree. 

The next n - 1 lines contain two integers u, v (1 ≤ u, v ≤ n) each, describing the vertices connected by the i-th edge.

It's guaranteed that the given edges form a tree.

Output

Output a single integer k — the maximum number of edges that can be removed to leave all connected components with even size, or -1 if it is impossible to remove edges in order to satisfy this property.

Examples

Input

4
2 4
4 1
3 1


Output

1

Input

3
1 2
1 3


Output

-1

Input

10
7 1
8 4
8 10
4 7
6 5
9 3
3 5
2 10
2 5


Output

4

Input

2
1 2


Output

0

Note

In the first example you can remove the edge between vertices 1 and 4. The graph after that will have two connected components with two vertices in each.

In the second example you can't remove edges in such a way that all components have even number of vertices, so the answer is -1.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: a is an integer n (1 ≤ n ≤ 100000) representing the number of vertices in the tree, and b is a list of tuples where each tuple (u, v) contains two integers (1 ≤ u, v ≤ n) representing the edges connecting the vertices in the tree. The length of b is n - 1.
def func_1(a, b):
    Q = deque()
    Q.append(a)
    seen = {b}
    cnt = 0
    while Q:
        a = Q.popleft()
        
        if a in seen:
            continue
        
        cnt += 1
        
        seen.add(a)
        
        for b in E[a]:
            Q.append(b)
        
    #State of the program after the loop has been executed: `Q` is empty, `seen` contains all unique elements that were reachable from the initial elements in `Q`, `cnt` is equal to the number of unique elements processed from `Q`, and `a` is the last integer removed from `Q` before it became empty.
    return cnt
    #The program returns the number of unique elements processed from Q, which is equal to cnt

#Function 2:
#State of the program right berfore the function call: n is an integer representing the number of vertices in the tree, where 1 ≤ n ≤ 10^5; each of the next n - 1 lines contains two integers u and v (1 ≤ u, v ≤ n) representing the vertices connected by an edge, forming a valid tree structure.
def func_2(node):
    print(node)
    if (node in seen) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: *`n` is an integer representing the number of vertices in the tree, where 1 ≤ `n` ≤ 10^5; `node` is printed, and `node` is not in `seen`.
    seen.add(node)
    sz[node] = 1
    for neigh in E[node]:
        print(neigh)
        
        sz[node] += func_2(neigh)
        
    #State of the program after the  for loop has been executed: `n` is an integer representing the number of vertices in the tree; `node` is printed and added to `seen`; `sz[node]` is equal to 1 plus the sum of the return values of `func_2` for all neighbors in `E[node]`; `neigh` is the last neighbor in `E[node]` printed during the loop execution.
    return sz[node]
    #The program returns the size of the subtree rooted at 'node', which is equal to 1 plus the sum of the sizes of all its neighbors in 'E[node]'


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
