
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Lord Omkar has permitted you to enter the Holy Church of Omkar! To test your worthiness, Omkar gives you a password which you must interpret!

A password is an array a of n positive integers. You apply the following operation to the array: pick any two adjacent numbers that are not equal to each other and replace them with their sum. Formally, choose an index i such that 1 ≤ i < n and a_{i} ≠ a_{i+1}, delete both a_i and a_{i+1} from the array and put a_{i}+a_{i+1} in their place. 

For example, for array [7, 4, 3, 7] you can choose i = 2 and the array will become [7, 4+3, 7] = [7, 7, 7]. Note that in this array you can't apply this operation anymore.

Notice that one operation will decrease the size of the password by 1. What is the shortest possible length of the password after some number (possibly 0) of operations?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the password.

The second line of each test case contains n integers a_{1},a_{2},...,a_{n} (1 ≤ a_{i} ≤ 10^9) — the initial contents of your password.

The sum of n over all test cases will not exceed 2 ⋅ 10^5.

Output

For each password, print one integer: the shortest possible length of the password after some number of operations.

Example

Input


2
4
2 1 3 1
2
420 420


Output


1
2

Note

In the first test case, you can do the following to achieve a length of 1:

Pick i=2 to get [2, 4, 1]

Pick i=1 to get [6, 1]

Pick i=1 to get [7]

In the second test case, you can't perform any operations because there is no valid i that satisfies the requirements mentioned above.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: t is an integer representing the number of test cases (1 ≤ t ≤ 100). Each test case consists of an integer n (1 ≤ n ≤ 2 ⋅ 10^5) followed by a list of n positive integers a where each integer (1 ≤ a[i] ≤ 10^9). The sum of n over all test cases does not exceed 2 ⋅ 10^5.
def func_1():
    fact = [1]
    for i in range(1, 100005):
        fact.append(fact[-1] * i % mod)
        
    #State of the program after the  for loop has been executed: `t` is an integer representing the number of test cases, `fact` is a list containing the factorials of integers from 0 to 100004 modulo `mod`.
    ifact = [0] * 100005
    ifact[100004] = pow(fact[100004], mod - 2, mod)
    for i in range(100004, 0, -1):
        ifact[i - 1] = i * ifact[i] % mod
        
    #State of the program after the  for loop has been executed: `t` is an integer representing the number of test cases; `fact` is a list containing the factorials of integers from 0 to 100004 modulo `mod`; `ifact` is updated with values calculated for all indices from 0 to 100004; `i` is 1.
    return fact, ifact
    #The program returns the list 'fact' containing the factorials of integers from 0 to 100004 modulo 'mod', and the list 'ifact' updated with values calculated for all indices from 0 to 100004.

#Function 2:
#State of the program right berfore the function call: n is a positive integer representing the length of the password, and p is a list of n positive integers (1 ≤ p[i] ≤ 10^9).
def func_2(n, p):
    return pow(n, p - 2, p)
    #The program returns the result of pow(n, p - 2, p), where n is a positive integer representing the length of the password and p is a list of n positive integers. The result is computed as n raised to the power of (p - 2) modulo the integers in the list p.

#Function 3:
#State of the program right berfore the function call: n is a positive integer representing the length of the password, r is an array of n positive integers, fact and ifact are lists of precomputed factorials and their modular inverses, respectively.
def func_3(n, r, fact, ifact):
    t = fact[n] * (ifact[r] * ifact[n - r]) % mod % mod
    return t
    #The program returns the value of t, which is calculated as `fact[n] * (ifact[r] * ifact[n - r]) % mod % mod`, where `n` is the length of the password and `r` is an array of `n` positive integers.

#Function 4:
#State of the program right berfore the function call: The input consists of multiple test cases, where each test case contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5), followed by an array of n positive integers (1 ≤ a_i ≤ 10^9), and the total number of integers across all test cases does not exceed 2 ⋅ 10^5.
def func_4():
    return map(int, sys.stdin.readline().strip().split())
    #The program returns a map object containing n positive integers read from the input, where n is the first integer from the input, followed by an array of n positive integers.

#Function 5:
#State of the program right berfore the function call: The function processes multiple test cases, with t being the number of test cases (1 ≤ t ≤ 100). Each test case consists of an integer n (1 ≤ n ≤ 2 ⋅ 10^5) representing the length of the password, followed by an array a of n positive integers (1 ≤ a[i] ≤ 10^9) which represents the initial contents of the password. The sum of n across all test cases does not exceed 2 ⋅ 10^5.
def func_5():
    return list(map(int, sys.stdin.readline().strip().split()))
    #The program returns a list of integers processed from the input line, representing the initial contents of the password as an array of n positive integers.

#Function 6:
#State of the program right berfore the function call: The function processes multiple test cases, where each test case consists of an integer n (1 ≤ n ≤ 200,000) representing the length of an array a, followed by an array a of n positive integers (1 ≤ a[i] ≤ 10^9). The total sum of n across all test cases will not exceed 200,000.
def func_6():
    return sys.stdin.readline().strip()
    #The program returns a string input read from standard input, which represents a test case consisting of an integer n followed by an array a of n positive integers.

#Function 7:
#State of the program right berfore the function call: x is a positive integer representing the number of test cases (1 ≤ x ≤ 100), and y is a list of tuples where each tuple contains a positive integer n (1 ≤ n ≤ 2 ⋅ 10^5) followed by a list of n positive integers (1 ≤ a[i] ≤ 10^9) representing the elements of the password. The sum of n over all test cases does not exceed 2 ⋅ 10^5.
def func_7(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is the last non-zero value of `x % y` before `y` becomes zero, `x` is the previous value of `y` before it became zero.
    return x
    #The program returns the previous value of y before it became zero, which is the current value of x

#Function 8:
#State of the program right berfore the function call: x is a positive integer representing the number of test cases (1 ≤ x ≤ 100), and y is a list of tuples where each tuple contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) followed by n positive integers (1 ≤ a_i ≤ 10^9) representing the contents of the password for each test case. The total length of all passwords across test cases does not exceed 2 ⋅ 10^5.
def func_8(x, y):
    return x * y // func_7(x, y)
    #The program returns the result of multiplying the number of test cases x by the list of tuples y, divided by the result of the function func_7 with parameters x and y

#Function 9:
#State of the program right berfore the function call: n is a positive integer representing the number of elements in the password array, and the password array contains n positive integers.
def func_9(n):
    return [n, 1, n + 1, 0][n % 4]
    #The program returns an element from the list [n, 1, n + 1, 0] based on the value of n modulo 4, which represents the remainder when n is divided by 4.

#Function 10:
#State of the program right berfore the function call: a is a list of positive integers representing the password, and b is a positive integer indicating the length of the password a.
def func_10(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a
            res %= MOD
            b -= 1
        else:
            a = a * a
            a %= MOD
            b >>= 1
        
    #State of the program after the loop has been executed: `b` is 0, `res` is updated to the result of the exponentiation of the initial value of `a` raised to the original positive integer value of `b` modulo `MOD`. If `b` was initially odd, `res` includes one more multiplication of `a`, while if `b` was initially even, it doesn't.
    res %= MOD
    return res
    #The program returns the value of res which is 1, the result of the exponentiation of the initial value of a raised to 0 modulo MOD.

#Function 11:
#State of the program right berfore the function call: P is a list of tuples, where each tuple contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) followed by n positive integers (1 ≤ a_i ≤ 10^9), and the length of P is at most 100. The sum of n over all tuples in P does not exceed 2 ⋅ 10^5.
def func_11(P):
    ans = (-1 + sqrt(1 + 8 * P)) // 2
    return ans
    #The program returns the calculated value of `ans`, which is derived from the first integer of each tuple in `P`, though the specific numerical result cannot be determined without concrete values in `P`.

#Function 12:
#State of the program right berfore the function call: There are multiple test cases, with t being a positive integer (1 ≤ t ≤ 100). For each test case, n is a positive integer (1 ≤ n ≤ 2 ⋅ 10^5) representing the length of the password, and a is an array of n positive integers (1 ≤ a[i] ≤ 10^9). The sum of n over all test cases will not exceed 2 ⋅ 10^5.
def func_12():
    T = int(func_6())
    while T:
        n = int(func_6())
        
        Arr = func_5()
        
        p = Arr[0]
        
        flag = 0
        
        for i in Arr[1:]:
            if i != p:
                flag = 1
                break
        
        if flag == 1:
            print(1)
        else:
            print(n)
        
        T -= 1
        
    #State of the program after the loop has been executed: `t` is 0, `n` is the last value assigned from `int(func_6())`, `Arr` is the last list assigned from `func_5()`, `p` is the last value of `Arr[0]`, and `flag` is unchanged from its last value.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
