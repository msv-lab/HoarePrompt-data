
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Alexey, a merry Berland entrant, got sick of the gray reality and he zealously wants to go to university. There are a lot of universities nowadays, so Alexey is getting lost in the diversity — he has not yet decided what profession he wants to get. At school, he had bad grades in all subjects, and it's only thanks to wealthy parents that he was able to obtain the graduation certificate.

The situation is complicated by the fact that each high education institution has the determined amount of voluntary donations, paid by the new students for admission — ni berubleys. He cannot pay more than ni, because then the difference between the paid amount and ni can be regarded as a bribe!

Each rector is wearing the distinctive uniform of his university. Therefore, the uniform's pockets cannot contain coins of denomination more than ri. The rector also does not carry coins of denomination less than li in his pocket — because if everyone pays him with so small coins, they gather a lot of weight and the pocket tears. Therefore, a donation can be paid only by coins of denomination x berubleys, where li ≤ x ≤ ri (Berland uses coins of any positive integer denomination). Alexey can use the coins of different denominations and he can use the coins of the same denomination any number of times. When Alexey was first confronted with such orders, he was puzzled because it turned out that not all universities can accept him! Alexey is very afraid of going into the army (even though he had long wanted to get the green uniform, but his dad says that the army bullies will beat his son and he cannot pay to ensure the boy's safety). So, Alexey wants to know for sure which universities he can enter so that he could quickly choose his alma mater.

Thanks to the parents, Alexey is not limited in money and we can assume that he has an unlimited number of coins of each type.

In other words, you are given t requests, each of them contains numbers ni, li, ri. For each query you need to answer, whether it is possible to gather the sum of exactly ni berubleys using only coins with an integer denomination from li to ri berubleys. You can use coins of different denominations. Coins of each denomination can be used any number of times.

Input

The first line contains the number of universities t, (1 ≤ t ≤ 1000) Each of the next t lines contain three space-separated integers: ni, li, ri (1 ≤ ni, li, ri ≤ 109; li ≤ ri).

Output

For each query print on a single line: either "Yes", if Alexey can enter the university, or "No" otherwise.

Examples

Input

2
5 2 3
6 4 5


Output

Yes
No

Note

You can pay the donation to the first university with two coins: one of denomination 2 and one of denomination 3 berubleys. The donation to the second university cannot be paid.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: t is a positive integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, and ri are positive integers (1 ≤ ni, li, ri ≤ 10^9) such that li ≤ ri.
def func_1():
    return int(input())
    #The program returns a positive integer input by the user, which represents a university's value or identifier
#Overall this is what the function does:The function accepts no parameters and returns a positive integer input by the user, which represents a university's value or identifier. It does not handle cases where the input might not be a positive integer or where input might be invalid; thus, it assumes valid input is provided.

#Function 2:
#State of the program right berfore the function call: t is a positive integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, and ri are integers such that (1 ≤ ni, li, ri ≤ 10^9) and li ≤ ri.
def func_2():
    return input()
    #The program returns the input data, which includes the number of universities t and their respective values ni, li, and ri for each university, all of which are positive integers within the specified ranges.
#Overall this is what the function does:The function accepts no parameters and simply returns the input data from the user, which is expected to include the number of universities and their respective values ni, li, and ri. However, it does not perform any processing or validation of these values, nor does it handle cases where input might not conform to the expected format or constraints.

#Function 3:
#State of the program right berfore the function call: t is a positive integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a list of integers obtained from the input, which represents values for ni, li, and ri for each of the t universities, all of which are positive integers within the specified range.
#Overall this is what the function does:The function accepts input from the user, which is expected to be a space-separated string of integers representing values for ni, li, and ri for each of the t universities. It returns a map object of these integers, which can be converted to a list. However, it does not explicitly handle cases where the input format may be incorrect or outside the specified range, as it assumes the input is valid.

#Function 4:
#State of the program right berfore the function call: t is a positive integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, and ri are integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object of string representations of the input values, which are space-separated integers provided as input.
#Overall this is what the function does:The function accepts no parameters and reads a single line of space-separated integers from input, returning a map object of their string representations. It does not process or validate the integers ni, li, and ri directly; it simply returns the input as strings in a map object.

#Function 5:
#State of the program right berfore the function call: t is a positive integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_5():
    return list(func_3())
    #The program returns a list generated by the function func_3(), which processes the positive integers ni, li, and ri for each of the t universities, where 1 ≤ t ≤ 1000 and 1 ≤ ni, li, ri ≤ 10^9 with li ≤ ri.
#Overall this is what the function does:The function accepts no parameters and returns a list generated by the function `func_3()`, which processes positive integers `ni`, `li`, and `ri` for `t` universities, where `t` is between 1 and 1000, and each of `ni`, `li`, `ri` is between 1 and 10^9 with the condition that `li` is less than or equal to `ri`. The details of the processing performed by `func_3()` are not specified in this code snippet.

#Function 6:
#State of the program right berfore the function call: t is a positive integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, and ri are positive integers (1 ≤ ni, li, ri ≤ 10^9) such that li ≤ ri.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function `func_6` initializes a new thread that runs the `main` function. It accepts no parameters and does not return any value. The code suggests that it is designed to handle a scenario involving a positive integer `t`, which represents the number of universities, but the actual implementation of how this integer is used is not present within the function. Therefore, the function's current implementation does not handle or process the integer `t` or the associated parameters `ni`, `li`, and `ri`.

#Function 7:
#State of the program right berfore the function call: item is a list of tuples, where each tuple contains three integers ni, li, and ri such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The first element of the list indicates the number of universities t (1 ≤ t ≤ 1000).
def func_7(item):
    return item[1]
    #The program returns the second tuple in the list 'item', which contains three integers (n1, l1, r1) such that 1 ≤ n1, l1, r1 ≤ 10^9 and l1 ≤ r1.
#Overall this is what the function does:The function accepts a list of tuples, where each tuple contains three integers. It returns the second tuple in the list, which includes three integers (n1, l1, r1) that satisfy the constraints 1 ≤ n1, l1, r1 ≤ 10^9 and l1 ≤ r1. If the list contains fewer than two tuples, the function will raise an IndexError.

#Function 8:
#State of the program right berfore the function call: l is a list of tuples, where each tuple contains three integers ni, li, and ri such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri, and the length of the list l is t, where 1 ≤ t ≤ 1000.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list of tuples 'l' sorted in descending order based on the key function 'getKey'
#Overall this is what the function does:The function accepts a list of tuples `l`, where each tuple contains three integers. It returns the list sorted in descending order based on a key function `getKey`. There are no checks for the validity of the input list or the tuples, so if `getKey` is not defined or if the list contains non-tuple elements, it may raise an error.

#Function 9:
#State of the program right berfore the function call: n is a positive integer representing the donation amount, m is a positive integer representing the minimum denomination of coins, and num is a positive integer representing the maximum denomination of coins, with the condition that m ≤ num.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of n lists, each containing m elements, where each element is the value of num, resulting in a structure of dimensions n x m filled with the maximum denomination of coins, num.
#Overall this is what the function does:The function accepts three positive integer parameters `n`, `m`, and `num`, and returns a list containing `n` lists, each with `m` elements, all set to the value of `num`. This creates a 2D list (matrix) of dimensions `n x m` filled with the maximum denomination of coins, `num`. There are no checks for the values of `n`, `m`, and `num`, so if they are not positive integers, the function may not behave as expected.

#Function 10:
#State of the program right berfore the function call: x is a list of tuples, where each tuple contains three integers ni, li, and ri (1 ≤ ni, li, ri ≤ 10^9; li ≤ ri), and the length of x is t (1 ≤ t ≤ 1000).
def func_10(x):
    return x and not x & x - 1
    #The program returns the list of tuples x and the evaluation of the expression (x and not (x & (x - 1))) which depends on the specific values in x. The exact output of this expression cannot be determined without knowing the specific contents of x.
#Overall this is what the function does:The function accepts a list of tuples `x`, where each tuple contains three integers. It evaluates and returns the result of the expression `(x and not (x & (x - 1)))`, which checks if `x` is not empty and if `x` has only one bit set in its binary representation. However, the function does not return the list of tuples `x` itself, as stated in the annotations. The output solely depends on the logical evaluation of `x`. If `x` is empty, it returns `False`. If `x` contains valid tuples, the output is based on the evaluation of the specified expression.

#Function 11:
#State of the program right berfore the function call: n is an integer representing the number of universities (1 ≤ n ≤ 1000), and for each university, there are three integers ni, li, ri (1 ≤ ni, li, ri ≤ 10^9) provided such that li ≤ ri.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the integer n, without the '0b' prefix.
#Overall this is what the function does:The function accepts an integer `n` (where 1 ≤ n ≤ 1000) and returns the binary representation of `n` as a string, excluding the '0b' prefix. The function does not handle any edge cases since `n` is guaranteed to be within the specified range.

#Function 12:
#State of the program right berfore the function call: n is a list of tuples, where each tuple contains three integers ni, li, and ri (1 ≤ ni, li, ri ≤ 10^9; li ≤ ri), and the length of n is a positive integer t (1 ≤ t ≤ 1000).
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers created by converting each element of the list of tuples n into a string and then back to an integer, resulting in a flattened representation of all integers from the tuples in n.
#Overall this is what the function does:The function accepts a list of tuples `n`, where each tuple contains three integers. It returns a flattened list of integers formed by converting the entire list of tuples into a string and then back to integers, resulting in a single list of digits rather than individual integers from the tuples. This could lead to unexpected results if the tuples contain multi-digit integers.

#Function 13:
#State of the program right berfore the function call: n is a positive integer representing the amount of donation, and r is a list of tuples where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the value of n choose r, calculated as factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
#Overall this is what the function does:The function accepts a positive integer `n` and an integer `r`, and returns the value of `n` choose `r`, calculated as `factorial(n) // (factorial(r) * factorial(max(n - r, 1)))`. However, it does not handle cases where `r` is greater than `n`, which would result in incorrect behavior or a mathematical error, as the combination is undefined in such cases. It also does not validate the input values or check for potential overflow in factorial calculations.

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of universities (1 ≤ x ≤ 1000), and y is a list of tuples where each tuple contains three integers (ni, li, ri) such that (1 ≤ ni, li, ri ≤ 10^9) and (li ≤ ri).
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the result of dividing the integer x by the length of the list y, which is the number of universities divided by the number of tuples in the list.
    else :
        return x // y + 1
        #The program returns the integer result of x divided by the number of tuples in y, plus 1
#Overall this is what the function does:The function accepts an integer `x` representing the number of universities and a list `y` of tuples. It returns the integer result of dividing `x` by the length of `y`. If `x` is not evenly divisible by the length of `y`, it adds 1 to the result, effectively rounding up the division. However, the code incorrectly attempts to use `y` directly in the division condition instead of `len(y)`, which could lead to an error if `y` is not treated as the length of the list. Additionally, the function does not handle the case where `y` is empty, which would lead to a division by zero error.

#Function 15:
#State of the program right berfore the function call: x is a positive integer representing the donation amount ni, y is a positive integer representing the minimum coin denomination li, and p is a positive integer representing the maximum coin denomination ri, such that li ≤ ri.
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is the result of raising the original value of `x` to the power of the initial value of `y` modulo `p`, `x` is the final value after all iterations, having been updated to (previous value of `x` * previous value of `x`) % p repeatedly.
    return res
    #The program returns the result of raising the final value of `x` to the power of 0 modulo `p`, which is always 1.
#Overall this is what the function does:The function accepts three positive integers `x`, `y`, and `p`, and computes `x` raised to the power of `y` modulo `p`. The function returns the result of this computation, which can vary based on the values of `x`, `y`, and `p`. If `y` is 0, it will always return 1 since any number raised to the power of 0 is 1.

#Function 16:
#State of the program right berfore the function call: x is a list of integers where the first element is the number of universities t (1 ≤ t ≤ 1000), and each of the following elements is a tuple of three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`, `y` is 0.
    return x
    #The program returns the greatest common divisor (GCD) of the original values of x and y, which is x since y is 0.
#Overall this is what the function does:The function accepts a list of integers `x` and an integer `y`, and returns the greatest common divisor (GCD) of the last element of the list `x` and `y`. If `y` is initially 0, it simply returns the last element of the list `x`. However, the function does not utilize the rest of the integers in the list `x`, which may be relevant based on the problem context. If `y` is negative or not an integer, the behavior of the function is undefined based on the provided code.

#Function 17:
#State of the program right berfore the function call: n is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The length of the list n is between 1 and 1000.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The length of the list `n` is greater than 1, and the length of `n` is between 1 and 1000.
    if (n <= 3) :
        return True
        #The program returns True, indicating a successful execution without any conditions being checked or affected.
    #State of the program after the if block has been executed: *`n` is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The length of the list `n` is greater than 3 and less than or equal to 1000.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The length of the list `n` is greater than 3 and less than or equal to 1000. The length of `n` is not divisible by 2 and not divisible by 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is a list of tuples with at least 25 elements; `i` is greater than or equal to 5 and increased by 6 for each iteration until `i * i` exceeds the length of `n`.
    return True
    #The program returns True, indicating that the condition for the loop has been satisfied.
#Overall this is what the function does:The function accepts a list of tuples `n`, where each tuple contains three integers. It checks the length of the list and returns `False` if the length is less than or equal to 1, and `True` if the length is less than or equal to 3. If the length is greater than 3, it checks if the length is divisible by 2 or 3, returning `False` if so. It then performs a check for prime conditions on the length of the list using a while loop, returning `False` if it finds any factors, and `True` otherwise. However, it does not properly handle cases where the length of the list is exactly 0 or 1, as those conditions are not explicitly checked in the code.

#Function 18:
#State of the program right berfore the function call: t is a positive integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, and ri are positive integers such that (1 ≤ ni, li, ri ≤ 10^9) and li ≤ ri.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function sets up input and output redirection to read from 'input.txt' and write to 'output.txt'. It is designed to process data related to a specified number of universities, but the actual processing logic for the universities (using parameters `ni`, `li`, and `ri`) is not implemented in the provided code. There is no return value or further logic beyond setting up the I/O redirection.

#Function 19:
#State of the program right berfore the function call: t is a positive integer representing the number of universities, and for each university, ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_19():
    for _ in range(func_1()):
        n, l, r = func_3()
        
        low = 1
        
        high = 1000000000
        
        f = 0
        
        while low <= high:
            mid = (low + high) // 2
            x = l * mid
            y = r * mid
            if x <= n and n <= y:
                f = 1
                break
            if y < n:
                low = mid + 1
            else:
                high = mid - 1
        
        if f:
            func_20('Yes')
        else:
            func_20('No')
        
    #State of the program after the  for loop has been executed: `low` is greater than `high`, `f` is either 1 or 0 depending on the conditions evaluated during all iterations, `t` is a positive integer, and `n`, `l`, `r` are the values returned by `func_3()` for the last iteration. The function `func_20` is called with 'Yes' if at least one valid `mid` was found across all iterations, otherwise it is called with 'No'.
#Overall this is what the function does:The function processes a number of universities, each defined by parameters n, l, and r. For each university, it determines if there exists a positive integer mid such that the product of l and mid is less than or equal to n and the product of r and mid is greater than or equal to n. If such a mid is found for any university, the function calls func_20 with 'Yes'; otherwise, it calls func_20 with 'No'. It accepts no parameters directly but relies on external function calls to obtain the necessary values.

#Function 20:
#State of the program right berfore the function call: t is a positive integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `t` is a positive integer (1 ≤ `t` ≤ 1000), `args` is a list with at least `t` elements, `at_start` is False, `sep` is written to the file between all elements of `args`, and `file` now contains the string representation of all elements in `args` separated by `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`t` is a positive integer (1 ≤ `t` ≤ 1000), `args` is a list with at least `t` elements, `at_start` is False, `sep` is written to the file between all elements of `args`, `file` now contains the string representation of all elements in `args` separated by `sep`, and if the flush operation is executed, it has been performed on `file`.
#Overall this is what the function does:The function accepts variable arguments and keyword arguments, printing the string representations of the arguments to a specified file or standard output, separated by a specified separator. It supports flushing the output if requested. The function does not process any specific data related to universities or their associated values, as mentioned in the annotations; it simply prints the provided arguments.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.