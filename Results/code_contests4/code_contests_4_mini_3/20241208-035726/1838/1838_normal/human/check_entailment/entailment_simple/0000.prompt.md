
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Yura is tasked to build a closed fence in shape of an arbitrary non-degenerate simple quadrilateral. He's already got three straight fence segments with known lengths a, b, and c. Now he needs to find out some possible integer length d of the fourth straight fence segment so that he can build the fence using these four segments. In other words, the fence should have a quadrilateral shape with side lengths equal to a, b, c, and d. Help Yura, find any possible length of the fourth side.

A non-degenerate simple quadrilateral is such a quadrilateral that no three of its corners lie on the same line, and it does not cross itself.

Input

The first line contains a single integer t — the number of test cases (1 ≤ t ≤ 1000). The next t lines describe the test cases.

Each line contains three integers a, b, and c — the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).

Output

For each test case print a single integer d — the length of the fourth fence segment that is suitable for building the fence. If there are multiple answers, print any. We can show that an answer always exists.

Example

Input


2
1 2 3
12 34 56


Output


4
42

Note

We can build a quadrilateral with sides 1, 2, 3, 4.

We can build a quadrilateral with sides 12, 34, 56, 42.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.
def func_1():
    return int(input())
    #The program returns a positive integer input, which is within the range of 1 to 1000 for t, and for each test case, it can return a, b, or c which are integers between 1 and 10^9.

#Function 2:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are positive integers (1 ≤ a, b, c ≤ 10^9).
def func_2():
    return input()
    #The program returns input values for t, a, b, and c as positive integers within the specified ranges.

#Function 3:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing the integers a, b, and c, which are read from input and are within the range 1 to 10^9.

#Function 4:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000) representing the number of test cases, and for each test case, a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representations of the integers a, b, and c from the input, which are positive integers each ranging between 1 and 10^9.

#Function 5:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases (1 ≤ t ≤ 1000), and for each test case, a, b, and c are positive integers representing the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).
def func_5():
    return list(func_3())
    #The program returns a list of results from the function `func_3()` for each test case involving positive integers a, b, and c representing the lengths of the three fence segments. Each result indicates whether the lengths can form a triangle, based on the triangle inequality theorem.

#Function 6:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000) representing the number of test cases, and for each test case, a, b, and c are integers (1 ≤ a, b, c ≤ 10^9) representing the lengths of the three fence segments.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a list of t test cases, where each test case contains three integers a, b, and c (1 ≤ a, b, c ≤ 10^9), and t is an integer such that 1 ≤ t ≤ 1000.
def func_7(item):
    return item[1]
    #The program returns the second test case from the list 'item', which consists of three integers a, b, and c

#Function 8:
#State of the program right berfore the function call: l is a list of tuples, where each tuple contains three integers a, b, and c (1 ≤ a, b, c ≤ 10^9), and the length of l is equal to the number of test cases t (1 ≤ t ≤ 1000).
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list of tuples 'l' sorted in descending order based on the key function 'getKey'

#Function 9:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list with dimensions n x m, where each element is 'num'

#Function 10:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are positive integers (1 ≤ a, b, c ≤ 10^9).
def func_10(x):
    return x and not x & x - 1
    #The program returns the boolean result of the expression `x and not (x & (x - 1))`, which indicates whether `x` is a power of two, where `x` is a positive integer.

#Function 11:
#State of the program right berfore the function call: n is a positive integer representing the number of test cases (1 ≤ n ≤ 1000), and for each test case, a, b, and c are integers representing the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the positive integer n, which represents the number of test cases, without the '0b' prefix.

#Function 12:
#State of the program right berfore the function call: n is a positive integer representing the number of test cases (1 ≤ n ≤ 1000), and for each test case, a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers representing each digit of the positive integer n, which corresponds to the number of test cases.

#Function 13:
#State of the program right berfore the function call: n is a positive integer representing the number of test cases (1 ≤ n ≤ 1000), and r is a list of tuples where each tuple contains three integers a, b, and c representing the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program attempts to calculate a combinatorial value based on the number of test cases 'n' and a list of tuples 'r', but the return statement is incorrect since 'r' is a list of tuples and cannot be directly used with factorial. Hence, it will result in an error instead of a valid output.

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 1000), and y is a list of tuples, where each tuple contains three integers (a, b, c) representing the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the number of test cases 'x' divided by the length of the list 'y', which contains tuples of three integers representing fence segments.
    else :
        return x // y + 1
        #The program returns the integer division of x by the length of y plus 1

#Function 15:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is either the product of `x` raised to the power of the number of times the least significant bit of the original value of `y` was 1, modulo `p`, `x` is updated to `x` raised to the power of 2 to the number of shifts applied to the original value of `y`, modulo `p`, `t` is a positive integer (1 ≤ t ≤ 1000), `a`, `b`, and `c` are integers (1 ≤ a, b, c ≤ 10^9)
    return res
    #The program returns the product of `x` raised to the power of the number of times the least significant bit of `y` was 1, modulo `p`

#Function 16:
#State of the program right berfore the function call: x and y are integers representing the lengths of the three known fence segments a, b, and c, where 1 ≤ a, b, c ≤ 10^9. The function is called for multiple test cases, with 1 ≤ t ≤ 1000 test cases.
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the greatest common divisor (GCD) of the original values of `x` and `y`, `y` is 0.
    return x
    #The program returns the greatest common divisor (GCD) of the original values of `x` and `y`, which is `x`, since `y` is 0.

#Function 17:
#State of the program right berfore the function call: n is a positive integer representing the number of test cases, followed by n lines each containing three positive integers a, b, and c (1 ≤ a, b, c ≤ 10^9).
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a positive integer greater than 1 representing the number of test cases, followed by `n` lines each containing three positive integers `a`, `b`, and `c` (1 ≤ `a`, `b`, `c` ≤ 10^9).
    if (n <= 3) :
        return True
        #The program returns True, indicating a successful condition was met for the given test cases
    #State of the program after the if block has been executed: *`n` is a positive integer greater than 1 representing the number of test cases, followed by `n` lines each containing three positive integers `a`, `b`, and `c` (1 ≤ `a`, `b`, `c` ≤ 10^9). The value of `n` is greater than 3.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a positive integer greater than 1 representing the number of test cases, followed by `n` lines each containing three positive integers `a`, `b`, and `c` (1 ≤ `a`, `b`, `c` ≤ 10^9). The value of `n` is greater than 3, and `n` is neither divisible by 2 nor divisible by 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is a positive integer greater than or equal to 25, `i` is greater than or equal to 5 and increased by 6 for each iteration until `i * i` exceeds `n`.
    return True
    #The program returns True, indicating that the conditions based on `n` and `i` have been satisfied in the given iterations.

#Function 18:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are positive integers (1 ≤ a, b, c ≤ 10^9).
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.
def func_19():
    for _ in range(func_1()):
        a, b, c = func_3()
        
        func_20(c + 1)
        
    #State of the program after the  for loop has been executed: `t` is a positive integer; `a`, `b`, `c` are the values returned by `func_3()` from the last iteration of the loop; `func_20` is called `func_1()` times with the argument `c + 1` for each iteration of the loop.

#Function 20:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000) representing the number of test cases, and for each test case, a, b, and c are positive integers (1 ≤ a, b, c ≤ 10^9) representing the lengths of the three fence segments.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `t` is a positive integer (1 ≤ `t` ≤ 1000), `at_start` is False, `args` contains at least `t` elements, `sep` is written between elements except before the first element, and all elements in `args` are written to the file as strings.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`t` is a positive integer (1 ≤ `t` ≤ 1000), `at_start` is False, and `args` contains at least `t` elements. If `kwargs.pop('flush', False)` is True, the file is flushed after something is written based on `kwargs.pop('end', '\n')`.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
