
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Little Susie listens to fairy tales before bed every day. Today's fairy tale was about wood cutters and the little girl immediately started imagining the choppers cutting wood. She imagined the situation that is described below.

There are n trees located along the road at points with coordinates x1, x2, ..., xn. Each tree has its height hi. Woodcutters can cut down a tree and fell it to the left or to the right. After that it occupies one of the segments [xi - hi, xi] or [xi;xi + hi]. The tree that is not cut down occupies a single point with coordinate xi. Woodcutters can fell a tree if the segment to be occupied by the fallen tree doesn't contain any occupied point. The woodcutters want to process as many trees as possible, so Susie wonders, what is the maximum number of trees to fell. 

Input

The first line contains integer n (1 ≤ n ≤ 105) — the number of trees.

Next n lines contain pairs of integers xi, hi (1 ≤ xi, hi ≤ 109) — the coordinate and the height of the і-th tree.

The pairs are given in the order of ascending xi. No two trees are located at the point with the same coordinate.

Output

Print a single number — the maximum number of trees that you can cut down by the given rules.

Examples

Input

5
1 2
2 1
5 10
10 9
19 1


Output

3


Input

5
1 2
2 1
5 10
10 9
20 1


Output

4

Note

In the first sample you can fell the trees like that: 

  * fell the 1-st tree to the left — now it occupies segment [ - 1;1]
  * fell the 2-nd tree to the right — now it occupies segment [2;3]
  * leave the 3-rd tree — it occupies point 5
  * leave the 4-th tree — it occupies point 10
  * fell the 5-th tree to the right — now it occupies segment [19;20]



In the second sample you can also fell 4-th tree to the right, after that it will occupy segment [10;19].
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and each tree is represented by a pair of integers (xi, hi) where 1 ≤ xi, hi ≤ 10^9, and the coordinates xi are given in strictly ascending order with no duplicates.
def func():
    n = input()
    p = []
    h = []
    for i in range(n):
        e = map(int, raw_input().split())
        
        p.append(e[0])
        
        h.append(e[1])
        
    #State of the program after the  for loop has been executed: `n` is an input string that must be convertible to an integer and at least 1; `p` contains the first integer from each of the `n` input strings; `h` contains the second integer from each of the `n` input strings; `i` is `n - 1`, `e` is a map object of integers created from the last split input string.
    pivout = p[0]
    if (n == 1) :
        cont = 1
    else :
        cont = 2
    #State of the program after the if-else block has been executed: *`n` is an input string that must be convertible to an integer and at least 1. If `n` is equal to 1, `p` contains the first integer from each of the `n` input strings, `h` contains the second integer from each of the `n` input strings, `i` is 0 (`n - 1`), `e` is a map object of integers created from the last split input string, `pivout` is assigned the value of `p[0]`, and `cont` is set to 1. Otherwise, `cont` is set to 2 while maintaining that `p`, `h`, `i`, `e`, and `pivout` retain their respective values based on `n`.
    for i in range(1, len(p) - 1):
        if p[i] - h[i] > pivout:
            cont += 1
            pivout = p[i]
        elif p[i] + h[i] < p[i + 1]:
            cont += 1
            pivout = p[i] + h[i]
        else:
            pivout = p[i]
        
    #State of the program after the  for loop has been executed: `n` is an integer at least 1, `cont` is the final count based on conditions in the loop, `p` is a list of integers with at least 2 elements, `h` is a list of integers with at least 2 elements, `i` is `len(p) - 1`, `pivout` is the last computed value based on the loop conditions.
    print(cont)

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
