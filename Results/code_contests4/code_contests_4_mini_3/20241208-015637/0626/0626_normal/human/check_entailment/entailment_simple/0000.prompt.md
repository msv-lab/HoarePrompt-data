
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given a rooted tree with n vertices. In each leaf vertex there's a single integer — the number of apples in this vertex. 

The weight of a subtree is the sum of all numbers in this subtree leaves. For instance, the weight of a subtree that corresponds to some leaf is the number written in the leaf.

A tree is balanced if for every vertex v of the tree all its subtrees, corresponding to the children of vertex v, are of equal weight. 

Count the minimum number of apples that you need to remove from the tree (specifically, from some of its leaves) in order to make the tree balanced. Notice that you can always achieve the goal by just removing all apples.

Input

The first line contains integer n (2 ≤ n ≤ 105), showing the number of vertices in the tree. The next line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 108), ai is the number of apples in the vertex number i. The number of apples in non-leaf vertices is guaranteed to be zero. 

Then follow n - 1 lines, describing the tree edges. Each line contains a pair of integers xi, yi (1 ≤ xi, yi ≤ n, xi ≠ yi) — the vertices connected by an edge. 

The vertices are indexed from 1 to n. Vertex 1 is the root.

Output

Print a single integer — the minimum number of apples to remove in order to make the tree balanced.

Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the sin, cout streams cin, cout or the %I64d specifier.

Examples

Input

6
0 0 12 13 5 6
1 2
1 3
1 4
2 5
2 6


Output

6
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n is an integer between 2 and 100,000 (2 ≤ n ≤ 10^5), representing the number of vertices in the tree; and there is a list of n integers where each integer (0 ≤ ai ≤ 10^8) represents the number of apples at the leaf vertices, with non-leaf vertices guaranteed to have zero apples. Additionally, there are n - 1 edges described by pairs of integers, each representing a connection between two vertices (1 ≤ xi, yi ≤ n, xi ≠ yi).
def func_1(n):
    return [raw_input().strip() for i in range(n)]
    #The program returns a list of n integers, where each integer represents the number of apples at the leaf vertices, inputted by the user

#Function 2:
#State of the program right berfore the function call: n is an integer such that 2 ≤ n ≤ 10^5, and there is a list of n integers where each integer ai (0 ≤ ai ≤ 10^8) represents the number of apples in the leaf vertices, with non-leaf vertices guaranteed to have zero apples. The tree is described by n - 1 edges connecting pairs of vertices, where each edge consists of two distinct integers xi and yi (1 ≤ xi, yi ≤ n).
def func_2():
    return raw_input().strip()
    #The program returns the raw input as a string, stripped of any leading or trailing whitespace.

#Function 3:
#State of the program right berfore the function call: n is an integer such that 2 ≤ n ≤ 10^5, and there is a list of n integers representing the number of apples in each vertex, where each integer ai satisfies 0 ≤ ai ≤ 10^8. The tree is described by n-1 edges connecting the vertices, with each edge connecting two distinct vertices indexed from 1 to n.
def func_3():
    return map(int, func_2().split())
    #The program returns a map object containing integers parsed from the output of func_2(), which is expected to be a space-separated string of integers.

#Function 4:
#State of the program right berfore the function call: n is an integer representing the number of vertices in the tree (2 ≤ n ≤ 10^5), and a is a list of n integers where each integer ai (0 ≤ ai ≤ 10^8) represents the number of apples in the leaf vertices of the tree. The tree is defined by n-1 edges connecting the vertices, where each edge connects two distinct vertices indexed from 1 to n.
def func_4():
    return func_3()[0]
    #The program returns the first element of the result from the function func_3(), which is expected to contain relevant information based on the number of vertices and the number of apples in the leaf vertices of the tree.

#Function 5:
#State of the program right berfore the function call: o is a tuple containing an integer n (2 ≤ n ≤ 10^5), a list of n integers representing the number of apples in the leaf vertices (0 ≤ ai ≤ 10^8), and a list of n-1 pairs of integers representing the edges of the tree.
def func_5(o):
    print(o)

#Function 6:
#State of the program right berfore the function call: a is a list of n integers representing the number of apples in each vertex, where 0 ≤ ai ≤ 10^8, and b is a list of n-1 tuples representing the edges of the tree, where each tuple contains two distinct integers representing connected vertices (1 ≤ xi, yi ≤ n).
def func_6(a, b):
    while b != 0:
        a %= b
        
        a, b = b, a
        
    #State of the program after the loop has been executed: `a` is a list of n-1 tuples, `b` is a list of n integers, the loop has terminated.
    return a
    #The program returns the list of n-1 tuples stored in variable 'a'

#Function 7:
#State of the program right berfore the function call: a is a list of integers where each integer represents the number of apples in the leaf vertices of a rooted tree, and b is a list of tuples where each tuple contains two integers representing the edges connecting the vertices in the tree. The number of vertices in the tree is n, where 2 ≤ n ≤ 10^5, and each integer in the list a satisfies 0 ≤ ai ≤ 10^8.
def func_7(a, b):
    return a / func_6(a, b) * b
    #The program returns the result of dividing the list of integers 'a' by the result of 'func_6(a, b)' and then multiplying by 'b', where 'a' represents the number of apples in the leaf vertices and 'b' contains the edges connecting the vertices in the tree.

#Function 8:
#State of the program right berfore the function call: node is an integer representing a vertex in the tree, parent is an integer representing the parent vertex of the current node. The tree has n vertices (2 ≤ n ≤ 10^5), with leaf vertices containing non-negative integers (0 ≤ ai ≤ 10^8) representing the number of apples, and non-leaf vertices having zero apples.
def func_8(node, parent):
    ii = -1
    for i in range(len(node[2])):
        if node[2][i] != parent:
            func_8(node[2][i], node)
        else:
            ii = i
        
    #State of the program after the  for loop has been executed: `ii` is the index of the last occurrence of `parent` in `node[2]` or -1 if `parent` is not found, `i` is equal to `len(node[2])`, and `node[2]` is a list with at least `len(node[2])` elements.
    if (ii >= 0) :
        node[2].pop(ii)
    #State of the program after the if block has been executed: *`ii` is the index of the last occurrence of `parent` in `node[2]` or -1 if `parent` is not found, `i` is equal to `len(node[2])`, and if `ii` is non-negative, then `node[2]` has one less element after the pop operation. If `ii` is -1, there is no change to `node[2]` or `i`.

#Function 9:
#State of the program right berfore the function call: node is a tree represented as a rooted structure with n vertices where n is an integer (2 ≤ n ≤ 10^5). Each leaf vertex contains a non-negative integer representing the number of apples (0 ≤ ai ≤ 10^8), and non-leaf vertices have a value of zero. The edges connecting the vertices are given as pairs of integers.
def func_9(node):
    if (node[1] >= 0) :
        return
        #The program returns the tree structure 'node' with 'n' vertices, where leaf vertices contain non-negative integers representing the number of apples, and non-leaf vertices have a value of zero. The value of 'node[1]' is greater than or equal to 0.
    #State of the program after the if block has been executed: *`node` is a tree represented as a rooted structure with `n` vertices where `n` is an integer (2 ≤ n ≤ 10^5). Each leaf vertex contains a non-negative integer representing the number of apples (0 ≤ ai ≤ 10^8), and non-leaf vertices have a value of zero. The value of `node[1]` is less than 0.
    lcm = 1
    max = -1
    for child in node[2]:
        func_9(child)
        
        lcm = func_7(lcm, child[0])
        
    #State of the program after the  for loop has been executed: `node` is a tree with at least one child in `node[2]`; `lcm` is the least common multiple of the values returned by `func_7(lcm, child[0])` for all children in `node[2]`; `func_9(child)` has been executed for all children in `node[2]`.
    for child in node[2]:
        t = child[1] / lcm * lcm
        
        if max < 0 or max > t:
            max = t
        
    #State of the program after the  for loop has been executed: `node` is a tree with at least one child in `node[2]`, `lcm` is the least common multiple of the values returned by `func_7(lcm, child[0])` for all children in `node[2]`, `func_9(child)` has been executed for all children in `node[2]`, `child` is the last child in `node[2]`, `t` is equal to the value of the last child's second element, and `max` is the maximum value of `t` encountered during the iterations, which is either equal to the last `t` or the maximum of all previous `t` values if `max` was updated during the loop executions.`
    node[0] = lcm
    node[1] = max * len(node[2])


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
