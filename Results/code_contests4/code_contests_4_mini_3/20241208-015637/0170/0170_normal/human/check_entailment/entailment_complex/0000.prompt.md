
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You are given three sequences: a_1, a_2, …, a_n; b_1, b_2, …, b_n; c_1, c_2, …, c_n.

For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.

Find a sequence p_1, p_2, …, p_n, that satisfy the following conditions:

  * p_i ∈ \\{a_i, b_i, c_i\}
  * p_i ≠ p_{(i mod n) + 1}.



In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements i,i+1 adjacent for i<n and also elements 1 and n) will have equal value.

It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.

Input

The first line of input contains one integer t (1 ≤ t ≤ 100): the number of test cases.

The first line of each test case contains one integer n (3 ≤ n ≤ 100): the number of elements in the given sequences.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 100).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ 100).

The fourth line contains n integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 100).

It is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.

Output

For each test case, print n integers: p_1, p_2, …, p_n (p_i ∈ \\{a_i, b_i, c_i\}, p_i ≠ p_{i mod n + 1}).

If there are several solutions, you can print any.

Example

Input


5
3
1 1 1
2 2 2
3 3 3
4
1 2 1 2
2 1 2 1
3 4 3 4
7
1 3 3 1 1 1 1
2 4 4 3 2 2 4
4 2 2 2 4 4 2
3
1 2 1
2 3 3
3 1 2
10
1 1 1 2 2 2 3 3 3 1
2 2 2 3 3 3 1 1 1 2
3 3 3 1 1 1 2 2 2 3


Output


1 2 3
1 2 1 2
1 3 4 3 2 4 2
1 3 2
1 2 3 1 2 3 1 2 3 2

Note

In the first test case p = [1, 2, 3].

It is a correct answer, because:

  * p_1 = 1 = a_1, p_2 = 2 = b_2, p_3 = 3 = c_3 
  * p_1 ≠ p_2 , p_2 ≠ p_3 , p_3 ≠ p_1 



All possible correct answers to this test case are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].

In the second test case p = [1, 2, 1, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = a_3, p_4 = a_4. Also we can see, that no two adjacent elements of the sequence are equal.

In the third test case p = [1, 3, 4, 3, 2, 4, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = b_3, p_4 = b_4, p_5 = b_5, p_6 = c_6, p_7 = c_7. Also we can see, that no two adjacent elements of the sequence are equal.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100 for each test case, a, b, and c are lists of integers of length n where each integer is in the range 1 ≤ a_i, b_i, c_i ≤ 100, and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_1():
    return int(input())
    #The program returns an integer input value from the user
#Overall this is what the function does:The function accepts no parameters and returns an integer value that is provided as input by the user. It does not handle any exceptions or validate the input range, so if the user enters a non-integer value, it will raise a ValueError.

#Function 2:
#State of the program right berfore the function call: t is an integer (1 ≤ t ≤ 100) representing the number of test cases; for each test case, n is an integer (3 ≤ n ≤ 100) representing the number of elements in the sequences; a_i, b_i, and c_i are integers (1 ≤ a_i, b_i, c_i ≤ 100) such that a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all i.
def func_2():
    return input()
    #The program returns the input data which includes the number of test cases t and the integer sequences a_i, b_i, and c_i for each test case, with the constraints that a_i, b_i, and c_i are distinct integers within the specified ranges.
#Overall this is what the function does:The function accepts input data which includes the number of test cases `t` and for each test case, it expects to handle integer sequences `a_i`, `b_i`, and `c_i`. However, the function only reads and returns the input data without processing or validating the sequences according to the specified constraints on their values. It does not handle the integers `n`, `a_i`, `b_i`, and `c_i` explicitly within the function, nor does it check if the constraints (distinctness and range) are satisfied. Therefore, the functionality is limited to returning the raw input without any additional checks.

#Function 3:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100; for each test case, n is an integer such that 3 ≤ n ≤ 100; a, b, and c are lists of n integers where each integer is in the range 1 to 100, and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a list of integers obtained from the input, which are space-separated values that are converted to integers. Each integer is within the range of 1 to 100.
#Overall this is what the function does:The function accepts no parameters and returns a map object of integers obtained from space-separated input values. These integers are converted from string format to integer format. Each integer is expected to be within the range of 1 to 100, but there is no explicit error handling for cases where the input may not meet the conditions. The function does not validate the input or ensure that the integers are distinct among the lists mentioned in the annotations.

#Function 4:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100 for each test case, and a, b, c are lists of integers of length n where each element a_i, b_i, c_i satisfies 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object that converts the input string of space-separated values into strings, after stripping any leading or trailing whitespace.
#Overall this is what the function does:The function does not accept any parameters and returns a map object that converts a space-separated string of input values into strings, after stripping any leading or trailing whitespace. However, it relies on user input and does not handle any potential errors or edge cases that may arise from invalid input.

#Function 5:
#State of the program right berfore the function call: t is an integer (1 ≤ t ≤ 100), n is an integer (3 ≤ n ≤ 100) for each test case, and a_i, b_i, c_i are integers (1 ≤ a_i, b_i, c_i ≤ 100) such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i (1 ≤ i ≤ n).
def func_5():
    return list(func_3())
    #The program returns a list generated by the function func_3() based on the integers t, n, a_i, b_i, and c_i, which represent the constraints and conditions given.
#Overall this is what the function does:The function `func_5` does not accept any parameters and returns a list generated by the function `func_3()`. The contents of the list are based on integer constraints defined for test cases that involve integers `t`, `n`, `a_i`, `b_i`, and `c_i` which are not explicitly passed to `func_5` but are instead presumably defined in the broader scope of the program.

#Function 6:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100; for each test case, n is an integer such that 3 ≤ n ≤ 100; a, b, and c are lists of integers of length n where each element is in the range 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function `func_6` initializes a new thread to execute the `main` function, but it does not accept any parameters directly. It sets the recursion limit and stack size for the thread, which may be necessary for handling deep recursive calls or large data in the `main` function. However, without the implementation of `main`, the specific output or behavior based on the lists `a`, `b`, and `c` is not defined in this code. Therefore, the function primarily serves as a setup for threading without providing direct functionality on its own.

#Function 7:
#State of the program right berfore the function call: item is a tuple containing three sequences of integers (a, b, c), where each sequence has n elements (3 ≤ n ≤ 100), and for each index i, a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i] with 1 ≤ a[i], b[i], c[i] ≤ 100. Additionally, the function is called for multiple test cases (1 ≤ t ≤ 100).
def func_7(item):
    return item[1]
    #The program returns the second sequence of integers 'b' from the tuple 'item' containing three sequences (a, b, c)
#Overall this is what the function does:The function accepts a tuple `item` containing three sequences of integers (a, b, c) and returns the second sequence of integers `b`. It does not perform any validation on the contents of the tuple or the sequences, assuming they adhere to the conditions specified in the preconditions.

#Function 8:
#State of the program right berfore the function call: l is a list containing multiple test cases, where each test case consists of four lines: the first line is an integer n (3 ≤ n ≤ 100), the second line is a list of n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 100), the third line is a list of n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ 100), and the fourth line is a list of n integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 100). For all i in the range [0, n-1], a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list 'l' sorted in descending order based on the values determined by the function 'getKey'
#Overall this is what the function does:The function accepts a list `l` containing multiple test cases, where each test case consists of four lines of data as specified. It returns the list `l` sorted in descending order based on the values determined by the function `getKey`.

#Function 9:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100, a, b, and c are lists of integers of length n, where each integer in the lists satisfies 1 ≤ a_i, b_i, c_i ≤ 100, and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of lists with dimensions n x m, where each inner list contains the same integer 'num' repeated m times. 'num' is not given in the initial state.
#Overall this is what the function does:The function accepts two integer parameters `n` and `m`, and an integer `num`. It returns a list of lists with dimensions `n x m`, where each inner list contains the integer `num` repeated `m` times. There are no checks for the validity of `n`, `m`, or `num`, so it assumes they are provided as specified in the annotations.

#Function 10:
#State of the program right berfore the function call: x is a list of tuples, where each tuple contains three sequences (a, b, c) of n integers, with 1 ≤ a_i, b_i, c_i ≤ 100, n is an integer such that 3 ≤ n ≤ 100, and it is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i. The number of test cases t is an integer such that 1 ≤ t ≤ 100.
def func_10(x):
    return x and not x & x - 1
    #The program returns the list of tuples x and the result of the bitwise operation 'not x & (x - 1)'
#Overall this is what the function does:The function accepts a list of tuples `x`, where each tuple contains three sequences of integers. It returns the list of tuples `x` along with the result of the boolean expression `x and not (x & (x - 1))`, which checks if `x` is non-empty and if `x` has a single bit set in its binary representation, yielding either `True` or `False`. However, this boolean operation does not have a meaningful interpretation with a list of tuples, and it may not behave as expected for the intended context.

#Function 11:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 100), n is an integer (3 ≤ n ≤ 100), and a, b, c are lists of length n containing integers (1 ≤ a_i, b_i, c_i ≤ 100) where a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all valid i.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the integer n without the '0b' prefix.
#Overall this is what the function does:The function accepts an integer `n` and returns its binary representation as a string without the '0b' prefix. It does not handle any edge cases since the input is assumed to be valid within the specified range (3 ≤ n ≤ 100).

#Function 12:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100; for each test case, there are three sequences of integers a, b, c of length n, where each element in a, b, and c is an integer in the range 1 to 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers representing each digit of the integer n, where n is between 3 and 100.
#Overall this is what the function does:The function accepts an integer `n` between 3 and 100 and returns a list of integers representing each digit of `n`. If `n` is a single-digit number, it returns a list containing that single digit; if `n` is a two-digit number, it returns a list of the two digits. The function does not perform any additional validation beyond the stated constraints.

#Function 13:
#State of the program right berfore the function call: n is an integer in the range [3, 100], and r is a list of three sequences, where each sequence contains n integers in the range [1, 100] with the property that for each index i, a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of the binomial coefficient calculation based on the integer n in the range [3, 100] and the integer r, which is one of the sequences from the list of three sequences, using the formula factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
#Overall this is what the function does:The function accepts an integer `n` in the range [3, 100] and an integer `r` that should be chosen from one of the sequences contained in the list `r`. It returns the result of the binomial coefficient calculation using the formula factorial(n) // (factorial(r) * factorial(max(n - r, 1))). However, there is no validation in the code to ensure that `r` is within the valid range of integers for the sequences, which could lead to errors if `r` is outside the expected range. Additionally, the function does not handle cases where `r` could be negative or greater than `n`, which would also cause computation issues.

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), and for each test case, y is a list of three tuples, each containing n integers (3 ≤ n ≤ 100) where the integers are in the range 1 to 100, and each tuple represents the sequences a, b, and c respectively, with the condition that no two integers in the same position of the tuples are equal.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer result of dividing x by y, where x is the number of test cases (1 ≤ x ≤ 100) and y is a list of three tuples of integers (3 ≤ n ≤ 100) that are all distinct in each position. Since x is divisible by y, the output will be a whole number.
    else :
        return x // y + 1
        #The program returns the integer result of x divided by y, plus 1, where x is the number of test cases (1 ≤ x ≤ 100) and y is a list containing three tuples of integers (3 ≤ n ≤ 100) that are not equal in the same position.
#Overall this is what the function does:The function accepts an integer `x` representing the number of test cases and a list `y` containing three tuples of integers. It returns the integer result of dividing `x` by the length of `y` (which is always 3), returning `x // 3` if `x` is divisible by 3, or `x // 3 + 1` if not. The function does not properly handle edge cases where `y` might not contain exactly three tuples, leading to potential incorrect behavior.

#Function 15:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), y is an integer representing the number of elements in the sequences (3 ≤ y ≤ 100), and p is a list of three lists, each containing y integers (1 ≤ p[i][j] ≤ 100) such that for each i (0 ≤ i < y), p[0][i] ≠ p[1][i], p[0][i] ≠ p[2][i], and p[1][i] ≠ p[2][i].
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the final value after repeatedly squaring and taking modulo `p`, `res` is the result of the exponentiation by squaring process based on the initial values of `x` and `y`, and `p` is a list of three lists.
    return res
    #The program returns the result of the exponentiation by squaring process based on the initial values of x and y
#Overall this is what the function does:The function accepts an integer `x`, an integer `y`, and a list of three lists `p`, and returns the result of the exponentiation by squaring process based on the values of `x` and `y`, reduced modulo the integer value derived from the lists in `p`. Note that the function does not use the contents of `p` for any calculations other than the modulo operation, which may not accurately reflect the intended use of the input. Additionally, the function assumes `x` is initially reduced by some undefined `p` value, which could lead to unexpected results if `p` does not contain a singular integer.

#Function 16:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100); for each test case, y is an integer representing the number of elements in the sequences (3 ≤ y ≤ 100), followed by three lists of integers a, b, and c of length y, where each integer in these lists (1 ≤ a_i, b_i, c_i ≤ 100) satisfies the condition that a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all i.
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the greatest common divisor (GCD) of the initial values of `x` and `y`.
    return x
    #The program returns the greatest common divisor (GCD) of the initial values of `x` and `y`, where `y` is 0. Therefore, the program returns `x`, which is the initial value of `x`.
#Overall this is what the function does:The function accepts two integers `x` and `y`, and calculates their greatest common divisor (GCD) using the Euclidean algorithm. It returns the GCD of the initial values of `x` and `y`. If `y` is 0 at the start, the function will return the initial value of `x`. The function assumes valid input within specified bounds, but does not handle cases where `y` could be less than 1, which is outside the stated constraints.

#Function 17:
#State of the program right berfore the function call: n is an integer where 3 ≤ n ≤ 100. For each test case, there are three sequences of integers a, b, and c, each containing n integers where 1 ≤ a_i, b_i, c_i ≤ 100, and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i. There are t test cases where 1 ≤ t ≤ 100.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer where 3 ≤ `n` ≤ 100. For each test case, there are three sequences of integers `a`, `b`, and `c`, each containing `n` integers where 1 ≤ `a_i`, `b_i`, `c_i` ≤ 100, and for all `i`, `a_i ≠ b_i`, `a_i ≠ c_i`, `b_i ≠ c_i`. There are `t` test cases where 1 ≤ `t` ≤ 100, and `n` is greater than 1.
    if (n <= 3) :
        return True
        #The program returns True indicating that the conditions for n, a, b, and c are satisfied.
    #State of the program after the if block has been executed: *`n` is an integer where 3 < `n` ≤ 100. For each test case, there are three sequences of integers `a`, `b`, and `c`, each containing `n` integers where 1 ≤ `a_i`, `b_i`, `c_i` ≤ 100, and for all `i`, `a_i ≠ b_i`, `a_i ≠ c_i`, `b_i ≠ c_i`. There are `t` test cases where 1 ≤ `t` ≤ 100, and `n` is greater than 3.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False, indicating a condition that is not satisfied within the given constraints.
    #State of the program after the if block has been executed: *`n` is an integer where 3 < `n` ≤ 100, and `n` is neither divisible by 2 nor by 3. For each test case, there are three sequences of integers `a`, `b`, and `c`, each containing `n` integers where 1 ≤ `a_i`, `b_i`, `c_i` ≤ 100, and for all `i`, `a_i ≠ b_i`, `a_i ≠ c_i`, `b_i ≠ c_i`. There are `t` test cases where 1 ≤ `t` ≤ 100, and `n` is greater than 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `i` is greater than or equal to 5 and is the smallest integer greater than or equal to the square root of `n`; `n` remains an integer where 3 < `n` ≤ 100 and is neither divisible by 2 nor by 3.
    return True
    #The program returns True
#Overall this is what the function does:The function accepts an integer `n` (where 3 ≤ n ≤ 100) and checks various conditions to determine if `n` is a prime number. It returns `False` if `n` is less than or equal to 1, if `n` is less than or equal to 3 (but greater than 1), or if `n` is divisible by 2 or 3. If `n` passes these checks, it further checks divisibility by numbers starting from 5, increasing by 6 each time, up to the square root of `n`. If `n` is found to be divisible by any of these numbers, it returns `False`. If all checks are passed, it returns `True`, indicating that `n` is a prime number. The function does not evaluate sequences `a`, `b`, and `c` as described in the annotations—this aspect is not implemented in the code.

#Function 18:
#State of the program right berfore the function call: t is an integer between 1 and 100 inclusive, n is an integer between 3 and 100 inclusive for each test case, and a, b, c are lists of integers of length n where each element is between 1 and 100 inclusive, and for all i (1 <= i <= n), a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function `func_18` does not accept any parameters directly but expects to read from a file named 'input.txt' and writes the output to a file named 'output.txt'. The expected input format is defined by the context, where `t` is an integer between 1 and 100, `n` is an integer between 3 and 100, and lists `a`, `b`, `c` must each contain `n` integers between 1 and 100, ensuring the elements of these lists are distinct at each index. However, the function does not process or validate this input data in any way, making it limited in functionality to simply handling file input/output.

#Function 19:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, and for each test case, n is an integer such that 3 ≤ n ≤ 100. The sequences a, b, and c are lists of integers where each list has n integers and for each index i (1 ≤ i ≤ n), a_i, b_i, and c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100, and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_19():
    for _ in range(func_1()):
        n = func_1()
        
        a = func_5()
        
        b = func_5()
        
        c = func_5()
        
        ans = [0] * n
        
        ans[0] = a[0]
        
        for i in range(1, n):
            if ans[i - 1] != a[i]:
                ans[i] = a[i]
            elif ans[i - 1] != b[i]:
                ans[i] = b[i]
            else:
                ans[i] = c[i]
        
        func_20(*ans)
        
    #State of the program after the  for loop has been executed: `t` is an integer such that 1 ≤ `t` ≤ 100; `n` is a positive integer; `ans` is a list of length `n` with values from `a`, `b`, and `c`, ensuring no two consecutive elements are the same; `func_20` has been called `t` times with the corresponding `ans` from each iteration.
#Overall this is what the function does:The function processes a series of test cases where for each test case it reads an integer `n` and three lists `a`, `b`, and `c`, each containing `n` integers. It constructs a new list `ans` where each element is taken from `a`, `b`, or `c`, ensuring that no two consecutive elements in `ans` are the same. The function then calls `func_20` with the constructed `ans` list for each test case. It does not accept parameters directly but relies on predefined input constraints.

#Function 20:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer for each test case such that 3 ≤ n ≤ 100, and a_i, b_i, c_i are integers for each i (1 ≤ i ≤ n) with 1 ≤ a_i, b_i, c_i ≤ 100, where a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `at_start` is False, `args` is a list of arguments, and the first element of `args` is written directly to the file without a separator, while all subsequent elements are written with a separator prepended.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`at_start` is False, `args` is a list of arguments, and a value (from `kwargs` or a newline) is written to the file. If the flush operation is performed, it indicates that `kwargs` had a key 'flush' with a value of True, or it is removed from `kwargs`.
#Overall this is what the function does:The function does not accept any parameters and prints provided arguments to a specified output stream, separating them with a defined separator. The first argument is printed without a separator, and it can append an optional ending string. If the 'flush' keyword argument is set to True, it flushes the output stream. The function does not handle any test case logic or constraints, as suggested by the annotations.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.