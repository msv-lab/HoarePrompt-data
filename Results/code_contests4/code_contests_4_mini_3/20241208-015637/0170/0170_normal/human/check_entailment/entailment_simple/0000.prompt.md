
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given three sequences: a_1, a_2, …, a_n; b_1, b_2, …, b_n; c_1, c_2, …, c_n.

For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.

Find a sequence p_1, p_2, …, p_n, that satisfy the following conditions:

  * p_i ∈ \\{a_i, b_i, c_i\}
  * p_i ≠ p_{(i mod n) + 1}.



In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements i,i+1 adjacent for i<n and also elements 1 and n) will have equal value.

It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.

Input

The first line of input contains one integer t (1 ≤ t ≤ 100): the number of test cases.

The first line of each test case contains one integer n (3 ≤ n ≤ 100): the number of elements in the given sequences.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 100).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ 100).

The fourth line contains n integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 100).

It is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.

Output

For each test case, print n integers: p_1, p_2, …, p_n (p_i ∈ \\{a_i, b_i, c_i\}, p_i ≠ p_{i mod n + 1}).

If there are several solutions, you can print any.

Example

Input


5
3
1 1 1
2 2 2
3 3 3
4
1 2 1 2
2 1 2 1
3 4 3 4
7
1 3 3 1 1 1 1
2 4 4 3 2 2 4
4 2 2 2 4 4 2
3
1 2 1
2 3 3
3 1 2
10
1 1 1 2 2 2 3 3 3 1
2 2 2 3 3 3 1 1 1 2
3 3 3 1 1 1 2 2 2 3


Output


1 2 3
1 2 1 2
1 3 4 3 2 4 2
1 3 2
1 2 3 1 2 3 1 2 3 2

Note

In the first test case p = [1, 2, 3].

It is a correct answer, because:

  * p_1 = 1 = a_1, p_2 = 2 = b_2, p_3 = 3 = c_3 
  * p_1 ≠ p_2 , p_2 ≠ p_3 , p_3 ≠ p_1 



All possible correct answers to this test case are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].

In the second test case p = [1, 2, 1, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = a_3, p_4 = a_4. Also we can see, that no two adjacent elements of the sequence are equal.

In the third test case p = [1, 3, 4, 3, 2, 4, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = b_3, p_4 = b_4, p_5 = b_5, p_6 = c_6, p_7 = c_7. Also we can see, that no two adjacent elements of the sequence are equal.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100 for each test case, a, b, and c are lists of integers of length n where each integer is in the range 1 ≤ a_i, b_i, c_i ≤ 100, and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_1():
    return int(input())
    #The program returns an integer input value from the user

#Function 2:
#State of the program right berfore the function call: t is an integer (1 ≤ t ≤ 100) representing the number of test cases; for each test case, n is an integer (3 ≤ n ≤ 100) representing the number of elements in the sequences; a_i, b_i, and c_i are integers (1 ≤ a_i, b_i, c_i ≤ 100) such that a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all i.
def func_2():
    return input()
    #The program returns the input data which includes the number of test cases t and the integer sequences a_i, b_i, and c_i for each test case, with the constraints that a_i, b_i, and c_i are distinct integers within the specified ranges.

#Function 3:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100; for each test case, n is an integer such that 3 ≤ n ≤ 100; a, b, and c are lists of n integers where each integer is in the range 1 to 100, and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a list of integers obtained from the input, which are space-separated values that are converted to integers. Each integer is within the range of 1 to 100.

#Function 4:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100 for each test case, and a, b, c are lists of integers of length n where each element a_i, b_i, c_i satisfies 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object that converts the input string of space-separated values into strings, after stripping any leading or trailing whitespace.

#Function 5:
#State of the program right berfore the function call: t is an integer (1 ≤ t ≤ 100), n is an integer (3 ≤ n ≤ 100) for each test case, and a_i, b_i, c_i are integers (1 ≤ a_i, b_i, c_i ≤ 100) such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i (1 ≤ i ≤ n).
def func_5():
    return list(func_3())
    #The program returns a list generated by the function func_3() based on the integers t, n, a_i, b_i, and c_i, which represent the constraints and conditions given.

#Function 6:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100; for each test case, n is an integer such that 3 ≤ n ≤ 100; a, b, and c are lists of integers of length n where each element is in the range 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a tuple containing three sequences of integers (a, b, c), where each sequence has n elements (3 ≤ n ≤ 100), and for each index i, a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i] with 1 ≤ a[i], b[i], c[i] ≤ 100. Additionally, the function is called for multiple test cases (1 ≤ t ≤ 100).
def func_7(item):
    return item[1]
    #The program returns the second sequence of integers 'b' from the tuple 'item' containing three sequences (a, b, c)

#Function 8:
#State of the program right berfore the function call: l is a list containing multiple test cases, where each test case consists of four lines: the first line is an integer n (3 ≤ n ≤ 100), the second line is a list of n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 100), the third line is a list of n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ 100), and the fourth line is a list of n integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 100). For all i in the range [0, n-1], a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list 'l' sorted in descending order based on the values determined by the function 'getKey'

#Function 9:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100, a, b, and c are lists of integers of length n, where each integer in the lists satisfies 1 ≤ a_i, b_i, c_i ≤ 100, and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of lists with dimensions n x m, where each inner list contains the same integer 'num' repeated m times. 'num' is not given in the initial state.

#Function 10:
#State of the program right berfore the function call: x is a list of tuples, where each tuple contains three sequences (a, b, c) of n integers, with 1 ≤ a_i, b_i, c_i ≤ 100, n is an integer such that 3 ≤ n ≤ 100, and it is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i. The number of test cases t is an integer such that 1 ≤ t ≤ 100.
def func_10(x):
    return x and not x & x - 1
    #The program returns the list of tuples x and the result of the bitwise operation 'not x & (x - 1)'

#Function 11:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 100), n is an integer (3 ≤ n ≤ 100), and a, b, c are lists of length n containing integers (1 ≤ a_i, b_i, c_i ≤ 100) where a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all valid i.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the integer n without the '0b' prefix.

#Function 12:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100; for each test case, there are three sequences of integers a, b, c of length n, where each element in a, b, and c is an integer in the range 1 to 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers representing each digit of the integer n, where n is between 3 and 100.

#Function 13:
#State of the program right berfore the function call: n is an integer in the range [3, 100], and r is a list of three sequences, where each sequence contains n integers in the range [1, 100] with the property that for each index i, a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of the binomial coefficient calculation based on the integer n in the range [3, 100] and the integer r, which is one of the sequences from the list of three sequences, using the formula factorial(n) // (factorial(r) * factorial(max(n - r, 1)))

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), and for each test case, y is a list of three tuples, each containing n integers (3 ≤ n ≤ 100) where the integers are in the range 1 to 100, and each tuple represents the sequences a, b, and c respectively, with the condition that no two integers in the same position of the tuples are equal.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer result of dividing x by y, where x is the number of test cases (1 ≤ x ≤ 100) and y is a list of three tuples of integers (3 ≤ n ≤ 100) that are all distinct in each position. Since x is divisible by y, the output will be a whole number.
    else :
        return x // y + 1
        #The program returns the integer result of x divided by y, plus 1, where x is the number of test cases (1 ≤ x ≤ 100) and y is a list containing three tuples of integers (3 ≤ n ≤ 100) that are not equal in the same position.

#Function 15:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), y is an integer representing the number of elements in the sequences (3 ≤ y ≤ 100), and p is a list of three lists, each containing y integers (1 ≤ p[i][j] ≤ 100) such that for each i (0 ≤ i < y), p[0][i] ≠ p[1][i], p[0][i] ≠ p[2][i], and p[1][i] ≠ p[2][i].
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the final value after repeatedly squaring and taking modulo `p`, `res` is the result of the exponentiation by squaring process based on the initial values of `x` and `y`, and `p` is a list of three lists.
    return res
    #The program returns the result of the exponentiation by squaring process based on the initial values of x and y

#Function 16:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100); for each test case, y is an integer representing the number of elements in the sequences (3 ≤ y ≤ 100), followed by three lists of integers a, b, and c of length y, where each integer in these lists (1 ≤ a_i, b_i, c_i ≤ 100) satisfies the condition that a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all i.
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the greatest common divisor (GCD) of the initial values of `x` and `y`.
    return x
    #The program returns the greatest common divisor (GCD) of the initial values of `x` and `y`, where `y` is 0. Therefore, the program returns `x`, which is the initial value of `x`.

#Function 17:
#State of the program right berfore the function call: n is an integer where 3 ≤ n ≤ 100. For each test case, there are three sequences of integers a, b, and c, each containing n integers where 1 ≤ a_i, b_i, c_i ≤ 100, and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i. There are t test cases where 1 ≤ t ≤ 100.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer where 3 ≤ `n` ≤ 100. For each test case, there are three sequences of integers `a`, `b`, and `c`, each containing `n` integers where 1 ≤ `a_i`, `b_i`, `c_i` ≤ 100, and for all `i`, `a_i ≠ b_i`, `a_i ≠ c_i`, `b_i ≠ c_i`. There are `t` test cases where 1 ≤ `t` ≤ 100, and `n` is greater than 1.
    if (n <= 3) :
        return True
        #The program returns True indicating that the conditions for n, a, b, and c are satisfied.
    #State of the program after the if block has been executed: *`n` is an integer where 3 < `n` ≤ 100. For each test case, there are three sequences of integers `a`, `b`, and `c`, each containing `n` integers where 1 ≤ `a_i`, `b_i`, `c_i` ≤ 100, and for all `i`, `a_i ≠ b_i`, `a_i ≠ c_i`, `b_i ≠ c_i`. There are `t` test cases where 1 ≤ `t` ≤ 100, and `n` is greater than 3.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False, indicating a condition that is not satisfied within the given constraints.
    #State of the program after the if block has been executed: *`n` is an integer where 3 < `n` ≤ 100, and `n` is neither divisible by 2 nor by 3. For each test case, there are three sequences of integers `a`, `b`, and `c`, each containing `n` integers where 1 ≤ `a_i`, `b_i`, `c_i` ≤ 100, and for all `i`, `a_i ≠ b_i`, `a_i ≠ c_i`, `b_i ≠ c_i`. There are `t` test cases where 1 ≤ `t` ≤ 100, and `n` is greater than 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `i` is greater than or equal to 5 and is the smallest integer greater than or equal to the square root of `n`; `n` remains an integer where 3 < `n` ≤ 100 and is neither divisible by 2 nor by 3.
    return True
    #The program returns True

#Function 18:
#State of the program right berfore the function call: t is an integer between 1 and 100 inclusive, n is an integer between 3 and 100 inclusive for each test case, and a, b, c are lists of integers of length n where each element is between 1 and 100 inclusive, and for all i (1 <= i <= n), a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, and for each test case, n is an integer such that 3 ≤ n ≤ 100. The sequences a, b, and c are lists of integers where each list has n integers and for each index i (1 ≤ i ≤ n), a_i, b_i, and c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100, and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_19():
    for _ in range(func_1()):
        n = func_1()
        
        a = func_5()
        
        b = func_5()
        
        c = func_5()
        
        ans = [0] * n
        
        ans[0] = a[0]
        
        for i in range(1, n):
            if ans[i - 1] != a[i]:
                ans[i] = a[i]
            elif ans[i - 1] != b[i]:
                ans[i] = b[i]
            else:
                ans[i] = c[i]
        
        func_20(*ans)
        
    #State of the program after the  for loop has been executed: `t` is an integer such that 1 ≤ `t` ≤ 100; `n` is a positive integer; `ans` is a list of length `n` with values from `a`, `b`, and `c`, ensuring no two consecutive elements are the same; `func_20` has been called `t` times with the corresponding `ans` from each iteration.

#Function 20:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer for each test case such that 3 ≤ n ≤ 100, and a_i, b_i, c_i are integers for each i (1 ≤ i ≤ n) with 1 ≤ a_i, b_i, c_i ≤ 100, where a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `at_start` is False, `args` is a list of arguments, and the first element of `args` is written directly to the file without a separator, while all subsequent elements are written with a separator prepended.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`at_start` is False, `args` is a list of arguments, and a value (from `kwargs` or a newline) is written to the file. If the flush operation is performed, it indicates that `kwargs` had a key 'flush' with a value of True, or it is removed from `kwargs`.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
