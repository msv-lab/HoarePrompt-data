
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Everybody knows what an arithmetic progression is. Let us remind you just in case that an arithmetic progression is such sequence of numbers a1, a2, ..., an of length n, that the following condition fulfills: 

a2 - a1 = a3 - a2 = a4 - a3 = ... = ai + 1 - ai = ... = an - an - 1.

For example, sequences [1, 5], [10], [5, 4, 3] are arithmetic progressions and sequences [1, 3, 2], [1, 2, 4] are not.

Alexander has n cards containing integers. Arthur wants to give Alexander exactly one more card with a number so that he could use the resulting n + 1 cards to make an arithmetic progression (Alexander has to use all of his cards).

Arthur has already bought a card but he hasn't written a number on it. Help him, print all integers that you can write on a card so that the described condition fulfilled.

Input

The first line contains integer n (1 ≤ n ≤ 105) — the number of cards. The next line contains the sequence of integers — the numbers on Alexander's cards. The numbers are positive integers, each of them doesn't exceed 108.

Output

If Arthur can write infinitely many distinct integers on the card, print on a single line -1.

Otherwise, print on the first line the number of integers that suit you. In the second line, print the numbers in the increasing order. Note that the numbers in the answer can exceed 108 or even be negative (see test samples).

Examples

Input

3
4 1 7


Output

2
-2 10


Input

1
10


Output

-1


Input

4
1 3 5 9


Output

1
7


Input

4
4 3 4 5


Output

0


Input

2
2 4


Output

3
0 3 6
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers where each integer does not exceed 10^8.
def func_1():
    return int(input())
    #The program returns a positive integer input by the user, which is less than or equal to 10^8
#Overall this is what the function does:The function does not accept any parameters and returns a positive integer input by the user. However, it does not enforce any upper limit on the input, meaning the user can potentially input a value greater than 10^8, which contradicts the annotations. The function simply reads the input and converts it to an integer.

#Function 2:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_2():
    return input()
    #The program returns the input sequence of integers from Alexander's cards, which is a list of positive integers each not exceeding 10^8.
#Overall this is what the function does:The function does not accept any parameters and returns the input sequence as a string. The string may represent a list of positive integers, each not exceeding 10^8, but it does not guarantee that the input is parsed or validated as a list of integers.

#Function 3:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing the sequence of integers from input, which is a list of positive integers, each not exceeding 10^8.
#Overall this is what the function does:The function accepts no parameters and reads a line of input from the user, returning a map object that contains the sequence of positive integers from that input, where each integer is converted to an integer type. The integers must follow the constraints that they are positive and do not exceed 10^8. However, if the input does not adhere to these constraints or if it is empty, the function will not handle those cases explicitly, leading to potential errors when processing the map object.

#Function 4:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object that converts the sequence of integers from Alexander's cards into strings
#Overall this is what the function does:The function accepts no parameters and returns a map object that converts a sequence of space-separated integers read from input into strings. It does not handle any invalid input cases, such as non-integer values or empty input, which could lead to unexpected behavior.

#Function 5:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5) representing the number of cards, and the sequence of integers on the cards consists of positive integers that do not exceed 10^8.
def func_5():
    return list(func_3())
    #The program returns a list generated by the function func_3(), which processes the sequence of positive integers on the cards, where n is a positive integer (1 ≤ n ≤ 10^5) and the integers do not exceed 10^8.
#Overall this is what the function does:The function accepts no parameters and returns a list generated by the function `func_3()`, which processes a sequence of positive integers on cards, where the number of cards, `n`, is a positive integer between 1 and 100,000, and the integers on the cards do not exceed 100,000,000. The behavior of `func_3()` is not defined here, so any specific details about the processing of the integers are not included in this summary.

#Function 6:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function initializes a new thread to execute the `main` function, but does not accept any parameters or return a value. It sets a high recursion limit and stack size, which may allow for deep recursion or large stack frames if the `main` function requires it, but the specific behavior of `main` is not defined in the provided code.

#Function 7:
#State of the program right berfore the function call: item is a tuple containing an integer n (1 ≤ n ≤ 10^5) followed by n positive integers, each not exceeding 10^8.
def func_7(item):
    return item[1]
    #The program returns the first positive integer from the tuple 'item' which follows the integer n
#Overall this is what the function does:The function accepts a tuple `item`, where the first element is an integer `n` (1 ≤ n ≤ 10^5) followed by `n` positive integers. It returns the first positive integer from the tuple that follows `n`. If `n` is 1, it will return the only positive integer present in the tuple; however, if `n` is greater than 1, it will return the second element in the tuple. The function does not check for the validity of the input regarding the specified constraints.

#Function 8:
#State of the program right berfore the function call: l is a list of integers where the first element is a positive integer n (1 ≤ n ≤ 10^5) representing the number of cards, followed by n positive integers, each not exceeding 10^8.
def func_8(l):
    return sorted(l, key=getKey)
    #The program returns the sorted list 'l' based on the key provided by the function getKey, where 'l' consists of integers with the first element being the number of cards followed by n positive integers.
#Overall this is what the function does:The function accepts a list of integers `l`, where the first element represents the number of cards followed by `n` positive integers. It returns the sorted version of the list `l` based on a specified sorting key provided by the function `getKey`. There are no checks for the validity of the input list, meaning if the first element does not accurately reflect the number of subsequent integers, the sorting may not behave as expected.

#Function 9:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), m is a list of integers containing n positive integers, each not exceeding 10^8.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of n lists, each containing the integer m repeated n times, where n is a positive integer (1 ≤ n ≤ 10^5) and m is a list of n positive integers, each not exceeding 10^8.
#Overall this is what the function does:The function accepts a positive integer `n` and a list `m` of positive integers. It returns a list containing `n` lists, where each inner list contains the integer `num` repeated `m` times. The value of `m` is not utilized as a list to determine the count of repetitions; instead, the function always repeats `num` for `m` times given by the argument, which may lead to confusion regarding its intended functionality based on the annotations.

#Function 10:
#State of the program right berfore the function call: x is a list of integers representing the numbers on Alexander's cards, and the length of x is a positive integer n such that 1 ≤ n ≤ 10^5. All integers in x are positive and do not exceed 10^8.
def func_10(x):
    return x and not x & x - 1
    #The program returns the list of integers on Alexander's cards, x, and the result of the bitwise operation 'not x & (x - 1)'
#Overall this is what the function does:The function accepts a list of positive integers `x` and evaluates the expression `not x and x & (x - 1)`. It returns a boolean value indicating whether the list `x` is empty (by returning `True` if it is empty) or if it contains exactly one unique element (by returning `True` if all elements in `x` are the same and non-zero). If `x` contains more than one unique element, it returns `False`. Therefore, the function does not return the list `x` as indicated in the annotations.

#Function 11:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards consists of positive integers, each not exceeding 10^8.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the integer n, without the '0b' prefix, which is a string of '0's and '1's corresponding to the binary form of n.
#Overall this is what the function does:The function accepts an integer `n` where 1 ≤ n ≤ 10^5 and returns the binary representation of `n` as a string without the '0b' prefix. The function correctly handles valid inputs within the specified range and does not account for any inputs outside this range or any non-integer types, but the input constraints ensure that `n` will always be a positive integer.

#Function 12:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and the sequence of integers consists of positive integers, each not exceeding 10^8.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers representing the digits of the integer n, where n is between 1 and 100,000.
#Overall this is what the function does:The function accepts an integer `n` (where 1 ≤ n ≤ 100,000) and returns a list of integers representing the individual digits of `n`. It does not handle any edge cases outside this specified range, as it assumes that `n` will always be a valid integer within the defined limits.

#Function 13:
#State of the program right berfore the function call: x is an integer representing the number of cards (1 ≤ x ≤ 10^5), y is a list of integers containing the numbers on the cards (each positive integer does not exceed 10^8), and p is an integer that denotes the position in the sequence.
def func_13(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `x` is updated to `x * x % p` for each iteration, and `res` contains the final result based on the contributions of `x` from all iterations where the least significant bit of the elements of `y` was 1.
    return res
    #The program returns the final result contained in 'res' based on the contributions of 'x' from all iterations where the least significant bit of 'y' was 1.
#Overall this is what the function does:The function accepts an integer `x`, a positive integer `y`, and an integer `p`. It calculates the result of exponentiation by squaring, effectively computing `(x^y) % p`. The function will return the final result contained in `res`, which is determined by iterating through the bits of `y` and multiplying `res` by `x` whenever the least significant bit is 1. Note that `y` is treated as a single integer rather than a list, which contradicts the annotations claiming `y` is a list of integers. The function does not handle cases where `p` is zero, which could lead to a division by zero error in modular arithmetic.

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of cards (1 ≤ x ≤ 10^5), and y is a list of positive integers, the numbers on Alexander's cards, each not exceeding 10^8.
def func_14(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is an empty list, `x` is the last value of `y` before it became empty.
    return x
    #The program returns the last value of 'y' before it became empty, which is the value x.
#Overall this is what the function does:The function accepts an integer `x` and a list `y` of positive integers. It repeatedly updates `x` with the last element of `y` and updates `y` with the result of `x % y`, until `y` becomes empty. The function then returns the last value of `y` before it became empty, which may not accurately reflect the initial value of `x`. This implementation does not handle the case where `y` starts as an empty list, which would lead to an error. Thus, if `y` is empty upon function call, a runtime error will occur instead of returning a value.

#Function 15:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the input sequence consists of n positive integers, each not exceeding 10^8.
def func_15(n):
    if (n <= 1) :
        return False
        #The program returns False, indicating that the condition is not met for the input sequence of positive integers.
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5, and the input sequence consists of `n` positive integers, each not exceeding 10^8. `n` is greater than 1.
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5, and the input sequence consists of `n` positive integers, each not exceeding 10^8. `n` is greater than 3.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5, and `n` is greater than 3. The value of `n` is neither divisible by 2 nor by 3. The input sequence consists of `n` positive integers, each not exceeding 10^8.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is a positive integer such that 25 ≤ `n` ≤ 10^5; `i` is the smallest integer such that `i * i` is greater than `n`, and has been incremented from 5 by 6 until the loop condition failed.
    return True
    #The program returns True
#Overall this is what the function does:The function accepts a positive integer `n` and determines if `n` is a prime number. It returns False if `n` is less than or equal to 1, returns True if `n` is 2 or 3, returns False if `n` is divisible by 2 or 3, and uses trial division to check for factors of `n` starting from 5, incrementing by 6, until the square root of `n` is reached. If no factors are found, it returns True. Thus, the function accurately identifies prime numbers and handles edge cases correctly.

#Function 16:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_16():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function `func_16` does not accept any parameters and redirects standard input to read from a file named 'input.txt' and standard output to write to a file named 'output.txt'. It operates on a sequence of positive integers, but there is no logic implemented for processing these integers or returning any results. Therefore, the function's functionality is limited to setting up file redirection without performing any computations or returning values.

#Function 17:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards contains positive integers, each not exceeding 10^8.
def func_17():
    n = func_1()
    a = func_5()
    a.sort()
    if (n == 1) :
        func_18(-1)
        exit()
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5 and `a` is sorted in ascending order. If `n` is equal to 1, the function `func_18` is called with the argument -1. There is no action taken if `n` is greater than 1.
    if (n == 2) :
        if (a[0] == a[1]) :
            func_18(1)
            func_18(a[0])
            exit()
        #State of the program after the if block has been executed: *`n` is a positive integer such that `n` is equal to 2 and 1 ≤ `n` ≤ 10^5; `a` is sorted in ascending order. If the first two elements of `a` are equal, the function `func_18` is called with the argument `a[0]`, and the program exits. If `n` is equal to 1, the function `func_18` is called with the argument -1, and no action is taken if `n` is greater than 1.
        l = []
        g = a[1] - a[0]
        if (abs(g) % 2 == 0) :
            l.append(a[0] + g // 2)
        #State of the program after the if block has been executed: *`n` is a positive integer equal to 2, `a` is sorted in ascending order, and `g` is equal to `a[1] - a[0]`. If the absolute value of `g` is an even number, then the list `l` contains one element: `a[0] + g // 2`.
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[1] + (a[1] - a[0]))
        l.sort()
        l = list(set(l))
        func_18(len(l))
        func_18(*l)
        exit()
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5 and `a` is sorted in ascending order. If `n` is 2, `func_18` is called with the unpacked values of `l`, and the program exits. If `n` is equal to 1, `func_18` is called with the argument -1. If `n` is greater than 2, no action is taken.
    g = []
    l = []
    for i in range(n - 1):
        g.append(a[i + 1] - a[i])
        
        l.append(abs(a[i + 1] - a[i]))
        
    #State of the program after the  for loop has been executed: `n` is a positive integer such that 1 ≤ `n` ≤ 10^5; `a` is sorted in ascending order; `g` contains `n - 1` elements representing the differences between consecutive elements of `a`; `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`.
    if (len(list(set(g))) > 2) :
        func_18(0)
        exit()
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5; `a` is sorted in ascending order; `g` contains `n - 1` elements representing the differences between consecutive elements of `a`; `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`. If the number of unique elements in `g` is greater than 2, `func_18` is called with argument 0 and the program exits. Otherwise, the program continues executing without calling `func_18`.
    if (len(list(set(g))) == 1) :
        l = []
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[-1] + (a[1] - a[0]))
        l = list(set(l))
        l.sort()
        func_18(len(l))
        func_18(*l)
    else :
        if (0 in l) :
            if (len(list(set(g))) >= 2) :
                func_18(0)
                exit()
            #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5; `a` is sorted in ascending order; `g` contains `n - 1` elements representing the differences between consecutive elements of `a`; `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`; the number of unique elements in `g` is not equal to 1; there exists at least one element in `l` that is equal to 0; if the number of unique elements in `g` is at least 2, the program exits without any changes.
        #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5; `a` is sorted in ascending order; `g` contains `n - 1` elements representing the differences between consecutive elements of `a`; `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`; the number of unique elements in `g` is not equal to 1. If there exists at least one element in `l` that is equal to 0, the program exits without any changes.
        gc = l[0]
        for i in range(1, len(l)):
            gc = func_14(gc, l[i])
            
        #State of the program after the  for loop has been executed: `gc` is assigned the value returned by `func_14` applied cumulatively to all elements of `l` starting from `l[1]`, and `l` is a list with at least one element after `l[0]`.
        for i in range(n - 1):
            if abs(a[i + 1] - a[i]) != gc:
                x = a[i] + (a[i + 1] - a[i]) // 2
                a.append(a[i] + (a[i + 1] - a[i]) // 2)
                break
            
        #State of the program after the  for loop has been executed: `gc` is the cumulative value returned by `func_14` applied to all elements of `l` starting from `l[1]`, `n` is at least 2, `a` contains all original elements plus any additional elements added during the iterations, and `x` is the last calculated value if the loop executed at least once. If the loop did not execute, `a` remains unchanged and contains the original elements.
        a.sort()
        l = []
        for i in range(n):
            l.append(a[i + 1] - a[i])
            
        #State of the program after the  for loop has been executed: `gc` is the cumulative value returned by `func_14` applied to all elements of `l` starting from `l[1]`, `n` is at least 2, `x` is the last calculated value, and `l` contains `n` elements which are the differences between consecutive elements of `a`.
        if (len(list(set(l))) == 1) :
            func_18(1)
            func_18(x)
        else :
            func_18(0)
        #State of the program after the if-else block has been executed: *`gc` is the cumulative value returned by `func_14` applied to all elements of `l` starting from `l[1]`, `n` is at least 2, `x` is the last calculated value, and `l` contains `n` elements which are the differences between consecutive elements of `a`. If all elements of `l` are the same, `func_18(1)` is called and the function is executed with the value of `x`. Otherwise, `func_18(0)` is called but does not modify any values or return anything.
    #State of the program after the if-else block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5; `a` is sorted in ascending order; `g` contains `n - 1` elements representing the differences between consecutive elements of `a` with only one unique value; `l` is sorted; `func_18` has been called with the length of `l`. If there is only one unique value in `g`, the function will have called `func_18` with the length of `l`. If there are multiple unique values in `g`, then `gc` is the cumulative value returned by `func_14` applied to all elements of `l` starting from `l[1]`, `n` is at least 2, `x` is the last calculated value, and `l` contains `n` elements which are the differences between consecutive elements of `a`. If all elements of `l` are the same, `func_18(1)` is called and the function is executed with the value of `x`. Otherwise, `func_18(0)` is called but does not modify any values or return anything.
#Overall this is what the function does:The function accepts no parameters and processes a sequence of positive integers. It first checks the count of integers; if there is only one integer, it calls `func_18` with -1 and exits. If there are two integers, it checks for equality and performs calculations based on their difference. If more than two integers are present, it computes the differences between consecutive integers. It returns results through multiple calls to `func_18`, including the count of unique differences, specific calculated values, or exits with zero based on the conditions met. If the differences are not uniform, the function may add a new integer to the list, which could influence the subsequent checks. If all conditions are met, it will either call `func_18` with the number of unique values or zero, depending on the uniformity of the differences.

#Function 18:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 100000, and the sequence of integers on Alexander's cards consists of positive integers, each not exceeding 10^8.
def func_18():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `n` is an integer such that 1 ≤ `n` ≤ 100000, `sep` is either a specified separator or ' ', `file` is either a specified file or `sys.stdout`, `at_start` is False, `args` is a non-empty iterable with at least `n` elements, and all elements of `args` have been written to `file` as strings separated by `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`n` is an integer such that 1 ≤ `n` ≤ 100000, `sep` is either a specified separator or ' ', `file` is either a specified file or `sys.stdout`, `at_start` is False, `args` is a non-empty iterable with at least `n` elements, and all elements of `args` have been written to `file` as strings separated by `sep`. A value has been written to `file` from `kwargs` or a newline character has been written if `end` was not present in `kwargs`. If the `flush` option in `kwargs` is True, the file's output buffer has been flushed. Otherwise, the output buffer remains unchanged.
#Overall this is what the function does:The function accepts a variable number of arguments, where `n` is an integer indicating the number of arguments (1 ≤ n ≤ 100000). It writes these arguments to a specified output stream, separated by a specified separator (defaulting to a space), and ends the output with a specified end character (defaulting to a newline). If the flush option is set to True, it flushes the output buffer. The function does not return any value.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.