
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Everybody knows what an arithmetic progression is. Let us remind you just in case that an arithmetic progression is such sequence of numbers a1, a2, ..., an of length n, that the following condition fulfills: 

a2 - a1 = a3 - a2 = a4 - a3 = ... = ai + 1 - ai = ... = an - an - 1.

For example, sequences [1, 5], [10], [5, 4, 3] are arithmetic progressions and sequences [1, 3, 2], [1, 2, 4] are not.

Alexander has n cards containing integers. Arthur wants to give Alexander exactly one more card with a number so that he could use the resulting n + 1 cards to make an arithmetic progression (Alexander has to use all of his cards).

Arthur has already bought a card but he hasn't written a number on it. Help him, print all integers that you can write on a card so that the described condition fulfilled.

Input

The first line contains integer n (1 ≤ n ≤ 105) — the number of cards. The next line contains the sequence of integers — the numbers on Alexander's cards. The numbers are positive integers, each of them doesn't exceed 108.

Output

If Arthur can write infinitely many distinct integers on the card, print on a single line -1.

Otherwise, print on the first line the number of integers that suit you. In the second line, print the numbers in the increasing order. Note that the numbers in the answer can exceed 108 or even be negative (see test samples).

Examples

Input

3
4 1 7


Output

2
-2 10


Input

1
10


Output

-1


Input

4
1 3 5 9


Output

1
7


Input

4
4 3 4 5


Output

0


Input

2
2 4


Output

3
0 3 6
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers where each integer does not exceed 10^8.
def func_1():
    return int(input())
    #The program returns a positive integer input by the user, which is less than or equal to 10^8

#Function 2:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_2():
    return input()
    #The program returns the input sequence of integers from Alexander's cards, which is a list of positive integers each not exceeding 10^8.

#Function 3:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing the sequence of integers from input, which is a list of positive integers, each not exceeding 10^8.

#Function 4:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object that converts the sequence of integers from Alexander's cards into strings

#Function 5:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5) representing the number of cards, and the sequence of integers on the cards consists of positive integers that do not exceed 10^8.
def func_5():
    return list(func_3())
    #The program returns a list generated by the function func_3(), which processes the sequence of positive integers on the cards, where n is a positive integer (1 ≤ n ≤ 10^5) and the integers do not exceed 10^8.

#Function 6:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a tuple containing an integer n (1 ≤ n ≤ 10^5) followed by n positive integers, each not exceeding 10^8.
def func_7(item):
    return item[1]
    #The program returns the first positive integer from the tuple 'item' which follows the integer n

#Function 8:
#State of the program right berfore the function call: l is a list of integers where the first element is a positive integer n (1 ≤ n ≤ 10^5) representing the number of cards, followed by n positive integers, each not exceeding 10^8.
def func_8(l):
    return sorted(l, key=getKey)
    #The program returns the sorted list 'l' based on the key provided by the function getKey, where 'l' consists of integers with the first element being the number of cards followed by n positive integers.

#Function 9:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), m is a list of integers containing n positive integers, each not exceeding 10^8.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of n lists, each containing the integer m repeated n times, where n is a positive integer (1 ≤ n ≤ 10^5) and m is a list of n positive integers, each not exceeding 10^8.

#Function 10:
#State of the program right berfore the function call: x is a list of integers representing the numbers on Alexander's cards, and the length of x is a positive integer n such that 1 ≤ n ≤ 10^5. All integers in x are positive and do not exceed 10^8.
def func_10(x):
    return x and not x & x - 1
    #The program returns the list of integers on Alexander's cards, x, and the result of the bitwise operation 'not x & (x - 1)'

#Function 11:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards consists of positive integers, each not exceeding 10^8.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the integer n, without the '0b' prefix, which is a string of '0's and '1's corresponding to the binary form of n.

#Function 12:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and the sequence of integers consists of positive integers, each not exceeding 10^8.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers representing the digits of the integer n, where n is between 1 and 100,000.

#Function 13:
#State of the program right berfore the function call: x is an integer representing the number of cards (1 ≤ x ≤ 10^5), y is a list of integers containing the numbers on the cards (each positive integer does not exceed 10^8), and p is an integer that denotes the position in the sequence.
def func_13(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `x` is updated to `x * x % p` for each iteration, and `res` contains the final result based on the contributions of `x` from all iterations where the least significant bit of the elements of `y` was 1.
    return res
    #The program returns the final result contained in 'res' based on the contributions of 'x' from all iterations where the least significant bit of 'y' was 1.

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of cards (1 ≤ x ≤ 10^5), and y is a list of positive integers, the numbers on Alexander's cards, each not exceeding 10^8.
def func_14(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is an empty list, `x` is the last value of `y` before it became empty.
    return x
    #The program returns the last value of 'y' before it became empty, which is the value x.

#Function 15:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the input sequence consists of n positive integers, each not exceeding 10^8.
def func_15(n):
    if (n <= 1) :
        return False
        #The program returns False, indicating that the condition is not met for the input sequence of positive integers.
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5, and the input sequence consists of `n` positive integers, each not exceeding 10^8. `n` is greater than 1.
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5, and the input sequence consists of `n` positive integers, each not exceeding 10^8. `n` is greater than 3.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5, and `n` is greater than 3. The value of `n` is neither divisible by 2 nor by 3. The input sequence consists of `n` positive integers, each not exceeding 10^8.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is a positive integer such that 25 ≤ `n` ≤ 10^5; `i` is the smallest integer such that `i * i` is greater than `n`, and has been incremented from 5 by 6 until the loop condition failed.
    return True
    #The program returns True

#Function 16:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_16():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 17:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards contains positive integers, each not exceeding 10^8.
def func_17():
    n = func_1()
    a = func_5()
    a.sort()
    if (n == 1) :
        func_18(-1)
        exit()
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5 and `a` is sorted in ascending order. If `n` is equal to 1, the function `func_18` is called with the argument -1. There is no action taken if `n` is greater than 1.
    if (n == 2) :
        if (a[0] == a[1]) :
            func_18(1)
            func_18(a[0])
            exit()
        #State of the program after the if block has been executed: *`n` is a positive integer such that `n` is equal to 2 and 1 ≤ `n` ≤ 10^5; `a` is sorted in ascending order. If the first two elements of `a` are equal, the function `func_18` is called with the argument `a[0]`, and the program exits. If `n` is equal to 1, the function `func_18` is called with the argument -1, and no action is taken if `n` is greater than 1.
        l = []
        g = a[1] - a[0]
        if (abs(g) % 2 == 0) :
            l.append(a[0] + g // 2)
        #State of the program after the if block has been executed: *`n` is a positive integer equal to 2, `a` is sorted in ascending order, and `g` is equal to `a[1] - a[0]`. If the absolute value of `g` is an even number, then the list `l` contains one element: `a[0] + g // 2`.
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[1] + (a[1] - a[0]))
        l.sort()
        l = list(set(l))
        func_18(len(l))
        func_18(*l)
        exit()
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5 and `a` is sorted in ascending order. If `n` is 2, `func_18` is called with the unpacked values of `l`, and the program exits. If `n` is equal to 1, `func_18` is called with the argument -1. If `n` is greater than 2, no action is taken.
    g = []
    l = []
    for i in range(n - 1):
        g.append(a[i + 1] - a[i])
        
        l.append(abs(a[i + 1] - a[i]))
        
    #State of the program after the  for loop has been executed: `n` is a positive integer such that 1 ≤ `n` ≤ 10^5; `a` is sorted in ascending order; `g` contains `n - 1` elements representing the differences between consecutive elements of `a`; `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`.
    if (len(list(set(g))) > 2) :
        func_18(0)
        exit()
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5; `a` is sorted in ascending order; `g` contains `n - 1` elements representing the differences between consecutive elements of `a`; `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`. If the number of unique elements in `g` is greater than 2, `func_18` is called with argument 0 and the program exits. Otherwise, the program continues executing without calling `func_18`.
    if (len(list(set(g))) == 1) :
        l = []
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[-1] + (a[1] - a[0]))
        l = list(set(l))
        l.sort()
        func_18(len(l))
        func_18(*l)
    else :
        if (0 in l) :
            if (len(list(set(g))) >= 2) :
                func_18(0)
                exit()
            #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5; `a` is sorted in ascending order; `g` contains `n - 1` elements representing the differences between consecutive elements of `a`; `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`; the number of unique elements in `g` is not equal to 1; there exists at least one element in `l` that is equal to 0; if the number of unique elements in `g` is at least 2, the program exits without any changes.
        #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5; `a` is sorted in ascending order; `g` contains `n - 1` elements representing the differences between consecutive elements of `a`; `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`; the number of unique elements in `g` is not equal to 1. If there exists at least one element in `l` that is equal to 0, the program exits without any changes.
        gc = l[0]
        for i in range(1, len(l)):
            gc = func_14(gc, l[i])
            
        #State of the program after the  for loop has been executed: `gc` is assigned the value returned by `func_14` applied cumulatively to all elements of `l` starting from `l[1]`, and `l` is a list with at least one element after `l[0]`.
        for i in range(n - 1):
            if abs(a[i + 1] - a[i]) != gc:
                x = a[i] + (a[i + 1] - a[i]) // 2
                a.append(a[i] + (a[i + 1] - a[i]) // 2)
                break
            
        #State of the program after the  for loop has been executed: `gc` is the cumulative value returned by `func_14` applied to all elements of `l` starting from `l[1]`, `n` is at least 2, `a` contains all original elements plus any additional elements added during the iterations, and `x` is the last calculated value if the loop executed at least once. If the loop did not execute, `a` remains unchanged and contains the original elements.
        a.sort()
        l = []
        for i in range(n):
            l.append(a[i + 1] - a[i])
            
        #State of the program after the  for loop has been executed: `gc` is the cumulative value returned by `func_14` applied to all elements of `l` starting from `l[1]`, `n` is at least 2, `x` is the last calculated value, and `l` contains `n` elements which are the differences between consecutive elements of `a`.
        if (len(list(set(l))) == 1) :
            func_18(1)
            func_18(x)
        else :
            func_18(0)
        #State of the program after the if-else block has been executed: *`gc` is the cumulative value returned by `func_14` applied to all elements of `l` starting from `l[1]`, `n` is at least 2, `x` is the last calculated value, and `l` contains `n` elements which are the differences between consecutive elements of `a`. If all elements of `l` are the same, `func_18(1)` is called and the function is executed with the value of `x`. Otherwise, `func_18(0)` is called but does not modify any values or return anything.
    #State of the program after the if-else block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 10^5; `a` is sorted in ascending order; `g` contains `n - 1` elements representing the differences between consecutive elements of `a` with only one unique value; `l` is sorted; `func_18` has been called with the length of `l`. If there is only one unique value in `g`, the function will have called `func_18` with the length of `l`. If there are multiple unique values in `g`, then `gc` is the cumulative value returned by `func_14` applied to all elements of `l` starting from `l[1]`, `n` is at least 2, `x` is the last calculated value, and `l` contains `n` elements which are the differences between consecutive elements of `a`. If all elements of `l` are the same, `func_18(1)` is called and the function is executed with the value of `x`. Otherwise, `func_18(0)` is called but does not modify any values or return anything.

#Function 18:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 100000, and the sequence of integers on Alexander's cards consists of positive integers, each not exceeding 10^8.
def func_18():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `n` is an integer such that 1 ≤ `n` ≤ 100000, `sep` is either a specified separator or ' ', `file` is either a specified file or `sys.stdout`, `at_start` is False, `args` is a non-empty iterable with at least `n` elements, and all elements of `args` have been written to `file` as strings separated by `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`n` is an integer such that 1 ≤ `n` ≤ 100000, `sep` is either a specified separator or ' ', `file` is either a specified file or `sys.stdout`, `at_start` is False, `args` is a non-empty iterable with at least `n` elements, and all elements of `args` have been written to `file` as strings separated by `sep`. A value has been written to `file` from `kwargs` or a newline character has been written if `end` was not present in `kwargs`. If the `flush` option in `kwargs` is True, the file's output buffer has been flushed. Otherwise, the output buffer remains unchanged.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
