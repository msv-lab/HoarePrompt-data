
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Ujan has a lot of useless stuff in his drawers, a considerable part of which are his math notebooks: it is time to sort them out. This time he found an old dusty graph theory notebook with a description of a graph.

It is an undirected weighted graph on n vertices. It is a complete graph: each pair of vertices is connected by an edge. The weight of each edge is either 0 or 1; exactly m edges have weight 1, and all others have weight 0.

Since Ujan doesn't really want to organize his notes, he decided to find the weight of the minimum spanning tree of the graph. (The weight of a spanning tree is the sum of all its edges.) Can you find the answer for Ujan so he stops procrastinating?

Input

The first line of the input contains two integers n and m (1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5)), the number of vertices and the number of edges of weight 1 in the graph. 

The i-th of the next m lines contains two integers a_i and b_i (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i), the endpoints of the i-th edge of weight 1.

It is guaranteed that no edge appears twice in the input.

Output

Output a single integer, the weight of the minimum spanning tree of the graph.

Examples

Input


6 11
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6


Output


2


Input


3 0


Output


0

Note

The graph from the first sample is shown below. Dashed edges have weight 0, other edges have weight 1. One of the minimum spanning trees is highlighted in orange and has total weight 2.

<image>

In the second sample, all edges have weight 0 so any spanning tree has total weight 0.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n is an integer representing the number of vertices in the graph (1 ≤ n ≤ 10^5), m is an integer representing the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/(2),10^5)), and for each of the m edges, a_i and b_i are integers (1 ≤ a_i, b_i ≤ n) representing the endpoints of the edge, with a_i ≠ b_i.
def func_1():
    n, m = func_4()
    p = list(range(n))
    r = func_7(int, n)
    sg = func_7(set, n)
    for _ in range(m):
        x, y = func_5(-1)
        
        sg[x].add(y)
        
        sg[y].add(x)
        
    #State of the program after the  for loop has been executed: `n` is an integer, `m` is the number of edges added, `p` is a list containing integers from 0 to `n-1`, `sg` is a list of sets where each set contains the vertices connected by edges, reflecting all connections established from the loop's executions.
    v = min(range(n), key=lambda i: len(sg[i]))
    for i in range(n):
        if i not in sg[v]:
            union(i, v)
        else:
            for j in range(n):
                if j not in sg[i]:
                    union(i, j)
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `sg` contains the updated connections based on the union operations, `v` is the index of the vertex with the minimum number of connections in the modified `sg`.
    roots = set()
    for i in range(n):
        roots.add(find(i))
        
    #State of the program after the  for loop has been executed: `roots` is a set containing the unique results of `find(i)` for all integers `i` from 0 to `n-1`, `n` is a non-negative integer.
    print(len(roots) - 1)

#Function 2:
#State of the program right berfore the function call: n is a positive integer representing the number of vertices in the graph (1 ≤ n ≤ 10^5), m is a non-negative integer representing the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/(2),10^5)), and the input consists of m pairs of integers (a_i, b_i) where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i, indicating the endpoints of edges with weight 1.
def find(v):
    vc = v
    while v != p[v]:
        v = p[v]
        
    #State of the program after the loop has been executed: `n` is a positive integer, `m` is a non-negative integer, `v` is equal to the value that p points to for the original value of `v` such that `v` is now equal to a representative or root in the structure defined by `p`, and `p[v]` is equal to `v`.
    while vc != v:
        p[vc], vc = v, p[vc]
        
    #State of the program after the loop has been executed: `n` is a positive integer, `m` is a non-negative integer, `v` is equal to the representative or root in the structure defined by `p`, and `vc` is equal to `v` after all iterations of the loop. After the loop, `vc` is equal to a value that points to `v`, and `p[vc]` is equal to `v`, indicating that `vc` has reached the representative of the structure.
    return v
    #The program returns the representative or root value 'v' from the structure defined by 'p'

#Function 3:
#State of the program right berfore the function call: n is an integer representing the number of vertices in the graph (1 ≤ n ≤ 10^5), m is an integer representing the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/(2),10^5)), and each edge is defined by two distinct integers a_i and b_i (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i) for 1 ≤ i ≤ m.
def union(u, v):
    u, v = find(u), find(v)
    if (u == v) :
        return
        #The program returns None, as there is no value specified to return.
    #State of the program after the if block has been executed: *`u` and `v` are assigned the values returned from the function `find(u)` and `find(v)`, respectively. `u` is not equal to `v`.
    if (r[u] < r[v]) :
        u, v = v, u
    #State of the program after the if block has been executed: *`u` and `v` are assigned the values returned from the function `find(u)` and `find(v)`, respectively; `u` is not equal to `v`; the value of `r` at index `u` is less than the value of `r` at index `v`. However, after execution, `u` takes the value of `v` and `v` takes the value of `u`, resulting in a contradiction as `u` becomes equal to `v`, violating the precondition that `u` is not equal to `v`.
    p[u] = v
    if (r[u] == r[v]) :
        r[u] += 1
    #State of the program after the if block has been executed: *`u` and `v` are assigned values returned from `find(u)` and `find(v)`, respectively, with `u` not equal to `v`. If `r[u]` equals `r[v]`, then `r[u]` is incremented by 1, leading to a contradiction as `p[u]` is assigned the value of `v`, which would violate the precondition that `u` is not equal to `v`.

#Function 4:
#State of the program right berfore the function call: x is a tuple containing two integers n and m, where n is the number of vertices (1 ≤ n ≤ 10^5) and m is the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/(2), 10^5)). Following this, there are m pairs of integers (a_i, b_i) representing the endpoints of the edges with weight 1, where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_2(x):
    return pow(x, MOD - 2, MOD)
    #The program returns the modular inverse of the tuple x under modulo MOD

#Function 5:
#State of the program right berfore the function call: x is an integer representing the number of vertices in the graph (1 ≤ x ≤ 10^5), and y is an integer representing the number of edges with weight 1 (0 ≤ y ≤ min((x(x-1))/(2), 10^5)).
def func_3(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the greatest common divisor (GCD) of the original values of `x` and `y`.
    return x
    #The program returns the greatest common divisor (GCD) of the original values of x and y, where y is 0. Since the GCD of any number and 0 is the number itself, it returns the value of x.

#Function 6:
#State of the program right berfore the function call: n is an integer representing the number of vertices in the graph (1 ≤ n ≤ 10^5), m is an integer representing the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/(2),10^5)), and for each of the next m lines, a_i and b_i are integers representing the endpoints of the edges (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i).
def func_4():
    return list(map(int, input().split()))
    #The program returns a list of integers derived from the input provided, which represents the endpoints of the edges in the graph.

#Function 7:
#State of the program right berfore the function call: o is a tuple containing two integers n and m, where n (1 ≤ n ≤ 10^5) is the number of vertices, and m (0 ≤ m ≤ min((n(n-1))/(2),10^5)) is the number of edges with weight 1. Additionally, the following m lines contain pairs of integers (a_i, b_i) where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i, representing the endpoints of the edges with weight 1.
def func_5(o):
    return list(map(lambda x: int(x) + o, input().split()))
    #The program returns a list of integers where each integer is the sum of the respective input value and the tuple `o` containing the number of vertices and edges.

#Function 8:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), m is a non-negative integer (0 ≤ m ≤ min((n(n-1))/(2), 10^5)), and for each of the next m lines, a_i and b_i are integers such that 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_6(n, m):
    return [func_4() for _ in range(n)]
    #The program returns a list of n elements, each being the result of func_4() called n times. The specific values of the elements depend on the implementation of func_4().

#Function 9:
#State of the program right berfore the function call: f is a callable function representing the edges of a complete undirected graph, dim is a tuple containing two integers n and m where 1 ≤ n ≤ 10^5 and 0 ≤ m ≤ min((n(n-1))/(2),10^5), followed by m pairs of integers (a_i, b_i) indicating the endpoints of the edges with weight 1, where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_7(f):
    return [func_7(f, *dim[1:]) for _ in range(dim[0])] if dim else f()
    #The program returns a list generated by calling func_7 with the second element of the tuple dim repeated dim[0] times if dim is not empty; otherwise, it returns the result of calling f()

#Function 10:
#State of the program right berfore the function call: start is an integer representing the number of vertices (n) in the graph, step is an integer representing the number of edges of weight 1 (m) such that 0 ≤ m ≤ min((n(n-1))/(2),10^5), and count is a list of tuples where each tuple contains two integers representing the endpoints of the edges of weight 1 (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i).
def func_8(start, step, count):
    return range(start, start + step * count, step)
    #The program returns a range starting from 'start' and extending to 'start + step * count' with an interval of 'step'

#Function 11:
#State of the program right berfore the function call: l is a list of tuples where each tuple contains two integers representing the endpoints of edges of weight 1 in an undirected complete graph, start and end are non-negative integers such that 0 <= start <= end <= len(l). The first element of l contains two integers n and m, where 1 ≤ n ≤ 100000 and 0 ≤ m ≤ min((n(n-1))/2, 100000).
def func_9(l, start, end):
    return range(start, len(l) + end)
    #The program returns a range from start to the length of list 'l' plus end, which is a range object representing the integers from start to len(l) + end.

#Function 12:
#State of the program right berfore the function call: n is an integer representing the number of vertices in a complete undirected weighted graph, where 1 ≤ n ≤ 10^5. The input also includes m, the number of edges with weight 1, satisfying 0 ≤ m ≤ min((n(n-1))/2, 10^5), and for each of the m edges, two integers a_i and b_i (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i) representing the endpoints of the edges.
def func_10(n):
    """ [0, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, ...] """
    return 2 ** (n - 1).bit_length()
    #The program returns 2 raised to the power of the bit length of (n - 1), which represents the smallest power of 2 that is greater than or equal to n.

#Function 13:
#State of the program right berfore the function call: x is an integer representing the number of vertices in the graph (1 ≤ x ≤ 10^5), and r is an integer representing the number of edges of weight 1 (0 ≤ r ≤ min((x(x-1))/(2), 10^5)).
def func_11(x, r):
    """ = ceil(x / r) """
    return (x + r - 1) // r
    #The program returns the result of the integer division of (x + r - 1) by r, which is defined when r > 0; if r = 0, the division by zero is undefined.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
