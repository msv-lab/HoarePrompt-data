
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: The research center Q has developed a new multi-core processor. The processor consists of n cores and has k cells of cache memory. Consider the work of this processor.

At each cycle each core of the processor gets one instruction: either do nothing, or the number of the memory cell (the core will write an information to the cell). After receiving the command, the core executes it immediately. Sometimes it happens that at one cycle, multiple cores try to write the information into a single cell. Unfortunately, the developers did not foresee the possibility of resolving conflicts between cores, so in this case there is a deadlock: all these cores and the corresponding memory cell are locked forever. Each of the locked cores ignores all further commands, and no core in the future will be able to record an information into the locked cell. If any of the cores tries to write an information into some locked cell, it is immediately locked.

The development team wants to explore the deadlock situation. Therefore, they need a program that will simulate the processor for a given set of instructions for each core within m cycles . You're lucky, this interesting work is entrusted to you. According to the instructions, during the m cycles define for each core the number of the cycle, during which it will become locked. It is believed that initially all cores and all memory cells are not locked.

Input

The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 100). Then follow n lines describing instructions. The i-th line contains m integers: xi1, xi2, ..., xim (0 ≤ xij ≤ k), where xij is the instruction that must be executed by the i-th core at the j-th cycle. If xij equals 0, then the corresponding instruction is «do nothing». But if xij is a number from 1 to k, then the corresponding instruction is «write information to the memory cell number xij».

We assume that the cores are numbered from 1 to n, the work cycles are numbered from 1 to m and the memory cells are numbered from 1 to k.

Output

Print n lines. In the i-th line print integer ti. This number should be equal to 0 if the i-th core won't be locked, or it should be equal to the number of the cycle when this core will be locked.

Examples

Input

4 3 5
1 0 0
1 0 2
2 3 1
3 2 0


Output

1
1
3
0


Input

3 2 2
1 2
1 2
2 2


Output

1
1
0


Input

1 1 1
0


Output

0
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n, m, and k are positive integers such that 1 ≤ n, m, k ≤ 100, and instructions for each of the n cores consist of m integers where each integer x_ij (0 ≤ x_ij ≤ k) represents either a write command to a memory cell (1 to k) or a do-nothing command (0).
def func_1():
    n, m, k = map(int, raw_input().split())
    ins = [([0] * m) for i in xrange(n + 1)]
    cell = [False] * (k + 1)
    nn = [0] * (k + 1)
    core = [0] * (n + 1)
    for i in xrange(n):
        ins[i + 1] = map(int, raw_input().split())
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `ins` is a list containing `n` lists of integers from user input, `i` is `n - 1`.
    for i in xrange(m):
        for j in xrange(1, k + 1):
            nn[j] = 0
        
        for j in xrange(1, n + 1):
            if core[j] == 0:
                d = ins[j][i]
                if d != 0:
                    if cell[d]:
                        core[j] = i + 1
                    elif nn[d] != 0:
                        cell[d] = True
                        core[j] = core[nn[d]] = i + 1
                        nn[d] = j
                    elif nn[d] == 0:
                        nn[d] = j
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `i` is equal to `n + m`, `k` is a positive integer, `core` contains values updated based on the conditions evaluated during the loop, `nn` may contain updated indices or remain zero for certain values, and `cell` may have some entries set to True based on the conditions processed throughout the loop.
    for i in xrange(1, n + 1):
        print(core[i])
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `i` is `n`, `core` contains values updated based on the conditions evaluated during the loop, `nn` may contain updated indices or remain zero for certain values, and `cell` may have some entries set to True based on the conditions processed throughout the loop.
#Overall this is what the function does:The function accepts no parameters and processes instructions for `n` cores, each consisting of `m` integers. It tracks memory commands that could either write to a memory cell (1 to `k`) or do nothing (0). The function updates a core's state based on these commands, printing the final state of each core after processing all instructions. The logic ensures that it handles cases where memory cells are already written to, as well as tracking the most recent core that accessed a specific memory cell. It does not handle invalid inputs or edge cases where `n`, `m`, or `k` are out of the specified bounds.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
