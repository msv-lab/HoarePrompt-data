
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Write a program which performs the following operations to a binary search tree $T$ by adding the find operation to A: Binary Search Tree I.

* insert  $k$: Insert a node containing $k$ as key into $T$.
* find $k$: Report whether $T$ has a node containing $k$.
* print: Print the keys of the binary search tree by inorder tree walk and preorder tree walk respectively.

Constraints

* The number of operations $\leq 500,000$
* The number of print operations $\leq 10$.
* $-2,000,000,000 \leq key \leq 2,000,000,000$
* The height of the binary tree does not exceed 100 if you employ the above pseudo code.
* The keys in the binary search tree are all different.

Input

In the first line, the number of operations $m$ is given. In the following $m$ lines, operations represented by insert $k$, find $k$ or print are given.

Output

For each find $k$ operation, print "yes" if $T$ has a node containing $k$, "no" if not.

In addition, for each print operation, print a list of keys obtained by inorder tree walk and preorder tree walk in a line respectively. Put a space character before each key.

Example

Input

10
insert 30
insert 88
insert 12
insert 1
insert 20
find 12
insert 17
insert 25
find 16
print


Output

yes
no
 1 12 17 20 25 30 88
 30 12 1 20 17 25 88
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: top is the root node of a binary search tree, and z is a list of strings where each string is an operation in the format of either "insert k", "find k", or "print". The integer k in the operations is within the range -2,000,000,000 to 2,000,000,000, and the number of operations is less than or equal to 500,000.
def func_1(top, z):
    y = None
    x = top
    while isinstance(x, Node):
        y = x
        
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
        
    #State of the program after the loop has been executed: `y` is the last node visited in the binary search tree traversal based on the key of `z`, `x` is None indicating the point where the search ends (either a leaf node was reached or the key was found), and `top` remains the root node of the binary search tree.
    z.parent = y
    if (y is None) :
        top = z
    else :
        if (z.key < y.key) :
            y.left = z
        else :
            y.right = z
        #State of the program after the if-else block has been executed: *`y` is the last node visited in the binary search tree traversal based on the key of `z`; `x` is None; `top` remains the root node of the binary search tree; `z.parent` is assigned the value of `y`; `y` is not None; if the key of `z` is less than the key of `y`, then `y.left` is now `z`; otherwise, `y.right` is assigned the value of `z`.
    #State of the program after the if-else block has been executed: *`y` is the last node visited in the binary search tree traversal based on the key of `z`, `x` is None, and `top` remains the root node of the binary search tree. If `y` is None, then `top` is assigned the value of `z`, `z.parent` is assigned the value of `y`, and `y` is None. If `y` is not None, then `z.parent` is assigned the value of `y`, and if the key of `z` is less than the key of `y`, then `y.left` is now `z`; otherwise, `y.right` is assigned the value of `z`.
    return top
    #The program returns the root node of the binary search tree, which is assigned to 'top' regardless of the state of 'y' or 'z'.
#Overall this is what the function does:The function accepts the root node of a binary search tree (`top`) and a node (`z`) to be inserted into the tree. It traverses the tree to find the appropriate position for `z` based on its key, updates the parent-child relationships accordingly, and returns the updated root node of the binary search tree. If the tree is empty (i.e., `top` is `None`), `z` becomes the new root. The function does not handle operations to find or print values from the tree, despite the comments indicating a list of operations.

#Function 2:
#State of the program right berfore the function call: node is the root of a binary search tree where each node contains a unique integer key, and key is an integer within the range -2,000,000,000 to 2,000,000,000.
def func_2(node, key):
    if (not node) :
        return False
        #The program returns False because the node is not present (i.e., it is None)
    #State of the program after the if block has been executed: *`node` is the root of a binary search tree where each node contains a unique integer key, and `key` is an integer within the range -2,000,000,000 to 2,000,000,000. `node` is not None (i.e., it exists and is a valid node of the tree).
    if (node.key == key) :
        return True
        #The program returns True indicating that the key is found in the binary search tree node.
    #State of the program after the if block has been executed: *`node` is the root of a binary search tree where each node contains a unique integer key, `key` is an integer within the range -2,000,000,000 to 2,000,000,000, `node` is not None, and `node.key` is not equal to `key`.
    if (key < node.key) :
        return func_2(node.left, key)
        #The program returns the result of calling func_2 with the left child of the current node and the key, which is less than the current node's key
    #State of the program after the if block has been executed: *`node` is the root of a binary search tree where each node contains a unique integer key, `key` is an integer within the range -2,000,000,000 to 2,000,000,000, `node` is not None, `node.key` is not equal to `key`, and `key` is greater than or equal to `node.key`.
    return func_2(node.right, key)
    #The program returns the result of calling func_2 on the right subtree of the binary search tree node with the provided key
#Overall this is what the function does:The function accepts a binary search tree node and an integer key. It returns False if the node is None, True if the key is found in the tree, or continues the search recursively in the left or right subtree based on whether the key is less than or greater than the current node's key. If the key is not found after exploring all relevant nodes, it will eventually return False.

#Function 3:
#State of the program right berfore the function call: node is the root of a binary search tree, where each node contains a unique integer key within the range of -2,000,000,000 to 2,000,000,000, and the number of operations does not exceed 500,000.
def func_3(node):
    if node.left :
        func_3(node.left)
    #State of the program after the if block has been executed: *`node` is the root of a binary search tree, where each node contains a unique integer key within the range of -2,000,000,000 to 2,000,000,000, and the number of operations does not exceed 500,000. If `node` has a left child, the function `func_3` is called with `node.left`.
    print('', node.key, end='')
    if node.right :
        func_3(node.right)
    #State of the program after the if block has been executed: *`node` is the root of a binary search tree. If `node` has a right child, the key of the root node is printed without any additional output, and `func_3` is called with `node.right` as the argument.
#Overall this is what the function does:The function accepts a node from a binary search tree and performs an in-order traversal, printing the keys of the nodes in ascending order. This traversal visits the left subtree, prints the current node's key, and then visits the right subtree. If the tree is empty (i.e., the node is None), the function does nothing.

#Function 4:
#State of the program right berfore the function call: node is the root node of a binary search tree, where the tree contains unique integer keys, and the number of operations performed does not exceed 500,000. Operations include inserting keys within the range of -2,000,000,000 to 2,000,000,000, finding keys, and printing the tree in inorder and preorder traversals.
def func_4(node):
    print('', node.key, end='')
    if node.left :
        func_4(node.left)
    #State of the program after the if block has been executed: *`node` is the root node of a binary search tree; the key of the node is printed. If `node` has a left child, the function `func_4` is called with `node.left` as the argument. If `node` does not have a left child, only the key of the node is printed.
    if node.right :
        func_4(node.right)
    #State of the program after the if block has been executed: *`node` is the root node of a binary search tree; the key of the node is printed. If `node` has a right child, the function `func_4` is called with `node.right` as the argument. If `node` has a left child, the function `func_4` is called with `node.left` as the argument; otherwise, only the key of the node is printed.
#Overall this is what the function does:The function accepts a node representing the root of a binary search tree and performs a preorder traversal, printing the keys of the nodes in the order they are visited. It does not perform any insertions or searches; it only prints the keys of the current node, its left child (if present), and then its right child (if present). The function assumes that the input node is not None. If the input node is None, the function will raise an error as there is no handling for that case.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.