
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description. If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". Partially correct programs should be considered incorrect. You have to use the source code to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the descriptions says.  If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Andrew, Fedor and Alex are inventive guys. Now they invent the game with strings for two players.

Given a group of n non-empty strings. During the game two players build the word together, initially the word is empty. The players move in turns. On his step player must add a single letter in the end of the word, the resulting word must be prefix of at least one string from the group. A player loses if he cannot move.

Andrew and Alex decided to play this game k times. The player who is the loser of the i-th game makes the first move in the (i + 1)-th game. Guys decided that the winner of all games is the player who wins the last (k-th) game. Andrew and Alex already started the game. Fedor wants to know who wins the game if both players will play optimally. Help him.

Input

The first line contains two integers, n and k (1 ≤ n ≤ 105; 1 ≤ k ≤ 109).

Each of the next n lines contains a single non-empty string from the given group. The total length of all strings from the group doesn't exceed 105. Each string of the group consists only of lowercase English letters.

Output

If the player who moves first wins, print "First", otherwise print "Second" (without the quotes).

Examples

Input

2 3
a
b


Output

First


Input

3 1
a
b
c


Output

First


Input

1 2
ab


Output

Second
Program:
```
class TrieNode:

    def __init__(self):
        self.childs = dict()
        self.isWord = False

class Trie:

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for letter in word:
            child = node.childs.get(letter)
            if child is None:
                child = TrieNode()
                node.childs[letter] = child
            elif child.isWord == True:
                child.isWord = False
            node = child
        node.isWord = True

    def searh(self, word):
        node = self.root
        for letter in word:
            node = node.childs.get(letter)
            if node is None:
                return False
        return node.isWord

    def startsWith(self, prefix):
        node = self.root
        for letter in prefix:
            node = node.childs.get(letter)
            if node is None:
                return False
        return True

def func_1(node, level):
    if node is not None and node.isWord:
        if level % 2 == 1:
            return (True, False)
        else:
            return (False, True)
    nodes = node.childs
    odd_ret = False
    even_ret = False
    for it in nodes:
        child = nodes.get(it)
        (odd_w, even_w) = func_1(child, level + 1)
        if odd_w == True:
            odd_ret = True
        if even_w == True:
            even_ret = True
    return (odd_ret, even_ret)

def func_2(ttree):
    canloss = False
    canwin = False
    node = ttree.root.childs
    for it in node:
        child = node.get(it)
        (odd_w, even_w) = func_1(child, 0)
        if odd_w == True:
            odd_w = True
        if even_w == True:
            even_w = True
        if even_w:
            canwin = True
        if odd_w:
            canloss = True
    if canloss and canwin:
        return 3
    if canloss:
        return 1
    return 2
(n, k) = [int(s) for s in raw_input().split(' ')]
tree = Trie()
for i in xrange(0, n):
    tree.insert(raw_input())
ret_type = func_2(tree)
if ret_type == 1:
    print('Second')
if ret_type == 2:
    if k % 2 == 1:
        print('First')
    else:
        print('Second')
if ret_type == 3:
    print('First')
```


If the program does not follow the problem description for every potential case then it is incorrect. Then if even for one input or potential case the program does not work then Correctness **False** .You are trying to find any potential case that the porgram does not does what the descriptions says. But if you cant find an example where the program does not work as expected in the description and all the examples you think work correctly then the program is correct.
You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly. If you cant find a single case then the program is correct.
