
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There are N balls in a two-dimensional plane. The i-th ball is at coordinates (x_i, y_i).

We will collect all of these balls, by choosing two integers p and q such that p \neq 0 or q \neq 0 and then repeating the following operation:

* Choose a ball remaining in the plane and collect it. Let (a, b) be the coordinates of this ball. If we collected a ball at coordinates (a - p, b - q) in the previous operation, the cost of this operation is 0. Otherwise, including when this is the first time to do this operation, the cost of this operation is 1.



Find the minimum total cost required to collect all the balls when we optimally choose p and q.

Constraints

* 1 \leq N \leq 50
* |x_i|, |y_i| \leq 10^9
* If i \neq j, x_i \neq x_j or y_i \neq y_j.
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


N
x_1 y_1
:
x_N y_N


Output

Print the minimum total cost required to collect all the balls.

Examples

Input

2
1 1
2 2


Output

1


Input

3
1 4
4 6
7 8


Output

1


Input

4
1 1
1 2
2 1
2 2


Output

2
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: N is an integer such that 1 <= N <= 50, and for each ball i (1 <= i <= N), (x_i, y_i) are integers where |x_i|, |y_i| <= 10^9, and all (x_i, y_i) coordinates are distinct.
def func_1():
    N = read_int()
    balls = []
    for _ in range(N):
        balls.append(read_int_array())
        
    #State of the program after the  for loop has been executed: `N` is an integer such that 1 <= `N` <= 50; `_` is `N - 1`; `balls` contains `N` integer arrays appended from `read_int_array()`
    func_8(func_2(N, balls))

#Function 2:
#State of the program right berfore the function call: n is an integer such that 1 <= n <= 50, and balls is a list of tuples where each tuple contains two integers (x_i, y_i) representing the coordinates of a ball, with |x_i|, |y_i| <= 10^9 and all balls have unique coordinates.
def func_2(n, balls):
    bdict = collections.defaultdict(set)
    for (x, y) in balls:
        bdict[x].add(y)
        
    #State of the program after the  for loop has been executed: `n` is an integer such that 1 <= n <= 50; `balls` is a list of tuples containing coordinates of balls; `bdict` is a defaultdict where for each unique x coordinate in `balls`, the corresponding set contains all y coordinates associated with that x.
    tried = set()
    ans = n
    for i in range(n):
        for j in range(i):
            p, q = balls[j][0] - balls[i][0], balls[j][1] - balls[i][1]
            if (p, q) not in tried:
                tried.add((p, q))
                tried.add((-p, -q))
                points = score(p, q)
                if points < ans:
                    ans = points
        
    #State of the program after the  for loop has been executed: `n` is an integer such that 1 <= `n` <= 50; `ans` is the minimum score obtained from the function `score(p, q)` for all valid pairs of balls; `tried` contains all unique tuples `(p, q)` and their negations for each unique pair of balls considered; `i` is `n-1`; `j` is `i-1` at the last iteration; `p` and `q` are defined based on the last pair of balls processed.
    return ans
    #The program returns the minimum score obtained from the function `score(p, q)` for all valid pairs of balls processed, represented by the variable `ans`.

#Function 3:
#State of the program right berfore the function call: p and q are integers such that p is not equal to 0 or q is not equal to 0, and there are N balls in a two-dimensional plane with coordinates (x_i, y_i) where 1 <= N <= 50 and |x_i|, |y_i| <= 10^9. All x_i and y_i are distinct.
def score(p, q):
    out = n
    for (x, y) in balls:
        nx, ny = x + p, y + q
        
        if ny in bdict.get(nx, []):
            out -= 1
        
    #State of the program after the  for loop has been executed: `p` is not equal to 0, `q` is not equal to 0, `N` is at least 1, `out` is `n - k` where `k` is the number of times `ny` is found in the list `bdict.get(nx, [])`, `nx` is the x-coordinate of each ball after adding `p`, and `ny` is the y-coordinate of each ball after adding `q`.
    return out
    #The program returns the value of 'out', which is calculated as 'n - k', where 'k' is the number of times 'ny' is found in the list 'bdict.get(nx, [])' and 'n' is at least 1.

#Function 4:
#State of the program right berfore the function call: N is an integer such that 1 <= N <= 50, and the coordinates (x_i, y_i) for each ball are integers with |x_i|, |y_i| <= 10^9, with the condition that no two balls share the same coordinates.
def func_3():
    if (False and 'PYCHARM_HOSTED' in os.environ) :
        func_4()
    else :
        func_1()
    #State of the program after the if-else block has been executed: *`N` is an integer such that 1 <= `N` <= 50, and the coordinates (x_i, y_i) for each ball are integers with |x_i|, |y_i| <= 10^9, with the condition that no two balls share the same coordinates. If the condition is met for the if statement (which it never is since it is always false), the function `func_4()` is called, but its effects are unknown. In all other cases, the function `func_1()` is executed, and since no information about its implementation or effects is provided, the output state remains unchanged.

#Function 5:
#State of the program right berfore the function call: N is an integer such that 1 <= N <= 50, and each ball's coordinates (x_i, y_i) are distinct integers with |x_i|, |y_i| <= 10^9.
def func_4():
    solution = solve
    test_inputs = None
    test_outputs = None
    judge = None
    slow_solution = None
    if (solution is not None) :
        if (test_outputs is not None) :
            func_5(solution, test_inputs, test_outputs)
        #State of the program after the if block has been executed: *`N` is an integer such that 1 <= `N` <= 50; `solution` is a function assigned to `solve`; `test_inputs` is None; `test_outputs` is not None; `judge` is None; `slow_solution` is None; and `solution` is not None. If `test_outputs` is not None, then `func_5` is called with `solution`, `test_inputs`, and `test_outputs`.
        if (judge is not None) :
            func_6(solution, test_inputs, judge)
        #State of the program after the if block has been executed: *`N` is an integer such that 1 <= `N` <= 50; `solution` is a function assigned to `solve`; `test_inputs` is None; `test_outputs` is not None; `judge` is not None; `slow_solution` is None; and `solution` is not None. If `judge` is not None, `func_6` is called with `solution`, `test_inputs`, and `judge`.
        if (slow_solution is not None) :
            func_7(solution, test_inputs, slow_solution)
        #State of the program after the if block has been executed: *`N` is an integer such that 1 <= `N` <= 50; `solution` is a function assigned to `solve`; `test_inputs` is None; `test_outputs` is not None; `judge` is not None; `slow_solution` is not None; and `solution` is not None. If `slow_solution` is not None, `func_7` is called with `solution`, `test_inputs`, and `slow_solution`.
    #State of the program after the if block has been executed: *`N` is an integer such that 1 <= `N` <= 50; `solution` is a function assigned to `solve`; `test_inputs` is None; `test_outputs` is not None; `judge` is not None; `slow_solution` is not None; and `solution` is not None. If `solution` is not None, `func_7` is called with `solution`, `test_inputs`, and `slow_solution`.

#Function 6:
#State of the program right berfore the function call: solution is an integer representing the minimum total cost required to collect all the balls, inputs_answers is a list of tuples where each tuple contains two integers (x_i, y_i) representing the coordinates of each ball, and the length of inputs_answers is equal to N, where 1 <= N <= 50.
def func_5(solution, inputs_answers):
    total, wrong = 0, 0
    for (args, test_ans) in inputs_answers:
        ans = solution(*args.copy())
        
        if ans != test_ans:
            func_8('WRONG! ans=%s, test_ans=%s, args=%s' % (ans, test_ans, args))
            wrong += 1
        else:
            func_8('GOOD')
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is the number of items in `inputs_answers`, `wrong` is the number of incorrect answers.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 7:
#State of the program right berfore the function call: solution is a function that takes in a list of integers representing coordinates of balls in a two-dimensional plane, where each ball's position is given as a pair (x_i, y_i) with 1 <= N <= 50 and |x_i|, |y_i| <= 10^9; inputs_gen is a function that generates input values, and judge is a function that evaluates the output of solution.
def func_6(solution, inputs_gen, judge):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        if not judge(deepcopy(ans), *deepcopy(args)):
            func_8('WRONG! ans=%s, args=%s' % (ans, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is equal to the number of iterations of `inputs_gen`, `wrong` is the number of failed tests from those iterations.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 8:
#State of the program right berfore the function call: N is a positive integer such that 1 <= N <= 50, and each ball's coordinates (x_i, y_i) are integers with |x_i|, |y_i| <= 10^9, where i ranges from 1 to N and no two balls have the same coordinates.
def func_7(solution, inputs_gen, solution_slow):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        slow = solution_slow(*deepcopy(args))
        
        if ans != slow:
            func_8('WRONG! ans=%s, slow=%s, args=%s' % (ans, slow, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: `N` is a positive integer such that 1 <= `N` <= 50; `total` is the total number of iterations (0 if `inputs_gen` is empty); `wrong` is the count of wrong answers (0 <= `wrong` <= `total`); `args` is the last value yielded from `inputs_gen` (if any); `ans` is the result of calling `solution` with the last `args` (if any); `slow` is the result of calling `solution_slow` with the last `args` (if any).
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 9:
#State of the program right berfore the function call: args is a tuple of length N where each element is a pair of integers (x_i, y_i) representing the coordinates of the balls, and N is an integer such that 1 <= N <= 50.
def func_8():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` is set to the value from `kwargs` or defaults to ' '; `file` is set to the value from `kwargs` or defaults to sys.stdout; `at_start` is False; if `args` has at least one element, `file` contains the string representation of all elements in `args` separated by `sep`; if `args` is empty, nothing is written to `file`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is set to the value from `kwargs` or defaults to ' '; `file` is set to the value from `kwargs` or defaults to sys.stdout; `at_start` is False; if `args` has at least one element, `file` contains the string representation of all elements in `args` separated by `sep`; if `args` is empty, nothing is written to `file`; `file` writes the value from `kwargs.pop('end', '\n')`, which is either the value of 'end' in `kwargs` or defaults to a newline character; if the flush parameter in `kwargs` is set to True, `file.flush()` is called to flush the output buffer of `file`.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
