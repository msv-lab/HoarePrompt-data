
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given three sequences: a_1, a_2, …, a_n; b_1, b_2, …, b_n; c_1, c_2, …, c_n.

For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.

Find a sequence p_1, p_2, …, p_n, that satisfy the following conditions:

  * p_i ∈ \\{a_i, b_i, c_i\}
  * p_i ≠ p_{(i mod n) + 1}.



In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements i,i+1 adjacent for i<n and also elements 1 and n) will have equal value.

It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.

Input

The first line of input contains one integer t (1 ≤ t ≤ 100): the number of test cases.

The first line of each test case contains one integer n (3 ≤ n ≤ 100): the number of elements in the given sequences.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 100).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ 100).

The fourth line contains n integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 100).

It is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.

Output

For each test case, print n integers: p_1, p_2, …, p_n (p_i ∈ \\{a_i, b_i, c_i\}, p_i ≠ p_{i mod n + 1}).

If there are several solutions, you can print any.

Example

Input


5
3
1 1 1
2 2 2
3 3 3
4
1 2 1 2
2 1 2 1
3 4 3 4
7
1 3 3 1 1 1 1
2 4 4 3 2 2 4
4 2 2 2 4 4 2
3
1 2 1
2 3 3
3 1 2
10
1 1 1 2 2 2 3 3 3 1
2 2 2 3 3 3 1 1 1 2
3 3 3 1 1 1 2 2 2 3


Output


1 2 3
1 2 1 2
1 3 4 3 2 4 2
1 3 2
1 2 3 1 2 3 1 2 3 2

Note

In the first test case p = [1, 2, 3].

It is a correct answer, because:

  * p_1 = 1 = a_1, p_2 = 2 = b_2, p_3 = 3 = c_3 
  * p_1 ≠ p_2 , p_2 ≠ p_3 , p_3 ≠ p_1 



All possible correct answers to this test case are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].

In the second test case p = [1, 2, 1, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = a_3, p_4 = a_4. Also we can see, that no two adjacent elements of the sequence are equal.

In the third test case p = [1, 3, 4, 3, 2, 4, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = b_3, p_4 = b_4, p_5 = b_5, p_6 = c_6, p_7 = c_7. Also we can see, that no two adjacent elements of the sequence are equal.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100; for each test case, n is an integer such that 3 ≤ n ≤ 100; a, b, and c are lists of n integers where each integer is in the range 1 to 100, and for all i, a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i].
def func_1():
    return int(input())
    #The program returns an integer input provided by the user, which is within the range defined by the constraints.

#Function 2:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100 for each test case, and a, b, c are lists of integers where each list contains n integers (1 ≤ a_i, b_i, c_i ≤ 100) and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_2():
    return input()
    #The program returns the input provided by the user, which is expected to be the values of t, n, and the lists a, b, c, where t is an integer (1 ≤ t ≤ 100), n is an integer (3 ≤ n ≤ 100), and each list contains n integers (1 ≤ a_i, b_i, c_i ≤ 100) with the condition that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.

#Function 3:
#State of the program right berfore the function call: t is an integer (1 ≤ t ≤ 100) representing the number of test cases; for each test case, n is an integer (3 ≤ n ≤ 100) representing the number of elements in the sequences; a, b, and c are lists of n integers (1 ≤ a_i, b_i, c_i ≤ 100) with the constraints that a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all i.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a list of integers parsed from the input string, which contains n integers separated by spaces, where each integer is in the range from 1 to 100.

#Function 4:
#State of the program right berfore the function call: t is an integer where 1 ≤ t ≤ 100, n is an integer where 3 ≤ n ≤ 100 for each test case, a, b, and c are sequences of n integers with values between 1 and 100, and for each i, a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i].
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object that converts the input sequence of integers into strings, based on the provided input values.

#Function 5:
#State of the program right berfore the function call: The function processes multiple test cases where each test case consists of an integer n (3 ≤ n ≤ 100) followed by three sequences of n integers (a, b, c) such that for each index i (1 ≤ i ≤ n), a[i] ≠ b[i], a[i] ≠ c[i], and b[i] ≠ c[i]. Each integer in the sequences is within the range 1 to 100. The total number of test cases t is between 1 and 100.
def func_5():
    return list(func_3())
    #The program returns a list containing the results of the function func_3() for multiple test cases, where each test case consists of three sequences of integers with specified conditions.

#Function 6:
#State of the program right berfore the function call: The input consists of an integer t (1 ≤ t ≤ 100) representing the number of test cases, and for each test case, an integer n (3 ≤ n ≤ 100) followed by three sequences of n integers each: a, b, and c, where each element in the sequences satisfies 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a tuple containing three sequences of integers (a, b, c), where each sequence has exactly n elements (3 ≤ n ≤ 100) and all elements are in the range [1, 100]. Additionally, for each index i, the conditions a[i] ≠ b[i], a[i] ≠ c[i], and b[i] ≠ c[i] must hold true.
def func_7(item):
    return item[1]
    #The program returns the second sequence of integers from the tuple 'item'

#Function 8:
#State of the program right berfore the function call: l is a list of test cases, where each test case consists of a positive integer n followed by three lists of n integers each, representing sequences a, b, and c, with the constraints that 3 ≤ n ≤ 100 and 1 ≤ a_i, b_i, c_i ≤ 100, and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list 'l' sorted in descending order based on the values returned by the function 'getKey' applied to each test case, where each test case consists of a positive integer n followed by three lists of n integers each.

#Function 9:
#State of the program right berfore the function call: n is an integer representing the number of elements in the sequences (3 ≤ n ≤ 100), m is an integer representing the number of test cases (1 ≤ m ≤ 100), and num is a list of tuples, where each tuple contains three lists of integers (a, b, c) of size n, with each integer in the range 1 to 100 and ensuring that a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i] for all i.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list containing 'm' elements, each of which is the list 'num' that consists of tuples with three lists of integers (a, b, c) of size 'n'.

#Function 10:
#State of the program right berfore the function call: x is a list of tuples, where each tuple contains three sequences of integers (a, b, c) of length n (3 ≤ n ≤ 100) for each test case, and the integers in each sequence are such that 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_10(x):
    return x and not x & x - 1
    #The program returns the list of tuples `x` and the result of the bitwise expression `not x & (x - 1)`, which involves the tuples in `x`.

#Function 11:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100, and a, b, c are lists of integers where each list has n elements, with each element 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the integer n without the '0b' prefix

#Function 12:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100. For each test case, there are three sequences a, b, and c, each containing n integers where 1 ≤ a_i, b_i, c_i ≤ 100, and it is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of the digits of the integer n, where n is an integer such that 3 ≤ n ≤ 100

#Function 13:
#State of the program right berfore the function call: n is an integer representing the number of elements in the sequences (3 ≤ n ≤ 100), and r is a list of tuples such that each tuple contains three integers (a_i, b_i, c_i) with 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for each i.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of the combination formula involving the factorial of n and the factorial of the elements in r, adjusted by the maximum of (n - r) and 1.

#Function 14:
#State of the program right berfore the function call: x is a list of integers where each element corresponds to the sequences a_1, a_2, …, a_n, b_1, b_2, …, b_n, c_1, c_2, …, c_n for multiple test cases, and y is an integer representing the number of test cases such that 1 ≤ y ≤ 100 and for each test case, the number of elements n (3 ≤ n ≤ 100) in the sequences is followed by three lists of integers where each integer is between 1 and 100 and satisfies a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the list of integers `x` divided by the integer `y`, representing the sequences for each test case, with each test case processed accordingly.
    else :
        return x // y + 1
        #The program returns the integer result of the list of integers `x` divided by the integer `y` plus 1, where `x` is not divisible by `y`.

#Function 15:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), y is an integer representing the number of elements in the given sequences (3 ≤ y ≤ 100), and p is a list of tuples where each tuple contains three lists of integers a, b, and c (1 ≤ a_i, b_i, c_i ≤ 100) such that for each i, a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the final value computed from the expression `x * x % p` after all iterations, `p` is a list of tuples containing three lists of integers, and `res` is updated based on the number of times `y` was odd during the iterations.
    return res
    #The program returns the value of 'res', which is updated based on the number of times 'y' was odd during the iterations.

#Function 16:
#State of the program right berfore the function call: x is a positive integer representing the number of test cases (1 ≤ x ≤ 100), and y is a list of tuples, each containing an integer n (3 ≤ n ≤ 100) followed by three lists of integers a, b, and c, where each list contains n integers (1 ≤ a_i, b_i, c_i ≤ 100) such that a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all i.
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is a non-empty tuple containing the last value of `y`, `y` is the result of `x % y`, where `x` is a positive integer and `y` is an empty tuple, indicating that the loop has terminated.
    return x
    #The program returns the non-empty tuple 'x' containing the last value of 'y', where 'y' is the result of 'x % y' and 'y' is an empty tuple, indicating the loop has terminated.

#Function 17:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100, and for each i (1 ≤ i ≤ n), a_i, b_i, c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100 with a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer such that 3 ≤ `n` ≤ 100; for each `i` (1 ≤ `i` ≤ `n`), `a_i`, `b_i`, `c_i` are integers such that 1 ≤ `a_i`, `b_i`, `c_i` ≤ 100 with `a_i` ≠ `b_i`, `a_i` ≠ `c_i`, `b_i` ≠ `c_i`; `n` is greater than 1.
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *`n` is an integer such that 3 < `n` ≤ 100; for each `i` (1 ≤ `i` ≤ `n`), `a_i`, `b_i`, `c_i` are integers such that 1 ≤ `a_i`, `b_i`, `c_i` ≤ 100 with `a_i` ≠ `b_i`, `a_i` ≠ `c_i`, `b_i` ≠ `c_i`; `n` is greater than 1.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer such that 3 < `n` ≤ 100 and `n` is not divisible by 2 or 3; for each `i` (1 ≤ `i` ≤ `n`), `a_i`, `b_i`, `c_i` are integers such that 1 ≤ `a_i`, `b_i`, `c_i` ≤ 100 with `a_i` ≠ `b_i`, `a_i` ≠ `c_i`, `b_i` ≠ `c_i`; `n` is greater than 1.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is an integer such that 3 < `n` ≤ 100, `n` is not divisible by 2 or 3, `i` is the smallest integer greater than or equal to the square root of `n`, increased in steps of 6 until `i * i` exceeds `n`. The loop terminates without finding any divisors among `i` or `i + 2`.
    return True
    #The program returns True, indicating that n is a prime number and has no divisors found among the checked values of i and i + 2.

#Function 18:
#State of the program right berfore the function call: t is an integer (1 ≤ t ≤ 100), n is an integer (3 ≤ n ≤ 100) for each test case, a, b, and c are lists of n integers (1 ≤ a_i, b_i, c_i ≤ 100) such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100 for each test case, and a, b, c are lists of integers of length n where each element is in the range 1 ≤ a_i, b_i, c_i ≤ 100 and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_19():
    for _ in range(func_1()):
        n = func_1()
        
        a = func_5()
        
        b = func_5()
        
        c = func_5()
        
        ans = [0] * n
        
        ans[0] = a[0]
        
        for i in range(1, n):
            if ans[i - 1] != a[i]:
                ans[i] = a[i]
            elif ans[i - 1] != b[i]:
                ans[i] = b[i]
            else:
                ans[i] = c[i]
        
        func_20(*ans)
        
    #State of the program after the  for loop has been executed: `t` is an integer such that 1 ≤ `t` ≤ 100; for each test case, `n` is an integer such that 3 ≤ `n` ≤ 100; `a`, `b`, and `c` are lists of integers of length `n`; `ans` is a list of length `n` ensuring that consecutive values in `ans` are not equal; `func_20` is called with `*ans` for each test case.

#Function 20:
#State of the program right berfore the function call: args is a list of tuples, where each tuple contains four elements: an integer n (3 ≤ n ≤ 100), and three lists of integers a, b, and c, each containing n integers (1 ≤ a[i], b[i], c[i] ≤ 100) such that a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i] for all i.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a list of tuples containing integers and lists, `x` is the last tuple in `args`, `file` now contains the string representation of all tuples in `args` separated by ' ', and `at_start` is False.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a list of tuples containing integers and lists; `x` is the last tuple in `args`; `file` contains the string representation of all tuples in `args` separated by ' '; `at_start` is False; `file` is updated by writing the value returned by `kwargs.pop('end', '\n')`; if `kwargs` contains the key 'flush' with a value of True or 'flush' key does not exist, the flush operation is performed on the file object.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
