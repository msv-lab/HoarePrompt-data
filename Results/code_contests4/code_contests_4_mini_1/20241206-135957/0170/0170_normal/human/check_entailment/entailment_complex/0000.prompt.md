
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: You are given three sequences: a_1, a_2, …, a_n; b_1, b_2, …, b_n; c_1, c_2, …, c_n.

For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.

Find a sequence p_1, p_2, …, p_n, that satisfy the following conditions:

  * p_i ∈ \\{a_i, b_i, c_i\}
  * p_i ≠ p_{(i mod n) + 1}.



In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements i,i+1 adjacent for i<n and also elements 1 and n) will have equal value.

It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.

Input

The first line of input contains one integer t (1 ≤ t ≤ 100): the number of test cases.

The first line of each test case contains one integer n (3 ≤ n ≤ 100): the number of elements in the given sequences.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 100).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ 100).

The fourth line contains n integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 100).

It is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.

Output

For each test case, print n integers: p_1, p_2, …, p_n (p_i ∈ \\{a_i, b_i, c_i\}, p_i ≠ p_{i mod n + 1}).

If there are several solutions, you can print any.

Example

Input


5
3
1 1 1
2 2 2
3 3 3
4
1 2 1 2
2 1 2 1
3 4 3 4
7
1 3 3 1 1 1 1
2 4 4 3 2 2 4
4 2 2 2 4 4 2
3
1 2 1
2 3 3
3 1 2
10
1 1 1 2 2 2 3 3 3 1
2 2 2 3 3 3 1 1 1 2
3 3 3 1 1 1 2 2 2 3


Output


1 2 3
1 2 1 2
1 3 4 3 2 4 2
1 3 2
1 2 3 1 2 3 1 2 3 2

Note

In the first test case p = [1, 2, 3].

It is a correct answer, because:

  * p_1 = 1 = a_1, p_2 = 2 = b_2, p_3 = 3 = c_3 
  * p_1 ≠ p_2 , p_2 ≠ p_3 , p_3 ≠ p_1 



All possible correct answers to this test case are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].

In the second test case p = [1, 2, 1, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = a_3, p_4 = a_4. Also we can see, that no two adjacent elements of the sequence are equal.

In the third test case p = [1, 3, 4, 3, 2, 4, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = b_3, p_4 = b_4, p_5 = b_5, p_6 = c_6, p_7 = c_7. Also we can see, that no two adjacent elements of the sequence are equal.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100; for each test case, n is an integer such that 3 ≤ n ≤ 100; a, b, and c are lists of n integers where each integer is in the range 1 to 100, and for all i, a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i].
def func_1():
    return int(input())
    #The program returns an integer input provided by the user, which is within the range defined by the constraints.
#Overall this is what the function does:The function accepts no parameters and returns an integer input provided by the user. However, it does not enforce any constraints on the input value, meaning the user can enter any integer, not just those within the specified range of 1 to 100. Therefore, the functionality is to read and return an integer input from the user without validating it against the given constraints.

#Function 2:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100 for each test case, and a, b, c are lists of integers where each list contains n integers (1 ≤ a_i, b_i, c_i ≤ 100) and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_2():
    return input()
    #The program returns the input provided by the user, which is expected to be the values of t, n, and the lists a, b, c, where t is an integer (1 ≤ t ≤ 100), n is an integer (3 ≤ n ≤ 100), and each list contains n integers (1 ≤ a_i, b_i, c_i ≤ 100) with the condition that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
#Overall this is what the function does:The function accepts no parameters and returns the raw input provided by the user, which is expected to be a string representation of the values for t, n, and the lists a, b, c. However, it does not enforce or validate any constraints on these values, such as the expected ranges for t and n, or the uniqueness of elements within the lists. Therefore, it simply captures user input without any built-in checks for correctness or format.

#Function 3:
#State of the program right berfore the function call: t is an integer (1 ≤ t ≤ 100) representing the number of test cases; for each test case, n is an integer (3 ≤ n ≤ 100) representing the number of elements in the sequences; a, b, and c are lists of n integers (1 ≤ a_i, b_i, c_i ≤ 100) with the constraints that a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all i.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a list of integers parsed from the input string, which contains n integers separated by spaces, where each integer is in the range from 1 to 100.
#Overall this is what the function does:The function accepts no parameters and retrieves input from the user, parsing it into a list of integers. It returns a map object containing integers that represent a sequence of numbers separated by spaces. Each integer is expected to be in the range from 1 to 100. However, since the function does not handle any input validation, any input that does not conform to these specifications could lead to unexpected behavior or errors.

#Function 4:
#State of the program right berfore the function call: t is an integer where 1 ≤ t ≤ 100, n is an integer where 3 ≤ n ≤ 100 for each test case, a, b, and c are sequences of n integers with values between 1 and 100, and for each i, a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i].
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object that converts the input sequence of integers into strings, based on the provided input values.
#Overall this is what the function does:The function accepts no parameters and returns a map object that converts a sequence of space-separated integers read from input into strings. It does not handle any potential cases where the input could be malformed or not conforming to the expected format, such as non-integer values.

#Function 5:
#State of the program right berfore the function call: The function processes multiple test cases where each test case consists of an integer n (3 ≤ n ≤ 100) followed by three sequences of n integers (a, b, c) such that for each index i (1 ≤ i ≤ n), a[i] ≠ b[i], a[i] ≠ c[i], and b[i] ≠ c[i]. Each integer in the sequences is within the range 1 to 100. The total number of test cases t is between 1 and 100.
def func_5():
    return list(func_3())
    #The program returns a list containing the results of the function func_3() for multiple test cases, where each test case consists of three sequences of integers with specified conditions.
#Overall this is what the function does:The function `func_5` does not accept any parameters and returns a list containing the results of the function `func_3()` for multiple test cases. Each test case consists of three sequences of integers, with the constraints that for each index, the integers in the sequences are distinct and within the range of 1 to 100, and the total number of test cases can range from 1 to 100. Additionally, the function assumes that `func_3()` is defined elsewhere and is responsible for processing these test cases.

#Function 6:
#State of the program right berfore the function call: The input consists of an integer t (1 ≤ t ≤ 100) representing the number of test cases, and for each test case, an integer n (3 ≤ n ≤ 100) followed by three sequences of n integers each: a, b, and c, where each element in the sequences satisfies 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function initializes a new thread to execute the `main` function, which is expected to handle multiple test cases involving integer inputs and sequences, but does not itself process any inputs or produce any outputs directly. It simply sets up the environment for concurrency without returning any results or handling the input parameters.

#Function 7:
#State of the program right berfore the function call: item is a tuple containing three sequences of integers (a, b, c), where each sequence has exactly n elements (3 ≤ n ≤ 100) and all elements are in the range [1, 100]. Additionally, for each index i, the conditions a[i] ≠ b[i], a[i] ≠ c[i], and b[i] ≠ c[i] must hold true.
def func_7(item):
    return item[1]
    #The program returns the second sequence of integers from the tuple 'item'
#Overall this is what the function does:The function accepts a tuple `item` containing three sequences of integers and returns the second sequence of integers from the tuple. It assumes that the input tuple will always have three sequences, each with exactly `n` elements, where `3 ≤ n ≤ 100` and all elements are in the range [1, 100]. The function does not handle any validation or edge cases regarding the structure or content of the tuple beyond this assumption.

#Function 8:
#State of the program right berfore the function call: l is a list of test cases, where each test case consists of a positive integer n followed by three lists of n integers each, representing sequences a, b, and c, with the constraints that 3 ≤ n ≤ 100 and 1 ≤ a_i, b_i, c_i ≤ 100, and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list 'l' sorted in descending order based on the values returned by the function 'getKey' applied to each test case, where each test case consists of a positive integer n followed by three lists of n integers each.
#Overall this is what the function does:The function accepts a list of test cases, where each test case consists of a positive integer followed by three lists of integers. It returns the list sorted in descending order based on the values returned by the function 'getKey' applied to each test case. The function does not handle cases where 'getKey' might raise an error, nor does it validate the input format or constraints beyond what is assumed in the annotations.

#Function 9:
#State of the program right berfore the function call: n is an integer representing the number of elements in the sequences (3 ≤ n ≤ 100), m is an integer representing the number of test cases (1 ≤ m ≤ 100), and num is a list of tuples, where each tuple contains three lists of integers (a, b, c) of size n, with each integer in the range 1 to 100 and ensuring that a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i] for all i.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list containing 'm' elements, each of which is the list 'num' that consists of tuples with three lists of integers (a, b, c) of size 'n'.
#Overall this is what the function does:The function accepts an integer `n`, an integer `m`, and a list of tuples `num`. It returns a list containing `m` elements, where each element is a copy of the list `num`. Each element in `num` consists of three lists of integers (`a`, `b`, `c`) of size `n`. The function does not validate the contents of `num` or check for the uniqueness of elements across `a`, `b`, and `c`, as specified in the annotations.

#Function 10:
#State of the program right berfore the function call: x is a list of tuples, where each tuple contains three sequences of integers (a, b, c) of length n (3 ≤ n ≤ 100) for each test case, and the integers in each sequence are such that 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_10(x):
    return x and not x & x - 1
    #The program returns the list of tuples `x` and the result of the bitwise expression `not x & (x - 1)`, which involves the tuples in `x`.
#Overall this is what the function does:The function accepts a list of tuples `x`, where each tuple contains three distinct integers. It returns `True` if `x` is not empty and contains only one unique tuple (the result of the bitwise expression `not x & (x - 1)` evaluates to `True`), otherwise it returns `False` if `x` is empty or contains multiple tuples. The overall result of the function is not directly related to the contents of the tuples themselves.

#Function 11:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100, and a, b, c are lists of integers where each list has n elements, with each element 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the integer n without the '0b' prefix
#Overall this is what the function does:The function accepts an integer `n` and returns its binary representation as a string without the '0b' prefix. It does not handle invalid values of `n` outside the specified range, but given the preconditions, it will always return a valid binary string for any integer `n` in the range of 3 to 100.

#Function 12:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100. For each test case, there are three sequences a, b, and c, each containing n integers where 1 ≤ a_i, b_i, c_i ≤ 100, and it is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of the digits of the integer n, where n is an integer such that 3 ≤ n ≤ 100
#Overall this is what the function does:The function accepts an integer `n` (where 3 ≤ n ≤ 100) and returns a list of the individual digits of `n`. The input constraints ensure that `n` is always a valid integer within this range, and the function accurately converts `n` to a string, extracts each digit, and returns them as integers in a list format.

#Function 13:
#State of the program right berfore the function call: n is an integer representing the number of elements in the sequences (3 ≤ n ≤ 100), and r is a list of tuples such that each tuple contains three integers (a_i, b_i, c_i) with 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for each i.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of the combination formula involving the factorial of n and the factorial of the elements in r, adjusted by the maximum of (n - r) and 1.
#Overall this is what the function does:The function accepts an integer `n` and a list of tuples `r`, and it calculates the combination result using the factorial of `n` and the integer `r`. However, the implementation appears to incorrectly use `r` as an integer in the factorial calculation, while `r` should represent the number of selections being made (which is not directly provided from the tuples). The function does not handle potential edge cases related to the tuple contents or the implications of choosing values from `r`, resulting in an incorrect calculation if `r` is not a single integer or not properly defined in the context of combinations.

#Function 14:
#State of the program right berfore the function call: x is a list of integers where each element corresponds to the sequences a_1, a_2, …, a_n, b_1, b_2, …, b_n, c_1, c_2, …, c_n for multiple test cases, and y is an integer representing the number of test cases such that 1 ≤ y ≤ 100 and for each test case, the number of elements n (3 ≤ n ≤ 100) in the sequences is followed by three lists of integers where each integer is between 1 and 100 and satisfies a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the list of integers `x` divided by the integer `y`, representing the sequences for each test case, with each test case processed accordingly.
    else :
        return x // y + 1
        #The program returns the integer result of the list of integers `x` divided by the integer `y` plus 1, where `x` is not divisible by `y`.
#Overall this is what the function does:The function accepts a list of integers `x` and an integer `y`. It attempts to divide a single integer `x` by `y` and returns the result of this division, either as `x // y` or `x // y + 1` depending on whether `x` is divisible by `y`. However, the function does not process multiple test cases as suggested by the annotations, and it does not handle the sequence of integers in `x` correctly. Instead, it assumes `x` is a single integer, which is inconsistent with the expected input structure described in the annotations. Therefore, it lacks any functionality for handling the multiple test cases correctly.

#Function 15:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), y is an integer representing the number of elements in the given sequences (3 ≤ y ≤ 100), and p is a list of tuples where each tuple contains three lists of integers a, b, and c (1 ≤ a_i, b_i, c_i ≤ 100) such that for each i, a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the final value computed from the expression `x * x % p` after all iterations, `p` is a list of tuples containing three lists of integers, and `res` is updated based on the number of times `y` was odd during the iterations.
    return res
    #The program returns the value of 'res', which is updated based on the number of times 'y' was odd during the iterations.
#Overall this is what the function does:The function accepts an integer `x` (number of test cases), an integer `y` (number of elements in the sequences), and a list `p` of tuples containing three lists of integers. The function computes and returns the result of exponentiation by squaring, specifically calculating \( x^y \mod p \). It does not directly utilize the contents of `p` in the computation, which may be misleading based on the annotations. Additionally, since `x` is modified to `x % p`, and `p` is expected to be an integer during this operation, it could raise an error if `p` is not an integer.

#Function 16:
#State of the program right berfore the function call: x is a positive integer representing the number of test cases (1 ≤ x ≤ 100), and y is a list of tuples, each containing an integer n (3 ≤ n ≤ 100) followed by three lists of integers a, b, and c, where each list contains n integers (1 ≤ a_i, b_i, c_i ≤ 100) such that a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all i.
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is a non-empty tuple containing the last value of `y`, `y` is the result of `x % y`, where `x` is a positive integer and `y` is an empty tuple, indicating that the loop has terminated.
    return x
    #The program returns the non-empty tuple 'x' containing the last value of 'y', where 'y' is the result of 'x % y' and 'y' is an empty tuple, indicating the loop has terminated.
#Overall this is what the function does:The function accepts a positive integer `x` and a list of tuples `y`. It performs a while loop that continues until `y` is empty, where it repeatedly updates `x` with the value of `y` and `y` with the result of `x % y`. Eventually, it returns the last non-empty value of `x`, which represents the result of the last computation before `y` became empty. However, the function does not utilize the contents of the tuples in `y` and does not return any meaningful results related to the test cases described in the input.

#Function 17:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100, and for each i (1 ≤ i ≤ n), a_i, b_i, c_i are integers such that 1 ≤ a_i, b_i, c_i ≤ 100 with a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer such that 3 ≤ `n` ≤ 100; for each `i` (1 ≤ `i` ≤ `n`), `a_i`, `b_i`, `c_i` are integers such that 1 ≤ `a_i`, `b_i`, `c_i` ≤ 100 with `a_i` ≠ `b_i`, `a_i` ≠ `c_i`, `b_i` ≠ `c_i`; `n` is greater than 1.
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *`n` is an integer such that 3 < `n` ≤ 100; for each `i` (1 ≤ `i` ≤ `n`), `a_i`, `b_i`, `c_i` are integers such that 1 ≤ `a_i`, `b_i`, `c_i` ≤ 100 with `a_i` ≠ `b_i`, `a_i` ≠ `c_i`, `b_i` ≠ `c_i`; `n` is greater than 1.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer such that 3 < `n` ≤ 100 and `n` is not divisible by 2 or 3; for each `i` (1 ≤ `i` ≤ `n`), `a_i`, `b_i`, `c_i` are integers such that 1 ≤ `a_i`, `b_i`, `c_i` ≤ 100 with `a_i` ≠ `b_i`, `a_i` ≠ `c_i`, `b_i` ≠ `c_i`; `n` is greater than 1.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is an integer such that 3 < `n` ≤ 100, `n` is not divisible by 2 or 3, `i` is the smallest integer greater than or equal to the square root of `n`, increased in steps of 6 until `i * i` exceeds `n`. The loop terminates without finding any divisors among `i` or `i + 2`.
    return True
    #The program returns True, indicating that n is a prime number and has no divisors found among the checked values of i and i + 2.
#Overall this is what the function does:The function accepts an integer `n` within the range of 3 to 100 and returns True if `n` is a prime number. It returns False if `n` is less than or equal to 1, less than or equal to 3, or if `n` is divisible by 2 or 3. Additionally, it checks for divisibility by numbers of the form `6k ± 1` up to the square root of `n`, returning False if any divisors are found. If `n` passes all these checks, it is confirmed to be prime, and the function returns True.

#Function 18:
#State of the program right berfore the function call: t is an integer (1 ≤ t ≤ 100), n is an integer (3 ≤ n ≤ 100) for each test case, a, b, and c are lists of n integers (1 ≤ a_i, b_i, c_i ≤ 100) such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function does not accept any parameters and reads multiple test cases from an input file, processing three lists of integers `a`, `b`, and `c` which follow specific constraints. However, the function does not return any values or perform any computations based on these lists, as it only sets up input and output redirection. Therefore, it lacks any evaluative or output functionality related to the test cases described.

#Function 19:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100 for each test case, and a, b, c are lists of integers of length n where each element is in the range 1 ≤ a_i, b_i, c_i ≤ 100 and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_19():
    for _ in range(func_1()):
        n = func_1()
        
        a = func_5()
        
        b = func_5()
        
        c = func_5()
        
        ans = [0] * n
        
        ans[0] = a[0]
        
        for i in range(1, n):
            if ans[i - 1] != a[i]:
                ans[i] = a[i]
            elif ans[i - 1] != b[i]:
                ans[i] = b[i]
            else:
                ans[i] = c[i]
        
        func_20(*ans)
        
    #State of the program after the  for loop has been executed: `t` is an integer such that 1 ≤ `t` ≤ 100; for each test case, `n` is an integer such that 3 ≤ `n` ≤ 100; `a`, `b`, and `c` are lists of integers of length `n`; `ans` is a list of length `n` ensuring that consecutive values in `ans` are not equal; `func_20` is called with `*ans` for each test case.
#Overall this is what the function does:The function accepts no parameters and processes multiple test cases, each involving three lists `a`, `b`, and `c` of integers. It constructs a new list `ans` of the same length as the input lists, ensuring that no two consecutive elements in `ans` are equal. It initializes the first element of `ans` with the first element of `a`, then iteratively assigns values from `a`, `b`, or `c` to `ans` based on the condition that the chosen value must not be equal to the previous element in `ans`. After constructing `ans`, it calls `func_20` with `*ans` for each test case. The function does not return any value.

#Function 20:
#State of the program right berfore the function call: args is a list of tuples, where each tuple contains four elements: an integer n (3 ≤ n ≤ 100), and three lists of integers a, b, and c, each containing n integers (1 ≤ a[i], b[i], c[i] ≤ 100) such that a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i] for all i.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a list of tuples containing integers and lists, `x` is the last tuple in `args`, `file` now contains the string representation of all tuples in `args` separated by ' ', and `at_start` is False.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a list of tuples containing integers and lists; `x` is the last tuple in `args`; `file` contains the string representation of all tuples in `args` separated by ' '; `at_start` is False; `file` is updated by writing the value returned by `kwargs.pop('end', '\n')`; if `kwargs` contains the key 'flush' with a value of True or 'flush' key does not exist, the flush operation is performed on the file object.
#Overall this is what the function does:The function accepts a list of tuples `args`, where each tuple consists of an integer `n` and three lists of integers `a`, `b`, and `c`, each containing `n` integers. It prints the string representation of each tuple in `args`, separated by a specified separator (default is a space) and followed by a specified end character (default is a newline). The function also allows for flushing the output stream if specified. However, the behavior of the function is not explicitly defined in terms of handling invalid input, such as the actual structure and content of the tuples, which may lead to unexpected results if the constraints are not adhered to.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.