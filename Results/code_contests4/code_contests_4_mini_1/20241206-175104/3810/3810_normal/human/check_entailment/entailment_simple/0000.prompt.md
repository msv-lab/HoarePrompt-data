
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Alexey, a merry Berland entrant, got sick of the gray reality and he zealously wants to go to university. There are a lot of universities nowadays, so Alexey is getting lost in the diversity — he has not yet decided what profession he wants to get. At school, he had bad grades in all subjects, and it's only thanks to wealthy parents that he was able to obtain the graduation certificate.

The situation is complicated by the fact that each high education institution has the determined amount of voluntary donations, paid by the new students for admission — ni berubleys. He cannot pay more than ni, because then the difference between the paid amount and ni can be regarded as a bribe!

Each rector is wearing the distinctive uniform of his university. Therefore, the uniform's pockets cannot contain coins of denomination more than ri. The rector also does not carry coins of denomination less than li in his pocket — because if everyone pays him with so small coins, they gather a lot of weight and the pocket tears. Therefore, a donation can be paid only by coins of denomination x berubleys, where li ≤ x ≤ ri (Berland uses coins of any positive integer denomination). Alexey can use the coins of different denominations and he can use the coins of the same denomination any number of times. When Alexey was first confronted with such orders, he was puzzled because it turned out that not all universities can accept him! Alexey is very afraid of going into the army (even though he had long wanted to get the green uniform, but his dad says that the army bullies will beat his son and he cannot pay to ensure the boy's safety). So, Alexey wants to know for sure which universities he can enter so that he could quickly choose his alma mater.

Thanks to the parents, Alexey is not limited in money and we can assume that he has an unlimited number of coins of each type.

In other words, you are given t requests, each of them contains numbers ni, li, ri. For each query you need to answer, whether it is possible to gather the sum of exactly ni berubleys using only coins with an integer denomination from li to ri berubleys. You can use coins of different denominations. Coins of each denomination can be used any number of times.

Input

The first line contains the number of universities t, (1 ≤ t ≤ 1000) Each of the next t lines contain three space-separated integers: ni, li, ri (1 ≤ ni, li, ri ≤ 109; li ≤ ri).

Output

For each query print on a single line: either "Yes", if Alexey can enter the university, or "No" otherwise.

Examples

Input

2
5 2 3
6 4 5


Output

Yes
No

Note

You can pay the donation to the first university with two coins: one of denomination 2 and one of denomination 3 berubleys. The donation to the second university cannot be paid.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: t is an integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, and ri are integers such that (1 ≤ ni, li, ri ≤ 10^9) and li ≤ ri.
def func_1():
    return int(input())
    #The program returns an integer input value, which represents the number of universities.

#Function 2:
#State of the program right berfore the function call: t is a positive integer representing the number of universities (1 ≤ t ≤ 1000), and for each university request, ni, li, and ri are integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_2():
    return input()
    #The program returns the input data for the universities, which consists of integers ni, li, and ri for each request, where t is the number of universities.

#Function 3:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each query, ni, li, and ri are integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a list of integers parsed from the input string, which consists of space-separated integers. Each integer is bounded by the conditions 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.

#Function 4:
#State of the program right berfore the function call: The function does not take any parameters, and it reads input from standard input consisting of an integer t (1 ≤ t ≤ 1000) followed by t lines, each containing three space-separated integers ni, li, and ri (1 ≤ ni, li, ri ≤ 10^9; li ≤ ri).
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representations of the integers read from standard input, which includes the integer t followed by t sets of three space-separated integers (ni, li, ri).

#Function 5:
#State of the program right berfore the function call: t is a positive integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_5():
    return list(func_3())
    #The program returns a list generated by func_3() based on the positive integers representing the number of universities and their corresponding values (ni, li, ri)

#Function 6:
#State of the program right berfore the function call: t is a positive integer representing the number of universities, and for each university request, ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a list of t integers where each integer is a tuple containing three integers ni, li, ri (1 ≤ ni, li, ri ≤ 10^9; li ≤ ri), representing the donation amount and the coin denomination limits for each university.
def func_7(item):
    return item[1]
    #The program returns the second tuple in the list 'item', which contains three integers representing the donation amount and coin denomination limits for a university.

#Function 8:
#State of the program right berfore the function call: l is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The length of the list l is an integer t where 1 ≤ t ≤ 1000.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list of tuples 'l' sorted in descending order based on the criteria defined in the function 'getKey'

#Function 9:
#State of the program right berfore the function call: n is a positive integer representing the donation amount, m is a positive integer representing the minimum denomination of coins, and num is a positive integer representing the maximum denomination of coins, with the condition that m ≤ num.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list with 'n' rows and 'm' columns, where each element is the value of 'num'

#Function 10:
#State of the program right berfore the function call: x is a list of tuples, where each tuple contains three integers ni, li, and ri (1 ≤ ni, li, ri ≤ 10^9; li ≤ ri), and the length of the list x is between 1 and 1000.
def func_10(x):
    return x and not x & x - 1
    #The program returns the list of tuples x and the result of the expression 'not x & (x - 1)', which evaluates whether the list x contains exactly one element that is a power of two.

#Function 11:
#State of the program right berfore the function call: n is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri, and the length of the list n is between 1 and 1000.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the list n, after converting n to an integer, and removing the '0b' prefix.

#Function 12:
#State of the program right berfore the function call: n is a list of tuples, each containing three integers (ni, li, ri) where 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The length of n is an integer t such that 1 ≤ t ≤ 1000.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers representing the string conversion of the list of tuples n, where each tuple contains three integers (ni, li, ri).

#Function 13:
#State of the program right berfore the function call: n is a positive integer representing the donation amount, r is a list of tuples where each tuple contains three integers (ni, li, ri) representing the donation amount, minimum coin denomination, and maximum coin denomination respectively, for each university query. The number of queries is such that 1 <= len(r) <= 1000 and 1 <= ni, li, ri <= 10^9 with li <= ri.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the number of ways to distribute n donation amount into r coins, calculated using the formula for combinations based on the factorial of n and the factorial of r.

#Function 14:
#State of the program right berfore the function call: x is a positive integer representing the number of universities (1 ≤ x ≤ 1000), and y is a list of tuples, where each tuple contains three positive integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer result of dividing the positive integer x by the list of tuples y, where x is a positive integer representing the number of universities and y is a list of tuples containing positive integers.
    else :
        return x // y + 1
        #The program returns the result of integer division of x by the list y plus 1, but since x is not divisible by y, the program will return a value greater than 1

#Function 15:
#State of the program right berfore the function call: x is a positive integer representing the donation amount ni, y is a positive integer representing the minimum coin denomination li, and p is a positive integer representing the maximum coin denomination ri, such that 1 ≤ x, y, p ≤ 10^9 and y ≤ p.
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is the accumulated result of `x` raised to the power of the number of 1s in the binary representation of the original `y`, `x` is the final value after all squarings modulo `p`, `p` remains unchanged.
    return res
    #The program returns the accumulated result 'res' of 'x' raised to the power of the number of 1s in the binary representation of 'y' which is 0

#Function 16:
#State of the program right berfore the function call: x is an integer representing the number of universities (1 ≤ x ≤ 1000), and for each university, y is a tuple containing three integers (n_i, l_i, r_i) where 1 ≤ n_i, l_i, r_i ≤ 10^9 and l_i ≤ r_i.
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is empty, `x` is the GCD of the integers from the original values of `y`
    return x
    #The program returns the GCD of the integers from the original values of an empty list 'y', which is undefined or 0 since there are no integers available to calculate the GCD.

#Function 17:
#State of the program right berfore the function call: n is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The length of the list n is between 1 and 1000.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The length of the list `n` is greater than 1, and the length of `n` is between 1 and 1000.
    if (n <= 3) :
        return True
        #The program returns True, indicating a successful condition or state.
    #State of the program after the if block has been executed: *`n` is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The length of the list `n` is greater than 3, and the length of `n` is between 1 and 1000.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The length of the list `n` is greater than 3 and between 1 and 1000. The length of `n` is not divisible by 2 and is not divisible by 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `i` is greater than 5, `n` contains at least one tuple where at least one integer is greater than or equal to `i * i`, and `n` is an integer.
    return True
    #The program returns True, indicating that the condition based on 'i' and the tuple in 'n' is satisfied.

#Function 18:
#State of the program right berfore the function call: There are t queries (1 ≤ t ≤ 1000), and for each query, ni, li, ri are integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000) representing the number of university queries, and each query consists of three integers ni, li, ri (1 ≤ ni, li, ri ≤ 10^9; li ≤ ri) where ni is the exact amount of money needed, and li and ri define the range of coin denominations that can be used.
def func_19():
    for _ in range(func_1()):
        n, l, r = func_3()
        
        low = 1
        
        high = 1000000000
        
        f = 0
        
        while low <= high:
            mid = (low + high) // 2
            x = l * mid
            y = r * mid
            if x <= n and n <= y:
                f = 1
                break
            if y < n:
                low = mid + 1
            else:
                high = mid - 1
        
        if f:
            func_20('Yes')
        else:
            func_20('No')
        
    #State of the program after the  for loop has been executed: `low` is greater than `high` for each query, `f` indicates whether there exists a valid `mid` for each query (1 if found, 0 if not), `n`, `l`, `r`, and `t` retain the values returned by `func_3()` for each respective query, and the function `func_20` is called with 'Yes' or 'No' based on the value of `f` for each query.

#Function 20:
#State of the program right berfore the function call: t is an integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, ri are integers such that (1 ≤ ni, li, ri ≤ 10^9) and li ≤ ri.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `at_start` is False, `args` is written to `file` with separators between elements if `args` is not empty; if `args` is empty, `at_start` remains True.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`at_start` is False, the file is written with either `kwargs['end']` or a newline character. If the 'flush' key is removed from `kwargs` with its value being True, the file is flushed to ensure all data is written out.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
