
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: This problem differs from the previous one only in the absence of the constraint on the equal length of all numbers a_1, a_2, ..., a_n.

A team of SIS students is going to make a trip on a submarine. Their target is an ancient treasure in a sunken ship lying on the bottom of the Great Rybinsk sea. Unfortunately, the students don't know the coordinates of the ship, so they asked Meshanya (who is a hereditary mage) to help them. He agreed to help them, but only if they solve his problem.

Let's denote a function that alternates digits of two numbers f(a_1 a_2 ... a_{p - 1} a_p, b_1 b_2 ... b_{q - 1} b_q), where a_1 ... a_p and b_1 ... b_q are digits of two integers written in the decimal notation without leading zeros.

In other words, the function f(x, y) alternately shuffles the digits of the numbers x and y by writing them from the lowest digits to the older ones, starting with the number y. The result of the function is also built from right to left (that is, from the lower digits to the older ones). If the digits of one of the arguments have ended, then the remaining digits of the other argument are written out. Familiarize with examples and formal definitions of the function below.

For example: $$$f(1111, 2222) = 12121212 f(7777, 888) = 7787878 f(33, 44444) = 4443434 f(555, 6) = 5556 f(111, 2222) = 2121212$$$

Formally,

  * if p ≥ q then f(a_1 ... a_p, b_1 ... b_q) = a_1 a_2 ... a_{p - q + 1} b_1 a_{p - q + 2} b_2 ... a_{p - 1} b_{q - 1} a_p b_q; 
  * if p < q then f(a_1 ... a_p, b_1 ... b_q) = b_1 b_2 ... b_{q - p} a_1 b_{q - p + 1} a_2 ... a_{p - 1} b_{q - 1} a_p b_q. 



Mishanya gives you an array consisting of n integers a_i, your task is to help students to calculate ∑_{i = 1}^{n}∑_{j = 1}^{n} f(a_i, a_j) modulo 998 244 353.

Input

The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of elements in the array. The second line of the input contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9) — the elements of the array.

Output

Print the answer modulo 998 244 353.

Examples

Input


3
12 3 45


Output


12330

Input


2
123 456


Output


1115598
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 100,000, and a is a list of n integers where each integer a_i is in the range 1 ≤ a_i ≤ 10^9.
def func_1():
    mod = 998244353
    n = int(input())
    l1 = list(input().split())
    arr = [0] * 10
    for item in l1:
        arr[len(item) - 1] += 1
        
    #State of the program after the  for loop has been executed: `n` is a positive integer such that 1 ≤ `n` ≤ 100,000; `a` is a list of `n` integers where each integer `a_i` is in the range 1 ≤ `a_i` ≤ 10^9; `mod` is 998244353; `l1` is a list of strings containing `n` strings; `item` is the last string in `l1`; `arr` contains the counts of strings of lengths 1 to 10, where `arr[i]` is the number of strings in `l1` of length `i + 1`.
    ans = 0
    for item in l1:
        for i in range(1, 11):
            if arr[i - 1] == 0:
                continue
            x = len(item)
            res = 0
            if x <= i:
                for j in range(x - 1, -1, -1):
                    res = (res + int(item[j]) * pow(10, (x - j - 1) * 2, mod)) % mod
                    res = (res + int(item[j]) * pow(10, (x - j) * 2 - 1, mod)) % mod
                ans = ans + arr[i - 1] * res
            else:
                x -= 1
                i -= 1
                j = 0
                while x > i:
                    res = (res + 2 * int(item[j]) * pow(10, x - i + 2 * (i + 1) - 1,
                        mod)) % mod
                    x -= 1
                    j += 1
                i += 1
                x = len(item)
                for j in range(i - 1, -1, -1):
                    res = (res + int(item[j + (x - i)]) * pow(10, (i - j - 1) * 2, mod)
                        ) % mod
                    res = (res + int(item[j + (x - i)]) * pow(10, (i - j) * 2 - 1, mod)
                        ) % mod
                ans = ans + arr[i - 1] * res
        
    #State of the program after the  for loop has been executed: `n` is a positive integer such that 1 ≤ `n` ≤ 100,000; `l1` is a list of strings containing `n` strings; `item` is the last string in `l1`; `x` is the length of `item`; `res` is the final computed result based on the last string; `ans` is the accumulated result from all iterations.
    print(ans)

#Function 2:
#State of the program right berfore the function call: n is a positive integer such that 1 <= n <= 100000, and a is a list of n integers where each integer is between 1 and 10^9.
def power(x, y, p):
    res = 1
    x = x % p
    while y > 0:
        if y & 1 == 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is updated based on the original value of `y` and the corresponding powers of `x` modulo `p`, `x` is updated to the final value based on the initial value of `x` modulo `p`.
    return res
    #The program returns the value of 'res' that is updated based on the original value of 'y' and the corresponding powers of 'x' modulo 'p'

#Function 3:
#State of the program right berfore the function call: xs is a list of integers where each integer is between 1 and 10^9, and the length of the list n is between 1 and 100,000.
def count_next_smaller_elements(xs):
    ys = sorted((x, i) for i, x in enumerate(xs))
    zs = [0] * len(ys)
    for i in range(1, len(ys)):
        zs[ys[i][1]] = zs[ys[i - 1][1]]
        
        if ys[i][0] != ys[i - 1][0]:
            zs[ys[i][1]] += 1
        
    #State of the program after the  for loop has been executed: `xs` is a list of integers, `ys` is a list of tuples containing sorted integers and their original indices, `zs` is a list where each element represents the count of distinct integers in `xs` up to that index, with `zs[ys[0][1]]` initialized to 0 and incremented for each unique integer in `ys`.
    ts = [0] * (zs[ys[-1][1]] + 1)
    us = [0] * len(xs)
    for i in range(len(xs) - 1, -1, -1):
        x = zs[i] + 1
        
        while True:
            us[i] += ts[x - 1]
            x -= x & -x
            if x <= 0:
                break
            x = zs[i] + 1
        
        while True:
            x += x & -x
            if x > len(ts):
                break
            ts[x - 1] += 1
        
    #State of the program after the  for loop has been executed: `ts` is a list where each element reflects the cumulative count of contributions from previous indices, `us` is updated based on contributions from `ts` throughout all iterations, `i` is -1 after processing all indices in `xs`, and `x` is greater than the length of `ts` after the last iteration of the loop.
    return us
    #The program returns the updated value of 'us' based on contributions from the list 'ts' throughout all iterations.

#Function 4:
#State of the program right berfore the function call: zero is an integer that defaults to 0. The function calculates a value based on an array of integers a_i where 1 ≤ n ≤ 100,000 and 1 ≤ a_i ≤ 10^9.
def func_2(zero):
    conv = ord if py2 else lambda x: x
    A = []
    numb = zero
    sign = 1
    i = 0
    s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0'[0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-'[0]:
                sign = -1
            elif s[i] != b'\r'[0]:
                A.append(sign * numb)
                numb = zero
                sign = 1
            
            i += 1
            
        #State of the program after the loop has been executed: `zero` is an integer that defaults to 0; `conv` is assigned the value of `ord` if `py2` is true or a lambda function otherwise; `A` contains the parsed integers from the string `s`; `numb` is 0; `sign` is 1; `i` is the length of the string `s`.
    except:
        pass
    #State of the program after the try-except block has been executed: `zero` is an integer that defaults to 0; `conv` is assigned the value of `ord` if `py2` is true or a lambda function otherwise; `A` contains the parsed integers from the string `s`; `numb` is 0; `sign` is 1; `i` is the length of the string `s`.
    if (s and s[-1] >= b'0'[0]) :
        A.append(sign * numb)
    #State of the program after the if block has been executed: *`zero` is an integer that defaults to 0; `conv` is assigned the value of `ord` if `py2` is true or a lambda function otherwise; `A` contains the parsed integers from the string `s` followed by 0; `numb` is 0; `sign` is 1; `i` is the length of the string `s`. If the string `s` is not empty and its last character is greater than or equal to the ASCII value of '0', then `A` will include the parsed integers from `s` followed by 0.
    return A
    #The program returns the list A which contains the parsed integers from the string s followed by 0


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
