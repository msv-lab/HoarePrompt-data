
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Happy PMP is freshman and he is learning about algorithmic problems. He enjoys playing algorithmic games a lot.

One of the seniors gave Happy PMP a nice game. He is given two permutations of numbers 1 through n and is asked to convert the first one to the second. In one move he can remove the last number from the permutation of numbers and inserts it back in an arbitrary position. He can either insert last number between any two consecutive numbers, or he can place it at the beginning of the permutation.

Happy PMP has an algorithm that solves the problem. But it is not fast enough. He wants to know the minimum number of moves to convert the first permutation to the second. 

Input

The first line contains a single integer n (1 ≤ n ≤ 2·105) — the quantity of the numbers in the both given permutations. 

Next line contains n space-separated integers — the first permutation. Each number between 1 to n will appear in the permutation exactly once. 

Next line describe the second permutation in the same format.

Output

Print a single integer denoting the minimum number of moves required to convert the first permutation to the second.

Examples

Input

3
3 2 1
1 2 3


Output

2


Input

5
1 2 3 4 5
1 5 2 3 4


Output

1


Input

5
1 5 2 3 4
1 2 3 4 5


Output

3

Note

In the first sample, he removes number 1 from end of the list and places it at the beginning. After that he takes number 2 and places it between 1 and 3.

In the second sample, he removes number 5 and inserts it after 1.

In the third sample, the sequence of changes are like this: 

  * 1 5 2 3 4 
  * 1 4 5 2 3 
  * 1 3 4 5 2 
  * 1 2 3 4 5 

So he needs three moves.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 200,000; the first permutation and the second permutation are both lists of n unique integers, each containing numbers from 1 to n exactly once.
def func():
    n = int(sys.stdin.readline())
    start = [int(x) for x in sys.stdin.readline().split()]
    end = [int(x) for x in sys.stdin.readline().split()]
    start_m = {}
    for (index, val) in enumerate(start):
        start_m[val] = index
        
    #State of the program after the  for loop has been executed: `n` is a positive integer such that 1 ≤ `n` ≤ 200,000, `start` is a list of integers with at least `n` elements, `start_m` is a dictionary mapping each element in `start` to its corresponding index.
    end_m = {}
    for (index, val) in enumerate(end):
        end_m[val] = index
        
    #State of the program after the  for loop has been executed: `n` is a positive integer such that 1 ≤ `n` ≤ 200,000; `start` is a list of integers with at least `n` elements; `start_m` is a dictionary mapping each element in `start` to its corresponding index; `end` is a list with at least `n` elements; `end_m` is a dictionary mapping each element in `end` to its corresponding index in the list.
    res = 0
    for (v1, i1) in start_m.items():
        i2 = end_m[v1]
        
        n_moves = i2 - i1
        
        if n_moves < 0:
            n_moves = n - i1
        
        res = max(res, n_moves)
        
    #State of the program after the  for loop has been executed: `res` is the maximum number of moves calculated based on the indices of elements in `start` and `end`, `n_moves` is the final calculated number of moves from the last iteration, `start_m` is a dictionary mapping elements in `start` to their indices, `end_m` is a dictionary mapping elements in `end` to their indices.
    print(res)
#Overall this is what the function does:The function reads a positive integer n and two permutations of unique integers from 1 to n. It calculates the maximum number of moves required to rearrange the first permutation into the second by shifting elements around in a circular manner. The function then prints this maximum number of moves. It does not accept parameters directly, as it reads input from standard input.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
