To evaluate the given program against the problem description, we need to analyze the logic of the program and check if it correctly computes the distance from Harry's position to the place of the second meeting of the spell impulses.

The program reads three inputs: the length of the corridor (`l`), the speed of Harry's spell (`p`), and the speed of You-Know-Who's spell (`q`). It then calculates the distance to the point of the second collision using the formula:

```python
print(float(l) / (p + q)) * p
```

### Analysis of the Program:
1. **Input Handling**: The program uses `input()` to read values, which are strings by default. It converts `l` to a float, but `p` and `q` are still strings when used directly in the formula. Since Python allows implicit conversion of string to integer when used in arithmetic, this might work in practice, but it's not clear or safe.

2. **Formula**: The formula used is:
   \[
   \text{distance} = \left(\frac{l}{p + q}\right) \times p
   \]
   This formula correctly represents the distance from Harry to the collision point after the first meeting, as it is based on the ratio of speeds.

3. **Collision Point Calculation**: The program calculates the distance to the first collision point correctly. However, it does not explicitly handle the second meeting point. The second meeting point will also be at the same distance from Harry as the first collision due to the symmetry of the situation (since both spells travel the same distance back to their casters and then meet again).

### Edge Cases:
The program does not account for any edge cases in input handling:
- It assumes all values will be valid integers within the specified bounds.
- It does not handle cases where `p` or `q` might be zero, even though the problem guarantees that 1 ≤ p, q ≤ 500.

### Conclusion:
The program does correctly compute the distance from Harry to the collision point after the second meeting based on the provided formula. Since the formula correctly calculates the first collision and, due to their symmetrical behavior, the second collision will happen at the same point.

Thus, after evaluating the program against the problem statement and considering edge cases, I conclude:

Correctness: **True**. 

The program correctly implements the logic needed to find the distance for all valid input cases according to the problem description.