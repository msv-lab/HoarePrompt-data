
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given two segments [l_1; r_1] and [l_2; r_2] on the x-axis. It is guaranteed that l_1 < r_1 and l_2 < r_2. Segments may intersect, overlap or even coincide with each other.

<image> The example of two segments on the x-axis.

Your problem is to find two integers a and b such that l_1 ≤ a ≤ r_1, l_2 ≤ b ≤ r_2 and a ≠ b. In other words, you have to choose two distinct integer points in such a way that the first point belongs to the segment [l_1; r_1] and the second one belongs to the segment [l_2; r_2].

It is guaranteed that the answer exists. If there are multiple answers, you can print any of them.

You have to answer q independent queries.

Input

The first line of the input contains one integer q (1 ≤ q ≤ 500) — the number of queries.

Each of the next q lines contains four integers l_{1_i}, r_{1_i}, l_{2_i} and r_{2_i} (1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9, l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i}) — the ends of the segments in the i-th query.

Output

Print 2q integers. For the i-th query print two integers a_i and b_i — such numbers that l_{1_i} ≤ a_i ≤ r_{1_i}, l_{2_i} ≤ b_i ≤ r_{2_i} and a_i ≠ b_i. Queries are numbered in order of the input.

It is guaranteed that the answer exists. If there are multiple answers, you can print any.

Example

Input


5
1 2 1 2
2 6 3 4
2 4 1 3
1 2 1 3
1 4 5 8


Output


2 1
3 4
3 2
1 2
3 7
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: The input consists of an integer q (1 ≤ q ≤ 500) followed by q lines, each containing four integers l_1, r_1, l_2, r_2 (1 ≤ l_1 < r_1, 1 ≤ l_2 < r_2 ≤ 10^9) representing two segments on the x-axis.
def func_1():
    return int(input())
    #The program returns an integer input value q, followed by the integer inputs l_1, r_1, l_2, r_2 for each of the q segments on the x-axis.

#Function 2:
#State of the program right berfore the function call: There is an integer q (1 ≤ q ≤ 500) representing the number of queries. For each query, there are four integers l1, r1, l2, and r2 (1 ≤ l1 < r1, 1 ≤ l2 < r2 ≤ 10^9) representing the endpoints of two segments on the x-axis, such that l1 ≤ a ≤ r1 and l2 ≤ b ≤ r2, and a ≠ b.
def func_2():
    return input()
    #The program returns the input values representing the number of queries and the endpoints of the two segments, which includes integers q, l1, r1, l2, and r2 within specified ranges.

#Function 3:
#State of the program right berfore the function call: q is an integer such that 1 ≤ q ≤ 500, and for each query i (1 ≤ i ≤ q), l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} are integers such that 1 ≤ l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} ≤ 10^9, l_{1_i} < r_{1_i}, and l_{2_i} < r_{2_i}.
def func_3():
    return map(int, input().split(' '))
    #The program returns a list of integers obtained from splitting the input string by spaces.

#Function 4:
#State of the program right berfore the function call: The function handles multiple queries where each query consists of four integers l1, r1, l2, and r2 such that 1 ≤ l1 < r1 ≤ 10^9 and 1 ≤ l2 < r2 ≤ 10^9. The number of queries q is an integer such that 1 ≤ q ≤ 500.
def func_4():
    return map(str, input().split(' '))
    #The program returns a map object that converts the input string of space-separated integers into strings

#Function 5:
#State of the program right berfore the function call: There is an integer q (1 ≤ q ≤ 500) representing the number of queries, and for each query, there are four integers l1, r1, l2, r2 (1 ≤ l1 < r1, 1 ≤ l2 < r2 ≤ 10^9) representing the endpoints of two segments on the x-axis.
def func_5():
    return list(func_3())
    #The program returns the result of func_3() which processes the integer q representing the number of queries and the segments defined by the integers l1, r1, l2, r2 for each query.

#Function 6:
#State of the program right berfore the function call: The function handles multiple queries, where each query consists of four integers l1, r1, l2, r2 such that 1 ≤ l1 < r1, 1 ≤ l2 < r2 ≤ 10^9. The number of queries q is an integer such that 1 ≤ q ≤ 500.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: n is a positive integer representing the number of queries, and each query consists of four integers l_1, r_1, l_2, r_2 such that 1 ≤ l_1 < r_1 ≤ 10^9 and 1 ≤ l_2 < r_2 ≤ 10^9.
def func_7(n):
    sum = 0
    while n > 0:
        sum += int(n % 10)
        
        n = int(n / 10)
        
    #State of the program after the loop has been executed: `n` is 0, `sum` is the sum of the digits of the original value of `n`.
    return sum
    #The program returns the sum of the digits of the original value of n, which is 0, resulting in a sum of 0.

#Function 8:
#State of the program right berfore the function call: x is a list of tuples, where each tuple contains four integers l1, r1, l2, r2 such that 1 ≤ l1 < r1, 1 ≤ l2 < r2 ≤ 10^9, and the number of queries q is an integer such that 1 ≤ q ≤ 500.
def func_8(x):
    return x and not x & x - 1
    #The program returns the list of tuples 'x' and the result of the bitwise operation 'not x & (x - 1)' which is an integer representing the least significant bit that is set in 'x'

#Function 9:
#State of the program right berfore the function call: x is a positive integer representing the number of queries (1 ≤ x ≤ 500), and y is a list of tuples where each tuple contains four integers (l1, r1, l2, r2) such that 1 ≤ l1 < r1 ≤ 10^9 and 1 ≤ l2 < r2 ≤ 10^9.
def func_9(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the last non-zero tuple from `y`, `y` is 0, which occurs when the loop terminates after processing all queries.
    return x
    #The program returns the last non-zero tuple from 'y', which is 0, that occurs when the loop terminates after processing all queries.

#Function 10:
#State of the program right berfore the function call: a is a list of integers where each element is a tuple of four integers (l1, r1, l2, r2) representing the endpoints of two segments on the x-axis for q queries, with 1 ≤ q ≤ 500 and 1 ≤ l1, r1, l2, r2 ≤ 10^9, l1 < r1, and l2 < r2.
def func_10(a, b):
    if (a == 0) :
        return b, 0, 1
        #The program returns the value of b, which is undefined in the current context, along with the integers 0 and 1
    #State of the program after the if block has been executed: *`a` is a list of integers where each element is a tuple of four integers (l1, r1, l2, r2) representing the endpoints of two segments on the x-axis for q queries, with 1 ≤ q ≤ 500 and 1 ≤ l1, r1, l2, r2 ≤ 10^9, l1 < r1, and l2 < r2. The variable `a` is not equal to 0.
    gcd, x1, y1 = func_10(b % a, a)
    x = y1 - b // a * x1
    y = x1
    return gcd, x, y
    #The program returns gcd, x, and y where gcd is the greatest common divisor calculated from func_10, x is computed as y1 - b // a * x1, and y is equal to x1.

#Function 11:
#State of the program right berfore the function call: n is an integer representing the number of queries (1 ≤ n ≤ 500), and for each query, the integers l1, r1, l2, r2 are such that 1 ≤ l1 < r1 ≤ 10^9 and 1 ≤ l2 < r2 ≤ 10^9.
def func_11(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer representing the number of queries where n is greater than 1, and for each query, the integers `l1`, `r1`, `l2`, `r2` are such that 1 ≤ l1 < r1 ≤ 10^9 and 1 ≤ l2 < r2 ≤ 10^9.
    if (n <= 3) :
        return True
        #The program returns True, indicating a successful evaluation of the queries.
    #State of the program after the if block has been executed: *`n` is an integer representing the number of queries where `n` is greater than 3, and for each query, the integers `l1`, `r1`, `l2`, `r2` are such that 1 ≤ l1 < r1 ≤ 10^9 and 1 ≤ l2 < r2 ≤ 10^9.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer representing the number of queries where `n` is greater than 3, and for each query, the integers `l1`, `r1`, `l2`, `r2` are such that 1 ≤ l1 < r1 ≤ 10^9 and 1 ≤ l2 < r2 ≤ 10^9. `n` is neither divisible by 2 nor divisible by 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is an integer greater than or equal to 25 and is not divisible by 2 or 3; `i` is greater than or equal to 5 and has been incremented by 6 until `i * i` exceeds `n`.
    return True
    #The program returns True

#Function 12:
#State of the program right berfore the function call: n is a positive integer representing the number of queries, and for each query, l_1, r_1, l_2, and r_2 are integers such that 1 ≤ l_1 < r_1 ≤ 10^9 and 1 ≤ l_2 < r_2 ≤ 10^9.
def func_12(n):
    if (n == 0) :
        return 0, 1
        #The program returns the tuple (0, 1)
    #State of the program after the if block has been executed: *`n` is a positive integer representing the number of queries, and for each query, `l_1`, `r_1`, `l_2`, and `r_2` are integers such that 1 ≤ `l_1` < `r_1` ≤ 10^9 and 1 ≤ `l_2` < `r_2` ≤ 10^9. The value of `n` is greater than 0.
    p = func_12(n >> 1)
    c = p[0] * (2 * p[1] - p[0])
    d = p[0] * p[0] + p[1] * p[1]
    if (n & 1) :
        return c + 2 * d
        #The program returns c plus 2 times the value of d, where d is the sum of the squares of the two elements in the tuple p returned from func_12(n >> 1)
    else :
        return c + d
        #The program returns the sum of 'c' and 'd', where 'd' is the sum of the squares of the first two elements of the result from `func_12(n >> 1)`

#Function 13:
#State of the program right berfore the function call: q is an integer such that 1 ≤ q ≤ 500, and for each query, l1, r1, l2, r2 are integers satisfying 1 ≤ l1 < r1, 1 ≤ l2 < r2 ≤ 10^9.
def func_13():
    sys.stdin = open('input.txt', 'r')

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of queries (1 ≤ x ≤ 500), and y is a list of tuples where each tuple contains four integers (l1, r1, l2, r2) such that 1 ≤ l1 < r1 ≤ 10^9 and 1 ≤ l2 < r2 ≤ 10^9.
def func_14(x, y):
    res = 1
    while y > 0:
        if y & 1:
            res = res * x
        
        x = x * x
        
        y >>= 1
        
    #State of the program after the loop has been executed: `y` is 0, `res` is the result of raising the initial value of `x` to the power of the initial value of `y`, and `x` is the final value after squaring each time during the iterations.
    return res
    #The program returns the result of raising the initial value of x to the power of 0, which is 1, since any number raised to the power of 0 equals 1.

#Function 15:
#State of the program right berfore the function call: q is an integer between 1 and 500 inclusive, and for each query, l1, r1, l2, r2 are integers such that 1 ≤ l1 < r1 ≤ 10^9 and 1 ≤ l2 < r2 ≤ 10^9.
def func_15():
    q = func_1()
    for i in range(q):
        l1, r1, l2, r2 = func_3()
        
        func_16(l1, r2)
        
    #State of the program after the  for loop has been executed: `q` is an integer between 1 and 500 inclusive, `i` is `q - 1`, `l1`, `r1`, `l2`, and `r2` are the last values assigned from the final call to `func_3()`, `func_16(l1, r2)` has been called `q` times.

#Function 16:
#State of the program right berfore the function call: args is a list of integers where each query consists of four integers l1, r1, l2, r2 such that 1 ≤ l1 < r1 ≤ 10^9 and 1 ≤ l2 < r2 ≤ 10^9. The number of queries is a positive integer q (1 ≤ q ≤ 500).
def func_16():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` is a list of integers; `file` contains the string representation of all integers in `args`, separated by `sep`; `at_start` is False.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` is a list of integers, `file` is updated with the value of `kwargs.pop('end', '\n')`, `at_start` is False. If `kwargs.pop('flush', False)` is True, `file.flush()` is called to flush the stream.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
