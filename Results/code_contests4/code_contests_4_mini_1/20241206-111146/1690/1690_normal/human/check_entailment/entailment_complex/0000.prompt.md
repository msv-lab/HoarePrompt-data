
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Vasya is preparing a contest, and now he has written a statement for an easy problem. The statement is a string of length n consisting of lowercase Latin latters. Vasya thinks that the statement can be considered hard if it contains a subsequence hard; otherwise the statement is easy. For example, hard, hzazrzd, haaaaard can be considered hard statements, while har, hart and drah are easy statements. 

Vasya doesn't want the statement to be hard. He may remove some characters from the statement in order to make it easy. But, of course, some parts of the statement can be crucial to understanding. Initially the ambiguity of the statement is 0, and removing i-th character increases the ambiguity by a_i (the index of each character is considered as it was in the original statement, so, for example, if you delete character r from hard, and then character d, the index of d is still 4 even though you delete it from the string had).

Vasya wants to calculate the minimum ambiguity of the statement, if he removes some characters (possibly zero) so that the statement is easy. Help him to do it!

Recall that subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.

Input

The first line contains one integer n (1 ≤ n ≤ 10^5) — the length of the statement.

The second line contains one string s of length n, consisting of lowercase Latin letters — the statement written by Vasya.

The third line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 998244353).

Output

Print minimum possible ambiguity of the statement after Vasya deletes some (possibly zero) characters so the resulting statement is easy.

Examples

Input


6
hhardh
3 2 9 11 7 1


Output


5


Input


8
hhzarwde
3 2 6 9 4 8 7 1


Output


4


Input


6
hhaarr
1 2 3 4 5 6


Output


0

Note

In the first example, first two characters are removed so the result is ardh.

In the second example, 5-th character is removed so the result is hhzawde.

In the third example there's no need to remove anything.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), s is a string of length n consisting of lowercase Latin letters, and a is a list of n integers where each integer a_i (1 ≤ a_i ≤ 998244353) corresponds to the ambiguity increase of removing the i-th character of the string s.
def func():
    rstr = lambda : stdin.readline().strip()
    rints = lambda : [int(x) for x in stdin.readline().split()]
    n, s, a, ans, word = int(input()), rstr(), rints(), float('inf'), 'hard'
    for i in range(4):
        be, en, tem = 0, n, 0
        
        cur = 0
        
        for j in range(n):
            if cur == i:
                break
            elif s[j] == word[cur]:
                cur += 1
            be += 1
        
        cur = 3
        
        for j in range(n - 1, -1, -1):
            if cur == i:
                break
            elif s[j] == word[cur]:
                cur -= 1
            en -= 1
        
        for j in range(be, en):
            if s[j] == word[i]:
                tem += a[j]
        
        ans = min(ans, tem)
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `j` is -1, `be` is equal to `n`, `cur` is 0, 1, 2, or 3 based on the last matching, `s` contains `n` characters, `en` is less than or equal to `n`, `tem` is the sum of `a[j]` for indices where `s[j]` equals `word[3]`, and `ans` is the minimum of all calculated `tem` values across iterations.
    print(ans)
#Overall this is what the function does:The function accepts a positive integer `n`, a string `s` of length `n`, and a list `a` of `n` integers. It computes the minimum ambiguity increase by trying to match the string `s` with the word "hard" and calculates the total ambiguity increase for characters in `s` that correspond to the letters in "hard". If a character in `s` matches, it adds the associated ambiguity increase from list `a`. The function returns the minimum total ambiguity increase required to form "hard" from `s`. If "hard" cannot be formed, the function will return infinity, indicating that no valid matches were found.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
