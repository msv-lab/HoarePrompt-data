
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Consider a permutation p of length n, we build a graph of size n using it as follows: 

  * For every 1 ≤ i ≤ n, find the largest j such that 1 ≤ j < i and p_j > p_i, and add an undirected edge between node i and node j 
  * For every 1 ≤ i ≤ n, find the smallest j such that i < j ≤ n and p_j > p_i, and add an undirected edge between node i and node j 



In cases where no such j exists, we make no edges. Also, note that we make edges between the corresponding indices, not the values at those indices.

For clarity, consider as an example n = 4, and p = [3,1,4,2]; here, the edges of the graph are (1,3),(2,1),(2,3),(4,3).

A permutation p is cyclic if the graph built using p has at least one simple cycle. 

Given n, find the number of cyclic permutations of length n. Since the number may be very large, output it modulo 10^9+7.

Please refer to the Notes section for the formal definition of a simple cycle

Input

The first and only line contains a single integer n (3 ≤ n ≤ 10^6).

Output

Output a single integer 0 ≤ x < 10^9+7, the number of cyclic permutations of length n modulo 10^9+7.

Examples

Input


4


Output


16

Input


583291


Output


135712853

Note

There are 16 cyclic permutations for n = 4. [4,2,1,3] is one such permutation, having a cycle of length four: 4 → 3 → 2 → 1 → 4.

Nodes v_1, v_2, …, v_k form a simple cycle if the following conditions hold: 

  * k ≥ 3. 
  * v_i ≠ v_j for any pair of indices i and j. (1 ≤ i < j ≤ k) 
  * v_i and v_{i+1} share an edge for all i (1 ≤ i < k), and v_1 and v_k share an edge. 
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 10^6.
def func_1():
    return int(input())
    #The program returns an integer value input by the user, where the value must be within the range of 3 to 10^6.

#Function 2:
#State of the program right berfore the function call: n is a single integer such that 3 ≤ n ≤ 10^6.
def func_2():
    return list(map(int, input().split()))
    #The program returns a list of integers generated from user input, where the input consists of space-separated integers

#Function 3:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 10^6.
def func_3():
    s = input()
    return list(s[:len(s) - 1])
    #The program returns a list containing all characters of the string 's' except the last one.

#Function 4:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 10^6.
def func_4():
    return map(int, input().split())
    #The program returns a map object containing integers obtained from the input split into a list of strings, which can be converted to integers.

#Function 5:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 10^6.
def func_5():
    s = input()
    return s.split(' ')
    #The program returns a list of substrings obtained by splitting the string 's' at each space character

#Function 6:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 10^6.
def func_6(n):
    if (n == 1) :
        return [1]
        #The program returns the list containing the single integer 1
    #State of the program after the if block has been executed: *`n` is an integer such that 3 ≤ `n` ≤ 10^6, and `n` is not equal to 1.
    ans = []
    i = 2
    cap = sqrt(n)
    while i <= cap:
        if n % i == 0:
            ans.append(i)
            n = n // i
            cap = sqrt(n)
        else:
            i += 1
        
    #State of the program after the loop has been executed: `n` is an integer that is a prime factorization result or 1, `ans` contains all prime factors of the original value of the initial `n`, `i` is greater than `cap`, and `cap` is less than or equal to 1.
    if (n > 1) :
        ans.append(n)
    #State of the program after the if block has been executed: *`n` is an integer that is a prime factorization result or 1. If `n` is greater than 1, then `ans` contains all prime factors including the new value of `n`, `i` remains greater than `cap`, and `cap` is less than or equal to 1.
    return ans
    #The program returns the list 'ans' that contains all prime factors including the new value of 'n' if 'n' is greater than 1

#Function 7:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 10^6, and k is an integer.
def func_7(n, k):
    if (n == 1 or n == k) :
        return 1
        #The program returns the integer 1
    #State of the program after the if block has been executed: *`n` is an integer such that 3 ≤ `n` ≤ 10^6, `n` is not equal to 1 and `n` is not equal to `k`, and `k` is an integer.
    if (k > n) :
        return 0
        #The program returns 0
    else :
        a = math.factorial(n)
        b = math.factorial(k)
        c = math.factorial(n - k)
        div = a // (b * c)
        return div
        #The program returns the integer division result of the factorial of n by the product of the factorial of k and the factorial of (n - k)


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
