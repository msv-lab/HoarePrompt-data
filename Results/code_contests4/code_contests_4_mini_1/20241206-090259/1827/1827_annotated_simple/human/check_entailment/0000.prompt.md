
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: A direced graph is strongly connected if every two nodes are reachable from each other. In a strongly connected component of a directed graph, every two nodes of the component are mutually reachable.

Constraints

* 1 ≤ |V| ≤ 10,000
* 0 ≤ |E| ≤ 30,000
* 1 ≤ Q ≤ 100,000

Input

A directed graph G(V, E) and a sequence of queries where each query contains a pair of nodes u and v.


|V| |E|
s0 t0
s1 t1
:
s|E|-1 t|E|-1
Q
u0 v0
u1 v1
:
uQ-1 vQ-1


|V| is the number of nodes and |E| is the number of edges in the graph. The graph nodes are named with the numbers 0, 1,..., |V|-1 respectively.

si and ti represent source and target nodes of i-th edge (directed).

ui and vi represent a pair of nodes given as the i-th query.

Output

For each query, pinrt "1" if the given nodes belong to the same strongly connected component, "0" otherwise.

Example

Input

5 6
0 1
1 0
1 2
2 4
4 3
3 2
4
0 1
0 3
2 3
3 4


Output

1
0
1
1
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: frm is a directed graph represented as a list of edges where each edge is a tuple (si, ti) indicating a directed edge from si to ti, and to is a list of queries where each query is a tuple (ui, vi) representing a pair of nodes. The graph contains |V| nodes (0 to |V|-1) and |E| edges, with constraints 1 ≤ |V| ≤ 10,000 and 0 ≤ |E| ≤ 30,000. The number of queries Q is between 1 and 100,000.
def func_1(frm, to):
    g[frm].append(to)
    rg[to].append(frm)

#Function 2:
#State of the program right berfore the function call: now is a node in the directed graph represented by integers from 0 to |V|-1, used is a set of nodes that have been visited, and back_track is a data structure used to manage the traversal of the graph. The graph has |V| nodes (1 ≤ |V| ≤ 10,000) and |E| edges (0 ≤ |E| ≤ 30,000), and the queries consist of pairs of nodes (u, v) where 1 ≤ Q ≤ 100,000.
def func_2(now, used, back_track):
    used[now] = True
    for nx in g[now]:
        if not used[nx]:
            func_2(nx, used, back_track)
        
    #State of the program after the  for loop has been executed: `used[now]` is True, `g[now]` is a list of neighboring nodes, and `used[nx]` is True for all `nx` in `g[now]`.
    back_track.append(now)

#Function 3:
#State of the program right berfore the function call: now is an integer representing the current node, num_cmp is an integer representing the number of strongly connected components, used is a list of booleans indicating whether nodes have been visited, and cmp is a list of integers representing the component each node belongs to, where the number of nodes |V| is between 1 and 10,000 and the number of edges |E| is between 0 and 30,000.
def func_3(now, num_cmp, used, cmp):
    used[now] = True
    cmp[now] = num_cmp
    for nx in rg[now]:
        if not used[nx]:
            func_3(nx, num_cmp, used, cmp)
        
    #State of the program after the  for loop has been executed: `now` is the current node, `num_cmp` is the number of strongly connected components, `used` has all nodes reachable from `now` marked as `True`, and `cmp` has all reachable nodes from `now` assigned the value `num_cmp`.

#Function 4:
#State of the program right berfore the function call: n is a non-negative integer representing the number of nodes in the directed graph, and the graph is defined by a list of edges (pairs of integers) with constraints on the number of nodes (1 ≤ |V| ≤ 10,000) and edges (0 ≤ |E| ≤ 30,000). Each query consists of a pair of nodes (u, v) where 0 ≤ u, v < n.
def func_4(n):
    used = [False] * n
    back_track = []
    cmp = [-1] * n
    for v in xrange(n):
        if not used[v]:
            func_2(v, used, back_track)
        
    #State of the program after the  for loop has been executed: `used` is a list of length `n` with values indicating which nodes were visited (True for visited, False for unvisited), `back_track` is a list that may contain information related to the traversal of the nodes, `cmp` is a list of length `n` that remains unchanged and contains all values set to `-1`, and `n` is a non-negative integer representing the number of nodes in the directed graph.
    used = [False] * n
    num_cmp = 0
    for v in back_track[::-1]:
        if not used[v]:
            func_3(v, num_cmp, used, cmp)
            num_cmp += 1
        
    #State of the program after the  for loop has been executed: `used` is a list of length `n` indicating which nodes have been processed (True for processed, False for unprocessed); `back_track` is unchanged; `cmp` remains a list of length `n` with values updated based on processed nodes; `n` is a non-negative integer; `num_cmp` is the count of nodes processed (increased for each unprocessed node).
    return num_cmp, cmp
    #The program returns the count of processed nodes 'num_cmp' and the updated list 'cmp' based on processed nodes


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
