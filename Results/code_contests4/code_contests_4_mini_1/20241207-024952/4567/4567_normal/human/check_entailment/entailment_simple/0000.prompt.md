
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There is a right triangle with legs of length a and b. Your task is to determine whether it is possible to locate the triangle on the plane in such a way that none of its sides is parallel to the coordinate axes. All the vertices must have integer coordinates. If there exists such a location, you have to output the appropriate coordinates of vertices.

Input

The first line contains two integers a, b (1 ≤ a, b ≤ 1000), separated by a single space.

Output

In the first line print either "YES" or "NO" (without the quotes) depending on whether the required location exists. If it does, print in the next three lines three pairs of integers — the coordinates of the triangle vertices, one pair per line. The coordinates must be integers, not exceeding 109 in their absolute value.

Examples

Input

1 1


Output

NO


Input

5 5


Output

YES
2 1
5 5
-2 4


Input

5 10


Output

YES
-10 4
-2 -2
1 2
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: a and b are integers such that 1 ≤ a, b ≤ 1000.
def func_1():
    trips = []
    for i in range(1, 1001):
        for j in range(1, 1001):
            k = (i ** 2 + j ** 2) ** 0.5
            if k.is_integer():
                k = int(k)
                trips.append([i, j, k])
        
    #State of the program after the  for loop has been executed: `a` is an integer such that 1 ≤ `a` ≤ 1000, `b` is an integer such that 1 ≤ `b` ≤ 1000; `trips` contains all valid combinations of `[i, j, k]` where `k` is the integer value of the hypotenuse calculated from `i` and `j` for all pairs `(i, j)` such that `1 ≤ i, j ≤ 1000` and `k` is an integer.
    a, b = get_list()
    for (i, j, k) in trips:
        if a % k == 0 and b % k == 0:
            mul1 = a // k
            mul2 = b // k
            if i * mul1 != mul2 * j:
                func_2('YES')
                func_2(0, 0)
                func_2(j * mul1, i * mul1)
                func_2(-i * mul2, j * mul2)
                return
        
    #State of the program after the  for loop has been executed: `a` and `b` are values obtained from `get_list()`, `trips` may remain unchanged or be a list of trips, and if the loop executes, for each trip (i, j, k) where `a % k == 0` and `b % k == 0`, the state may change based on the conditions evaluated within the loop. If any condition leads to a return from the function, the function will terminate; otherwise, the function will complete without returning.
    func_2('NO')

#Function 2:
#State of the program right berfore the function call: a and b are integers such that 1 ≤ a, b ≤ 1000.
def func_2():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `a` and `b` are integers such that 1 ≤ `a` ≤ 1000 and 1 ≤ `b` ≤ 1000; `sep` is extracted from `kwargs`; `file` is extracted from `kwargs`; `x` has been converted to a string for each element in `args` and written to `file`, separated by `sep` after the first element; `at_start` is False.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`a` and `b` are integers such that 1 ≤ `a` ≤ 1000 and 1 ≤ `b` ≤ 1000; `sep` is extracted from `kwargs`; `file` is flushed, and `at_start` is False if `flush` is True. If `flush` is False, the state of `file`, `sep`, `at_start`, `a`, and `b` remains unchanged.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
