
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given a deck of n cards numbered from 1 to n (not necessarily in this order in the deck). You have to sort the deck by repeating the following operation. 

  * Choose 2 ≤ k ≤ n and split the deck in k nonempty contiguous parts D_1, D_2,..., D_k (D_1 contains the first |D_1| cards of the deck, D_2 contains the following |D_2| cards and so on). Then reverse the order of the parts, transforming the deck into D_k, D_{k-1}, ..., D_2, D_1 (so, the first |D_k| cards of the new deck are D_k, the following |D_{k-1}| cards are D_{k-1} and so on). The internal order of each packet of cards D_i is unchanged by the operation. 



You have to obtain a sorted deck (i.e., a deck where the first card is 1, the second is 2 and so on) performing at most n operations. It can be proven that it is always possible to sort the deck performing at most n operations.

Examples of operation: The following are three examples of valid operations (on three decks with different sizes). 

  * If the deck is [3 6 2 1 4 5 7] (so 3 is the first card and 7 is the last card), we may apply the operation with k=4 and D_1=[3 6], D_2=[2 1 4], D_3=[5], D_4=[7]. Doing so, the deck becomes [7 5 2 1 4 3 6]. 
  * If the deck is [3 1 2], we may apply the operation with k=3 and D_1=[3], D_2=[1], D_3=[2]. Doing so, the deck becomes [2 1 3]. 
  * If the deck is [5 1 2 4 3 6], we may apply the operation with k=2 and D_1=[5 1], D_2=[2 4 3 6]. Doing so, the deck becomes [2 4 3 6 5 1]. 

Input

The first line of the input contains one integer n (1≤ n≤ 52) — the number of cards in the deck.

The second line contains n integers c_1, c_2, ..., c_n — the cards in the deck. The first card is c_1, the second is c_2 and so on.

It is guaranteed that for all i=1,...,n there is exactly one j∈\{1,...,n\} such that c_j = i.

Output

On the first line, print the number q of operations you perform (it must hold 0≤ q≤ n).

Then, print q lines, each describing one operation.

To describe an operation, print on a single line the number k of parts you are going to split the deck in, followed by the size of the k parts: |D_1|, |D_2|, ... , |D_k|. 

It must hold 2≤ k≤ n, and |D_i|≥ 1 for all i=1,...,k, and |D_1|+|D_2|+⋅⋅⋅ + |D_k| = n.

It can be proven that it is always possible to sort the deck performing at most n operations. If there are several ways to sort the deck you can output any of them.

Examples

Input


4
3 1 2 4


Output


2
3 1 2 1
2 1 3


Input


6
6 5 4 3 2 1


Output


1
6 1 1 1 1 1 1


Input


1
1


Output


0

Note

Explanation of the first testcase: Initially the deck is [3 1 2 4]. 

  * The first operation splits the deck as [(3) (1 2) (4)] and then transforms it into [4 1 2 3]. 
  * The second operation splits the deck as [(4) (1 2 3)] and then transforms it into [1 2 3 4]. 

Explanation of the second testcase: Initially the deck is [6 5 4 3 2 1]. 

  * The first (and only) operation splits the deck as [(6) (5) (4) (3) (2) (1)] and then transforms it into [1 2 3 4 5 6]. 
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 52, and c is a list of n unique integers where each integer is in the range from 1 to n.
def func():
    n = int(input())
    i = 1
    sq = False
    while i <= n:
        if i == n:
            sq = True
        
        i = i * 3
        
    #State of the program after the loop has been executed: `i` is greater than `n`, `sq` is True if `n` is 3 or more, otherwise `sq` is False, `n` remains unchanged, `c` remains unchanged
    if sq :
        print('YES')
    else :
        print('NO')
    #State of the program after the if-else block has been executed: *`i` is greater than `n`, `n` and `c` remain unchanged. If `sq` is True (indicating `n` is 3 or more), 'YES' is printed. Otherwise, if `sq` is False, 'NO' is printed.
#Overall this is what the function does:The function accepts an integer `n` (1 ≤ n ≤ 52) and checks if `n` is a power of 3. If `n` is equal to a power of 3, it prints 'YES'; otherwise, it prints 'NO'. The function does not utilize or validate the list `c` that is mentioned in the annotations.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
