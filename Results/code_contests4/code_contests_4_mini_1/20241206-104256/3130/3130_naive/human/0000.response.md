To determine the correctness of the provided program based on the problem description, let's analyze the code and its intended functionality.

### Problem Description Recap:
The task is to compute the distance of each element in an array to the nearest zero. The output should provide these distances for each element in the order they appear in the array.

### Provided Program:
```python
(n, a) = (int(input()), [int(x) for x in stdin.readline().split()])
(out, que) = ([-1] * n, deque())
for i in range(n):
    if not a[i]:
        que.append((i, 0))
while que:
    (ix, lev) = que.popleft()
    if out[ix] != -1:
        out[ix] = lev
        if 0 <= ix + 1 <= n - 1:
            que.append((ix + 1, lev + 1))
        if 0 <= ix - 1 <= n - 1:
            que.append((ix - 1, lev + 1))
print(' '.join(map(str, out)))
```

### Analysis of the Code:
1. **Initialization**: 
   - The program initializes an output list `out` with `-1` values and a deque `que`.
   
2. **Finding Zeros**: 
   - It iterates through the array `a` and appends the index of each zero found to the queue with a starting level (distance) of `0`.

3. **Calculating Distances**: 
   - Using a breadth-first search approach, it processes each index in the queue:
     - If the distance for that index in `out` is already set (not `-1`), it updates the distance.
     - It then attempts to add the next and previous indices to the queue with an incremented distance level.

4. **Output**: 
   - Finally, it prints the distances as a space-separated string.

### Potential Issues:
- The condition `if out[ix] != -1:` is incorrect. This should actually check if `out[ix]` is `-1` to ensure we set the distance the first time we reach that index. If `out[ix]` is already set, it implies that we have already calculated the distance for that index, and we should not overwrite it. The current check is causing the program to skip setting the distance for the first zero it encounters.

### Example of Failure:
Consider the input:
```
5
1 0 0 1 1
```

Expected output:
```
1 0 0 1 2
```
With the current implementation, the second zero's distance may not be calculated correctly due to the faulty condition.

### Conclusion:
The program does not work correctly for all cases due to the faulty condition check. Therefore, it fails to meet the requirements of the problem description.

Correctness: **False**.