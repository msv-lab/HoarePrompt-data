
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There are N balls in a two-dimensional plane. The i-th ball is at coordinates (x_i, y_i).

We will collect all of these balls, by choosing two integers p and q such that p \neq 0 or q \neq 0 and then repeating the following operation:

* Choose a ball remaining in the plane and collect it. Let (a, b) be the coordinates of this ball. If we collected a ball at coordinates (a - p, b - q) in the previous operation, the cost of this operation is 0. Otherwise, including when this is the first time to do this operation, the cost of this operation is 1.



Find the minimum total cost required to collect all the balls when we optimally choose p and q.

Constraints

* 1 \leq N \leq 50
* |x_i|, |y_i| \leq 10^9
* If i \neq j, x_i \neq x_j or y_i \neq y_j.
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


N
x_1 y_1
:
x_N y_N


Output

Print the minimum total cost required to collect all the balls.

Examples

Input

2
1 1
2 2


Output

1


Input

3
1 4
4 6
7 8


Output

1


Input

4
1 1
1 2
2 1
2 2


Output

2
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: N is a positive integer such that 1 <= N <= 50, and the coordinates (x_i, y_i) for each ball are integers satisfying |x_i|, |y_i| <= 10^9, with all (x_i, y_i) being distinct for i ≠ j.
def func_1():
    N = read_int()
    balls = []
    for _ in range(N):
        balls.append(read_int_array())
        
    #State of the program after the  for loop has been executed: `N` is a positive integer such that 1 <= `N` <= 50; `balls` is a list containing `N` arrays of integers; `_` is `N - 1`.
    func_8(func_2(N, balls))

#Function 2:
#State of the program right berfore the function call: n is a positive integer representing the number of balls (1 <= n <= 50), and balls is a list of tuples where each tuple contains two integers (x_i, y_i) representing the coordinates of the i-th ball, with |x_i|, |y_i| <= 10^9. Each ball's coordinates are unique.
def func_2(n, balls):
    bdict = collections.defaultdict(set)
    for (x, y) in balls:
        bdict[x].add(y)
        
    #State of the program after the  for loop has been executed: `n` is a positive integer representing the number of balls; `balls` is a list of tuples containing unique coordinates; `bdict` is a defaultdict where each key corresponds to an `x` coordinate, and the associated value is a set containing all `y` coordinates from `balls` that share the same `x`.
    tried = set()
    ans = n
    for i in range(n):
        for j in range(i):
            p, q = balls[j][0] - balls[i][0], balls[j][1] - balls[i][1]
            if (p, q) not in tried:
                tried.add((p, q))
                tried.add((-p, -q))
                points = score(p, q)
                if points < ans:
                    ans = points
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `tried` contains all unique tuples `(p, q)` and their negations generated from the differences of `balls[j]` and `balls[i]` for all valid pairs, `ans` is the minimum score calculated from the function `score(p, q)` for all valid `(p, q)` pairs across all iterations.
    return ans
    #The program returns the minimum score 'ans' calculated from the function 'score(p, q)' for all valid unique tuples '(p, q)' and their negations across all iterations.

#Function 3:
#State of the program right berfore the function call: p and q are integers such that at least one of them is non-zero, and N is a positive integer where 1 <= N <= 50. Each ball's coordinates (x_i, y_i) are integers with |x_i|, |y_i| <= 10^9, and all coordinates are unique.
def score(p, q):
    out = n
    for (x, y) in balls:
        nx, ny = x + p, y + q
        
        if ny in bdict.get(nx, []):
            out -= 1
        
    #State of the program after the  for loop has been executed: `p` and `q` are integers, `N` is a positive integer (1 <= N <= 50), `out` is equal to `N` minus the count of successful matches of `ny` in `bdict.get(nx, [])` for all iterations of the loop.
    return out
    #The program returns the value of 'out', which is equal to N minus the count of successful matches of 'ny' in 'bdict.get(nx, [])' for all iterations of the loop.

#Function 4:
#State of the program right berfore the function call: N is an integer such that 1 <= N <= 50, and each ball is represented by its coordinates (x_i, y_i) where |x_i|, |y_i| <= 10^9 and all coordinates are integers. The balls have unique positions, meaning if i ≠ j, then x_i ≠ x_j or y_i ≠ y_j.
def func_3():
    if (False and 'PYCHARM_HOSTED' in os.environ) :
        func_4()
    else :
        func_1()
    #State of the program after the if-else block has been executed: *`N` is an integer such that 1 <= `N` <= 50, and each ball is represented by its coordinates (x_i, y_i) where |x_i|, |y_i| <= 10^9, with unique positions. Since the condition is false, `func_4()` is called. If 'PYCHARM_HOSTED' is not in os.environ, `func_1()` is executed, and its output is unknown.

#Function 5:
#State of the program right berfore the function call: N is an integer such that 1 <= N <= 50, and each ball's coordinates (x_i, y_i) are integers with |x_i|, |y_i| <= 10^9, where i ranges from 1 to N and all (x_i, y_i) pairs are distinct.
def func_4():
    solution = solve
    test_inputs = None
    test_outputs = None
    judge = None
    slow_solution = None
    if (solution is not None) :
        if (test_outputs is not None) :
            func_5(solution, test_inputs, test_outputs)
        #State of the program after the if block has been executed: *`N` is an integer such that 1 <= N <= 50; each ball's coordinates (x_i, y_i) are integers with |x_i|, |y_i| <= 10^9; `solution` is a function assigned to `solve`; `test_inputs` is None; `test_outputs` is not None; `judge` is None; `slow_solution` is None; and `solution` is not None. If `test_outputs` is not None, then the function `func_5` is called with arguments `solution`, `test_inputs`, and `test_outputs`.
        if (judge is not None) :
            func_6(solution, test_inputs, judge)
        #State of the program after the if block has been executed: *`N` is an integer such that 1 <= N <= 50; each ball's coordinates (x_i, y_i) are integers with |x_i|, |y_i| <= 10^9; `solution` is a function assigned to `solve`; `test_inputs` is None; `test_outputs` is not None; `judge` is not None; `slow_solution` is None; and `solution` is not None. If `judge` is not None, the function `func_6` is called with arguments `solution`, `test_inputs`, and `judge`.
        if (slow_solution is not None) :
            func_7(solution, test_inputs, slow_solution)
        #State of the program after the if block has been executed: *`N` is an integer such that 1 <= N <= 50; `test_inputs` is None; `slow_solution` is not None; `solution` is not None. If `slow_solution` is not None, then `func_7` is called with `solution`, `test_inputs`, and `slow_solution`.
    #State of the program after the if block has been executed: *`N` is an integer such that 1 <= N <= 50; `test_inputs` is None; `slow_solution` is not None; `solution` is not None. If `solution` is not None, and `slow_solution` is also not None, then `func_7` is called with `solution`, `test_inputs`, and `slow_solution`.

#Function 6:
#State of the program right berfore the function call: solution is a callable function that takes a list of tuples representing the coordinates of N balls in a 2D plane, where 1 <= N <= 50 and each coordinate is an integer with |x_i|, |y_i| <= 10^9; inputs_answers is a list containing the expected output for the corresponding inputs.
def func_5(solution, inputs_answers):
    total, wrong = 0, 0
    for (args, test_ans) in inputs_answers:
        ans = solution(*args.copy())
        
        if ans != test_ans:
            func_8('WRONG! ans=%s, test_ans=%s, args=%s' % (ans, test_ans, args))
            wrong += 1
        else:
            func_8('GOOD')
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is the number of pairs in `inputs_answers`, `wrong` is the number of times `ans` did not equal `test_ans`.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 7:
#State of the program right berfore the function call: solution is a function that takes a list of tuples representing the coordinates of N balls in a two-dimensional plane, where 1 <= N <= 50 and each coordinate is an integer with absolute values not exceeding 10^9. inputs_gen is a function that generates the input in the specified format, and judge is a function that evaluates the output of the solution.
def func_6(solution, inputs_gen, judge):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        if not judge(deepcopy(ans), *deepcopy(args)):
            func_8('WRONG! ans=%s, args=%s' % (ans, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is the number of iterations of the loop, `wrong` is the count of incorrect answers based on the `judge` function, and `inputs_gen` is a generator that provides input arguments for the loop.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 8:
#State of the program right berfore the function call: solution is a function that computes the minimum total cost required to collect all balls given the number of balls N and their coordinates (x_i, y_i) as a list of tuples, where 1 <= N <= 50 and |x_i|, |y_i| <= 10^9. inputs_gen is a generator function that yields input data in the specified format, and solution_slow is a reference to a slower alternative solution function for comparison.
def func_7(solution, inputs_gen, solution_slow):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        slow = solution_slow(*deepcopy(args))
        
        if ans != slow:
            func_8('WRONG! ans=%s, slow=%s, args=%s' % (ans, slow, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is the number of elements processed from `inputs_gen`, `wrong` is the total count of wrong answers where `ans` does not equal `slow`, `inputs_gen` is exhausted, `args` is the last element processed from `inputs_gen`, and `slow` is assigned the value returned by `solution_slow(*deepcopy(args))` for the last processed `args` if `ans` was not equal to `slow`.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 9:
#State of the program right berfore the function call: args contains N pairs of integers (x_i, y_i) representing the coordinates of the balls, where N is a positive integer such that 1 <= N <= 50, and |x_i|, |y_i| <= 10^9.
def func_8():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` contains N pairs of integers, `sep` remains unchanged, `file` contains all pairs from `args` separated by `sep`, `at_start` is False.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` contains N pairs of integers, `sep` remains unchanged, `file` has written the value of `kwargs.pop('end', '\n')` to it, `at_start` is False. If `kwargs.pop('flush', False)` is True, the contents of `file` are flushed to ensure all data is written out.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
