
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: There are N balls in a two-dimensional plane. The i-th ball is at coordinates (x_i, y_i).

We will collect all of these balls, by choosing two integers p and q such that p \neq 0 or q \neq 0 and then repeating the following operation:

* Choose a ball remaining in the plane and collect it. Let (a, b) be the coordinates of this ball. If we collected a ball at coordinates (a - p, b - q) in the previous operation, the cost of this operation is 0. Otherwise, including when this is the first time to do this operation, the cost of this operation is 1.



Find the minimum total cost required to collect all the balls when we optimally choose p and q.

Constraints

* 1 \leq N \leq 50
* |x_i|, |y_i| \leq 10^9
* If i \neq j, x_i \neq x_j or y_i \neq y_j.
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


N
x_1 y_1
:
x_N y_N


Output

Print the minimum total cost required to collect all the balls.

Examples

Input

2
1 1
2 2


Output

1


Input

3
1 4
4 6
7 8


Output

1


Input

4
1 1
1 2
2 1
2 2


Output

2
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: N is a positive integer such that 1 <= N <= 50, and the coordinates (x_i, y_i) for each ball are integers satisfying |x_i|, |y_i| <= 10^9, with all (x_i, y_i) being distinct for i ≠ j.
def func_1():
    N = read_int()
    balls = []
    for _ in range(N):
        balls.append(read_int_array())
        
    #State of the program after the  for loop has been executed: `N` is a positive integer such that 1 <= `N` <= 50; `balls` is a list containing `N` arrays of integers; `_` is `N - 1`.
    func_8(func_2(N, balls))
#Overall this is what the function does:The function does not accept any parameters. It reads a positive integer `N` (with 1 <= N <= 50) and then reads `N` arrays of integers which represent the coordinates of distinct balls. After populating the list `balls`, it calls another function `func_2` with `N` and `balls` as arguments, and subsequently calls `func_8` with the result of that call. The function does not specify what it returns or the behavior of `func_2` and `func_8`, leaving the overall output unclear.

#Function 2:
#State of the program right berfore the function call: n is a positive integer representing the number of balls (1 <= n <= 50), and balls is a list of tuples where each tuple contains two integers (x_i, y_i) representing the coordinates of the i-th ball, with |x_i|, |y_i| <= 10^9. Each ball's coordinates are unique.
def func_2(n, balls):
    bdict = collections.defaultdict(set)
    for (x, y) in balls:
        bdict[x].add(y)
        
    #State of the program after the  for loop has been executed: `n` is a positive integer representing the number of balls; `balls` is a list of tuples containing unique coordinates; `bdict` is a defaultdict where each key corresponds to an `x` coordinate, and the associated value is a set containing all `y` coordinates from `balls` that share the same `x`.
    tried = set()
    ans = n
    for i in range(n):
        for j in range(i):
            p, q = balls[j][0] - balls[i][0], balls[j][1] - balls[i][1]
            if (p, q) not in tried:
                tried.add((p, q))
                tried.add((-p, -q))
                points = score(p, q)
                if points < ans:
                    ans = points
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `tried` contains all unique tuples `(p, q)` and their negations generated from the differences of `balls[j]` and `balls[i]` for all valid pairs, `ans` is the minimum score calculated from the function `score(p, q)` for all valid `(p, q)` pairs across all iterations.
    return ans
    #The program returns the minimum score 'ans' calculated from the function 'score(p, q)' for all valid unique tuples '(p, q)' and their negations across all iterations.
#Overall this is what the function does:The function accepts a positive integer `n` and a list of tuples `balls`, where each tuple contains unique coordinates of balls. It calculates the minimum score based on unique directional differences between pairs of balls using the function `score(p, q)`, and returns this minimum score. If no valid pairs are found or if `n` is less than 1, it will still return the initial value of `ans`, which is `n`.

#Function 3:
#State of the program right berfore the function call: p and q are integers such that at least one of them is non-zero, and N is a positive integer where 1 <= N <= 50. Each ball's coordinates (x_i, y_i) are integers with |x_i|, |y_i| <= 10^9, and all coordinates are unique.
def score(p, q):
    out = n
    for (x, y) in balls:
        nx, ny = x + p, y + q
        
        if ny in bdict.get(nx, []):
            out -= 1
        
    #State of the program after the  for loop has been executed: `p` and `q` are integers, `N` is a positive integer (1 <= N <= 50), `out` is equal to `N` minus the count of successful matches of `ny` in `bdict.get(nx, [])` for all iterations of the loop.
    return out
    #The program returns the value of 'out', which is equal to N minus the count of successful matches of 'ny' in 'bdict.get(nx, [])' for all iterations of the loop.
#Overall this is what the function does:The function accepts two integers `p` and `q` (with at least one being non-zero) and a positive integer `N` (where 1 <= N <= 50). It calculates a score by starting with the value of `N` and decrementing it for each successful match found between the modified `ny` (calculated as `y + q`) and the values in `bdict` corresponding to the modified `nx` (calculated as `x + p`). The function returns this final score. Note that if there are no matches, the score will be `N`, and if all conditions are met for matches, the score could reach zero. The function does not handle the case where `bdict` may not contain any keys corresponding to `nx`, which could lead to unexpected behavior if not properly managed in the surrounding code.

#Function 4:
#State of the program right berfore the function call: N is an integer such that 1 <= N <= 50, and each ball is represented by its coordinates (x_i, y_i) where |x_i|, |y_i| <= 10^9 and all coordinates are integers. The balls have unique positions, meaning if i ≠ j, then x_i ≠ x_j or y_i ≠ y_j.
def func_3():
    if (False and 'PYCHARM_HOSTED' in os.environ) :
        func_4()
    else :
        func_1()
    #State of the program after the if-else block has been executed: *`N` is an integer such that 1 <= `N` <= 50, and each ball is represented by its coordinates (x_i, y_i) where |x_i|, |y_i| <= 10^9, with unique positions. Since the condition is false, `func_4()` is called. If 'PYCHARM_HOSTED' is not in os.environ, `func_1()` is executed, and its output is unknown.
#Overall this is what the function does:The function `func_3` does not accept any parameters and conditionally calls either `func_4` or `func_1` based on an always-false condition. As a result, it will always execute `func_1`, but the return value and effects of `func_1` are unknown from the provided information. The function does not return any value or output that can be determined from the given code.

#Function 5:
#State of the program right berfore the function call: N is an integer such that 1 <= N <= 50, and each ball's coordinates (x_i, y_i) are integers with |x_i|, |y_i| <= 10^9, where i ranges from 1 to N and all (x_i, y_i) pairs are distinct.
def func_4():
    solution = solve
    test_inputs = None
    test_outputs = None
    judge = None
    slow_solution = None
    if (solution is not None) :
        if (test_outputs is not None) :
            func_5(solution, test_inputs, test_outputs)
        #State of the program after the if block has been executed: *`N` is an integer such that 1 <= N <= 50; each ball's coordinates (x_i, y_i) are integers with |x_i|, |y_i| <= 10^9; `solution` is a function assigned to `solve`; `test_inputs` is None; `test_outputs` is not None; `judge` is None; `slow_solution` is None; and `solution` is not None. If `test_outputs` is not None, then the function `func_5` is called with arguments `solution`, `test_inputs`, and `test_outputs`.
        if (judge is not None) :
            func_6(solution, test_inputs, judge)
        #State of the program after the if block has been executed: *`N` is an integer such that 1 <= N <= 50; each ball's coordinates (x_i, y_i) are integers with |x_i|, |y_i| <= 10^9; `solution` is a function assigned to `solve`; `test_inputs` is None; `test_outputs` is not None; `judge` is not None; `slow_solution` is None; and `solution` is not None. If `judge` is not None, the function `func_6` is called with arguments `solution`, `test_inputs`, and `judge`.
        if (slow_solution is not None) :
            func_7(solution, test_inputs, slow_solution)
        #State of the program after the if block has been executed: *`N` is an integer such that 1 <= N <= 50; `test_inputs` is None; `slow_solution` is not None; `solution` is not None. If `slow_solution` is not None, then `func_7` is called with `solution`, `test_inputs`, and `slow_solution`.
    #State of the program after the if block has been executed: *`N` is an integer such that 1 <= N <= 50; `test_inputs` is None; `slow_solution` is not None; `solution` is not None. If `solution` is not None, and `slow_solution` is also not None, then `func_7` is called with `solution`, `test_inputs`, and `slow_solution`.
#Overall this is what the function does:The function accepts no parameters and is designed to invoke other functions (`func_5`, `func_6`, and `func_7`) based on the conditional presence of certain variables (`solution`, `test_outputs`, `judge`, and `slow_solution`). However, it does not return any value or provide output related to the number of distinct balls based on their coordinates, as suggested by the annotations. Instead, it appears to set up for a testing or judging mechanism without producing a final result. Therefore, the function does not fulfill the stated purpose of returning the number of distinct balls.

#Function 6:
#State of the program right berfore the function call: solution is a callable function that takes a list of tuples representing the coordinates of N balls in a 2D plane, where 1 <= N <= 50 and each coordinate is an integer with |x_i|, |y_i| <= 10^9; inputs_answers is a list containing the expected output for the corresponding inputs.
def func_5(solution, inputs_answers):
    total, wrong = 0, 0
    for (args, test_ans) in inputs_answers:
        ans = solution(*args.copy())
        
        if ans != test_ans:
            func_8('WRONG! ans=%s, test_ans=%s, args=%s' % (ans, test_ans, args))
            wrong += 1
        else:
            func_8('GOOD')
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is the number of pairs in `inputs_answers`, `wrong` is the number of times `ans` did not equal `test_ans`.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))
#Overall this is what the function does:The function accepts a callable `solution` and a list of tuples `inputs_answers`, where each tuple contains arguments for `solution` and the expected result. It executes `solution` with the provided arguments, compares the output to the expected result, and counts how many tests failed. At the end of the evaluation, it logs a message indicating how many tests passed or failed. The function does not handle cases where `solution` raises exceptions or when the input arguments are not in the expected format.

#Function 7:
#State of the program right berfore the function call: solution is a function that takes a list of tuples representing the coordinates of N balls in a two-dimensional plane, where 1 <= N <= 50 and each coordinate is an integer with absolute values not exceeding 10^9. inputs_gen is a function that generates the input in the specified format, and judge is a function that evaluates the output of the solution.
def func_6(solution, inputs_gen, judge):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        if not judge(deepcopy(ans), *deepcopy(args)):
            func_8('WRONG! ans=%s, args=%s' % (ans, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is the number of iterations of the loop, `wrong` is the count of incorrect answers based on the `judge` function, and `inputs_gen` is a generator that provides input arguments for the loop.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))
#Overall this is what the function does:The function accepts a solution function, an input generator function, and a judge function. It evaluates the solution against generated inputs and counts the number of incorrect answers based on the judge function. After all evaluations, it prints the total number of tests conducted and how many were incorrect, if any. The function does not handle any exceptions that may arise from the solution or judge functions and assumes they will execute without error.

#Function 8:
#State of the program right berfore the function call: solution is a function that computes the minimum total cost required to collect all balls given the number of balls N and their coordinates (x_i, y_i) as a list of tuples, where 1 <= N <= 50 and |x_i|, |y_i| <= 10^9. inputs_gen is a generator function that yields input data in the specified format, and solution_slow is a reference to a slower alternative solution function for comparison.
def func_7(solution, inputs_gen, solution_slow):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        slow = solution_slow(*deepcopy(args))
        
        if ans != slow:
            func_8('WRONG! ans=%s, slow=%s, args=%s' % (ans, slow, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is the number of elements processed from `inputs_gen`, `wrong` is the total count of wrong answers where `ans` does not equal `slow`, `inputs_gen` is exhausted, `args` is the last element processed from `inputs_gen`, and `slow` is assigned the value returned by `solution_slow(*deepcopy(args))` for the last processed `args` if `ans` was not equal to `slow`.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))
#Overall this is what the function does:The function accepts a computational function `solution`, a generator `inputs_gen` that yields input data as tuples for testing, and a slower solution function `solution_slow` for comparison. It runs tests by executing `solution` and `solution_slow` on the same inputs, counts the number of incorrect results where `solution` does not match `solution_slow`, and logs the results. If all tests pass, it outputs a success message; otherwise, it reports the number of wrong answers out of the total tests conducted.

#Function 9:
#State of the program right berfore the function call: args contains N pairs of integers (x_i, y_i) representing the coordinates of the balls, where N is a positive integer such that 1 <= N <= 50, and |x_i|, |y_i| <= 10^9.
def func_8():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `args` contains N pairs of integers, `sep` remains unchanged, `file` contains all pairs from `args` separated by `sep`, `at_start` is False.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`args` contains N pairs of integers, `sep` remains unchanged, `file` has written the value of `kwargs.pop('end', '\n')` to it, `at_start` is False. If `kwargs.pop('flush', False)` is True, the contents of `file` are flushed to ensure all data is written out.
#Overall this is what the function does:The function accepts a variable number of arguments that represent pairs of integers. It prints these integers to a specified output stream, separated by a customizable separator. The output ends with a line break or another specified ending character. If the flush argument is set to True, the output stream is flushed after writing. The function does not return any value; it solely performs printing operations.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.