
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Students in a class are making towers of blocks. Each student makes a (non-zero) tower by stacking pieces lengthwise on top of each other. n of the students use pieces made of two blocks and m of the students use pieces made of three blocks.

The students don’t want to use too many blocks, but they also want to be unique, so no two students’ towers may contain the same number of blocks. Find the minimum height necessary for the tallest of the students' towers.

Input

The first line of the input contains two space-separated integers n and m (0 ≤ n, m ≤ 1 000 000, n + m > 0) — the number of students using two-block pieces and the number of students using three-block pieces, respectively.

Output

Print a single integer, denoting the minimum possible height of the tallest tower.

Examples

Input

1 3


Output

9


Input

3 2


Output

8


Input

5 0


Output

10

Note

In the first case, the student using two-block pieces can make a tower of height 4, and the students using three-block pieces can make towers of height 3, 6, and 9 blocks. The tallest tower has a height of 9 blocks.

In the second case, the students can make towers of heights 2, 4, and 8 with two-block pieces and towers of heights 3 and 6 with three-block pieces, for a maximum height of 8 blocks.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n and m are non-negative integers such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_1():
    return int(input())
    #The program returns an integer input from the user, which is a non-negative integer greater than 0 and less than or equal to 1,000,000.

#Function 2:
#State of the program right berfore the function call: n and m are non-negative integers such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_2():
    return input()
    #The program returns the user input, which can be any value since it is obtained from the input function.

#Function 3:
#State of the program right berfore the function call: n and m are non-negative integers such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing the integers parsed from the input string, which consists of non-negative integers n and m such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.

#Function 4:
#State of the program right berfore the function call: n and m are non-negative integers such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representations of the non-negative integers n and m, which are input as a space-separated string.

#Function 5:
#State of the program right berfore the function call: n and m are non-negative integers such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_5():
    return list(func_3())
    #The program returns a list that is the result of calling func_3()

#Function 6:
#State of the program right berfore the function call: n and m are non-negative integers such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a tuple containing two non-negative integers n and m such that 0 ≤ n, m ≤ 1 000 000 and n + m > 0, where n is the number of students using two-block pieces and m is the number of students using three-block pieces.
def func_7(item):
    return item[1]
    #The program returns the number of students using three-block pieces, which is the second element of the tuple 'item'

#Function 8:
#State of the program right berfore the function call: l is a list containing two non-negative integers n and m such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0, representing the number of students using two-block pieces and three-block pieces respectively.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list 'l' sorted in descending order based on the key defined by the function 'getKey'

#Function 9:
#State of the program right berfore the function call: n and m are non-negative integers such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0. num is an unused parameter that does not affect the output.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a list of lists with 'n' sublists, each containing 'm' elements, where each element is equal to 'num', which is an unused parameter

#Function 10:
#State of the program right berfore the function call: x is a tuple of two non-negative integers (n, m) where n is the number of students using two-block pieces and m is the number of students using three-block pieces, with the constraints 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_10(x):
    return x and not x & x - 1
    #The program returns the tuple x and the result of the expression 'not x & x - 1', which evaluates to a boolean indicating whether x is zero or not.

#Function 11:
#State of the program right berfore the function call: n is a non-negative integer representing the number of students using two-block pieces, and m is a non-negative integer representing the number of students using three-block pieces such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the non-negative integer n, with the '0b' prefix removed.

#Function 12:
#State of the program right berfore the function call: n is a non-negative integer representing the number of students using two-block pieces, and m is a non-negative integer representing the number of students using three-block pieces such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of the digits of the non-negative integer n, which represents the number of students using two-block pieces.

#Function 13:
#State of the program right berfore the function call: n and m are non-negative integers such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(n - r))
    #The program returns the result of the binomial coefficient calculation factorial(n) // (factorial(r) * factorial(n - r)), where n and m are non-negative integers and n + m > 0.

#Function 14:
#State of the program right berfore the function call: x and y are non-negative integers representing the number of students using two-block pieces and three-block pieces respectively, such that 0 ≤ x, y ≤ 1,000,000 and x + y > 0.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the result of integer division of x by y, where x is a non-negative integer divisible by y, and y is a non-negative integer greater than 0.
    else :
        return x // y + 1
        #The program returns the integer division of x by y plus 1, where x is a non-negative integer, y is a non-negative integer not equal to 0, and x is not divisible by y.

#Function 15:
#State of the program right berfore the function call: x is a non-negative integer representing the number of students using two-block pieces, y is a non-negative integer representing the number of students using three-block pieces, and it is guaranteed that at least one of x or y is greater than 0.
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is updated based on the contributions of `x` during the iterations when `y` was odd, and `x` is updated to `x^(2^k) % p` where `k` is the number of times the loop executed.
    return res
    #The program returns the value of 'res', which is updated based on the contributions of 'x' during the iterations when 'y' was odd.

#Function 16:
#State of the program right berfore the function call: x and y are non-negative integers representing the number of students using two-block pieces and three-block pieces, respectively, such that 0 ≤ x, y ≤ 1,000,000 and x + y > 0.
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the greatest common divisor of the initial values of `x` and `y`.
    return x
    #The program returns the greatest common divisor of the initial values of `x` and `y`, which is `x` since `y` is 0.

#Function 17:
#State of the program right berfore the function call: n is a non-negative integer representing the number of students using two-block pieces, and m is a non-negative integer representing the number of students using three-block pieces such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a non-negative integer representing the number of students using two-block pieces, `m` is a non-negative integer representing the number of students using three-block pieces such that 0 ≤ n, m ≤ 1,000,000, n + m > 0, and n is greater than 1.
    if (n <= 3) :
        return True
        #The program returns True, indicating that there is at least one student using either two-block or three-block pieces, as n is between 2 and 3 and m is greater than or equal to 0.
    #State of the program after the if block has been executed: *`n` is a non-negative integer representing the number of students using two-block pieces, `m` is a non-negative integer representing the number of students using three-block pieces such that 0 ≤ n, m ≤ 1,000,000, n + m > 0, and n is greater than 3. Additionally, `n` is greater than 1.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a non-negative integer representing the number of students using two-block pieces, `m` is a non-negative integer representing the number of students using three-block pieces such that 0 ≤ n, m ≤ 1,000,000, n + m > 0, and n is greater than 3. Additionally, `n` is greater than 1, `n` is not divisible by 2, and `n` is not divisible by 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is a non-negative integer greater than or equal to 25, `m` is a non-negative integer, `i` is greater than or equal to 5 and increased by multiples of 6 until `i * i` exceeds `n`. If the loop executes, it indicates that `n` is not divisible by any primes of the form 6k ± 1 up to the square root of `n`.
    return True
    #The program returns True, indicating that n is not divisible by any primes of the form 6k ± 1 up to the square root of n

#Function 18:
#State of the program right berfore the function call: n and m are non-negative integers such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: n and m are non-negative integers such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_19():
    n, m = func_3()
    for i in range(1, 1000001):
        if n <= i // 2 and m <= i // 3 and n + m <= i // 2 + i // 3 - i // 6:
            func_20(i)
            break
        
    #State of the program after the  for loop has been executed: `n` and `m` are non-negative integers, `i` is a positive integer at least 1 and at most 1,000,000. The loop executes until it finds the smallest `i` such that `n` is less than or equal to half of `i`, `m` is less than or equal to a third of `i`, and the sum of `n` and `m` is less than or equal to the sum of half of `i` and a third of `i` minus a sixth of `i`. If such an `i` is found, the loop breaks; otherwise, it continues until `i` reaches 1,000,000.

#Function 20:
#State of the program right berfore the function call: n and m are non-negative integers such that 0 ≤ n, m ≤ 1,000,000 and n + m > 0.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `n` and `m` are non-negative integers such that 0 ≤ `n`, `m` ≤ 1,000,000 and `n` + `m` > 0; `args` is a non-empty iterable; `file` now contains the string representations of all elements in `args`, separated by `sep`; `at_start` is False.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *The value associated with the key 'end' in `kwargs` is written to `file`, defaulting to a newline character if not present; `n` and `m` are non-negative integers such that 0 ≤ `n`, `m` ≤ 1,000,000 and `n` + `m` > 0; `args` is a non-empty iterable; `file` remains as before; `at_start` is False; and if `flush` is True, then `file` is flushed.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
