
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given an integer sequence of length n+1, a_1,a_2,...,a_{n+1}, which consists of the n integers 1,...,n. It is known that each of the n integers 1,...,n appears at least once in this sequence.

For each integer k=1,...,n+1, find the number of the different subsequences (not necessarily contiguous) of the given sequence with length k, modulo 10^9+7.

Constraints

* 1 \leq n \leq 10^5
* 1 \leq a_i \leq n
* Each of the integers 1,...,n appears in the sequence.
* n and a_i are integers.

Input

Input is given from Standard Input in the following format:


n
a_1 a_2 ... a_{n+1}


Output

Print n+1 lines. The k-th line should contain the number of the different subsequences of the given sequence with length k, modulo 10^9+7.

Examples

Input

3
1 2 1 3


Output

3
5
4
1


Input

1
1 1


Output

1
1


Input

32
29 19 7 10 26 32 27 4 11 20 2 8 16 23 5 14 6 12 17 22 18 30 28 24 15 1 25 3 13 21 19 31 9


Output

32
525
5453
40919
237336
1107568
4272048
13884156
38567100
92561040
193536720
354817320
573166440
818809200
37158313
166803103
166803103
37158313
818809200
573166440
354817320
193536720
92561040
38567100
13884156
4272048
1107568
237336
40920
5456
528
33
1
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and a is a list of integers of length n+1 where each integer a_i satisfies 1 ≤ a_i ≤ n and every integer from 1 to n appears at least once in the list.
def func():
    n = int(raw_input())
    a = map(int, re.split('\\s', raw_input()))
    left = 0
    right = 0
    mask = 10 ** 9 + 7
    pow = [0] * n + 2
    tmp = 1
    for i in range(1, n + 2):
        tmp *= i
        
        pow[i] = tmp
        
    #State of the program after the  for loop has been executed: `n` is an input integer within the range 1 ≤ n ≤ 10^5, `left` is 0, `right` is 0, `mask` is 1000000007, `pow` is a list where `pow[i]` is the factorial of `i` for `i` in range 1 to n + 1, `tmp` is `(n + 1)!`.
    for i in range(0, n + 1):
        x = a.index(a[i])
        
        if a[i] in a[x + 1:]:
            left = i
            right = a[x + 1:].index(a[i]) + x + 1
            break
        
    #State of the program after the  for loop has been executed: `n` is an input integer within the range 1 ≤ n ≤ 10^5; `left` is the index of the first occurrence of a duplicate element in `a` if found, otherwise 0; `right` is the index of the duplicate element in the sublist `a[x + 1:]` plus `x + 1` if found, otherwise 0; `mask` is 1000000007; `pow` is a list where `pow[i]` is the factorial of `i` for `i` in range 1 to `n + 1`; `tmp` is `(n + 1)!`.
    for i in range(1, n + 2):
        ans = pow[n + 1] / (pow[i] * pow[n + 1 - i])
        
        x = pow[left + n - right] / (pow[i - 1] * pow[left + n - right - i + 1])
        
        print(ans - x) % mask
        
    #State of the program after the  for loop has been executed: `n` is within the range 1 ≤ n ≤ 10^5; `left` is an index; `right` is an index; `mask` is 1000000007; `pow` is a list of factorials; `tmp` is (n + 1)!; `i` is `n + 1`; `ans` is calculated; `x` is calculated; and the last printed output is `(ans - x) % 1000000007.
#Overall this is what the function does:The function accepts an integer `n` and a list `a` of integers, where each integer from 1 to `n` appears at least once. It calculates and prints the difference between two combinatorial values based on the factorial of `n + 1`, the index of the first duplicate element in the list, and the index of that duplicate in the subsequent part of the list. The calculation is performed modulo `10^9 + 7`. If no duplicate is found, the function will still execute but may produce incorrect results as the indices for `left` and `right` will remain zero, leading to potential division by zero errors in the combinatorial calculations.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
