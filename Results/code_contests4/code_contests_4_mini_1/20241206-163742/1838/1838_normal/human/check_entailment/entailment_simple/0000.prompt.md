
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Yura is tasked to build a closed fence in shape of an arbitrary non-degenerate simple quadrilateral. He's already got three straight fence segments with known lengths a, b, and c. Now he needs to find out some possible integer length d of the fourth straight fence segment so that he can build the fence using these four segments. In other words, the fence should have a quadrilateral shape with side lengths equal to a, b, c, and d. Help Yura, find any possible length of the fourth side.

A non-degenerate simple quadrilateral is such a quadrilateral that no three of its corners lie on the same line, and it does not cross itself.

Input

The first line contains a single integer t — the number of test cases (1 ≤ t ≤ 1000). The next t lines describe the test cases.

Each line contains three integers a, b, and c — the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).

Output

For each test case print a single integer d — the length of the fourth fence segment that is suitable for building the fence. If there are multiple answers, print any. We can show that an answer always exists.

Example

Input


2
1 2 3
12 34 56


Output


4
42

Note

We can build a quadrilateral with sides 1, 2, 3, 4.

We can build a quadrilateral with sides 12, 34, 56, 42.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are integers representing the lengths of the three fence segments, where 1 ≤ a, b, c ≤ 10^9.
def func_1():
    return int(input())
    #The program returns a positive integer based on user input, which represents the number of test cases or a specific value provided by the user.

#Function 2:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are integers representing the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).
def func_2():
    return input()
    #The program returns the input values for t, a, b, and c, where t is a positive integer (1 ≤ t ≤ 1000), and a, b, and c are integers representing the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9)

#Function 3:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are positive integers (1 ≤ a, b, c ≤ 10^9).
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing the integers from the input string split by spaces, which represents the positive integers a, b, and c for each test case

#Function 4:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are positive integers (1 ≤ a, b, c ≤ 10^9).
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representations of the integers a, b, and c after splitting the input string.

#Function 5:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000) representing the number of test cases, and for each test case, a, b, and c are positive integers (1 ≤ a, b, c ≤ 10^9) representing the lengths of the three fence segments.
def func_5():
    return list(func_3())
    #The program returns a list containing the results of func_3() for each of the t test cases, where each test case consists of positive integers a, b, and c representing the lengths of the three fence segments.

#Function 6:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 1000, and for each test case, a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a list of tuples, where each tuple contains three integers a, b, and c representing the lengths of three fence segments, with 1 ≤ a, b, c ≤ 10^9, and the number of tuples is between 1 and 1000.
def func_7(item):
    return item[1]
    #The program returns the second tuple (item[1]) from the list 'item', which contains three integers representing the lengths of three fence segments.

#Function 8:
#State of the program right berfore the function call: l is a list of tuples, where each tuple contains three integers a, b, and c (1 ≤ a, b, c ≤ 10^9), and the length of l is equal to t (1 ≤ t ≤ 1000).
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list of tuples 'l' sorted in descending order based on the key defined by the function getKey

#Function 9:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each test case, a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a matrix of size n x m filled with the value of num. The variables a, b, and c are positive integers, and the values of n and m must be derived from these variables based on the context, but they are not specified in the initial state.

#Function 10:
#State of the program right berfore the function call: x is a list of tuples, where each tuple contains three integers a, b, and c (1 ≤ a, b, c ≤ 10^9), and the number of test cases is an integer t (1 ≤ t ≤ 1000).
def func_10(x):
    return x and not x & x - 1
    #The program returns the list of tuples x and the result of the expression 'not x & x - 1', where x is a list of tuples containing three integers each (a, b, c) and 't' is the number of test cases. The expression evaluates to a boolean value based on the truthiness of 'x' and the bitwise operations on the list.

#Function 11:
#State of the program right berfore the function call: n is a positive integer representing the number of test cases, and for each test case, three integers a, b, and c (1 ≤ a, b, c ≤ 10^9) are provided representing the lengths of the three fence segments.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the positive integer n, excluding the '0b' prefix.

#Function 12:
#State of the program right berfore the function call: n is a positive integer representing the number of test cases (1 ≤ n ≤ 1000), and for each test case, the function receives three integers a, b, and c (1 ≤ a, b, c ≤ 10^9) representing the lengths of the three fence segments.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers representing the digits of the positive integer n, which indicates the number of test cases (1 ≤ n ≤ 1000)

#Function 13:
#State of the program right berfore the function call: n is a positive integer representing the number of test cases (1 ≤ n ≤ 1000), and r is a list of tuples where each tuple contains three integers a, b, and c (1 ≤ a, b, c ≤ 10^9).
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the result of the combinatorial expression based on the value of n and the tuple r, which includes three integers a, b, and c, representing the number of test cases and parameters for the calculation

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 1000), and y is a list of tuples where each tuple contains three integers (a, b, c) representing the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer result of dividing the number of test cases `x` by the list `y` of tuples containing the lengths of the three fence segments.
    else :
        return x // y + 1
        #The program returns the integer value of x divided by the length of list y plus 1, where x represents the number of test cases and y is a list of tuples containing three integers each.

#Function 15:
#State of the program right berfore the function call: x is a positive integer representing the number of test cases, and for each test case, y is a tuple of three positive integers (a, b, c) where 1 ≤ a, b, c ≤ 10^9.
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is updated according to the number of times the least significant bit of `y` was 1, and `x` is the last value updated to `x * x % p` before the loop terminated.
    return res
    #The program returns the value of 'res', which is updated according to the number of times the least significant bit of 'y' was 1, with 'y' being 0

#Function 16:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 1000), and y is a list of tuples, each containing three integers (a, b, c) representing the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the GCD of the initial values from `y`, `y` is 0 (as the loop will eventually terminate when `y` becomes 0).
    return x
    #The program returns the GCD of the initial values from `y`, which is `x`, as `y` is 0.

#Function 17:
#State of the program right berfore the function call: n is a positive integer representing the number of test cases, followed by n lines each containing three positive integers a, b, and c (1 ≤ a, b, c ≤ 10^9) representing the lengths of the three fence segments.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a positive integer representing the number of test cases greater than 1, followed by `n` lines each containing three positive integers `a`, `b`, and `c` (1 ≤ `a`, `b`, `c` ≤ 10^9) representing the lengths of the three fence segments.
    if (n <= 3) :
        return True
        #The program returns True, indicating that the conditions for the test cases with three positive integers representing lengths of fence segments are met.
    #State of the program after the if block has been executed: *`n` is a positive integer representing the number of test cases greater than 1, followed by `n` lines each containing three positive integers `a`, `b`, and `c` (1 ≤ `a`, `b`, `c` ≤ 10^9). `n` is greater than 3.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a positive integer greater than 1 and greater than 3 representing the number of test cases, followed by `n` lines each containing three positive integers `a`, `b`, and `c` (1 ≤ `a`, `b`, `c` ≤ 10^9). `n` is not divisible by 2 and not divisible by 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is a positive integer greater than or equal to 289, `i` is 59
    return True
    #The program returns True

#Function 18:
#State of the program right berfore the function call: t is a positive integer such that 1 ≤ t ≤ 1000, and for each test case, a, b, and c are integers such that 1 ≤ a, b, c ≤ 10^9.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases (1 ≤ t ≤ 1000), and for each test case, a, b, and c are positive integers representing the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).
def func_19():
    for _ in range(func_1()):
        a, b, c = func_3()
        
        func_20(c + 1)
        
    #State of the program after the  for loop has been executed: `t` is a positive integer (1 ≤ t ≤ 1000); `a`, `b`, `c` are the values returned by `func_3()` for the last iteration of the loop, and `func_20(c + 1)` has been called for each iteration with the corresponding `c` value.

#Function 20:
#State of the program right berfore the function call: t is a positive integer representing the number of test cases (1 ≤ t ≤ 1000), and for each test case, a, b, and c are positive integers representing the lengths of the three fence segments (1 ≤ a, b, c ≤ 10^9).
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `t`, `a`, `b`, `c` are positive integers; `sep` is either the value from `kwargs` or a space; `file` is either the value from `kwargs` or sys.stdout; `at_start` is False; `file` has written the string representation of all elements in `args`, separated by `sep` if there are multiple elements.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`t`, `a`, `b`, `c` are positive integers; `sep` is either the value from `kwargs` or a space; `file` is either the value from `kwargs` or sys.stdout; `at_start` is False; the 'end' key is removed from `kwargs`, and `file` has written the value associated with 'end' or a newline character. If the flush option in kwargs is set to True, the contents of `file` have been flushed.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
