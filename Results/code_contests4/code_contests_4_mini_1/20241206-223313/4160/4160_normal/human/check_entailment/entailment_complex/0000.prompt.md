
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Programmers working on a large project have just received a task to write exactly m lines of code. There are n programmers working on a project, the i-th of them makes exactly ai bugs in every line of code that he writes. 

Let's call a sequence of non-negative integers v1, v2, ..., vn a plan, if v1 + v2 + ... + vn = m. The programmers follow the plan like that: in the beginning the first programmer writes the first v1 lines of the given task, then the second programmer writes v2 more lines of the given task, and so on. In the end, the last programmer writes the remaining lines of the code. Let's call a plan good, if all the written lines of the task contain at most b bugs in total.

Your task is to determine how many distinct good plans are there. As the number of plans can be large, print the remainder of this number modulo given positive integer mod.

Input

The first line contains four integers n, m, b, mod (1 ≤ n, m ≤ 500, 0 ≤ b ≤ 500; 1 ≤ mod ≤ 109 + 7) — the number of programmers, the number of lines of code in the task, the maximum total number of bugs respectively and the modulo you should use when printing the answer.

The next line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 500) — the number of bugs per line for each programmer.

Output

Print a single integer — the answer to the problem modulo mod.

Examples

Input

3 3 3 100
1 1 1


Output

10


Input

3 6 5 1000000007
1 2 3


Output

0


Input

3 5 6 11
1 2 1


Output

0
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n is a positive integer representing the number of programmers (1 ≤ n ≤ 500), m is a positive integer representing the number of lines of code to be written (1 ≤ m ≤ 500), b is a non-negative integer representing the maximum total number of bugs allowed (0 ≤ b ≤ 500), mod is a positive integer for the modulo operation (1 ≤ mod ≤ 10^9 + 7), and a is a list of n non-negative integers where each integer ai represents the number of bugs per line for each programmer (0 ≤ ai ≤ 500).
def func():
    add = lambda a, b: (a + b) % mod
    mult = lambda a, b: a % mod * (b % mod) % mod
    rints = lambda : [int(x) for x in stdin.readline().split()]
    n, m, b, mod = rints()
    a, mem = rints(), [[[int(j == 0) for _ in range(b + 1)] for j in range(m + 
    1)] for _ in range(2)]
    ans = 0
    for i in range(1, n + 1):
        ix = i & 1
        
        for j in range(1, m + 1):
            for k in range(a[i - 1], b + 1):
                mem[ix][j][k] = mem[ix ^ 1][j][k]
                mem[ix][j][k] = add(mem[ix][j][k], mem[ix][j - 1][k - a[i - 1]])
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `m` is a non-negative integer, `b` is a non-negative integer, `a` is a list of `n` non-negative integers, `mem` is a 3D list where `mem[0][j][k]` and `mem[1][j][k]` contain counts based on the contributions from all elements of `a` and their respective combinations, `ans` is 0 or the result of some cumulative operation based on `mem`, depending on further calculations outside the loop.
    for i in range(b + 1):
        ans = add(ans, mem[n & 1][m][i])
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `m` is a non-negative integer, `b` is a non-negative integer, `a` is a list of `n` non-negative integers, `mem` is a 3D list with counts based on contributions from `a`, `ans` is updated to the cumulative sum of `mem[n & 1][m][i]` for `i` ranging from 0 to `b`, and `i` is equal to `b` after the loop finishes executing.
    print(ans)
#Overall this is what the function does:The function accepts parameters representing the number of programmers (n), the number of lines of code (m), the maximum total number of bugs allowed (b), a modulo value (mod), and a list (a) of non-negative integers indicating the number of bugs per line for each programmer. It calculates and returns the number of valid configurations for writing the lines of code, ensuring the total bugs do not exceed the specified limit. The function employs a dynamic programming approach to track valid combinations, and the result is printed as an integer.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
