
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Everybody knows what an arithmetic progression is. Let us remind you just in case that an arithmetic progression is such sequence of numbers a1, a2, ..., an of length n, that the following condition fulfills: 

a2 - a1 = a3 - a2 = a4 - a3 = ... = ai + 1 - ai = ... = an - an - 1.

For example, sequences [1, 5], [10], [5, 4, 3] are arithmetic progressions and sequences [1, 3, 2], [1, 2, 4] are not.

Alexander has n cards containing integers. Arthur wants to give Alexander exactly one more card with a number so that he could use the resulting n + 1 cards to make an arithmetic progression (Alexander has to use all of his cards).

Arthur has already bought a card but he hasn't written a number on it. Help him, print all integers that you can write on a card so that the described condition fulfilled.

Input

The first line contains integer n (1 ≤ n ≤ 105) — the number of cards. The next line contains the sequence of integers — the numbers on Alexander's cards. The numbers are positive integers, each of them doesn't exceed 108.

Output

If Arthur can write infinitely many distinct integers on the card, print on a single line -1.

Otherwise, print on the first line the number of integers that suit you. In the second line, print the numbers in the increasing order. Note that the numbers in the answer can exceed 108 or even be negative (see test samples).

Examples

Input

3
4 1 7


Output

2
-2 10


Input

1
10


Output

-1


Input

4
1 3 5 9


Output

1
7


Input

4
4 3 4 5


Output

0


Input

2
2 4


Output

3
0 3 6
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on the cards consists of positive integers, each of which does not exceed 10^8.
def func_1():
    return int(input())
    #The program returns a positive integer read from input, which is guaranteed to be within the range of 1 to 10^5.

#Function 2:
#State of the program right berfore the function call: n is an integer (1 ≤ n ≤ 10^5) representing the number of cards, and the sequence of integers on the cards is a list of positive integers where each integer does not exceed 10^8.
def func_2():
    return input()
    #The program returns the input provided for the sequence of integers on the cards, which is a list of positive integers where each integer does not exceed 10^8.

#Function 3:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5) representing the number of cards, and the next line contains a sequence of n positive integers, each not exceeding 10^8.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object containing the sequence of n positive integers, each not exceeding 10^8, converted to integers.

#Function 4:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 105, and the sequence of integers on Alexander's cards consists of positive integers, each not exceeding 10^8.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object of the positive integers from the input, converted to strings, which are part of the sequence of integers on Alexander's cards.

#Function 5:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_5():
    return list(func_3())
    #The program returns the result of func_3() as a list, which processes the sequence of integers on Alexander's cards, where n is the number of cards and the integers are positive integers not exceeding 10^8.

#Function 6:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers contains exactly n positive integers, each not exceeding 10^8.
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a tuple where the first element is an integer n (1 ≤ n ≤ 10^5) representing the number of cards, and the second element is a list of n positive integers, each not exceeding 10^8.
def func_7(item):
    return item[1]
    #The program returns the list of n positive integers from the tuple 'item'

#Function 8:
#State of the program right berfore the function call: l is a list of integers where the first element is a positive integer n (1 ≤ n ≤ 10^5) representing the number of cards, followed by n positive integers not exceeding 10^8.
def func_8(l):
    return sorted(l, key=getKey)
    #The program returns the list of integers 'l' sorted according to the key defined by the function 'getKey'

#Function 9:
#State of the program right berfore the function call: n is an integer (1 ≤ n ≤ 10^5), m is a list of n positive integers where each integer does not exceed 10^8.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a matrix of size n x m, where each row contains the same integer 'm' repeated 'm' times.

#Function 10:
#State of the program right berfore the function call: x is a tuple where the first element is an integer n (1 ≤ n ≤ 10^5) representing the number of cards, and the second element is a list of n positive integers, each not exceeding 10^8.
def func_10(x):
    return x and not x & x - 1
    #The program returns a tuple x and the result of the expression 'not x & x - 1'

#Function 11:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5) representing the number of cards, and the sequence of integers on the cards consists of positive integers, each not exceeding 10^8.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the positive integer n, excluding the '0b' prefix. This binary representation corresponds to the number of cards, n, which is between 1 and 100,000.

#Function 12:
#State of the program right berfore the function call: n is an integer in the range 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers representing the digits of the integer n, where n is in the range 1 ≤ n ≤ 10^5

#Function 13:
#State of the program right berfore the function call: x is an integer representing the number of cards (1 ≤ x ≤ 10^5), y is a list of positive integers representing the numbers on Alexander's cards, where each integer does not exceed 10^8, and p is a non-negative integer representing the possible integers that can be written on the additional card.
def func_13(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is `x` raised to the power of the original value of `y` modulo `p`, `x` is modified to the result of `x` raised to the power of 2 raised to the number of times the loop executed modulo `p`.
    return res
    #The program returns the value of `x` raised to the power of 0 modulo `p`, which is 1.

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of cards (1 ≤ x ≤ 10^5), and y is a list of x positive integers, each not exceeding 10^8.
def func_14(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is an empty list, `x` is the last non-empty list of positive integers that was assigned to `y`, which corresponds to the last computed values from the modulo operations until `y` became empty.
    return x
    #The program returns the last non-empty list of positive integers assigned to 'y' before it became empty

#Function 15:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5) representing the number of cards, and the sequence of integers on the cards consists of positive integers each not exceeding 10^8.
def func_15(n):
    if (n <= 1) :
        return False
        #The program returns False as the sequence of integers on the cards does not meet the criteria specified (n is less than or equal to 1)
    #State of the program after the if block has been executed: *`n` is a positive integer (1 ≤ n ≤ 10^5) representing the number of cards, and the sequence of integers on the cards consists of positive integers each not exceeding 10^8. Additionally, `n` is greater than 1.
    if (n <= 3) :
        return True
        #The program returns True, indicating a successful condition given that n is a positive integer greater than 1 and less than or equal to 3.
    #State of the program after the if block has been executed: *`n` is a positive integer (1 ≤ n ≤ 10^5) representing the number of cards, and the sequence of integers on the cards consists of positive integers each not exceeding 10^8. Additionally, `n` is greater than 3 and also greater than 1.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a positive integer (1 ≤ n ≤ 10^5) representing the number of cards, and the sequence of integers on the cards consists of positive integers each not exceeding 10^8. Additionally, `n` is greater than 3 and also greater than 1. `n` is not divisible by 2 and is not divisible by 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `i` is greater than or equal to 5 + 6 * k (where k is the number of iterations the loop executed), `n` remains a positive integer greater than or equal to 25. If `i * i` becomes greater than `n`, the loop terminates and `i` will be the smallest number such that `i * i` exceeds `n`.
    return True
    #The program returns True, indicating that the loop has successfully terminated and that `i` is the smallest number such that `i * i` exceeds `n`.

#Function 16:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), and the sequence of integers on Alexander's cards consists of positive integers that do not exceed 10^8.
def func_16():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 17:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and the list of integers on the cards contains positive integers, each not exceeding 10^8.
def func_17():
    n = func_1()
    a = func_5()
    a.sort()
    if (n == 1) :
        func_18(-1)
        exit()
    #State of the program after the if block has been executed: *`n` is an integer such that 1 ≤ `n` ≤ 10^5; `a` is a sorted list of integers. If `n` is equal to 1, `func_18` is called with the argument -1 and the program execution is terminated.
    if (n == 2) :
        if (a[0] == a[1]) :
            func_18(1)
            func_18(a[0])
            exit()
        #State of the program after the if block has been executed: *`n` is an integer such that 1 ≤ `n` ≤ 10^5 and is equal to 2; `a` is a sorted list of integers where the first two elements are equal, resulting in the program being terminated.
        l = []
        g = a[1] - a[0]
        if (abs(g) % 2 == 0) :
            l.append(a[0] + g // 2)
        #State of the program after the if block has been executed: *`n` is 2; `a` is a sorted list of integers where the first two elements are equal; `l` is a list containing `a[0]`; `g` is 0; and if the absolute value of `g` is even, then `l` is updated to include `a[0]`.
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[1] + (a[1] - a[0]))
        l.sort()
        l = list(set(l))
        func_18(len(l))
        func_18(*l)
        exit()
    #State of the program after the if block has been executed: *`n` is an integer such that 1 ≤ `n` ≤ 10^5, and if `n` is equal to 2, then `a` is a sorted list of integers where the first two elements are equal, `l` contains one element equal to `a[0]`, `g` is 0, and the program has terminated without further execution.
    g = []
    l = []
    for i in range(n - 1):
        g.append(a[i + 1] - a[i])
        
        l.append(abs(a[i + 1] - a[i]))
        
    #State of the program after the  for loop has been executed: `n` is at least 2, `g` contains `n - 1` elements representing the differences between consecutive elements of `a`, `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`, and both `g` and `l` reflect the differences between all pairs of consecutive elements in the sorted list `a`.
    if (len(list(set(g))) > 2) :
        func_18(0)
        exit()
    #State of the program after the if block has been executed: *`n` is at least 2, `g` contains `n - 1` elements representing the differences between consecutive elements of `a`, and `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`. If there are more than 2 distinct elements in `g`, the function `func_18(0)` is called and the program is terminated.
    if (len(list(set(g))) == 1) :
        l = []
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[-1] + (a[1] - a[0]))
        l = list(set(l))
        l.sort()
        func_18(len(l))
        func_18(*l)
    else :
        if (0 in l) :
            if (len(list(set(g))) >= 2) :
                func_18(0)
                exit()
            #State of the program after the if block has been executed: *`n` is at least 2, `g` contains `n - 1` elements representing the differences between consecutive elements of `a`, `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`, there are more than 1 distinct elements in `g`, and 0 is an element of `l`. If there are at least 2 distinct elements in `g`, the function `func_18(0)` was called, and the program terminated due to exit().
        #State of the program after the if block has been executed: *`n` is at least 2, `g` contains `n - 1` elements representing the differences between consecutive elements of `a`, `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`, and there are more than 1 distinct elements in `g`. If 0 is an element of `l`, then the function `func_18(0)` is called, and the program terminates.
        gc = l[0]
        for i in range(1, len(l)):
            gc = func_14(gc, l[i])
            
        #State of the program after the  for loop has been executed: `n` is at least 2, `g` contains `n - 1` elements, `l` contains `n - 1` elements, `gc` is modified by applying `func_14` to `l[0]` and all subsequent elements in `l`.
        for i in range(n - 1):
            if abs(a[i + 1] - a[i]) != gc:
                x = a[i] + (a[i + 1] - a[i]) // 2
                a.append(a[i] + (a[i + 1] - a[i]) // 2)
                break
            
        #State of the program after the  for loop has been executed: `n` is at least 2, `g` contains `n - 1` elements, `l` contains `n - 1` elements, `gc` is modified by applying `func_14` to `l[0]` and all subsequent elements in `l`, `i` is less than `n - 1`, and `a` may contain additional elements based on the condition checks within the loop. If the loop executes, `a` contains elements where each new element is calculated as `a[i] + (a[i + 1] - a[i]) // 2` for the first instance where the condition is met. If the loop does not execute, `a` remains unchanged.
        a.sort()
        l = []
        for i in range(n):
            l.append(a[i + 1] - a[i])
            
        #State of the program after the  for loop has been executed: `n` is at least 2; `g` contains `n - 1` elements; `l` contains `n - 1` elements representing the differences between each pair of consecutive elements in `a`; `gc` is modified by applying `func_14` to the previous elements in `l`; `i` is `n - 1`; `a` is sorted.
        if (len(list(set(l))) == 1) :
            func_18(1)
            func_18(x)
        else :
            func_18(0)
        #State of the program after the if-else block has been executed: *`n` is at least 2; `g` contains `n - 1` elements; `l` contains `n - 1` elements representing the differences between each pair of consecutive elements in `a`; `gc` is modified by applying `func_14` to the previous elements in `l`; `i` is `n - 1`; `a` is sorted. If all elements in `l` are equal, the call to `func_18(1)` was made but did not change any values. If `l` contains at least two different values, `func_18(0)` is called.
    #State of the program after the if-else block has been executed: *If `g` contains only one distinct element, then `n` is at least 2, `g` contains `n - 1` elements, `l` is sorted in ascending order with unique elements, and `func_18` is called with the length of `l`. If `g` contains more than one distinct element, then `n` is at least 2; `g` still contains `n - 1` elements; `l` retains its elements representing the differences between each pair of consecutive elements in `a`; `gc` is modified by applying `func_14` to the previous elements in `l`; `i` is set to `n - 1`; `a` is sorted. If all elements in `l` are equal, `func_18(1)` was called but did not change any values; if `l` contains at least two different values, `func_18(0)` is called.

#Function 18:
#State of the program right berfore the function call: n is a positive integer such that 1 <= n <= 10^5, and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_18():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `n` is a positive integer such that 1 <= `n` <= 10^5; `args` is a non-empty iterable; `at_start` is False; `sep` has been written to the file between all elements after the first; each element in `args` has been written to the file as a string.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 <= `n` <= 10^5, `args` is a non-empty iterable, `at_start` is False, `sep` has been written to the file between all elements after the first, and a value has been written to the file (either specified by `kwargs['end']` or a newline character). If the flush parameter has been popped from kwargs and its value is True, the file buffer is flushed.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
