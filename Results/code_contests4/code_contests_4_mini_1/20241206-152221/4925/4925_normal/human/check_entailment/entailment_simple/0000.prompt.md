
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Ujan has a lot of useless stuff in his drawers, a considerable part of which are his math notebooks: it is time to sort them out. This time he found an old dusty graph theory notebook with a description of a graph.

It is an undirected weighted graph on n vertices. It is a complete graph: each pair of vertices is connected by an edge. The weight of each edge is either 0 or 1; exactly m edges have weight 1, and all others have weight 0.

Since Ujan doesn't really want to organize his notes, he decided to find the weight of the minimum spanning tree of the graph. (The weight of a spanning tree is the sum of all its edges.) Can you find the answer for Ujan so he stops procrastinating?

Input

The first line of the input contains two integers n and m (1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5)), the number of vertices and the number of edges of weight 1 in the graph. 

The i-th of the next m lines contains two integers a_i and b_i (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i), the endpoints of the i-th edge of weight 1.

It is guaranteed that no edge appears twice in the input.

Output

Output a single integer, the weight of the minimum spanning tree of the graph.

Examples

Input


6 11
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6


Output


2


Input


3 0


Output


0

Note

The graph from the first sample is shown below. Dashed edges have weight 0, other edges have weight 1. One of the minimum spanning trees is highlighted in orange and has total weight 2.

<image>

In the second sample, all edges have weight 0 so any spanning tree has total weight 0.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n is an integer representing the number of vertices in the graph, where 1 ≤ n ≤ 100000; m is an integer representing the number of edges with weight 1, where 0 ≤ m ≤ min((n(n-1))/2, 100000); for each of the m edges, a_i and b_i are integers representing the endpoints of the edges, where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_1():
    n, m = func_4()
    p = list(range(n))
    r = func_7(int, n)
    sg = func_7(set, n)
    for _ in range(m):
        x, y = func_5(-1)
        
        sg[x].add(y)
        
        sg[y].add(x)
        
    #State of the program after the  for loop has been executed: `n` is an integer, `p` is a list of integers from 0 to `n-1`, `r` is the value returned by func_7(int, n), `sg` contains edges added from the pairs (x, y) returned by func_5(-1) for each of the `m` iterations, where each `x` and `y` are integers representing vertices in the graph.
    v = min(range(n), key=lambda i: len(sg[i]))
    for i in range(n):
        if i not in sg[v]:
            union(i, v)
        else:
            for j in range(n):
                if j not in sg[i]:
                    union(i, j)
        
    #State of the program after the  for loop has been executed: `n` is an integer, `p` is a list of integers from 0 to `n-1`, `sg` contains the edges from the union operations among all indices, `v` is still the index of the vertex with the fewest edges in `sg`, and all indices `0` to `n-1` are connected through the union operations.
    roots = set()
    for i in range(n):
        roots.add(find(i))
        
    #State of the program after the  for loop has been executed: `n` is an integer, `roots` contains the unique results of `find(i)` for all indices `i` from 0 to `n-1`.
    print(len(roots) - 1)

#Function 2:
#State of the program right berfore the function call: v is a tuple containing two integers n and m, where n is the number of vertices (1 ≤ n ≤ 10^5) and m is the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/(2), 10^5)).
def find(v):
    vc = v
    while v != p[v]:
        v = p[v]
        
    #State of the program after the loop has been executed: `v` is equal to `p[v]`, indicating convergence; the loop has terminated when `v` equals `p[v]`.
    while vc != v:
        p[vc], vc = v, p[vc]
        
    #State of the program after the loop has been executed: 'v' is equal to 'p[v]', 'vc' is equal to 'v', and the loop has terminated as 'vc' equals 'v'.
    return v
    #The program returns the value of 'v', which is equal to 'p[v]'

#Function 3:
#State of the program right berfore the function call: n is a positive integer representing the number of vertices in the graph, m is a non-negative integer representing the number of edges with weight 1, and for each edge described by a_i and b_i, 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def union(u, v):
    u, v = find(u), find(v)
    if (u == v) :
        return
        #The program returns nothing as the return statement is empty.
    #State of the program after the if block has been executed: *`n` is a positive integer representing the number of vertices in the graph, `m` is a non-negative integer representing the number of edges with weight 1, the values of `u` and `v` are updated to their respective representatives in the union-find structure as determined by the `find` function, and `u` is not equal to `v`.
    if (r[u] < r[v]) :
        u, v = v, u
    #State of the program after the if block has been executed: *`n` is a positive integer representing the number of vertices in the graph, `m` is a non-negative integer representing the number of edges with weight 1, `u` and `v` are updated to their respective representatives in the union-find structure. If `r[u]` is less than `r[v]`, then `u` is assigned the value of `v`, and `v` is assigned the value of `u`.
    p[u] = v
    if (r[u] == r[v]) :
        r[u] += 1
    #State of the program after the if block has been executed: *`n` is a positive integer and `m` is a non-negative integer. If `r[u]` is equal to `r[v]`, then `r[u]` is increased by 1, while `r[v]` remains unchanged. If `r[u]` is not equal to `r[v]`, the state remains unchanged since there is no else part.

#Function 4:
#State of the program right berfore the function call: x is a tuple containing two integers n and m, where n is the number of vertices (1 ≤ n ≤ 10^5) and m is the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/(2),10^5)). The next m elements in the input represent pairs of integers (a_i, b_i) indicating the endpoints of edges with weight 1, where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_2(x):
    return pow(x, MOD - 2, MOD)
    #The program returns the result of raising the tuple x to the power of MOD - 2, modulo MOD.

#Function 5:
#State of the program right berfore the function call: x is an integer representing the number of vertices in the graph (1 ≤ x ≤ 10^5), and y is an integer representing the number of edges with weight 1 (0 ≤ y ≤ min((x(x-1))/(2), 10^5)).
def func_3(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the GCD of the original values of `x` and `y`.
    return x
    #The program returns the GCD of the original values of `x` and `y`, where `y` is 0. Therefore, the program returns the value of `x`.

#Function 6:
#State of the program right berfore the function call: n is a positive integer representing the number of vertices in the graph (1 ≤ n ≤ 10^5), m is a non-negative integer representing the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/(2),10^5)), and for each of the m edges, a_i and b_i are integers such that 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_4():
    return list(map(int, input().split()))
    #The program returns a list of integers from the input, which are provided as space-separated values

#Function 7:
#State of the program right berfore the function call: o is a tuple containing two integers n and m, where n is the number of vertices (1 ≤ n ≤ 100000) and m is the number of edges of weight 1 (0 ≤ m ≤ min((n(n-1))/(2), 100000)). Following this, there are m pairs of integers (a_i, b_i) representing the endpoints of each edge of weight 1, where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_5(o):
    return list(map(lambda x: int(x) + o, input().split()))
    #The program returns a list of integers where each integer is the sum of the corresponding integer from the input and the tuple 'o' containing two integers (n, m)

#Function 8:
#State of the program right berfore the function call: n is a positive integer representing the number of vertices (1 ≤ n ≤ 10^5), m is a non-negative integer representing the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/(2),10^5)), and for each of the next m lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i) representing the endpoints of the edges with weight 1.
def func_6(n, m):
    return [func_4() for _ in range(n)]
    #The program returns a list containing the results of calling func_4() n times, where n is a positive integer representing the number of vertices.

#Function 9:
#State of the program right berfore the function call: f is a function that accepts two integers n and m, where 1 ≤ n ≤ 10^5 and 0 ≤ m ≤ min((n(n-1))/(2),10^5), and subsequent pairs of integers representing edges of weight 1, where each pair (a_i, b_i) satisfies 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_7(f):
    return [func_7(f, *dim[1:]) for _ in range(dim[0])] if dim else f()
    #The program returns a list containing the result of calling func_7 with the function f and the subsequent pairs of integers based on the dimensions specified in dim, repeated dim[0] times, or the result of calling f() if dim is empty.

#Function 10:
#State of the program right berfore the function call: start is an integer representing the number of vertices in the graph (1 ≤ start ≤ 10^5), step is an integer representing the number of edges of weight 1 in the graph (0 ≤ step ≤ min((start(start-1))/(2),10^5)), and count is a list of tuples where each tuple contains two integers representing the endpoints of the edges of weight 1 (1 ≤ a_i, b_i ≤ start, a_i ≠ b_i).
def func_8(start, step, count):
    return range(start, start + step * count, step)
    #The program returns a range object starting from 'start' to 'start + step * count' with a step of 'step'.

#Function 11:
#State of the program right berfore the function call: l is a list of tuples representing edges in a complete undirected weighted graph, where each tuple contains two distinct integers (a_i, b_i) indicating an edge with weight 1 between vertices a_i and b_i; start is an integer representing the starting vertex (default is 0), and end is an integer representing the ending vertex (default is 0). The number of vertices n is inferred from the maximum value in the tuples and must satisfy 1 ≤ n ≤ 10^5, and the number of edges m must satisfy 0 ≤ m ≤ min((n(n-1))/(2), 10^5).
def func_9(l, start, end):
    return range(start, len(l) + end)
    #The program returns a range object starting from 'start' and ending at the length of the list 'l' plus 'end'

#Function 12:
#State of the program right berfore the function call: n is an integer representing the number of vertices in the graph, where 1 ≤ n ≤ 10^5. The function does not take in m directly, but m is determined by the number of edges with weight 1, which can be between 0 and min((n(n-1))/(2),10^5). The pairs of integers (a_i, b_i) indicating the endpoints of the edges with weight 1 are provided in the input, where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_10(n):
    """ [0, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, ...] """
    return 2 ** (n - 1).bit_length()
    #The program returns 2 raised to the power of (n - 1) bit length, which represents the smallest power of 2 greater than or equal to n.

#Function 13:
#State of the program right berfore the function call: x is an integer representing the number of vertices in the graph (1 ≤ x ≤ 10^5) and r is an integer representing the number of edges with weight 1 (0 ≤ r ≤ min((x(x-1))/(2),10^5)).
def func_11(x, r):
    """ = ceil(x / r) """
    return (x + r - 1) // r
    #The program returns the integer result of (x + r - 1) // r, which represents the ceiling of x divided by r


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
