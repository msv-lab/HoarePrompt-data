
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: For a finite set of integers X, let f(X)=\max X - \min X.

Given are N integers A_1,...,A_N.

We will choose K of them and let S be the set of the integers chosen. If we distinguish elements with different indices even when their values are the same, there are {}_N C_K ways to make this choice. Find the sum of f(S) over all those ways.

Since the answer can be enormous, print it \bmod (10^9+7).

Constraints

* 1 \leq N \leq 10^5
* 1 \leq K \leq N
* |A_i| \leq 10^9

Input

Input is given from Standard Input in the following format:


N K
A_1 ... A_N


Output

Print the answer \bmod (10^9+7).

Examples

Input

4 2
1 1 3 4


Output

11


Input

6 3
10 10 10 -10 -10 -10


Output

360


Input

3 1
1 1 1


Output

0


Input

10 6
1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0


Output

999998537
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: a is a list of integers with length N (1 <= N <= 10^5), and b is an integer K (1 <= K <= N). The absolute value of each integer in a is at most 10^9.
def func_1(a, b):
    c = a + b
    if (c >= mod) :
        c -= mod
    #State of the program after the if block has been executed: *`a` is a list of integers with length N, `b` is an integer K, and `c` is intended to be a list where each element of `a` has `b` added to it. If `c` is greater than or equal to `mod`, then `c` is reduced by `mod`.
    return c
    #The program returns the list `c`, which contains each element of list `a` with `b` added to it, reduced by `mod` if `c` is greater than or equal to `mod`.

#Function 2:
#State of the program right berfore the function call: a is a list of integers with length N (1 ≤ N ≤ 10^5), and b is an integer K (1 ≤ K ≤ N). The absolute value of each integer in a is at most 10^9.
def func_2(a, b):
    return (a - b) % mod
    #The program returns the result of subtracting integer b from the list a, and then taking the modulus of that result with respect to mod

#Function 3:
#State of the program right berfore the function call: a is a list of integers with length N (1 <= N <= 10^5) where each integer |A_i| is less than or equal to 10^9, and b is an integer K (1 <= K <= N).
def func_3(a, b):
    return a * b % mod
    #The program returns the result of multiplying each integer in the list 'a' by the integer 'b' and then taking the modulus with respect to 'mod'.

#Function 4:
#State of the program right berfore the function call: a is a list of integers of length N (1 <= N <= 10^5), and b is an integer K (1 <= K <= N). Each integer in a is within the range of -10^9 to 10^9.
def func_4(a, b):
    if (b == 0) :
        return 1
        #The program returns the integer 1
    #State of the program after the if block has been executed: *`a` is a list of integers of length N (1 <= N <= 10^5), and `b` is an integer K (1 <= K <= N). The value of `b` is not equal to 0. Each integer in `a` is within the range of -10^9 to 10^9.
    if (b % 2 == 1) :
        return func_3(a, func_4(a, b - 1))
        #The program returns the result of calling func_3 with the list 'a' and the result of calling func_4 with 'a' and 'b - 1', where 'b' is an odd integer and 'b' is not equal to 0.
    else :
        temp = func_4(a, b / 2)
        return temp * temp
        #The program returns the square of the value stored in 'temp', which is the result of 'func_4(a, b / 2)' where 'b / 2' is an integer in the range from 1 to N/2.

#Function 5:
#State of the program right berfore the function call: a is a tuple where the first element is a list of integers representing the values A_1, ..., A_N and the second element is a tuple of two integers N and K such that 1 ≤ N ≤ 10^5, 1 ≤ K ≤ N, and |A_i| ≤ 10^9 for all integers in the list.
def func_5(a):
    return func_4(a, mod - 2)
    #The program returns the result of the function func_4 that processes the tuple 'a' containing a list of integers and the integers N and K, with 'mod' adjusted by subtracting 2.

#Function 6:
#State of the program right berfore the function call: n is an integer representing the number of elements, k is an integer representing the number of elements to choose such that 1 <= k <= n, and fac is a list of integers representing the factorial values used for combinations, where the length of fac is at least n.
def func_6(n, k, fac):
    if (k > n) :
        return 0
        #The program returns 0, indicating that no valid combinations can be formed since k is greater than n.
    #State of the program after the if block has been executed: *`n` is an integer representing the number of elements, `k` is an integer representing the number of elements to choose such that 1 <= `k` <= `n`, and `fac` is a list of integers representing the factorial values used for combinations, where the length of `fac` is at least `n`. Additionally, `k` is less than or equal to `n`.
    return func_3(fac[n], func_5(func_3(fac[n - k], fac[k])))
    #The program returns the result of the combination calculation using the factorial values at indices n, n-k, and k from the list 'fac'

#Function 7:
#State of the program right berfore the function call: N is a positive integer such that 1 <= N <= 100000, K is a positive integer such that 1 <= K <= N, and A is a list of N integers where each integer A_i satisfies -10^9 <= A_i <= 10^9.
def func_7():
    n, k = [int(x) for x in raw_input().split()]
    a = [int(x) for x in raw_input().split()]
    fac = [0] * (n + 5)
    fac[0] = 1
    for i in range(1, n + 5):
        fac[i] = func_3(fac[i - 1], i)
        
    #State of the program after the  for loop has been executed: `N` is a positive integer such that 1 <= `N` <= 100000, `fac[i]` is assigned the value of `func_3` applied cumulatively from `fac[0]` to `fac[N + 4]` for `i` in the range from 0 to `N + 4.
    a.sort()
    ans = 0
    for i in range(n - 1):
        diff = func_2(a[i + 1], a[i])
        
        ways = func_6(n, k, fac)
        
        ways = func_2(ways, func_6(i + 1, k, fac))
        
        ways = func_2(ways, func_6(n - i - 1, k, fac))
        
        ans = func_1(ans, func_3(diff, ways))
        
    #State of the program after the  for loop has been executed: `N` is a positive integer such that 1 <= `N` <= 100000; `ans` is updated based on all iterations, `i` is `N - 2` (or `-1` if `N` is 1), `diff` is the result of `func_2(a[N-1], a[N-2])` (or not calculated if `N` is 1), `ways` is the final computed value based on the last iteration's calculations.
    print(ans)


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
