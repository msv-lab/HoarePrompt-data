
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Berland starts to seize the initiative on the war with Flatland. To drive the enemy from their native land, the berlanders need to know exactly how many more flatland soldiers are left in the enemy's reserve. Fortunately, the scouts captured an enemy in the morning, who had a secret encrypted message with the information the berlanders needed so much.

The captured enemy had an array of positive integers. Berland intelligence have long been aware of the flatland code: to convey the message, which contained a number m, the enemies use an array of integers a. The number of its subarrays, in which there are at least k equal numbers, equals m. The number k has long been known in the Berland army so General Touristov has once again asked Corporal Vasya to perform a simple task: to decipher the flatlanders' message.

Help Vasya, given an array of integers a and number k, find the number of subarrays of the array of numbers a, which has at least k equal numbers.

Subarray a[i... j] (1 ≤ i ≤ j ≤ n) of array a = (a1, a2, ..., an) is an array, made from its consecutive elements, starting from the i-th one and ending with the j-th one: a[i... j] = (ai, ai + 1, ..., aj).

Input

The first line contains two space-separated integers n, k (1 ≤ k ≤ n ≤ 4·105), showing how many numbers an array has and how many equal numbers the subarrays are required to have, correspondingly. 

The second line contains n space-separated integers ai (1 ≤ ai ≤ 109) — elements of the array.

Output

Print the single number — the number of such subarrays of array a, that they have at least k equal integers.

Please do not use the %lld specifier to read or write 64-bit integers in С++. In is preferred to use the cin, cout streams or the %I64d specifier.

Examples

Input

4 2
1 2 1 2


Output

3

Input

5 3
1 2 1 1 3


Output

2

Input

3 1
1 1 1


Output

6

Note

In the first sample are three subarrays, containing at least two equal numbers: (1,2,1), (2,1,2) and (1,2,1,2).

In the second sample are two subarrays, containing three equal numbers: (1,2,1,1,3) and (1,2,1,1).

In the third sample any subarray contains at least one 1 number. Overall they are 6: (1), (1), (1), (1,1), (1,1) and (1,1,1).
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 400,000, k is a positive integer such that 1 ≤ k ≤ n, and a is a list of n positive integers where each integer a[i] satisfies 1 ≤ a[i] ≤ 1,000,000,000.
def func():
    debug = 'DEBUG' in os.environ
    n, k = map(int, sys.stdin.readline().split()[:2])
    vals = map(int, sys.stdin.readline().strip('\n\r ').split()[:n])
    if (k == 1) :
        count = n * (n + 1) / 2
    else :
        count = 0
        d = {}
        leftmost = -1
        for (i, val) in enumerate(vals):
            if val in d:
                d[val] += [i]
                dval = d[val]
                if len(dval) < k:
                    pass
                else:
                    dvalk = dval[-k]
                    if dvalk > leftmost:
                        leftmost = dvalk
            else:
                d[val] = [i]
            
            count += leftmost + 1
            
        #State of the program after the  for loop has been executed: `count` is equal to the total sum of `leftmost + 1` for each iteration where `leftmost` is the largest index of the `k`-th occurrence of any value in `vals`, `d` is a dictionary mapping each value in `vals` to the list of its indices, `leftmost` may be -1 or the index of the k-th occurrence of the value with the largest index, and `vals` contains `n` integers.
    #State of the program after the if-else block has been executed: *`n` is a positive integer such that 1 ≤ `n` ≤ 400,000; `k` is a positive integer such that 1 ≤ `k` ≤ `n`; `a` is a list of `n` positive integers; `debug` remains unchanged; `vals` is a map object containing the first `n` integers read from input as integers. If `k` is equal to 1, then `count` is equal to `n * (n + 1) / 2`. Otherwise, `count` is equal to the total sum of `leftmost + 1` for each iteration, where `leftmost` is the largest index of the `k`-th occurrence of any value in `vals`, and `d` is a dictionary mapping each value in `vals` to the list of its indices. `leftmost` may be -1 or the index of the `k`-th occurrence of the value with the largest index. `vals` contains `n` integers.
    print(count)
#Overall this is what the function does:The function accepts two positive integers `n` and `k`, along with a list of `n` positive integers. It calculates and prints a count based on the occurrences of each integer in the list: if `k` is 1, it computes the sum of the first `n` integers; otherwise, it sums the indices of the `k`-th occurrences of each integer, updating the count based on the leftmost index of these occurrences. If there are fewer than `k` occurrences for any integer, it does not contribute to the count. The function does not return any value but prints the computed count.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
