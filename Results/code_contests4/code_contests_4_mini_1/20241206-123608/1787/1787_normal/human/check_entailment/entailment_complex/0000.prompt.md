
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Lord Omkar has permitted you to enter the Holy Church of Omkar! To test your worthiness, Omkar gives you a password which you must interpret!

A password is an array a of n positive integers. You apply the following operation to the array: pick any two adjacent numbers that are not equal to each other and replace them with their sum. Formally, choose an index i such that 1 ≤ i < n and a_{i} ≠ a_{i+1}, delete both a_i and a_{i+1} from the array and put a_{i}+a_{i+1} in their place. 

For example, for array [7, 4, 3, 7] you can choose i = 2 and the array will become [7, 4+3, 7] = [7, 7, 7]. Note that in this array you can't apply this operation anymore.

Notice that one operation will decrease the size of the password by 1. What is the shortest possible length of the password after some number (possibly 0) of operations?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the password.

The second line of each test case contains n integers a_{1},a_{2},...,a_{n} (1 ≤ a_{i} ≤ 10^9) — the initial contents of your password.

The sum of n over all test cases will not exceed 2 ⋅ 10^5.

Output

For each password, print one integer: the shortest possible length of the password after some number of operations.

Example

Input


2
4
2 1 3 1
2
420 420


Output


1
2

Note

In the first test case, you can do the following to achieve a length of 1:

Pick i=2 to get [2, 4, 1]

Pick i=1 to get [6, 1]

Pick i=1 to get [7]

In the second test case, you can't perform any operations because there is no valid i that satisfies the requirements mentioned above.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: The input consists of multiple test cases, where t is an integer (1 ≤ t ≤ 100) representing the number of test cases. Each test case consists of an integer n (1 ≤ n ≤ 200,000) representing the length of the password, followed by a list of n positive integers (1 ≤ a[i] ≤ 10^9) representing the contents of the password. The sum of n across all test cases will not exceed 200,000.
def func_1():
    fact = [1]
    for i in range(1, 100005):
        fact.append(fact[-1] * i % mod)
        
    #State of the program after the  for loop has been executed: `fact` is a list containing factorial values from 0! to 100004! modulo `mod`, `i` is 100004.
    ifact = [0] * 100005
    ifact[100004] = pow(fact[100004], mod - 2, mod)
    for i in range(100004, 0, -1):
        ifact[i - 1] = i * ifact[i] % mod
        
    #State of the program after the  for loop has been executed: `fact` is a list containing factorial values from 0! to 100004! modulo `mod`, `i` is 0, `ifact` is a list where each entry `ifact[n]` holds the value of `(n! modulo mod)^(-1) modulo mod` for `n` from 0 to 100004.
    return fact, ifact
    #The program returns the list 'fact' containing factorial values from 0! to 100004! modulo 'mod' and the list 'ifact' where each entry 'ifact[n]' holds the value of '(n! modulo mod)^(-1) modulo mod' for n from 0 to 100004.
#Overall this is what the function does:The function does not accept any parameters and returns two lists: 'fact' containing factorial values from 0! to 100004! computed modulo 'mod', and 'ifact' containing the modular inverses of these factorial values for n from 0 to 100004. The function ensures efficient computation of factorials and their inverses for later use, particularly in combinatorial calculations.

#Function 2:
#State of the program right berfore the function call: n is a positive integer representing the length of the password array p, where p is a list of n positive integers such that 1 ≤ p[i] ≤ 10^9 for all 0 ≤ i < n. The number of test cases t is a positive integer such that 1 ≤ t ≤ 100, and the sum of n over all test cases does not exceed 2 ⋅ 10^5.
def func_2(n, p):
    return pow(n, p - 2, p)
    #The program returns the result of calculating n raised to the power of (p - 2) modulo p for the length of the password array p, where n is a positive integer and p is a list of positive integers with constraints defined.
#Overall this is what the function does:The function accepts a positive integer `n` and a list of positive integers `p`, and returns the result of calculating `n` raised to the power of `(p[i] - 2)` modulo `p[i]` for each element `p[i]` in the list `p`. However, it does not iterate through the list `p`, and it will raise an error since the code attempts to perform the power operation on `p` directly instead of each individual element. Thus, the function will not work as intended and will fail if `p` is a list.

#Function 3:
#State of the program right berfore the function call: n is a positive integer representing the length of the password, r is a list of n positive integers where each integer is between 1 and 10^9, and the total number of integers across all test cases does not exceed 200,000.
def func_3(n, r, fact, ifact):
    t = fact[n] * (ifact[r] * ifact[n - r]) % mod % mod
    return t
    #The program returns the value of t, which is calculated as `fact[n] * (ifact[r] * ifact[n - r]) % mod % mod`, where `n` is a positive integer representing the length of the password and `r` is a list of `n` positive integers.
#Overall this is what the function does:The function accepts a positive integer `n`, a list `r` of `n` positive integers, and lists `fact` and `ifact` representing factorials and their inverses. It calculates and returns the value of `t`, which is computed as `fact[n] * (ifact[r] * ifact[n - r]) % mod % mod`. However, the implementation does not handle cases where `r` is not a single integer but a list, which could lead to potential errors or unexpected behavior. The function assumes that `r` is a valid index for accessing `ifact` and `n - r` is also valid, which may not always be the case based on the input provided.

#Function 4:
#State of the program right berfore the function call: The input consists of multiple test cases, where each test case contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) representing the length of the password, followed by an array a of n positive integers (1 ≤ a[i] ≤ 10^9). The total sum of n across all test cases does not exceed 2 ⋅ 10^5.
def func_4():
    return map(int, sys.stdin.readline().strip().split())
    #The program returns a map object containing the integers read from the input, which represents the array 'a' of length 'n' consisting of positive integers
#Overall this is what the function does:The function reads a line of input containing multiple integers, splits the input into individual strings, converts them into integers, and returns a map object of these integers. This map object represents an array of positive integers, which are expected to be part of multiple test cases, but the function does not handle the entirety of those test cases or their lengths directly; it only processes the provided input as a single line.

#Function 5:
#State of the program right berfore the function call: The input consists of multiple test cases, where each test case includes an integer n (1 ≤ n ≤ 2 ⋅ 10^5) indicating the length of the password, followed by an array a of n positive integers (1 ≤ a[i] ≤ 10^9). The total number of integers across all test cases does not exceed 2 ⋅ 10^5.
def func_5():
    return list(map(int, sys.stdin.readline().strip().split()))
    #The program returns a list of integers read from standard input, where each integer is part of an array of length n, based on the multiple test cases provided.
#Overall this is what the function does:The function reads a line of input from standard input, splits it into individual string components, converts these components to integers, and returns a list of these integers. It does not handle multiple test cases or any specific structure for the input beyond reading a single line of integers.

#Function 6:
#State of the program right berfore the function call: The function will handle multiple test cases, where t is a positive integer (1 ≤ t ≤ 100) representing the number of test cases. For each test case, n is a positive integer (1 ≤ n ≤ 2 ⋅ 10^5) representing the length of the password, and a is a list of n positive integers (1 ≤ a[i] ≤ 10^9) representing the initial contents of the password. The total sum of n across all test cases will not exceed 2 ⋅ 10^5.
def func_6():
    return sys.stdin.readline().strip()
    #The program returns a string input read from standard input, which is expected to be the next line of data provided during execution.
#Overall this is what the function does:The function accepts no parameters and returns a string that represents the next line of input read from standard input. It does not handle any cases regarding the format or validity of the input, and it assumes that the input will be provided correctly as expected during execution.

#Function 7:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), and y is a list of tuples, where each tuple contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) representing the length of the password, followed by n positive integers (1 ≤ a_i ≤ 10^9) representing the initial contents of the password. The sum of n over all test cases will not exceed 2 ⋅ 10^5.
def func_7(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the list of tuples, since the loop continues until `y` becomes 0.
    return x
    #The program returns the list of tuples `x` since `y` is 0 and the loop does not execute.
#Overall this is what the function does:The function accepts an integer `x` and a list `y` of tuples. It appears to attempt to compute the greatest common divisor (GCD) between `x` and `y` using a while loop, but due to the way the loop is structured, it will not execute as expected because `y` is a list, and the operation `x % y` will raise an error. As a result, the function will not return the intended tuple list but will instead lead to a TypeError. Therefore, the function is incomplete and does not provide meaningful output.

#Function 8:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), and y is a list of tuples where each tuple contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) and a list of n positive integers (1 ≤ a_i ≤ 10^9), with the sum of n over all test cases not exceeding 2 ⋅ 10^5.
def func_8(x, y):
    return x * y // func_7(x, y)
    #The program returns the result of the expression x multiplied by the list y divided by the result of the function func_7 with parameters x and y.
#Overall this is what the function does:The function accepts an integer `x`, representing the number of test cases, and a list `y` of tuples, where each tuple contains an integer `n` and a list of `n` positive integers. It returns the result of the expression `x` multiplied by `y` divided by the result of calling another function `func_7` with the same parameters `x` and `y`. The actual behavior of the function depends on the implementation of `func_7`, which may not be defined here, potentially leading to undefined behavior if `func_7` returns zero or a non-integer. Additionally, the multiplication of `x` with `y` may not yield the intended mathematical result since `y` is a list, which could lead to an error if not handled correctly.

#Function 9:
#State of the program right berfore the function call: n is a positive integer representing the length of the password, followed by an array a of n positive integers, where each integer a[i] is between 1 and 10^9.
def func_9(n):
    return [n, 1, n + 1, 0][n % 4]
    #The program returns one of the values from the list [n, 1, n + 1, 0] based on the value of n modulo 4
#Overall this is what the function does:The function accepts a positive integer `n` and returns one of the values from the list `[n, 1, n + 1, 0]` based on the result of `n % 4`. Specifically, it returns `n` when `n % 4` equals 0, `1` when `n % 4` equals 1, `n + 1` when `n % 4` equals 2, and `0` when `n % 4` equals 3.

#Function 10:
#State of the program right berfore the function call: a is a list of positive integers representing the password, b is an integer representing the number of test cases, where 1 ≤ b ≤ 100 and the sum of the lengths of lists in a does not exceed 200,000.
def func_10(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a
            res %= MOD
            b -= 1
        else:
            a = a * a
            a %= MOD
            b >>= 1
        
    #State of the program after the loop has been executed: `b` is 0, `res` is the product of the elements of the original list `a` raised to the power of the initial value of `b`, taken modulo `MOD`, and `a` is the final value of the list after all squaring operations and modulo `MOD`.
    res %= MOD
    return res
    #The program returns the product of the elements of the original list `a` raised to the power of 0, taken modulo `MOD`, which is 1, since any number raised to the power of 0 is 1.
#Overall this is what the function does:The function accepts a list of positive integers `a` and an integer `b`, and computes the product of the elements of `a` raised to the power of `b`, taken modulo `MOD`. If `b` is initially 0, the function returns 1, as any number raised to the power of 0 equals 1.

#Function 11:
#State of the program right berfore the function call: P is a list of tuples, where each tuple contains two elements: an integer n (1 ≤ n ≤ 2 ⋅ 10^5) representing the length of the password, and a list of n positive integers a (1 ≤ a[i] ≤ 10^9) representing the initial contents of the password. The length of all password contents across all test cases does not exceed 2 ⋅ 10^5.
def func_11(P):
    ans = (-1 + sqrt(1 + 8 * P)) // 2
    return ans
    #The program returns 'ans', which is not calculable without a specific integer value for the list of tuples 'P' containing an integer n and a list of positive integers a.
#Overall this is what the function does:The function accepts a list of tuples `P`, where each tuple contains an integer `n` and a list of `n` positive integers. It calculates a value `ans` using the formula (-1 + sqrt(1 + 8 * P)) // 2, which is based on the integer `P` but does not actually utilize the contents of the tuples in any meaningful way. The function returns this calculated value `ans`, which is not directly related to the contents of the input list. Therefore, the actual output does not depend on the specific values in the tuples of `P`.

#Function 12:
#State of the program right berfore the function call: The input consists of multiple test cases, with the first line containing an integer t (1 ≤ t ≤ 100). Each test case has a line with an integer n (1 ≤ n ≤ 2 ⋅ 10^5), followed by a line with n positive integers a_{1}, a_{2}, ..., a_{n} (1 ≤ a_{i} ≤ 10^9). The sum of n over all test cases does not exceed 2 ⋅ 10^5.
def func_12():
    T = int(func_6())
    while T:
        n = int(func_6())
        
        Arr = func_5()
        
        p = Arr[0]
        
        flag = 0
        
        for i in Arr[1:]:
            if i != p:
                flag = 1
                break
        
        if flag == 1:
            print(1)
        else:
            print(n)
        
        T -= 1
        
    #State of the program after the loop has been executed: `T` is 0, `n` is the value assigned from the last call to `int(func_6())`, `Arr` contains at least 2 elements from the last call to `func_5()`, `p` is the value of `Arr[0]`, `i` is the last element of `Arr[1:]`, and if `flag` is 1, 1 is printed in the last iteration; otherwise, the last value of `n` is printed if `flag` is 0.
#Overall this is what the function does:The function processes multiple test cases where the first input is an integer `t` indicating the number of test cases. For each test case, it reads an integer `n` followed by `n` positive integers. It checks if all the integers in the list are the same. If they are, it prints `n`; otherwise, it prints `1`. The function effectively computes whether the list of integers consists of identical values or not, returning `n` for identical values and `1` for differing values.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.