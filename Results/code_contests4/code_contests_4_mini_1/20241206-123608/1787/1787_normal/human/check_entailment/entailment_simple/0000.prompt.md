
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Lord Omkar has permitted you to enter the Holy Church of Omkar! To test your worthiness, Omkar gives you a password which you must interpret!

A password is an array a of n positive integers. You apply the following operation to the array: pick any two adjacent numbers that are not equal to each other and replace them with their sum. Formally, choose an index i such that 1 ≤ i < n and a_{i} ≠ a_{i+1}, delete both a_i and a_{i+1} from the array and put a_{i}+a_{i+1} in their place. 

For example, for array [7, 4, 3, 7] you can choose i = 2 and the array will become [7, 4+3, 7] = [7, 7, 7]. Note that in this array you can't apply this operation anymore.

Notice that one operation will decrease the size of the password by 1. What is the shortest possible length of the password after some number (possibly 0) of operations?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the password.

The second line of each test case contains n integers a_{1},a_{2},...,a_{n} (1 ≤ a_{i} ≤ 10^9) — the initial contents of your password.

The sum of n over all test cases will not exceed 2 ⋅ 10^5.

Output

For each password, print one integer: the shortest possible length of the password after some number of operations.

Example

Input


2
4
2 1 3 1
2
420 420


Output


1
2

Note

In the first test case, you can do the following to achieve a length of 1:

Pick i=2 to get [2, 4, 1]

Pick i=1 to get [6, 1]

Pick i=1 to get [7]

In the second test case, you can't perform any operations because there is no valid i that satisfies the requirements mentioned above.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: The input consists of multiple test cases, where t is an integer (1 ≤ t ≤ 100) representing the number of test cases. Each test case consists of an integer n (1 ≤ n ≤ 200,000) representing the length of the password, followed by a list of n positive integers (1 ≤ a[i] ≤ 10^9) representing the contents of the password. The sum of n across all test cases will not exceed 200,000.
def func_1():
    fact = [1]
    for i in range(1, 100005):
        fact.append(fact[-1] * i % mod)
        
    #State of the program after the  for loop has been executed: `fact` is a list containing factorial values from 0! to 100004! modulo `mod`, `i` is 100004.
    ifact = [0] * 100005
    ifact[100004] = pow(fact[100004], mod - 2, mod)
    for i in range(100004, 0, -1):
        ifact[i - 1] = i * ifact[i] % mod
        
    #State of the program after the  for loop has been executed: `fact` is a list containing factorial values from 0! to 100004! modulo `mod`, `i` is 0, `ifact` is a list where each entry `ifact[n]` holds the value of `(n! modulo mod)^(-1) modulo mod` for `n` from 0 to 100004.
    return fact, ifact
    #The program returns the list 'fact' containing factorial values from 0! to 100004! modulo 'mod' and the list 'ifact' where each entry 'ifact[n]' holds the value of '(n! modulo mod)^(-1) modulo mod' for n from 0 to 100004.

#Function 2:
#State of the program right berfore the function call: n is a positive integer representing the length of the password array p, where p is a list of n positive integers such that 1 ≤ p[i] ≤ 10^9 for all 0 ≤ i < n. The number of test cases t is a positive integer such that 1 ≤ t ≤ 100, and the sum of n over all test cases does not exceed 2 ⋅ 10^5.
def func_2(n, p):
    return pow(n, p - 2, p)
    #The program returns the result of calculating n raised to the power of (p - 2) modulo p for the length of the password array p, where n is a positive integer and p is a list of positive integers with constraints defined.

#Function 3:
#State of the program right berfore the function call: n is a positive integer representing the length of the password, r is a list of n positive integers where each integer is between 1 and 10^9, and the total number of integers across all test cases does not exceed 200,000.
def func_3(n, r, fact, ifact):
    t = fact[n] * (ifact[r] * ifact[n - r]) % mod % mod
    return t
    #The program returns the value of t, which is calculated as `fact[n] * (ifact[r] * ifact[n - r]) % mod % mod`, where `n` is a positive integer representing the length of the password and `r` is a list of `n` positive integers.

#Function 4:
#State of the program right berfore the function call: The input consists of multiple test cases, where each test case contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) representing the length of the password, followed by an array a of n positive integers (1 ≤ a[i] ≤ 10^9). The total sum of n across all test cases does not exceed 2 ⋅ 10^5.
def func_4():
    return map(int, sys.stdin.readline().strip().split())
    #The program returns a map object containing the integers read from the input, which represents the array 'a' of length 'n' consisting of positive integers

#Function 5:
#State of the program right berfore the function call: The input consists of multiple test cases, where each test case includes an integer n (1 ≤ n ≤ 2 ⋅ 10^5) indicating the length of the password, followed by an array a of n positive integers (1 ≤ a[i] ≤ 10^9). The total number of integers across all test cases does not exceed 2 ⋅ 10^5.
def func_5():
    return list(map(int, sys.stdin.readline().strip().split()))
    #The program returns a list of integers read from standard input, where each integer is part of an array of length n, based on the multiple test cases provided.

#Function 6:
#State of the program right berfore the function call: The function will handle multiple test cases, where t is a positive integer (1 ≤ t ≤ 100) representing the number of test cases. For each test case, n is a positive integer (1 ≤ n ≤ 2 ⋅ 10^5) representing the length of the password, and a is a list of n positive integers (1 ≤ a[i] ≤ 10^9) representing the initial contents of the password. The total sum of n across all test cases will not exceed 2 ⋅ 10^5.
def func_6():
    return sys.stdin.readline().strip()
    #The program returns a string input read from standard input, which is expected to be the next line of data provided during execution.

#Function 7:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), and y is a list of tuples, where each tuple contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) representing the length of the password, followed by n positive integers (1 ≤ a_i ≤ 10^9) representing the initial contents of the password. The sum of n over all test cases will not exceed 2 ⋅ 10^5.
def func_7(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the list of tuples, since the loop continues until `y` becomes 0.
    return x
    #The program returns the list of tuples `x` since `y` is 0 and the loop does not execute.

#Function 8:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), and y is a list of tuples where each tuple contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) and a list of n positive integers (1 ≤ a_i ≤ 10^9), with the sum of n over all test cases not exceeding 2 ⋅ 10^5.
def func_8(x, y):
    return x * y // func_7(x, y)
    #The program returns the result of the expression x multiplied by the list y divided by the result of the function func_7 with parameters x and y.

#Function 9:
#State of the program right berfore the function call: n is a positive integer representing the length of the password, followed by an array a of n positive integers, where each integer a[i] is between 1 and 10^9.
def func_9(n):
    return [n, 1, n + 1, 0][n % 4]
    #The program returns one of the values from the list [n, 1, n + 1, 0] based on the value of n modulo 4

#Function 10:
#State of the program right berfore the function call: a is a list of positive integers representing the password, b is an integer representing the number of test cases, where 1 ≤ b ≤ 100 and the sum of the lengths of lists in a does not exceed 200,000.
def func_10(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a
            res %= MOD
            b -= 1
        else:
            a = a * a
            a %= MOD
            b >>= 1
        
    #State of the program after the loop has been executed: `b` is 0, `res` is the product of the elements of the original list `a` raised to the power of the initial value of `b`, taken modulo `MOD`, and `a` is the final value of the list after all squaring operations and modulo `MOD`.
    res %= MOD
    return res
    #The program returns the product of the elements of the original list `a` raised to the power of 0, taken modulo `MOD`, which is 1, since any number raised to the power of 0 is 1.

#Function 11:
#State of the program right berfore the function call: P is a list of tuples, where each tuple contains two elements: an integer n (1 ≤ n ≤ 2 ⋅ 10^5) representing the length of the password, and a list of n positive integers a (1 ≤ a[i] ≤ 10^9) representing the initial contents of the password. The length of all password contents across all test cases does not exceed 2 ⋅ 10^5.
def func_11(P):
    ans = (-1 + sqrt(1 + 8 * P)) // 2
    return ans
    #The program returns 'ans', which is not calculable without a specific integer value for the list of tuples 'P' containing an integer n and a list of positive integers a.

#Function 12:
#State of the program right berfore the function call: The input consists of multiple test cases, with the first line containing an integer t (1 ≤ t ≤ 100). Each test case has a line with an integer n (1 ≤ n ≤ 2 ⋅ 10^5), followed by a line with n positive integers a_{1}, a_{2}, ..., a_{n} (1 ≤ a_{i} ≤ 10^9). The sum of n over all test cases does not exceed 2 ⋅ 10^5.
def func_12():
    T = int(func_6())
    while T:
        n = int(func_6())
        
        Arr = func_5()
        
        p = Arr[0]
        
        flag = 0
        
        for i in Arr[1:]:
            if i != p:
                flag = 1
                break
        
        if flag == 1:
            print(1)
        else:
            print(n)
        
        T -= 1
        
    #State of the program after the loop has been executed: `T` is 0, `n` is the value assigned from the last call to `int(func_6())`, `Arr` contains at least 2 elements from the last call to `func_5()`, `p` is the value of `Arr[0]`, `i` is the last element of `Arr[1:]`, and if `flag` is 1, 1 is printed in the last iteration; otherwise, the last value of `n` is printed if `flag` is 0.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
