
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You're given a tree with n vertices.

Your task is to determine the maximum possible number of edges that can be removed in such a way that all the remaining connected components will have even size.

Input

The first line contains an integer n (1 ≤ n ≤ 10^5) denoting the size of the tree. 

The next n - 1 lines contain two integers u, v (1 ≤ u, v ≤ n) each, describing the vertices connected by the i-th edge.

It's guaranteed that the given edges form a tree.

Output

Output a single integer k — the maximum number of edges that can be removed to leave all connected components with even size, or -1 if it is impossible to remove edges in order to satisfy this property.

Examples

Input

4
2 4
4 1
3 1


Output

1

Input

3
1 2
1 3


Output

-1

Input

10
7 1
8 4
8 10
4 7
6 5
9 3
3 5
2 10
2 5


Output

4

Input

2
1 2


Output

0

Note

In the first example you can remove the edge between vertices 1 and 4. The graph after that will have two connected components with two vertices in each.

In the second example you can't remove edges in such a way that all components have even number of vertices, so the answer is -1.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: a is an integer representing the number of vertices in the tree (1 ≤ a ≤ 100000), and b is a list of tuples where each tuple contains two integers (u, v) representing the edges between vertices (1 ≤ u, v ≤ a) such that the length of b is a - 1.
def func_1(a, b):
    Q = deque()
    Q.append(a)
    seen = {b}
    cnt = 0
    while Q:
        a = Q.popleft()
        
        if a in seen:
            continue
        
        cnt += 1
        
        seen.add(a)
        
        for b in E[a]:
            Q.append(b)
        
    #State of the program after the loop has been executed: `Q` is empty, `seen` contains all vertices that were reachable from the initial vertices in `Q`, `cnt` is equal to the number of unique vertices that were traversed, `a` is the last vertex processed from `Q`, and `b` represents the last edges processed from `E[a]`.
    return cnt
    #The program returns the count of unique vertices that were traversed, represented by 'cnt'

#Function 2:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), and the input consists of n - 1 pairs of integers (u, v) where 1 ≤ u, v ≤ n, representing the edges of a tree.
def func_2(node):
    print(node)
    if (node in seen) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: *`n` is a positive integer (1 ≤ n ≤ 10^5), and the input consists of n - 1 pairs of integers (u, v) where 1 ≤ u, v ≤ n; `node` is printed and `node` is not in `seen`.
    seen.add(node)
    sz[node] = 1
    for neigh in E[node]:
        print(neigh)
        
        sz[node] += func_2(neigh)
        
    #State of the program after the  for loop has been executed: `n` is a positive integer (1 ≤ n ≤ 10^5), `node` is printed, `node` has been added to `seen`, `sz[node]` is equal to 1 plus the sum of the return values of `func_2` for all neighbors in `E[node]`, and `E[node]` contains all the neighbors of `node`.
    return sz[node]
    #The program returns the size of the node which is 1 plus the sum of the return values of func_2 for all its neighbors in E[node]


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
