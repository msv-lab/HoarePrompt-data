
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Lord Omkar has permitted you to enter the Holy Church of Omkar! To test your worthiness, Omkar gives you a password which you must interpret!

A password is an array a of n positive integers. You apply the following operation to the array: pick any two adjacent numbers that are not equal to each other and replace them with their sum. Formally, choose an index i such that 1 ≤ i < n and a_{i} ≠ a_{i+1}, delete both a_i and a_{i+1} from the array and put a_{i}+a_{i+1} in their place. 

For example, for array [7, 4, 3, 7] you can choose i = 2 and the array will become [7, 4+3, 7] = [7, 7, 7]. Note that in this array you can't apply this operation anymore.

Notice that one operation will decrease the size of the password by 1. What is the shortest possible length of the password after some number (possibly 0) of operations?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the password.

The second line of each test case contains n integers a_{1},a_{2},...,a_{n} (1 ≤ a_{i} ≤ 10^9) — the initial contents of your password.

The sum of n over all test cases will not exceed 2 ⋅ 10^5.

Output

For each password, print one integer: the shortest possible length of the password after some number of operations.

Example

Input


2
4
2 1 3 1
2
420 420


Output


1
2

Note

In the first test case, you can do the following to achieve a length of 1:

Pick i=2 to get [2, 4, 1]

Pick i=1 to get [6, 1]

Pick i=1 to get [7]

In the second test case, you can't perform any operations because there is no valid i that satisfies the requirements mentioned above.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: The input consists of multiple test cases, where each test case has an integer n (1 ≤ n ≤ 200,000) representing the length of the password, followed by an array of n positive integers (1 ≤ a_i ≤ 10^9). The total number of integers across all test cases does not exceed 200,000.
def func_1():
    fact = [1]
    for i in range(1, 100005):
        fact.append(fact[-1] * i % mod)
        
    #State of the program after the  for loop has been executed: `fact` is a list containing the factorials of integers from 0 to 100004 modulo `mod`.
    ifact = [0] * 100005
    ifact[100004] = pow(fact[100004], mod - 2, mod)
    for i in range(100004, 0, -1):
        ifact[i - 1] = i * ifact[i] % mod
        
    #State of the program after the  for loop has been executed: `fact` is a list containing the factorials of integers from 0 to 100004 modulo `mod`; `ifact` now contains the modular inverses of the factorials of integers from 0 to 100004 modulo `mod`, with `ifact[0]` being 1, and `i` is 0.
    return fact, ifact
    #The program returns the list 'fact' containing the factorials of integers from 0 to 100004 modulo 'mod', and the list 'ifact' containing the modular inverses of those factorials, with 'ifact[0]' being 1.

#Function 2:
#State of the program right berfore the function call: n is a positive integer representing the length of the password, and p is a list of n positive integers.
def func_2(n, p):
    return pow(n, p - 2, p)
    #The program returns the result of pow(n, p - 2, p), where n is a positive integer representing the length of the password and p is a list of n positive integers.

#Function 3:
#State of the program right berfore the function call: n is a positive integer representing the length of the password, r is an array of n positive integers, and the sum of n over all test cases does not exceed 2 ⋅ 10^5.
def func_3(n, r, fact, ifact):
    t = fact[n] * (ifact[r] * ifact[n - r]) % mod % mod
    return t
    #The program returns the value of t, which is calculated as `fact[n] * (ifact[r] * ifact[n - r]) % mod % mod` based on the given positive integer n and the array r.

#Function 4:
#State of the program right berfore the function call: The function handles multiple test cases where t is an integer (1 ≤ t ≤ 100) representing the number of test cases. For each test case, n is an integer (1 ≤ n ≤ 2 ⋅ 10^5) representing the length of the password, and a is a list of n positive integers (1 ≤ a[i] ≤ 10^9) representing the contents of the password. The sum of all n across test cases does not exceed 2 ⋅ 10^5.
def func_4():
    return map(int, sys.stdin.readline().strip().split())
    #The program returns a map object containing the integers parsed from the input line read from standard input, which represents the contents of the password.

#Function 5:
#State of the program right berfore the function call: The function processes multiple test cases, where each test case consists of an integer n (1 ≤ n ≤ 2 ⋅ 10^5) followed by an array a of n positive integers (1 ≤ a[i] ≤ 10^9). The total length of all test cases combined does not exceed 2 ⋅ 10^5.
def func_5():
    return list(map(int, sys.stdin.readline().strip().split()))
    #The program returns a list of integers parsed from the input line, which is expected to consist of multiple integers separated by spaces, based on the array a of size n.

#Function 6:
#State of the program right berfore the function call: The input consists of multiple test cases, where each test case includes an integer n (1 ≤ n ≤ 2 ⋅ 10^5) indicating the length of the password followed by n positive integers (1 ≤ a_{i} ≤ 10^9) representing the contents of the password. The total sum of n across all test cases does not exceed 2 ⋅ 10^5.
def func_6():
    return sys.stdin.readline().strip()
    #The program returns a single line input consisting of an integer n followed by n positive integers representing the contents of the password, stripped of any leading or trailing whitespace.

#Function 7:
#State of the program right berfore the function call: x is a positive integer representing the number of test cases (1 ≤ x ≤ 100), and y is a list of tuples where each tuple contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) and a list of n positive integers (1 ≤ a_i ≤ 10^9) representing the password for each test case. The sum of n over all test cases does not exceed 2 ⋅ 10^5.
def func_7(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the last non-empty tuple from `y`, `y` is the result of `x % y` which is an empty tuple, indicating that the loop has finished executing when `y` becomes empty.
    return x
    #The program returns the last non-empty tuple 'x' from 'y', which indicates the loop has finished executing when 'y' became empty.

#Function 8:
#State of the program right berfore the function call: x is a positive integer representing the number of test cases (1 ≤ x ≤ 100), and y is a list of tuples where each tuple contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) followed by n positive integers (1 ≤ a_i ≤ 10^9) representing the elements of the password for each test case. The sum of n over all test cases does not exceed 2 ⋅ 10^5.
def func_8(x, y):
    return x * y // func_7(x, y)
    #The program returns the result of multiplying the number of test cases 'x' by the list of tuples 'y', divided by the result of func_7(x, y)

#Function 9:
#State of the program right berfore the function call: n is a positive integer representing the number of integers in the password, and the password is an array of n positive integers where each integer is in the range 1 to 10^9.
def func_9(n):
    return [n, 1, n + 1, 0][n % 4]
    #The program returns 1 if n % 4 is 1, n + 1 if n % 4 is 2, 0 if n % 4 is 3, and n if n % 4 is 0.

#Function 10:
#State of the program right berfore the function call: a is a list of positive integers representing the password, and b is a positive integer representing the number of elements in the list a, with 1 ≤ b ≤ 2 * 10^5.
def func_10(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a
            res %= MOD
            b -= 1
        else:
            a = a * a
            a %= MOD
            b >>= 1
        
    #State of the program after the loop has been executed: `b` is 0, `res` is the result of multiplying elements of the original list `a` raised to the power of the original `b` modulo `MOD`, and `a` is a list representing the final transformation of the original list after the necessary squaring operations and modulo `MOD`.
    res %= MOD
    return res
    #The program returns the result of multiplying elements of the original list 'a' raised to the power of 'b' which is 0, and since any number raised to the power of 0 is 1, 'res' is updated to 1 modulo 'MOD'

#Function 11:
#State of the program right berfore the function call: P is a list of tuples, each containing an integer n (1 ≤ n ≤ 2 ⋅ 10^5) followed by a list of n positive integers (1 ≤ a_i ≤ 10^9) representing the password for each test case. The first element of each tuple represents the number of elements in the password, and the total number of elements across all test cases does not exceed 2 ⋅ 10^5.
def func_11(P):
    ans = (-1 + sqrt(1 + 8 * P)) // 2
    return ans
    #The program returns the calculated values of 'ans' using the formula for each first element of the tuples in the list 'P'

#Function 12:
#State of the program right berfore the function call: The function reads multiple test cases where each test case consists of an integer n (1 ≤ n ≤ 2 ⋅ 10^5) representing the length of the password, followed by an array a of n positive integers (1 ≤ a[i] ≤ 10^9). The total number of integers across all test cases does not exceed 2 ⋅ 10^5.
def func_12():
    T = int(func_6())
    while T:
        n = int(func_6())
        
        Arr = func_5()
        
        p = Arr[0]
        
        flag = 0
        
        for i in Arr[1:]:
            if i != p:
                flag = 1
                break
        
        if flag == 1:
            print(1)
        else:
            print(n)
        
        T -= 1
        
    #State of the program after the loop has been executed: `T` is 0, `n` is the last value assigned from `func_6()`, `Arr` is the last list returned by `func_5()`, `p` is the first element of the last `Arr`, and `flag` is either 0 or 1 depending on the last comparison within the loop.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
