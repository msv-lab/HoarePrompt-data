
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You're given a tree with n vertices.

Your task is to determine the maximum possible number of edges that can be removed in such a way that all the remaining connected components will have even size.

Input

The first line contains an integer n (1 ≤ n ≤ 10^5) denoting the size of the tree. 

The next n - 1 lines contain two integers u, v (1 ≤ u, v ≤ n) each, describing the vertices connected by the i-th edge.

It's guaranteed that the given edges form a tree.

Output

Output a single integer k — the maximum number of edges that can be removed to leave all connected components with even size, or -1 if it is impossible to remove edges in order to satisfy this property.

Examples

Input

4
2 4
4 1
3 1


Output

1

Input

3
1 2
1 3


Output

-1

Input

10
7 1
8 4
8 10
4 7
6 5
9 3
3 5
2 10
2 5


Output

4

Input

2
1 2


Output

0

Note

In the first example you can remove the edge between vertices 1 and 4. The graph after that will have two connected components with two vertices in each.

In the second example you can't remove edges in such a way that all components have even number of vertices, so the answer is -1.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: a is an integer n (1 ≤ n ≤ 10^5) representing the number of vertices in a tree, and b is a list of n-1 tuples (u, v) where each tuple represents an edge between vertices u and v (1 ≤ u, v ≤ n).
def func_1(a, b):
    Q = deque()
    Q.append(a)
    seen = {b}
    cnt = 0
    while Q:
        a = Q.popleft()
        
        if a in seen:
            continue
        
        cnt += 1
        
        seen.add(a)
        
        for b in E[a]:
            Q.append(b)
        
    #State of the program after the loop has been executed: `Q` is empty, `cnt` is the total number of unique elements encountered from the initial `Q`, `seen` includes all unique elements processed, and `a` is the last element removed from `Q` before it became empty.
    return cnt
    #The program returns the total number of unique elements encountered from the initial empty queue `Q`

#Function 2:
#State of the program right berfore the function call: n is an integer representing the number of vertices in the tree (1 ≤ n ≤ 100000), and the edges are provided as pairs of integers (u, v) representing connections between vertices (1 ≤ u, v ≤ n), with exactly n - 1 pairs indicating a valid tree structure.
def func_2(node):
    print(node)
    if (node in seen) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: *`n` is an integer representing the number of vertices in the tree (1 ≤ n ≤ 100000), the variable `node` is printed and its value is not in the `seen` set.
    seen.add(node)
    sz[node] = 1
    for neigh in E[node]:
        print(neigh)
        
        sz[node] += func_2(neigh)
        
    #State of the program after the  for loop has been executed: `n` is an integer representing the number of vertices in the tree; `node` is printed and its value is not in the `seen` set; `sz[node]` is increased by the cumulative return value of `func_2(neigh)` for all neighbors in `E[node]`; `E[node]` contains all neighbors of `node`; `neigh` is the last neighbor printed.
    return sz[node]
    #The program returns the size 'sz[node]' which has been increased by the cumulative return value of 'func_2(neigh)' for all neighbors in 'E[node]'


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
