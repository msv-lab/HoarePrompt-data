
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Ujan has a lot of useless stuff in his drawers, a considerable part of which are his math notebooks: it is time to sort them out. This time he found an old dusty graph theory notebook with a description of a graph.

It is an undirected weighted graph on n vertices. It is a complete graph: each pair of vertices is connected by an edge. The weight of each edge is either 0 or 1; exactly m edges have weight 1, and all others have weight 0.

Since Ujan doesn't really want to organize his notes, he decided to find the weight of the minimum spanning tree of the graph. (The weight of a spanning tree is the sum of all its edges.) Can you find the answer for Ujan so he stops procrastinating?

Input

The first line of the input contains two integers n and m (1 ≤ n ≤ 10^5, 0 ≤ m ≤ min((n(n-1))/(2),10^5)), the number of vertices and the number of edges of weight 1 in the graph. 

The i-th of the next m lines contains two integers a_i and b_i (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i), the endpoints of the i-th edge of weight 1.

It is guaranteed that no edge appears twice in the input.

Output

Output a single integer, the weight of the minimum spanning tree of the graph.

Examples

Input


6 11
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6


Output


2


Input


3 0


Output


0

Note

The graph from the first sample is shown below. Dashed edges have weight 0, other edges have weight 1. One of the minimum spanning trees is highlighted in orange and has total weight 2.

<image>

In the second sample, all edges have weight 0 so any spanning tree has total weight 0.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n is an integer representing the number of vertices in the graph, where 1 ≤ n ≤ 100,000, and m is an integer representing the number of edges with weight 1, where 0 ≤ m ≤ min((n(n-1))/2, 100,000). For each of the next m lines, a_i and b_i are integers representing the endpoints of the edges with weight 1, where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_1():
    n, m = func_4()
    p = list(range(n))
    r = func_7(int, n)
    sg = func_7(set, n)
    for _ in range(m):
        x, y = func_5(-1)
        
        sg[x].add(y)
        
        sg[y].add(x)
        
    #State of the program after the  for loop has been executed: `n` is an integer representing the number of vertices in the graph; `m` is the number of edges added; `sg` is a list of sets where each set `sg[i]` contains the vertices connected to vertex `i`; `sg` contains edges as defined by the pairs (x, y) returned from `func_5(-1)` for all iterations of the loop.
    v = min(range(n), key=lambda i: len(sg[i]))
    for i in range(n):
        if i not in sg[v]:
            union(i, v)
        else:
            for j in range(n):
                if j not in sg[i]:
                    union(i, j)
        
    #State of the program after the  for loop has been executed: `n` is an integer representing the number of vertices, `m` is the number of edges added, `sg` is a list of sets representing the connections after unions, `v` is the index of the vertex with the minimum connections in `sg`.
    roots = set()
    for i in range(n):
        roots.add(find(i))
        
    #State of the program after the  for loop has been executed: `n` is an integer representing the number of vertices, `roots` is a set containing the unique roots from `find(i)` for all `i` in range `n`, `m` is unchanged, `sg` is unchanged, and `v` is unchanged.
    print(len(roots) - 1)

#Function 2:
#State of the program right berfore the function call: v is a tuple containing two integers n and m, where n is the number of vertices (1 ≤ n ≤ 10^5) and m is the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/(2),10^5)). Additionally, there are m pairs of integers (a_i, b_i) representing the endpoints of the edges with weight 1, where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def find(v):
    vc = v
    while v != p[v]:
        v = p[v]
        
    #State of the program after the loop has been executed: `v` is equal to `p[v]`, indicating that the final value of `v` is a stable state defined by the mapping of `p`.
    while vc != v:
        p[vc], vc = v, p[vc]
        
    #State of the program after the loop has been executed: `v` is equal to the stable value defined by the mapping `p`, `vc` is also equal to `v`.
    return v
    #The program returns the stable value defined by the mapping `p`, which is equal to `v`.

#Function 3:
#State of the program right berfore the function call: n is a positive integer representing the number of vertices in the graph (1 ≤ n ≤ 10^5), m is a non-negative integer representing the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/(2),10^5)), and for each of the m edges, a_i and b_i are integers (1 ≤ a_i, b_i ≤ n) representing the endpoints of the edges, with a_i ≠ b_i.
def union(u, v):
    u, v = find(u), find(v)
    if (u == v) :
        return
        #The program returns None because there is no value specified to return.
    #State of the program after the if block has been executed: *`u` and `v` are assigned the values returned by the `find` function when called with their current values. `u` is not equal to `v`. Other variables remain unaffected.
    if (r[u] < r[v]) :
        u, v = v, u
    #State of the program after the if block has been executed: *`u` and `v` are assigned the values returned by the `find` function when called with their current values, and `u` is not equal to `v`. If the value of `r[u]` is less than the value of `r[v]`, then the values of `u` and `v` are swapped. Otherwise, the values of `u` and `v` remain unchanged.
    p[u] = v
    if (r[u] == r[v]) :
        r[u] += 1
    #State of the program after the if block has been executed: *`u` and `v` are assigned the values returned by the `find` function when called with their current values, `u` is not equal to `v`, and `p[u]` is assigned the value of `v`. If the values at index `u` and `v` in array `r` are equal, then `r[u]` is incremented by 1.

#Function 4:
#State of the program right berfore the function call: x is a tuple containing two integers n and m, where n (1 ≤ n ≤ 10^5) is the number of vertices and m (0 ≤ m ≤ min((n(n-1))/(2),10^5)) is the number of edges of weight 1 in the graph. Additionally, the next m lines contain pairs of integers (a_i, b_i) representing the endpoints of the edges of weight 1, where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_2(x):
    return pow(x, MOD - 2, MOD)
    #The program returns the result of raising the tuple x to the power of (MOD - 2) modulo MOD

#Function 5:
#State of the program right berfore the function call: x is an integer representing the number of vertices (1 ≤ x ≤ 10^5), and y is an integer representing the number of edges with weight 1 (0 ≤ y ≤ min((x(x-1))/(2), 10^5)).
def func_3(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the greatest common divisor of the initial values of `x` and `y`.
    return x
    #The program returns the greatest common divisor of the initial values of `x` and `y`, which is `x` since `y` is 0.

#Function 6:
#State of the program right berfore the function call: n is an integer representing the number of vertices in a graph, where 1 ≤ n ≤ 10^5; m is an integer representing the number of edges with weight 1, where 0 ≤ m ≤ min((n(n-1))/(2),10^5); for each edge, a_i and b_i are integers representing the endpoints of the edge, where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_4():
    return list(map(int, input().split()))
    #The program returns a list of integers obtained from the input, which represents the values entered by the user.

#Function 7:
#State of the program right berfore the function call: o is a tuple containing two integers n and m, where n is the number of vertices (1 ≤ n ≤ 10^5) and m is the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/(2), 10^5)). Following this, there are m pairs of integers (a_i, b_i) representing the endpoints of each edge with weight 1, ensuring that 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i, with no duplicate edges.
def func_5(o):
    return list(map(lambda x: int(x) + o, input().split()))
    #The program returns a list of integers, where each integer is the sum of the corresponding input integer and the tuple 'o' containing two integers n and m.

#Function 8:
#State of the program right berfore the function call: n is an integer representing the number of vertices in the graph (1 ≤ n ≤ 100,000), m is an integer representing the number of edges with weight 1 (0 ≤ m ≤ min((n(n-1))/2, 100,000)), and m edges are defined by pairs of integers (a_i, b_i) where 1 ≤ a_i, b_i ≤ n and a_i ≠ b_i.
def func_6(n, m):
    return [func_4() for _ in range(n)]
    #The program returns a list of n elements, each being the result of calling func_4()

#Function 9:
#State of the program right berfore the function call: f is a 2D list representing the vertices of a complete undirected weighted graph, where each edge has a weight of either 0 or 1; dim is a tuple containing two integers n and m, where n (1 ≤ n ≤ 10^5) is the number of vertices and m (0 ≤ m ≤ min((n(n-1))/(2),10^5)) is the number of edges with weight 1, and for each edge, the endpoints a_i and b_i (1 ≤ a_i, b_i ≤ n, a_i ≠ b_i) are provided.
def func_7(f):
    return [func_7(f, *dim[1:]) for _ in range(dim[0])] if dim else f()
    #The program returns a list containing the result of func_7 applied to the second element of dim for each vertex in the complete undirected weighted graph represented by f, repeated dim[0] times, if dim is not empty; otherwise, it returns f()

#Function 10:
#State of the program right berfore the function call: start is an integer representing the number of vertices in the graph (1 ≤ start ≤ 10^5), step is an integer representing the number of edges of weight 1 (0 ≤ step ≤ min((start(start-1))/(2),10^5)), and count is a list of tuples where each tuple contains two integers (a_i, b_i) representing the endpoints of edges with weight 1 (1 ≤ a_i, b_i ≤ start, a_i ≠ b_i).
def func_8(start, step, count):
    return range(start, start + step * count, step)
    #The program returns a range starting from `start` to `start + step * len_count` with a step of `step`, where `len_count` is the number of tuples in the list `count`.

#Function 11:
#State of the program right berfore the function call: l is a list of pairs of integers representing edges with weight 1 in a complete undirected graph, start and end are integers that represent the range of vertices (1 ≤ start, end ≤ n) where n is the number of vertices in the graph and m is the number of edges in the graph such that 1 ≤ n ≤ 10^5 and 0 ≤ m ≤ min((n(n-1))/(2),10^5).
def func_9(l, start, end):
    return range(start, len(l) + end)
    #The program returns a range object from 'start' to 'len(l) + end', where 'len(l)' is the number of edges in the list 'l' representing pairs of integers.

#Function 12:
#State of the program right berfore the function call: n is a positive integer representing the number of vertices in the graph, and m is a non-negative integer representing the number of edges with weight 1 such that 0 ≤ m ≤ min((n(n-1))/2, 10^5). Each of the next m lines contains two distinct integers a_i and b_i (1 ≤ a_i, b_i ≤ n) representing the endpoints of an edge with weight 1.
def func_10(n):
    """ [0, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, ...] """
    return 2 ** (n - 1).bit_length()
    #The program returns the number of bits required to represent 2 raised to the power of (n - 1), which is equivalent to n - 1 + 1, hence the return value is n.

#Function 13:
#State of the program right berfore the function call: x is an integer representing the number of vertices in the graph (1 ≤ x ≤ 10^5), and r is a non-negative integer representing the number of edges of weight 1 (0 ≤ r ≤ min((x(x-1))/(2), 10^5)).
def func_11(x, r):
    """ = ceil(x / r) """
    return (x + r - 1) // r
    #The program returns the integer result of the expression (x + r - 1) // r, where x is the number of vertices in the graph and r is the number of edges of weight 1


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
