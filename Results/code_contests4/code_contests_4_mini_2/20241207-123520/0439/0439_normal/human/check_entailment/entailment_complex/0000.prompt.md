
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: A monopole magnet is a magnet that only has one pole, either north or south. They don't actually exist since real magnets have two poles, but this is a programming contest problem, so we don't care.

There is an n× m grid. Initially, you may place some north magnets and some south magnets into the cells. You are allowed to place as many magnets as you like, even multiple in the same cell.

An operation is performed as follows. Choose a north magnet and a south magnet to activate. If they are in the same row or the same column and they occupy different cells, then the north magnet moves one unit closer to the south magnet. Otherwise, if they occupy the same cell or do not share a row or column, then nothing changes. Note that the south magnets are immovable.

Each cell of the grid is colored black or white. Let's consider ways to place magnets in the cells so that the following conditions are met.

  1. There is at least one south magnet in every row and every column. 
  2. If a cell is colored black, then it is possible for a north magnet to occupy this cell after some sequence of operations from the initial placement. 
  3. If a cell is colored white, then it is impossible for a north magnet to occupy this cell after some sequence of operations from the initial placement. 



Determine if it is possible to place magnets such that these conditions are met. If it is possible, find the minimum number of north magnets required (there are no requirements on the number of south magnets).

Input

The first line contains two integers n and m (1≤ n,m≤ 1000) — the number of rows and the number of columns, respectively.

The next n lines describe the coloring. The i-th of these lines contains a string of length m, where the j-th character denotes the color of the cell in row i and column j. The characters "#" and "." represent black and white, respectively. It is guaranteed, that the string will not contain any other characters.

Output

Output a single integer, the minimum possible number of north magnets required.

If there is no placement of magnets that satisfies all conditions, print a single integer -1.

Examples

Input


3 3
.#.
###
##.


Output


1


Input


4 2
##
.#
.#
##


Output


-1


Input


4 5
....#
####.
.###.
.#...


Output


2


Input


2 1
.
#


Output


-1


Input


3 5
.....
.....
.....


Output


0

Note

In the first test, here is an example placement of magnets:

<image>

In the second test, we can show that no required placement of magnets exists. Here are three example placements that fail to meet the requirements. The first example violates rule 3 since we can move the north magnet down onto a white square. The second example violates rule 2 since we cannot move the north magnet to the bottom-left black square by any sequence of operations. The third example violates rule 1 since there is no south magnet in the first column.

<image>

In the third test, here is an example placement of magnets. We can show that there is no required placement of magnets with fewer north magnets.

<image>

In the fourth test, we can show that no required placement of magnets exists. Here are two example placements that fail to meet the requirements. The first example violates rule 1 since there is no south magnet in the first row. The second example violates rules 1 and 3 since there is no south magnet in the second row and we can move the north magnet up one unit onto a white square.

<image>

In the fifth test, we can put the south magnet in each cell and no north magnets. Because there are no black cells, it will be a correct placement.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n, m ≤ 1000, and grid is a list of strings where each string is of length m and consists only of the characters '#' (black) and '.' (white).
def func_1(n, m, grid):
    components, visited = 0, [([False] * m) for _ in range(n)]
    for i in range(n):
        for j in range(m):
            if not visited[i][j] and grid[i][j] == '#':
                components += dfs(i, j)
        
    #State of the program after the  for loop has been executed: `components` is equal to the total number of components found in the grid, `visited` contains the state of all cells indicating which cells have been processed, `grid` remains unchanged, `i` is equal to `n`, `j` is equal to `m`.
    return components
    #The program returns the total number of components found in the grid, denoted by 'components'
#Overall this is what the function does:The function accepts two integers `n` and `m`, and a list of strings `grid`. It counts and returns the total number of connected components in the grid where each component is represented by contiguous '#' characters (black cells), connected either horizontally or vertically. The function assumes that the grid dimensions are valid and does not handle cases where `grid` may not conform to the expected format.

#Function 2:
#State of the program right berfore the function call: n and m are positive integers where 1 ≤ n, m ≤ 1000, and the following n lines contain strings of length m consisting only of the characters '#' (representing black cells) and '.' (representing white cells).
def get_adj(i, j):
    adj = [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]
    res = []
    for (ai, aj) in adj:
        if 0 <= ai < n and 0 <= aj < m and grid[ai][aj] == '#':
            res.append((ai, aj))
        
    #State of the program after the  for loop has been executed: `n` and `m` are positive integers; `res` contains all tuples `(ai, aj)` where `0 <= ai < n`, `0 <= aj < m`, and `grid[ai][aj]` is equal to '#'.
    return res
    #The program returns all tuples (ai, aj) where 0 <= ai < n, 0 <= aj < m, and grid[ai][aj] is equal to '#'
#Overall this is what the function does:The function accepts two parameters, `i` and `j`, representing the coordinates in a grid, and returns a list of tuples containing the coordinates of all adjacent cells that are black ('#'). This includes checking the cells to the right, down, left, and up of the given coordinates, while ensuring that the indices remain within the bounds of the grid. It does not handle cases where `i` and `j` are out of bounds prior to checking the adjacent cells, as it assumes valid input based on the surrounding context.

#Function 3:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n, m ≤ 1000, and the coloring of the grid is represented as a list of n strings, each of length m, consisting only of characters '#' (black) and '.' (white).
def dfs(i, j):
    component, stack = 1, [(i, j)]
    while stack:
        si, sj = stack[-1]
        
        if visited[si][sj]:
            stack.pop()
            continue
        else:
            visited[si][sj] = True
            component = 1
            for ai, aj in get_adj(si, sj):
                if not visited[ai][aj]:
                    stack.append((ai, aj))
        
    #State of the program after the loop has been executed: `stack` is empty, `component` remains 1, and all coordinates in `visited` corresponding to the initial coordinates in `stack` have been marked as True.
    return component
    #The program returns the value of component, which is 1
#Overall this is what the function does:The function `dfs` accepts two integer parameters `i` and `j`, which represent coordinates in a grid (where `1 ≤ n, m ≤ 1000`). It is intended to perform a depth-first search (DFS) starting from the position `(i, j)`. However, the function does not correctly calculate the size of the connected component, as it always returns 1 regardless of the actual number of connected cells. Therefore, the functionality of the function is to always return 1, indicating that at least one cell (the starting cell) has been visited, but it does not reflect the actual size of the connected component.

#Function 4:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n, m ≤ 1000, representing the number of rows and columns in a grid, respectively. Additionally, there are n strings of length m consisting solely of characters '#' and '.', where '#' represents a black cell and '.' represents a white cell.
def func_2():
    n, m = map(int, input().split())
    grid = [input() for _ in range(n)]
    if (grid == [('.' * m) for _ in range(n)]) :
        func_3(0)
        return
        #The program returns None, as there is no value specified for return.
    #State of the program after the if block has been executed: *`n` and `m` are integers derived from input, and `grid` is a list containing `n` input strings representing rows in the grid. The `grid` is not equal to a list consisting of `n` rows of `m` dots ('.').
    for row in grid:
        start, stop = row.find('#'), row.rfind('#')
        
        if start == -1 or '.' in row[start:stop + 1]:
            func_3(-1)
            return
        
    #State of the program after the  for loop has been executed: `start` is the index of the first '#' in the last row of `grid`, `stop` is the index of the last '#' in the last row of `grid`. If any row contains no '#' or contains '.' between the first and last occurrences of '#', the program will return None. Otherwise, the program completes without returning any value, indicating all rows are valid according to the specified conditions.
    grit = transpose(grid)
    for row in grit:
        start, stop = row.find('#'), row.rfind('#')
        
        if start == -1 or '.' in row[start:stop + 1]:
            func_3(-1)
            return
        
    #State of the program after the  for loop has been executed: `start` is the index of the first '#' in the last row of `grit`, `stop` is the index of the last '#' in the last row of `grit`, and all rows in `grit` have been processed without finding a row where `start` is -1 or where there is a '.' in the substring `row[start:stop + 1]`.
    func_3(func_1(n, m, grid))
#Overall this is what the function does:The function accepts two integers, `n` and `m`, which represent the dimensions of a grid consisting of `n` strings of length `m`. It checks if the grid is entirely composed of '.' (white cells), in which case it calls `func_3(0)` and returns None. It then validates each row to ensure that if a '#' (black cell) exists, there are no '.' (white cells) between the first and last '#' in that row. If any row fails this check, it calls `func_3(-1)` and returns None. The function also transposes the grid and performs the same validation on the columns. If all rows and columns are valid, it calls `func_3` with the result of `func_1(n, m, grid)`. The function ultimately returns None in all scenarios as no explicit return value is defined.

#Function 5:
#State of the program right berfore the function call: n and m are integers such that 1 ≤ n, m ≤ 1000, and the next n lines contain strings of length m consisting of characters '#' (black) and '.' (white).
def func_3():
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `n` is an integer such that 1 ≤ `n` ≤ 1000, `m` is an integer such that 1 ≤ `m` ≤ 1000, `sep` is either a value from `kwargs` or ' ', `file` has written the string representations of all elements in `args` separated by `sep`, `at_start` is False, and `args` is a non-empty iterable.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`n` is an integer such that 1 ≤ `n` ≤ 1000, `m` is an integer such that 1 ≤ `m` ≤ 1000, `sep` is either a value from `kwargs` or ' ', `file` has written the string representations of all elements in `args` separated by `sep`, `at_start` is False, `args` is a non-empty iterable, and `file` has written the value of `kwargs.pop('end', '\n')`. If `kwargs.pop('flush', False)` is True, then the buffer of `file` is flushed. Otherwise, the buffer of `file` remains unchanged.
#Overall this is what the function does:The function accepts variable-length arguments and keyword arguments, writing the string representations of the arguments to a specified output file, separated by a specified separator. It handles the 'end' parameter to determine what to write at the end of the output and can flush the output buffer if requested. However, the function does not directly accept parameters for `n` and `m` nor processes n strings of length m as indicated in the comments; rather, it writes whatever is passed to it in `args`. There may also be an assumption of the existence of `kwargs`, which are not shown to be defined in the function, leading to potential issues if not properly handled.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.