
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Given are N positive integers A_1,...,A_N.

Consider positive integers B_1, ..., B_N that satisfy the following condition.

Condition: For any i, j such that 1 \leq i < j \leq N, A_i B_i = A_j B_j holds.

Find the minimum possible value of B_1 + ... + B_N for such B_1,...,B_N.

Since the answer can be enormous, print the sum modulo (10^9 +7).

Constraints

* 1 \leq N \leq 10^4
* 1 \leq A_i \leq 10^6
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


N
A_1 ... A_N


Output

Print the minimum possible value of B_1 + ... + B_N for B_1,...,B_N that satisfy the condition, modulo (10^9 +7).

Examples

Input

3
2 3 4


Output

13


Input

5
12 12 12 12 12


Output

5


Input

3
1000000 999999 999998


Output

996989508
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: a is a positive integer N (1 <= N <= 10^4), and b is a list of N positive integers A_i (1 <= A_i <= 10^6).
def func_1(a, b):
    c = a + b
    if (c >= mod) :
        c -= mod
    #State of the program after the if block has been executed: *`a` is a positive integer, `b` is a list of N positive integers, and `c` is the result of the expression `a + b` which raises a TypeError due to incompatible types. If `c` is greater than or equal to `mod`, then `c` is reduced by `mod`.
    return c
    #The program raises a TypeError due to incompatible types when attempting to calculate c as a result of adding a positive integer a and a list of N positive integers b. Therefore, c is not defined and cannot be returned.

#Function 2:
#State of the program right berfore the function call: a is a positive integer representing the number of elements, and b is a list of positive integers of length a, where 1 <= a <= 10000 and 1 <= b[i] <= 1000000 for all valid i.
def func_2(a, b):
    return a * b % mod
    #The program returns the product of the positive integer 'a' and the sum of the elements in the list 'b', taken modulo 'mod'.

#Function 3:
#State of the program right berfore the function call: a is an integer N (1 <= N <= 10^4) representing the number of positive integers, and b is a list of N positive integers A_i (1 <= A_i <= 10^6).
def func_3(a, b):
    if (b == 0) :
        return 1
        #The program returns 1, which is a constant integer value, regardless of the values of 'a' and 'b'.
    else :
        if (b % 2 == 1) :
            return func_2(a, func_3(a, b - 1))
            #The program returns the result of calling func_2 with the integer 'a' and the result of calling func_3 with 'a' and the last element of list 'b' reduced by 1.
        else :
            temp = func_3(a, b / 2)
            return func_2(temp, temp)
            #The program returns the result of func_2 called with temp as both arguments, where temp is the result of func_3 called with integer N and the list of even integers A_i divided by 2.

#Function 4:
#State of the program right berfore the function call: a is a list of N positive integers A_1, ..., A_N where 1 <= N <= 10^4 and 1 <= A_i <= 10^6 for all i.
def func_4(a):
    return func_3(a, mod - 2)
    #The program returns the result of calling func_3 with the list 'a' of N positive integers and the value 'mod - 2'

#Function 5:
#State of the program right berfore the function call: a is a list of N positive integers where 1 <= N <= 10^4 and 1 <= A[i] <= 10^6 for each element A[i] in the list, and m is a constant equal to 10^9 + 7.
def func_5(a, m):
    m0 = m
    y = 0
    x = 1
    if (m == 1) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: *`a` is a list of N positive integers; `m` is 10^9 + 7; `m0` is 10^9 + 7; `y` is 0; `x` is 1; and `m` is not equal to 1.
    while a > 1:
        q = a // m
        
        t = m
        
        m = a % m
        
        a = t
        
        t = y
        
        y = x - q * y
        
        x = t
        
    #State of the program after the loop has been executed: `a` is the final value of `y`, `m` is 0, `y` is the last computed value before the division by zero error, and `x` holds the value of the last `t`.
    if (x < 0) :
        x = x + m0
    #State of the program after the if block has been executed: *`a` is the final value of `y`, `m` is 0, `y` is the last computed value before the division by zero error, and if `x` is less than 0, `x` is updated to a value less than 0 since `m0` is not defined or assigned a value.
    return x
    #The program returns the updated value of x, which is less than 0

#Function 6:
#State of the program right berfore the function call: N is a positive integer such that 1 <= N <= 10^4, and A is a list of N positive integers where each A_i satisfies 1 <= A_i <= 10^6.
def func_6():
    n = int(raw_input())
    arr = [int(x) for x in raw_input().split()]
    answer = {}
    for i in range(n):
        cnt = {}
        
        x = arr[i]
        
        i = 2
        
        while i * i <= x:
            while x % i == 0:
                x /= i
                cnt[i] = cnt.get(i, 0) + 1
            i += 1
        
        if x != 1:
            cnt[x] = cnt.get(x, 0) + 1
        
        for key in cnt:
            answer[key] = max(answer.get(key, 0), cnt[key])
        
    #State of the program after the  for loop has been executed: `answer` contains the maximum counts of prime factors for all integers in `arr`, `cnt` is an empty dictionary.
    lcm = 1
    for prime in answer:
        for _ in range(answer[prime]):
            lcm = func_2(lcm, prime)
        
    #State of the program after the  for loop has been executed: `cnt` is an empty dictionary, `lcm` is the result of func_2 applied `answer[prime]` times for each prime in `answer`, `answer` contains keys corresponding to prime factors with their respective maximum counts.
    ans = 0
    for x in arr:
        ans = func_1(ans, func_2(lcm, func_4(x)))
        
    #State of the program after the  for loop has been executed: `cnt` is an empty dictionary, `lcm` is the result of func_2 applied `answer[prime]` times for each prime in `answer`, `answer` contains keys corresponding to prime factors with their respective maximum counts, `ans` is the result of func_1 applied to the initial value of `ans` and the results of func_2 applied to `lcm` for each element in `arr`, `arr` is a non-empty array, and `x` is the last element in `arr`.
    ans = int(ans)
    print(ans)


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
