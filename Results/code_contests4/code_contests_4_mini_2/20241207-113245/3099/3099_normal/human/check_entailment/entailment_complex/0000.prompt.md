
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Given are N positive integers A_1,...,A_N.

Consider positive integers B_1, ..., B_N that satisfy the following condition.

Condition: For any i, j such that 1 \leq i < j \leq N, A_i B_i = A_j B_j holds.

Find the minimum possible value of B_1 + ... + B_N for such B_1,...,B_N.

Since the answer can be enormous, print the sum modulo (10^9 +7).

Constraints

* 1 \leq N \leq 10^4
* 1 \leq A_i \leq 10^6
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


N
A_1 ... A_N


Output

Print the minimum possible value of B_1 + ... + B_N for B_1,...,B_N that satisfy the condition, modulo (10^9 +7).

Examples

Input

3
2 3 4


Output

13


Input

5
12 12 12 12 12


Output

5


Input

3
1000000 999999 999998


Output

996989508
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: a is a positive integer N (1 <= N <= 10^4), and b is a list of N positive integers A_i (1 <= A_i <= 10^6).
def func_1(a, b):
    c = a + b
    if (c >= mod) :
        c -= mod
    #State of the program after the if block has been executed: *`a` is a positive integer, `b` is a list of N positive integers, and `c` is the result of the expression `a + b` which raises a TypeError due to incompatible types. If `c` is greater than or equal to `mod`, then `c` is reduced by `mod`.
    return c
    #The program raises a TypeError due to incompatible types when attempting to calculate c as a result of adding a positive integer a and a list of N positive integers b. Therefore, c is not defined and cannot be returned.
#Overall this is what the function does:The function accepts a positive integer `a` and a list of positive integers `b`. However, it attempts to perform an addition operation between a positive integer and a list, which raises a TypeError due to incompatible types. As a result, the function does not return a value and fails to execute successfully.

#Function 2:
#State of the program right berfore the function call: a is a positive integer representing the number of elements, and b is a list of positive integers of length a, where 1 <= a <= 10000 and 1 <= b[i] <= 1000000 for all valid i.
def func_2(a, b):
    return a * b % mod
    #The program returns the product of the positive integer 'a' and the sum of the elements in the list 'b', taken modulo 'mod'.
#Overall this is what the function does:The function accepts a positive integer `a` and a list `b` of positive integers. It returns the product of `a` and the sum of the elements in `b`, taken modulo `mod`. Note that the variable `mod` is not defined within the function, which could lead to a NameError if it is not defined in the surrounding scope. Additionally, if `b` is an empty list, the sum will be 0, resulting in a return value of 0.

#Function 3:
#State of the program right berfore the function call: a is an integer N (1 <= N <= 10^4) representing the number of positive integers, and b is a list of N positive integers A_i (1 <= A_i <= 10^6).
def func_3(a, b):
    if (b == 0) :
        return 1
        #The program returns 1, which is a constant integer value, regardless of the values of 'a' and 'b'.
    else :
        if (b % 2 == 1) :
            return func_2(a, func_3(a, b - 1))
            #The program returns the result of calling func_2 with the integer 'a' and the result of calling func_3 with 'a' and the last element of list 'b' reduced by 1.
        else :
            temp = func_3(a, b / 2)
            return func_2(temp, temp)
            #The program returns the result of func_2 called with temp as both arguments, where temp is the result of func_3 called with integer N and the list of even integers A_i divided by 2.
#Overall this is what the function does:The function accepts an integer `a` and a list `b`. It returns 1 if `b` is 0, or it recursively calls `func_3` and `func_2` based on whether the last element of `b` is odd or even. For odd values, it returns the result of `func_2` called with `a` and the result of `func_3` called with `a` and the last element of `b` decremented by 1. For even values, it computes `temp` as the result of `func_3` with `a` and half of the last element of `b`, and returns `func_2` called with `temp` twice. The function does not handle cases where `b` is an empty list or contains non-positive integers, which may lead to unexpected behavior.

#Function 4:
#State of the program right berfore the function call: a is a list of N positive integers A_1, ..., A_N where 1 <= N <= 10^4 and 1 <= A_i <= 10^6 for all i.
def func_4(a):
    return func_3(a, mod - 2)
    #The program returns the result of calling func_3 with the list 'a' of N positive integers and the value 'mod - 2'
#Overall this is what the function does:The function accepts a list of N positive integers and returns the result of calling func_3 with that list and the value 'mod - 2'. There are no checks for the validity of the input list or the value of 'mod', so if 'mod' is not defined or if it leads to an unexpected result, this may cause errors in the execution of func_3.

#Function 5:
#State of the program right berfore the function call: a is a list of N positive integers where 1 <= N <= 10^4 and 1 <= A[i] <= 10^6 for each element A[i] in the list, and m is a constant equal to 10^9 + 7.
def func_5(a, m):
    m0 = m
    y = 0
    x = 1
    if (m == 1) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: *`a` is a list of N positive integers; `m` is 10^9 + 7; `m0` is 10^9 + 7; `y` is 0; `x` is 1; and `m` is not equal to 1.
    while a > 1:
        q = a // m
        
        t = m
        
        m = a % m
        
        a = t
        
        t = y
        
        y = x - q * y
        
        x = t
        
    #State of the program after the loop has been executed: `a` is the final value of `y`, `m` is 0, `y` is the last computed value before the division by zero error, and `x` holds the value of the last `t`.
    if (x < 0) :
        x = x + m0
    #State of the program after the if block has been executed: *`a` is the final value of `y`, `m` is 0, `y` is the last computed value before the division by zero error, and if `x` is less than 0, `x` is updated to a value less than 0 since `m0` is not defined or assigned a value.
    return x
    #The program returns the updated value of x, which is less than 0
#Overall this is what the function does:The function accepts a list of positive integers `a` and a constant `m`. It returns 0 if `m` is 1; otherwise, it performs calculations in a loop based on the values of `a` and `m`, and returns an updated value of `x`, which could potentially be negative, depending on the loop's execution. The function may not handle cases where `a` does not decrease properly during the loop.

#Function 6:
#State of the program right berfore the function call: N is a positive integer such that 1 <= N <= 10^4, and A is a list of N positive integers where each A_i satisfies 1 <= A_i <= 10^6.
def func_6():
    n = int(raw_input())
    arr = [int(x) for x in raw_input().split()]
    answer = {}
    for i in range(n):
        cnt = {}
        
        x = arr[i]
        
        i = 2
        
        while i * i <= x:
            while x % i == 0:
                x /= i
                cnt[i] = cnt.get(i, 0) + 1
            i += 1
        
        if x != 1:
            cnt[x] = cnt.get(x, 0) + 1
        
        for key in cnt:
            answer[key] = max(answer.get(key, 0), cnt[key])
        
    #State of the program after the  for loop has been executed: `answer` contains the maximum counts of prime factors for all integers in `arr`, `cnt` is an empty dictionary.
    lcm = 1
    for prime in answer:
        for _ in range(answer[prime]):
            lcm = func_2(lcm, prime)
        
    #State of the program after the  for loop has been executed: `cnt` is an empty dictionary, `lcm` is the result of func_2 applied `answer[prime]` times for each prime in `answer`, `answer` contains keys corresponding to prime factors with their respective maximum counts.
    ans = 0
    for x in arr:
        ans = func_1(ans, func_2(lcm, func_4(x)))
        
    #State of the program after the  for loop has been executed: `cnt` is an empty dictionary, `lcm` is the result of func_2 applied `answer[prime]` times for each prime in `answer`, `answer` contains keys corresponding to prime factors with their respective maximum counts, `ans` is the result of func_1 applied to the initial value of `ans` and the results of func_2 applied to `lcm` for each element in `arr`, `arr` is a non-empty array, and `x` is the last element in `arr`.
    ans = int(ans)
    print(ans)
#Overall this is what the function does:The function processes a list of positive integers read from input and calculates a result based on the least common multiple (LCM) of the maximum counts of prime factors across the integers. It uses additional functions (func_1, func_2, func_4) to compute intermediate results, and the final output is the integer value of the calculated result printed to the console. It does not return any parameters; instead, it directly prints the result.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.