
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Attention: we lost all the test cases for this problem, so instead of solving the problem, we need you to generate test cases. We're going to give you the answer, and you need to print a test case that produces the given answer. The original problem is in the following paragraph.

People don't use cash as often as they used to. Having a credit card solves some of the hassles of cash, such as having to receive change when you can't form the exact amount of money needed to purchase an item. Typically cashiers will give you as few coins as possible in change, but they don't have to. For example, if your change is 30 cents, a cashier could give you a 5 cent piece and a 25 cent piece, or they could give you three 10 cent pieces, or ten 1 cent pieces, two 5 cent pieces, and one 10 cent piece. Altogether there are 18 different ways to make 30 cents using only 1 cent pieces, 5 cent pieces, 10 cent pieces, and 25 cent pieces. Two ways are considered different if they contain a different number of at least one type of coin. Given the denominations of the coins and an amount of change to be made, how many different ways are there to make change?

As we mentioned before, we lost all the test cases for this problem, so we're actually going to give you the number of ways, and want you to produce a test case for which the number of ways is the given number. There could be many ways to achieve this (we guarantee there's always at least one), so you can print any, as long as it meets the constraints described below.

Input

Input will consist of a single integer A (1 ≤ A ≤ 105), the desired number of ways.

Output

In the first line print integers N and M (1 ≤ N ≤ 106, 1 ≤ M ≤ 10), the amount of change to be made, and the number of denominations, respectively.

Then print M integers D1, D2, ..., DM (1 ≤ Di ≤ 106), the denominations of the coins. All denominations must be distinct: for any i ≠ j we must have Di ≠ Dj.

If there are multiple tests, print any of them. You can print denominations in atbitrary order.

Examples

Input

18


Output

30 4
1 5 10 25


Input

3


Output

20 2
5 2


Input

314


Output

183 4
6 5 2 139
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: A is a single integer such that 1 ≤ A ≤ 10^5.
def func():
    n = int(sys.stdin.readline().rstrip('\n'))
    change = 1000000
    nom = [1]
    if (n <= 10) :
        for x in range(1000001 - 1, 0, -1):
            if len(nom) == n:
                break
            
            nom.append(x)
            
        #State of the program after the  for loop has been executed: `A` is a single integer such that 1 ≤ `A` ≤ 10^5, `n` is an input integer within that range and `n` is less than or equal to 10; `nom` contains the values [1, 1000000, 999999, 999998, 999997, 999996, 999995, 999994, 999993, 999992] if `n` is 10, and if `n` is less than 10, `nom` contains the values [1, 1000000, 999999, ..., 1000000 - (n - 1)].
    else :
        if (10 < n <= 100) :
            res = n - n % 10 - 1
            res_ = change // res
            nom.append(res_)
            for x in range(1000000 - 1, 0, -1):
                if len(nom) == 10:
                    break
                
                nom.append(x)
                
            #State of the program after the  for loop has been executed: `A` is a single integer such that 1 ≤ A ≤ 10^5; `n` is an input integer (11 ≤ n ≤ 100); `change` is 1000000; `nom` is a list of integers containing 10 elements; `res` is between 10 and 99; `res_` is between 10101 and 100000.
        else :
            if (100 < n <= 1000) :
                res = n - n % 10 - 1
                res_ = change // res
                nom.append(res_)
                for x in range(1000000 - 1, 0, -1):
                    if len(nom) == 10:
                        break
                    elif len(nom) == n % 10 + 2:
                        break
                    
                    nom.append(x)
                    
                #State of the program after the  for loop has been executed: `A` is a single integer such that 1 ≤ A ≤ 10^5, `n` is an integer larger than 100 and within the range of 100 to 1000, `change` is 1000000, `nom` has at most 11 elements with the last element being either 999990 or 999989 depending on the break condition, `res` is between 98 and 999, `res_` is between 1000 and 10101.
            else :
                if (1000 < n <= 10000) :
                    if (n == 10000) :
                        change = 10000
                        print(str(change) + ' ' + str(2))
                        print(str(1) + ' ' + str(9))
                        exit(0)
                    #State of the program after the if block has been executed: *`A` is a single integer such that 1 ≤ A ≤ 10^5; `n` is equal to 10000, so `change` is set to 10000, `nom` remains as [1], and the output is "10000 2", with a printed output of "1 9".
                    res = n - n % 10 - 1
                    res_ = change // res
                    nom.append(res_)
                    for x in range(1000000 - 1, 0, -1):
                        if len(nom) == 10:
                            break
                        elif len(nom) == n % 10 + 2:
                            break
                        
                        nom.append(x)
                        
                    #State of the program after the  for loop has been executed: `A` is a single integer such that 1 ≤ `A` ≤ 10^5, `n` is 10000, `change` is 10000, `nom` is a list containing 2 elements, the output is "10000 2", printed output is "1 9", `res` is 9999, `res_` is 1, `x` is 999999.
                else :
                    if (10000 < n <= 100000) :
                        if (n == 100000) :
                            change = 100000
                            print(str(change) + ' ' + str(2))
                            print(str(1) + ' ' + str(9))
                            exit(0)
                        #State of the program after the if block has been executed: *`A` is a single integer such that 1 ≤ `A` ≤ 10^5; `n` is an input integer larger than 100 and within the specified ranges; `change` is 1000000; `nom` is [1]; if `n` is equal to 100000, the output is "100000 2", printed output is "1 9", and the program exits.
                        res = n - n % 10 - 1
                        res_ = change // res
                        nom.append(res_)
                        for x in range(1000000 - 1, 0, -1):
                            if len(nom) == 10:
                                break
                            elif len(nom) == n % 10 + 2:
                                break
                            
                            nom.append(x)
                            
                        #State of the program after the  for loop has been executed: `A` is a single integer such that 1 ≤ `A` ≤ 10^5, `n` is 100000, `change` is 1000000, `nom` contains 10 elements, `res` is 99999, `res_` is 10, and `x` is 999992.
                    #State of the program after the if block has been executed: *`A` is a single integer such that 1 ≤ `A` ≤ 10^5, `n` is an integer greater than 100. If 10000 < `n` ≤ 100000, then `n` is set to 100000, `change` is 1000000, `nom` contains 10 elements, `res` is 99999, `res_` is 10, and `x` is 999992.
                #State of the program after the if-else block has been executed: *`A` is a single integer such that 1 ≤ `A` ≤ 10^5. If `n` is 10000, `change` is updated to 10000, `nom` becomes a list containing 2 elements, the output is "10000 2", printed output is "1 9", `res` is 9999, `res_` is 1, and `x` is 999999. Otherwise, if `n` is greater than 100 but less than or equal to 100000, then if 10000 < `n` ≤ 100000, `n` is set to 100000, `change` remains 1000000, `nom` contains 10 elements, `res` is 99999, `res_` is 10, and `x` is 999992.
            #State of the program after the if-else block has been executed: *`A` is a single integer such that 1 ≤ `A` ≤ 10^5. If `n` is an integer larger than 100 and within the range of 100 to 1000, `change` is 1000000, `nom` has at most 11 elements with the last element being either 999990 or 999989 depending on the break condition, `res` is between 98 and 999, and `res_` is between 1000 and 10101. Otherwise, if `n` is 10000, `change` is updated to 10000, `nom` becomes a list containing 2 elements, the output is "10000 2", printed output is "1 9", `res` is 9999, `res_` is 1, and `x` is 999999. If `n` is greater than 100 but less than or equal to 100000, and if 10000 < `n` ≤ 100000, then `n` is set to 100000, `change` remains 1000000, `nom` contains 10 elements, `res` is 99999, `res_` is 10, and `x` is 999992.
        #State of the program after the if-else block has been executed: *`A` is a single integer such that 1 ≤ `A` ≤ 10^5. If `n` is an integer within the range of 11 to 100, then `change` is 1000000, `nom` is a list of integers containing 10 elements, `res` is between 10 and 99, and `res_` is between 10101 and 100000. If `n` is larger than 100 and within the range of 101 to 1000, then `change` is 1000000, `nom` has at most 11 elements with the last element being either 999990 or 999989 depending on the break condition, `res` is between 98 and 999, and `res_` is between 1000 and 10101. If `n` is exactly 10000, then `change` is updated to 10000, `nom` becomes a list containing 2 elements, the output is "10000 2", printed output is "1 9", `res` is 9999, `res_` is 1, and `x` is 999999. If `n` is greater than 100 but less than or equal to 100000, and if 10000 < `n` ≤ 100000, then `n` is set to 100000, `change` remains 1000000, `nom` contains 10 elements, `res` is 99999, `res_` is 10, and `x` is 999992.
    #State of the program after the if-else block has been executed: *`A` is a single integer such that 1 ≤ `A` ≤ 10^5. If `n` is less than or equal to 10, then `nom` contains the values [1, 1000000, 999999, 999998, 999997, 999996, 999995, 999994, 999993, 999992] if `n` is 10, otherwise `nom` contains the values [1, 1000000, 999999, ..., 1000000 - (n - 1)]. If `n` is between 11 and 100, then `change` is 1000000, `nom` is a list of integers containing 10 elements, `res` is between 10 and 99, and `res_` is between 10101 and 100000. If `n` is between 101 and 1000, `change` remains 1000000, `nom` has at most 11 elements with the last element being either 999990 or 999989, `res` is between 98 and 999, and `res_` is between 1000 and 10101. If `n` is exactly 10000, then `change` is updated to 10000, `nom` contains 2 elements, the output is "10000 2", printed output is "1 9", `res` is 9999, `res_` is 1, and `x` is 999999. If `n` is greater than 100 but less than or equal to 100000, and if 10000 < `n` ≤ 100000, then `n` is set to 100000, `change` remains 1000000, `nom` contains 10 elements, `res` is 99999, `res_` is 10, and `x` is 999992.
    print(str(change) + ' ' + str(len(nom)))
    print(' '.join(list(map(str, nom))))
    exit(0)
#Overall this is what the function does:The function reads an integer `n` from input, which is constrained to the range 1 ≤ n ≤ 100,000. Depending on the value of `n`, the function generates a list `nom` and outputs its length and contents. If `n` is 10 or less, `nom` will contain the integers from 1 to 1,000,000 down to a certain value. If `n` is between 11 and 100, `nom` will include a calculated value based on `n` and then fill up to 10 elements. For `n` between 101 and 1000, it behaves similarly but with additional break conditions based on the length of `nom`. If `n` equals 10,000 or 100,000, the function will print specific output and exit. The function does not return a value but prints the result directly. It also handles edge cases for input values at the boundaries of the defined ranges.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
