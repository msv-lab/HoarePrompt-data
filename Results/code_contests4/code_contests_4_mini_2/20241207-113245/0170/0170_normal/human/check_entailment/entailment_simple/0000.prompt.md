
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given three sequences: a_1, a_2, …, a_n; b_1, b_2, …, b_n; c_1, c_2, …, c_n.

For each i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.

Find a sequence p_1, p_2, …, p_n, that satisfy the following conditions:

  * p_i ∈ \\{a_i, b_i, c_i\}
  * p_i ≠ p_{(i mod n) + 1}.



In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements i,i+1 adjacent for i<n and also elements 1 and n) will have equal value.

It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.

Input

The first line of input contains one integer t (1 ≤ t ≤ 100): the number of test cases.

The first line of each test case contains one integer n (3 ≤ n ≤ 100): the number of elements in the given sequences.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 100).

The third line contains n integers b_1, b_2, …, b_n (1 ≤ b_i ≤ 100).

The fourth line contains n integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 100).

It is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.

Output

For each test case, print n integers: p_1, p_2, …, p_n (p_i ∈ \\{a_i, b_i, c_i\}, p_i ≠ p_{i mod n + 1}).

If there are several solutions, you can print any.

Example

Input


5
3
1 1 1
2 2 2
3 3 3
4
1 2 1 2
2 1 2 1
3 4 3 4
7
1 3 3 1 1 1 1
2 4 4 3 2 2 4
4 2 2 2 4 4 2
3
1 2 1
2 3 3
3 1 2
10
1 1 1 2 2 2 3 3 3 1
2 2 2 3 3 3 1 1 1 2
3 3 3 1 1 1 2 2 2 3


Output


1 2 3
1 2 1 2
1 3 4 3 2 4 2
1 3 2
1 2 3 1 2 3 1 2 3 2

Note

In the first test case p = [1, 2, 3].

It is a correct answer, because:

  * p_1 = 1 = a_1, p_2 = 2 = b_2, p_3 = 3 = c_3 
  * p_1 ≠ p_2 , p_2 ≠ p_3 , p_3 ≠ p_1 



All possible correct answers to this test case are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].

In the second test case p = [1, 2, 1, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = a_3, p_4 = a_4. Also we can see, that no two adjacent elements of the sequence are equal.

In the third test case p = [1, 3, 4, 3, 2, 4, 2].

In this sequence p_1 = a_1, p_2 = a_2, p_3 = b_3, p_4 = b_4, p_5 = b_5, p_6 = c_6, p_7 = c_7. Also we can see, that no two adjacent elements of the sequence are equal.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer such that 3 ≤ n ≤ 100, and a, b, c are lists of integers of length n where each element is in the range 1 ≤ a_i, b_i, c_i ≤ 100, with the condition that a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all i.
def func_1():
    return int(input())
    #The program returns an integer value obtained from user input, which is not directly related to the initial values of t, n, a, b, or c.

#Function 2:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, n is an integer for each test case such that 3 ≤ n ≤ 100, a, b, and c are lists of integers of length n, where each element of a, b, and c is between 1 and 100, and for each i, a[i] ≠ b[i], a[i] ≠ c[i], and b[i] ≠ c[i].
def func_2():
    return input()
    #The program returns the input provided by the user, which is expected to be in accordance with the constraints defined (1 ≤ t ≤ 100, 3 ≤ n ≤ 100, and lists a, b, and c containing integers between 1 and 100 with specific inequality conditions).

#Function 3:
#State of the program right berfore the function call: t is an integer (1 ≤ t ≤ 100) representing the number of test cases; for each test case, n is an integer (3 ≤ n ≤ 100) representing the number of elements in each sequence, followed by three sequences a, b, and c, each containing n integers (1 ≤ a_i, b_i, c_i ≤ 100) where for all i, a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a sequence of integers obtained from the input, where each integer is a value from the three sequences a, b, and c, separated by spaces.

#Function 4:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 100) representing the number of test cases, and for each test case, n is an integer (3 ≤ n ≤ 100) representing the number of elements in the sequences. The sequences a, b, and c each contain n integers (1 ≤ a_i, b_i, c_i ≤ 100) such that a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all i.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representations of the integers inputted, split by spaces, for each test case.

#Function 5:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100; for each test case, n is an integer such that 3 ≤ n ≤ 100; a, b, and c are lists of integers of length n where each element in the lists satisfies 1 ≤ a_i, b_i, c_i ≤ 100 and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all valid i.
def func_5():
    return list(func_3())
    #The program returns the list generated by func_3() based on the integers and lists defined in the initial state.

#Function 6:
#State of the program right berfore the function call: t is an integer in the range 1 ≤ t ≤ 100, and for each test case n is an integer in the range 3 ≤ n ≤ 100; a_i, b_i, c_i are integers in the range 1 ≤ a_i, b_i, c_i ≤ 100 for all i such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a tuple containing three sequences (a, b, c), where each sequence is a list of integers of length n (3 ≤ n ≤ 100), and each integer in the sequences satisfies 1 ≤ a_i, b_i, c_i ≤ 100 with the conditions that a_i ≠ b_i, a_i ≠ c_i, and b_i ≠ c_i for all i.
def func_7(item):
    return item[1]
    #The program returns the second sequence (list of integers) from the tuple 'item' containing three sequences (a, b, c)

#Function 8:
#State of the program right berfore the function call: l is a list of tuples, each containing three sequences of integers where each sequence has the same length n (3 ≤ n ≤ 100) and the elements are such that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i. The value of t (1 ≤ t ≤ 100) indicates the number of test cases. Each sequence element is an integer within the range 1 ≤ a_i, b_i, c_i ≤ 100.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list of tuples 'l' sorted in descending order based on the key defined by 'getKey'

#Function 9:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100; for each test case, n is an integer such that 3 ≤ n ≤ 100; a, b, and c are lists of integers of size n where each element satisfies 1 ≤ a[i], b[i], c[i] ≤ 100 and a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i] for all i.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a matrix of size n x m, where each element is the value 'num', which is not defined in the current context.

#Function 10:
#State of the program right berfore the function call: x is a tuple containing three sequences of integers (a, b, c), where each sequence has length n (3 ≤ n ≤ 100), and for each index i (1 ≤ i ≤ n), a[i] ≠ b[i], a[i] ≠ c[i], and b[i] ≠ c[i].
def func_10(x):
    return x and not x & x - 1
    #The program returns the tuple x and a boolean value indicating whether x is not equal to x & (x - 1). The tuple x contains three sequences of integers (a, b, c) with specified conditions.

#Function 11:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100. Additionally, for each test case, there are three sequences (a, b, c) of length n where each element a_i, b_i, c_i is an integer in the range 1 ≤ a_i, b_i, c_i ≤ 100, and it holds that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the integer n, without the '0b' prefix, where n is an integer such that 3 ≤ n ≤ 100

#Function 12:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100. Additionally, for each test case, there are three sequences of integers a, b, and c, each containing n integers where 1 ≤ a_i, b_i, c_i ≤ 100, and a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of integers representing the digits of the integer n

#Function 13:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100, r is a list of three sequences each containing n integers, where each integer is between 1 and 100, and for each i, the elements satisfy a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the binomial coefficient C(n, r) computed as factorial(n) // (factorial(r) * factorial(max(n - r, 1))), where n is an integer between 3 and 100 and r is an integer between 1 and n-1.

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), and for each test case, y is a list containing three sequences of integers a, b, and c, where each sequence has n integers (3 ≤ n ≤ 100) and 1 ≤ a[i], b[i], c[i] ≤ 100 with a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i].
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the integer result of dividing the number of test cases `x` by the list `y`, which contains three sequences of integers.
    else :
        return x // y + 1
        #The program returns the result of integer division of the number of test cases `x` by `y`, plus 1, where `y` is a list with three sequences of integers for each test case.

#Function 15:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), y is an integer representing the number of elements in the sequences for each test case (3 ≤ y ≤ 100), and p consists of three lists of integers (a, b, c) where each list has y integers (1 ≤ a_i, b_i, c_i ≤ 100) and for all i, a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i.
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is equal to the initial value of `x` raised to the power of the initial value of `y` modulo `p`, `x` has been updated to the final value of `x` after all iterations.
    return res
    #The program returns the value of 'res', which is equal to the final value of 'x' raised to the power of 0 modulo 'p', resulting in 1.

#Function 16:
#State of the program right berfore the function call: x is an integer representing the number of test cases (1 ≤ x ≤ 100), and y is a list of tuples where each tuple contains an integer n (3 ≤ n ≤ 100) followed by three lists of n integers (a, b, c) satisfying 1 ≤ a[i], b[i], c[i] ≤ 100 and a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i] for all i.
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is empty, `x` is the GCD of the original value of `x` and the first element of the last tuple in `y`
    return x
    #The program returns the GCD of the original value of 'x' and the first element of the last tuple in 'y', where 'y' is empty

#Function 17:
#State of the program right berfore the function call: n is an integer such that 3 ≤ n ≤ 100, and there are three sequences of integers a, b, and c each containing n integers where 1 ≤ a[i], b[i], c[i] ≤ 100, and for all i, a[i] ≠ b[i], a[i] ≠ c[i], b[i] ≠ c[i].
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer such that 3 ≤ `n` ≤ 100, and there are three sequences of integers `a`, `b`, and `c` each containing `n` integers where 1 ≤ `a[i]`, `b[i]`, `c[i]` ≤ 100, and for all `i`, `a[i]` ≠ `b[i]`, `a[i]` ≠ `c[i]`, `b[i]` ≠ `c[i]`. The value of `n` is greater than 1.
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *`n` is an integer such that `n` is greater than 3 and less than or equal to 100, and there are three sequences of integers `a`, `b`, and `c` each containing `n` integers where 1 ≤ `a[i]`, `b[i]`, `c[i]` ≤ 100, and for all `i`, `a[i]` ≠ `b[i]`, `a[i]` ≠ `c[i]`, `b[i]` ≠ `c[i]`. The value of `n` is greater than 1.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer such that `n` is greater than 3 and less than or equal to 100, and there are three sequences of integers `a`, `b`, and `c` each containing `n` integers where 1 ≤ `a[i]`, `b[i]`, `c[i]` ≤ 100, and for all `i`, `a[i]` ≠ `b[i]`, `a[i]` ≠ `c[i]`, `b[i]` ≠ `c[i]`. The value of `n` is greater than 1, and `n` is not divisible by 2 or 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is an integer between 25 and 100; `i` is greater than 29.
    return True
    #The program returns True

#Function 18:
#State of the program right berfore the function call: The function is designed to handle multiple test cases, where each test case consists of three sequences (a, b, c) of integers with the same length n (3 ≤ n ≤ 100), and for each index i (1 ≤ i ≤ n), a_i, b_i, and c_i are distinct integers (1 ≤ a_i, b_i, c_i ≤ 100). The number of test cases t is such that 1 ≤ t ≤ 100.
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: t is an integer such that 1 ≤ t ≤ 100, each test case contains an integer n (3 ≤ n ≤ 100), and three sequences a, b, c of length n where each element a_i, b_i, c_i is an integer (1 ≤ a_i, b_i, c_i ≤ 100) and satisfies a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_19():
    for _ in range(func_1()):
        n = func_1()
        
        a = func_5()
        
        b = func_5()
        
        c = func_5()
        
        ans = [0] * n
        
        ans[0] = a[0]
        
        for i in range(1, n):
            if ans[i - 1] != a[i]:
                ans[i] = a[i]
            elif ans[i - 1] != b[i]:
                ans[i] = b[i]
            else:
                ans[i] = c[i]
        
        func_20(*ans)
        
    #State of the program after the  for loop has been executed: `t` is an integer such that 1 ≤ `t` ≤ 100, `n` is at least 3, `c` is the return value of `func_5()`, `ans` is a list of length `n` containing distinct values from `a`, `b`, and `c` such that no two consecutive elements in `ans` are equal, and `func_20(*ans)` is called with unpacked values of `ans`.

#Function 20:
#State of the program right berfore the function call: The first argument is an integer t (1 ≤ t ≤ 100) representing the number of test cases. For each test case, there is an integer n (3 ≤ n ≤ 100) followed by three sequences of n integers a, b, and c, where each integer in the sequences is in the range (1 ≤ a_i, b_i, c_i ≤ 100) and it is guaranteed that a_i ≠ b_i, a_i ≠ c_i, b_i ≠ c_i for all i.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` is set to its default value, `file` contains the string representations of all elements in `args` separated by `sep`, `at_start` is False, `args` is a non-empty iterable.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` is set to its default value, `file` contains the string representations of all elements in `args` separated by `sep`, `at_start` is False, `args` is a non-empty iterable, a value has been written to `file` (either the value of kwargs['end'] or '\n'), and the flush operation has been performed on `file` if kwargs['flush'] is True.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
