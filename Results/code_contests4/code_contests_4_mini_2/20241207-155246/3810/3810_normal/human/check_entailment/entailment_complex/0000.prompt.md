
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Alexey, a merry Berland entrant, got sick of the gray reality and he zealously wants to go to university. There are a lot of universities nowadays, so Alexey is getting lost in the diversity — he has not yet decided what profession he wants to get. At school, he had bad grades in all subjects, and it's only thanks to wealthy parents that he was able to obtain the graduation certificate.

The situation is complicated by the fact that each high education institution has the determined amount of voluntary donations, paid by the new students for admission — ni berubleys. He cannot pay more than ni, because then the difference between the paid amount and ni can be regarded as a bribe!

Each rector is wearing the distinctive uniform of his university. Therefore, the uniform's pockets cannot contain coins of denomination more than ri. The rector also does not carry coins of denomination less than li in his pocket — because if everyone pays him with so small coins, they gather a lot of weight and the pocket tears. Therefore, a donation can be paid only by coins of denomination x berubleys, where li ≤ x ≤ ri (Berland uses coins of any positive integer denomination). Alexey can use the coins of different denominations and he can use the coins of the same denomination any number of times. When Alexey was first confronted with such orders, he was puzzled because it turned out that not all universities can accept him! Alexey is very afraid of going into the army (even though he had long wanted to get the green uniform, but his dad says that the army bullies will beat his son and he cannot pay to ensure the boy's safety). So, Alexey wants to know for sure which universities he can enter so that he could quickly choose his alma mater.

Thanks to the parents, Alexey is not limited in money and we can assume that he has an unlimited number of coins of each type.

In other words, you are given t requests, each of them contains numbers ni, li, ri. For each query you need to answer, whether it is possible to gather the sum of exactly ni berubleys using only coins with an integer denomination from li to ri berubleys. You can use coins of different denominations. Coins of each denomination can be used any number of times.

Input

The first line contains the number of universities t, (1 ≤ t ≤ 1000) Each of the next t lines contain three space-separated integers: ni, li, ri (1 ≤ ni, li, ri ≤ 109; li ≤ ri).

Output

For each query print on a single line: either "Yes", if Alexey can enter the university, or "No" otherwise.

Examples

Input

2
5 2 3
6 4 5


Output

Yes
No

Note

You can pay the donation to the first university with two coins: one of denomination 2 and one of denomination 3 berubleys. The donation to the second university cannot be paid.
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000) representing the number of universities, and for each university, ni, li, and ri are positive integers (1 ≤ ni, li, ri ≤ 10^9) such that li ≤ ri.
def func_1():
    return int(input())
    #The program returns a positive integer input value, representing the number of universities t, which is between 1 and 1000.
#Overall this is what the function does:The function accepts user input and returns a positive integer representing the number of universities, with no validation to ensure the input is within the specified range (1 to 1000), which could lead to invalid values being accepted.

#Function 2:
#State of the program right berfore the function call: t is a positive integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, and ri are integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_2():
    return input()
    #The program returns the input values provided for the number of universities, including the integers ni, li, and ri for each university, based on the positive integer t representing the number of universities.
#Overall this is what the function does:The function accepts no parameters and returns the input provided by the user, which is expected to include information for a specified number of universities. However, it does not handle the input of multiple universities in a structured manner, nor does it validate the values to ensure they adhere to the specified constraints. It simply returns whatever input is given as a single string.

#Function 3:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000) representing the number of universities, and for each university, ni, li, and ri are integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a list of integers parsed from the input string, representing values related to the universities' parameters.
#Overall this is what the function does:The function accepts no parameters and returns a map object containing integers parsed from a single input string. The integers represent values related to the parameters of a number of universities. Since the input is taken from the user, the function does not handle any potential input errors or invalid formats, and it does not specify how many integers to expect, relying instead on the user to provide the correct format.

#Function 4:
#State of the program right berfore the function call: t is a positive integer representing the number of universities, and for each university, ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representations of the input values split by spaces. The input consists of positive integers representing the respective values for each university.
#Overall this is what the function does:The function accepts input values representing the attributes of universities, processes the input by splitting it into individual string representations, and returns a map object containing these string values. The function does not handle any potential edge cases related to input formatting or validation, such as empty input or non-integer values, and assumes the input will always be correctly formatted as positive integers.

#Function 5:
#State of the program right berfore the function call: t is a positive integer representing the number of universities, and for each university i (1 ≤ i ≤ t), ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_5():
    return list(func_3())
    #The program returns a list generated by func_3() based on the positive integers ni, li, and ri for t universities. Each entry in the list corresponds to the processing of these integers within func_3().
#Overall this is what the function does:The function accepts no parameters and returns a list generated by `func_3()`, which processes the positive integers `ni`, `li`, and `ri` for `t` universities. Each entry in the list corresponds to the results of this processing. However, since the exact behavior and output of `func_3()` are not defined in the provided code, the specific contents of the returned list cannot be determined.

#Function 6:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each query, ni, li, and ri are positive integers (1 ≤ ni, li, ri ≤ 10^9) such that li ≤ ri.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
#Overall this is what the function does:The function accepts no parameters and initializes a thread to execute the `main` function, which is intended to process multiple queries consisting of positive integers. However, it does not handle any return values or provide direct output; its primary role is to set up an environment for multi-threaded execution. The function lacks any error handling or checks for the execution of the `main` function.

#Function 7:
#State of the program right berfore the function call: item is a list of t tuples, where each tuple contains three integers ni, li, and ri such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri, and t is an integer such that 1 ≤ t ≤ 1000.
def func_7(item):
    return item[1]
    #The program returns the second tuple (item[1]) from the list of t tuples, where each tuple contains three integers ni, li, and ri
#Overall this is what the function does:The function accepts a list of tuples `item`, where each tuple contains three integers. It returns the second tuple from the list (item[1]). If the list contains fewer than two tuples, attempting to access item[1] will result in an `IndexError`.

#Function 8:
#State of the program right berfore the function call: l is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri; the length of the list l is at most 1000.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list of tuples 'l' sorted in descending order based on the key defined by 'getKey'
#Overall this is what the function does:The function accepts a list of tuples `l`, where each tuple contains three integers. It returns the list sorted in descending order based on a key defined by the `getKey` function. There are no checks for any edge cases regarding the contents of the tuples or the structure of the list.

#Function 9:
#State of the program right berfore the function call: n is a positive integer representing the exact amount of berubleys to be gathered, m is a positive integer representing the number of universities, and num is a list of tuples, each containing three integers (ni, li, ri) where ni is the donation amount, li is the minimum coin denomination, and ri is the maximum coin denomination, with constraints 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a matrix of size n x m, where each element is the list of tuples 'num' containing donation amounts and coin denominations.
#Overall this is what the function does:The function accepts two positive integers `n` and `m`, and a list of tuples `num`. It returns a matrix of size `n x m`, where each element is a reference to the same list of tuples `num`. This means that all entries in the matrix point to the same list, rather than creating distinct copies for each entry.

#Function 10:
#State of the program right berfore the function call: x is a list of tuples, where each tuple contains three integers (ni, li, ri) representing the donation amount, minimum coin denomination, and maximum coin denomination respectively, such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The length of x is t, where 1 ≤ t ≤ 1000.
def func_10(x):
    return x and not x & x - 1
    #The program returns the list of tuples x and the result of the expression 'not x & x - 1' which evaluates the bitwise AND of x and (x - 1), effectively checking if x is empty or has a specific numeric representation.
#Overall this is what the function does:The function accepts a list of tuples `x`, where each tuple contains three integers. It returns the list of tuples `x` along with a boolean value indicating whether `x` is empty or has a specific numeric representation based on the bitwise operation `not x & (x - 1)`. The expression evaluates to `True` if `x` is empty or if `x` is a power of two (which is not applicable here since `x` is a list of tuples and not a numeric value). However, the behavior of the bitwise operation may not yield a meaningful result in the context of a list, leading to potential misunderstandings about its output.

#Function 11:
#State of the program right berfore the function call: n is a list of tuples, each containing three integers (ni, li, ri) where 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri, and the length of the list n is between 1 and 1000.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the list 'n' as a string, after removing the '0b' prefix.
#Overall this is what the function does:The function accepts a list of tuples `n` and returns the binary representation of the entire list as a string, after removing the '0b' prefix. It does not return the binary representation of each integer within the tuples or handle any errors arising from unexpected input.

#Function 12:
#State of the program right berfore the function call: n is a positive integer representing the total donation amount, and each query consists of three space-separated integers ni, li, and ri where ni is the exact donation amount to be paid, and li and ri are the minimum and maximum coin denominations respectively, such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. Additionally, there are t queries with 1 ≤ t ≤ 1000.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of the digits of the positive integer n representing the total donation amount, where each digit is an integer
#Overall this is what the function does:The function accepts a positive integer `n` and returns a list of its digits, where each digit is represented as an integer. There are no edge cases or missing functionalities as the function correctly handles any positive integer input within the specified range.

#Function 13:
#State of the program right berfore the function call: n is a positive integer representing the donation amount, and r is a list of tuples where each tuple contains three integers (ni, li, ri) representing the donation amount, minimum coin denomination, and maximum coin denomination respectively, for t queries (1 <= t <= 1000; 1 ≤ ni, li, ri ≤ 10^9; li ≤ ri).
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the number of ways to choose r items from n items, calculated using the formula n! / (r! * (n - r)!)
#Overall this is what the function does:The function accepts a positive integer `n` representing the total number of items and an integer `r`, which indicates the number of items to choose. It returns the number of ways to choose `r` items from `n` items using the formula n! / (r! * (n - r)!). However, it does not handle edge cases where `r` is greater than `n`, which would result in incorrect calculations or potentially an error, as the factorial of a negative number is not defined. Therefore, the function should ideally check if `r` is less than or equal to `n` before performing the calculation.

#Function 14:
#State of the program right berfore the function call: x is a positive integer representing the number of universities (1 ≤ x ≤ 1000), and y is a list of tuples, each containing three positive integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri for each tuple.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the value of x divided by the list y, where x is a positive integer representing the number of universities and y is a list of tuples. Since x is divisible by y, the return value is an integer.
    else :
        return x // y + 1
        #The program returns the integer result of x divided by the length of the list y plus 1, considering that x is a positive integer between 1 and 1000 and the length of y is not a divisor of x.
#Overall this is what the function does:The function accepts a positive integer `x` representing the number of universities and a list `y` of tuples. It returns `x` divided by the length of `y` if `x` is divisible by the length of `y`; otherwise, it returns `x` divided by the length of `y` plus 1. There is a potential error in the code as it uses `y` instead of `len(y)` in the division, which may lead to a TypeError if `y` is not an integer. The code does not handle cases where `y` is empty, which could also lead to a ZeroDivisionError.

#Function 15:
#State of the program right berfore the function call: x is a positive integer representing the total donation amount (ni), y is a positive integer representing the minimum coin denomination (li), and p is a positive integer representing the maximum coin denomination (ri) such that y ≤ p.
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is `(x^original_y) % p`, `x` is updated to `x^(2^k) % p` for some integer k based on the number of iterations.
    return res
    #The program returns the value of res, which is calculated as (x^original_y) % p, where y is 0, indicating that original_y is 0 as well. Thus, res is equal to (x^0) % p, which is 1 % p.
#Overall this is what the function does:The function accepts three positive integer parameters `x`, `y`, and `p`, where `y` is less than or equal to `p`. It calculates the result of `(x^y) % p` using exponentiation by squaring. The function returns this computed value, which can be different from 1 depending on the values of `x`, `y`, and `p`. The function correctly handles the case where `y` is greater than 0 and performs calculations based on the binary representation of `y`. If `y` is 0, the result will always be 1 % p, which is 1.

#Function 16:
#State of the program right berfore the function call: x is an integer representing the number of universities (1 ≤ x ≤ 1000), and y is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the last computed value from `x % y`, and `y` is empty after all iterations have executed.
    return x
    #The program returns the last computed value of `x` from the expression `x % y`, where `y` is empty after all iterations have executed.
#Overall this is what the function does:The function accepts an integer `x` (representing the number of universities, constrained to 1 ≤ x ≤ 1000) and a list `y` of tuples, where each tuple contains three integers. The function computes the greatest common divisor (GCD) of `x` and the values in the first tuple of `y`, repeatedly updating `x` with the modulo of `x` by the elements of `y`, until `y` is empty. It then returns the last computed value of `x`. However, as the code currently stands, it lacks handling for the actual elements within the tuples of `y`, and thus, the function will not perform as expected with the provided input structure.

#Function 17:
#State of the program right berfore the function call: n is an integer representing the number of universities, and for each university, there are three integers ni, li, and ri such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer representing the number of universities greater than 1, and for each university, `ni`, `li`, and `ri` are integers such that 1 ≤ `ni`, `li`, `ri` ≤ 10^9 and `li` ≤ `ri`.
    if (n <= 3) :
        return True
        #The program returns True, indicating a successful condition or state regarding the universities
    #State of the program after the if block has been executed: *`n` is an integer representing the number of universities greater than 1, and `n` is greater than 3. For each university, `ni`, `li`, and `ri` are integers such that 1 ≤ `ni`, `li`, `ri` ≤ 10^9 and `li` ≤ `ri`.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer representing the number of universities greater than 1, and `n` is greater than 3. For each university, `ni`, `li`, and `ri` are integers such that 1 ≤ `ni`, `li`, `ri` ≤ 10^9 and `li` ≤ `ri`. Additionally, `n` is not divisible by 2 and not divisible by 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `i` is greater than or equal to 5 + 6*k where k is the number of times the loop executed, and `n` remains an integer greater than or equal to the largest square less than or equal to `n`, specifically greater than or equal to 121.
    return True
    #The program returns True, as `i` is greater than or equal to 5 + 6*k and `n` is an integer greater than or equal to 121.
#Overall this is what the function does:The function accepts an integer `n` representing the number of universities and returns False if `n` is less than or equal to 1, or if `n` is greater than 3 and divisible by either 2 or 3. It returns True if `n` is greater than 3 and not divisible by 2 or 3, or if `n` is 2 or 3. The function also checks for primality for numbers greater than 3 using a trial division method, returning True if `n` is prime and False if it is not.

#Function 18:
#State of the program right berfore the function call: The function processes t queries where t is a positive integer (1 ≤ t ≤ 1000). Each query consists of three integers ni, li, and ri, where ni is a positive integer representing the donation amount (1 ≤ ni ≤ 10^9), and li and ri are integers representing the minimum and maximum coin denominations respectively (1 ≤ li ≤ ri ≤ 10^9).
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
#Overall this is what the function does:The function `func_18` reads input from a file named 'input.txt', where it is expected to process multiple queries regarding donation amounts and coin denominations. However, the function does not perform any computation or return any results related to those queries; it merely redirects standard input and output. Therefore, it lacks the implementation to handle the actual logic of processing the donation amounts (`ni`) and coin denominations (`li`, `ri`). As a result, while it sets up the environment for input/output, it does not provide any meaningful output or return values based on the queries, rendering it incomplete in terms of functionality.

#Function 19:
#State of the program right berfore the function call: t is a positive integer less than or equal to 1000, and for each query, ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_19():
    for _ in range(func_1()):
        n, l, r = func_3()
        
        low = 1
        
        high = 1000000000
        
        f = 0
        
        while low <= high:
            mid = (low + high) // 2
            x = l * mid
            y = r * mid
            if x <= n and n <= y:
                f = 1
                break
            if y < n:
                low = mid + 1
            else:
                high = mid - 1
        
        if f:
            func_20('Yes')
        else:
            func_20('No')
        
    #State of the program after the  for loop has been executed: `low` is greater than `high`, `n`, `l`, `r`, and `t` retain their initial values assigned from `func_3()`, and `high` is less than or equal to 1000000000. `f` indicates whether there exists a `mid` such that `l * mid <= n <= r * mid` for each iteration, and `func_20` is called with 'Yes' or 'No' based on the value of `f` for each iteration.
#Overall this is what the function does:The function processes a number of queries defined by a positive integer `t`, where for each query it checks if there exists an integer `mid` such that `l * mid <= n <= r * mid`. If such a `mid` exists, it returns 'Yes'; otherwise, it returns 'No'. The function does not accept any parameters and relies on the values retrieved from other functions (`func_1` and `func_3`) for its operations. It may be subject to edge cases based on the values of `n`, `l`, and `r`, including scenarios where `n` is outside the bounds defined by `l` and `r`.

#Function 20:
#State of the program right berfore the function call: t is a positive integer representing the number of universities; for each university, ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `t` is a positive integer, `args` is a collection with at least `t` elements, `x` is the last element in `args`, `at_start` is False; `file` writes the string representations of all elements in `args` separated by `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`t` is a positive integer, `args` is a collection with at least `t` elements, `x` is the last element in `args`, `at_start` is False; `file` writes the string representations of all elements in `args` separated by `sep`, using either the default newline character or a specified value from `kwargs`, and if `flush` is True, the `flush` operation is performed on `file` to ensure all buffered output is written out.
#Overall this is what the function does:The function accepts a variable number of arguments and prints their string representations to a specified output stream, separated by a specified separator. It also allows for customization of the end character and includes an option to flush the output stream after writing. The function does not directly handle or return any values related to the positive integers representing universities (`t`, `ni`, `li`, `ri`), as these are not explicitly defined as parameters or processed within the function.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.