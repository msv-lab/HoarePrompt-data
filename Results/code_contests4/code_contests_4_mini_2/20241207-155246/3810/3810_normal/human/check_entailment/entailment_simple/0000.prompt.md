
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Alexey, a merry Berland entrant, got sick of the gray reality and he zealously wants to go to university. There are a lot of universities nowadays, so Alexey is getting lost in the diversity — he has not yet decided what profession he wants to get. At school, he had bad grades in all subjects, and it's only thanks to wealthy parents that he was able to obtain the graduation certificate.

The situation is complicated by the fact that each high education institution has the determined amount of voluntary donations, paid by the new students for admission — ni berubleys. He cannot pay more than ni, because then the difference between the paid amount and ni can be regarded as a bribe!

Each rector is wearing the distinctive uniform of his university. Therefore, the uniform's pockets cannot contain coins of denomination more than ri. The rector also does not carry coins of denomination less than li in his pocket — because if everyone pays him with so small coins, they gather a lot of weight and the pocket tears. Therefore, a donation can be paid only by coins of denomination x berubleys, where li ≤ x ≤ ri (Berland uses coins of any positive integer denomination). Alexey can use the coins of different denominations and he can use the coins of the same denomination any number of times. When Alexey was first confronted with such orders, he was puzzled because it turned out that not all universities can accept him! Alexey is very afraid of going into the army (even though he had long wanted to get the green uniform, but his dad says that the army bullies will beat his son and he cannot pay to ensure the boy's safety). So, Alexey wants to know for sure which universities he can enter so that he could quickly choose his alma mater.

Thanks to the parents, Alexey is not limited in money and we can assume that he has an unlimited number of coins of each type.

In other words, you are given t requests, each of them contains numbers ni, li, ri. For each query you need to answer, whether it is possible to gather the sum of exactly ni berubleys using only coins with an integer denomination from li to ri berubleys. You can use coins of different denominations. Coins of each denomination can be used any number of times.

Input

The first line contains the number of universities t, (1 ≤ t ≤ 1000) Each of the next t lines contain three space-separated integers: ni, li, ri (1 ≤ ni, li, ri ≤ 109; li ≤ ri).

Output

For each query print on a single line: either "Yes", if Alexey can enter the university, or "No" otherwise.

Examples

Input

2
5 2 3
6 4 5


Output

Yes
No

Note

You can pay the donation to the first university with two coins: one of denomination 2 and one of denomination 3 berubleys. The donation to the second university cannot be paid.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000) representing the number of universities, and for each university, ni, li, and ri are positive integers (1 ≤ ni, li, ri ≤ 10^9) such that li ≤ ri.
def func_1():
    return int(input())
    #The program returns a positive integer input value, representing the number of universities t, which is between 1 and 1000.

#Function 2:
#State of the program right berfore the function call: t is a positive integer representing the number of universities (1 ≤ t ≤ 1000), and for each university, ni, li, and ri are integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_2():
    return input()
    #The program returns the input values provided for the number of universities, including the integers ni, li, and ri for each university, based on the positive integer t representing the number of universities.

#Function 3:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000) representing the number of universities, and for each university, ni, li, and ri are integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a list of integers parsed from the input string, representing values related to the universities' parameters.

#Function 4:
#State of the program right berfore the function call: t is a positive integer representing the number of universities, and for each university, ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representations of the input values split by spaces. The input consists of positive integers representing the respective values for each university.

#Function 5:
#State of the program right berfore the function call: t is a positive integer representing the number of universities, and for each university i (1 ≤ i ≤ t), ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_5():
    return list(func_3())
    #The program returns a list generated by func_3() based on the positive integers ni, li, and ri for t universities. Each entry in the list corresponds to the processing of these integers within func_3().

#Function 6:
#State of the program right berfore the function call: t is a positive integer (1 ≤ t ≤ 1000), and for each query, ni, li, and ri are positive integers (1 ≤ ni, li, ri ≤ 10^9) such that li ≤ ri.
def func_6():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a list of t tuples, where each tuple contains three integers ni, li, and ri such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri, and t is an integer such that 1 ≤ t ≤ 1000.
def func_7(item):
    return item[1]
    #The program returns the second tuple (item[1]) from the list of t tuples, where each tuple contains three integers ni, li, and ri

#Function 8:
#State of the program right berfore the function call: l is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri; the length of the list l is at most 1000.
def func_8(l):
    return sorted(l, key=getKey, reverse=True)
    #The program returns the list of tuples 'l' sorted in descending order based on the key defined by 'getKey'

#Function 9:
#State of the program right berfore the function call: n is a positive integer representing the exact amount of berubleys to be gathered, m is a positive integer representing the number of universities, and num is a list of tuples, each containing three integers (ni, li, ri) where ni is the donation amount, li is the minimum coin denomination, and ri is the maximum coin denomination, with constraints 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a matrix of size n x m, where each element is the list of tuples 'num' containing donation amounts and coin denominations.

#Function 10:
#State of the program right berfore the function call: x is a list of tuples, where each tuple contains three integers (ni, li, ri) representing the donation amount, minimum coin denomination, and maximum coin denomination respectively, such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. The length of x is t, where 1 ≤ t ≤ 1000.
def func_10(x):
    return x and not x & x - 1
    #The program returns the list of tuples x and the result of the expression 'not x & x - 1' which evaluates the bitwise AND of x and (x - 1), effectively checking if x is empty or has a specific numeric representation.

#Function 11:
#State of the program right berfore the function call: n is a list of tuples, each containing three integers (ni, li, ri) where 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri, and the length of the list n is between 1 and 1000.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the list 'n' as a string, after removing the '0b' prefix.

#Function 12:
#State of the program right berfore the function call: n is a positive integer representing the total donation amount, and each query consists of three space-separated integers ni, li, and ri where ni is the exact donation amount to be paid, and li and ri are the minimum and maximum coin denominations respectively, such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri. Additionally, there are t queries with 1 ≤ t ≤ 1000.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of the digits of the positive integer n representing the total donation amount, where each digit is an integer

#Function 13:
#State of the program right berfore the function call: n is a positive integer representing the donation amount, and r is a list of tuples where each tuple contains three integers (ni, li, ri) representing the donation amount, minimum coin denomination, and maximum coin denomination respectively, for t queries (1 <= t <= 1000; 1 ≤ ni, li, ri ≤ 10^9; li ≤ ri).
def func_13(n, r):
    return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
    #The program returns the number of ways to choose r items from n items, calculated using the formula n! / (r! * (n - r)!)

#Function 14:
#State of the program right berfore the function call: x is a positive integer representing the number of universities (1 ≤ x ≤ 1000), and y is a list of tuples, each containing three positive integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri for each tuple.
def func_14(x, y):
    if (x % y == 0) :
        return x // y
        #The program returns the value of x divided by the list y, where x is a positive integer representing the number of universities and y is a list of tuples. Since x is divisible by y, the return value is an integer.
    else :
        return x // y + 1
        #The program returns the integer result of x divided by the length of the list y plus 1, considering that x is a positive integer between 1 and 1000 and the length of y is not a divisor of x.

#Function 15:
#State of the program right berfore the function call: x is a positive integer representing the total donation amount (ni), y is a positive integer representing the minimum coin denomination (li), and p is a positive integer representing the maximum coin denomination (ri) such that y ≤ p.
def func_15(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0, `res` is `(x^original_y) % p`, `x` is updated to `x^(2^k) % p` for some integer k based on the number of iterations.
    return res
    #The program returns the value of res, which is calculated as (x^original_y) % p, where y is 0, indicating that original_y is 0 as well. Thus, res is equal to (x^0) % p, which is 1 % p.

#Function 16:
#State of the program right berfore the function call: x is an integer representing the number of universities (1 ≤ x ≤ 1000), and y is a list of tuples, where each tuple contains three integers (ni, li, ri) such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_16(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `x` is the last computed value from `x % y`, and `y` is empty after all iterations have executed.
    return x
    #The program returns the last computed value of `x` from the expression `x % y`, where `y` is empty after all iterations have executed.

#Function 17:
#State of the program right berfore the function call: n is an integer representing the number of universities, and for each university, there are three integers ni, li, and ri such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_17(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer representing the number of universities greater than 1, and for each university, `ni`, `li`, and `ri` are integers such that 1 ≤ `ni`, `li`, `ri` ≤ 10^9 and `li` ≤ `ri`.
    if (n <= 3) :
        return True
        #The program returns True, indicating a successful condition or state regarding the universities
    #State of the program after the if block has been executed: *`n` is an integer representing the number of universities greater than 1, and `n` is greater than 3. For each university, `ni`, `li`, and `ri` are integers such that 1 ≤ `ni`, `li`, `ri` ≤ 10^9 and `li` ≤ `ri`.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is an integer representing the number of universities greater than 1, and `n` is greater than 3. For each university, `ni`, `li`, and `ri` are integers such that 1 ≤ `ni`, `li`, `ri` ≤ 10^9 and `li` ≤ `ri`. Additionally, `n` is not divisible by 2 and not divisible by 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `i` is greater than or equal to 5 + 6*k where k is the number of times the loop executed, and `n` remains an integer greater than or equal to the largest square less than or equal to `n`, specifically greater than or equal to 121.
    return True
    #The program returns True, as `i` is greater than or equal to 5 + 6*k and `n` is an integer greater than or equal to 121.

#Function 18:
#State of the program right berfore the function call: The function processes t queries where t is a positive integer (1 ≤ t ≤ 1000). Each query consists of three integers ni, li, and ri, where ni is a positive integer representing the donation amount (1 ≤ ni ≤ 10^9), and li and ri are integers representing the minimum and maximum coin denominations respectively (1 ≤ li ≤ ri ≤ 10^9).
def func_18():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 19:
#State of the program right berfore the function call: t is a positive integer less than or equal to 1000, and for each query, ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_19():
    for _ in range(func_1()):
        n, l, r = func_3()
        
        low = 1
        
        high = 1000000000
        
        f = 0
        
        while low <= high:
            mid = (low + high) // 2
            x = l * mid
            y = r * mid
            if x <= n and n <= y:
                f = 1
                break
            if y < n:
                low = mid + 1
            else:
                high = mid - 1
        
        if f:
            func_20('Yes')
        else:
            func_20('No')
        
    #State of the program after the  for loop has been executed: `low` is greater than `high`, `n`, `l`, `r`, and `t` retain their initial values assigned from `func_3()`, and `high` is less than or equal to 1000000000. `f` indicates whether there exists a `mid` such that `l * mid <= n <= r * mid` for each iteration, and `func_20` is called with 'Yes' or 'No' based on the value of `f` for each iteration.

#Function 20:
#State of the program right berfore the function call: t is a positive integer representing the number of universities; for each university, ni, li, and ri are positive integers such that 1 ≤ ni, li, ri ≤ 10^9 and li ≤ ri.
def func_20():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `t` is a positive integer, `args` is a collection with at least `t` elements, `x` is the last element in `args`, `at_start` is False; `file` writes the string representations of all elements in `args` separated by `sep`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`t` is a positive integer, `args` is a collection with at least `t` elements, `x` is the last element in `args`, `at_start` is False; `file` writes the string representations of all elements in `args` separated by `sep`, using either the default newline character or a specified value from `kwargs`, and if `flush` is True, the `flush` operation is performed on `file` to ensure all buffered output is written out.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
