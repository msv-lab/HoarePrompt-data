
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Mike is trying rock climbing but he is awful at it. 

There are n holds on the wall, i-th hold is at height ai off the ground. Besides, let the sequence ai increase, that is, ai < ai + 1 for all i from 1 to n - 1; we will call such sequence a track. Mike thinks that the track a1, ..., an has difficulty <image>. In other words, difficulty equals the maximum distance between two holds that are adjacent in height.

Today Mike decided to cover the track with holds hanging on heights a1, ..., an. To make the problem harder, Mike decided to remove one hold, that is, remove one element of the sequence (for example, if we take the sequence (1, 2, 3, 4, 5) and remove the third element from it, we obtain the sequence (1, 2, 4, 5)). However, as Mike is awful at climbing, he wants the final difficulty (i.e. the maximum difference of heights between adjacent holds after removing the hold) to be as small as possible among all possible options of removing a hold. The first and last holds must stay at their positions.

Help Mike determine the minimum difficulty of the track after removing one hold.

Input

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of holds.

The next line contains n space-separated integers ai (1 ≤ ai ≤ 1000), where ai is the height where the hold number i hangs. The sequence ai is increasing (i.e. each element except for the first one is strictly larger than the previous one).

Output

Print a single number — the minimum difficulty of the track after removing a single hold.

Examples

Input

3
1 4 6


Output

5


Input

5
1 2 3 4 5


Output

2


Input

5
1 2 3 7 8


Output

4

Note

In the first sample you can remove only the second hold, then the sequence looks like (1, 6), the maximum difference of the neighboring elements equals 5.

In the second test after removing every hold the difficulty equals 2.

In the third test you can obtain sequences (1, 3, 7, 8), (1, 2, 7, 8), (1, 2, 3, 8), for which the difficulty is 4, 5 and 5, respectively. Thus, after removing the second element we obtain the optimal answer — 4.
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: lst is a list of integers representing the heights of holds where 3 ≤ len(lst) ≤ 100 and 1 ≤ lst[i] ≤ 1000 for all valid i, and c is an integer representing the number of holds (which is not explicitly used in the removal process but relates to the number of elements in lst).
def func_1(lst, c):
    temp = []
    for i in c:
        temp.append(lst[i])
        
    #State of the program after the  for loop has been executed: `temp` contains the elements of `lst` at the indices specified by `c`, `c` is the number of holds processed, `lst` is a list of integers representing heights of holds.
    awk = -1
    if (0 in c and n - 1 in c) :
        for i in range(len(temp)):
            awk = max(awk, temp[i] - temp[i - 1])
            
        #State of the program after the  for loop has been executed: `temp` contains elements of `lst` at the indices specified by `c`, `awk` is the maximum difference between consecutive elements in `temp`, `c` includes all valid indices from `lst`, `i` is equal to the length of `temp` after the loop finishes, and `temp` has at least as many elements as there are valid indices in `c`.
    #State of the program after the if block has been executed: *`temp` contains elements of `lst` at the indices specified by `c`, `awk` is the maximum difference between consecutive elements in `temp`, `c` includes all valid indices from `lst`, and `i` is equal to the length of `temp` after the loop finishes, with `temp` having at least as many elements as there are valid indices in `c`, provided that both 0 and `n - 1` are included in `c`.
    if (awk == -1) :
        return 10000000000
        #The program returns the value 10000000000
    else :
        return awk
        #The program returns the maximum difference between consecutive elements in 'temp', which is represented by the variable 'awk', and 'awk' is not equal to -1
#Overall this is what the function does:The function accepts a list of integers `lst` representing heights and an integer `c`, which is expected to be a list of indices. It returns 10000000000 if both the first (index 0) and last (index n-1) elements are not included in `c`. If both indices are included, it computes and returns the maximum difference between consecutive heights specified by `c`. If no valid differences are found, it defaults to returning 10000000000. The function does not handle cases where `c` is not a list of valid indices, which could lead to index errors.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
