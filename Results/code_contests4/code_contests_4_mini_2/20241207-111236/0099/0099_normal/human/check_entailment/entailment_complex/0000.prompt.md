
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Ori and Sein have overcome many difficult challenges. They finally lit the Shrouded Lantern and found Gumon Seal, the key to the Forlorn Ruins. When they tried to open the door to the ruins... nothing happened.

Ori was very surprised, but Sein gave the explanation quickly: clever Gumon decided to make an additional defence for the door.

There are n lamps with Spirit Tree's light. Sein knows the time of turning on and off for the i-th lamp — l_i and r_i respectively. To open the door you have to choose k lamps in such a way that there will be a moment of time when they all will be turned on.

While Sein decides which of the k lamps to pick, Ori is interested: how many ways there are to pick such k lamps that the door will open? It may happen that Sein may be wrong and there are no such k lamps. The answer might be large, so print it modulo 998 244 353.

Input

First line contains two integers n and k (1 ≤ n ≤ 3 ⋅ 10^5, 1 ≤ k ≤ n) — total number of lamps and the number of lamps that must be turned on simultaneously.

Next n lines contain two integers l_i ans r_i (1 ≤ l_i ≤ r_i ≤ 10^9) — period of time when i-th lamp is turned on.

Output

Print one integer — the answer to the task modulo 998 244 353.

Examples

Input


7 3
1 7
3 8
4 5
6 7
1 3
5 10
8 9


Output


9

Input


3 1
1 1
2 2
3 3


Output


3

Input


3 2
1 1
2 2
3 3


Output


0

Input


3 3
1 3
2 3
3 3


Output


1

Input


5 2
1 3
2 4
3 5
4 6
5 7


Output


7

Note

In first test case there are nine sets of k lamps: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 2, 6), (1, 3, 6), (1, 4, 6), (2, 3, 6), (2, 4, 6), (2, 6, 7).

In second test case k=1, so the answer is 3.

In third test case there are no such pairs of lamps.

In forth test case all lamps are turned on in a time 3, so the answer is 1.

In fifth test case there are seven sets of k lamps: (1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (3, 5), (4, 5).
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: be is a list of integers representing the start times l_i of n lamps, en is a list of integers representing the end times r_i of n lamps, where n is a positive integer such that 1 ≤ n ≤ 300000, and for each lamp, 1 ≤ l_i ≤ r_i ≤ 10^9.
def func_1(be, en):
    res = [1]
    for i in range(be, en + 1):
        res.append(mult(res[-1], i))
        
    #State of the program after the  for loop has been executed: `res` is a list containing `n + 1` elements where `res[0]` is 1 and `res[i]` is equal to `mult(res[i - 1], i)` for `i` in the range from 1 to `n`.
    return res
    #The program returns the list 'res' containing n + 1 elements, where 'res[0]' is 1 and each 'res[i]' is computed as 'mult(res[i - 1], i)' for 'i' in the range from 1 to 'n'.
#Overall this is what the function does:The function accepts two parameters: `be`, which is expected to be the starting integer of a range, and `en`, which is the ending integer of the range. It returns a list `res` that contains `n + 1` elements, where `res[0]` is always 1, and each subsequent element `res[i]` is computed as `mult(res[i - 1], i)` for `i` in the range from 1 to `n` (inclusive). However, the input parameters `be` and `en` are not used correctly; instead of being lists, they should be integers representing the start and end of a range. The function does not handle cases where `be` is greater than `en`, nor does it check the validity of the inputs, leading to potential errors.

#Function 2:
#State of the program right berfore the function call: n is an integer representing the total number of lamps (1 ≤ n ≤ 300000), k is an integer representing the number of lamps that must be turned on simultaneously (1 ≤ k ≤ n), and r is a list of tuples where each tuple contains two integers (l_i, r_i) representing the time period when the i-th lamp is turned on (1 ≤ l_i ≤ r_i ≤ 10^9) for all i from 1 to n.
def func_2(n, r):
    if (n < r) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: *`n` is an integer representing the total number of lamps (1 ≤ n ≤ 300000), `k` is an integer representing the number of lamps that must be turned on simultaneously (1 ≤ k ≤ n), and `r` is a list of tuples where each tuple contains two integers (l_i, r_i) representing the time period when the i-th lamp is turned on (1 ≤ l_i ≤ r_i ≤ 10^9). The value of `n` is greater than or equal to `r`.
    return div(facs[n], facs[n - r])
    #The program returns the result of the division of facs[n] by facs[n - r], where 'facs' is a list containing the factorial values up to n.
#Overall this is what the function does:The function accepts an integer `n` representing the total number of lamps and a list `r` of tuples, but it does not use the `r` parameter in its calculations. If `n` is less than `r`, it returns 0. Otherwise, it returns the result of dividing `facs[n]` by `facs[n - r]`, where `facs` is a list containing the factorial values up to `n`. This implies that the function does not correctly handle the intended logic related to the lamps' time periods in `r`, and the parameter `k` mentioned in the comments is not utilized at all in the function.

#Function 3:
#State of the program right berfore the function call: arr is a list of tuples, where each tuple contains two integers (l_i, r_i) representing the on and off times of the i-th lamp, and the first element of the input must be a list of two integers n and k, where n is the total number of lamps (1 ≤ n ≤ 300,000) and k is the number of lamps that must be turned on simultaneously (1 ≤ k ≤ n).
def func_3(arr):
    tem = [0]
    for i in range(len(arr)):
        tem.append(tem[i] + arr[i])
        
    #State of the program after the  for loop has been executed: `tem` is the list of cumulative sums of the elements in `arr`, starting from 0; if `arr` is empty, `tem` is [0].
    return tem
    #The program returns the list 'tem' which contains the cumulative sums of the elements in 'arr', starting from 0; if 'arr' is empty, 'tem' is [0].
#Overall this is what the function does:The function accepts a list of integers `arr`, representing lamp timings, and returns a list of cumulative sums of the elements in `arr`, starting from 0. If `arr` is empty, it returns [0]. However, it does not handle cases where `arr` contains tuples; it only processes the integer values directly, which may lead to incorrect behavior if tuples are passed instead of a flat list of integers.

#Function 4:
#State of the program right berfore the function call: n is an integer representing the total number of lamps (1 ≤ n ≤ 3 ⋅ 10^5), k is an integer representing the number of lamps that must be turned on simultaneously (1 ≤ k ≤ n), and for each lamp i (1 ≤ i ≤ n), l_i and r_i are integers such that (1 ≤ l_i ≤ r_i ≤ 10^9).
def func_4():
    sys.stdout = BytesIO()
    atexit.register(lambda : os.write(1, sys.stdout.getvalue()))
    return BytesIO(os.read(0, os.fstat(0).st_size)).readline
    #The program returns the first line of input read from standard input, utilizing a BytesIO stream.
#Overall this is what the function does:The function does not accept any parameters and returns the first line of input read from standard input as a byte string. It utilizes a `BytesIO` stream to capture the input, and there are no checks for input length or format. The function will return the raw byte data of the first line, without any conversion to string or error handling for invalid input.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.