
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description and the annotations of the code which are provided as comments . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: A sequence a_1,a_2,... ,a_n is said to be /\/\/\/ when the following conditions are satisfied:

* For each i = 1,2,..., n-2, a_i = a_{i+2}.
* Exactly two different numbers appear in the sequence.



You are given a sequence v_1,v_2,...,v_n whose length is even. We would like to make this sequence /\/\/\/ by replacing some of its elements. Find the minimum number of elements that needs to be replaced.

Constraints

* 2 \leq n \leq 10^5
* n is even.
* 1 \leq v_i \leq 10^5
* v_i is an integer.

Input

Input is given from Standard Input in the following format:


n
v_1 v_2 ... v_n


Output

Print the minimum number of elements that needs to be replaced.

Examples

Input

4
3 1 3 2


Output

1


Input

6
105 119 105 119 105 119


Output

0


Input

4
1 1 1 1


Output

2
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: n is an even integer such that 2 <= n <= 100000, and v is a list of n integers where each integer v_i satisfies 1 <= v_i <= 100000.
def func():
    n = int(raw_input())
    v = map(int, raw_input().split())
    even = [vi for i, vi in enumerate(v) if i % 2 == 0]
    odd = [vi for i, vi in enumerate(v) if i % 2 == 1]
    evenc = collections.Counter(even)
    oddc = collections.Counter(odd)
    evenc_most_common = evenc.most_common(len(set(even))) + [(None, 0)]
    oddc_most_common = oddc.most_common(len(set(odd))) + [(None, 0)]
    m = []
    for i in range(2):
        for j in range(2):
            if evenc_most_common[i][0] != oddc_most_common[j][0]:
                a = len(even) - evenc_most_common[i][1]
                b = len(odd) - oddc_most_common[j][1]
                m.append(a + b)
        
    #State of the program after the  for loop has been executed: `n` is an even integer between 2 and 100000; `m` contains the sums of `len(even) - evenc_most_common[i][1]` and `len(odd) - oddc_most_common[j][1]` for each valid comparison of `evenc_most_common` and `oddc_most_common` where the first elements are not equal; `m` may have 0, 1, 2, or more elements depending on the comparisons made.
    print(min(m))
#Overall this is what the function does:The function accepts an even integer `n` (between 2 and 100,000) and a list `v` of `n` integers (each between 1 and 100,000). It separates the integers in `v` into even and odd indexed elements, counts the occurrences of each integer in both groups, and then calculates the minimum number of elements that need to be removed from `v` such that the most common integer in the even indexed elements is different from the most common integer in the odd indexed elements. The function finally prints this minimum value.
```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
