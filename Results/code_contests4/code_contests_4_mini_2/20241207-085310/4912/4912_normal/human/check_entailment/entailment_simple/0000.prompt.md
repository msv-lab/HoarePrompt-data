
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Rng is going to a festival.

The name of the festival is given to you as a string S, which ends with `FESTIVAL`, from input. Answer the question: "Rng is going to a festival of what?" Output the answer.

Here, assume that the name of "a festival of s" is a string obtained by appending `FESTIVAL` to the end of s. For example, `CODEFESTIVAL` is a festival of `CODE`.

Constraints

* 9 \leq |S| \leq 50
* S consists of uppercase English letters.
* S ends with `FESTIVAL`.

Input

Input is given from Standard Input in the following format:


S


Output

Print the answer to the question: "Rng is going to a festival of what?"

Examples

Input

CODEFESTIVAL


Output

CODE


Input

CODEFESTIVALFESTIVAL


Output

CODEFESTIVAL


Input

YAKINIKUFESTIVAL


Output

YAKINIKU
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#State of the program right berfore the function call: S is a string that consists of uppercase English letters, has a length between 9 and 50, and ends with the substring 'FESTIVAL'.
def func():
    n = int(input())
    s = input()
    res = []
    count = 0
    if (s[0] == '1') :
        one = 1
    else :
        one = 0
    #State of the program after the if-else block has been executed: *`S` is a string that consists of uppercase English letters, has a length between 9 and 50, and ends with the substring 'FESTIVAL'; `n` is an input integer; `s` is a new input string. If the first character of `s` is '1', then `one` is set to 1. Otherwise, `one` is set to 0. The list `res` remains empty, and `count` is 0 in both cases.
    temp = []
    tar = 0
    for i in range(1, n - 1):
        if s[i - 1:i + 2] == '101':
            tar = 1
            temp.append(one)
            one = 0
        else:
            if s[i] == '0' and tar == 1:
                temp.append(one)
                res.append(temp.copy())
                temp = []
                tar = 0
            if s[i] == '1':
                one += 1
            else:
                one = 0
        
    #State of the program after the  for loop has been executed: `S` is a string that consists of uppercase English letters, has a length between 9 and 50, and ends with the substring 'FESTIVAL'; `n` is greater than 1; `res` is a list of lists containing values of `one` that were recorded when the conditions were met; `temp` is an empty list if the last condition was met or the last recorded state before it was reset; `tar` is either 0 or 1 indicating whether the last processed substring matched '101'; `one` is the count of consecutive '1's encountered before the last reset.
    if (s[-1] == '1') :
        one += 1
    #State of the program after the if block has been executed: *`S` is a string that consists of uppercase English letters, has a length between 9 and 50, and ends with the substring 'FESTIVAL'; `n` is greater than 1; `res` is a list of lists containing values of `one` that were recorded when the conditions were met; `temp` is an empty list if the last condition was met or the last recorded state before it was reset; `tar` is either 0 or 1 indicating whether the last processed substring matched '101'; if the last character of `S` is '1', then `one` is increased by 1.
    if (tar == 1) :
        temp.append(one)
        res.append(temp.copy())
    #State of the program after the if block has been executed: *`S` is a string that consists of uppercase English letters, has a length between 9 and 50, and ends with the substring 'FESTIVAL'; `n` is greater than 1; if `tar` is 1, `res` is updated with a new entry, `temp` now contains the value of `one`, and `tar` remains 1 indicating that the last processed substring matched '101'.
    for x in res:
        temp = 0
        
        m = len(x)
        
        f = []
        
        if m == 2:
            temp = max(x[0], x[1])
        
        if m == 3:
            temp = max(x[0], x[1], x[2])
        
        if m == 4:
            temp = max(x[0] + x[2], x[3] + max(x[0], x[1]))
        
        if m >= 5:
            f.append([x[0], x[1]])
            f.append([x[1], max(x[2], x[0])])
            f.append(x[0] + x[2], x[3] + f[0])
            for i in range(3, m - 1):
                f.append(x[i] + max(f[i - 2][0], f[i - 3][0]))
                f.append(x[i + 1] + max(f[i - 2][0], f[i - 2][1]))
            temp = max(f[-1][0], f[-1][1], f[-2][0])
        
        count += temp
        
    #State of the program after the  for loop has been executed: `S` is a string that consists of uppercase English letters, has a length between 9 and 50, and ends with the substring 'FESTIVAL'; `n` is greater than 1; `tar` is 1; `res` contains at least an entry equal to the number of iterations; `count` is increased by the sum of all maximum values calculated from the entries in `res`; `temp` holds the last maximum value calculated; `m` is the length of the last processed entry in `res`; `f` contains updated entries based on the calculations from the loop.
    print(count)

```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
