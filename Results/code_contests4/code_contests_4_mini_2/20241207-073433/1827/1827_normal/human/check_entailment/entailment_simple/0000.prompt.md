
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: A direced graph is strongly connected if every two nodes are reachable from each other. In a strongly connected component of a directed graph, every two nodes of the component are mutually reachable.

Constraints

* 1 ≤ |V| ≤ 10,000
* 0 ≤ |E| ≤ 30,000
* 1 ≤ Q ≤ 100,000

Input

A directed graph G(V, E) and a sequence of queries where each query contains a pair of nodes u and v.


|V| |E|
s0 t0
s1 t1
:
s|E|-1 t|E|-1
Q
u0 v0
u1 v1
:
uQ-1 vQ-1


|V| is the number of nodes and |E| is the number of edges in the graph. The graph nodes are named with the numbers 0, 1,..., |V|-1 respectively.

si and ti represent source and target nodes of i-th edge (directed).

ui and vi represent a pair of nodes given as the i-th query.

Output

For each query, pinrt "1" if the given nodes belong to the same strongly connected component, "0" otherwise.

Example

Input

5 6
0 1
1 0
1 2
2 4
4 3
3 2
4
0 1
0 3
2 3
3 4


Output

1
0
1
1
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: frm is a list of pairs representing directed edges in a directed graph, where each pair consists of non-negative integers representing node indices, and to is a list of pairs representing queries, where each pair consists of non-negative integers representing node indices, with constraints 1 ≤ |V| ≤ 10,000, 0 ≤ |E| ≤ 30,000, and 1 ≤ Q ≤ 100,000.
def func_1(frm, to):
    g[frm].append(to)
    rg[to].append(frm)

#Function 2:
#State of the program right berfore the function call: now is an integer representing the current node in the graph, used is a set of integers representing the nodes that have been visited, and back_track is a list of integers representing the path taken during the traversal.
def func_2(now, used, back_track):
    used[now] = True
    for nx in g[now]:
        if not used[nx]:
            func_2(nx, used, back_track)
        
    #State of the program after the  for loop has been executed: `now` is the current node, `used` marks all reachable nodes from the starting node as visited, `back_track` remains unchanged.
    back_track.append(now)

#Function 3:
#State of the program right berfore the function call: now is an integer representing the current node, num_cmp is an integer representing the number of strongly connected components, used is a list of boolean values indicating whether each node has been visited, and cmp is a list of integers representing the component index of each node.
def func_3(now, num_cmp, used, cmp):
    used[now] = True
    cmp[now] = num_cmp
    for nx in rg[now]:
        if not used[nx]:
            func_3(nx, num_cmp, used, cmp)
        
    #State of the program after the  for loop has been executed: `now` is an integer representing the current node, `num_cmp` is an integer representing the number of strongly connected components, `used` is a list of boolean values with all nodes reachable from `now` set to True, `cmp` has updated `cmp` for all nodes reachable from `now` to `num_cmp`, and `rg[now]` contains all neighboring nodes of `now`.

#Function 4:
#State of the program right berfore the function call: n is a non-negative integer representing the number of nodes in a directed graph, and the function processes a list of directed edges and a sequence of queries on pairs of nodes (u, v) where 0 <= u, v < n. The number of edges must satisfy 0 <= |E| <= 30,000, and the number of queries Q must satisfy 1 ≤ Q ≤ 100,000.
def func_4(n):
    used = [False] * n
    back_track = []
    cmp = [-1] * n
    for v in xrange(n):
        if not used[v]:
            func_2(v, used, back_track)
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer; `used` is a list of length `n` where elements may be either `True` or `False` depending on whether `func_2` was called for the corresponding index; `back_track` is a list that may contain elements modified by `func_2`; `cmp` is a list of length `n` with all elements set to `-1` unless modified by `func_2`.
    used = [False] * n
    num_cmp = 0
    for v in back_track[::-1]:
        if not used[v]:
            func_3(v, num_cmp, used, cmp)
            num_cmp += 1
        
    #State of the program after the  for loop has been executed: `n` is a non-negative integer, `used` reflects which elements from `back_track` were processed, `cmp` is unchanged unless modified by `func_3`, `num_cmp` is the number of unprocessed elements from `back_track` that were not used.
    return num_cmp, cmp
    #The program returns the number of unprocessed elements from 'back_track' that were not used as 'num_cmp' and the value of 'cmp' which is unchanged unless modified by 'func_3'.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
