
You have been assigned the role of a program verifier. Your task is to determine the correctness of a given Python program based on the provided problem description and  the annotations in the code. If the program is correct, that is it meets the requirements in the problem description, print Correctness: **True**; otherwise, print  Correctness: **False**. Partially correct programs should be considered incorrect. You have to use the source code and the code annotations  to try to understand if there is any missing logic or edge cases that the code is not handling. 
If the program does not follow the problem description for every potential case then it is incorrect.Since if for at least one input or potential case the program does not work then Correctness **False**.
You are trying to find any potential case that the porgram does not does what the problem descriptions says. The annotations in the code summarise the state of the program and  might give you examples of some of the cases that the code is not working corectly.
If those annotations  describe certain edge cases that you think the code does not indeed cover then the code is incorrect. If you can't think of an example of the ocde not working as expected then the code is correct.
You need to strictly follow the format Correctness: **True or False**.

# Your task:
Problem description: Enough is enough. Too many times it happened that Vasya forgot to dispose of garbage and his apartment stank afterwards. Now he wants to create a garbage disposal plan and stick to it.

For each of next n days Vasya knows a_i — number of units of garbage he will produce on the i-th day. Each unit of garbage must be disposed of either on the day it was produced or on the next day. Vasya disposes of garbage by putting it inside a bag and dropping the bag into a garbage container. Each bag can contain up to k units of garbage. It is allowed to compose and drop multiple bags into a garbage container in a single day.

Being economical, Vasya wants to use as few bags as possible. You are to compute the minimum number of bags Vasya needs to dispose of all of his garbage for the given n days. No garbage should be left after the n-th day.

Input

The first line of the input contains two integers n and k (1 ≤ n ≤ 2⋅10^5, 1 ≤ k ≤ 10^9) — number of days to consider and bag's capacity. The second line contains n space separated integers a_i (0 ≤ a_i ≤ 10^9) — the number of units of garbage produced on the i-th day.

Output

Output a single integer — the minimum number of bags Vasya needs to dispose of all garbage. Each unit of garbage should be disposed on the day it was produced or on the next day. No garbage can be left after the n-th day. In a day it is allowed to compose and drop multiple bags.

Examples

Input

3 2
3 2 1


Output

3


Input

5 1
1000000000 1000000000 1000000000 1000000000 1000000000


Output

5000000000


Input

3 2
1 0 1


Output

2


Input

4 4
2 8 4 1


Output

4
Annotated Functions:
#Function 1:
#State of the program right berfore the function call: a is a list of integers representing the number of units of garbage produced each day, where each element is non-negative and satisfies 0 ≤ a[i] ≤ 10^9 for 0 <= i < len(a); k is a positive integer representing the maximum capacity of a bag, where 1 ≤ k ≤ 10^9.
def func_1(a, k):
    bags, carry = 0, 0
    for i in a:
        if carry != 0:
            bags += 1
            i = max(0, i - carry)
        
        bags += i // k
        
        carry = i % k
        
    #State of the program after the  for loop has been executed: `bags` is the total number of bags calculated from all items in `a`, `carry` is the remainder from the last item in `a` when divided by `k`, and `i` is no longer relevant outside of the loop context.
    if (carry != 0) :
        bags += 1
    #State of the program after the if block has been executed: *`bags` is the total number of bags calculated from all items in `a`, if `carry` is not equal to 0, then `bags` is incremented by 1. If `carry` is equal to 0, `bags` remains unchanged.
    return bags
    #The program returns the total number of bags, which is incremented by 1 if `carry` is not equal to 0, otherwise, it remains unchanged.
#Overall this is what the function does:The function accepts a list of non-negative integers `a`, each representing daily garbage production, and a positive integer `k`, representing the maximum capacity of a bag. It calculates the total number of bags needed to carry the garbage, where each bag can carry up to `k` units. If there's any leftover garbage after filling bags, it increments the total bag count by 1. The function correctly handles the case where the last day's garbage has a remainder, ensuring that it accounts for any leftover that doesn't fill a complete bag.

#Function 2:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 200,000), k is a positive integer (1 ≤ k ≤ 10^9), and a_i is a non-negative integer (0 ≤ a_i ≤ 10^9) for each day i (1 ≤ i ≤ n).
def func_2():
    _, k = map(int, input().split(' '))
    a = list(map(int, input().split(' ')))
    print(min(func_1(a, k), func_1(a[::-1], k)))
#Overall this is what the function does:The function accepts two integers `k` and a list of integers `a`, which represents some data over `n` days. It calculates the minimum result of a function `func_1` applied to the list `a` and its reverse, with `k` as an additional parameter. It does not explicitly return a value but prints the minimal result. The behavior of `func_1` is not specified, so the exact effect of this function on the output is unknown. The function does not handle any errors or edge cases directly related to input validation, such as ensuring `a` contains exactly `n` elements.




I want you to try to see if the code (including all the functions) does what the problem description says. The code must follow the problem description for it to be correct!!
You can also use the code annotations to understand the code better. Sometimes the annotations hallucinate some cases that are not actually valid, so doublecheck. Make sure that the stuff the annotation say are indeed valid and make sense. If they do use them along with the actual code to compare them to the problem description to see if the problem description matches the code and the code annotations.
Does the code follow the problem description for every potential case?
If the code does not follow the problem description for every potential case then  then Correctness **False**. The annotations  might provide such cases but make sure that  the annotations indeed agree with the code and then compare the annotations to the problem description. Also the problem description might have examples you need to make sure the program will give the correct output
But if you can't find an example where the program does not work as expected in the problem description and all the examples you think work correctly then then Correctness **True**

You need to strictly follow the format Correctness: **True or False**. Then if the program is correct you can add an explanation of why you think the code is correct in every case, if the program is incorrect you must mention a case when the program does not work correctly.