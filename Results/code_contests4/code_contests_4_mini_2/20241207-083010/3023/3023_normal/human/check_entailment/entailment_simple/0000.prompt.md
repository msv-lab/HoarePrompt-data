
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There are N balls in a two-dimensional plane. The i-th ball is at coordinates (x_i, y_i).

We will collect all of these balls, by choosing two integers p and q such that p \neq 0 or q \neq 0 and then repeating the following operation:

* Choose a ball remaining in the plane and collect it. Let (a, b) be the coordinates of this ball. If we collected a ball at coordinates (a - p, b - q) in the previous operation, the cost of this operation is 0. Otherwise, including when this is the first time to do this operation, the cost of this operation is 1.



Find the minimum total cost required to collect all the balls when we optimally choose p and q.

Constraints

* 1 \leq N \leq 50
* |x_i|, |y_i| \leq 10^9
* If i \neq j, x_i \neq x_j or y_i \neq y_j.
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


N
x_1 y_1
:
x_N y_N


Output

Print the minimum total cost required to collect all the balls.

Examples

Input

2
1 1
2 2


Output

1


Input

3
1 4
4 6
7 8


Output

1


Input

4
1 1
1 2
2 1
2 2


Output

2
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: N is an integer such that 1 <= N <= 50, and each ball's coordinates (x_i, y_i) are distinct integers with |x_i|, |y_i| <= 10^9 for i from 1 to N.
def func_1():
    N = read_int()
    balls = []
    for _ in range(N):
        balls.append(read_int_array())
        
    #State of the program after the  for loop has been executed: `N` is an integer such that 1 <= `N` <= 50; `balls` contains `N` arrays of integers collected from `read_int_array()`.
    func_8(func_2(N, balls))

#Function 2:
#State of the program right berfore the function call: n is a positive integer (1 <= n <= 50) representing the number of balls, and balls is a list of n tuples, where each tuple contains two integers (x_i, y_i) representing the coordinates of the i-th ball, with |x_i|, |y_i| <= 10^9.
def func_2(n, balls):
    bdict = collections.defaultdict(set)
    for (x, y) in balls:
        bdict[x].add(y)
        
    #State of the program after the  for loop has been executed: `n` is a positive integer (1 <= n <= 50); `balls` is a list of n tuples containing two integers each; `bdict` maps each unique first element `x` from the tuples in `balls` to a set containing all corresponding second elements `y` from those tuples; there are `n` iterations of the loop, processing all tuples in `balls`.
    tried = set()
    ans = n
    for i in range(n):
        for j in range(i):
            p, q = balls[j][0] - balls[i][0], balls[j][1] - balls[i][1]
            if (p, q) not in tried:
                tried.add((p, q))
                tried.add((-p, -q))
                points = score(p, q)
                if points < ans:
                    ans = points
        
    #State of the program after the  for loop has been executed: `n` is a positive integer (1 <= n <= 50), `ans` is the minimum score obtained from all processed differences, `tried` contains all unique pairs of differences `(p, q)` and their negations that were processed during the entire loop execution.
    return ans
    #The program returns the minimum score `ans` obtained from all processed differences.

#Function 3:
#State of the program right berfore the function call: p and q are integers such that at least one of them is non-zero, and there are N balls with coordinates (x_i, y_i) where 1 <= N <= 50 and |x_i|, |y_i| <= 10^9 for each ball.
def score(p, q):
    out = n
    for (x, y) in balls:
        nx, ny = x + p, y + q
        
        if ny in bdict.get(nx, []):
            out -= 1
        
    #State of the program after the  for loop has been executed: `out` is equal to `N` minus the count of occurrences where `ny` is found in the list associated with `nx` in `bdict` for all pairs `(x, y)` in `balls`; `nx` is `x + p`, `ny` is `y + q` for each pair in `balls`.
    return out
    #The program returns the value of 'out', which is equal to N minus the count of occurrences where 'ny' is found in the list associated with 'nx' in 'bdict' for all pairs '(x, y)' in 'balls'

#Function 4:
#State of the program right berfore the function call: N is an integer such that 1 ≤ N ≤ 50, and each ball's coordinates (x_i, y_i) are integers with |x_i|, |y_i| ≤ 10^9, where i = 1, 2, ..., N.
def func_3():
    if (False and 'PYCHARM_HOSTED' in os.environ) :
        func_4()
    else :
        func_1()
    #State of the program after the if-else block has been executed: *`N` is an integer such that 1 ≤ `N` ≤ 50, and each ball's coordinates (`x_i`, `y_i`) are integers with |`x_i`|, |`y_i`| ≤ 10^9 for `i` = 1, 2, ..., `N`. Since the condition for the if block is false, the function `func_1()` is called instead of `func_4()`, leaving the output unchanged in terms of the conditions stated.

#Function 5:
#State of the program right berfore the function call: N is an integer such that 1 <= N <= 50, and each ball's coordinates (x_i, y_i) are integers where |x_i|, |y_i| <= 10^9, with all (x_i, y_i) being distinct pairs.
def func_4():
    solution = solve
    test_inputs = None
    test_outputs = None
    judge = None
    slow_solution = None
    if (solution is not None) :
        if (test_outputs is not None) :
            func_5(solution, test_inputs, test_outputs)
        #State of the program after the if block has been executed: *`N` is an integer such that 1 <= `N` <= 50; each ball's coordinates (`x_i`, `y_i`) are integers where |`x_i`|, |`y_i`| <= 10^9, with all (`x_i`, `y_i`) being distinct pairs; `solution` is assigned the value of `solve` and is not None; `test_inputs` is None; `test_outputs` is not None; `judge` is None; `slow_solution` is None; if `test_outputs` is not None, the function `func_5` is called with arguments (`solution`, `test_inputs`, `test_outputs`).
        if (judge is not None) :
            func_6(solution, test_inputs, judge)
        #State of the program after the if block has been executed: *`N` is an integer such that 1 <= `N` <= 50; each ball's coordinates (`x_i`, `y_i`) are integers where |`x_i`|, |`y_i`| <= 10^9, with all (`x_i`, `y_i`) being distinct pairs; `solution` is assigned the value of `solve` and is not None; `test_inputs` is None; `test_outputs` is not None; `judge` is not None; `slow_solution` is None; if `judge` is not None, `func_6` has been called with arguments (`solution`, `test_inputs`, `judge`).
        if (slow_solution is not None) :
            func_7(solution, test_inputs, slow_solution)
        #State of the program after the if block has been executed: *`N` is an integer such that 1 <= `N` <= 50; each ball's coordinates (`x_i`, `y_i`) are integers where |`x_i`|, |`y_i`| <= 10^9, with all (`x_i`, `y_i`) being distinct pairs; `solution` is assigned the value of `solve` and is not None; `test_inputs` is None; `test_outputs` is not None; `judge` is not None; `slow_solution` is not None; `func_6` has been called with arguments (`solution`, `test_inputs`, `judge`); and `func_7` has been called with arguments (`solution`, `test_inputs`, `slow_solution`).
    #State of the program after the if block has been executed: *`N` is an integer such that 1 <= `N` <= 50; each ball's coordinates (`x_i`, `y_i`) are integers where |`x_i`|, |`y_i`| <= 10^9, with all (`x_i`, `y_i`) being distinct pairs. If `solution` is not None, then `solution` is assigned the value of `solve`, `test_inputs` is None, `test_outputs` is not None, `judge` is not None, `slow_solution` is not None, `func_6` has been called with arguments (`solution`, `test_inputs`, `judge`), and `func_7` has been called with arguments (`solution`, `test_inputs`, `slow_solution`).

#Function 6:
#State of the program right berfore the function call: solution is an integer representing the minimum total cost required to collect all balls, inputs_answers is a list of tuples where each tuple contains two integers representing the coordinates (x_i, y_i) of the balls, and the length of inputs_answers is an integer N such that 1 <= N <= 50.
def func_5(solution, inputs_answers):
    total, wrong = 0, 0
    for (args, test_ans) in inputs_answers:
        ans = solution(*args.copy())
        
        if ans != test_ans:
            func_8('WRONG! ans=%s, test_ans=%s, args=%s' % (ans, test_ans, args))
            wrong += 1
        else:
            func_8('GOOD')
        
        total += 1
        
    #State of the program after the  for loop has been executed: `solution` is an integer representing the minimum total cost required to collect all balls, `total` is the number of tuples in `inputs_answers`, `wrong` is the count of incorrect answers, `inputs_answers` is the original list of tuples.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 7:
#State of the program right berfore the function call: N is an integer such that 1 <= N <= 50, and each ball's coordinates (x_i, y_i) are integers with |x_i|, |y_i| <= 10^9. Additionally, all coordinates are distinct.
def func_6(solution, inputs_gen, judge):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        if not judge(deepcopy(ans), *deepcopy(args)):
            func_8('WRONG! ans=%s, args=%s' % (ans, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: `N` is an integer such that 1 <= `N` <= 50; `total` is equal to the number of items processed from `inputs_gen`; `wrong` is equal to the count of incorrect answers; `args` is the last item yielded by `inputs_gen` (if any); `ans` is assigned the value of `solution(*deepcopy(args))` for the last item processed (if any).
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 8:
#State of the program right berfore the function call: solution is a callable that takes in an integer N (1 ≤ N ≤ 50) representing the number of balls, followed by N pairs of integers (x_i, y_i) with |x_i|, |y_i| ≤ 10^9, where each pair represents the coordinates of a ball in a two-dimensional plane. The pairs (x_i, y_i) are distinct. inputs_gen and solution_slow are callable functions relevant to the problem context.
def func_7(solution, inputs_gen, solution_slow):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        slow = solution_slow(*deepcopy(args))
        
        if ans != slow:
            func_8('WRONG! ans=%s, slow=%s, args=%s' % (ans, slow, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is the number of elements in `inputs_gen`, `wrong` is the number of discrepancies between `ans` and `slow`.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 9:
#State of the program right berfore the function call: N is an integer such that 1 <= N <= 50, and each ball's coordinates (x_i, y_i) are integers with |x_i|, |y_i| <= 10^9, where all coordinate pairs (x_i, y_i) are distinct.
def func_8():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `N` is an integer such that 1 <= `N` <= 50, `args` contains at least `N` elements, `at_start` is False; `sep` is written to the file before each element except the first, and all elements of `args` have been written to the file as strings.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`N` is an integer such that 1 <= `N` <= 50; `args` contains at least `N` elements; `at_start` is False; `sep` has been written to the file before each element except the first; a value from `kwargs` associated with 'end' has been written to the file, or a newline character has been written if 'end' was not present; if the value associated with 'flush' in `kwargs` was True, it has been removed, and the file has been flushed to ensure all data is written to it.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
