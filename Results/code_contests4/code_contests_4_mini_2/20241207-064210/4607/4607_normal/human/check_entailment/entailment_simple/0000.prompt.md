
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Everybody knows what an arithmetic progression is. Let us remind you just in case that an arithmetic progression is such sequence of numbers a1, a2, ..., an of length n, that the following condition fulfills: 

a2 - a1 = a3 - a2 = a4 - a3 = ... = ai + 1 - ai = ... = an - an - 1.

For example, sequences [1, 5], [10], [5, 4, 3] are arithmetic progressions and sequences [1, 3, 2], [1, 2, 4] are not.

Alexander has n cards containing integers. Arthur wants to give Alexander exactly one more card with a number so that he could use the resulting n + 1 cards to make an arithmetic progression (Alexander has to use all of his cards).

Arthur has already bought a card but he hasn't written a number on it. Help him, print all integers that you can write on a card so that the described condition fulfilled.

Input

The first line contains integer n (1 ≤ n ≤ 105) — the number of cards. The next line contains the sequence of integers — the numbers on Alexander's cards. The numbers are positive integers, each of them doesn't exceed 108.

Output

If Arthur can write infinitely many distinct integers on the card, print on a single line -1.

Otherwise, print on the first line the number of integers that suit you. In the second line, print the numbers in the increasing order. Note that the numbers in the answer can exceed 108 or even be negative (see test samples).

Examples

Input

3
4 1 7


Output

2
-2 10


Input

1
10


Output

-1


Input

4
1 3 5 9


Output

1
7


Input

4
4 3 4 5


Output

0


Input

2
2 4


Output

3
0 3 6
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 100000, and the sequence of integers on the cards is a list of positive integers, each of which does not exceed 10^8.
def func_1():
    return int(input())
    #The program returns a positive integer entered by the user that is within the range of 1 to 100000.

#Function 2:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_2():
    return input()
    #The program returns the input value which is a sequence of integers on Alexander's cards, all being positive integers not exceeding 10^8.

#Function 3:
#State of the program right berfore the function call: n is an integer in the range 1 ≤ n ≤ 10^5, and the sequence of integers on the cards consists of positive integers, each not exceeding 10^8.
def func_3():
    return map(int, input().strip().split(' '))
    #The program returns a map object of integers from the input sequence of positive integers, each not exceeding 10^8.

#Function 4:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5) representing the number of cards, and the sequence of integers on the cards consists of positive integers that do not exceed 10^8.
def func_4():
    return map(str, input().strip().split(' '))
    #The program returns a map object containing the string representations of the input integers that are provided as a space-separated sequence.

#Function 5:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards consists of positive integers, each not exceeding 10^8.
def func_5():
    return list(func_3())
    #The program returns a list generated by func_3(), which processes a sequence of positive integers based on the constraints that n is a positive integer (1 ≤ n ≤ 10^5) and each integer on Alexander's cards does not exceed 10^8.

#Function 6:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers contains n positive integers, each not exceeding 10^8.
def func_6():
    sys.setrecursionlimit(100000000)
    threading.stack_size(40960000)
    thread = threading.Thread(target=main)
    thread.start()

#Function 7:
#State of the program right berfore the function call: item is a tuple where the first element is an integer n (1 ≤ n ≤ 10^5) representing the number of cards, and the second element is a list of n positive integers, each not exceeding 10^8.
def func_7(item):
    return item[1]
    #The program returns the list of n positive integers from the second element of the tuple 'item'

#Function 8:
#State of the program right berfore the function call: l is a list of integers where the first element is a positive integer n (1 ≤ n ≤ 10^5), followed by n positive integers, each not exceeding 10^8.
def func_8(l):
    return sorted(l, key=getKey)
    #The program returns the list 'l' sorted based on the criteria defined in the function 'getKey'

#Function 9:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5), m is a list of integers containing n positive integers, each of which does not exceed 10^8.
def func_9(n, m, num):
    return [[num for x in range(m)] for y in range(n)]
    #The program returns a 2D list where each inner list contains the integers from list 'm', repeated 'n' times.

#Function 10:
#State of the program right berfore the function call: x is a list of integers representing the numbers on Alexander's cards, where 1 ≤ len(x) ≤ 105 and each integer in x is a positive integer not exceeding 10^8.
def func_10(x):
    return x and not x & x - 1
    #The program returns the list of integers in x and the result of the expression 'not x & (x - 1)' evaluated as a boolean value

#Function 11:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 10^5) representing the number of cards, and the sequence of integers on the cards is a list of positive integers, each not exceeding 10^8.
def func_11(n):
    return bin(n).replace('0b', '')
    #The program returns the binary representation of the positive integer n, without the '0b' prefix.

#Function 12:
#State of the program right berfore the function call: n is a positive integer (1 ≤ n ≤ 100,000), and the sequence of integers consists of positive integers not exceeding 10^8.
def func_12(n):
    return [int(i) for i in str(n)]
    #The program returns a list of the digits of the positive integer n

#Function 13:
#State of the program right berfore the function call: x is an integer representing the number of cards (1 ≤ x ≤ 10^5), y is a list of integers representing the numbers on the cards, where each integer is a positive integer not exceeding 10^8, and p is a placeholder for the number that Arthur can write on the card to form an arithmetic progression.
def func_13(x, y, p):
    res = 1
    x %= p
    while y > 0:
        if y & 1:
            res = res * x % p
        
        y = y >> 1
        
        x = x * x % p
        
    #State of the program after the loop has been executed: `y` is 0 (after all iterations of the loop), `x` is updated to `x * x % p` for each iteration, and `res` contains the product of all `x` values multiplied together based on the bits of the initial `y` value that were set to 1, modulo `p`.
    return res
    #The program returns the product of all 'x' values multiplied together based on the bits of the initial 'y' value that were set to 1, modulo 'p'

#Function 14:
#State of the program right berfore the function call: x is an integer representing the number of cards (1 ≤ x ≤ 10^5) and y is a list of integers representing the numbers on Alexander's cards, where each integer is a positive integer not exceeding 10^8.
def func_14(x, y):
    while y:
        x, y = y, x % y
        
    #State of the program after the loop has been executed: `y` is 0, `x` is the greatest common divisor (GCD) of the original list of integers in `y`.
    return x
    #The program returns the greatest common divisor (GCD) of the original list of integers in variable 'y', which is currently 0.

#Function 15:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers, each of which does not exceed 10^8.
def func_15(n):
    if (n <= 1) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ n ≤ 10^5 and n is greater than 1, and the sequence of integers on Alexander's cards is a list of positive integers, each of which does not exceed 10^8.
    if (n <= 3) :
        return True
        #The program returns True
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ n ≤ 10^5 and n is greater than 3, and the sequence of integers on Alexander's cards is a list of positive integers, each of which does not exceed 10^8.
    if (n % 2 == 0 or n % 3 == 0) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *`n` is a positive integer such that 1 ≤ n ≤ 10^5 and n is greater than 3, and the sequence of integers on Alexander's cards is a list of positive integers, each of which does not exceed 10^8. `n` is not divisible by 2 and is not divisible by 3.
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        
        i = i + 6
        
    #State of the program after the loop has been executed: `n` is a positive integer greater than 3 and at least 25; `i` is increased by 6 for each iteration until `i * i` exceeds `n`. The final value of `i` is the last incremented value exceeding the square root of `n`.
    return True
    #The program returns True, indicating that the condition has been successfully met.

#Function 16:
#State of the program right berfore the function call: n is a positive integer such that 1 ≤ n ≤ 100000, and the sequence of integers consists of positive integers where each integer does not exceed 100000000.
def func_16():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

#Function 17:
#State of the program right berfore the function call: n is an integer such that 1 ≤ n ≤ 10^5, and the sequence of integers on Alexander's cards is a list of positive integers, each not exceeding 10^8.
def func_17():
    n = func_1()
    a = func_5()
    a.sort()
    if (n == 1) :
        func_18(-1)
        exit()
    #State of the program after the if block has been executed: *`n` is assigned the value returned by `func_1()`, `a` is sorted. If `n` equals 1, `func_18(-1)` is called, but the values of the variables do not change, and the program exits.
    if (n == 2) :
        if (a[0] == a[1]) :
            func_18(1)
            func_18(a[0])
            exit()
        #State of the program after the if block has been executed: *`n` is assigned the value returned by `func_1()`, `a` is a sorted list, and `n` equals 2. If `a[0]` is equal to `a[1]`, the program is terminated by the exit command. If `n` equals 1, `func_18(-1)` is called, but the values of the variables do not change, and the program exits.
        l = []
        g = a[1] - a[0]
        if (abs(g) % 2 == 0) :
            l.append(a[0] + g // 2)
        #State of the program after the if block has been executed: *`n` equals 2, `a` is a sorted list, `l` contains one element which is `a[0] + g // 2` if the absolute value of `g` is even.
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[1] + (a[1] - a[0]))
        l.sort()
        l = list(set(l))
        func_18(len(l))
        func_18(*l)
        exit()
    #State of the program after the if block has been executed: *`n` is assigned the value returned by `func_1()`, and `a` is a sorted list. If `n` equals 2, `l` is sorted based on its previous elements including the value `2 * a[1] - a[0]` and duplicates have been removed from `l`, then `func_18` is called with the length of `l`, and the program execution is terminated with exit(). If `n` is not 2, the program does not change the values of the variables and exits.
    g = []
    l = []
    for i in range(n - 1):
        g.append(a[i + 1] - a[i])
        
        l.append(abs(a[i + 1] - a[i]))
        
    #State of the program after the  for loop has been executed: `n` is a positive integer, `g` contains `n - 1` elements representing the differences between consecutive elements of `a`, `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`, `a` is a sorted list with at least `n` elements.
    if (len(list(set(g))) > 2) :
        func_18(0)
        exit()
    #State of the program after the if block has been executed: *`n` is a positive integer, `g` contains `n - 1` elements representing the differences between consecutive elements of `a`, `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`, `a` is a sorted list with at least `n` elements. If the number of unique elements in `g` is greater than 2, the program terminates.
    if (len(list(set(g))) == 1) :
        l = []
        l.append(a[0] - (a[1] - a[0]))
        l.append(a[-1] + (a[1] - a[0]))
        l = list(set(l))
        l.sort()
        func_18(len(l))
        func_18(*l)
    else :
        if (0 in l) :
            if (len(list(set(g))) >= 2) :
                func_18(0)
                exit()
            #State of the program after the if block has been executed: *`n` is a positive integer, `g` contains `n - 1` elements representing the differences between consecutive elements of `a`, `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`, `a` is a sorted list with at least `n` elements, the number of unique elements in `g` is greater than 1, and 0 is an element in `l`. If the length of the set of unique elements in `g` is at least 2, then `func_18` has been called with an argument of 0 and the program exits. Otherwise, the program continues executing without any specific action defined for the else case.
        #State of the program after the if block has been executed: *`n` is a positive integer, `g` contains `n - 1` elements representing the differences between consecutive elements of `a`, `l` contains `n - 1` elements representing the absolute differences between consecutive elements of `a`, `a` is a sorted list with at least `n` elements, the number of unique elements in `g` is greater than 1. If 0 is an element in `l`, `func_18` has been called with an argument of 0 and the program exits. Otherwise, the program continues executing without any specific action defined for the else case.
        gc = l[0]
        for i in range(1, len(l)):
            gc = func_14(gc, l[i])
            
        #State of the program after the  for loop has been executed: `n` is greater than 2, `gc` is assigned the value returned by `func_14` applied cumulatively to the elements of `l` from index 0 to `len(l) - 1`.
        for i in range(n - 1):
            if abs(a[i + 1] - a[i]) != gc:
                x = a[i] + (a[i + 1] - a[i]) // 2
                a.append(a[i] + (a[i + 1] - a[i]) // 2)
                break
            
        #State of the program after the  for loop has been executed: `n` is greater than 2, `a` may have one additional element appended based on the condition, and `gc` remains unchanged.
        a.sort()
        l = []
        for i in range(n):
            l.append(a[i + 1] - a[i])
            
        #State of the program after the  for loop has been executed: `n` is greater than 2; `i` is `n-1`; `l` contains `n-1` elements, which are the differences between consecutive elements of `a`, specifically `a[1] - a[0], a[2] - a[1], ..., a[n-1] - a[n-2]`.
        if (len(list(set(l))) == 1) :
            func_18(1)
            func_18(x)
        else :
            func_18(0)
        #State of the program after the if-else block has been executed: *`n` is greater than 2; `i` is `n-1`; `l` contains `n-1` elements, which are the differences between consecutive elements of `a`. If all elements in `l` are equal, the function `func_18(1)` is called. Otherwise, the function `func_18(0)` is called.
    #State of the program after the if-else block has been executed: *`n` is a positive integer and `g` contains `n - 1` elements representing the differences between consecutive elements of `a`, where `l` is sorted and `a` is a sorted list with at least `n` elements. If the number of unique elements in `g` is 1, `func_18` is executed with the unpacked elements of `l`. If `n` is greater than 2 and all elements in `l` are equal, `func_18(1)` is called; otherwise, `func_18(0)` is called.

#Function 18:
#State of the program right berfore the function call: The first input is an integer n (1 ≤ n ≤ 10^5), representing the number of cards. The second input is a list of n positive integers, each of which does not exceed 10^8.
def func_18():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `n` is an integer representing the number of cards, `args` is an iterable containing elements, `file` contains the string representations of all elements in `args`, separated by `sep`, and `at_start` is False.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`n` is an integer representing the number of cards, `args` is an iterable containing elements, `file` contains the string representations of all elements in `args`, separated by `sep`, and `at_start` is False. If the `flush` keyword argument is true, the file's buffer has been flushed. There is no other action taken in the else part.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
