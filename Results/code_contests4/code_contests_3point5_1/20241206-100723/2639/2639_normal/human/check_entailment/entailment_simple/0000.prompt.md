
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: Write a program which performs the following operations to a binary search tree $T$ by adding the find operation to A: Binary Search Tree I.

* insert  $k$: Insert a node containing $k$ as key into $T$.
* find $k$: Report whether $T$ has a node containing $k$.
* print: Print the keys of the binary search tree by inorder tree walk and preorder tree walk respectively.

Constraints

* The number of operations $\leq 500,000$
* The number of print operations $\leq 10$.
* $-2,000,000,000 \leq key \leq 2,000,000,000$
* The height of the binary tree does not exceed 100 if you employ the above pseudo code.
* The keys in the binary search tree are all different.

Input

In the first line, the number of operations $m$ is given. In the following $m$ lines, operations represented by insert $k$, find $k$ or print are given.

Output

For each find $k$ operation, print "yes" if $T$ has a node containing $k$, "no" if not.

In addition, for each print operation, print a list of keys obtained by inorder tree walk and preorder tree walk in a line respectively. Put a space character before each key.

Example

Input

10
insert 30
insert 88
insert 12
insert 1
insert 20
find 12
insert 17
insert 25
find 16
print


Output

yes
no
 1 12 17 20 25 30 88
 30 12 1 20 17 25 88
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: m is a non-negative integer representing the number of operations. Each operation is represented by insert k, find k, or print. k is an integer such that -2,000,000,000 <= k <= 2,000,000,000.**
def func_1(top, z):
    y = None
    x = top
    while isinstance(x, Node):
        y = x
        
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
        
    #State of the program after the loop has been executed: `x`, `y`, `z` are instances of Node. After the loop finishes, `x` will not be an instance of Node as the loop will terminate when `x` is not an instance of Node. `y` will hold the last instance of Node before `x` is not an instance of Node anymore.
    z.parent = y
    if (y is None) :
        top = z
    else :
        if (z.key < y.key) :
            y.left = z
        else :
            y.right = z
        #State of the program after the if-else block has been executed: *After the execution of the code block, `x` is no longer an instance of Node. `y` holds the last instance of Node before `x` is not an instance of Node anymore. `z.parent` is assigned the value of `y`. `y` is not None. If `z.key` is less than `y.key`, `y.left` is assigned the value of `z` and `y.left` now points to the instance of Node `z`. If `z.key` is not less than `y.key`, `y.right` is assigned the value of `z`.
    #State of the program after the if-else block has been executed: *After the execution of the code block, `x` is no longer an instance of Node. `y` holds the last instance of Node before `x` is not an instance of Node anymore. `z.parent` is assigned the value of `y`. If `y` is None, `top` is assigned the value of `z`. If `y` is not None, and `z.key` is less than `y.key`, then `y.left` is assigned the value of `z` and `y.left` now points to the instance of Node `z`. If `z.key` is not less than `y.key`, `y.right` is assigned the value of `z`.
    return top
    #The program returns the value of 'top' after the specified operations on 'x', 'y', and 'z'.

#Function 2:
#State of the program right berfore the function call: m is a non-negative integer representing the number of operations. Each operation is represented by insert k, find k, or print where k is an integer such that -2,000,000,000 <= k <= 2,000,000,000.**
def func_2(node, key):
    if (not node) :
        return False
        #The program returns False
    #State of the program after the if block has been executed: *m is a non-negative integer representing the number of operations. Each operation is represented by insert k, find k, or print where k is an integer such that -2,000,000,000 <= k <= 2,000,000,000. node is not empty
    if (node.key == key) :
        return True
        #The program returns True if the node's key is equal to the key, otherwise it returns False
    #State of the program after the if block has been executed: *m is a non-negative integer representing the number of operations. Each operation is represented by insert k, find k, or print where k is an integer such that -2,000,000,000 <= k <= 2,000,000,000. node is not empty. node.key is not equal to key
    if (key < node.key) :
        return func_2(node.left, key)
        #The program returns the result of recursively calling func_2 on the left child of node with the key value
    #State of the program after the if block has been executed: *m is a non-negative integer representing the number of operations. Each operation is represented by insert k, find k, or print where k is an integer such that -2,000,000,000 <= k <= 2,000,000,000. node is not empty. node.key is not equal to key. The key is greater than or equal to node.key
    return func_2(node.right, key)
    #The program returns the result of calling func_2 on the right child of node with the key provided

#Function 3:
#State of the program right berfore the function call: **m is a non-negative integer representing the number of operations. Each operation is represented by insert k, find k, or print. k is an integer where -2,000,000,000 <= k <= 2,000,000,000.**
def func_3(node):
    if node.left :
        func_3(node.left)
    #State of the program after the if block has been executed: *m is a non-negative integer representing the number of operations. If node.left exists, the program performs certain operations based on the condition of the node.left. Otherwise, there are no operations performed.
    print('', node.key, end='')
    if node.right :
        func_3(node.right)
    #State of the program after the if block has been executed: *m is a non-negative integer representing the number of operations. If node.left exists, the program performs certain operations based on the condition of the node.left. Otherwise, there are no operations performed. If node.right exists, the program performs certain operations based on the condition of the node.right.

#Function 4:
#State of the program right berfore the function call: **
def func_4(node):
    print('', node.key, end='')
    if node.left :
        func_4(node.left)
    #State of the program after the if block has been executed: *the program prints an empty space followed by the value of `node.key`. If `node.left` is true, the function continues with the left child node. Otherwise, the function terminates.
    if node.right :
        func_4(node.right)
    #State of the program after the if block has been executed: *the program prints an empty space followed by the value of `node.key`. If `node.left` is true, the function continues with the left child node. Otherwise, the function terminates. If `node.right` is true, the function continues with the right child node.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
