
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: There are N balls in a two-dimensional plane. The i-th ball is at coordinates (x_i, y_i).

We will collect all of these balls, by choosing two integers p and q such that p \neq 0 or q \neq 0 and then repeating the following operation:

* Choose a ball remaining in the plane and collect it. Let (a, b) be the coordinates of this ball. If we collected a ball at coordinates (a - p, b - q) in the previous operation, the cost of this operation is 0. Otherwise, including when this is the first time to do this operation, the cost of this operation is 1.



Find the minimum total cost required to collect all the balls when we optimally choose p and q.

Constraints

* 1 \leq N \leq 50
* |x_i|, |y_i| \leq 10^9
* If i \neq j, x_i \neq x_j or y_i \neq y_j.
* All values in input are integers.

Input

Input is given from Standard Input in the following format:


N
x_1 y_1
:
x_N y_N


Output

Print the minimum total cost required to collect all the balls.

Examples

Input

2
1 1
2 2


Output

1


Input

3
1 4
4 6
7 8


Output

1


Input

4
1 1
1 2
2 1
2 2


Output

2
This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
#Function 1:
#State of the program right berfore the function call: **
def func_1():
    N = read_int()
    balls = []
    for _ in range(N):
        balls.append(read_int_array())
        
    #State of the program after the  for loop has been executed: N is greater than 0, balls contains N arrays of integers
    func_8(func_2(N, balls))

#Function 2:
#State of the program right berfore the function call: **
def func_2(n, balls):
    bdict = collections.defaultdict(set)
    for (x, y) in balls:
        bdict[x].add(y)
        
    #State of the program after the  for loop has been executed: `bdict` is a defaultdict of sets with keys as all unique values of `x` from balls and values as sets containing all unique values of `y` corresponding to each `x` in balls.
    tried = set()
    ans = n
    for i in range(n):
        for j in range(i):
            p, q = balls[j][0] - balls[i][0], balls[j][1] - balls[i][1]
            if (p, q) not in tried:
                tried.add((p, q))
                tried.add((-p, -q))
                points = score(p, q)
                if points < ans:
                    ans = points
        
    #State of the program after the  for loop has been executed: `bdict` is a defaultdict of sets with keys as all unique values of `x` from `balls` and values as sets containing all unique values of `y` corresponding to each `x` in `balls`; `tried` is a set containing all unique tuples `(p, q)` where `(p, q)` is added as well as `(-p, -q)` for all unique combinations of differences between elements of `balls[j]` and `balls[i]`; `ans` is the minimum score obtained from all combinations of differences between elements of `balls[j]` and `balls[i]`; `i` is `n-1`, `n` is greater than 0 and satisfies the loop condition, `j` is `i-1`, `p` and `q` are the differences between the last elements of `balls[j]` and `balls[i]` respectively for the last iteration; `points` is the score obtained from the last combination of differences.
    return ans
    #The program returns the minimum score obtained from all combinations of differences between elements of balls[j] and balls[i]

#Function 3:
#State of the program right berfore the function call: **
def score(p, q):
    out = n
    for (x, y) in balls:
        nx, ny = x + p, y + q
        
        if ny in bdict.get(nx, []):
            out -= 1
        
    #State of the program after the  for loop has been executed: `out` is the value of `n` minus the number of times `ny` is in the list retrieved from `bdict` using `nx` as key for all tuples in `balls`, `balls` is a non-empty iterable, `x` and `y` are assigned values from the last tuple in `balls`, `nx` is the sum of `x` and `p`, `ny` is the sum of `y` and `q`.
    return out
    #The program returns the value of 'out', which is calculated as the value of 'n' minus the number of times 'ny' appears in the list retrieved from 'bdict' using 'nx' as the key for all tuples in 'balls'. 'balls' is a non-empty iterable where 'x' and 'y' are assigned values from the last tuple. 'nx' is the sum of 'x' and 'p', 'ny' is the sum of 'y' and 'q'.

#Function 4:
#State of the program right berfore the function call: N is a positive integer. x_i and y_i are integers representing the coordinates of the i-th ball.**
def func_3():
    if (False and 'PYCHARM_HOSTED' in os.environ) :
        func_4()
    else :
        func_1()
    #State of the program after the if-else block has been executed: *N is a positive integer. x_i and y_i are integers representing the coordinates of the i-th ball. The condition (False and 'PYCHARM_HOSTED' in os.environ) is always false.

#Function 5:
#State of the program right berfore the function call: **
def func_4():
    solution = solve
    test_inputs = None
    test_outputs = None
    judge = None
    slow_solution = None
    if (solution is not None) :
        if (test_outputs is not None) :
            func_5(solution, test_inputs, test_outputs)
        #State of the program after the if block has been executed: *`solution` is `solve`, `test_inputs` is `None`, `test_outputs` is not `None`, `judge` is `None`, `slow_solution` is `None`, and `solution` is not `None`
        if (judge is not None) :
            func_6(solution, test_inputs, judge)
        #State of the program after the if block has been executed: *`solution` is `solve`, `test_inputs` is `None`, `test_outputs` is not `None`, `judge` is `None`, `slow_solution` is `None`, and `solution` is not `None`. If `judge` is not `None`, all the specified conditions are met.
        if (slow_solution is not None) :
            func_7(solution, test_inputs, slow_solution)
        #State of the program after the if block has been executed: *`solution` is `solve`, `test_inputs` is `None`, `test_outputs` is not `None`, `judge` is `None`, `slow_solution` is `None`, and `solution` is not `None`. If `slow_solution` is not `None`, the program executes the specified conditions successfully.
    #State of the program after the if block has been executed: *`solution` is `solve`, `test_inputs` is `None`, `test_outputs` is not `None`, `judge` is `None`, `slow_solution` is `None`, and `solution` is not `None`. If `slow_solution` is not `None`, the program executes the specified conditions successfully.

#Function 6:
#State of the program right berfore the function call: **
def func_5(solution, inputs_answers):
    total, wrong = 0, 0
    for (args, test_ans) in inputs_answers:
        ans = solution(*args.copy())
        
        if ans != test_ans:
            func_8('WRONG! ans=%s, test_ans=%s, args=%s' % (ans, test_ans, args))
            wrong += 1
        else:
            func_8('GOOD')
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is increased by the number of elements in `inputs_answers`, `inputs_answers` is empty, `ans` and `test_ans` are the values returned by the function `solution` with the last set of copied arguments, `wrong` is the number of times `ans` was not equal to `test_ans` during the loop execution.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 7:
#State of the program right berfore the function call: **
def func_6(solution, inputs_gen, judge):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        if not judge(deepcopy(ans), *deepcopy(args)):
            func_8('WRONG! ans=%s, args=%s' % (ans, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is the total number of values generated by `inputs_gen`, `wrong` is the number of times the judge function returned false, `inputs_gen` generates at least 1 value, `ans` is the returned value from calling the function `solution` with arguments `args` after creating a deep copy of `args`. If the function judge returns false when comparing the deep copy of `ans` with the deep copy of `args`, then the function `func_8` is called with the string 'WRONG! ans=%s, args=%s'.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 8:
#State of the program right berfore the function call: **
def func_7(solution, inputs_gen, solution_slow):
    total, wrong = 0, 0
    for args in inputs_gen:
        ans = solution(*deepcopy(args))
        
        slow = solution_slow(*deepcopy(args))
        
        if ans != slow:
            func_8('WRONG! ans=%s, slow=%s, args=%s' % (ans, slow, args))
            wrong += 1
        
        total += 1
        
    #State of the program after the  for loop has been executed: `total` is the total number of values produced by `inputs_gen`, `wrong` is the number of times `ans` is not equal to `slow`, `args` is the last value produced by `inputs_gen`, `ans` is the result of calling the function `solution` with a deepcopy of the last `args`, `slow` holds the result of calling `solution_slow` with a deepcopy of the last `args`.
    func_8('ALL %d TESTS PASSED' % total if not wrong else 
    '%d out of %d tests are WRONG' % (wrong, total))

#Function 9:
#State of the program right berfore the function call: **
def func_8():
    """Prints the values to a stream, or to sys.stdout by default."""
    sep, file = kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        
        file.write(str(x))
        
        at_start = False
        
    #State of the program after the  for loop has been executed: `sep` and `file` retain their previous values, `at_start` is False, `args` has at least 1 element, `x` is the last element in `args`, `sep` is written to the `file`, and `file` now contains the string representation of the last element in `args`.
    file.write(kwargs.pop('end', '\n'))
    if kwargs.pop('flush', False) :
        file.flush()
    #State of the program after the if block has been executed: *`sep` and `file` retain their previous values, `at_start` is False, `args` has at least 1 element, `x` is the last element in `args`, `sep` is written to the `file`, `file` now contains the string representation of the last element in `args`, 'flush' key is popped from `kwargs` and its value is True.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
